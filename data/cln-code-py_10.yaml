- en: Clean Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 干净的架构
- en: In this final chapter, we focus on how everything fits together in the design
    of a whole system. This is a more theoretical chapter. Given the nature of the
    topic, it would be too complex to delve down into the more low-level details.
    Besides, the point is precisely to escape from those details, assume that all
    the principles explored in previous chapters are assimilated, and focus on the
    design of a system at scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将重点讨论如何在整个系统的设计中将所有内容整合在一起。这是一个更加理论化的章节。鉴于主题的性质，深入到更低级别的细节将会太复杂。此外，重点正是要摆脱这些细节，假设在前几章中探讨的所有原则都被吸收，并专注于大规模系统的设计。
- en: 'The main concerns and goals for this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要关注点和目标如下：
- en: Designing software systems that can be maintained in the long run
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可以长期维护的软件系统
- en: Working effectively on a software project by maintaining quality attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过保持质量属性有效地在软件项目上工作
- en: Studying how all concepts applied to code relate to systems in general
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究所有概念如何应用于代码与系统的关系
- en: From clean code to clean architecture
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从干净的代码到干净的架构
- en: This section is a discussion of how concepts that were emphasized in previous
    chapters reappear in a slightly different shape when we consider aspects of large
    systems. There is an interesting resemblance to how concepts that apply to more
    detailed design, as well as code, also apply to large systems and architectures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了在前几章中强调的概念在考虑大型系统方面以稍微不同的形式重新出现。有趣的是，适用于更详细设计以及代码的概念也适用于大型系统和架构。
- en: 'The concepts explored in previous chapters were related to single applications,
    generally, a project, that might be a single repository (or a few), for a source
    control version system (git). This is not to say that those design ideas are only
    applicable to code, or that they are of no use when thinking of an architecture,
    for two reasons: the code is the foundation of the architecture, and, if it''s
    not written carefully, the system will fail regardless of how well thought-out
    the architecture is.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章探讨的概念与单个应用程序相关，通常是一个项目，可能是一个或几个源代码控制版本系统（git）的单个存储库。这并不是说这些设计理念只适用于代码，或者在考虑架构时没有用处，有两个原因：代码是架构的基础，如果不小心编写，系统将会失败，无论架构设计得多么周密。
- en: Second, some principles that were revisited in previous chapters do not apply
    to code but are instead design ideas. The clearest example comes from design patterns.
    They are high-level ideas. With this, we can get a quick picture of how a component
    in our architecture might appear, without going into the details of the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，前几章重新讨论的一些原则不适用于代码，而是设计理念。最清晰的例子来自设计模式。它们是高层次的想法。有了这个，我们可以快速了解我们架构中的一个组件可能是什么样子，而不用深入代码的细节。
- en: But large enterprise systems typically consist of many of these applications,
    and now it's time to start thinking in terms of a larger design, in the form of
    a distributed system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是大型企业系统通常由许多这些应用程序组成，现在是时候开始考虑更大规模的设计，以分布式系统的形式。
- en: In the following sections, we discuss the main topics that have been discussed
    throughout the book, but now from the perspective of a system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论本书中一直讨论的主要主题，但现在是从系统的角度来看。
- en: Separation of concerns
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Inside an application, there are multiple components. Their code is divided
    into other subcomponents, such as modules or packages, and the modules into classes
    or functions, and the classes into methods. Throughout the book, the emphasis
    has been on keeping these components as small as possible, particularly in the
    case of functions—functions should do one thing, and be small.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中，有多个组件。它们的代码被划分为其他子组件，如模块或包，模块被划分为类或函数，类被划分为方法。在整本书中，重点一直是尽可能保持这些组件尽可能小，特别是在函数的情况下——函数应该只做一件事，并且要小。
- en: Several reasons were presented to justify this rationale. Small functions are
    easier to understand, follow, and debug. They are also easier to test. The smaller
    the pieces in our code, the easier it will be to write unit tests for it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了几个理由来证明这种推理。小函数更容易理解、遵循和调试。它们也更容易测试。我们代码中的部分越小，编写单元测试就越容易。
- en: For the components of each application, we wanted different traits, mainly high
    cohesion, and low coupling. By dividing components into smaller units, each one
    with a single and well-defined responsibility, we achieve a better structure where
    changes are easier to manage. In the face of new requirements, there will be a
    single rightful place to make the changes, and the rest of the code should probably
    be unaffected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个应用程序的组件，我们希望具有不同的特征，主要是高内聚和低耦合。通过将组件划分为更小的单元，每个单元都有一个单一且明确定义的责任，我们实现了更好的结构，使得变更更容易管理。面对新的需求，将会有一个正确的地方来进行更改，而其余的代码可能不受影响。
- en: When we talk about code, we say *component* to refer to one of these cohesive
    units (it might be a class, for example). When speaking in terms of an architecture,
    a component means anything in the system that can be treated as a working unit.
    The term component itself is quite vague, so there is no universally accepted
    definition in software architecture of what this means more concretely. The concept
    of a working unit is something that can vary from project to project. A component
    should be able to be released or deployed with its own cycles, independently from
    the rest of the parts of the system. And it is precisely that, one of the parts
    of a system, is namely the entire application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码时，我们说“组件”来指代这些内聚单元中的一个（例如可能是一个类）。在架构方面，组件意味着系统中可以作为一个工作单元对待的任何东西。组件本身这个术语相当模糊，因此在软件架构中没有普遍接受的更具体含义的定义。工作单元的概念是可以根据项目的不同而变化的。一个组件应该能够独立于系统的其余部分发布或部署。而它恰恰是系统的一部分，即整个应用程序。
- en: For Python projects, a component could be a package, but a service can also
    be a component. Notice how two different concepts, with different levels of granularity,
    can be considered under the same category. To give an example, the event systems
    we used in previous chapters could be considered a component. It's a working unit
    with a clearly defined purpose (to enrich events identified from logs), it can
    be deployed independently from the rest (whether as a Python package, or, if we
    expose its functionality, as a service), and it's a part of the entire system,
    but not the whole application itself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python项目，一个组件可以是一个包，但一个服务也可以是一个组件。请注意，两个不同的概念，具有不同级别的粒度，可以被视为同一类别。举个例子，我们在前几章中使用的事件系统可以被视为一个组件。它是一个具有明确定义目的（从日志中识别事件），可以独立部署（无论是作为Python包，还是如果我们公开其功能，作为一个服务），它是整个系统的一部分，但不是整个应用程序本身。
- en: On the examples of previous chapters we have seen an idiomatic code, and we
    have also highlighted the importance of good design for our code, with objects
    that have single well-defined responsibilities, being isolated, orthogonal, and
    easier to maintain. This very same criteria, which applies to detailed design
    (functions, classes, methods), also applies to the components of a software architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的例子中，我们已经看到了惯用代码，并且也强调了对我们的代码进行良好设计的重要性，具有单一明确定义的责任的对象，被隔离、正交并且更易于维护。这个非常相同的标准，适用于详细设计（函数、类、方法），也适用于软件架构的组件。
- en: It's probably undesirable for a large system to be just one component. A monolithic
    application will act as the single source of truth, responsible for everything
    in the system, and that will carry a lot of undesired consequences (harder to
    isolate and identify changes, to test effectively, and so on). In the same way,
    our code will be harder to maintain, if we are not careful and place everything
    in one place, the application will suffer from similar problems if its components
    aren't treated with the same level of attention.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型系统只是一个组件可能是不可取的。单体应用程序将作为唯一的真相来源，负责系统中的一切，并将带来许多不希望的后果（更难以隔离和识别变化，更难以有效测试等）。同样，如果我们不小心将所有东西放在一个地方，我们的代码也将更难以维护，如果其组件没有受到同等级别的关注，应用程序也将遭受类似的问题。
- en: The idea of creating cohesive components in a system can have more than one
    implementation, depending on the level of abstraction we require.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中创建具有内聚力的组件的想法可能有多种实现方式，这取决于我们需要的抽象级别。
- en: One option would be to identify common logic that is likely to be reused multiple
    times and place it in a Python package (we will discuss the details later in the
    chapter).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是识别可能多次重用的常见逻辑，并将其放在一个Python包中（我们将在本章后面讨论细节）。
- en: Another alternative would be to break the application into multiple smaller
    services, in a microservice architecture. The idea is to have components with
    a single and well-defined responsibility, and achieve the same functionality as
    a monolithic application by making those services cooperate, and exchange information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将应用程序分解为多个较小的服务，采用微服务架构。这个想法是通过使这些服务合作和交换信息，实现具有单一和明确定义责任的组件，并通过这些服务实现与单体应用程序相同的功能。
- en: Abstractions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: This is where encapsulation appears again. From our systems (as we do in relation
    to the code), we want to speak in terms of the domain problem, and leave the implementation
    details as hidden as possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是封装再次出现的地方。从我们的系统（就像我们在与代码相关的情况下一样），我们希望用领域问题的术语来交流，并尽可能隐藏实现细节。
- en: In the same way that the code has to be expressive (almost to the point of being
    self-documenting), and have the right abstractions that reveal the solution to
    the essential problem (minimizing accidental complexity), the architecture should
    tell us what the system is about. Details such as the solution used to persist
    data on disk, the web framework of choice, the libraries used to connect to external
    agents, and interaction between systems, are not relevant. What is relevant is
    what the system does. A concept such as a scream architecture (SCREAM) reflects
    this idea.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码必须表达（几乎到了自我记录的程度），并具有揭示基本问题解决方案的正确抽象（最小化偶发复杂性）一样，架构应该告诉我们系统的内容。诸如用于将数据持久化到磁盘的解决方案、首选的Web框架、用于连接到外部代理的库以及系统之间的交互等细节都不重要。重要的是系统的功能。像尖叫架构（SCREAM）这样的概念反映了这个想法。
- en: The **dependency inversion principle** (**DIP**), explained in [Chapter 4](532e5ff0-6f3d-44a5-b2a9-94c686bbd6ba.xhtml),
    *The SOLID Principles*, is of great help in this regard; we don't want to depend
    upon concrete implementations but rather abstractions. In the code, we place abstractions
    (or interfaces) on the boundaries, the dependencies, those parts of the application
    that we don't control and might change in the future. We do this because we want
    to invert the dependencies. Let them have to adapt to our code (by having to comply
    with an interface), and not the other way round.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖反转原则**（**DIP**），在[第4章](532e5ff0-6f3d-44a5-b2a9-94c686bbd6ba.xhtml)中解释的*
    SOLID原则*，在这方面非常有帮助；我们不想依赖具体的实现，而是依赖抽象。在代码中，我们将抽象（或接口）放在边界上，依赖关系上，即应用程序的那些我们无法控制并且可能在未来发生变化的部分。我们这样做是因为我们想要反转依赖。让它们适应我们的代码（通过必须遵守一个接口），而不是相反。'
- en: Creating abstractions and inverting dependencies are good practices, but they're
    not enough. We want our entire application to be independent and isolated from
    things that are out of our control. And this is even more than just abstracting
    with objects—we need layers of abstraction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抽象和反转依赖是良好的实践，但这还不够。我们希望整个应用程序独立并与我们无法控制的事物隔离。这甚至比仅仅使用对象进行抽象更重要——我们需要层层抽象。
- en: This is a subtle, but important difference with respect to the detailed design.
    In the DIP, it was recommended to create an interface, that could be implemented
    with the `abc` module from the standard library, for instance. Because Python
    works with duck typing, while using an abstract class might be helpful, it's not
    mandatory, as we can easily achieve the same effect with regular objects as long
    as they comply with the required interface. The dynamic typing nature of Python
    allowed us to have these alternatives. When thinking in terms of architecture,
    there is no such a thing. As it will become clearer with the example, we need
    to abstract dependencies entirely, and there is no feature of Python that can
    do that for us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这与详细设计有一个微妙但重要的区别。在DIP中，建议创建一个接口，可以使用标准库中的`abc`模块来实现。因为Python使用鸭子类型，虽然使用抽象类可能有所帮助，但并不是强制性的，因为只要它们符合所需的接口，我们可以很容易地用常规对象实现相同的效果。Python的动态类型特性使我们能够有这些替代方案。在架构方面思考时，没有这样的东西。正如例子中将变得更加清晰的那样，我们需要完全抽象依赖关系，没有Python的特性可以为我们做到这一点。
- en: Some might argue "Well, the ORM is a good abstraction for a database, isn't
    it?" It's not enough. The ORM itself is a dependency and, as such, out of our
    control. It would be even better to create an intermediate layer, an adapter,
    between the API of the ORM and our application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会争论“ORM是数据库的一个很好的抽象，不是吗？”这还不够。ORM本身是一个依赖项，因此超出了我们的控制。最好创建一个中间层，一个适配器，介于ORM的API和我们的应用程序之间。
- en: This means that we don't abstract the database just with an ORM; we use the
    abstraction layer we create on top of it, to define objects of our own that belong
    to our domain.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不仅仅用ORM来抽象数据库；我们使用我们在其上创建的抽象层，来定义属于我们领域的自己的对象。
- en: The application then imports this component, and uses the entities provided
    by this layer, but not the other way round. The abstraction layer should not know
    about the logic of our application; it's even truer that the database should know
    nothing about the application itself. If that were the case, the database would
    be coupled to our application. The goal is to invert the dependency—this layer
    provides an API, and every storage component that wants to connect has to conform
    to this API. This is the concept of a hexagonal architecture (HEX)*.*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用程序导入这个组件，并使用这个层提供的实体，但不是反过来。抽象层不应该了解我们应用程序的逻辑；更确切地说，数据库不应该了解应用程序本身。如果是这样的话，数据库将与我们的应用程序耦合。目标是反转依赖关系——这个层提供一个API，每个想要连接的存储组件都必须符合这个API。这就是六边形架构的概念（HEX）。
- en: Software components
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件组件
- en: We have a large system now, and we need to scale it. It also has to be maintainable.
    At this point, the concerns aren't only technical but also organizational. This
    means it's not just about managing software repositories; each repository will
    most likely belong to an application, and it will be maintained by a team who
    owns that part of the system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个庞大的系统，我们需要扩展它。它还必须是可维护的。此时的关注点不仅仅是技术上的，还包括组织上的。这意味着不仅仅是管理软件存储库；每个存储库很可能都属于一个应用程序，并且将由拥有该系统部分的团队维护。
- en: This demands we keep in mind how a large system is divided into different components.
    This can have many phases, from a very simple approach about, say, creating Python
    packages, to more complex scenarios in a microservice architecture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们牢记一个大型系统是如何划分为不同组件的。这可以有许多阶段，从一个非常简单的方法，比如创建Python包，到微服务架构中的更复杂场景。
- en: The situation could be even more complex when different languages are involved,
    but in this chapter, we will assume they are all Python projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到不同的语言时，情况可能会更加复杂，但在本章中，我们将假设它们都是Python项目。
- en: These components need to interact, as do the teams. The only way this can work
    at scale is if all the parts agree on an interface, a contract.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件需要互相交互，团队也是如此。这在规模上能够起作用的唯一方式是，所有部分都同意一个接口，一个契约。
- en: Packages
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: A Python package is a convenient way to distribute software and reuse code in
    a more general way. Packages that have been built can be published to an artifact
    repository (such as an internal PyPi server for the company), from where it will
    be downloaded by the rest of the applications that require it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python包是一种方便的方式来分发软件并以更一般的方式重用代码。已构建的包可以发布到存储库（例如公司的内部PyPi服务器），其他需要它的应用程序将从中下载。
- en: The motivation behind this approach has many elements to it—it's about reusing
    code at large, andalso achieving conceptual integrity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法背后的动机有许多元素——它是关于在大范围内重用代码，并实现概念上的一致性。
- en: Here, we discuss the basics of packaging a Python project that can be published
    in a repository. The default repository might be PyPi ([https://pypi.org/](https://pypi.org/)),
    but also internal; or custom setups will work with the same basics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了打包Python项目的基础知识，这些项目可以发布到存储库中。默认存储库可能是PyPi（[https://pypi.org/](https://pypi.org/)），但也可以是内部的；或者自定义设置将使用相同的基础知识。
- en: We are going to simulate that we have created a small library, and we will use
    that as an example to review the main points to take into consideration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟我们创建了一个小型图书馆，并将其用作示例来审查需要考虑的主要要点。
- en: Aside from all the open source libraries available, sometimes we might need
    some extra functionality—perhaps our application uses a particular idiom repeatedly
    or relies on a function or mechanism quite heavily and the team has devised a
    better function for these particular needs. In order to work more effectively,
    we can place this abstraction into a library, and encourage all team members to
    use the idioms as provided by it, because doing so will help avoid mistakes and
    reduce bugs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有可用的开源库之外，有时我们可能需要一些额外的功能——也许我们的应用程序重复使用特定习惯用语，或者严重依赖某个函数或机制，团队已经为这些特定需求设计了更好的函数。为了更有效地工作，我们可以将这种抽象放入一个库中，并鼓励所有团队成员使用它提供的习惯用语，因为这样做将有助于避免错误并减少错误。
- en: Potentially, there are infinite examples that could suit this scenario. Maybe
    the application needs to extract a lot of `.tag.gz` files (in a particular format)
    and has faced security problems in the past with malicious files that ended up
    with path traversal attacks. As a mitigation measure, the functionality for abstracting
    custom file formats securely was put in a library that wraps the default one and
    adds some extra checks. This sounds like a good idea.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在地，有无数的例子可以适用于这种情况。也许应用程序需要提取许多`.tag.gz`文件（以特定格式）并且在过去面临过恶意文件导致路径遍历攻击的安全问题。作为缓解措施，将安全地抽象自定义文件格式的功能放入一个库中，该库包装了默认库并添加了一些额外的检查。这听起来是个好主意。
- en: Or maybe there is a configuration file that has to be written, or parsed in
    a particular format, and this requires many steps to be followed in order; again,
    creating a helper function to wrap this, and using it in all the projects that
    need it, constitutes a good investment, not only because it saves a lot of code
    repetition, but also because it makes it harder to make mistakes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能有一个必须以特定格式编写或解析的配置文件，并且这需要按顺序遵循许多步骤；同样，创建一个帮助函数来包装这个，并在所有需要它的项目中使用它，不仅是一个很好的投资，因为它节省了大量的代码重复，而且因为它使错误更难发生。
- en: The gain is not only complying with the DRY principle (avoiding code duplication,
    encouraging reuse) but also that the abstracted functionality represents a single
    point of reference of how things should be done, hence contributing to the attainment
    of conceptual integrity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 收益不仅在于遵守DRY原则（避免代码重复，鼓励重用），而且抽象的功能代表了如何应该做事情的单一参考点，从而有助于实现概念完整性。
- en: 'In general, the minimum layout for a library would look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，库的最小布局如下：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The important part is the `setup.py` file, which contains the definition for
    the package. In this file, all the important definitions of the project (its requirements,
    dependencies, name, description, and so on) are specified.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的部分是`setup.py`文件，其中包含了项目的定义。在这个文件中，指定了项目的所有重要定义（其要求、依赖关系、名称、描述等）。
- en: The `apptool` directory under `src` is the name of the library we're working
    on. This is a typical Python project, so we place here all the files we need.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`目录下的`apptool`目录是我们正在开发的库的名称。这是一个典型的Python项目，所以我们在这里放置所有需要的文件。'
- en: 'An example of the `setup.py` file could be:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件的一个例子可能是：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This minimal example contains the key elements of the project. The `name` argument
    in the `setup` function is used to give the name that the package will have in
    the repository (under this name, we run the command to install it, in this case
    its `pip install apptool`*). *It's not strictly required that it matches the name
    of the project directory (`src/apptool`), but it's highly recommended, so its
    easier for users.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小的例子包含了项目的关键元素。`setup`函数中的`name`参数用于给包在存储库中的名称（在这个名称下，我们运行安装命令，这种情况下是`pip
    install apptool`*）。*它不是严格要求与项目目录的名称匹配（`src/apptool`），但强烈建议这样做，这样对用户来说更容易。
- en: In this case, since both names match, it's easier to see the relationship between
    what `pip install apptool` and then, in our code, run `from apptool import myutil`.
    But the latter corresponds to the name under the `src/` directory and the former
    to the one specified in the `setup.py` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于两个名称匹配，更容易看到`pip install apptool`和在我们的代码中运行`from apptool import myutil`之间的关系。但后者对应于`src/`目录下的名称，前者对应于`setup.py`文件中指定的名称。
- en: The version is important to keep different releases going on, and then the packages
    are specified. By using the `find_packages()` function, we automatically discover
    everything that's a package, in this case under the `src/` directory. Searching
    under this directory helps to avoid mixing up files beyond the scope of the project
    and, for instance, accidentally releasing tests or a broken structure of the project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 版本对于保持不同的发布很重要，然后指定包。通过使用`find_packages()`函数，我们自动发现所有的包，这种情况下是在`src/`目录下。在这个目录下搜索有助于避免混淆项目范围之外的文件，例如意外发布测试或项目的破损结构。
- en: 'A package is built by running the following commands, assuming its run inside
    a virtual environment with the dependencies installed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建包，假设其在已安装依赖项的虚拟环境中运行：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will place the artifacts in the `dist/` directory, from where they can
    be later published either to PyPi or to the internal package repository of the
    company.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把构件放在`dist/`目录中，从那里它们可以稍后发布到PyPi或公司的内部包存储库。
- en: 'The key points in packaging a Python project are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打包Python项目的关键点是：
- en: Test and verify that the installation is platform-independent and that it doesn't
    rely on any local setup (this can be achieved by placing the source files under
    an `src/` directory)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证安装是否与平台无关，并且不依赖于任何本地设置（可以通过将源文件放置在`src/`目录下来实现）
- en: Make sure that unit tests aren't shipped as part of the package being built
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保单元测试不作为构建的一部分进行发布
- en: Separate dependencies—what the project strictly needs to run is not the same
    as what developers require
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离依赖——项目严格需要运行的内容与开发人员需要的内容不同
- en: It's a good idea to create entry points for the commands that are going to be
    required the most
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为即将需要的命令创建入口点是个好主意
- en: The `setup.py` file supports multiple other parameters and configurations and
    can be effected in a much more complicated manner. If our package requires several
    operating system libraries to be installed, it's a good idea to write some logic
    in the `setup.py` file to compile and build the extensions that are required.
    This way, if something is amiss, it will fail early on in the installation process,
    and if the package provides a helpful error message, the user will be able to
    fix the dependencies more quickly and continue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件支持多个其他参数和配置，并且可以以更复杂的方式生效。如果我们的包需要安装多个操作系统库，最好在`setup.py`文件中编写一些逻辑来编译和构建所需的扩展。这样，如果出现问题，它将在安装过程的早期失败，如果包提供了有用的错误消息，用户将能够更快地修复依赖项并继续。'
- en: Installing such dependencies represents another difficult step in making the
    application ubiquitous, and easy to run by any developer regardless of their platform
    of choice. The best way to surmount this obstacle is to abstract the platform
    by creating a Docker image, as we will discuss in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些依赖项代表着另一个困难的步骤，使得应用程序无处不在，并且可以在任何开发人员选择的平台上轻松运行。克服这一障碍的最佳方法是通过创建一个Docker镜像来抽象平台，这将在下一节中讨论。
- en: Containers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: This chapter is dedicated to architecture, so the term container refers to something
    completely different from a Python container (an object with a `__contains__` method),
    explored in [Chapter 2](c6a1dd9e-e567-4254-b5cf-1033b8b89c3d.xhtml), *Pythonic
    Code*. A container is a process that runs in the operating system under a group
    with certain restrictions and isolation considerations. Concretely we refer to
    Docker containers, which allow managing applications (services or processes) as
    independent components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论架构，因此容器这个术语与Python容器（具有`__contains__`方法的对象）完全不同，这在第2章“Pythonic Code”中有所探讨。容器是在操作系统中以一组特定限制和隔离考虑运行的进程。具体来说，我们指的是Docker容器，它允许将应用程序（服务或进程）作为独立组件进行管理。
- en: Containers represent another way of delivering software. Creating Python packages
    taking into account the considerations in the previous section is more suitable
    for libraries, or frameworks, where the goal is to reuse code and take advantage
    of using a single place where specific logic is gathered.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 容器代表了另一种交付软件的方式。根据上一节中的考虑创建Python包更适合于库或框架，其中的目标是重用代码并利用一个特定逻辑被收集到一个地方。
- en: In the case of containers, the objective will not be creating libraries but
    applications (most of the time). However, an application or platform does not
    necessarily mean an entire service. The idea of building containers is to create
    small components that represent a service with a small and clear purpose.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的情况下，目标不是创建库，而是应用程序（大部分情况下）。然而，应用程序或平台并不一定意味着整个服务。构建容器的想法是创建代表具有小而清晰目的的服务的小组件。
- en: In this section, we will mention Docker when we talk about containers, and we
    will explore the basics of how to create Docker images and containers for Python
    projects. Keep in mind that this is not the only technology for launching applications
    into containers, and also that it's completely independent of Python.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，当我们谈论容器时，我们将提到Docker，并且将探讨如何为Python项目创建Docker镜像和容器的基础知识。请记住，这不是将应用程序部署到容器中的唯一技术，而且它完全独立于Python。
- en: A Docker container needs an image to run on, and this image is created from
    other base images. But the images we create can themselves serve as base images
    for other containers. We will want to do that in cases where there is a common
    base in our application that can be shared across many containers. A potential
    use would be creating a base image that installs a package (or many) in the way
    we described in the previous section, and also all of its dependencies, including
    those at the operating system level. As discussed in [Chapter 9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common
    Design Patterns*, a package we create can depend not only on other Python libraries,
    but also on a particular platform (a specific operating system), and particular
    libraries preinstalled in that operating system, without which the package will
    simply not install and will fail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器需要一个镜像来运行，这个镜像是从其他基础镜像创建的。但是我们创建的镜像本身可以作为其他容器的基础镜像。在我们的应用程序中存在一个通用基础的情况下，我们将希望这样做，这个通用基础可以在许多容器之间共享。一个潜在的用途是创建一个基础镜像，以我们在上一节中描述的方式安装一个包（或多个包），以及所有的依赖项，包括操作系统级别的依赖项。正如在第9章“Common
    Design Patterns”中讨论的那样，我们创建的一个包不仅可以依赖于其他Python库，还可以依赖于特定平台（特定操作系统）和在该操作系统中预安装的特定库，如果没有这些库，包将无法安装并且会失败。
- en: Containers are a great portability tool for this. They can help us ensure that
    our application will have a canonical way of running, and it will also ease the
    development process a lot (reproducing scenarios across environments, replicating
    tests, on-boarding new team members, and so on).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 容器对此是一个很好的可移植性工具。它们可以帮助我们确保我们的应用程序将有一个规范的运行方式，并且也会极大地简化开发过程（在不同环境中复制场景，复制测试，新团队成员入职等）。
- en: As packages are the way we reuse code and unify criteria, containers represent
    the way we create the different services of the application. They meet the criteria
    behind the principle of **separation of concerns** (**SoC**) of the architecture.
    Each service is another kind of component that will encapsulate a set of functionalities
    independently of the rest of the application. These containers ought to be designed
    in such a way that they favor maintainability—if the responsibilities are clearly
    divided, a change in a service should not impact any other part of the application
    whatsoever.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包是我们重用代码和统一标准的方式，容器代表了我们创建应用程序的不同服务的方式。它们符合架构的**关注点分离**（**SoC**）原则背后的标准。每个服务都是另一种独立封装一组功能的组件，与应用程序的其余部分无关。这些容器应该被设计成有利于可维护性——如果责任被清晰划分，对服务的更改不应该对应用程序的任何其他部分产生影响。
- en: We cover the basics of how to create a Docker container from a Python project
    in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍如何从Python项目创建Docker容器的基础知识。
- en: Use case
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: As an example of how we might organize the components of our application, and
    how the previous concepts might work in practice, we present the following simple
    example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们如何组织应用程序组件以及之前的概念如何在实践中工作的示例，我们提供以下简单示例。
- en: The use case is that there is an application for delivering food, and this application
    has a specific service for tracking the status of each delivery at its different
    stages. We are going to focus only on this particular service, regardless of how
    the rest of the application might appear. The service has to be really simple—a
    REST API that, when asked about the status of a particular order, will return
    a JSON response with a descriptive message.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是有一个用于交付食物的应用程序，这个应用程序有一个特定的服务，用于跟踪每个交付在不同阶段的状态。我们将只关注这个特定的服务，而不管应用程序的其余部分是什么样子。这个服务必须非常简单——一个REST
    API，当询问特定订单的状态时，将返回一个带有描述性消息的JSON响应。
- en: We are going to assume that the information about each particular order is stored
    in a database, but this detail should not matter at all.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个特定订单的信息都存储在数据库中，但这个细节根本不重要。
- en: 'Our service has two main concerns for now: getting the information about a
    particular order (from wherever this might be stored), and presenting this information
    in a useful way to the clients (in this case, delivering the results in JSON format,
    exposed as a web service).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务目前有两个主要关注点：获取特定订单的信息（无论这些信息存储在何处），并以对客户有用的方式呈现这些信息（在这种情况下，以JSON格式呈现结果，作为Web服务公开）。
- en: 'As the application has to be maintainable and extensible, we want to keep these
    two concerns as hidden as possible and focus on the main logic. Therefore, these
    two details are abstracted and encapsulated into Python packages that the main
    application with the core logic will use, as shown in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序必须是可维护和可扩展的，我们希望尽可能隐藏这两个关注点，并专注于主要逻辑。因此，这两个细节被抽象和封装到Python包中，主应用程序与核心逻辑将使用这些包，如下图所示：
- en: '![](assets/5c01ae94-c035-452c-8540-6c5ade590286.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c01ae94-c035-452c-8540-6c5ade590286.png)'
- en: In the following sections, we briefly demonstrate how the code might appear,
    in terms of the packages mainly, and how to create services from these, in order
    to finally see what conclusions we can infer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将简要演示代码可能的外观，主要是包方面，以及如何从中创建服务，最终看看我们能得出什么结论。
- en: The code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: The idea of creating Python packages in this example is to illustrate how abstracted
    and isolated components can be made, in order to work effectively. In reality,
    there is no actual need for these to be Python packages; we could just create
    the right abstractions as part of the "delivery service" project, and, while the
    correct isolation is preserved, it will work without any issues.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中创建Python包的想法是为了说明如何有效地制作抽象和隔离的组件。实际上，这些不需要是Python包；我们可以将正确的抽象作为“交付服务”项目的一部分创建，而且在保持正确的隔离的同时，它将可以正常工作。
- en: Creating packages makes more sense when there is logic that is going to be repeated
    and is expected to be used across many other applications (that will import from
    those packages) because we want to favor code reuse. In this particular case,
    there are no such requirements, so it might be beyond the scope of the design,
    but such distinction still makes more clear the idea of a "pluggable architecture"
    or component, something that is really a wrapper abstracting technical details
    we don't really want to deal with, much less depend upon.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包在逻辑需要重复使用并且预计会被许多其他应用程序使用时更有意义（这些应用程序将从这些包中导入），因为我们希望倾向于代码重用。在这种特殊情况下，没有这样的要求，所以这可能超出了设计的范围，但这种区别仍然更清晰地表明了“可插拔架构”或组件的概念，这是一个真正的封装，抽象了我们不想处理的技术细节，更不要依赖于它。
- en: The `storage` package is in charge of retrieving the data that is required,
    and presenting this to the next layer (the delivery service) in a convenient format,
    something that is suitable for the business rules. The main application should
    now know where this data came from, what its format is, and so on. This is the
    entire reason why we have such an abstraction in between so the application doesn't
    use a row or an ORM entity directly, but rather something workable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`包负责检索所需的数据，并以方便的格式呈现给下一层（交付服务），这对业务规则是合适的。主应用现在不应该知道这些数据来自哪里，它的格式是什么，等等。这就是为什么我们在应用程序之间有这样一个抽象的原因，这样应用程序就不会直接使用行或ORM实体，而是使用一些可操作的东西。'
- en: Domain models
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型
- en: The following definitions apply to classes for business rules. Notice that they
    are meant to be pure business objects, not bound to anything in particular. They
    aren't models of an ORM, or objects of an external framework, and so on. The application
    should work with these objects (or objects with the same criteria).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义适用于业务规则的类。请注意，它们旨在成为纯业务对象，不与任何特定内容绑定。它们不是ORM的模型，也不是外部框架的对象等等。应用程序应该使用这些对象（或具有相同标准的对象）。
- en: 'In each case, the dosctring documents the purpose of each class, according
    to the business rule:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，文档字符串都记录了每个类的目的，根据业务规则：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From this code, we can already get an idea of what the application will look
    like—we want to have a `DeliveryOrder` object, which will have its own status
    (as an internal collaborator), and once we have that, we will call its `message()` method
    to return this information to the user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们已经可以想象应用程序的样子了——我们想要有一个`DeliveryOrder`对象，它将有自己的状态（作为内部协作者），一旦我们有了这个对象，我们将调用它的`message()`方法将这些信息返回给用户。
- en: Calling from the application
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序调用
- en: 'Here is how these objects are going to be used in the application. Notice how
    this depends on the previous packages (`web` and `storage`), but not the other
    way round:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象将如何在应用程序中使用。请注意，这取决于先前的包（`web`和`storage`），但反之则不然：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous section, the `domain` objects were shown and here the code for
    the application is displayed. Aren't we missing something? Sure, but is it something
    we really need to know now? Not necessarily.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，展示了`domain`对象，这里显示了应用程序的代码。我们是不是漏掉了什么？当然，但这是我们现在真的需要知道的吗？不一定。
- en: The code inside the `storage` and `web` packages was deliberately left out (although
    the reader is more than encouraged to look at it—the repository for the book contains
    the full example). Also, and this was done on purpose, the names of such packages
    were chosen so as not to reveal any technical detail—`storage` and `web`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`和`web`包中的代码故意被省略了（尽管鼓励读者查看——本书的存储库包含完整的示例）。同样，这是故意的，这些包的名称被选择为不透露任何技术细节——`storage`和`web`。'
- en: Look again at the code in the previous listing. Can you tell which frameworks
    are being used? Does it say whether the data comes from a text file, a database
    (if so, of what type? SQL? NoSQL?), or another service (the web, for instance)?
    Assume that it comes from a relational database. Is there any clue to how this
    information is retrieved (manual SQL queries? Through an ORM?)?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看一下前面清单中的代码。你能告诉使用了哪些框架吗？它是否说明了数据来自文本文件、数据库（如果是的话，是什么类型的？SQL？NoSQL？）或另一个服务（例如网络）？假设它来自关系数据库。有没有线索表明这些信息是如何检索的（手动SQL查询？通过ORM？）？
- en: What about the web? Can we guess what frameworks are used?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 网络呢？我们能猜出使用了哪些框架吗？
- en: The fact that we cannot answer any of those questions is probably a good sign.
    Those are details, and details ought to be encapsulated. We can't answer those
    questions unless we take a look at what's inside those packages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法回答这些问题可能是一个好迹象。这些都是细节，细节应该被封装。除非我们查看这些包中的内容，否则我们无法回答这些问题。
- en: There is another way of answering the previous questions, and it comes in the
    form of a question itself: why do we need to know that? Looking at the code, we
    can see that there is a `DeliveryOrder`, created with an identifier of a delivery,
    and it that has a `get()` method, which returns an object representing the status
    of the delivery. If all of this information is correct, that's all we should care
    about. What difference does it make how is it done?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回答上述问题的另一种方法是以问题的形式提出：我们为什么需要知道这个？从代码中，我们可以看到有一个`DeliveryOrder`，使用交付的标识符创建，它有一个`get()`方法，返回表示交付状态的对象。如果所有这些信息都是正确的，那就是我们应该关心的。它是如何完成的有什么区别呢？
- en: The abstractions we created make our code declarative. In declarative programming,
    we declare the problem we want to solve, not how we want to solve it. It's the
    opposite of imperative, in which we have to make all the steps required explicit
    in order to get something (for instance connect to the database, run this query,
    parse the result, load it into this object, and so on). In this case, we are declaring
    that we just want to know the status of the delivery given by some identifier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的抽象使我们的代码具有声明性。在声明性编程中，我们声明要解决的问题，而不是如何解决它。这与命令式相反，在命令式中，我们必须明确地执行所有必需的步骤才能获得某些东西（例如连接到数据库，运行此查询，解析结果，将其加载到此对象中等等）。在这种情况下，我们声明只想知道给定某个标识符的交付状态。
- en: These packages are in charge of dealing with the details and presenting what
    the application needs in a convenient format, namely objects of the kind presented
    in the previous section. We just have to know that the `storage` package contains
    an object that, given an ID for a delivery and a storage client (this dependency
    is being injected into this example for simplicity, but other alternatives are
    also possible), it will retrieve `DeliveryOrder` which we can then ask to compose
    the message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包负责处理细节，并以方便的格式呈现应用程序需要的内容，即在上一节中呈现的对象。我们只需要知道`storage`包含一个对象，给定交付ID和存储客户端（这个依赖项被注入到这个示例中以简化，但也有其他可能的选择），它将检索`DeliveryOrder`，然后我们可以要求它组成消息。
- en: This architecture provides convenience and makes it easier to adapt to changes,
    as it protects the kernel of the business logic from the external factors that
    can change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构提供了便利，并使其更容易适应变化，因为它保护了业务逻辑的核心，使其不受可能发生变化的外部因素的影响。
- en: 'Imagine we want to change how the information is retrieved. How hard would
    that be? The application relies on an API, like the following one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要改变信息的检索方式。这有多难？应用程序依赖于一个API，就像下面这样：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So it would be about just changing how the `get()` method works, adapting it
    to the new implementation detail. All we need is for this new object to return `DeliveryOrder`
    on its `get()` method and that would be all. We can change the query, the ORM,
    the database, and so on, and, in all cases, the code in the application does not
    need to change!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需更改`get()`方法的工作方式，将其适应新的实现细节。我们只需要让这个新对象在其`get()`方法上返回`DeliveryOrder`，就可以了。我们可以更改查询、ORM、数据库等等，在所有情况下，应用程序中的代码都不需要更改！
- en: Adapters
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: Still, without looking at the code in the packages, we can conclude that they
    work as interfaces for the technical details of the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有查看包中的代码，我们可以得出结论，它们作为应用程序的技术细节的接口。
- en: In fact, since we are seeing the application from a high-level perspective,
    without needing to look at the code, we can imagine that inside those packages
    there must be an implementation of the adapter design pattern (introduced in [Chapter
    9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common Design Patterns*). One
    or more of these objects is adapting an external implementation to the API defined
    by the application. This way, dependencies that want to work with the application
    must conform to the API, and an adapter will have to be made.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于我们是从高层次的角度来看待应用程序，而不需要查看代码，我们可以想象这些包中必须有适配器设计模式的实现（在[第9章](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml)中介绍，*常见设计模式*）。其中一个或多个对象正在将外部实现适配到应用程序定义的API。这样，想要与应用程序一起工作的依赖项必须符合API，并且必须制作一个适配器。
- en: There is one clue pertaining to this adapter in the code for the application
    though. Notice how the view is constructed. It inherits from a class named `View`
    that comes from our `web` package. We can deduce that this `View` is, in turn,
    a class derived from one of the web frameworks that might be being used, creating
    an adapter by inheritance. The important thing to note is that once this is done,
    the only object that matters is our `View` class, because, in a way, we are creating
    our own framework, which is based on adapting an existing one (but again changing
    the framework will mean just changing the adapters, not the entire application).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在应用程序的代码中有一个关于适配器的线索。注意视图是如何构建的。它继承自一个名为`View`的类，该类来自我们的`web`包。我们可以推断，这个`View`又是从可能正在使用的一个web框架派生出来的类，通过继承创建了一个适配器。需要注意的是，一旦这样做了，唯一重要的对象就是我们的`View`类，因为在某种程度上，我们正在创建我们自己的框架，这是基于对现有框架进行适配（但再次更改框架只意味着更改适配器，而不是整个应用程序）。
- en: The services
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: To create the service, we are going to launch the Python application inside
    a Docker container. Starting from a base image, the container will have to install
    the dependencies for the application to run, which also has dependencies at the
    operating system level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建服务，我们将在Docker容器中启动Python应用程序。从基础镜像开始，容器将安装应用程序运行所需的依赖项，这些依赖项也存在于操作系统级别。
- en: This is actually a choice because it depends on how the dependencies are used.
    If a package we use requires other libraries on the operating system to compile
    at installation time, we can avoid this simply by building a wheel for our platform
    of the library and installing this directly. If the libraries are needed at runtime,
    then there is no choice but to make them part of the image of the container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个选择，因为它取决于依赖项的使用方式。如果我们使用的一个软件包在安装时需要在操作系统上编译其他库，我们可以通过为我们的平台构建该库的wheel并直接安装它来避免这一点。如果这些库在运行时需要，那么除了将它们作为容器镜像的一部分之外别无选择。
- en: 'Now, we discuss one of the many ways of preparing a Python application to be
    run inside a Docker container. This is one of numerous alternatives for packaging
    a Python project into a container. First, we take a look at what the structure
    of the directories looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们讨论准备Python应用程序在Docker容器中运行的众多方法之一。这是将Python项目打包到容器中的众多替代方案之一。首先，让我们看一下目录结构是什么样子的：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `libs` directory can be ignored since it's just the place where the dependencies
    are placed (it's displayed here to keep them in mind when they are referenced
    in the `setup.py` file, but they could be placed in a different repository and
    installed remotely via `pip`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`libs`目录可以忽略，因为它只是放置依赖项的地方（这里显示出来是为了在`setup.py`文件中引用它们时记住它们，但它们可以放在不同的存储库中，并通过`pip`远程安装）。'
- en: We have `Makefile` with some helper commands, then the `setup.py` file, and
    the application itself inside the `statusweb` directory. A common difference between
    packaging applications and libraries is that while the latter specify their dependencies
    in the `setup.py` file, the former have a `requirements.txt` file from where dependencies
    are installed via `pip install -r requirements.txt`. Normally, we would do this
    in the `Dockerfile`, but in order to keep things simpler in this particular example,
    we will assume that taking the dependencies from the `setup.py` file is enough.
    This is because, besides this consideration, there are a lot more considerations
    to be taken into account when dealing with dependencies, such as freezing the
    version of the packages, tracking indirect dependencies, using extra tools such
    as `pipenv`, and more topics that are beyond the scope of the chapter. In addition,
    it is also customary to make the `setup.py` file read from `requirements.txt`
    for consistency.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Makefile`，其中包含一些辅助命令，然后是`setup.py`文件，以及`statusweb`目录中的应用程序本身。打包应用程序和库之间的一个常见区别是，后者在`setup.py`文件中指定它们的依赖关系，而前者有一个`requirements.txt`文件，依赖关系通过`pip
    install -r requirements.txt`安装。通常情况下，我们会在`Dockerfile`中执行这些操作，但是为了在这个特定的例子中保持简单，我们将假设从`setup.py`文件中获取依赖关系就足够了。这是因为除了这一考虑因素之外，在处理依赖关系时还有很多其他考虑因素，比如冻结软件包的版本、跟踪间接依赖关系、使用额外的工具如`pipenv`，以及本章节范围之外的更多主题。此外，为了保持一致，通常也习惯让`setup.py`文件从`requirements.txt`中读取。
- en: 'Now we have the content of the `setup.py` file, which states some details of
    the application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`setup.py`文件的内容，其中说明了应用程序的一些细节：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing we notice is that the application declares its dependencies,
    which are the packages we created and placed under `libs/`, namely `web` and `storage`,
    abstracting and adapting to some external components. These packages, in turn,
    will have dependencies, so we will have to make sure the container installs all
    the required libraries when the image is being created so that they can install
    successfully, and then this package afterward.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是应用程序声明了它的依赖项，这些依赖项是我们在`libs/`下创建并放置的包，即`web`和`storage`，对一些外部组件进行了抽象和适应。这些包反过来又会有依赖项，因此我们必须确保容器在创建镜像时安装所有所需的库，以便它们可以成功安装，然后再安装这个包。
- en: 'The second thing we notice is the definition of the `entry_points` keyword
    argument passed to the `setup` function. This is not strictly mandatory, but it''s
    a good idea to create an entry point. When the package is installed in a virtual
    environment, it shares this directory along with all its dependencies. A virtual
    environment is a structure of directories with the dependencies of a given project.
    It has many subdirectories, but the most important ones are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第二件事是传递给`setup`函数的`entry_points`关键字参数的定义。这并不是严格必需的，但创建一个入口点是个好主意。当包安装在虚拟环境中时，它与所有的依赖项共享这个目录。虚拟环境是一个具有给定项目的依赖项的目录结构。它有许多子目录，但最重要的是：
- en: '`<virtual-env-root>/lib/<python-version>/site-packages`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<virtual-env-root>/lib/<python-version>/site-packages`'
- en: '`<virtual-env-root>/bin`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<virtual-env-root>/bin`'
- en: The first one contains all the libraries installed in that virtual environment.
    If we were to create a virtual environment with this project, that directory would
    contain the `web`, and `storage` packages, along with all its dependencies, plus
    some extra basic ones and the current project itself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含了在该虚拟环境中安装的所有库。如果我们要为这个项目创建一个虚拟环境，那么该目录将包含`web`和`storage`包，以及它们的所有依赖项，再加上一些额外的基本依赖项和当前项目本身。
- en: The second, `/bin/`, contains the binary files and commands available when that
    virtual environment is active. By default, it would just be the version of Python,
    `pip`, and some other basic commands. When we create an entry point, a binary
    with that declared name is placed there, and, as a result, we have that command
    available to run when the environment is active. When this command is called,
    it will run the function that is specified with all the context of the virtual
    environment. That means it is a binary we can call directly without having to
    worry about whether the virtual environment is active, or whether the dependencies
    are installed in the path that is currently running.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`/bin/`包含了当虚拟环境处于活动状态时可用的二进制文件和命令。默认情况下，它只是Python的版本、`pip`和一些其他基本命令。当我们创建一个入口点时，一个具有声明名称的二进制文件将被放置在那里，结果就是当环境处于活动状态时，我们可以运行该命令。当调用此命令时，它将运行指定的函数，并且具有虚拟环境的所有上下文。这意味着它是一个可以直接调用的二进制文件，而无需担心虚拟环境是否处于活动状态，或者当前运行的路径中是否安装了依赖项。
- en: 'The definition is the following one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 定义如下：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The left-hand side of the equals sign declares the name of the entry point.
    In this case, we will have a command named `status-service` available. The right-hand
    side declares how that command should be run. It requires the package where the
    function is defined, followed by the function name after `:`. In this case, it
    will run the `main` function declared in `statusweb/service.py`*.*
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 等号左边声明了入口点的名称。在这种情况下，我们将有一个名为`status-service`的命令可用。右边声明了该命令应该如何运行。它需要包含函数定义的包，后面跟着`:`和函数名。在这种情况下，它将运行`statusweb/service.py`中声明的`main`函数。
- en: 'This is followed by a definition of the Dockerfile:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Dockerfile的定义：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The image is built based on a lightweight Python image, and then the operating
    system dependencies are installed so that our libraries can be installed. Following
    the previous consideration, this `Dockerfile` simply copies the libraries, but
    this might as well be installed from a `requirements.txt` file accordingly. After
    all the `pip install` commands are ready, it copies the application in the working
    directory, and the entry point from Docker (the `CMD` command, not to be confused
    with the Python one) calls the entry point of the package where we placed the
    function that launches the process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像是基于轻量级的Python镜像构建的，然后安装操作系统依赖项，以便我们可以安装我们的库。根据之前的考虑，这个`Dockerfile`只是简单地复制了库，但这也可以根据`requirements.txt`文件进行安装。在所有`pip
    install`命令准备好之后，它将应用程序复制到工作目录中，并且Docker的入口点（`CMD`命令，不要与Python混淆）调用了我们放置了启动进程的函数的包的入口点。
- en: All the configuration is passed by environment variables, so the code for our
    service will have to comply with this norm.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的配置都是通过环境变量传递的，因此我们的服务代码必须符合这个规范。
- en: In a more complex scenario involving more services and dependencies, we will
    not just run the image of the created container, but instead declare a `docker-compose.yml`
    file with the definitions of all the services, base images, and how they are linked
    and interconnected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及更多服务和依赖项的更复杂场景中，我们不仅仅会运行创建的容器的镜像，而是会声明一个`docker-compose.yml`文件，其中包含所有服务、基础镜像的定义，以及它们是如何链接和相互连接的。
- en: 'Now that we have the container running, we can launch it and run a small test
    on it to get an idea of how it works:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了容器，我们可以启动它并对其进行小型测试，以了解其工作原理：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Analysis
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: There are many conclusions to be drawn from the previous implementation. While
    it might seem like a good approach, there are cons that come with the benefits;
    after all, no architecture or implementation is perfect. This means that a solution
    such as this one cannot be good for all cases, so it will pretty much depend on
    the circumstances of the project, the team, the organization, and more.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的实现中可以得出许多结论。虽然这可能看起来是一个不错的方法，但好处也伴随着一些缺点；毕竟，没有架构或实现是完美的。这意味着这样的解决方案并不适用于所有情况，因此它在很大程度上取决于项目、团队、组织等的情况。
- en: While it's true that the main idea of the solution is to abstract details as
    much as possible, as we shall see some parts cannot be fully abstracted away,
    and also the contracts between the layers imply an abstraction leak.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案的主要思想是尽可能抽象细节，但正如我们将看到的，有些部分无法完全抽象化，而且层之间的合同暗示了一个抽象泄漏。
- en: The dependency flow
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖流
- en: Notice that dependencies flow in only one direction, as they move closer to
    the kernel, where the business rules lie. This can be traced by looking at the `import`statements.
    The application imports everything it needs from storage, for example, and in
    no part is this inverted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，依赖关系只朝一个方向流动，因为它们越接近内核，业务规则就越明显。这可以通过查看`import`语句来追踪。例如，应用程序从存储中导入它所需的一切，在任何地方都没有倒置。
- en: Breaking this rule would create coupling. The way the code is arranged now means
    that there is a weak dependency between the application and storage. The API is
    such that we need an object with a `get()` method, and any storage that wants
    to connect to the application needs to implement this object according to this
    specification. The dependencies are therefore inverted—it's up to every storage
    to implement this interface, in order to create an object according to what the
    application is expecting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这个规则会导致耦合。现在代码的排列方式意味着应用程序和存储之间存在着弱依赖关系。API的设计要求我们需要一个具有`get()`方法的对象，任何想要连接到应用程序的存储都需要根据这个规范实现这个对象。因此，依赖关系被倒置了——每个存储都需要实现这个接口，以便根据应用程序的期望创建一个对象。
- en: Limitations
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: Not everything can be abstracted away. In some cases, it's simply not possible,
    and in others, it might not be convenient. Let's start with the convenience aspect.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有东西都可以被抽象化。在某些情况下，这根本不可能，而在其他情况下，可能也不方便。让我们从方便的角度开始。
- en: In this example, there is an adapter of the web framework of choice to a clean
    API to be presented to the application. In a more complex scenario, such a change
    might not be possible. Even with this abstraction, parts of the library were still
    visible to the application. Adapting an entire framework might not only be hard
    but also not possible in some cases. It's not entirely a problem to be completely
    isolated from the web framework because, sooner or later, we will need some of
    its features or technical details.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个将Web框架适配到一个干净的API以供应用程序使用的适配器。在更复杂的情况下，这样的变化可能是不可能的。即使有这种抽象，库的部分仍然对应用程序可见。适应整个框架可能不仅困难，而且在某些情况下也是不可能的。完全与Web框架隔离并不完全是一个问题，因为迟早我们会需要一些它的功能或技术细节。
- en: The important takeaway here is not the adapter, but the idea of hiding technical
    details as much as possible. That means, that the best thing that was displayed
    on the listing for the code of the application was not the fact that there was
    an adapter between our version of the web framework and the actual one, but instead
    the fact that the latter was not mentioned by name in any part of the visible
    code. The service was made clear that `web` was just a dependency (a detail being
    imported), and revealed the intention behind what it was supposed to do. The goal
    is to reveal the intention (as in the code) and to defer details as much as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要观点不是适配器，而是尽可能隐藏技术细节的想法。这意味着在应用程序代码的列表中显示的最好的东西不是我们的Web框架版本和实际框架之间有一个适配器，而是后者在可见代码的任何部分都没有被提及。服务清楚地表明了`web`只是一个依赖项（一个被导入的细节），并揭示了它应该做什么的意图。目标是揭示意图（如代码中所示）并尽可能推迟细节。
- en: As to what things cannot be isolated, those are the elements that are closest
    to the code. In this case, the web application was using the objects operating
    within them in an asynchronous fashion. That is a hard constraint we cannot circumvent.
    It's true that whatever is inside the `storage` package can be changed, refactored,
    and modified, but whatever these modifications might be, it still needs to preserve
    the interface, and that includes the asynchronous interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 至于不能被隔离的东西，那些最接近代码的元素。在这种情况下，Web应用程序以异步方式使用其中的对象。这是一个我们无法规避的硬性约束。在`storage`包中的任何东西都可以更改、重构和修改，但无论这些修改是什么，它仍然需要保留接口，包括异步接口。
- en: Testability
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可测试性
- en: Again, much like with the code, the architecture can benefit from separating
    pieces into smaller components. The fact that dependencies are now isolated and
    controlled by separate components leaves us with a cleaner design for the main
    application, and now it's easier to ignore the boundaries to focus on testing
    the core of the application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码类似，架构也可以从将部分分离为更小的组件中受益。现在依赖关系被隔离并由独立的组件控制，这为主应用程序提供了更清晰的设计，现在更容易忽略边界，专注于测试应用程序的核心。
- en: We could create a patch for the dependencies, and write unit tests that are
    simpler (they won't need a database), or to launch an entire web service, for
    instance. Working with pure `domain` objects means it will be easier to understand
    the code and the unit tests. Even the adapters will not need that much testing
    because their logic should be very simple.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为依赖关系创建一个补丁，并编写更简单的单元测试（它们不需要数据库），或者启动整个网络服务，例如。使用纯粹的`domain`对象意味着更容易理解代码和单元测试。甚至适配器也不需要太多的测试，因为它们的逻辑应该非常简单。
- en: Intention revealing
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图揭示
- en: These details included keeping functions short, concerns separated, dependencies
    isolated, and assigning the right meaning to abstractions in every part of the
    code. Intention revealing was a critical concept for our code—every name has to
    be wisely chosen, clearly communicating what it's supposed to do. Every function
    should tell a story.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节包括保持函数简短，分离关注点，隔离依赖关系，并在代码的每个部分中为抽象赋予正确的含义。意图的揭示对我们的代码来说是一个关键概念——每个名称都必须明智地选择，清晰地传达它应该做的事情。每个函数都应该讲述一个故事。
- en: A good architecture should reveal the intent of the system it entails. It should
    not mention the tools it's built with; those are details, and as we discussed
    at length, details should be hidden, encapsulated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的架构应该揭示系统的意图。它不应该提到它所构建的工具；那些都是细节，正如我们长时间讨论的，细节应该被隐藏，封装起来。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The principles for good software design apply on all levels. In the same way
    that we want to write readable code, and for that we need to mind the intention
    revealing degree of the code, the architecture also has to express the intent
    of the problem it is trying to solve.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 良好软件设计的原则适用于所有层面。就像我们想要编写可读的代码一样，为此我们需要关注代码的意图揭示程度，架构也必须表达它试图解决的问题的意图。
- en: All these ideas are interconnected. The same intention revealing that ensures
    our architecture is defined in terms of the domain problem also leads us to abstract
    details as much as possible, create layers of abstraction, invert dependencies,
    and separate concerns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些想法都是相互关联的。相同的意图揭示确保我们的架构是根据领域问题来定义的，同时也导致我们尽可能地抽象细节，创建抽象层，倒置依赖关系，以及分离关注点。
- en: When it comes to reusing code, Python packages are a great and flexible alternative.
    Criteria, such as cohesion and the **single responsibility principle** (**SRP**),
    are the most important considerations when deciding to create a package. In line
    with having components with cohesion and few responsibilities, the concept of
    microservices comes into play, and for that, we have seen how a service can be
    deployed in a Docker container starting from a packaged Python application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在重用代码方面，Python包是一个很好且灵活的选择。在决定创建包时，诸如内聚性和**单一责任原则**（**SRP**）之类的标准是最重要的考虑因素。与具有内聚性和少责任的组件一致，微服务的概念也开始发挥作用，为此，我们已经看到了如何从打包的Python应用程序开始，在Docker容器中部署服务。
- en: As with everything in software engineering, there are limitations, and there
    are exceptions. It will not always be possible to abstract things as much as we
    would like to or to completely isolate dependencies. Sometimes, it will just not
    be possible (or practical) to comply with the principles explained here in the
    book. But that is probably the best piece of advice the reader should take from
    the book—they are just principles, not laws. If it's not possible, or practical,
    to abstract from a framework, it should not be a problem. Remember what has been
    quoted from the zen of Python itself, throughout the book—**practicality beats
    purity*****.***
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件工程中的一切一样，都存在局限性和例外。我们并不总是能够像我们希望的那样抽象事物，或者完全隔离依赖关系。有时，遵循本书中解释的原则可能是不可能的（或不切实际的）。但这可能是读者应该从本书中得到的最好建议——它们只是原则，而不是法律。如果从框架中抽象出来是不可能的或不切实际的，那也不应该成为问题。请记住本书中引用的Python禅宗本身所说的话——**实用性胜过纯粹*****。***
- en: References
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以参考的信息列表：
- en: '*SCREAM*: The Screaming Architecture ([https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SCREAM*: 尖叫架构 ([https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html))'
- en: '*CLEAN-01*: The Clean Architecture ([https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html))'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CLEAN-01*: 清洁架构 ([https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html))'
- en: '*HEX*: Hexagonal Architecture ([https://staging.cockburn.us/hexagonal-architecture/](https://staging.cockburn.us/hexagonal-architecture/))'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HEX*: 六边形架构 ([https://staging.cockburn.us/hexagonal-architecture/](https://staging.cockburn.us/hexagonal-architecture/))'
- en: '*PEP-508*: Dependency specification for Python software packages ([https://www.python.org/dev/peps/pep-0508/](https://www.python.org/dev/peps/pep-0508/))'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-508*: Python软件包的依赖规范 ([https://www.python.org/dev/peps/pep-0508/](https://www.python.org/dev/peps/pep-0508/))'
- en: Packaging and distributing projects in Python ([https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages](https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中打包和分发项目 ([https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages](https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages)
- en: Summing it all up
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结一切
- en: 'The content of the book is a reference, a possible way of implementing a software
    solution by following criteria. These criteria are explained through examples,
    and the rationale for every decision presented. The reader might very well disagree
    with the approach taken on the examples, and this is actually desirable: the more
    viewpoints, the richer the debate. But regardless of opinions, it''s important
    to make clear that what is presented here is by no means a strong directive, something
    that must be followed imperatively. Quite the opposite, it''s a way of presenting
    the reader with a solution and a set of ideas that they might find helpful.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的内容是一个参考，是通过遵循标准来实现软件解决方案的一种可能方式。这些标准是通过示例来解释的，并且为每个决定提出了理由。读者可能会对示例中采取的方法持不同意见，这实际上是可取的：观点越多，辩论就越丰富。但不管观点如何，重要的是要明确，这里呈现的内容绝不是一种强有力的指令，也不是必须坚决遵循的东西。恰恰相反，它是一种向读者呈现解决方案和一套可能有用的想法的方式。
- en: As introduced at the beginning of the book, the goal of the book was not to
    give you recipes or formulas that you can apply directly, but rather to make you
    develop critical thinking. Idioms and syntax features come and go, they change
    over time. But ideas, and core software concepts, remain. With these tools given,
    and the examples provided, you should have a better understanding of what clean
    code means.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在书的开头介绍的那样，这本书的目标不是给你提供可以直接应用的配方或公式，而是让你发展批判性思维。习语和句法特点会随着时间而改变。但是想法和核心软件概念是不变的。有了这些工具和提供的例子，你应该对清晰的代码意味着什么有更好的理解。
- en: I sincerely hope the book has helped you become a better developer than you
    were before you started it, and I wish you the best of luck in your projects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望这本书能帮助你成为比开始阅读之前更好的开发者，祝你在项目中好运。
