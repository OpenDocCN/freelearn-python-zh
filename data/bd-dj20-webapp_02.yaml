- en: Adding Users to MyMDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户添加到MyMDB
- en: 'In our preceding chapter, we started our project and created our `core` app
    and our `core` models (`Movie` and `Person`). In this chapter, we will build on
    that foundation to do the following things:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们启动了我们的项目并创建了我们的`core`应用程序和我们的`core`模型（`Movie`和`Person`）。在本章中，我们将在此基础上做以下事情：
- en: Let users register, log in, and log out
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户注册、登录和退出
- en: Let logged in users vote movies up/down
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让已登录用户对电影进行投票
- en: Score each movie based on the votes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据投票为每部电影评分
- en: Use votes to recommend the top 10 movies.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用投票来推荐前10部电影。
- en: Let's start this chapter with managing users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从管理用户开始这一章。
- en: Creating the user app
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`user`应用程序
- en: In this section, you will create a new Django app, called `user`, register it
    with your project, and make it manage users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个名为`user`的新Django应用程序，将其注册到您的项目中，并使其管理用户。
- en: At the beginning of [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*, you learned that a Django project is made up of many Django
    apps (such as our existing `core` app). A Django app should provide well-defined
    and tightly scoped behavior. Adding user management to our `core` app violates
    that principle. Making a Django app bear too many responsibilities makes it harder
    to test and harder to reuse. For example, we’ll be reusing the code we write in
    this `user` Django app throughout this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml) *构建MyMDB* 的开头，您了解到Django项目由许多Django应用程序组成（例如我们现有的`core`应用程序）。Django应用程序应提供明确定义和紧密范围的行为。将用户管理添加到我们的`core`应用程序中违反了这一原则。让一个Django应用程序承担太多责任会使测试和重用变得更加困难。例如，我们将在本书中的整个过程中重用我们在这个`user`
    Django应用程序中编写的代码。
- en: Creating a new Django app
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的Django应用程序
- en: 'As we did when we created the `core` app, we will use `manage.py` to generate
    our `user` app:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`core`应用程序时所做的一样，我们将使用`manage.py`来生成我们的`user`应用程序：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll register it with our Django project by editing our `django/config/settings.py`
    file and updating the `INSTALLED_APPS` property:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过编辑我们的`django/config/settings.py`文件并更新`INSTALLED_APPS`属性来将其注册到我们的Django项目中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will need to put `user` before the `admin` app for reasons that we'll discuss
    in the *Logging in and out* section. Generally, it's a good idea to put our apps
    above built-in apps.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 出于我们将在*登录和退出*部分讨论的原因，我们需要将`user`放在`admin`应用程序之前。通常，将我们的应用程序放在内置应用程序之上是一个好主意。
- en: Our `user` app is now a part of our project. Usually, we would now move on to
    creating and defining models for our app. However, thanks to Django’s built-in `auth`
    app, we already have a user model that we can use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`user`应用程序现在是我们项目的一部分。通常，我们现在会继续为我们的应用程序创建和定义模型。但是，由于Django内置的`auth`应用程序，我们已经有了一个可以使用的用户模型。
- en: If we want to use a custom user model, then we can register it by updating `settings.py`
    and setting `AUTH_USER_MODEL` to a string python path to the model (for example, `AUTH_USER_MODEL=myuserapp.models.MyUserModel`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用自定义用户模型，那么我们可以通过更新`settings.py`并将`AUTH_USER_MODEL`设置为模型的字符串python路径来注册它（例如，`AUTH_USER_MODEL=myuserapp.models.MyUserModel`）。
- en: Next, we'll create our user registration view.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的用户注册视图。
- en: Creating a user registration view
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户注册视图
- en: Our `RegisterView` class will be responsible for letting users register for
    our site. If it receives a `GET` request, then it will show them the `UserCreationFrom`;
    if it gets a `POST` request, it will validate the data and create the user. `UserCreationForm`
    is provided by the `auth` app and provides a way to collect and validate the data
    required to register a user; also, it is capable of saving a new user model if
    the data is valid.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`RegisterView`类将负责让用户注册我们的网站。如果它收到一个`GET`请求，那么它将向用户显示`UserCreationFrom`；如果它收到一个`POST`请求，它将验证数据并创建用户。`UserCreationForm`由`auth`应用程序提供，并提供了一种收集和验证注册用户所需数据的方式；此外，如果数据有效，它还能保存一个新的用户模型。
- en: 'Let''s add our view to `django/user/views.py`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的视图添加到`django/user/views.py`中：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a look at our code line by line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看我们的代码：
- en: '`class RegisterView(CreateView):`: Our view extends `CreateView`, so it doesn''t
    have to define how to handle `GET` and `POST` requests, as we will discuss in
    the following steps.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class RegisterView(CreateView):`：我们的视图扩展了`CreateView`，因此不必定义如何处理`GET`和`POST`请求，我们将在接下来的步骤中讨论。'
- en: '`template_name = ''user/register.html''`: This is a template that we''ll create.
    Its context will be a little different than what we''ve seen before; it won''t
    have an `object` or `object_list` variables but will have a `form` variable, which
    is an instance of the class we set in the `form_class` attribute.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_name = ''user/register.html''`：这是一个我们将创建的模板。它的上下文将与我们以前看到的有些不同；它不会有`object`或`object_list`变量，但会有一个`form`变量，它是`form_class`属性中设置的类的实例。'
- en: '`form_class = UserCreationForm`: This is the form class that this `CreateView`
    should use. Simpler models could just say `model = MyModel`, but a user is a little
    more complex because passwords need to be entered twice then hashed. We’ll talk
    about how Django stores password in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_class = UserCreationForm`：这是这个`CreateView`应该使用的表单类。更简单的模型可以只说`model =
    MyModel`，但是用户稍微复杂一些，因为密码需要输入两次然后进行哈希处理。我们将在[第3章](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml)
    *海报、头像和安全* 中讨论Django如何存储密码。'
- en: '`success_url = reverse_lazy(''core:MovieList'')`: When model creation succeeds,
    this is the URL that you need to redirect to. This is actually an optional parameter;
    if the model has a method called `model.get_absolute_url()`, then that will be
    used and we don''t need to provide `success_url`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success_url = reverse_lazy(''core:MovieList'')`：当模型创建成功时，这是您需要重定向到的URL。这实际上是一个可选参数；如果模型有一个名为`model.get_absolute_url()`的方法，那么将使用该方法，我们就不需要提供`success_url`。'
- en: The behavior of `CreateView` is spread across a number of base classes and mixins
    that interact through methods that act as hooks we can override to change behavior.
    Let's take a look at some of the most critical points.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateView`的行为分布在许多基类和mixin中，它们通过方法相互作用，作为我们可以重写以改变行为的挂钩。让我们来看看一些最关键的点。'
- en: If `CreateView` receives a `GET` request, it will render the template for the
    form. One of the ancestors of `CreateView` is `FormMixin` which overrides `get_context_data()`
    to call `get_form()` and add the form instance to our template's context. The
    rendered template is returned as the body of the response by `render_to_response`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CreateView`收到`GET`请求，它将呈现表单的模板。 `CreateView`的祖先之一是`FormMixin`，它重写了`get_context_data()`来调用`get_form()`并将表单实例添加到我们模板的上下文中。
    渲染的模板作为响应的主体由`render_to_response`返回。
- en: If `CreateView` receives a `POST` request, it will also use `get_form()` to
    get the form instance. The form will be *bound* to the `POST` data in the request.
    A bound form can validate the data it is bound to. `CreateView` will then call
    `form.is_valid()` and either `form_valid()` or `form_invalid()` as appropriate.
    `form_valid()` will call `form.save()` (saving the data to the database) then
    return a 302 response that will redirect the browser to `success_url`. The `form_invalid()` method will
    re-render the template with the form (which will now contain error messages for
    the user to fix and resubmit).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CreateView`收到`POST`请求，它还将使用`get_form()`来获取表单实例。 表单将被*绑定*到请求中的`POST`数据。 绑定的表单可以验证其绑定的数据。
    `CreateView`然后将调用`form.is_valid()`，并根据需要调用`form_valid()`或`form_invalid()`。 `form_valid()`将调用`form.save()`（将数据保存到数据库）然后返回一个302响应，将浏览器重定向到`success_url`。
    `form_invalid()`方法将使用包含错误消息的表单重新呈现模板，供用户修复并重新提交。
- en: We're also seeing `reverse_lazy()` for the first time. It's a lazy version of
    `reverse()`. Lazy functions are functions that return a value that is not resolved
    until it is used. We can't use `reverse()` because views classes are evaluated
    while the full set of URLConfs are still being built, so if we need to use `reverse()` at
    the *class* level of a view, we must use `reverse_lazy()`. The value will not
    resolved until the view returns its first response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还第一次看到了`reverse_lazy()`。 它是`reverse()`的延迟版本。 延迟函数是返回值直到使用时才解析的函数。 我们不能使用`reverse()`，因为视图类在构建完整的URLConfs集时进行评估，所以如果我们需要在视图的*类*级别使用`reverse()`，我们必须使用`reverse_lazy()`。
    值直到视图返回其第一个响应才会解析。
- en: Next, let's create the template for our view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的视图创建模板。
- en: Creating the RegisterView template
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RegisterView模板
- en: 'In writing a template with a Django form, we must remember that Django doesn''t
    provide the `<form>` or `<button type=''submit>` tags, just contents of the form
    body. This lets us potentially include multiple Django forms in the same `<form>`.
    With that in mind, let’s add our template to `django/user/templates/user/register.html`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写带有Django表单的模板时，我们必须记住Django不提供`<form>`或`<button type='submit>`标签，只提供表单主体的内容。
    这让我们有可能在同一个`<form>`中包含多个Django表单。 有了这个想法，让我们将我们的模板添加到`django/user/templates/user/register.html`中：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like our previous templates, we extend `base.html` and put our code in one of
    the existing `block` s (in this case, `main`). Let's take a closer look at how
    forms render.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的模板一样，我们扩展`base.html`并将我们的代码放在现有`block`之一中（在这种情况下是`main`）。 让我们更仔细地看看表单是如何呈现的。
- en: 'When a form is rendered, it renders in two parts, first an optional `<ul class=''errorlist''>` tag
    of general error messages (if any), then each field is rendered in four basic
    parts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单呈现时，它分为两部分，首先是一个可选的`<ul class='errorlist'>`标签，用于一般错误消息（如果有的话），然后每个字段分为四个基本部分：
- en: a `<label>` tag with the field name
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有字段名称的`<label>`标签
- en: a `<ul class="errorlist">` tag with errors from the user's previous form submission;
    this will only render if there were errors for that field
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<ul class="errorlist">`标签，显示用户先前表单提交的错误；只有在该字段有错误时才会呈现
- en: an `<input>` (or `<select>`) tag to accept input
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<input>`（或`<select>`）标签来接受输入
- en: a `<span class="helptext">` tag for the field's help text
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`<span class="helptext">`标签，用于字段的帮助文本
- en: '`Form` comes with the following three utility methods to render the form:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`带有以下三个实用方法来呈现表单：'
- en: '`as_table()`: Each field is wrapped in a `<tr>` tag with the label in a `<th>` tag
    and the widget wrapped in a `<td>` tag. The containing `<table>` tag is not provided.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as_table()`: 每个字段都包裹在一个`<tr>`标签中，标签中包含一个`<th>`标签和一个包裹在`<td>`标签中的小部件。 不提供包含的`<table>`标签。'
- en: '`as_ul`: The entire field (label and help text widget) is wrapped in a `<li>` tag.
    The containing `<ul>` tag is not provided.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as_ul`: 整个字段（标签和帮助文本小部件）都包裹在一个`<li>`标签中。 不提供包含的`<ul>`标签。'
- en: '`as_p`: The entire field (label and help text widget) is wrapped in a `<p>` tag.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as_p`: 整个字段（标签和帮助文本小部件）都包裹在一个`<p>`标签中。'
- en: Containing `<table>` and `<ul>` tags are not provided for the same form that
    a `<form>` tag is not provided, to make it easier to output multiple forms together
    if necessary.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同的表单，不提供包含`<table>`和`<ul>`标签，也不提供`<form>`标签，以便在必要时更容易一起输出多个表单。
- en: If you want fine-grained control over form rendering, `Form` instances are iterable,
    yielding a `Field` in each iteration, or can be looked up by name as `form["fieldName"]`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对表单呈现进行精细的控制，`Form`实例是可迭代的，在每次迭代中产生一个`Field`，或者可以按名称查找为`form["fieldName"]`。
- en: In our example, we use the `as_p()` method because we don't need fine-grained
    layout control.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`as_p()`方法，因为我们不需要精细的布局控制。
- en: This template is also the first time we will see the `csrf_token` tag. CSRF
    is a common vulnerability in web apps that we'll discuss more in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*. Django automatically checks all `POST` and
    `PUT` requests for a valid `csrfmiddlewaretoken` and header. Requests missing
    this won’t even reach the view, but will get a `403 Forbidden` response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板也是我们第一次看到`csrf_token`标签。 CSRF是Web应用程序中常见的漏洞，我们将在[第3章](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml)中更多地讨论它，*海报、头像和安全性*。
    Django自动检查所有`POST`和`PUT`请求是否有有效的`csrfmiddlewaretoken`和标头。 缺少这个的请求甚至不会到达视图，而是会得到一个`403
    Forbidden`的响应。
- en: Now that we have our template, let's add a `path()` object to our view in our
    URLConf.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板，让我们在我们的URLConf中为我们的视图添加一个`path()`对象。
- en: Adding a path to RegisterView
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到RegisterView的路径
- en: 'Our `user` app doesn''t have a `urls.py` file, so we''ll have to create the `django/user/urls.py` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`user`应用程序没有`urls.py`文件，所以我们需要创建`django/user/urls.py`文件：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll have to `include()` this URLConf in our root URLConf in `django/config/urls.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`django/config/urls.py`的根URLConf中`include()`此URLConf：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since URLConf will only search until the *first* matching `path` is found, we
    always want to put `path`s with no prefix or with the broadest URLConfs last so
    that they don't accidentally block other views.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于URLConf只会搜索直到找到*第一个*匹配的`path`，因此我们总是希望将没有前缀或最广泛的URLConfs的`path`放在最后，以免意外阻止其他视图。
- en: Logging in and out
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录和登出
- en: 'Django''s `auth` app provides views for logging in and out. Adding this to
    our project will be a two-step process:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`auth`应用程序提供了用于登录和注销的视图。将此添加到我们的项目将是一个两步过程：
- en: Registering the views in the `user` URLConf
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user` URLConf中注册视图
- en: Adding templates for the views
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为视图添加模板
- en: Updating user URLConf
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户URLConf
- en: Django's `auth` app provides a lot of views to help make user management and
    authentication easier, including logging in/out, changing passwords, and resetting
    forgotten passwords. A full-featured production app should offer all three features
    to users. In our case, we will restrict ourselves to just log in and log out.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`auth`应用程序提供了许多视图，以帮助简化用户管理和身份验证，包括登录/注销、更改密码和重置忘记的密码。一个功能齐全的生产应用程序应该为用户提供所有三个功能。在我们的情况下，我们将限制自己只提供登录和注销。
- en: 'Let''s update `django/user/urls.py` to use log in and log out views of `auth`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/user/urls.py`以使用`auth`的登录和注销视图：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you''re providing log in/log out, password change, and password reset, then
    you can use URLConf of `auth` as shown in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提供了登录/注销、更改密码和重置密码，则可以使用`auth`的URLConf，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's add the template.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加模板。
- en: Creating a LoginView template
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个LoginView模板
- en: 'First, let''s add a template for the login page in `django/user/templates/registration/login.html`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`django/user/templates/registration/login.html`中为登录页面添加模板：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code looks very similar to `user/register.html`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来与`user/register.html`非常相似。
- en: However, what should happen when the user logs in?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当用户登录时应该发生什么？
- en: A successful login redirect
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功的登录重定向
- en: 'In `RegisterView`, we were able to specify where to redirect the user after
    success because we created the view. The `LoginView` class will follow these steps
    to decide where to redirect the user:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RegisterView`中，我们能够指定成功后将用户重定向到何处，因为我们创建了视图。`LoginView`类将按照以下步骤决定将用户重定向到何处：
- en: Use the `POST` parameter `next` if it is a valid URL and point at a server hosting
    this application. `path()` names are not available.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`POST`参数`next`是一个有效的URL，并指向托管此应用程序的服务器，则使用`POST`参数`next`。`path()`名称不可用。
- en: Use the `GET` parameter `next` if it is a valid URL and point at a server hosting
    this application. `path()` names are not available.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`next`是一个有效的URL，并指向托管此应用程序的服务器，则使用`GET`参数`next`。`path()`名称不可用。
- en: '`LOGIN_REDIRECT_URL` setting which has a default of `''/accounts/profile/''`.
    `path()` names *are* available.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LOGIN_REDIRECT_URL`设置默认为`''/accounts/profile/''`。`path()`名称*可用*。'
- en: 'In our case, we want to redirect all users to the movie list, so let''s update
    `django/config/settings.py` to have a `LOGIN_REDIRECT_URL` setting:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望将所有用户重定向到电影列表，所以让我们更新`django/config/settings.py`以设置`LOGIN_REDIRECT_URL`：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, if there were cases where we wanted to redirect users to a specific
    page, we could use the `next` parameter to specifically redirect them to a particular
    page. For example, if a user tries to perform an action before they're logged
    in, we pass the page they were on to `LoginView` as a `next` parameter to redirect
    them back to the page they were on after logging in.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果有情况需要将用户重定向到特定页面，我们可以使用`next`参数将其专门重定向到特定页面。例如，如果用户尝试在登录之前执行操作，我们将他们所在的页面传递给`LoginView`作为`next`参数，以便在登录后将他们重定向回所在的页面。
- en: Now, when a user will log in, they will be redirected to our Movie List view.
    Next, let’s create a template for the logout view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户登录时，他们将被重定向到我们的电影列表视图。接下来，让我们为注销视图创建一个模板。
- en: Creating a LogoutView template
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个LogoutView模板
- en: The `LogoutView` class behaves strangely. If it receives a `GET` request, it
    will log the user out and then try to render `registration/logged_out.html`. It's
    unusual for `GET` requests to modify a user's state, so it's worth remembering
    that this view is a bit different.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogoutView`类的行为有些奇怪。如果它收到一个`GET`请求，它将注销用户，然后尝试呈现`registration/logged_out.html`。`GET`请求修改用户状态是不寻常的，因此值得记住这个视图有点不同。'
- en: There's another wrinkle with the `LogoutView` class. If you don't provide a
    `registration/logged_out.html` template and you have the `admin` app installed,
    then Django *may* use the template of `admin` because the `admin` app does have
    that template (log out of the `admin` app, and you’ll see it).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogoutView`类还有另一个问题。如果您没有提供`registration/logged_out.html`模板，并且已安装`admin`应用程序，则Django
    *可能*会使用`admin`的模板，因为`admin`应用程序确实有该模板（退出`admin`应用程序，您会看到它）。'
- en: 'The way that Django resolves template names into files is a three-step process
    that stops as soon as a file is found, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Django将模板名称解析为文件的方式是一个三步过程，一旦找到文件，就会停止，如下所示：
- en: Django iterates over the directories in the `DIRS` list in `settings.TEMPLATES`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django遍历`settings.TEMPLATES`中`DIRS`列表中的目录。
- en: If `APP_DIRS` is `True`, then it will iterate over the apps listed in `INSTALLED_APPS`
    until a match is found. If `admin` comes before `user` in the `INSTALLED_APPS`
    list, then it will match first. If `user` comes first, `user` will match first.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`APP_DIRS`为`True`，则它将遍历`INSTALLED_APPS`中列出的应用程序，直到找到匹配项。如果`admin`在`INSTALLED_APPS`列表中出现在`user`之前，那么它将首先匹配。如果`user`在前面，`user`将首先匹配。
- en: Raise a `TemplateDoesNotExist` exception.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引发`TemplateDoesNotExist`异常。
- en: This is why we put `user` first in our list of installed apps and added a comment
    warning future developers not to change the order.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们把`user`放在已安装应用程序列表的第一位，并添加了一个警告未来开发人员不要改变顺序的注释。
- en: We're now done with our `user` app. Let's review what we've accomplished.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了我们的`user`应用程序。让我们回顾一下我们取得了什么成就。
- en: A quick review of the section
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾本节
- en: We've created a `user` app to encapsulate user management. In our `user` app,
    we leveraged a lot of functionalities that Django's `auth` app provides, including `UserCreationForm`,
    `LoginView`, and `LogoutView` classes. We've also learned about some new generic
    views that Django provides and used `CreateView` in combination with the `UserCreationForm` class
    to make the `RegisterView` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`user`应用来封装用户管理。在我们的`user`应用中，我们利用了Django的`auth`应用提供的许多功能，包括`UserCreationForm`、`LoginView`和`LogoutView`类。我们还了解了Django提供的一些新的通用视图，并结合`UserCreationForm`类使用`CreateView`来创建`RegisterView`类。
- en: Now that we have users, let's allow them to vote on our movies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户，让我们允许他们对我们的电影进行投票。
- en: Letting users vote on movies
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户对电影进行投票
- en: Part of the fun of community sites such as IMDB is being able to vote on the
    movies we love and hate. In MyMDB, users will be able to vote for movies with
    either a ![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png) or a ![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png).
    A movie will have a score, which is the number of ![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png)
     minus the number of ![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像IMDB这样的社区网站的一部分的乐趣就是能够对我们喜欢和讨厌的电影进行投票。在MyMDB中，用户将能够为电影投票，要么是![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png)，要么是![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png)。一部电影将有一个分数，即![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png)的数量减去![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png)的数量。
- en: 'Let''s start with the most important part of voting: the `Vote` model.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从投票的最重要部分开始：`Vote`模型。
- en: Creating the Vote model
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vote模型
- en: In MyMDB, each user can have one vote per movie. The vote can either be positive—![](img/99b1dc6e-8da4-459c-ac70-7ea8c550c455.png)—or
    negative—![](img/184747c1-7c19-4599-8fd8-d8319dab8d5c.png).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在MyMDB中，每个用户可以对每部电影投一次票。投票可以是正面的—![](img/99b1dc6e-8da4-459c-ac70-7ea8c550c455.png)—或者是负面的—![](img/184747c1-7c19-4599-8fd8-d8319dab8d5c.png)。
- en: 'Let''s update our `django/core/models.py` file to have our `Vote` model:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`django/core/models.py`文件来拥有我们的`Vote`模型：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This model has the following four fields:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型有以下四个字段：
- en: '`value`, which must be `1` or `-1`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`，必须是`1`或`-1`。'
- en: '`user` is a `ForeignKey`, which references the `User` mode through `settings.AUTH_USER_MODEL`.
    Django recommends that you never reference `django.contrib.auth.models.User` directly
    but using either `settings.AUTH_USER_MODEL` or `django.contrib.auth.get_user_model()`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`是一个`ForeignKey`，它通过`settings.AUTH_USER_MODEL`引用`User`模型。Django建议您永远不要直接引用`django.contrib.auth.models.User`，而是使用`settings.AUTH_USER_MODEL`或`django.contrib.auth.get_user_model()`。'
- en: '`movie` is a `ForeignKey` referencing a `Movie` model.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movie`是一个引用`Movie`模型的`ForeignKey`。'
- en: '`voted_on` is a `DateTimeField` with `auto_now` enabled. The `auto_now` argument
    makes the model update the field to the current date time every time the model
    is saved.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`voted_on`是一个带有`auto_now`启用的`DateTimeField`。`auto_now`参数使模型在每次保存模型时更新字段为当前日期时间。'
- en: The `unique_together` attribute of Meta creates a unique constraint on the table.
    A unique constraint will prevent two rows having the same value for both `user`
    and `movie`, enforcing our rule of one vote per user per movie.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_together`属性的`Meta`在表上创建了一个唯一约束。唯一约束将防止两行具有相同的`user`和`movie`值，强制执行我们每个用户每部电影一次投票的规则。'
- en: 'Let''s create a migration for our mode with `manage.py`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的模型创建一个迁移，使用`manage.py`：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, let''s run our migration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们运行我们的迁移：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have our model and table set up, let's create a form to validate
    votes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的模型和表，让我们创建一个表单来验证投票。
- en: Creating VoteForm
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建VoteForm
- en: Django's forms API is very robust and lets us create almost any kind of form
    we want. If we want to create an arbitrary form, we can create a class that extends
    `django.forms.Form` and add whatever fields we want to it. However, if we want
    to build a form that represents a model, Django offers us a shortcut with `django.forms.ModelForm`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Django的表单API非常强大，让我们可以创建几乎任何类型的表单。如果我们想创建一个任意的表单，我们可以创建一个扩展`django.forms.Form`的类，并向其中添加我们想要的字段。然而，如果我们想构建一个代表模型的表单，Django为我们提供了一个快捷方式，即`django.forms.ModelForm`。
- en: The type of form we want depends on where the form will be placed and how it
    will be used. In our case, we want a form we can place on the `MovieDetail` page
    and just let it give the user the following two radio buttons:![](img/05b14743-dedd-4122-97df-cc15869422be.png) and ![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的表单类型取决于表单将被放置的位置以及它将如何被使用。在我们的情况下，我们想要一个可以放在`MovieDetail`页面上的表单，并让它给用户以下两个单选按钮：![](img/05b14743-dedd-4122-97df-cc15869422be.png)和![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png)。
- en: 'Let''s take a look at the simplest `VoteForm` possible:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看可能的最简单的`VoteForm`：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Django will generate a form from the `Vote` model using the `value`, `user`,
    and `movie` fields. `user` and `movie` will be `ModelChoiceField`s that use a
    `<select>` dropdown to pick the correct value, and `value` is a `ChoiceField`
    that also uses a `<select>` drop-down widget, not quite what we wanted by default.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Django将使用`value`、`user`和`movie`字段从`Vote`模型生成一个表单。`user`和`movie`将是使用`<select>`下拉列表选择正确值的`ModelChoiceField`，而`value`是一个使用`<select>`下拉小部件的`ChoiceField`，这不是我们默认想要的。
- en: '`VoteForm` will require `user` and `movie`. Since we''ll use `VoteForm` to
    save new votes, we can''t eliminate those fields. However, letting users vote
    on behalf of other users will create a vulnerability. Let''s customize our form
    to prevent that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`VoteForm`将需要`user`和`movie`。由于我们将使用`VoteForm`来保存新的投票，我们不能消除这些字段。然而，让用户代表其他用户投票将会创建一个漏洞。让我们自定义我们的表单来防止这种情况发生：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding form, we've customized the fields.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表单中，我们已经自定义了字段。
- en: 'Let''s take a closer look at the `user` field:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下`user`字段：
- en: '`user = forms.ModelChoiceField(`: A `ModelChoiceField` accepts another model
    as the value for this field. The choice of model is validated by providing a `QuerySet` instance
    of valid options.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user = forms.ModelChoiceField(`: `ModelChoiceField`接受另一个模型作为该字段的值。通过提供有效选项的`QuerySet`实例来验证模型的选择。'
- en: '`queryset=get_user_model().objects.all(),`: A `QuerySet` that defines the valid
    choices for this field. In our case, any user can vote.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryset=get_user_model().objects.all(),`：定义此字段的有效选择的`QuerySet`。在我们的情况下，任何用户都可以投票。'
- en: '`widget=forms.HiddenInput,`: The `HiddenInput` widget renders as a `<input
    type=''hidden''>` HTML element, meaning that the user won’t be distracted by any
    UI.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widget=forms.HiddenInput,`: `HiddenInput`小部件呈现为`<input type=''hidden''>`HTML元素，这意味着用户不会被任何UI分散注意力。'
- en: '`disabled=True,`: The `disabled` parameter tells the form to ignore any provided
    data for this field and only use values initially provided in the code. This prevents
    users from voting on behalf of other users.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled=True,`: `disabled`参数告诉表单忽略此字段的任何提供的数据，只使用代码中最初提供的值。这可以防止用户代表其他用户投票。'
- en: The `movie` field is much the same as `user`, but with the  `queryset` attribute
    queries for `Movie` model instances.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`movie`字段与`user`基本相同，但`queryset`属性查询`Movie`模型实例。'
- en: 'The value field is customized in a different way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值字段以不同的方式进行了定制：
- en: '`value = forms.ChoiceField(`: A `ChoiceField` is used to represent a field
    that can have a single value from a limited set. By default, it''s represented
    by a drop-down list widget.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value = forms.ChoiceField(`: `ChoiceField`用于表示可以从有限集合中具有单个值的字段。默认情况下，它由下拉列表小部件表示。'
- en: '`label=''Vote'',`: The `label` attribute lets us customize the label used for
    this field. While `value` makes sense in our code, we want users to think that
    their ![](img/05b14743-dedd-4122-97df-cc15869422be.png)/![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png) is
    the vote.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label=''Vote'',`: `label`属性让我们自定义此字段使用的标签。虽然`value`在我们的代码中有意义，但我们希望用户认为他们的投票是`![](img/05b14743-dedd-4122-97df-cc15869422be.png)/![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png)`。'
- en: '`widget=forms.RadioSelect,`: A dropdown hides the options until a user clicks
    on the dropdown. But our values are effective calls to action that we want to
    be always visible. Using the `RadioSelect` widget, Django will render each choice
    as an `<input type=''radio''>` tag with the appropriate `<label>` tag and `name` value
    to make voting easier.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widget=forms.RadioSelect,`: 下拉列表隐藏选项，直到用户点击下拉列表。但我们的值是我们希望始终可见的有效行动呼叫。使用`RadioSelect`小部件，Django将每个选择呈现为`<input
    type=''radio''>`标签，并带有适当的`<label>`标签和`name`值，以便更容易进行投票。'
- en: '`choices=Vote.VALUE_CHOICES,`: A `ChoiceField` must be told the valid choices;
    conveniently, it uses the same format as a model field’s `choices` parameter,
    so we can reuse the `Vote.VALUE_CHOICES` tuple we used in the model.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices=Vote.VALUE_CHOICES,`: `ChoiceField`必须告知有效选择；方便的是，它使用与模型字段的`choices`参数相同的格式，因此我们可以重用模型中使用的`Vote.VALUE_CHOICES`元组。'
- en: Our newly customized form will appear with the label `vote` and two radio buttons.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新定制的表单将显示为标签`vote`和两个单选按钮。
- en: Now that we have our form, let's add voting to the `MovieDetail` view and create
    views that know how to process votes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表单，让我们将投票添加到`MovieDetail`视图，并创建知道如何处理投票的视图。
- en: Creating voting views
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建投票视图
- en: 'In this section, we will update the `MovieDetail` view to let users cast their
    votes and views that log the votes in the database. To process the users casting
    votes, we will create the following two views:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将更新`MovieDetail`视图，让用户投票并记录投票到数据库中。为了处理用户的投票，我们将创建以下两个视图：
- en: '`CreateVote`, which will be a `CreateView` to be used if a user hasn''t voted
    for a movie yet'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateVote`，这将是一个`CreateView`，如果用户尚未为电影投票'
- en: '`UpdateVote`, which will be an `UpdateView` to be used if a user has already
    voted but is changing their vote'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateVote`，这将是一个`UpdateView`，如果用户已经投票但正在更改他们的投票'
- en: Let's start by updating `MovieDetail` to provide a UI for voting on a movie.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更新`MovieDetail`开始，为电影提供投票的UI。
- en: Adding VoteForm to MovieDetail
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将VoteForm添加到MovieDetail
- en: Our `MovieDetail.get_context_data` method will be a bit more complex now. It
    will have to get the user's vote for the movie, instantiate the form, and know
    which URL to submit the vote to (`create_vote` or `update_vote`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MovieDetail.get_context_data`方法现在会更加复杂。它将需要获取用户对电影的投票，实例化表单，并知道将投票提交到哪个URL（`create_vote`或`update_vote`）。
- en: The first thing we will need is a way to check whether a user model has a related
    `Vote` model instance for a given `Movie` model instance. To do this, we will
    create a `VoteManager` class with a custom method. Our method will have a special
    behavior—if there is no matching `Vote` model instance, it will return an *unsaved*
    blank `Vote` object. This will make it easier to instantiate our `VoteForm` with
    the proper `movie` and `user` values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一种方法来检查用户模型是否对给定的`Movie`模型实例有相关的`Vote`模型实例。为此，我们将创建一个带有自定义方法的`VoteManager`类。我们的方法将具有特殊行为
    - 如果没有匹配的`Vote`模型实例，它将返回一个*未保存*的空白`Vote`对象。这将使我们更容易使用正确的`movie`和`user`值实例化我们的`VoteForm`。
- en: 'Here''s our new `VoteManager`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新`VoteManager`：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`VoteManager` is much like our previous `Manager`s.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`VoteManager`与我们以前的`Manager`非常相似。'
- en: One thing we haven't encountered before is instantiating a model using its constructor
    (for example, `Vote(movie=movie, user=user)`) as opposed to its manager's `create()`
    method. Using the constructor creates a new model in memory but *not* in the database.
    An unsaved model is fully functional in itself (all the methods and manager methods
    are generally available), with the exception of anything that relies on relationships.
    An unsaved model has no `id` thus cannot be looked up using a `RelatedManager`
    or `QuerySet` until it is saved by calling its `save()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前没有遇到的一件事是使用构造函数实例化模型（例如，`Vote(movie=movie, user=user)`）而不是使用其管理器的`create()`方法。使用构造函数在内存中创建一个新模型，但*不*在数据库中创建。未保存的模型本身是完全可用的（通常可用所有方法和管理器方法），但除了依赖关系的任何内容。未保存的模型没有`id`，因此在调用其`save()`方法保存之前，无法使用`RelatedManager`或`QuerySet`查找它。
- en: 'Now that we have everything that `MovieDetail` needs, let''s update it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了`MovieDetail`所需的一切，让我们来更新它：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've introduced two new elements in the preceding code, `self.request` and
    instantiating forms with instances.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上述代码中引入了两个新元素，`self.request`和使用实例化表单。
- en: Views have access to the request that they're processing through their `request`
    attribute. Also, `Request`s have a `user` property that gives us access to the
    user who made the request. We use this to check whether the user is authenticated
    or not, since only authenticated users can vote.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通过它们的`request`属性访问它们正在处理的请求。此外，`Request`有一个`user`属性，它让我们访问发出请求的用户。我们使用这个来检查用户是否已经验证，因为只有已验证的用户才能投票。
- en: '`ModelForms` can be instantiated with an instance of the model they represent.
    When we instantiate a `ModelForm` with an instance and render it, the fields will
    have the values of the instance. A nice shortcut for a common task is to display
    this model’s values in this form.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelForms`可以使用它们所代表的模型的实例进行实例化。当我们使用一个实例实例化`ModelForm`并渲染它时，字段将具有实例的值。一个常见任务的一个很好的快捷方式是在这个表单中显示这个模型的值。'
- en: 'We will also reference two `path`s that we haven''t created yet; we''ll do
    that in a moment. First, let''s finish off our `MovieDetail` update by updating
    the `movie_detail.html` template sidebar block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引用两个我们还没有创建的`path`；我们马上就会创建。首先，让我们通过更新`movie_detail.html`模板的侧边栏块来完成我们的`MovieDetail`更新：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In designing this, we again follow the principle that templates should have
    the least amount of logic possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计这个过程中，我们再次遵循模板应该具有尽可能少的逻辑的原则。
- en: Next, let's add our `CreateVote` view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们的`CreateVote`视图。
- en: Creating the CreateVote view
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`CreateVote`视图
- en: The `CreateVote` view will be responsible for validating vote data using `VoteForm`
    and then creating the correct `Vote` model instance. However, we will not create
    a template for voting. If there's a problem, we'll just redirect the user to the
    `MovieDetail` view.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateVote`视图将负责使用`VoteForm`验证投票数据，然后创建正确的`Vote`模型实例。然而，我们不会为投票创建一个模板。如果有问题，我们将把用户重定向到`MovieDetail`视图。'
- en: 'Here''s the `CreateVote` view we should have in our `django/core/views.py` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该在`django/core/views.py`文件中拥有的`CreateVote`视图：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ve introduced four new concepts in the preceding code that are different
    than in the `RegisterView` class—`get_initial()`, `render_to_response()`, `redirect()`,
    and `LoginRequiredMixin`. They are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们引入了四个与`RegisterView`类不同的新概念——`get_initial()`、`render_to_response()`、`redirect()`和`LoginRequiredMixin`。它们如下：
- en: '`get_initial()` is used to pre-populate a form with `initial` values before
    the form gets `data` values from the request. This is important for `VoteForm`
    because we''ve disabled `movie` and `user`. `Form` disregards `data` assigned
    to disabled fields. Even if a user sends in a different `movie` value or `user`
    value in the form, it will be disregarded by the disabled fields, and our `initial`
    values will be used instead.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_initial()`用于在表单从请求中获取`data`值之前，使用`initial`值预填充表单。这对于`VoteForm`很重要，因为我们已经禁用了`movie`和`user`。`Form`会忽略分配给禁用字段的`data`。即使用户在表单中发送了不同的`movie`值或`user`值，它也会被禁用字段忽略，而我们的`initial`值将被使用。'
- en: '`render_to_response()` is called by `CreateView` to return a response with
    the render template to the client. In our case, we will not return a response
    with a template, but an HTTP redirect to `MovieDetail`. There is a serious downside
    to this approach—we lose any errors associated with the form. However, since our
    user has only two choices for input, there aren''t many error messages we could
    provide anyway.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_to_response()`被`CreateView`调用以返回一个包含渲染模板的响应给客户端。在我们的情况下，我们不会返回一个包含模板的响应，而是一个HTTP重定向到`MovieDetail`。这种方法有一个严重的缺点——我们会丢失与表单相关的任何错误。然而，由于我们的用户只有两种输入选择，我们也无法提供太多错误消息。'
- en: '`redirect()` is from Django''s `django.shortcuts` package. It provides shortcuts
    for common operations, including creating an HTTP redirect response to a given
    URL.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect()`来自Django的`django.shortcuts`包。它提供了常见操作的快捷方式，包括创建一个HTTP重定向响应到给定的URL。'
- en: '`LoginRequiredMixin` is a mixin that can be added to any `View` and will check
    whether the request is being made by an authenticated user. If the user is not
    logged in, they will be redirected to the login page.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginRequiredMixin`是一个可以添加到任何`View`中的mixin，它将检查请求是否由已验证用户发出。如果用户没有登录，他们将被重定向到登录页面。'
- en: 'Django''s default setting for a login page is `/accounts/profile/`, so let''s
    change this by editing our `settings.py` file and adding a new setting:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Django的默认登录页面设置为`/accounts/profile/`，所以让我们通过编辑`settings.py`文件并添加一个新的设置来改变这一点：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have a view that will create a `Vote` model instance and redirect the
    user back to the related `MovieDetail` view on success or failure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个视图，它将创建一个`Vote`模型实例，并在成功或失败时将用户重定向回相关的`MovieDetail`视图。
- en: Next, let's add a view to let users update their `Vote` model instances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个视图，让用户更新他们的`Vote`模型实例。
- en: Creating the UpdateVote view
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`UpdateVote`视图
- en: The `UpdateVote` view is much simpler because `UpdateView` (like `DetailView`)
    takes care of the job of looking up the vote though we still have to be concerned
    about `Vote` tampering.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateVote`视图要简单得多，因为`UpdateView`（就像`DetailView`）负责查找投票，尽管我们仍然必须关注`Vote`的篡改。'
- en: 'Let''s update our `django/core/views.py` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`django/core/views.py`文件：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our `UpdateVote` view checks whether the `Vote` retrieved is the logged in user's
    vote in the `get_object()` method. We've added this check to prevent vote tampering.
    Our user interface doesn't let users do this by mistake. If the `Vote` wasn't
    cast by the logged in user then `UpdateVote` throws a `PermissionDenied` exception
    that Django will process and return into a `403 Forbidden` response.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UpdateVote`视图在`get_object()`方法中检查检索到的`Vote`是否是已登录用户在其中的投票。我们添加了这个检查来防止投票篡改。我们的用户界面不会让用户错误地这样做。如果`Vote`不是由已登录用户投出的，那么`UpdateVote`会抛出一个`PermissionDenied`异常，Django会处理并返回一个`403
    Forbidden`响应。
- en: The final step will be to register our new views with the `core` URLConf.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将是在`core` URLConf中注册我们的新视图。
- en: Adding views to core/urls.py
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`core/urls.py`中添加视图
- en: 'We''ve now created two new views, but, as always, they''re not accessible to
    users until they’re listed in a URLConf. Let''s edit `core/urls.py`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了两个新视图，但是，和往常一样，除非它们在URLConf中列出，否则用户无法访问它们。让我们编辑`core/urls.py`：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A quick review of the section
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本节的快速回顾
- en: In this section, we saw examples of how to build basic and highly customized
    forms for accepting and validating user input. We also discussed some of the built-in
    views that simplify the common tasks of processing forms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何构建基本和高度定制的表单来接受和验证用户输入。我们还讨论了一些简化处理表单常见任务的内置视图。
- en: Next, we'll show how to start using our users, votes to rank each movie and
    provide a top-10 list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何开始使用我们的用户、投票来对每部电影进行排名并提供一个前10名的列表。
- en: Calculating Movie score
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算电影得分
- en: In this section, we'll use Django's aggregate query API to calculate the score
    for each movie. Django makes writing database agnostic aggregate queries easy
    by building the functionality into its `QuerySet` objects.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用Django的聚合查询API来计算每部电影的得分。Django通过将功能内置到其`QuerySet`对象中，使编写与数据库无关的聚合查询变得容易。
- en: Let's start by adding a method to calculate a score to `MovieManager`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加一个计算`MovieManager`得分的方法。
- en: Using MovieManager to calculate Movie score
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MovieManager来计算电影得分
- en: Our `MovieManager` class is responsible for building `QuerySet` objects associated
    with `Movie`. We now need a new method that retrieves movies (ideally still with
    the related persons) and marking each movie's score based on the sum of the votes
    it received (we can just sum all the `1` and `-1`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MovieManager`类负责构建与`Movie`相关的`QuerySet`对象。我们现在需要一个新的方法，该方法检索电影（理想情况下仍与相关人员相关）并根据其收到的投票总和标记每部电影的得分（我们可以简单地对所有的`1`和`-1`求和）。
- en: 'Let''s take a look at how we can do this using Django''s `QuerySet.annotate()`
    API:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Django的`QuerySet.annotate()` API来做到这一点：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In `all_with_related_persons_and_score`, we call `all_with_related_persons`
    and get a `QuerySet` that we can modify further with our `annotate()` call.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`all_with_related_persons_and_score`中，我们调用`all_with_related_persons`并获得一个我们可以进一步使用`annotate()`调用修改的`QuerySet`。
- en: '`annotate` turns our regular SQL query into an aggregate query, adding the
    supplied aggregate operation''s result to a new attribute called `score`. Django
    abstracts most common SQL aggregate functions into class representations, including
    `Sum`, `Count`, and `Average` (and many more).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate`将我们的常规SQL查询转换为聚合查询，将提供的聚合操作的结果添加到一个名为`score`的新属性中。Django将大多数常见的SQL聚合函数抽象为类表示，包括`Sum`、`Count`和`Average`（以及更多）。'
- en: The new `score` attribute is available on any instance we `get()` out of the
    `QuerySet` as well as in any methods we want to call on our new `QuerySet` (for
    example, `qs.filter(score__gt=5)` would return a `QuerySet` that has movies with
    a `score` attribute greater than 5).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`score`属性可用于我们从`QuerySet`中`get()`出来的任何实例，以及我们想要在我们的新`QuerySet`上调用的任何方法（例如，`qs.filter(score__gt=5)`将返回一个具有`score`属性大于5的电影的`QuerySet`）。
- en: Our new method still returns a `QuerySet` that is lazy, which means that our
    next step is to update `MovieDetail` and its template.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新方法仍然返回一个懒惰的`QuerySet`，这意味着我们的下一步是更新`MovieDetail`及其模板。
- en: Updating MovieDetail and template
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新MovieDetail和模板
- en: 'Now that we can query movies with their scores, let''s change the `QuerySet`
    `MovieDetail` uses:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查询带有得分的电影，让我们更改`MovieDetail`使用的`QuerySet`：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, when `MovieDetail` uses `get()` on its query set, the `Movie` will have
    a score attribute. Let''s use it in our `movie_detail.html` template:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`MovieDetail`在其查询集上使用`get()`时，该`Movie`将具有一个得分属性。让我们在我们的`movie_detail.html`模板中使用它：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can reference the `score` property safely because of `QuerySet` of `MovieDetail`.
    However, we don't have a guarantee that the score will not be `None` (for example,
    if the `Movie` has no votes). To guard against a blank score, we use the `default_if_none`
    filter to provide a value to print out.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地引用`score`属性，因为`MovieDetail`的`QuerySet`。然而，我们不能保证得分不会是`None`（例如，如果`Movie`没有投票）。为了防止空白得分，我们使用`default_if_none`过滤器来提供一个要打印的值。
- en: We now have a `MovieManager` method that can calculate the score for all movies,
    but when you use it in `MovieDetail`, it means that it will only do so for the
    `Movie` being displayed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以计算所有电影得分的`MovieManager`方法，但是当您在`MovieDetail`中使用它时，这意味着它只会为正在显示的`Movie`计算得分。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we added users to our system, letting them register, log in
    (and out), and vote on our movies. We learned how to use aggregate queries to
    efficiently calculate the results of these votes in the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向我们的系统添加了用户，让他们注册、登录（和退出登录），并对我们的电影进行投票。我们学会了如何使用聚合查询来高效地计算数据库中这些投票的结果。
- en: Next, we will let users upload pictures associated with our `Movie` and `People`
    models and discuss security considerations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将让用户上传与我们的`Movie`和`People`模型相关的图片，并讨论安全考虑。
