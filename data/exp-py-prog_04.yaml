- en: Chapter 4. Choosing Good Names
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。选择好的名称
- en: 'Most of the standard library was built keeping usability in mind. For instance,
    working with built-in types is done naturally and was designed to be easy to use.
    Python, in this case, can be compared to the pseudocode you might think about
    when working on a program. Most of the code can be read out loud. For instance,
    this snippet should be understandable by anyone:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分标准库都是在考虑可用性的基础上构建的。例如，使用内置类型是自然而然的，并且旨在易于使用。在这种情况下，Python可以与您在编写程序时可能考虑的伪代码进行比较。大部分代码都可以大声朗读出来。例如，任何人都应该能理解这段代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is one of the reasons why writing Python is so easy when compared to other
    languages. When you are writing a program, the flow of your thoughts is quickly
    translated into lines of code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么与其他语言相比，编写Python如此容易的原因之一。当您编写程序时，您的思维流很快就会转化为代码行。
- en: 'This chapter focuses on the best practices for writing code that is easy to
    understand and use, through:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了编写易于理解和使用的代码的最佳实践，包括：
- en: The usage of naming conventions, described in **PEP 8**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在PEP 8中描述的命名约定
- en: The set of naming best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套命名最佳实践
- en: The short summary of popular tools that allow you to check for compliance with
    styling guides
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查遵循样式指南的流行工具的简短摘要
- en: PEP 8 and naming best practices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 8和命名最佳实践
- en: PEP 8 ([http://www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008))
    provides a style guide for writing Python code. Besides some basic rules such
    as space indentation, maximum line length, and other details concerning the code
    layout, PEP 8 also provides a section on naming conventions that most of the codebases
    follow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8（[http://www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008)）提供了编写Python代码的风格指南。除了一些基本规则，如空格缩进、最大行长度和其他有关代码布局的细节，PEP
    8还提供了一个关于命名约定的部分，大多数代码库都遵循这些约定。
- en: This section provides a quick summary of this PEP, and adds to it a naming best-practice
    guide for each kind of element. You should still consider reading of PEP 8 document
    as mandatory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了对本PEP的快速摘要，并为每种元素添加了命名最佳实践指南。您仍应考虑阅读PEP 8文件作为强制性要求。
- en: Why and when to follow PEP 8?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时以及为什么要遵循PEP 8？
- en: 'If you are creating a new software package that is intended to be open-sourced,
    then the answer is simple: always. PEP 8 is de facto the standard code style for
    most of the open source software in Python. If you want to accept any collaboration
    from other programmers, then you should definitely stick to PEP 8, even if you
    have different views on the best code style guidelines. Doing so has the benefit
    of making it a lot easier for other developers to jump straight into your project.
    Code will be easier to read for newcomers because it will be consistent in style
    with most of the other Python open source packages.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个打算开源的新软件包，那么答案很简单：始终如此。对于大多数Python开源软件来说，PEP 8实际上是标准的代码风格。如果您希望接受其他程序员的任何合作，那么您绝对应该坚持PEP
    8，即使您对最佳代码风格指南有不同的看法。这样做的好处是使其他开发人员更容易直接参与到您的项目中。对于新手来说，代码将更容易阅读，因为它在风格上与大多数其他Python开源软件包保持一致。
- en: Also, starting with full PEP 8 compliance saves you time and trouble in the
    future. If you want to release your code to the public, you will eventually face
    suggestions from fellow programmers to switch to PEP 8\. Arguments as to whether
    it is really necessary to do so for a particular project tend to be never-ending
    flame wars that are impossible to win. This is the sad truth, but you may eventually
    be forced to be consistent with this style guide in order to not lose contributors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，完全遵循PEP 8可以节省您未来的时间和麻烦。如果您想将代码发布给公众，最终您将不可避免地面临来自其他程序员的建议，要求您切换到PEP 8。关于是否真的有必要为特定项目这样做的争论往往是无休止的争论，无法取胜。这是一个悲伤的事实，但您最终可能会被迫遵循这个风格指南，以保持一致性，以免失去贡献者。
- en: Also, restyling of the whole project's codebase, if it is in a mature state
    of development, might require a tremendous amount of work. In some cases, such
    restyling might require changing almost every line of code. While most of the
    changes can be automated (indentation, newlines, and trailing whitespaces), such
    massive code overhaul usually introduces a lot of conflicts in every version control
    workflow that is based on branching. It is also very hard to review so many changes
    at once. These are the reasons why many open source projects have a rule that
    style fixing changes should always be included in separate pull/merge requests
    or patches that do not affect any feature or bug.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果项目的整个代码库处于成熟的开发状态，重新设计可能需要大量的工作。在某些情况下，这种重新设计可能需要改变几乎每一行代码。虽然大部分更改可以自动化（缩进、换行和尾随空格），但这种大规模的代码改造通常会在基于分支的每个版本控制工作流程中引入许多冲突。同时一次性审查如此多的更改也非常困难。这就是为什么许多开源项目有一个规则，即样式修复更改应始终包含在不影响任何功能或错误的单独拉取/合并请求或补丁中的原因。
- en: Beyond PEP 8 – team-specific style guidelines
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越PEP 8 - 面向团队的特定风格指南
- en: Despite providing a comprehensive set of style guidelines, PEP 8 still leaves
    some freedom for the developers. Especially in terms of nested data literals and
    multiline function calls that require long lists of arguments. Some teams may
    decide that they require additional styling rules and the best option is to formalize
    them in some kind of document that is available for every team member.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PEP 8提供了一套全面的风格指南，但仍然为开发人员留下了一些自由。特别是在嵌套数据文字和需要长参数列表的多行函数调用方面。一些团队可能决定他们需要额外的样式规则，最佳选择是将它们正式化为每个团队成员都可以访问的某种文档。
- en: Also, in some situations, it may be impossible, or economically infeasible,
    to be strictly consistent with PEP 8 in some old projects that had no style guide
    defined. Such projects will still benefit from formalization of the actual coding
    conventions even if they do not reflect the official set of PEP 8 rules. Remember,
    what is more important than consistency with PEP 8 is consistency within the project.
    If rules are formalized and available as a reference for every programmer, then
    it is way easier to keep consistency within a project and organization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，严格遵守 PEP 8 对于一些旧项目可能是不可能的，或者在经济上是不可行的，因为这些项目没有定义风格指南。即使这些项目不符合官方的
    PEP 8 规则，它们仍将受益于实际编码约定的形式化。请记住，与 PEP 8 一致性更重要的是项目内的一致性。如果规则被形式化并且对每个程序员都可用作参考，那么在项目和组织内保持一致性就会更容易。
- en: Naming styles
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名风格
- en: 'The different naming styles used in Python are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中使用的不同命名风格有：
- en: CamelCase
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰命名法
- en: mixedCase
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合大小写
- en: UPPERCASE, and UPPER_CASE_WITH_UNDERSCORES
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写字母和下划线
- en: lowercase and lower_case_with_underscores
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写和下划线小写
- en: _leading and trailing_ underscores, and sometimes __doubled__ underscores
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前导和尾随下划线，有时是双下划线
- en: Lowercase and uppercase elements are often a single word, and sometimes a few
    words concatenated. With underscores, they are usually abbreviated phrases. Using
    a single word is better. The leading and trailing underscores are used to mark
    the privacy and special elements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 小写和大写元素通常是一个单词，有时是几个单词连接在一起。使用下划线时，它们通常是缩写短语。使用一个单词更好。前导和尾随下划线用于标记隐私和特殊元素。
- en: 'These styles are applied to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些风格适用于：
- en: Variables
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Functions and methods
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和方法
- en: Properties
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Classes
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Modules
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Packages
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Variables
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'There are two kinds of variables in Python:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有两种类型的变量：
- en: Constants
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Public and private variables
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共和私有变量
- en: Constants
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: For constant global variables, an uppercase with an underscore is used. It informs
    the developer that the given variable represents a constant value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常量全局变量，使用大写字母和下划线。它告诉开发人员给定的变量表示一个常量值。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are no real constants in Python like those in C++, where `const` can be
    used. You can change the value of any variable. That's why Python uses a naming
    convention to mark a variable as a constant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中没有像 C++ 中的 `const` 那样的真正的常量。您可以更改任何变量的值。这就是为什么 Python 使用命名约定来标记变量为常量的原因。
- en: 'For example, the `doctest` module provides a list of option flags and directives
    ([https://docs.python.org/2/library/doctest.html](https://docs.python.org/2/library/doctest.html))
    that are small sentences, clearly defining what each option is intended for:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`doctest` 模块提供了一系列选项标志和指令（[https://docs.python.org/2/library/doctest.html](https://docs.python.org/2/library/doctest.html)），它们是简短的句子，清楚地定义了每个选项的用途：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These variable names seem rather long, but it is important to clearly describe
    them. Their usage is mostly located in initialization code rather than in the
    body of the code itself, so this verbosity is not annoying.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量名似乎相当长，但清楚地描述它们是很重要的。它们的使用大多位于初始化代码中，而不是代码本身的主体，因此这种冗长并不令人讨厌。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Abbreviated names obfuscate the code most of the time. Don't be afraid of using
    complete words when an abbreviation seems unclear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写名称大多数时候会使代码难以理解。当缩写不清晰时，不要害怕使用完整的单词。
- en: 'Some constants'' names are also driven by the underlying technology. For instance,
    the `os` module uses some constants that are defined on C side, such as the `EX_XXX`
    series, that defines Unix exit code numbers. The same name code can be found,
    for example, in the system''s `sysexits.h` C headers file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有些常量的名称也受到底层技术的驱动。例如，`os` 模块使用一些在 C 侧定义的常量，例如 `EX_XXX` 系列，它定义了 Unix 退出代码数字。例如，相同的名称代码可以在系统的
    `sysexits.h` C 头文件中找到：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another good practice when using constants is to gather them at the top of
    a module that uses them and combine them under new variables when they are intended
    for such operations:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用常量时的另一个好的做法是将它们收集在使用它们的模块的顶部，并在它们用于此类操作时将它们组合在新变量下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Naming and usage
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名和用法
- en: Constants are used to define a set of values the program relies on, such as
    the default configuration filename.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常量用于定义程序依赖的一组值，例如默认配置文件名。
- en: 'A good practice is to gather all the constants in a single file in the package.
    That is how Django works, for instance. A module named `settings.py` provides
    all the constants:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的做法是将所有常量收集到包中的单个文件中。例如 Django 就是这样工作的。一个名为 `settings.py` 的模块提供了所有常量：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another approach is to use a configuration file that can be parsed with the
    `ConfigParser` module, or an advanced tool such as `ZConfig`, which is the parser
    used in Zope to describe its configuration files. But some people argue that it
    is rather an overkill to use another file format in a language such as Python,
    where a file can be edited and changed as easily as a text file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用配置文件，可以使用 `ConfigParser` 模块解析，或者像 `ZConfig` 这样的高级工具，它是 Zope 中用于描述其配置文件的解析器。但有些人认为在
    Python 这样的语言中使用另一种文件格式是一种过度使用，因为文件可以像文本文件一样容易地被编辑和更改。
- en: 'For options that act like flags, a common practice is to combine them with
    Boolean operations, as the `doctest` and `re` modules do. The pattern taken from
    `doctest` is quite simple:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像标志一样的选项，一种常见的做法是将它们与布尔运算结合使用，就像 `doctest` 和 `re` 模块所做的那样。从 `doctest` 中采用的模式非常简单：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When such a new set of constants is created, avoid using a common prefix for
    them, unless the module has several sets. The module name itself is a common prefix.
    Another solution would be to use the `Enum` class from the built-in `enum` module
    and simply rely on the `set` collection instead of the binary operators. Unfortunately,
    the `Enum` class has limited applications in code that targets old Python releases
    because the `enum` module was provided in Python 3.4 version.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建这样一组新的常量时，避免为它们使用共同的前缀，除非模块有几组。模块名称本身就是一个共同的前缀。另一个解决方案是使用内置的`enum`模块中的`Enum`类，并简单地依赖于`set`集合而不是二进制运算符。不幸的是，`Enum`类在针对旧版本的Python的代码中应用有限，因为`enum`模块是在Python
    3.4版本中提供的。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using binary bit-wise operations to combine options is common in Python. The
    inclusive OR (`|`) operator will let you combine several options in a single integer,
    and the AND (`&`) operator will let you check that the option is present in the
    integer (refer to the `has_option` function).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用二进制位操作来组合选项是很常见的。包含OR（`|`）运算符将允许您将多个选项组合成单个整数，而AND（`&`）运算符将允许您检查该选项是否存在于整数中（参考`has_option`函数）。
- en: Public and private variables
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共和私有变量
- en: 'For global variables that are mutable and freely available through imports,
    a lowercase letter with an underscore should be used when they need to be protected.
    But these kinds of variables are not used frequently, since the module usually
    provides getters and setters to work with them when they need to be protected.
    A leading underscore, in that case, can mark the variable as a private element
    of the package:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变且可以通过导入自由使用的全局变量，在需要保护时应使用带下划线的小写字母。但是这种类型的变量并不经常使用，因为模块通常提供getter和setter来处理它们在需要保护时。在这种情况下，前导下划线可以将变量标记为包的私有元素：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Variables that are located in functions and methods follow the same rules, and
    are never marked as private, since they are local to the context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 位于函数和方法中的变量遵循相同的规则，并且从不标记为私有，因为它们是局部的。
- en: For class or instance variables, using the private marker (the leading underscore)
    has to be done only if making the variable a part of the public signature does
    not bring any useful information, or is redundant.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类或实例变量，只有在使变量成为公共签名的一部分不带来任何有用信息或是多余的情况下，才需要使用私有标记（前导下划线）。
- en: In other words, if the variable is used internally in the method to provide
    a public feature, and is dedicated to this role, it is better to make it private.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果变量在方法中用于提供公共功能，并且专门用于此角色，则最好将其设置为私有。
- en: 'For instance, the attributes that are powering a property are good private
    citizens:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为属性提供动力的属性是良好的私有成员：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another example would be a variable that keeps an internal state. This value
    is not useful for the rest of the code, but participates in the behavior of the
    class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是保持内部状态的变量。这个值对于代码的其余部分并不有用，但参与类的行为：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is what you will see in interactive session:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中，您将看到以下内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Functions and methods
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数和方法
- en: Functions and methods should be in lowercase with underscores. This rule was
    not always true in the old standard library modules. Python 3 did a lot of reorganizations
    to the standard library, so most of its functions and methods have a consistent
    case. Still, for some modules like `threading`, you can access the old function
    names that used *mixedCase* (for example, `currentThread`). This was left to allow
    easier backwards compatibility, but if you don't need to run your code in older
    versions of Python, then you should avoid using these old names.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法应该使用小写和下划线。在旧标准库模块中，这条规则并不总是成立。Python 3对标准库进行了大量重组，因此大多数函数和方法都具有一致的大小写。但是，对于一些模块，如`threading`，您可以访问使用*mixedCase*的旧函数名称（例如`currentThread`）。这是为了更容易地向后兼容，但如果您不需要在旧版本的Python中运行代码，那么您应该避免使用这些旧名称。
- en: This way of writing methods was common before the lowercase norm became the
    standard, and some frameworks, such as Zope and Twisted, are also using *mixedCase*
    for methods. The community of developers working with them is still quite large.
    So the choice between *mixedCase* and lowercase with an underscore is definitely
    driven by the library you are using.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在小写规范成为标准之前，编写方法的方式是很常见的，并且一些框架，如Zope和Twisted，也在使用*mixedCase*来命名方法。与他们一起工作的开发人员社区仍然相当庞大。因此，使用*mixedCase*和小写加下划线之间的选择绝对受到您使用的库的驱动。
- en: As a Zope developer, it is not easy to stay consistent because building an application
    that mixes pure Python modules and modules that import Zope code is difficult.
    In Zope, some classes mix both conventions because the code base is still evolving
    and Zope developers try to adopt the common conventions accepted by so many.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Zope开发人员，要保持一致并不容易，因为构建一个同时混合纯Python模块和导入Zope代码的应用程序是困难的。在Zope中，一些类混合了这两种约定，因为代码库仍在不断发展，Zope开发人员试图采纳被许多人接受的常见约定。
- en: A decent practice in this kind of library environment is to use *mixedCase*
    only for elements that are exposed in the framework, and to keep the rest of the
    code in PEP 8 style.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种库环境中的一个不错的做法是，仅对在框架中公开的元素使用*mixedCase*，并将其余代码保持在PEP 8风格中。
- en: It is also worth noting that developers of the Twisted project took a completely
    different approach to this problem. The Twisted project, same as Zope, predates
    the PEP 8 document. It was started when there were no official guidelines for
    code style, so it had its own. Stylistic rules about the indentation, docstrings,
    line lengths, and so on could be easily adopted. On the other hand, updating all
    the code to match naming conventions from PEP 8 would result in completely broken
    backwards compatibility. And doing that for such a large project as Twisted is
    infeasible. So Twisted adopted as much of PEP 8 as possible and left things like
    *mixedCase* for variables, functions, and methods as part of its own coding standard.
    And this is completely compatible with the PEP 8 suggestion because it specifically
    says that consistency within a project is more important than consistency with
    PEP 8 style guide.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Twisted项目的开发人员对这个问题采取了完全不同的方法。Twisted项目和Zope一样，早于PEP 8文档。它是在没有代码风格的官方指南时开始的，因此它有自己的指南。关于缩进、文档字符串、行长度等的风格规则可以很容易地采用。另一方面，将所有代码更新以匹配PEP
    8的命名约定将导致完全破坏的向后兼容性。对于如此庞大的Twisted项目来说，这是不可行的。因此，Twisted尽可能地采用了PEP 8的规范，并将*mixedCase*作为其自己的编码标准的一部分。这与PEP
    8的建议完全兼容，因为它明确指出项目内的一致性比与PEP 8风格指南的一致性更重要。
- en: The private controversy
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有争议
- en: For private methods and functions, a leading underscore is conventionally added.
    This rule was quite controversial because of the name-mangling feature in Python.
    When a method has two leading underscores, it is renamed on the fly by the interpreter
    to prevent a name collision with a method from any subclass.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于私有方法和函数，通常会添加一个前导下划线。这条规则曾经引起了很大的争议，因为Python中有名称修饰的特性。当一个方法有两个前导下划线时，解释器会即时将其重命名，以防止与任何子类的方法发生名称冲突。
- en: 'So some people tend to use a double leading underscore for their private attributes
    to avoid name collision in the subclasses:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些人倾向于在子类中使用双下划线来避免名称冲突：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The original motivation for name mangling in Python was not to provide a private
    gimmick, like in C++, but to make sure that some base classes implicitly avoid
    collisions in subclasses, especially in multiple inheritance contexts. But using
    it for every attribute obfuscates the code in private, which is not Pythonic at
    all.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python中名称修饰的最初动机不是为了提供类似C++中的私有花招，而是为了确保一些基类在子类中隐式避免冲突，特别是在多重继承的情况下。但是，将其用于每个属性会使代码在私有部分变得模糊，这完全不符合Python的风格。
- en: 'Therefore, some people opined that the explicit name mangling should always
    be used:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些人认为应始终使用显式名称修饰：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This duplicates the class name all over the code and so `__` should be preferred.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这在整个代码中重复了类名，因此应该优先使用`__`。
- en: But the best practice, as the **BDFL** (Guido, the **Benevolent Dictator For
    Life**, see [http://en.wikipedia.org/wiki/BDFL](http://en.wikipedia.org/wiki/BDFL))
    said, is to avoid using name mangling by looking at the `__mro__` (method resolution
    order) value of a class before writing a method in a subclass. Changing the base
    class private methods has to be done carefully.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，最佳实践是避免使用名称修饰，而是在编写子类方法之前查看类的`__mro__`（方法解析顺序）值。必须小心更改基类的私有方法。
- en: For more information on this topic, an interesting thread occurred in the Python-Dev
    mailing list many years ago, where people argued on the utility of name mangling
    and its fate in the language. It can be found at [http://mail.python.org/pipermail/python-dev/2005-December/058555.html](http://mail.python.org/pipermail/python-dev/2005-December/058555.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅多年前在Python-Dev邮件列表中发生的有趣讨论，人们在那里讨论了名称修饰的实用性及其在语言中的命运。可以在[http://mail.python.org/pipermail/python-dev/2005-December/058555.html](http://mail.python.org/pipermail/python-dev/2005-December/058555.html)找到。
- en: Special methods
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊方法
- en: 'Special methods ([https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names))
    start and end with a double underscore, and no normal method should use this convention.
    Some developers used to call them *dunder* methods as a portmanteau of double-underscore.
    They are used for operator overloading, container definitions, and so on. For
    the sake of readability, they should be gathered at the beginning of class definitions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法（[https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names)）以双下划线开头和结尾，普通方法不应使用此约定。一些开发人员习惯称它们为*dunder*方法，这是双下划线的混成词。它们用于操作符重载、容器定义等。为了可读性，它们应该在类定义的开头收集起来：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For a normal method, you should never use these kinds of names. So don''t invent
    a name for a method such as this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通方法，你不应该使用这种名称。因此，不要为方法发明这样的名称：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arguments
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Arguments are in lowercase, with underscores if needed. They follow the same
    naming rules as variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使用小写，如果需要则使用下划线。它们遵循与变量相同的命名规则。
- en: Properties
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'The names of properties are in lowercase, or in lowercase with underscores.
    Most of the time, they represent an object''s state, which can be a noun or an
    adjective, or a small phrase when needed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的名称为小写，或者小写加下划线。大多数情况下，它们表示对象的状态，可以是名词、形容词，或者在需要时是一个小短语：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When run on interactive session:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中运行时：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Classes
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: The names of classes are always in CamelCase, and may have a leading underscore
    when they are private to a module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类的名称始终为CamelCase，并且如果它们对模块是私有的，则可能有一个前导下划线。
- en: 'The class and instance variables are often noun phrases, and form a usage logic
    with the method names that are verb phrases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类和实例变量通常是名词短语，并且与动词短语的方法名称形成使用逻辑：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is an example usage in interactive session:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互式会话中的一个示例用法：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modules and packages
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块和包
- en: Besides the special module `__init__`, the module names are in lowercase with
    no underscores.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特殊模块`__init__`之外，模块名称都是小写的，没有下划线。
- en: 'The following are some examples from the standard library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标准库中的一些示例：
- en: '`os`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: '`sys`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`'
- en: '`shutil`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutil`'
- en: When the module is private to the package, a leading underscore is added. Compiled
    C or C++ modules are usually named with an underscore and imported in pure Python
    modules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块对包是私有的时，会添加一个前导下划线。编译的C或C++模块通常以下划线命名，并在纯Python模块中导入。
- en: Package names follow the same rules, since they act like more structured modules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称遵循相同的规则，因为它们的行为类似于更结构化的模块。
- en: The naming guide
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名指南
- en: A common set of naming rules can be applied on variables, methods, functions,
    and properties. The names of classes and modules also play an important role in
    namespace construction, and in turn in code readability. This mini-guide provides
    common patterns and antipatterns for picking their names.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一组通用的命名规则可以应用于变量、方法、函数和属性。类和模块的名称也对命名空间的构建以及代码的可读性起着重要作用。这个迷你指南提供了选择它们的名称的常见模式和反模式。
- en: Using the has or is prefix for Boolean elements
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对布尔元素使用`has`或`is`前缀
- en: 'When an element holds a Boolean value, the `is` and `has` prefixes provide
    a natural way to make it more readable in its namespace:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素持有布尔值时，`is`和`has`前缀提供了一种使其在其命名空间中更易读的自然方式：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using plurals for variables that are collections
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于持有集合的变量使用复数
- en: 'When an element is holding a collection, it is a good idea to use a plural
    form. Some mappings can also benefit from this when they are exposed like sequences:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素持有一个集合时，最好使用复数形式。当它们像序列一样被暴露时，一些映射也可以从中受益：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using explicit names for dictionaries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于字典使用显式名称
- en: 'When a variable holds a mapping, you should use an explicit name when possible.
    For example, if a `dict` holds a person''s address, it can be named `persons_addresses`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量持有一个映射时，尽可能使用显式名称。例如，如果一个`dict`持有一个人的地址，它可以被命名为`persons_addresses`：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Avoiding generic names
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用通用名称
- en: Using terms such as `list`, `dict`, `sequence`, or `elements`, even for local
    variables, is evil if your code is not building a new abstract datatype. It makes
    the code hard to read, understand, and use. Using a built-in name has to be avoided
    as well, to avoid shadowing it in the current namespace. Generic verbs should
    also be avoided, unless they have a meaning in the namespace.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码没有构建新的抽象数据类型，即使是对于局部变量，使用`list`、`dict`、`sequence`或`elements`等术语也是有害的。这使得代码难以阅读、理解和使用。还必须避免使用内置名称，以避免在当前命名空间中遮蔽它。通用动词也应该避免使用，除非它们在命名空间中有意义。
- en: 'Instead, domain-specific terms should be used:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应该使用特定于域的术语：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is also a list of prefixes and suffixes that despite being very common
    in programming should be, in fact, avoided in function and class names:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些前缀和后缀的列表，尽管它们在编程中非常常见，但实际上在函数和类名称中应该避免使用：
- en: Manager
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器
- en: Object
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Do, handle, or perform
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做、处理或执行
- en: The reason for this is that they are vague, ambiguous, and do not add any value
    to the actual name. Jeff Atwood, the co-founder of Discourse and Stack Overflow,
    has a very good article on this topic, which can be found on his blog at [http://blog.codinghorror.com/i-shall-call-it-somethingmanager/](http://blog.codinghorror.com/i-shall-call-it-somethingmanager/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是它们模糊、含糊不清，并且对实际名称没有任何价值。Discourse和Stack Overflow的联合创始人Jeff Atwood在这个主题上有一篇非常好的文章，可以在他的博客上找到[http://blog.codinghorror.com/i-shall-call-it-somethingmanager/](http://blog.codinghorror.com/i-shall-call-it-somethingmanager/)。
- en: There is also a list of package names that should be avoided. Everything that
    does not give any clue about its content can do a lot of harm to the project in
    the long term. Names such as `misc`, `tools`, `utils`, `common`, or `core` have
    a very strong tendency to become endless bags of various unrelated code pieces
    of very poor quality that seem to grow in size exponentially. In most cases, the
    existence of such a module is a sign of laziness or lack of enough design efforts.
    Enthusiasts of such module names can simply forestall the future and rename them
    to `trash` or `dumpster` because this is exactly how their teammates will eventually
    treat such modules.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些应该避免的包名称。一切不能给出关于其内容的线索的东西在长期内都会对项目造成很大的伤害。诸如`misc`、`tools`、`utils`、`common`或`core`这样的名称有很强的倾向成为各种无关代码片段的无尽袋，质量非常差，似乎呈指数增长。在大多数情况下，这样一个模块的存在是懒惰或者没有足够的设计努力的标志。这些模块名称的爱好者可以简单地预见未来，并将它们重命名为`trash`或`dumpster`，因为这正是他们的队友最终会对待这样的模块的方式。
- en: In most cases, it is almost always better to have more small modules, even with
    very little content, but with names that well reflect what is inside. To be honest,
    there is nothing inherently wrong with names such as `utils` and `common` and
    it is possible to use them responsibly. But the reality shows that in many cases
    they instead become a stub for dangerous structural antipatterns that proliferate
    very fast. And if you don't act fast enough, you may not ever be able get rid
    of them. So the best approach is simply to avoid such risky organizational patterns
    and nip them in the bud if introduced by other people working on a project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，拥有更多小模块几乎总是更好的，即使内容很少，但名称很好地反映了内部内容。老实说，像`utils`和`common`这样的名称并没有本质上的错误，而且可以负责任地使用它们。但现实表明，在许多情况下，它们反而成为危险的结构反模式的替代品，这些反模式扩散得非常快。如果你不够快地采取行动，你可能永远无法摆脱它们。因此，最好的方法就是简单地避免这种风险的组织模式，并在项目中由其他人引入时及时制止它们。
- en: Avoiding existing names
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免现有名称
- en: 'It is bad practice to use names that already exist in the context because it
    makes reading and, more specifically, debugging very confusing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中使用已经存在的名称是不好的做法，因为它会使阅读，特别是调试非常混乱：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the `os` name was shadowed by the code. Both built-ins and
    module names from the standard library should be avoided.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`os`名称被代码遮蔽了。应该避免使用内置的和标准库中的模块名称。
- en: 'Try to create original names, even if they are local to the context. For keywords,
    a trailing underscore is a way to avoid a collision:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建原始名称，即使它们只在上下文中使用。对于关键字，使用尾随下划线是避免冲突的一种方法：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that `class` is often replaced by `klass` or `cls`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`class`通常被`klass`或`cls`替换：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Best practices for arguments
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数的最佳实践
- en: 'The signatures of functions and methods are the guardians of code integrity.
    They drive its usage and build its API. Besides the naming rules that we have
    seen previously, special care has to be taken for arguments. This can be done
    through three simple rules:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法的签名是代码完整性的守护者。它们驱动其使用并构建其API。除了我们之前看到的命名规则之外，对参数还必须特别小心。这可以通过三条简单的规则来实现：
- en: Build arguments by iterative design
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过迭代设计构建参数
- en: Trust the arguments and your tests
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相信参数和你的测试
- en: Use `*args` and `**kwargs` magic arguments carefully
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用`*args`和`**kwargs`魔术参数
- en: Building arguments by iterative design
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过迭代设计构建参数
- en: Having a fixed and well-defined list of arguments for each function makes the
    code more robust. But this can't be done in the first version, so arguments have
    to be built by iterative design. They should reflect the precise use cases the
    element was created for, and evolve accordingly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个函数拥有一个固定和明确定义的参数列表使代码更加健壮。但这在第一个版本中无法完成，因此参数必须通过迭代设计构建。它们应反映元素创建的精确用例，并相应地发展。
- en: 'For instance, when some arguments are appended, they should have default values
    wherever possible, to avoid any regression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当添加一些参数时，应尽可能使用默认值，以避免任何回归：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the argument of a public element has to be changed, a deprecation process
    is to be used, which is presented later in this section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更改公共元素的参数时，应使用逐步废弃的过程，该过程将在本节后面介绍。
- en: Trust the arguments and your tests
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相信参数和你的测试
- en: 'Given the dynamic typing nature of Python, some developers use assertions at
    the top of their functions and methods to make sure the arguments have proper
    content:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python的动态类型特性，一些开发人员在其函数和方法顶部使用断言来确保参数具有适当的内容：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is often done by developers who are used to static typing and feel that
    something is missing in Python.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是由习惯于静态类型的开发人员完成的，他们觉得Python中缺少了一些东西。
- en: This way of checking arguments is a part of the **Design by Contract** (**DbC**,
    see [http://en.wikipedia.org/wiki/Design_By_Contract](http://en.wikipedia.org/wiki/Design_By_Contract))
    programming style, where preconditions are checked before the code is actually
    run.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 检查参数的这种方式是**契约设计**（**DbC**，参见[http://en.wikipedia.org/wiki/Design_By_Contract](http://en.wikipedia.org/wiki/Design_By_Contract)）编程风格的一部分，在实际运行代码之前检查前置条件。
- en: 'The two main problems with this approach are:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的两个主要问题是：
- en: DbC's code explains how it should be used, making it less readable
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DbC的代码解释了它应该如何使用，使其不太可读
- en: This can make it slower, since the assertions are made on each call
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会使其变慢，因为每次调用都会进行断言
- en: The latter can be avoided with the `"-O"` option of the interpreter. In that
    case, all assertions are removed from the code before the byte code is created,
    so that the checking is lost.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可以通过解释器的`"-O"`选项避免。在这种情况下，所有断言都会在生成字节码之前从代码中删除，因此检查会丢失。
- en: In any case, assertions have to be done carefully, and should not be used to
    bend Python to a statically typed language. The only use case for this is to protect
    the code from being called nonsensically.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，断言都必须小心使用，并且不应该用来将Python弯曲成静态类型的语言。唯一的用例是保护代码免受无意义的调用。
- en: A healthy Test-Driven Development style provides a robust base code in most
    cases. Here, the functional and unit tests validate all the use cases the code
    is created for.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 健康的测试驱动开发风格在大多数情况下提供了健壮的基础代码。在这里，功能和单元测试验证了代码创建的所有用例。
- en: When code in a library is used by external elements, making assertions can be
    useful, as the incoming data might break things up or even create damage. This
    happens for code that deals with databases or the filesystem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当库中的代码被外部元素使用时，进行断言可能是有用的，因为传入的数据可能会破坏事物，甚至造成损害。这种情况发生在处理数据库或文件系统的代码中。
- en: Another approach to this is **fuzz testing** (`http://en.wikipedia.org/wiki/Fuzz_testing`),
    where random pieces of data are sent to the program to detect its weaknesses.
    When a new defect is found, the code can be fixed to take care of that, together
    with a new test.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是**模糊测试**（`http://en.wikipedia.org/wiki/Fuzz_testing`），其中随机数据片段被发送到程序以检测其弱点。当发现新的缺陷时，可以修复代码以解决该问题，并编写新的测试。
- en: Let's take care that a code base, which follows the TDD approach, evolves in
    the right direction, and gets increasingly robust, since it is tuned every time
    a new failure occurs. When it is done in the right way, the list of assertions
    in the tests becomes similar in some way to the list of pre-conditions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保遵循TDD方法的代码库朝着正确的方向发展，并且在每次出现新的失败时进行调整，从而变得越来越健壮。当以正确的方式完成时，测试中的断言列表在某种程度上类似于前置条件的列表。
- en: Using *args and **kwargs magic arguments carefully
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨慎使用`*args`和`**kwargs`魔术参数
- en: 'The `*args` and `**kwargs` arguments can break the robustness of a function
    or method. They make the signature fuzzy, and the code often starts to build a
    small argument parser where it should not:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args`和`**kwargs`参数可能会破坏函数或方法的健壮性。它们使签名变得模糊，代码往往开始构建一个小的参数解析器，而不应该这样做：'
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the argument list gets long and complex, it is tempting to add magic arguments.
    But this is more a sign of a weak function or method that should be broken into
    pieces or refactored.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数列表变得又长又复杂，很容易添加魔术参数。但这更多地表明了一个弱函数或方法，应该被拆分或重构。
- en: 'When `*args` is used to deal with a sequence of elements that are treated the
    same way in the function, asking for a unique container argument, such as an `iterator`,
    is better:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当`*args`用于处理在函数中以相同方式处理的元素序列时，最好要求一个唯一的容器参数，比如`iterator`：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For `**kwargs`, the same rule applies. It is better to fix the named arguments
    to make the method''s signature meaningful:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`**kwargs`，同样适用相同的规则。最好修复命名参数，使方法的签名有意义：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another interesting approach is to create a container class that groups several
    related arguments to provide an execution context. This structure differs from
    `*args` or `**kwargs` because it can provide internals that work over the values
    and can evolve independently. The code that uses it as an argument will not have
    to deal with its internals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的方法是创建一个容器类，将几个相关参数分组以提供执行上下文。这种结构不同于`*args`或`**kwargs`，因为它可以提供在值上工作的内部，并且可以独立地发展。使用它作为参数的代码将不必处理其内部。
- en: 'For instance, a web request passed on to a function is often represented by
    an instance of a class. This class is in charge of holding the data passed by
    the web server:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，传递给函数的Web请求通常由类的实例表示。这个类负责保存Web服务器传递的数据：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Magic arguments cannot be avoided sometimes, especially in meta-programming.
    For instance, they are indispensable in the creation of decorators that work on
    functions with any kind of signature. More globally, anywhere where working with
    unknown data that just traverses the function, the magic arguments are great:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时无法避免使用魔术参数，特别是在元编程中。例如，在创建适用于任何类型签名的函数的装饰器时，它们是不可或缺的。更全局地，在任何处理未知数据只是遍历函数的地方，魔术参数都很棒：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Class names
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类名
- en: 'The name of a class has to be concise, precise, so that it is sufficient to
    understand from it what the class does. A common practice is to use a suffix that
    informs about its type or nature, for example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类的名称必须简洁，准确，以便从中了解类的作用。一个常见的做法是使用一个后缀来通知其类型或性质，例如：
- en: '**SQL**Engine'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL**Engine'
- en: '**Mime**Types'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mime**Types'
- en: '**String**Widget'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**Widget'
- en: '**Test**Case'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Test**Case'
- en: 'For base or abstract classes, a **Base** or **Abstract** prefix can be used
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基类或抽象类，可以使用**Base**或**Abstract**前缀，如下所示：
- en: '**Base**Cookie'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Base**Cookie'
- en: '**Abstract**Formatter'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Abstract**Formatter'
- en: 'The most important thing is to be consistent with the class attributes. For
    example, try to avoid redundancy between the class and its attributes'' names:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要与类属性保持一致。例如，尽量避免类和其属性名称之间的冗余：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Module and package names
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包名称
- en: 'The module and package names inform about the purpose of their content. The
    names are short, in lowercase, and without underscores:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包名称告知其内容的目的。名称要简短，小写，不带下划线：
- en: '`sqlite`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite`'
- en: '`postgres`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres`'
- en: '`sha1`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha1`'
- en: 'They are often suffixed with `lib` if they are implementing a protocol:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们实现了一个协议，通常会在后缀加上`lib`：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'They also need to be consistent within the namespace, so their usage is easier:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还需要在命名空间内保持一致，以便更容易使用：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, always avoid using the same name as that of one of the modules from the
    standard library.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，始终避免使用与标准库中模块之一的相同名称。
- en: When a module is getting complex, and contains a lot of classes, it is good
    practice to create a package and split the module's elements in other modules.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块变得复杂，并包含许多类时，最好的做法是创建一个包，并将模块的元素拆分到其他模块中。
- en: 'The `__init__` module can also be used to put back some APIs at the top level
    as it will not impact its usage, but will help with re-organizing the code into
    smaller parts. For example, consider the `__init__` module in a `foo` package
    with the following content:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`模块也可以用于将一些API放回顶层，因为它不会影响其使用，但会帮助重新组织代码为更小的部分。例如，考虑一个`foo`包中的`__init__`模块，其内容如下：'
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will allow users to import features directly, as shown in the following
    code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许用户直接导入功能，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But beware that this can increase your chances to get circular dependencies,
    and that the code added in the `__init__` module will be instantiated. So use
    it with care.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，这可能会增加循环依赖的机会，并且添加到`__init__`模块中的代码将被实例化。因此要小心使用。
- en: Useful tools
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的工具
- en: 'Part of the previous conventions and practices can be controlled and worked
    out with the following tools:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的惯例和做法的一部分可以通过以下工具来控制和解决：
- en: '**Pylint**: This is a very flexible source code analyzer'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pylint**：这是一个非常灵活的源代码分析器'
- en: '**pep8** and **flake8**: These are a small code style checker, and a wrapper
    that adds to it some more useful features, like static analysis and complexity
    measurement'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pep8**和**flake8**：这是一个小的代码风格检查器，以及一个添加了一些更有用功能的包装器，如静态分析和复杂度测量'
- en: Pylint
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pylint
- en: Besides some quality assurance metrics, Pylint allows you to check whether a
    given source code is following a naming convention. Its default settings correspond
    to PEP 8, and a Pylint script provides a shell report output.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些质量保证指标外，Pylint还允许您检查给定源代码是否遵循命名约定。其默认设置对应于PEP 8，Pylint脚本提供了一个shell报告输出。
- en: 'To install Pylint, you can use `pip`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Pylint，可以使用`pip`：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After this step, the command is available and can be run against a module,
    or several modules, using wildcards. Let''s try it on Buildout''s `bootstrap.py`
    script:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，该命令可用，并且可以针对一个模块或多个模块使用通配符运行。让我们在Buildout的`bootstrap.py`脚本上尝试一下：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Real Pylint's output is a bit longer and has been truncated here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的Pylint输出有点长，在这里被截断了。
- en: Notice that Pylint can give you bad rates or complaints. For instance, an import
    statement that is not used by the code of the module itself is perfectly fine
    in some cases (having it available in the namespace).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Pylint可能会给出不良评价或投诉。例如，在某些情况下，模块本身的代码没有使用的导入语句是完全可以的（在命名空间中可用）。
- en: Making calls to libraries that are using mixedCase for methods can also lower
    your rating. In any case, the global evaluation is not as important. Pylint is
    just a tool that points the possible improvements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 调用使用mixedCase方法的库也可能降低您的评级。无论如何，全局评估并不重要。Pylint只是一个指出可能改进的工具。
- en: 'The first thing to do to fine-tune Pylint is to create a `.pylinrc` configuration
    file in your projects directory, with the `–generate-rcfile` option:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 调整Pylint的第一件事是在项目目录中创建一个`.pylinrc`配置文件，使用`–generate-rcfile`选项：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This configuration file is self-documenting (every possible option is described
    with comment) and should already contain every available configuration option.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件是自我记录的（每个可能的选项都有注释描述），并且应该已经包含了每个可用的配置选项。
- en: 'Besides checking for compliance with some arbitrary coding standards, Pylint
    can also give additional information about the overall code quality, like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查是否符合某些武断的编码标准外，Pylint还可以提供有关整体代码质量的其他信息，例如：
- en: Code duplication metrics
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重复度量
- en: Unused variables and imports
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的变量和导入
- en: Missing function, method, or class docstrings
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少函数、方法或类的文档字符串
- en: Too long function signatures
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数签名太长
- en: The list of available checks that are enabled by default is very long. It is
    important to know that some of the rules are arbitrary and will not easily apply
    to every codebase. Remember that consistency is always more valuable than compliance
    with some arbitrary standards. Fortunately, Pylint is very tunable, so if your
    team uses some naming and coding conventions that are different than assumed by
    default, you can easily configure it to check for consistency with these conventions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认启用的可用检查列表非常长。重要的是要知道，其中一些规则是武断的，并不容易适用于每个代码库。记住，一致性总是比遵守某些武断标准更有价值。幸运的是，Pylint非常可调，所以如果您的团队使用的一些命名和编码约定与默认情况下假定的不同，您可以轻松配置它以检查这些约定的一致性。
- en: pep8 and flake8
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pep8和flake8
- en: '`pep8` is a tool that has only one purpose: it provides only a stylecheck against
    code conventions from PEP 8\. This is the main difference from Pylint, which has
    many additional features. This is the best option for programmers that are interested
    in automated code style checking only for PEP 8 standard, without any additional
    tool configuration, like in Pylint''s case.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`pep8`是一个只有一个目的的工具：它只提供对PEP 8标准的代码约定的样式检查。这是与Pylint的主要区别，后者具有许多其他功能。这是对于那些只对PEP
    8标准的自动化代码样式检查感兴趣的程序员来说是最佳选择，而无需进行任何额外的工具配置，就像Pylint的情况一样。'
- en: '`pep8` can be installed with `pip`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`pep8`可以通过`pip`安装：'
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When run on the Buildout''s `bootstrap.py` script, it will give a short list
    of code style violations:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Buildout的`bootstrap.py`脚本上运行时，它将给出一份代码样式违规的简短列表：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The main difference from Pylint's output is its length. `pep8` concentrates
    only on style, so it does not provide any other warning, like unused variables,
    too long function names, or missing docstrings. It also does not give any rating.
    And it really makes sense because there is no such thing as partial consistency.
    Any, even the slightest, violation of style guidelines makes the code immediately
    inconsistent.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pylint输出的主要区别在于其长度。`pep8`只集中在样式上，因此它不提供任何其他警告，例如未使用的变量、函数名太长或缺少文档字符串。它也不提供任何评级。这确实是有道理的，因为没有部分一致性这样的事情。任何，甚至是最轻微的，违反样式指南的行为都会立即使代码不一致。
- en: 'Output of `pep8` is simpler than Pylint''s and easier to parse, so it may be
    a better choice if you want to integrate it with some continuous integration solutions,
    like Jenkins. If you are missing some static analysis features, there is the `flake8`
    package that is a wrapper on `pep8` and few other tools that is easily extendable
    and provides a more extensive suite of features:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`pep8`的输出比Pylint更简单，更容易解析，因此如果您想将其与一些持续集成解决方案（如Jenkins）集成，它可能是更好的选择。如果您缺少一些静态分析功能，还有`flake8`包，它是`pep8`和其他几个工具的包装器，易于扩展，并提供更广泛的功能套件：'
- en: McCabe complexity measurement
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: McCabe复杂度测量
- en: Static analysis via `pyflakes`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`pyflakes`进行静态分析
- en: Disabling whole files or single lines using comments
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注释禁用整个文件或单行
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained the most accepted coding conventions by pointing to the
    official Python style guide (the PEP 8 document). The official style guide was
    complemented by some naming suggestions that will make your future code more explicit,
    and also a few useful tools that are indispensable in keeping the code style consistent.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过指向官方Python样式指南（PEP 8文档）来解释了最受欢迎的编码约定。官方样式指南还补充了一些命名建议，这些建议将使您未来的代码更加明确，还有一些在保持代码风格一致方面不可或缺的有用工具。
- en: All of this prepares us for the first practical topic of the book—writing and
    distributing packages. In the next chapter we will learn how to publish our very
    own package on a public PyPI repository, and also how to leverage the power of
    the packaging ecosystem in your private organization.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都为我们准备了本书的第一个实际主题——编写和分发软件包。在下一章中，我们将学习如何在公共PyPI存储库上发布我们自己的软件包，以及如何在您的私人组织中利用包装生态系统的力量。
