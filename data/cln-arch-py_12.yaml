- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Adding Web UI: Clean Architecture’s Interface Flexibility'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Web UI：纯净架构的接口灵活性
- en: In previous chapters, we established Clean Architecture’s foundational patterns
    through our task management system. We built domain entities, implemented use
    cases, and created a command line interface (CLI) that demonstrated how Clean
    Architecture’s boundaries enable clear separation between our core business logic
    and user interfaces. While the CLI provides a functional interface, many applications
    require web-based access. This presents an excellent opportunity to show how Clean
    Architecture’s principles enable interface evolution without compromising architectural
    integrity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过任务管理系统建立了纯净架构的基础模式。我们构建了领域实体，实现了用例，并创建了一个命令行界面（CLI），展示了纯净架构的边界如何使我们的核心业务逻辑和用户界面之间的分离变得清晰。虽然CLI提供了一个功能接口，但许多应用程序需要基于Web的访问。这为我们展示了纯净架构的原则如何在不损害架构完整性的情况下实现接口进化提供了极好的机会。
- en: 'Through our task management system, we’ll demonstrate one of Clean Architecture’s
    key benefits: the ability to add new interfaces without modifying existing code.
    Because our domain logic, use cases, and controllers were built with proper architectural
    boundaries, adding a web interface becomes a purely additive exercise. No refactoring
    of existing components is required. This same principle that makes adding a web
    UI straightforward also enables long-term maintenance of multiple interfaces,
    as each can evolve independently while sharing the same robust core.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的任务管理系统，我们将展示纯净架构的关键优势之一：在不修改现有代码的情况下添加新接口的能力。因为我们的领域逻辑、用例和控制器都是基于适当的架构边界构建的，添加一个网络接口就变成了一项纯粹的增加性练习。不需要对现有组件进行重构。这个使得添加网络用户界面变得简单的相同原则，也使得长期维护多个接口成为可能，因为每个接口都可以独立进化，同时共享相同的强大核心。
- en: By the end of this chapter, you’ll understand how to implement additional interfaces
    while maintaining architectural boundaries. You’ll be able to apply these patterns
    to your own projects, ensuring your applications remain adaptable as interface
    requirements evolve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在保持架构边界的同时实现额外的接口。你将能够将这些模式应用到自己的项目中，确保你的应用程序在接口需求进化时保持适应性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将涵盖以下主要主题：
- en: Understanding interface flexibility in Clean Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在纯净架构中理解接口灵活性
- en: Web presentation patterns in Clean Architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯净架构中的Web展示模式
- en: Integrating Flask with Clean Architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Flask与纯净架构集成
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    have been tested with Python 3.13\. For brevity, most code examples in the chapter
    are only partially implemented. Complete versions of all examples can be found
    in the book’s accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分展示的代码示例已在Python 3.13上进行了测试。为了简洁，本章中的大多数代码示例仅部分实现。所有示例的完整版本可以在本书配套的GitHub存储库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: Understanding interface flexibility in Clean Architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在纯净架构中理解接口灵活性
- en: 'Our task management system’s CLI (implemented in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168)),
    demonstrates Clean Architecture’s careful separation between core business logic
    and user interfaces. This separation wasn’t just good practice—it was strategic
    preparation for exactly what we’ll accomplish in this chapter: adding a completely
    new user interface while preserving our existing functionality.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理系统CLI（在[*第7章*](Chapter_07.xhtml#_idTextAnchor168)中实现），展示了纯净架构在核心业务逻辑和用户界面之间的谨慎分离。这种分离不仅是一种良好的实践，而且是为我们将在本章中完成的具体任务进行的战略准备：在保留现有功能的同时添加一个全新的用户界面。
- en: Understanding our web implementation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解我们的Web实现
- en: To implement our web interface, we’ll use **Flask**—a lightweight and flexible
    Python web framework. Flask’s explicit request handling and straightforward application
    structure make it ideal for demonstrating Clean Architecture’s boundaries. Its
    minimal core and extensive ecosystem of optional extensions align well with Clean
    Architecture’s preference for explicit dependencies. While the patterns we’ll
    explore would work equally well with Django, FastAPI, or other web frameworks,
    Flask’s simplicity helps keep our focus on architectural principles rather than
    framework-specific features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的网页界面，我们将使用**Flask**——一个轻量级且灵活的Python网页框架。Flask的明确请求处理和直接的应用程序结构使其非常适合展示清洁架构的边界。其最小核心和广泛的可选扩展生态系统与清洁架构对显式依赖的偏好相吻合。虽然我们将探索的图案同样适用于Django、FastAPI或其他网页框架，但Flask的简单性有助于我们将重点放在架构原则而不是框架特定功能上。
- en: 'Through a browser-based interface, users can now manage their projects and
    tasks with familiar workflows enhanced by web-specific capabilities. When a user
    visits the application, they’re presented with their projects and associated tasks
    in a clean, hierarchical view:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于浏览器的界面，用户现在可以使用熟悉的、由网页特定功能增强的工作流程来管理他们的项目和任务。当用户访问应用程序时，他们会看到一个干净、分层的视图，展示他们的项目和相关的任务：
- en: '![Figure 9.1: Web UI listing page showing projects and their associated tasks](img/B31577_09_1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：Web UI列表页面，显示项目和它们相关的任务](img/B31577_09_1.png)'
- en: 'Figure 9.1: Web UI listing page showing projects and their associated tasks'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Web UI列表页面，显示项目和它们相关的任务
- en: The web interface enhances our existing task management capabilities through
    immediate visual feedback and intuitive navigation. Users can create new tasks,
    update their status, and organize them within projects. The interface adapts our
    existing business logic to web conventions, using standard patterns such as form
    submissions for task creation and flash messages for user feedback.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网页界面通过即时视觉反馈和直观的导航增强了我们现有的任务管理功能。用户可以创建新的任务，更新它们的状态，并在项目中组织它们。界面将我们的现有业务逻辑适配到网页惯例，使用标准模式，如表单提交用于任务创建和闪存消息用于用户反馈。
- en: 'To implement this interface while maintaining our architectural boundaries,
    our web implementation is organized into distinct components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在保持我们的架构边界的同时实现此界面，我们的网页实现被组织成不同的组件：
- en: '![Figure 9.2: Associated files for the Web UI implementation](img/B31577_09_2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：Web UI实现的相关文件](img/B31577_09_2.png)'
- en: 'Figure 9.2: Associated files for the Web UI implementation'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Web UI实现的相关文件
- en: This structure demonstrates Clean Architecture’s separation of concerns in action.
    In our Adapters and Interfaces (`interfaces`) layer, the web presenters know how
    to format data for web display by creating HTML-friendly strings and structuring
    data for templates, but remain completely unaware of Flask or any specific web
    framework. These presenters could work equally well with Django, FastAPI, or any
    other web framework.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构展示了清洁架构在实际操作中的关注点分离。在我们的适配器和接口(`interfaces`)层，网页展示者知道如何通过创建HTML友好的字符串和为模板结构化数据来格式化数据以供网页显示，但完全不了解Flask或任何特定的网页框架。这些展示者可以同样好地与Django、FastAPI或任何其他网页框架一起工作。
- en: This separation stands in stark contrast to applications built without clear
    architectural boundaries. In a less structured application, a request to *add
    a web interface* often triggers a cascade of changes throughout the codebase.
    Business logic mixed with presentation concerns requires extensive refactoring.
    Database queries embedded in display logic need restructuring. Even seemingly
    simple changes like formatting dates for web display can require modifications
    across multiple components. In extreme cases, teams find themselves essentially
    rewriting their application to accommodate the new interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离与没有明确架构边界的应用程序形成鲜明对比。在一个结构较松散的应用程序中，对*添加网页界面*的请求往往会触发代码库中的连锁反应。业务逻辑与展示关注点的混合需要大量的重构。嵌入在展示逻辑中的数据库查询需要重新构建。即使是像为网页显示格式化日期这样的看似简单的更改，也可能需要在多个组件中进行修改。在极端情况下，团队发现自己实际上在重写他们的应用程序以适应新的界面。
- en: 'Our task management system, by contrast, treats the web interface as a purely
    additive change. No existing code needs modification: not our business rules,
    not our use cases, not even our CLI. This ability to add major features without
    disturbing existing functionality demonstrates Clean Architecture’s practical
    value in evolving systems.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们的任务管理系统将Web界面视为纯粹的增加性变化。不需要修改现有代码：既不是我们的业务规则，也不是我们的用例，甚至不是我们的CLI。这种在不干扰现有功能的情况下添加主要功能的能力，展示了Clean
    Architecture在系统演变中的实际价值。
- en: The framework-specific code lives where it belongs—in the `infrastructure/web`
    directory within our Frameworks and Drivers layer. Here, Flask-specific concerns
    like route handling, template configuration, and HTTP session management stay
    isolated at the edges of our system. This separation means we could switch web
    frameworks without touching our interface adapters or core business logic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 框架特定的代码位于它所属的位置——在我们的框架和驱动层中的`infrastructure/web`目录内。在这里，Flask特定的关注点，如路由处理、模板配置和HTTP会话管理，保持在我们系统边缘的隔离。这种分离意味着我们可以在不触及我们的接口适配器或核心业务逻辑的情况下切换Web框架。
- en: Parallel interface implementations
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行接口实现
- en: Before diving into our web implementation details, let’s examine how our CLI
    and web interfaces coexist within our Clean Architecture system. While these interfaces
    serve users through very different mechanisms (command line versus HTTP), they
    share the same core components and follow identical architectural patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究我们的Web实现细节之前，让我们检查我们的CLI和Web界面如何在Clean Architecture系统中共存。虽然这些界面通过非常不同的机制（命令行与HTTP）为用户提供服务，但它们共享相同的核心组件并遵循相同的建筑模式。
- en: '![Figure 9.3: Request flow comparison](img/B31577_09_3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：请求流比较](img/B31577_09_3.png)'
- en: 'Figure 9.3: Request flow comparison'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：请求流比较
- en: 'This diagram illustrates how our architecture maintains clear boundaries while
    supporting multiple interfaces:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此图说明了我们的架构如何在支持多个接口的同时保持清晰的边界：
- en: '**CLI** transforms command-line input through Click Command Handler'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLI**通过Click命令处理器转换命令行输入'
- en: '**Web interface** processes HTTP requests via Flask Route Handler'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web界面**通过Flask路由处理器处理HTTP请求'
- en: '**Shared core** contains our Task Controller, Use Cases, and Entities'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享核心**包含我们的任务控制器、用例和实体'
- en: Clean Architecture enables this coexistence through strict dependency rules.
    Both interface handlers connect to the same task controller, but the core components
    remain completely unaware of how they’re being used. This isolation means our
    core business logic can focus on task creation rules while each interface handles
    its specific concerns, whether that’s parsing command-line arguments or processing
    form submissions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture通过严格的依赖规则实现了这种共存。两个接口处理器连接到同一个任务控制器，但核心组件完全不知道它们是如何被使用的。这种隔离意味着我们的核心业务逻辑可以专注于任务创建规则，而每个接口处理其特定的关注点，无论是解析命令行参数还是处理表单提交。
- en: 'To implement this separation, we use a pragmatic dependency injection approach
    through our Application container:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，我们通过应用程序容器使用实用的依赖注入方法：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how each component is declared using abstract interfaces (`TaskRepository`,
    `NotificationPort`, etc.). This enables each interface implementation to provide
    its own specific dependencies while our application core remains unaware of the
    concrete implementations it will receive. The application factory demonstrates
    how this flexibility works in practice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个组件是如何使用抽象接口（`TaskRepository`、`NotificationPort`等）声明的。这使每个接口实现能够提供其自己的特定依赖，而我们的应用程序核心仍然不知道它将接收的具体实现。应用程序工厂展示了这种灵活性在实际中的工作方式。
- en: 'Our application factory implements Clean Architecture’s composition root pattern
    which serves as the single point where we compose our interface-agnostic core
    with interface-specific implementations. The factory demonstrates two key architectural
    principles:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序工厂实现了Clean Architecture的组成根模式，它作为唯一的点，将我们的接口无关的核心与接口特定的实现组合在一起。工厂展示了两个关键的建筑原则：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, the factory demonstrates Clean Architecture’s Dependency Inversion Principle
    in action: interface-specific components (presenters) are passed in as parameters,
    while core infrastructure (repositories) is constructed internally. This separation
    means interface implementations can provide their own presenters while the factory
    ensures everything connects properly to our shared business core.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，工厂展示了清洁架构的依赖倒置原则在实际中的应用：接口特定的组件（展示者）作为参数传递，而核心基础设施（存储库）是内部构建的。这种分离意味着接口实现可以提供自己的展示者，而工厂确保一切都能正确连接到我们的共享业务核心。
- en: Second, the factory serves as the composition root that functions as the single
    point where abstract interfaces meet their concrete implementations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，工厂作为组合根，是抽象接口与其具体实现相遇的唯一点。
- en: 'Our CLI application demonstrates this adaptability to different interfaces.
    At the application boundary, we wire together our shared core with CLI-specific
    components:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CLI应用程序展示了这种对不同接口的适应性。在应用程序边界，我们将共享的核心与CLI特定的组件连接起来：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note how `main()` configures a CLI-specific application instance by providing
    interface-specific implementations (`CliTaskPresenter`, `CliProjectPresenter`)
    to our generic application container. The `ClickCli` class then wraps this core
    application, handling the translation between command-line interactions and our
    application’s interface-agnostic operations. This pattern of wrapping interface-specific
    code around our core application is a fundamental Clean Architecture practice
    that we’ll see mirrored in our web implementation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`main()`如何通过提供接口特定的实现（`CliTaskPresenter`，`CliProjectPresenter`）到我们的通用应用程序容器来配置CLI特定的应用程序实例。然后`ClickCli`类包装这个核心应用程序，处理命令行交互与我们的应用程序接口无关的操作。围绕我们的核心应用程序包装接口特定代码的模式是清洁架构的基本实践，我们将在Web实现中看到其镜像。
- en: 'By setting up our application this way, we’ve established a clear pattern for
    how new interfaces connect to our core application. To add our web interface,
    we’ll need to implement analogous components that fulfill the same roles but for
    web-specific concerns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式设置我们的应用程序，我们建立了一个清晰的模式，说明新的接口如何连接到我们的核心应用程序。要添加我们的Web接口，我们需要实现类似的角色，但针对Web特定的关注点：
- en: '**Presentation layer**: implementing `WebTaskPresenter` for HTML templates'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示层**：为HTML模板实现`WebTaskPresenter`'
- en: '**Request handling**: processing form submissions and URL parameters'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求处理**：处理表单提交和URL参数'
- en: '**Session state**: managing persistence between requests'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话状态**：管理请求之间的持久性'
- en: '**User feedback**: implementing web-specific error presentation'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户反馈**：实现Web特定的错误展示'
- en: The key insight is that all interface-specific concerns remain at the edges
    of our system. Each interface handles its own unique requirements, such as web
    session management or CLI argument parsing, while our core business logic remains
    focused and clean.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的洞见在于所有与接口相关的关注点都保持在我们的系统边缘。每个接口处理其独特的需求，例如Web会话管理或CLI参数解析，而我们的核心业务逻辑保持专注且清晰。
- en: In the next section, we’ll explore specific presentation patterns for web interfaces,
    seeing how these same principles that kept our CLI implementation clean can guide
    us in creating maintainable web-specific components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨特定于Web界面的展示模式，看看这些保持了CLI实现清洁的相同原则如何指导我们创建可维护的特定于Web的组件。
- en: Common interface boundary violations
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的接口边界违规
- en: 'Clean Architecture’s effectiveness depends on maintaining clear boundaries
    between layers. A common violation occurs when developers allow interface-specific
    formatting to creep into controllers, creating problematic dependencies that flow
    in the wrong direction. Consider this anti-pattern:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的有效性取决于在层之间保持清晰的边界。一个常见的违规行为是当开发者允许接口特定的格式渗透到控制器中，从而产生错误的方向依赖。考虑以下反模式：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This implementation violates Clean Architecture’s Dependency Rule in a subtle
    but important way. The controller, which lives in our Interface Adapters layer,
    directly references Click (a framework that should be constrained to our outermost
    layer). This creates a problematic coupling, for our controller now depends on
    both the Application layer (inward) and the Frameworks layer (outward), breaking
    Clean Architecture’s fundamental rule that dependencies should only point inward.
    Beyond the architectural violation, this coupling has practical consequences:
    we couldn’t reuse this controller for our web interface, and even updating to
    a newer version of Click would require changes in our Interface Adapters layer.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式在微妙但重要的方式上违反了清洁架构的依赖规则。控制器位于我们的接口适配器层，直接引用Click（一个应该限制在我们最外层框架的框架）。这造成了一个问题耦合，因为我们的控制器现在既依赖于应用层（内部）又依赖于框架层（外部），违反了清洁架构的基本规则，即依赖关系应该只指向内部。除了架构违规之外，这种耦合还有实际后果：我们无法重用这个控制器来处理我们的Web界面，而且即使更新到Click的新版本，也需要在我们的接口适配器层进行更改。
- en: 'Instead, our task management system correctly delegates all formatting concerns
    to interface-specific presenters. Notice how our controller depends only on the
    abstract Presenter interface. It has no knowledge of whether it’s working with
    CLI, web, or any other concrete presenter implementation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们的任务管理系统正确地将所有格式化问题委托给特定于接口的展示者。注意我们的控制器只依赖于抽象的`展示者`接口。它不知道它是在与命令行界面（CLI）、Web界面还是任何其他具体的展示者实现工作：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This corrected implementation demonstrates several Clean Architecture principles:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修正后的实现展示了几个清洁架构的原则：
- en: The controller accepts simple types (`str`) rather than framework-specific structures
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器接受简单类型（`str`）而不是特定于框架的结构
- en: Error handling produces framework-agnostic `OperationResult` instances
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理产生无框架的`OperationResult`实例
- en: All formatting is delegated to the abstract `presenter` interface
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有格式化都委托给抽象的`presenter`接口
- en: The controller remains focused on coordinating between use cases and presentation
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器始终专注于协调用例和展示层之间的工作
- en: This approach yields significant practical benefits. With our clean implementation,
    framework changes only affect the outermost layer. We could replace Click with
    another CLI framework by simply implementing new adapters without touching our
    controllers, use cases, or domain logic. The same controller handles requests
    identically regardless of whether they originate from our CLI, web interface,
    or any future interface we might add.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了显著的实际效益。在我们的清洁实现中，框架更改只会影响最外层。我们可以通过简单地实现新的适配器来替换Click，而不必触及我们的控制器、用例或领域逻辑。相同的控制器可以以相同的方式处理请求，无论这些请求是从我们的CLI、Web界面还是我们可能添加的任何未来界面发起。
- en: The Interface Adapters layer acts as a protective boundary, transforming data
    between our domain core and external interfaces. This architectural boundary enables
    us to add a web interface without disrupting existing components. Our domain entities
    focus solely on business rules while interface-specific concerns remain properly
    isolated at the system edges.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接口适配器层充当保护边界，在领域核心和外部接口之间转换数据。这个架构边界使我们能够在不破坏现有组件的情况下添加Web界面。我们的领域实体专注于业务规则，而特定于接口的关注点则被适当地隔离在系统边缘。
- en: Now that we’ve established how Clean Architecture’s boundaries enable interface
    flexibility, let’s examine the specific presentation patterns needed for web interfaces
    and how they maintain these same architectural principles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了清洁架构的边界如何使接口具有灵活性，那么让我们来检查为Web界面所需的特定展示模式以及它们如何保持相同的架构原则。
- en: Web presentation patterns in Clean Architecture
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构中的Web展示模式
- en: 'Having established how Clean Architecture enables interface flexibility, we
    now turn to the specific patterns needed for web presentation. While our CLI directly
    formatted data for console output, web interfaces must handle more complex presentation
    requirements: formatting data for HTML templates, managing state across multiple
    requests, and providing user feedback through form validation and flash messages
    (temporary notification banners that appear at the top of the page after an action,
    like the green success message shown in *Figure 9.1*). This section explores these
    web-specific challenges and shows how Clean Architecture’s boundaries guide our
    implementation choices.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了Clean Architecture如何实现界面灵活性之后，我们现在转向网络展示所需的具体模式。虽然我们的CLI直接格式化数据以供控制台输出，但网络界面必须处理更复杂的展示需求：为HTML模板格式化数据、跨多个请求管理状态，以及通过表单验证和闪存消息（在页面顶部显示的临时通知横幅，如*图9.1*中显示的绿色成功消息）提供用户反馈。本节将探讨这些特定于网络的挑战，并展示Clean
    Architecture的边界如何指导我们的实现选择。
- en: We’ll examine how web-specific presenters format domain data for HTML display,
    ensuring our templates receive properly structured information. We’ll see how
    state management across requests can respect Clean Architecture’s boundaries,
    and how form handling can maintain separation between web concerns and business
    rules. Through these patterns, we’ll demonstrate that web interfaces, despite
    their complexity, can integrate cleanly with our existing architecture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查特定于网络的演示者如何格式化域数据以供HTML显示，确保我们的模板接收适当结构化的信息。我们将看到如何跨请求的状态管理可以尊重Clean Architecture的边界，以及如何表单处理可以保持网络关注点和业务规则之间的分离。通过这些模式，我们将展示尽管网络界面复杂，但它们可以干净地与我们的现有架构集成。
- en: Implementing web-specific presenters
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现特定于网络的演示者
- en: 'To bridge our domain logic and web display requirements, we need presenters
    that understand web conventions. To understand how our web presenter should work,
    let’s first examine our CLI presenter from [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168).
    Notice how it encapsulates all CLI-specific formatting decisions (bracketed status,
    colored priorities) while maintaining a clean interface through `TaskViewModel`.
    This established pattern of transforming domain objects into interface-appropriate
    view models will guide our web implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接我们的域逻辑和网络展示需求，我们需要理解网络约定的演示者。为了了解我们的网络演示者应该如何工作，让我们首先检查[*第7章*](Chapter_07.xhtml#_idTextAnchor168)中的CLI演示者。注意它如何封装所有CLI特定的格式化决策（括号中的状态、彩色优先级）同时通过`TaskViewModel`保持一个干净的界面。这种将域对象转换为适合界面的视图模型的模式将指导我们的网络实现：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our web presenter follows the same pattern but adapts the formatting for HTML
    display:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络演示者遵循相同的模式，但适应HTML显示的格式化：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice how the `WebTaskPresenter` class provides additional fields and formatting
    specific to web display needs: HTML-friendly status values, date formatting for
    browser display, and structured completion information for template rendering.
    This implementation demonstrates how Clean Architecture’s presenters serve as
    a systematic translation layer between domain concepts and presentation needs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`WebTaskPresenter`类如何提供针对网络显示需求额外的字段和格式：HTML友好的状态值、浏览器显示的日期格式，以及用于模板渲染的结构化完成信息。这种实现展示了Clean
    Architecture的演示者如何作为域概念和展示需求之间的系统化翻译层：
- en: Translates domain objects into interface-appropriate formats while preserving
    their business meaning
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将域对象转换为适合界面的格式，同时保留其业务意义
- en: Centralizes all presentation decisions in a single, testable component
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有展示决策集中在一个单一、可测试的组件中
- en: Enables each interface to adapt domain data according to its specific needs
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使每个接口能够根据其特定需求适应域数据
- en: Maintains clear separation between domain logic and display concerns
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在域逻辑和展示关注点之间保持清晰的分离
- en: 'The presenter doesn’t just format data; it serves as the authoritative interpreter
    of how domain concepts should appear in the interface. Consider our date formatting
    method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 演示者不仅格式化数据；它作为域概念在界面中呈现的权威解释者。考虑我们的日期格式化方法：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `_format_due_date` method encapsulates all date-related formatting decisions:
    time zone handling, date format strings, and overdue status checks. By containing
    these decisions in the presenter, we ensure our domain entities remain focused
    on business rules (when a task is due) while presentation concerns (how to display
    that due date) stay in the appropriate architectural layer.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`_format_due_date`方法封装了所有与日期相关的格式化决策：时区处理、日期格式字符串和逾期状态检查。通过将这些决策包含在演讲者中，我们确保我们的领域实体保持专注于业务规则（何时完成任务）同时，展示关注点（如何显示到期日期）保持在适当的架构层。'
- en: 'This translation layer allows our templates to remain simple while still delivering
    rich, contextual information:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个翻译层允许我们的模板保持简单，同时仍然提供丰富、上下文相关的信息：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The template exemplifies Clean Architecture’s separation of concerns in action:
    it focuses purely on HTML structure and styling decisions based on pre-formatted
    values. All business logic (`datetime` comparisons) and data formatting remain
    in the appropriate architectural layers. The template simply adapts the presenter’s
    output for visual display, using simple string checks to apply appropriate CSS
    classes.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模板展示了Clean Architecture在操作中的关注点分离：它纯粹关注HTML结构和基于预格式化值的样式决策。所有业务逻辑（`datetime`比较）和数据格式化都保留在适当的架构层。模板只是简单地调整演讲者的输出以进行视觉显示，使用简单的字符串检查来应用适当的CSS类。
- en: 'Just as in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192), we can verify
    this formatting logic through focused unit tests. This test demonstrates a key
    benefit of Clean Architecture’s separation of concerns: we can verify our presentation
    logic in isolation, without any web framework dependencies. By testing against
    the presenter directly, we can ensure that our date formatting logic works correctly
    without setting up a full web environment. The test focuses purely on the transformation
    from domain data to presentation format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第[*第8章*](Chapter_08.xhtml#_idTextAnchor192)中一样，我们可以通过集中的单元测试来验证这个格式化逻辑。这个测试展示了Clean
    Architecture关注点分离的关键好处：我们可以独立验证我们的展示逻辑，而不需要任何Web框架依赖。通过直接针对演讲者进行测试，我们可以确保我们的日期格式化逻辑正确无误，而无需设置完整的Web环境。测试纯粹关注从领域数据到展示格式的转换：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This test demonstrates how Clean Architecture’s separation enables precise
    verification of our web formatting logic. We can test complex scenarios, like
    overdue dates, without any web framework setup. The same pattern applies to future
    dates:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试展示了Clean Architecture的关注点分离如何使我们能够精确验证我们的Web格式化逻辑。我们可以测试复杂的场景，如逾期日期，而无需任何Web框架设置。相同的模式适用于未来日期：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This complementary test ensures that our presenter handles future dates appropriately,
    completing our verification of the date formatting logic. Together with the previous
    test, we’ve confirmed both the presence and absence of the ‘Overdue’ indicator,
    all without touching any web framework code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个互补的测试确保我们的演讲者适当地处理未来日期，完成了我们对日期格式化逻辑的验证。与之前的测试一起，我们确认了“逾期”指示器的存在和不存在，所有这些都不需要接触任何Web框架代码。
- en: These tests highlight key benefits of Clean Architecture’s presenter pattern.
    Our formatting logic can be verified without complex web setup. No need for Flask
    test clients, mock databases, or HTML parsing. Changes to date formatting can
    be tested quickly and precisely, while our templates remain focused purely on
    display concerns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试突出了Clean Architecture的演讲者模式的优点。我们的格式化逻辑可以在不复杂的网络设置下得到验证。无需Flask测试客户端、模拟数据库或HTML解析。日期格式的更改可以快速、精确地测试，同时我们的模板仍然专注于显示问题。
- en: This pattern extends across all domain concepts, from task status to priority
    levels, ensuring consistent translation of business objects into presentation-ready
    formats. Any template in our system can display task due dates without knowing
    how those dates are formatted. More importantly, as our formatting logic evolves
    with additions such as time zone support or new display formats, we only need
    to update the presenter and its tests. Our templates, controllers, and domain
    logic remain unchanged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式跨越了所有领域概念，从任务状态到优先级级别，确保业务对象到展示格式的持续转换。我们系统中的任何模板都可以显示任务到期日期，而无需知道这些日期是如何格式化的。更重要的是，随着我们的格式化逻辑随着时区支持或新的显示格式等添加而发展，我们只需要更新演讲者和其测试。我们的模板、控制器和领域逻辑保持不变。
- en: Presenters versus template-based formatting
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演讲者与基于模板的格式化
- en: 'Developers familiar with modern web frameworks like React, Vue, or template-oriented
    patterns in Flask/Django might question our separation of formatting logic into
    presenters. Many applications embed formatting directly in templates:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉现代Web框架（如React、Vue）或Flask/Django中的模板导向模式的开发者可能会质疑我们将格式化逻辑分离到展示器中的做法。许多应用程序直接在模板中嵌入格式化：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While this pattern is widespread, it blurs the boundary between presentation
    decisions and display structure. In Clean Architecture, we recognize formatting
    as a translation concern that belongs in the Interface Adapters layer, not in
    the templates themselves.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种模式很普遍，但它模糊了展示决策和显示结构之间的界限。在清洁架构中，我们将格式化视为属于接口适配器层的翻译关注点，而不是模板本身。
- en: 'Even when working with template-oriented frameworks, Clean Architecture principles
    can still guide implementation decisions by:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在与模板导向框架一起工作时，清洁架构的原则仍然可以通过以下方式指导实现决策：
- en: Recognizing where business decisions are leaking into templates
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到业务决策是如何泄漏到模板中的
- en: Extracting formatting logic into dedicated components
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将格式化逻辑提取到专用组件中
- en: Treating templates purely as display structure
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模板纯粹视为显示结构
- en: 'The fundamental architectural principle remains the same: maintain clear boundaries
    between layers. Whether implemented through our explicit presenter pattern or
    through template helpers and components, the goal is to ensure that domain concepts
    are properly translated before they reach the outermost display layer.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基本架构原则保持不变：在层之间保持清晰的边界。无论是通过我们的显式展示器模式还是通过模板辅助程序和组件来实现，目标都是确保在它们达到最外层的显示层之前，领域概念得到适当的转换。
- en: Managing web-specific state
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Web特定的状态
- en: 'Session data and form state present unique challenges for maintaining Clean
    Architecture’s boundaries. Let’s examine how our system handles these web-specific
    concerns while keeping our core domain logic pure. Consider this anti-pattern
    where a domain entity directly accesses web session data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 会话数据和表单状态为维护清洁架构的边界带来了独特的挑战。让我们看看我们的系统是如何在保持核心领域逻辑纯净的同时处理这些特定的Web关注点的。考虑以下反模式，其中领域实体直接访问Web会话数据：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This demonstrates how mixing web concerns into domain entities creates multiple
    maintenance challenges:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了将Web关注点混合到领域实体中如何创造多个维护挑战：
- en: Testing requires mocking web session data even for basic domain logic
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试需要模拟基本的领域逻辑的Web会话数据
- en: Adding new interfaces means updating entity code rather than just adding adapters
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新接口意味着更新实体代码，而不仅仅是添加适配器
- en: Session handling bugs can ripple through the entire Domain layer
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话处理错误可能会在整个领域层中传播
- en: Entity behavior becomes dependent on web framework implementation details
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体行为变得依赖于Web框架的实现细节
- en: 'Our Flask route handlers act as the architectural boundary where web-specific
    concerns are managed. They translate HTTP concepts into domain-agnostic operations
    while keeping web state management where it belongs:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flask路由处理程序充当了架构边界，在这里管理Web特定的关注点。它们将HTTP概念转换为领域无关的操作，同时保持Web状态管理在其所属的位置：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This handler exemplifies Clean Architecture’s boundary management in action.
    At this outer edge of our system, the route captures and processes web-specific
    state like the `show_completed` preference, translating HTTP concepts into domain-agnostic
    operations. Instead of allowing domain entities to access session data directly,
    the handler extracts only the necessary information before passing it to our core
    business logic. Web-specific concerns such as user feedback through flash messages
    and template rendering stay in this outer layer, while our domain logic remains
    focused purely on its core responsibilities.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序展示了清洁架构边界管理的实际应用。在我们系统的这个外围边缘，路由捕获并处理Web特定的状态，如`show_completed`偏好，将HTTP概念转换为领域无关的操作。而不是允许领域实体直接访问会话数据，处理程序在传递给我们的核心业务逻辑之前只提取必要的信息。Web特定的关注点，如通过闪存消息的用户反馈和模板渲染，保持在这一外围层，而我们的领域逻辑则专注于其核心职责。
- en: Form handling and validation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单处理和验证
- en: 'Form submissions in web applications present an architectural challenge. A
    common anti-pattern is to spread validation logic across templates, controllers,
    and domain entities, making it difficult to maintain and evolve validation rules.
    Let’s examine how Clean Architecture guides us to handle forms appropriately using
    a simple project creation form:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，表单提交提出了一个架构挑战。一个常见的反模式是在模板、控制器和领域实体之间分散验证逻辑，这使得维护和演进验证规则变得困难。让我们看看
    Clean Architecture 如何指导我们适当地处理表单，以一个简单的项目创建表单为例：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The route handler demonstrates Clean Architecture’s validation flow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序展示了 Clean Architecture 的验证流程：
- en: 'The route extracts web-specific inputs:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由提取 Web 特定的输入：
- en: URL parameters (`project_id`)
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 参数（`project_id`）
- en: Form fields (`request.form["title"]`, etc.)
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单字段（`request.form["title"]` 等）
- en: Optional fields with defaults (`due_date`)
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认值的可选字段（`due_date`）
- en: 'The task controller receives standard Python types:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务控制器接收标准的 Python 类型：
- en: Strings for text fields
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字段使用字符串
- en: '`None` for empty optional fields'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于空的可选字段使用 `None`
- en: The `project_id` from the URL
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 URL 的 `project_id`
- en: 'Domain validation occurs through established layers:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域验证通过既定的层进行：
- en: Business rules in entities
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体中的业务规则
- en: Use case coordination
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例协调
- en: Results returned via our Result type
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过我们的 Result 类型返回的结果
- en: 'Web-specific responses:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 特定响应：
- en: Success redirects with flash messages
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 flash 消息的成功重定向
- en: Error handling through flash messages and redirects
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 flash 消息和重定向进行错误处理
- en: '**Syncing client-side and domain validation**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步客户端和领域验证**'
- en: While our domain validation provides the ultimate source of truth, modern web
    applications often need immediate user feedback. Flask provides mechanisms like
    WTForms that can mirror domain validation rules in the view layer, enabling responsive
    UX without duplicating validation logic. The key is to ensure that these view-layer
    validations remain thin wrappers around our core domain rules rather than introduce
    parallel validation logic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的领域验证提供了最终的真实来源，但现代 Web 应用程序通常需要立即的用户反馈。Flask 提供了像 WTForms 这样的机制，可以在视图层中反映领域验证规则，从而实现响应式
    UX 而不重复验证逻辑。关键是确保这些视图层验证只是我们核心领域规则的外层包装，而不是引入并行验证逻辑。
- en: This separation ensures that our validation rules stay with our domain logic
    where they belong, while the web layer focuses on collecting input and presenting
    feedback.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离确保我们的验证规则留在它们所属的领域逻辑中，而 Web 层则专注于收集输入和呈现反馈。
- en: Integrating Flask with Clean Architecture
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Flask 与 Clean Architecture 集成
- en: 'Having established our presentation patterns and state management approach,
    we now turn to the practical integration of Flask into our Clean Architecture
    system. Building on the application container structure seen earlier in *Understanding
    interface flexibility in Clean Architecture*, we’ll focus on the Flask-specific
    aspects of our web interface:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了我们的展示模式和状态管理方法之后，我们现在转向将 Flask 实际集成到我们的 Clean Architecture 系统中。在 *理解 Clean
    Architecture 中的接口灵活性* 中看到的先前应用程序容器结构的基础上，我们将关注 Web 接口的 Flask 特定方面：
- en: Configuring Flask’s application factory pattern
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Flask 的应用程序工厂模式
- en: Managing Flask-specific settings and dependencies
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Flask 特定的设置和依赖项
- en: Connecting Flask routes to our core application logic
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Flask 路由连接到我们的核心应用程序逻辑
- en: 'Here’s how our Flask application factory integrates with our existing architecture:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 Flask 应用程序工厂如何与我们的现有架构集成：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s examine the key components of this setup. As shown in *Figure 9.4*, `web_main.py`
    acts as our application’s entry point, orchestrating the creation and configuration
    of both our business logic (Application Container) and web interface (Web Container)
    through Flask. The Application Container holds our core business logic while the
    Web Container manages Flask-specific concerns like routes and templates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个设置的要点组件。如图 *图 9.4* 所示，`web_main.py` 作为我们应用程序的入口点，通过 Flask 协调创建和配置我们的业务逻辑（应用程序容器）和
    Web 接口（Web 容器）。应用程序容器持有我们的核心业务逻辑，而 Web 容器则管理 Flask 特定的关注点，如路由和模板。
- en: '![Figure 9.4: Flask application bootstrapping showing container relationships](img/B31577_09_4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：显示容器关系的 Flask 应用程序引导](img/B31577_09_4.png)'
- en: 'Figure 9.4: Flask application bootstrapping showing container relationships'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：显示容器关系的 Flask 应用程序引导
- en: 'This structure follows Clean Architecture’s principles in several key ways:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构在几个关键方面遵循 Clean Architecture 的原则：
- en: Keeping Flask-specific code isolated in the Web Container
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Flask 特定代码隔离在 Web 容器中
- en: Maintaining our core Application Container’s independence from web concerns
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维持我们的核心应用程序容器的独立性，不受Web关注的影响
- en: Enabling clear communication paths between containers through well-defined interfaces
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义良好的接口，在容器之间启用清晰的通信路径
- en: With these containers properly configured and connected, we’re ready to implement
    our routes and templates. These components will build on the presentation patterns
    we’ve established, showing how Clean Architecture enables us to create a full-featured
    web interface while maintaining clear architectural boundaries.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些容器正确配置和连接后，我们就可以实现我们的路由和模板了。这些组件将建立在已建立的展示模式之上，展示Clean Architecture如何使我们能够创建一个功能齐全的Web界面，同时保持清晰的架构边界。
- en: Implementing routes and templates
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现路由和模板
- en: 'Earlier in this chapter we examined routes from a data flow perspective: how
    they represent entry points into our system and translate HTTP requests for our
    core domain. Now let’s look more closely at their implementation to understand
    how they maintain Clean Architecture’s boundaries while delivering web-specific
    functionality.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们从数据流的角度检查了路由：它们如何代表我们系统的入口点，以及如何将HTTP请求转换为我们的核心领域。现在让我们更仔细地看看它们的实现，以了解它们如何在提供特定于Web的功能的同时维护Clean
    Architecture的边界。
- en: 'Just as our CLI implementation translated command-line arguments into use case
    inputs, our web routes translate HTTP requests into operations our core application
    can understand. While the delivery mechanism differs (HTTP requests instead of
    command-line arguments), the architectural pattern remains the same: external
    input flows through our interface adapters before reaching our application core.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们的CLI实现将命令行参数转换为用例输入一样，我们的Web路由将HTTP请求转换为我们的核心应用程序可以理解的操作。虽然交付机制不同（HTTP请求而不是命令行参数），但架构模式保持不变：外部输入通过我们的接口适配器流动，然后到达我们的应用程序核心。
- en: 'Consider how our CLI handled task creation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的CLI如何处理任务创建：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our web route implements the same architectural pattern as our CLI, though
    adapted for HTTP’s request-response cycle. Just as the CLI handler transformed
    command-line arguments into domain operations, this route handler serves as a
    clean boundary between HTTP concepts and our domain logic:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web路由实现了与CLI相同的架构模式，尽管是为HTTP的请求-响应周期进行了调整。正如CLI处理程序将命令行参数转换为领域操作一样，这个路由处理程序作为HTTP概念和我们的领域逻辑之间的清晰边界：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice how both implementations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这两种实现：
- en: Collect input in interface-specific ways (CLI prompts versus form data)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以接口特定的方式收集输入（CLI提示与表单数据）
- en: Transform that input into standard parameters for our controller
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该输入转换为我们的控制器标准参数
- en: Handle success and error responses appropriately for their interface (CLI output
    versus HTTP redirects)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地处理它们的界面中的成功和错误响应（CLI输出与HTTP重定向）
- en: This consistent pattern demonstrates how Clean Architecture enables multiple
    interfaces while keeping our core application focused on business logic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一致的模式展示了Clean Architecture如何使多个接口成为可能，同时保持我们的核心应用程序专注于业务逻辑。
- en: 'The route handling goes beyond simple form processing. The `project_id` parameter
    comes from the URL itself (`/projects/<project_id>/tasks/new`), while form fields
    contain task details. Our Clean Architecture layers handle this naturally:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理不仅限于简单的表单处理。`project_id`参数来自URL本身（`/projects/<project_id>/tasks/new`），而表单字段包含任务详情。我们的Clean
    Architecture层自然地处理这一点：
- en: 'The route layer manages all web specifics:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由层管理所有Web特定内容：
- en: URL parameter extraction
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取URL参数
- en: Form data collection
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单数据收集
- en: Flash messages for user feedback (temporary UI messages shown after redirects)
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于用户反馈的闪存消息（在重定向后显示的临时UI消息）
- en: Template selection and rendering
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板选择和渲染
- en: 'The controller layer handles:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器层处理：
- en: Combining URL and form data into a single operation
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将URL和表单数据合并为单一操作
- en: Coordinating with the appropriate use cases
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调适当的用例
- en: Returning results that our web layer can interpret
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回我们的Web层可以解释的结果
- en: 'The templates represent the outermost layer of our Clean Architecture system,
    serving as the final transformation point between our domain concepts and user
    interface. While our presenters handle the logical transformation of domain data
    into view models, templates focus exclusively on the visual representation of
    that data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代表我们Clean Architecture系统的最外层，作为领域概念与用户界面之间的最终转换点。虽然我们的展示者处理领域数据到视图模型的逻辑转换，但模板专注于数据的视觉表示：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This template demonstrates our clean separation of concerns in action. It works
    exclusively with the `ProjectViewModel` provided by our presenters. Notice how
    it simply references `project.name` without any knowledge of how that data was
    retrieved or processed. The template has no awareness of repositories, use cases,
    or even the HTTP layer, but focuses instead solely on rendering the provided view
    models in a user-friendly format. This mirrors how our CLI presenters formatted
    data for console output, with each interface handling only its specific display
    requirements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板展示了我们在实际操作中如何清晰地区分关注点。它仅与我们的演示者提供的`ProjectViewModel`一起工作。注意它如何简单地引用`project.name`，而不需要了解这些数据是如何检索或处理的。模板对存储库、用例或甚至HTTP层都没有意识，而是专注于以用户友好的格式渲染提供的视图模型。这反映了我们的CLI演示者如何格式化数据以供控制台输出，每个接口只处理其特定的显示要求。
- en: This separation means we can completely redesign our templates, whether changing
    layouts, adding new UI components, or even switching template engines, without
    touching our core application logic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离意味着我们可以完全重新设计我们的模板，无论是更改布局、添加新的UI组件，甚至切换模板引擎，而无需触及我们的核心应用程序逻辑。
- en: Running your Clean Architecture web application
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行你的Clean Architecture Web应用程序
- en: 'Having implemented our web interface components, let’s examine how to bootstrap
    our Clean Architecture application. The `web_main.py` script serves as our composition
    root—the single point where abstract interfaces meet their concrete implementations.
    This entry point orchestrates the creation and connection of our components while
    maintaining Clean Architecture’s dependency rules:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了我们的Web界面组件之后，让我们来看看如何引导我们的Clean Architecture应用程序。`web_main.py`脚本作为我们的组合根——抽象接口与具体实现相遇的唯一点。此入口点协调组件的创建和连接，同时保持Clean
    Architecture的依赖规则：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The Dependency Inversion Principle enables runtime configuration of concrete
    implementations through environment variables. Just as our CLI application could
    switch components without code changes, our web interface maintains this flexibility:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则允许通过环境变量在运行时配置具体实现。正如我们的CLI应用程序可以在不更改代码的情况下切换组件一样，我们的Web界面保持了这种灵活性：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This configuration flexibility demonstrates a key benefit of Clean Architecture:
    the ability to easily switch components. For example, changing `TODO_REPOSITORY_TYPE`
    from “memory” to “file” switches our entire storage implementation without requiring
    any code changes. The same pattern that enabled us to add a web interface also
    enables:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置灵活性展示了Clean Architecture的关键优势：能够轻松切换组件。例如，将`TODO_REPOSITORY_TYPE`从“memory”更改为“file”，可以切换我们的整个存储实现，而无需进行任何代码更改。使我们能够添加Web界面的相同模式也使得以下操作成为可能：
- en: Adding new storage backends (like PostgreSQL or MongoDB)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的存储后端（如PostgreSQL或MongoDB）
- en: Implementing additional notification services
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现额外的通知服务
- en: Creating new interfaces (such as a desktop or mobile app)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的接口（例如桌面或移动应用）
- en: Supporting alternative authentication methods
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持替代认证方法
- en: Each of these enhancements can be implemented and tested in isolation, then
    integrated through our clean architectural boundaries. This capability empowers
    development teams to experiment with new features and technologies while maintaining
    system stability. Rather than risky ‘big bang’ code deployments, teams can gradually
    evolve their applications by adding and testing new components within Clean Architecture’s
    protective boundaries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些增强功能都可以独立实现和测试，然后通过我们的清洁架构边界进行集成。这种能力使开发团队能够在保持系统稳定性的同时，对新功能和新技术进行实验。而不是冒险的“大爆炸”代码部署，团队可以在Clean
    Architecture的保护边界内，逐步通过添加和测试新组件来演进他们的应用程序。
- en: 'To launch the web application, run the main script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Web应用程序，运行主脚本：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Visiting `http://127.0.0.1:5000` in your browser presents a web interface that,
    while radically different in form from our CLI, operates on the exact same core
    components. Where our CLI interpreted command-line arguments, our web interface
    now processes form submissions and URL parameters. The same task creation use
    case that previously responded to CLI commands now handles HTTP POST requests:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中访问`http://127.0.0.1:5000`将呈现一个Web界面，虽然其形式与我们的CLI截然不同，但它运行在完全相同的核心组件上。我们的CLI解释命令行参数，而我们的Web界面现在处理表单提交和URL参数。之前响应CLI命令的任务创建用例现在处理HTTP
    POST请求：
- en: '![Figure 9.5: Task creation form showing web-specific input handling](img/B31577_09_5.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：显示Web特定输入处理的任务创建表单](img/B31577_09_5.png)'
- en: 'Figure 9.5: Task creation form showing web-specific input handling'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：任务创建表单显示Web特定的输入处理
- en: This duality showcases Clean Architecture in practice. Our simple command-line
    application now coexists with a full web interface, complete with forms, dynamic
    updates, and visual feedback. Both interfaces run independently but share the
    same core components. The identical task creation use case that previously processed
    CLI commands now seamlessly handles web form submissions. Our repositories maintain
    consistent data regardless of which interface creates or updates records. Error
    handling adapts naturally, with command-line error messages for CLI users, flash
    messages and form validation for web users.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双重性展示了Clean Architecture的实际应用。我们的简单命令行应用程序现在与完整的Web界面共存，包括表单、动态更新和视觉反馈。这两个接口独立运行但共享相同的内核组件。之前处理CLI命令的相同任务创建用例现在无缝处理Web表单提交。我们的存储库维护一致的数据，无论哪个接口创建或更新记录。错误处理自然适应，对于CLI用户是命令行错误消息，对于Web用户是闪存消息和表单验证。
- en: 'These aren’t just two separate applications that happen to use similar code:
    they’re two interfaces to the exact same application core, each presenting its
    capabilities in a way that makes sense for its environment. A team member could
    create a task through the CLI while another updates it through the web interface,
    with both operations flowing through the same use cases and repositories, demonstrating
    the practical power of Clean Architecture’s boundary rules.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不仅仅是两个使用类似代码的独立应用程序：它们是访问相同应用程序核心的两个接口，每个接口都以适合其环境的方式展示其功能。团队成员可以通过CLI创建任务，而另一位成员可以通过Web界面更新它，这两个操作都通过相同的用例和存储库进行，展示了Clean
    Architecture边界规则的实用力量。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Our journey from CLI to web interface highlights Clean Architecture’s power
    to enable system evolution without compromising architectural integrity. This
    capability extends beyond web interfaces to a broader principle: well-designed
    architectural boundaries create systems that can adapt to changing interface requirements
    while maintaining a stable core.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从CLI到Web界面的转变突出了Clean Architecture在使系统演进而不损害架构完整性方面的力量。这种能力不仅限于Web界面，而是一个更广泛的原则：精心设计的架构边界创建的系统可以适应不断变化的接口需求，同时保持稳定的内核。
- en: The patterns we’ve explored provide a template for future system evolution.
    These patterns range from interface-specific presenters to state management at
    system boundaries. Whether adding mobile interfaces, API endpoints, or entirely
    new interaction models, these same principles ensure that our core business logic
    remains focused and protected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所探讨的这些模式为未来的系统演进提供了一个模板。这些模式从特定于接口的演示者到系统边界的状态管理。无论是添加移动界面、API端点还是全新的交互模型，这些相同的原理确保我们的核心业务逻辑保持专注和保护。
- en: This flexibility doesn’t come at the cost of maintainability. By keeping our
    domain entities focused on business rules and our use cases working with pure
    domain concepts, we’ve created a system where each layer can evolve independently.
    New interface requirements can be met through additional adapters, while our core
    business logic remains stable and untouched.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性并不会牺牲可维护性。通过保持我们的领域实体专注于业务规则，以及我们的用例与纯领域概念协同工作，我们创建了一个系统，其中每个层都可以独立演进。新的接口需求可以通过额外的适配器来满足，而我们的核心业务逻辑保持稳定且未受影响。
- en: In [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor235), we’ll explore how to add
    logging and monitoring to Clean Architecture systems, ensuring that our applications
    remain observable and maintainable in production environments.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](Chapter_10.xhtml#_idTextAnchor235)中，我们将探讨如何向Clean Architecture系统添加日志记录和监控，确保我们的应用程序在生产环境中保持可观察性和可维护性。
- en: Further reading
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Flask Documentation* ([https://flask.palletsprojects.com/en/stable/](https://flask.palletsprojects.com/en/stable/)).
    Full documentation for the Flask framework.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flask 文档* ([https://flask.palletsprojects.com/en/stable/](https://flask.palletsprojects.com/en/stable/))。Flask框架的完整文档。'
- en: '*WTForms* ([https://wtforms.readthedocs.io/en/3.2.x/](https://wtforms.readthedocs.io/en/3.2.x/)).
    Flexible forms validation and rendering library for Python web development.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WTForms* ([https://wtforms.readthedocs.io/en/3.2.x/](https://wtforms.readthedocs.io/en/3.2.x/))。Python
    Web开发的灵活表单验证和渲染库。'
