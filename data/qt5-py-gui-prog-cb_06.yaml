- en: Chapter 6. Threads and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 线程和网络
- en: In this chapter, we will create threads, queues, and TCP/IP sockets using Python
    3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 创建线程、队列和 TCP/IP 套接字。
- en: How to create multiple threads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: Starting a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个线程
- en: Stopping a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: How to use queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: Passing queues among different modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: Using dialog widgets to copy files to your network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: Using TCP/IP to communicate via networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: Using URLOpen to read data from websites
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 URLOpen 从网站读取数据
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用线程、队列和网络连接来扩展我们Python GUI的功能。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A tkinter GUI is single-threaded. Every function that involves sleep or wait
    time has to be called in a separate thread, otherwise the tkinter GUI freezes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter图形用户界面是单线程的。涉及睡眠或等待时间的任何函数都必须在单独的线程中调用，否则Tkinter GUI会冻结。
- en: When we run our Python GUI in Windows Task Manager, we can see that a new `python.exe`
    process has been launched.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Windows 任务管理器中运行我们的 Python GUI 时，我们可以看到一个新的 `python.exe` 进程已经被启动。
- en: When we give our Python GUI a `.pyw` extension, then the process created will
    be `python.pyw`, as can be seen in Task Manager.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给我们的 Python GUI 添加 `.pyw` 扩展名时，创建的进程将是 `python.pyw`，如任务管理器中所示。
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a single-threaded application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个进程时，进程会自动创建一个主线程来运行我们的应用程序。这被称为单线程应用程序。
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task such as clicking a button that
    has a sleep of a few seconds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Python GUI，如果是一个单线程应用程序，那么一旦我们调用一个运行时间较长的任务，比如点击一个有几秒休眠的按钮，我们的GUI就会立即冻结。
- en: In order to keep our GUI responsive we have to use multi-threading, and this
    is what we will study in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的图形用户界面（GUI）响应，我们必须使用多线程，这正是本章将要探讨的内容。
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过创建多个Python GUI实例来创建多个进程，这在任务管理器中可以看得到。
- en: Processes are isolated by design from each other and do not share common data.
    In order to communicate between separate processes we would have to use **Inter-Process-Communication**
    (**IPC**), which is an advanced technique.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，进程彼此隔离且不共享公共数据。为了在分离的进程之间进行通信，我们不得不使用**进程间通信**（**IPC**），这是一种高级技术。
- en: Threads, on the other hand, do share common data, code, and files, which makes
    communication between threads within the same process much easier than when using
    IPC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程确实共享相同的数据、代码和文件，这使得在同一进程内线程之间的通信比使用进程间通信（IPC）要容易得多。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'A great explanation of threads can be found at: [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一份关于线程的精彩解释可以在以下链接找到：[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)
- en: In this chapter, we will learn how to keep our Python GUI responsive and not
    to freeze.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何保持我们的 Python 图形用户界面（GUI）响应，并防止其冻结。
- en: How to create multiple threads
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: We will create multiple threads using Python. This is necessary in order to
    keep our GUI responsive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 创建多个线程。这是为了保持我们的 GUI 响应性所必需的。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A thread is like weaving a fabric made out of yarn and is nothing to be afraid
    of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程就像是用线织成的布料，没有什么可怕的。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Multiple threads run within the same computer process memory space. There is
    no need for Inter-Process-Communication (aka IPC), which would complicate our
    code. In this recipe, we will avoid IPC by using threads.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程在同一个计算机进程的内存空间中运行。无需进行进程间通信（简称IPC），这会使得我们的代码变得复杂。在本食谱中，我们将通过使用线程来避免IPC。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrolW` to 40 and `scrolH` to 10.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将增加我们的`ScrolledText`小部件的大小，使其更大。让我们将`scrolW`增加到40，将`scrolH`增加到10。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we now run the resulting GUI, the `Spinbox` widget is center-aligned in
    relation to the `Entry` widget above it, which does not look good. We'll change
    this by left-aligning the widget.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行生成的GUI时，相对于其上方的`Entry`小部件，`Spinbox`小部件是居中对齐的，这看起来不太好。我们将通过左对齐小部件来改变这一点。
- en: Add `sticky='W'` to the `grid` control to left-align the `Spinbox` widget.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `sticky='W'` 添加到 `grid` 控制中，以左对齐 `Spinbox` 小部件。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The GUI could still look better, so next, we will increase the size of the `Entry`
    widget to get a more balanced GUI layout.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 界面看起来还可以更好，所以接下来，我们将增加`Entry`小部件的大小，以获得更平衡的GUI布局。
- en: 'Increase the width to 24, as shown in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将宽度增加到24，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let us also slightly increase the width of the `Combobox` to 14.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将`Combobox`的宽度略微增加到14。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running the modified and improved code results in a larger GUI, which we will
    use for this and the following recipes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改和改进后的代码将产生一个更大的GUI，我们将使用这个GUI以及接下来的食谱。
- en: '![How to do it...](img/B04829_06_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_01.jpg)'
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the threading module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建和使用线程，我们必须从threading模块导入`Thread`类。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's add a method to be created in a thread to our `OOP` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OOP`类中添加一个在线程中创建的方法。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can now call our threaded method in the code, saving the instance in a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在代码中调用我们的线程方法，并将实例保存在一个变量中。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个线程化的方法，但当我们运行代码时，控制台没有任何输出！
- en: We have to start the `Thread` first before it can run and the next recipe will
    show us how to do this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先启动`线程`，然后它才能运行，下一道菜谱将展示如何进行这一操作。
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a `Thread` object, as can been seen in the Eclipse IDE Debugger.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在GUI主事件循环之后设置断点证明我们确实创建了一个`Thread`对象，正如可以在Eclipse IDE调试器中看到的那样。
- en: '![How to do it...](img/B04829_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_02.jpg)'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size, so we could better see the results printed to the `ScrolledText` widget.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先通过增加GUI的大小来准备使用线程，这样我们就能更好地看到打印到`ScrolledText`小部件的结果。
- en: We then imported the `Thread` class from the Python `threading` module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从 Python 的 `threading` 模块中导入了 `Thread` 类。
- en: After that, we created a method that we call in a thread from within our GUI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在GUI内部创建了一个我们称之为线程的方法。
- en: Starting a thread
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个线程
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向我们展示如何启动一个线程。它还将演示为什么在长时间运行的任务中，线程对于保持我们的GUI响应性是必要的。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's first see what happens when we call a function or method of our GUI that
    has some sleep associated with it without using threads.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看当我们调用我们的GUI中与睡眠相关联的函数或方法，但没有使用线程时会发生什么。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We are using a sleep here to simulate a real-world application that might have
    to wait for a web server or database to respond or a large file transfer or complex
    computation to complete its task.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用睡眠来模拟一个可能需要等待网络服务器或数据库响应、大文件传输或复杂计算完成任务的真实世界应用。
- en: The sleep is a very realistic place-holder and shows the principle involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠是一个非常实际的占位符，并展示了其中涉及的原则。
- en: Adding a loop into our button callback method with some sleep time results in
    our GUI becoming unresponsive and, when we try to close the GUI, things get even
    worse.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的按钮回调方法中添加一个循环并设置一些休眠时间会导致我们的GUI变得无响应，当我们尝试关闭GUI时，情况变得更糟。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Getting ready](img/B04829_06_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B04829_06_03.jpg)'
- en: If we wait long enough, the method will eventually complete but during this
    time none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待足够长的时间，该方法最终会完成，但在这一过程中，我们所有的GUI小部件都不会对点击事件做出响应。我们通过使用线程来解决这个问题。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In the previous recipe, we created a method to be run in a thread, but so far,
    the thread has not run!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们创建了一个在线程中运行的方法，但到目前为止，该线程还没有运行！
- en: Unlike regular Python functions and methods, we have to `start` a method that
    is going to be run in its own thread!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的 Python 函数和方法不同，我们必须在它自己的线程中`启动`一个将要运行的方法！
- en: This is what we will do next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要做的。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做……
- en: First, let's move the creation of the thread into its own method and then call
    this method from the button callback method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将创建线程的操作移入一个独立的方法中，然后从按钮回调方法中调用这个方法。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clicking the button now results in the `createThread` method being called which,
    in turn, calls the `methodInAThread` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮现在会导致调用`createThread`方法，该方法反过来又调用`methodInAThread`方法。
- en: First, we create a thread and target it at a method. Next, we start the thread
    that will run the targeted method in a new thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个线程并将其指向一个方法。接下来，我们启动一个新线程来运行目标方法。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 本身在其自己的线程中运行，这是应用程序的主线程。
- en: '![How to do it...](img/B04829_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_04.jpg)'
- en: We can print out the instance of the thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出线程的实例。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clicking the button now creates the following printout:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮现在将生成以下打印输出：
- en: '![How to do it...](img/B04829_06_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_05.jpg)'
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们多次点击按钮时，我们可以看到每个线程都被分配了一个唯一的名称和ID。
- en: '![How to do it...](img/B04829_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_06.jpg)'
- en: Let's now move our code with the `sleep` in a loop into the `methodInAThread`
    method to verify that threads really do solve our problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将带有`sleep`的代码放入`methodInAThread`方法中，以验证线程确实解决了我们的问题。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，在数字以五秒延迟打印到`ScrolledText`小部件的过程中，我们可以在我们的GUI中任意点击，切换标签页等等。由于我们使用了线程，我们的GUI再次变得响应了！
- en: '![How to do it...](img/B04829_06_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_07.jpg)'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we called methods of our GUI class in their own threads and
    learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在自己的线程中调用了GUI类的函数，并了解到我们必须启动线程。否则，线程会被创建，但只是在那里等待我们运行其目标方法。
- en: We noticed that each thread gets assigned a unique name and ID.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到每个线程都被分配了一个唯一的名称和ID。
- en: We simulated long-running tasks by inserting a `sleep` statement into our code,
    which showed us that threads can indeed solve our problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中插入`sleep`语句来模拟长时间运行的任务，这表明线程确实可以解决我们的问题。
- en: Stopping a thread
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: We have to start a thread to actually make it do something by calling the `start()`
    method, so, intuitively, we would expect there to be a matching `stop()` method,
    but there is no such thing. In this recipe, we will learn how to run a thread
    as a background task, which is called a daemon. When closing the main thread,
    which is our GUI, all daemons will automatically be stopped as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须启动一个线程，通过调用`start()`方法来让它执行某些操作，所以直观上，我们可能会期望存在一个对应的`stop()`方法，但实际上并没有这样的方法。在本教程中，我们将学习如何将线程作为一个后台任务运行，这被称为守护线程。当关闭主线程，也就是我们的GUI时，所有守护线程也会自动停止。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在线程中调用方法时，我们也可以向方法传递参数和关键字参数。我们通过做这件事来开始这个步骤。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在线程构造函数中添加`args=[8]`并将目标方法修改为期望参数，我们可以向线程方法传递参数。`args`参数必须是一个序列，因此我们将我们的数字包裹在一个Python列表中。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following code, `runT` is a local variable which we only access within
    the scope of the method inside of which we created `runT`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`runT` 是一个局部变量，我们只在该方法的作用域内访问我们创建的 `runT`。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By turning the local variable into a member, we can then check if the thread
    is still running by calling `isAlive` on it from another method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将局部变量转换为成员，我们就可以通过在另一个方法中调用其`isAlive`方法来检查线程是否仍在运行。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we have elevated our local `runT` variable to a member
    of our class. What this does is enable us to assess the `self.runT` variable from
    any method in our class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将本地`runT`变量提升为我们的类成员。这样做的作用是使我们能够从我们的类中的任何方法访问`self.runT`变量。
- en: 'This is achieved like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样实现的：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we click the button and then exit the GUI, we can see that the print statement
    in the `createThread` method was printed, but we do not see the second print statement
    from `methodInAThread`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮然后退出GUI时，我们可以看到`createThread`方法中的打印语句被打印出来，但我们看不到来自`methodInAThread`的第二个打印语句。
- en: Instead, we get a RuntimeError.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们得到一个 RuntimeError。
- en: '![How to do it...](img/B04829_06_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_08.jpg)'
- en: Threads are expected to finish their assigned task so when we close the GUI
    while the thread has not completed, Python tells us that the thread we started
    is not in the main event loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 线程预计将完成其分配的任务，因此当我们关闭GUI而线程尚未完成时，Python会告诉我们我们启动的线程不在主事件循环中。
- en: We can solve this by turning the thread into a daemon, which will then execute
    as a background task.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将线程转换为守护进程来解决此问题，然后它将作为一个后台任务执行。
- en: What this gives us is that, as soon as we close our GUI, which is our main thread
    starting other threads, the daemon threads will cleanly exit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来的结果是，当我们关闭我们的GUI（图形用户界面），也就是我们的主线程启动其他线程时，守护线程将干净地退出。
- en: We can do this by calling the `setDaemon(True)` method on the thread before
    we start the thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在启动线程之前，通过调用线程的`setDaemon(True)`方法来实现这一点。
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we now click the button and exit our GUI while the thread has not yet completed
    its assigned task, we no longer get any errors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击按钮并退出我们的GUI，而线程尚未完成其分配的任务时，我们不再收到任何错误。
- en: '![How to do it...](img/B04829_06_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_09.jpg)'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While there is a start method to make threads run, surprisingly there is not
    really an equivalent stop method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有启动方法可以让线程运行，但令人惊讶的是，并没有真正等效的停止方法。
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在一个线程中运行一个方法，该方法将数字打印到我们的`ScrolledText`小部件中。
- en: When we exit our GUI, we are no longer interested in the thread that used to
    print to our widget, so, by turning the thread into a background daemon, we can
    exit our GUI cleanly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出我们的图形用户界面时，我们就不再对曾经用于向我们的小部件打印的线程感兴趣了，因此，通过将线程转换为后台守护进程，我们可以干净地退出我们的GUI。
- en: How to use queues
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: A Python queue is a data structure that implements the first-in-first-out paradigm,
    basically working like a pipe. You shovel something into the pipe on one side
    and it falls out on the other side of the pipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python队列是一种实现先进先出（FIFO）范式的数据结构，基本上就像一个管道。你在一侧把东西铲进管道，它就会从管道的另一侧掉出来。
- en: The main difference between this queue shoveling, and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one integral piece.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与将泥土铲入物理管道相比，这种队列铲雪的主要区别在于，在Python队列中，事物不会混淆。你放入一个单元，这个单元就会从另一端出来。接下来，你放入另一个单元（比如，一个类的实例），这个整个单元将作为一个整体从另一端出来。
- en: It comes back out at the other end in the exact order we inserted code into
    the queue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它以我们插入队列中代码的精确顺序从另一端返回。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A queue is not a stack where we push and pop data. A stack is a last-in-first-out
    (LIFO) data structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 队列并非是我们可以进行入栈和出栈操作的栈。栈是一种后进先出（LIFO）的数据结构。
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是用于存储从可能不同的数据源中输入的数据的容器。当客户端有可用数据时，我们可以让不同的客户端向队列提供数据。无论哪个客户端准备好向我们的队列发送数据，它就会发送，然后我们可以将此数据显示在小部件中或将其转发到其他模块。
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of the processing and displaying them. The data
    is inserted at one end of the queue and then comes out of the other end in an
    ordered fashion, First-In-First-Out (FIFO).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个线程在队列中完成分配的任务，在接收处理结果的最终结果并显示它们时非常有用。数据被插入到队列的一端，然后以有序的方式从另一端出来，即先进先出（FIFO）。
- en: Our GUI might have five different button widgets that each kick off different
    tasks that we want to display in our GUI in a widget (for example, a ScrolledText
    widget).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形用户界面可能有五个不同的按钮小部件，每个小部件都会启动不同的任务，我们希望在GUI中的小部件（例如，滚动文本小部件）中显示这些任务。
- en: These five different tasks take a different amount of time to complete.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这五项不同的任务需要不同时间来完成。
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一项任务完成时，我们立即需要知道这一点，并在我们的图形用户界面中显示此信息。
- en: By creating a shared Python queue and having the five tasks write their results
    to this queue, we can display the result of whatever task has been completed immediately
    using a FIFO approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个共享的 Python 队列，并让五个任务将它们的结果写入这个队列，我们可以使用先进先出（FIFO）的方法立即显示已完成任务的任何结果。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As our GUI is ever increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to represent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的图形用户界面（GUI）在功能和实用性上不断增长，它开始与网络、进程和网站进行交互，并且最终必须等待数据变得可用，以便图形用户界面能够展示。
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建队列可以解决在GUI中等待数据显示的问题。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement towards the top of our GUI module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建队列，我们必须从`queue`模块中导入`Queue`类。将以下语句添加到我们的GUI模块顶部：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That gets us started.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就让我们开始了。
- en: Next, we create a queue instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个队列实例。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code we create a local `Queue` instance that is only accessible
    within this method. If we wish to access this queue from other places, we have
    to turn it into a member of our class by using the `self` keyword which binds
    the local variable to the entire class, making it available from any other method
    within our class. In Python, we often create class instance variables in the `__init__(self)`
    method but Python is very pragmatic and enables us to create those member variables
    anywhere in the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个局部`Queue`实例，该实例仅在此方法内部可访问。如果我们希望从其他地方访问这个队列，我们必须使用`self`关键字将其变成我们类的一个成员，这会将局部变量绑定到整个类，使其可以在我们类中的任何其他方法中访问。在Python中，我们通常在`__init__(self)`方法中创建类实例变量，但Python非常实用，允许我们在代码的任何地方创建这些成员变量。
- en: Now we have an instance of a queue. We can prove that this works by printing
    it out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个队列的实例。我们可以通过打印它来证明这是有效的。
- en: '![How to do it...](img/B04829_06_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_10.jpg)'
- en: In order to put data into the queue, we use the `put` command. In order to get
    data out of the queue, we use the `get` command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据放入队列，我们使用`put`命令。为了从队列中获取数据，我们使用`get`命令。
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the modified code results in the message first being placed in the `Queue`,
    and then being taken out of the `Queue`, and then printed to the console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码会导致消息首先被放入`队列`中，然后从`队列`中取出，接着打印到控制台。
- en: '![How to do it...](img/B04829_06_11.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_11.jpg)'
- en: We can place many messages into the queue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多消息放入队列中。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have placed 10 messages into the `Queue`, but we are only getting the first
    one out. The other messages are still inside of the `Queue`, waiting to be taken
    out in a FIFO fashion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将10条消息放入了`队列`，但我们只取出了第一条。其他消息仍然在`队列`中，等待以FIFO（先进先出）的方式被取出。
- en: '![How to do it...](img/B04829_06_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_12.jpg)'
- en: In order to get all messages that have been placed into a `Queue` out, we can
    create an endless loop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取所有已放入`队列`的消息，我们可以创建一个无限循环。
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](img/B04829_06_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_13.jpg)'
- en: While this code works, unfortunately it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in previous recipes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码能工作，但不幸的是它会冻结我们的图形用户界面。为了解决这个问题，我们必须在它自己的线程中调用该方法，就像我们在之前的菜谱中做的那样。
- en: 'Let''s run our method in a thread and tie it to the button event:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个线程中运行我们的方法，并将其绑定到按钮事件：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we now click the action `Button`, we no longer get an extraneous pop-up
    window and the code works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击操作`按钮`，我们不再得到一个多余的弹出窗口，代码也能正常工作。
- en: '![How to do it...](img/B04829_06_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_14.jpg)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have created a `Queue`, placed messages into one side of the `Queue` in a
    first-in-first-out (aka FIFO) fashion. We got the messages out of the `Queue`
    and then printed them to the console (stdout).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`队列`，以先进先出（即FIFO）的方式将消息放入`队列`的一侧。我们从`队列`中取出消息，然后将其打印到控制台（stdout）。
- en: We realized that we have to call the method in its own `Thread`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到我们必须在自己的`Thread`中调用该方法。
- en: Passing queues among different modules
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: In this recipe, we will pass `Queues` around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将`队列`传递到不同的模块中。随着我们的GUI代码复杂性增加，我们希望将GUI组件从业务逻辑中分离出来，将它们分别放入不同的模块中。
- en: Modularization gives us code reuse and also makes the code more readable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化使我们能够复用代码，同时也使得代码更加易于阅读。
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what `Queues` solve. By passing instances
    of `Queues` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在GUI中显示的数据来自不同的数据源时，我们将面临延迟问题，这正是`队列`解决的问题。通过在不同Python模块之间传递`队列`的实例，我们正在分离模块功能的不同关注点。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The GUI code ideally would only be concerned with creating and displaying widgets.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GUI代码理想情况下只需关注创建和显示小部件。
- en: The business logic modules' job is to only do the business logic.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑模块的职责仅限于执行业务逻辑。
- en: We have to combine the two elements, ideally using as few relations among the
    different modules, reducing code interdependence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须结合这两个元素，理想情况下使用尽可能少的模块间关系，减少代码之间的依赖性。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The coding principle of avoiding unnecessary dependencies is usually called
    "loose coupling".
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要的依赖的编码原则通常被称为“松耦合”。
- en: In order to understand the significance of loose coupling, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解松耦合的重要性，我们可以在白板上或一张纸上画一些方框。一个方框代表我们的GUI类和代码，而其他方框则代表业务逻辑、数据库等。
- en: Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes which are our Python modules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在这些方框之间画线，绘制出这些方框（即我们的Python模块）之间的相互依赖关系。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The fewer lines we have between our Python boxes, the more loosely-coupled our
    design is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Python盒子之间的行数越少，我们的设计就越松散耦合。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In the previous recipe, we have started to use `Queues`. In this recipe we will
    pass instances of a `Queue` from our main GUI thread to other Python modules,
    which will enable us to write to the `ScrolledText` widget from another module
    while keeping our GUI responsive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们已经开始使用 `队列`。在这个菜谱中，我们将从主GUI线程传递 `队列` 的实例到其他Python模块，这将使我们能够从另一个模块写入
    `ScrolledText` 小部件，同时保持我们的GUI响应。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, we create a new Python module in our project. Let's call it `Queues.py`.
    We'll place a function into it (no OOP necessary yet) and pass it an instance
    of the queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在项目中创建一个新的 Python 模块。让我们称它为 `Queues.py`。我们将一个函数放入其中（目前不需要面向对象编程）并传递一个队列实例。
- en: We also pass a self-reference of the class that creates the GUI form and widgets,
    which enables us to use all of the GUI methods from another Python module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了创建GUI表单和控件的类的自引用，这使得我们能够从另一个Python模块中使用所有的GUI方法。
- en: We do this in the button callback.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按钮回调中这样做
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class, using the `self` keyword.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象编程（OOP）的魔力。在类的中间，我们使用`self`关键字将自身传递给类内部调用的函数。
- en: The code now looks like this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在看起来是这样的。
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The imported module contains the function we are calling,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的模块包含我们正在调用的函数，
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have commented out the call to `createThread` in the button callback because
    we are now calling it from our new module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按钮回调中注释掉了对`createThread`的调用，因为我们现在是从我们新的模块中调用它的。
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By passing in a self-reference from the class instance to the function the class
    is calling in another module, we now have access to all of our GUI elements from
    other Python modules.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将类实例的自引用传递给类在另一个模块中调用的函数，我们现在可以访问来自其他Python模块的所有GUI元素。
- en: Running the code creates the following result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会生成以下结果。
- en: '![How to do it...](img/B04829_06_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_15.jpg)'
- en: Next, we will create the `Queue` as a member of our class, placing a reference
    to it in the `__init__` method of the class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`Queue`作为我们类的一个成员，并在类的`__init__`方法中放置对其的引用。
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we can put messages into the queue from our new module by simply using the
    passed-in class reference to our GUI.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单地使用传递给我们的GUI的类引用，将消息放入队列中。
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `createThread` method in our GUI code now only reads from the queue, which
    got filled in by the business logic residing in our new module, which has separated
    the logic from our GUI module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GUI代码中的`createThread`方法现在只从队列中读取，该队列是由我们新模块中的业务逻辑填充的，该模块已经将逻辑从我们的GUI模块中分离出来。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running our modified code creates the same results. We have not broken anything
    (yet)!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们修改后的代码会产生相同的结果。我们还没有破坏任何东西（目前还没有）！
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue a member of this class and, by
    passing an instance of the class into a function residing in a different Python
    module, we now have access to all of the GUI widgets as well as the `Queue`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图形用户界面（GUI）小部件与表达业务逻辑的功能分离，我们创建了一个类，将队列作为这个类的成员，并通过将这个类的实例传递给位于不同Python模块中的函数，我们现在可以访问所有的GUI小部件以及`Queue`。
- en: This recipe is an example of when it makes sense to program in OOP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是一个例子，说明在面向对象编程（OOP）中编程是有意义的。
- en: Using dialog widgets to copy files to your network
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: This recipe shows us how to copy files from your local hard drive to a network
    location.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何将文件从您的本地硬盘复制到网络位置。
- en: We will do this by using one of Python's tkinter built-in dialogs, which enables
    us to browse our hard drive. We can then select a file to be copied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 Python 的 tkinter 内置对话框之一来完成这项工作，它使我们能够浏览我们的硬盘驱动器。然后我们可以选择要复制的文件。
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    our `Entry` to a specified location, which speeds up the browsing of our hard
    drive.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱还向我们展示了如何将`Entry`小部件设置为只读，并将我们的`Entry`默认设置为指定位置，这可以加快我们浏览硬盘的速度。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will extend **Tab 2** of the GUI we have been building in previous recipes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展之前菜谱中构建的图形用户界面（GUI）的**Tab 2**。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add the following code to our GUI in the `def createWidgets(self)` method towards
    the bottom where we created Tab Control 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们的GUI中，在`def createWidgets(self)`方法底部，即我们创建Tab Control 2的地方。
- en: The parent of the new widget frame is `tab2`, which we have created at the very
    beginning of the `createWidgets()` method. As long as you place the code shown
    as follows physically below the creation of `tab2`, it will work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 widget 框架的父元素是 `tab2`，这是我们最初在 `createWidgets()` 方法中创建的。只要您将以下代码物理地放置在创建 `tab2`
    之下，它就会正常工作。
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will add two buttons and two entries to **Tab 2** of our GUI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的GUI的**Tab 2**标签页中添加两个按钮和两个输入框。
- en: We are not yet implementing the functionality of our button callback function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未实现按钮回调函数的功能。
- en: 'Running the code creates the following GUI:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将创建以下图形用户界面：
- en: '![How to do it...](img/B04829_06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_16.jpg)'
- en: Clicking the **Browse to File…** button currently prints to the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**浏览到文件…**按钮当前会打印到控制台。
- en: '![How to do it...](img/B04829_06_17.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_17.jpg)'
- en: We can use tkinter's built-in file dialogs so let's add the following `import`
    statements to the top of our Python GUI module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用tkinter内置的文件对话框，所以让我们将以下`import`语句添加到我们的Python GUI模块顶部。
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now use the dialogs in our code. Instead of hard-coding a path, we can
    use Python's os module to find the full path to where our GUI module resides.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在代码中使用对话框。我们不再需要硬编码路径，而是可以使用Python的os模块来找到我们的GUI模块所在的全路径。
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Clicking the browse button now opens up the `askopenfilename` dialog.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击浏览按钮现在将打开`askopenfilename`对话框。
- en: '![How to do it...](img/B04829_06_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_18.jpg)'
- en: We can now open a file in this directory or browse to a different directory.
    After selecting a file and clicking the **Open** button in the dialog, we will
    save the full path to the file in the `fName` local variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在这个目录中打开一个文件或浏览到不同的目录。在对话框中选择一个文件并点击**打开**按钮后，我们将把文件的完整路径保存到`fName`局部变量中。
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们打开 Python 的 `askopenfilename` 对话框小部件时，能自动默认到一个目录，这样我们就不必浏览到我们要打开的特定文件所在的位置了，那就太好了。
- en: It is best to demonstrate how to do this by going back to our GUI **Tab 1**,
    which is what we will do next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是回到我们的GUI **标签1**，这是我们接下来要做的。
- en: We can default values into Entry widgets. Back on our **Tab 1**, this is very
    easy. All we have to do is add the following two lines of code to the creation
    of the `Entry` widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将默认值设置到输入框小部件中。回到我们的**标签页 1**，这非常简单。我们只需在创建`Entry`小部件时添加以下两行代码即可。
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we now run the GUI, the `nameEntered` Entry has a default value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行GUI时，`nameEntered`输入框有一个默认值。
- en: '![How to do it...](img/B04829_06_19.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_19.jpg)'
- en: We can get the full path to the module we are using with the following Python
    syntax and then we can create a new subfolder just below it. We can do this as
    a module level global, or we can create the subfolder within a method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下Python语法获取我们正在使用的模块的完整路径，然后我们可以在其下方创建一个新的子文件夹。我们可以将其作为一个模块级别的全局操作，或者我们可以在一个方法内部创建该子文件夹。
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are setting defaults for both entry widgets and, after setting them, we make
    the local file entry widget read-only.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为输入小部件设置默认值，并在设置后，使本地文件输入小部件为只读状态。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序很重要。我们必须先填充条目，然后才能将其设置为只读。
- en: We are also selecting **Tab 2** before calling the main event loop and no longer
    set the focus into the `Entry` of **Tab 1**. Calling `select` on our tkinter `notebook`
    is zero-based so by passing in the value of 1 we select **Tab 2**…
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用主事件循环之前，我们也在选择**Tab 2**，并且不再将焦点设置到**Tab 1**的`Entry`中。在我们的tkinter `notebook`上调用`select`是零基索引的，所以通过传入值1，我们选择**Tab
    2**…
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it...](img/B04829_06_20.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_20.jpg)'
- en: As we are not all on the same network, this recipe will use the local hard drive
    as an example for a network.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不都在同一个网络中，这个食谱将以本地硬盘为例来展示网络的使用。
- en: A UNC path is a Universal Naming Convention and what this means is that we can
    access a server on our network by using double backslashes to access a network
    server instead of the typical `C:\` when we access our local hard drive on a Windows
    PC.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: UNC路径是一种通用命名约定，这意味着我们可以通过使用双反斜杠来访问网络服务器，而不是在Windows PC上访问本地硬盘驱动器时使用的典型`C:\`，从而访问我们网络上的服务器。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: You just have to use the UNC and replace `C:\` with `\\<server name> \<folder>\`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需使用UNC路径，并将`C:\`替换为`\\<server name> \<folder>\`。
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可用于将我们的代码备份到备份目录，如果该目录不存在，我们可以通过使用`os.makedirs`来创建它。
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After selecting a file to copy to somewhere else, we import the Python `shutil`
    module. We need the full path to the source of the file to be copied, a network
    or local directory path, and then we append the file name to the path where we
    are going to copy it, using `shutil.copy`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一个文件复制到其他位置后，我们导入Python的`shutil`模块。我们需要复制文件的源路径的完整路径，一个网络或本地目录路径，然后使用`shutil.copy`将文件名追加到我们要复制到的路径中。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Shutil is short-hand notation for shell utility.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Shutil 是 shell 工具的简写表示。
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, import `messagebox` and rename
    it `mBox`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过消息框向用户反馈复制是否成功或失败。为了实现这一点，导入`messagebox`并将其重命名为`mBox`。
- en: In the following code, we will mix two different approaches of where to place
    our import statements. In Python, we have some flexibility that other languages
    do not provide.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将混合两种不同的方法来放置我们的导入语句。在Python中，我们有其他语言所不具备的灵活性。
- en: We typically place all of the import statements towards the very top of each
    of our Python modules so that it is clear which modules we are importing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将所有的导入语句放置在每个Python模块的顶部，以便清楚地知道我们正在导入哪些模块。
- en: At the same time, a modern coding approach is to place the creation of variables
    close to the function or method where they are first being used.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，现代编码方法是将变量的创建放置在它们首次被使用的函数或方法附近。
- en: In the following code, we import the message box at the top of our Python module,
    but then we also import the shutil Python module in a function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们在Python模块的顶部导入消息框，但随后在函数中又导入了shutil Python模块。
- en: Why would we wish to do this?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要做这件事呢？
- en: Does this even work?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至能行得通吗？
- en: The answer is, yes, it does work, and we are placing this import statement into
    a function because this is the only place in our code where we actually do need
    this module.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，是的，它确实有效，我们将这个导入语句放入函数中，因为这是我们代码中唯一真正需要这个模块的地方。
- en: If we never call this method, then we will never import the module this method
    requires.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从未调用这个方法，那么我们就永远不会导入这个方法所需的模块。
- en: In a sense, you can view this technique as the lazy initialization design pattern.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，你可以将这种技术视为懒加载设计模式。
- en: If we don't need it, we don't import it until we really do require it in our
    Python code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要它，我们不会在真正需要在我们的Python代码中导入它之前就导入它。
- en: The idea here is that our entire code might require, let's say, twenty different
    modules. At runtime, which modules are really needed depends upon the user interaction.
    If we never call the `copyFile()` function then there is no need to import `shutil`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，我们整个代码可能需要，比如说，二十个不同的模块。在运行时，哪些模块真正需要取决于用户交互。如果我们从未调用`copyFile()`函数，那么就没有必要导入`shutil`。
- en: Once we click the button that invokes the `copyFile()` function in this function,
    we import the required module.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击调用此函数中`copyFile()`函数的按钮，我们就导入所需的模块。
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we now run our GUI and browse to a file and click copy, the file is copied
    to the location we specified in our `Entry` widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行我们的GUI并浏览到一个文件并点击复制时，文件会被复制到我们在`Entry`小部件中指定的位置。
- en: '![How to do it...](img/B04829_06_21.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_21.jpg)'
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，或者我们忘记浏览到文件而试图复制整个父文件夹，代码也会通知我们这一点，因为我们正在使用Python内置的异常处理功能。
- en: '![How to do it...](img/B04829_06_22.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_22.jpg)'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Python 壳工具将文件从本地硬盘复制到网络上。由于我们大多数人没有连接到同一个局域网，我们通过将代码备份到不同的本地文件夹来模拟复制过程。
- en: We are using one of tkinter's dialog controls and, by defaulting directory paths,
    we can increase our efficiency in copying files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用tkinter的一个对话框控件，并且通过默认目录路径，我们可以提高复制文件的效率。
- en: Using TCP/IP to communicate via networks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: This recipe shows you how to use sockets to communicate via TCP/IP. In order
    to achieve this, we need both an IP address and a port number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用套接字通过TCP/IP进行通信。为了实现这一点，我们需要一个IP地址和一个端口号。
- en: In order to keep things simple and independent of the ever-changing internet
    IP addresses, we will create our own local TCP/IP server and, as a client, learn
    how to connect to it and read data from a TCP/IP connection.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单且不依赖于不断变化的互联网IP地址，我们将创建自己的本地TCP/IP服务器，并且作为客户端，学习如何连接到它并从TCP/IP连接中读取数据。
- en: We will integrate this networking capability into our GUI by using the queues
    we created in previous recipes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用在前面的菜谱中创建的队列，将这种网络功能整合到我们的图形用户界面中。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new Python module, which will be the TCP server.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 Python 模块，它将成为 TCP 服务器。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中实现 TCP 服务器的一种方法是从 `socketserver` 模块继承。我们子类化 `BaseRequestHandler` 并然后覆盖继承的
    `handle` 方法。在非常少的 Python 代码行中，我们就能实现一个 TCP 服务器模块。
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are passing in our `RequestHandler` class into a `TCPServer` initializer.
    The empty single quotes are a short cut for passing in localhost, which is our
    own PC. This is the IP address of 127.0.0.1\. The second item in the tuple is
    the port number. We can choose any port number that is not in use on our local
    PC.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`RequestHandler`类传递给`TCPServer`初始化器。空的单引号是一个快捷方式，用于传递本地主机，也就是我们自己的电脑。这是127.0.0.1的IP地址。元组中的第二个项目是端口号。我们可以在我们的本地电脑上选择任何未使用的端口号。
- en: We just have to make sure that we are using the same port on the client side
    of the TCP connection, otherwise we would not be able to connect to the server.
    Of course, we have to start the server first before clients can connect to it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需确保在TCP连接的客户端使用相同的端口，否则我们就无法连接到服务器。当然，在客户端能够连接之前，我们必须首先启动服务器。
- en: We will modify our `Queues.py` module to become the TCP client.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的`Queues.py`模块，使其成为TCP客户端。
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要与TCP服务器通信的所有代码。在这个例子中，我们只是向服务器发送一些字节，服务器在返回响应之前会预先添加一些字符串。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This shows the principle of how TCP communications via networks work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了TCP通过网络通信的工作原理。
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何通过TCP/IP连接到远程服务器，我们就会使用我们感兴趣与之通信的程序协议所设计的任何命令。第一步是在向服务器上特定应用程序发送命令之前建立连接。
- en: In the `writeToScrol` function, we will use the same loop as before but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI member queue
    which, as in previous recipes, runs in its own `Thread`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`writeToScrol`函数中，我们将使用之前相同的循环，但现在我们将消息发送到TCP服务器。服务器修改接收到的消息，然后将其发送回我们这里。接下来，我们将它放入GUI成员队列中，正如之前的菜谱中所述，它在自己的`Thread`中运行。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 3, we have to send strings over sockets in binary format. Adding the
    integer index now becomes a little bit convoluted as we have to cast it to a string,
    encode it, and then cast the encoded string into bytes!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，我们必须以二进制格式通过套接字发送字符串。现在添加整数索引变得有些复杂，因为我们不得不将其转换为字符串，对其进行编码，然后将编码后的字符串转换为字节！
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the `b` before the string and then, well, all the rest of the required
    casting…
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串前面的`b`，然后，嗯，接下来就是所有必要的转换……
- en: We are starting the TCP server in its own thread in the initializer of the OOP
    class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在OOP类的初始化器中在自己的线程中启动TCP服务器。
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Clicking the **Click Me!** button on **Tab 1** now creates the following output
    in our `ScrolledText` widget, as well as on the console, and the response, due
    to using `Threads`, is very fast.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**点击我！**按钮在**标签1**上现在会在我们的`ScrolledText`小部件以及控制台上创建以下输出，并且由于使用了`Threads`，响应速度非常快。
- en: '![How to do it...](img/B04829_06_23.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_23.jpg)'
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a TCP server to simulate connecting to a server in our local area
    network or on the Internet. We turned our queues module into a TCP client. We
    are running both the queue and the server in their own background thread, which
    keeps our GUI very responsive.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个TCP服务器来模拟连接到我们局域网或互联网上的服务器。我们将队列模块转换成了TCP客户端。我们分别在各自的背景线程中运行队列和服务器，这使得我们的GUI界面非常响应灵敏。
- en: Using URLOpen to read data from websites
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 URLOpen 从网站读取数据
- en: This recipe shows how we can easily read entire webpages by using Python's built-in
    modules. We will display the webpage data first in its raw format and then decode
    it, and then we will display it in our GUI.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了我们如何通过使用Python内置模块轻松地阅读整个网页。我们首先以原始格式显示网页数据，然后对其进行解码，接着我们将它在我们的图形用户界面中显示。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will read the data from a webpage and then display it in the `ScrolledText`
    widget of our GUI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网页读取数据，然后将其显示在我们GUI的`ScrolledText`小部件中。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, we create a new Python module and name it `URL.py`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 Python 模块，并将其命名为 `URL.py`。
- en: We then import the required functionality to read webpages using Python.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后导入所需的Python功能来读取网页。
- en: We can do this in very few lines of code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用非常少的代码行来实现这一点。
- en: We are wrapping our code in a `try…except` block similar to Java and C#. This
    is a modern approach to coding which Python supports.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码包裹在类似于 Java 和 C# 的 `try…except` 块中。这是 Python 支持的现代编程方法。
- en: Whenever we have code that might not complete we can experiment with this code
    and, if it works, all is fine.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有可能会未完成的代码时，我们可以对这个代码进行实验，如果它工作正常，那就一切顺利。
- en: If the block of code in the `try…except` block does not work, the Python interpreter
    will throw one of several possible exceptions, which we then can catch. Once we
    have caught the exception we can decide what to do next.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try…except`代码块中的代码无法执行，Python解释器将抛出几种可能的异常之一，然后我们可以捕获这些异常。一旦我们捕获了异常，我们就可以决定接下来要做什么。
- en: There is a hierarchy of exceptions in Python and we can also create our own
    classes that inherit from and extend the Python exception classes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中存在异常的层次结构，我们还可以创建自己的类，这些类继承并扩展了 Python 的异常类。
- en: In the code shown as follows, we are mainly concerned that the URL we are trying
    to open might not be available and so we wrap our code within a `try…except` code
    block.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下展示的代码中，我们主要关注的是我们试图打开的URL可能不可用，因此我们将代码包裹在`try…except`代码块中。
- en: If the code succeeds in opening the requested URL, all is fine.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码成功打开请求的URL，一切正常。
- en: If it fails, maybe because our internet connection is down, we fall into the
    exception part of the code and print out that an exception has occurred.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，可能是因为我们的网络连接中断，我们就会进入代码的异常部分，并打印出异常已发生的信息。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: You can read more about Python exception handling at [https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html)了解更多关于Python异常处理的信息。
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在官方Python网站上调用`urlopen`，我们得到整个数据作为一个长字符串。
- en: The first print statement prints this long string out to the console.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条打印语句将这个长字符串输出到控制台。
- en: We then call `decode` on the result and this time we get a little over 1,000
    lines of web data, including some whitespace.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在结果上调用`decode`函数，这次我们得到了超过1,000行的网页数据，包括一些空白字符。
- en: We are also printing out the type of calling `urlopen`, which is an `http.client.HTTPResponse`
    object. Actually, we are printing it out first.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印出了调用类型 `urlopen`，它是一个 `http.client.HTTPResponse` 对象。实际上，我们首先打印它。
- en: '![How to do it...](img/B04829_06_24.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_24.jpg)'
- en: Here is the official Python webpage we just read. If you are a web developer,
    you probably have some good ideas what to do with the parsed data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚阅读的官方Python网页。如果你是一名网页开发者，你可能已经有一些关于如何处理解析数据的不错想法。
- en: '![How to do it...](img/B04829_06_25.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_25.jpg)'
- en: We next display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module to read the data from the webpage
    to our GUI.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来在GUI中的`ScrolledText`小部件中展示这些数据。为了做到这一点，我们必须将我们的新模块连接到从网页读取数据到我们的GUI。
- en: In order to do this, we need a reference to our GUI, and one way to do this
    is by tying our new module to the **Tab 1** button callback.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一个对我们GUI的引用，而实现这一目标的一种方法是将我们的新模块与**Tab 1**按钮回调函数关联起来。
- en: We can return the decoded HTML data from the Python webpage to the `Button`
    widget, which we can then place in the `ScrolledText` control.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将解码后的HTML数据从Python网页返回到`Button`小部件，然后我们可以将其放置在`ScrolledText`控件中。
- en: So, let's turn our code into a function and return the data to the calling code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的代码转换成一个函数，并将数据返回给调用代码。
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now write the data in our `button` callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `writeToScrol`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过首先导入新模块，然后将数据插入到小部件中，将数据写入我们的`button`回调方法到`ScrolledText`控件中。我们还在调用`writeToScrol`之后给它一些休眠时间。
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The HTML data is now displayed in our GUI widget.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 数据现在显示在我们的 GUI 小部件中。
- en: '![How to do it...](img/B04829_06_26.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_26.jpg)'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a new module to separate the code that gets the data from a webpage
    from our GUI code. This is always a good thing to do. We read in the webpage data
    and then return it to the calling code after decoding it. We then use the button
    callback function to place the returned data in the `ScrolledText` control.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的模块，用于将获取网页数据的代码与我们的GUI代码分离。这始终是一件好事。我们读取网页数据，然后在解码后将其返回给调用代码。然后我们使用按钮回调函数将返回的数据放置在`ScrolledText`控件中。
- en: This chapter introduced us to some advanced Python programming concepts, which
    we combined to produce a functional GUI program.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了一些高级的Python编程概念，我们将这些概念结合起来，创建了一个功能性的图形用户界面程序。
