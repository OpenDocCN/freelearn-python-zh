- en: Building an Internet of Things (IoT) Weather Machine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网（IoT）天气机
- en: In this chapter, we will create an internet-connected weather machine that will
    tell us the weather in random cities at the press of a button. In order to produce
    this working device, we will combine a number of concepts and technologies that
    we have covered in the book .
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个连接到互联网的天气机，它将在按下按钮时告诉我们随机城市的天气。为了制作这个工作设备，我们将结合本书中涵盖的一些概念和技术。
- en: We'll use some of the networking techniques shown in [Chapter 12](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml),
    *Networking*, as well as the display logic shown in [Chapter 13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml),
    *Interacting with the Adafruit FeatherWing OLED*, covering how to interact with
    the FeatherWing OLED. These different technologies will be combined to create
    a device that responds to touch button events by fetching live weather data using
    RESTful APIs and presenting them on an **organic light-emitting diode** (**OLED**)
    display.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第12章](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml)中展示的一些网络技术，以及[第13章](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml)中展示的显示逻辑，介绍如何与FeatherWing
    OLED交互。这些不同的技术将结合起来创建一个设备，通过触摸按钮事件获取实时天气数据，并在**有机发光二极管**（OLED）显示器上呈现。
- en: This chapter can be a useful source of information to help you create internet-connected
    devices with MicroPython that are easy to interact with and will give a rich set
    of visual outputs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可以成为一个有用的信息来源，帮助您使用MicroPython创建易于交互并提供丰富的视觉输出的物联网连接设备。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Retrieving weather data from the internet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从互联网检索天气数据
- en: Creating a function to get a city's weather
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个获取城市天气的函数
- en: Randomly selecting cities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择城市
- en: Creating a Screen object for text handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于文本处理的屏幕对象
- en: Creating a function to show a city's weather
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数来显示城市的天气
- en: Providing visual feedback when fetching weather data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取天气数据时提供视觉反馈
- en: Creating a function to display the weather for a random city
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个显示随机城市天气的函数
- en: Creating an IoT button to show the weather around the world
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个物联网按钮来显示全球各地的天气
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found in the `Chapter14` folder of the
    following GitHub repository: [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下GitHub存储库的`Chapter14`文件夹中找到：[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266 and the Assembled Adafruit
    FeatherWing OLED 128x32 OLED add-on for Feather. CircuitPython 3.1.2 was used
    for all the recipes in this chapter. You will need to apply the configuration
    described in the *Connecting to an existing Wi-Fi network* recipe from [Chapter
    10](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml), *Controlling the ESP8266*. The
    `wait_for_networking` function described in the *Creating a function to wait for
    internet connectivity* recipe from [Chapter 12](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml),
    *Networking*, will also be used in this chapter. You will also need to perform
    the steps described in [Chapter 13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml),
    *Interacting with the Adafruit FeatherWing OLED*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用Adafruit Feather HUZZAH ESP8266和已组装的Adafruit FeatherWing OLED 128x32 OLED附加件。本章的所有教程都使用了CircuitPython
    3.1.2。您需要应用[第10章](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml)中描述的*连接到现有Wi-Fi网络*教程中的配置，*控制ESP8266*。本章还将使用[第12章](63916b81-fcec-4b2b-95f2-b1acc79061a0.xhtml)中描述的*创建等待互联网连接的函数*教程中的`wait_for_networking`函数，*网络*。您还需要执行[第13章](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml)中描述的步骤，*与Adafruit
    FeatherWing OLED交互*。
- en: The recipes in this chapter use the weather API service provided by Openweather.
    This service is free to use, but you must register and obtain an **API key** (**APPID**)
    to use the service. The API key will be needed to run the code in this chapter.
    You can visit [https://openweathermap.org/appid](https://openweathermap.org/appid) to
    get an API key.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的教程使用Openweather提供的天气API服务。该服务是免费使用的，但您必须注册并获取一个API密钥（APPID）才能使用该服务。API密钥将需要在本章中运行代码。您可以访问[https://openweathermap.org/appid](https://openweathermap.org/appid)获取API密钥。
- en: Retrieving weather data from the internet
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从互联网检索天气数据
- en: This recipe will show you how to connect to the internet using the ESP8266 and
    fetch live weather data using RESTful web services. The service that we will be
    using has up-to-date weather information for over 100,000 cities around the world.
    A very large amount of weather information for each location is provided, so this
    recipe will show how we can drill down to the items that are of most interest
    to us.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示如何使用ESP8266连接到互联网，并使用RESTful Web服务获取实时天气数据。我们将使用的服务为全球10万多个城市提供最新的天气信息。每个位置提供了大量的天气信息，因此本教程将展示如何筛选出对我们最感兴趣的项目。
- en: This recipe can be useful in your projects whenever you need to pass different
    parameters to a RESTful call or when the returned results are very large and you
    need to find ways to navigate through these large datasets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程在您的项目中可能很有用，每当您需要向RESTful调用传递不同的参数，或者返回的结果非常庞大，您需要找到浏览这些大型数据集的方法。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照本教程中所需的步骤进行操作：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `API_URL` variable has now been defined, which we will use to access the
    weather API. In the next block of code, we define `APPID` and `city` to get weather
    data for. Make sure to replace the `APPID` value with your actual `APPID` value.
    We will now build the URL by combining these variables, which we we can then access:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`API_URL`变量现在已经定义，我们将使用它来访问天气API。在下一个代码块中，我们定义`APPID`和`city`以获取天气数据。确保用你实际的`APPID`值替换`APPID`值。现在我们将通过组合这些变量来构建URL，然后我们可以访问：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following block of code will connect to the weather API and retrieve the
    weather data:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将连接到天气API并检索天气数据：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We know that the response uses JSON format, so we can parse it and inspect
    how many top-level keys are in the data:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道响应使用JSON格式，所以我们可以解析它并检查数据中有多少个顶级键：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next block of code inspects the parsed weather data. There is a lot of
    nested data, so it is difficult to digest in its current form:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块检查了解析后的天气数据。由于有很多嵌套的数据，所以以当前形式很难理解：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'MicroPython doesn''t have the `pprint` module. We will copy and paste the output
    of the data and run the following on a Python REPL on a computer:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MicroPython没有`pprint`模块。我们将复制并粘贴数据的输出，并在计算机上的Python REPL上运行以下操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the next block of code on the computer''s REPL, and we will get a more
    structured representation of the data:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机的REPL上运行下一个代码块，我们将得到数据的更结构化表示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can return to the MicroPython REPL now and run the following lines of code
    to inspect the `main` key:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以返回到MicroPython REPL并运行以下代码来检查`main`键：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next lines of code will give us access to the temperature and humidity
    values of Berlin:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码将让我们访问柏林的温度和湿度数值：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can access the wind section of the data with the following lines of code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下代码访问数据的风部分：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this way, we can drill down further and get the wind speed value for the
    requested city.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以进一步深入，并获取所请求城市的风速值。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After importing the `urequests` library, we define a number of variables so
    that we can proceed and prepare the URL to perform the API call. The `API_URL`
    is a fixed constant that will not change between calls to the web service. Then,
    we define a variable to store the API key and city values. These values are combined
    to make the final URL, which we then call using the `urequests` library's `get`
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`urequests`库后，我们定义了一些变量，以便我们可以继续准备URL来执行API调用。`API_URL`是一个固定的常量，在对网络服务进行调用时不会改变。然后，我们定义一个变量来存储API密钥和城市值。这些值被组合在一起，以制作最终的URL，然后我们使用`urequests`库的`get`函数进行调用。
- en: The `return` response is parsed and the output is displayed. Because the data
    structure is so large, we use a trick to move this data to the REPL on a computer
    where we can use the `pprint` function and get a much clearer output format of
    the returned data. This makes it much easier to identify the different parts of
    the data structure and start accessing different data elements in the nested data
    structure. We then use the keys in the dictionary to access the humidity, temperature,
    and wind speed of the city of Berlin.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`响应被解析并显示输出。由于数据结构非常庞大，我们使用了一个技巧，将这些数据移动到计算机上的REPL，这样我们就可以使用`pprint`函数，并获得返回数据的更清晰的输出格式。这样可以更容易地识别数据结构的不同部分，并开始访问嵌套数据结构中的不同数据元素。然后我们使用字典中的键来访问柏林市的湿度、温度和风速。'
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The use of API keys is widespread in the world of web services. This recipe
    is a great example of how we can take these keys and include them in our API calls
    so that they can be processed successfully. We also showed the trick of copying
    data structures from our MicroPython REPL to a Python REPL on a computer. This
    lets us bounce between these two worlds and access some modules, such as `pprint`,
    that are available on computers but not on MicroPython.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务的世界中，API密钥的使用非常普遍。这个示例是一个很好的例子，说明了我们如何将这些密钥包含在我们的API调用中，以便它们可以成功处理。我们还展示了一个技巧，即将数据结构从MicroPython
    REPL复制到计算机上的Python REPL。这样我们可以在这两个世界之间跳转，并访问一些在计算机上可用但在MicroPython上不可用的模块，比如`pprint`。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Documentation on the `pprint` module can be found at [https://docs.python.org/3/library/pprint.html](https://docs.python.org/3/library/pprint.html).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprint`模块的文档可以在[https://docs.python.org/3/library/pprint.html](https://docs.python.org/3/library/pprint.html)找到。'
- en: Documentation on accessing weather data by city name can be found at [https://openweathermap.org/current#name](https://openweathermap.org/current#name).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关通过城市名称访问天气数据的文档可以在[https://openweathermap.org/current#name](https://openweathermap.org/current#name)找到。
- en: Creating a function to get a city's weather
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个获取城市天气的函数
- en: In this recipe, we will create a function to connect to the weather API and
    fetch the weather data for a particular city. We don't want to hardcode values
    such as our API keys directly in our source code. So, this recipe will also show
    you how to create a JSON formatted configuration file that can store different
    settings, such as the API key. The application will then read in the values from
    this configuration file at boot up and use them for the calls to the weather web
    services.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个连接到天气API并获取特定城市天气数据的函数。我们不希望直接在源代码中硬编码诸如API密钥之类的值。因此，这个示例还将向您展示如何创建一个JSON格式的配置文件，可以存储不同的设置，比如API密钥。应用程序将在启动时从这个配置文件中读取值，并在调用天气网络服务时使用它们。
- en: This recipe will be particularly useful to you whenever you want to keep configuration
    values separate from your code base, whether it be for security reasons or to
    just tweak these settings more easily without changing your application's source
    code. This can also help you in your own projects to organize the API calls into
    reusable functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要将配置值与代码库分开保留时，无论是出于安全原因还是为了更轻松地调整这些设置而不更改应用程序的源代码，这个示例都会对您非常有用。这也可以帮助您在自己的项目中将API调用组织成可重用的函数。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESP8266上运行此处方中提供的代码，您将需要访问REPL。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这个食谱所需的步骤进行操作：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一块代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `CONF_PATH` variable defines the location of our JSON configuration file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CONF_PATH`变量定义了我们的JSON配置文件的位置。'
- en: 'The following content should be put into the `conf.json` file on the board''s
    root folder. Replace the value of `APPID` with your actual `APPID` value:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下内容应放入板的根文件夹中的`conf.json`文件中。将`APPID`的值替换为您的实际`APPID`值：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next block of code defines a function that will read and parse the settings
    provided in your configuration file. The values of these settings are then returned
    to the calling function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一块代码定义了一个函数，该函数将读取和解析配置文件中提供的设置。然后将这些设置的值返回给调用函数：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now call the `get_conf` function and store its results into a variable
    called `conf`. The value of `APPID` is retrieved and saved into a variable for
    future use:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将调用`get_conf`函数并将其结果存储在名为`conf`的变量中。然后检索并保存`APPID`的值以供将来使用：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following block of code defines a function that receives a city name and
    performs the weather API call for that city and returns the parsed weather data:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一块代码定义了一个函数，该函数接收一个城市名称并执行该城市的天气API调用，并返回解析后的天气数据：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next block of code calls the `get_weather` function for the city of London
    and stores the result in a variable called `data`. A number of different data
    fields are then accessed and printed out:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一块代码调用`get_weather`函数获取伦敦市的天气，并将结果存储在名为`data`的变量中。然后访问并打印出多个不同的数据字段：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next block of code should be put into the `main.py` file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一块代码应该放入`main.py`文件中。
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When this script is executed, it will connect to the weather API and print out
    a number of retrieved data elements for the city of London.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将连接到天气API并打印出伦敦市检索到的多个数据元素。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main script first calls `wait_for_networking` to ensure that networking
    is up and running before making any API calls. It then retrieves the applications
    configuration data by calling `get_conf`, which parses the JSON data stored in
    the configuration file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 主脚本首先调用`wait_for_networking`来确保网络正常运行，然后调用`get_conf`来检索应用程序的配置数据，后者解析存储在配置文件中的JSON数据。
- en: The value of `APPID` is then accessed from the configuration settings. An API
    call is then made using the `get_weather` function. This function receives the
    `APPID` value and name of the city to fetch information on. With these two values,
    it can prepare the URL and make the API call.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从配置设置中访问`APPID`的值。然后使用`get_weather`函数进行API调用。此函数接收`APPID`值和要获取信息的城市名称。有了这两个值，它就可以准备URL并进行API调用。
- en: The results are then parsed and returned to the `main` function. The data structure
    is then accessed to get a number of values from the returned API call and print
    them out with their associated labels.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对结果进行解析并返回到`main`函数。然后访问数据结构以从返回的API调用中获取多个值，并打印出它们的相关标签。
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe shows a generic technique to store values such as your API keys
    outside your source code. JSON is a useful file format for storing configuration
    values, particularly when working with MicroPython, since it has built-in support
    for parsing this file format. Some applications also use the popular `.ini` file
    format for configuration files, which has support in the Python standard library.
    This Python module is not available as part of the main libraries in MicroPython,
    so it's best to avoid it in your MicroPython projects when you can.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱展示了一种通用的技术，用于将诸如API密钥之类的值存储在源代码之外。JSON是一种有用的文件格式，特别适用于存储配置值，特别是在使用MicroPython时，因为它内置支持解析此文件格式。一些应用程序还使用流行的`.ini`文件格式进行配置文件，该文件格式在Python标准库中得到支持。这个Python模块不作为MicroPython的主要库的一部分提供，因此最好在您可以的时候避免在MicroPython项目中使用它。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考：
- en: Documentation on the `json` module can be found at [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`json`模块的文档可以在[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)找到。
- en: Documentation on the `configparser` module used to parse INI files can be found
    at [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关用于解析INI文件的`configparser`模块的文档可以在[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)找到。
- en: Randomly selecting cities
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机选择城市
- en: In this recipe, we will use the `random` module to randomly select cities from
    a fixed list of cities. We first create a global variable called `CITIES` to store
    these values. We can then use a specific function in the `random` module that
    is for the specific purpose of selecting random items from a list of values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用`random`模块从固定的城市列表中随机选择城市。我们首先创建一个名为`CITIES`的全局变量来存储这些值。然后我们可以使用`random`模块中的特定函数，用于从值列表中选择随机项。
- en: The recipe will then loop 10 times and make a random selection from the list
    of cities and output details of the selected city. This recipe will be particularly
    useful to you whenever you have a project that needs to select a certain option
    randomly from a fixed list of values. You might, for example, create a dice-rolling
    MicroPython project that should choose from the values one to six on each roll.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该食谱将循环10次，从城市列表中进行随机选择，并输出所选城市的详细信息。每当您需要从固定值列表中随机选择某个选项的项目时，这个食谱将特别有用。例如，您可以创建一个骰子投掷MicroPython项目，每次投掷都应该从值1到6中选择一个值。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESP8266上运行此处方中提供的代码，您将需要访问REPL。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这个食谱所需的步骤进行操作：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL来运行以下代码行：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have now defined a list of cities that we can make a random selection from.
    The next code shows one of the simplest ways of getting random data from the `random`
    Python module:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经定义了一个城市列表，我们可以从中随机选择。下一段代码展示了从`random` Python模块中获取随机数据的最简单方法之一：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For our purposes, we can use the `choice` function, as it will randomly select
    an item from a list. The following block of code uses this method to randomly
    select three cities:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以使用`choice`函数，因为它会从列表中随机选择一个项目。以下代码块使用这种方法随机选择三个城市：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following block of code will loop 10 times and print out a randomly selected
    city in each iteration:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将循环10次，并在每次迭代中打印出一个随机选择的城市：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码应该放入`main.py`文件中：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When this script is executed, it will print out 10 randomly selected cities.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将打印出10个随机选择的城市。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We first import the `random` module that will be used to perform the random
    selection of cities. The `random` function is called repeatedly to verify that
    we can get random numbers from the module. We have created a variable called `CITIES`,
    which is our list of cities that we want to make random selections from. The `choice`
    function in the `random` module is then used to pick a random choice from this
    list. The `main` function provides a demonstration of this logic by calling the
    `choice` function 10 times and printing out the results of each call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入将用于执行城市的随机选择的`random`模块。重复调用`random`函数以验证我们可以从模块中获取随机数。我们创建了一个名为`CITIES`的变量，这是我们想要从中进行随机选择的城市列表。然后使用`random`模块中的`choice`函数从这个列表中选择一个随机选择。`main`函数通过调用`choice`函数10次并打印出每次调用的结果来演示了这种逻辑。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This chapter only needs random numbers to be chosen to create a level of unpredictability
    in the operation of the weather machine. Because of this, we don't need to worry
    about the quality of the random numbers being generated. If, however, we need
    random numbers for the purpose of some cryptographic operation, then we would
    need to be more careful of how these numbers are generated. We would also need
    to go into detail in terms of how the random number generator is initialized with
    a call to the `seed` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只需要选择随机数来创建天气机器运行的不可预测性水平。因此，我们不需要担心生成的随机数的质量。然而，如果我们需要随机数用于某些加密操作的目的，那么我们需要更加小心地生成这些数字。我们还需要详细了解随机数生成器如何通过调用`seed`函数进行初始化。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Documentation on the `choice` function can be found at [https://docs.python.org/3/library/random.html#random.choice](https://docs.python.org/3/library/random.html#random.choice).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`choice`函数的文档可以在[https://docs.python.org/3/library/random.html#random.choice](https://docs.python.org/3/library/random.html#random.choice)找到。
- en: Documentation on the `seed` function can be found at [https://docs.python.org/3/library/random.html#random.seed](https://docs.python.org/3/library/random.html#random.seed).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`seed`函数的文档可以在[https://docs.python.org/3/library/random.html#random.seed](https://docs.python.org/3/library/random.html#random.seed)找到。
- en: Creating a Screen object for text handling
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为文本处理创建一个Screen对象
- en: In this recipe, we will create a `Screen` object that will make it easier to
    write a multi-line output to the FeatherWing OLED display. The weather machine
    that we are building will want to take advantage of the multi-line output capabilities
    of the OLED display.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个`Screen`对象，它将更容易地将多行输出写入到FeatherWing OLED显示器中。我们正在构建的天气机器将希望利用OLED显示器的多行输出功能。
- en: To facilitate this output, this recipe will create an object that receives multi-line
    text and will properly position the text in its associated *x* and *y* coordinates.
    You will find this recipe useful for any projects where you are writing text content
    to the display frequently and want an automatic way to handle the multi-line output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便输出，这个示例将创建一个对象，接收多行文本，并将文本正确地定位在其关联的*x*和*y*坐标上。您会发现这个示例对于任何需要频繁向显示器写入文本内容并希望自动处理多行输出的项目非常有用。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这个示例中所需的步骤进行操作：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have imported the necessary modules and created a variable called `MESSAGE`
    that we will use to generate multi-line output messages. The next block of code
    will create the basic structure of the `Screen` object with a constructor that
    receives the `oled` display object:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经导入了必要的模块，并创建了一个名为`MESSAGE`的变量，我们将用它来生成多行输出消息。下一段代码将创建`Screen`对象的基本结构，其中包含一个接收`oled`显示对象的构造函数：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following lines of code, we create an object to interact with the display
    and an instance of the `Screen` class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们创建一个与显示器交互的对象和`Screen`类的一个实例：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now add a method to the `Screen` object that will be responsible for
    writing the multi-line text to the display:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在`Screen`对象中添加一个方法，负责将多行文本写入显示器：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now create a `Screen` object and call its `write` method. You should see
    the `''hello''` text appear on the display now:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建一个`Screen`对象并调用它的`write`方法。您应该会在显示器上看到`'hello'`文本出现：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next block of code will print a multi-line message to the display that
    takes up three lines:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码将在显示器上打印一个占据三行的多行消息：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the following code to display 10 different multi-line messages on the display:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码在显示器上显示10条不同的多行消息：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code should be put into the `screen.py` file:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`screen.py`文件中：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码应该放入`main.py`文件中：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When this script gets executed, it will print out 10 multi-line blocks of text
    to the OLED display.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将在OLED显示器上打印出10个多行文本块。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `screen` object takes a single argument to its constructor. This argument
    is the `oled` variable, which will let us interact with the display. A reference
    to this object is saved, and then all the pixels on the display are cleared. It
    also defines a method called `write`. This method receives a string, which can
    be a single or multi-line piece of text.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen`对象将其构造函数的单个参数。这个参数是`oled`变量，它将让我们与显示器交互。保存了对这个对象的引用，然后清除了显示器上的所有像素。它还定义了一个名为`write`的方法。这个方法接收一个字符串，可以是单行或多行文本。'
- en: The display is then cleared and the text is broken up into a list of strings,
    each representing a single line of output. These lines are looped through and
    written each to their correct row. Once all lines have been processed, the `show`
    method is called on the display to render the content on the screen. The `main`
    function in this recipe sets up the `screen` object and then sends one simple
    `hello` message to the display. It then loops 10 times and generates a set of
    multi-line messages, which are displayed on the screen one after the other.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后清除显示器，将文本分解为字符串列表，每个字符串代表一个输出行。这些行被循环处理，并分别写入其正确的行。一旦所有行都被处理，就会在显示器上调用`show`方法来呈现内容。这个配方中的`main`函数设置了`screen`对象，然后向显示器发送了一个简单的`hello`消息。然后循环10次并生成一组多行消息，这些消息将依次显示在屏幕上。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The design of the `Screen` object is similar to the design of other files, such
    as objects, in Python. The `sys` Python module, for example, has a `stdout` object,
    which has a `write` method that lets you write text output to the screen. Packaging
    complex interactions, such as *x*, *y* positioning for text placement into a separate
    object, will often make the rest of the code simpler and more readable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Screen`对象的设计类似于Python中其他文件（如对象）的设计。例如，Python模块`sys`有一个`stdout`对象，它有一个`write`方法，可以让您将文本输出到屏幕上。将复杂的交互（如文本放置的*x*，*y*位置）打包到一个单独的对象中，通常会使其余的代码更简单和更易读。'
- en: See also
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考：
- en: Documentation on the `stdout` object can be found at [https://docs.python.org/3/library/sys.html#sys.stdout](https://docs.python.org/3/library/sys.html#sys.stdout).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`stdout`对象的文档可以在[https://docs.python.org/3/library/sys.html#sys.stdout](https://docs.python.org/3/library/sys.html#sys.stdout)找到。
- en: Documentation on file objects that expose the `write` methods can be found at
    [https://docs.python.org/3/glossary.html#term-file-object](https://docs.python.org/3/glossary.html#term-file-object).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://docs.python.org/3/glossary.html#term-file-object](https://docs.python.org/3/glossary.html#term-file-object)找到公开`write`方法的文件对象的文档。
- en: Creating a function to show a city's weather
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个显示城市天气的函数
- en: In this recipe, we will create a function that takes the name of a city, looks
    up its weather information, and then display a portion of this information on
    the OLED display. To achieve this, the function in this recipe will combine different
    pieces from the recipes covered in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将创建一个函数，该函数接受城市的名称，查找其天气信息，然后在OLED显示器上显示部分信息。为了实现这一点，本配方中的函数将结合本章中涵盖的不同部分。
- en: In addition to outputting to the OLED, it will also print out the same information
    to standard output to facilitate debugging. This recipe can be useful to you when
    you want to see how a project such as weather machine can be broken into separate
    pieces that all call one another in a structured design.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输出到OLED，它还会将相同的信息打印到标准输出，以便进行调试。当您想要查看像天气机这样的项目如何被分解为结构化设计中互相调用的单独部分时，这个配方对您可能有用。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本配方中提供的代码。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照本配方中所需的步骤进行操作：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一段代码：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After importing the needed modules, we create a new variable called `WEATHER`
    that stores the template, which we will use to output the weather information
    to the display. Run the next block of code to set up the screen object and get
    the `APPID` value for the API calls:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入所需的模块之后，我们创建了一个名为`WEATHER`的新变量，它存储了模板，我们将使用它来将天气信息输出到显示器上。运行下一段代码来设置屏幕对象并获取API调用的`APPID`值：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following lines of code, we define the `show_weather` function that
    takes the screen, `APPID`, and the city name, and weather information for that
    city will be fetched and displayed on the screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们定义了`show_weather`函数，该函数接受屏幕、`APPID`和城市名称，然后将获取并显示该城市的天气信息：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the next block of code to call the `show_weather` function for the city
    of Tokyo. The text you see on the standard output should also be displayed on
    the OLED display:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一段代码来调用`show_weather`函数以获取东京市的天气。您在标准输出上看到的文本也应该显示在OLED显示器上：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we execute the following block of code, it will loop through all the cities
    and display their weather information on the screen:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们执行以下代码块时，它将循环遍历所有城市，并在屏幕上显示它们的天气信息：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码应该放入`main.py`文件中：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When this script gets executed, it will loop through all the city names and
    display their weather information on the OLED display.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将循环遍历所有城市名称，并在OLED显示器上显示它们的天气信息。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `show_weather` function does most of the heavy lifting in this recipe. When
    called, it first collects the weather data by calling the `get_weather` function.
    It then takes this information and populates a dictionary called `data` with three
    values. The values are the city name, its temperature, and its wind speed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_weather`函数在这个示例中承担了大部分的工作。当调用时，它首先通过调用`get_weather`函数收集天气数据。然后，它将这些信息填充到一个名为`data`的字典中，包括城市名称、温度和风速。'
- en: These values are then filled into the `WEATHER` template, which acts as a template
    to control how this information is presented on the screen. The generated text
    is then both outputted to the standard output display as well as being displayed
    on the OLED display. The main function will configure a number of variables so
    that the API calls can be made and the screen can be updated. Then, it loops through
    the list of cities and calls `show_weather` for each one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些值被填入`WEATHER`模板中，该模板用作控制如何在屏幕上呈现这些信息的模板。生成的文本既输出到标准输出显示器上，也显示在OLED显示器上。主函数将配置多个变量，以便可以进行API调用并更新屏幕。然后，它循环遍历城市列表，并为每个城市调用`show_weather`。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Python offers a lot of options when it comes to string templates. What is used
    in this recipe is the string formatting function that is built into both Python
    and MicroPython, making it an ideal choice. It's usually a good idea to keep your
    templates in their own variables, as was done in this recipe. This makes it easier
    to change labels and to visualize what the intended result will look like.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Python在字符串模板方面提供了很多选项。在这个示例中使用的是内置于Python和MicroPython中的字符串格式化函数，这使它成为一个理想的选择。通常最好将模板保存在它们自己的变量中，就像在这个示例中所做的那样。这样可以更容易地更改标签并可视化预期结果的外观。
- en: The `show_weather` function outputs the same text on both the standard output
    and the OLED display. One of the powerful aspects of dealing with textual output
    is that you can replicate the same output on many devices. You could extend this
    further and keep a record of every screen update in a text log file to help with
    debugging.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_weather`函数在标准输出和OLED显示器上输出相同的文本。处理文本输出的一个强大方面是可以在许多设备上复制相同的输出。您还可以进一步扩展这一点，并在文本日志文件中记录每次屏幕更新，以帮助调试。'
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Documentation on Python string formatting can be found at [https://docs.python.org/3.4/library/string.html#string-formatting](https://docs.python.org/3.4/library/string.html#string-formatting).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Python字符串格式化的文档可以在[https://docs.python.org/3.4/library/string.html#string-formatting](https://docs.python.org/3.4/library/string.html#string-formatting)找到。
- en: Documentation on the `Template` object can be found at [https://docs.python.org/3.4/library/string.html#template-strings](https://docs.python.org/3.4/library/string.html#template-strings).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`Template`对象的文档可以在[https://docs.python.org/3.4/library/string.html#template-strings](https://docs.python.org/3.4/library/string.html#template-strings)找到。
- en: Providing visual feedback when fetching data
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在获取数据时提供视觉反馈
- en: In this recipe, we will enhance the code in the last recipe in such a way as
    to add visual feedback each time we start the operation of fetching the weather
    data for a particular city. The first part of this recipe is to take some measurements
    to find out how slow the `show_weather` function is. This will give us a sense
    of whether the function is slow enough that it would be visible to a user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将增强上一个示例中的代码，以便在每次开始获取特定城市的天气数据时添加视觉反馈。这个示例的第一部分是进行一些测量，以找出`show_weather`函数有多慢。这将让我们了解函数是否足够慢，以至于用户可以看到。
- en: Then, we will use the `invert` feature on the display to provide immediate visual
    feedback that we have started fetching weather data. This recipe will help you
    as a real-life example of the performance challenges you can face with the hardware
    constraints of microcontrollers and how you can overcome them at times to provide
    some sort of feedback to the users of your application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用显示器上的`invert`功能提供即时的视觉反馈，表明我们已经开始获取天气数据。这个示例将帮助您了解微控制器的硬件限制所面临的性能挑战，并且如何克服这些挑战，有时为应用程序的用户提供某种反馈。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. The approach of measuring execution time and inverting colors are
    based on what was covered in the *Inverting colors on the display* recipe in [Chapter
    13](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml), *Interacting with the Adafruit
    FeatherWing* *OLED*. It will be helpful to first review that recipe before continuing
    with this one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问ESP8266上的REPL来运行本示例中呈现的代码。测量执行时间和反转颜色的方法是基于[第13章](f78cb633-f895-4ee3-9ab4-f0f1c9a45157.xhtml)中*在显示器上反转颜色*一节中介绍的，*与Adafruit
    FeatherWing* *OLED*交互。在继续本示例之前，最好先复习一下那个示例。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这个示例中所需的步骤进行操作：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL来运行以下代码行：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `measure_time` function has now been defined. Before continuing, be sure
    to paste all the function definitions, module imports, and global variables from
    the `main.py` file in the previous recipe into the REPL. Then, run the following
    code block:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`measure_time`函数现在已经定义。在继续之前，请确保将上一个示例中`main.py`文件中的所有函数定义、模块导入和全局变量粘贴到REPL中。然后，运行以下代码块：'
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now have everything we need to measure the execution time of the `show_weather`
    function. Run the next block of code to take three measurements:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经有了测量`show_weather`函数执行时间所需的一切。运行下一个代码块来进行三次测量：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From these measurements, we can see that each call takes about 2 seconds of
    execution time. We will now add to calls to the `invert` method at the start and
    end of the `show_weather` function, as shown in the next block of code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些测量中，我们可以看到每次调用大约需要2秒的执行时间。我们现在将在`show_weather`函数的开头和结尾添加对`invert`方法的调用，如下面的代码块所示：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following block of code, when executed, will provide visual feedback at
    the start and end of the `show_weather` function''s execution:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码块时，将在`show_weather`函数执行的开始和结束提供视觉反馈：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码应该放在`main.py`文件中：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When this script gets executed, it will loop through each city and call the
    `show_weather` function with the new inverted color visual feedback.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将循环遍历每个城市，并使用新的反转颜色视觉反馈调用`show_weather`函数。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `measure_time` function helped us measure how long the execution took for
    the `show_weather` function. This function is fetching data from the internet,
    parsing it, and then performing a number of screen operations to display it. The
    measured execution time was around 2 seconds. Microcontrollers, compared to desktop
    computers, have limited computational power. Operations like these on a desktop
    would take a few hundred milliseconds, but on a microcontroller can take longer.
    Because of this noticeable execution time, we have enhanced the `show_weather`
    function by inverting the colors at the very start of its execution. This color
    inversion will be shown within a few milliseconds and will be displayed before
    any other processing is done. Then, at the end of the execution, the inverted
    colors are returned back to their normal state to indicate that the function has
    completed its execution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`measure_time`函数帮助我们测量了`show_weather`函数的执行时间。该函数正在从互联网获取数据，解析数据，然后执行一些屏幕操作来显示它。测得的执行时间大约为2秒。与台式电脑相比，微控制器的计算能力有限。在台式电脑上，类似这样的操作可能需要几百毫秒，但在微控制器上可能需要更长时间。由于这种明显的执行时间，我们通过在执行的开始处反转颜色来增强`show_weather`函数。这种颜色反转将在几毫秒内显示，并且会在任何其他处理之前显示。然后，在执行结束时，反转的颜色将恢复到正常状态，以指示函数已完成执行。'
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a later recipe, when we connect the push button to the `show_weather` function,
    visual feedback will become very important. A 2 second delay in a screen update
    is very visible and users will lead some sort of visual feedback to indicate the
    machine is performing an operation as opposed to being stuck. The `invert` method
    shown in this recipe is perfect for this purpose and doesn't require very much
    additional code to achieve its result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的教程中，当我们将按钮连接到`show_weather`函数时，视觉反馈将变得非常重要。屏幕更新延迟2秒是非常明显的，用户需要某种视觉反馈来指示机器正在执行操作，而不是卡住了。本教程中展示的`invert`方法非常适合这个目的，并且不需要太多额外的代码来实现其结果。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Details on human perceptual abilities from a usability perspective can be found
    at [https://www.nngroup.com/articles/response-times-3-important-limits/](https://www.nngroup.com/articles/response-times-3-important-limits/).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从可用性的角度来看，有关人类感知能力的详细信息可以在[https://www.nngroup.com/articles/response-times-3-important-limits/](https://www.nngroup.com/articles/response-times-3-important-limits/)找到。
- en: Documentation on software usability can be found at [https://www.interaction-design.org/literature/topics/usability](https://www.interaction-design.org/literature/topics/usability).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关软件可用性的文档可以在[https://www.interaction-design.org/literature/topics/usability](https://www.interaction-design.org/literature/topics/usability)找到。
- en: Creating a function to display the weather for a random city
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来显示随机城市的天气
- en: In this recipe, we will create a function that will select a random city and
    display its weather information on the screen each time it is called. The function
    will use the `choice` function from the `random` module to select a random city,
    and then it will use the `show_weather` function to display the weather information
    for that city.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个函数，每次调用时都会选择一个随机城市并在屏幕上显示其天气信息。该函数将使用`random`模块中的`choice`函数来选择一个随机城市，然后使用`show_weather`函数来显示该城市的天气信息。
- en: This recipe can be useful to you whenever you are in a situation where you want
    to add some randomness to a project so that there is a greater level of unpredictability
    in the interaction with that device. This can create some unexpected and surprising
    behavior in your projects that make them more interesting to interact with.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要向项目中添加一些随机性以使与该设备的交互更加不可预测的情况下，本教程可能对您有用。这可以在您的项目中创建一些意想不到的和令人惊讶的行为，使其更有趣。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s check for the steps required in this recipe:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个教程需要哪些步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `show_random_weather` function has now been defined. Before continuing,
    be sure to paste all the function definitions, module imports, and global variables
    from the `main.py` file in the previous recipe into the REPL. Then, run the following
    code block:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`show_random_weather`函数现在已经定义。在继续之前，请确保将上一个教程中的`main.py`文件中的所有函数定义，模块导入和全局变量粘贴到REPL中。然后，运行以下代码块：'
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the next block of code and the weather of a random city will be displayed:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一段代码，将显示随机城市的天气：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will now loop three times and call the `show_random_weather` function to
    test its functionality:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将循环三次并调用`show_random_weather`函数来测试其功能：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码应该放在`main.py`文件中：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When this script gets executed, it will loop three times and select a random
    city in each iteration, which will have its weather information displayed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将循环三次并在每次迭代中选择一个随机城市，然后显示其天气信息。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `show_random_weather` function expects two arguments as its input. The screen
    and `APPID` are needed as input arguments to make the needed API calls and update
    the screen contents. The `choice` function of the `random` module is called on
    the `CITIES` list to select a random city. Once this city is selected, its weather
    can be fetched and displayed using the `show_weather` function. The `main` function
    in this recipe loops three times and calls the `show_random_weather` function
    in each `for` loop iteration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_random_weather`函数期望两个参数作为其输入。屏幕和`APPID`需要作为输入参数，以进行所需的API调用并更新屏幕内容。在`random`模块的`choice`函数上调用`CITIES`列表，以选择一个随机城市。一旦选择了这个城市，就可以使用`show_weather`函数获取并显示其天气。在这个示例中，`main`函数循环三次，并在每个`for`循环迭代中调用`show_random_weather`函数。'
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe is one of the last remaining pieces of the internet-connected weather
    machine. We have built and tested each piece of this application to confirm that
    each one goes before building additional logic on the previous layer. All the
    code and logic of this recipe is self-contained in its own function, which improves
    code readability and also helps with troubleshooting. If any errors occur, it
    will be easier to troubleshoot by knowing exactly which function the exception
    was raised in.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是互联网连接的天气机器的最后几个部分之一。我们已经构建和测试了应用程序的每个部分，以确认每个部分在构建上一层的附加逻辑之前都是正常的。这个示例的所有代码和逻辑都是自包含的，这提高了代码的可读性，也有助于故障排除。如果发生任何错误，通过确切地知道异常是在哪个函数中引发的，将更容易进行故障排除。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Documentation on interacting with displays on MicroPython details can be found
    at [https://learn.adafruit.com/micropython-displays-drawing-shapes](https://learn.adafruit.com/micropython-displays-drawing-shapes).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与MicroPython交互显示的文档详细信息可以在[https://learn.adafruit.com/micropython-displays-drawing-shapes](https://learn.adafruit.com/micropython-displays-drawing-shapes)找到。
- en: Documentation on a microcontroller project using the Adafruit FeatherWing OLED
    can be found at [https://learn.adafruit.com/digital-display-badge](https://learn.adafruit.com/digital-display-badge).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Adafruit FeatherWing OLED的微控制器项目的文档可以在[https://learn.adafruit.com/digital-display-badge](https://learn.adafruit.com/digital-display-badge)找到。
- en: Creating an IoT button to show the weather around the world
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个显示世界各地天气的物联网按钮
- en: In this recipe, we will add the final touch to our internet-connected weather
    machine. We will take the bulk of code introduced in the recipes throughout this
    chapter and add an `event` loop to our `main` function so that we can react to
    button press events by displaying the weather of random cities around the world.
    This recipe will provide you with a good example of how you can add an `event`
    loop to an existing code base to create user interactivity.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将为我们的互联网连接的天气机器添加最后的修饰。我们将在本章中介绍的代码大部分，并在`main`函数中添加一个`事件`循环，以便我们可以通过显示世界各地随机城市的天气来响应按钮按下事件。这个示例将为您提供一个很好的例子，说明您如何向现有代码库添加`事件`循环，以创建用户交互性。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s follow the steps required in this recipe:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照这个示例中所需的步骤进行操作：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一个代码块：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Pin` object is now imported so that we can interact with the board''s
    push buttons. Before continuing, be sure to paste all the function definitions,
    module imports, and global variables from the `main.py` file in the previous recipe into
    the REPL. Then run the following code block:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入`Pin`对象，以便我们可以与板载按钮进行交互。在继续之前，请确保将上一个示例中的`main.py`文件中的所有函数定义、模块导入和全局变量粘贴到REPL中。然后运行以下代码块：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `button` variable can now read the state of push button A. Run the next
    block of code to detect whether push button A is currently being pressed:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`button`变量现在可以读取按钮A的状态。运行下一个代码块来检测当前是否按下按钮A：'
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While pressing push button A, execute the following block of code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按下按钮A时，执行以下代码块：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the next block of code to prepare the `screen` and `APPID` variables:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一个代码块来准备`screen`和`APPID`变量：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following block of code will start an `event` loop. Each time you press
    push button A, the weather of a random city should be displayed:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将启动一个`事件`循环。每次按下按钮A时，应显示一个随机城市的天气：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next block of code should be put into the `main.py` file:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块应放入`main.py`文件中：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When this script gets executed, it will kick off an `event` loop that will fetch
    and display the weather of a random city each time push button A is pressed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将启动一个`事件`循环，每次按下按钮A时都会获取并显示一个随机城市的天气。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `main` function in this recipe creates a `Pin` object called `Button` that
    will be connected to push button A. We can use this `button` variable to poll
    the state of the push button. We then show the weather for a random city so that
    the starting state of the application is the weather being shown on the display.
    Then, an `infinite` loop is started, which will be our `event` loop to process
    any push button events. In each loop, we check whether push button A is pressed.
    If it is, then the `show_random_weather` function is called to display the weather
    of a random city on the screen.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中的`main`函数创建了一个名为`Button`的`Pin`对象，它将连接到按钮A。我们可以使用这个`button`变量来轮询按钮的状态。然后，我们显示一个随机城市的天气，以便应用程序的起始状态是显示屏上显示的天气。然后，启动一个`无限`循环，这将是我们的`事件`循环，用于处理任何按钮事件。在每个循环中，我们检查按钮A是否被按下。如果是，则调用`show_random_weather`函数在屏幕上显示一个随机城市的天气。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This recipe reacts to a single push button to show random weather. We could
    connect push button B and C to our main `event` loop and have them produce other
    functionalities. Push button A might change the city while B and C could let you
    scroll and see more weather information relating to the currently selected city.
    The next photograph shows what the internet-connected weather machine looks like
    when showing weather information on the city of Tokyo:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的食谱对单个按钮的按下做出反应，显示随机天气。我们可以将按钮B和C连接到我们的主“事件”循环，并让它们产生其他功能。按下按钮A可能会更改城市，而B和C可以让您滚动并查看与当前选择的城市相关的更多天气信息。下一张照片显示了连接到互联网的天气机在显示东京市天气信息时的样子：
- en: '![](assets/c0b499f3-126b-47ee-b061-1ca6896c55dc.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c0b499f3-126b-47ee-b061-1ca6896c55dc.png)'
- en: This recipe could also be changed to fetch and display any information from
    web services. You could fetch the latest news headlines and display them, or display
    a random joke from a RESTful joke API. The sky is the limit to what you can do
    with a multi-line text display and internet connectivity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱也可以更改为从网络服务中获取和显示任何信息。您可以获取最新的新闻头条并显示它们，或者从RESTful笑话API中显示一个随机笑话。拥有多行文本显示和互联网连接，您可以做的事情是无限的。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references for further information:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步信息的参考资料：
- en: Documentation on using the `PULL_UP` setting with buttons on MicroPython can
    be found at [https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs](https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于在MicroPython上使用`PULL_UP`设置与按钮的文档可以在[https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs](https://learn.adafruit.com/micropython-hardware-digital-i-slash-o/digital-inputs)找到。
- en: Documentation on a RESTful jokes API can be found at [http://www.icndb.com/api/](http://www.icndb.com/api/).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用RESTful笑话API的文档可以在[http://www.icndb.com/api/](http://www.icndb.com/api/)找到。
