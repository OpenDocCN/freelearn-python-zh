- en: Chapter 3. Unit Testing with Doctest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用Doctest进行单元测试
- en: '*Okay, so we''ve talked about what doctest does, and how to make it behave
    the way we want. We''ve talked about testing things with doctest too. What''s
    left to talk about in this chapter, then? In this chapter, we''ll be talking about
    the programming discipline called Unit testing. We''ll still be using doctest,
    but this time the focus is on what you''re doing and why, rather than on the details
    of how to do it.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*好的，我们已经讨论了doctest的功能以及如何让它按我们的意愿运行。我们也讨论了使用doctest进行测试。那么，在这一章中还有什么要讨论的呢？在这一章中，我们将讨论称为单元测试的编程纪律。我们仍然会使用doctest，但这次的重点是你在做什么以及为什么，而不是如何做的细节。*'
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将：
- en: Discuss in detail what Unit testing is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细讨论单元测试是什么
- en: Talk about the ways in which Unit testing helps various stages of development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论单元测试如何帮助开发各个阶段
- en: Work with examples that illustrate Unit testing and its advantages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例来说明单元测试及其优势
- en: So, let's get on with it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: What is Unit testing and what it is not?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试是什么，它不是什么？
- en: 'The title of this section, begs another question: "Why do I care?" One answer
    is that Unit testing is a best practice that has been evolving toward its current
    form over most of the time that programming has existed. Another answer is that
    the core principles of Unit testing are just good sense; it might actually be
    a little embarrassing to our community as a whole that it took us so long to recognize
    them.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题又提出了另一个问题：“我为什么要关心？”一个答案是，单元测试是一种最佳实践，它在编程存在的大部分时间里一直在演变。另一个答案是，单元测试的核心原则只是常识；对我们整个社区来说，我们花了这么长时间才认识到它们，这实际上可能有点尴尬。
- en: Alright, so what is Unit testing? In its most fundamental form, Unit testing
    can be defined as testing the smallest meaningful pieces of code (such pieces
    are called units), in such a way that each piece's success or failure depends
    only on itself. For the most part, we've been following this principle already.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么什么是单元测试？在其最基本的形式中，单元测试可以被定义为以这样的方式测试代码的最小有意义的部分（这样的部分被称为单元），即每个部分的成功或失败只取决于它自己。在很大程度上，我们已经在遵循这个原则了。
- en: 'There''s a reason for each part of this definition: we test the smallest meaningful
    pieces of code because, when a test fails, we want that failure to tell where
    the problem is us as specifically as possible. We make each test independent because
    we don''t want a test to make any other test succeed, when it should have failed;
    or fail when it should have succeeded. When tests aren''t independent, you can''t
    trust them to tell you what you need to know.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定义中的每一部分都有其原因：我们测试最小的有意义的代码部分，因为当测试失败时，我们希望这个失败尽可能具体地告诉我们问题所在。我们使每个测试独立，因为我们不希望一个测试在它应该失败时让另一个测试成功；或者在一个测试应该成功时让它失败。当测试不独立时，你不能信任它们告诉你你需要知道的信息。
- en: Traditionally, automated testing is associated with Unit testing. Automated
    testing makes it fast and easy to run unit tests, which tend to be amenable to
    automation. We'll certainly make heavy use of automated testing with doctest and
    later with tools such as unittest and Nose as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，自动化测试与单元测试相关联。自动化测试使得运行单元测试变得快速且容易，而这些单元测试往往易于自动化。我们肯定会大量使用自动化测试，包括doctest，以及之后的unittest和Nose等工具。
- en: Any test that involves more than one unit is automatically not a unit test.
    That matters because the results of such tests tend to be confusing. The effects
    of the different units get tangled together, with the end result that not only
    do you not know where the problem is (is the mistake in this piece of code, or
    is it just responding correctly to bad input from some other piece of code?),
    you're also often unsure exactly what the problem is this output is wrong, but
    how does each unit contribute to the error? Empirical scientists must perform
    experiments that check only one hypothesis at a time, whether the subject at hand
    is chemistry, physics, or the behavior of a body of program code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何涉及多个单元的测试自动就不是单元测试。这很重要，因为这类测试的结果往往令人困惑。不同单元的效果交织在一起，最终结果是，你不仅不知道问题出在哪里（是这段代码中的错误，还是只是对其他代码的错误输入做出了正确的响应？），而且你通常也不确定具体的问题是什么——这个输出是错误的，但每个单元是如何导致错误的？经验科学家必须进行实验，每次只检查一个假设，无论研究对象是化学、物理还是程序代码的行为。
- en: Time for action – identifying units
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——识别单元
- en: 'Imagine that you''re responsible for testing the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你负责测试以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, what are the units? Is the whole class a single unit, or is
    each method a separate unit. How about each statement, or each expression? Keep
    in mind that the definition of a unit is somewhat subjective (although never bigger
    than a single class), and make your own decision.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，单位是什么？整个班级是一个单独的单位，还是每种方法是一个单独的单位。每个语句或每个表达式又如何呢？请记住，单位的定义是相对主观的（尽管永远不会大于单个班级），并做出自己的决定。
- en: Think about what you chose. What would the consequences have been if you chose
    otherwise? For example, if you chose to think of each method as a unit, what would
    be different if you chose to treat the whole class as a unit?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑你的选择。如果你选择了不同的选择，会有什么后果？例如，如果你选择将每个方法视为一个单位，如果你选择将整个类作为单位处理，会有什么不同？
- en: Consider `method4`. Its result depends on all of the other methods working correctly.
    On top of that, it depends on something that changes from one test run to another,
    the unique ID of the `self` object. Is it even possible to treat `method4` as
    a unit in a self-contained test? If we could change anything except `method4`,
    what would we have to change to enable `method4` to run in a self-contained test
    and produce a predictable result?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑`method4`。它的结果依赖于所有其他方法正确工作。除此之外，它还依赖于从一个测试运行到另一个测试运行发生变化的东西，即`self`对象的唯一ID。在自包含测试中将`method4`作为单位是否甚至可能？如果我们可以改变除`method4`之外的一切，我们还需要改变什么才能使`method4`在自包含测试中运行并产生可预测的结果？
- en: '*What just happened?*'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: By answering those three questions, you thought about some of the deeper aspects
    of unit testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答这三个问题，你思考了单元测试的一些更深入的方面。
- en: The question of what constitutes a unit, is fundamental to how you organize
    your tests. The capabilities of the language affects this choice. C++ and Java
    make it difficult or impossible to treat methods as units, for example, so in
    those languages each class is usually treated as a single unit. C, on the other
    hand, doesn't support classes as language features at all, so the obvious choice
    of unit is the function. Python is flexible enough that either classes or methods
    could be considered units, and of course it has stand-alone functions as well,
    which are also natural to think of as units. Python can't easily handle individual
    statements within a function or method as units, because they don't exist as separate
    objects when the test runs. They're all lumped together into a single code object
    that's part of the function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单位构成的问题对于你如何组织你的测试是基本的。语言的能力影响这个选择。例如，C++和Java使得将方法作为单位处理变得困难或不可能，因此在这些语言中，每个类通常被视为一个单独的单位。另一方面，C语言根本不支持类作为语言特性，因此显然的单位选择是函数。Python足够灵活，既可以认为类或方法作为单位，当然它也有独立的函数，这些函数也自然地被认为是单位。Python无法轻松地将函数或方法内的单个语句作为单位处理，因为当测试运行时，它们并不作为单独的对象存在。它们都被合并成一个单一的代码对象，这是函数的一部分。
- en: The consequences of your choice of unit are far-reaching. The smaller the units
    are, the more useful the tests tend to be, because they narrow down the location
    and nature of bugs more quickly. For example, one of the consequences of choosing
    to treat the testable class as a single unit is that tests of the class will fail
    if there is a mistake in any of the methods. That tells you that there's a mistake
    in testable, but not (for example) that it's in `method2`. On the other hand,
    there is a certain amount of rigmarole involved in treating `method4` and its
    like as units, to such an extent that the next chapter of the book is dedicated
    to dealing with such situations. Even so, I recommend using methods and functions
    as units most of the time, because it pays off in the long run.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择单位的结果是深远的。单位越小，测试通常越有用，因为它们可以更快地缩小错误的位置和性质。例如，选择将可测试的类作为单个单位的一个后果是，如果任何方法中存在错误，类的测试将失败。这告诉你存在错误，但并不是（例如）在`method2`中。另一方面，将`method4`及其类似方法作为单位处理涉及一定程度的繁琐，以至于本书的下一章专门用于处理这种情况。即便如此，我建议大多数时候使用方法和函数作为单位，因为从长远来看这是值得的。
- en: In answering the third question, you probably discovered that the functions
    `id` and `self.method3` would need to have different definitions, definitions
    that produced a predictable result, and did so without invoking code in any of
    the other units. In Python, replacing the real function with such stand-ins is
    fairly easy to do in an ad hoc manner, but we'll be discussing a more structured
    approach in the next chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答第三个问题时，你可能发现函数`id`和`self.method3`需要有不同的定义，这些定义会产生可预测的结果，并且在不调用任何其他单元的代码的情况下完成。在Python中，用这种临时代替品替换真实函数相对容易，但在下一章中我们将讨论一种更结构化的方法。
- en: Pop quiz – understanding units
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验——理解单位
- en: 'Consider this code and then try to answer the questions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，然后尝试回答问题：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assuming that methods are units, how many units exist in the above code?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设方法就是单元，上述代码中存在多少个单元？
- en: Which units make assumptions about the correct operation of other units? In
    other words, which units are not independent?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些单元假设其他单元的正确运行？换句话说，哪些单元不是独立的？
- en: What would you need to do to create a test for `method2` that was independent
    of other units?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要做什么来创建一个对其他单元独立的`method2`测试？
- en: Unit testing throughout the development process
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发过程中的单元测试
- en: We'll walk through the development of a single class, treating it with all the
    dignity of a real project. We'll be strictly careful to integrate unit testing
    into every phase of the project. This may seem silly at times, but just play along.
    There's a lot to learn from the experience.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍一个单一类的开发，对待它就像对待一个真实项目一样。我们将严格确保将单元测试集成到项目的每个阶段。这有时可能看起来很愚蠢，但请配合一下。从经验中我们可以学到很多东西。
- en: The example we'll be working with is a PID controller. The basic idea is that
    a PID controller is a feedback loop for controlling some piece of real-world hardware.
    It takes input from a sensor that can measure some property of the hardware, and
    generates a control signal that adjusts that property toward some desired state.
    The position of a robot arm in a factory might be controlled by a PID controller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的例子是一个PID控制器。基本思想是PID控制器是控制现实世界硬件的反馈回路。它从可以测量硬件某些属性的传感器获取输入，并生成一个控制信号来调整该属性以达到某个期望的状态。在工厂中，机器人手臂的位置可能由PID控制器控制。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to know more about `PID` controllers, the Internet is rife with
    information. The Wikipedia entry is a good place to start: [http://en.wikipedia.org/wiki/PID_controller](http://en.wikipedia.org/wiki/PID_controller).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`PID`控制器的信息，互联网上充满了相关信息。维基百科条目是一个很好的起点：[http://en.wikipedia.org/wiki/PID_controller](http://en.wikipedia.org/wiki/PID_controller)。
- en: Design phase
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计阶段
- en: 'Our notional client comes to us with the following (rather sparse) specification:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的概念客户向我们提出了以下（相当稀疏的）规范：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Time for action – unit testing during design
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——设计阶段的单元测试
- en: Time to make that specification a bit more formal—and complete—by writing unit
    tests that describe the desired behavior.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将那个规范变得更加正式和完整，通过编写描述所需行为的单元测试来实现。
- en: 'We need to write a test that describes the PID constructor. After checking
    our references, we determine that a PID controller is defined by three `gains`,
    and a `setpoint`. The controller has three components: proportional, integral
    and derivative (hence the name PID). Each `gain` is a number that determines how
    much one of the three parts of the controller has on the final result. The `setpoint`
    determines what the goal of the controller is; in other words, to where it''s
    trying to move the controlled variable. Looking at all that, we decide that the
    constructor should just store the `gains` and the `setpoint`, along with initializing
    some internal state that we know we''ll need due to reading up on the workings
    of a PID controller:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写一个测试来描述PID构造函数。在检查我们的参考后，我们确定PID控制器由三个`增益`和一个`设定点`定义。控制器有三个组成部分：比例、积分和微分（因此得名PID）。每个`增益`是一个数字，它决定了控制器三个部分中的哪一个对最终结果的影响程度。`设定点`决定了控制器的目标；换句话说，它试图将控制变量移动到哪个位置。考虑到所有这些，我们决定构造函数应该只存储`增益`和`设定点`，以及初始化一些内部状态，我们知道我们将来会因为阅读PID控制器的工作原理而需要这些状态：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to write tests that describe measurement processing. This is the controller
    in action, taking a measured value as its input and producing a control signal
    that should smoothly move the measured variable to the `setpoint`. For this to
    work correctly, we need to be able to control what the controller sees as the
    current time. After that, we plug our test input values into the math that defines
    a PID controller, along with the `gains`, to figure out what the correct outputs
    would be:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写描述测量处理的测试。这是控制器在起作用，它将测量值作为输入，并产生一个控制信号，该信号应该平滑地将测量变量移动到`setpoint`。为了正确工作，我们需要能够控制控制器看到的是当前时间。之后，我们将我们的测试输入值插入到定义PID控制器的数学中，包括`gains`，以确定正确的输出应该是什么：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to write tests that describe `setpoint` handling. Our client asked for
    a `setpoint` stack, so we write tests that check such stack behavior. Writing
    code that uses this stack behavior brings to our attention that fact that a PID
    controller with no `setpoint` is not a meaningful entity, so we add a test that
    checks that the PID class rejects that situation by raising an exception.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写描述`setpoint`处理的测试。我们的客户要求一个`setpoint`堆栈，所以我们编写了检查这种堆栈行为的测试。编写使用这种堆栈行为的代码使我们注意到，没有`setpoint`的PID控制器不是一个有意义的实体，因此我们添加了一个测试来检查PID类通过抛出异常来拒绝这种情况。
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Our clients gave us a pretty good initial specification, but it left a lot of
    details to assumption. By writing these tests, we've codified exactly what our
    goal is. Writing the tests forced us to make our assumptions explicit. Additionally,
    we've gotten a chance to use the object, which gives us an understanding of it
    that would otherwise be hard to get at this stage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户给了我们一个相当好的初始规格说明，但它留下了很多细节需要假设。通过编写这些测试，我们已经明确地定义了我们的目标。编写测试迫使我们明确我们的假设。此外，我们还得到了一个使用对象的机会，这让我们对这个对象的理解比这个阶段更难获得。
- en: Normally we'd place the doctests in the same file as the specification, and
    in fact that's what you'll find in the book's code archive. In the book format,
    we used the specification text as the description for each step of the example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会将doctests放在与规格说明相同的文件中，实际上你会在书籍的代码存档中找到这些内容。在书籍格式中，我们使用了规格说明文本作为每个示例步骤的描述。
- en: You could ask how many tests we should write for each piece of the specification.
    After all, each test is for certain specific input values, so when code passes
    it, all it proves is that the code produces the right results for that specific
    input. The code could conceivably do something entirely wrong, and still pass
    the test. The fact is that it's usually a safe assumption that the code you'll
    be testing was supposed to do the right thing, and so a single test for each specified
    property fairly well distinguishes between working and non-working code. Add to
    that tests for any boundaries specified—for "The X input may be between the values
    1 and 7, inclusive" you might add tests for X values of 0.9 and 7.1 to make sure
    they weren't accepted—and you're doing fine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，对于每个规格说明的部分，我们应该编写多少个测试。毕竟，每个测试都是为了特定的输入值，所以当代码通过它时，它所证明的只是代码为那个特定的输入产生了正确的结果。代码可能实际上做了一些完全错误的事情，但仍然可以通过测试。事实上，通常可以安全地假设你将要测试的代码原本应该是做正确的事情，因此针对每个指定的属性进行单个测试，可以很好地区分出正常和异常的代码。再加上对任何指定的边界值进行的测试——对于“X输入值可能在1和7之间，包括1和7”的情况，你可能需要添加对X值为0.9和7.1的测试，以确保它们不会被接受——这样你就做得很好了。
- en: There were a couple of tricks we pulled to make the tests repeatable and independent.
    In every test after the first, we called the `reload` function on the `pid` module,
    to reload it from the disk. That has the effect of resetting anything that might
    have changed in the module, and causes it to re-import any modules that it depends
    on. That latter effect is particularly important, since in the tests of measure,
    we replaced `time.time` with a dummy function. We want to be sure that the `pid`
    module uses the dummy time function, so we reload the `pid` module. If the real
    time function is used instead of the dummy, the test won't be useful, because
    there will be only one time in all of history at which it would succeed. Tests
    need to be repeatable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些技巧来使测试可重复和独立。在第一个测试之后，我们在`pid`模块上调用`reload`函数，从磁盘重新加载它。这会重置模块中可能发生变化的任何内容，并导致它重新导入它所依赖的任何模块。后者的效果尤为重要，因为在测量测试中，我们用虚拟函数替换了`time.time`。我们想确保`pid`模块使用虚拟时间函数，所以我们重新加载`pid`模块。如果使用真实的时间函数而不是虚拟函数，测试将没有用处，因为历史上只有一个时间点它会成功。测试需要可重复。
- en: The dummy time function is created by making an iterator that counts through
    the integers from 1 to 999 (as floating point values), and binding `time.time`
    to that iterator's `next` method. Once we were done with the time-dependent tests,
    we replaced the original `time.time`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟时间函数是通过创建一个迭代器，从1到999（以浮点值形式）计数，并将`time.time`绑定到该迭代器的`next`方法来创建的。一旦我们完成了与时间相关的测试，我们就替换了原始的`time.time`。
- en: Right now, we have tests for a module that doesn't exist. That's good! Writing
    the tests was easier than writing the module will be, and it gives us a stepping
    stone toward getting the module right, quickly and easily. As a general rule,
    you always want to have tests ready before the code that they test is written.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个模块的测试，而这个模块并不存在。这很好！编写测试比编写模块要容易，这为我们快速、轻松地编写正确的模块提供了一个垫脚石。一般来说，你总是希望在编写测试的代码之前就准备好测试。
- en: Pop quiz – unit testing during design
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 – 设计过程中的单元测试
- en: Why should we care whether tests are independent of each other, when the code
    they're testing is imaginary and the tests can't even be run?
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们测试的代码是虚构的，而且测试甚至无法运行时，我们为什么关心测试是否相互独立呢？
- en: Why are you, as a programmer, writing tests during this phase? Should this be
    part of the job of the people writing the specification instead?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么作为程序员，你在这一阶段编写测试？这应该是编写规范的人的工作内容吗？
- en: Tests at this phase try to make use of code that hasn't been written yet, and
    so they end up—in a sense—defining that code. What advantages and disadvantages
    does this have?
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一阶段的测试试图使用尚未编写的代码，因此它们在某种程度上定义了那段代码。这有什么优点和缺点？
- en: Have a go hero
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'Try this a few times on your own: Describe some program or module that you''d
    enjoy having access to in real life, using normal language. Then go back through
    it and try writing tests, describing the program or module. Keep an eye out for
    places where writing the test makes you aware of ambiguities in your prior description,
    or makes you realize that there''s a better way to do something.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己这样做几次：描述一些你希望在现实生活中能够访问的程序或模块，使用正常语言。然后回到它上面，尝试编写测试，描述程序或模块。注意那些编写测试让你意识到先前描述中的模糊性，或者让你意识到有更好的做事方式的地方。
- en: Development phase
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发阶段
- en: With tests in hand, we're ready to write some code. The tests will act as a
    guide to us, a specification that actively tells us when we get something wrong.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有测试在手，我们准备编写一些代码。测试将作为我们的指南，一个主动告诉我们何时出错的规定。
- en: Time for action – unit testing during development
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 开发过程中的单元测试
- en: The first step is to run the tests. Of course, we have a pretty good idea of
    what's going to happen; they're all going to fail. Still, it's useful to know
    exactly what the failures are, because those are the things that we need to address
    by writing code.![Time for action – unit testing during development](img/8846_03_01.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是运行测试。当然，我们相当清楚将要发生什么；它们都会失败。然而，了解确切的失败原因是有用的，因为那些是我们需要通过编写代码来解决的问题。![行动时间
    – 开发过程中的单元测试](img/8846_03_01.jpg)
- en: There are many more failing tests after that, but you get the idea.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后还有更多失败的测试，但你应该已经明白了这个概念。
- en: 'Taking our cue from the tests, and our references on PID controllers, we write
    the `pid.py` module:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试和我们对PID控制器的参考资料中汲取灵感，我们编写了`pid.py`模块：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next we run the tests again. We're hoping that they will all pass, but unfortunately
    the measure method seems to have some sort of bug.![Time for action – unit testing
    during development](img/8846_03_02.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们再次运行测试。我们希望它们都能通过，但不幸的是，测量方法似乎有一些bug。![行动时间 - 开发中的单元测试](img/8846_03_02.jpg)
- en: There are several more reports showing similar things (five tests in total should
    fail). The measure function is working backwards, returning positive numbers when
    it should be returning negative, and vice-versa.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有几个报告显示了类似的情况（总共应该有五个测试失败）。测量函数正在反向工作，当它应该返回负数时却返回了正数，反之亦然。
- en: 'We know we need to look for a sign error in the measure method, so we don''t
    have too much trouble finding and fixing the bug. The measured value should be
    subtracted from the setpoint, not the other way around, on the fourth line of
    the `measure` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道需要在测量方法中寻找符号错误，所以我们不太难找到并修复这个错误。在`measure`方法的第四行，应该从设定点减去测量值，而不是反过来：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After fixing that, we find that all the tests pass.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修复了那个问题之后，我们发现所有测试都通过了。
- en: '*What just happened?*'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We used our tests to tell us what needed to be done and when our code was finished.
    Our first run of the tests gave us a list of things that needed to be written;
    a to-do list, of sorts. After we wrote some code, we ran the tests again to see
    if it was doing what we expected, which gave us a new to-do list. We keep on alternating
    between running the tests and writing code until the tests all passed. When all
    the tests pass, either we're done, or we need to write more tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用测试来告诉我们需要做什么，以及何时我们的代码完成。我们第一次运行测试给我们列出了一些需要编写的事情；类似于待办事项列表。在我们编写了一些代码之后，我们再次运行测试以查看它是否按预期工作，这给了我们一个新的待办事项列表。我们继续在运行测试和编写代码之间交替，直到所有测试都通过。当所有测试都通过时，要么我们就完成了，要么我们需要编写更多的测试。
- en: Whenever we find a bug that isn't already caught by a test, the right thing
    to do is to add a test that catches it, and then to fix it. That way, you not
    only have a fixed bug, you have a test that covers some aspect of the program
    that wasn't tested before. That test may well catch other bugs in the future,
    or tell you if you accidentally re-introduced the original bug.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发现一个测试尚未捕获的bug时，正确的做法是添加一个测试来捕获它，然后修复它。这样，你不仅修复了bug，还添加了一个测试，覆盖了之前未测试的程序的一些方面。这个测试可能会在未来捕获其他bug，或者告诉你你是否意外地重新引入了原始bug。
- en: This "test a little, code a little" style of programming is called *Test-Driven
    Development*, and you'll find that it's very productive.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“测试一点，编码一点”的编程风格被称为*测试驱动开发*，你会发现它非常高效。
- en: Notice that the pattern in the way the tests failed was immediately apparent.
    There's no guarantee that this will always be the case, of course, but it's quite
    common. Combined with the ability to narrow your attention to the specific units
    that are having problems, debugging is usually a snap.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到测试失败的模式立即就显现出来了。当然，这并不能保证总是如此，但这种情况相当普遍。结合能够将注意力集中在有问题的特定单元上，调试通常很容易完成。
- en: Another thing to think about is test isolation. The methods of the `PID` class
    make use of variables stored in `self`, which means that in order for the tests
    to be isolated, we have to make sure that none of the changes to `self` variables
    made by any method propagate to any other method. We did that by just reloading
    the `pid` module and making a new instance of the `PID` class for each test. As
    long as the test (and the code being tested) doesn't invoke any other methods
    on `self`, that's all that we need.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要考虑的事情是测试隔离。`PID`类的使用方法依赖于存储在`self`中的变量，这意味着为了使测试隔离，我们必须确保任何方法对`self`变量的更改都不会传播到任何其他方法。我们通过仅重新加载`pid`模块并为每个测试创建一个新的`PID`类实例来实现这一点。只要测试（以及被测试的代码）不调用`self`上的任何其他方法，这就足够了。
- en: Feedback phase
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈阶段
- en: So, we have a PID controller, and it passes all the tests. We're feeling pretty
    good. Time to brave the lions, and show it to the client!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个PID控制器，并且它通过了所有的测试。我们感觉相当不错。是时候勇敢面对狮子，向客户展示它了！
- en: 'Luckily for us, for the most part they like it. They do have a few requests,
    though: They want us to let them optionally specify the current time as a parameter
    to `measure`, instead of just using `time.time` to figure it out. They also want
    us to change the signature of the constructor so that it takes an initial measurement
    and optional time as parameters. Finally, they want us to rename the `measure`
    function to `calculate_response`, because they think that more clearly describes
    what it does.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大部分人都喜欢这样。尽管他们也有一些要求：他们希望我们允许他们可选地指定当前时间作为`measure`的参数，而不是仅仅使用`time.time`来计算。他们还希望我们更改构造函数的签名，使其接受初始测量值和可选时间作为参数。最后，他们希望我们将`measure`函数重命名为`calculate_response`，因为他们认为这更清楚地描述了它的功能。
- en: Time for action – unit testing during feedback
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 反馈期间的单元测试
- en: So, how are we going to deal with this? The program passes all the tests, but
    the tests no longer reflect the requirements.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何处理这个问题呢？程序通过了所有测试，但测试不再反映需求。
- en: Add the initial parameter to the constructor test, and update the expected results.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数测试中添加初始参数，并更新预期结果。
- en: Add a second constructor test, which tests the optional time parameter that
    is now expected to be part of the constructor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个构造函数测试，该测试测试现在预期作为构造函数一部分的可选时间参数。
- en: Change the `measure` method's name to `calculate_response` in all tests.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有测试中的`measure`方法名称更改为`calculate_response`。
- en: Add the initial constructor parameter in the `calculate_response` test – while
    we're doing that, we notice that this is going to change the way the `calculate_response`
    function behaves. We contact the client for clarification, and they decide it's
    okay, so we update the expectations to match what we calculate should happen after
    the change.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calculate_response`测试中添加初始构造函数参数 - 在我们做这件事的时候，我们注意到这将改变`calculate_response`函数的行为。我们联系客户进行澄清，他们决定这是可以接受的，因此我们更新期望值以匹配更改后我们应该计算会发生的事情。
- en: Add a second `calculate_response` test, which checks its behavior when the optional
    time parameter is supplied.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个`calculate_response`测试，该测试检查在提供可选时间参数时的行为。
- en: After making all those changes, our specification/test file looks like the following.
    Lines that have been changed or added are formatted differently, to help you spot
    them more easily.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行所有这些更改后，我们的规范/测试文件看起来如下。更改或添加的行格式不同，以便您更容易找到它们。
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Our tests didn't match the requirements any more, so they had to change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试不再符合要求，因此它们不得不进行更改。
- en: Well and good, but we don't want them to change too much, because our collection
    of tests helps us avoid regressions in our code. Regressions are changes that
    cause something that used to work, to stop working. One of the best ways to avoid
    them is to avoid deleting tests. If you still have tests in place that check for
    every desired behavior and every bug fixed, then if you introduce a regression
    you find out about it immediately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但我们不希望它们改变太多，因为我们的测试集合帮助我们避免代码中的回归。回归是导致曾经工作过的某些东西停止工作的更改。避免回归的最好方法之一是避免删除测试。如果您仍然有检查每个期望行为和每个已修复错误的测试，那么如果您引入了回归，您会立即发现。
- en: That's one reason why we added new tests to check the behavior when the optional
    time parameters are supplied. The other reason is that if we added those parameters
    to the existing tests, we wouldn't have any tests of what happens when you don't
    use those parameters. We always want to check every code path through each unit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们添加新测试以检查提供可选时间参数时的行为的一个原因。另一个原因是，如果我们将这些参数添加到现有测试中，我们就不会有测试来检查不使用这些参数会发生什么。我们总是想检查每个单元的每个代码路径。
- en: Sometimes, a test just isn't right any more. For example, tests that make use
    of the `measure` method are just plain wrong, and need to be updated to call `calculate_response`
    instead. When we change these tests, though, we still change them as little as
    possible. After all, we don't want the test to stop checking for old behavior
    that's still correct, and we don't want to introduce a bug in the test itself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个测试就不再正确了。例如，使用`measure`方法的测试完全是错误的，需要更新为调用`calculate_response`。当我们更改这些测试时，尽管我们尽量保持更改最小，因为毕竟我们不希望测试停止检查仍然正确的行为，也不希望在测试本身中引入错误。
- en: The addition of the `initial` parameter to the constructor is a big deal. It
    not only changes the way the constructor should behave, it also changes the way
    the `calculate_response` (née `measure`) method should behave in a rather dramatic
    way. Since this is a change in the correct behavior (a fact which we didn't realize
    until the tests pointed it out to us, which in turn allowed us to get confirmation
    of what the correct behavior should be from our clients *before* we started writing
    the code), we have no choice but to go through and change the tests, recalculating
    the expected outputs. However, doing all that work has a benefit over and above
    the future ability to check that the function is working correctly; it makes it
    much easier to comprehend how the function should work when we actually write
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `initial` 参数添加到构造函数中是一个大事件。这不仅改变了构造函数应有的行为方式，还以相当戏剧性的方式改变了 `calculate_response`（原名
    `measure`）方法的行为。由于这是一个正确行为的改变（我们直到测试指出这一点才意识到这一点，而这反过来又使我们能够在编写代码之前从客户那里确认正确的行为应该是什么），我们别无选择，只能修改测试，重新计算预期的输出。然而，做所有这些工作除了未来能够检查函数是否正确工作之外，还有一个好处；它使得我们在实际编写代码时更容易理解函数应该如何工作。
- en: Back to the development phase
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到开发阶段
- en: Well, it's time to go back into development. In real life, there's no telling
    how often we'd have to cycle back and forth between development and feedback,
    but we would want to keep the cycle short. The more often we switch back and forth,
    the more in contact we are with what our clients really want, and that makes for
    a more productive, more rewarding job.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在是时候回到开发阶段了。在现实生活中，我们无法预测我们多久需要来回循环于开发和反馈之间，但我们希望保持循环尽可能短。我们来回切换得越频繁，就越能接触到客户真正想要的东西，这会使工作更加高效、更有成就感。
- en: Time for action – unit testing during development... again
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 开发中的单元测试... 再次
- en: We've got our updated tests, so now it's time to get back into a state where
    all of our tests pass.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了测试，所以现在是我们回到所有测试都通过的状态的时候了。
- en: First off, let's run the tests, and so get a new list of things that need to
    be done.![Time for action – unit testing during development... again](img/8846_03_03.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们运行测试，以便得到需要完成的新事项列表。![行动时间 – 开发中的单元测试... 再次](img/8846_03_03.jpg)
- en: There are several more error reports after this, of course. Doctest reports
    a total of 32 failing examples, although that's not particularly meaningful since
    none of the tests are able to even construct a PID object right now. Fixing that
    constructor would be a reasonable place to start.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，之后还有更多的错误报告。Doctest报告了总共32个失败的例子，尽管这并不特别有意义，因为目前没有一个测试能够构建一个PID对象。修复那个构造函数可能是一个合理的起点。
- en: 'Using the doctest report as a guide, we set about adjusting the PID class.
    This is going to work best as an iterative process, where we make a few changes,
    then run the tests, then make a few changes, and so on. In the end, though, we''ll
    end up with something like the following (the `push_setpoint` and `pop_setpoint`
    methods are unchanged, so they''ve been omitted here to save space):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以doctest报告作为指南，我们着手调整PID类。这将最好作为一个迭代过程，我们进行一些更改，然后运行测试，然后进行一些更改，如此等等。然而，最终我们将会得到以下类似的结果（`push_setpoint`
    和 `pop_setpoint` 方法没有改变，所以为了节省空间，这里省略了它们）：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We check the tests again, and they all pass.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次检查测试，并且它们都通过了。
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This wasn't very different from our first time through the development phase.
    Just as before, we had a set of tests, and the error report from those tests gives
    us a checklist of things we need to fix. As we work, we keep an eye out for things
    that need to be tested, but aren't yet, and add those tests. When all the tests
    pass, we check with our client again (which means we go back to the feedback phase).
    Eventually the client will be satisfied. Then we can move on to releasing the
    code, and then into the maintenance phase.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们第一次通过开发阶段并没有太大区别。就像之前一样，我们有一套测试，那些测试的错误报告给我们列出了一项需要修复的事项清单。在我们工作的过程中，我们留意需要测试但尚未测试的事项，并添加那些测试。当所有测试都通过时，我们再次与客户核对（这意味着我们回到了反馈阶段）。最终客户会满意。然后我们可以继续发布代码，然后进入维护阶段。
- en: As we're working, the tests give us a nice, fast way to get a sense of whether
    what we're doing works, and how far along we are. It makes it easy for us to see
    that the code we're writing does something, which in turn makes the coding process
    flow better, and even makes it more fun. Writing code that just sits there is
    boring and bug-prone, but because we have the tests, our code doesn't just sit
    there. It's active, and we can see the results at any time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们工作的过程中，测试以快速、简便的方式让我们了解我们所做的是否有效，以及我们进展到了什么程度。这使得我们很容易看到我们编写的代码做了些什么，这反过来又使得编码过程更加流畅，甚至更加有趣。编写只是坐那的代码是无聊且容易出错的，但因为我们有测试，我们的代码不会只是坐那。它是活跃的，我们可以在任何时候看到结果。
- en: Maintenance phase
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护阶段
- en: Now that we've passed on our work to our client, we have to make sure that they
    stay happy with it. That means fixing any bugs that may have slipped past our
    tests (hopefully not many) and making small improvements on request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的工作转交给客户，我们必须确保他们对此感到满意。这意味着修复任何可能在我们测试中遗漏的错误（希望不多）并根据要求进行小的改进。
- en: Time for action – unit testing during maintenance
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 维护期间的单元测试
- en: 'Our client has come to us with a change request: they don''t want the `PID`
    class to accept negative gain values in its constructor, because negative gains
    make its output push things further away from the `setpoint`, instead of pulling
    them toward it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户向我们提出了一个变更请求：他们不希望`PID`类在其构造函数中接受负增益值，因为负增益会使输出将事物推得更远，而不是将其拉向设定点。
- en: We add new tests that describe what should happen when negative gains are passed
    to the constructor. We're testing something that the old tests don't describe,
    so we get to leave the old tests alone and just add new tests. That's a good thing,
    because it means that the old tests will be certain to catch any regressions that
    we might introduce while we're working on this.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了新的测试，描述了当将负增益传递给构造函数时应该发生什么。我们正在测试旧测试没有描述的内容，因此我们可以保留旧测试不变，只需添加新测试。这是一件好事，因为它意味着旧测试将确保捕捉到我们在进行这项工作时可能引入的任何回归。
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the tests to see what needs doing. As we might expect in this case, doctest
    reports three failures, one for each of the tests we just added – The `PID` class
    didn't raise the expected `ValueError`s.![Time for action – unit testing during
    maintenance](img/8846_03_05.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以查看需要做什么。正如我们可能预期的那样，在这个案例中，doctest报告了三个失败，每个都是针对我们刚刚添加的测试——`PID`类没有抛出预期的`ValueError`异常。![行动时间
    - 维护期间的单元测试](img/8846_03_05.jpg)
- en: 'Now we write the code that will make the `PID` class pass the tests. That''s
    easily done by adding the following to the constructor:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们编写代码，使`PID`类通过测试。这很容易通过在构造函数中添加以下内容来完成：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We run the tests again, and when they all pass, we can report to our client
    that the change has been implemented.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次运行测试，当它们全部通过时，我们可以向客户报告变更已经实施。
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, if doctest doesn't print anything, then all the tests passed. It only
    tells you about errors, unless you pass `-v` on its command line.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，如果doctest没有打印任何内容，那么所有测试都通过了。它只会告诉你关于错误的信息，除非你在其命令行上传递了`-v`。
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: That looked pretty straightforward, but the fact is that our body of tests was
    a big help to us here. When we're mucking around in a codebase, trying to update
    its behavior, or to fix a bug that we've never even considered might exist, it's
    easy to break other parts of the program. This is doubly so when the codebase
    is one that we haven't worked with for a while, as is often the case with maintenance
    requests. Thanks to the expertise stored inthe tests that we wrote, we don't have
    to worry about forgetting details of what constitutes correct behavior, or what
    might go wrong in various parts of the code. We don't have to waste time or effort
    re-learning those details when we come back to the code. Instead, we can just
    execute the tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当直接，但事实是，我们的测试集在这里帮了我们大忙。当我们在一个代码库中摸索，试图更新其行为，或者修复我们从未考虑过可能存在的错误时，很容易破坏程序的其它部分。特别是当代码库是我们已经有一段时间没有合作的项目时，这种情况在维护请求中很常见。多亏了我们编写的测试中存储的专业知识，我们不必担心忘记构成正确行为或代码各部分可能出错的具体细节。当我们回到代码时，我们不必浪费时间或精力重新学习这些细节。相反，我们只需执行测试。
- en: Our clients don't necessarily know about our testing process, but they appreciate
    the fast turnaround time we can give them because of it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户可能并不了解我们的测试流程，但他们很欣赏我们因此能提供的快速响应时间。
- en: Reuse phase
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用阶段
- en: Eventually, there comes a time when—if the code we wrote is useful—we'll want
    to use it again in a different project. That means we're going to be putting it
    in a context where the assumptions made in the code may no longer be valid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，会有这样一个时刻——如果我们所编写的代码是有用的，我们将在不同的项目中再次使用它。这意味着我们将把它放在一个可能不再有效的假设的上下文中。
- en: Time for action – unit testing during reuse
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 重复使用时的单元测试
- en: 'Our client wants to use a PID controller in a new project, but there''s a twist:
    The value that''s going to be measured and controlled is represented as a complex
    number. When we wrote the PID controller, there was an implicit assumption that
    the values would always be representable as floating point numbers. What do we
    have to do to re-use this code? Let''s find out.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户想在新的项目中使用PID控制器，但有一个转折：将要测量和控制的价值表示为复数。当我们编写PID控制器时，有一个隐含的假设，即这些值总是可以表示为浮点数。为了重新使用这段代码，我们该怎么办？让我们来看看。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By the way, if you don't know what complex numbers are, don't worry. They're
    not actually complicated; a complex number is just a pair of coordinates, much
    like latitude and longitude.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你不知道复数是什么，不要担心。它们实际上并不复杂；复数只是一个坐标对，就像纬度和经度一样。
- en: Write some tests that use complex numbers for `setpoint`, `initial` and the
    measurements. Since we want to make sure we don't break code that still uses floating
    point numbers, we don't replace the older tests, we just add more.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一些使用复数`setpoint`、`initial`和测量的测试。由于我们想确保不会破坏仍然使用浮点数的代码，我们并没有替换旧的测试，只是添加了更多的测试。
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You''ll notice that we''re using some very random-looking numbers here. They''re
    not random at all. Complex numbers can be thought of as representing coordinates;
    they represent the same values that we used in our earlier tests, except rotated
    `45` degrees and translated by `1+1j`. For example, where before we used the value
    `12`, we now use the value of `12 * complex(cos(0.25 * pi), sin(0.25 * pi))+ (1+1j)`,
    which is `9.4852813742385695+9.4852813742385695j`. If you don''t understand, or
    don''t care, it''s enough to know that the same expression can be used to calculate
    the value of every complex number in this example: just substitute the appropriate
    number in place of the `12`. You can find `sin`, `cos` and `pi` in the `math`
    module.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我们在这里使用了一些看起来非常随机的数字。它们根本不是随机的。复数可以被认为是表示坐标；它们表示的是我们在早期测试中使用过的相同值，只是旋转了`45`度并平移了`1+1j`。例如，之前我们使用的是值`12`，现在我们使用的是`12
    * complex(cos(0.25 * pi), sin(0.25 * pi))+ (1+1j)`，即`9.4852813742385695+9.4852813742385695j`。如果你不理解，或者不在乎，只要知道相同的表达式可以用来计算这个例子中每个复数的值就足够了：只需将适当的数字替换`12`即可。你可以在`math`模块中找到`sin`、`cos`和`pi`。
- en: (Some of the input lines here are very long, and have to be wrapped to fit onto
    the page. They shouldn't be wrapped in the doctest file.)
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这里的一些输入行非常长，必须折行以适应页面。它们不应该在doctest文件中折行。）
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Okay, the correct behavior has been calculated and the tests have been written.
    Let's run them and see what doesn't work. We run the doctests, and the first thing
    that comes out of it is an exception raised in the constructor. It looks like
    our floating point assumption is already causing trouble. There are several more
    error reports after this, but since the constructor didn't work, we can't expect
    them to make much sense.![Time for action – unit testing during reuse](img/8846_03_04.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，正确的行为已经被计算出来，测试也已经编写。让我们运行它们，看看什么不工作。我们运行了doctests，首先出现的是在构造函数中抛出的异常。看起来我们的浮点假设已经引起了麻烦。之后还有几个错误报告，但由于构造函数没有工作，我们无法期望它们有太多意义。![行动时间
    - 重复使用时的单元测试](img/8846_03_04.jpg)
- en: The problems in the constructor arise from passing complex numbers into the
    constructor for the `float` class, which is not allowed. Do we really need to
    call `float` there? Sometimes we do, because we don't want to use integers for
    `setpoint` and `initial`. Integer division doesn't work the same way as floating
    point division in versions of Python less than 3.0, so integers could severely
    mess up the behavior of the system.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数中的问题源于将复数传递给`float`类的构造函数，这是不允许的。我们真的需要在那个地方调用`float`吗？有时我们确实需要，因为我们不想用整数来表示`setpoint`和`initial`。在Python
    3.0之前的版本中，整数除法与浮点除法的工作方式不同，所以整数可能会严重破坏系统的行为。
- en: 'So, we want to call the `float` constructor on `initial` and `setpoint`, *unless*
    they are complex numbers. That makes the constructor look like this (again, watch
    out for the wrapping of long lines):'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们希望在`initial`和`setpoint`上调用`float`构造函数，*除非*它们是复数。这使得构造函数看起来像这样（再次注意长行的包装）：
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Okay, we've fixed the constructor. We run the tests again, and all the tests
    pass! Somewhat surprisingly, perhaps, the `calculate_response` function is already
    compatible with complex numbers.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，我们已经修复了构造函数。我们再次运行测试，所有的测试都通过了！也许有些令人惊讶的是，`calculate_response`函数已经与复数兼容。
- en: '*What just happened?*'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Writing our tests originally helped us to determine what assumptions we were
    making, and the tests check those assumptions explicitly. Furthermore, even the
    assumptions that we didn't know we were making have a tendency to be checked by
    our tests, because they are implicit in our expectations. An example of this is
    the floating point results that the tests expected. If we had just removed the
    calls to float in the constructor entirely, all of those tests that were expecting
    a float would have failed, telling us that we'd violated an implicit assumption
    about the behavior of the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初编写测试帮助我们确定我们正在做出的假设，并且测试会明确检查这些假设。此外，即使我们不知道我们正在做出的假设，它们也有被我们的测试检查的倾向，因为它们隐含在我们的期望中。这个例子是测试期望的浮点数结果。如果我们完全从构造函数中移除了对float的调用，所有期望浮点数的测试都会失败，这会告诉我们我们违反了一个关于代码行为的隐含假设。
- en: Our tests give us confidence that our code is correct (even when its operating
    on complex numbers), and that we haven't broken anything else by changing the
    code. No muss, no fuss; it works. If one of the tests had failed, that would have
    told us where the problems lay. Either way, we know where we are in the project
    and what needs to be done next, which lets us keep the process rolling along.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试让我们对我们的代码正确性有信心（即使它在操作复数时），并且我们没有通过更改代码破坏其他东西。没有麻烦，没有烦恼；它工作得很好。如果有一个测试失败了，那会告诉我们问题所在。无论如何，我们知道我们在项目中的位置以及下一步需要做什么，这让我们能够使过程继续进行。
- en: Pop quiz – unit testing
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 单元测试
- en: When you write a test, should you do it while referring to the code being tested,
    or should you do it based on your expectations of what correct behavior should
    be, before the code is even written?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编写测试时，你应该在参考被测试的代码的同时进行，还是应该基于你对正确行为应该是什么的期望进行，在代码编写之前？
- en: 'True or false: You should avoid changing or deleting tests whenever possible,
    and prefer changing them to deleting them when you aren''t able to keep them untouched.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：尽可能避免更改或删除测试，当无法保持测试不变时，更倾向于更改它们而不是删除它们。
- en: How often do you think your tests should be run? Can you think of any particularly
    good times to execute the tests?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为你的测试应该多久运行一次？你能想到执行测试的特别好的时间吗？
- en: If your development process is test driven, you as a programmer will spend most
    of your time doing what?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的开发过程是测试驱动的，作为程序员，你将花大部分时间做什么？
- en: Have a go hero – test-driven development
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄式测试驱动开发
- en: 'Try using the methods that we''ve talked about in this chapter to implement
    this plain language specification:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用本章中我们讨论的方法来实现这个简单的语言规范：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about Unit testing and Test-Driven Development,
    which are best-practice disciplines for quickly building reliable programs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学到了很多关于单元测试和测试驱动开发的知识，这些是快速构建可靠程序的最佳实践学科。
- en: Specifically, we covered the definition of Unit testing, how unit testing can
    help during each stage of the development process, what it feels like to use unit
    testing to drive development, and how it can make the process quicker and more
    pleasant.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了单元测试的定义，单元测试如何帮助开发过程的每个阶段，使用单元测试驱动开发的感觉，以及它如何使过程更快、更愉快。
- en: Now that we've learned about Unit testing, we're ready to talk about making
    it easier to isolate tests with the help of mock objects—which is the topic of
    the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试，我们准备讨论如何通过使用模拟对象来使测试的隔离更加容易，这是下一章的主题。
