- en: 'Chapter 10. When All Else Fails: Getting Outside Help'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。当一切都失败时：寻求外部帮助
- en: Sometimes we run into problems that do not seem to be caused by our own code.
    Though following the documentation to the best of our understanding, the results
    we are getting don't match what we expect. One of the benefits of building on
    open source code such as Django is that we can delve into its code and figure
    out exactly where things are going wrong. However, that may not be the best use
    of our time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们遇到的问题似乎不是由我们自己的代码引起的。尽管我们按照最好的理解遵循文档，但我们得到的结果与我们的预期不符。构建在Django等开源代码上的好处之一是我们可以深入研究其代码，确切地找出问题出在哪里。然而，这可能不是我们时间的最佳利用方式。
- en: Most often a better first step in tracking down such problems is to consult
    community resources. Perhaps someone else has already encountered the problem
    we are facing and found a fix or workaround. If so, we can likely save a lot of
    time by taking advantage of their experience rather than finding our own solution
    to the problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪此类问题的更好的第一步通常是查阅社区资源。也许其他人已经遇到了我们面临的问题，并找到了解决方法或解决方法。如果是这样，我们可能可以通过利用他们的经验来节省大量时间，而不是找到自己的解决方案。
- en: 'This chapter describes the Django community resources and illustrates how to
    use them. Specifically, in this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Django社区资源，并说明了如何使用它们。具体来说，在本章中我们将：
- en: Walk through the discovery of a bug that existed in the Django 1.1 release and
    caused a problem for some of the survey application code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过发现Django 1.1版本中存在的一个错误的过程，并且导致了一些调查应用代码的问题
- en: See how the resources available on the Django website can be used to research
    the problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Django网站上提供的资源如何用于研究问题
- en: Discuss the best way to proceed based on the results of the research, for both
    this problem specifically and problems in general
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据研究结果讨论解决问题的最佳方法，无论是针对特定问题还是一般问题
- en: Learn what other avenues for getting help exist, and how best to make use of
    them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解其他获取帮助的途径，以及如何最好地利用它们
- en: Tracking down a problem in Django
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Django中追踪问题
- en: This book has been written using the latest available Django release at the
    time of writing. Early on that was Django 1.1\. Then, during the course of writing,
    Django 1.1.1 was released and everything written after that release date used
    Django 1.1.1\. The three 1s in that release number are the major, minor, and micro
    release numbers. (A missing micro number, as in Django 1.1, is an implied 0.)
    Django 1.1.1, since it has an explicit micro number, is called a micro release.
    The only changes made in micro releases are bug fixes, thus micro releases are
    100 percent backwards compatible with the previous release. While a change in
    a major or minor version number may involve some backwards-incompatible changes
    that require code adjustments, the only difference you will see in updating to
    a new micro release is fewer bugs. Therefore, it is always recommended to run
    the latest micro release for the major.minor version you are using.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是使用写作时最新的Django版本编写的。一开始是Django 1.1。然后，在写作过程中，发布了Django 1.1.1，之后的所有内容都使用了Django
    1.1.1。该版本号中的三个1是主要、次要和微小的发布号。（缺少微小号，如Django 1.1，意味着是0。）Django 1.1.1由于有明确的微小号，被称为微小发布。微小发布中唯一的更改是错误修复，因此微小发布与上一个版本完全兼容。虽然主要或次要版本号的更改可能涉及一些需要代码调整的不兼容更改，但更新到新的微小发布的唯一区别是减少了错误。因此，始终建议运行您正在使用的主要.次要版本的最新微小发布。
- en: 'Despite this advice and compatibility guarantee, it''s sometimes tempting to
    not upgrade to the latest available release. Upgrading requires some (likely small,
    but non-zero) amount of work. In addition, there''s always the common-sense axiom:
    if it isn''t broken, don''t fix it. If you''re not actually experiencing any problems,
    why upgrade?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这样的建议和兼容性保证，有时候不升级到最新的可用版本是很诱人的。升级需要一些（可能很小，但不为零）工作量。此外，还有一个常识公理：如果它没有坏，就不要修理它。如果您实际上没有遇到任何问题，为什么要升级呢？
- en: 'I had exactly these thoughts when Django 1.1.1 was released. That release happened
    to occur right during the middle of writing [Chapter 7](ch07.html "Chapter 7. When
    the Wheels Fall Off: Understanding a Django Debug Page"), *When the Wheels Fall
    Off: Understanding a Django Debug Page*, a chapter full of screenshots and console
    displays showing tracebacks that included Django code. If I changed the Django
    code base right in the middle of writing that chapter, even by just a micro release,
    who knew what subtle differences might be introduced in early compared to late-chapter
    tracebacks? Such differences could cause confusion for eagle-eyed readers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django 1.1.1发布时，我正好有这些想法。该发布恰好发生在写作中间[第7章](ch07.html "第7章。当车轮脱落时：理解Django调试页面")，“当车轮脱落时：理解Django调试页面”，这是一个充满了包含Django代码的跟踪的截图和控制台显示的章节。如果我在写作该章节的中间改变了Django代码库，即使只是微小的发布，谁知道早期和晚期章节的跟踪之间可能会引入什么微妙的差异？这样的差异可能会让敏锐的读者感到困惑。
- en: If I did upgrade mid-chapter, it would be safest to re-do all the examples from
    the beginning to ensure they were consistent. That was an unattractive option
    since it was both a fair amount of work and error-prone. Thus my initial inclination
    when Django 1.1.1 was released was to delay upgrading until at least the next
    chapter break.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在中间升级，最安全的做法是重新做所有的示例，以确保它们是一致的。这是一个不太吸引人的选择，因为这既需要相当多的工作，又容易出错。因此，当Django
    1.1.1发布时，我的最初倾向是延迟升级，至少直到下一章节的休息时间。
- en: However, in the end I found I did have to upgrade in the middle of the chapter,
    because I ran into a Django bug that was fixed by the 1.1.1 release. The following
    sections describe encountering the bug and show how it can be tracked down to
    a problem that had been fixed in Django 1.1.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终我发现我确实不得不在章节中间升级，因为我遇到了一个Django错误，这个错误被1.1.1版本修复了。接下来的几节描述了遇到的错误，并展示了如何将其追踪到在Django
    1.1.1中已经修复的问题。
- en: Revisiting the Chapter 7 voting form
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视第7章投票表单
- en: 'Recall in [Chapter 7](ch07.html "Chapter 7. When the Wheels Fall Off: Understanding
    a Django Debug Page") we implemented the code to display an active survey. This
    includes a form to allow a user to choose answers for each question in the survey.
    One of the final changes made to the form code involved customizing the error
    format. The final code for the `QuestionVoteForm` looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第7章](ch07.html "第7章。当轮子掉下来：理解Django调试页面")中，我们实现了显示活动调查的代码。这包括一个表单，允许用户为调查中的每个问题选择答案。对表单代码所做的最终更改之一涉及自定义错误格式。`QuestionVoteForm`的最终代码如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The inclusion of the `PlainErrorList` class, and setting the form instance''s
    `error_class` attribute to it during `__init__`, is intended to change the display
    of an error for a question from an HTML unordered list (the default behavior)
    to a simple string. However, when running this code under Django 1.1, and forcing
    an error situation by attempting to submit a survey with both questions unanswered,
    the result displayed is:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`期间包含`PlainErrorList`类，并将表单实例的`error_class`属性设置为它，旨在将问题的错误显示从HTML无序列表（默认行为）更改为简单字符串。然而，当在Django
    1.1下运行此代码，并尝试提交两个问题都未回答的调查以强制出现错误时，显示的结果是：
- en: '![Revisiting the Chapter 7 voting form](img/7566_10_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![重温第7章的投票表单](img/7566_10_01.jpg)'
- en: 'The inclusion of the bullets to the left of the two error messages shows that
    the error lists are still being formatted as HTML unordered lists. This can also
    be confirmed by checking the HTML source for the page, which includes the following
    snippet for each error message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个错误消息左侧添加了项目符号表明错误列表仍然被格式化为HTML无序列表。这也可以通过检查页面的HTML源代码来确认，其中包括每个错误消息的以下片段：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It seems that setting the `error_class` attribute is not having any effect.
    How can we best track down a problem like this?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎设置`error_class`属性没有任何效果。我们如何最好地追踪这样的问题？
- en: Is the right code actually running?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际上是否运行了正确的代码？
- en: 'First, we need to make sure the code that is running is actually the code we
    think is running. In this case, when I encountered the problem I could see that
    the development server had restarted after the code changes to add the `PlainErrorList`
    class and the setting of the `error_class` attribute, so I was pretty sure the
    right code was running. Still, inserting an `import pdb; pdb.set_trace()` right
    before the `error_class` assignment allowed me to confirm the code was there and
    doing what I expected:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保正在运行的代码实际上是我们认为正在运行的代码。在这种情况下，当我遇到问题时，我可以看到开发服务器在添加`PlainErrorList`类和设置`error_class`属性的代码更改后重新启动，因此我非常确定正在运行正确的代码。尽管如此，在`error_class`赋值之前插入`import
    pdb; pdb.set_trace()`允许我确认代码已经存在并且正在按照我期望的方式运行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we can see that on entry to the debugger, before our assignment of `PlainErrorList`
    to `error_class`, this attribute had the value `django.forms.util.ErrorList`.
    Stepping through the assignment shows that the `__init__` method is then about
    to return, and checking the value of the `error_class` attribute again shows that
    indeed the value has been changed to our customized `PlainErrorList`. That all
    looks good. At the very end of the form creation code, the `error_class` attribute
    has been set to the customized class. Why isn't it being used?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入调试器之前，我们可以看到`error_class`的值为`django.forms.util.ErrorList`。通过赋值的步骤显示`__init__`方法即将返回，并再次检查`error_class`属性的值显示确实已将值更改为我们自定义的`PlainErrorList`。这一切看起来都很好。在表单创建代码的最后，`error_class`属性已设置为自定义类。为什么它没有被使用？
- en: Is the code correct as per the documentation?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码是否符合文档要求？
- en: 'The next step (after removing the added breakpoint) is to double-check the
    documentation. Though it seems unlikely, perhaps there is something else required
    to use a custom error class? After rechecking the documentation, there doesn''t
    seem to be. The full documentation on customizing the error class is simply:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步（在移除添加的断点后）是再次检查文档。尽管似乎不太可能，也许还需要其他内容才能使用自定义错误类？重新检查文档后，似乎并没有。有关自定义错误类的完整文档如下：
- en: '![Is the code correct as per the documentation?](img/7566_10_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![代码是否符合文档要求？](img/7566_10_02.jpg)'
- en: There are a couple of slight differences between what the provided example does
    and what the `QuestionVoteForm` does. First, the provided example passes the error
    class as an argument on form creation, and thus it is passed to the form's superclass
    `__init__`. The `QuestionVoteForm`, on the other hand, manually sets `error_class`
    after the superclass `__init__` runs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例所做的事情与`QuestionVoteForm`所做的事情有一些细微差异。首先，提供的示例在表单创建时将错误类作为参数传递，因此它被传递给了表单的超类`__init__`。另一方面，`QuestionVoteForm`在超类`__init__`运行后手动设置`error_class`。
- en: 'This seems unlikely to be the cause of the problem, since over-riding values
    in a subclass `__init__` routine, as we have done with `QuestoinVoteForm`, is
    a very common idiom. We can check, though, to see if this slight difference causes
    a problem by attempting the demonstration of use of the custom `error_class` setting,
    as shown in the documentation in a Python shell, for the `QuestionVoteForm`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不太可能是问题的原因，因为在子类`__init__`例程中覆盖值，就像我们在`QuestoinVoteForm`中所做的那样，是一个非常常见的习语。不过，我们可以通过尝试在Python
    shell中演示使用自定义`error_class`设置的方法来检查是否这种细微差异会导致问题，如文档中所示，对于`QuestionVoteForm`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have created a form instance, `qvf`, for the question with primary
    key `1` in the database. By passing in an empty `data` dictionary, we have forced
    the error condition of a form submitted with no `answer` value. The documentation
    shows that using the form''s `as_p` method to display this form should show the
    error formatted using the form''s custom error class. We can check whether that
    happens for the `QuestionVoteForm`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经创建了一个表单实例`qvf`，用于数据库中主键为`1`的问题。通过传递一个空的`data`字典，我们强制了一个没有`answer`值的表单提交的错误条件。文档显示，使用表单的`as_p`方法来显示这个表单应该显示使用表单的自定义错误类格式化的错误。我们可以检查`QuestionVoteForm`是否发生了这种情况：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There we see that the `as_p` method does indeed use the custom error class:
    there is no HTML unordered list wrapped around the error message. So the error
    class is being set, and is used when the form is displayed using a routine like
    `as_p`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我们看到`as_p`方法确实使用了自定义错误类：错误消息周围没有HTML无序列表。因此，错误类已设置，并且在使用`as_p`等例行程序显示表单时使用。
- en: 'This leads to the second difference between what the documentation shows and
    what the survey application code actually does. The `survey/active_survey.html`
    template does not use `as_p` to display the form. Rather, it individually prints
    the label for the answer field, errors for the answer field, and then the answer
    field itself:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了文档显示和调查应用程序代码实际执行之间的第二个差异。`survey/active_survey.html`模板不使用`as_p`来显示表单。相反，它分别打印答案字段的标签，答案字段的错误，然后是答案字段本身。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Should that cause the custom error class to not be used for display? You wouldn't
    think so. Though the documentation only shows the custom error class used with
    `as_p`, there is no mention there that the custom error class is only used by
    the convenience display methods such as `as_p`. Such a restriction would be very
    limiting, since the convenience form display methods are frequently not appropriate
    for a non-trivial form.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否会导致自定义错误类不用于显示？你不会这样认为。尽管文档只显示自定义错误类与`as_p`一起使用，但在那里没有提到自定义错误类只被方便的显示方法如`as_p`使用。这样的限制将非常有限，因为方便的表单显示方法通常不适用于非平凡的表单。
- en: It seems clear that the intent of the `error_class` attribute is to override
    the error display regardless of the exact way in which a form is output, but it
    doesn't seem to be working. This is the point where we may begin to strongly suspect
    a bug in Django instead of some error or misunderstanding of usage in the application
    code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎很明显，`error_class`属性的意图是覆盖错误显示，而不管表单以何种方式输出，但似乎并没有起作用。这是我们可能开始强烈怀疑Django中的一个错误，而不是应用程序代码中的某个错误或误用的地方。
- en: Searching for a matching problem report
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索匹配的问题报告
- en: 'The next step, then, is to visit the Django website to see if anyone has reported
    a problem using `error_class`. Choosing the **Code** link from the main Django
    project page (rightmost of the links across the top of the page) brings up the
    main page for Django''s code tracker:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要访问Django网站，看看是否有人报告了使用`error_class`的问题。从Django项目主页的**Code**链接（页面顶部横跨的链接的最右边）中选择**Code**链接，将显示Django代码跟踪器的主页面：
- en: '![Searching for a matching problem report](img/7566_10_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配的问题报告](img/7566_10_03.jpg)'
- en: 'The Django project uses Trac, which provides an easy-to-use web-based interface
    for tracking bugs and feature requests. With Trac, bugs and feature requests are
    reported and tracked in tickets. Specifics of the way in which the Django project
    has configured Trac, and thus the meaning of the various ticket attribute values,
    can be found in the Django documentation page on contributing. Specifically, the
    diagram and descriptions found here: [http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage](http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage)
    are very helpful in understanding all of the information associated with a ticket.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目使用Trac，它提供了一个易于使用的基于Web的界面来跟踪错误和功能请求。使用Trac，错误和功能请求是通过票务报告和跟踪的。Django项目配置Trac的方式的具体细节，以及因此各种票务属性值的含义，可以在Django贡献文档页面上找到。特别是在这里找到的图表和描述：[http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage](http://docs.djangoproject.com/en/dev/internals/contributing/#ticket-triage)对于理解与票务相关的所有信息非常有帮助。
- en: 'What we want to do now is search the Django project tickets for reported problems
    with the use of `error_class`. One way to do that is to select the **View Tickets**
    tab and construct an appropriate search. When **View Tickets** is first selected,
    by default it will show a page listing all non-closed tickets. For example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的是搜索Django项目票务，查找使用`error_class`的报告问题。一种方法是选择**View Tickets**选项卡并构建适当的搜索。当首次选择**View
    Tickets**时，默认情况下将显示列出所有未关闭票务的页面。例如：
- en: '![Searching for a matching problem report](img/7566_10_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配的问题报告](img/7566_10_04.jpg)'
- en: The criteria used to generate the report are shown in the box labeled **Filters**.
    Here we see that the report includes all tickets with any status that is not **closed**,
    since that is the only **Status** choice that is not checked. In order to get
    a report that is more useful for what we are trying to research, we need to modify
    the search criteria in the **Filters** box.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成报告的标准显示在标有**Filters**的框中。在这里，我们看到报告包括所有状态不是**closed**的票务，因为这是唯一未被选中的**Status**选项。为了获得更适合我们正在研究的报告，我们需要修改**Filters**框中的搜索标准。
- en: First, we can remove the constraint on the ticket status. We are interested
    in all reports related to `error_class`, regardless of ticket status. We can remove
    the existing constraint on status by clicking the box with a minus sign on the
    extreme right side of the line that contains the constraint.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以取消对票务状态的限制。我们对与`error_class`相关的所有报告感兴趣，而不管票务状态如何。我们可以通过点击包含约束的行的极右侧带有减号的框来删除现有的状态约束。
- en: Second, we need to add a filter for the search constraint we want to apply.
    To do this, we select an appropriate choice from the **Add filter** drop-down
    box. This drop-down box contains a full list of the ticket attributes we could
    search on, such as **Reporter**, **Owner**, **Status**, and **Component**. Most
    of these attributes are not relevant for the search we are currently interested
    in. The one in the list most likely to find what we are looking for is **Summary**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要为我们想要应用的搜索约束添加一个过滤器。为此，我们从**添加过滤器**下拉框中选择一个合适的选项。这个下拉框包含了我们可以搜索的票务属性的完整列表，比如**报告人**、**所有者**、**状态**和**组件**。这些属性中大多数对我们当前感兴趣的搜索不相关。在列表中最有可能找到我们要找的内容的是**摘要**。
- en: 'The ticket summary is the brief description of the problem. We could hope that
    this summary would include the string `error_class` for any reports of the problem
    we have run into with using it. Adding a single filter on **Summary** with a specification
    that it contains the string `error_class` will thus hopefully find any relevant
    tickets. Clicking on the **Update** button to refresh the search results given
    the new criteria then shows the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 票务摘要是问题的简要描述。我们希望这个摘要包含字符串`error_class`，以便包括我们遇到的问题的任何报告。在**摘要**上添加一个单一过滤器，并规定它包含字符串`error_class`，因此有望找到任何相关的票务。点击**更新**按钮以根据新标准刷新搜索结果，然后显示以下内容：
- en: '![Searching for a matching problem report](img/7566_10_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配的问题报告](img/7566_10_05.jpg)'
- en: There have been three tickets opened that contain `error_class` (or `error class`)
    in the summary. Two have been closed, one is still open (status **new**). Of the
    three, based on the displayed summary, the top one sounds like it might be the
    problem we are seeing with `error_class`, while the other two do not sound particularly
    relevant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开启了三个包含`error_class`（或`error class`）的票务。其中两个已关闭，一个仍然打开（状态为**新**）。根据显示的摘要，这三个中，排在前面的一个听起来可能是我们遇到的与`error_class`有关的问题，而另外两个则似乎不太相关。
- en: 'We can get more details on a listed problem by clicking on the ticket number
    or summary, both of which are links to view the full ticket details. Looking at
    the full details will allow us to verify that it is really the same as what we
    are seeing, and find out more details on when and why it was closed. In this case,
    we see the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点击票号或摘要可以获取列出的问题的更多详细信息，这两者都是查看完整票务详情的链接。查看完整详情将允许我们验证它是否与我们所看到的情况相同，并了解更多有关关闭时间和原因的详细信息。在这种情况下，我们看到以下内容：
- en: '![Searching for a matching problem report](img/7566_10_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配的问题报告](img/7566_10_06.jpg)'
- en: 'This ticket has a fairly long history—two years between when it was opened
    and the last activity. The short guide for reproducing the problem does make it
    sound like exactly the same problem we are seeing with `error_class`. The resolution
    of **fixed** listed after the ticket number near the top sounds encouraging, but
    unfortunately this ticket has no details on what code change was made, and when,
    to fix the problem. Scrolling all the way down to the tail end of the various
    comments added to the ticket history, we see that the last few updates are as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个票务有一个相当长的历史——从开启到最后一次活动经过了两年。简要重现问题的指南确实让人觉得这可能正是我们遇到的与`error_class`有关的问题。在顶部附近的票号后面列出的**已修复**解决方案听起来令人鼓舞，但不幸的是，这个票务没有关于修复问题的代码更改以及何时进行的详细信息。在滚动到票务历史中添加的各种评论的最后，我们看到最近的几次更新如下：
- en: '![Searching for a matching problem report](img/7566_10_07.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配的问题报告](img/7566_10_07.jpg)'
- en: In August of 2009 user **peter2108** was interested in helping move the ticket
    along by providing patches, including tests, to fix the problem (reading through
    the full history, the lack of tests in the originally-provided patches was one
    reason this ticket was open for a long time). Then, on October 16, 2009, **peter2108**
    closed the ticket with a resolution of **fixed**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年8月，用户**peter2108**有兴趣通过提供补丁来帮助推动票务，包括修复问题的测试（通过阅读完整历史，最初提供的补丁中缺少测试是这个票务长时间开放的原因之一）。然后，在2009年10月16日，**peter2108**以**已修复**的解决方案关闭了票务。
- en: It may not be obvious at first, but this way of closing a ticket is not typical
    for a ticket that required a Django code change. Normally, when the code change
    is committed to the Django SVN repository, the ticket number is included in the
    commit message and the corresponding ticket is automatically updated with a comment
    including the commit message and a link to the changeset. This automatic process
    also closes the ticket with a resolution of fixed. This makes it very easy to
    see exactly what code was changed to fix the problem and when the code change
    was made.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能并不明显，但这种关闭票务的方式对于需要Django代码更改的票务来说并不典型。通常，当代码更改提交到Django SVN存储库时，票号会包含在提交消息中，并且相应的票务会自动更新，包括提交消息和更改集的链接。这个自动过程还会以已修复的解决方案关闭票务。这样就非常容易看到确切是哪个代码更改修复了问题，以及代码更改是何时进行的。
- en: Sometimes that automatic process fails to run properly, and usually someone
    will notice when that happens and manually close the ticket, noting which code
    update fixed the problem. But that's not what happened here either. Rather it
    looks like **peter2108**, who was interested in seeing the bug fixed, simply noticed
    that the problem had gone away at some point and closed the ticket as fixed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动过程无法正确运行，通常当发生这种情况时，有人会注意到并手动关闭票务，注明哪个代码更新修复了问题。但这也不是这里发生的情况。相反，看起来**peter2108**，他对看到错误修复感兴趣，只是注意到问题在某个时候消失了，并将票务标记为已修复。
- en: We could guess, based on the fact that the same user who was interested in getting
    the problem fixed in August closed the ticket as fixed in October, that the fix
    went into the code base sometime between August 28 and October 16\. What we'd
    like, though, is to know for sure when exactly the fix was made, so we could know
    for sure whether we should already have it in the code we are running, or if updating
    to the latest release would fix the problem, or if the fix is available only in
    a version of code pulled directly from the SVN repository.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以猜测，基于同一个用户在8月份对问题进行了关闭，而在10月份又将问题关闭为已解决，修复可能是在8月28日至10月16日之间的某个时间点进入了代码库。然而，我们想要确定修复确切是何时进行的，这样我们就可以确定我们是否应该已经在我们运行的代码中拥有它，或者更新到最新版本是否会解决问题，或者修复是否仅在直接从SVN存储库中拉取的代码版本中可用。
- en: Looking back at the other two tickets that mention `error_class` in the summary,
    neither of them are helpful in determining when exactly this problem with `error_class`
    was fixed, since they describe different problems entirely. How, then, can we
    locate the information about when exactly the problem we are encountering was
    fixed? For this case, it turns out that the **View Tickets** type of search is
    not broad enough to get us the information we are looking for. Fortunately, there's
    an alternate way of searching the Django tracker that we can use to find the missing
    information.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾另外两个在摘要中提到`error_class`的票据，它们都无法帮助确定问题`error_class`究竟是何时修复的，因为它们描述的是完全不同的问题。那么，我们如何才能找到我们遇到的问题确切是何时修复的信息呢？对于这种情况，**查看票据**类型的搜索不够广泛，无法为我们提供所需的信息。幸运的是，有一种替代的搜索Django跟踪器的方法，我们可以使用它来找到缺失的信息。
- en: Another way to search for a matching problem report
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索匹配问题报告的另一种方法
- en: 'This alternative way of searching is found by clicking on the **Search** tab
    instead of the **View Tickets** tab. This brings up a page with a single text
    entry box and three check boxes to control where to search: **Tickets**, **Changesets**,
    and **Wiki**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击**搜索**选项卡而不是**查看票据**选项卡，可以找到这种替代搜索方式。这将显示一个带有单个文本输入框和三个复选框的页面，用于控制搜索位置：**票据**、**变更集**和**Wiki**。
- en: This page provides a much broader and less targeted way of searching. In addition
    to searching ticket data, changesets and Wiki articles are searched by default
    as well. Even when those options are turned off, the ticket search alone is broader
    than what is possible under **View Tickets**. The ticket search from this page
    covers all of the ticket comments and updates, which cannot be searched under
    **View Tickets**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面提供了一种更广泛和不太有针对性的搜索方式。除了搜索票据数据外，默认情况下还搜索变更集和Wiki文章。即使关闭这些选项，仅票据搜索也比**查看票据**下可能的搜索范围更广。此页面的票据搜索涵盖了所有票据评论和更新，这些在**查看票据**下无法搜索。
- en: A plus side of using this page to search is it may find relevant results that
    cannot be found using a **View Tickets** search. A downside of using this page
    to search is it may find an overwhelming number of irrelevant results, depending
    on exactly what search terms are entered in the textbox. If that happens you can
    further limit the results shown by entering more words that must be matched in
    the textbox, which can help. In this case, though, searching on a string as uncommon
    as `error_class` is not likely to produce an overwhelming number of results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此页面进行搜索的一个好处是它可能会找到**查看票据**搜索无法找到的相关结果。使用此页面进行搜索的一个缺点是，它可能会找到大量无关的结果，具体取决于在文本框中输入了什么搜索词。如果发生这种情况，您可以通过在文本框中输入更多必须匹配的单词来进一步限制显示的结果，这可能有所帮助。然而，在这种情况下，搜索一个像`error_class`这样不常见的字符串不太可能产生大量的结果。
- en: 'To proceed, then, entering `error_class` in the textbox and clicking on the
    **Search** button leads to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输入`error_class`并单击**搜索**按钮会导致以下结果：
- en: '![Another way to search for a matching problem report](img/7566_10_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配问题报告的另一种方法](img/7566_10_08.jpg)'
- en: This search does produce more results than the **View Tickets** search—twelve
    instead of three. The first result listed, ticket **#12001**, is the same as the
    still-open ticket found by the previous search. The other results from the previous
    search are also contained in the full list, only further down. But first we can
    see a result that is a changeset, **[11498]**, which mentions `error_class` in
    the commit message, and its associated ticket **#10968**. This ticket did not
    show up in the original search we tried because, though it includes reference
    to `error_class` in the full description, the string `error_class` is not in the
    ticket summary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这次搜索产生的结果比**查看票据**搜索更多——12个而不是3个。列出的第一个结果，票据**#12001**，与之前搜索找到的仍然打开的票据相同。先前搜索的其他结果也包含在完整列表中，只是在下面。但首先，我们可以看到一个变更集的结果，**[11498]**，它在提交消息中提到了`error_class`，以及其关联的票据**#10968**。这个票据之前没有出现在我们尝试的原始搜索中，因为虽然它在完整描述中包含对`error_class`的引用，但字符串`error_class`不在票据摘要中。
- en: Clicking through to the details of ticket **#10968** shows that it is a duplicate
    report of the same problem we have encountered and that was reported in the other
    ticket we found, **#6138**. Ordinarily when duplicates like this are opened, they
    are quickly closed as duplicates with a reference to the existing ticket that
    describes the problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**#10968**票据的详细信息后，显示它是我们遇到的相同问题的重复报告，并且在我们找到的另一个票据**#6138**中报告了该问题。通常，当这样的重复票据被打开时，它们会很快被关闭为重复，并引用描述问题的现有票据。
- en: 'However, if nobody realizes a new ticket is a duplicate, then the duplicate
    ticket may turn out to be the one referenced when the fix is checked into the
    code base. That''s apparently what happened in this case. We can see in the last
    update to this new ticket the automatically-generated comment added when the fix
    was committed to the SVN repository:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有人意识到新的票据是重复的，那么重复的票据可能会变成在检入代码库时引用的票据。这显然是在这种情况下发生的。我们可以在这个新票据的最后更新中看到自动生成的评论，当修复提交到SVN存储库时添加：
- en: '![Another way to search for a matching problem report](img/7566_10_09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配问题报告的另一种方法](img/7566_10_09.jpg)'
- en: 'The changeset number in that comment is a link to a detailed description of
    the changeset. Clicking on it, we see the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该评论中的变更集编号是变更集的详细描述的链接。单击它，我们会看到以下内容：
- en: '![Another way to search for a matching problem report](img/7566_10_10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![搜索匹配问题报告的另一种方法](img/7566_10_10.jpg)'
- en: 'Here we can see all the detailed information related to this code change: when
    it was made, who made it, the commit message, the files that were changed (or
    added or deleted), the specific lines in the files that were changed, and what
    those changes were. Most of this information is more than we really need to know
    for the problem we are researching now, but it can come in handy at times. For
    this problem, what we''d like to know is: what released level of code contains
    this fix? We''ll consider that question next.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与此代码更改相关的所有详细信息：更改是何时进行的，由谁进行的，提交消息，更改的文件（或添加或删除的文件），更改的文件中的具体行以及这些更改是什么。对于我们现在正在研究的问题，大部分这些信息都不是我们真正需要了解的，但有时可能会派上用场。对于这个问题，我们想知道的是：哪个发布级别的代码包含了这个修复程序？我们将在下面考虑这个问题。
- en: Determining the release that contains a fix
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定包含修复程序的发布版本
- en: For the particular case we are looking at, we can tell, simply based on dates,
    that the first release containing the fix should be Django 1.1.1\. A quick check
    of the web log on the Django project home page shows that Django 1.1 was released
    on July 29, 2009 and Django 1.1.1 was released on October 9, 2009\. All bug fixes
    made between those dates should be included in the 1.1.1 release, thus a fix made
    on September 11, 2009 should be in Django 1.1.1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在查看的特定情况，我们可以简单地根据日期判断，包含修复程序的第一个发布版本应该是Django 1.1.1。在Django项目主页的网志上快速检查显示，Django
    1.1于2009年7月29日发布，Django 1.1.1于2009年10月9日发布。在这些日期之间进行的所有错误修复应该包含在1.1.1版本中，因此2009年9月11日进行的修复应该包含在Django
    1.1.1中。
- en: Sometimes things may not be so clear. For example, we might be unsure if a code
    change made on the same day as a release was included in the release or happened
    just after the release. Alternatively, we might be unsure if a change was classified
    as a bug fix or a new feature. For such cases, we can check on the revision number
    of the release and compare it to the revision we are interested in.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时事情可能不那么清楚。例如，我们可能不确定在发布当天进行的代码更改是否包含在发布中，或者是在发布后发生的。或者，我们可能不确定更改是被分类为错误修复还是新功能。对于这种情况，我们可以检查发布的修订号并将其与我们感兴趣的修订号进行比较。
- en: 'Django uses the standard subversion practice of tagging released versions;
    the tagged release versions can be found under `root/django/tags/releases`. We
    can navigate down this path by first selecting the **Browse Code** tab and then
    selecting each path component in turn. Navigating in this way to the 1.1.1 release
    and clicking on **Revision Log** in the upper-right corner brings up the following
    page:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用标记发布版本的标准子版本惯例；标记的发布版本可以在`root/django/tags/releases`下找到。我们可以通过首先选择**浏览代码**选项卡，然后依次选择每个路径组件来导航到此路径。以这种方式导航到1.1.1发布并在右上角单击**修订日志**会显示以下页面：
- en: '![Determining the release that contains a fix](img/7566_10_11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![确定包含修复程序的发布版本](img/7566_10_11.jpg)'
- en: This shows that the 1.1.1 tagged release version was created by copying the
    1.1.X release branch. The changeset that created the tag is **[11612]**, higher
    than the changeset we are interested in (11498), so we'd expect the fix we are
    concerned with to be in the 1.1.X release.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明1.1.1标记的发布版本是通过复制1.1.X发布分支创建的。创建标记的变更集是**[11612]**，高于我们感兴趣的变更集（11498），因此我们期望我们关心的修复程序在1.1.X发布中。
- en: But wait a minute. Looking at the details of changeset 11498, the files changed
    were on trunk (`django/trunk/django/forms/forms.py`, for example), not the 1.1.X
    release branch `django/branches/releases/1.1.X`. If the release was created by
    copying the 1.1.X branch but the fix was only made to trunk, is it really included
    in the 1.1.1 release?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下。查看变更集11498的详细信息时，更改的文件位于主干（例如`django/trunk/django/forms/forms.py`），而不是1.1.X发布分支`django/branches/releases/1.1.X`。如果发布是通过复制1.1.X分支创建的，但修复只是在主干上进行的，那么它真的包含在1.1.1发布中吗？
- en: The answer is yes. Clicking through the link on this page to the 1.1.X release
    branch, selecting **Revision Log** for it, and scrolling down to the bottom shows
    that the 1.1.X release branch was created as a copy of trunk at revision 11500,
    two revisions past the revision 11498 we are interested in. Thus, when the 1.1.X
    branch was initially created, it contained the fix we are looking for.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。通过单击此页面上的链接转到1.1.X发布分支，为其选择**修订日志**，然后向下滚动到底部，显示1.1.X发布分支是作为主干的副本在修订版本11500时创建的，比我们感兴趣的修订版本11498晚两个修订版本。因此，当最初创建1.1.X分支时，它包含了我们正在寻找的修复程序。
- en: 'You might wonder why the 1.1.X branch was not created until sometime after
    September 11, 2009 when the 1.1 release went out in late July. The reason is because
    once the release branch is created, bug fixes have to be applied in two different
    places: trunk and the latest release branch. This is slightly more work than having
    to apply them in only one place (trunk). Creation of the release branch is thus
    generally delayed for some period of time after a release to allow bug fixes to
    be made more easily.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么1.1.X分支直到2009年9月11日之后才创建，而1.1版本在7月底就已经发布了。原因是因为一旦创建了发布分支，就必须在两个不同的地方应用错误修复程序：主干和最新的发布分支。这比只在一个地方（主干）应用它们稍微多一些工作。因此，发布分支的创建通常会在发布后的一段时间内延迟一段时间，以便更轻松地进行错误修复。
- en: This delayed creation of the release branch means that during the time it does
    not exist, no changes related to new features can be made to trunk, since the
    release branch must contain only bug fixes, and no new features. That's generally
    not a problem, though, since right after a release there is little feature work
    being done. Everyone involved usually needs some time to take a breather and first
    decide what features might go into the next release. Once some feature work for
    the next release gets close to needing to be checked in, then the release branch
    for the previous release is created. From then on, feature work gets checked into
    trunk while bug fixes get checked in to both trunk and the release branch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在不存在发布分支的时间内，不能对主干进行与新功能相关的更改，因为发布分支必须仅包含错误修复，而不包含新功能。不过，这通常不是问题，因为在发布后不久，很少进行功能工作。通常每个人都需要一些时间来休息，并首先决定哪些功能可能会进入下一个发布版本。一旦下一个发布版本的一些功能工作接近需要被检入的时候，那么就会创建上一个发布版本的发布分支。从那时起，功能工作被检入主干，而错误修复被检入主干和发布分支。
- en: What if a fix hasn't been released yet?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果修复尚未发布呢？
- en: Here we were lucky enough to run into a problem that had already been fixed,
    and the fix was already available in an officially released version. In any case
    of a problem like this that is encountered, it should be an easy choice to simply
    update to the latest micro release to get the fix. As mentioned earlier, it is
    always recommended to install the latest micro release for the particular major.minor
    version in use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们很幸运地遇到了一个已经修复的问题，并且修复已经在官方发布的版本中可用。在遇到这样的问题时，应该很容易地选择更新到最新的微版本以获得修复。如前所述，始终建议安装正在使用的特定
    major.minor 版本的最新微版本。
- en: But what if the fix we wanted was made sometime after the latest available release?
    What should we do then? The easy technical answer is to simply check out the latest
    level of either trunk or the release branch that contains the fix, and run with
    that code. If the release branch, in particular, is used, there should be no concern
    about picking up any code instabilities, since the only changes that go into the
    release branch are bug fixes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要的修复是在最新可用版本之后的某个时间点进行的呢？那么我们应该怎么办？简单的技术答案是简单地检出包含修复的最新级别的主干或发布分支，并使用该代码。特别是如果使用发布分支，就不必担心采用任何代码不稳定性，因为发布分支中的唯一更改是错误修复。
- en: This easy technical answer may, however, run afoul of local policies regarding
    running only "release level" code. If you are working in an environment with such
    policies, you may have some additional hurdles to overcome in order to use fixes
    that have not yet been made available in an official version. The best course
    to take will likely be determined by factors such as the exact policies you are
    dealing with, the severity of the problem you have encountered, and the ability
    to find a workaround in your own code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的技术答案可能违反了关于仅运行“发布级别”代码的本地政策。如果你在这样的环境中工作，可能需要克服一些额外的障碍，以便使用尚未在官方版本中提供的修复。采取的最佳方法可能会由你所处理的确切政策、你遇到的问题的严重程度以及在你自己的代码中找到解决方法的能力等因素决定。
- en: What if a fix hasn't been committed yet?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果修复尚未提交呢？
- en: 'Sometimes when researching a problem the results will show that the problem
    has been reported, but not yet fixed. How best to proceed then will likely depend
    on how interested you are in getting involved and contributing to Django, and
    how close the matching problem report is to being fixed. Details of how to get
    involved in contributing to Django are beyond the scope of what is covered here,
    but this section provides some broad guidelines for how to proceed based on your
    level of interest. If you are interested in contributing, the Django website has
    details of how to contribute, available at: [http://docs.djangoproject.com/en/dev/internals/contributing/](http://docs.djangoproject.com/en/dev/internals/contributing/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在研究问题时，结果会显示问题已经被报告，但尚未修复。在这种情况下，如何最好地继续可能取决于你对参与和贡献到 Django 的兴趣程度，以及匹配问题报告与修复之间的接近程度。如何参与贡献到
    Django 的细节超出了本文的范围，但本节提供了一些基于你的兴趣程度的广泛指导方针。如果你有兴趣贡献，Django 网站提供了如何贡献的详细信息，网址为：[http://docs.djangoproject.com/en/dev/internals/contributing/](http://docs.djangoproject.com/en/dev/internals/contributing/)。
- en: If you are not interested in experimenting with code that has not yet been committed
    to the code base, there will likely not be much you can do besides wait for a
    fix to be committed. The exception to this would be for problems that are not
    well understood. In that case, you may be able to provide specific details of
    the case where you are running into the problem that can help others better understand
    the problem and develop a fix.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对尚未提交到代码库的代码不感兴趣，除了等待修复被提交之外，可能没有太多事情可做。唯一的例外是对于尚未被充分理解的问题。在这种情况下，你可能能够提供你遇到问题的具体细节，以帮助其他人更好地理解问题并开发修复方案。
- en: If you are willing to experiment with uncommitted code, you'll likely be able
    to find a workable solution to the problem you've encountered more quickly. In
    the best case, you may find that the ticket matching the problem you have encountered
    already has a working patch attached. It's possible and all you need to do is
    download it and apply it to your copy of the Django code to resolve the problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意尝试未提交的代码，你可能会更快地找到解决你遇到的问题的可行解决方案。在最好的情况下，你可能会发现与你遇到的问题匹配的票据已经附有一个有效的补丁。这是可能的，你所需要做的就是下载它并将其应用到你的
    Django 代码副本中以解决问题。
- en: You'll then have to decide whether you are able to, and comfortable with, deploying
    your application with a version of Django that has some "custom" fixes applied.
    If not, you might like to help out in getting the working patch checked into the
    code base by seeing if there is anything missing (such as tests) that needs to
    be included before the fix is checked in and if so, supplying the missing bits.
    In some cases, though, there is nothing missing and all that is needed is time
    for the fix to make its way into the code base.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要决定是否能够并且愿意部署你的应用程序，使用一个已经应用了一些“自定义”修复的Django版本。如果不能，你可能想要帮助将工作补丁检查到代码库中，看看是否有任何遗漏的部分（比如测试）需要在修复被检查之前包含进去，如果有的话，提供这些遗漏的部分。然而，在某些情况下，没有任何遗漏，所需要的只是时间让修复进入代码库。
- en: If you find a matching ticket with a patch that you try, but it doesn't fix
    the problem you are experiencing, that is valuable information that would be useful
    to post to the ticket. You might want to be sure first, though, that your problem
    is really the same as the one in the ticket you have found. If it's really a slightly
    different problem, then it might be more appropriate to open a new ticket for
    the somewhat different problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到一个有补丁的匹配票据，但它没有解决你所遇到的问题，那么这是有价值的信息，可以发布到票据上。不过，你可能首先要确保你的问题确实与你找到的票据中的问题相同。如果它确实是一个稍微不同的问题，那么为这个稍微不同的问题开一个新的票据可能更合适。
- en: When in doubt, you can always post information in what you think is the matching
    ticket about the problem you are seeing and how the existing patch doesn't seem
    to fix it. Someone else following the ticket might then be able to provide feedback
    on whether your problem is the same and the existing patch is indeed not quite
    right or whether you are really dealing with a different problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你怀疑时，你可以随时在你认为匹配的票据中发布关于你所看到的问题以及现有补丁似乎无法解决它的信息。跟踪票据的其他人可能会提供反馈，告诉你你的问题是否相同，现有的补丁是否确实不太对，或者你是否真的在处理一个不同的问题。
- en: In the worst case, you may find a ticket reporting the same problem as you are
    experiencing but no attached patch to try. That's not very helpful to you, but
    offers you the most opportunity to contribute. If you have the time and are so
    inclined, you can delve into the Django code and see if you can come up with a
    patch that you can post to the ticket to help get the problem fixed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，你可能会发现一个报告与你所经历的相同问题的票，但没有附加的补丁可供尝试。这对你来说并不是很有帮助，但却为你提供了最多的机会去贡献。如果你有时间并且愿意，你可以深入研究Django代码，看看是否能够提出一个补丁，然后将其发布到票据上，以帮助解决问题。
- en: What if a ticket has been closed without a fix?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果一个票已经关闭而没有修复呢？
- en: 'Sometimes when researching a problem the results will turn up with a matching
    report (or multiple reports) that have been closed without any fix being made.
    There are three different resolutions that might be used in cases like this: invalid,
    worksforme, and wontfix. How best to proceed will depend on the specifics of the
    problem report and the resolution used to close the matching problem ticket.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在研究问题时，结果会出现一个匹配的报告（或多个报告），但没有进行任何修复而被关闭。在这种情况下可能会使用三种不同的解决方案：无效、worksforme和wontfix。如何最好地继续将取决于问题报告的具体情况以及用于关闭匹配问题票据的解决方案。
- en: 'First, the invalid resolution is pretty broad. A ticket might be closed as
    invalid for many different reasons, including:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无效的解决方案是非常广泛的。一个票可能因为很多不同的原因而被关闭为无效，包括：
- en: The described problem is not a problem at all but rather some error in the reporter's
    code or misunderstanding about how some feature is supposed to work.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述的问题根本不是问题，而是报告者代码中的一些错误，或者对某些功能应该如何工作的误解。
- en: The described problem is too vague. For example, if a ticket is opened that
    provides just an error traceback but no information on how to trigger the traceback,
    there is not much anyone can do to help track down and fix the problem, so it
    might well be closed as invalid.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述的问题太模糊了。例如，如果一个票只提供了一个错误的回溯，但没有关于如何触发回溯的信息，那么没有人能够帮助跟踪并解决问题，所以它很可能会被关闭为无效。
- en: The described problem is indeed a problem, but the root cause is some code other
    than Django. If there is nothing that can be done in Django code to fix the problem,
    the ticket will likely be closed as invalid.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述的问题确实是一个问题，但根本原因是Django之外的一些代码。如果在Django代码中无法解决问题，那么票据很可能会被关闭为无效。
- en: In cases where you find a matching ticket that has been closed as invalid, you
    should read the comment that was made when the ticket was closed. In cases where
    the ticket was closed due to lack of information about the problem, and you can
    provide some of the missing data needed to make progress on fixing the problem,
    it may be appropriate to re-open the ticket. Otherwise, if you don't understand
    the explanation for closing, or don't agree with the reason for closing, it's
    best to start a discussion on one of the mailing lists (discussed in the next
    section) to get some more feedback on how best to proceed to fix the problem you
    are encountering.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你找到一个被关闭为无效的匹配票据时，你应该阅读票据关闭时所做的评论。在票据因缺乏关于问题的信息而关闭时，如果你可以提供一些需要的缺失数据来解决问题，重新打开票据可能是合适的。否则，如果你不理解关闭的解释，或者不同意关闭的原因，最好在邮件列表中开始讨论（在下一节中讨论），以获得更多关于如何最好地解决你遇到的问题的反馈。
- en: The worksforme resolution is pretty straightforward; it indicates that the person
    who closed the ticket could not reproduce the reported problem. It, like invalid,
    may be used when the original problem report does not really contain enough information
    to recreate the problem. The missing information may be specifics of the code
    used to cause the problem, or specifics of the environment (operating system,
    Python version, deployment specifics) where the problem occurs. If you are able
    to recreate a problem that has been closed worksforme, and can supply the missing
    details that would allow someone else to do the same, you should feel free to
    re-open the ticket and provide that information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: worksforme解决方案非常直接，它表示关闭工单的人无法重现报告的问题。它和invalid一样，可能是在原始问题报告中没有足够的信息来重现问题时使用的。缺少的信息可能是导致问题的代码的具体信息，或者问题发生的环境的具体信息（操作系统，Python版本，部署细节）。如果您能够重现一个被关闭为worksforme的问题，并且能够提供缺失的细节，使其他人能够做同样的事情，那么您应该随时重新打开工单并提供这些信息。
- en: The wontfix resolution is also straightforward. Usually only core committers
    will close tickets wontfix, and that indicates that a decision has been made by
    the core team to not fix that particular problem (which will usually be a feature
    request, not a bug). If you disagree with a wontfix decision or believe that not
    all of the appropriate information was considered in making the decision, you
    will not make any forward progress on changing anyone's mind by simply re-opening
    the ticket. Rather, you will need to bring the issue up on the django-developers
    mailing list and see if you can get enough consensus from the wider development
    community to get the wontfix decision reversed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: wontfix解决方案也很直接。通常只有核心贡献者会关闭wontfix工单，这表示核心团队已经决定不修复特定的问题（通常是一个功能请求，而不是一个错误）。如果您不同意wontfix的决定，或者认为在做出决定时没有考虑到所有适当的信息，那么您不会通过简单地重新打开工单来改变任何人的想法。相反，您需要在django-developers邮件列表上提出这个问题，并看看是否能够得到更广泛的开发社区的共识，以便推翻wontfix的决定。
- en: Tracking down unreported problems
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪未报告的问题
- en: Sometimes when researching a problem no matching reports will turn up. How best
    to proceed then likely depends on how sure you are that the problem you are encountering
    is a bug in Django. If you are really sure the problem lies in Django, you can
    proceed directly to opening a new ticket to report it. If you are not so sure,
    it is best to get some feedback from the community first. The following sections
    will describe where to ask questions, present some tips on asking good questions,
    and describe how to open a new ticket.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在研究问题时，找不到匹配的报告。在这种情况下，最好的处理方式可能取决于您对您遇到的问题是否是Django中的错误有多确定。如果您非常确定问题出在Django中，您可以直接打开一个新的工单来报告它。如果您不太确定，最好先从社区中获得一些反馈。以下部分将描述在哪里提问，提供一些关于提问的好建议，并描述如何打开一个新的工单。
- en: Where to ask questions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哪里提问
- en: 'Clicking on the **Community** link on any Django website page brings up the
    following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Django网站页面上点击**社区**链接会弹出以下内容：
- en: '![Wheunreported problems, trackingaboutre to ask questions](img/7566_10_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![未报告的问题，追踪问题的地方](img/7566_10_12.jpg)'
- en: The left side of this page provides links to articles in blogs written by people
    who discuss Django. While reading such entries is a good way to learn about the
    community of people using Django, it is the right side of this page that we are
    interested in right now. Here we see links to ways to interact directly with other
    members of the Django community.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的左侧提供了链接到博客文章的链接，这些文章是由讨论Django的人写的。阅读这些文章是了解使用Django的人群的一个好方法，但我们现在感兴趣的是这个页面的右侧。在这里，我们可以看到与Django社区其他成员直接互动的方式的链接。
- en: First in the list is a link to the **#django IRC channel**. (**IRC** stands
    for **Internet Relay Chat**.) This option provides a chat-type interface to talk
    to other Django users interactively. This is a good choice for times when you'd
    like very quick feedback on whatever you'd like to ask about or discuss. It can
    be difficult, though, to follow a detailed coding discussion in a chat interface.
    For cases like that, one of the mailing lists is likely a better alternative.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个是**#django IRC频道**的链接。（**IRC**代表**Internet Relay Chat**。）这个选项提供了一个聊天式界面，可以与其他Django用户进行互动交流。这是在您想要快速获得关于您想要询问或讨论的任何内容的反馈时的一个不错的选择。然而，在聊天界面中进行详细的编码讨论可能会有困难。对于这种情况，其中一个邮件列表可能是一个更好的选择。
- en: 'There are two mailing lists, shown next: **django-users** and **django-developers**.
    The first is for discussions about using Django, the second is for discussions
    about developing Django itself. If you have encountered a problem that you think,
    but are not sure, is a problem in Django, django-users is the correct place to
    post a question about the issue. Members of the Django core development team read
    and respond to questions on the user''s list and will provide feedback on whether
    the problem should be opened as a ticket or taken to the developer''s list for
    further discussion.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个邮件列表，如下所示：**django-users**和**django-developers**。第一个用于讨论如何使用Django，第二个用于讨论Django本身的开发。如果你遇到了一个问题，你认为，但不确定，是Django的问题，django-users是发布有关该问题的问题的正确地方。Django核心开发团队的成员会阅读并回答用户列表上的问题，并提供反馈，告知问题是否应该被提出为一个工单或者是否应该被带到开发者列表进行进一步讨论。
- en: Both of the mailing lists are hosted as Google groups. Each of the group names
    previously shown is actually a link that you can click to go directly to the Google
    groups page for the group. From there you can see the list of recent discussions
    in the group, and read any topics that might be of interest. Google groups also
    provide a search function, but unfortunately this function does not always work
    correctly, so searching in the group from the group's page may not produce helpful
    results.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个邮件列表都托管在Google群组中。先前显示的每个组名称实际上都是一个链接，您可以单击该链接直接转到该组的Google群组页面。从那里，您可以查看该组中的最近讨论列表，并阅读可能感兴趣的任何主题。Google群组还提供搜索功能，但不幸的是，该功能并不总是正常工作，因此从该组的页面中搜索可能不会产生有用的结果。
- en: 'If you decide you want to post to one of the groups, you will first need to
    join it. This helps to cut down on spam posted to the groups, since would-be spammers
    must first join. There are, however, plenty of would-be spammers that do join
    and attempt to send spam to the lists. Thus, there is also an additional anti-spam
    measure in place: posts sent by new members are sent through moderation.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定要发布到其中一个组，您首先需要加入该组。这有助于减少发布到组的垃圾邮件，因为潜在的垃圾邮件发送者必须首先加入。然而，有很多潜在的垃圾邮件发送者确实加入并尝试向列表发送垃圾邮件。因此，还有一个额外的反垃圾邮件措施：新成员发送的帖子将通过审核。
- en: This anti-spam measure means that the first post you send to either of these
    lists may take some time to appear, since it must be manually approved by one
    of the volunteer moderators. Usually this will not take very long, but it could
    take up to a few hours. Typically, once a first obviously legitimate post is received
    from a user, their status is updated to indicate their posts do not need to be
    moderated, so subsequent posts will appear in the group immediately.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反垃圾邮件措施意味着您发送到这些列表中的第一篇帖子可能需要一些时间才能出现，因为它必须由其中一位志愿者审核批准。通常情况下，这不会花费太长时间，但可能需要多达几个小时。通常情况下，一旦用户收到一个明显合法的第一篇帖子，他们的状态将被更新，以指示他们的帖子不需要经过审核，因此随后的帖子将立即出现在组中。
- en: Tips on asking questions that will get good answers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提出问题以获得良好答案的提示
- en: Once you decide to post a question, the next task will be to compose a question
    in a way that will most likely produce some helpful answers. This section presents
    some guidance on how to do that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定发布问题，下一个任务将是以最有可能产生一些有用答案的方式撰写问题。本节提供了一些建议，说明如何做到这一点。
- en: First, be specific about what you are doing. If you have some code that isn't
    behaving as you expect, include the code verbatim rather than describing in prose
    what the code does. Often, it is the detailed specifics of the actual code in
    use that is key to understanding a problem, and those specifics are easily lost
    in a prose description of the code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要具体说明你正在做什么。如果您有一些代码的行为与您的期望不符，请直接包含代码，而不是用散文描述代码的功能。通常，实际使用的代码的详细细节是理解问题的关键，这些细节在代码的散文描述中很容易丢失。
- en: However, if the code is too lengthy or too wide to be read easily in an e-mail
    interface that will automatically wrap long lines, it's likely best not to include
    it in a post. Ideally in a situation like this you would be able to cut the code
    necessary to recreate the problem down to a manageable size that can be read easily
    in an e-mail, and post that.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果代码过长或过宽，无法在电子邮件界面中轻松阅读，因为它会自动换行长行，最好不要在帖子中包含它。理想情况下，在这种情况下，您应该能够将重新创建问题所需的代码剪切到一个可以在电子邮件中轻松阅读的可管理大小，并发布它。
- en: Note that if you do this, it's a good idea to first verify that the cut-down
    version of the code is both correct (does not have any syntax errors, for example)
    and exhibits the problem you are asking about. Otherwise, the only responses you
    get may simply report that the posted code either doesn't work at all or doesn't
    show the behavior you describe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您这样做，最好先验证剪裁版本的代码是否正确（例如没有任何语法错误）并且是否出现您所询问的问题。否则，您可能只会收到回复，报告发布的代码根本不起作用，或者不显示您描述的行为。
- en: If you cannot cut the necessary code down to a manageable size, either because
    you do not have the time or because cutting it down makes the problem go away,
    you might try posting the code on some place like dpaste.com and just including
    a link to it in your question. It is really in your best interest, though, to
    keep the code needed to demonstrate the problem as short as possible. As the code
    you post or point to gets longer and longer, fewer and fewer people on the mailing
    list will take the time to try to understand the problem and help guide you towards
    a solution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法将必要的代码剪裁到可管理的大小，要么是因为您没有时间，要么是因为剪裁代码会使问题消失，您可以尝试将代码发布在dpaste.com之类的地方，并在问题中包含一个链接。但是，最好将需要演示问题的代码保持尽可能短。随着您发布或指向的代码越来越长，邮件列表上的人越来越少，他们会花时间去理解问题并帮助您找到解决方案。
- en: In addition to being specific about the code you are using, be specific about
    what you are doing to trigger the errant behavior. Are you observing a problem
    when you visit one of your own application URLs? When you do something in the
    admin application? When you try something from a `manage.py` shell? It may seem
    obvious to you, but it really helps others to recreate the problem if you spell
    out what you are doing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具体说明您正在使用的代码外，还要具体说明您正在做什么来触发错误行为。当您访问自己的应用程序URL之一时，您是否观察到问题？当您在管理应用程序中执行某些操作时？当您从`manage.py`
    shell尝试某些操作时？这对您可能显而易见，但如果您详细说明您正在做什么，它确实有助于他人重现问题。
- en: Second, be specific about what happens and what you expected to happen instead.
    "It doesn't work" is not specific. Nor is "it dies", nor "it gives me an error
    message". Give specifics of what "doesn't work" looks like. A browser page that
    displays X when you expected Y? An error message that states XYZ? A traceback?
    In this last case, do include the full traceback in the question, since that provides
    valuable debugging clues for people who might try to help.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，具体说明发生了什么，以及你期望发生的是什么。"它不起作用"不是具体的。"它死了"也不是，"它给了我一个错误信息"也不是。给出"不起作用"的具体表现。当你期望Y时，浏览器页面显示X？一个声明XYZ的错误信息？一个回溯？在最后一种情况下，在问题中包含完整的回溯，因为这为可能试图帮助的人提供了宝贵的调试线索。
- en: Third, if you mention in the question that your expected behavior is based on
    what the documentation says, be specific about what documentation, exactly, you
    are referring to. Django has extensive documentation, including both guide and
    reference information. Someone reading your question and searching the documentation
    for what you are referencing may easily find a completely different section and
    have a hard time following what you are saying. If you provide a specific link
    to the documentation in question, then misunderstandings are less likely to occur.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果你在问题中提到你的预期行为是基于文档的，那么请具体说明你所指的是哪个文档。Django有广泛的文档，包括指南和参考信息。阅读你的问题并搜索你所引用的文档的人可能会轻易地找到一个完全不同的部分，并且很难理解你的意思。如果你提供了问题文档的具体链接，那么误解的可能性就会降低。
- en: 'A common theme running through all these tips, as you''ve likely noticed, is:
    be specific. Yes it takes more work to provide specifics. But a specific question
    is far more likely to get helpful answers than an imprecise and vague question.
    If you leave out the specifics, once in a blue moon someone may post an answer
    that guides you towards a solution. It''s far more likely, though, that a vague
    question will get either no responses, responses asking for specifics, or responses
    that send you down an entirely wrong path because the responder completely misunderstood
    the question.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有这些提示中都有一个共同的主题：具体。是的，提供具体信息需要更多的工作。但是一个具体的问题更有可能得到有用的答案，而不是一个不明确和模糊的问题。如果你省略了具体信息，偶尔会有人发布一个指导你解决问题的答案。然而，更有可能的是，一个模糊的问题要么得不到回应，要么得到要求具体信息的回应，要么得到完全误解问题的回应。
- en: Opening a new ticket to report a problem
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开一个新的票证来报告问题
- en: 'If you run into a problem that appears to be an unreported and unfixed bug
    in Django code, the next step is to open a ticket for it. The process for this
    is pretty self-explanatory when you select the **New Ticket** tab after clicking
    on **Code** from the Django home page:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个看起来是Django代码中未报告和未修复的错误，下一步就是为此问题打开一个票证。当你从Django首页点击**Code**后选择**New
    Ticket**选项卡时，这个过程就变得非常直观了。
- en: '![Opening a new ticket to report a problem](img/7566_10_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![打开一个新的票证来报告问题](img/7566_10_13.jpg)'
- en: Please do read through the **Read this first** list. Much of the information
    in that list has been covered earlier in this chapter, but not all. In particular,
    the last item notes how to mark up submitted code snippets or tracebacks so that
    they will be formatted properly. The note includes the one type of mark up most
    frequently left out and also points to the full documentation on how text can
    be specially formatted. Note that you can check how the formatting will look by
    selecting the **Preview** button at the bottom—it's always a good idea to try
    previewing a submission before pressing **Submit**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保阅读**首先阅读**列表。该列表中的许多信息在本章的早些部分已经涵盖了，但并非全部。特别是，最后一项指出了如何标记提交的代码片段或回溯，以便它们能够正确格式化。该注释包括最常被忽略的一种标记类型，并指向了关于如何特殊格式化文本的完整文档。请注意，你可以通过选择底部的**预览**按钮来检查格式化的效果——在按下**提交**之前尝试预览是一个很好的主意。
- en: Note that the Django Trac installation does allow anonymous ticket submissions
    and updates. However, it also uses the Akismet spam-filtering service, and this
    service does sometimes reject non-spam submissions. As noted in the big yellow
    box, the easiest way to avoid this is to **register for an account** (that text
    on the page is a link to a page where you can register).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Django Trac安装确实允许匿名提交和更新票证。然而，它也使用Akismet垃圾邮件过滤服务，这项服务有时会拒绝非垃圾邮件的提交。正如大黄框中所指出的，避免这种情况的最简单方法是**注册一个账户**（页面上的文字是一个链接，可以跳转到注册页面）。
- en: The two most important bits to fill out when opening a new ticket are the short
    summary and full description. In the short summary, try to include key terms that
    will make the new ticket show up in likely searches by people encountering the
    same problem. In the full description, all the advice from the previous section
    about being specific applies again. If you are opening a ticket after the discussion
    on one of the mailing lists came to the conclusion that a ticket is a good idea,
    it's helpful to include a link to that discussion in the problem. However, it
    is also good to include the basic information about the problem in the ticket
    description itself as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开一个新的票证时，填写最重要的部分是简短的摘要和完整的描述。在简短的摘要中，尽量包含关键术语，这样新的票证就会在遇到相同问题的人的可能搜索中显示出来。在完整的描述中，之前关于具体性的所有建议都再次适用。如果你在邮件列表的讨论后得出结论认为需要打开一个票证，那么在问题中包含该讨论的链接是有帮助的。然而，在票证描述中也包含关于问题的基本信息也是很好的。
- en: In the information in **Ticket Properties**, you likely don't need to change
    anything from the default values, excepting **Version** (if you are using a version
    other than the one displayed) and **Has patch** (if you are going to attach a
    patch that fixes the problem). You can try to guess the correct **Component**
    from the list and include some appropriate **Keywords**, but it's not necessary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在**票据属性**中的信息中，您可能不需要更改任何默认值，除了**版本**（如果您使用的版本与显示的版本不同）和**有补丁**（如果您将附加修复问题的补丁）。您可以尝试从列表中猜测正确的**组件**并包含一些适当的**关键字**，但这并非必要。
- en: Similarly, you can set the **Milestone** to the next release, though that won't
    really make it any more likely that someone will tackle the problem sooner rather
    than later. That field is typically only closely watched towards the very tail
    end of a release to note which bugs absolutely must be fixed before release.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以将**里程碑**设置为下一个发布版本，尽管这并不会使有人更有可能尽快解决问题。该字段通常只在发布的最后阶段密切关注，以记录哪些错误绝对必须在发布之前修复。
- en: 'Once you submit a ticket, if you used a login that included an e-mail address,
    or specified an e-mail address in the field labeled **Your email or username**,
    updates to the ticket will automatically be e-mailed to the e-mail address specified.
    So if someone adds a comment to the ticket, you will be notified. An annoying
    exception to this is the automatically-generated update resulting from a commit
    to the code base: this does not generate e-mail to the ticket reporter. So, you
    won''t necessarily get notified when the ticket is closed as fixed, but rather
    will have to check back on its status from the website manually.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提交票据后，如果您使用包含电子邮件地址的登录，或在标有**您的电子邮件或用户名**的字段中指定了电子邮件地址，则票据的更新将自动发送到指定的电子邮件地址。因此，如果有人向票据添加评论，您将收到通知。这种情况的一个令人讨厌的例外是由于对代码库的提交而产生的自动生成的更新：这不会生成发送给票据报告者的电子邮件。因此，当票据被关闭为已修复时，您不一定会收到通知，而是必须手动从网站上检查其状态。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We''ve now come to the end of discussion of what to do when none of the other
    debugging techniques covered previously have succeeded in solving some problem.
    In this chapter, we:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们讨论了在先前介绍的调试技术都未能成功解决某些问题时该怎么办。在本章中，我们：
- en: Encountered a bug that existed in Django 1.1 and caused some of the survey application
    code to not behave as desired
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到了一个存在于Django 1.1中的错误，导致一些调查应用代码无法按预期行为
- en: Walked through the verification process of tracking down the problem to Django
    instead of the survey code
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走过了追踪问题的验证过程，发现问题是由Django而不是调查代码引起的
- en: Saw how searching in the Django code tracker revealed the problem was a bug
    that had been fixed in Django 1.1.1, which provided an easy solution to the problem
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到在Django代码跟踪器中搜索揭示了问题是一个已在Django 1.1.1中修复的错误，这为问题提供了一个简单的解决方案
- en: Discussed options for how to proceed when problems are tracked down to bugs
    with fixes that are either not yet available or not available in official releases
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了当问题被追踪到尚未可用或在官方发布中不可用的修复程序时如何继续的选项
- en: Described the various community resources that exist for asking questions about
    behavior that seems puzzling, but doesn't seem to have been reported as a bug
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述了存在的各种社区资源，用于询问行为似乎令人困惑，但似乎尚未被报告为错误的问题
- en: Discussed tips for writing questions so that they get the desired helpful responses
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了撰写问题的提示，以便获得所需的有益回应
- en: Described the process of opening a new ticket to report a problem in Django
    code
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述了在Django代码中报告问题时打开新票的过程
- en: 'In the next chapter, we will advance to the final stage in developing a Django
    application: moving to production.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入Django应用程序开发的最后阶段：转向生产。
