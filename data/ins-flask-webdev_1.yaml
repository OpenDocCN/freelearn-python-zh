- en: Chapter 1. Instant Flask Web Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。即时Flask网络开发
- en: Welcome to *Instant Flask Web Development*. We will progressively walk through
    web development in the Python programming language using Flask, a small but expressive
    framework which provides the essentials and enables you to build your own code
    patterns. We will build a simple scheduling application to keep track of appointments,
    including a database and a user interface, and we will build one piece at a time.
    We will build our application bottom-up, and you will see how everything fits
    together in later sections. This bottom-up approach will give you the building
    blocks you need to grow your project with Flask.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*即时Flask网络开发*。我们将逐步学习使用Flask这种小而富有表现力的框架在Python编程语言中进行网络开发，该框架提供了基本功能，并使您能够构建自己的代码模式。我们将构建一个简单的日程安排应用程序来跟踪约会，包括数据库和用户界面，我们将一步一步地构建。我们将从底层构建我们的应用程序，您将在后面的章节中看到一切是如何组合在一起的。这种自下而上的方法将为您提供使用Flask扩展项目所需的基本组件。
- en: Preparing for development (Simple)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发（简单）
- en: We begin our exploration of Flask web programming with everything in its place,
    setting up a development environment in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Python中设置开发环境，开始探索Flask网络编程。
- en: Getting ready
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Go to [python.org](http://python.org) to get Python. Our application will run
    on Python 2.7 and Python 3.3+. Once you have Python, you do not need administrative
    access to your development machine, and you can even install Python for just your
    user according to the install instructions on [python.org](http://python.org).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[python.org](http://python.org)获取Python。我们的应用程序将在Python 2.7和Python 3.3+上运行。一旦您安装了Python，您就不需要对开发机器进行管理访问，甚至可以根据[python.org](http://python.org)上的安装说明仅为您的用户安装Python。
- en: How to do it...
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Python projects can manage packages using **virtualenv**, a user-writable area
    on the machine that is dedicated to a specific project. You can use virtualenv
    on Unix/Unix-like systems, Mac OS X, and Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python项目可以使用**virtualenv**来管理软件包，这是机器上专门用于特定项目的用户可写区域。您可以在Unix/类Unix系统、Mac OS
    X和Windows上使用virtualenv。
- en: We'll use the command line to get virtualenv up and running, then discuss the
    tools you need in your development environment. Before we get started, note the
    *Common Errors and how to solve them* subsection in the *There's more...* section
    in case you run into a problem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行来启动virtualenv，然后讨论您在开发环境中需要的工具。在开始之前，请注意*常见错误及其解决方法*小节中的*更多信息*部分，以防遇到问题。
- en: 'Unix-style systems ship with a terminal emulator, which we will use throughout
    this book. The steps required to install Flask on Unix, Unix-like systems, and
    Mac OS X are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix系统附带一个终端仿真器，我们将在本书中使用。在Unix、类Unix系统和Mac OS X上安装Flask所需的步骤如下：
- en: Open a terminal in the directory where you would like your project to be located.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您希望项目位于的目录中打开一个终端。
- en: Download virtualenv from `pypi.python.org/pypi/virtualenv/1.9.1`. In the terminal,
    you can do this with `curl -O https://pypi.python.org/packages/source/v/virtualenv/virtualenv-1.9.1.tar.gz`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`pypi.python.org/pypi/virtualenv/1.9.1`下载virtualenv。在终端中，您可以使用`curl -O https://pypi.python.org/packages/source/v/virtualenv/virtualenv-1.9.1.tar.gz`来完成这个步骤。
- en: Unpack virtualenv with `tar xvzf virtualenv-1.9.1.tar.gz`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tar xvzf virtualenv-1.9.1.tar.gz`解压virtualenv。
- en: Create a virtualenv tool named `env` with `python virtualenv-1.9.1/virtualenv.py
    env`. You can use any name you like; just be sure to make the changes in the commands
    here according to the name you choose.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python virtualenv-1.9.1/virtualenv.py env`创建一个名为`env`的virtualenv工具。您可以使用任何名称；只需根据您选择的名称更改这里的命令。
- en: Activate the virtualenv tool with `. env/bin/activate`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`. env/bin/activate`激活virtualenv工具。
- en: Install Flask with `pip install Flask`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip install Flask`安装Flask。
- en: Verify whether Flask is installed with a simple smoke test, `python -m flask.config`.
    Nothing will be displayed if Flask is installed.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的烟雾测试`python -m flask.config`验证Flask是否已安装。如果已安装Flask，则不会显示任何内容。
- en: You can turn off the virtualenv with `deactivate` to continue using the terminal
    for other projects. Anytime you resume work on your Flask project, activate the
    virtualenv again with `. path/to/env/bin/activate`. The `.` command sources the
    activate script to set environment variables that point to the `python` executable
    in the virtualenv and enable import of the packages installed there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`deactivate`关闭virtualenv，以便继续在终端上使用其他项目。每当您恢复对Flask项目的工作时，都要使用`. path/to/env/bin/activate`再次激活virtualenv。`.`命令会源化激活脚本，设置指向virtualenv中的`python`可执行文件的环境变量，并启用在那里安装的软件包的导入。
- en: 'For Windows, we will use `cmd.exe`. The steps to install Flask on Windows are
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，我们将使用`cmd.exe`。在Windows上安装Flask的步骤如下：
- en: Ensure the Python installation and its `scripts` directory, which are `C:\Python33\`
    and `C:\Python33\Scripts\` by default, are in your current `PATH` variable. Use
    `Python27` if you are using Python 2.7, and note that Windows uses a semicolon
    in-between directories in `PATH`. Use `echo %PATH%` to see your `PATH` variable.
    In general, edit `PATH` by navigating to **Computer** | **Properties** | **Advanced**
    | **Environment Variables**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Python安装及其`scripts`目录（默认为`C:\Python33\`和`C:\Python33\Scripts\`）在您当前的`PATH`变量中。如果您使用Python
    2.7，则使用`Python27`，请注意Windows在`PATH`中的目录之间使用分号。使用`echo %PATH%`查看您的`PATH`变量。通常，通过导航到**计算机**
    | **属性** | **高级** | **环境变量**来编辑`PATH`。
- en: Open a shell in the directory where you would like your project to be located.
    Historically, you could run into scripts which fail on spaces in the filepath,
    which is why `C:\Python27\` is preferred to `C:\Program Files\Python27\`; keep
    that in mind if you see strange errors.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您希望项目位于的目录中打开一个shell。从历史上看，您可能会遇到在文件路径中存在空格时运行失败的脚本，这就是为什么`C:\Python27\`比`C:\Program
    Files\Python27\`更受青睐；如果您遇到奇怪的错误，请记住这一点。
- en: Download `virtualenv.py` from [https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py](https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py)
    to the same directory.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py](https://raw.github.com/pypa/virtualenv/1.9.1/virtualenv.py)下载`virtualenv.py`到相同的目录。
- en: Create a virtualenv named `env` with `python virtualenv.py env`. You can use
    any name you like; just be sure to make the changes in the commands here according
    to the name you chose.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python virtualenv.py env`创建名为`env`的虚拟环境。您可以使用任何名称；只需确保根据您选择的名称更改这里的命令。
- en: Activate the virtualenv with `env\Scripts\activate.bat`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`env\Scripts\activate.bat`激活virtualenv。
- en: Install Flask with `pip install Flask`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip install Flask`安装Flask。
- en: Verify whether Flask is installed with a simple smoke test, `python -m flask.config`.
    Nothing will be displayed if Flask is installed.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的烟雾测试`python -m flask.config`验证Flask是否已安装。如果已安装Flask，则不会显示任何内容。
- en: You can turn off the virtualenv tool with `deactivate` to continue using the
    command prompt for other projects. Anytime you resume work on your Flask project,
    activate the virtualenv tool again with `env\Scripts\activate.bat`, which is a
    batch file to set environment variables that point to the python executable in
    the virtualenv and enable import of the packages installed there.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`deactivate`关闭virtualenv工具，以便继续在命令提示符中使用其他项目。每当您恢复对Flask项目的工作时，再次使用`env\Scripts\activate.bat`激活virtualenv工具，这是一个批处理文件，用于设置指向virtualenv中的python可执行文件的环境变量，并启用在其中安装的软件包的导入。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using Windows, you can use PowerShell for a richer command-line environment
    by referring to [technet.microsoft.com/en-us/library/bb978526.aspx](http://technet.microsoft.com/en-us/library/bb978526.aspx),
    or you can work with `cmd.exe` if you do not have access to PowerShell by referring
    to [docs.python.org/2/using/windows.html](http://docs.python.org/2/using/windows.html).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，可以参考[technet.microsoft.com/en-us/library/bb978526.aspx](http://technet.microsoft.com/en-us/library/bb978526.aspx)使用PowerShell获得更丰富的命令行环境，或者如果您无法访问PowerShell，则可以使用`cmd.exe`，网址为[docs.python.org/2/using/windows.html](http://docs.python.org/2/using/windows.html)。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Python itself ships with a large collection of utilities in its standard library.
    With Python out of the box, you can immediately use any of the code listed at
    [docs.python.org/2/library/](http://docs.python.org/2/library/). The Python interpreter
    has several functions and objects which are always available, and several more
    which become available with an import statement as shown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python本身附带了一个大量的实用程序集合。使用Python即可立即使用[docs.python.org/2/library/](http://docs.python.org/2/library/)中列出的任何代码。Python解释器具有几个始终可用的函数和对象，以及几个通过导入语句显示的其他函数和对象，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Python community adds even more modules to import through collaborations
    on frameworks (including Flask) and toolkits published to the Python Package Index,
    PyPI (pronounced "pie p.i."), at [pypi.python.org](http://pypi.python.org). Packaging
    gets complicated, and pip and virtualenv aim to make a manageable workflow around
    use of third-party packages on PyPI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区通过在Python软件包索引PyPI（发音为"pie p.i."）上发布的框架（包括Flask）和工具包的合作，添加了更多要导入的模块，网址为[pypi.python.org](http://pypi.python.org)。打包变得复杂，pip和virtualenv旨在使在PyPI上使用第三方软件包的工作流程变得可管理。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There''s a lot more that can be achieved as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可以实现的内容：
- en: Checklist for the development environment
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发环境清单
- en: 'Here are the items you need to develop a web application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发Web应用程序所需的项目：
- en: A text editor for adding and editing source code. I use emacs and vim, which
    have highly productive keyboard shortcuts, and Sublime Text is a popular choice.
    There are many options; just be sure the editor is designed for code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于添加和编辑源代码的文本编辑器。我使用emacs和vim，它们具有高效的键盘快捷键，Sublime Text是一个受欢迎的选择。有许多选择；只需确保编辑器是为代码设计的。
- en: Python with a virtualenv tool, using the instructions in this chapter.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本章中的说明，带有虚拟环境工具的Python。
- en: A terminal console to run your Flask code, one for each Flask application you
    run, as discussed in the next section.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个终端控制台用于运行您的Flask代码，每个运行的Flask应用程序一个，如下一节所述。
- en: A terminal console to run Python's interactive interpreter. Here you can poke
    at APIs, experiment with code, verify unit functionality, and use Python's built-in
    `help(arg)` function to get online documentation.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个终端控制台用于运行Python的交互式解释器。在这里，您可以查看API，尝试代码，验证单元功能，并使用Python内置的`help(arg)`函数获取在线文档。
- en: A modern web browser. Firefox and Chrome have readily accessible JavaScript
    consoles and document inspectors for web pages. The JavaScript console and document
    inspector are essential for web user interface development.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代的Web浏览器。Firefox和Chrome具有方便访问的JavaScript控制台和网页文档检查器。JavaScript控制台和文档检查器对于Web用户界面开发至关重要。
- en: 'Flask docs available at: [flask.pocoo.org/docs/](http://flask.pocoo.org/docs/).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask文档可在[flask.pocoo.org/docs/](http://flask.pocoo.org/docs/)上获得。
- en: 'Werkzeug docs available at: [werkzeug.pocoo.org/docs/](http://werkzeug.pocoo.org/docs/).
    Werkzeug is Flask''s underlying web service implementation.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Werkzeug文档可在[werkzeug.pocoo.org/docs/](http://werkzeug.pocoo.org/docs/)上获得。Werkzeug是Flask的底层Web服务实现。
- en: 'Jinja docs available at: [jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/).
    Jinja is Flask''s default template engine.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja文档可在[jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)上获得。Jinja是Flask的默认模板引擎。
- en: 'Python docs available at: [docs.python.org/2/](http://docs.python.org/2/).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文档可在[docs.python.org/2/](http://docs.python.org/2/)上获得。
- en: Version control system. Track changes to your project. I personally recommend
    git, available at [git-scm.com](http://git-scm.com).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统。跟踪对项目的更改。我个人推荐git，可在[git-scm.com](http://git-scm.com)上获得。
- en: An integrated development environment (IDE) can bundle these tools together
    in one application, and there are several available for Python. Personally, I
    find the best tool for each item in the checklist and put together my own environment
    as a collection of standalone tools and applications. I highly recommend having
    a stand-alone command-line available for code interaction, so that you can always
    get to the core of your code even if you have an IDE that you like.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）可以将这些工具捆绑在一个应用程序中，Python有几种可用的IDE。我个人发现清单中每一项的最佳工具，并将它们组合成一个独立工具和应用程序的集合作为我的环境。我强烈建议拥有一个独立的命令行，以便进行代码交互，这样即使您喜欢的IDE，也可以随时访问代码的核心。
- en: (I find myself to be more productive doing everything on the command-line and
    in the terminal, but that's a matter of personal preference. Be sure to love your
    development environment, so that you can think clearly about your work.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: （我发现自己在命令行和终端上做任何事情都更有效率，但这是个人偏好的问题。一定要喜欢您的开发环境，这样您才能清晰地思考您的工作。）
- en: Common errors and how to solve them
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见错误及其解决方法
- en: 'Two common errors you will see in using a Python virtualenv are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python虚拟环境时，您会遇到两个常见错误：
- en: The `python` command is not found when you attempt to run Python
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试运行Python时找不到`python`命令
- en: '"No module named flask" when you attempt to import Flask in your code'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的代码中尝试导入Flask时出现“没有名为flask的模块”
- en: Both issues are caused by an incorrect environment variable named **PATH** in
    your command-line session, which is an ordered list of directories your system
    should search when loading a command. If `python` is not found, your PATH was
    not updated when you installed Python and you should revisit the Python installer.
    If `flask` is not found, you have either not activated your virtualenv or you
    have not installed Flask, and you should revisit the install instructions here.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都是由于命令行会话中的一个名为**PATH**的环境变量设置不正确引起的，它是一个有序的目录列表，系统在加载命令时应该搜索这些目录。如果找不到`python`，则在安装Python时未更新PATH，应该重新安装Python。如果找不到`flask`，则要么没有激活虚拟环境，要么没有安装Flask，应该重新查看安装说明。
- en: Running a simple application (Simple)
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个简单的应用程序（简单）
- en: Let's get started by running a simplest Flask application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始运行一个最简单的Flask应用程序。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have activated your virtualenv tool as described in the previous
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已激活虚拟环境工具，如前一节所述。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Put this code into a file named `hello.py`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码放入名为`hello.py`的文件中：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run this application from the console:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台运行此应用程序：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If this runs correctly, you will see:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个运行正确，您将看到：
- en: '*** Running on http://127.0.0.1:5000/**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*** 在 http://127.0.0.1:5000/ 上运行**'
- en: This is a URL, which you can visit in your browser. When you do, your browser
    will display a plain page which says "**Hello, world!**" (without quotes). Note
    that the address `127.0.0.1` refers to localhost, such that Flask will only respond
    to requests from the host running the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个URL，您可以在浏览器中访问。当您这样做时，您的浏览器将显示一个简单的页面，上面写着“**Hello, world!**”（不带引号）。请注意，地址`127.0.0.1`指的是本地主机，因此Flask只会响应来自运行代码的主机的请求。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Line-by-line, here is what this code does:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行来看，这段代码做了什么：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates a Python object `app,` which is a **WSGI** application. WSGI stands
    for **Web Service Gateway Interface**, and is the Python community's standard
    interface for hosting web projects. Any WSGI resource or tool that you find, you
    can apply to this `app` object, including WSGI middleware (if you do, wrap `app.wsgi_app`)
    and HTTP servers such as gunicorn or Apache `httpd` with `mod_wsgi`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`app`的Python对象，它是一个**WSGI**应用程序。WSGI代表**Web Service Gateway Interface**，是Python社区托管Web项目的标准接口。您找到的任何WSGI资源或工具，都可以应用到这个`app`对象上，包括WSGI中间件（如果这样做，请包装`app.wsgi_app`）和HTTP服务器，如gunicorn或带有`mod_wsgi`的Apache
    `httpd`。
- en: 'The argument given to the `Flask` class tells Flask how to find resources associated
    with your application: static files and templates. Passing `__name__` tells Flask
    to look at the current Python module—the `.py` file containing this code. Most
    of your applications will use `__name__`; the Flask docs describe this parameter
    in detail if you ever suspect `__name__` is not fulfilling your needs.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Flask`类的参数告诉Flask如何找到与您的应用关联的资源：静态文件和模板。传递`__name__`告诉Flask查看当前的Python模块——包含此代码的`.py`文件。大多数应用程序将使用`__name__`；如果您怀疑`__name__`未满足您的需求，Flask文档会详细描述此参数。
- en: 'The next block sets up a function to handle web requests to the `''/''` URL:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块设置一个处理对“/'”URL的Web请求的函数：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Every time Flask gets a request to the `'/'` URL, it will call the `hello` function.
    The Python web community calls these routed functions **view** functions. In general,
    view functions in Flask return strings for web responses, and here we provide
    a simple "Hello, world!" response for all the requests, to prove that things are
    working.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Flask收到对“/'”URL的请求时，它将调用`hello`函数。Python网络社区将这些路由函数称为**视图**函数。一般来说，Flask中的视图函数返回字符串以进行Web响应，这里我们为所有请求提供一个简单的“Hello,
    world!”响应，以证明事情正在运行。
- en: 'The final block tells Python to run a development web server, but to only do
    so if the current `.py` file is being called directly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个代码块告诉Python运行一个开发Web服务器，但只有在当前的`.py`文件被直接调用时才这样做：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That is, this code block will run if you run the command `python hello.py` but
    not if you use `import hello` from another Python module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，这段代码块将在运行命令`python hello.py`时运行，但如果您从另一个Python模块中使用`import hello`，则不会运行。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once you are satisfied with the Hello World application, let's structure our
    project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对Hello World应用程序满意，让我们构建我们的项目结构。
- en: Project layout
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目布局
- en: We will be building a simple scheduling application to manage appointments and
    display them. Let's move our one-file application into a directory setup for a
    larger application. Create the following file layout in your project, with a `sched`
    directory which contains subdirectories `static` and `templates`, both currently
    empty.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个简单的调度应用程序来管理约会并显示它们。让我们将我们的单文件应用程序移动到一个为更大的应用程序设置的目录中。在您的项目中创建以下文件布局，其中包含一个`sched`目录，其中包含当前为空的子目录`static`和`templates`。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Move `hello.py` to `app.py` inside the `sched` directory. The `__init__.py`
    file is an empty file telling Python that `sched` is a package containing Python
    files. The `config.py`, `filters.py`, `forms.py`, and `models.py` files are currently
    empty files which we will fill in the upcoming sections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将`hello.py`移动到`sched`目录中的`app.py`。`__init__.py`文件是一个空文件，告诉Python`sched`是一个包含Python文件的包。`config.py`、`filters.py`、`forms.py`和`models.py`文件目前是空文件，我们将在接下来的部分中填写它们。
- en: Development server
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发服务器
- en: 'If you need to access your Flask application from another machine on the network,
    use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从网络上的另一台机器访问Flask应用程序，请使用：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The default port for Flask's development server is `5000`, and we will use `localhost`
    on port `5000` throughout this book. If this is already in use, or you would like
    to use a different port, you can set it via the second argument to the `run` method,
    as follows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Flask开发服务器的默认端口是`5000`，在本书中我们将在端口`5000`上使用`localhost`。如果此端口已被占用，或者您想使用不同的端口，可以通过`run`方法的第二个参数进行设置。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The development server given by `app.run` is for development only. When you
    are ready to publish your application, use an industrial strength web server as
    discussed in the later section on deploying and logging. Because we are using
    `app.run` for development only, let''s turn on the debug mode, which will provide
    an interactive debugger in the web browser when uncaught exceptions occur and
    will reload code on changes to existing Python files in your project. You should
    only use `''0.0.0.0''` and/or debug mode on a trusted network. Add `debug=True`
    to the run line, keeping any other arguments you already added:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.run`提供的开发服务器仅用于开发。当您准备发布应用程序时，请使用工业强度的Web服务器，如后面关于部署和日志记录的部分所讨论的。因为我们仅在开发中使用`app.run`，让我们打开调试模式，当未捕获的异常发生时，它将在Web浏览器中提供交互式调试器，并且将在项目中现有的Python文件更改时重新加载代码。您应该只在受信任的网络上使用`''0.0.0.0''`和/或调试模式。在运行行中添加`debug=True`，保留您已经添加的任何其他参数：'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Command-line interface with Flask-Script
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Flask-Script的命令行界面
- en: 'We will use `manage.py` to manage our application using **Flask-Script**, with
    these contents:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Flask-Script**的`manage.py`来管理我们的应用程序，内容如下：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `requirements.txt` file is a conventional way to track all third-party Python
    packages. Set the file with the following listing, which is one package name per
    line. Run `pip install -r requirements.txt` with your virtualenv active and a
    working internet connection to install these dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件是跟踪所有第三方Python包的常规方式。使用以下列表设置文件，每行一个包名。在您的虚拟环境处于活动状态并且有工作的互联网连接时，运行`pip
    install -r requirements.txt`以安装这些依赖项。'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you can run your application with `python manage.py runserver`. Run `python
    manage.py -h` to get help and `python manage.py runserver -h` to get help on the
    development server options. Use `python manage.py shell` to get an interactive
    Python interpreter with the Flask application loaded, which you can use to inspect
    your code and try new things interactively. By default, Flask-Script gives you
    the `runserver` and `shell` commands; you can add custom `manage.py` subcommands;
    refer to the Flask-Script docs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`python manage.py runserver`运行应用程序。运行`python manage.py -h`以获取帮助，运行`python
    manage.py runserver -h`以获取有关开发服务器选项的帮助。使用`python manage.py shell`获取加载了Flask应用程序的交互式Python解释器，您可以使用它来检查代码并尝试新的交互式功能。默认情况下，Flask-Script为您提供`runserver`和`shell`命令；您可以添加自定义的`manage.py`子命令；请参阅Flask-Script文档。
- en: 'As we discussed, you can make the development server accessible from another
    machine on the network and change the port; here is the command pattern:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，您可以使开发服务器从网络上的另一台机器访问，并更改端口；以下是命令模式：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Flask-Script added Python 3 support earlier this month. This book now fully
    supports Python 2 and Python 3.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Script在本月早些时候添加了Python 3支持。本书现在完全支持Python 2和Python 3。
- en: Routing URLs and accepting requests (Simple)
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由URL并接受请求（简单）
- en: This section will connect URLs to Python functions in our web service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将在我们的Web服务中将URL连接到Python函数。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use the project layout listed under the *Project Layout* section in the *Running
    a Simple Application* recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“运行简单应用程序”食谱中列出的*项目布局*部分下的项目布局。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The Flask `app` object includes a `route` decorator to specify URL rules to
    use for a view function conveniently, which provides a declarative style for routing
    requests to Python callables. The following code routes five URL handling functions
    for the list, detail, creation, updating, and deletion of appointment records
    in our scheduling application. For now, we simply return a string describing what
    the handler is going to do, which we''ll implement later, so that you can see
    the URL routing in action from your browser. Place into `app.py`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask `app`对象包括一个`route`装饰器，用于方便地指定用于视图函数的URL规则，为Python可调用的请求提供了一种声明式样式的路由。以下代码为我们的调度应用程序中的约会记录的列表、详细信息、创建、更新和删除路由了五个URL处理函数。目前，我们只是返回一个描述处理程序将要执行的字符串，稍后我们将实现它，这样您就可以从浏览器中看到URL路由的操作。放入`app.py`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: 'Using `python manage.py runserver`, you can visit these URLs at:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python manage.py runserver`，您可以访问以下URL：
- en: '`http://localhost:5000/appointments/`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/appointments/`'
- en: '`http://localhost:5000/appointments/1/`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/appointments/1/`'
- en: '`http://localhost:5000/appointments/1/edit/`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/appointments/1/edit/`'
- en: '`http://localhost:5000/appointments/create/`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/appointments/create/`'
- en: '`http://localhost:5000/appointments/1/delete/`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/appointments/1/delete/`'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you test these URLs in your browser, you will find that the delete URL responds
    with a **405 Method Not Allowed** error. This is intentional, because the browser
    sends a `GET` reuest by default and we are only allowing `DELETE` methods. We
    do not want to delete a record on a `GET` request, but only when our delete button
    is pressed (built in a later section).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中测试这些URL，您会发现删除URL会响应**405 Method Not Allowed**错误。这是有意为之的，因为浏览器默认发送`GET`请求，我们只允许`DELETE`方法。我们不希望在`GET`请求上删除记录，而是只有在按下删除按钮时才删除记录（在后面的部分中构建）。
- en: 'You can build URLs to your view functions using the `flask.url_for` function,
    which returns a string representation of the URL. This lets you program using
    clean identifiers in case URLs change, using the names of the target function
    and its arguments:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`flask.url_for`函数构建到视图函数的URL，它返回URL的字符串表示。这样可以使用干净的标识符进行编程，以防URL发生变化，使用目标函数的名称和其参数：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first argument to `url_for` is called the endpoint, which by default is
    the name of the Python function wrapped by the `app.route` decorator. You can
    override the default using the `endpoint` keyword argument to `app.route`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`url_for`的第一个参数称为端点，默认情况下是由`app.route`装饰器包装的Python函数的名称。您可以使用`app.route`的`endpoint`关键字参数来覆盖默认值：'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main argument to `app.route` is the string URL rule as implemented by **Werkzeug**,
    Flask''s underlying toolkit for all things WSGI. Items listed in angle brackets
    `<argument>` are parsed as named arguments to pass into the view function. Flask
    uses a convention of `<converter:argument>` in the URL rule to parse the argument
    value before passing it to your view function, and only routing the URL if a value
    is correctly parsed. By default, Flask treats the argument as a string. The additional
    built-in converters are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.route`的主要参数是字符串URL规则，由Flask的底层工具包**Werkzeug**实现。在尖括号`<argument>`中列出的项目被解析为命名参数，传递到视图函数中。Flask在URL规则中使用`<converter:argument>`的约定来解析参数值，然后将其传递给视图函数，并仅在正确解析值时路由URL。默认情况下，Flask将参数视为字符串。其他内置转换器包括：'
- en: '`int`: The value of this converter is an integer'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：此转换器的值是整数'
- en: '`float`: The value of this converter is a floating point number'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：此转换器的值是浮点数'
- en: '`path`: The value of this converter is a string such as the default, but also
    accepts slashes'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：此转换器的值是字符串，如默认值，但也接受斜杠'
- en: You can define your own converters as shown in Flask's `app.url_map` documentation,
    but you may not need to, such that your view function can inspect the string argument
    and parse what it needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像Flask的`app.url_map`文档中所示那样定义自己的转换器，但您可能不需要这样做，这样您的视图函数可以检查字符串参数并解析所需的内容。
- en: By default, if a URL rule ends in a trailing slash `/`, Flask will redirect
    requests without the trailing slash to the handler which includes it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果URL规则以斜杠`/`结尾，Flask将重定向不带斜杠的请求到包含它的处理程序。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once you are up and routing, there are a few things you should know about HTTP
    and Flask routes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始路由，您应该了解有关HTTP和Flask路由的一些事项。
- en: Handling HTTP methods
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理HTTP方法
- en: 'The most common keyword argument to `app.route` is `methods`, giving Flask
    a list of HTTP methods to accept when routing, which when absent defaults to `GET`.
    Valid values are `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, and `OPTIONS`. RFC2068
    is a standards document which defines these methods. Briefly, they are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.route`的最常见关键字参数是`methods`，它给Flask一个接受的HTTP方法列表，当路由时默认为`GET`。有效值为`GET`、`POST`、`PUT`、`DELETE`、`HEAD`和`OPTIONS`。RFC2068是一个定义这些方法的标准文档。简而言之，它们是：'
- en: '`GET`: This option is used to reply with information on resource, most common'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此选项用于回复有关资源的信息，最常见'
- en: '`POST`: This option is used to receive from browser/client updated information
    for resource'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此选项用于从浏览器/客户端接收资源的更新信息'
- en: '`PUT`: This option is like `POST`, but repeat `PUT` calls on a resource should
    have no effect'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：此选项类似于`POST`，但对资源进行重复的`PUT`调用不应产生影响'
- en: '`DELETE`: Using this option removes the resource'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：使用此选项删除资源'
- en: '`HEAD`: This option is like `GET`, but replies only with HTTP headers and not
    content'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：此选项类似于`GET`，但仅回复HTTP标头而不是内容'
- en: '`OPTIONS`: This option is used to determine which methods are available for
    resource'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：此选项用于确定资源可用的方法'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flask implements `HEAD` for you if `GET` is present, and `OPTIONS` for you in
    all cases. Old implementations of HTTP browsers only supported `GET` and `POST`,
    but we will add a `DELETE` request by JavaScript in a later section. It is up
    to you and your project to use the other HTTP methods, particularly in cases where
    the semantics of the methods are important.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`GET`存在，Flask会为您实现`HEAD`，并在所有情况下为您实现`OPTIONS`。旧的HTTP浏览器实现只支持`GET`和`POST`，但我们将在后面的部分通过JavaScript添加`DELETE`请求。在某些情况下，使用其他HTTP方法取决于您和您的项目，特别是在方法的语义很重要的情况下。
- en: An alternative to decorating functions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰函数的替代方法
- en: The `@app.route` approach is a Python decorator, which you use at the time you
    define a function. As an alternative, you can use `app.add_url_rule,` which works
    exactly like `app.route` but is a simple method call and is not a decorator. You
    can provide `app.add_url_rule` with any Python callable, accepting the parameters
    in the URL rule, which will become `request.view_args` at the time of the request.
    If you have your own ideas on how to specify the URL routes of your application,
    you can use whatever tools you like with `app.add_url_rule` as a utility to wire
    up your Flask application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`@app.route`方法是Python装饰器，在定义函数时使用。作为替代，您可以使用`app.add_url_rule`，它的工作方式与`app.route`完全相同，但是它是一个简单的方法调用，而不是一个装饰器。您可以向`app.add_url_rule`提供任何Python可调用对象，接受URL规则中的参数，在请求时将成为`request.view_args`。如果您对如何指定应用程序的URL路由有自己的想法，您可以使用`app.add_url_rule`与您喜欢的任何工具来连接您的Flask应用程序。'
- en: Route collisions
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由冲突
- en: When Flask routes your requests to unexpected places, look for collisions in
    your `app.route` calls. That is, if you have routes `/<path:foopath>` and `/foo/bar/baz/`,
    both will match on `/foo/bar/baz/`. The solution is to be as specific as possible
    in your route parameters, and avoid overly generic parameters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当Flask将您的请求路由到意外的位置时，请查找`app.route`调用中的冲突。也就是说，如果您有路由`/<path:foopath>`和`/foo/bar/baz/`，两者都将匹配`/foo/bar/baz/`。解决方案是在路由参数中尽可能具体，并避免过于通用的参数。
- en: Routing with subdomains
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子域路由
- en: 'You can route subdomains using the `subdomain` keyword argument to `app.route`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`app.route`的`subdomain`关键字参数路由子域：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This subdomain argument uses the same parameter approach as other URLs, but
    note that proper subdomains are limited in what they can accept. Simple names
    are straightforward, but if you have specific requirements, see RFC2181 for name
    syntax and note that some HTTP clients do not support the full spec in subdomains.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子域参数使用与其他URL相同的参数方法，但请注意适当的子域在接受的内容方面是有限制的。简单名称很直接，但如果您有特定要求，请参阅RFC2181以获取名称语法，并注意一些HTTP客户端不支持子域中的完整规范。
- en: When you use subdomains, Flask needs to know the server name in order to parse
    the subdomain from the URL. Provide `SERVER_NAME` to `app.config`, as described
    in the section on configuration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用子域时，Flask需要知道服务器名称以便从URL中解析子域。提供`SERVER_NAME`给`app.config`，如配置部分所述。
- en: 'You will also run into limitations while developing locally on your machine,
    because `localhost` does not accept subdomains. You can set your operating system''s
    hosts file (typically `/etc/hosts`). If your `SERVER_NAME` is `example.com` and
    your subdomain argument is `foo`, you can set:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发时，您也会遇到限制，因为`localhost`不接受子域。您可以设置操作系统的hosts文件（通常为`/etc/hosts`）。如果您的`SERVER_NAME`是`example.com`，并且您的子域参数是`foo`，您可以设置：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `hosts` file does not accept wildcards. If you have access to a domain name
    service, an alternative to hosts file is to set an A record and all of its subdomains
    (wildcard) in DNS to `127.0.0.1`, like the following example. This will route
    all subdomains for `local.example.com` on all machines to the local host.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`hosts`文件不接受通配符。如果您可以访问域名服务，hosts文件的替代方法是在DNS中设置A记录及其所有子域（通配符）为`127.0.0.1`，就像以下示例一样。这将在所有机器上将`local.example.com`的所有子域路由到本地主机。'
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This technique requires a DNS network call, so if you are working offline, you'll
    need to fall back on the hosts file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术需要进行DNS网络调用，因此如果您离线工作，您需要退回到hosts文件。
- en: Handling requests and responses (Simple)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求和响应（简单）
- en: This section will demonstrate how Flask handles incoming data on HTTP requests
    and how you can send responses.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示Flask如何处理HTTP请求上的传入数据以及您如何发送响应。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set aside the scheduling application and open a new Python file to explore Flask.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将调度应用程序搁置一边，打开一个新的Python文件来探索Flask。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'At the core, Flask and Werkzeug provide request and response objects to represent
    incoming and outgoing data for your web application. Flask provides three different
    patterns for return values from your view functions:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在核心上，Flask和Werkzeug提供请求和响应对象来表示您的Web应用程序的传入和传出数据。Flask提供了三种不同的模式来返回视图函数的返回值：
- en: string, which can optionally use a template engine (introduced later)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串，可以选择使用模板引擎（稍后介绍）
- en: a response instance, an object with attributes representing HTTP response details
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应实例，一个具有表示HTTP响应细节的属性的对象
- en: tuple of `(string, status)` or `(string, status, http_headers)`, for convenience,
    such that you do not have to create a response instance
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组`(string, status)`或`(string, status, http_headers)`，以方便起见，这样您就不必创建响应实例
- en: Let's see each of the response patterns in action. Each response will say **Hello,
    world!** with a 200 OK status code (the typical HTTP response on success), and
    the latter two functions tell the browser to display the response as plain text.
    The first function's response displays as though it were HTML because a string-only
    return object has no means to tell Flask how to set the content-type of the response.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看每个响应模式的实际操作。每个响应都将以200 OK状态码（成功的典型HTTP响应）说**Hello, world!**，后两个函数告诉浏览器将响应显示为纯文本。第一个函数的响应显示为HTML，因为仅字符串返回对象无法告诉Flask如何设置响应的内容类型。
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As Flask prepares to call your view function and accepts its return value, it
    walks through each of the before-request and after-request callbacks you provide.
    Here, we set up a before-request function and an after-request function, purely
    for demonstration purposes to illustrate Flask's request and response handling.
    You can use these handlers to explore Flask behavior when you want to interact
    with what Flask docs are saying. When you run this code, keep in mind that browsers
    often automatically look for `/favicon.ico`, which can cause extra requests for
    your application when testing.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Flask准备调用您的视图函数并接受其返回值时，它会遍历您提供的每个在请求之前和请求之后的回调。在这里，我们设置了一个在请求之前的函数和一个在请求之后的函数，纯粹是为了演示Flask的请求和响应处理。您可以使用这些处理程序来探索Flask在您想要与Flask文档交互时的行为。当您运行此代码时，请记住，浏览器通常会自动寻找`/favicon.ico`，这可能会在测试时导致对您的应用程序的额外请求。
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here are commonly used features of the request object. See the Flask docs for
    the full list of incoming request data. To provide an example, each description
    includes an example value for a request hitting `/string/?foo=bar&foo=baz` from
    our browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是请求对象的常用特性。请参阅Flask文档以获取传入请求数据的完整列表。为了提供一个示例，每个描述都包括一个示例值，用于从我们的浏览器命中`/string/?foo=bar&foo=baz`的请求。
- en: '`endpoint`: This feature of the request object specifies the name of the request
    endpoint routed, for example, `return_string`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint`：请求对象的这个特性指定路由的请求端点的名称，例如`return_string`。'
- en: '`method`: This feature of the request object specifies the HTTP method of the
    current request, for example, `GET`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：请求对象的这个特性指定当前请求的HTTP方法，例如`GET`。'
- en: '`view_args`: This feature of the request object specifies the dict of view
    function arguments parsed from URL route rule, for example, `{}`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_args`：请求对象的这个特性指定从URL路由规则解析的视图函数参数字典，例如`{}`。'
- en: '`args`: This feature of the request object specifies the dict of arguments
    parsed from the URL query string, for example, `request.args[''foo'']` is `''bar''`
    and `request.args.getlist(''foo'')` is `[''bar'', ''baz'']`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：请求对象的这个特性指定从URL查询字符串解析的参数字典，例如`request.args[''foo'']`是`''bar''`，`request.args.getlist(''foo'')`是`[''bar'',
    ''baz'']`。'
- en: '`form`: This feature of the request object specifies the dict of form data
    from `POST` or `PUT` requests, for example, `{}`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form`：请求对象的这个特性指定来自`POST`或`PUT`请求的表单数据字典，例如`{}`。'
- en: '`user_agent`: This feature of the request object specifies the version identification
    provided by the browser.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_agent`：请求对象的这个特性指定了浏览器提供的版本标识。'
- en: '`files`: This feature of the request object specifies the dict of file uploads
    from `POST` or `PUT` requests, which go here instead of `request.form`, for example,
    `{}`. Each value in the dict is a `FileStorage` object which behaves like a Python
    `file` object, but also includes a `save(filepath)` method to store uploaded files
    (after you validate the destination path).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件`：请求对象的这个特性指定了来自`POST`或`PUT`请求的文件上传的字典，这些文件上传代替了`request.form`，例如，`{}`。字典中的每个值都是一个`FileStorage`对象，它的行为类似于Python的`file`对象，但也包括一个`save(filepath)`方法来存储上传的文件（在验证目标路径之后）。'
- en: '`is_xhr`: `True`: This feature of the request object specifies when the incoming
    request is a JavaScript `XMLHttpRequest`, and `False` otherwise. This works with
    JavaScript libraries that provide the `X-Requested-With` HTTP header, set to `XMLHttpRequest`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_xhr`：`True`：请求对象的这个特性指定了传入请求是否为JavaScript `XMLHttpRequest`，否则为`False`。这适用于提供`X-Requested-With`
    HTTP头的JavaScript库，设置为`XMLHttpRequest`。'
- en: Flask uses a custom `dict` type `ImmutableMultiDict` which supports multiple
    values per key (accessed by the `getlist` method), in cases where HTTP allows
    multiple values for a given argument, such as the query string in the URL, for
    example, `?foo=bar&foo=baz`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Flask使用自定义的`dict`类型`ImmutableMultiDict`，它支持每个键的多个值（通过`getlist`方法访问），在HTTP允许给定参数的多个值的情况下，例如URL中的查询字符串，例如，`?foo=bar&foo=baz`。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We used `app.before_request` and `app.after_request` in our demonstration code.
    Eventually, you will want objects to stick around in your code between the before-
    and after-request handlers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在演示代码中使用了`app.before_request`和`app.after_request`。最终，您将希望在请求之前和之后的处理程序之间保留对象。
- en: Before and after a request
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求之前和之后
- en: If you need to keep an object around between the before and after request hooks,
    you can set an attribute on the `flask.g` object. The `g` object only lives for
    the duration of the request, and you can set anything you want on the `g` object.
    This is for convenience, for the things that you need throughout the request,
    but do not yet have a home. Do not abuse the `g` object by giving it objects that
    belong elsewhere, such as a database system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在请求之前和之后的处理程序之间保留一个对象，可以在`flask.g`对象上设置一个属性。`g`对象只在请求的持续时间内存在，您可以在`g`对象上设置任何您想要的东西。这是为了方便起见，对于您在整个请求过程中需要的东西，但目前还没有归属地。不要滥用`g`对象，不要给它属于其他地方的对象，比如数据库系统。
- en: 'Here is the `g` object in action, where a random integer between 0 and 9 is
    set on `g.x` and logged before and after the request:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`g`对象的示例，其中在请求之前和之后设置了`g.x`上的0到9之间的随机整数，并在请求之前和之后记录：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Handling static files (Simple)
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理静态文件（简单）
- en: Flask is ready to serve files on your disk from the moment you serve your first
    request.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Flask准备好在您提供第一个请求时从磁盘上提供文件。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Go to your scheduler project and look at the `static` folder inside the `sched`
    directory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您的调度器项目，查看`sched`目录中的`static`文件夹。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Put the files inside the `static` folder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件放入`static`文件夹中。
- en: Build URLs for them using `flask.url_for('static', filename='path/to/filename')`
    where `path/to/filename` is the file path inside the static folder, using `/`
    regardless of the operating system you are using.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flask.url_for('static', filename='path/to/filename')`为它们构建URL，其中`path/to/filename`是静态文件夹中的文件路径，使用`/`，无论您使用的操作系统是什么。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By convention, Flask looks for a folder named `static` next to your application,
    and serves the files there at the `/static/<path:filename>` URL, matching all
    the files in your `static` folder and its subdirectories. That is, if your application
    is at `app.py`, then by default, Flask will look at the `static` folder next to
    `app.py`. Placing a file at `/static/img/favicon.ico` next to `app.py` becomes
    available at the URL `/static/img/favicon.ico`, which is `http://localhost:5000/static/img/favicon.ico`
    in the default development server. (This favicon is wired up in the next section
    on templating.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，Flask会在应用程序旁边查找名为`static`的文件夹，并在`/static/<path:filename>` URL处提供该文件夹中及其子文件夹中的所有文件。也就是说，如果您的应用程序在`app.py`中，则默认情况下，Flask会查看`app.py`旁边的`static`文件夹。将文件放置在`app.py`旁边的`/static/img/favicon.ico`处，可以在URL`/static/img/favicon.ico`处使用，默认开发服务器中的`http://localhost:5000/static/img/favicon.ico`。（这个favicon在下一节关于模板的部分中有详细说明。）
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can customize how Flask handles static files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自定义Flask处理静态文件的方式。
- en: Serving static files in production
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生产环境中提供静态文件
- en: When you deploy your application, you will likely want to serve static files
    from an industrial strength HTTP server such as nginx or Apache httpd, which are
    highly optimized for static files. You can configure these servers to serve the
    `/static/` URL from the same `/static/` folder in your project. If you do not
    have access to these servers, you can use Flask's static file handling in production
    if you need to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署应用程序时，您可能希望从诸如nginx或Apache httpd之类的工业强度HTTP服务器中提供静态文件，这些服务器对静态文件进行了高度优化。您可以配置这些服务器从项目中的相同`/static/`文件夹中提供`/static/`
    URL。如果您无法访问这些服务器，如果需要，您可以在生产中使用Flask的静态文件处理。
- en: Hosting static files elsewhere
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在其他地方托管静态文件
- en: If you are using static files served by another server at a URL other than `/static/`,
    you can add routes to your Flask application with the `build_only` option. This
    tells Flask how to build URLs with the `flask.url_for` function, without needing
    a `view` function or having Flask attempt to serve those files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用由另一个服务器提供的URL不是`/static/`的静态文件，您可以在Flask应用程序中添加`build_only`选项的路由。这告诉Flask如何使用`flask.url_for`函数构建URL，而无需`view`函数或让Flask尝试提供这些文件。
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom static file handler
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义静态文件处理程序
- en: 'You can build your own static file handler if you need to do any custom handling
    when serving files from the filesystem (for example, only serving a file to users
    who pay), for use in static files outside your static folder (for example, `/robots.txt`),
    or to override Flask''s built-in static view function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在从文件系统提供文件时进行任何自定义处理（例如，仅向付费用户提供文件），可以构建自己的静态文件处理程序，用于静态文件夹之外的静态文件（例如，`/robots.txt`），或者覆盖Flask的内置静态视图函数：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using a hard-coded directory and `send_from_directory` will mitigate directory
    traversal attacks, because the underlying implementation uses `flask.safe_join(directory,
    filename)` to sanitize the input, which you can use in your own code when handling
    filenames passed in as user input.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬编码的目录和`send_from_directory`将减轻目录遍历攻击，因为底层实现使用`flask.safe_join(directory,
    filename)`来清理输入，您可以在处理作为用户输入传递的文件名时在自己的代码中使用它。
- en: 'Use a custom static view function to do custom handling of static files, and
    not to change configuration of the `static` folder. If you just need to rename
    the `static` folder, use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义静态视图函数来自定义处理静态文件，并不是更改`static`文件夹的配置。如果只需要重命名`static`文件夹，请使用：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, Flask serves static files at `/static/` where `static` is the name
    of the folder provided in the `static_folder` argument, with default `static`.
    If you want a different URL path from the folder name, use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask在`/static/`处提供静态文件，其中`static`是在`static_folder`参数中提供的文件夹的名称，默认为`static`。如果要从文件夹名称使用不同的URL路径，请使用：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: HTTP caching
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP缓存
- en: 'By default, Flask sends an HTTP header with the static file telling the browser
    to cache the file for 43200 seconds, or 12 hours. You can configure this using
    the `SEND_FILE_MAX_AGE_DEFAULT` configuration variable. For example, if you want
    aggressive caching on all static files, you can set this value to 2592000 seconds,
    or 30 days:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask发送一个带有静态文件的HTTP头，告诉浏览器将文件缓存43200秒，即12小时。您可以使用`SEND_FILE_MAX_AGE_DEFAULT`配置变量进行配置。例如，如果您希望对所有静态文件进行积极缓存，可以将此值设置为2592000秒，即30天：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Be careful when increasing the HTTP cache length, because browsers will have
    stale files when you deploy changes. To work around that issue, change the static
    URL path on redeploy:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 增加HTTP缓存长度时要小心，因为在部署更改时浏览器会有过时的文件。为了解决这个问题，在重新部署时更改静态URL路径：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Directory index
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录索引
- en: Flask does not list the contents of the files in a static directory for user
    browsing; you have to link to the static files directly. If you need a directory
    index view, consider using an industrial strength static file web server such
    as nginx or Apache httpd.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Flask不会列出静态目录中的文件内容供用户浏览；您必须直接链接到静态文件。如果需要目录索引视图，请考虑使用像nginx或Apache httpd这样的工业级静态文件Web服务器。
- en: Using a database (Simple)
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库（简单）
- en: Our scheduler application needs data, and we want to store that data properly
    so that we can stop and start our application without losing our appointments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的调度程序应用程序需要数据，我们希望正确存储这些数据，以便我们可以在不丢失约会的情况下停止和启动我们的应用程序。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are working from the `models.py` file inside the `sched` directory of our
    project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从项目的`sched`目录中的`models.py`文件中进行工作。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '**SQLAlchemy** provides a Python toolkit and object-relational manager for
    relational databases which use SQL. SQLAlchemy stands on its own, regardless of
    what web framework you use, and we can integrate it into Flask with Flask-SQLAlchemy,
    which will manage database connections with the Flask request lifecycle.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy提供了一个Python工具包和对象关系管理器，用于使用SQL的关系数据库。SQLAlchemy独立存在，不管你使用什么web框架，我们可以将其集成到Flask中，使用Flask-SQLAlchemy来管理Flask请求生命周期中的数据库连接。
- en: 'Update `requirements.txt`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`requirements.txt`：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's model our appointment data structure using SQLAlchemy's declarative extension,
    which allows us to write Python classes to represent database tables. Note that
    Flask-SQLAlchemy includes some declarative functionality, but our application
    uses pure SQLAlchemy to make the code portable to any Python project and to let
    you reference the core SQLAlchemy docs, [docs.sqlalchemy.org](http://docs.sqlalchemy.org).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用SQLAlchemy的声明性扩展来建模我们的约会数据结构，这允许我们编写Python类来表示数据库表。请注意，Flask-SQLAlchemy包括一些声明性功能，但我们的应用程序使用纯SQLAlchemy来使代码可移植到任何Python项目，并让您引用核心SQLAlchemy文档，[docs.sqlalchemy.org](http://docs.sqlalchemy.org)。
- en: 'We are modeling an `Appointment` class which maps objects to an `appointment`
    table. Start with a `Base` class and define an `Appointment` subclass. SQLAlchemy
    will find all subclasses of `Base` when working with the underlying database system.
    We then define columns on the `Appointment` class which will map attributes on
    every `Appointment` object that we use in our code, storing and retrieving values
    as columns in the `appointment` table in our database. In `models.py`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在建模一个`Appointment`类，它将对象映射到`appointment`表。从一个`Base`类开始，定义一个`Appointment`子类。当与底层数据库系统一起使用时，SQLAlchemy将找到`Base`的所有子类。然后在`Appointment`类上定义列，这些列将映射到我们在代码中使用的每个`Appointment`对象的属性，将值存储和检索为数据库中`appointment`表中的列。在`models.py`中：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To load our domain model in our application, we configure our database on our
    Flask app and setup a `db` object to get ready for queries in our request handlers,
    in `app.py`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中加载领域模型，我们在我们的Flask应用程序上配置我们的数据库，并设置一个`db`对象，以准备在我们的请求处理程序中进行查询，在`app.py`中：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can add a couple of helpers as methods on the `Appointment` class. A `duration`
    property provides a calculation of the length of the appointment, in seconds,
    using the start and end times of the `appointment` object. The `__repr__` method
    tells Python how to represent the `appointment` object when printing it. This
    implementation will say `<Appointment: 1>` instead of Python''s default form of
    `<__main__.Appointment object at 0x26cf2d0>`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将一些辅助方法添加为`Appointment`类的方法。`duration`属性提供了约会的长度的计算，以秒为单位，使用`appointment`对象的开始和结束时间。`__repr__`方法告诉Python如何在打印时表示`appointment`对象。这个实现将说`<Appointment:
    1>`而不是Python的默认形式`<__main__.Appointment object at 0x26cf2d0>`。'
- en: 'Back in `models.py`, in the `Appointment` class declaration, add:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`中，在`Appointment`类声明中，添加：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each `Column` takes a type, which gives structure to the `appointment` record.
    We give keyword arguments to `Column` to define behavior as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Column`都采用一个类型，为`appointment`记录提供结构。我们给`Column`关键字参数定义行为如下：
- en: '`primary_key`: `True` means that this field is the record identifier.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primary_key`：`True`表示该字段是记录标识符。'
- en: '`default`: When no data is given, use this value. This can be a function which
    returns a value, for example, set `created` to the output of `datetime.now()`
    to provide the date/time at the time the database record is created.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当没有提供数据时，使用此值。这可以是返回值的函数，例如，将`created`设置为`datetime.now()`的输出，以提供数据库记录创建时的日期/时间。'
- en: '`onupdate`: When a record is stored or updated, set its value to the return
    value of the given function, for example, set `modified` to the current date/time
    at the time the database record is updated.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onupdate`：当记录被存储或更新时，将其值设置为给定函数的返回值，例如，将`modified`设置为数据库记录更新时的当前日期/时间。'
- en: '`nullable`: When `False`, do not allow records to be stored which do not have
    a value set for this attribute, by raising an exception.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullable`：当为`False`时，不允许存储没有为此属性设置值的记录，通过引发异常。'
- en: The URL `sqlite:///sched.db` tells SQLAlchemy to use a SQLite database in the
    current working directory. Python ships with support for SQLite, which is an embedded
    relational database management system also available at, [sqlite.org](http://sqlite.org).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite:///sched.db` URL告诉SQLAlchemy在当前工作目录中使用SQLite数据库。Python内置支持SQLite，它是一种嵌入式关系数据库管理系统，也可以在[sqlite.org](http://sqlite.org)上找到。'
- en: There's more...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have only modeled our data and told Flask how to connect to a SQLite database.
    Let's try out some queries.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对数据进行了建模，并告诉Flask如何连接到SQLite数据库。让我们尝试一些查询。
- en: Querying with SQLAlchemy
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy进行查询
- en: 'With an Appointment model definition in place, we can run some queries from
    Python. We can make some sample queries before building out our application''s
    view functions. Add the following code to the main script of `models.py`, inside
    an `if __name__ == ''__main__''` block. Add any statements or `print` calls that
    you want, in order to see how SQLAlchemy works and watch it run with:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Appointment`模型定义，我们可以从Python运行一些查询。在构建应用程序的视图函数之前，我们可以进行一些示例查询。将以下代码添加到`models.py`的主脚本中，在`if
    __name__ == '__main__'`块内。添加任何语句或`print`调用，以便查看SQLAlchemy的工作原理并观察它的运行方式：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Where is the web request? This section works with SQLAlchemy directly, outside
    a request context, in order to illustrate how SQLAlchemy works. This bottom-up
    approach helps you understand your building blocks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Web请求在哪里？这一部分直接使用SQLAlchemy，而不是在请求上下文中，以便说明SQLAlchemy的工作原理。这种自下而上的方法有助于理解构建模块。
- en: We start with an engine, which connects to the database and executes queries.
    If you would rather not create a file on disk, you can use a temporary in-memory
    database. The `sqlite://` URL tells SQLAlchemy to connect to a SQLite database,
    and because the filepath is omitted, it should connect to a temporary database
    in memory. That is, the `sqlite://` URL would provide a database which only exists
    for the duration of Python's process execution, and will not persist across calls
    to Python.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个引擎开始，它连接到数据库并执行查询。如果您不想在磁盘上创建文件，可以使用临时内存数据库。`sqlite://` URL告诉SQLAlchemy连接到SQLite数据库，并且因为省略了文件路径，它应该连接到内存中的临时数据库。也就是说，`sqlite://`
    URL将提供一个仅在Python进程执行期间存在的数据库，并且不会在调用Python时持久存在。
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next we create a session and create the database tables. When the engine connects
    to the database and executes queries, the session represents an on-going conversation
    with the database and is the primary entry point for applications to use a relational
    database in SQLAlchemy.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们创建一个会话并创建数据库表。当引擎连接到数据库并执行查询时，会话表示与数据库的持续对话，并且是应用程序使用SQLAlchemy中的关系数据库的主要入口点。
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we add some sample data. We generate times for our fake appointments using
    the current time `now` plus or minus some `timedelta`, which accepts days and
    seconds.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一些示例数据。我们使用当前时间`now`加上或减去一些`timedelta`来生成我们虚假预约的时间，`timedelta`接受天数和秒数。
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To create, update, and delete an appointment record:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建、更新和删除预约记录：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here are some sample queries you can run to get an idea of how SQLAlchemy works.
    Each `appt` example is a Python object of type `Appointment`. Each `appts` example
    is a Python list of `Appointment` objects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例查询，您可以运行以了解SQLAlchemy的工作原理。每个`appt`示例都是`Appointment`类型的Python对象。每个`appts`示例都是`Appointment`对象的Python列表。
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: SQLAlchemy provides full SQL functionality. Be sure to refer to the SQLAlchemy
    docs when you are generating SQL queries from your Python code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy提供完整的SQL功能。确保在从Python代码生成SQL查询时参考SQLAlchemy文档。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'About the `session` object: you will be using `db.session` (on the `db` object
    we added to `app.py` in this section) instead of session directly. Flask-SQLAlchemy
    will make sure that `db.session` is instantiated correctly and that data accessed
    through the database `session` in one web request does not interfere with the
    `session` in other requests.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`session`对象：您将使用`db.session`（在本节中我们在`app.py`中添加的`db`对象）而不是直接使用会话。Flask-SQLAlchemy将确保正确实例化`db.session`，并且通过数据库会话访问的数据不会干扰其他请求中的`session`。
- en: Production database
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产数据库
- en: SQLite is great for development and can work in production, but when you deploy
    your code, you may want to use PostgreSQL or MySQL as your database management
    system. You can change the underlying database while keeping your models as they
    are by specifying a different database URL and installing the necessary package
    to bind to the database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite非常适合开发，并且可以在生产中使用，但是当您部署代码时，您可能希望使用PostgreSQL或MySQL作为您的数据库管理系统。您可以通过指定不同的数据库URL并安装必要的包来更改底层数据库，同时保持模型不变。
- en: 'For PostgreSQL:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL：
- en: 'URL pattern: `postgresql://user:pass@localhost:5432/database_name`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL模式：`postgresql://user:pass@localhost:5432/database_name`
- en: '`pip install psycopg2`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install psycopg2`'
- en: 'For MySQL:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL：
- en: 'URL pattern: `mysql://user:pass@localhost:3306/database_name`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL模式：`mysql://user:pass@localhost:3306/database_name`
- en: '`pip install mysql-python`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install mysql-python`'
- en: Remember to create tables when you connect to a clean database.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在连接到一个干净的数据库时创建表。
- en: SQLAlchemy knows how to translate data definitions to all major relational database
    management systems, and when you need to use specific database features, it has
    support for SQL dialects as documented at [docs.sqlalchemy.org/en/rel_0_8/dialects/](http://docs.sqlalchemy.org/en/rel_0_8/dialects/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy知道如何将数据定义转换为所有主要的关系数据库管理系统，当您需要使用特定的数据库功能时，它支持SQL方言，如[docs.sqlalchemy.org/en/rel_0_8/dialects/](http://docs.sqlalchemy.org/en/rel_0_8/dialects/)中所述。
- en: Naming conventions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: Our `Appointment` class uses an underlying table named `appointment`. I recommend
    singular table names with a primary key, always named `id`, but you can decide
    for yourself how to name your tables and columns.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Appointment`类使用名为`appointment`的基础表。我建议使用带有主键的单数表名，主键始终命名为`id`，但您可以自行决定如何命名您的表和列。
- en: Custom SQL
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义SQL
- en: At its core, SQLAlchemy is a Python toolkit to construct parameterized SQL expressions.
    At any point, if you need to write custom queries, you do not need to drop down
    to raw execute statement by passing strings—SQLAlchemy has the tools for you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，SQLAlchemy是一个用于构建参数化SQL表达式的Python工具包。在任何时候，如果您需要编写自定义查询，您不需要通过传递字符串来降级到原始执行语句—SQLAlchemy为您提供了工具。
- en: See the SQL Expression Language docs at [docs.sqlalchemy.org/en/rel_0_8/core/](http://docs.sqlalchemy.org/en/rel_0_8/core/).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[docs.sqlalchemy.org/en/rel_0_8/core/](http://docs.sqlalchemy.org/en/rel_0_8/core/)中的SQL表达语言文档。
- en: Document stores and non-relational databases
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档存储和非关系数据库
- en: If you prefer another database management system, perhaps one which is document-oriented
    instead of relational, use the tools available for connecting to that database
    from Python. As you can see, we have kept the domain model declarations isolated
    in one file and hooked them into the Flask application object with a few lines
    of code. Our application code throughout this book will use SQLAlchemy APIs to
    query data, but you can translate these calls to the database of your choice.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢另一个数据库管理系统，也许是文档导向而不是关系型的，那么可以使用Python连接到该数据库的可用工具。正如您所看到的，我们已经将域模型声明隔离在一个文件中，并用几行代码将其连接到Flask应用程序对象中。本书中的应用程序代码将使用SQLAlchemy
    API来查询数据，但您可以将这些调用转换为您选择的数据库。
- en: Handling forms and file uploads (Simple)
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单和文件上传（简单）
- en: Let's get data from the user. Before we begin, remember to NEVER trust user
    input because sooner or later someone (or someone's script) with malicious intent
    will try to break your application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用户那里获取数据。在开始之前，请记住绝对不要相信用户输入，因为迟早有人（或某人的脚本）会试图破坏您的应用程序。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are working from the `forms.py` file inside the `sched` directory of our
    project.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从项目的`sched`目录中的`forms.py`文件中工作。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now that we have a data model, we need to present a form to the user in order
    to fill our database and validate user input to make sure it matches our schema.
    You can validate incoming data using any tools you like. We will use **WTForms**
    in our scheduler.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了数据模型，我们需要向用户呈现一个表单，以便填写我们的数据库并验证用户输入，以确保它与我们的模式匹配。您可以使用任何您喜欢的工具来验证传入的数据。我们将在我们的调度程序中使用**WTForms**。
- en: 'Update `requirements.txt`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`requirements.txt`：
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: WTForms models forms with classes in a similar style to SQLAlchemy's declarative
    extension for modeling database tables. It takes the philosophy that forms should
    be modeled separately from the data, such that forms and data are separate concerns
    and often user forms (in the HTML user interface) do not line up exactly with
    the domain data (in the database modeled with SQLAlchemy). WTForms provides HTML
    form generation and validation of form data. In Flask, you will find submitted
    form data in `request.form` on the `POST` and `PUT` requests.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WTForms使用类似于SQLAlchemy的声明性扩展来模拟表单模型的形式。它的理念是表单应该与数据分开建模，这样表单和数据就是分开的关注点，通常用户表单（在HTML用户界面中）与使用SQLAlchemy建模的域数据并不完全匹配。WTForms提供HTML表单生成和表单数据验证。在Flask中，您将在`POST`和`PUT`请求的`request.form`中找到提交的表单数据。
- en: 'Here is our appointment''s form. Each attribute takes a label and a set of
    validators. The `Length(max=255)` validator ensures an input of maximum of 255
    characters, and the `required()` validator rejects an empty input. In `forms.py`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的预约表单。每个属性都有一个标签和一组验证器。`Length(max=255)`验证器确保最多输入255个字符，`required()`验证器拒绝空输入。在`forms.py`中：
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The purpose of `AppointmentForm` class is two-fold: render an input form in
    HTML and validate submitted data. This matches the SQLAlchemy-based `Appointment`
    class very closely. Where the `Appointment` model represents the domain and its
    persistence, this form class represents how to display a form in HTML and accept
    or reject the results.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppointmentForm`类的目的是双重的：在HTML中呈现输入表单并验证提交的数据。这与基于SQLAlchemy的`Appointment`类非常接近。`Appointment`模型代表了域及其持久性，而这个表单类代表了如何在HTML中显示表单并接受或拒绝结果。'
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here is an opportunity to see what our code does before adding it to our Flask
    application, in our bottom-up approach. This section explains how WTForms works
    through some example code. You can add this code to the bottom of `forms.py` inside
    an `if name == '__main__'` block, and watch it run with `python forms.py`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自下而上的方法中，这是一个在将代码添加到我们的Flask应用程序之前查看我们的代码的机会。本节通过一些示例代码解释了WTForms的工作原理。您可以将此代码添加到`forms.py`的底部的`if
    name == '__main__'`块中，并使用`python forms.py`运行它。
- en: 'Before we add the form to our application in a later section, let''s see the
    form in action on its own. We will print the values that WTForms creates so that
    we can understand what it is doing. If you are using Python 2, you will need to
    add a line to the top of your Python file in order to make your print expressions
    compatible between Python 2 and Python 3:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的部分中，我们将在应用程序中添加表单之前，让我们看看表单在自己身上的作用。我们将打印WTForms创建的值，以便我们可以理解它在做什么。如果您使用Python
    2，您需要在Python文件的顶部添加一行，以使您的打印表达式在Python 2和Python 3之间兼容。
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following code prints the HTML representation of the `title` field:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码打印了`title`字段的HTML表示：
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When displayed in the browser, this form field renders as a very plain input
    as shown in the following screenshot. We will style our forms in a later section
    on HTML templating.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中显示时，此表单字段将呈现为非常简单的输入，如下面的屏幕截图所示。我们将在HTML模板的后面部分为我们的表单添加样式。
- en: '![How it works...](img/9628OS_01_06.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/9628OS_01_06.jpg)'
- en: The following code shows how to interact with the form's validation directly.
    You can instantiate the `AppointmentForm` with a dictionary of form data. You
    can give Flask's `request.form` object to `AppointmentForm`, but here we will
    build our own dictionary to see how it works. Since HTML forms support multiple
    values for a single argument, we cannot use Python's built-in `dict`. Instead
    we use Werkzeug's `ImmutableMultiDict` type and make dummy data for a `title`
    field and omit all of the other fields.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何直接与表单验证进行交互。您可以使用表单数据的字典来实例化`AppointmentForm`。您可以将Flask的`request.form`对象传递给`AppointmentForm`，但在这里，我们将构建自己的字典来查看它是如何工作的。由于HTML表单支持单个参数的多个值，我们不能使用Python的内置`dict`。相反，我们使用Werkzeug的`ImmutableMultiDict`类型，并为`title`字段制作虚拟数据，并省略所有其他字段。
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that when `AppointmentForm` is given the dictionary form data, `form.validate()`
    will process it and return either `True` or `False` depending on whether the form
    data is valid (`True` means valid). Errors from validators are loaded on each
    of the fields in an `errors` list so that you can display errors in context, which
    we will do when rendering a template in a later section.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`AppointmentForm`获得字典表单数据时，`form.validate()`将处理它，并根据表单数据是否有效返回`True`或`False`（`True`表示有效）。验证器的错误将加载在`errors`列表中的每个字段上，以便您可以在上下文中显示错误，这是我们在后面的模板渲染中将要做的。
- en: There's more...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We handle file uploads a bit differently.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以稍有不同的方式处理文件上传。
- en: Handling file uploads
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: 'If you are handling file uploads, you need to interact with Flask directly.
    These snippets will get you started. First, the HTML form will include these basic
    elements: `enctype=multipart/form-data` attribute on the `form` element and file
    input in the form of `"<input type=file name=...>"`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理文件上传，您需要直接与Flask进行交互。以下代码将帮助您入门。首先，HTML表单将包括这些基本元素：`form`元素上的`enctype=multipart/form-data`属性和表单中的文件输入，格式为`"<input
    type=file name=...>"`。
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The code on the receiving end should look for a Werkzeug `FileStorage` object
    in the `request.files` dictionary by the name given on the file input element,
    and then sanitize the filename before saving the file to disk. Note that if you
    serve the file back with a Content-Type in the response which matches the filename's
    extension, you should only do so with file extensions you trust. Otherwise, an
    attacker could use your file-upload feature to embed JavaScript in your application,
    which will cause the user's browser to trust someone else's code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接收端的代码应该在`request.files`字典中查找Werkzeug的`FileStorage`对象，名称与文件输入元素上给定的名称相匹配，然后在保存文件到磁盘之前对文件名进行清理。请注意，如果您在响应中使用与文件名扩展名匹配的Content-Type，您应该只对您信任的文件扩展名这样做。否则，攻击者可以利用您的文件上传功能在您的应用程序中嵌入JavaScript，这将导致用户的浏览器信任其他人的代码。
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Templating with Jinja – setting a base template (Simple)
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja模板化-设置基本模板（简单）
- en: Flask ships with the Jinja templating engine to render any text format you need.
    Our scheduler will present HTML5 pages rendered by Jinja with a little style and
    a bit of JavaScript.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Flask附带了Jinja模板引擎，可以呈现您需要的任何文本格式。我们的调度程序将通过Jinja呈现HTML5页面，稍加样式和一点JavaScript。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will build templates using HTML, CSS, and JavaScript. You will need some
    familiarity with these to understand the responses we build in Flask. We will
    use Twitter's Bootstrap ([getbootstrap.com/2.3.2/](http://getbootstrap.com/2.3.2/))
    framework for CSS and the jQuery ([jquery.com](http://jquery.com)) library for
    JavaScript. Both include online documentation. Bootstrap also includes icons,
    which we can use in our application, provided by Glyphicons ([glyphicons.com](http://glyphicons.com)).
    We will use a free theme for Bootstrap from Bootswatch ([bootswatch.com](http://bootswatch.com)).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTML、CSS和JavaScript构建模板。您需要对这些内容有一定的了解，才能理解我们在Flask中构建的响应。我们将使用Twitter的Bootstrap
    ([getbootstrap.com/2.3.2/](http://getbootstrap.com/2.3.2/))框架进行CSS和jQuery ([jquery.com](http://jquery.com))库进行JavaScript。两者都包括在线文档。Bootstrap还包括图标，我们可以在我们的应用程序中使用，提供者是Glyphicons
    ([glyphicons.com](http://glyphicons.com))。我们将使用Bootswatch ([bootswatch.com](http://bootswatch.com))为Bootstrap提供免费主题。
- en: We are working from `base.html` inside the `templates` directory within the
    `sched` directory.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是在`sched`目录中的`templates`目录内的`base.html`中工作。
- en: Tip
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This text shows templating by example. In our bottom-up approach, we will start
    with a base page structure before building out our specific application pages.
    Jinja has documentation on all of its template features. Be sure to refer to the
    docs at [http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/) to check
    out what Jinja provides.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字通过示例展示了模板化。在我们的自下而上的方法中，我们将从基本页面结构开始，然后构建特定的应用程序页面。Jinja有关其所有模板功能的文档。请务必参考[http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)上的文档，了解Jinja提供了什么。
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will use public **content delivery networks** (**CDNs**) for Bootstrap and
    jQuery, which will speed up our start time in our project. NetDNA provides a public
    CDN for Bootstrap. The jQuery project provides a CDN through MediaTemple. Whenever
    you are ready or prefer to move away from a CDN, simply download the files you
    need and serve them with your application''s static files, updating the links
    in the base template. The CDN URLs are, for use in the base template (where `...
    thing ...` identifiers are):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用公共**内容传送网络**（**CDN**）来为Bootstrap和jQuery提供服务，这将加快我们项目的启动时间。NetDNA为Bootstrap提供了一个公共CDN。jQuery项目通过MediaTemple提供了一个CDN。每当你准备好或者更喜欢远离CDN时，只需下载你需要的文件，并将它们与应用的静态文件一起提供，更新基础模板中的链接。CDN的URL如下，用于基础模板（其中`...
    thing ...`标识符）：
- en: '[http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css](http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css](http://netdna.bootstrapcdn.com/bootswatch/2.3.2/united/bootstrap.min.css)'
- en: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-responsive.min.css)'
- en: '[http://code.jquery.com/jquery-1.9.1.min.js](http://code.jquery.com/jquery-1.9.1.min.js)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.jquery.com/jquery-1.9.1.min.js](http://code.jquery.com/jquery-1.9.1.min.js)'
- en: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js](http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js)'
- en: 'Jinja supports template inheritance, where template files can extend an existing
    template. We will use this feature to layout our base structure, using the `block`
    template tag to indicate sections which child templates will fill. We provide
    a block to set the page title, add any additional content to the page head (which
    is useful for additional style and scripting), and fill the main content of the
    page. Jinja uses template tags `{% ... %}` to indicate Jinja-specific markup and
    directives. Here is our base template, in `templates/base.html`, with screenshots
    in the coming sections:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja支持模板继承，其中模板文件可以扩展现有模板。我们将使用这个功能来布局我们的基本结构，使用`block`模板标签来指示子模板将填充的部分。我们提供了一个块来设置页面标题，向页面头部添加任何额外的内容（对于额外的样式和脚本很有用），并填充页面的主要内容。Jinja使用模板标签`{%
    ... %}`来指示Jinja特定的标记和指令。以下是我们的基础模板，在`templates/base.html`中，屏幕截图在接下来的部分中：
- en: '[PRE49]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This base template allows us to write focused pages which share a common structure
    and style. Any template you create in the templates directory can inherit the
    base:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础模板允许我们编写专注的页面，这些页面共享一个共同的结构和样式。你在模板目录中创建的任何模板都可以继承这个基础模板：
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Render it with the `flask.render_template` function. If the file is named `index.html`
    inside the templates directory, you can render that template into a string with:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flask.render_template`函数进行渲染。如果文件名为`index.html`，在模板目录中，你可以使用以下代码将该模板渲染为字符串：
- en: '[PRE51]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Ther's a lot more that can be done using Jinja templating
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja模板还有很多其他功能
- en: Using a template engine other than Jinja
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jinja以外的模板引擎
- en: You can choose any template engine you like. When you call `render_template`,
    you have a Python string, and Flask converts the string into a `Response` object.
    If you prefer a different approach to templating, build a string and return it
    from your view functions. Flask bundles Jinja to provide a default templating
    environment for quick start, and for the community to build Flask extensions which
    are guaranteed a common environment.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择任何你喜欢的模板引擎。当你调用`render_template`时，你会得到一个Python字符串，Flask会将该字符串转换为一个`Response`对象。如果你更喜欢不同的模板方法，可以构建一个字符串并从你的视图函数中返回它。Flask捆绑了Jinja，为快速启动提供了一个默认的模板环境，并为社区构建Flask扩展提供了一个共同的环境。
- en: Manage web packages with Bower
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bower管理Web包
- en: You can manage downloaded static files using Bower, a package manager for web
    tools, [bower.io](http://bower.io). With Bower, you would list dependencies using
    a `bower.json` file, use `bower install` to load these files, and then serve the
    files in your application's static area.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Bower来管理下载的静态文件，Bower是一个用于Web工具的包管理器，[bower.io](http://bower.io)。使用Bower，你可以使用`bower.json`文件列出依赖项，使用`bower
    install`加载这些文件，然后在应用的静态区域提供这些文件。
- en: Creating a new record (Intermediate)
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新记录（中级）
- en: 'Here we provide a web form to create a new appointment as shown in the following
    screenshot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们提供一个网页表单，用于创建新的预约，如下截图所示：
- en: '![Creating a new record (Intermediate)](img/9628OS_01_01.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![创建新记录（中级）](img/9628OS_01_01.jpg)'
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to work from the `app.py` file from `sched` and the `templates`
    directory.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`的`app.py`文件和`templates`目录中进行工作。
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We provide a `view` function to do both GET and POST handling for the form.
    Here, we pull together `db.session` from the database section and `AppointmentForm`
    from the forms section. In `app.py`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供了一个`view`函数来处理表单的GET和POST。在这里，我们从数据库部分提取了`db.session`，从表单部分提取了`AppointmentForm`。在`app.py`中：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before we build out the input fields, we can create a utility for ourselves
    which will display all of the WTForms features for a given field: label, input,
    and errors. Jinja has macros, which are similar to Python functions. We will create
    a macro to render an `edit` field from `AppointmentForm`.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建输入字段之前，我们可以为自己创建一个实用程序，它将显示给定字段的所有WTForms功能：标签、输入和错误。Jinja有宏，类似于Python函数。我们将创建一个宏来从`AppointmentForm`中呈现一个`edit`字段。
- en: 'For inputs, we can follow Bootstrap conventions with `control-group` and `controls`
    page elements, which will let us completely control the form flow from CSS. We
    want to start a new template with our macro, so that we can reuse it in other
    templates we create. In `templates/appointment/common.html`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于输入，我们可以遵循Bootstrap的约定，使用`control-group`和`controls`页面元素，这将让我们完全控制表单流程的CSS。我们想要用我们的宏开始一个新的模板，这样我们可以在我们创建的其他模板中重用它。在`templates/appointment/common.html`中：
- en: '[PRE53]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we can build a form using our new macro. Starting a new template, we can
    extend the base and import the macro. When extending the base, we provide blocks
    title and main, using the same syntax as the base template. You can set variables
    within a template, for use within that template, using `{% set ... %}`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以使用我们的新宏构建一个表单。开始一个新模板，我们可以扩展基础并导入宏。在扩展基础时，我们提供标题和主要块，使用与基础模板相同的语法。您可以在模板中设置变量，以便在模板内使用，使用`{%
    set ... %}`。 '
- en: 'In `templates/appointment/edit.html`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/appointment/edit.html`中：
- en: '[PRE54]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On GET, the form is rendered with an action to POST the data to the same URL.
    On POST, the view function validates the data and adds it to the database. If
    the validation fails, the POST renders the template again, but this time the form
    object has errors.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在GET时，表单将呈现为将数据POST到相同URL的操作。在POST时，视图函数验证数据并将其添加到数据库中。如果验证失败，POST将再次呈现模板，但这次表单对象有错误。
- en: Jinja uses template syntax `{{ ... }}` to print a Python object in context to
    the template's output. We use a simple `if` statement to add the error class if
    the field has errors, which will highlight the input when errors exist (thanks
    to Bootstrap style). We use a `for` loop to lay down a help span for each error
    on the field. The use of `**kwargs` will catch all arguments which are given beyond
    the macro's call signature; this lets us pass in all WTForm field options through
    the macro. The `kwargs` feature only works in Jinja macros when `catch_kwargs=true`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja使用模板语法`{{ ... }}`将Python对象打印到模板输出的上下文中。我们使用一个简单的`if`语句，如果字段有错误，则添加错误类，这将在存在错误时突出显示输入（感谢Bootstrap样式）。我们使用`for`循环为字段上的每个错误放置一个帮助span。`**kwargs`的使用将捕获超出宏调用签名的所有参数；这使我们能够通过宏传递所有WTForm字段选项。`kwargs`特性仅在Jinja宏中`catch_kwargs=true`时起作用。
- en: CSS classes `form-horizontal`, `span3`, and `span5` tell Bootstrap how to layout
    the form on its grid system. The `placeholder` attribute is a feature in HTML5
    to show a watermarkin the input when there is no content.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: CSS类`form-horizontal`、`span3`和`span5`告诉Bootstrap如何在其网格系统上布局表单。`placeholder`属性是HTML5中的一个特性，用于在输入没有内容时显示一个水印。
- en: Displaying a record (Intermediate)
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示记录（中级）
- en: 'With content going into the database, let''s get it back out as shown in the
    following figure:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 随着内容进入数据库，让我们按照下图所示将其取回：
- en: '![Displaying a record (Intermediate)](img/9628OS_01_03.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![显示记录（中级）](img/9628OS_01_03.jpg)'
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will continue to work from the `app.py` file from the `sched` folder and
    the `templates` directory.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`文件夹和`templates`目录的`app.py`文件中进行工作。
- en: How to do it...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We provide a simple query to get an appointment by database ID. In `app.py`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供一个简单的查询，通过数据库ID获取一个约会。在`app.py`中：
- en: '[PRE55]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s take the same macro approach to displaying an appointment. A template
    macro will give us a tool to display an appointment any time we need it. In `templates/appointment/common.html`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们采用相同的宏方法来显示一个约会。模板宏将为我们提供一个工具，以便在任何需要时显示一个约会。在`templates/appointment/common.html`中：
- en: '[PRE56]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can then use the macro in `templates/appointment/detail.html`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以在`templates/appointment/detail.html`中使用宏：
- en: '[PRE57]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: If a request comes in for a database ID that does not exist, we tell Flask to
    abort with a **404 Not Found** response. The `flask.abort` function is implemented
    as an exception, so Python will stop execution in the current function when `abort`
    is called.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的数据库ID不存在，我们告诉Flask中止并返回**404 Not Found**响应。`flask.abort`函数被实现为一个异常，因此当调用`abort`时，Python将停止当前函数的执行。
- en: We will also implement a few utilities for Jinja named filters, which formats
    the output of a Python object before it goes into the template's output, in the
    form of `{{ foo | filter }}`. We will build filters `date`, `datetime`, `duration`,
    and `nl2br.` On your first pass through in implementing these, simply omit these
    from your template; use `{{ appt.start }}` instead of `{{ appt.start | date }}`.
    This will give you a clearer idea of why we are building the filter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一些用于Jinja的实用程序，名为过滤器，它可以在Python对象进入模板输出之前格式化Python对象的输出，格式为`{{ foo | filter
    }}`。我们将构建`date`、`datetime`、`duration`和`nl2br`过滤器。在首次实现这些过滤器时，可以简单地从模板中省略它们；使用`{{
    appt.start }}`代替`{{ appt.start | date }}`。这将让您更清楚地了解我们为什么要构建这个过滤器。
- en: For individual fields which may not exist, we use Python's `or` behavior. When
    used for display or assignment, `or` expression is "shortcut" until a true value
    is hit, and that value is used. This approach lets us provide a default display
    value in a simple way.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能不存在的单个字段，我们使用Python的`or`行为。当用于显示或赋值时，`or`表达式是一种"快捷方式"，直到命中一个真值，并且使用该值。这种方法让我们以一种简单的方式提供默认的显示值。
- en: Editing a record (Intermediate)
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑记录（中级）
- en: 'Now we provide an edit page for existing appointments, as shown in the following
    screenshot:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们提供一个用于现有约会的编辑页面，如下截图所示：
- en: '![Editing a record (Intermediate)](img/9628OS_01_02.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![编辑记录（中级）](img/9628OS_01_02.jpg)'
- en: Getting ready
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will continue to work from the `app.py` file from the `sched` directory and
    `templates` directory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`目录和`templates`目录的`app.py`文件中进行工作。
- en: How to do it...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The edit workflow is a mix of add and detail views. We get an appointment,
    and if it exists, we display a form to edit it. In `app.py`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑工作流是添加和详细视图的混合。我们获取一个约会，如果它存在，我们显示一个表单来编辑它。在`app.py`中：
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `templates/appointment/edit.html`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/appointment/edit.html`中：
- en: '[PRE59]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We reuse the same template as the create form, but we say **Edit** instead of
    **Add**. Since this is very simple logic, we can use an `if` statement in the
    template. Flask lets us inspect the request object in the template. If you find
    your project does a lot of request inspection, you should consider a design pattern
    which moves this logic back into your Python code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用与创建表单相同的模板，但是我们使用**编辑**而不是**添加**。由于这是非常简单的逻辑，我们可以在模板中使用`if`语句。Flask允许我们在模板中检查请求对象。如果您发现您的项目需要大量的请求检查，您应该考虑一种设计模式，将这种逻辑移回到您的Python代码中。
- en: Listing all records (Simple)
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有记录（简单）
- en: 'We don''t want users to keep track of the database IDs of their appointments,
    so we provide a view, which will list all the appointments that they have, as
    shown in the following screenshot:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望用户跟踪他们约会的数据库ID，因此我们提供了一个视图，它将列出他们所有的约会，如下面的屏幕截图所示：
- en: '![Listing all records (Simple)](img/9628OS_01_04.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![列出所有记录（简单）](img/9628OS_01_04.jpg)'
- en: Getting ready
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to work from the `app.py` file from the `sched` directory and
    the `templates` directory.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`目录的`app.py`文件和`templates`目录中进行操作。
- en: How to do it...
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We query for all appointments, in `app.py`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`app.py`中查询所有约会：
- en: '[PRE60]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `templates/appointment/index.html`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/appointment/index.html`中：
- en: '[PRE61]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We query for all appointments in ascending order by appointment start time.
    SQLAlchemy declarative classes include helpers on column attributes that let us
    provide SQL clauses, here with `.asc()` to indicate the `sort` field. In the appointment
    list template, we iterate over all appointment records and reuse our display macro
    and switch off the features which only apply to the detail view, using the call
    signature we created.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按约会开始时间的升序查询所有约会。SQLAlchemy声明类包括在列属性上的助手，让我们提供SQL子句，这里使用`.asc()`来指示`sort`字段。在约会列表模板中，我们遍历所有约会记录，并重用我们的显示宏，并关闭仅适用于详细视图的功能，使用我们创建的调用签名。
- en: There's more...
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We kept the appointment list simple. If you are new to database identifiers,
    you may be wondering how the appointment URLs are generated.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持了约会列表的简单。如果你对数据库标识符不熟悉，你可能会想知道约会的URL是如何生成的。
- en: Database identifiers
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库标识符
- en: 'A note on those database IDs: they are system generated by our database management
    system and SQLAlchemy. That is, they are meaningless outside of our application.
    IDs make for good URLs, but not for human memory. This view is one where you can
    get creative and use the day, week, month, and year calendar metaphors. You can
    do that, but that will live mostly in HTML, CSS, and JavaScript. For our simple
    scheduler application, we just list out the appointments in a list.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些数据库ID的说明：它们是由我们的数据库管理系统和SQLAlchemy系统生成的，它们在我们的应用程序之外是没有意义的。ID对于URL很有用，但对于人类的记忆来说并不好。这个视图是一个可以让你发挥创意并使用日、周、月和年的日历隐喻的地方。你可以这样做，但这主要存在于HTML、CSS和JavaScript中。对于我们简单的调度程序应用程序，我们只是在列表中列出约会。
- en: Deleting a record (Advanced)
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除记录（高级）
- en: We are all set with our appointment interactions. Wait; how do we delete appointments?
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的约会交互。等等，我们如何删除约会？
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to work from `sched`'s `app.py` file and `templates` directory.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`的`app.py`文件和`templates`目录中进行操作。
- en: How to do it...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We build an Ajax handler, in `app.py`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中构建一个Ajax处理程序：
- en: '[PRE62]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A little jQuery will wire up all delete links to use this handler, in `templates/base.html`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一点jQuery将使所有删除链接使用这个处理程序，放在`templates/base.html`中：
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We provide our first view function which does not render HTML, but uses a minimal
    Ajax interacting with JSON. It accepts HTTP DELETE requests and does the work.
    We do not have to expose delete functionality through GET requests, which would
    let users accidentally delete database records by browsing. This is particularly
    important when we publish code which can be hit by search engines and other robots.
    Crawling all of our pages would delete our entire database! Flask provides a `jsonify`
    function to turn a Python dictionary into a JSON response.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了我们的第一个视图函数，它不会呈现HTML，而是使用最小的Ajax与JSON交互。它接受HTTP DELETE请求并执行工作。我们不必通过GET请求公开删除功能，这样用户就不会因为浏览而意外删除数据库记录。当我们发布的代码可能被搜索引擎和其他机器人访问时，这一点尤为重要。爬取我们所有的页面将删除我们整个数据库！Flask提供了一个`jsonify`函数，将Python字典转换为JSON响应。
- en: How do you get a browser to send a DELETE request? With JavaScript. The jQuery
    library makes Ajax calls a lot simpler than JavaScript alone. We add a jQuery
    hook which will take all delete links and submit an ajax call when they are clicked.
    The on-click callback grabs the deletion URL from the delete link, and sends it
    as a DELETE request. On success, it redirects the current browser window to the
    appointment list. By placing this script into the base template, it will make
    all delete links functional on the appointment list and detail pages.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让浏览器发送DELETE请求？用JavaScript。jQuery库使得Ajax调用比单独使用JavaScript更简单。我们添加一个jQuery钩子，它将获取所有删除链接并在点击时提交一个ajax调用。点击回调从删除链接获取删除URL，并将其作为DELETE请求发送。成功后，它将当前浏览器窗口重定向到约会列表。通过将此脚本放入基本模板中，它将使约会列表和详细页面上的所有删除链接都可用。
- en: There's more...
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We only cover Ajax briefly here; it deserves an entire book.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只简要介绍了Ajax；它值得一本整书。
- en: Ajax
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ajax
- en: Ajax simply means that we render a web page and have the browser communicate
    with our web service without necessarily having to reload the page. That is, render
    the page once, and update the content displayed on the page without refreshing
    the entire page. This was originally called AJAX for "asynchronous JavaScript
    and XML", but has become a common word among web developers and can mean any serialization
    format, here JSON instead of XML.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax简单地意味着我们呈现一个网页，并让浏览器与我们的网络服务通信，而不一定要重新加载页面。也就是说，呈现页面一次，然后更新页面上显示的内容，而不刷新整个页面。最初这被称为AJAX，意为“异步JavaScript和XML”，但已经成为Web开发人员之间的常用词，并且可以表示任何序列化格式，这里使用JSON而不是XML。
- en: Using custom template filters in Jinja (Advanced)
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jinja中使用自定义模板过滤器（高级）
- en: To wrap up our templates, we need to clean up the display of some of our fields.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的模板，我们需要清理一些字段的显示。
- en: Getting ready
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We move to the `filters.py` file from the `sched` directory and work with `app.py`
    again.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`sched`目录中的`filters.py`文件转到`app.py`并再次进行操作。
- en: How to do it...
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to display time with a clean format. In `filters.py`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望以清晰的格式显示时间。在`filters.py`中：
- en: '[PRE64]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Add more filters here, and provide a hook to initialize the Flask application.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里添加更多的过滤器，并提供一个钩子来初始化Flask应用程序。
- en: '[PRE65]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the initialization hook in `app.py`:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中使用初始化钩子：
- en: '[PRE66]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Jinja supports an environment where Python functions are provided in the template
    as filters. We have a `datetime` field on our appointment, so we provide some
    formatting for it. You can call attributes and methods directly within the template,
    `{{ dt.strftime('%Y-%m-%d') }}`, but defining a filter lets us specify how to
    format all dates centrally while still exposing parameters. You can call `{{ dt
    | datetime }}` with our datetime filter to get the default functionality that
    we defined, as well as `{{ dt | datetime('%Y-%m-%d') }}` where the argument in
    the template call is passed in as an argument after the value being filtered.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja支持一个环境，其中Python函数作为过滤器提供在模板中。我们的预约中有一个`datetime`字段，因此我们为其提供了一些格式。您可以在模板中直接调用属性和方法，`{{
    dt.strftime('%Y-%m-%d') }}`，但是定义一个过滤器让我们指定如何在中心格式化所有日期，同时仍然暴露参数。您可以使用我们的datetime过滤器调用`{{
    dt | datetime }}`来获得我们定义的默认功能，以及`{{ dt | datetime('%Y-%m-%d') }}`，其中模板调用中的参数作为值之后作为参数传递。
- en: There's more...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can find the full code for filters in the source code files downloadable
    on the Packt website.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Packt网站上提供的源代码文件中找到过滤器的完整代码。
- en: Additional filters
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加过滤器
- en: The full source code of `sched` includes filters for default date formatting,
    duration formatting for the appointment records, and the `nl2br` filter to preserve
    user-entered line breaks in the appointment description field (since HTML normalizes
    whitespace otherwise).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`sched`的完整源代码包括默认日期格式化的过滤器，预约记录的持续时间格式化，以及`nl2br`过滤器，以保留预约描述字段中用户输入的换行符（因为HTML会规范化空格）。'
- en: Sending error responses (Simple)
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送错误响应（简单）
- en: In this section, we will send an error page to the user with style.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向用户发送一个带有样式的错误页面。
- en: Getting ready
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are working from the `app.py` file inside the `sched` directory of our project,
    and in the `templates` directory inside `sched`. Create a directory named `error`
    inside the `templates` directory.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从项目的`sched`目录中的`app.py`文件中工作，并且在`sched`内的`templates`目录中。在`templates`目录内创建一个名为`error`的目录。
- en: How to do it...
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: When the user hits a **Not Found** page, we want to display a page that will
    direct them back to the appointment list. You can tell Flask how to render responses
    for error cases, typically for HTTP error codes. We will provide a custom 404
    Not Found page as shown in the following screenshot:![How to do it...](img/9628OS_01_05.jpg)
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户访问**未找到**页面时，我们希望显示一个页面，指引他们返回预约列表。您可以告诉Flask如何渲染错误情况的响应，通常是针对HTTP错误代码。我们将提供一个自定义的404未找到页面，如下面的截图所示：![如何做...](img/9628OS_01_05.jpg)
- en: 'Flask provides `app.errorhandler` to tell Flask how to handle certain kinds
    of errors, taking either `4xx` or `5xx` HTTP status codes or Python exception
    classes. Decorate a function which accepts an `Exception` instance and returns
    a response. Be sure to include the HTTP status code in the Flask response, by
    providing `404` in a tuple response with the rendered template string. In the
    following code, we render a not-found template, which provides a link back to
    the appointment list. In `app.py`:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask提供了`app.errorhandler`来告诉Flask如何处理某些类型的错误，可以使用`4xx`或`5xx`的HTTP状态码或Python异常类。装饰一个接受`Exception`实例并返回响应的函数。确保在Flask响应中包含HTTP状态码，通过在渲染模板字符串的元组响应中提供`404`。在下面的代码中，我们渲染一个未找到的模板，其中提供了返回预约列表的链接。在`app.py`中：
- en: '[PRE67]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In `templates/error/not_found.html`:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/error/not_found.html`中：
- en: '[PRE68]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `navbar` element in the base template will help users navigate back to a
    known page.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模板中的`navbar`元素将帮助用户导航回已知页面。
- en: How it works...
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `app.errorhandler` decorator accepts exception classes or HTTP status codes
    as integers. Following are some HTTP status codes to get you started. You can
    use these with `flask.abort(status_code)` in your view functions to jump directly
    to an error response, and define a custom `app.errorhandler` to provide a styled
    response.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.errorhandler`装饰器接受异常类或HTTP状态码作为整数。以下是一些HTTP状态码，供您开始使用。您可以在视图函数中使用`flask.abort(status_code)`触发这些状态码的错误响应，并定义一个自定义的`app.errorhandler`来提供样式化的响应。'
- en: 400 Bad Request
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400错误的请求
- en: 401 Unauthorized
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 401未经授权
- en: 403 Forbidden
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 403禁止
- en: 404 Not Found
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404未找到
- en: 405 Method Not Allowed (you may have forgotten methods in your route)
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 405方法不允许（您可能在路由中忘记了方法）
- en: 410 Gone (and not coming back)
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 410已经消失（不会再回来）
- en: 500 Internal Server Error
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500内部服务器错误
- en: See [www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
    for the full list.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)获取完整列表。
- en: The `500` error handler will display anytime your code has an uncaught exception.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`500`错误处理程序将在您的代码出现未捕获的异常时显示。'
- en: There's more...
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Flask provides a very useful debugger to inspect your errors in development.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了一个非常有用的调试器，用于检查开发中的错误。
- en: Handling specific exceptions
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理特定的异常
- en: 'You can provide a custom error page on Python exceptions:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python异常上提供自定义错误页面：
- en: '[PRE69]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Flask's debugger
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flask的调试器
- en: This is a good place to discuss Flask's debugger. When a Flask application has
    `app.config['DEBUG']` set to `True`, any uncaught exception in the application
    code will display a developer-friendly debugger in the browser. This debugger
    makes the Python stack trace interactive, letting you run code at any point in
    the stack frame and viewing code in context.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是讨论Flask调试器的好地方。当Flask应用程序的`app.config['DEBUG']`设置为`True`时，应用程序代码中的任何未捕获异常都将在浏览器中显示一个开发人员友好的调试器。这个调试器使Python堆栈跟踪交互式，让您在堆栈帧的任何点上运行代码并查看上下文中的代码。
- en: 'In `app.py`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.py`中：
- en: '[PRE70]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can trigger exceptions intentionally for a quick peek at your stack. Write
    in an exception and hit the route in your web browser. My two favorite exceptions
    are:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以故意触发异常，快速查看您的堆栈。在异常中写入一个异常并在Web浏览器中访问路由。我最喜欢的两个异常是：
- en: '[PRE71]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Only use this in development on a secured machine, since the interactive interpreter
    allows execution of Python code from the browser. If the interactive interpreter
    becomes unresponsive in the browser, either the development server has shut down
    or has moved on to new requests, forgetting about your error.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 只在受保护的机器上进行开发时使用这个，因为交互式解释器允许从浏览器执行Python代码。如果交互式解释器在浏览器中变得无响应，要么开发服务器已关闭，要么已经转移到新的请求，忘记了你的错误。
- en: Authenticating users (Advanced)
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证（高级）
- en: So far we have assumed that anyone who can access the `sched` application should
    be able to create, display, edit, list, and delete appointment records in the
    database. Our Flask application needs to authenticate users and protect our database.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设任何可以访问`sched`应用程序的人都应该能够在数据库中创建、显示、编辑、列出和删除约会记录。我们的Flask应用程序需要对用户进行身份验证并保护我们的数据库。
- en: Getting ready
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We return to the `models.py` file inside the `sched` directory of our project.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到项目的`sched`目录中的`models.py`文件。
- en: How to do it...
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start with a database record for the user with a unique e-mail address,
    in `models.py`:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`models.py`中具有唯一电子邮件地址的用户的数据库记录开始：
- en: '[PRE72]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, we add a means to store a password hash (continuing in User definition):'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一种存储密码哈希的方法（继续在用户定义中）：
- en: '[PRE73]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we add a means to validate a password (continuing in User definition):'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一种验证密码的方法（继续在用户定义中）：
- en: '[PRE74]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We need a place to store user records, so that we can verify whether an authentication
    request is for a valid user in our application. However, we do not want to store
    the password in clear text, which would let anyone with read access to the database
    table know how to login as a valid user in the application. This may not seem
    important the first time you come across the idea, but you do not want to handle
    the responsibility of storing everyone's passwords, especially if users reuse
    passwords across applications. (This should be a hint as to why that is a bad
    idea.)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个地方来存储用户记录，这样我们就可以验证认证请求是否针对我们应用程序中的有效用户。然而，我们不希望以明文存储密码，这样任何具有对数据库表的读取权限的人都会知道如何以有效用户的身份登录应用程序。第一次遇到这个想法时可能看起来不重要，但是你不希望承担存储每个人密码的责任，特别是如果用户在不同应用程序中重复使用密码的话。（这应该是为什么这是一个坏主意的提示。）
- en: Werkzeug provides utilities to hash a password and verify that the provided
    password matches that hash. We store the hash and not the clear-text password.
    Anytime `user.password` is set on a `User` instance, the password is immediately
    hashed using a Python descriptor and SQLAlchemy's synonym hook. The synonym lets
    us have `user.password` behave just like every other SQLAlchemy object attribute,
    but when `user.password` is accessed, getting the value will call `_get_password`
    and setting it will call `_set_password`, which will store a hashed value.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Werkzeug提供了哈希密码和验证提供的密码是否与哈希匹配的实用程序。我们存储哈希而不是明文密码。每当在`User`实例上设置`user.password`时，密码立即使用Python描述符和SQLAlchemy的同义钩子进行哈希。同义词让我们可以让`user.password`的行为就像每个其他SQLAlchemy对象属性一样，但是当访问`user.password`时，获取值将调用`_get_password`，设置它将调用`_set_password`，这将存储一个哈希值。
- en: We can now authenticate using e-mail, password, and a SQLAlchemy query object
    with `User.authenticate(query, email, password)`, which returns a `user, bool`
    pair (tuple), where `user` is the matching user object and the Boolean value indicates
    whether the authentication is valid.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用电子邮件、密码和SQLAlchemy查询对象进行身份验证，`User.authenticate(query, email, password)`，它返回一个`user,
    bool`对（元组），其中`user`是匹配的用户对象，布尔值表示身份验证是否有效。
- en: There's more...
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We need to integrate our e-mail/password authentication into our application.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将电子邮件/密码身份验证集成到我们的应用程序中。
- en: Appointment relationship
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约会关系
- en: 'We can build a relationship between appointments and users so that we display
    only the current user''s appointments when we load schedules. Update the `Appointment`
    class in `models.py` to include a foreign-key relationship to `User`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以建立约会和用户之间的关系，这样当我们加载日程表时，只显示当前用户的约会。在`models.py`中更新`Appointment`类，包括与`User`的外键关系：
- en: '[PRE75]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Accessing an `Appointment` object will now provide the `appointment.user` property
    to access the `User` object for the owner of that appointment. Because we used
    `ForeignKey`, SQLAlchemy knows how to fetch the related `User` record when accessing
    an `Appointment` object.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问`Appointment`对象将提供`appointment.user`属性来访问该约会的所有者的`User`对象。因为我们使用了`ForeignKey`，所以当访问`Appointment`对象时，SQLAlchemy知道如何获取相关的`User`记录。
- en: Opening a session
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开一个会话
- en: HTTP is stateless, meaning that one request has no information about the previous
    requests. We need to open a session that is retained from request-to-request,
    so that we can authenticate the user in one request and use that authentication
    in each of the following requests that the user makes in a given sitting.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是无状态的，这意味着一个请求没有关于先前请求的信息。我们需要打开一个会话，该会话从一个请求保留到另一个请求，这样我们就可以在一个请求中对用户进行身份验证，并在用户在给定的会话中进行的每个后续请求中使用该身份验证。
- en: 'In the next section, we will see how to handle the session, adding a `current_user`
    object to our code which will represent the `User` database object which matches
    the currently authenticated user. Now that we''ve added a relationship between
    `User` and `Appointment` in `models.py`, we need to update `app.py` for every
    case where we create or retrieve an `Appointment` object. Change the `Appointment`
    object creation line to:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何处理会话，向我们的代码添加一个`current_user`对象，该对象将表示与当前经过身份验证的用户匹配的`User`数据库对象。现在我们已经在`models.py`中为`User`和`Appointment`之间添加了关系，我们需要在每种情况下更新`app.py`，在那里我们创建或检索`Appointment`对象。将`Appointment`对象创建行更改为：
- en: '[PRE76]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then verify whether the current `Appointment` is for the current User when
    retrieving records:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然后验证当前`Appointment`是否适用于当前用户在检索记录时：
- en: '[PRE77]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Database migration
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: Changing `models.py` means that we need to update the database structure of
    the database we have been using in development, or the production database if
    we have already deployed the `sched` application. If the only changes we have
    made are to add tables, then we can simply make another call to `Base.metadata.create_all(engine)`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`models.py`意味着我们需要更新我们在开发中使用的数据库的数据库结构，或者如果我们已经部署了`sched`应用程序，则是生产数据库。如果我们所做的唯一更改是添加表，那么我们可以简单地再次调用`Base.metadata.create_all(engine)`。
- en: 'Sometimes in development, this is the easiest method: just destroy the development
    database, run `create_all` again, then start adding data again. Setting up initial
    development or test data can be cumbersome, so you might want to invest in **fixtures**,
    which you load before running your application development server. There are several
    projects in the Python community to do this, including `fixture` at [pypi.python.org/pypi/fixture](http://pypi.python.org/pypi/fixture).'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在开发中，这是最简单的方法：只需销毁开发数据库，再次运行`create_all`，然后重新开始添加数据。设置初始开发或测试数据可能很麻烦，因此您可能希望投资于**fixtures**，在运行应用程序开发服务器之前加载它们。Python社区中有几个项目可以做到这一点，包括`fixture`在[pypi.python.org/pypi/fixture](http://pypi.python.org/pypi/fixture)。
- en: For column changes, we need to provide an automation to change the live database,
    especially for production databases, which people are using. If you are familiar
    with SQL, you can write your own `ALTER TABLE` statements and provide your own
    scripts. If you would like a toolkit to manage this, SQLAlchemy's creator Mike
    Bayer has written Alembic as a tool to perform migrations in SQLAlchemy, [alembic.readthedocs.org](http://alembic.readthedocs.org).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列的更改，我们需要提供一个自动化来更改实时数据库，特别是对于正在使用的生产数据库。如果您熟悉SQL，可以编写自己的`ALTER TABLE`语句并提供自己的脚本。如果您想要一个工具包来管理这个，SQLAlchemy的创始人Mike
    Bayer已经编写了Alembic作为在SQLAlchemy中执行迁移的工具，[alembic.readthedocs.org](http://alembic.readthedocs.org)。
- en: Authenticating with existing services
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用现有服务进行身份验证
- en: How do new users get started? With user authentication in place for `sched`,
    you need to provide a means to register users with your application. This can
    be as simple as creating `User` objects from the Python interactive interpreter,
    or it could be a user signup form within your application.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户如何开始？对于`sched`中的用户身份验证，您需要提供一种注册用户的方法。这可以是从Python交互解释器中创建`User`对象，也可以是应用程序内的用户注册表单。
- en: Alternatively, you can reduce the `User` implementation to the core application
    data that you need and use an existing service to authenticate your users externally,
    creating new `User` objects on the first such authentication. This will keep users
    from having to remember yet another password and speed up your user acquisition
    process.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将`User`实现减少到您需要的核心应用程序数据，并使用现有服务来在外部对您的用户进行身份验证，首次进行此类身份验证时创建新的`User`对象。这将使用户无需记住另一个密码，并加快用户获取过程。
- en: OpenID ([openid.net](http://openid.net)) provides an open standard to perform
    this style of authentication. Popular services such as Google have their own documentation
    for authentication and authorization using existing user accounts, [developers.google.com/accounts/](http://developers.google.com/accounts/).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID（[openid.net](http://openid.net)）提供了一个开放标准来执行这种类型的身份验证。流行的服务，如谷歌，有他们自己的身份验证和授权的文档，使用现有的用户账户，[developers.google.com/accounts/](http://developers.google.com/accounts/)。
- en: Handling sessions and users (Intermediate)
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理会话和用户（中级）
- en: Since HTTP is stateless, we need to track some data across requests with a session.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP是无状态的，我们需要使用会话在请求之间跟踪一些数据。
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will continue to work from the `app.py` file from the `sched` directory and
    the `models.py` file.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从`sched`目录中的`app.py`文件和`models.py`文件中进行工作。
- en: How to do it...
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Flask provides a `session` object, which behaves like a Python dictionary,
    and persists automatically across requests. You can, in your Flask application
    code:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask提供了一个`session`对象，它的行为类似于Python字典，并且在请求之间自动持久化。您可以在您的Flask应用程序代码中：
- en: '[PRE78]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Flask-Login provides a simple means to track a user in Flask''s session. Update
    requirements.txt:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask-Login提供了一种简单的方法来跟踪Flask会话中的用户。更新requirements.txt：
- en: '[PRE79]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE80]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can then load Flask-Login into `sched`''s request handling, in `app.py`:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将Flask-Login加载到`sched`的请求处理中，在`app.py`中：
- en: '[PRE81]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Flask-Login requires four methods on the `User` object, inside `class User`
    in `models.py`:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask-Login在`models.py`中的`class User`内需要`User`对象上的四种方法：
- en: '[PRE82]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Tip
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Flask-Login provides a **UserMixin** (`flask.ext.login.UserMixin`) if you prefer
    to use its default implementation.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢使用其默认实现，Flask-Login提供了一个**UserMixin**（`flask.ext.login.UserMixin`）。
- en: 'We then provide routes to log the user in when authenticated and log out. In
    `app.py`:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们提供路由来在经过身份验证时登录用户并注销。在`app.py`中：
- en: '[PRE83]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We then decorate every view function that requires a valid user, in `app.py`:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在`app.py`中装饰每个需要有效用户的视图函数：
- en: '[PRE84]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On `login_user`, Flask-Login gets the user object's ID from `User.get_id` and
    stores it in Flask's session. Flask-Login then sets a `before_request` handler
    to load the user instance into the `current_user` object, using the `load_user`
    hook we provide. The `logout_user` function then removes the relevant bits from
    the session.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login_user`中，Flask-Login从`User.get_id`获取用户对象的ID，并将其存储在Flask的会话中。然后，Flask-Login设置一个`before_request`处理程序，将用户实例加载到`current_user`对象中，使用我们提供的`load_user`钩子。`logout_user`函数然后从会话中删除相关的部分。
- en: If no user is logged in, then `current_user` will provide an anonymous user
    object which results in `current_user.is_anonymous()` returning `True` and `current_user.is_authenticated()`
    returning `False`, which allows application and template code to base logic on
    whether the user is valid. (Flask-Login puts `current_user` into all template
    contexts.) You can use `User.is_active` to make user accounts invalid without
    actually deleting them, by returning `False` as appropriate.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有用户登录，那么`current_user`将提供一个匿名用户对象，导致`current_user.is_anonymous()`返回`True`，`current_user.is_authenticated()`返回`False`，这允许应用程序和模板代码基于用户是否有效进行逻辑。
    （Flask-Login将`current_user`放入所有模板上下文中。）您可以使用`User.is_active`使用户帐户无效，而不必实际删除它们，返回适当的`False`。
- en: View functions decorated with `login_required` will redirect the user to the
    login view if the current user is not authenticated, without calling the decorated
    function.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`login_required`装饰的视图函数将在当前用户未经身份验证时将用户重定向到登录视图，而不调用装饰的函数。
- en: There's more...
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Flask's session supports display of messages and protection against request
    forgery.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的会话支持显示消息和防止请求伪造。
- en: Flashing messages
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闪存消息
- en: 'When you want to display a simple message to indicate a successful operation
    or a failure quickly, you can use Flask''s flash messaging, which loads the message
    into the session until it is retrieved. In application code, inside request handling
    code:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要显示一个简单的消息来指示成功的操作或快速失败时，您可以使用Flask的闪存消息，它将消息加载到会话中直到被检索。在应用程序代码中，在请求处理代码内：
- en: '[PRE85]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In template code, where you can use the `''success''` category for conditional
    display:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板代码中，您可以使用`'success'`类别进行条件显示：
- en: '[PRE86]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Cross-site request forgery protection
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站点请求伪造保护
- en: Malicious web code will attempt to forge data-altering requests for other web
    services. To protect against forgery, you can load a randomized token into the
    session and into the HTML form, and reject the request when the two do not match.
    This is provided in the Flask-SeaSurf extension, [pythonhosted.org/Flask-SeaSurf/](http://pythonhosted.org/Flask-SeaSurf/)
    or the Flask-WTF extension (which integrates WTForms), [pythonhosted.org/Flask-ETF/](http://pythonhosted.org/Flask-ETF/).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意网络代码将尝试伪造数据更改请求以访问其他网络服务。为了防止伪造，您可以将一个随机化的令牌加载到会话和HTML表单中，当两者不匹配时拒绝请求。这在Flask-SeaSurf扩展中提供，[pythonhosted.org/Flask-SeaSurf/](http://pythonhosted.org/Flask-SeaSurf/)或Flask-WTF扩展（集成了WTForms），[pythonhosted.org/Flask-ETF/](http://pythonhosted.org/Flask-ETF/)。
- en: Deploying to the world (Advanced)
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到世界（高级）
- en: Once satisfied with your application, you can deploy your application which
    would be available to the world.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满意您的应用程序，您可以部署您的应用程序，使其对外开放。
- en: Getting ready
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'You need a computer which is online and accessible to your target users. Install
    Python and place `requirements.txt` in a folder where you have command-line access,
    just as we did for your development environment (virtualenv is production-appropriate),
    then create your database tables. You can deploy to any operating system: Windows
    and any Unix-like systems (including Mac OS X).'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一台联机且可供目标用户访问的计算机。安装Python并将`requirements.txt`放在您可以访问命令行的文件夹中，就像我们为您的开发环境所做的那样（virtualenv适用于生产环境），然后创建数据库表。您可以部署到任何操作系统：Windows和任何类Unix系统（包括Mac
    OS X）。
- en: How to do it...
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'From a clean Ubuntu 12.04 server installation:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从干净的Ubuntu 12.04服务器安装开始：
- en: '[PRE87]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Use the `pip` and `gunicorn` programs in virtualenv. Load into the nginx configuration,
    changing localhost to your domain name if you have one:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在virtualenv中使用`pip`和`gunicorn`程序。将其加载到nginx配置中，如果您有域名，请将localhost更改为您的域名：
- en: '[PRE88]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Then add the gunicorn process into the server's boot order instead of running
    it by hand. See your operating system's documentation. For Unix-like systems,
    supervisord provides management of long-running applications, [supervisord.org](http://supervisord.org).
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将gunicorn进程添加到服务器的启动顺序中，而不是手动运行它。请参阅您操作系统的文档。对于类Unix系统，supervisord提供了长时间运行应用程序的管理，[supervisord.org](http://supervisord.org)。
- en: How it works...
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Anytime nginx receives a matching request, it sends a proxy request to the HTTP
    server running on port `5000`, which is gunicorn in our application, and passes
    along the response. Note that gunicorn does not automatically reload your application
    on code updates. You can reload with process signals as described in [docs.gunicorn.org/en/latest/faq.html](http://docs.gunicorn.org/en/latest/faq.html).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 每当nginx接收到匹配请求时，它会将代理请求发送到运行在端口`5000`上的HTTP服务器，这在我们的应用程序中是gunicorn，并传递响应。请注意，gunicorn不会在代码更新时自动重新加载您的应用程序。您可以按照[docs.gunicorn.org/en/latest/faq.html](http://docs.gunicorn.org/en/latest/faq.html)中描述的过程信号重新加载。
- en: See [docs.gunicorn.org/en/latest/deploy.html](http://docs.gunicorn.org/en/latest/deploy.html)
    for additional documentation.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其他文档，请参阅[docs.gunicorn.org/en/latest/deploy.html](http://docs.gunicorn.org/en/latest/deploy.html)。
- en: There's more...
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Deployment has many options; the configuration is entirely up to your project.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 部署有许多选项；配置完全取决于您的项目。
- en: Handling static files with nginx
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用nginx处理静态文件
- en: 'Flask provides a static file handler for convenience. Now that we have an optimized
    HTTP server in place, we can have it serve static files directly. The following
    configuration block shows how to serve static files with nginx and proxy all other
    requests to Flask. Adjust the configuration according to your setup:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了一个方便的静态文件处理程序。现在我们已经有了一个优化的HTTP服务器，我们可以让它直接提供静态文件。以下配置块显示了如何使用nginx提供静态文件并将所有其他请求代理到Flask。根据您的设置调整配置：
- en: Change `/var/www/myproject` to the filepath containing the `sched` folder from
    our project layout.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`/var/www/myproject`更改为包含我们项目布局中`sched`文件夹的文件路径。
- en: Change `/static/` if you changed the default static route in Flask.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您更改了Flask中的默认静态路由，请更改`/static/`。
- en: 'The updated server configuration, to handle static files:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的服务器配置，用于处理静态文件：
- en: '[PRE89]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Deployable on any OS with HTTP proxying
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可在任何OS上进行HTTP代理部署
- en: 'I prefer to run applications in production using HTTP proxying with application
    code served by stand-alone, independent operating system processes. Most industrial
    strength HTTP servers include a means to proxy requests to another web service,
    just as we demonstrated with nginx. gunicorn only runs on Unix-like systems, but
    cherrypy ([cherrypy.org](http://cherrypy.org)) provides a cross-platform WSGI
    server. You can start your application with a script which follows this example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用独立的操作系统进程通过HTTP代理来运行应用程序。大多数强大的HTTP服务器都包括一种方式来代理请求到另一个web服务，就像我们用nginx演示的那样。gunicorn只能在类Unix系统上运行，但cherrypy
    ([cherrypy.org](http://cherrypy.org))提供了一个跨平台的WSGI服务器。您可以使用以下示例中的脚本启动应用程序：
- en: '[PRE90]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Windows server deployment
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows服务器部署
- en: To run your Python application directly within Windows Server IIS, see the NWSGI
    project at [nwsgi.codeplex.com](http://nwsgi.codeplex.com).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows Server IIS中直接运行Python应用程序，请参阅[NWSGI项目](http://nwsgi.codeplex.com)。
- en: Other deployment options
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他部署选项
- en: See the Flask docs at [flask.pocoo.org/docs/deploying/](http://flask.pocoo.org/docs/deploying/).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[flask.pocoo.org/docs/deploying/](http://flask.pocoo.org/docs/deploying/)上的Flask文档。
