- en: Starting Answerly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始Answerly
- en: The second project that we will build is a Stack Overflow clone called Answerly.
    Users who register for Answerly will be able to ask and answer questions. A question's
    asker will also be able to accept answers to mark them as useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第二个项目是一个名为Answerly的Stack Overflow克隆。 注册Answerly的用户将能够提问和回答问题。 提问者还将能够接受答案以标记它们为有用。
- en: 'In this chapter, we''ll do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Create our new Django project—Answerly, a Stack Overflow clone
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的新Django项目Answerly，一个Stack Overflow克隆
- en: Create the models for Answerly (`Question` and `Answer`)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Answerly创建模型（`Question`和`Answer`）
- en: Let users register
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户注册
- en: Create forms, views, and templates to let users interact with our models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表单，视图和模板，让用户与我们的模型进行交互
- en: Run our code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的代码
- en: The code for this project is available online at [https://github.com/tomaratyn/Answerly](https://github.com/tomaratyn/Answerly).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在[https://github.com/tomaratyn/Answerly](https://github.com/tomaratyn/Answerly)上找到。
- en: This chapter won't go deeply into topics already covered in [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*, although it will touch upon many of the same points. Instead,
    this chapter will focus on going a bit further and introducing new views and third-party
    libraries.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会深入讨论已在[第1章](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml)中涵盖的主题，尽管它将涉及许多相同的要点。
    相反，本章将重点放在更进一步并引入新视图和第三方库上。
- en: Let's start our project!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的项目！
- en: Creating the Answerly Django project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Answerly Django项目
- en: 'First, let’s make a directory for our project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的项目创建一个目录：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All our future commands and paths will be relative to this project directory.
    A Django project is composed of multiple Django apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们未来的所有命令和路径都将相对于这个项目目录。 一个Django项目由多个Django应用程序组成。
- en: 'We’ll install Django using `pip`, Python''s preferred package manager. We will
    also track the packages that we install in a `requirements.txt` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pip`安装Django，Python的首选软件包管理器。 我们还将在`requirements.txt`文件中跟踪我们安装的软件包：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s install the packages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装软件包：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let''s generate the actual Django project using `django-admin`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`django-admin`生成实际的Django项目：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By default, Django creates a project that will use SQLite, but that's not usable
    for production; so, we'll follow the best practice of using the same database
    in development as in production.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django创建一个将使用SQLite的项目，但这对于生产来说是不可用的； 因此，我们将遵循在开发和生产中使用相同数据库的最佳实践。
- en: 'Let''s open up `django/config/settings.py` and update it to use our Postgres
    server. Find the line in `settings.py` that starts with `DATABASES`; to use Postgres,
    change the `DATABASES` value to the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`django/config/settings.py`并更新它以使用我们的Postgres服务器。 找到以`DATABASES`开头的`settings.py`中的行；
    要使用Postgres，请将`DATABASES`的值更改为以下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have our project started and configured, we can create and install
    the two Django apps we''ll make as part of this project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始并配置了我们的项目，我们可以创建并安装我们将作为项目一部分制作的两个Django应用程序：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A Django project is composed of apps. Django apps are where all the functionalities
    and code live. Models, forms, and templates all belong to Django apps. An app,
    like every other Python module, should have a clearly defined scope. In our case,
    we have two apps each with different roles. The `qanda` app will be responsible
    for the question and answer functionality of our app. The `user` app will be responsible
    for user management of our app. Each of them will also rely on other apps and
    Django's core functionality to work effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目由应用程序组成。 Django应用程序是所有功能和代码所在的地方。 模型，表单和模板都属于Django应用程序。 应用程序，就像其他Python模块一样，应该有一个明确定义的范围。
    在我们的情况下，我们有两个应用程序，每个应用程序都有不同的角色。 `qanda`应用程序将负责我们应用程序的问题和答案功能。 `user`应用程序将负责我们应用程序的用户管理。
    它们每个都将依赖其他应用程序和Django的核心功能以有效地工作。
- en: 'Now, let''s install our apps in our project by updating `django/config/settings.py`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过更新`django/config/settings.py`在我们的项目中安装我们的应用程序：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that Django knows about our app, let’s install start with the models for
    `qanda`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 既然Django知道我们的应用程序，让我们从`qanda`的模型开始安装。
- en: Creating the Answerly models
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Answerly模型
- en: Django is particularly helpful for creating data-driven apps. Models, representing
    the data in the apps, are often the core of these apps. Django encourages this
    with the best practice of *fat models, thin views, dumb templates*. The advice
    encourages us to place business logic in our models rather than our views.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Django在创建数据驱动的应用程序方面特别有帮助。 模型代表应用程序中的数据，通常是这些应用程序的核心。 Django通过*fat models, thin
    views, dumb templates*的最佳实践鼓励这一点。 这些建议鼓励我们将业务逻辑放在我们的模型中，而不是我们的视图中。
- en: Let’s start building our `qanda` models with the `Question` model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Question`模型开始构建我们的`qanda`模型。
- en: Creating the Question model
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Question模型
- en: 'We''ll create our `Question` model in `django/qanda/models.py`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/qanda/models.py`中创建我们的`Question`模型：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `Question` model, like all Django models, is derived from `django.db.models.Model`.
    It has the following four fields that will become columns in a `questions_question`
    table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Question`模型，像所有Django模型一样，派生自`django.db.models.Model`。 它具有以下四个字段，这些字段将成为`questions_question`表中的列：'
- en: '`title`: A character field that will become a `VARCHAR` column of maximum 140
    characters.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：一个字符字段，将成为最多140个字符的`VARCHAR`列。'
- en: '`question`: This is the body of the question. Since we can''t predict how long
    this will be, we use a `TextField`, which will become a `TEXT` column.The `TEXT`
    columns don''t have a size limit.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`question`：这是问题的主体。 由于我们无法预测这将有多长，我们使用`TextField`，它将成为`TEXT`列。`TEXT`列没有大小限制。'
- en: '`user`: This will create a foreign key to the project''s configured user model.
    In our case, we will go with the default `django.contrib.auth.models.User` that
    comes with Django. However, it''s still recommended to not hardcode this when
    we can avoid it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这将创建一个外键到项目配置的用户模型。 在我们的情况下，我们将使用Django提供的默认`django.contrib.auth.models.User`。
    但是，建议我们尽量避免硬编码这一点。'
- en: '`created`: This will be automatically set to the date and time that the `Question` model
    was created.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：这将自动设置为创建`Question`模型的日期和时间。'
- en: '`Question` also implements the following two methods commonly seen on Django
    models (`__str__` and `get_absolute_url`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Question`还实现了Django模型上常见的两种方法（`__str__`和`get_absolute_url`）：'
- en: '`__str__()`: This tells Python how to convert our model to a string. This is
    useful in the admin backend, our own templates, and in debugging.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__str__()`：这告诉Python如何将我们的模型转换为字符串。这在管理后端、我们自己的模板和调试中非常有用。'
- en: '`get_absolute_url()`: This is a commonly implemented method that lets the model
    return the path of a URL to view this model. Not all models need this method.
    Django’s built-in views, such as `CreateView`, will use this method to redirect
    the user to the view after the model is created.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_absolute_url()`：这是一个常见的实现方法，让模型返回查看此模型的URL路径。并非所有模型都需要此方法。Django的内置视图，如`CreateView`，将使用此方法在创建模型后将用户重定向到视图。'
- en: Finally, in the spirit of *fat models*, we also have `can_accept_answers()`.
    The decision of who can accept an `Answer` to a `Question` lies with the `Question`.
    Currently, only the user who asked the question can accept an answer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在“fat models”的精神下，我们还有`can_accept_answers()`。谁可以接受对`Question`的`Answer`的决定取决于`Question`。目前，只有提问问题的用户可以接受答案。
- en: Now that we have the `Question` s, we naturally need `Answer` s.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Question`，自然需要`Answer`。
- en: Creating the Answer model
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`Answer`模型
- en: 'We''ll create the `Answer` model in the `django/questions/models.py` file as
    shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/questions/models.py`文件中创建`Answer`模型，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Answer` model has five fields and a `Meta` class. Let''s take a look at
    the fields first:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Answer`模型有五个字段和一个`Meta`类。让我们先看看这些字段：'
- en: '`answer`: This is an unlimited text field for the user''s answer. `answer`
    will become a `TEXT` column.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answer`：这是用户答案的无限文本字段。`answer`将成为一个`TEXT`列。'
- en: '`user`: This will create a foreign key to the user model that our project has
    been configured to use. The user model will gain a new `RelatedManager` under
    the name `answer_set`, which will be able to query all the `Answer` s for a user.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这将创建一个到我们项目配置为使用的用户模型的外键。用户模型将获得一个名为`answer_set`的新`RelatedManager`，它将能够查询用户的所有`Answer`。'
- en: '`question`: This will create a foreign key to our `Question` model. `Question`
    will also gain a new `RelatedManager` under the name `answer_set`, which will
    be able to query all the `Answer` s to a `Question`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`question`：这将创建一个到我们的`Question`模型的外键。`Question`还将获得一个名为`answer_set`的新`RelatedManager`，它将能够查询所有`Question`的`Answer`。'
- en: '`created`: This will be set to the date and time when the `Answer` was created.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：这将设置为创建`Answer`的日期和时间。'
- en: '`accepted`: This is a Boolean that will be set to `False` by default. We''ll
    use it to mark accepted answers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accepted`：这是一个默认设置为`False`的布尔值。我们将用它来标记已接受的答案。'
- en: A model's `Meta` class lets us set metadata for our model and table. For `Answer`,
    we're using the `ordering` option to ensure that all queries will be ordered by
    `created`, in descending order. In this way, we ensure that the newest answers
    will be listed first, by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的`Meta`类让我们为我们的模型和表设置元数据。对于`Answer`，我们使用`ordering`选项来确保所有查询都将按`created`的降序排序。通过这种方式，我们确保最新的答案将首先列出，默认情况下。
- en: Now that we have `Question` and `Answer` models, we will need to create migrations
    to create their tables in the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Question`和`Answer`模型，我们需要创建迁移以在数据库中创建它们的表。
- en: Creating migrations
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建迁移
- en: Django comes with a built-in migration library. This is part of Django's *batteries
    included* philosophy. Migrations provide a way to manage the changes that we will
    need to make to our schema. Whenever we make a change to a model, we can use Django
    to generate a migration, which will contain the instructions on how to create
    or change the schema to fit the new model's definition. To make the change to
    our database, we will apply the schema.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Django自带一个内置的迁移库。这是Django“一揽子”哲学的一部分。迁移提供了一种管理我们需要对模式进行的更改的方法。每当我们对模型进行更改时，我们可以使用Django生成一个迁移，其中包含了如何创建或更改模式以适应新模型定义的指令。要对数据库进行更改，我们将应用模式。
- en: 'Like many operations we perform on our project, we''ll use the `manage.py`
    script Django provides for our project:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在项目上执行的许多操作一样，我们将使用Django为我们的项目提供的`manage.py`脚本：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we've created the migrations and applied them, let's set up a base
    template for our project so that our code works well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了迁移并应用了它们，让我们为我们的项目设置一个基础模板，以便我们的代码能够正常工作。
- en: Adding a base template
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加基础模板
- en: Before we create our views, let's create a base template. Django's template
    language allows templates to inherit from each other. A base template is a template
    that all our other project's templates will extend. This will give our entire
    project a common look and feel.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建视图之前，让我们创建一个基础模板。Django的模板语言允许模板相互继承。基础模板是所有其他项目模板都将扩展的模板。这将给我们整个项目一个共同的外观和感觉。
- en: Since a project is composed of multiple apps and they will all use the same
    base template, a base template belongs to the project, not to any particular app.
    This is a rare exception to the rule that everything lives in an app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目由多个应用程序组成，它们都将使用相同的基础模板，因此基础模板属于项目，而不属于任何特定的应用程序。这是一个罕见的例外，违反了一切都在应用程序中的规则。
- en: 'To add a project-wide templates directory, update `django/config/settings.py`.
    Check the `TEMPLATES` setting and update it to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个项目范围的模板目录，请更新`django/config/settings.py`。检查`TEMPLATES`设置并将其更新为以下内容：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In particular, the `DIRS` option for the `django.template.backends.django.DjangoTemplates` setting
    sets a project-wide template directory that will be searched. `''APP_DIRS'': True`
    means that each installed app’s `templates` directory will also be searched. In
    order for Django to search `django/templates`, we must add `os.path.join(BASE_DIR,
    ''templates'')` to the `DIRS` list.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '特别是，`django.template.backends.django.DjangoTemplates`设置的`DIRS`选项设置了一个项目范围的模板目录，将被搜索。`''APP_DIRS'':
    True`意味着每个安装的应用程序的`templates`目录也将被搜索。为了让Django搜索`django/templates`，我们必须将`os.path.join(BASE_DIR,
    ''templates'')`添加到`DIRS`列表中。'
- en: Creating base.html
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建base.html
- en: 'Django comes with its own template language eponymously called the Django Template
    Language. Django templates are text files, which are rendered using a dictionary
    (called a context) to look up values. A template can also include tags (which
    use the `{% tag argument %}` syntax). A template can print values from its context
    using the `{{ variableName }}` syntax. Values can be sent to filters to tweak
    them before being displayed (for example, `{{ user.username | uppercase }}` will
    print the user’s username with all uppercase characters). Finally, the `{# ignored
    #}` syntax can comment out multiple lines of text.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'Django自带了自己的模板语言，名为Django模板语言。Django模板是文本文件，使用字典（称为上下文）进行渲染以查找值。模板还可以包括标签（使用`{%
    tag argument %}`语法）。模板可以使用`{{ variableName }}`语法从其上下文中打印值。值可以发送到过滤器进行调整，然后显示（例如，`{{
    user.username | uppercase }}`将打印用户的用户名，所有字符都是大写）。最后，`{# ignored #}`语法可以注释掉多行文本。'
- en: 'We''ll create our base template in `django/templates/base.html`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/templates/base.html`中创建我们的基本模板：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We won''t go over this HTML, but it''s worth reviewing the Django template
    tags involved:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍这个HTML，但值得回顾涉及的Django模板标签：
- en: '`{% load static %}`: `load` lets us load template tag libraries that aren''t
    available by default. In this case, we''re loading the static library, which provides
    the `static` tag. The library and tag don''t always share their name. This is
    provided with Django by the `django.contrib.static` app.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% load static %}`：`load`让我们加载默认情况下不可用的模板标签库。在这种情况下，我们加载了静态库，它提供了`static`标签。该库和标签并不总是共享它们的名称。这是由`django.contrib.static`应用程序提供的Django。'
- en: '`{% block title %}Answerly{% endblock %}`: Blocks let us define areas that
    templates can override when extending this template.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% block title %}Answerly{% endblock %}`：块让我们定义模板在扩展此模板时可以覆盖的区域。'
- en: '`{% static ''base.css'' %}`: The `static` tag (loaded in from the preceding `static`
    library) uses the `STATIC_URL` setting to create a reference to a static file.
    In this case, it will return `/static/base.css`. As long as the file is in a directory
    listed in `settings.STATICFILES_DIRS` and Django is in debug mode, Django will
    serve that file for us. For production, refer to [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% static ''base.css'' %}`：`static`标签（从前面加载的`static`库中加载）使用`STATIC_URL`设置来创建对静态文件的引用。在这种情况下，它将返回`/static/base.css`。只要文件在`settings.STATICFILES_DIRS`列出的目录中，并且Django处于调试模式，Django就会为我们提供该文件。对于生产环境，请参阅[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)，*部署Answerly*。'
- en: That's enough for our `base.html` file to start. We'll update the navigation
    in `base.html` later, in the *Updating base.html navigation* section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够我们的`base.html`文件开始了。我们将在*更新base.html导航*部分中稍后更新`base.html`中的导航。
- en: Next, let's configure Django to know how to find our `base.css` file by configuring
    static files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置Django知道如何找到我们的`base.css`文件，通过配置静态文件。
- en: Configuring static files
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置静态文件
- en: 'Next, let''s configure a directory for project-wide static files in `django/config/settings.py`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/config/settings.py`中配置一个项目范围的静态文件目录：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will tell Django that any file in `django/static/` should be served while
    Django is in debug mode. For production, refer to [Chapter 9](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml),
    *Deploying Answerly*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django，在调试模式下应该提供`django/static/`中的任何文件。对于生产环境，请参阅[第9章](2c6bf064-57ff-41bc-89d0-21fac1308186.xhtml)，*部署Answerly*。
- en: 'Let''s put some basic CSS in `django/static/base.css`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/static/base.css`中放一些基本的CSS：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have created the foundation, let's create `AskQuestionView`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了基础，让我们创建`AskQuestionView`。
- en: Letting users post questions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户发布问题
- en: We will now create a view for letting users post questions that they need answered.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个视图，让用户发布他们需要回答的问题。
- en: Django follows **Model-View-Template** (**MVT**) pattern separate model, control,
    and presentation logic and encourage reusability. Models represent the data we'll
    store in the database. Views are responsible for handling a request and returning
    a response. Views should not have HTML. Templates are responsible for the body
    of a response and defining the HTML. This separation of responsibilities has proven
    to make it easy to write code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Django遵循**模型-视图-模板**（**MVT**）模式，将模型、控制和表示逻辑分开，并鼓励可重用性。模型代表我们将在数据库中存储的数据。视图负责处理请求并返回响应。视图不应该包含HTML。模板负责响应的主体和定义HTML。这种责任的分离已被证明使编写代码变得容易。
- en: 'To let users post questions, we''ll perform the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户发布问题，我们将执行以下步骤：
- en: Make a form to process the questions
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理问题的表单
- en: Make a view that uses Django forms to create questions
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用Django表单创建问题的视图
- en: Make a template that renders the form in HTML
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个在HTML中渲染表单的模板
- en: Add a `path` to the view
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加一个`path`
- en: First, let's make the `QuestionForm` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`QuestionForm`类。
- en: Ask question form
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提问表单
- en: Django forms serve two purposes. They make it easy to render the body of a form
    to receive user input. They also validate the user input. When a form is instantiated,
    it can be given initial values (by the `intial` parameter) and data to validate
    (by the `data` parameter). A form which has been provided data is said to be bound.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Django表单有两个目的。它们使得渲染表单主体以接收用户输入变得容易。它们还验证用户输入。当一个表单被实例化时，它可以通过`intial`参数给出初始值，并且通过`data`参数给出要验证的数据。提供了数据的表单被称为绑定的。
- en: Much of the power of Django comes from how easy it is to join models, forms,
    and views together to build features.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Django的许多强大之处在于将模型、表单和视图轻松地结合在一起构建功能。
- en: 'We''ll make our form in `django/qanda/forms.py`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/qanda/forms.py`中创建我们的表单：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ModelForm` makes creating forms from Django models easier. We use the inner
    `Meta` class of `QuestionForm` to specify the model and fields that are part of
    the form.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelForm`使得从Django模型创建表单更容易。我们使用`QuestionForm`的内部`Meta`类来指定表单的模型和字段。'
- en: By adding a `user` field, we're able to override how Django renders the `user`
    field. We tell Django to use the `HiddenInput` widget, which will render the field
    as `<input type='hidden'>`. The `queryset` argument lets us restrict the users
    that are valid values (in our case, all users are valid). Finally, the `disabled`
    argument says that we will ignore any values provided by `data` (that is, from
    a request) and rely on the `initial` values we provide to the form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个`user`字段，我们能够覆盖Django如何呈现`user`字段。我们告诉Django使用`HiddenInput`小部件，它将把字段呈现为`<input
    type='hidden'>`。`queryset`参数让我们限制有效值的用户（在我们的情况下，所有用户都是有效的）。最后，`disabled`参数表示我们将忽略由`data`（即来自请求的）提供的任何值，并依赖于我们提供给表单的`initial`值。
- en: Now that we know how to render and validate a question form, let's create our
    view.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何呈现和验证问题表单，让我们创建我们的视图。
- en: Creating AskQuestionView
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AskQuestionView
- en: 'We will create our `AskQuestionView` class in `django/qanda/views.py`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`django/qanda/views.py`中创建我们的`AskQuestionView`类：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`AskQuestionView` is derived from `CreateView` and uses the `LoginRequiredMixin`.
    The `LoginRequiredMixin` ensures that any request made by a user who is not logged
    in will be redirected to the login page. The `CreateView` knows to render the
    template for `GET` requests and to validate the form on `POST` requests. If a
    form is valid, `CreateView` will call `form_valid`. If the form is not valid,
    `CreateView` will re-render the template.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskQuestionView`派生自`CreateView`并使用`LoginRequiredMixin`。`LoginRequiredMixin`确保任何未登录用户发出的请求都将被重定向到登录页面。`CreateView`知道如何为`GET`请求呈现模板，并在`POST`请求上验证表单。如果表单有效，`CreateView`将调用`form_valid`。如果表单无效，`CreateView`将重新呈现模板。'
- en: Our `form_valid` method overrides the original `CreateView` method to support
    a save and preview mode. When we want to save, we will call the original `form_valid`
    method. The original method saves the new question and returns an HTTP response
    that redirects the user to the new question (using `Question.get_absolute_url()`).
    When we want to preview the question, we will re-render our template with the
    new `preview` variable in our template's context.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`form_valid`方法覆盖了原始的`CreateView`方法，以支持保存和预览模式。当我们想要保存时，我们将调用原始的`form_valid`方法。原始方法保存新问题并返回一个HTTP响应，将用户重定向到新问题（使用`Question.get_absolute_url()`）。当我们想要预览问题时，我们将在我们模板的上下文中重新呈现我们的模板，其中包含新的`preview`变量。
- en: When our view is instantiating the form, it will pass the result of `get_initial()`
    as the `initial` argument and the `POST` data as the `data` argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的视图实例化表单时，它将把`get_initial()`的结果作为`initial`参数传递，并将`POST`数据作为`data`参数传递。
- en: Now that we have our view, let's create `ask.html`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的视图，让我们创建`ask.html`。
- en: Creating ask.html
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ask.html
- en: 'Let''s create our template in `django/qanda/ask.html`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/ask.html`中创建我们的模板：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This template uses our `base.html` template and puts all its HTML in the `blocks`
    defined by there. When we render the template, Django renders `base.html` and
    then fills in the values of the blocks with the contents defined in `ask.html`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板使用我们的`base.html`模板，并将所有HTML放在那里定义的`blocks`中。当我们呈现模板时，Django会呈现`base.html`，然后用在`ask.html`中定义的内容填充块的值。
- en: '`ask.html` also loads two third-party tag libraries, `markdownify` and `crispy_forms_tags`.
    `markdownify` provides the `markdownify` filter used in the preview card’s body
    (`{{preview.question | markdownify}}`). The `crispy_forms_tags` library provides
    the `crispy` filter, which applies Bootstrap 4 CSS classes to help the Django
    form render nicely.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ask.html`还加载了两个第三方标签库，`markdownify`和`crispy_forms_tags`。`markdownify`提供了用于预览卡正文的`markdownify`过滤器（`{{preview.question
    | markdownify}}`）。`crispy_forms_tags`库提供了`crispy`过滤器，它应用Bootstrap 4 CSS类以帮助Django表单呈现得很好。'
- en: Each of these libraries needs to be installed and configured, which we do in
    the following sections (*Installing and configuring Markdownify* and *Installing
    and configuring Django Crispy Forms*, respectively).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库中的每一个都需要安装和配置，我们将在接下来的部分中进行（*安装和配置Markdownify*和*安装和配置Django Crispy Forms*）。
- en: 'The following are a few more new tags that `ask.html` shows us:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ask.html`向我们展示的一些新标记：
- en: '`{% if preview %}`: This demonstrates how to use an `if` statement in the Django
    template language. We only want to render a preview of the `Question` if we have
    a `preview` variable in our context.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% if preview %}`：这演示了如何在Django模板语言中使用`if`语句。我们只想在我们的上下文中有一个`preview`变量时才呈现`Question`的预览。'
- en: '`{% csrf_token %}`: This tag adds the expected CSRF token to our form. CSRF
    tokens help protect us against malicious scripts trying to submit data on behalf
    of an innocent but logged-in user; refer to [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*, for more information. In Django, CSRF tokens
    are not optional, and `POST` requests missing a CSRF token will not be processed.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% csrf_token %}`：此标记将预期的CSRF令牌添加到我们的表单中。 CSRF令牌有助于保护我们免受恶意脚本试图代表一个无辜但已登录的用户提交数据的攻击；有关更多信息，请参阅[第3章](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml)，*海报、头像和安全性*。在Django中，CSRF令牌是不可选的，缺少CSRF令牌的`POST`请求将不会被处理。'
- en: Let's take a closer look at those third-party libraries, starting with Markdownify.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看那些第三方库，从Markdownify开始。
- en: Installing and configuring Markdownify
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Markdownify
- en: Markdownify is a Django app available on the **Python Package Index** (**PyPI**)
    created by R Moelker and Erwin Matijsen and licensed under the MIT license (a
    popular open source license). Markdownify provides the Django template filter
    `markdownify`, which will convert Markdown to HTML.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Markdownify是由R Moelker和Erwin Matijsen创建的Django应用程序，可在**Python Package Index**（**PyPI**）上找到，并根据MIT许可证（一种流行的开源许可证）进行许可。Markdownify提供了Django模板过滤器`markdownify`，它将Markdown转换为HTML。
- en: Markdownify works by using the **python-markdown** package to convert Markdown
    to HTML. Marodwnify then uses Mozilla's `bleach`library to sanitize the resultiant
    HTML from Cross Site Scripting (**XSS**) attacks. The result is then returned
    to the template for output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Markdownify通过使用**python-markdown**包将Markdown转换为HTML来工作。然后，Marodwnify使用Mozilla的`bleach`库来清理结果HTML，以防止跨站脚本（**XSS**）攻击。然后将结果返回到模板进行输出。
- en: 'To install Markdownify, let''s add it to our `requirements.txt` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Markdownify，让我们将其添加到我们的`requirements.txt`文件中：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, run `pip` to install it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`pip`进行安装：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will need to add `markdownify` to our list of `INSTALLED_APPS` in `django/config/settings.py`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`django/config/settings.py`中将`markdownify`添加到我们的`INSTALLED_APPS`列表中。
- en: 'The last step is to configure Markdownify to let it know which HTML tags to
    whitelist. Add the following settings to `settings.py`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是配置Markdownify，让它知道要对哪些HTML标签进行白名单。将以下设置添加到`settings.py`中：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will whitiest all the text, list, and heading tags we want available to
    our users. Setting `MARKDOWNIFY_STRIP` to `False` tells Markdownify to HTML encode
    (rather than strip) any other HTML tag.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的用户可以使用所有文本、列表和标题标签。将`MARKDOWNIFY_STRIP`设置为`False`告诉Markdownify对其他HTML标签进行HTML编码（而不是剥离）。
- en: Now that we've configured Markdownify, let's install and configure Django Crispy
    Forms.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Markdownify，让我们安装和配置Django Crispy Forms。
- en: Installing and configuring Django Crispy Forms
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Django Crispy Forms
- en: Django Crispy Forms is a third-party Django app available on PyPI. Miguel Araujo
    is the development lead. It is licensed under the MIT license. Django Crispy Forms
    is one of the most popular Django libraries because it makes it so easy to render
    pretty (crisp) forms.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Django Crispy Forms是PyPI上可用的第三方Django应用程序。Miguel Araujo是开发负责人。它是根据MIT许可证许可的。Django
    Crispy Forms是最受欢迎的Django库之一，因为它使得渲染漂亮（清晰）的表单变得如此容易。
- en: 'One of the problems we encounter in Django is that when Django renders a field
    it will render it something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中遇到的问题之一是，当Django渲染字段时，它会呈现为这样：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, in order to style that form nicely, for example, using Bootstrap 4,
    we would like to render something more like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了漂亮地设计该表单，例如使用Bootstrap 4，我们希望呈现类似于这样的内容：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sadly, Django doesn't provide hooks that would let us easily wrap the field
    in a `div` with class `form-group`, or add CSS classes such as `form-control`
    or `form-control-label`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，Django没有提供钩子，让我们轻松地将字段包装在具有类`form-group`的`div`中，或者添加CSS类，如`form-control`或`form-control-label`。
- en: Django Crispy Forms solves this with its `crispy` filter. If we send a form
    into it by performing `{{ form | crispy}}`, Django Crispy Forms will correctly
    transform the form's HTML and CSS to work with a variety of CSS frameworks (including
    Zurb Foundation, Bootstrap 3, and Bootstrap 4). You can further customize the
    form’s rendering through more advanced usage of Django Crispy Forms, but we won't
    be doing that in this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Django Crispy Forms通过其`crispy`过滤器解决了这个问题。如果我们通过执行`{{ form | crispy}}`将一个表单发送到它，Django
    Crispy Forms将正确地转换表单的HTML和CSS，以适应各种CSS框架（包括Zurb Foundation，Bootstrap 3和Bootstrap
    4）。您可以通过更高级的使用Django Crispy Forms进一步自定义表单的渲染，但在本章中我们不会这样做。
- en: 'To install Django Crispy Forms, let''s add it to our `requirements.txt` and
    install it using `pip`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Django Crispy Forms，让我们将其添加到我们的`requirements.txt`并使用`pip`进行安装：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we will need to install it as a Django app in our project by editing `django/config/settings.py`
    and adding `'crispy_forms'` to our list of `INSTALLED_APPS`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过编辑`django/config/settings.py`并将`'crispy_forms'`添加到我们的`INSTALLED_APPS`列表中，将其安装为我们项目中的Django应用程序。
- en: 'Next, we will need to configure our project so that Django Crispy Forms knows
    to use the Bootstrap 4 template pack. Update `django/config/settings.py` with
    a new config:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的项目，以便Django Crispy Forms知道使用Bootstrap 4模板包。更新`django/config/settings.py`以进行新的配置：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we've installed all the libraries our template relies on, we can configure
    Django to route requests to our `AskQuestionView`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了模板所依赖的所有库，我们可以配置Django将请求路由到我们的`AskQuestionView`。
- en: Routing requests to AskQuestionView
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到AskQuestionView
- en: Django routes requests using a URLConf. It's a list of `path()` objects that
    a request's path is matched against. The view of the first matching `path()` gets
    to process the request. A URLConf can include another URLConf. A project's settings
    defines its root URLConf (in our case, `django/config/urls.py`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用URLConf路由请求。这是一个`path()`对象的列表，用于匹配请求的路径。第一个匹配的`path()`的视图将处理请求。URLConf可以包含另一个URLConf。项目的设置定义了其根URLConf（在我们的情况下是`django/config/urls.py`）。
- en: Defining all the `path()` objects for all the views in a project in the root
    URLConf can get messy and makes the apps less reusable. It’s often convenient
    to put a URLConf (usually in a `urls.py` file) in each app. Then, the root URLConf
    can use the `include()` function to include other apps' URLConfs to route requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在根URLConf中为项目中所有视图的所有`path()`对象定义可以变得混乱，并使应用程序不太可重用。通常方便的做法是在每个应用程序中放置一个URLConf（通常在`urls.py`文件中）。然后，根URLConf可以使用`include()`函数来包含其他应用程序的URLConfs以路由请求。
- en: 'Let''s create a URLConf for our `qanda` app in `django/qanda/urls.py`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/urls.py`中为我们的`qanda`应用程序创建一个URLConf：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A path has at least two components:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 路径至少有两个组件：
- en: First, a string defining the matching path. This may have named parameters that
    will be passed to the view. We'll see an example of this later, in the *Routing
    requests to the QuestionDetail view* section.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，是定义匹配路径的字符串。这可能有命名参数，将传递给视图。稍后我们将在*将请求路由到QuestionDetail视图*部分看到一个例子。
- en: Second, a callable that takes a request and returns a response. If your view
    is a function (also known as a **Function-Based View** (**FBV**)), then you can
    just pass a reference to your function. If you're using a **Class-Based View**
    (**CBV**), then you can use its `as_view()` class method to return the required
    callable.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，是一个接受请求并返回响应的可调用对象。如果您的视图是一个函数（也称为**基于函数的视图**（**FBV**）），那么您可以直接传递对函数的引用。如果您使用的是**基于类的视图**（**CBV**），那么您可以使用其`as_view()`类方法来返回所需的可调用对象。
- en: Optionally, a `name` parameter which we can use to reference this `path()` object
    in our view or template (for example, like the `Question` model does in its `get_absolute_url()`
    method).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`name`参数，我们可以在视图或模板中引用这个`path()`对象（例如，就像`Question`模型在其`get_absolute_url()`方法中所做的那样）。
- en: It is very strongly recommended that you name all your `path()` objects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议为所有的`path()`对象命名。
- en: 'Now, let''s update our root URLConf to include the `qanda` URLConf:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的根URLConf以包括`qanda`的URLConf：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This means that requests to `answerly.example.com/ask` will route to our `AskQuestionView.`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对`answerly.example.com/ask`的请求将路由到我们的`AskQuestionView`。
- en: A quick review of the section
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本节的快速回顾
- en: 'In this section, we have performed the following actions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们执行了以下操作：
- en: Created our first form, `QuestionForm`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了我们的第一个表单，`QuestionForm`
- en: Created `AskQuestionView` that uses the `QuestionForm` to create `Question`
    s
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了使用`QuestionForm`创建`Question`的`AskQuestionView`
- en: Created a template to render `AskQuestionView` and `QuestionForm`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个模板来渲染`AskQuestionView`和`QuestionForm`
- en: Installed and configured third-party libraries that provide filters for our
    template
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置了为我们的模板提供过滤器的第三方库
- en: Now, let’s allow our users to view questions with a `QuestionDetailView` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们允许我们的用户使用`QuestionDetailView`类查看问题。
- en: Creating QuestionDetailView
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建QuestionDetailView
- en: 'The `QuestionDetailView` has to offer quite a bit of functionality. It must
    be able to do the following things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestionDetailView`必须提供相当多的功能。它必须能够执行以下操作：'
- en: Show the question
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示问题
- en: Show all the answers
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有答案
- en: Let users post additional answers
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户发布额外的答案
- en: Let the asker accept answer(s)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让提问者接受答案
- en: Let the asker reject previously-accepted answers
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让提问者拒绝先前接受的答案
- en: Although `QuestionDetailView` won't process any forms, it will have to display
    many forms, leading to a complicated template. This complexity will give us a
    chance to note how to split a template up into separate subtemplates to make our
    code more readable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`QuestionDetailView`不会处理任何表单，但它必须显示许多表单，导致一个复杂的模板。这种复杂性将给我们一个机会来注意如何将模板分割成单独的子模板，以使我们的代码更易读。
- en: Creating Answer forms
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建答案表单
- en: 'We’ll need to make two forms to make `QuestionDetailView` work as described
    in the preceding section:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要制作两个表单，以使`QuestionDetailView`按照前一节的描述工作：
- en: '`AnswerForm`: For users to post their answers'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnswerForm`：供用户发布他们的答案'
- en: '`AnswerAcceptanceForm`: For the question''s asker to accept or reject answers'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnswerAcceptanceForm`：供问题的提问者接受或拒绝答案'
- en: Creating AnswerForm
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AnswerForm
- en: The `AnswerForm` will have to reference a `Question` model instance and a user
    because both are required to create an `Answer` model instance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnswerForm`将需要引用一个`Question`模型实例和一个用户，因为这两者都是创建`Answer`模型实例所必需的。'
- en: 'Let''s add our `AnswerForm` to `django/qanda/forms.py`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`AnswerForm`添加到`django/qanda/forms.py`中：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AnswerForm` class looks a lot like the `QuestionForm` class, though with
    slightly differently named fields. It uses the same technique of preventing a
    user from tampering with the `Question` associated with an `Answer` just as `QuestionForm`
    used to prevent tampering with the user of `Question`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnswerForm`类看起来很像`QuestionForm`类，尽管字段的命名略有不同。它使用了与`QuestionForm`相同的技术，防止用户篡改与`Answer`相关联的`Question`，就像`QuestionForm`用于防止篡改`Question`的用户一样。'
- en: Next, we'll create a form to accept an `Answer`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个接受`Answer`的表单。
- en: Creating AnswerAcceptanceForm
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AnswerAcceptanceForm
- en: 'An `Answer` is accepted if its `accepted` field is `True`. We''ll use a simple
    form to edit this field:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`accepted`字段为`True`，则`Answer`被接受。我们将使用一个简单的表单来编辑这个字段：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using `BooleanField` comes with a small wrinkle. If we want `BooleanField` to
    accept `False` values as well as `True` values, we must set `required=False`.
    Otherwise, `BooleanField` will get confused when it gets a `False` value, thinking
    that it actually didn’t receive a value.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BooleanField`会有一个小问题。如果我们希望`BooleanField`接受`False`值以及`True`值，我们必须设置`required=False`。否则，`BooleanField`在接收到`False`值时会感到困惑，认为它实际上没有收到值。
- en: We use a hidden input because we don't want users checking a checkbox and then
    having to click on submit. Instead, for each answer, we'll generate an accept
    form and a reject form, which the user can just submit with one click.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个隐藏的输入，因为我们不希望用户勾选复选框然后再点击提交。相反，对于每个答案，我们将生成一个接受表单和一个拒绝表单，用户只需点击一次即可提交。
- en: Next, let's write the `QuestionDetailView` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`QuestionDetailView`类。
- en: Creating QuestionDetailView
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建QuestionDetailView
- en: 'Now that we have the forms we''ll use, we can create `QuestionDetailView` in
    `django/qanda/views.py`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了要使用的表单，我们可以在`django/qanda/views.py`中创建`QuestionDetailView`：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`QuestionDetailView` lets Django''s `DetailView` do most of the work. `DetailView`
    gets a `Question` `QuerySet` out of the default manager of `Question` (`Question.objects`).
    `DetailView` then uses the `QuerySet` to get a `Question` based on the `pk` it
    received in the path of the URL. `DetailView` also knows which template to render
    based on our app and model name (`appname/modelname_detail.html`).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestionDetailView`让Django的`DetailView`完成大部分工作。`DetailView`从`Question`的默认管理器（`Question.objects`）中获取一个`Question`的`QuerySet`。然后，`DetailView`使用`QuerySet`根据URL路径中收到的`pk`获取一个`Question`。`DetailView`还根据我们的应用程序和模型名称（`appname/modelname_detail.html`）知道要渲染哪个模板。'
- en: The only area where we've had to customize behavior of `DetailView` is `get_context_data()`.
    `get_context_data()` provides the context used to render the template. In our
    case, we use the method to add the forms we want rendered to context.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要自定义`DetailView`行为的地方是`get_context_data（）`。`get_context_data（）`提供用于呈现模板的上下文。在我们的情况下，我们使用该方法将要呈现的表单添加到上下文中。
- en: Next, let's make the template for `QuestionDetailView`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为`QuestionDetailView`创建模板。
- en: Creating question_detail.html
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建question_detail.html
- en: Our template for the `QuestionDetailView` will work slightly differently to our
    previous templates.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`QuestionDetailView`模板将与我们以前的模板略有不同。
- en: 'Here''s what we''ll put in `django/qanda/templates/qanda/question_detail.html`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将放入`django/qanda/templates/qanda/question_detail.html`中的内容：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding template seemingly doesn’t do anything itself. Instead, we use
    the `{% include %}` tag to include other templates inside this template, to make
    organizing our code simpler. `{% include %}` passes the current context to the
    new template, renders it, and inserts it in place.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板似乎并没有做任何事情。相反，我们使用`{% include %}`标签将其他模板包含在此模板中，以使我们的代码组织更简单。`{% include
    %}`将当前上下文传递给新模板，呈现它，并将其插入到指定位置。
- en: Let's take a look at each of these sub templates in turn, staring with `dispaly_question.html`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看这些子模板，从`dispaly_question.html`开始。
- en: Creating the display_question.html common template
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建display_question.html通用模板
- en: We’ve put the HTML to display a question into its own sub template. This template
    can then be included by other templates to render a `question`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将显示问题的HTML放入了自己的子模板中。然后其他模板可以包含此模板，以呈现问题。
- en: 'Let''s create it in `django/qanda/templates/qanda/common/display_question.html`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/templates/qanda/common/display_question.html`中创建它：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The HTML itself is pretty simple, and there are no new tags here. We reuse the
    `markdownify` tag and library that we have previously configured.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: HTML本身非常简单，在这里没有新标签。我们重用了之前配置的`markdownify`标签和库。
- en: Next, let's look at the answer list template.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下答案列表模板。
- en: Creating list_answers.html
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建list_answers.html
- en: The answer list template has to list all the answers for the question and also
    render whether the answer is accepted. If the user can accept (or reject) answers,
    then those forms are rendered too.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 答案列表模板必须列出问题的所有答案，并渲染答案是否被接受。如果用户可以接受（或拒绝）答案，那么这些表单也会被呈现。
- en: 'Let’s create the template in `django/qanda/templates/qanda/view_questions/question_answers.html`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/templates/qanda/view_questions/question_answers.html`中创建模板：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Two things to observe about this template are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个模板有两件事需要注意：
- en: There's a rare bit of logic in the template, `{% if answer.accepted and reject_form
    %}`. Generally, templates should be dumb and avoid knowing about business logic.
    However, avoiding this would have created a more complex view. This is a trade-off
    that we must always evaluate on a case-by-case basis.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板中有一个罕见的逻辑，`{% if answer.accepted and reject_form %}`。通常，模板应该是简单的，避免了解业务逻辑。然而，避免这种情况会创建一个更复杂的视图。这是我们必须始终根据具体情况评估的权衡。
- en: The `{% empty %}` tag is related to our `{% for answer in question.answer_set.all
    %}` loop. The `{% empty %}` is used in the case of an empty list, much like the
    Python's `for ... else` syntax.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% empty %}`标签与我们的`{% for answer in question.answer_set.all %}`循环有关。`{% empty
    %}`在列表为空的情况下使用，就像Python的`for ... else`语法一样。'
- en: Next, let's take a look at the post answer template.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下发布答案模板。
- en: Creating the post_answer.html template
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建post_answer.html模板
- en: In the next template we're going to create, the user can post and preview their
    answer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来要创建的模板中，用户可以发布和预览他们的答案。
- en: 'Let''s create our next template in `django/qanda/templates/qanda/common/post_answer.html`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/templates/qanda/common/post_answer.html`中创建我们的下一个模板：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This template is quite simple, sampling rendering the `answer_form` using the `crispy`
    filter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板非常简单，使用`crispy`过滤器对`answer_form`进行渲染。
- en: Now that we have all our subtemplates done, let's create a `path` to route requests
    to `QuestionDetailView`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的子模板都完成了，让我们创建一个`path`来将请求路由到`QuestionDetailView`。
- en: Routing requests to the QuestionDetail view
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到QuestionDetail视图
- en: 'To be able to route requests to our `QuestionDetailView`, we need to add it
    to the URLConf in `django/qanda/urls.py`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将请求路由到我们的`QuestionDetailView`，我们需要将其添加到`django/qanda/urls.py`中的URLConf：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we see `path` taking a named parameter `pk`, which must
    be an integer. This will be passed to the `QuestionDetailView` and available in
    the `kwargs` dictionary. `DetailView` will rely on the presence of this argument
    to know which `Question` to retrieve.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们看到`path`使用了一个名为`pk`的参数，它必须是一个整数。这将传递给`QuestionDetailView`并在`kwargs`字典中可用。`DetailView`将依赖于此参数的存在来知道要检索哪个`Question`。
- en: Next, we'll create some of the form-related views we referenced in our templates.
    Let's start with the `CreateAnswerView` class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些我们在模板中引用的与表单相关的视图。让我们从`CreateAnswerView`类开始。
- en: Creating the CreateAnswerView
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CreateAnswerView
- en: The `CreateAnswerView` class will be used to create and preview `Answer` model
    instance for a `Question` model instance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAnswerView`类将用于为`Question`模型实例创建和预览`Answer`模型实例。'
- en: 'Let''s create it in `django/qanda/views.py`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/views.py`中创建它：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `CreateAnswerView` class follows a similar pattern to the `AskQuestionView` class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAnswerView`类遵循与`AskQuestionView`类类似的模式：'
- en: It's a `CreateView`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个`CreateView`
- en: It’s protected by `LoginRequiredMixin`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它受`LoginRequiredMixin`保护
- en: It uses `get_initial()` to provide initial arguments to its form so malicious
    users can't tamper with the question or user associated with the answer
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`get_initial（）`为其表单提供初始参数，以便恶意用户无法篡改与答案相关的问题或用户
- en: It uses `form_valid()` to perform a preview or save operation
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`form_valid（）`来执行预览或保存操作
- en: The main difference is that we will need to add a `get_question()` method in `CreateAnswerView` to
    retrieve the question we're answering. `kwargs['pk']` will be populated by the
    `path` we'll create (just like we did for `QuestionDetailView`).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别是我们需要在 `CreateAnswerView` 中添加一个 `get_question()` 方法来检索我们要回答的问题。`kwargs['pk']`
    将由我们将创建的 `path` 填充（就像我们为 `QuestionDetailView` 做的那样）。
- en: Next, let's create the template.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建模板。
- en: Creating create_answer.html
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 create_answer.html
- en: This template will be able to leverage the common template elements we've already
    created to make rendering the question and answer forms easier.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将能够利用我们已经创建的常见模板元素，使渲染问题和答案表单更容易。
- en: 'Let''s create it in `django/qanda/templates/qanda/create_answer.html`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `django/qanda/templates/qanda/create_answer.html` 中创建它：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding template introduces a new use of `{% include %}`. When we use
    the `with` argument, we can then pass a series of new names that values should
    have in the subtemplate’s context. In our case, we will only add the `answer_form`
    to the context of `post_answer.html`. The rest of the context is still passed
    to `{% include %}`. We can prevent the rest of the context being passed if we
    add `only` as the last argument to `{% include %}`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板介绍了 `{% include %}` 的新用法。当我们使用 `with` 参数时，我们可以传递一系列新名称，这些值应该在子模板的上下文中具有。在我们的情况下，我们只会将
    `answer_form` 添加到 `post_answer.html` 的上下文中。其余的上下文仍然被传递给 `{% include %}`。如果我们在
    `{% include %}` 的最后一个参数中添加 `only`，我们可以阻止其余的上下文被传递。
- en: Routing requests to CreateAnswerView
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到 CreateAnswerView
- en: 'The final step is to connect the `CreateAnswerView` to the `qanda` URLConf
    by adding a new `path` to the `urlpatterns` list in `qanda/urls.py`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是通过在 `qanda/urls.py` 的 `urlpatterns` 列表中添加一个新的 `path` 来将 `CreateAnswerView`
    连接到 `qanda` URLConf 中：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we’ll make a view to process the `AnswerAcceptanceForm`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个视图来处理 `AnswerAcceptanceForm`。
- en: Creating UpdateAnswerAcceptanceView
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 UpdateAnswerAcceptanceView
- en: 'The `accept_form` and `reject_form` variables we use in the `list_answers.html`
    template need a view to process their form submissions. Let’s add it to `django/qanda/views.py`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `list_answers.html` 模板中使用的 `accept_form` 和 `reject_form` 变量需要一个视图来处理它们的表单提交。让我们将其添加到
    `django/qanda/views.py` 中：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`UpdateView` works like a mix of `DetailView` (since it works on a single model)
    and `CreateView` (since it processes a form). Both `CreateView` and `UpdateView`
    share a common ancestor: `ModelFormMixin`. `ModelFormMixin` provides us with the
    hooks we’ve used so often in the past: `form_valid()`, `get_success_url()`, and
    `form_invalid()`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateView` 的工作方式类似于 `DetailView`（因为它在单个模型上工作）和 `CreateView`（因为它处理一个表单）。`CreateView`
    和 `UpdateView` 共享一个共同的祖先：`ModelFormMixin`。`ModelFormMixin` 为我们提供了我们过去经常使用的钩子：`form_valid()`、`get_success_url()`
    和 `form_invalid()`。'
- en: Thanks to the simplicity of this form, we will just respond to an invalid form
    by redirecting the user to the question.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个表单的简单性，我们将通过将用户重定向到问题来响应无效的表单。
- en: 'Next, let''s add it to our URLConf in `django/qanda/urls.py` file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将其添加到我们的 URLConf 中的 `django/qanda/urls.py` 文件中：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Remember to have a parameter named `pk` in your `path()` object's first argument
    so that `UpdateView` can retrieve the correct `Answer`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在你的 `path()` 对象的第一个参数中有一个名为 `pk` 的参数，这样 `UpdateView` 就可以检索到正确的 `Answer`。
- en: Next, let's create a daily list of questions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个每日问题列表。
- en: Creating the daily questions page
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建每日问题页面
- en: To help people find questions, we'll create a list of each day's questions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助人们找到问题，我们将创建每天问题的列表。
- en: Django offers views to create yearly, monthly, weekly, and daily archive views.
    In our case, we'll use the `DailyArchiveView`, but they all work basically the
    same. They take a date from the URL's path and search for everything related during
    that period.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了创建年度、月度、周度和每日归档视图的视图。在我们的情况下，我们将使用 `DailyArchiveView`，但它们基本上都是一样的。它们从
    URL 的路径中获取一个日期，并在该期间搜索所有相关内容。
- en: Let's build a daily question list using Django's `DailyArchiveView`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Django 的 `DailyArchiveView` 来构建一个每日问题列表。
- en: Creating DailyQuestionList view
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 DailyQuestionList 视图
- en: 'Let''s add our `DailyQuestionList` view to `django/qanda/views.py`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的 `DailyQuestionList` 视图添加到 `django/qanda/views.py` 中：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`DailyQuestionList` need not override any methods of `DayArchiveView` just
    to let Django do the work. Let''s look at how it does it.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`DailyQuestionList` 不需要覆盖 `DayArchiveView` 的任何方法，只需让 Django 做这项工作。让我们看看它是如何做到的。'
- en: '`DayArchiveView` expects to get a day, month, and year in the URL''s path.
    We can specify the format of these using `day_format`, `month_format`, and `year_format`.
    In our case, we change the expected format to `''%m''` so that the month is parsed
    as a number instead of the default `''%b''`, which is the short name of the month.
    These formats are the same, Python''s standard `datetime.datetime.strftime`. Once
    `DayArchiveView` has the date, it uses that date to filter the provided `queryset`
    using field named in the `date_field` attribute. The `queryset` is ordered by
    date. If `allow_empty` is `True`, then results will be rendered, otherwise a 404
    exception is thrown, for days with no items to list. To render the template, the
    object list is passed to the template much like a `ListView`. The default template
    is assumed to follow the `appname/modelname_archive_day.html` format.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`DayArchiveView` 期望在URL的路径中获取一个日期、月份和年份。我们可以使用 `day_format`、`month_format`
    和 `year_format` 来指定这些的格式。在我们的情况下，我们将期望的格式更改为 `''%m''`，这样月份就会被解析为一个数字，而不是默认的 `''%b''`，这是月份的简称。这些格式与
    Python 的标准 `datetime.datetime.strftime` 相同。一旦 `DayArchiveView` 有了日期，它就会使用该日期来过滤提供的
    `queryset`，使用在 `date_field` 属性中命名的字段。`queryset` 按日期排序。如果 `allow_empty` 为 `True`，那么结果将被渲染，否则将抛出
    404 异常，对于没有要列出的项目的日期。为了渲染模板，对象列表被传递到模板中，就像 `ListView` 一样。默认模板假定遵循 `appname/modelname_archive_day.html`
    的格式。'
- en: Next, let's create the template for this view.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为这个视图创建模板。
- en: Creating the daily question list template
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建每日问题列表模板
- en: 'Let''s add our template to `django/qanda/templates/qanda/question_archive_day.html`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的模板添加到 `django/qanda/templates/qanda/question_archive_day.html` 中：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The list of questions is much like one would expect, that is, a `<ul>` tag with
    a `{% for %}` loop creating `<li>` tags with links.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 问题列表就像人们所期望的那样，即一个带有 `{% for %}` 循环创建 `<li>` 标签和链接的 `<ul>` 标签。
- en: One of the conveniences of the `DailyArchiveView` (and all the date archive
    views) is that they provide their template's context with next and previous dates.
    These dates let us create a kind of pagination across dates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`DailyArchiveView`（以及所有日期存档视图）的一个便利之处是它们提供其模板的上下文，包括下一个和上一个日期。这些日期让我们在日期之间创建一种分页。'
- en: Routing requests to DailyQuestionLists
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求路由到DailyQuestionLists
- en: 'Finally, we''ll create a `path` to our `DailyQuestionList` view so that we
    can route requests to it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`path`到我们的`DailyQuestionList`视图，以便我们可以将请求路由到它：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, let's create a view to represent *today'*s questions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个视图来代表*今天*的问题。
- en: Getting today’s question list
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取今天的问题列表
- en: Having a daily archive is good, but we want to provide a convenient way to access
    today's archive. We'll use a `RedirectView` to always redirect the user to the
    `DailyQuestionList` of today’s date.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有每日存档是很好的，但我们希望提供一种方便的方式来访问今天的存档。我们将使用`RedirectView`来始终将用户重定向到今天日期的`DailyQuestionList`。
- en: 'Let''s add it to `django/qanda/views.py`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到`django/qanda/views.py`中：
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`RedirectView` is a simple view that returns a 301 or 302 redirect response.
    We use Django’s `django.util.timezone` to get today''s date according to how Django
    has been configured. By default, Django is configured using **Coordinated Universal
    Time** (**UTC**). Due to the complexity of time zones, it''s often simplest to
    track everything in UTC and then adjust the display on the client side.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedirectView`是一个简单的视图，返回301或302重定向响应。我们使用Django的`django.util.timezone`根据Django的配置获取今天的日期。默认情况下，Django使用**协调世界时**（**UTC**）进行配置。由于时区的复杂性，通常最简单的方法是在UTC中跟踪所有内容，然后在客户端上调整显示。'
- en: We've now created all the views for our initial `qanda` app, letting users ask
    and answer questions. The asker can also accept answer(s) to their question.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为我们的初始`qanda`应用程序创建了所有的视图，让用户提问和回答问题。提问者还可以接受问题的答案。
- en: Next, let's actually let the users log in, log out, and register with a `user`
    app.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们让用户实际上可以使用`user`应用程序登录、注销和注册。
- en: Creating the user app
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户应用程序
- en: As we mentioned before, a Django app should have a clear scope. To that end,
    we'll create a separate Django app to manage users, which we will call `user`.
    We shouldn't place our user management code in `qanda` or the `Question` model
    in the `user` app.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Django应用程序应该有一个明确的范围。为此，我们将创建一个单独的Django应用程序来管理用户，我们将其称为`user`。我们不应该将我们的用户管理代码放在`qanda`或者`user`应用程序中的`Question`模型。
- en: 'Let''s create the app using `manage.py`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`manage.py`创建应用：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, add it to our list of `INSTALLED_APPS` in `django/config/settings.py`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其添加到`django/config/settings.py`的`INSTALLED_APPS`列表中：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It's particularly important to keep the `user` app *before* the `admin` app,
    as they will both define login templates. The app that comes first will have their
    login template resolved first. We don't want our users redirected to the admin
    app.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是要将`user`应用程序*放在*`admin`应用程序之前，因为它们都将定义登录模板。先到达的应用程序将首先解析其登录模板。我们不希望我们的用户被重定向到管理员应用程序。
- en: 'Next, let''s create a URLConf for our `user` app in `django/user/urls.py`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`django/user/urls.py`中为我们的`user`应用程序创建一个URLConf：
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we''ll have the main URLConf in `django/config/urls.py` include the `user`
    app''s URLConf:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`django/config/urls.py`中的主URLConf中包含`user`应用程序的URLConf：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that we have our app configured, we can add our login and logout views.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的应用程序，我们可以添加我们的登录和注销视图。
- en: Using Django's LoginView and LogoutView
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django的LoginView和LogoutView
- en: 'To provide the login and logout functionalities, we''ll use views provided
    by the `django.contrib.auth` app. Let''s update the `django/users/urls.py` to
    reference them:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供登录和注销功能，我们将使用`django.contrib.auth`应用提供的视图。让我们更新`django/users/urls.py`来引用它们：
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These views take care of logging a user in and out. However, the login view
    requires a template to render nicely. The `LoginView` expects it under the `registration/login.html`
    name.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图负责登录和注销用户。然而，登录视图需要一个模板来渲染得漂亮。`LoginView`期望它在`registration/login.html`名称下。
- en: 'We''ll put our template in `django/user/templates/registration/login.html`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模板放在`django/user/templates/registration/login.html`中：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `LogoutView` doesn't require a template.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogoutView`不需要一个模板。'
- en: 'Now, we will need to inform our Django project''s `settings.py` about the login
    view''s location and the function it should perform when the user logs in and
    out. Let’s add some settings to `django/config/settings.py`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通知我们Django项目的`settings.py`关于登录视图的位置以及用户登录和注销时应执行的功能。让我们在`django/config/settings.py`中添加一些设置：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This way, the `LoginRequiredMixin` can know the view to which we need to redirect
    unauthenticated users. We are also informing `LoginView` and `LogoutView` of  `django.contrib.auth` where
    to redirect the user when they log in and log out, respectively.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`LoginRequiredMixin`就可以知道我们需要将未经身份验证的用户重定向到哪个视图。我们还通知了`django.contrib.auth`的`LoginView`和`LogoutView`在用户登录和注销时分别将用户重定向到哪里。
- en: Next, let's give users a way to register for our site.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为用户提供一种注册网站的方式。
- en: Creating RegisterView
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RegisterView
- en: 'Django doesn''t provide a user registration view, but it does offer a `UserCreationForm`
    if we''re using `django.conrib.auth.models.User` as our user model. Since we are
    using `django.conrib.auth.models.User` we can use a simple `CreateView` for our
    registration view:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Django不提供用户注册视图，但如果我们使用`django.conrib.auth.models.User`作为用户模型，它确实提供了一个`UserCreationForm`。由于我们使用`django.conrib.auth.models.User`，我们可以为我们的注册视图使用一个简单的`CreateView`：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we just need to create a template at `django/user/templates/register.html`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在`django/user/templates/register.html`中创建一个模板：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, our template is following a familiar pattern similar what we've seen
    in past views. We use our base template, blocks, and Django Crispy Form to create
    our page quickly and simply.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的模板遵循了一个熟悉的模式，类似于我们在过去的视图中看到的。我们使用我们的基本模板、块和Django Crispy Form来快速简单地创建我们的页面。
- en: 'Finally, we can add a `path` to the view in the `user` URLConf''s `urlpatterns`
    list:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`user` URLConf的`urlpatterns`列表中添加一个`path`到该视图：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Updating base.html navigation
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新base.html导航
- en: 'Now that we have created all our views, we can update our base template''s
    `<nav>` to list all our URLs:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有的视图，我们可以更新我们基础模板的`<nav>`来列出所有我们的URL：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Great! Now our user can always reach the most important pages on our site.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们的用户可以随时访问我们网站上最重要的页面。
- en: Running the development server
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: 'Finally, we can access our development server using the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下命令访问我们的开发服务器：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we can open the site in a browser at [http://localhost:8000/](http://localhost::8000/).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在浏览器中打开网站 [http://localhost:8000/](http://localhost::8000/)。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started our Answerly project. Answerly is composed of two
    apps (`user` and `qanda`), two third-party apps installed via PyPI (Markdownify
    and Django Crispy Forms), and a number of Django's built-in apps (`django.contrib.auth`
    being used most directly).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了Answerly项目。Answerly由两个应用程序（`user`和`qanda`）组成，通过PyPI安装了两个第三方应用程序（Markdownify和Django
    Crispy Forms），以及一些Django内置应用程序（`django.contrib.auth`被直接使用）。
- en: A logged-in user can now ask a question, answer questions, and accept answers.
    We can also see each day's highest-voted questions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 已登录用户现在可以提问，回答问题，并接受答案。我们还可以看到每天投票最高的问题。
- en: Next, we'll help users discover questions more easily by adding search functionality
    using ElasticSearch.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用ElasticSearch添加搜索功能，帮助用户更轻松地发现问题。
