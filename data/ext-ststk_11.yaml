- en: Chapter 11. Extending the Master
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。扩展Master
- en: Even though some of the modules that we've written so far can be used on the
    Master, the focus has still been entirely on managing Minion-based operations.
    Even runners, which only run on the Master, were originally designed to script
    tasks between Minions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止编写的一些模块可以在Master上使用，但焦点仍然完全集中在基于Minion的操作管理上。即使是只在Master上运行的runners，最初也是为了在Minion之间脚本化任务而设计的。
- en: 'There are two types of modules that are designed entirely for Master-side work:
    external authentication modules and wheel modules. In this chapter, we''ll go
    over:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种模块完全是为Master端工作而设计的：外部认证模块和轮模块。在本章中，我们将介绍：
- en: Adding external authentication to the Master
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Master添加外部认证
- en: Troubleshooting external authentication modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部认证模块故障排除
- en: Managing Master configuration with wheel modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轮模块管理Master配置
- en: Troubleshooting wheel modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮模块故障排除
- en: Using external authentication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部认证
- en: 'In its default setup, users only communicate with Salt with one user: usually
    either `root` or `salt`. Any user who has access to log in as that user will be
    able to issue Salt commands. This may be OK with smaller setups, but it does not
    scale well at all. Larger organizations will want each user to manage Salt with
    their own login, and be able to set access controls on a per-user basis. There
    are also other programs, including Salt API, which require the use of external
    authentication modules.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在其默认设置中，用户通常只使用一个用户与Salt通信：通常是`root`或`salt`。任何能够以该用户身份登录的用户都将能够发出Salt命令。对于较小的设置，这可能没问题，但它根本无法扩展。较大的组织希望每个用户都能使用自己的登录来管理Salt，并且能够根据用户设置访问控制。还有其他程序，包括Salt
    API，需要使用外部认证模块。
- en: '**External authentication** (or **auth or eauth**) modules allow individual
    users to have their own permissions to the various components of Salt. The simplest
    is probably the `pam` module, in part because other existing access control mechanisms
    can be configured inside PAM itself. Unfortunately, PAM is rarely used outside
    of Linux, so other modules are needed on other platforms.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部认证**（或**auth**或**eauth**）模块允许单个用户对Salt的各个组件拥有自己的权限。最简单的大概是`pam`模块，部分原因是因为其他现有的访问控制机制可以在PAM内部进行配置。不幸的是，PAM很少在Linux之外使用，因此在其他平台上需要其他模块。'
- en: Authenticating credentials
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证凭证
- en: On the surface, an auth module doesn't need to do much. It only needs to accept
    a username and password, and check with the appropriate service to ensure that
    it is valid. If it is, then it returns `True`. Otherwise, it will return `False`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，认证模块不需要做太多。它只需要接受一个用户名和一个密码，并检查适当的服务以确保其有效性。如果是，则返回`True`。否则，它将返回`False`。
- en: 'Let''s go ahead and set up an auth module for a fictional web service that
    accepts a username and password, and returns a status of `200` (`OK`) if they
    are correct and `403` (`FORBIDDEN`) if they are not. As with some of the other
    module types, there is a required function in auth modules. This one is called
    `auth()`. Let''s go ahead and look at our entire auth module at once:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为一家虚构的、接受用户名和密码的Web服务设置一个认证模块，如果它们正确，则返回状态`200`（`OK`），如果不正确，则返回`403`（`FORBIDDEN`）。与其他一些模块类型一样，认证模块中有一个必需的函数。这个函数叫做`auth()`。让我们一次性查看整个认证模块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our function declaration has two required arguments: username and password.
    These will be sent to the authentication service to check their validity. Our
    service doesn''t just accept arbitrary credentials; it requires an account to
    be set up first, with its own authentication, which stores the username and password.
    So, our first job is to grab the credentials for that service (`apiid` and `apikey`)
    from the master configuration. Then add in the URL to be used for the authentication
    check:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能声明有两个必需的参数：用户名和密码。这些信息将被发送到认证服务以检查其有效性。我们的服务不仅仅接受任意的凭证；它要求首先设置一个账户，并拥有自己的认证，该认证存储用户名和密码。因此，我们的首要任务是抓取该服务的凭证（`apiid`和`apikey`）从主配置中。然后添加用于认证检查的URL：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We want to be able to accept special characters in either the username or password,
    but since they won''t translate properly over the wire, we use Python''s `urllib`
    library to add quoting to them. Then we format the credentials in the way that
    the external web service expects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在用户名或密码中接受特殊字符，但由于它们在网络上无法正确翻译，我们使用Python的`urllib`库为它们添加引号。然后我们以外部Web服务期望的方式格式化凭证：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have all of the data set up to pass to the web service, we use
    the `http.query()` function to make the call. `apiid` and `apikey` are used as
    the username and password to the service itself, and the user''s username and
    password are set along as a JSON string. We also make sure to tell `http.query()`
    to return a status code, since that is the only part of the result that we care
    about:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有要传递给 Web 服务的数据，我们使用 `http.query()` 函数进行调用。`apiid` 和 `apikey` 用作服务本身的用户名和密码，用户的用户名和密码也作为
    JSON 字符串设置。我们还确保告诉 `http.query()` 返回状态码，因为这是我们唯一关心的结果部分：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have an authentication code, we check to see if it''s `200`. If something
    goes wrong and there is no code, then we default the value to `403`, but when
    it comes down to it, anything other than `200` means that the credentials will
    be considered invalid:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了认证代码，我们会检查它是否为 `200`。如果出现问题且没有代码，则默认值为 `403`，但归根结底，除了 `200` 以外的任何代码都意味着凭证将被视为无效：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Troubleshooting external authentication
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除外部身份验证
- en: Troubleshooting `auth` modules is a little different from other types of module,
    because what you're testing is the ability to access a command, not the functionality
    of the resulting command. This means that the command that you choose to execute
    should be one that is already known to work, such as `test.ping`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除 `auth` 模块与其他类型的模块略有不同，因为你所测试的是访问命令的能力，而不是结果命令的功能。这意味着你选择的要执行的命令应该是已知可以正常工作的，例如
    `test.ping`。
- en: Setting auth parameters
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置认证参数
- en: 'Before you can use an `auth` module, you need to enable it in the master configuration
    file. Multiple auth modules can be configured, using the `external_auth` directive:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用 `auth` 模块之前，你需要在主配置文件中启用它。可以使用 `external_auth` 指令配置多个认证模块：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we have three users set, between two different `auth` modules.
    The `moe` and `larry` users are set to use the `pam` module, and the `shemp` user
    is set to use the `webauth` module that we just created. The `moe` user has access
    to all execution modules, plus the runner and wheel systems, while `larry`'s execution
    module access is limited to the `test`, `disk`, and `network` modules. The `shemp`
    user is the same as `larry`, minus access to the `disk` module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们设置了三个用户，分布在两个不同的 `auth` 模块之间。`moe` 和 `larry` 用户被设置为使用 `pam` 模块，而 `shemp`
    用户被设置为使用我们刚刚创建的 `webauth` 模块。`moe` 用户可以访问所有执行模块，以及 runner 和 wheel 系统，而 `larry`
    的执行模块访问权限仅限于 `test`、`disk` 和 `network` 模块。`shemp` 用户与 `larry` 相同，只是没有访问 `disk`
    模块的权限。
- en: Keep in mind that Salt API requires `@runner` and `@wheel` to be set. If you
    are not planning on giving users access to resources using Salt API, then you
    can skip those two lines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Salt API 需要 `@runner` 和 `@wheel` 被设置。如果你不打算使用 Salt API 向用户授予资源访问权限，那么你可以跳过这两行。
- en: 'Once you have `external_auth` configured, there are two means of testing `auth`
    modules: using the `salt` command on the Master, and using Salt API.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了 `external_auth`，就有两种测试 `auth` 模块的方法：在 Master 上使用 `salt` 命令，以及使用 Salt
    API。
- en: Testing with the salt command
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 salt 命令进行测试
- en: 'The fastest way to test an `auth` module is to log in to the Master with the
    account that the `salt-master` service is running as and issue a `salt` command,
    with the appropriate arguments to set which `auth` module is to be used, and which
    credentials to use:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `auth` 模块最快的方法是登录到以 `salt-master` 服务运行的 Master 账户，并发出一个 `salt` 命令，使用适当的参数设置要使用的
    `auth` 模块和要使用的凭证：
- en: '`--auth` or `-a`: This argument sets which auth module to use. The default
    argument for this is `pam`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--auth` 或 `-a`：此参数设置要使用的认证模块。此参数的默认值是 `pam`。'
- en: '`--username`: The username to authenticate with.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--username`：用于认证的用户名。'
- en: '`--password`: The password to authenticate with.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--password`：用于认证的密码。'
- en: 'Assuming that you''re testing with the `webauth` module that we just created,
    a basic `salt` command will look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用我们刚刚创建的 `webauth` 模块进行测试，一个基本的 `salt` 命令看起来像这样：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Testing with Salt API
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Salt API 进行测试
- en: You can also test `auth` modules using Salt API. This can be easily accomplished
    using the `curl` command that is commonly available in Linux. Before you can test
    using this method, you need to configure Salt API inside the `master` configuration
    file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Salt API 测试 `auth` 模块。这可以通过在 Linux 中常见的 `curl` 命令轻松实现。在你可以使用此方法测试之前，你需要配置
    `master` 配置文件中的 Salt API。
- en: 'Please note that the following configuration block is insecure, as it does
    not use SSL. Never set `disable_ssl` to `True` in production! As a safety measure,
    this configuration block also sets Salt API to only listen to requests from the
    local host:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下配置块是不安全的，因为它没有使用 SSL。在生产环境中，切勿将 `disable_ssl` 设置为 `True`！作为一个安全措施，此配置块还将
    Salt API 设置为仅监听来自本地主机的请求：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have Salt API configured, go ahead and start the `salt-master` and
    `salt-api` services in the foreground (in two different windows):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置好 Salt API，请继续在两个不同的窗口中启动前台运行的 `salt-master` 和 `salt-api` 服务：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the following `curl` command to run the `test.ping` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 `curl` 命令运行 `test.ping` 函数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The most important arguments here are `eauth`, which is equivalent to the `--auth`
    parameter from the `salt` command, and `client`, which specifies which type of
    module to access. Here, we use `local`, which refers to execution modules. Some
    of the other available arguments are `runner` and `wheel`, for runner and wheel
    modules.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的参数是 `eauth`，它等同于 `salt` 命令中的 `--auth` 参数，以及 `client`，它指定要访问的模块类型。在这里，我们使用
    `local`，它指的是执行模块。其他一些可用的参数是 `runner` 和 `wheel`，分别用于运行者和 wheel 模块。
- en: 'When you issue the preceding command with the correct credentials, you will
    receive a JSON string back with the result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用正确的凭据执行前面的命令时，您将收到一个包含结果的 JSON 字符串：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you issue it with bad credentials, you will receive an error page that includes
    the following text:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用错误的凭据执行它，您将收到一个包含以下文本的错误页面：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you look at the window with `salt-master` running in the foreground, you
    will see an error message like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看前台运行的 `salt-master` 窗口，您将看到如下错误信息：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And if you look in the window running `salt-api`, you will see a message like
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看运行 `salt-api` 的窗口，您将看到如下信息：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Managing the Master with the wheel modules
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 wheel 模块管理 Master
- en: The wheel system is designed to provide an API to the Master, which is accessible
    via programs that give external access to the Master, such as Salt API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: wheel 系统旨在为主机提供一个 API，该 API 可通过提供对外部访问主机的程序（如 Salt API）进行访问。
- en: One of the first things that you'll find when writing wheel modules is that
    there is no command-line program available for testing wheel modules directly.
    Wheel modules generally include functionality that would be available via some
    other means, were you logged directly in to the Master, but are still useful when
    manual access is not an option.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写 wheel 模块时，您会发现没有可用的命令行程序可以直接测试 wheel 模块。通常，wheel 模块包括一些功能，如果您直接登录到 Master，这些功能将通过其他方式可用，但即使没有手动访问选项，这些功能仍然很有用。
- en: For instance, possibly the most commonly used wheel module is key, which allows
    a programmatic way to manage Minion keys without using the key command. Because
    wheel modules are available to the reactor system, you can write reactor modules
    that can automatically accept or delete keys for Minions based on predefined conditions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最常用的 wheel 模块是 key，它允许以编程方式管理 Minion 密钥，而无需使用密钥命令。由于 wheel 模块对 reactor 系统可用，您可以编写
    reactor 模块，这些模块可以根据预定义的条件自动接受或删除 Minion 的密钥。
- en: Wrapping a wheel around runners
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 wheel 包裹在运行者周围
- en: For our example module, we'll put together a wheel module that returns a small
    amount of data concerning runner modules. This module is a simplified version
    of the runner functions inside the `sys` execution module. The reason these functions
    might be useful as a wheel module is that runners are designed to run on the Master,
    not Minions. If you do not run the `salt-minion` service on the Master, then you
    have no way to programmatically list available runner modules on the Master.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例模块，我们将组合一个 wheel 模块，该模块返回有关运行者模块的一小部分数据。此模块是 `sys` 执行模块内运行者函数的简化版本。这些函数可能作为
    wheel 模块有用，因为运行者被设计在 Master 上运行，而不是在 Minion 上。如果您不在 Master 上运行 `salt-minion` 服务，那么您就没有办法以编程方式列出
    Master 上可用的运行者模块。
- en: 'To start things off, we''ll create a function that does nothing more than list
    all of the functions available in the runner system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个函数，该函数除了列出运行者系统中可用的所有函数外，不做任何其他操作：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function doesn't do a whole lot. It sets up a connection to the Runner
    system and assigns it to a `run_ object`. Then it returns a sorted list of all
    of the runner functions available on the Master.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数并没有做什么。它设置与运行者系统的连接，并将其分配给 `run_ 对象`。然后它返回 Master 上所有可用运行者函数的排序列表。
- en: 'To test this, we''ll need Salt API configured, just like we did in the *Troubleshooting
    external authentication* section. Then we issue a command that sets `client` to
    use the `wheel` system:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们需要配置Salt API，就像我们在*故障排除外部身份验证*部分所做的那样。然后我们发出一个命令，将`client`设置为使用`wheel`系统：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On a Master that only has the manage module available, we would get a JSON
    string back that looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个管理模块可用的Master上，我们会得到一个看起来像这样的JSON字符串：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s go ahead and build on that a little bit and add a runner-specific version
    of the `sys.doc` function in the execution modules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在此基础上进一步扩展，并在执行模块中添加一个特定于runner的`sys.doc`函数版本：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, this function sets up a connection to the Runner system, and assigns
    it to the `run_` object. It then iterates through the functions inside the `run_`
    object, extracting the docstrings that live inside the `__doc__` attribute. Each
    docstring is added to a `docs` dictionary, which is passed through a function
    in Salt called `_strip_rst()`, which cleans things up a little bit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此函数设置与Runner系统的连接，并将其分配给`run_`对象。然后它遍历`run_`对象内的函数，提取存在于`__doc__`属性中的docstrings。每个docstring都被添加到一个名为`docs`的字典中，该字典通过Salt中的一个函数`_strip_rst()`传递，该函数稍微清理了一下这些内容。
- en: 'Let''s finish things up with a function that lists just the runner modules
    available, but no other information about them such as docstrings or even function
    names:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个函数来结束这一切，该函数只列出可用的运行模块，而不包含其他信息，例如docstrings或甚至函数名称：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function expands upon the `list_runners()` function by stripping out function
    names and adding the resulting module names to a set called `runners`. As before,
    a sorted copy of that set is returned.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过删除函数名称并添加结果模块名称到名为`runners`的集合中来扩展`list_runners()`函数。与之前一样，返回该集合的排序副本。
- en: The final wheel module
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后一个wheel模块
- en: 'With all of our functions put together, we will end up with a cohesive module
    that looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们所有的函数组合在一起，最终我们会得到一个看起来像这样的模块：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Troubleshooting wheel modules
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮模块故障排除
- en: Once again, wheel modules are a little special when it comes to troubleshooting,
    because there is no specific command-line program in Salt that executes them directly.
    Unlike `auth` modules, they can't even be tested using the `salt` command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，轮模块在故障排除方面有些特殊，因为Salt中没有特定的命令行程序可以直接执行它们。与`auth`模块不同，它们甚至不能使用`salt`命令进行测试。
- en: 'However, as you have just seen, they can be tested using Salt API and `curl`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您刚才看到的，它们可以使用Salt API和`curl`进行测试：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also test wheel modules using the event system in Salt. It is good to
    get used to testing this way, since wheel modules are so useful inside reactor
    modules.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Salt的事件系统测试wheel模块。习惯于这种方式进行测试是很好的，因为wheel模块在reactor模块中非常有用。
- en: 'Let''s go ahead and set up a reactor that deletes a Minion''s key from the
    Master:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个反应器，从Master中删除Minion的密钥：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then add that reactor to the `master` configuration file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将该反应器添加到`master`配置文件中：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Go ahead and create a bad Minion key on the Master:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Master上创建一个坏Minion密钥：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After restarting the Master, go ahead and issue a command to trigger the reactor:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启Master后，发出一个命令以触发反应器：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you issue this command, you can use the `salt-key` command to make sure
    that the Minion''s bad key is no longer there:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您发出此命令，您可以使用`salt-key`命令确保Minion的坏密钥不再存在：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or for bonus points, why not use Salt API to make sure that Minion''s key is
    gone?:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者为了加分，为什么不使用Salt API来确保Minion的密钥已经删除？：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Don't be fooled by the fact that `success` is set to `true`; the important value
    here is `return`, which is an empty dictionary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被`success`设置为`true`的事实所迷惑；这里的重要值是`return`，它是一个空字典。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: External authentication (or auth) modules allow an external authentication system
    to validate user credentials on the Master. This can be used for authenticating
    a user locally, but it is required for using external systems that connect to
    Salt.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 外部身份验证（或auth）模块允许外部身份验证系统在Master上验证用户凭据。这可以用于本地验证用户，但使用连接到Salt的外部系统时是必需的。
- en: Wheel modules allow API access to Master-side functionality. The functions contained
    in a wheel module generally allow the management of features that are normally
    available via some other means on the Master locally, but not other means from
    an external endpoint outside the Master. However, wheel modules can contain any
    Master-side management that you deem necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 轮模块允许对Master端功能的API访问。轮模块中包含的函数通常允许管理在Master端通过其他方式本地可用，但不是通过Master外部端点的功能。然而，轮模块可以包含你认为必要的任何Master端管理功能。
- en: Congratulations! You made it all the way through Extending SaltStack! We've
    included a couple of appendices to give you some general development guidelines
    and some information about contributing to the community.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了Extending SaltStack的所有内容！我们包括了一些附录，为你提供一些一般性的开发指南以及一些关于贡献社区的信息。
- en: As you can see, there is a world of Salt development to explore. More modules
    are added regularly, and occasionally new types of modules will appear as well.
    While we haven't covered everything there is or will be, you now have a solid
    foundation that you can use to tackle new Salt code as you come across it. Good
    luck out there; I hope you win!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Salt开发的世界有待探索。经常会有更多模块被添加，偶尔也会出现新的模块类型。虽然我们还没有涵盖所有现有或将来会有的内容，但你现在已经拥有了一个坚实的基础，可以用来解决你遇到的新的Salt代码。祝你好运；希望你在那里取得成功！
- en: Appendix A. Connecting Different Modules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 连接不同模块
- en: When building an infrastructure, it is helpful to understand how each of the
    module types fits together. This includes both how they fit together inside of
    Salt and how you are able to use those connections to build your own solutions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建基础设施时，了解每种模块类型如何相互配合是有帮助的。这包括它们如何在Salt内部配合，以及你如何能够使用这些连接来构建自己的解决方案。
- en: Separating Master and Minion functionality
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离Master和Minion功能
- en: 'It''s easy to think of Salt in terms of the following: the Master sends commands
    to the Minions, the Minions do the work, and then the Minions send the results
    back to the Master. However, the Master and the Minion are two distinct components
    that work together in harmony to complete their respective tasks.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将Salt理解为以下方式：Master向Minion发送命令，Minion执行工作，然后Minion将结果发送回Master。然而，Master和Minion是两个不同的组件，它们和谐地协同工作以完成各自的任务。
- en: It is important to keep in mind that when the Minion is running in a Masterless
    mode (using `salt-call --local`), it behaves as its own Master, and outside of
    a few specific features (such as `salt-key` and runners that make use of `local_client`),
    any feature that is available on the Master is also available on the Minion, using
    the same configuration options that would appear in the `master` file, but in
    the `minion` file instead.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，当Minion以无Master模式运行（使用`salt-call --local`）时，它表现得像自己的Master一样，除了少数特定功能（如`salt-key`和使用`local_client`的runners）之外，Master上可用的任何功能在Minion上也是可用的，使用与`master`文件中相同的配置选项，但位于`minion`文件中。
- en: But when running with a Master and one or more Minions, they are two distinct
    entities. Some module types are available to either the Master or the Minion;
    there are many more that are only available for that specific service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但当与一个Master和一个或多个Minion一起运行时，它们是两个不同的实体。一些模块类型只对Master或Minion可用；而许多其他模块类型仅对该特定服务可用。
- en: 'Let us have a look at a diagrammatic representation of the Salt Master topology:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Salt Master拓扑的图示表示：
- en: '![Separating Master and Minion functionality](img/00002.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![分离Master和Minion功能](img/00002.jpeg)'
- en: 'And now follows the diagrammatic representation of the Salt Minion topology:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将展示Salt Minion拓扑的图示表示：
- en: '![Separating Master and Minion functionality](img/00003.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![分离Master和Minion功能](img/00003.jpeg)'
- en: Like the Master and the Minion, each module type is specific and distinct. However,
    like the Master and the Minion, modules connect to each other and work in concert
    to accomplish larger workflows. Regardless of module type, the Master and the
    Minion will always communicate directly (using transport modules, which are beyond
    the scope of this book). Beyond that, different modules are able to communicate
    with each other to varying degrees.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与Master和Minion一样，每种模块类型都是特定和独特的。然而，与Master和Minion一样，模块相互连接并协同工作以完成更大的工作流程。无论模块类型如何，Master和Minion都将始终直接通信（使用传输模块，这超出了本书的范围）。除此之外，不同的模块能够以不同程度的相互通信。
- en: The Master generally uses its own modules directly. Some of those modules may
    be used to provide Minions with resources (such as file server modules), but a
    number of them are used entirely for providing resources to the Master itself.
    Master returners are functionally identical to returners that execute on the Minion,
    with the exception of how they get their data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Master通常直接使用其自己的模块。其中一些模块可能被用来为Minion提供资源（例如文件服务器模块），但许多模块完全用于为Master本身提供资源。Master返回者与在Minion上执行的返回者在功能上相同，唯一的区别是它们获取数据的方式。
- en: Minion modules communicate with each other extensively. Execution modules can
    pull data from grain and SDB modules (and from pillars, through the Master) and
    cross-call each other. State modules are themselves called from an execution module,
    but also have access to cross-callback to execution modules. Renderers are used
    by a number of different module types, and when all is said and done, returners
    transport return data to the correct destination.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Minion模块之间进行广泛的通信。执行模块可以从Grain和SDB模块（以及通过Master从柱子上）拉取数据，并相互调用。状态模块本身由执行模块调用，但也可以访问跨回调到执行模块。渲染器被多种不同的模块类型使用，最终，返回者将返回数据传输到正确的目的地。
- en: Salt Cloud is the odd man out, because while it can be accessed via either a
    runner or an execution module, it can also be accessed directly, and even used
    independently of the rest of Salt. In fact, it can be used to manage nodes without
    even installing Salt on them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Salt Cloud是异类，因为它可以通过runner或执行模块访问，也可以直接访问，甚至可以在不安装Salt的情况下独立使用。实际上，它可以用来管理节点，甚至不需要在这些节点上安装Salt。
- en: Working with dunders
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与双下划线操作符一起工作
- en: 'For those of you not in the know, *dunder* refers to a variable that is preceded
    and succeeded by two underscores. For instance, one of the most common dunders
    in Salt is `__opts__`, which contains the configuration for either the Master
    or the Minion, depending on the context. There are a number of dunders that work
    together to form the glue that ties all of Salt together. Let''s take a look at
    them in turn:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不知道的人来说，*双下划线*指的是由两个下划线前后夹着的变量。例如，Salt中最常见的双下划线之一是`__opts__`，它包含Master或Minion的配置，具体取决于上下文。有许多双下划线一起工作，形成将所有Salt连接在一起的粘合剂。让我们依次看看它们：
- en: '`__opts__`: On a Master, the `__opts__` dictionary contains a composite of
    the information located in the Master''s configuration files (normally `/etc/salt/master`
    plus files located in the `/etc/salt/master.d/` directory), along with the default
    values for configuration parameters not specified, plus any internal configuration
    that Salt generates for its own use at runtime.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__opts__`：在Master上，`__opts__`字典包含位于Master配置文件中的信息（通常是`/etc/salt/master`以及位于`/etc/salt/master.d/`目录中的文件），还包括未指定配置参数的默认值，以及Salt在运行时为其自身生成的任何内部配置。'
- en: On a Minion, `__opts__` contains the same sort of information (but from the
    `/etc/salt/minion` file and the `/etc/salt/minion.d/` directory), when it is connected
    to the Master. However, when the Minion is used in a Masterless mode (such as
    when called from `salt-call --local`), any defaults are filled in as if it were
    a Master, rather than a Minion. This is because lookups such as pillars and files
    need to be provided from a Master of some sort, and in this capacity the Minion
    needs to play that role.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Minion上，当连接到Master时，`__opts__`包含类似的信息（但来自`/etc/salt/minion`文件和`/etc/salt/minion.d/`目录），然而，当Minion以无Master模式（例如从`salt-call
    --local`调用时）使用，任何默认值都填充为如果它是一个Master，而不是Minion。这是因为需要从某种Master提供查找，如pillar和文件，在这个角色中，Minion需要扮演这个角色。
- en: '`__salt__`: In modules that run on the Minions (most notably execution and
    state modules), `__salt__` contains a list of function calls to all of the available
    execution modules on the system. These items can be called directly, as if they
    were functions inside the calling module itself. For example:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__salt__`：在运行在Minion上的模块（最显著的是执行和状态模块）中，`__salt__`包含对系统上所有可用执行模块的函数调用的列表。这些项可以直接调用，就像它们是调用模块内部的函数一样。例如：'
- en: '[PRE27]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a function in this way is referred to as *cross-calling*. Because it calls
    out to execution modules, which are only available as a Minion, the Master does
    not make use of cross-calling.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式使用函数被称为*跨调用*。因为它调用执行模块，而这些模块仅作为Minion可用，所以Master不使用跨调用。
- en: '`__grains__`: Another Minion-only dunder is the `__grains__` dictionary, which
    contains a copy of all of the grains computed for the Minion. This is used extensively
    throughout Salt to help Minions auto-detect what kinds of resources are available.
    It is possible to start `salt-call` without detecting grains by passing the `--skip-grains`
    flag, like this:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__grains__`: 另一个仅适用于Minion的内置字典是`__grains__`，它包含为Minion计算的所有grains的副本。Salt广泛使用它来帮助Minion自动检测可用的资源类型。可以通过传递`--skip-grains`标志来启动`salt-call`而不检测grains，如下所示：'
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will notice that if you try this, the Minion responds much more quickly.
    But if you try to use any modules much more advanced than `test`, you will quickly
    find out how important grains are to the functionality of the Minion.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，如果你这样做，Minion的响应速度会更快。但如果你尝试使用比`test`更高级的任何模块，你很快就会了解到grains对于Minion功能的重要性。
- en: '`__pillar__`: Pillars have their own dunder dictionary as well, whose name
    is strangely singular (`__pillar__` instead of `__pillars__`). Unlike grains,
    which are generated by the Minion, pillars are generated by the Master. However,
    if you run `salt-call` in `--local` mode like this, you will discover that as
    `__opts__` now contains Master-side configuration, pillar configuration that would
    normally live on the Master will now be accepted by the Minion:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__pillar__`: Pillar也有自己的内置字典，其名称奇怪地是单数形式（`__pillar__`而不是`__pillars__`）。与由Minion生成的grains不同，pillar是由Master生成的。然而，如果你像这样以`--local`模式运行`salt-call`，你会发现`__opts__`现在包含Master端配置，因此通常位于Master上的pillar配置现在将由Minion接受：'
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is incredibly useful for writing and debugging pillar modules, since you
    don't run the risk of contaminating other Minions with bad pillar data.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对于编写和调试pillar模块非常有用，因为你不会冒着用不良pillar数据污染其他Minion的风险。
- en: '`__context__`: This dictionary is available both to state and execution modules.
    When Salt fires up the first execution module (which will be the `state` module
    on a state run), it creates the `__context__` dictionary. All of the information
    entered into this dictionary will persist across each subsequent module, so that
    different modules have a means of storing information for later use by another
    module. Once the final module has finished, the `__context__` dictionary will
    be destroyed.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__context__`: 这个字典对状态模块和执行模块都可用。当Salt启动第一个执行模块（在状态运行中将是`state`模块），它将创建`__context__`字典。所有输入到这个字典的信息都将跨后续模块持久化，这样不同的模块就有了一种存储信息以供其他模块后续使用的方法。一旦最终模块完成，`__context__`字典将被销毁。'
- en: Make sure that if you decide to use `__context__`, you check for the existence
    of keys in it before trying to set or use them. This is because you really have
    no way of knowing beforehand which order somebody will use modules in, so you
    shouldn't assume that things have or have not been populated.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保如果你决定使用`__context__`，在尝试设置或使用它之前检查其键的存在。这是因为你真的没有事先知道某人将使用模块的顺序，所以你不应该假设某些事情已经被填充或没有被填充。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about Salt dunders, check out:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Salt内置函数的更多信息，请参阅：
- en: '[https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html](https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html](https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html)'
- en: Using the event bus
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件总线
- en: The event bus does not appear in the topology drawings because it is available
    anywhere inside of Salt, just by importing the `salt.event` library. It also has
    the ability to call out to other module types, using the reactor system. Reactors
    have access to execution, state, and runner modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线没有出现在拓扑图中，因为它在Salt内部任何地方都可用，只需导入`salt.event`库即可。它还具有使用反应器系统调用其他模块类型的能力。反应器可以访问执行、状态和运行模块。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may be wondering why we didn't cover reactor modules in this book. In truth,
    there is no such thing as a reactor module. Reactors are written using standard
    SLS files, which can include extra functionality using the renderer system. For
    more thorough discussions on writing and using reactors, be sure to check out
    *Mastering SaltStack*, *Joseph Hall*, *Packt Publishing*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这本书没有涵盖反应器模块。实际上，并没有所谓的反应器模块。反应器是用标准的SLS文件编写的，可以使用渲染器系统添加额外的功能。关于编写和使用反应器的更深入讨论，请务必查看*Mastering
    SaltStack*，*Joseph Hall*，*Packt Publishing*。
- en: Because the event bus is so ubiquitous, it can be a very powerful tool for tying
    together the other module types into a cohesive workflow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件总线无处不在，它可以是一个非常强大的工具，用于将其他模块类型绑定成一个连贯的工作流程。
- en: For example, let's take a look at Salt Cloud. It can be operated independently
    from the rest of Salt, but when using a Master + Minions setup, it will fire events
    to the Master during the creation and deletion process that can be picked up by
    reactors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看Salt Cloud。它可以独立于Salt的其他部分运行，但在使用主节点+从节点设置时，它将在创建和删除过程中向主节点触发事件，这些事件可以被反应器捕获。
- en: 'Salt Cloud events use tags that are namespaced in a way that can be easily
    determined by reactors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Salt Cloud事件使用标签，这些标签以命名空间的方式命名，可以很容易地由反应器确定：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Available events vary depending on the cloud provider, and the work that provider
    has been configured to do, but a properly written cloud driver will always fire
    at least these two events when creating a node:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的事件取决于云提供商，以及该提供商已配置的工作，但一个编写良好的云驱动程序在创建节点时始终会触发至少这两个事件：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It will also fire these two events when deleting a node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点时，它还会触发这两个事件：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Operations that perform maintenance on Minions and their resources can be kicked
    off using these events. For instance, if you want to sync a Minion''s resources
    as soon as it''s created, you can use a reactor that looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些事件可以启动对从节点及其资源进行维护的操作。例如，如果你想从创建从节点的那一刻起同步从节点的资源，你可以使用一个看起来像这样的反应器：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because a Minion will be available by the time Salt Cloud sends the `salt/cloud/<minion_id>/created`
    tag, you can set a reactor to ensure that the Minion is synced as soon as it comes
    online, without having to configure any `startup_states`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从节点将在Salt Cloud发送`salt/cloud/<minion_id>/created`标签时可用，你可以设置一个反应器来确保从节点一上线就同步，而无需配置任何`startup_states`。
- en: Firing events
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'You can fire events both from the Minion-side modules (such as execution and
    state modules) and Master-side modules (such as runners). From a Minion-side module,
    you need nothing more than to call out to the event execution module as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从从节点模块（如执行和状态模块）和主节点模块（如运行器）触发事件。从一个从节点模块，你不需要做更多的事情，只需调用事件执行模块，如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But in Master-side modules, you need to do a little more work, since `__salt__`
    isn''t available. You need to import `salt.utils.event`, then use it to fire the
    event. This isn''t much more work, but you do have to do some setup. It looks
    like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但在主模块中，你需要做更多的工作，因为`__salt__`不可用。你需要导入`salt.utils.event`，然后使用它来触发事件。这并不是很多工作，但你确实需要进行一些设置。看起来是这样的：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's go over what happened here. First, we set up our imports. The `salt.syspaths`
    library contains information about where standard files and directories will be
    located on this system. In our case, we need to connect to a socket called `master`.
    We use this information to set up a variable called `sock_dir`, which tells Salt
    where to find the event bus to connect to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这里发生了什么。首先，我们设置我们的导入。`salt.syspaths`库包含有关在这个系统上标准文件和目录将位于何处的信息。在我们的情况下，我们需要连接到一个名为`master`的套接字。我们使用这些信息来设置一个名为`sock_dir`的变量，它告诉Salt如何找到要连接的事件总线。
- en: We also find out which transport mechanism is configured for this system. This
    will usually be `zeromq`, but it can also be another protocol such as `raet` or
    `tcp`. Then we set up an object using the `get_event()` function. The first argument
    says which bus we're dealing with, then the `sock_dir`, transport, and finally
    we say that we're not going to be listening for events' we'll be sending them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还找出为这个系统配置了哪种传输机制。这通常会是`zeromq`，但也可能是其他协议，如`raet`或`tcp`。然后我们使用`get_event()`函数设置一个对象。第一个参数说明我们正在处理哪个总线，然后是`sock_dir`、传输，最后我们说明我们不会监听事件，我们将发送它们。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What do we mean by *which bus we're dealing with*? Both the Master and the Minion
    have their own event bus. A Minion can either fire a message to itself using the
    `minion` bus, or to the Master using the `master` bus. The Minion event bus is
    rarely used except by the internal Salt code, but the Master bus is used extensively.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*我们正在处理哪个总线*是什么意思？主节点和从节点都有自己的事件总线。从节点可以使用`minion`总线向自己发送消息，或者使用`master`总线向主节点发送。从节点的事件总线很少被使用，除非是Salt的内部代码，但主节点总线被广泛使用。
- en: 'Once we have the event object set up, we can fire the event. The data (which
    can be a list or a dictionary) is specified first, and then the event tag. If
    you like, you can set up a listener on the Master to see those events come in:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了事件对象，我们就可以触发事件。首先指定数据（可以是列表或字典），然后是事件标签。如果你愿意，你可以在Master上设置一个监听器来查看这些事件：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: One of the most useful things that events are used in is reactors. As mentioned
    earlier, for more information on writing reactors, check out *Mastering SaltStack*,
    *Joseph Hal* *l*, *Packt Publishing*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事件被用于许多最有用的事情之一是reactors。如前所述，有关编写reactors的更多信息，请参阅*Mastering SaltStack*，*Joseph
    Hal* *l*，*Packt Publishing*。
- en: Appendix B. Contributing Code Upstream
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 向上游贡献代码
- en: A number of users have commented over the years that Salt has a low barrier
    to entry for new developers. This can be attributed in part both to the friendly
    and professional community, and the tools that are used to manage the Salt code
    base.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多用户都评论说Salt对新开发者的入门门槛很低。这可以部分归因于友好且专业的社区，以及用于管理Salt代码库的工具。
- en: How the community works
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区如何运作
- en: The Salt community comprises users and developers from all over the globe. The
    vast majority of these people are professionals who use Salt in a business environment,
    though some hobbyists have found their place among the ranks too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Salt社区由来自全球的用户和开发者组成。这些人中的绝大多数都是在商业环境中使用Salt的专业人士，尽管也有一些爱好者在其中找到了自己的位置。
- en: When most people make their way to the community, they are looking for help
    and information about a particular situation that they are working with. This
    may be as minor as looking for examples or documentation, or it could be more
    serious, such as reporting what appears to be a bug in the software.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数人进入社区时，他们正在寻找关于他们正在处理的特定情况的帮助和信息。这可能是寻找示例或文档这样的小事，也可能是更严重的事情，比如报告软件中似乎存在的错误。
- en: Once people have spent some time in the community, they often stick around to
    help out other users. Remember that while some of them may be experts with Salt
    and the various pieces of technology that it manages, they are still just users
    like you, who are contributing their own time to help out people like you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在社区中度过了一些时间后，他们通常会留下来帮助其他用户。记住，尽管他们中的一些人可能是Salt及其管理的各种技术的专家，但他们仍然只是像你一样的用户，他们贡献自己的时间来帮助像你这样的人。
- en: Asking questions and reporting issues
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提问和报告问题
- en: 'There are three primary places where the Salt community gets together to discuss
    the software and help each other out: the mailing list, the IRC chat room, and
    the issue tracker on GitHub.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Salt社区有三个主要的地方聚集在一起讨论软件并互相帮助：邮件列表、IRC聊天室和GitHub上的问题跟踪器。
- en: 'There are three types of messages that you will generally find in these places:
    questions about the software, bug reports, and feature requests. In general, questions
    about the software should be asked either on the mailing list or in IRC. Bug reports
    and feature requests are better suited to the issue tracker.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些地方，你通常会找到三种类型的信息：关于软件的问题、错误报告和功能请求。一般来说，关于软件的问题应该在邮件列表或IRC上提出。错误报告和功能请求更适合在问题跟踪器中提出。
- en: Using the mailing list
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用邮件列表
- en: 'The salt-users mailing list is a very active discussion environment, hosted
    on Google Groups. The mailing list can be found at:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: salt-users邮件列表是一个非常活跃的讨论环境，托管在Google Groups上。邮件列表可以在以下链接找到：
- en: '[https://groups.google.com/d/forum/salt-users](https://groups.google.com/d/forum/salt-users)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://groups.google.com/d/forum/salt-users](https://groups.google.com/d/forum/salt-users)'
- en: You can browse the mailing list at the preceding link, or you can set up an
    e-mail subscription and get messages sent to your inbox, where you can reply to
    them. There are, typically, a good dozen or so e-mails a day, so if that sounds
    like too many, then maybe just looking online is the way to go.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过前面的链接浏览邮件列表，或者设置电子邮件订阅，将消息发送到你的收件箱，你可以在那里回复它们。通常，每天有大约一二十封电子邮件，所以如果你觉得太多，那么可能只是在线查看是更好的选择。
- en: 'If you''re going to post a question, there are a few guidelines that will help
    you out:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算发帖提问，有一些指南可以帮助你：
- en: When you ask a question, try to post enough information about your problem so
    that people will be able help you out. In the past, people have asked how to fix
    a particular problem without stating what the problem actually is, or in some
    cases, even the part of Salt that the question pertains to. As you can imagine,
    this isn't helpful to anybody.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你提问时，尽量提供足够关于你问题的信息，以便人们能够帮助你。在过去，人们曾询问如何修复特定的问题，但没有说明问题的实际情况，或者在某些情况下，甚至没有提到与Salt相关的问题的部分。正如你可以想象的那样，这对任何人都没有帮助。
- en: Describe what you're trying to do, and what you expect to happen. If something
    isn't working the way that you expect, make sure to state what is actually happening.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述你想要尝试的事情以及你期望发生的结果。如果某些事情没有按照你预期的样子工作，请确保说明实际上发生了什么。
- en: You may need to post the output from a command in order to explain what is happening.
    If this is the case, make sure to post the actual command that you're running,
    and the relevant part of the output. If you issue a command that results in dozens
    of lines of logging output, but the actual error only takes up five lines, then
    just post those five lines to start with. If somebody asks for more, then go ahead
    and post more.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要发布命令的输出以解释正在发生的事情。如果这种情况发生，请确保发布你正在运行的实际命令和相关的输出部分。如果你发出的命令产生了数十行日志输出，但实际错误只占五行，那么最初只发布这五行。如果有人要求更多，那么你可以继续发布更多。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful when posting logs and configuration files! All too often, people
    will accidentally post an API key, password, or private network information without
    meaning to. Before pasting any information at a place online, where somebody can
    see it, make sure to remove any sensitive information. Making sure not to post
    long log messages will make this a lot easier.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在发布日志和配置文件时要小心！人们往往会无意中发布API密钥、密码或私人网络信息。在将任何信息粘贴到任何可能被他人看到的地方之前，请确保删除任何敏感信息。确保不发布过长的日志消息会使这个过程容易得多。
- en: 'It is also helpful to know which version of Salt you are running. It is likely
    that your particular experience is unique to a specific version of Salt. Rather
    than just saying which version of Salt, it is often more helpful to give the output
    of the following command:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解你正在运行的Salt版本也很有帮助。你的特定经验可能只与Salt的特定版本相关。与其只说Salt的哪个版本，通常更有帮助的是给出以下命令的输出：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you are working with Salt Cloud, then make sure to get that report instead,
    using:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用Salt Cloud，那么请确保使用以下方式获取报告：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because Salt Cloud uses a different set of libraries, using its `versions` report
    will give more information that may be useful, in addition to all of the version
    information for Salt itself.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为Salt Cloud使用不同的库集，使用它的`versions`报告将提供更多可能有用的信息，除了Salt本身的版本信息之外。
- en: If you happen to find the resolution for your situation from outside the mailing
    list, it is also a good idea to reply to your own thread with a copy of the solution.
    The mailing list is archived on Google's servers, and if somebody else with your
    issue searches for it, they will appreciate seeing the solution. Believe me, few
    things are more frustrating than finding a dozen different people asking the same
    question on a dozen different mailing lists, with either no solution or a message
    from the original person saying, "Hey, I figured it out," and leaving it at that.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你从邮件列表之外找到了解决你情况的方案，回复你自己的帖子并提供解决方案的副本也是一个好主意。邮件列表存档在谷歌的服务器上，如果其他人遇到同样的问题并搜索它，他们会很感激看到解决方案。相信我，没有什么比在十几个不同的邮件列表上找到十几个不同的人问同样的问题，要么没有解决方案，要么是原始发件人留言说“嘿，我想通了”，然后就此结束更令人沮丧的了。
- en: Using IRC
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IRC
- en: 'IRC, or Internet relay chat, is a type of chat room that''s been around for
    a very long time. If you already have an IRC client, you can connect to the Freenode
    server at:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: IRC，或互联网中继聊天，是一种存在了很长时间的聊天室类型。如果你已经有了IRC客户端，你可以连接到Freenode服务器：
- en: '[irc.freenode.com](http://irc.freenode.com)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[irc.freenode.com](http://irc.freenode.com)'
- en: 'And then join the Salt chat room at:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后加入Salt聊天室：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you don''t have an IRC client yet, you might want to consider Pidgin, which
    is a chat client that supports a number of chat protocols. It''s not the most
    popular IRC client by any means, but it''s easy to use and available for Windows,
    Mac, and Linux. You can download it at:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有IRC客户端，你可能想要考虑使用Pidgin，这是一个支持多种聊天协议的聊天客户端。它并不是最受欢迎的IRC客户端，但它易于使用，并且适用于Windows、Mac和Linux。你可以在以下地址下载它：
- en: '[https://www.pidgin.im/](https://www.pidgin.im/)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.pidgin.im/](https://www.pidgin.im/)'
- en: 'If you don''t want to commit to an IRC client, Freenode does have a web-based
    IRC client that you can use to connect to Salt''s chat room. You can find this
    client at:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用IRC客户端，Freenode确实有一个基于Web的IRC客户端，你可以用它来连接到Salt的聊天室。你可以在以下位置找到这个客户端：
- en: '[https://webchat.freenode.net/](https://webchat.freenode.net/)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://webchat.freenode.net/](https://webchat.freenode.net/)'
- en: 'When you connect to Salt''s chat room, there are a few things that will be
    useful to know:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接到Salt的聊天室时，有一些事情是很有用的：
- en: '**Be patient.** There are hundreds of people logged in to the Salt chat room
    at any given time, but not all of them are actively participating. It is very
    common for people to log in to an IRC room while at work, and check it periodically
    throughout the day. When you ask a question, don''t expect an immediate answer.
    Somebody may be watching at that moment and try to help you, but it may take an
    hour for the right person to see your question and jump in to try to answer it.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耐心等待**。在任何给定时间，Salt聊天室中都有数百人登录，但并非所有人都在积极参与。人们在工作时登录到IRC房间，并在一天中定期检查是很常见的。当你提问时，不要期望立即得到回答。可能有人正在观察并试图帮助你，但这可能需要一个小时才能有合适的人看到你的问题并跳出来尝试回答。'
- en: '**Be ready to provide information as necessary.** The kind person who offers
    to help you may ask for log messages or code snippets, or may ask you to try a
    few different commands, and post the response.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好提供必要的信息**。愿意帮助你的人可能会要求查看日志消息或代码片段，或者可能会要求你尝试几个不同的命令，并发布响应。'
- en: 'You may want to look into getting an account on a text-sharing service. One
    such popular service is PasteBin:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想要考虑在文本分享服务上注册一个账户。这样一个流行的服务是PasteBin：
- en: '[http://pastebin.com/](http://pastebin.com/)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://pastebin.com/](http://pastebin.com/)'
- en: 'However, you might also want to look into using GitHub''s gist service:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，你也可能想要考虑使用GitHub的gist服务：
- en: '[https://gist.github.com/](https://gist.github.com/)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/](https://gist.github.com/)'
- en: This has become an increasingly popular way to share logs and code snippets
    as with PasteBin, but with the kind of revision management that Git is known for.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这已经成为一种越来越流行的分享日志和代码片段的方式，就像PasteBin一样，但具有Git所知的版本管理功能。
- en: '**Post solutions.** As with the mailing list, conversations in the Salt chat
    room are archived. You can find them at:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布解决方案**。与邮件列表一样，Salt聊天室中的对话都会被存档。你可以在以下位置找到它们：'
- en: '[https://irclog.perlgeek.de/salt/](https://irclog.perlgeek.de/salt/)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://irclog.perlgeek.de/salt/](https://irclog.perlgeek.de/salt/)'
- en: If you find the solution as you are working on the problem, and it's not obvious
    by looking at the conversation what it is, make sure to post it in the chat room
    so that others can find it later.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在工作过程中找到了解决方案，但通过查看对话并不明显，确保将其发布在聊天室中，以便其他人以后可以找到。
- en: Using the issue tracker
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用问题跟踪器
- en: 'When you come across a situation that you know is a bug, or you have a feature
    request, the Salt issue tracker on GitHub is the way to go. You can find it at:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到你知道是错误的情况，或者你有功能请求时，GitHub上的Salt问题跟踪器是正确的选择。你可以在以下位置找到它：
- en: '[https://github.com/saltstack/salt/issues](https://github.com/saltstack/salt/issues)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/saltstack/salt/issues](https://github.com/saltstack/salt/issues)'
- en: You may come across a situation where you don't know whether your problem is
    the result of inexperience, or an actual bug. If you're not sure, go ahead and
    post it on the mailing list. If it is a bug, then you will probably be asked to
    file an issue in the issue tracker, assuming somebody else hasn't already filed
    the same issue.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一种情况，你不知道你的问题是不是由于缺乏经验，或者是一个真正的错误。如果你不确定，请将问题发布在邮件列表上。如果是错误，那么你可能会被要求在问题跟踪器中提交问题，前提是其他人还没有提交相同的问题。
- en: 'One of the advantages of filing an issue in the issue tracker is that you are
    automatically subscribed to updates for that issue. That means that when others
    post questions and comments on the issue, you will receive an e-mail with a copy
    of their response. If somebody else posted the issue, then you can still subscribe
    to it. Just look for the **Subscribe** button on the right-hand side of the issue
    page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题跟踪器中提交问题的优点之一是，你将自动订阅该问题的更新。这意味着当其他人发布有关问题的提问和评论时，你将收到一封包含他们响应的电子邮件。如果其他人已经发布了该问题，那么你仍然可以订阅它。只需在问题页面右侧查找**订阅**按钮：
- en: '![Using the issue tracker](img/00004.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![使用问题跟踪器](img/00004.jpeg)'
- en: Once you hit that button, it will change to say **Unsubscribe**. If you ever
    get tired of receiving updates for that issue (even if you created it), then you
    can unsubscribe from it. But if you've left comments, I would encourage you to
    remain subscribed, in case anybody wants to ask you further questions down the
    road.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击那个按钮，它将变为“取消订阅”。如果你对收到该问题的更新感到厌倦（即使是你创建的），那么你可以取消订阅。但如果你在上面留下了评论，我鼓励你保持订阅，以防将来有人想要进一步询问你。
- en: Once again, make sure to post any relevant information, exactly as you would
    on the mailing list. Detailed information about the issue, version reports, and
    code snippets are all helpful. A very recent addition to the Salt issue tracker
    is the use of templates, which provide reminders as to which information to give.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，确保发布任何相关信息，就像你在邮件列表上做的那样。关于问题的详细信息、版本报告和代码片段都是有帮助的。最近添加到Salt问题跟踪器的一个新功能是使用模板，它提供了关于需要提供哪些信息的提醒。
- en: Using GitHub markdown
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GitHub Markdown
- en: 'One incredibly helpful feature in GitHub is the ability to use markdown. You
    can find a helpful guide to markdown at:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub中一个极其有用的功能是能够使用Markdown。你可以在以下位置找到一个有用的Markdown指南：
- en: '[https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[GitHub Markdown指南](https://guides.github.com/features/mastering-markdown/)'
- en: 'By far the most useful markdown syntax to know is how to mark out code blocks.
    The character used to mark out code is commonly known as the backtick, also known
    as the grave accent. On an American QWERTY keyboard, this key is located in the
    top-left position:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最实用的Markdown语法是知道如何标记代码块。用于标记代码的字符通常被称为反引号，也称为重音符号。在美国QWERTY键盘上，这个键位于左上角的位置：
- en: '![Using GitHub markdown](img/00005.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![使用GitHub Markdown](img/00005.jpeg)'
- en: When you place a single backtick in front of a piece of text and another at
    the end, then the text will be formatted as a piece of code. If you need to format
    multiple lines, then start with three backticks together on the first line, and
    three more together on the last line. Blocking out code this way helps immensely
    with readability.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一段文本的前面和后面放置一个反引号时，该文本将被格式化为代码。如果你需要格式化多行，则在第一行开始时使用三个连续的反引号，在最后一行结束时也使用三个连续的反引号。以这种方式标记代码块极大地提高了可读性。
- en: '![Using GitHub markdown](img/00006.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![使用GitHub Markdown](img/00006.jpeg)'
- en: Understanding the Salt Style Guide
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Salt风格指南
- en: 'If you''ve spent enough time in Python, then you''re already familiar with
    the Style Guide for Python Code, also known as PEP 8\. For those who have not
    seen it, or if you need a refresher, you can take a look at it here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在Python中花费了足够的时间，那么你已经熟悉了Python代码风格指南，也称为PEP 8。对于那些尚未看到它或需要复习的人，你可以在以下位置查看它：
- en: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python PEP 8指南](https://www.python.org/dev/peps/pep-0008/)'
- en: 'There is also a guide to the Salt Coding Style, available at:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于Salt编码风格的指南，可在以下位置找到：
- en: '[https://docs.saltstack.com/en/latest/topics/development/conventions/style.html](https://docs.saltstack.com/en/latest/topics/development/conventions/style.html)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[Salt编码风格指南](https://docs.saltstack.com/en/latest/topics/development/conventions/style.html)'
- en: 'In general, Salt coding conventions follow PEP 8, but there are some key differences:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Salt的编码约定遵循PEP 8，但有一些关键的区别：
- en: '**Quoting:** One of the first conventions that new developers come across is
    that Salt uses single quotes ('') instead of double quotes ("). This applies to
    everything from string formatting to docstrings.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用：** 新开发者遇到的第一项约定之一是Salt使用单引号（''）而不是双引号（"）。这适用于从字符串格式化到文档字符串的任何地方。'
- en: '**Line length:** It is very common for code to restrict lines to no longer
    than 80 characters. This seems to be especially adhered to in Python, but it is
    based on an older convention where computer screens were exactly 80 characters
    wide. Because this is no longer the case, it is considered acceptable in Salt
    to expand to 120 characters, particularly if it helps with readability.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行长度：** 代码通常限制每行不超过80个字符，这在Python中尤其被严格遵守。这种做法基于一个较老的约定，即计算机屏幕的宽度正好是80个字符。由于现在的情况已经不再是这样，因此在Salt中扩展到120个字符被认为是可接受的，尤其是如果这有助于提高可读性。'
- en: '**Tabs versus spaces:** Salt uses four spaces for indentation. No tabs. No
    exceptions.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**制表符与空格：** Salt使用四个空格进行缩进。不使用制表符。没有例外。'
- en: Using Pylint
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pylint
- en: 'Salt makes extensive use of a program called **Pylint** to ensure that its
    code adheres to its style guide. You can find information about installing Pylint
    at:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Salt 广泛使用一个名为 **Pylint** 的程序来确保其代码遵循其风格指南。你可以在以下位置找到有关安装 Pylint 的信息：
- en: '[http://www.pylint.org/](http://www.pylint.org/)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[pylint 网站](http://www.pylint.org/)'
- en: Keep in mind that Salt currently uses Python 2 (the minimum version being 2.6),
    so if you're working in a distribution where both Python 2 and 3 versions of Pylint
    are available, make sure you use the Python 2 version.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Salt 目前使用 Python 2（最低版本为 2.6），所以如果你在一个同时提供 Python 2 和 3 版本的 Pylint 的发行版中工作，请确保你使用
    Python 2 版本。
- en: 'The Salt code base ships with a `.pylintrc` file to be used with Pylint. It
    doesn''t get used by default, so you need to make sure to point it out to Pylint:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Salt 代码库附带了一个 `.pylintrc` 文件，用于与 Pylint 一起使用。默认情况下它不会被使用，所以你需要确保将其指向 Pylint：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Not only will this file allow you to check your code against Salt style guidelines
    but also to check the entire code base at once. This is important, because the
    loader inserts variables into modules that wouldn't be picked up otherwise by
    Pylint.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个文件允许你检查你的代码是否符合 Salt 风格指南，还可以一次性检查整个代码库。这很重要，因为加载器会将变量插入到其他情况下 Pylint 无法检测到的模块中。
- en: Creating pull requests on GitHub
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GitHub 上创建 pull request
- en: 'Whereas many project communities accept code only through mailing lists or
    complex websites, Salt has opted to stick with pull requests for accepting code
    contributions. A list of active pull requests can be found at:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多项目社区只通过邮件列表或复杂的网站接受代码不同，Salt 选择坚持使用 pull request 来接受代码贡献。活跃的 pull request
    列表可以在以下位置找到：
- en: '[https://github.com/saltstack/salt/pulls](https://github.com/saltstack/salt/pulls)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[saltstack/salt 的 pull request](https://github.com/saltstack/salt/pulls)'
- en: The complete details of using Git are way beyond the scope of this book, but
    it is worth going over the steps to clone the Salt repository and put in a new
    pull request.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的完整使用细节超出了本书的范围，但了解克隆 Salt 仓库和提交新的 pull request 的步骤是值得的。
- en: 'First, you will need your own fork of Salt on GitHub. If you don''t have one
    yet, then use the **Fork** button at Salt''s own GitHub page:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在 GitHub 上有自己的 Salt fork。如果你还没有，那么请使用 Salt 自己的 GitHub 页面上的 **Fork** 按钮：
- en: '[https://github.com/saltstack/salt](https://github.com/saltstack/salt)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[saltstack/salt](https://github.com/saltstack/salt)'
- en: 'Assuming that your GitHub username is *mygithubuser*, your new fork will appear
    at:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 GitHub 用户名是 *mygithubuser*，你的新 fork 将出现在：
- en: '`https://github.com/mygithubuser/salt`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://github.com/mygithubuser/salt`'
- en: 'Once you have a fork set up, you''ll need to clone a copy to your computer.
    The following steps assume that you work in a command-line environment, such as
    Linux:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了 fork，你需要在你的电脑上克隆一个副本。以下步骤假设你在命令行环境中工作，例如 Linux：
- en: 'If you have an SSH key set up, you can clone using SSH:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经设置了 SSH 密钥，你可以使用 SSH 克隆：
- en: '[PRE41]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Otherwise, you''ll need to clone over HTTPS:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，你需要通过 HTTPS 克隆：
- en: '[PRE42]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You will also need to add the original SaltStack repository to your local clone,
    to be able to create pull requests:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要将原始 SaltStack 仓库添加到你的本地克隆中，以便能够创建 pull request：
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The default Git branch is `develop`. If you''re adding a new feature to Salt,
    the work should be performed on a branch based on `develop`. To create a new branch
    called `newfeature` and switch to it, use:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的 Git 分支是 `develop`。如果你正在为 Salt 添加新功能，则应在基于 `develop` 的分支上执行工作。要创建一个名为 `newfeature`
    的新分支并切换到它，请使用：
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you are ready to put in a pull request, it is best to rebase your branch
    to make sure it doesn''t conflict with any other pull requests that have been
    merged since your last update:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你准备好提交 pull request 时，最好重新基于你的分支进行合并，以确保它不会与自上次更新以来已合并的任何其他 pull request 冲突：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on using rebase, check out:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于使用 rebase 的更多信息，请参阅：
- en: '[https://help.github.com/articles/using-git-rebase/](https://help.github.com/articles/using-git-rebase/)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[使用 Git rebase](https://help.github.com/articles/using-git-rebase/)'
- en: 'Once you have rebased, go ahead and push your branch up to GitHub:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你完成了 rebase，就可以将你的分支推送到 GitHub：
- en: '[PRE46]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you visit your fork on GitHub again, you will see a link that says **New
    Pull Request**. From there, you can look at the diff readout between your branch
    and the current version of the `develop` branch on GitHub, and create your pull
    request when you're satisfied with it.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你再次访问你的 GitHub fork 时，你会看到一个链接，上面写着 **New Pull Request**。从那里，你可以查看你的分支和 GitHub
    上 `develop` 分支当前版本的差异，并在满意后创建你的 pull request。
- en: As with issue submission, pull requests now also have a template to use as a
    guide to provide useful information about describing the changes that your pull
    request includes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与问题提交一样，pull request 现在也有一个模板可供使用，作为描述 pull request 包含的更改的指南，提供有用的信息。
- en: Using other branches
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他分支
- en: 'If you''re submitting bug fixes, then it may be more appropriate to submit
    them against a branch that matches a specific version of Salt. If you know which
    version of Salt the bug was first found in, then use that branch. The exception
    would be if the branch in question is so old that it is no longer being maintained.
    If that is the case, then choose the oldest branch that is being maintained. For
    instance, if the oldest maintained version is `2015.8.x`, then check out the `2015.8`
    branch:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在提交错误修复，那么可能更合适的是针对与 Salt 的特定版本匹配的分支提交。如果你知道错误首次出现在哪个版本的 Salt 中，那么请使用那个分支。例外情况是，如果相关的分支已经太旧，不再维护。如果是这种情况，那么请选择正在维护的最旧分支。例如，如果最旧的维护版本是
    `2015.8.x`，那么检出 `2015.8` 分支：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Understanding test errors in pull requests
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 pull request 中的测试错误
- en: 'When you submit a new pull request, GitHub will trigger the test suite to run
    against it. This will take several minutes, as it needs to create a new virtual
    machine, and start a lint test using Pylint, as well as tests on popular platforms
    such as CentOS and Ubuntu:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提交一个新的 pull request 时，GitHub 将触发测试套件对其运行。这需要几分钟，因为它需要创建一个新的虚拟机，并使用 Pylint
    启动一个 lint 测试，以及针对 CentOS 和 Ubuntu 等流行平台的测试：
- en: '![Understanding test errors in pull requests](img/00007.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![理解 pull request 中的测试错误](img/00007.jpeg)'
- en: 'As the tests are running, you can check progress by clicking the **Details**
    button on the right:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试正在运行时，你可以通过点击右侧的 **详情** 按钮来检查进度：
- en: '![Understanding test errors in pull requests](img/00008.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![理解 pull request 中的测试错误](img/00008.jpeg)'
- en: Click on one of the tests to see more information. You will see output such
    as error messages, stacktraces, and standard output and standard error output.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 点击其中一个测试以查看更多信息。你会看到错误消息、堆栈跟踪以及标准输出和标准错误输出。
- en: There is a chance that one or more of the test failures that show up in your
    pull request are not actually your fault. It could be that another pull request
    was merged, which caused unforeseen issues on the build server. If the errors
    that show up don't look to be related to your code, leave a comment to ask about
    it. One of the core developers at SaltStack will see it and help you out.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能你 pull request 中出现的测试失败并非你的责任。可能是另一个 pull request 被合并，导致构建服务器出现了未预见的错误。如果出现的错误看起来与你的代码无关，请留下评论询问。SaltStack
    的核心开发者会看到并帮助你。
- en: 'Lint errors look a little different. When you look at the details for a lint
    test, you will see a list of files that are affected. Click on one, and you will
    see each error marked out. Hover over it to find out what went wrong:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Lint 错误看起来略有不同。当你查看 lint 测试的详细信息时，你会看到一个受影响的文件列表。点击其中一个，你会看到每个错误都被标记出来。悬停在它上面以找出出了什么问题：
- en: '![Understanding test errors in pull requests](img/00009.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![理解 pull request 中的测试错误](img/00009.jpeg)'
- en: If you would like more information about the lint test, you can click on **Console
    Output** on the left, to see a full log of the lint test.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 lint 测试的信息，你可以点击左侧的 **控制台输出**，以查看 lint 测试的完整日志。
- en: 'Once you have made corrections to the code in your local Git clone, commit
    them as you normally would, and push them back up to GitHub:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在本地 Git 克隆的代码中进行了修正，按照常规提交它们，并将它们推回 GitHub：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A new test run will be scheduled, and any remaining errors will show up as before.
    Once all of the errors have been resolved, a core developer will be able to merge
    your code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将安排新的测试运行，任何剩余的错误将如之前一样显示。一旦所有错误都得到解决，核心开发者将能够合并你的代码。
