- en: Chapter 2. Creating User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 创建用户界面
- en: 'In this chapter, we''ll be taking a guided tour through Maya''s collection
    of user interface elements and learning how to use them to create interfaces that
    you and your teammates will love to use. The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带您参观Maya的用户界面元素集合，并学习如何使用它们来创建您和您的团队成员都乐于使用的界面。以下主题将涵盖：
- en: Making a basic window
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本窗口
- en: Simple controls – making a button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单控件 – 创建一个按钮
- en: Retrieving input from controls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从控件中检索输入
- en: Using classes to organize UI logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类来组织UI逻辑
- en: Using nested layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套布局
- en: Using tabs and scrolling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签和滚动
- en: Adding menu to your UIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的UIs添加菜单
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While it is by no means required to create a graphical user interface (GUI)
    for your scripts, you're likely to want one in almost all cases. Very often, you'll
    find yourself creating scripts that are meant to be used by your teammates, some
    of whom may be less comfortable with command-line tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为您的脚本创建图形用户界面（GUI）并非必需，但在几乎所有情况下，您都可能想要一个GUI。非常常见的是，您会发现自己正在创建旨在供您的团队成员使用的脚本，其中一些人可能不太熟悉命令行工具。
- en: In this chapter, we'll be looking at how to create windows, fill them with interface
    elements, and link those elements up to other functionality within Maya.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何创建窗口，用界面元素填充它们，并将这些元素链接到Maya中的其他功能。
- en: Making a basic window
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本窗口
- en: All great user interfaces start with window. In this example, we'll be creating
    a simple window and using the text label control to add a simple message.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优秀的用户界面都是从窗口开始的。在这个例子中，我们将创建一个简单的窗口，并使用文本标签控件添加一个简单的消息。
- en: 'We''ll end up with something like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会得到以下类似的结果：
- en: '![Making a basic window](img/4657_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本窗口](img/4657_02_01.jpg)'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Start by creating a new file in your scripts directory and naming it basic `Window.py`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的脚本目录中创建一个新文件，并将其命名为基本的`Window.py`。
- en: 'Add the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you run the script, you should see a small window containing the text **Hello,
    Maya!**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行脚本，您应该会看到一个包含文本**Hello, Maya!**的小窗口。
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create a window, you'll need to use the window command.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个窗口，您需要使用窗口命令。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While all of the arguments are optional, there are a few that you'll generally
    want to include by default. Here, we're setting the title to "Simple Window" and
    the size of the window to 300 pixels wide by 200 pixels tall. Also note that we
    save the result of the command to a variable, `myWin`. This is necessary in order
    to use the `showWindow` command. More on that in a bit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有参数都是可选的，但您通常会默认包含一些参数。在这里，我们将窗口标题设置为“简单窗口”，并将窗口大小设置为300像素宽、200像素高。请注意，我们还保存了命令的结果到变量`myWin`。这是使用`showWindow`命令所必需的。稍后我们将详细介绍这一点。
- en: 'There is also one more requirement, that is, in order to add an element to
    a window, you must first specify a layout. Layouts are responsible for arranging
    items within a given area (either a window or another layout). If you fail to
    provide Maya with a layout, it won''t be able to properly position any controls
    you add, and your script will error out. In this example, we''re using a `columnLayout`,
    which will arrange all the controls we add in a single vertical column. We add
    a layout to the window with the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个额外的要求，那就是为了向窗口添加一个元素，你必须首先指定一个布局。布局负责在给定区域（无论是窗口还是另一个布局）内排列项目。如果你没有为Maya提供布局，它将无法正确地定位你添加的任何控件，并且你的脚本将出错。在这个例子中，我们使用的是`columnLayout`，它将把所有我们添加的控件排列在一个单独的垂直列中。我们使用以下方式将布局添加到窗口中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once we've created a window and specified a layout, we can start adding controls.
    In this case, we're using the text control that merely adds some text to the window.
    While you won't generally use text controls by themselves (it's far more common
    to use them next to other controls to provide labels or descriptive text), it
    serves as a good example of a typical, albeit simple, control.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个窗口并指定了布局，我们就可以开始添加控件。在这种情况下，我们使用的是仅向窗口添加一些文本的文本控件。虽然您通常不会单独使用文本控件（将它们与其他控件一起使用以提供标签或描述性文本的情况要常见得多），但它是一个典型（尽管简单）控件的良好示例。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we''re done with our interface, but creating a window will not
    actually show anything in Maya. To have it shown up in Maya''s interface, we''ll
    also need to explicitly show it using the `showWindow` command. The reason for
    this is that you generally don''t want to show a window until it has all of the
    controls and other UI elements you want it to have. However, in order to create
    a control, you must first have a window to add them to. Maya solves this by having
    you:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了我们的界面，但在Maya中创建一个窗口实际上并不会显示任何内容。为了使其在Maya的界面中显示，我们还需要使用`showWindow`命令显式地显示它。这样做的原因是，你通常不希望在窗口拥有所有你想要的控件和其他UI元素之前就显示它。然而，为了创建一个控件，你必须首先有一个窗口来添加它们。Maya通过让你这样做来解决这个问题：
- en: Create the window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建窗口。
- en: Add your controls.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加你的控件。
- en: Show the window once all of the controls have been added.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加所有控件后显示窗口。
- en: 'This is why, it was important to save the result of the `window()` command
    to a variable, so that we can tell Maya which window it should show to the user.
    Putting that together gives us the last line of our showUI function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，保存`window()`命令的结果到一个变量中非常重要，这样我们就可以告诉Maya它应该向用户显示哪个窗口。将这些放在一起，就给出了我们showUI函数的最后一行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that once a layout is created, it becomes the active context in order to
    add controls. You can certainly have multiple layouts in a single window (and
    even nest them within each other), but there is always exactly one current layout
    to which Maya will insert newly created controls.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦创建了一个布局，它就成为了活动上下文，以便添加控件。你当然可以在单个窗口中拥有多个布局（甚至可以嵌套它们），但总是只有一个当前布局，Maya会将新创建的控件插入其中。
- en: One problem with this example is that running the script multiple times will
    result in multiple copies of the window, which is usually not what you want. For
    most purposes, you'll want to ensure that there is only ever a single instance
    of your UI open at any one time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的一个问题是，多次运行脚本会导致多个窗口副本，这通常不是你想要的。对于大多数用途，你希望确保在任何时候只有一个UI实例打开。
- en: 'To do this, we''ll need to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要：
- en: Choose a unique name for our window
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的窗口选择一个独特的名称
- en: Before creating the window, check to see whether one already exists with that
    name
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建窗口之前，检查是否已经存在具有该名称的窗口
- en: If there's already a window by that name, delete it
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经存在一个同名窗口，则删除它
- en: Create the window using the window command, passing in the name
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用窗口命令创建窗口，并传递名称
- en: When choosing a name, make sure that it's something that is unlikely to conflict
    with other scripts the user might be using. Generic names such as `"MyWindow"`
    or `"MainWindow"` are likely to cause conflicts; it is much better to have something
    unique like `"CharacterRigControl"`. To make it even better, add your initials,
    or the initials of your company to the start of the name (`"ahCharacterRig"`,
    for example). Note that the name (which is not shown to the user) is distinct
    from the title (which is), so it's perfectly fine to have a long or unwieldy name.
    Just make sure that it's unique.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择名称时，确保它不太可能与用户可能使用的其他脚本冲突。像“我的窗口”或“主窗口”这样的通用名称很可能会引起冲突；拥有一个独特的名称，如“CharacterRigControl”，会更好。为了使其更加完美，可以在名称的开头添加你的首字母，或者你公司的首字母（例如，“ahCharacterRig”）。请注意，名称（不会显示给用户）与标题（会显示）是不同的，因此拥有一个长或难以操作的名字是完全可以的。只需确保它是唯一的。
- en: 'Once you have a name, we''ll want to start off by testing to see if a window
    by that name exists. We can do that with the window command and the `exists` flag.
    If we *do* find that a window of that name exists, we''ll want to get rid of it
    with the `deleteUI` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了名称，我们希望首先测试一下是否有一个同名窗口存在。我们可以使用窗口命令和`exists`标志来完成这个操作。如果我们确实发现存在一个同名窗口，我们希望使用`deleteUI`命令将其删除：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, when we create a new window, we'll make sure to pass in our desired
    name as the first argument, which will give the window the desired name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们创建一个新的窗口时，我们将确保将我们想要的名称作为第一个参数传递，这将给窗口赋予所需的名称。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alternatively, we could just stop the script if there's already a window with
    the given name, but the previously mentioned approach is more common. If the user
    invokes your script, they likely want to start with a fresh slate, so replacing
    the old window is often the best option.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以在已经存在具有给定名称的窗口时停止脚本，但前面提到的方法更为常见。如果用户调用你的脚本，他们很可能希望从一个全新的开始，因此替换旧窗口通常是最佳选择。
- en: Simple controls – making a button
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单控件——创建一个按钮
- en: Creating a window is only the beginning. In order to create a proper interface,
    we'll need to both add controls, and tie them to functionality. In this example,
    we'll be revisiting our good friend, the `polyCube` command, and tying it to a
    button press.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建窗口只是开始。为了创建一个合适的界面，我们需要添加控件并将它们与功能关联起来。在这个例子中，我们将重新访问我们的好朋友`polyCube`命令，并将其与按钮点击关联起来。
- en: 'The resulting UI (and its output) will look similar to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的UI（及其输出）将类似于以下内容：
- en: '![Simple controls – making a button](img/4657_02_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![简单控件 – 创建按钮](img/4657_02_02.jpg)'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and name it `buttonExample.py`. Add the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并将其命名为`buttonExample.py`。添加以下代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the script, and you should see a 200 by 200 pixel window with a single button
    inside it. Pushing the button will create a polygonal cube with the default parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该看到一个200x200像素的窗口，里面有一个按钮。按下按钮将使用默认参数创建一个多边形立方体。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to trigger functionality from our UI, we''ll first need to create
    a function to contain the functionality we want to trigger. We do that in our
    `buttonFunction` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的UI触发功能，我们首先需要创建一个函数来包含我们想要触发的功能。我们在`buttonFunction`函数中这样做：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, all we''re doing is creating a polygonal cube. Note that the
    function accepts arguments, even though we aren''t making use of them. That''s
    actually necessary, since when Maya triggers a function from a control, it passes
    information to the respective function. Assume that we write the function without
    arguments, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是在创建一个多边形立方体。请注意，即使我们没有使用它们，函数也接受参数。这实际上是必要的，因为当Maya从控制中触发函数时，它会将信息传递给相应的函数。假设我们编写一个不带参数的函数，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We would get the following error when we attempted to run our script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行脚本时，我们会得到以下错误：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are situations where we'll want to make use of the information that gets
    passed in, but even if we fully intend to ignore it, we *must* write our UI-driven
    functions to accept arguments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们会想要使用传递进来的信息，即使我们完全打算忽略它，我们也必须编写UI驱动的函数来接受参数。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `*args` syntax is a bit of handy Python that allows for a variable number
    of arguments to be passed in. Technically, all that really matters is the `*`;
    `*myEpicCollectionOfArguments` would work just as well, but `*args` is the general
    convention.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args`语法是一点有用的Python，允许传递可变数量的参数。技术上，真正重要的是`;`；`*myEpicCollectionOfArguments`同样可以工作，但`*args`是通用约定。'
- en: 'Once we have the function we want to trigger, we set up a window in the conventional
    way, creating it and adding a `columnLayout`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了想要触发的函数，我们就可以按照常规方式设置一个窗口，创建它并添加一个`columnLayout`：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we add the button itself with:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下方式添加按钮本身：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is pretty straightforward—we set the text that appears within the button
    with the `label` argument, and we set the command to execute when it is pressed
    with the `command` (or "c") argument. Note that there are no parentheses after
    the name of the function. That''s because we''re not actually invoking the function;
    we''re just passing the function itself in as the value for the command flag.
    We include parentheses, as in:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接——我们使用`label`参数设置按钮内显示的文本，并使用`command`（或“c”）参数设置按下时执行的命令。请注意，函数名称后面没有括号。这是因为我们实际上并没有调用函数；我们只是将函数本身作为命令标志的值传递。我们包括括号，如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This would result in the function being invoked, and its return value (rather
    than the function itself) being used as the value of the flag. That's almost certainly
    not what you want. The only exception is if you happen to have a function that
    creates a function and returns it, which can be useful in some situations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致函数被调用，并且它的返回值（而不是函数本身）被用作标志的值。这几乎肯定不是你想要的。唯一的例外是如果你恰好有一个创建函数并返回它的函数，这在某些情况下可能很有用。
- en: 'All that''s left is to show our window in the normal way with:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是以正常方式显示我们的窗口：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this is the most common way to use buttons, there are a few other options
    that can be useful in specific circumstances.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是使用按钮最常见的方式，但在某些特定情况下还有一些其他选项可能很有用。
- en: 'For example, the `enable` flag can be a great way to prevent the user from
    taking action that they shouldn''t be able to and to provide feedback. Let''s
    say that we''ve created a button, but it shouldn''t be active until the user takes
    some other action. If we set the enable flag to False, the button will appear
    grayed out and will not respond to the user input:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`enable`标志可以是一个很好的方法来防止用户执行他们不应该能做的操作，并提供反馈。假设我们已经创建了一个按钮，但它在用户执行其他操作之前不应该处于活动状态。如果我们将enable标志设置为False，按钮将显示为灰色，并且不会响应用户输入：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Later, you can make the button (or other control) active by using the edit
    mode to set the enable flag to True, as in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以通过使用编辑模式将enable标志设置为True来激活按钮（或其他控件），如下所示：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keeping controls inactive, until it's appropriate to call them, can be a great
    way to make your scripts a bit more robust and easier to use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的时候才激活控件，可以是一个很好的方法使你的脚本更加健壮且易于使用。
- en: Retrieving input from controls
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控件中检索输入
- en: While you will often need to add one-way controls (such as buttons) that trigger
    functions upon user input, you will also often need to retrieve information from
    the user before taking an action. In this example, we'll be looking at how to
    grab input from field controls, in both integer and float varieties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你经常需要添加单方向控件（如按钮）来在用户输入时触发函数，但你也会经常需要在采取行动之前从用户那里检索信息。在这个例子中，我们将探讨如何从字段控件中获取输入，无论是整数还是浮点数。
- en: 'The finished script will create a given number of polygonal spheres, each with
    a given radius. The resulting UI will look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的脚本将创建指定数量的多边形球体，每个球体具有指定的半径。生成的UI将看起来如下：
- en: '![Retrieving input from controls](img/4657_02_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![从控件中检索输入](img/4657_02_03.jpg)'
- en: 'Pressing the **Make Spheres** button with the previously mentioned settings
    of 4 spheres at a radius of 0.5 units each will result in a line of spheres along
    the x-axis:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前提到的设置（4个球体，每个球体的半径为0.5单位）按下**制作球体**按钮将导致沿x轴出现一串球体：
- en: '![Retrieving input from controls](img/4657_02_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![从控件中检索输入](img/4657_02_04.jpg)'
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new script and name it `makeSpheres.py`. Add the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`makeSpheres.py`。添加以下代码：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the script, enter some values into the two fields, and click on the button.
    You should see a nice orderly line of polygonal spheres running along the x-axis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，在两个字段中输入一些值，然后点击按钮。你应该看到一条整齐的、沿着x轴运行的球体线。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a few different things going on here, all of which are needed to grab
    information from the user. First, we create two variables to hold global references
    to our controls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个不同的事情在进行中，所有这些都需要从用户那里获取信息。首先，我们创建两个变量来保存对控件的全局引用。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We need variables for the fields since we'll need to call the corresponding
    functions twice—once in the create mode (to make the control) and again in the
    query mode to determine what the current value is. We'll also want to make those
    variables global in scope so that we can have separate functions to create UI
    and actually perform the action.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为字段变量设置变量，因为我们需要调用相应的函数两次——一次是在创建模式（创建控件）中，再次是在查询模式中确定当前值。我们还想让这些变量具有全局作用域，这样我们就可以有单独的函数来创建UI并实际执行操作。
- en: The "scope" of a variable or a function refers to the context in which it is
    defined. If a variable is defined outside of any function, it is *global* in scope,
    meaning that it is always accessible. Variables defined within a function, however,
    are *local*, meaning that they only exist within the function in which they are
    defined. Since we need to refer to our controls from two different functions,
    we'll need to make sure that they are global in scope.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 变量或函数的“作用域”指的是它被定义的上下文。如果一个变量在任何函数外部定义，它就是*全局*的，这意味着它始终可访问。然而，在函数内部定义的变量是*局部*的，这意味着它们只存在于定义它们的函数中。由于我们需要从两个不同的函数中引用我们的控件，我们需要确保它们具有全局作用域。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It isn't strictly necessary to have the variables declared at the top of the
    script as I've done here. We *could* just refer to them in the individual functions,
    and as long as we're careful to include the global keyword, it would still work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 并非严格必要在脚本顶部声明变量，就像我这里所做的那样。我们*可以*直接在各个函数中引用它们，只要我们小心地包含全局关键字，它仍然可以工作。
- en: However, I think that it makes things much easier to understand if we declare
    all our global variables at the start.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为如果我们一开始就声明所有全局变量，会使事情更容易理解。
- en: 'Next, we set up UI for the window. Note that we repeat the lines that we used
    to declare the global variables. This is necessary to tell Python that we want
    to use the global scope variables:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置窗口的用户界面。请注意，我们重复了用于声明全局变量的行。这是必要的，以便告诉Python我们想要使用全局作用域变量：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we left out the `global sphereCountField`, we would still end up with a variable
    named `sphereCountField` set to the output of the intField command. However, that
    variable would be of local scope and only available from within the `showUI()`
    function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了`global sphereCountField`，我们仍然会得到一个名为`sphereCountField`的变量，其值由`intField`命令的输出设置。然而，这个变量将是局部作用域的，并且只能在`showUI()`函数内部访问。
- en: In this case, `global sphereCountField` can almost be thought of as an import
    statement because it brings the global variable into the scope of the showUI function.
    We do the same thing in the `makeSpheres` function to make sure that we use the
    same variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`global sphereCountField`几乎可以被视为一个导入语句，因为它将全局变量引入了showUI函数的作用域。我们在`makeSpheres`函数中也做同样的事情，以确保我们使用相同的变量。
- en: 'Next, we set up a window as we''ve done in the past, with the `window()` and
    `columnLayout()` commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`window()`和`columnLayout()`命令设置窗口，就像我们过去做的那样：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we''ve done this, we can use two fields to collect input from the user.
    Since the number of spheres should always be a whole number value, and we should
    always make at least one sphere, we use an `intField` and set the minimum value
    to 1:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们可以使用两个字段来收集用户的输入。由于球体的数量应该始终是整数，并且我们至少应该创建一个球体，我们使用`intField`并将最小值设置为1：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the radius of the spheres, we''ll want to allow for non-integer values,
    but we likely want to ensure a reasonable minimum size. To do this, we create
    a `floatField` with a minimum value of 0.5\. We have the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于球体的半径，我们希望允许非整数值，但可能还想确保一个合理的最小尺寸。为此，我们创建一个最小值为0.5的`floatField`。以下是我们的代码：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we add a button to trigger the creation of the spheres and show the
    window with the `showWindow()` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个按钮来触发球体的创建并使用`showWindow()`命令显示窗口。
- en: 'Moving to the function to create the spheres, we start by (once again) telling
    Python that we want to make use of our two global variables, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 转到创建球体的函数中，我们首先（再次）告诉Python我们想要使用我们的两个全局变量，如下所示：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we''ve done this, we retrieve the current values of the `intField` and
    `floatField`. In both cases, we do that by rerunning the same command that we
    used to create the control, but with the following differences:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们检索`intField`和`floatField`的当前值。在两种情况下，我们通过重新运行用于创建控件的相同命令来实现，但有一些差异：
- en: We pass the name of the control (saved when we created it) as the first argument.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将控制的名字（在我们创建它时保存的）作为第一个参数传递。
- en: We set `query=True` to indicate to Maya that we want to retrieve information
    about the control.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`query=True`以指示Maya我们想要检索有关控件的信息。
- en: We set `value=True` to indicate that the specific attribute that we want to
    retrieve is the control's value.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`value=True`以指示我们想要检索的特定属性是控件的价值。
- en: 'Putting that all together give us the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下内容：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It may seem better to combine the two lines into the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来将这两行合并成以下内容可能更好：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, that doesn't actually work, owing to the way that Python works with
    global variables. Python requires that the declaration of a global variable remains
    separate from any commands that set the value of the variable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这实际上并不起作用，因为Python处理全局变量的方式。Python要求全局变量的声明必须与设置变量值的任何命令保持分离。
- en: 'Once we know how many spheres to create and how big to make each of them, we
    use a for loop to make and position them:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要创建多少个球体以及每个球体的大小，我们就使用for循环来创建和定位它们：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For loops allow you to repeat the same code multiple times. Python implements
    them slightly differently than most other languages in which they always iterate
    over a list of some kind. This means that if we want to do something X times,
    we have to have a list of X items. For this, we'll want the built-in `range()`
    function. By passing `numSpheres` into `range()`, we are asking Python to create
    a list of numbers that starts at 0 and goes up to (numSpheres-1). We can then
    use that list with the for keyword to set our index variable (i) to each of the
    values in our list, which in this case means stepping from 0 to (numSpheres-1).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许你多次重复相同的代码。Python的实现方式与其他大多数语言略有不同，它们总是遍历某种类型的列表。这意味着如果我们想执行X次操作，我们必须有一个包含X个项目的列表。为此，我们将需要内置的
    `range()` 函数。通过将 `numSpheres` 传递给 `range()`，我们要求Python创建一个从0开始到（numSpheres-1）的数字列表。然后我们可以使用这个列表与for关键字一起设置我们的索引变量（i），使其等于列表中的每个值，在这种情况下意味着从0步进到（numSpheres-1）。
- en: Note that we set the radius of each sphere with the radius flag. We also use
    the move function to separate each sphere from its neighbors by slightly more
    than their diameters (myRadius * 2.2). By default, the move command will affect
    the currently selected object (or objects). Since the `polySphere` command leaves
    the created sphere as the only selected object, that's what we'll move.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用半径标志设置每个球体的半径。我们还使用移动函数将每个球体与其邻居稍微分开，比它们的直径（myRadius * 2.2）略大。默认情况下，移动命令将影响当前选定的对象（或对象）。由于
    `polySphere` 命令将创建的球体作为唯一选定的对象留下，因此我们将移动这个对象。
- en: By default, the move command will accept three numbers for the amount by which
    to move the selected object(s)—one for each of the axes. There are a number of
    other ways that the move command can be used; be sure to check the documentation
    for details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，移动命令将接受三个数字来指定移动所选对象（或对象）的量——每个轴一个。移动命令还有许多其他用法；请务必查阅文档以获取详细信息。
- en: Using classes to organize UI logic
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类来组织UI逻辑
- en: Using global variables is one way to allow the different parts of your script
    communicate with each other, but there's a better way. Instead of using globals,
    you can organize your script using custom class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量是允许脚本的不同部分相互通信的一种方式，但还有更好的方法。与其使用全局变量，不如使用自定义类来组织你的脚本。
- en: Creating a class for your script will not only allow you to easily access UI
    elements from various functions, but it will also make it easy to neatly contain
    other kinds of data, useful in more advanced scripts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的脚本创建一个类不仅可以让你轻松地从各种函数中访问UI元素，而且还可以使你轻松地整齐地包含其他类型的数据，这在更高级的脚本中非常有用。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and name it `SpheresClass.py`. Add the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并将其命名为 `SpheresClass.py`。添加以下代码：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the script, and you should get a window that allows you to create a line
    of polygonal spheres along the x-axis.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该会得到一个窗口，允许你沿着x轴创建一串多边形球体。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The overall layout of the script is similar to what we''ve done before, in
    that we have one function to set up the interface and another function to actually
    perform the work. However, in this case, we wrap everything in a class, with:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的整体布局与我们之前所做的是相似的，即我们有一个用于设置界面的函数，另一个用于实际执行工作的函数。然而，在这种情况下，我们将所有内容都封装在一个类中，具体如下：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that the name of the class has been capitalized, which may seem odd, given
    that all of our functions have been lowercase so far. Although that''s by no means
    required, it''s generally common practice to capitalize class names, as it helps
    to distinguish classes from functions. Otherwise, invoking a function can look
    very similar to instantiating a class, leading to confusion. We have the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类的名称已经被大写，考虑到我们之前所有的函数都使用小写，这可能会显得有些奇怪。尽管这并不是必需的，但通常的惯例是将类名大写，因为这有助于区分类和函数。否则，调用函数可能会看起来非常类似于实例化一个类，从而导致混淆。以下是我们有以下代码：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Instantiating a class means that you create a brand new copy of that class,
    and the new copy is referred to as an "instance" of the class. Defining a class
    and instantiating it are two separate actions. The entire block of code that starts
    with the "class" keyword makes up the class definition and defines all of the
    attributes and capabilities of a class. It can be thought of as the blueprint
    for that class. However, to actually make use of a class, we have to actually
    create one. Once you've defined a class, you can make as many instances as you
    want, each with their own properties. The class definition is like the CAD files
    for a product, whereas the instance is like the actual physical product that rolls
    off the assembly line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个类意味着你创建了这个类的一个全新的副本，这个新副本被称为这个类的"实例"。定义一个类和实例化它是两个不同的动作。以"类"关键字开始的整个代码块构成了类的定义，并定义了类的所有属性和能力。它可以被视为该类的蓝图。然而，为了实际使用一个类，我们必须实际创建一个。一旦你定义了一个类，你可以创建尽可能多的实例，每个实例都有自己的属性。类定义就像产品的CAD文件，而实例就像实际物理产品，它从装配线上滚下来。
- en: Once we have a class, we can add functionality to it by adding functions. We
    have to at least create a function named `__init__` that will be responsible for
    initializing each class instance. This function will be called automatically each
    time an instance of the class is called.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个类，我们可以通过添加函数来向它添加功能。我们至少需要创建一个名为`__init__`的函数，该函数将负责初始化每个类实例。这个函数将在每次调用类实例时自动调用。
- en: Note that the `__init__` function takes one argument, which we've labeled "self".
    When Python instantiates a class, it always passes a reference to the instance
    itself to all of the member functions. We could call it anything we want, but
    "self" is the convention and one that we'll adhere to.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__init__`函数接受一个参数，我们将其标记为"self"。当Python实例化一个类时，它总是将实例本身的引用传递给所有成员函数。我们可以称它为任何我们想要的名称，但"self"是惯例，我们将遵守这个惯例。
- en: 'In the `__init__` function, we''ll do everything we need to do to set up out
    UI. In this case, we''ll create one field and one button. We store references
    to the field in an instance variable as properties of the self-object (which remember,
    is just the class instance itself). Doing this will allow us to retrieve the values
    of the controls later in the script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`函数中，我们将完成所有我们需要做的设置UI的工作。在这种情况下，我们将创建一个字段和一个按钮。我们将字段的引用存储在实例变量中，作为self对象的属性（记住，self只是类实例本身）。这样做将允许我们在脚本中稍后检索控件值：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, when we want to tie our controls to actual functionality, we''ll
    need to preface our functions with "self." to refer to the method of our class.
    We do this with the button code in the next line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们想要将我们的控件与实际功能关联起来时，我们需要在函数前加上"self."来引用我们的类方法。我们在下一行的按钮代码中这样做：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting variables as properties of the class via self will make them accessible
    to other functions within the class. Note that we stored a reference to the field,
    but not to the button; this is because we're not likely to want to query anything
    about the button or to change anything about it after it's been created. In such
    cases, it's fine to just use local variables or to not store the results at all.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量作为self的属性设置，将使它们在类内的其他函数中可访问。注意，我们存储了字段的引用，但没有存储按钮的引用；这是因为我们不太可能想要查询关于按钮的任何内容，或者在其创建后更改它。在这种情况下，使用局部变量或根本不存储结果都是可以的。
- en: 'Once we have both our field and our button, we show the window. Now we''re
    ready to add the `makeSpheres` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了字段和按钮，我们就显示窗口。现在我们准备添加`makeSpheres`函数：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the function signature includes "self" as the first argument and has
    "*args", our catch-all for any passed values as the second argument. This is another
    example of how Python passes the class instance into all of its member functions
    each time they are called.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数签名包括作为第一个参数的"self"，以及作为第二个参数的"*args"，它是任何传递值的通配符。这是Python如何将类实例传递给每次调用的所有成员函数的另一个例子。
- en: The rest of the code for the `makeSpheres` function is very similar to what
    we wrote in the non-class-based example. We use the query mode to retrieve the
    number in the `intField`, then we make that many spheres, moving each one by the
    corresponding multiple of the radius to space them out nicely.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeSpheres`函数的其余代码与我们在非类示例中写的非常相似。我们使用查询模式来检索`intField`中的数字，然后制作这么多球体，通过将每个球体移动到半径的相应倍数来使它们分布得很好。'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And with this, we''re done defining our class. However, we also need to actually
    create an instance of it in order to see anything happen. The last line of the
    script does exactly this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们就完成了类的定义。然而，我们还需要实际创建一个实例，以便看到任何变化。脚本的最后一条命令正是这样做的：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This creates a new instance of our `SpheresClass` class and, in so doing, runs
    the `__init__` function, which in turn, sets up our UI and shows it to the user.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了我们`SpheresClass`类的一个新实例，并且在这个过程中运行了`__init__`函数，该函数反过来设置我们的UI并将其显示给用户。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Object-oriented programming** (**OOP**) is a huge topic, and a full treatment
    of all of the ins and outs is beyond the scope of this book. It''s also something
    you''re likely to be familiar with if you''ve been using Python (or any other
    object-oriented language) for any length of time.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是一个很大的主题，全面处理所有细节超出了本书的范围。如果你长时间使用Python（或任何其他面向对象的语言），你可能会熟悉它。'
- en: If this is the first time you're seeing it, be sure to read through the Python
    documentation on classes. OOP practices may seem like a lot of unnecessary overhead
    at first, but they ultimately make it much easier to tackle complex problems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次看到这个，请务必阅读Python文档中的类部分。面向对象编程（OOP）的实践可能一开始看起来是很多不必要的开销，但它们最终会使解决复杂问题变得更加容易。
- en: Using nested layouts
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌套布局
- en: Very often, the interfaces that you'll want to create cannot be implemented
    with a single layout. In those cases, you'll need to nest layouts inside each
    other.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，你想要创建的界面不能仅用一个布局实现。在这种情况下，你需要将布局嵌套在彼此内部。
- en: In this example, we'll create `rowLayouts` within a single columnLayout. Each
    `rowLayout` will allow us to have two controls (in this case, some text and `intField`)
    next to each other horizontally, and the parent `columnLayout` will stack the
    combined text/field pairs on top of each other vertically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在单个`columnLayout`内创建`rowLayouts`。每个`rowLayout`将允许我们在水平方向上并排放置两个控件（在这种情况下，一些文本和`intField`），而父`columnLayout`将垂直堆叠组合的文本/字段对。
- en: 'The end result will be something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果将类似于这样：
- en: '![Using nested layouts](img/4657_02_05.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用嵌套布局](img/4657_02_05.jpg)'
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Make a new script and name it `nestedLayouts.py`. Add the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`nestedLayouts.py`。添加以下代码：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the script, and you should see two rows, each with a bit of text and an
    `intField`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该看到两行，每行都有一些文本和一个`intField`。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, we start out by creating a `columnLayout`, just as we''ve
    done in other examples so far. Then, we immediately create another layout, and
    this time, it is a rowLayout:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个`columnLayout`，就像我们在之前的例子中所做的那样。然后，我们立即创建另一个布局，这次是一个行布局：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you create a layout, it immediately becomes the default parent for any
    other elements (either controls or other layouts) that you create. So, in this
    case, we have a columnLayout that contains a two-column rowLayout.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个布局时，它立即成为你创建的任何其他元素（无论是控件还是其他布局）的默认父级。因此，在这个例子中，我们有一个包含两个列布局的`columnLayout`。
- en: 'Once we''ve done this, we can add elements to our rowLayout, which we do with
    the following lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以向行布局添加元素，这可以通过以下几行代码实现：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, our first rowLayout is filled because we created it with two
    columns and we''ve added two controls to it. If we attempt to add another control,
    we''ll get an error similar to the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的第一行布局已经填满，因为我们创建了一个有两个列的布局，并且已经向其中添加了两个控件。如果我们尝试添加另一个控件，我们会得到一个类似于以下错误的错误：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to continue to add elements to our UI, we''ll need to jump up a level
    back to the `columnLayout`. At any given moment, there is exactly one and only
    one default parent to which Maya will add controls to. Every time you create a
    new layout, it becomes the default parent automatically. Sometimes, you''ll need
    to change the default parent directly, which can be accomplished with the `setParent`
    command, as in the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续向我们的UI添加元素，我们需要回到`columnLayout`的上一级。在任何给定时刻，Maya都会添加控件到一个默认的父级，且只有一个。每次你创建一个新的布局，它就会自动成为默认的父级。有时，你可能需要直接更改默认的父级，这可以通过`setParent`命令实现，如下所示：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using `setParent` and passing `".."` as the argument will move up a single
    level in the hierarchy of layouts. In this case, it means that we move up from
    the rowLayout back to the columnLayout. Once we''ve done this, we can create the
    second rowLayout, again with two columns. We are then free to add a second group
    of a text field and an int field:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setParent`并传递`".."`作为参数将在布局的层次结构中向上移动一个级别。在这种情况下，这意味着我们从行布局回到列布局。一旦我们这样做，我们就可以创建第二个行布局，再次包含两个列。然后我们可以自由地添加一个包含文本字段和整数字段的第二个组：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Jumping around the hierarchy can get a bit tedious. If you're going to have
    a number of controls that you want to add label text to, it might be best to create
    a helper function to your script's class to add a new control.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中跳转可能会有些繁琐。如果你要添加多个控件并为其添加标签文本，最好为你的脚本类创建一个辅助函数来添加新的控件。
- en: 'Here''s an example of what that might look like:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的样子示例：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we take in the text to use for the label, and we return a reference to
    the newly created intField. Rewriting our example using the above would give us
    something like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接收用于标签的文本，并返回对新创建的intField的引用。使用上述方法重写我们的示例将得到以下类似的结果：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is quite a bit neater, indeed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实整洁得多。
- en: Note that our addLabeledIntField accepts two arguments, but we only pass a single
    one to it when we call it. This is due to the way that Python handles classes;
    every class method *always* receives a reference to the class itself. So, any
    arguments that we want to make use of start at the second one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的addLabeledIntField接受两个参数，但当我们调用它时，我们只传递一个参数。这是由于Python处理类的方式；每个类方法*总是*接收对类本身的引用。所以，我们想要使用的任何参数都从第二个开始。
- en: Using tabs and scrolling
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签和滚动
- en: In this example, we'll be looking at how to create UIs that contain tabs and
    how to provide scrollable containers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何创建包含标签的UI以及如何提供可滚动的容器。
- en: 'Our UI will contain two tabs arranged horizontally, with each tab containing
    a scrollable column of 20 buttons. The final result will look something like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的UI将包含两个水平排列的标签页，每个标签页包含一个可滚动的包含20个按钮的列。最终结果将类似于以下：
- en: '![Using tabs and scrolling](img/4657_02_06.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用标签和滚动](img/4657_02_06.jpg)'
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new script, name it `tabExample.py` and add the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`tabExample.py`，并添加以下代码：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating a tab layout is quite easy; all that's required is a call to the `tabLayout`
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建标签布局非常简单；所需做的只是调用`tabLayout`函数。
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we save the output of the `tabLayout` command to an instance variable,
    and we'll need that later. So now we have the tab layout, but we're still not
    ready to add any controls just yet. That's because the tab layout cannot actually
    contain controls directly; it is only meant to hold other layouts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`tabLayout`命令的输出保存到实例变量中，稍后我们需要用到它。所以现在我们有了标签布局，但我们还没有准备好添加任何控件。这是因为标签布局实际上不能直接包含控件；它只是用来包含其他布局的。
- en: 'For the first tab, we''ll keep it simple and just add a `columnLayout`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个标签页，我们将保持简单，只添加一个`columnLayout`：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we also store the output, which in this case is the name of the column
    layout (something like "columnLayout17" or similar). Now we can start adding controls
    if we want, but there's one more thing we'll want to do first.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还存储了输出，在这个例子中是列布局的名称（例如“columnLayout17”或类似）。现在我们可以开始添加控件了，但在此之前我们还有一件事要做。
- en: By default, the text that is displayed in the actual tab of the tabbed layout
    will be the name of the child layout. This will almost never be what you want;
    you'll generally want to give your tabs nice, sensible labels instead of leaving
    them with names like "columnLayout23" and "scrollLayout19".
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在标签布局的实际标签中显示的文本将是子布局的名称。这几乎永远不会是你想要的；你通常会想要给你的标签页提供一些好理解的标签，而不是让它们保留像“columnLayout23”和“scrollLayout19”这样的名称。
- en: 'To do this, we''ll need to edit our tab layout and use the `tabLabel` argument.
    The `tabLabel` argument expects a two-element array of strings, where the first
    string is the name of a child of the tab layout (in this case, our column layout),
    and the second is the text you want to display. Putting this all together gives
    us the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要编辑我们的标签布局并使用`tabLabel`参数。`tabLabel`参数期望一个包含两个字符串的数组，其中第一个字符串是标签布局的子项名称（在本例中，是我们的列布局），第二个是要显示的文本。将这些内容组合起来，我们得到以下结果：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We invoke the tabLayout command in the edit mode, direct it at our tab layout
    (which we stored in the `self.tabs` variable) and set the input to tabLabel such
    that we give our columnLayout the label of "Simple Tab".
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编辑模式下调用tabLayout命令，直接针对我们的标签页布局（我们将其存储在`self.tabs`变量中），并将输入设置为tabLabel，这样我们给columnLayout分配的标签是“简单标签”。
- en: 'Next, we add a single button, just so that we have something inside the tab:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个单独的按钮，这样我们就有一些内容在标签页内：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, we''re done with the first tab and ready to start on the second
    tab. But before we can do this, we need to jump up a level in the hierarchy so
    that we can add new content to the tab layout, rather than continuing to add to
    the column layout we created within it. We do this with the `setParent` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了第一个标签页，并准备开始第二个标签页。但在我们这样做之前，我们需要在层次结构中向上跳一级，这样我们就可以向标签页布局添加新内容，而不是继续添加到我们在其中创建的列布局。我们使用`setParent`命令来完成这个操作：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we''re ready to start on our second tab. This time, we''ll add a scroll
    layout as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始第二个标签页。这次，我们将添加一个滚动布局，如下所示：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once again, we'll edit the original tab layout so that the second tab has a
    proper name.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编辑原始标签页布局，以便第二个标签页有一个合适的名称。
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To finish things off, we'll create a column layout within the scroll layout
    and add some buttons.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成整个设置，我们将在滚动布局内创建一个列布局，并添加一些按钮。
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we''ll use setParent twice (once for the column layout and again for
    the scroll layout) to move back up the hierarchy to the tab layout:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`setParent`两次（一次用于列布局，再次用于滚动布局）来回到标签页布局的层次结构：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We're now ready to add more tabs, if we want.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加更多标签页，我们现在已经准备好了。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you ever need to know which tab is currently selected, you can find out
    via the `selectTabIndex` or sti flag. One gotcha to be aware of is that the number
    returned is indexed based on 1, rather than 0 as you might expect. If you *do*
    receive zero, it means that the tab layout in question doesn''t have any children:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道当前哪个标签页被选中，你可以通过`selectTabIndex`或sti标志来查找。需要注意的一个问题是返回的数字是基于1索引的，而不是你可能期望的0。如果你确实收到了0，这意味着相关的标签页布局没有子项：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also use the `selectTabIndex` to set which tab is currently active.
    For example, if we wanted to ensure that our example started out with the second
    tab selected, we could add the following line to our `__init__` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`selectTabIndex`来设置当前活动的标签页。例如，如果我们想确保我们的示例从第二个标签页开始选中，我们可以在`__init__`函数中添加以下行：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When building complex UIs, having the ability to change behavior based on what
    part of the interface is currently active, or to start the script with a different
    part showing, can be a great way to make your scripts more responsive and easier
    to use.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复杂的UI时，能够根据当前活动界面部分改变行为，或者以不同的部分显示来启动脚本，可以是一种使你的脚本更加响应和易于使用的好方法。
- en: Adding menus to your UIs
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的UIs添加菜单
- en: For more complex scripts, it can be helpful to add a drop-down menu to the top
    of your window. For example, you might want to have your script support custom
    configuration files and allow users to both save the current settings to disk,
    or to load previously saved settings. In that case, implementing the **File**
    menu with suboptions for **Save** and **Load** could be a very user-friendly option.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的脚本，在窗口顶部添加一个下拉菜单可能会有所帮助。例如，你可能希望你的脚本支持自定义配置文件，并允许用户将当前设置保存到磁盘，或者加载以前保存的设置。在这种情况下，实现**文件**菜单并带有**保存**和**加载**子选项可能是一个非常用户友好的选择。
- en: In this example, we'll be creating a window with its own menu, as well as looking
    at how to offer the user additional options via an option box, just like Maya's
    built-in menus.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个带有自己菜单的窗口，以及查看如何通过选项框提供用户额外选项，就像Maya的内置菜单一样。
- en: '![Adding menus to your UIs](img/4657_02_07.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![向你的UIs添加菜单](img/4657_02_07.jpg)'
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and name it `customMenu.py`. Once again, we''ll be creating
    a custom class to handle both our UI creation and functionality:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`customMenu.py`。我们再次将创建一个自定义类来处理我们的UI创建和功能：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you run this code, you'll get a window with a two-item menu (**File** and
    **Objects**), each one of which provides two options.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会得到一个带有两个项目菜单（**文件**和**对象**）的窗口，每个菜单都提供了两个选项。
- en: 'To actually have something happen when the user selects an option, we''ll need
    to provide a value for the command flag for one or more of our menuItem controls,
    as in the following (some of the preceding code has been removed to make the example
    shorter):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用户选择选项时实际发生某些事情，我们需要为我们的menuItem控件中的一个或多个提供命令标志的值，如下所示（一些前面的代码已被删除以缩短示例）：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This would enable both of the **Make Sphere** and **Make Cube** menu items to
    create the respective polygonal geometry.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使**制作球体**和**制作立方体**两个菜单项都能创建相应的多边形几何形状。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Creating menus is pretty easy, and it is mainly just required that you:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建菜单相当简单，主要只需要你：
- en: Include the `menuBare=True` option when creating the initial window.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建初始窗口时包含`menuBare=True`选项。
- en: Add one or more menus with the `menu()` command.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`menu()`命令添加一个或多个菜单。
- en: For each menu, add one or more menuItem controls, providing a command for each.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个菜单，添加一个或多个menuItem控件，为每个提供命令。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Many of Maya's commands offer the user two ways to trigger them—the default
    way and via the command's corresponding option box, which offers the user additional
    options for the command. You can do the same thing with your own menus by adding
    the second menuItem directly after the one to which you want to add an option
    box and setting the second menuItem's `optionBox` flag to true.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Maya的命令提供了两种方式来触发它们——默认方式和通过命令的相应选项框，它为用户提供额外的命令选项。你可以通过添加第二个menuItem直接在你想要添加选项框的menuItem之后，并将第二个menuItem的`optionBox`标志设置为true来实现相同的事情。
- en: 'Let''s say that we want to offer a command to create a polygonal sphere. We
    want the default radius to be 1 unit, but we also want to provide an option box,
    which when selected, will allow the user to specify a custom radius. To do this,
    we would want to add something like the following to our script:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要提供一个创建多边形球体的命令。我们希望默认半径为1单位，但我们还希望提供一个选项框，当用户选择时，将允许用户指定自定义半径。为此，我们可能需要在我们的脚本中添加以下内容：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Even though we're creating two menuItem controls, they would be presented to
    the user as a single entry in the `"Objects"` menu though one with an option box.
    When you add the `optionBox=True` flag to a menuItem control, Maya will add an
    option to the most recently created menuItem. Creating menuItem and setting `optionBox=True`
    without first creating a normal menuItem will leave Maya without anything to add
    the option box to and will result in an error.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们创建了两个menuItem控件，但它们会被用户作为“对象”菜单中的单个条目呈现，尽管其中一个带有选项框。当你将`optionBox=True`标志添加到menuItem控件时，Maya会向最近创建的menuItem添加一个选项。在创建menuItem并设置`optionBox=True`之前不先创建一个正常的menuItem，Maya将没有东西可以添加选项框，并会导致错误。
- en: This may seem a bit odd, but it makes a bit of sense since the default command
    and the option box are two separate clickable areas, so it's not totally unreasonable
    to implement them as separate controls.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，但考虑到默认命令和选项框是两个独立的可点击区域，所以将它们作为独立的控件实现并不是完全不合理。
- en: 'Once we''ve set up the two controls, we''ll want to make sure that they both
    do similar things, but one of them (the option box) provides additional input.
    An easy way to do it is with the `promptDialog` command, which provides an easy
    way to get a single value from the user. To ask the user to input a value for
    the sphere''s radius, we could do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了两个控件，我们想要确保它们都做类似的事情，但其中一个（选项框）提供额外的输入。一个简单的方法是使用`promptDialog`命令，它提供了一个简单的方法从用户那里获取单个值。要要求用户输入球体半径的值，我们可以做以下操作：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code would result in a new popup window with a single field and
    two buttons labeled **OK** and **CANCEL**. You'll note that we're storing the
    result of the promptDialog to a variable named promptInput.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致一个新弹出窗口，包含一个字段和两个标签为**确定**和**取消**的按钮。你会注意到我们将promptDialog的结果存储在一个名为promptInput的变量中。
- en: You might think that this variable would hold the value that the user has entered,
    but that would be incorrect. Instead, it holds the value of the button that they
    pressed to dismiss the dialog. That probably seems strange, but it's necessary
    so that we can determine if the user has actually finalized the command or if
    they are decided to be canceled.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个变量会保存用户输入的值，但这是不正确的。相反，它保存了用户按下的按钮来关闭对话框的值。这可能听起来很奇怪，但这是必要的，这样我们就可以确定用户是否实际上最终化了命令，或者他们决定取消。
- en: 'To actually make use of the input, we''ll want to start by checking to see
    whether the user did, in fact, press the **OK** button. The promptDialog will
    return one of the two values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用输入，我们首先需要检查用户是否确实按下了**确定**按钮。promptDialog 将返回两个值之一：
- en: If the user pressed one of the buttons, the return value will be the text associated
    with that button.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户按下了其中一个按钮，返回值将是与该按钮关联的文本。
- en: If the dialog was dismissed in some other way (like by clicking the X), whatever
    was provided as the dismissString will be returned.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对话框以其他方式（如点击 X）关闭，则返回 dismissString 提供的内容。
- en: 'In our example, if the user pressed one of the buttons, we will have either
    **OK** or **CANCEL** as the return value. Notice that we''ve also set the dismissString
    to **CANCEL** as well. So, all we have to do is to check to see whether **OK**
    was returned, as in:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果用户按下了其中一个按钮，返回值将是**确定**或**取消**。请注意，我们也将 dismissString 设置为**取消**。所以，我们只需要检查是否返回了**确定**，如下所示：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there are `two` equals signs, not one. This is a common source of
    error when people are new to Python. The key thing to remember is that a single
    equals sign always results in an `assignment`, and that you need to use two equals
    signs to perform a check for equality. This is true in many languages (not just
    Python) and stems from the fact that setting a variable to a given value is a
    very different operation than checking two values against each other. Since they
    are two different actions, Python (and most other languages) signifies each in
    a different way—one equals for assignment and two for comparison.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有`两个`等号，而不是一个。这是人们刚开始接触 Python 时常见的错误来源。要记住的关键点是，单个等号总是导致`赋值`，而你需要使用两个等号来执行相等性检查。这在许多语言中（不仅仅是
    Python）都是正确的，并且源于将变量设置为给定值与检查两个值之间的差异是非常不同的操作。由于它们是两种不同的操作，Python（以及大多数其他语言）以不同的方式表示每个操作——一个等号用于赋值，两个用于比较。
- en: If that check passes, then we know that the user pressed **OK** and that we
    should grab the input value. We'll have to do that in a slightly different way
    than we have previously though. In the other examples, we've saved a reference
    to the created control and used that to specify the control when using the query
    mode to grab the value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个检查通过，那么我们知道用户按下了**确定**，我们应该获取输入值。我们不得不以稍微不同的方式来做这件事。在其他例子中，我们保存了对创建的控件的引用，并使用该引用在查询模式下获取值时指定控件。
- en: In this case, however, the `promptDialog` command returns the button pressed,
    rather than a reference to its field. So how are we to refer to the proper control?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，`promptDialog` 命令返回的是按下的按钮，而不是其字段的引用。那么我们如何引用正确的控件呢？
- en: 'As it turns out, we can just use the `promptDialog` command the second time,
    but in the query mode. Even though we don''t specify the specific `promptDialog`
    to query, it will still work since Maya will default to the one that was most
    recently created. Since we''re grabbing the value immediately after creating the
    dialog, this will work just fine. Putting that all together, gives us the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以在第二次使用 `promptDialog` 命令时使用查询模式。即使我们没有指定要查询的特定 `promptDialog`，它仍然会工作，因为
    Maya 会默认使用最近创建的那个。由于我们是在创建对话框后立即获取值，所以这会正常工作。将这些放在一起，我们得到以下内容：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that we have to query "text" rather than "value". Also note that once we
    have the input, it gets passed to a separate function to actually do the work.
    This's important so that we can ensure that the exactly same code is triggered
    by both the default (non-option box) and option box versions of our menu item.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须查询“文本”而不是“值”。另外，请注意，一旦我们有了输入，它就会被传递到另一个函数中，以实际执行工作。这是很重要的，这样我们就可以确保默认（非选项框）和选项框版本的菜单项触发的是完全相同的代码。
- en: This may seem redundant here because we're just creating a sphere, but it's
    still a good idea. Don't duplicate code!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里可能看起来有些多余，因为我们只是创建了一个球体，但仍然是个好主意。不要重复代码！
- en: 'We would end up with three functions—first, to actually perform the work (in
    this case, creating a sphere), second, to call that function with default values
    (for the base menuItem), and third, to call that function after retrieving some
    additional information from the user. Putting all that together would give us
    something like this (the `__init__` method omitted for brevity):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到三个功能——首先，实际执行工作（在这种情况下，创建一个球体），其次，使用默认值调用该函数（对于基本的menuItem），最后，在从用户那里获取一些额外信息后调用该函数。将这些全部组合起来，我们得到类似以下内容（为了简洁，省略了`__init__`方法）：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
