- en: Introduction to Blockchain Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链编程简介
- en: In this book, we'll learn blockchain programming so that you can become a force
    to be reckoned with when finding blockchain opportunities. To achieve this, you
    need to begin by understanding blockchain technology and what it entails. In this
    chapter, we will learn what blockchain technology is. How does blockchain empower
    Bitcoin and Ethereum? We will get an intuitive understanding of blockchain technology.
    We will also replicate some basic functions behind blockchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习区块链编程，以便在寻找区块链机会时成为一个不可忽视的力量。为了实现这一点，你需要从理解区块链技术及其包含的内容开始。在本章中，我们将学习什么是区块链技术。区块链如何赋予比特币和以太坊力量？我们将直观地理解区块链技术。我们还将复制区块链背后的一些基本功能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The rise of cryptocurrency and blockchain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密货币和区块链的崛起
- en: Blockchain technology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链技术
- en: Cryptography
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学
- en: The hashing function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数
- en: Consensus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识
- en: Coding on the blockchain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链上的编码
- en: The rise of cryptocurrency and blockchain
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币和区块链的崛起
- en: Assuming that you didn't live a secluded life as a hermit on a mountain in 2017,
    you would have heard all about cryptocurrency, especially Bitcoin. You didn't
    have to look far to hear about the soaring popularity of this topic, its terminology,
    and its growth in value. At this point, other cryptocurrencies also began to grow,
    making way for headlines such as **Ethereum reaches $1,000!** During this craze,
    people discussed everything about cryptocurrency, from the swinging price to the
    technology behind it, which is blockchain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在2017年不是隐居在山上的隐士，你一定听说过加密货币，尤其是比特币。你不必远去就能听到这个话题的风靡，它的术语和价值的增长。在这一点上，其他加密货币也开始增长，为**以太坊达到1000美元！**等标题铺平了道路。在这狂热中，人们讨论了有关加密货币的一切，从价格的波动到其背后的技术，即区块链。
- en: Blockchain was regarded as the technology that would bring the dawn of a new
    era of justice and prosperity for mankind. It would democratize wealth. It would
    take the power away from the oligarchy and give it back to the people. It would
    protect the data of the people. Then came 2018, and cryptocurrency went down.
    The party was over. Bitcoin now sits at $6,000, while Ethereum sits at less than
    $400.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链被视为将为人类带来新时代的正义和繁荣的技术。它将使财富民主化。它将夺取寡头的权力并归还给人民。它将保护人民的数据。然后到了2018年，加密货币下跌了。派对结束了。比特币现在的价格是6000美元，而以太坊的价格不到400美元。
- en: However, despite the fact that the hype surrounding cryptocurrency had died
    down, it still continues to be a regular point of discussion. Blockchain conferences
    and meetups are cropping up in many places, while investments keep pouring into
    blockchain startups. Andreessen Horowitz, a giant name in Silicon Valley, secured as
    much as $300 million from its limited partner in a dedicated blockchain fund. [1] In
    this case, the opportunities lie where the money flows into. Katheryn Griffith
    Hill, a lead recruiter at Blockchain Developers, claims that [2] there are currently
    fourteen blockchain developer positions available for every blockchain developer. In
    addition, a friend of mine who attended a local blockchain event in Jakarta commented
    on this, stating that I could see around one hundred audience members, but there
    were only around four or five developers. 50% of the audience were investors. There
    are people who want to put money into blockchain, but there are fewer people who
    are capable of developing the product.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管围绕加密货币的炒作已经平息，但它仍然是一个经常讨论的话题。区块链会议和聚会在许多地方涌现，而投资继续涌入区块链初创公司。硅谷的巨头安德烈森·霍洛维茨从其有限合伙人那里获得了高达3亿美元的专门区块链基金。在这种情况下，机会就在资金流入的地方。区块链开发者的首席招聘官Katheryn
    Griffith Hill声称，目前每个区块链开发者有14个职位空缺。此外，我参加了雅加达的一个本地区块链活动的一位朋友评论说，我看到大约100名观众，但只有大约四五名开发者。50%的观众是投资者。有人想把钱投入区块链，但能够开发产品的人却更少。
- en: Blockchain started to be used as a payment solution without the middleman, namely
    Bitcoin. Then, people found out that blockchain has some other properties that
    are interesting. First, it is transparent, meaning people can audit it to check
    whether there is money laundering going on or not. Second, it gives to some extent
    privacy for users, which can be used to avoid profiling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链开始被用作无中间人的支付解决方案，即比特币。然后，人们发现区块链还具有一些其他有趣的特性。首先，它是透明的，意味着人们可以审计它，以检查是否存在洗钱行为。其次，它在一定程度上为用户提供隐私，可以用来避免个人资料被追踪。
- en: Then, after Ethereum was released, people suddenly became creative with how
    to apply blockchain in real life. From creating a token to represent ownership
    of something, such as an autonomous organization or payment with full privacy,
    to digital assets that cannot be duplicated (unlike MP3 files).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在以太坊发布后，人们突然开始创造如何在现实生活中应用区块链。从创建代表某物所有权的代币，比如自治组织或具有完全隐私支付的数字资产，到不能复制的数字资产（不像MP3文件）。
- en: Blockchain technology
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链技术
- en: Most people know Bitcoin exists because of blockchain. But what is blockchain?
    It is an append-only database that consists of blocks that are linked by hashing.
    Here, each block contains many transactions of transferring value (but could be
    other things) between participants secured by cryptography; a consensus between
    many nodes that hold an identical database decides on which new block is to be
    appended next.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人知道比特币存在是因为区块链。但区块链是什么？它是一个仅追加的数据库，由哈希链接的区块组成。在这里，每个区块包含许多由加密技术保护的价值转移交易（但也可能是其他东西）；持有相同数据库的许多节点之间的共识决定下一个要追加的新区块。
- en: You don't have to understand the definition at this point; those are a lot of
    words to chew on! First, I'll explain blockchain to you so that you can adjust
    to this new knowledge as we move through this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不必理解这个定义；这些都是很多需要消化的话！首先，我会向你解释区块链，这样你就可以适应这个新知识，随着我们在本书中的进展。
- en: Going back to the definition of blockchain, we can summarize the definition
    as an append-only database. Once you put something into the database, it cannot
    be changed; there is no Undo. We'll talk about the ramifications of this feature
    in [Chapter 2](8932df34-bbc2-47b9-99f1-18ea76844f44.xhtml), *Smart Contract Fundamentals*.
    This definition entails many things and opens up a whole new world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回到区块链的定义，我们可以总结定义为只能追加的数据库。一旦你把东西放入数据库，它就不能被改变；没有撤销。我们将在[第2章](8932df34-bbc2-47b9-99f1-18ea76844f44.xhtml)
    *智能合约基础*中讨论这一特性的影响。这个定义涉及许多事情，并开启了一个全新的世界。
- en: So, what can you put into this append-only database? It depends on the cryptocurrency.
    For Bitcoin, you can store the transactions of transferring value. For example,
    Nelson sends one Bitcoin to Dian. However, we accumulate many transactions into
    one block before appending them to the database. For Ethereum, the things that
    you can put into the append-only database are richer. This not only includes the
    transaction of transferring value—it could also be a change of state. What I mean
    by state here is really general. For example, a queue for buying a ticket for
    a show can have a state. This state can be empty or full. Similarly to Bitcoin,
    in Ethereum, you gather all the transactions before appending them together in
    this append-only database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可以把什么放入这个只能追加的数据库中呢？这取决于加密货币。对于比特币，你可以存储价值转移的交易。例如，纳尔逊向迪安发送1比特币。然而，在将它们附加到数据库之前，我们将许多交易累积到一个区块中。对于以太坊，你可以将更丰富的东西放入只能追加的数据库中。这不仅包括价值转移的交易，还可以是状态的改变。我在这里所说的状态是非常一般的。例如，购买演出门票的队列可以有一个状态。这个状态可以是空的或者满的。与比特币类似，在以太坊中，你需要在将所有交易一起附加到这个只能追加的数据库之前收集它们。
- en: To make it clearer, we put all these transactions into the block before appending
    them to the append-only database. Aside from the list of transactions, we store
    other things in this block, such as the time when we append the block into the
    append-only database, the target's difficulty (don't worry if you don't know about
    this), and the parent's hash (I'll explain this shortly), among many other things.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，我们将所有这些交易放入区块中，然后再将它们附加到只能追加的数据库中。除了交易列表，我们还在这个区块中存储其他东西，比如我们将区块追加到只能追加的数据库中的时间，目标的难度（如果你不了解这个，不用担心），以及父哈希（我马上会解释这个），以及其他许多东西。
- en: 'Now that you understand the block element of the blockchain, let''s look at
    the chain element. As previously explained, aside from the list of transactions,
    we also put the parent''s hash in the block. But for now, let''s just use a simple
    ID to indicate the parent instead of using a hash. **Parent id** is just the previous
    block id. Here, think of the stack. In the beginning, there is no block. Instead,
    we put **Block A**, which has three transactions: **Transaction 1**, **Transaction
    2**, and **Transaction 3**. Since **Block A** is the first block, it has no parent.
    We then apply **Block B** to **Block A**, which consists of two transactions:
    **Transaction 4** and **Transaction 5**. **Block B** is not the first one in this
    blockchain. Consequently, we set the parent section in **Block B** as the **Block
    A** id because **Block A** is the parent of **Block B**. Then, we put **Block
    C** in the blockchain, which has two transactions: **Transaction 6** and **Transaction
    7**.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了区块链的区块元素，让我们来看看链元素。如前所述，除了交易列表，我们还将父哈希放在区块中。但现在，让我们只使用一个简单的ID来表示父级，而不是使用哈希。**父ID**只是上一个区块的ID。在这里，想象一下堆栈。一开始，没有区块。相反，我们放置了**区块A**，其中包含三笔交易：**交易1**，**交易2**和**交易3**。由于**区块A**是第一个区块，它没有父级。然后，我们将**区块B**应用到**区块A**，其中包括两笔交易：**交易4**和**交易5**。**区块B**不是这个区块链中的第一个区块。因此，我们将**区块B**中的父级部分设置为**区块A**的ID，因为**区块A**是**区块B**的父级。然后，我们将**区块C**放入区块链中，其中包含两笔交易：**交易6**和**交易7**。
- en: 'The parent section in **Block C** would be the **Block B** id, and so on. To
    simplify things, we increment the id from 0 by 1 for every new block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块C**中的父级部分将是**区块B**的ID，依此类推。为了简化事情，我们为每个新区块从0开始递增ID：'
- en: '![](assets/711f6b14-1b62-4d35-bdcd-a6e28364737d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/711f6b14-1b62-4d35-bdcd-a6e28364737d.png)'
- en: 'Let''s implement a database to record the history of what people like and hate.
    This means that when you said you like cats at one point in history, you won''t
    be able to change that history. You may add new history when you change your mind
    (for example, if you then hate cats), but that won''t change the fact that you
    liked them in the past. So, we can see that in the past you liked cats, but now
    you hate them. We want to make this database full of integrity and secure against
    cheating. Take a look at the following code block:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个数据库来记录人们喜欢和讨厌的历史。这意味着当你在历史上某个时刻说你喜欢猫时，你将无法改变那段历史。当你改变主意时（例如，如果你后来讨厌猫），你可以添加新的历史，但这不会改变你过去喜欢它们的事实。因此，我们可以看到在过去你喜欢猫，但现在你讨厌它们。我们希望使这个数据库充满诚信并且安全防止作弊。看一下以下代码块：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you studied computer science, you will recognize this data structure, which
    is called a **linked list**. Now, there is a problem. Say Marie hates Nelson and
    wants to paint Nelson in a negative light. Marie can do this by changing the history
    of block A:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学过计算机科学，你会认识到这种数据结构，它被称为**链表**。现在，有一个问题。假设玛丽讨厌纳尔逊，并希望给纳尔逊抹黑。玛丽可以通过改变区块A的历史来做到这一点：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is unfair to Nelson, who is a big fan of cats. So, we need to add a way
    in which only Nelson can write the history of his own preferences. The way to
    do this is by using a private key and a public key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这对喜欢猫的纳尔逊是不公平的。因此，我们需要添加一种只有纳尔逊才能写下自己偏好历史的方法。这样做的方法是使用私钥和公钥。
- en: Signing data in blockchain
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在区块链中签署数据
- en: 'In blockchain, we use two keys to sign data, to authenticate a message and
    protect it from being altered by unauthorized users. The two keys are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链中，我们使用两个密钥对数据进行签名，以验证消息的真实性并保护免受未经授权的用户篡改。这两个密钥如下：
- en: Private key
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥
- en: Public key
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥
- en: The secrecy of the private key is guarded and it is not made known to the public.
    On the other hand, you let the public key be given out in public. You tell everyone,
    *h**ey, this is my public key*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥的保密性受到保护，不向公众公开。另一方面，您可以将公钥公开。您可以告诉每个人，*嘿，这是我的公钥*。
- en: 'Let''s generate the private key. To do this, we need `openssl` software. You
    can install this by doing the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成私钥。为此，我们需要`openssl`软件。您可以通过以下方式安装它：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, Nelson generates the private key, which is the `nelsonkey.pem` file. He
    must keep this key secret. It is generated as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Nelson生成私钥，即`nelsonkey.pem`文件。他必须保守这个密钥。生成如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the private key, Nelson generates the public key:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从私钥中，Nelson生成公钥：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nelson can share this public key, `nelsonkey.pub`, with everyone. Now, in the
    real world we could set up a simple dictionary of the public key and its owner
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Nelson可以与所有人分享这个公钥`nelsonkey.pub`。现实世界中，我们可以建立一个简单的公钥及其所有者的字典，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will now look at how Nelson can prove that he is the only one who can make
    changes to his history.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下Nelson如何证明他是唯一能够对其历史进行更改的人。
- en: 'First, let''s create a Python virtual environment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个Python虚拟环境：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, install the library:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装库：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the Python script that can be used to sign the message. Name this script
    `verify_message.py` (refer to the code file in the following GitLab link for the
    full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/verify_message.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/verify_message.py)):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以用来签署消息的Python脚本。将此脚本命名为`verify_message.py`（请参考以下GitLab链接中的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/verify_message.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/verify_message.py)）：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When executing this script, nothing will happen, as expected. This means that
    the message is verified with the signature from the public key. The signature
    can only be created by Nelson because you need the private key in order to create
    a signature. However, to verify the message with the signature, you only need
    the public key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，如预期的那样，不会发生任何事情。这意味着消息已通过公钥的签名进行了验证。签名只能由Nelson创建，因为您需要私钥才能创建签名。但是，要使用签名验证消息，您只需要公钥。
- en: 'Let''s take a look at a case in which Marie tries to falsify the facts with
    a script named `falsify_message.py`. Marie tries to put `Nelson hates cat` in
    the history database as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个案例，Marie试图使用名为`falsify_message.py`的脚本伪造事实。Marie试图将`Nelson hates cat`放入历史数据库中，如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here's how the verify method works. Nelson calculates the hash from the message,
    then encrypts it with his private key. The result is the signature. For example,
    if Sky wants to verify the signature, he has the message and the signature. He
    calculates the hash of the message. Then, he decrypts the signature using the
    public key. The result is compared to the hash of the message. If it is the same,
    then everything is well. If not, either the message has been altered or the private
    key used to sign the message is different.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是验证方法的工作原理。Nelson计算消息的哈希值，然后用他的私钥对其进行加密。结果就是签名。例如，如果Sky想要验证签名，他有消息和签名。他计算消息的哈希值。然后，他使用公钥解密签名。结果与消息的哈希值进行比较。如果相同，那么一切正常。如果不同，要么消息已被更改，要么用于签署消息的私钥不同。
- en: 'When doing this, you would get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，您将获得以下输出：
- en: '![](assets/1d5d62fc-eafc-46d7-9607-20748b084469.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d5d62fc-eafc-46d7-9607-20748b084469.png)'
- en: 'So, what does the signature look like? Go back to `verify_message.py` and append
    this line to the end of the file. Then, run the script again:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么签名是什么样的？回到`verify_message.py`，并将以下行附加到文件末尾。然后再次运行脚本：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The signature looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 签名看起来像这样：
- en: '![](assets/2b278750-339c-472b-b97c-b8fc1d92d5bc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2b278750-339c-472b-b97c-b8fc1d92d5bc.png)'
- en: Every message has a different signature, and it's impossible for Marie to guess
    the signature in order to falsify the message. So, with the private key and the
    public key, we can verify whether or not the message is indeed from someone authorized,
    even if we communicate on an unsecured channel.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都有不同的签名，Marie不可能猜到签名以伪造消息。因此，有了私钥和公钥，我们可以验证消息是否确实来自授权人员，即使我们在不安全的通道上进行通信。
- en: 'So with the private key, Nelson could create a signature that is unique to
    the message it tries to sign:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了私钥，Nelson可以创建一个对其尝试签署的消息唯一的签名：
- en: '![](assets/88c70fc5-dd4f-40e1-903f-615373ee1968.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88c70fc5-dd4f-40e1-903f-615373ee1968.png)'
- en: 'Everyone in the world who has Nelson''s public key can verify that Nelson did
    indeed write **Message A**. Nelson can prove he did write **Message A** by showing
    **Signature A**. Everyone can take those two inputs and verify the truth:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上每个拥有Nelson公钥的人都可以验证Nelson确实写了**消息A**。Nelson可以通过展示**签名A**来证明他确实写了**消息A**。每个人都可以获取这两个输入并验证真相：
- en: '![](assets/1712437e-8359-47e6-b1bf-3f465bafd63e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1712437e-8359-47e6-b1bf-3f465bafd63e.png)'
- en: 'So, to validate whether or not it is Nelson who wrote `Nelson likes cat`, input
    the following (refer to the code file in the following GitLab link for the full
    code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/validate_message.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/validate_message.py)):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要验证是否是Nelson写的`Nelson likes cat`，请输入以下内容（请参考以下GitLab链接中的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/validate_message.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_01/validate_message.py)）：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From linked list to blockchain
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从链表到区块链
- en: 'Now we know that only Nelson can write `Nelson likes cats` or `Nelson hates
    cats`, we can be at peace. However, to make the tutorial code short, we won''t
    integrate the validation using the private key and the public key. We assume only
    authorized people are able to write the history in the block. Take a look at the
    following code block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道只有尼尔森能写`尼尔森喜欢猫`或`尼尔森讨厌猫`，我们可以安心了。然而，为了使教程代码简短，我们不会集成使用私钥和公钥进行验证。我们假设只有授权的人能够在区块中写历史。看一下以下代码块：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When that happens, we assume it's Nelson who wrote that history. So, what is
    the problem in recording data with a linked list?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，我们假设是尼尔森写了那段历史。那么，用链表记录数据的问题是什么呢？
- en: 'The problem is that the data can be altered easily. Say Nelson wants to be
    a senator. If many people in his district don''t like cats, they may not be happy
    with the fact that Nelson likes them. Consequently, Nelson wants to alter the
    history:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于数据可以很容易地被更改。比如尼尔森想成为一名参议员。如果他的选区有很多人不喜欢猫，他们可能不会喜欢尼尔森喜欢它们的事实。因此，尼尔森想要更改历史：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like that, the history has been changed. We can avoid this way of cheating
    by recording all history in the block every day. So, when Nelson alters the database,
    we can compare the data in the blockchain today to the data in the blockchain
    yesterday. If it's different, we can confirm that something fishy is happening.
    That method could work, but let's see if we can come up with something better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，历史已经改变了。我们可以通过每天在区块中记录所有历史的方式来避免这种作弊。因此，当尼尔森改变数据库时，我们可以将今天区块链中的数据与昨天区块链中的数据进行比较。如果不同，我们可以确认发生了可疑的事情。这种方法可能有效，但让我们看看是否能想出更好的办法。
- en: 'Let''s upgrade our linked list to the blockchain. To do this, we add a new
    property in the `Block` class, which is the parent''s hash:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的链表升级为区块链。为此，我们在`Block`类中添加一个新属性，即父哈希：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s demonstrate what the `hashlib()` function does:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示`hashlib()`函数的作用：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we change the history of `block_A`, the following code look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变`block_A`的历史，以下代码看起来像这样：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, the history has been changed just like that. However, this time there
    is a twist. We can verify that this change has occurred by printing the original
    parent''s hash of `block_C`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，历史已经被改变就像那样。然而，这一次有一个转折。我们可以通过打印`block_C`的原始父哈希来验证这一变化已经发生：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s recalculate the parent''s hash of each block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新计算每个区块的父哈希：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These blocks are different. By looking at these, we can be very sure that the
    history has been altered. Consequently, Nelson would be caught red-handed. Now
    if Nelson wants to alter the history without getting caught, it is not enough
    to change the history in `block_A` anymore. Nelson needs to change all the `parent_hash`
    properties in every block (except `block_A` of course). This is tougher cheating.
    With three blocks only, Nelson needs to change two `parent_hash` properties. With
    a 1,000 blocks, Nelson needs to change 999 `parent_hash` properties!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区块是不同的。通过观察这些，我们可以非常确定历史已经被更改。因此，尼尔森将被当场抓住。现在，如果尼尔森想要更改历史而不被抓住，仅仅更改`block_A`中的历史已经不够了。尼尔森需要更改每个区块中的`parent_hash`属性（当然除了`block_A`）。这是更难的作弊。仅有三个区块，尼尔森就需要更改两个`parent_hash`属性。有了1000个区块，尼尔森就需要更改999个`parent_hash`属性！
- en: Cryptography
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: 'The most popular use of blockchain is to create a cryptocurrency. As the word
    **crypto** is in cryptocurrency, you would expect that you need to master cryptography
    in order to become a blockchain programmer. That is not true. You only need to
    know two things about cryptography:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链最流行的用途是创建加密货币。由于加密货币中有**crypto**这个词，你可能会认为你需要精通密码学才能成为区块链程序员。这是不正确的。你只需要了解密码学的两件事：
- en: Private key and public key (asymmetric cryptography)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥和公钥（非对称加密）
- en: Hashing
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: These two have been explained in the previous part of this chapter. You don't
    need to know how to design a hashing algorithm or private key and public key algorithm.
    You only need to get an intuitive understanding of how they work and the implications
    of these technologies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个在本章的前一部分已经解释过了。你不需要知道如何设计哈希算法或私钥和公钥算法。你只需要对它们的工作方式和这些技术的含义有直观的理解。
- en: The implication of private keys and public keys is that it enables decentralized
    accounts. In a normal application, you have a username and password. These two
    fields enable someone to access their account. But having a private key and public
    key enables someone to have an account in a decentralized manner.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥和公钥的含义是它实现了去中心化账户。在普通应用中，你有一个用户名和密码。这两个字段使某人能够访问他们的账户。但是拥有私钥和公钥使某人能够以去中心化的方式拥有一个账户。
- en: 'For hashing, it is a one-way function, meaning that given an input, you can
    get the output easily. But given an output, you couldn''t get the input. A simple
    version of a one-way function would be this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于哈希，它是一个单向函数，意味着给定一个输入，你可以轻松地得到输出。但是给定一个输出，你无法得到输入。一个简单版本的单向函数可能是这样的：
- en: '![](assets/b8d813f7-cdf1-4f4e-9415-b393199bb8e2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8d813f7-cdf1-4f4e-9415-b393199bb8e2.png)'
- en: This is an addition process. If I tell you one of the outputs of this function
    is 999, and I ask you what the inputs are, you couldn't guess the answer. It could
    be anything from 1 and 998 to 500 and 499\. A hashing function is something like
    that. The algorithm is clear as sky (you can read the algorithm of any hashing
    function on the internet), but it's hard to reverse the algorithm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个附加过程。如果我告诉你这个函数的一个输出是999，然后问你输入是什么，你无法猜出答案。它可以是从1和998到500和499的任何东西。哈希函数就像这样。算法就像天空一样清晰（你可以在互联网上阅读任何哈希函数的算法），但是很难逆转算法。
- en: 'So, all you need to know about hashing is this: given input **input** you get
    this SHA-256 output (in hexadecimal): `c96c6d5be8d08a12e7b5cdc1b207fa6b2430974c86803d8891675e76fd992c20`.
    If you don''t know the input, you couldn''t get the input based on this output
    alone. Say you know the input **input** it is very prohibitive to find another
    input that produces the same output. We wouldn''t even know whether such input
    exists or not.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于哈希，你需要知道的是：给定输入 **input**，你会得到这个SHA-256输出（十六进制）：`c96c6d5be8d08a12e7b5cdc1b207fa6b2430974c86803d8891675e76fd992c20`。如果你不知道输入，你就无法仅凭这个输出得到输入。假设你知道输入
    **input**，要找到另一个产生相同输出的输入是非常困难的。我们甚至不知道是否存在这样的输入。
- en: That is all you need to know about cryptography when you become a blockchain
    developer. But that's only true if you become a certain type of blockchain developer,
    who creates a program on top of Ethereum.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你成为区块链开发者时需要了解的有关加密的一切。但是，只有当你成为某种类型的区块链开发者时才是真的，这种开发者会在以太坊之上创建程序。
- en: Symmetric and asymmetric cryptography
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称和非对称加密
- en: Symmetric cryptography uses the same key between sender and receiver. This key
    is used to encrypt and decrypt a message. For example, you want to create an encryption
    function to encrypt text. Symmetric cryptography could be as simple as adding
    5 to the text to be encrypted. If A (or 65 in ASCII) is the text to be encrypted,
    then this encryption function will add 5 to 65\. The encrypted text would be F
    (or 71 in ASCII). To decrypt it, you just subtract 5 from the encrypted text,
    F.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密使用发送方和接收方之间相同的密钥。这个密钥用于加密和解密消息。例如，你想创建一个加密函数来加密文本。对称加密可能就是简单地将文本加5。如果 A（或者ASCII中的65）是要加密的文本，那么这个加密函数将65加5。加密后的文本将是F（或者ASCII中的71）。要解密它，只需从加密后的文本F中减去5。
- en: 'Asymmetric cryptography is a different beast. There are two keys: a public
    key and a private key. They are linked with a special mathematical relationship.
    If you encrypt a message with a public key, you can only decrypt it with a private
    key. If you encrypt a message with a private key, you can only decrypt it with
    a public key. There is no straight relationship as with symmetric keys (adding
    and subtracting the same number) between a public key and a private key. There
    are a couple of asymmetric cryptography algorithms. I''ll explain the easiest
    one, the RSA algorithm.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密是一种不同的东西。有两个密钥：公钥和私钥。它们之间有一个特殊的数学关系。如果你用公钥加密一条消息，你只能用私钥解密它。如果你用私钥加密一条消息，你只能用公钥解密它。与对称密钥（加减相同的数字）之间的关系不同，公钥和私钥之间没有直接的关系。有几种非对称加密算法。我将解释最简单的一种，即RSA算法。
- en: 'Generate two prime numbers, called `p` and `q`. They should be really big numbers
    (with at least hundreds of digits), but for this example, we choose low numbers:
    11 and 17\. These are your private key. Don''t let someone know these numbers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生成两个素数，称为 `p` 和 `q`。它们应该是非常大的数字（至少有数百位数），但是对于这个例子，我们选择了较小的数字：11 和 17。这些是你的私钥。不要让别人知道这些数字：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`n` is a composite number. In our case, `n` is `187`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` 是一个合数。在我们的例子中，`n` 是 `187`。'
- en: 'Then, we find `e` number, which should be relatively prime, with `(p-1)x(q-1)`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到 `e` 数，它应该与 `(p-1)x(q-1)` 互质：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Relatively prime means `e` and `(p-1) x (q-1)` cannot be factorized with any
    number except *1*. There is no number other than 1 that we can divide them by
    without a remainder. So, *e* is *7*. But, *e* can be *11* as well. For this example,
    we choose *7* for *e*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 互质意味着 `e` 和 `(p-1) x (q-1)` 除了 *1* 之外不能被任何数字因数分解。除了1之外，没有其他数字可以整除它们而不产生余数。因此，*e*
    是 *7*。但是，*e* 也可以是 *11*。在这个例子中，我们选择 *7* 作为 *e*。
- en: '*e* and *n* are your public key. You can tell these numbers to strangers you
    meet on the bus, your grandma, your friendly neighbor, or your date.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* 和 *n* 是你的公钥。你可以把这些数字告诉你在公交车上遇到的陌生人、你的祖母、友好的邻居或者你的约会对象。'
- en: Let's say the message we want to encrypt is *A*. In the real world, encrypting
    a short message like this is not safe. We have to pad the short message. So, *A*
    would be something like `xxxxxxxxxxxxxxxxxxxA`. If you check the previous script
    to encrypt a message earlier in this chapter, you would see there is a padding
    function. But for this example, we would not pad the message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要加密的消息是A。在现实世界中，加密这样一个短消息是不安全的。我们必须填充这个短消息。因此，*A* 将变成类似 `xxxxxxxxxxxxxxxxxxxA`。如果你查看本章早些时候加密消息的脚本，你会看到有一个填充函数。但是在这个例子中，我们不会填充消息。
- en: 'The encryption function is this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 加密函数是这样的：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, the `encrypted_message` would be *65 ** 7 % 187 = 142*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`encrypted_message` 将是 *65 ** 7 % 187 = 142*。
- en: 'Before we are able to decrypt the message, we need to find the `d` number:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够解密消息之前，我们需要找到 `d` 数：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`d` is *23*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`d` 是 *23*。'
- en: 'The decryption function is this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解密函数是这样的：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, the `decrypted_message` would be *142 ** 23 % 187 = 65\. 65* in ASCII is
    *A*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`decrypted_message` 将是 *142 ** 23 % 187 = 65*。65在ASCII中是A。
- en: Apparently, `x^y mod n` is easy to calculate, but finding the *y* root of integer
    module *n* is really hard. We call this trapdoor permutation. Factorization of
    *n* to find *p* and *q* is really hard (generating a private key from a public
    key). But, finding *n* from *p* and *q* is easy (generating a public key from
    a private key). These properties enable asymmetric cryptography.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`x^y mod n` 很容易计算，但是找到整数模 *n* 的 *y* 次根确实很难。我们称之为陷门置换。对 *n* 因数分解以找到 *p* 和
    *q* 是非常困难的（从公钥生成私钥）。但是，从 *p* 和 *q* 找到 *n* 是容易的（从私钥生成公钥）。这些属性使得非对称加密成为可能。
- en: 'Compared to symmetric cryptography, asymmetric cryptography enables people
    to communicate securely without needing to exchange keys first. You have two keys
    (private key and public key). You throw the public key out to anyone. All you
    need to do is to protect the secrecy of the private key. The private key is like
    a password to your Bitcoin/Ethereum account. Creating an account in any cryptocurrency
    is just generating a private key. Your address (or your username in cryptocurrency)
    is derived from the public key. The public key itself can be derived from the
    private key. An example of Bitcoin''s private key in **Wallet Import Format**
    (**WIF**) is this: `5K1vbDP1nxvVYPqdKB5wCVpM3y99MzNqMJXWTiffp7sRWyC7SrG`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称加密相比，非对称加密使人们能够在不需要先交换密钥的情况下进行安全通信。你有两个密钥（私钥和公钥）。你把公钥给任何人。你只需要保护私钥的保密性。私钥就像是你的比特币/以太坊账户的密码。在任何加密货币中创建账户只是生成一个私钥。你的地址（或者说在加密货币中的用户名）是由公钥派生出来的。公钥本身可以由私钥派生出来。比特币的私钥的一个例子是**钱包导入格式**（**WIF**）：`5K1vbDP1nxvVYPqdKB5wCVpM3y99MzNqMJXWTiffp7sRWyC7SrG`。
- en: 'It has 51 hexadecimal characters. Each character can have 16 combinations.
    So, the amount of private keys is as follows: `16 ^ 51 = 25711008708143844408671393477458601640355247900524685364822016`
    (it''s not exactly this amount, because the first number of a private key in Bitcoin
    is always 5 in mainnet, but you get the idea). That is a huge number. So, the
    probability of someone finding another account that is filled with Bitcoin already
    when generating a private key with a strong random process is very, very low.
    But the kind of account generated by a private key and public key does not have
    a reset password feature.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它有51个十六进制字符。每个字符可以有16种组合。因此，私钥的数量如下：`16 ^ 51 = 25711008708143844408671393477458601640355247900524685364822016`（实际数量并非如此，因为比特币的私钥的第一个数字在主网上始终为5，但你明白我的意思）。这是一个巨大的数字。因此，通过强大的随机过程生成私钥时，有人找到另一个已经充满比特币的账户的概率是非常非常低的。但是私钥和公钥生成的账户类型没有重置密码功能。
- en: If someone sends Bitcoin to your address, and you forgot your private key, then
    it's gone for good. So, while your public key is recorded on the blockchain that
    is kept in every Bitcoin node, people are not going to get the private key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人向你的地址发送比特币，而你忘记了你的私钥，那么它就永远丢失了。因此，尽管你的公钥被记录在每个比特币节点中的区块链上，但人们不会得到私钥。
- en: The hashing function
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: 'Hashing is a function that takes an input of any length and turns it into a
    fixed length output. So, to make this clearer, we can look at the following code
    example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一个函数，它接受任意长度的输入并将其转换为固定长度的输出。因此，为了更清楚地说明这一点，我们可以看下面的代码示例：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, the length of the input can be *1*, *5*, or even *20* characters,
    but the output will always be the length of *64* hexadecimal numeric characters.
    The output looks scrambled and it appears that there is no apparent link between
    the input and the output. However, if you give the same input, it will give the
    same output every time:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输入的长度可以是*1*、*5*，甚至*20*个字符，但输出始终是*64*个十六进制数字字符的长度。输出看起来是乱码，似乎输入和输出之间没有明显的联系。然而，如果给出相同的输入，它每次都会产生相同的输出：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you change the input by even just a character, the output would be totally
    different:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只改变一个字符的输入，输出也会完全不同：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that the output has a fixed length, which is 64 in this case, of course
    there will be two different inputs that have the same output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出的长度是固定的，这种情况下是64，当然会有两个不同的输入产生相同的输出。
- en: 'Here is the interesting thing: it is very prohibitive to find two different
    inputs that have the same output as this hashing function. Mission Impossible:
    even if you hijack all the computers in the world and make them run the hashing
    computation, it is unlikely that you would ever find two different inputs with
    the same output.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是：找到两个不同的输入，使得这个哈希函数的输出相同是非常困难的。不可能的任务：即使你劫持了世界上所有的计算机并让它们运行哈希计算，你也不太可能找到两个不同的输入产生相同的输出。
- en: Not all hashing functions are safe though. `SHA-1` already died in 2017\. This
    means that people can find two different long strings that have the same output.
    In this example, we will use `SHA-256`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的哈希函数都是安全的。`SHA-1`在2017年已经消亡。这意味着人们可以找到两个不同的长字符串，它们具有相同的输出。在这个例子中，我们将使用`SHA-256`。
- en: The output of the hashing function can be used as a digital signature. Imagine
    you have a string with a length of 10 million (say you are writing a novel), and
    to make sure this novel is not tampered with, you tell all your potential readers
    that they have to count the 10 million characters in order to ensure that the
    novel isn't be corrupted. Nobody would do that. But with hashing, you can publish
    the output validation with only 64 characters (through Twitter, for example) and
    your potential readers can hash the novel that they buy/download and compare them
    to make sure that their novel is legit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的输出可以用作数字签名。想象一下，你有一个长度为1000万的字符串（比如你在写一部小说），为了确保这部小说没有被篡改，你告诉所有潜在的读者，他们必须数一遍这1000万个字符，以确保小说没有被损坏。但是没有人会这样做。但是通过哈希，你可以用只有64个字符的输出验证（比如通过Twitter），你的潜在读者可以对他们购买/下载的小说进行哈希，并进行比较，以确保他们的小说是合法的。
- en: So, we add the parent's hash in the block class. This way, we keep the digital
    signature of the parent's block in our block. This means that if we are ever naughty
    and change the content of any block, the parent's hash in any child's block will
    be invalid, and you would get caught red-handed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在块类中添加了父哈希。这样，我们在我们的块中保留了父块的数字签名。这意味着如果我们有任何块的内容发生变化，任何子块中的父哈希将无效，你将被当场抓住。
- en: 'But can''t you change the parent''s hash of the children''s block if you want
    to alter the content of any block? You can, obviously. However, the process of
    altering the content becomes more difficult. You have to have two steps. Now,
    imagine you have 10 blocks and you want to change the content in the first block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想改变任何区块的内容，你可以改变子区块的父哈希吗？显然可以。然而，改变内容的过程变得更加困难。你需要有两个步骤。现在，想象一下你有10个区块，你想改变第一个区块的内容：
- en: In this case, you have to change the parent's hash in its immediate child's
    block. But, alas, there are unseen ramifications with this. Technically speaking,
    the parent's hash in its immediate child is a part of the content in that block.
    That would mean that the parent's hash in its child (the grandchild of the first
    block) would be invalid.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须改变其直接子区块中父区块的哈希。但是，遗憾的是，这会带来看不见的后果。从技术上讲，其直接子区块中的父哈希是该区块中的一部分。这意味着其子区块中的父哈希（第一个区块的孙子）将无效。
- en: Now, you have to change that grandchild's parent's hash, but this affects the
    subsequent block, and so on. Now, you have to change all blocks' parent's hashes.
    For this, ten steps need to be taken. Using a parent's hash makes tampering much
    more difficult.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须改变那个孙子的父哈希，但这会影响后续的区块，依此类推。现在，你必须改变所有区块的父哈希。为此，需要进行十个步骤。使用父哈希使篡改变得更加困难。
- en: Proof of work
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作证明
- en: 'So, we have three participants in this case: Nelson, Marie, and Sky. But there
    is another type of participant too: the one who writes into the blockchain is
    called—in blockchain parlance—the miner. In order to put the transaction into
    the blockchain, the miner is required to do some work first.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这种情况下，我们有三个参与者：纳尔逊，玛丽和斯凯。但还有另一种类型的参与者：在区块链术语中，写入区块链的人被称为矿工。为了将交易放入区块链，矿工需要先做一些工作。
- en: 'Previously, we had three blocks (`block_A`, `block_B`, and `block_C`), but
    now we have a candidate block (`block_D`), which we want to add into the blockchain
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们有三个区块（`block_A`，`block_B`和`block_C`），但现在我们有一个候选区块（`block_D`），我们希望将其添加到区块链中，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But instead of adding `block_D` to the blockchain just like that, we first require
    the miner to do some puzzle work. We serialize that block and ask the miner to
    apply an extra string, which, when appended to the serialization string of that
    block, will show the hash output with at least five zeros in the front, if it
    is hashed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不是直接将`block_D`添加到区块链中，而是首先要求矿工做一些谜题工作。我们对该区块进行序列化，并要求矿工应用一个额外的字符串，当附加到该区块的序列化字符串时，如果进行哈希，将显示前面至少有五个零的哈希输出。
- en: 'Those are a lot of words to chew on. First things first, we serialize the block:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是需要仔细思考的话。首先，我们对区块进行序列化：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the serialized block is hashed, what does it mean if we want the hash output
    to have at least five zeros at the front? It means that we want the output to
    look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对序列化的区块进行哈希，如果我们希望哈希输出的前面至少有五个零，那意味着我们希望输出看起来像这样：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, we want it to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们希望它看起来像这样：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the puzzle is something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个谜题就像这样：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The miner needs to guess the correct answer. If this puzzle is converted to
    Python code, it would be something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工需要猜出正确的答案。如果将这个谜题转换为Python代码，它会是这样的：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, how could the miner solve a problem like this? We can use brute force:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，矿工如何解决这样的问题呢？我们可以使用穷举法：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result would therefore be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果将如下所示：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means that the answer is `184798`, or the hash output of `{"history":
    "Sky loves turtle", "parent_id": 3, "id": 4}184798` is the one that has five leading
    zeros. In that simple script, we iterate from 0 to 9999999 and append that into
    the input. This is a naive method, but it works. Of course, you could also append
    with characters other than numbers, such as a, b, or c.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '这意味着答案是`184798`，或者`{"history": "Sky loves turtle", "parent_id": 3, "id": 4}184798`的哈希输出是前面有五个零的那个。在这个简单的脚本中，我们从0迭代到9999999，并将其附加到输入中。这是一种天真的方法，但它有效。当然，你也可以附加字符而不是数字，比如a、b或c。'
- en: Now, try to increase the number of leading zeros to six, or even ten. In this
    case, can you find the hash output? If there is no output, you could increase
    the range limit from 10000000 to an even higher number, such as 1000000000000\.
    Once you get an appreciation of the hard work that goes into this, try to comprehend
    this: Bitcoin required around 18 leading zeros in the hash output at the time
    that this book was being written. The number of leading zeros is not static and
    changes according to the situation (but you don't need to worry about this).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，试着将前导零的数量增加到六个，甚至十个。在这种情况下，你能找到哈希输出吗？如果没有输出，你可以将范围限制从10000000增加到更高的数字，比如1000000000000。一旦你对这个工作的艰辛有所了解，试着理解这一点：比特币在这本书写作时需要大约18个前导零的哈希输出。前导零的数量不是固定的，会根据情况而变化（但你不需要担心这个）。
- en: So, why do we need proof of work? We need to take a look at the idea of consensus
    first.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要工作证明呢？我们首先需要看一下共识的概念。
- en: Consensus
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识
- en: As we can see, the hashing function makes history tampering hard, but not too
    hard. Even if we have a blockchain that consists of 1000 blocks, it would be trivial
    to alter the content of the first block and change the 999 parent hashes on the
    other blocks with recent computers. So, to ensure that bad people cannot alter
    the history (or at least make it very hard), we distribute this append-only database
    to everyone who wants to keep it (let's call them miners). Say there are ten miners.
    In this case, you cannot just alter the blockchain in your copy because the other
    nine miners who would scold, saying something like *hey, our records say history
    A but your record says B*. In this case, the majority wins.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，哈希函数使得篡改历史变得困难，但并非太难。即使我们有一个由1000个区块组成的区块链，利用现代计算机轻而易举地改变第一个区块的内容，并将其他区块上的999个父哈希值更改。因此，为了确保坏人无法更改历史（或者至少使其变得非常困难），我们将这个追加数据库分发给每个想要保存它的人（让我们称他们为矿工）。假设有十个矿工。在这种情况下，你不能仅仅在你的副本中更改区块链，因为其他九个矿工会责骂你，说一些像“嘿，我们的记录显示历史A，但你的记录显示B”的话。在这种情况下，多数人胜出。
- en: However, consensus is not just a case of choosing which blockchain has been
    chosen by the majority. The problem starts when we want to add a new block to
    the blockchain. Where do we start? How do we do it? The answer is that we broadcast.
    When we broadcast the candidate block that contains a new transaction, it will
    not reach every miner at the same time. You may reach the miner that stands beside
    you, but it will require time for your message to reach the miner that stands
    far away from you.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，共识不仅仅是选择大多数人选择的区块链。问题在于当我们想要向区块链中添加一个新区块时。我们从哪里开始？我们该如何做？答案是我们广播。当我们广播包含新交易的候选区块时，它不会立即到达每个矿工。你可能会到达站在你旁边的矿工，但你的消息需要时间才能到达远离你的矿工。
- en: 'Here''s where it gets interesting: the miner that stands far away from you
    may receive another new candidate block first. So, how do we synchronize all these
    things and make sure that the majority will have the same blockchain? The simple
    rule is to choose the longest chain. So if you are a miner in the middle, you
    may receive two different candidate blocks at the same time, as shown in the following
    figure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有趣的地方：远离你的矿工可能会先收到另一个新的候选区块。那么，我们如何同步所有这些事情，并确保大多数人拥有相同的区块链呢？简单的规则是选择最长的链。因此，如果你是中间的矿工，你可能会同时收到两个不同的候选区块，如下图所示：
- en: '![](assets/2a5eb6cd-7179-466b-8672-e1fb39c26d53.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a5eb6cd-7179-466b-8672-e1fb39c26d53.png)'
- en: 'You get this from the West side:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你从西边得到这个：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And you get this from the East side:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你从东边得到这个：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, we will keep both versions of `block_E`. Our blockchain now has a branch.
    However, in a short time, other blocks have arrived from the East side. Here is
    the situation now:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将保留`block_E`的两个版本。我们的区块链现在有一个分支。然而，不久后，来自东边的其他区块已经到达。现在的情况是这样的：
- en: '![](assets/51f0c9e9-e2ca-4473-9eb4-0a91178e331e.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51f0c9e9-e2ca-4473-9eb4-0a91178e331e.png)'
- en: 'This is from the West side:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自西边的：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is from the East side:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自东边的：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By this point, we can get rid of the West side version of the blockchain because
    we chose the longer version.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们可以摆脱区块链的西侧版本，因为我们选择了更长的版本。
- en: 'Here comes the problem. Say Sherly hates sharks but Sherly wants to get votes
    from a district where most people only vote for a candidate who loves sharks.
    To get more votes, Sherly broadcasts a block containing the following lie:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 问题来了。假设Sherly讨厌鲨鱼，但她想从一个地区获得选票，那里的大多数人只投票给喜欢鲨鱼的候选人。为了获得更多选票，Sherly广播了一个包含以下谎言的区块：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All is fine and dandy. The voting session takes one day. After one day has
    passed, the blockchain has gotten another two blocks:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好。投票会话持续一天。一天过去后，区块链又增加了两个区块：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following figure illustrates the three blocks:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了三个区块：
- en: '![](assets/37763ec3-f582-4528-9964-a090f1d74c44.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37763ec3-f582-4528-9964-a090f1d74c44.png)'
- en: Now, Sherly needs to get votes from another district where most people only
    vote for candidates who hate sharks. So, how can Sherly tamper with the blockchain
    to make this work in her favor? Sherly could broadcast four blocks!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Sherly需要从另一个地区获得选票，那里的大多数人只投票给讨厌鲨鱼的候选人。那么，Sherly如何篡改区块链以使其对她有利呢？Sherly可以广播四个区块！
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following figure illustrates the four blocks:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了四个区块：
- en: '![](assets/f549c02e-be9d-43b0-a6d0-3fadf539c526.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f549c02e-be9d-43b0-a6d0-3fadf539c526.png)'
- en: The miner will choose the blockchain from Sherly instead of the previous blockchain
    they kept, which contains the history of `Sherly loves sharks`. So, Sherly has
    been able to change the history. This is what we call a double-spending attack.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工将选择来自Sherly而不是他们之前保存的区块链，其中包含“Sherly爱鲨鱼”的历史。因此，Sherly已经能够改变历史。这就是我们所说的双重支付攻击。
- en: 'We can prevent this through proof of work (an incentive for adding blocks).
    We explained proof of work earlier in this chapter, but we haven''t explained
    the incentive system yet. An incentive means that if the miner successfully adds
    a new block to the blockchain, the system gives them a digital reward. We can
    integrate it into the code as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过工作证明（添加区块的激励）来防止这种情况。我们在本章前面解释了工作证明，但我们还没有解释激励系统。激励意味着如果矿工成功地将新区块添加到区块链中，系统会给予他们数字奖励。我们可以将其整合到代码中如下：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If Sherly wants to alter the history (by replacing some blocks), she needs to
    spend some resources by solving four puzzles in a short time. By the times she
    finishes doing this, the blockchain kept by the most miners would have likely
    added more blocks, making it longer than Sherly's blockchain.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Sherly想要更改历史（替换一些区块），她需要花费一些资源来在短时间内解决四个难题。等她完成这个过程时，大多数矿工保存的区块链可能已经添加了更多的区块，使得它比Sherly的区块链更长。
- en: This is the case because most miners want to get that reward we spoke of in
    the most efficient manner possible. To do this, they would get a new candidate
    block, work hard to find the answer in proof of work, and then add it to the longest
    chain as quickly as possible. But, why do they want to add it to the longest chain
    and not another chain? This is because it secures their reward.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数矿工希望以最有效的方式获得我们提到的奖励。为了做到这一点，他们会获得一个新的候选区块，努力找到工作证明的答案，然后尽快将其添加到最长的链上。但是，为什么他们想要将其添加到最长的链而不是其他链呢？这是因为它保障了他们的奖励。
- en: Say we have two versions of the blockchain. One has three blocks, while the
    other has eight blocks. The most sensible way to add a new block is to add it
    to the blockchain that has eight blocks. If someone adds it to the blockchain
    that has three blocks, it is more likely to get discarded. Consequently, the reward
    would be taken away from the miner. The longest chain attracts the most miners
    anyway, and you want to be in the blockchain version that is kept by more people.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个版本的区块链。一个有三个区块，而另一个有八个区块。添加新区块的最明智的方法是将其添加到有八个区块的区块链中。如果有人将其添加到只有三个区块的区块链中，它更有可能被丢弃。因此，奖励将被从矿工那里拿走。最长的链无论如何都会吸引最多的矿工，您希望在被更多人保留的区块链版本中。
- en: Some miners could persist in adding the block to the blockchain with three blocks,
    while other miners could also persist in adding the block to the blockchain with
    eight blocks. We call this a hard fork. Most of the time, miners will stick to
    the blockchain that has the longest chain.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些矿工可能会坚持将区块添加到只有三个区块的区块链中，而其他矿工也可能会坚持将区块添加到有八个区块的区块链中。我们称之为硬分叉。大多数时候，矿工会坚持保持最长的链的区块链。
- en: To change the history, Sherly will need to outgun at least more than 50% of
    the miners, which is impossible. The older the block, the more secure the history
    in that block is. Say one person needs 5 minutes to do the puzzle work. In this
    case, to replace the last five blocks in the blockchain, Sherly needs more than
    25 minutes (because Sherly needs at least six blocks to convince miners to replace
    the last five blocks in their blockchain). But in those 25 minutes, other miners
    would keep adding new blocks to the most popular blockchain. So when 25 minutes
    have passed, the most popular blockchain would have gained an additional five
    blocks! Maybe the miners take a nap for an hour and don't add any more blocks.
    In this case, Sherly could accumulate six blocks to tamper with the most popular
    blockchain. However, the incentive embedded in the blockchain keeps the miners
    awake 24/7 as they want to get the reward as much as possible. Consequently, it's
    a losing battle for Sherly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变历史，Sherly将需要击败至少50%以上的矿工，这是不可能的。区块越老，其中的历史就越安全。假设一个人需要5分钟来完成谜题工作。在这种情况下，为了替换区块链中的最后五个区块，Sherly需要超过25分钟（因为Sherly至少需要六个区块来说服矿工替换他们区块链中的最后五个区块）。但是在这25分钟内，其他矿工将继续向最受欢迎的区块链添加新的区块。因此，当25分钟过去时，最受欢迎的区块链将增加五个额外的区块！也许矿工们会打个小盹，一个小时不再添加任何区块。在这种情况下，Sherly可以积累六个区块来篡改最受欢迎的区块链。然而，嵌入在区块链中的激励使矿工们24/7保持清醒，因为他们希望尽可能多地获得奖励。因此，对于Sherly来说，这是一场失败的战斗。
- en: Coding on the blockchain
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在区块链上编码
- en: 'As this book is being written, the two most popular cryptocurrencies are Bitcoin
    and Ethereum (once in a while, Ripple will take second place). If you ask a simple
    question to someone who knows a lot about cryptocurrencies, you may get an answer:
    Bitcoin is just for sending money, but you can create a program on Ethereum. The
    program can be tokens, auction, or escrow, among many other things. But that is
    a half-truth. You can also create a program on Bitcoin. Usually, people call this
    program a script. In fact, it is a must to provide a script in a Bitcoin transaction.
    A transaction in Bitcoin can be mundane, so if I want to send you 1 BTC (a unit
    of currency in Bitcoin) and your Bitcoin address is Z, I need to upload a script
    like this into Bitcoin blockchain:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最受欢迎的两种加密货币是比特币和以太坊（偶尔，瑞波会占据第二位）。如果您向了解加密货币的人提出一个简单的问题，您可能会得到这样的答案：比特币只是用来发送货币，但您可以在以太坊上创建程序。该程序可以是代币、拍卖或托管等。但这只是半真。您也可以在比特币上创建程序。通常，人们称这个程序为脚本。事实上，在比特币交易中必须提供一个脚本。比特币交易可能很普通，所以如果我想向您发送1个比特币（比特币中的货币单位）并且您的比特币地址是Z，我需要将这样的脚本上传到比特币区块链中：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But it could be a little bit fancier. Let''s say you want to require at least
    two signatures from four authorized signatures to unlock this account; you can
    do that with Bitcoin script. Think creative and you can come up with something
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但它可能会更加复杂。假设您想要至少需要四个授权签名中的两个签名来解锁此帐户；您可以使用比特币脚本来实现。发挥创造力，您可以想出类似这样的东西：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But a Bitcoin script is created with a simple programming language, incapable
    of even looping. It is stack-based. So, you put instructions: hash the public
    key, check a signature, and check the current time. Then, it will be executed
    on the Bitcoin node from left to right.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是比特币脚本是用简单的编程语言创建的，甚至无法循环。它是基于堆栈的。因此，您可以放置指令：对公钥进行哈希，检查签名，并检查当前时间。然后，它将在比特币节点上从左到右执行。
- en: This means that you cannot create a fancy program, such as an auction, on Bitcoin.
    Bitcoin is designed just to store and transfer value (money). So it is purposely
    designed to avoid a complex program. In a Bitcoin node, every script is executed.
    Without a loop, a Bitcoin script will be so simple and you know when it will stop.
    But if you have a loop in a Bitcoin script, you don't know when it will stop.
    It could stop in the fourth iteration, or the millionth iteration, or in a far
    away future.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您无法在比特币上创建一个复杂的程序，比如拍卖。比特币的设计只是用来存储和转移价值（货币）。因此，它特意设计成避免复杂的程序。在比特币节点中，每个脚本都会被执行。没有循环，比特币脚本将会非常简单，您知道它何时会停止。但是如果您在比特币脚本中有一个循环，您就不知道它何时会停止。它可能在第四次迭代中停止，或者在第一百万次迭代中停止，或者在遥远的未来停止。
- en: Some people were not satisfied with this limitation, so Ethereum was created.
    The programming language that you are equipped with on the Ethereum blockchain
    is much more sophisticated than the programming language in Bitcoin (there is
    a `while` or `for` construct). Technically speaking, you could create a program
    that runs forever in the Ethereum blockchain.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对此限制感到不满，因此创建了以太坊。您在以太坊区块链上配备的编程语言比比特币中的编程语言要复杂得多（有`while`或`for`结构）。从技术上讲，您可以在以太坊区块链上创建一个永远运行的程序。
- en: You can do what you can do in Bitcoin, which is store and transfer values. But
    there is so much more that you can do in Ethereum. You could create a voting program,
    an escrow service, an online auction, and even another cryptocurrency on top of
    it. So, people like to differentiate the currencies of **Bitcoin** (**BTC**) and
    **Ethereum** (**ETH**).  BTC is like digital gold. ETH is like oil and gas. Both
    are valuable, if we take that analogy. But, you can use oil and gas to create
    a whole new world, such as by creating plastics, fuel, and so on. On the other
    hand, what you can do with gold is quite limited, other than creating jewelry.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像在比特币中那样存储和转移价值。但在以太坊中，您可以做的远不止这些。您可以创建一个投票程序、担保服务、在线拍卖，甚至在其上创建另一种加密货币。因此，人们喜欢区分**比特币**（**BTC**）和**以太坊**（**ETH**）的货币。BTC就像是数字黄金。ETH就像是石油和天然气。如果我们采用这个类比，两者都是有价值的。但是，您可以使用石油和天然气来创造一个全新的世界，例如通过创造塑料、燃料等。另一方面，您可以做的事情与黄金相比相当有限，除了创造珠宝。
- en: Creating a cryptocurrency on top of Ethereum is very easy. All you need is a
    weekend if you are a skilled programmer. You just inherit a class, and set your
    token's name and supply limit. Then, you compile it and launch to the Ethereum
    production blockchain, and you would have your own cryptocurrency. Prior to this,
    creating another cryptocurrency meant forking Bitcoin. The skill level required
    to do that is quite deep (C++, CMake, and replacing many parts of files in the
    Bitcoin core).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上创建加密货币非常容易。如果您是一名熟练的程序员，您只需要一个周末。您只需继承一个类，并设置您的代币名称和供应限制。然后，您编译它并发布到以太坊生产区块链上，您就会拥有自己的加密货币。在此之前，创建另一种加密货币意味着分叉比特币。所需的技能水平相当深（C++、CMake，并替换比特币核心文件的许多部分）。
- en: Other types of blockchain programmers
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的区块链程序员…
- en: This chapter intended to give you an intuitive understanding of how blockchain
    works. However, it's not a complete scope of how it works. My explanation differs
    quite a lot from how Bitcoin works (and even Ethereum). Ethereum does not use
    `SHA-256` for hashing; it commonly uses the `Keccak-256` algorithm. In our case,
    we only put one history/transaction/payload in one block, but Bitcoin can save
    more than 1,000 transactions in one block. Then, we generate a private key and
    public key by using RSA cryptography, while Bitcoin and Ethereum use elliptic
    curve cryptography. In our case, the payload is history (who likes/loves/hates
    an animal), but in Bitcoin it's a transaction that has a dependency on the previous
    payload. In Ethereum itself, it's a state of programs. So, if you have variable
    `a` as equal to integer `5` in the payload, it could be something like change
    variable `a` to integer `7`. In the Bitcoin consensus, we choose the blockchain
    that has the most hashing rate power, not the one that has the longest chain.
    For example, blockchain A has two blocks, but each block has the answer to solve
    the puzzle with 12 leading zeros, while blockchain B has ten blocks but each block
    has the answer to solving the puzzle with only five leading zeros. In this situation,
    blockchain A has the most hash rate power.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在让您直观地了解区块链的工作原理。然而，这并不是它的完整范围。我的解释与比特币（甚至以太坊）的工作方式有很大不同。以太坊不使用`SHA-256`进行哈希；它通常使用`Keccak-256`算法。在我们的情况下，我们只在一个区块中放入一个历史记录/交易/有效负载，但比特币可以在一个区块中保存超过1,000笔交易。然后，我们通过使用RSA密码学生成私钥和公钥，而比特币和以太坊使用椭圆曲线密码学。在我们的情况下，有效负载是历史记录（谁喜欢/爱/讨厌动物），但在比特币中，它是对先前有效负载的依赖性交易。在以太坊本身中，它是程序的状态。因此，如果有效负载中的变量`a`等于整数`5`，它可能是类似于将变量`a`更改为整数`7`。在比特币共识中，我们选择具有最高哈希率功率的区块链，而不是具有最长链的区块链。例如，区块链A有两个区块，但每个区块的答案都是以12个前导零解决谜题，而区块链B有十个区块，但每个区块的答案只有五个前导零。在这种情况下，区块链A具有最高的哈希率功率。
- en: 'Now, we go back to the following questions: what does it mean to be a blockchain
    programmer? How many types of Blockchain programmers are there? What is the scope
    of this book?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到以下问题：成为区块链程序员意味着什么？有多少种类型的区块链程序员？这本书的范围是什么？
- en: Blockchain programming could mean that you are working on improving the state
    of Bitcoin or creating a fork of Bitcoin, such as Bitcoin Cash. You need C++ and
    Python. If you are creating a Bitcoin fork, such as Bitcoin Gold, you need to
    dig deeper into cryptography. In Bitcoin Gold, the developers changed the proof
    of work hashing function from SHA-256 to Equihash because Equihash is ASIC resistant.
    ASIC resistance means you cannot create a specific machine to do the hashing.
    You need a computer with a GPU to do the Equihash hashing function, but this book
    will not discuss that.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链编程可能意味着您正在努力改进比特币的状态或创建比特币的分叉，如比特币现金。您需要C++和Python。如果您正在创建比特币分叉，例如比特币黄金，您需要更深入地了解密码学。在比特币黄金中，开发人员将工作证明哈希函数从SHA-256更改为Equihash，因为Equihash是ASIC抗性的。ASIC抗性意味着您无法创建特定的机器来进行哈希。您需要一台带有GPU的计算机来执行Equihash哈希函数，但本书不会讨论这一点。
- en: Furthermore, Blockchain programming could mean that you are working on improving
    the Ethereum Virtual Machine. You need Go, C++, or Python. You need to understand
    how to interact with low-level cryptographic library functions. An intuitive understanding
    of how basic cryptography works is not enough, but this book will not discuss
    that either.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，区块链编程可能意味着您正在努力改进以太坊虚拟机。您需要Go、C++或Python。您需要了解如何与低级加密库函数进行交互。对基本密码学的直观理解是不够的，但本书也不会讨论这一点。
- en: Blockchain programming could mean that you are writing the program on top of
    Ethereum. You need Solidity or Vyper for this, which this book will discuss. You
    only need an intuitive understanding of how basic cryptography works. You have
    been abstracted away from low-level cryptography. Once in a while, you might use
    a hashing function in a program you write, but nothing fancy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链编程可能意味着你正在在以太坊上编写程序。为此，你需要Solidity或Vyper，这本书将讨论这些内容。你只需要对基本密码学的直观理解。你已经摆脱了低级密码学。偶尔，你可能会在你编写的程序中使用哈希函数，但没有什么花哨的。
- en: Blockchain programming could mean that you are writing a program to interact
    with the program on top of Ethereum, which sounds meta. But what you will need
    for this depends on the platform. If it is a mobile app, you need Kotlin, Java,
    Swift, Obj-C, or even C++. If it is a web frontend, you will most likely need
    JavaScript. Only an intuitive understanding of how basic cryptography works is
    needed. This book will discuss some of this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链编程可能意味着你正在编写一个与以太坊上的程序进行交互的程序，听起来有点元。但你为此所需取决于平台。如果是移动应用程序，你需要Kotlin、Java、Swift、Obj-C，甚至C++。如果是Web前端，你很可能需要JavaScript。只需要对基本密码学的直观理解。这本书将讨论其中的一些内容。
- en: This is the same as if I asked you, *what does it entail when someone wants
    to become a web developer?* The answer is quite diverse. Should I learn Ruby,
    Java, PHP, or Python? Should I learn Ruby on Rails, Laravel, or Django?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就好像我问你，“当有人想成为Web开发人员时，这意味着什么？”答案是多种多样的。我应该学习Ruby、Java、PHP还是Python？我应该学习Ruby
    on Rails、Laravel还是Django？
- en: This book is going to teach you how to build a program on top of Ethereum (not
    to be confused with building Ethereum itself). Comparing this with web development,
    this is like saying that this book is going to teach you how to build a web application
    using Ruby on Rails, but the book does not teach you how to dissect the Ruby on
    Rails framework itself. This does not mean that the internals of Ruby on Rails
    are not important, it just means that most of the time, you don't need them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将教你如何在以太坊上构建程序（不要与构建以太坊本身混淆）。将这与Web开发进行比较，这就好像说这本书将教你如何使用Ruby on Rails构建Web应用程序，但这本书不会教你如何解剖Ruby
    on Rails框架本身。这并不意味着Ruby on Rails的内部不重要，只是大多数情况下你不需要它们。
- en: 'This book will teach you to use the Python programming language, assuming that
    you have basic knowledge of Python already. But why Python? The answer is a cliché:
    Python is one of the easiest and most popular programming languages. It lowers
    the barrier to entry for someone who wants to jump into blockchain.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将教你使用Python编程语言，假设你已经有Python的基本知识。但为什么选择Python呢？答案是老生常谈：Python是最简单和最流行的编程语言之一。它降低了想要进入区块链领域的人的门槛。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into the technology behind cryptocurrencies such
    as Bitcoin and Ethereum. This technology enables the decentralization of storing
    values or code. We also covered cryptography by using private and public keys
    to secure the integrity of any data. Further on, we learned about hash functions,
    proof of work, consensus, and the basic concepts of blockchain programming.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究了比特币和以太坊等加密货币背后的技术。这项技术使价值或代码的去中心化存储成为可能。我们还涵盖了使用私钥和公钥来保护任何数据的完整性的密码学。此外，我们还学习了哈希函数、工作证明、共识和区块链编程的基本概念。
- en: In the next chapter, we will learn about a smart contract, a kind of program
    that lives in Ethereum. A smart contract is different than a kind of program that
    lives in a server, such as an application written with Ruby on Rails, Laravel,
    or Django. The differences are more than just the syntax; the concept is radically
    different than a normal web application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习智能合约，这是以太坊中的一种程序。智能合约不同于在服务器中运行的程序，比如使用Ruby on Rails、Laravel或Django编写的应用程序。区别不仅仅在于语法；这个概念与普通的Web应用程序完全不同。
- en: References
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://techcrunch.com/2018/06/25/andreessen-horowitz-has-a-new-crypto-fund-and-its-first-female-general-partner-is-running-it-with-chris-dixon/](https://techcrunch.com/2018/06/25/andreessen-horowitz-has-a-new-crypto-fund-and-its-first-female-general-partner-is-running-it-with-chris-dixon/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://techcrunch.com/2018/06/25/andreessen-horowitz-has-a-new-crypto-fund-and-its-first-female-general-partner-is-running-it-with-chris-dixon/](https://techcrunch.com/2018/06/25/andreessen-horowitz-has-a-new-crypto-fund-and-its-first-female-general-partner-is-running-it-with-chris-dixon/)'
- en: '[https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)'
- en: '[https://bitcoin.org/en/development](https://bitcoin.org/en/development)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitcoin.org/en/development](https://bitcoin.org/en/development)'
