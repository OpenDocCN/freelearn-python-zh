- en: Chapter 8. Strings and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。字符串和序列化
- en: 'Before we get involved with higher level design patterns, let''s take a deep
    dive into one of Python''s most common objects: the string. We''ll see that there
    is a lot more to the string than meets the eye, and also cover searching strings
    for patterns and serializing data for storage or transmission.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涉及更高级别的设计模式之前，让我们深入研究Python中最常见的对象之一：字符串。我们会发现字符串比看上去更复杂，还会涵盖搜索字符串的模式和序列化数据以便存储或传输。
- en: 'In particular, we''ll visit:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将讨论：
- en: The complexities of strings, bytes, and byte arrays
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串、字节和字节数组的复杂性
- en: The ins and outs of string formatting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化的内在和外在
- en: A few ways to serialize data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种序列化数据的方法
- en: The mysterious regular expression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神秘的正则表达式
- en: Strings
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are a basic primitive in Python; we've used them in nearly every example
    we've discussed so far. All they do is represent an immutable sequence of characters.
    However, though you may not have considered it before, "character" is a bit of
    an ambiguous word; can Python strings represent sequences of accented characters?
    Chinese characters? What about Greek, Cyrillic, or Farsi?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Python中的基本原语；我们几乎在我们迄今讨论的每个例子中都使用了它们。它们所做的就是表示一个不可变的字符序列。然而，虽然你以前可能没有考虑过，"字符"是一个有点模糊的词；Python字符串能表示重音字符的序列吗？中文字符？希腊、西里尔或波斯字符呢？
- en: 'In Python 3, the answer is yes. Python strings are all represented in Unicode,
    a character definition standard that can represent virtually any character in
    any language on the planet (and some made-up languages and random characters as
    well). This is done seamlessly, for the most part. So, let''s think of Python
    3 strings as an immutable sequence of Unicode characters. So what can we do with
    this immutable sequence? We''ve touched on many of the ways strings can be manipulated
    in previous examples, but let''s quickly cover it all in one place: a crash course
    in string theory!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，答案是肯定的。Python字符串都以Unicode表示，这是一个可以表示地球上任何语言中的几乎任何字符的字符定义标准（还包括一些虚构的语言和随机字符）。这在很大程度上是无缝的。因此，让我们把Python
    3字符串看作是不可变的Unicode字符序列。那么我们可以用这个不可变序列做什么呢？我们在之前的例子中已经提到了许多字符串可以被操作的方式，但让我们快速地在一个地方概括一下：字符串理论的速成课程！
- en: String manipulation
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'As you know, strings can be created in Python by wrapping a sequence of characters
    in single or double quotes. Multiline strings can easily be created using three
    quote characters, and multiple hardcoded strings can be concatenated together
    by placing them side by side. Here are some examples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，可以通过用单引号或双引号包裹一系列字符来在Python中创建字符串。可以使用三个引号字符轻松创建多行字符串，并且可以通过将它们并排放置来连接多个硬编码字符串。以下是一些例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That last string is automatically composed into a single string by the interpreter.
    It is also possible to concatenate strings using the `+` operator (as in `"hello
    " + "world"`). Of course, strings don't have to be hardcoded. They can also come
    from various outside sources such as text files, user input, or encoded on the
    network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器会自动将最后一个字符串组合成一个字符串。也可以使用`+`运算符连接字符串（如`"hello " + "world"`）。当然，字符串不一定是硬编码的。它们也可以来自各种外部来源，如文本文件、用户输入，或者在网络上编码。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The automatic concatenation of adjacent strings can make for some hilarious
    bugs when a comma is missed. It is, however, extremely useful when a long string
    needs to be placed inside a function call without exceeding the 79 character line-length
    limit suggested by the Python style guide.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相邻字符串的自动连接可能会导致一些滑稽的错误，当逗号丢失时。然而，当需要将长字符串放置在函数调用中而不超过Python风格指南建议的79个字符行长度限制时，这是非常有用的。
- en: Like other sequences, strings can be iterated over (character by character),
    indexed, sliced, or concatenated. The syntax is the same as for lists.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他序列一样，字符串可以被迭代（逐个字符），索引，切片或连接。语法与列表相同。
- en: The `str` class has numerous methods on it to make manipulating strings easier.
    The `dir` and `help` commands in the Python interpreter can tell us how to use
    all of them; we'll consider some of the more common ones directly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`类上有许多方法，可以使操作字符串更容易。Python解释器中的`dir`和`help`命令可以告诉我们如何使用它们；我们将直接考虑一些更常见的方法。'
- en: Several Boolean convenience methods help us identify whether or not the characters
    in a string match a certain pattern. Here is a summary of these methods. Most
    of these, such as `isalpha`, `isupper`/`islower`, and `startswith`/`endswith`
    have obvious interpretations. The `isspace` method is also fairly obvious, but
    remember that all whitespace characters (including tab, newline) are considered,
    not just the space character.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几种布尔方便方法帮助我们确定字符串中的字符是否与某种模式匹配。以下是这些方法的摘要。其中大多数方法，如`isalpha`，`isupper`/`islower`，`startswith`/`endswith`都有明显的解释。`isspace`方法也相当明显，但请记住，所有空白字符（包括制表符、换行符）都被考虑在内，而不仅仅是空格字符。
- en: The `istitle` method returns `True` if the first character of each word is capitalized
    and all other characters are lowercase. Note that it does not strictly enforce
    the English grammatical definition of title formatting. For example, Leigh Hunt's
    poem "The Glove and the Lions" should be a valid title, even though not all words
    are capitalized. Robert Service's "The Cremation of Sam McGee" should also be
    a valid title, even though there is an uppercase letter in the middle of the last
    word.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`istitle`方法返回`True`，如果每个单词的第一个字符都是大写，其他字符都是小写。请注意，它并不严格执行英语的标题格式定义。例如，Leigh
    Hunt的诗歌"The Glove and the Lions"应该是一个有效的标题，即使并非所有单词都是大写。Robert Service的"The Cremation
    of Sam McGee"也应该是一个有效的标题，即使最后一个单词中间有一个大写字母。'
- en: 'Be careful with the `isdigit`, `isdecimal`, and `isnumeric` methods, as they
    are more nuanced than you would expect. Many Unicode characters are considered
    numbers besides the ten digits we are used to. Worse, the period character that
    we use to construct floats from strings is not considered a decimal character,
    so `''45.2''.isdecimal()` returns `False`. The real decimal character is represented
    by Unicode value 0660, as in 45.2, (or `45\u06602`). Further, these methods do
    not verify whether the strings are valid numbers; "127.0.0.1" returns `True` for
    all three methods. We might think we should use that decimal character instead
    of a period for all numeric quantities, but passing that character into the `float()`
    or i`nt()` constructor converts that decimal character to a zero:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`isdigit`，`isdecimal`和`isnumeric`方法要小心，因为它们比您期望的更微妙。许多Unicode字符被认为是数字，除了我们习惯的十个数字之外。更糟糕的是，我们用来从字符串构造浮点数的句点字符不被视为十进制字符，因此`'45.2'.isdecimal()`返回`False`。真正的十进制字符由Unicode值0660表示，如45.2中的0660（或`45\u06602`）。此外，这些方法不验证字符串是否为有效数字；"127.0.0.1"对所有三种方法都返回`True`。我们可能认为应该使用该十进制字符而不是句点来表示所有数字数量，但将该字符传递给`float()`或`int()`构造函数会将该十进制字符转换为零：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Other methods useful for pattern matching do not return Booleans. The `count`
    method tells us how many times a given substring shows up in the string, while
    `find`, `index`, `rfind`, and `rindex` tell us the position of a given substring
    within the original string. The two ''`r`'' (for ''right'' or ''reverse'') methods
    start searching from the end of the string. The `find` methods return `-1` if
    the substring can''t be found, while `index` raises a `ValueError` in this situation.
    Have a look at some of these methods in action:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用于模式匹配的其他有用方法不返回布尔值。`count`方法告诉我们给定子字符串在字符串中出现了多少次，而`find`，`index`，`rfind`和`rindex`告诉我们给定子字符串在原始字符串中的位置。两个`r`（表示“右”或“反向”）方法从字符串的末尾开始搜索。如果找不到子字符串，`find`方法返回`-1`，而`index`在这种情况下会引发`ValueError`。看看其中一些方法的实际应用：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the remaining string methods return transformations of the string. The
    `upper`, `lower`, `capitalize`, and `title` methods create new strings with all
    alphabetic characters in the given format. The `translate` method can use a dictionary
    to map arbitrary input characters to specified output characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其余大多数字符串方法返回字符串的转换。`upper`，`lower`，`capitalize`和`title`方法创建具有给定格式的所有字母字符的新字符串。`translate`方法可以使用字典将任意输入字符映射到指定的输出字符。
- en: For all of these methods, note that the input string remains unmodified; a brand
    new `str` instance is returned instead. If we need to manipulate the resultant
    string, we should assign it to a new variable, as in `new_value = value.capitalize()`.
    Often, once we've performed the transformation, we don't need the old value anymore,
    so a common idiom is to assign it to the same variable, as in `value = value.title()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些方法，请注意输入字符串保持不变；而是返回一个全新的`str`实例。如果我们需要操作结果字符串，我们应该将其赋值给一个新变量，如`new_value
    = value.capitalize()`。通常，一旦我们执行了转换，我们就不再需要旧值了，因此一个常见的习惯是将其赋值给相同的变量，如`value = value.title()`。
- en: 'Finally, a couple of string methods return or operate on lists. The `split`
    method accepts a substring and splits the string into a list of strings wherever
    that substring occurs. You can pass a number as a second parameter to limit the
    number of resultant strings. The `rsplit` behaves identically to `split` if you
    don''t limit the number of strings, but if you do supply a limit, it starts splitting
    from the end of the string. The `partition` and `rpartition` methods split the
    string at only the first or last occurrence of the substring, and return a tuple
    of three values: characters before the substring, the substring itself, and the
    characters after the substring.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些字符串方法返回或操作列表。`split`方法接受一个子字符串，并在该子字符串出现的地方将字符串拆分为字符串列表。您可以将数字作为第二个参数传递以限制结果字符串的数量。`rsplit`如果不限制字符串的数量，则行为与`split`相同，但如果您提供了限制，它将从字符串的末尾开始拆分。`partition`和`rpartition`方法仅在子字符串的第一次或最后一次出现时拆分字符串，并返回一个包含三个值的元组：子字符串之前的字符，子字符串本身和子字符串之后的字符。
- en: 'As the inverse of `split`, the `join` method accepts a list of strings, and
    returns all of those strings combined together by placing the original string
    between them. The `replace` method accepts two arguments, and returns a string
    where each instance of the first argument has been replaced with the second. Here
    are some of these methods in action:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`split`的反向操作，`join`方法接受一个字符串列表，并通过将原始字符串放在它们之间来返回所有这些字符串组合在一起的字符串。`replace`方法接受两个参数，并返回一个字符串，其中第一个参数的每个实例都已被第二个参数替换。以下是其中一些方法的实际应用：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There you have it, a whirlwind tour of the most common methods on the `str`
    class! Now, let's look at Python 3's method for composing strings and variables
    to create new strings.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最常见的`str`类上的方法的快速浏览！现在，让我们看看Python 3的方法，用于组合字符串和变量以创建新字符串。
- en: String formatting
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Python 3 has a powerful string formatting and templating mechanism that allows
    us to construct strings comprised of hardcoded text and interspersed variables.
    We've used it in many previous examples, but it is much more versatile than the
    simple formatting specifiers we've used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3具有强大的字符串格式化和模板机制，允许我们构造由硬编码文本和插入的变量组成的字符串。我们在许多先前的示例中使用过它，但它比我们使用的简单格式化说明符要灵活得多。
- en: Any string can be turned into a format string by calling the `format()` method
    on it. This method returns a new string where specific characters in the input
    string have been replaced with values provided as arguments and keyword arguments
    passed into the function. The `format` method does not require a fixed set of
    arguments; internally, it uses the `*args` and `**kwargs` syntax that we discussed
    in [Chapter 7](ch07.html "Chapter 7. Python Object-oriented Shortcuts"), *Python
    Object-oriented Shortcuts*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字符串都可以通过在其上调用`format()`方法将其转换为格式化字符串。此方法返回一个新字符串，其中输入字符串中的特定字符已被替换为作为参数和关键字参数传递给函数的值。`format`方法不需要固定的参数集；在内部，它使用了我们在[第7章](ch07.html
    "第7章。Python面向对象的快捷方式")中讨论的`*args`和`**kwargs`语法，*Python面向对象的快捷方式*。
- en: 'The special characters that are replaced in formatted strings are the opening
    and closing brace characters: `{` and `}`. We can insert pairs of these in a string
    and they will be replaced, in order, by any positional arguments passed to the
    `str.format` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化字符串中替换的特殊字符是开放和关闭的大括号字符：`{`和`}`。我们可以在字符串中插入这些对，并且它们将按顺序被任何传递给`str.format`方法的位置参数替换：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run these statements, it replaces the braces with variables, in order:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些语句，它将按顺序用变量替换大括号：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This basic syntax is not terribly useful if we want to reuse variables within
    one string or decide to use them in a different position. We can place zero-indexed
    integers inside the curly braces to tell the formatter which positional variable
    gets inserted at a given position in the string. Let''s repeat the name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在一个字符串中重用变量或者决定在不同位置使用它们，这种基本语法就不是特别有用。我们可以在花括号中放置从零开始的整数，以告诉格式化程序在字符串的特定位置插入哪个位置变量。让我们重复一下名字：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we use these integer indexes, we have to use them in all the variables.
    We can''t mix empty braces with positional indexes. For example, this code fails
    with an appropriate `ValueError` exception:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这些整数索引，我们必须在所有变量中使用它们。我们不能将空大括号与位置索引混合使用。例如，这段代码会因为适当的`ValueError`异常而失败：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Escaping braces
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义大括号
- en: 'Brace characters are often useful in strings, aside from formatting. We need
    a way to escape them in situations where we want them to be displayed as themselves,
    rather than being replaced. This can be done by doubling the braces. For example,
    we can use Python to format a basic Java program:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号字符在字符串中通常很有用，除了格式化之外。我们需要一种方法来在我们希望它们以它们自己的形式显示而不是被替换的情况下对它们进行转义。这可以通过加倍大括号来实现。例如，我们可以使用Python来格式化一个基本的Java程序：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wherever we see the `{{` or `}}` sequence in the template, that is, the braces
    enclosing the Java class and method definition, we know the `format` method will
    replace them with single braces, rather than some argument passed into the `format`
    method. Here''s the output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，无论我们看到`{{`或`}}`序列，也就是包围Java类和方法定义的大括号，我们知道`format`方法将用单个大括号替换它们，而不是一些传递给`format`方法的参数。以下是输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The class name and contents of the output have been replaced with two parameters,
    while the double braces have been replaced with single braces, giving us a valid
    Java file. Turns out, this is about the simplest possible Python program to print
    the simplest possible Java program that can print the simplest possible Python
    program!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的类名和内容已被替换为两个参数，而双大括号已被替换为单大括号，从而给我们一个有效的Java文件。结果是，这是一个打印最简单的Java程序的最简单的可能的Python程序，可以打印最简单的可能的Python程序！
- en: Keyword arguments
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'If we''re formatting complex strings, it can become tedious to remember the
    order of the arguments or to update the template if we choose to insert a new
    argument. The `format` method therefore allows us to specify names inside the
    braces instead of numbers. The named variables are then passed to the `format`
    method as keyword arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要格式化复杂的字符串，要记住参数的顺序或者更新模板如果我们选择插入一个新的参数可能会变得很繁琐。因此，`format`方法允许我们在大括号内指定名称而不是数字。然后将命名变量作为关键字参数传递给`format`方法：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also mix index and keyword arguments (as with all Python function calls,
    the keyword arguments must follow the positional ones). We can even mix unlabeled
    positional braces with keyword arguments:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以混合使用索引和关键字参数（与所有Python函数调用一样，关键字参数必须跟在位置参数后面）。我们甚至可以将未标记的位置大括号与关键字参数混合使用：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, this code outputs:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这段代码输出：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Container lookups
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器查找
- en: We aren't restricted to passing simple string variables into the `format` method.
    Any primitive, such as integers or floats can be printed. More interestingly,
    complex objects, including lists, tuples, dictionaries, and arbitrary objects
    can be used, and we can access indexes and variables (but not methods) on those
    objects from within the `format` string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于将简单的字符串变量传递给`format`方法。任何原始类型，如整数或浮点数都可以打印。更有趣的是，可以使用复杂对象，包括列表、元组、字典和任意对象，并且可以从`format`字符串中访问这些对象的索引和变量（但不能访问方法）。
- en: 'For example, if our e-mail message had grouped the from and to e-mail addresses
    into a tuple, and placed the subject and message in a dictionary, for some reason
    (perhaps because that''s the input required for an existing `send_mail` function
    we want to use), we can format it like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的电子邮件消息将发件人和收件人的电子邮件地址分组到一个元组中，并将主题和消息放在一个字典中，出于某种原因（也许是因为这是现有`send_mail`函数所需的输入），我们可以这样格式化它：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The variables inside the braces in the template string look a little weird,
    so let's look at what they're doing. We have passed one argument as a position-based
    parameter and one as a keyword argument. The two e-mail addresses are looked up
    by `0[x]`, where `x` is either `0` or `1`. The initial zero represents, as with
    other position-based arguments, the first positional argument passed to `format`
    (the `emails` tuple, in this case).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串中大括号内的变量看起来有点奇怪，所以让我们看看它们在做什么。我们已经将一个参数作为基于位置的参数传递，另一个作为关键字参数。两个电子邮件地址通过`0[x]`查找，其中`x`可以是`0`或`1`。初始的零表示，与其他基于位置的参数一样，传递给`format`的第一个位置参数（在这种情况下是`emails`元组）。
- en: The square brackets with a number inside are the same kind of index lookup we
    see in regular Python code, so `0[0]` maps to `emails[0]`, in the `emails` tuple.
    The indexing syntax works with any indexable object, so we see similar behavior
    when we access `message[subject]`, except this time we are looking up a string
    key in a dictionary. Notice that unlike in Python code, we do not need to put
    quotes around the string in the dictionary lookup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 带有数字的方括号是我们在常规Python代码中看到的相同类型的索引查找，所以`0[0]`映射到`emails[0]`，在`emails`元组中。索引语法适用于任何可索引的对象，所以当我们访问`message[subject]`时，我们看到类似的行为，除了这次我们在字典中查找一个字符串键。请注意，与Python代码不同的是，在字典查找中我们不需要在字符串周围加上引号。
- en: 'We can even do multiple levels of lookup if we have nested data structures.
    I would recommend against doing this often, as template strings rapidly become
    difficult to understand. If we have a dictionary that contains a tuple, we can
    do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有嵌套的数据结构，甚至可以进行多层查找。我建议不要经常这样做，因为模板字符串很快就变得难以理解。如果我们有一个包含元组的字典，我们可以这样做：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Object lookups
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象查找
- en: 'Indexing makes `format` lookup powerful, but we''re not done yet! We can also
    pass arbitrary objects as parameters, and use the dot notation to look up attributes
    on those objects. Let''s change our e-mail message data once again, this time
    to a class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 索引使`format`查找功能强大，但我们还没有完成！我们还可以将任意对象作为参数传递，并使用点符号来查找这些对象的属性。让我们再次更改我们的电子邮件消息数据，这次是一个类：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The template in this example may be more readable than the previous examples,
    but the overhead of creating an e-mail class adds complexity to the Python code.
    It would be foolish to create a class for the express purpose of including the
    object in a template. Typically, we'd use this sort of lookup if the object we
    are trying to format already exists. This is true of all the examples; if we have
    a tuple, list, or dictionary, we'll pass it into the template directly. Otherwise,
    we'd just create a simple set of positional and keyword arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模板可能比之前的例子更易读，但创建一个电子邮件类的开销会给Python代码增加复杂性。为了将对象包含在模板中而创建一个类是愚蠢的。通常，如果我们要格式化的对象已经存在，我们会使用这种查找。所有的例子都是如此；如果我们有一个元组、列表或字典，我们会直接将其传递到模板中。否则，我们只需创建一组简单的位置参数和关键字参数。
- en: Making it look right
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使其看起来正确
- en: 'It''s nice to be able to include variables in template strings, but sometimes
    the variables need a bit of coercion to make them look right in the output. For
    example, if we are doing calculations with currency, we may end up with a long
    decimal that we don''t want to show up in our template:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串中包含变量是很好的，但有时变量需要一点强制转换才能使它们在输出中看起来正确。例如，如果我们在货币计算中，可能会得到一个我们不想在模板中显示的长小数：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we run this formatting code, the output doesn''t quite look like proper
    currency:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个格式化代码，输出看起来并不像正确的货币：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, we should never use floating-point numbers in currency calculations
    like this; we should construct `decimal.Decimal()` objects instead. Floats are
    dangerous because their calculations are inherently inaccurate beyond a specific
    level of precision. But we're looking at strings, not floats, and currency is
    a great example for formatting!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不应该在货币计算中使用浮点数；我们应该使用`decimal.Decimal()`对象来构造。浮点数是危险的，因为它们的计算在特定精度水平之后本质上是不准确的。但我们正在看字符串，而不是浮点数，货币是格式化的一个很好的例子！
- en: 'To fix the preceding `format` string, we can include some additional information
    inside the curly braces to adjust the formatting of the parameters. There are
    tons of things we can customize, but the basic syntax inside the braces is the
    same; first, we use whichever of the earlier layouts (positional, keyword, index,
    attribute access) is suitable to specify the variable that we want to place in
    the template string. We follow this with a colon, and then the specific syntax
    for the formatting. Here''s an improved version:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复前面的`format`字符串，我们可以在花括号内包含一些额外的信息，以调整参数的格式。我们可以定制很多东西，但花括号内的基本语法是相同的；首先，我们使用早期的布局（位置、关键字、索引、属性访问）中适合的布局来指定我们想要放入模板字符串中的变量。然后我们跟着一个冒号，然后是特定的格式语法。这是一个改进版：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `0.2f` format specifier after the colons basically says, from left to right:
    for values lower than one, make sure a zero is displayed on the left side of the
    decimal point; show two places after the decimal; format the input value as a
    float.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号后面的`0.2f`格式说明符基本上是这样说的，从左到右：对于小于一的值，确保小数点左侧显示一个零；显示小数点后两位；将输入值格式化为浮点数。
- en: 'We can also specify that each number should take up a particular number of
    characters on the screen by placing a value before the period in the precision.
    This can be useful for outputting tabular data, for example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定每个数字在屏幕上占据特定数量的字符，方法是在精度的句点之前放置一个值。这对于输出表格数据非常有用，例如：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ok, that''s a pretty scary looking format string, so let''s see how it works
    before we break it down into understandable parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个看起来相当可怕的格式字符串，让我们看看它是如何工作的，然后再将其分解成可理解的部分：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Nifty! So, how is this actually happening? We have four variables we are formatting,
    in each line in the `for` loop. The first variable is a string and is formatted
    with `{0:10s}`. The `s` means it is a string variable, and the `10` means it should
    take up ten characters. By default, with strings, if the string is shorter than
    the specified number of characters, it appends spaces to the right side of the
    string to make it long enough (beware, however: if the original string is too
    long, it won''t be truncated!). We can change this behavior (to fill with other
    characters or change the alignment in the format string), as we do for the next
    value, `quantity`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 厉害！那么，这实际上是如何发生的呢？在`for`循环中的每一行中，我们正在格式化四个变量。第一个变量是一个字符串，并且使用`{0:10s}`进行格式化。`s`表示它是一个字符串变量，`10`表示它应该占用十个字符。默认情况下，对于字符串，如果字符串的长度小于指定的字符数，它会在字符串的右侧附加空格，使其足够长（但要注意，如果原始字符串太长，它不会被截断！）。我们可以更改这种行为（在格式字符串中填充其他字符或更改对齐方式），就像我们对下一个值`quantity`所做的那样。
- en: 'The formatter for the `quantity` value is `{1: ^9d}`. The `d` represents an
    integer value. The `9` tells us the value should take up nine characters. But
    with integers, instead of spaces, the extra characters are zeros, by default.
    That looks kind of weird. So we explicitly specify a space (immediately after
    the colon) as a padding character. The caret character `^` tells us that the number
    should be aligned in the center of this available padding; this makes the column
    look a bit more professional. The specifiers have to be in the right order, although
    all are optional: fill first, then align, then the size, and finally, the type.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantity`值的格式化程序是`{1: ^9d}`。`d`表示整数值。`9`告诉我们该值应该占用九个字符。但是对于整数，额外的字符默认情况下是零，而不是空格。这看起来有点奇怪。因此，我们明确指定一个空格（在冒号后面）作为填充字符。插入符`^`告诉我们数字应该对齐在这个可用填充的中心；这使得列看起来更专业一些。说明符必须按正确的顺序，尽管所有都是可选的：首先填充，然后对齐，然后大小，最后类型。'
- en: 'We do similar things with the specifiers for price and subtotal. For `price`,
    we use `{2: <8.2f}` and for `subtotal`, `{3: >7.2f}`. In both cases, we''re specifying
    a space as the fill character, but we use the `<` and `>` symbols, respectively,
    to represent that the numbers should be aligned to the left or right within the
    minimum space of eight or seven characters. Further, each float should be formatted
    to two decimal places.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '我们对价格和小计的说明符做了类似的处理。对于`price`，我们使用`{2: <8.2f}`，对于`subtotal`，我们使用`{3: >7.2f}`。在这两种情况下，我们指定空格作为填充字符，但是我们分别使用`<`和`>`符号，表示数字应该在八个或七个字符的最小空间内左对齐或右对齐。此外，每个浮点数应该格式化为两位小数。'
- en: The "type" character for different types can affect formatting output as well.
    We've seen the `s`, `d`, and `f` types, for strings, integers, and floats. Most
    of the other format specifiers are alternative versions of these; for example,
    `o` represents octal format and `X` represents hexadecimal for integers. The `n`
    type specifier can be useful for formatting integer separators in the current
    locale's format. For floating-point numbers, the `%` type will multiply by 100
    and format a float as a percentage.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的“类型”字符也会影响格式化输出。我们已经看到了`s`、`d`和`f`类型，分别代表字符串、整数和浮点数。大多数其他格式说明符都是这些类型的替代版本；例如，`o`代表八进制格式，`X`代表十六进制格式。`n`类型说明符可以用于在当前区域设置的格式中格式化整数分隔符。对于浮点数，`%`类型将乘以100并将浮点数格式化为百分比。
- en: 'While these standard formatters apply to most built-in objects, it is also
    possible for other objects to define nonstandard specifiers. For example, if we
    pass a `datetime` object into `format`, we can use the specifiers used in the
    `datetime.strftime` function, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些标准格式适用于大多数内置对象，但其他对象也可以定义非标准的说明符。例如，如果我们将`datetime`对象传递给`format`，我们可以使用`datetime.strftime`函数中使用的说明符，如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is even possible to write custom formatters for objects we create ourselves,
    but that is beyond the scope of this book. Look into overriding the `__format__`
    special method if you need to do this in your code. The most comprehensive instructions
    can be found in PEP 3101 at [http://www.python.org/dev/peps/pep-3101/](http://www.python.org/dev/peps/pep-3101/),
    although the details are a bit dry. You can find more digestible tutorials using
    a web search.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以为我们自己创建的对象编写自定义格式化程序，但这超出了本书的范围。如果您需要在代码中执行此操作，请查看如何覆盖`__format__`特殊方法。最全面的说明可以在PEP
    3101中找到[http://www.python.org/dev/peps/pep-3101/](http://www.python.org/dev/peps/pep-3101/)，尽管细节有点枯燥。您可以通过网络搜索找到更易理解的教程。
- en: The Python formatting syntax is quite flexible but it is a difficult mini-language
    to remember. I use it every day and still occasionally have to look up forgotten
    concepts in the documentation. It also isn't powerful enough for serious templating
    needs, such as generating web pages. There are several third-party templating
    libraries you can look into if you need to do more than basic formatting of a
    few strings.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python的格式化语法非常灵活，但是很难记住。我每天都在使用它，但偶尔还是不得不查阅文档中忘记的概念。它也不足以满足严肃的模板需求，比如生成网页。如果您需要做更多的字符串基本格式化，可以查看几个第三方模板库。
- en: Strings are Unicode
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串是Unicode
- en: At the beginning of this section, we defined strings as collections of immutable
    Unicode characters. This actually makes things very complicated at times, because
    Unicode isn't really a storage format. If you get a string of bytes from a file
    or a socket, for example, they won't be in Unicode. They will, in fact, be the
    built-in type `bytes`. Bytes are immutable sequences of... well, bytes. Bytes
    are the lowest-level storage format in computing. They represent 8 bits, usually
    described as an integer between 0 and 255, or a hexadecimal equivalent between
    0 and FF. Bytes don't represent anything specific; a sequence of bytes may store
    characters of an encoded string, or pixels in an image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们将字符串定义为不可变的Unicode字符集合。这实际上有时会使事情变得非常复杂，因为Unicode实际上并不是一种存储格式。例如，如果从文件或套接字中获取字节字符串，它们实际上不会是Unicode。它们实际上是内置类型`bytes`。字节是不可变的序列...嗯，字节。字节是计算机中最低级别的存储格式。它们代表8位，通常描述为介于0和255之间的整数，或者介于0和FF之间的十六进制等价物。字节不代表任何特定的内容；一系列字节可以存储编码字符串的字符，或者图像中的像素。
- en: If we print a byte object, any bytes that map to ASCII representations will
    be printed as their original character, while non-ASCII bytes (whether they are
    binary data or other characters) are printed as hex codes escaped by the `\x`
    escape sequence. You may find it odd that a byte, represented as an integer, can
    map to an ASCII character. But ASCII is really just a code where each letter is
    represented by a different byte pattern, and therefore, a different integer. The
    character "a" is represented by the same byte as the integer 97, which is the
    hexadecimal number 0x61\. Specifically, all of these are an interpretation of
    the binary pattern 01100001.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印一个字节对象，任何映射到ASCII表示的字节都将打印为它们原始的字符，而非ASCII字节（无论它们是二进制数据还是其他字符）都将以`\x`转义序列转义的十六进制代码打印出来。你可能会觉得奇怪，一个字节，表示为一个整数，可以映射到一个ASCII字符。但ASCII实际上只是一个代码，其中每个字母都由不同的字节模式表示，因此，不同的整数。字符“a”由与整数97相同的字节表示，这是十六进制数0x61。具体来说，所有这些都是对二进制模式01100001的解释。
- en: Many I/O operations only know how to deal with `bytes`, even if the bytes object
    refers to textual data. It is therefore vital to know how to convert between `bytes`
    and Unicode.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 许多I/O操作只知道如何处理`bytes`，即使字节对象引用文本数据。因此，了解如何在`bytes`和Unicode之间转换至关重要。
- en: The problem is that there are many ways to map `bytes` to Unicode text. Bytes
    are machine-readable values, while text is a human-readable format. Sitting in
    between is an encoding that maps a given sequence of bytes to a given sequence
    of text characters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于有许多种方法可以将`bytes`映射到Unicode文本。字节是机器可读的值，而文本是一种人类可读的格式。它们之间是一种编码，它将给定的字节序列映射到给定的文本字符序列。
- en: However, there are multiple such encodings (ASCII is only one of them). The
    same sequence of bytes represents completely different text characters when mapped
    using different encodings! So, `bytes` must be decoded using the same character
    set with which they were encoded. It's not possible to get text from bytes without
    knowing how the bytes should be decoded. If we receive unknown bytes without a
    specified encoding, the best we can do is guess what format they are encoded in,
    and we may be wrong.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有多种这样的编码（ASCII只是其中之一）。当使用不同的编码进行映射时，相同的字节序列代表完全不同的文本字符！因此，`bytes`必须使用与它们编码时相同的字符集进行解码。如果我们收到未知编码的字节而没有指定编码，我们能做的最好的事情就是猜测它们的编码格式，而我们可能会猜错。
- en: Converting bytes to text
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将字节转换为文本
- en: If we have an array of `bytes` from somewhere, we can convert it to Unicode
    using the `.decode` method on the `bytes` class. This method accepts a string
    for the name of the character encoding. There are many such names; common ones
    for Western languages include ASCII, UTF-8, and latin-1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从某个地方有一个`bytes`数组，我们可以使用`bytes`类的`.decode`方法将其转换为Unicode。这个方法接受一个字符串作为字符编码的名称。有许多这样的名称；西方语言的常见名称包括ASCII、UTF-8和拉丁-1。
- en: 'The sequence of bytes (in hex), 63 6c 69 63 68 e9, actually represents the
    characters of the word cliché in the latin-1 encoding. The following example will
    encode this sequence of bytes and convert it to a Unicode string using the latin-1
    encoding:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序列（十六进制）63 6c 69 63 68 e9，实际上代表了拉丁-1编码中单词cliché的字符。以下示例将对这个字节序列进行编码，并使用拉丁-1编码将其转换为Unicode字符串：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line creates a `bytes` object; the `b` character immediately before
    the string tells us that we are defining a `bytes` object instead of a normal
    Unicode string. Within the string, each byte is specified using—in this case—a
    hexadecimal number. The `\x` character escapes within the byte string, and each
    say, "the next two characters represent a byte using hexadecimal digits."
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个`bytes`对象；字符串前面的`b`字符告诉我们，我们正在定义一个`bytes`对象，而不是一个普通的Unicode字符串。在字符串中，每个字节都使用十六进制数字指定。在这种情况下，`\x`字符在字节字符串中转义，并且每个都表示“下面的两个字符使用十六进制数字表示一个字节”。
- en: 'Provided we are using a shell that understands the latin-1 encoding, the two
    `print` calls will output the following strings:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们使用了理解拉丁-1编码的shell，两个`print`调用将输出以下字符串：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first `print` statement renders the bytes for ASCII characters as themselves.
    The unknown (unknown to ASCII, that is) character stays in its escaped hex format.
    The output includes a `b` character at the beginning of the line to remind us
    that it is a `bytes` representation, not a string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`print`语句将ASCII字符的字节呈现为它们自己。未知的（对ASCII来说是未知的）字符保持在其转义的十六进制格式中。输出包括一行开头的`b`字符，提醒我们这是一个`bytes`表示，而不是一个字符串。
- en: The next call decodes the string using latin-1 encoding. The `decode` method
    returns a normal (Unicode) string with the correct characters. However, if we
    had decoded this same string using the Cyrillic "iso8859-5" encoding, we'd have
    ended up with the string 'clichщ'! This is because the `\xe9` byte maps to different
    characters in the two encodings.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用使用latin-1编码解码字符串。`decode`方法返回一个带有正确字符的普通（Unicode）字符串。然而，如果我们使用西里尔文“iso8859-5”编码解码相同的字符串，我们最终会得到字符串'clichщ'！这是因为`\xe9`字节在这两种编码中映射到不同的字符。
- en: Converting text to bytes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文本转换为字节
- en: 'If we need to convert incoming bytes into Unicode, clearly we''re also going
    to have situations where we convert outgoing Unicode into byte sequences. This
    is done with the `encode` method on the `str` class, which, like the `decode`
    method, requires a character set. The following code creates a Unicode string
    and encodes it in different character sets:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将传入的字节转换为Unicode，显然我们也会遇到将传出的Unicode转换为字节序列的情况。这是通过`str`类上的`encode`方法完成的，就像`decode`方法一样，需要一个字符集。以下代码创建一个Unicode字符串，并以不同的字符集对其进行编码：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first three encodings create a different set of bytes for the accented
    character. The fourth one can''t even handle that byte:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种编码为重音字符创建了不同的字节集。第四种甚至无法处理该字节：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Do you understand the importance of encoding now? The accented character is
    represented as a different byte for each encoding; if we use the wrong one when
    we are decoding bytes to text, we get the wrong character.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你明白编码的重要性了吗？重音字符对于每种编码都表示为不同的字节；如果我们在解码字节为文本时使用错误的编码，我们会得到错误的字符。
- en: 'The exception in the last case is not always the desired behavior; there may
    be cases where we want the unknown characters to be handled in a different way.
    The `encode` method takes an optional string argument named `errors` that can
    define how such characters should be handled. This string can be one of the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，异常并不总是期望的行为；可能有些情况下我们希望以不同的方式处理未知字符。`encode`方法接受一个名为`errors`的可选字符串参数，可以定义如何处理这些字符。这个字符串可以是以下之一：
- en: '`strict`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strict`'
- en: '`replace`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`'
- en: '`ignore`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore`'
- en: '`xmlcharrefreplace`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlcharrefreplace`'
- en: 'The `strict` replacement strategy is the default we just saw. When a byte sequence
    is encountered that does not have a valid representation in the requested encoding,
    an exception is raised. When the `replace` strategy is used, the character is
    replaced with a different character; in ASCII, it is a question mark; other encodings
    may use different symbols, such as an empty box. The `ignore` strategy simply
    discards any bytes it doesn''t understand, while the `xmlcharrefreplace` strategy
    creates an `xml` entity representing the Unicode character. This can be useful
    when converting unknown strings for use in an XML document. Here''s how each of
    the strategies affects our sample word:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`替换策略是我们刚刚看到的默认值。当遇到一个字节序列在请求的编码中没有有效表示时，会引发异常。当使用`replace`策略时，字符将被替换为不同的字符；在ASCII中，它是一个问号；其他编码可能使用不同的符号，比如一个空盒子。`ignore`策略简单地丢弃它不理解的任何字节，而`xmlcharrefreplace`策略创建一个代表Unicode字符的`xml`实体。这在将未知字符串转换为XML文档中使用时非常有用。以下是每种策略对我们示例单词的影响：'
- en: '| Strategy | "cliché".encode("ascii", strategy) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 策略 | "cliché".encode("ascii", strategy) |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `replace` | `b''clich?''` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | `b''clich?''` |'
- en: '| `ignore` | `b''clich''` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `ignore` | `b''clich''` |'
- en: '| `xmlcharrefreplace` | `b''cliché''` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `xmlcharrefreplace` | `b''cliché''` |'
- en: It is possible to call the `str.encode` and `bytes.decode` methods without passing
    an encoding string. The encoding will be set to the default encoding for the current
    platform. This will depend on the current operating system and locale or regional
    settings; you can look it up using the `sys.getdefaultencoding()` function. It
    is usually a good idea to specify the encoding explicitly, though, since the default
    encoding for a platform may change, or the program may one day be extended to
    work on text from a wider variety of sources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用`str.encode`和`bytes.decode`方法而不传递编码字符串。编码将设置为当前平台的默认编码。这将取决于当前操作系统和区域设置；您可以使用`sys.getdefaultencoding()`函数查找它。不过，通常最好明确指定编码，因为平台的默认编码可能会更改，或者程序可能有一天会扩展到处理更多来源的文本。
- en: If you are encoding text and don't know which encoding to use, it is best to
    use the UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern
    software, it is a de facto standard encoding to ensure documents in any language—or
    even multiple languages—can be exchanged. The various other possible encodings
    are useful for legacy documents or in regions that still use different character
    sets by default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要对文本进行编码，但不知道要使用哪种编码，最好使用UTF-8编码。UTF-8能够表示任何Unicode字符。在现代软件中，它是确保以任何语言甚至多种语言交换文档的事实标准编码。其他各种可能的编码对于传统文档或仍然默认使用不同字符集的地区非常有用。
- en: The UTF-8 encoding uses one byte to represent ASCII and other common characters,
    and up to four bytes for more complex characters. UTF-8 is special because it
    is backwards-compatible with ASCII; any ASCII document encoded using UTF-8 will
    be identical to the original ASCII document.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8编码使用一个字节来表示ASCII和其他常见字符，对于更复杂的字符最多使用四个字节。UTF-8很特殊，因为它向后兼容ASCII；使用UTF-8编码的任何ASCII文档将与原始ASCII文档相同。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I can never remember whether to use `encode` or `decode` to convert from binary
    bytes to Unicode. I always wished these methods were named "to_binary" and "from_binary"
    instead. If you have the same problem, try mentally replacing the word "code"
    with "binary"; "enbinary" and "debinary" are pretty close to "to_binary" and "from_binary".
    I have saved a lot of time by not looking up the method help files since devising
    this mnemonic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我永远记不住是使用`encode`还是`decode`来将二进制字节转换为Unicode。我总是希望这些方法的名称改为"to_binary"和"from_binary"。如果您有同样的问题，请尝试在脑海中用"binary"替换"code"；"enbinary"和"debinary"与"to_binary"和"from_binary"非常接近。自从想出这个记忆方法以来，我已经节省了很多时间，因为不用再查找方法帮助文件。
- en: Mutable byte strings
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变字节字符串
- en: The `bytes` type, like `str`, is immutable. We can use index and slice notation
    on a `bytes` object and search for a particular sequence of bytes, but we can't
    extend or modify them. This can be very inconvenient when dealing with I/O, as
    it is often necessary to buffer incoming or outgoing bytes until they are ready
    to be sent. For example, if we are receiving data from a socket, it may take several
    `recv` calls before we have received an entire message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes`类型和`str`一样是不可变的。我们可以在`bytes`对象上使用索引和切片表示法，并搜索特定的字节序列，但我们不能扩展或修改它们。当处理I/O时，这可能非常不方便，因为通常需要缓冲传入或传出的字节，直到它们准备好发送。例如，如果我们从套接字接收数据，可能需要多次`recv`调用才能接收到整个消息。'
- en: This is where the `bytearray` built-in comes in. This type behaves something
    like a list, except it only holds bytes. The constructor for the class can accept
    a `bytes` object to initialize it. The `extend` method can be used to append another
    `bytes` object to the existing array (for example, when more data comes from a
    socket or other I/O channel).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`bytearray`内置的作用。这种类型的行为有点像列表，只是它只包含字节。该类的构造函数可以接受一个`bytes`对象来初始化它。`extend`方法可以用来附加另一个`bytes`对象到现有的数组中（例如，当更多的数据来自套接字或其他I/O通道时）。
- en: 'Slice notation can be used on `bytearray` to modify the item inline. For example,
    this code constructs a `bytearray` from a `bytes` object and then replaces two
    bytes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表示法可以在`bytearray`上使用，以内联修改项目。例如，这段代码从`bytes`对象构造了一个`bytearray`，然后替换了两个字节：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be careful; if we want to manipulate a single element in the `bytearray`, it
    will expect us to pass an integer between 0 and 255 inclusive as the value. This
    integer represents a specific `bytes` pattern. If we try to pass a character or
    `bytes` object, it will raise an exception.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心；如果我们想要操作`bytearray`中的单个元素，它将期望我们传递一个介于0和255之间的整数作为值。这个整数代表一个特定的`bytes`模式。如果我们尝试传递一个字符或`bytes`对象，它将引发异常。
- en: 'A single byte character can be converted to an integer using the `ord` (short
    for ordinal) function. This function returns the integer representation of a single
    character:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单字节字符可以使用`ord`（ordinal的缩写）函数转换为整数。这个函数返回单个字符的整数表示：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After constructing the array, we replace the character at index `3` (the fourth
    character, as indexing starts at `0`, as with lists) with byte 103\. This integer
    was returned by the `ord` function and is the ASCII character for the lowercase
    `g`. For illustration, we also replaced the next character up with the byte number
    `68`, which maps to the ASCII character for the uppercase `D`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造数组之后，我们用字节103替换索引为`3`（第四个字符，因为索引从`0`开始，就像列表一样）。这个整数是由`ord`函数返回的，是小写`g`的ASCII字符。为了说明，我们还用字节号`68`替换了上一个字符，它映射到大写`D`的ASCII字符。
- en: The `bytearray` type has methods that allow it to behave like a list (we can
    append integer bytes to it, for example), but also like a `bytes` object; we can
    use methods like `count` and `find` the same way they would behave on a `bytes`
    or `str` object. The difference is that `bytearray` is a mutable type, which can
    be useful for building up complex sequences of bytes from a specific input source.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytearray`类型有一些方法，使它可以像列表一样行为（例如，我们可以向其附加整数字节），但也像`bytes`对象；我们可以使用`count`和`find`方法，就像它们在`bytes`或`str`对象上的行为一样。不同之处在于`bytearray`是一种可变类型，这对于从特定输入源构建复杂的字节序列是有用的。'
- en: Regular expressions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: You know what's really hard to do using object-oriented principles? Parsing
    strings to match arbitrary patterns, that's what. There have been a fair number
    of academic papers written in which object-oriented design is used to set up string
    parsing, but the result is always very verbose and hard to read, and they are
    not widely used in practice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道使用面向对象的原则真的很难做的事情是什么吗？解析字符串以匹配任意模式，就是这样。已经有相当多的学术论文使用面向对象的设计来设置字符串解析，但结果总是非常冗长和难以阅读，并且在实践中并不广泛使用。
- en: In the real world, string parsing in most programming languages is handled by
    regular expressions. These are not verbose, but, boy, are they ever hard to read,
    at least until you learn the syntax. Even though regular expressions are not object
    oriented, the Python regular expression library provides a few classes and objects
    that you can use to construct and run regular expressions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，大多数编程语言中的字符串解析都是由正则表达式处理的。这些表达式并不冗长，但是，哦，它们真的很难阅读，至少在你学会语法之前是这样。尽管正则表达式不是面向对象的，但Python正则表达式库提供了一些类和对象，可以用来构建和运行正则表达式。
- en: 'Regular expressions are used to solve a common problem: Given a string, determine
    whether that string matches a given pattern and, optionally, collect substrings
    that contain relevant information. They can be used to answer questions like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于解决一个常见问题：给定一个字符串，确定该字符串是否与给定的模式匹配，并且可选地收集包含相关信息的子字符串。它们可以用来回答类似的问题：
- en: Is this string a valid URL?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个字符串是一个有效的URL吗？
- en: What is the date and time of all warning messages in a log file?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件中所有警告消息的日期和时间是什么？
- en: Which users in `/etc/passwd` are in a given group?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd`中的哪些用户属于给定的组？'
- en: What username and document were requested by the URL a visitor typed?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访客输入的URL请求了哪个用户名和文档？
- en: There are many similar scenarios where regular expressions are the correct answer.
    Many programmers have made the mistake of implementing complicated and fragile
    string parsing libraries because they didn't know or wouldn't learn regular expressions.
    In this section, we'll gain enough knowledge of regular expressions to not make
    such mistakes!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类似的情况，正则表达式是正确的答案。许多程序员犯了一个错误，实现了复杂而脆弱的字符串解析库，因为他们不知道或不愿意学习正则表达式。在本节中，我们将获得足够的正则表达式知识，以避免犯这样的错误！
- en: Matching patterns
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配模式
- en: 'Regular expressions are a complicated mini-language. They rely on special characters
    to match unknown strings, but let''s start with literal characters, such as letters,
    numbers, and the space character, which always match themselves. Let''s see a
    basic example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种复杂的迷你语言。它们依赖于特殊字符来匹配未知的字符串，但让我们从字面字符开始，比如字母、数字和空格字符，它们总是匹配它们自己。让我们看一个基本的例子：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Python Standard Library module for regular expressions is called `re`. We
    import it and set up a search string and pattern to search for; in this case,
    they are the same string. Since the search string matches the given pattern, the
    conditional passes and the `print` statement executes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库模块用于正则表达式的称为`re`。我们导入它并设置一个搜索字符串和要搜索的模式；在这种情况下，它们是相同的字符串。由于搜索字符串与给定模式匹配，条件通过并且`print`语句执行。
- en: 'Bear in mind that the `match` function matches the pattern to the beginning
    of the string. Thus, if the pattern were `"ello world"`, no match would be found.
    With confusing asymmetry, the parser stops searching as soon as it finds a match,
    so the pattern `"hello wo"` matches successfully. Let''s build a small example
    program to demonstrate these differences and help us learn other regular expression
    syntax:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`match`函数将模式与字符串的开头匹配。因此，如果模式是`"ello world"`，将找不到匹配。令人困惑的是，解析器一旦找到匹配就停止搜索，因此模式`"hello
    wo"`可以成功匹配。让我们构建一个小的示例程序来演示这些差异，并帮助我们学习其他正则表达式语法：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is just a generic version of the earlier example that accepts the pattern
    and search string from the command line. We can see how the start of the pattern
    must match, but a value is returned as soon as a match is found in the following
    command-line interaction:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个通用版本的早期示例，它从命令行接受模式和搜索字符串。我们可以看到模式的开头必须匹配，但是一旦在以下命令行交互中找到匹配，就会返回一个值：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We'll be using this script throughout the next few sections. While the script
    is always invoked with the command line `python regex_generic.py "<pattern>" "<string>"`,
    we'll only see the output in the following examples, to conserve space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个部分中使用这个脚本。虽然脚本总是通过命令行`python regex_generic.py "<pattern>" "<string>"`调用，但我们只会在以下示例中看到输出，以节省空间。
- en: 'If you need control over whether items happen at the beginning or end of a
    line (or if there are no newlines in the string, at the beginning and end of the
    string), you can use the `^` and `$` characters to represent the start and end
    of the string respectively. If you want a pattern to match an entire string, it''s
    a good idea to include both of these:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要控制项目是否发生在行的开头或结尾（或者字符串中没有换行符，发生在字符串的开头和结尾），可以使用`^`和`$`字符分别表示字符串的开头和结尾。如果要匹配整个字符串的模式，最好包括这两个：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Matching a selection of characters
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配一组字符
- en: 'Let''s start with matching an arbitrary character. The period character, when
    used in a regular expression pattern, can match any single character. Using a
    period in the string means you don''t care what the character is, just that there
    is a character there. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从匹配任意字符开始。句号字符在正则表达式模式中使用时，可以匹配任何单个字符。在字符串中使用句号意味着您不在乎字符是什么，只是有一个字符在那里。例如：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how the last example does not match because there is no character at
    the period's position in the pattern.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一个示例不匹配，因为在模式中句号的位置上没有字符。
- en: 'That''s all well and good, but what if we only want a few specific characters
    to match? We can put a set of characters inside square brackets to match any one
    of those characters. So if we encounter the string `[abc]` in a regular expression
    pattern, we know that those five (including the two square brackets) characters
    will only match one character in the string being searched, and further, that
    this one character will be either an `a`, a `b`, or a `c`. See a few examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做很好，但是如果我们只想匹配几个特定的字符怎么办？我们可以将一组字符放在方括号中，以匹配其中任何一个字符。因此，如果我们在正则表达式模式中遇到字符串`[abc]`，我们知道这五个（包括两个方括号）字符只会匹配字符串中的一个字符，并且进一步地，这一个字符将是`a`、`b`或`c`中的一个。看几个例子：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These square bracket sets should be named character sets, but they are more
    often referred to as **character classes**. Often, we want to include a large
    range of characters inside these sets, and typing them all out can be monotonous
    and error-prone. Fortunately, the regular expression designers thought of this
    and gave us a shortcut. The dash character, in a character set, will create a
    range. This is especially useful if you want to match "all lower case letters",
    "all letters", or "all numbers" as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方括号集应该被称为字符集，但更常见的是被称为**字符类**。通常，我们希望在这些集合中包含大量的字符，并且将它们全部打出来可能会很单调和容易出错。幸运的是，正则表达式设计者考虑到了这一点，并给了我们一个快捷方式。在字符集中，短横线字符将创建一个范围。如果您想匹配"所有小写字母"、"所有字母"或"所有数字"，可以使用如下方法：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are other ways to match or exclude individual characters, but you'll need
    to find a more comprehensive tutorial via a web search if you want to find out
    what they are!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他匹配或排除单个字符的方法，但如果您想找出它们是什么，您需要通过网络搜索找到更全面的教程！
- en: Escaping characters
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'If putting a period character in a pattern matches any arbitrary character,
    how do we match just a period in a string? One way might be to put the period
    inside square brackets to make a character class, but a more generic method is
    to use backslashes to escape it. Here''s a regular expression to match two digit
    decimal numbers between 0.00 and 0.99:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在模式中放置句号字符可以匹配任意字符，那么如何在字符串中匹配一个句号呢？一种方法是将句号放在方括号中以创建一个字符类，但更通用的方法是使用反斜杠进行转义。下面是一个正则表达式，用于匹配0.00到0.99之间的两位小数：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For this pattern, the two characters `\.` match the single `.` character. If
    the period character is missing or is a different character, it does not match.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，两个字符`\.`匹配单个`.`字符。如果句号字符缺失或是另一个字符，它就不匹配。
- en: This backslash escape sequence is used for a variety of special characters in
    regular expressions. You can use `\[` to insert a square bracket without starting
    a character class, and `\(` to insert a parenthesis, which we'll later see is
    also a special character.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反斜杠转义序列用于正则表达式中的各种特殊字符。您可以使用`\[`来插入一个方括号而不开始一个字符类，`\(`来插入一个括号，我们稍后会看到它也是一个特殊字符。
- en: 'More interestingly, we can also use the escape symbol followed by a character
    to represent special characters such as newlines (`\n`), and tabs (`\t`). Further,
    some character classes can be represented more succinctly using escape strings;
    `\s` represents whitespace characters, `\w` represents letters, numbers, and underscore,
    and `\d` represents a digit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们还可以使用转义符号后跟一个字符来表示特殊字符，例如换行符（`\n`）和制表符（`\t`）。此外，一些字符类可以更简洁地用转义字符串表示；`\s`表示空白字符，`\w`表示字母、数字和下划线，`\d`表示数字：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Matching multiple characters
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配多个字符
- en: With this information, we can match most strings of a known length, but most
    of the time we don't know how many characters to match inside a pattern. Regular
    expressions can take care of this, too. We can modify a pattern by appending one
    of several hard-to-remember punctuation symbols to match multiple characters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以匹配大多数已知长度的字符串，但大多数情况下，我们不知道模式内要匹配多少个字符。正则表达式也可以处理这个问题。我们可以通过附加几个难以记住的标点符号来修改模式以匹配多个字符。
- en: 'The asterisk (`*`) character says that the previous pattern can be matched
    zero or more times. This probably sounds silly, but it''s one of the most useful
    repetition characters. Before we explore why, consider some silly examples to
    make sure we understand what it does:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）字符表示前面的模式可以匹配零次或多次。这可能听起来很愚蠢，但它是最有用的重复字符之一。在我们探索原因之前，考虑一些愚蠢的例子，以确保我们理解它的作用：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, the `*` character in the pattern says that the previous pattern (the `l`
    character) is optional, and if present, can be repeated as many times as possible
    to match the pattern. The rest of the characters (`h`, `e`, and `o`) have to appear
    exactly once.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模式中的`*`字符表示前面的模式（`l`字符）是可选的，如果存在，可以重复多次以匹配模式。其余的字符（`h`，`e`和`o`）必须出现一次。
- en: It's pretty rare to want to match a single letter multiple times, but it gets
    more interesting if we combine the asterisk with patterns that match multiple
    characters. `.*`, for example, will match any string, whereas `[a-z]*` matches
    any collection of lowercase words, including the empty string.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配单个字母多次可能是非常罕见的，但如果我们将星号与匹配多个字符的模式结合起来，就会变得更有趣。例如，`.*`将匹配任何字符串，而`[a-z]*`将匹配任何小写单词的集合，包括空字符串。
- en: 'For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The plus (`+`) sign in a pattern behaves similarly to an asterisk; it states
    that the previous pattern can be repeated one or more times, but, unlike the asterisk
    is not optional. The question mark (?) ensures a pattern shows up exactly zero
    or one times, but not more. Let''s explore some of these by playing with numbers
    (remember that `\d` matches the same character class as `[0-9]`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中的加号（`+`）与星号类似；它表示前面的模式可以重复一次或多次，但与星号不同的是，它不是可选的。问号（`?`）确保模式出现零次或一次，但不会更多。让我们通过玩数字来探索一些例子（记住`\d`与`[0-9]`匹配相同的字符类）：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Grouping patterns together
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式分组在一起
- en: 'So far we''ve seen how we can repeat a pattern multiple times, but we are restricted
    in what patterns we can repeat. If we want to repeat individual characters, we''re
    covered, but what if we want a repeating sequence of characters? Enclosing any
    set of patterns in parenthesis allows them to be treated as a single pattern when
    applying repetition operations. Compare these patterns:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何可以多次重复一个模式，但我们在可以重复的模式上受到了限制。如果我们想重复单个字符，那么我们已经覆盖了，但如果我们想要重复一系列字符呢？将任何一组模式括在括号中允许它们在应用重复操作时被视为单个模式。比较这些模式：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Combined with complex patterns, this grouping feature greatly expands our pattern-matching
    repertoire. Here''s a regular expression that matches simple English sentences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与复杂模式结合使用，这种分组功能极大地扩展了我们的模式匹配能力。这是一个匹配简单英语句子的正则表达式：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first word starts with a capital, followed by zero or more lowercase letters.
    Then, we enter a parenthetical that matches a single space followed by a word
    of one or more lowercase letters. This entire parenthetical is repeated zero or
    more times, and the pattern is terminated with a period. There cannot be any other
    characters after the period, as indicated by the `$` matching the end of string.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单词以大写字母开头，后面跟着零个或多个小写字母。然后，我们进入一个匹配一个空格后跟一个或多个小写字母的单词的括号。整个括号部分重复零次或多次，模式以句号结束。句号后不能有任何其他字符，这由`$`匹配字符串结束来表示。
- en: We've seen many of the most basic patterns, but the regular expression language
    supports many more. I spent my first few years using regular expressions looking
    up the syntax every time I needed to do something. It is worth bookmarking Python's
    documentation for the `re` module and reviewing it frequently. There are very
    few things that regular expressions cannot match, and they should be the first
    tool you reach for when parsing strings.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多最基本的模式，但正则表达式语言支持更多。我在使用正则表达式的头几年里，每次需要做一些事情时都会查找语法。值得将Python的`re`模块文档加入书签，并经常复习。几乎没有什么是正则表达式无法匹配的，当解析字符串时，它们应该是你首选的工具。
- en: Getting information from regular expressions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从正则表达式获取信息
- en: Let's now focus on the Python side of things. The regular expression syntax
    is the furthest thing from object-oriented programming. However, Python's `re`
    module provides an object-oriented interface to enter the regular expression engine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于Python方面。正则表达式语法与面向对象编程完全不同。然而，Python的`re`模块提供了一个面向对象的接口来进入正则表达式引擎。
- en: We've been checking whether the `re.match` function returns a valid object or
    not. If a pattern does not match, that function returns `None`. If it does match,
    however, it returns a useful object that we can introspect for information about
    the pattern.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在检查`re.match`函数是否返回有效对象。如果模式不匹配，该函数将返回`None`。但是，如果匹配，它将返回一个有用的对象，我们可以内省有关模式的信息。
- en: 'So far, our regular expressions have answered questions such as "Does this
    string match this pattern?" Matching patterns is useful, but in many cases, a
    more interesting question is, "If this string matches this pattern, what is the
    value of a relevant substring?" If you use groups to identify parts of the pattern
    that you want to reference later, you can get them out of the match return value
    as illustrated in the next example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的正则表达式已经回答了诸如“这个字符串是否与此模式匹配？”的问题。匹配模式是有用的，但在许多情况下，一个更有趣的问题是，“如果这个字符串匹配这个模式，相关子字符串的值是多少？”如果您使用组来标识您想要稍后引用的模式的部分，您可以从匹配返回值中获取它们，如下一个示例所示：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The specification describing valid e-mail addresses is extremely complicated,
    and the regular expression that accurately matches all possibilities is obscenely
    long. So we cheated and made a simple regular expression that matches some common
    e-mail addresses; the point is that we want to access the domain name (after the
    `@` sign) so we can connect to that address. This is done easily by wrapping that
    part of the pattern in parenthesis and calling the `groups()` method on the object
    returned by match.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 描述有效电子邮件地址的规范非常复杂，准确匹配所有可能性的正则表达式非常长。因此，我们作弊并制作了一个简单的正则表达式，用于匹配一些常见的电子邮件地址；重点是我们想要访问域名（在`@`符号之后），以便我们可以连接到该地址。通过将模式的该部分包装在括号中，并在匹配返回的对象上调用`groups()`方法，可以轻松实现这一点。
- en: The `groups` method returns a tuple of all the groups matched inside the pattern,
    which you can index to access a specific value. The groups are ordered from left
    to right. However, bear in mind that groups can be nested, meaning you can have
    one or more groups inside another group. In this case, the groups are returned
    in the order of their left-most brackets, so the outermost group will be returned
    before its inner matching groups.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`groups`方法返回模式内匹配的所有组的元组，您可以对其进行索引以访问特定值。组从左到右排序。但是，请记住，组可以是嵌套的，这意味着您可以在另一个组内部有一个或多个组。在这种情况下，组按其最左边的括号顺序返回，因此外部组将在其内部匹配组之前返回。'
- en: In addition to the match function, the `re` module provides a couple other useful
    functions, `search`, and `findall`. The `search` function finds the first instance
    of a matching pattern, relaxing the restriction that the pattern start at the
    first letter of the string. Note that you can get a similar effect by using match
    and putting a `^.*` character at the front of the pattern to match any characters
    between the start of the string and the pattern you are looking for.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了匹配函数之外，`re`模块还提供了另外两个有用的函数，`search`和`findall`。`search`函数找到匹配模式的第一个实例，放宽了模式从字符串的第一个字母开始的限制。请注意，您可以通过使用匹配并在模式的前面放置`^.*`字符来获得类似的效果，以匹配字符串的开头和您要查找的模式之间的任何字符。
- en: The `findall` function behaves similarly to search, except that it finds all
    non-overlapping instances of the matching pattern, not just the first one. Basically,
    it finds the first match, then it resets the search to the end of that matching
    string and finds the next one.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall`函数的行为类似于search，只是它找到匹配模式的所有非重叠实例，而不仅仅是第一个。基本上，它找到第一个匹配，然后将搜索重置为该匹配字符串的末尾，并找到下一个匹配。'
- en: 'Instead of returning a list of match objects, as you would expect, it returns
    a list of matching strings. Or tuples. Sometimes it''s strings, sometimes it''s
    tuples. It''s not a very good API at all! As with all bad APIs, you''ll have to
    memorize the differences and not rely on intuition. The type of the return value
    depends on the number of bracketed groups inside the regular expression:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与其返回预期的匹配对象列表，它返回一个匹配字符串的列表。或元组。有时是字符串，有时是元组。这根本不是一个很好的API！与所有糟糕的API一样，您将不得不记住差异并不依赖直觉。返回值的类型取决于正则表达式内括号组的数量：
- en: If there are no groups in the pattern, `re.findall` will return a list of strings,
    where each value is a complete substring from the source string that matches the
    pattern
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中没有组，则`re.findall`将返回一个字符串列表，其中每个值都是与模式匹配的源字符串的完整子字符串
- en: If there is exactly one group in the pattern, `re.findall` will return a list
    of strings where each value is the contents of that group
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中恰好有一个组，则`re.findall`将返回一个字符串列表，其中每个值都是该组的内容
- en: If there are multiple groups in the pattern, then `re.findall` will return a
    list of tuples where each tuple contains a value from a matching group, in order
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中有多个组，则`re.findall`将返回一个元组列表，其中每个元组包含匹配组的值，按顺序排列
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you are designing function calls in your own Python libraries, try to make
    the function always return a consistent data structure. It is often good to design
    functions that can take arbitrary inputs and process them, but the return value
    should not switch from single value to a list, or a list of values to a list of
    tuples depending on the input. Let `re.findall` be a lesson!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在设计自己的Python库中的函数调用时，请尝试使函数始终返回一致的数据结构。通常设计函数可以接受任意输入并处理它们是很好的，但返回值不应该从单个值切换到列表，或者从值列表切换到元组列表，具体取决于输入。让`re.findall`成为一个教训！
- en: 'The examples in the following interactive session will hopefully clarify the
    differences:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互式会话中的示例将有望澄清差异：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Making repeated regular expressions efficient
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使重复的正则表达式高效
- en: Whenever you call one of the regular expression methods, the engine has to convert
    the pattern string into an internal structure that makes searching strings fast.
    This conversion takes a non-trivial amount of time. If a regular expression pattern
    is going to be reused multiple times (for example, inside a `for` or `while` loop),
    it would be better if this conversion step could be done only once.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用正则表达式方法之一时，引擎都必须将模式字符串转换为内部结构，以便快速搜索字符串。这种转换需要相当长的时间。如果一个正则表达式模式将被多次重复使用（例如，在`for`或`while`循环内），最好只进行一次这种转换。
- en: This is possible with the `re.compile` method. It returns an object-oriented
    version of the regular expression that has been compiled down and has the methods
    we've explored (`match`, `search`, `findall`) already, among others. We'll see
    examples of this in the case study.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`re.compile`方法实现的。它返回一个已经编译过的正则表达式的面向对象版本，并且具有我们已经探索过的方法（`match`、`search`、`findall`）等。我们将在案例研究中看到这方面的例子。
- en: 'This has definitely been a condensed introduction to regular expressions. At
    this point, we have a good feel for the basics and will recognize when we need
    to do further research. If we have a string pattern matching problem, regular
    expressions will almost certainly be able to solve them for us. However, we may
    need to look up new syntaxes in a more comprehensive coverage of the topic. But
    now we know what to look for! Let''s move on to a completely different topic:
    serializing data for storage.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个简短的正则表达式介绍。到目前为止，我们对基础知识有了很好的了解，并且会意识到何时需要进行进一步的研究。如果我们遇到字符串模式匹配问题，正则表达式几乎肯定能够解决。但是，我们可能需要在更全面地涵盖该主题的情况下查找新的语法。但现在我们知道该找什么了！让我们继续进行一个完全不同的主题：为存储序列化数据。
- en: Serializing objects
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Nowadays, we take the ability to write data to a file and retrieve it at an
    arbitrary later date for granted. As convenient as this is (imagine the state
    of computing if we couldn't store anything!), we often find ourselves converting
    data we have stored in a nice object or design pattern in memory into some kind
    of clunky text or binary format for storage, transfer over the network, or remote
    invocation on a distant server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们认为能够将数据写入文件并在任意以后的日期检索出来是理所当然的。尽管这很方便（想象一下，如果我们不能存储任何东西，计算机的状态会是什么样子！），但我们经常发现自己需要将我们在内存中存储的数据转换为某种笨拙的文本或二进制格式，以便进行存储、在网络上传输或在远程服务器上进行远程调用。
- en: The Python `pickle` module is an object-oriented way to store objects directly
    in a special storage format. It essentially converts an object (and all the objects
    it holds as attributes) into a sequence of bytes that can be stored or transported
    however we see fit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`pickle`模块是一种以面向对象的方式直接存储对象的特殊存储格式。它基本上将一个对象（以及它作为属性持有的所有对象）转换为一系列字节，可以根据需要进行存储或传输。
- en: For basic work, the `pickle` module has an extremely simple interface. It is
    comprised of four basic functions for storing and loading data; two for manipulating
    file-like objects, and two for manipulating `bytes` objects (the latter are just
    shortcuts to the file-like interface, so we don't have to create a `BytesIO` file-like
    object ourselves).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本工作，`pickle`模块有一个非常简单的接口。它由四个基本函数组成，用于存储和加载数据；两个用于操作类似文件的对象，两个用于操作`bytes`对象（后者只是文件类似接口的快捷方式，因此我们不必自己创建`BytesIO`文件类似对象）。
- en: The `dump` method accepts an object to be written and a file-like object to
    write the serialized bytes to. This object must have a `write` method (or it wouldn't
    be file-like), and that method must know how to handle a `bytes` argument (so
    a file opened for text output wouldn't work).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump`方法接受一个要写入的对象和一个类似文件的对象，用于将序列化的字节写入其中。这个对象必须有一个`write`方法（否则它就不会像文件一样），并且该方法必须知道如何处理`bytes`参数（因此，对于文本输出打开的文件将无法工作）。'
- en: 'The `load` method does exactly the opposite; it reads a serialized object from
    a file-like object. This object must have the proper file-like `read` and `readline`
    arguments, each of which must, of course, return `bytes`. The `pickle` module
    will load the object from these bytes and the `load` method will return the fully
    reconstructed object. Here''s an example that stores and then loads some data
    in a list object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`方法恰恰相反；它从类似文件的对象中读取序列化的对象。这个对象必须具有适当的类似文件的`read`和`readline`参数，每个参数当然都必须返回`bytes`。`pickle`模块将从这些字节中加载对象，并且`load`方法将返回完全重建的对象。以下是一个存储然后加载列表对象中的一些数据的示例：'
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code works as advertised: the objects are stored in the file and then
    loaded from the same file. In each case, we open the file using a `with` statement
    so that it is automatically closed. The file is first opened for writing and then
    a second time for reading, depending on whether we are storing or loading data.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按照预期工作：对象被存储在文件中，然后从同一个文件中加载。在每种情况下，我们使用`with`语句打开文件，以便它会自动关闭。文件首先被打开以进行写入，然后第二次以进行读取，具体取决于我们是存储还是加载数据。
- en: The `assert` statement at the end would raise an error if the newly loaded object
    is not equal to the original object. Equality does not imply that they are the
    same object. Indeed, if we print the `id()` of both objects, we would discover
    they are different. However, because they are both lists whose contents are equal,
    the two lists are also considered equal.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`assert`语句会在新加载的对象不等于原始对象时引发错误。相等并不意味着它们是相同的对象。事实上，如果我们打印两个对象的`id()`，我们会发现它们是不同的。但是，因为它们都是内容相等的列表，所以这两个列表也被认为是相等的。
- en: The `dumps` and `loads` functions behave much like their file-like counterparts,
    except they return or accept `bytes` instead of file-like objects. The `dumps`
    function requires only one argument, the object to be stored, and it returns a
    serialized `bytes` object. The `loads` function requires a `bytes` object and
    returns the restored object. The `'s'` character in the method names is short
    for string; it's a legacy name from ancient versions of Python, where `str` objects
    were used instead of `bytes`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumps`和`loads`函数的行为与它们的类似文件的对应函数类似，只是它们返回或接受`bytes`而不是类似文件的对象。`dumps`函数只需要一个参数，即要存储的对象，并返回一个序列化的`bytes`对象。`loads`函数需要一个`bytes`对象，并返回还原的对象。方法名称中的`''s''`字符代表字符串；这是Python古老版本的一个遗留名称，那时使用的是`str`对象而不是`bytes`。'
- en: Both `dump` methods accept an optional `protocol` argument. If we are saving
    and loading pickled objects that are only going to be used in Python 3 programs,
    we don't need to supply this argument. Unfortunately, if we are storing objects
    that may be loaded by older versions of Python, we have to use an older and less
    efficient protocol. This should not normally be an issue. Usually, the only program
    that would load a pickled object would be the same one that stored it. Pickle
    is an unsafe format, so we don't want to be sending it unsecured over the Internet
    to unknown interpreters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`dump`方法都接受一个可选的`protocol`参数。如果我们正在保存和加载只会在Python 3程序中使用的拾取对象，我们不需要提供此参数。不幸的是，如果我们正在存储可能会被旧版本的Python加载的对象，我们必须使用一个更旧且效率低下的协议。这通常不是问题。通常，加载拾取对象的唯一程序将是存储它的程序。拾取是一种不安全的格式，因此我们不希望将其不安全地发送到未知的解释器。
- en: The argument supplied is an integer version number. The default version is number
    3, representing the current highly efficient storage system used by Python 3 pickling.
    The number 2 is the older version, which will store an object that can be loaded
    on all interpreters back to Python 2.3\. As 2.6 is the oldest of Python that is
    still widely used in the wild, version 2 pickling is normally sufficient. Versions
    0 and 1 are supported on older interpreters; 0 is an ASCII format, while 1 is
    a binary format. There is also an optimized version 4 that may one day become
    the default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的参数是一个整数版本号。默认版本是3，代表Python 3拾取使用的当前高效存储系统。数字2是旧版本，将存储一个可以在所有解释器上加载回Python
    2.3的对象。由于2.6是仍然广泛使用的Python中最古老的版本，因此通常版本2的拾取就足够了。版本0和1在旧解释器上受支持；0是ASCII格式，而1是二进制格式。还有一个优化的版本4，可能有一天会成为默认版本。
- en: As a rule of thumb, then, if you know that the objects you are pickling will
    only be loaded by a Python 3 program (for example, only your program will be loading
    them), use the default pickling protocol. If they may be loaded by unknown interpreters,
    pass a protocol value of 2, unless you really believe they may need to be loaded
    by an archaic version of Python.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个经验法则，如果您知道您要拾取的对象只会被Python 3程序加载（例如，只有您的程序会加载它们），请使用默认的拾取协议。如果它们可能会被未知的解释器加载，传递一个值为2的协议值，除非您真的相信它们可能需要被古老版本的Python加载。
- en: 'If we do pass a protocol to `dump` or `dumps`, we should use a keyword argument
    to specify it: `pickle.dumps(my_object, protocol=2)`. This is not strictly necessary,
    as the method only accepts two arguments, but typing out the full keyword argument
    reminds readers of our code what the purpose of the number is. Having a random
    integer in the method call would be hard to read. Two what? Store two copies of
    the object, maybe? Remember, code should always be readable. In Python, less code
    is often more readable than longer code, but not always. Be explicit.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`dump`或`dumps`传递一个协议，我们应该使用关键字参数来指定它：`pickle.dumps(my_object, protocol=2)`。这并不是严格必要的，因为该方法只接受两个参数，但是写出完整的关键字参数会提醒我们代码的读者数字的目的。在方法调用中有一个随机整数会很难阅读。两个是什么？存储对象的两个副本，也许？记住，代码应该始终可读。在Python中，较少的代码通常比较长的代码更易读，但并非总是如此。要明确。
- en: It is possible to call `dump` or `load` on a single open file more than once.
    Each call to `dump` will store a single object (plus any objects it is composed
    of or contains), while a call to `load` will load and return just one object.
    So for a single file, each separate call to `dump` when storing the object should
    have an associated call to `load` when restoring at a later date.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个打开的文件上多次调用`dump`或`load`。每次调用`dump`都会存储一个对象（以及它所组成或包含的任何对象），而调用`load`将加载并返回一个对象。因此，对于单个文件，存储对象时的每个单独的`dump`调用应该在以后的某个日期还原时有一个关联的`load`调用。
- en: Customizing pickles
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义拾取
- en: With most common Python objects, pickling "just works". Basic primitives such
    as integers, floats, and strings can be pickled, as can any container object,
    such as lists or dictionaries, provided the contents of those containers are also
    picklable. Further, and importantly, any object can be pickled, so long as all
    of its attributes are also picklable.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数常见的Python对象，拾取“只是起作用”。基本的原始类型，如整数、浮点数和字符串可以被拾取，任何容器对象，如列表或字典，只要这些容器的内容也是可拾取的。此外，任何对象都可以被拾取，只要它的所有属性也是可拾取的。
- en: So what makes an attribute unpicklable? Usually, it has something to do with
    time-sensitive attributes that it would not make sense to load in the future.
    For example, if we have an open network socket, open file, running thread, or
    database connection stored as an attribute on an object, it would not make sense
    to pickle these objects; a lot of operating system state would simply be gone
    when we attempted to reload them later. We can't just pretend a thread or socket
    connection exists and make it appear! No, we need to somehow customize how such
    transient data is stored and restored.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么使属性无法被拾取？通常，这与时间敏感的属性有关，这些属性在将来加载时是没有意义的。例如，如果我们在对象的属性上存储了一个打开的网络套接字、打开的文件、运行中的线程或数据库连接，那么将这些对象拾取是没有意义的；当我们尝试以后重新加载它们时，很多操作系统状态将会消失。我们不能假装一个线程或套接字连接存在并使其出现！不，我们需要以某种方式自定义如何存储和还原这样的瞬态数据。
- en: 'Here''s a class that loads the contents of a web page every hour to ensure
    that they stay up to date. It uses the `threading.Timer` class to schedule the
    next update:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个每小时加载网页内容以确保其保持最新的类。它使用`threading.Timer`类来安排下一次更新：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `url`, `contents`, and `last_updated` are all pickleable, but if we try
    to pickle an instance of this class, things go a little nutty on the `self.timer`
    instance:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`、`contents`和`last_updated`都是可pickle的，但如果我们尝试pickle这个类的一个实例，事情在`self.timer`实例上会有点混乱：'
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's not a very useful error, but it looks like we're trying to pickle something
    we shouldn't be. That would be the `Timer` instance; we're storing a reference
    to `self.timer` in the schedule method, and that attribute cannot be serialized.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个非常有用的错误，但看起来我们正在尝试pickle我们不应该pickle的东西。那将是`Timer`实例；我们在schedule方法中存储了对`self.timer`的引用，而该属性无法被序列化。
- en: When `pickle` tries to serialize an object, it simply tries to store the object's
    `__dict__` attribute; `__dict__` is a dictionary mapping all the attribute names
    on the object to their values. Luckily, before checking `__dict__`, `pickle` checks
    to see whether a `__getstate__` method exists. If it does, it will store the return
    value of that method instead of the `__dict__`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当`pickle`尝试序列化一个对象时，它只是尝试存储对象的`__dict__`属性；`__dict__`是一个字典，将对象上的所有属性名称映射到它们的值。幸运的是，在检查`__dict__`之前，`pickle`会检查是否存在`__getstate__`方法。如果存在，它将存储该方法的返回值，而不是`__dict__`。
- en: 'Let''s add a `__getstate__` method to our `UpdatedURL` class that simply returns
    a copy of the `__dict__` without a timer:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`UpdatedURL`类添加一个`__getstate__`方法，它简单地返回`__dict__`的副本，而不包括计时器：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If we pickle the object now, it will no longer fail. And we can even successfully
    restore that object using `loads`. However, the restored object doesn't have a
    timer attribute, so it will not be refreshing the content like it is designed
    to do. We need to somehow create a new timer (to replace the missing one) when
    the object is unpickled.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在pickle对象，它将不再失败。我们甚至可以使用`loads`成功地恢复该对象。然而，恢复的对象没有计时器属性，因此它将无法像设计时那样刷新内容。我们需要在对象被反pickle时以某种方式创建一个新的计时器（以替换丢失的计时器）。
- en: 'As we might expect, there is a complementary `__setstate__` method that can
    be implemented to customize unpickling. This method accepts a single argument,
    which is the object returned by `__getstate__`. If we implement both methods,
    `__getstate__` is not required to return a dictionary, since `__setstate__` will
    know what to do with whatever object `__getstate__` chooses to return. In our
    case, we simply want to restore the `__dict__`, and then create a new timer:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的那样，有一个互补的`__setstate__`方法，可以实现以自定义反pickle。这个方法接受一个参数，即`__getstate__`返回的对象。如果我们实现了这两个方法，`__getstate__`不需要返回一个字典，因为`__setstate__`将知道如何处理`__getstate__`选择返回的任何对象。在我们的情况下，我们只想恢复`__dict__`，然后创建一个新的计时器：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `pickle` module is very flexible and provides other tools to further customize
    the pickling process if you need them. However, these are beyond the scope of
    this book. The tools we've covered are sufficient for many basic pickling tasks.
    Objects to be pickled are normally relatively simple data objects; we would not
    likely pickle an entire running program or complicated design pattern, for example.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块非常灵活，并提供其他工具来进一步自定义pickling过程，如果您需要的话。然而，这些超出了本书的范围。我们已经涵盖的工具对于许多基本的pickling任务已经足够了。通常被pickle的对象是相对简单的数据对象；例如，我们不太可能pickle整个运行中的程序或复杂的设计模式。'
- en: Serializing web objects
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化网络对象
- en: It is not a good idea to load a pickled object from an unknown or untrusted
    source. It is possible to inject arbitrary code into a pickled file to maliciously
    attack a computer via the pickle. Another disadvantage of pickles is that they
    can only be loaded by other Python programs, and cannot be easily shared with
    services written in other languages.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从未知或不受信任的来源加载pickled对象并不是一个好主意。可以向pickled文件中注入任意代码，以恶意攻击计算机。pickles的另一个缺点是它们只能被其他Python程序加载，并且不能轻松地与其他语言编写的服务共享。
- en: There are many formats that have been used for this purpose over the years.
    XML (Extensible Markup Language) used to be very popular, especially with Java
    developers. YAML (Yet Another Markup Language) is another format that you may
    see referenced occasionally. Tabular data is frequently exchanged in the CSV (Comma
    Separated Value) format. Many of these are fading into obscurity and there are
    many more that you will encounter over time. Python has solid standard or third-party
    libraries for all of them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来已经使用了许多用于此目的的格式。XML（可扩展标记语言）曾经非常流行，特别是在Java开发人员中。YAML（另一种标记语言）是另一种格式，偶尔也会看到它被引用。表格数据经常以CSV（逗号分隔值）格式交换。其中许多已经逐渐被遗忘，而且您将随着时间的推移遇到更多。Python对所有这些都有坚实的标准或第三方库。
- en: Before using such libraries on untrusted data, make sure to investigate security
    concerns with each of them. XML and YAML, for example, both have obscure features
    that, used maliciously, can allow arbitrary commands to be executed on the host
    machine. These features may not be turned off by default. Do your research.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在对不受信任的数据使用这样的库之前，请确保调查每个库的安全性问题。例如，XML和YAML都有模糊的特性，如果恶意使用，可以允许在主机机器上执行任意命令。这些特性可能不会默认关闭。做好你的研究。
- en: '**JavaScript Object Notation** (**JSON**) is a human readable format for exchanging
    primitive data. JSON is a standard format that can be interpreted by a wide array
    of heterogeneous client systems. Hence, JSON is extremely useful for transmitting
    data between completely decoupled systems. Further, JSON does not have any support
    for executable code, only data can be serialized; thus, it is more difficult to
    inject malicious statements into it.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种用于交换基本数据的人类可读格式。JSON是一种标准格式，可以被各种异构客户端系统解释。因此，JSON非常适用于在完全解耦的系统之间传输数据。此外，JSON没有任何对可执行代码的支持，只能序列化数据；因此，很难向其中注入恶意语句。'
- en: Because JSON can be easily interpreted by JavaScript engines, it is often used
    for transmitting data from a web server to a JavaScript-capable web browser. If
    the web application serving the data is written in Python, it needs a way to convert
    internal data into the JSON format.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JSON可以被JavaScript引擎轻松解释，所以经常用于从Web服务器传输数据到支持JavaScript的Web浏览器。如果提供数据的Web应用程序是用Python编写的，它需要一种将内部数据转换为JSON格式的方法。
- en: There is a module to do this, predictably named `json`. This module provides
    a similar interface to the `pickle` module, with `dump`, `load`, `dumps`, and
    `loads` functions. The default calls to these functions are nearly identical to
    those in `pickle`, so let us not repeat the details. There are a couple differences;
    obviously, the output of these calls is valid JSON notation, rather than a pickled
    object. In addition, the `json` functions operate on `str` objects, rather than
    `bytes`. Therefore, when dumping to or loading from a file, we need to create
    text files rather than binary ones.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个模块可以做到这一点，它的名称可预测地叫做`json`。该模块提供了与`pickle`模块类似的接口，具有`dump`、`load`、`dumps`和`loads`函数。对这些函数的默认调用几乎与`pickle`中的调用相同，因此我们不再重复细节。有一些区别；显然，这些调用的输出是有效的JSON表示，而不是一个被pickled的对象。此外，`json`函数操作`str`对象，而不是`bytes`。因此，在转储到文件或从文件加载时，我们需要创建文本文件而不是二进制文件。
- en: The JSON serializer is not as robust as the `pickle` module; it can only serialize
    basic types such as integers, floats, and strings, and simple containers such
    as dictionaries and lists. Each of these has a direct mapping to a JSON representation,
    but JSON is unable to represent classes, methods, or functions. It is not possible
    to transmit complete objects in this format. Because the receiver of an object
    we have dumped to JSON format is normally not a Python object, it would not be
    able to understand classes or methods in the same way that Python does, anyway.
    In spite of the O for Object in its name, JSON is a **data** notation; objects,
    as you recall, are composed of both data and behavior.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JSON序列化器不像`pickle`模块那样健壮；它只能序列化诸如整数、浮点数和字符串之类的基本类型，以及诸如字典和列表之类的简单容器。每种类型都有直接映射到JSON表示，但JSON无法表示类、方法或函数。无法以这种格式传输完整的对象。因为我们将对象转储为JSON格式的接收者通常不是Python对象，所以它无法以与Python相同的方式理解类或方法。尽管其名称中有“对象”一词，但JSON是一种**数据**表示法；对象，你会记得，由数据和行为组成。
- en: If we do have objects for which we want to serialize only the data, we can always
    serialize the object's `__dict__` attribute. Or we can semiautomate this task
    by supplying custom code to create or parse a JSON serializable dictionary from
    certain types of objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有要序列化仅包含数据的对象，我们总是可以序列化对象的`__dict__`属性。或者我们可以通过提供自定义代码来从某些类型的对象创建或解析JSON可序列化字典来半自动化这个任务。
- en: In the `json` module, both the object storing and loading functions accept optional
    arguments to customize the behavior. The `dump` and `dumps` methods accept a poorly
    named `cls` (short for class, which is a reserved keyword) keyword argument. If
    passed, this should be a subclass of the `JSONEncoder` class, with the `default`
    method overridden. This method accepts an arbitrary object and converts it to
    a dictionary that `json` can digest. If it doesn't know how to process the object,
    we should call the `super()` method, so that it can take care of serializing basic
    types in the normal way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`json`模块中，存储和加载函数都接受可选参数来自定义行为。`dump`和`dumps`方法接受一个名为`cls`（缩写为类，这是一个保留关键字）的关键字参数。如果传递了这个参数，它应该是`JSONEncoder`类的子类，并且应该重写`default`方法。此方法接受任意对象并将其转换为`json`可以解析的字典。如果它不知道如何处理对象，我们应该调用`super()`方法，以便它可以以正常方式处理序列化基本类型。
- en: The `load` and `loads` methods also accept such a `cls` argument that can be
    a subclass of the inverse class, `JSONDecoder`. However, it is normally sufficient
    to pass a function into these methods using the `object_hook` keyword argument.
    This function accepts a dictionary and returns an object; if it doesn't know what
    to do with the input dictionary, it can return it unmodified.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`和`loads`方法也接受`cls`参数，该参数可以是`JSONDecoder`的子类。但是，通常只需使用`object_hook`关键字参数将函数传递给这些方法。此函数接受一个字典并返回一个对象；如果它不知道如何处理输入字典，它可以原样返回。'
- en: 'Let''s look at an example. Imagine we have the following simple contact class
    that we want to serialize:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们有以下简单的联系人类，我们想要序列化：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We could just serialize the `__dict__` attribute:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只序列化`__dict__`属性：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But accessing special (double-underscore) attributes in this fashion is kind
    of crude. Also, what if the receiving code (perhaps some JavaScript on a web page)
    wanted that `full_name` property to be supplied? Of course, we could construct
    the dictionary by hand, but let''s create a custom encoder instead:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，以这种方式访问特殊（双下划线）属性有点粗糙。另外，如果接收代码（也许是网页上的一些JavaScript）希望提供`full_name`属性呢？当然，我们可以手工构建字典，但让我们创建一个自定义编码器：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `default` method basically checks to see what kind of object we're trying
    to serialize; if it's a contact, we convert it to a dictionary manually; otherwise,
    we let the parent class handle serialization (by assuming that it is a basic type,
    which `json` knows how to handle). Notice that we pass an extra attribute to identify
    this object as a contact, since there would be no way to tell upon loading it.
    This is just a convention; for a more generic serialization mechanism, it might
    make more sense to store a string type in the dictionary, or possibly even the
    full class name, including package and module. Remember that the format of the
    dictionary depends on the code at the receiving end; there has to be an agreement
    as to how the data is going to be specified.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`方法基本上是检查我们试图序列化的对象是什么类型；如果是联系人，我们手动将其转换为字典；否则，我们让父类处理序列化（假设它是一个基本类型，`json`知道如何处理）。请注意，我们传递了一个额外的属性来标识这个对象是一个联系人，因为在加载时没有办法知道。这只是一个约定；对于更通用的序列化机制，可能更合理的是在字典中存储一个字符串类型，或者甚至包括包和模块在内的完整类名。请记住，字典的格式取决于接收端的代码；必须就数据的规范方式达成一致。'
- en: 'We can use this class to encode a contact by passing the class (not an instantiated
    object) to the `dump` or `dumps` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个类来通过将类（而不是实例化对象）传递给`dump`或`dumps`函数来编码一个联系人：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For decoding, we can write a function that accepts a dictionary and checks
    the existence of the `is_contact` variable to decide whether to convert it to
    a contact:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解码，我们可以编写一个接受字典并检查`is_contact`变量存在性的函数，以决定是否将其转换为联系人：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can pass this function to the `load` or `loads` function using the `object_hook`
    keyword argument:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`object_hook`关键字参数将这个函数传递给`load`或`loads`函数：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Case study
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Let's build a basic regular expression-powered templating engine in Python.
    This engine will parse a text file (such as an HTML page) and replace certain
    directives with text calculated from the input to those directives. This is about
    the most complicated task we would want to do with regular expressions; indeed,
    a full-fledged version of this would likely utilize a proper language parsing
    mechanism.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中构建一个基本的基于正则表达式的模板引擎。这个引擎将解析一个文本文件（比如一个HTML页面），并用从这些指令输入的文本替换某些指令。这是我们希望用正则表达式做的最复杂的任务；事实上，一个完整的版本可能会利用适当的语言解析机制。
- en: 'Consider the following input file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下输入文件：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This file contains "tags" of the form `/** <directive> <data> **/` where the
    data is an optional single word and the directives are:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含形式为`/** <directive> <data> **/`的“标签”，其中数据是可选的单词，指令是：
- en: '`include`: Copy the contents of another file here'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：在这里复制另一个文件的内容'
- en: '`variable`: Insert the contents of a variable here'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable`：在这里插入变量的内容'
- en: '`loopover`: Repeat the contents of the loop for a variable that is a list'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loopover`：重复循环的内容，对应一个列表变量'
- en: '`endloop`: Signal the end of looped text'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endloop`：标志循环文本的结束'
- en: '`loopvar`: Insert a single value from the list being looped over'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loopvar`：插入循环变量中的单个值'
- en: 'This template will render a different page depending which variables are passed
    into it. These variables will be passed in from a so-called context file. This
    will be encoded as a `json` object with keys representing the variables in question.
    My context file might look like this, but you would derive your own:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将根据传递给它的变量呈现不同的页面。这些变量将从所谓的上下文文件中传递进来。这将被编码为一个表示相关变量的键的`json`对象。我的上下文文件可能看起来像这样，但你可以自己推导出你自己的：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Before we get into the actual string processing, let''s throw together some
    object-oriented boilerplate code for processing files and grabbing data from the
    command line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入实际的字符串处理之前，让我们为处理文件和从命令行获取数据编写一些面向对象的样板代码：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is all pretty basic, we create a class and initialize it with some variables
    passed in on the command line.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这都是相当基础的，我们创建一个类，并用从命令行传入的一些变量对其进行初始化。
- en: Notice how we try to make the regular expression a little bit more readable
    by breaking it across two lines? We use raw strings (the r prefix), so we don't
    have to double escape all our backslashes. This is common in regular expressions,
    but it's still a mess. (Regular expressions always are, but they're often worth
    it.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何通过跨两行来使正则表达式变得更可读？我们使用原始字符串（r前缀），这样我们就不必对所有反斜杠进行双重转义。这在正则表达式中很常见，但仍然很混乱。（正则表达式总是如此，但通常是值得的。）
- en: The `pos` indicates the current character in the content that we are processing;
    we'll see a lot more of it in a moment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`pos`表示我们正在处理的内容中的当前字符；我们马上会看到更多。'
- en: Now "all that's left" is to implement that process method. There are a few ways
    to do this. Let's do it in a fairly explicit way.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“剩下的就是”实现那个process方法。有几种方法可以做到这一点。让我们以一种相当明确的方式来做。
- en: The process method has to find each directive that matches the regular expression
    and do the appropriate work with it. However, it also has to take care of outputting
    the normal text before, after, and between each directive to the output file,
    unmodified.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: process方法必须找到与正则表达式匹配的每个指令，并对其进行适当的处理。但是，它还必须负责将每个指令之前、之后和之间的普通文本输出到输出文件中，不经修改。
- en: 'One good feature of the compiled version of regular expressions is that we
    can tell the `search` method to start searching at a specific position by passing
    the `pos` keyword argument. If we temporarily define doing the appropriate work
    with a directive as "ignore the directive and delete it from the output file",
    our process loop looks quite simple:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的编译版本的一个很好的特性是，我们可以通过传递`pos`关键字参数告诉`search`方法从特定位置开始搜索。如果我们临时定义对指令进行适当处理为“忽略指令并从输出文件中删除它”，我们的处理循环看起来非常简单：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In English, this function finds the first string in the text that matches the
    regular expression, outputs everything from the current position to the start
    of that match, and then advances the position to the end of aforesaid match. Once
    it's out of matches, it outputs everything since the last position.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在英语中找到文本中与正则表达式匹配的第一个字符串，输出从当前位置到该匹配的开始的所有内容，然后将位置前进到上述匹配的结束。一旦匹配完毕，它就会输出自上次位置以来的所有内容。
- en: 'Of course, ignoring the directive is pretty useless in a templating engine,
    so let''s set up replace that position advancing line with code that delegates
    to a different method on the class depending on the directive:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在模板引擎中忽略指令是相当无用的，所以让我们设置用不同的方法委托到类上的不同方法的代码来替换那个位置前进的行：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So we grab the directive and the single argument from the regular expression.
    The directive becomes a method name and we dynamically look up that method name
    on the `self` object (a little error processing here in case the template writer
    provides an invalid directive would be better). We pass the match object and argument
    into that method and assume that method will deal with everything appropriately,
    including moving the `pos` pointer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们从正则表达式中获取指令和单个参数。指令变成一个方法名，我们动态地在`self`对象上查找该方法名（在模板编写者提供无效指令的情况下，这里可能需要一些错误处理更好）。我们将匹配对象和参数传递给该方法，并假设该方法将适当地处理一切，包括移动`pos`指针。
- en: 'Now that we''ve got our object-oriented architecture this far, it''s actually
    pretty simple to implement the methods that are delegated to. The `include` and
    `variable` directives are totally straightforward:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的面向对象的架构已经到了这一步，实际上实现委托的方法是非常简单的。`include`和`variable`指令是完全直接的。
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first simply looks up the included file and inserts the file contents, while
    the second looks up the variable name in the context dictionary (which was loaded
    from `json` in the `__init__` method), defaulting to an empty string if it doesn't
    exist.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法简单地查找包含的文件并插入文件内容，而第二个方法在上下文字典中查找变量名称（这些变量是在`__init__`方法中从`json`中加载的），如果不存在则默认为空字符串。
- en: The three methods that deal with looping are a bit more intense, as they have
    to share state between the three of them. For simplicity (I'm sure you're eager
    to see the end of this long chapter, we're almost there!), we'll handle this as
    instance variables on the class itself. As an exercise, you might want to consider
    better ways to architect this, especially after reading the next three chapters.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 处理循环的三种方法要复杂一些，因为它们必须在它们之间共享状态。为了简单起见（我相信你迫不及待地想看到这一漫长章节的结束，我们快到了！），我们将把这些方法作为类本身的实例变量来处理。作为练习，你可能会考虑更好的架构方式，特别是在阅读完接下来的三章之后。
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When we encounter the `loopover` directive, we don't have to output anything,
    but we do have to set the initial state on three variables. The `loop_list` variable
    is assumed to be a list pulled from the context dictionary. The `loop_index` variable
    indicates what position in that list should be output in this iteration of the
    loop, while `loop_pos` is stored so we know where to jump back to when we get
    to the end of the loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到`loopover`指令时，我们不必输出任何内容，但我们必须在三个变量上设置初始状态。假定`loop_list`变量是从上下文字典中提取的列表。`loop_index`变量指示在循环的这一次迭代中应该输出列表中的哪个位置，而`loop_pos`被存储，这样当我们到达循环的结尾时就知道要跳回到哪里。
- en: The `loopvar` directive outputs the value at the current position in the `loop_list`
    variable and skips to the end of the directive. Note that it doesn't increment
    the loop index because the `loopvar` directive could be called multiple times
    inside a loop.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`loopvar`指令输出`loop_list`变量中当前位置的值，并跳到指令的结尾。请注意，它不会增加循环索引，因为`loopvar`指令可以在循环内多次调用。'
- en: The `endloop` directive is more complicated. It determines whether there are
    more elements in the `loop_list`; if there are, it just jumps back to the start
    of the loop, incrementing the index. Otherwise, it resets all the variables that
    were being used to process the loop and jumps to the end of the directive so the
    engine can carry on with the next match.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`endloop`指令更复杂。它确定`loop_list`中是否还有更多的元素；如果有，它就跳回到循环的开始，增加索引。否则，它重置了用于处理循环的所有变量，并跳到指令的结尾，这样引擎就可以继续处理下一个匹配。'
- en: 'Note that this particular looping mechanism is very fragile; if a template
    designer were to try nesting loops or forget an `endloop` call, it would go poorly
    for them. We would need a lot more error checking and probably want to store more
    loop state to make this a production platform. But I promised that the end of
    the chapter was nigh, so let''s just head to the exercises, after seeing how our
    sample template is rendered with its context:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种特定的循环机制非常脆弱；如果模板设计者尝试嵌套循环或忘记调用`endloop`，那对他们来说会很糟糕。我们需要进行更多的错误检查，可能还要存储更多的循环状态，以使其成为一个生产平台。但我承诺这一章快要结束了，所以让我们在查看我们的示例模板如何与其上下文一起呈现后，直接转到练习：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There are some weird newline effects due to the way we planned our template,
    but it works as expected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们规划模板的方式，会产生一些奇怪的换行效果，但它的工作效果如预期。
- en: Exercises
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've covered a wide variety of topics in this chapter, from strings to regular
    expressions, to object serialization, and back again. Now it's time to consider
    how these ideas can be applied to your own code.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了各种主题，从字符串到正则表达式，再到对象序列化，然后再回来。现在是时候考虑这些想法如何应用到你自己的代码中了。
- en: Python strings are very flexible, and Python is an extremely powerful tool for
    string-based manipulations. If you don't do a lot of string processing in your
    daily work, try designing a tool that is exclusively intended for manipulating
    strings. Try to come up with something innovative, but if you're stuck, consider
    writing a web log analyzer (how many requests per hour? How many people visit
    more than five pages?) or a template tool that replaces certain variable names
    with the contents of other files.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串非常灵活，而Python是一个非常强大的基于字符串的操作工具。如果您在日常工作中没有进行大量的字符串处理，请尝试设计一个专门用于操作字符串的工具。尝试想出一些创新的东西，但如果遇到困难，可以考虑编写一个网络日志分析器（每小时有多少请求？有多少人访问了五个以上的页面？）或一个模板工具，用其他文件的内容替换某些变量名。
- en: Spend a lot of time toying with the string formatting operators until you've
    got the syntax memorized. Write a bunch of template strings and objects to pass
    into the format function, and see what kind of output you get. Try the exotic
    formatting operators, such as percentage or hexadecimal notation. Try out the
    fill and alignment operators, and see how they behave differently for integers,
    strings, and floats. Consider writing a class of your own that has a `__format__`
    method; we didn't discuss this in detail, but explore just how much you can customize
    formatting.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 花费大量时间玩弄字符串格式化运算符，直到您记住了语法。编写一堆模板字符串和对象传递给格式化函数，并查看您得到了什么样的输出。尝试一些奇特的格式化运算符，比如百分比或十六进制表示法。尝试填充和对齐运算符，并查看它们在整数、字符串和浮点数上的不同行为。考虑编写一个自己的类，其中有一个`__format__`方法；我们没有详细讨论这一点，但探索一下您可以自定义格式化的程度。
- en: Make sure you understand the difference between `bytes` and `str` objects. The
    distinction is very complicated in older versions of Python (there was no `bytes`,
    and `str` acted like both `bytes` and `str` unless we needed non-ASCII characters
    in which case there was a separate `unicode` object, which was similar to Python
    3's `str` class. It's even more confusing than it sounds!). It's clearer nowadays;
    `bytes` is for binary data, and `str` is for character data. The only tricky part
    is knowing how and when to convert between the two. For practice, try writing
    text data to a file opened for writing `bytes` (you'll have to encode the text
    yourself), and then reading from the same file.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您理解`bytes`和`str`对象之间的区别。在旧版本的Python中，这个区别非常复杂（没有`bytes`，`str`同时充当`bytes`和`str`，除非我们需要非ASCII字符，此时有一个单独的`unicode`对象，类似于Python
    3的`str`类。这甚至比听起来的更令人困惑！）。现在更清晰了；`bytes`用于二进制数据，`str`用于字符数据。唯一棘手的部分是知道如何以及何时在两者之间转换。练习时，尝试将文本数据写入以`bytes`方式打开的文件（您将不得不自己对文本进行编码），然后从同一文件中读取。
- en: Do some experimenting with `bytearray`; see how it can act both like a bytes
    object and a list or container object at the same time. Try writing to a buffer
    that holds data in the bytes array until it is a certain length before returning
    it. You can simulate the code that puts data into the buffer by using `time.sleep`
    calls to ensure data doesn't arrive too quickly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`bytearray`进行一些实验；看看它如何同时像一个字节对象和一个列表或容器对象。尝试向一个缓冲区写入数据，直到达到一定长度之前将其返回。您可以通过使用`time.sleep`调用来模拟将数据放入缓冲区的代码，以确保数据不会到达得太快。
- en: Study regular expressions online. Study them some more. Especially learn about
    named groups greedy versus lazy matching, and regex flags, three features that
    we didn't cover in this chapter. Make conscious decisions about when not to use
    them. Many people have very strong opinions about regular expressions and either
    overuse them or refuse to use them at all. Try to convince yourself to use them
    only when appropriate, and figure out when that is.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上学习正则表达式。再多学习一些。特别是要了解有名分组、贪婪匹配与懒惰匹配以及正则表达式标志，这些是我们在本章中没有涵盖的三个特性。要有意识地决定何时不使用它们。许多人对正则表达式有非常强烈的意见，要么过度使用它们，要么根本不使用它们。试着说服自己只在适当的时候使用它们，并找出何时是适当的时候。
- en: 'If you''ve ever written an adapter to load small amounts of data from a file
    or database and convert it to an object, consider using a pickle instead. Pickles
    are not efficient for storing massive amounts of data, but they can be useful
    for loading configuration or other simple objects. Try coding it multiple ways:
    using a pickle, a text file, or a small database. Which do you find easiest to
    work with?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经编写过一个适配器，用于从文件或数据库中加载少量数据并将其转换为对象，请考虑改用pickle。Pickles不适合存储大量数据，但对于加载配置或其他简单对象可能会有用。尝试多种编码方式：使用pickle、文本文件或小型数据库。哪种方式对您来说最容易使用？
- en: 'Try experimenting with pickling data, then modifying the class that holds the
    data, and loading the pickle into the new class. What works? What doesn''t? Is
    there a way to make drastic changes to a class, such as renaming an attribute
    or splitting it into two new attributes and still get the data out of an older
    pickle? (Hint: try placing a private pickle version number on each object and
    update it each time you change the class; you can then put a migration path in
    `__setstate__`.)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对数据进行pickling实验，然后修改保存数据的类，并将pickle加载到新类中。什么有效？什么无效？有没有办法对一个类进行重大更改，比如重命名属性或将其拆分为两个新属性，但仍然可以从旧的pickle中获取数据？（提示：尝试在每个对象上放置一个私有的pickle版本号，并在更改类时更新它；然后可以在`__setstate__`中放置一个迁移路径。）
- en: If you do any web development at all, do some experimenting with the JSON serializer.
    Personally, I prefer to serialize only standard JSON serializable objects, rather
    than writing custom encoders or `object_hooks`, but the desired effect really
    depends on the interaction between the frontend (JavaScript, typically) and backend
    code.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从事任何网络开发工作，请尝试使用JSON序列化器进行一些实验。就个人而言，我更喜欢只序列化标准的JSON可序列化对象，而不是编写自定义编码器或`object_hooks`，但期望的效果实际上取决于前端（通常是JavaScript）和后端代码之间的交互。
- en: Create some new directives in the templating engine that take more than one
    or an arbitrary number of arguments. You might need to modify the regular expression
    or add new ones. Have a look at the Django project's online documentation, and
    see if there are any other template tags you'd like to work with. Try mimicking
    their filter syntax instead of using the variable tag. Revisit this chapter when
    you've studied iteration and coroutines and see if you can come up with a more
    compact way of representing the state between related directives, such as the
    loop.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板引擎中创建一些新的指令，这些指令需要多个或任意数量的参数。您可能需要修改正则表达式或添加新的正则表达式。查看Django项目的在线文档，看看是否有任何其他模板标签您想要使用。尝试模仿它们的过滤器语法，而不是使用变量标签。当您学习了迭代和协程时，重新阅读本章，看看是否能找到一种更
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered string manipulation, regular expressions, and object serialization
    in this chapter. Hardcoded strings and program variables can be combined into
    outputtable strings using the powerful string formatting system. It is important
    to distinguish between binary and textual data and `bytes` and `str` have specific
    purposes that must be understood. Both are immutable, but the `bytearray` type
    can be used when manipulating bytes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了字符串操作、正则表达式和对象序列化。硬编码的字符串和程序变量可以使用强大的字符串格式化系统组合成可输出的字符串。区分二进制和文本数据很重要，`bytes`和`str`有特定的用途必须要理解。它们都是不可变的，但在操作字节时可以使用`bytearray`类型。
- en: Regular expressions are a complex topic, but we scratched the surface. There
    are many ways to serialize Python data; pickles and JSON are two of the most popular.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个复杂的主题，但我们只是触及了表面。有许多种方法可以序列化Python数据；pickle和JSON是最流行的两种方法之一。
- en: 'In the next chapter, we''ll look at a design pattern that is so fundamental
    to Python programming that it has been given special syntax support: the iterator
    pattern.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一种设计模式，这种模式对于Python编程非常基础，以至于它已经被赋予了特殊的语法支持：迭代器模式。
