- en: Chapter 19. Security in Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章 Django中的安全性
- en: Ensuring that the sites you build are secure is of the utmost importance to
    a professional web applications developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您构建的网站是安全的对于专业的Web应用程序开发人员至关重要。
- en: The Django framework is now very mature and the majority of common security
    issues are addressed in some way by the framework itself, however no security
    measure is 100% guaranteed and there are new threats emerging all the time, so
    it's up to you as a web developer to ensure that your websites and applications
    are secure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架现在非常成熟，大多数常见的安全问题都以某种方式得到了解决，但是没有安全措施是100%保证的，而且新的威胁不断出现，因此作为Web开发人员，您需要确保您的网站和应用程序是安全的。
- en: web security is too large a subject to cover in depth in a single book chapter.
    This chapter includes an overview of Django's security features and advice on
    securing a Django-powered site that will protect your sites 99% of the time, but
    it's up to you to keep abreast of changes in web security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Web安全是一个庞大的主题，无法在一本书的章节中深入讨论。本章概述了Django的安全功能，并提供了有关保护Django网站的建议，这将在99%的时间内保护您的网站，但您需要随时了解Web安全的变化。
- en: For more detailed information on web security, Django's archive of security
    issues(for more information visit [https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/))
    is a good place to start, along with Wikipedia's web application security page
    ([https://en.wikipedia.org/wiki/web_application_security](https://en.wikipedia.org/wiki/web_application_security)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Web安全的更详细信息，请参阅Django的安全问题存档（有关更多信息，请访问[https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/)），以及维基百科的Web应用程序安全页面（[https://en.wikipedia.org/wiki/web_application_security](https://en.wikipedia.org/wiki/web_application_security)）。
- en: Django's built in security features
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django内置的安全功能
- en: Cross Site Scripting (XSS) protection
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站点脚本攻击（XSS）保护
- en: '**Cross Site Scripting** (**XSS**) attacks allow a user to inject client side
    scripts into the browsers of other users.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站点脚本**（**XSS**）攻击允许用户向其他用户的浏览器注入客户端脚本。'
- en: This is usually achieved by storing the malicious scripts in the database where
    it will be retrieved and displayed to other users, or by getting users to click
    a link which will cause the attacker's JavaScript to be executed by the user's
    browser. However, XSS attacks can originate from any untrusted source of data,
    such as cookies or web services, whenever the data is not sufficiently sanitized
    before including in a page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过将恶意脚本存储在数据库中，然后检索并显示给其他用户，或者让用户点击一个链接，从而导致攻击者的JavaScript在用户的浏览器中执行。但是，XSS攻击可能源自任何不受信任的数据源，例如cookie或Web服务，只要在包含在页面中之前未经充分净化。
- en: Using Django templates protects you against the majority of XSS attacks. However,
    it is important to understand what protections it provides and its limitations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django模板可以保护您免受大多数XSS攻击。但是，重要的是要了解它提供的保护措施及其局限性。
- en: 'Django templates escape specific characters which are particularly dangerous
    to HTML. While this protects users from most malicious input, it is not entirely
    foolproof. For example, it will not protect the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板会转义对HTML特别危险的特定字符。虽然这可以保护用户免受大多数恶意输入，但并非绝对安全。例如，它无法保护以下内容：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If `var` is set to `'class1 onmouseover=javascript:func()'`, this can result
    in unauthorized JavaScript execution, depending on how the browser renders imperfect
    HTML. (Quoting the attribute value would fix this case).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`var`设置为`'class1 onmouseover=javascript:func()'`，这可能导致未经授权的JavaScript执行，具体取决于浏览器如何呈现不完美的HTML。（引用属性值将修复此情况）。
- en: It is also important to be particularly careful when using `is_safe` with custom
    template tags, the `safe` template tag, `mark_safe`, and when `autoescape` is
    turned off.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自定义模板标记时，使用`is_safe`、`safe`模板标记、`mark_safe`以及关闭`autoescape`时要特别小心。
- en: In addition, if you are using the template system to output something other
    than HTML, there may be entirely separate characters and words which require escaping.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您使用模板系统输出除HTML之外的内容，可能需要转义完全不同的字符和单词。
- en: You should also be very careful when storing HTML in the database, especially
    when that HTML is retrieved and displayed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储HTML在数据库时，特别需要非常小心，特别是当检索和显示该HTML时。
- en: Cross Site Request Forgery (CSRF) protection
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站点请求伪造（CSRF）保护
- en: '**Cross Site Request Forgery** (**CSRF**) attacks allow a malicious user to
    execute actions using the credentials of another user without that user''s knowledge
    or consent.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站点请求伪造**（**CSRF**）攻击允许恶意用户在不知情或未经同意的情况下使用另一个用户的凭据执行操作。'
- en: Django has built-in protection against most types of CSRF attacks, providing
    you have enabled and used it where appropriate. However, as with any mitigation
    technique, there are limitations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Django内置了对大多数CSRF攻击的保护，只要您已启用并在适当的地方使用它。但是，与任何缓解技术一样，存在局限性。
- en: For example, it is possible to disable the CSRF module globally or for particular
    views. You should only do this if you know what you are doing. There are other
    limitations if your site has subdomains that are outside of your control.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以全局禁用CSRF模块或特定视图。只有在知道自己在做什么时才应该这样做。如果您的网站具有超出您控制范围的子域，还存在其他限制。
- en: CSRF protection works by checking for a nonce in each `POST` request. This ensures
    that a malicious user cannot simply replay a form `POST` to your website and have
    another logged in user unwittingly submit that form. The malicious user would
    have to know the nonce, which is user specific (using a cookie).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF保护通过检查每个`POST`请求中的一次性令牌来实现。这确保了恶意用户无法简单地重放表单`POST`到您的网站，并使另一个已登录的用户无意中提交该表单。恶意用户必须知道一次性令牌，这是用户特定的（使用cookie）。
- en: When deployed with HTTPS, `CsrfViewMiddleware` will check that the HTTP referrer
    header is set to a URL on the same origin (including subdomain and port). Because
    HTTPS provides additional security, it is imperative to ensure connections use
    HTTPS where it is available by forwarding insecure connection requests and using
    HSTS for supported browsers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用HTTPS部署时，`CsrfViewMiddleware`将检查HTTP引用头是否设置为同一来源的URL（包括子域和端口）。因为HTTPS提供了额外的安全性，所以必须确保连接在可用时使用HTTPS，通过转发不安全的连接请求并为受支持的浏览器使用HSTS。
- en: Be very careful with marking views with the `csrf_exempt` decorator unless it
    is absolutely necessary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 非常小心地标记视图为`csrf_exempt`装饰器，除非绝对必要。
- en: Django's CSRF middleware and template tag provides easy-to-use protection against
    Cross Site Request Forgeries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Django的CSRF中间件和模板标签提供了易于使用的跨站请求伪造保护。
- en: The first defense against CSRF attacks is to ensure that `GET` requests (and
    other 'safe' methods, as defined by 9.1.1 Safe Methods, HTTP 1.1, RFC 2616 (for
    more information visit [https://tools.ietf.org/html/rfc2616.html#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)))
    are side-effect free. Requests via 'unsafe' methods, such as `POST`, `PUT` and
    `DELETE`, can then be protected by following the steps below.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗CSRF攻击的第一道防线是确保`GET`请求（以及其他“安全”方法，如9.1.1安全方法，HTTP 1.1，RFC 2616中定义的方法（有关更多信息，请访问[https://tools.ietf.org/html/rfc2616.html#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)）是无副作用的。然后，通过以下步骤保护通过“不安全”方法（如`POST`，`PUT`和`DELETE`）的请求。
- en: How to use it
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用它
- en: 'To take advantage of CSRF protection in your views, follow these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中利用CSRF保护，请按照以下步骤进行操作：
- en: The CSRF middleware is activated by default in the `MIDDLEWARE_CLASSES` setting.
    If you override that setting, remember that `'django.middleware.csrf.CsrfViewMiddleware'`
    should come before any view middleware that assume that CSRF attacks have been
    dealt with.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSRF中间件在`MIDDLEWARE_CLASSES`设置中默认激活。如果您覆盖该设置，请记住`'django.middleware.csrf.CsrfViewMiddleware'`应该在任何假设已处理CSRF攻击的视图中间件之前。
- en: If you disabled it, which is not recommended, you can use `csrf_protect()` on
    particular views you want to protect (see below).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您禁用了它，这是不推荐的，您可以在要保护的特定视图上使用`csrf_protect()`（见下文）。
- en: 'In any template that uses a `POST` form, use the `csrf_token` tag inside the
    `<form>` element if the form is for an internal URL, for example:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何使用`POST`表单的模板中，如果表单用于内部URL，请在`<form>`元素内使用`csrf_token`标签，例如：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should not be done for `POST` forms that target external URLs, since that
    would cause the CSRF token to be leaked, leading to a vulnerability.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不应该对目标外部URL的`POST`表单执行此操作，因为这会导致CSRF令牌泄漏，从而导致漏洞。
- en: 'In the corresponding view functions, ensure that the `''django.template.context_processors.csrf''`
    context processor is being used. Usually, this can be done in one of two ways:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的视图函数中，确保使用了`'django.template.context_processors.csrf'`上下文处理器。通常，可以通过以下两种方式之一完成：
- en: Use `RequestContext`, which always uses `'django.template.context_processors.csrf'`
    (no matter what template context processors are configured in the `TEMPLATES`
    setting). If you are using generic views or contrib apps, you are covered already,
    since these apps use `RequestContext` throughout.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RequestContext`，它始终使用`'django.template.context_processors.csrf'`（无论在`TEMPLATES`设置中配置了哪些模板上下文处理器）。如果您使用通用视图或贡献应用程序，则已经涵盖了，因为这些应用程序始终在整个`RequestContext`中使用。
- en: 'Manually import and use the processor to generate the CSRF token and add it
    to the template context. for example:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动导入并使用处理器生成CSRF令牌，并将其添加到模板上下文中。例如：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may want to write your own `render_to_response()` wrapper that takes care
    of this step for you.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能希望编写自己的`render_to_response()`包装器，以便为您处理此步骤。
- en: AJAX
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AJAX
- en: 'While the above method can be used for AJAX POST requests, it has some inconveniences:
    you have to remember to pass the CSRF token in as POST data with every POST request.
    For this reason, there is an alternative method: on each `XMLHttpRequest`, set
    a custom `X-CSRFToken` header to the value of the CSRF token. This is often easier,
    because many JavaScript frameworks provide hooks that allow headers to be set
    on every request.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述方法可以用于AJAX POST请求，但它有一些不便之处：您必须记住在每个POST请求中将CSRF令牌作为POST数据传递。因此，有一种替代方法：在每个`XMLHttpRequest`上，将自定义的`X-CSRFToken`标头设置为CSRF令牌的值。这通常更容易，因为许多JavaScript框架提供了允许在每个请求上设置标头的钩子。
- en: As a first step, you must get the CSRF token itself. The recommended source
    for the token is the `csrftoken` cookie, which will be set if you've enabled CSRF
    protection for your views as outlined above.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须获取CSRF令牌本身。令牌的推荐来源是`csrftoken` cookie，如果您已经按上述方式为视图启用了CSRF保护，它将被设置。
- en: The CSRF token cookie is named `csrftoken` by default, but you can control the
    cookie name via the `CSRF_COOKIE_NAME` setting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF令牌cookie默认名为`csrftoken`，但您可以通过`CSRF_COOKIE_NAME`设置控制cookie名称。
- en: 'Acquiring the token is straightforward:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取令牌很简单：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The above code could be simplified by using the jQuery cookie plugin ([http://plugins.jquery.com/cookie/](http://plugins.jquery.com/cookie/))
    to replace `getCookie`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用jQuery cookie插件（[http://plugins.jquery.com/cookie/](http://plugins.jquery.com/cookie/)）来替换`getCookie`，可以简化上述代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The CSRF token is also present in the DOM, but only if explicitly included using
    `csrf_token` in a template. The cookie contains the canonical token; the `CsrfViewMiddleware`
    will prefer the cookie to the token in the DOM. Regardless, you're guaranteed
    to have the cookie if the token is present in the DOM, so you should use the cookie!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF令牌也存在于DOM中，但仅当在模板中明确包含`csrf_token`时才会存在。cookie包含规范令牌；`CsrfViewMiddleware`将优先使用cookie而不是DOM中的令牌。无论如何，如果DOM中存在令牌，则保证会有cookie，因此应该使用cookie！
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If your view is not rendering a template containing the `csrf_token` template
    tag, Django might not set the CSRF token cookie. This is common in cases where
    forms are dynamically added to the page. To address this case, Django provides
    a view decorator which forces setting of the cookie: `ensure_csrf_cookie()`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的视图没有呈现包含`csrf_token`模板标签的模板，则Django可能不会设置CSRF令牌cookie。这在动态添加表单到页面的情况下很常见。为了解决这种情况，Django提供了一个视图装饰器，强制设置cookie：`ensure_csrf_cookie()`。
- en: 'Finally, you''ll have to actually set the header on your AJAX request, while
    protecting the CSRF token from being sent to other domains using `settings.crossDomain`
    in jQuery 1.5.1 and newer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将需要在AJAX请求中实际设置标头，同时使用jQuery 1.5.1及更高版本中的`settings.crossDomain`保护CSRF令牌，以防止发送到其他域：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Other template engines
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他模板引擎
- en: When using a different template engine than Django's built-in engine, you can
    set the token in your forms manually after making sure it's available in the template
    context.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用与Django内置引擎不同的模板引擎时，您可以在确保它在模板上下文中可用后，在表单中手动设置令牌。
- en: 'For example, in the Jinja2 template language, your form could contain the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Jinja2模板语言中，您的表单可以包含以下内容：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use JavaScript similar to the AJAX code above to get the value of the
    CSRF token.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似于上面的AJAX代码的JavaScript来获取CSRF令牌的值。
- en: The decorator method
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器方法
- en: Rather than adding `CsrfViewMiddleware` as a blanket protection, you can use
    the `csrf_protect` decorator, which has exactly the same functionality, on particular
    views that need the protection. It must be used both on views that insert the
    CSRF token in the output, and on those that accept the `POST` form data. (These
    are often the same view function, but not always).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`csrf_protect`装饰器，而不是将`CsrfViewMiddleware`作为一种全面的保护措施，该装饰器具有完全相同的功能，用于需要保护的特定视图。它必须同时用于在输出中插入CSRF令牌的视图和接受`POST`表单数据的视图。（这些通常是相同的视图函数，但并非总是如此）。
- en: Use of the decorator by itself is not recommended, since if you forget to use
    it, you will have a security hole. The *belt and braces* strategy of using both
    is fine, and will incur minimal overhead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议单独使用装饰器，因为如果您忘记使用它，将会有安全漏洞。同时使用两者的“双重保险”策略是可以的，并且会产生最小的开销。
- en: '`django.views.decorators.csrf.csrf_protect(view)`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.views.decorators.csrf.csrf_protect(view)`'
- en: Decorator that provides the protection of `CsrfViewMiddleware` to a view.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对视图的`CsrfViewMiddleware`保护的装饰器。
- en: 'Usage:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you are using class-based views, you can refer to Decorating class-based
    views.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于类的视图，可以参考装饰基于类的视图。
- en: Rejected requests
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被拒绝的请求
- en: By default, a *403 Forbidden* response is sent to the user if an incoming request
    fails the checks performed by `CsrfViewMiddleware`. This should usually only be
    seen when there is a genuine Cross Site Request Forgery, or when, due to a programming
    error, the CSRF token has not been included with a `POST` form.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果传入请求未通过`CsrfViewMiddleware`执行的检查，则向用户发送*403 Forbidden*响应。通常只有在存在真正的跨站请求伪造或由于编程错误，CSRF令牌未包含在`POST`表单中时才会看到这种情况。
- en: The error page, however, is not very friendly, so you may want to provide your
    own view for handling this condition. To do this, simply set the `CSRF_FAILURE_VIEW`
    setting.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，错误页面并不是很友好，因此您可能希望为处理此条件提供自己的视图。要做到这一点，只需设置`CSRF_FAILURE_VIEW`设置。
- en: How it works
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The CSRF protection is based on the following things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF保护基于以下几点：
- en: A CSRF cookie that is set to a random value (a session independent nonce, as
    it is called), which other sites will not have access to.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置为随机值的CSRF cookie（称为会话独立nonce），其他站点将无法访问。
- en: This cookie is set by `CsrfViewMiddleware`. It is meant to be permanent, but
    since there is no way to set a cookie that never expires, it is sent with every
    response that has called `django.middleware.csrf.get_token()` (the function used
    internally to retrieve the CSRF token).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个cookie是由`CsrfViewMiddleware`设置的。它是永久性的，但由于没有办法设置永不过期的cookie，因此它会随着每次调用`django.middleware.csrf.get_token()`（内部用于检索CSRF令牌的函数）的响应一起发送。
- en: A hidden form field with the name *csrfmiddlewaretoken* present in all outgoing
    POST forms. The value of this field is the value of the CSRF cookie.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有传出的POST表单中都有一个名为*csrfmiddlewaretoken*的隐藏表单字段。该字段的值是CSRF cookie的值。
- en: This part is done by the template tag.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这部分是由模板标签完成的。
- en: For all incoming requests that are not using HTTP `GET`, `HEAD`, `OPTIONS`,
    or `TRACE`, a CSRF cookie must be present, and the *csrfmiddlewaretoken* field
    must be present and correct. If it isn't, the user will get a 403 error.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有不使用HTTP `GET`，`HEAD`，`OPTIONS`或`TRACE`的传入请求，必须存在CSRF cookie，并且必须存在并正确的*csrfmiddlewaretoken*字段。如果没有，用户将收到403错误。
- en: This check is done by `CsrfViewMiddleware`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个检查是由`CsrfViewMiddleware`完成的。
- en: In addition, for HTTPS requests, strict referrer checking is done by `CsrfViewMiddleware`.
    This is necessary to address a Man-In-The-Middle attack that is possible under
    HTTPS when using a session independent nonce, due to the fact that HTTP 'Set-Cookie'
    headers are (unfortunately) accepted by clients that are talking to a site under
    HTTPS. (Referer checking is not done for HTTP requests because the presence of
    the Referer header is not reliable enough under HTTP.)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，对于HTTPS请求，`CsrfViewMiddleware`会进行严格的引用检查。这是必要的，以解决在HTTPS下使用会话独立nonce时可能发生的中间人攻击，因为（不幸的是）客户端接受了对HTTPS站点进行通信的“Set-Cookie”标头。
    （在HTTP请求下不进行引用检查，因为在HTTP下，引用标头的存在不够可靠。）
- en: This ensures that only forms that have originated from your website can be used
    to `POST` data back.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保只有来自您网站的表单才能用于将数据`POST`回来。
- en: It deliberately ignores `GET` requests (and other requests that are defined
    as 'safe' by RFC 2616). These requests ought never to have any potentially dangerous
    side effects, and so a CSRF attack with a `GET` request ought to be harmless.
    RFC 2616 defines `POST`, `PUT`, and `DELETE` as 'unsafe', and all other methods
    are assumed to be unsafe, for maximum protection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它故意忽略`GET`请求（以及RFC 2616定义为“安全”的其他请求）。这些请求不应该具有任何潜在的危险副作用，因此使用`GET`请求的CSRF攻击应该是无害的。RFC
    2616将`POST`、`PUT`和`DELETE`定义为“不安全”，并假定所有其他方法都是不安全的，以获得最大的保护。
- en: Caching
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: 'If the `csrf_token` template tag is used by a template (or the `get_token`
    function is called some other way), `CsrfViewMiddleware` will add a cookie and
    a `Vary: Cookie` header to the response. This means that the middleware will play
    well with the cache middleware if it is used as instructed (`UpdateCacheMiddleware`
    goes before all other middleware).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '如果模板使用`csrf_token`模板标签（或以其他方式调用`get_token`函数），`CsrfViewMiddleware`将向响应添加一个cookie和一个`Vary:
    Cookie`标头。这意味着如果按照指示使用缓存中间件（`UpdateCacheMiddleware`在所有其他中间件之前），中间件将与缓存中间件协同工作。'
- en: However, if you use cache decorators on individual views, the CSRF middleware
    will not yet have been able to set the `Vary` header or the CSRF cookie, and the
    response will be cached without either one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在单个视图上使用缓存装饰器，CSRF中间件还没有能够设置`Vary`标头或CSRF cookie，响应将被缓存而没有任何一个。
- en: 'In this case, on any views that will require a CSRF token to be inserted you
    should use the `django.views.decorators.csrf.csrf_protect()` decorator first:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于任何需要插入CSRF令牌的视图，您应该首先使用`django.views.decorators.csrf.csrf_protect()`装饰器：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are using class-based views, you can refer to decorating class-based
    views in the Django documentation ([https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views](https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于类的视图，可以参考Django文档中的装饰基于类的视图（[https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views](https://docs.djangoproject.com/en/1.8/topics/class-based-views/intro/#decorating-class-based-views)）。
- en: Testing
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: The `CsrfViewMiddleware` will usually be a big hindrance to testing view functions,
    due to the need for the CSRF token which must be sent with every `POST` request.
    For this reason, Django's HTTP client for tests has been modified to set a flag
    on requests which relaxes the middleware and the `csrf_protect` decorator so that
    they no longer rejects requests. In every other respect (for example, sending
    cookies and so on), they behave the same.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要在每个`POST`请求中发送CSRF令牌，`CsrfViewMiddleware`通常会对测试视图函数造成很大的阻碍。因此，Django的测试HTTP客户端已经修改，以在请求上设置一个标志，从而放宽中间件和`csrf_protect`装饰器，使其不再拒绝请求。在其他方面（例如发送cookie等），它们的行为是相同的。
- en: 'If, for some reason, you want the test client to perform CSRF checks, you can
    create an instance of the test client that enforces CSRF checks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您希望测试客户端执行CSRF检查，您可以创建一个强制执行CSRF检查的测试客户端实例：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Limitations
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: Subdomains within a site will be able to set cookies on the client for the whole
    domain. By setting the cookie and using a corresponding token, subdomains will
    be able to circumvent the CSRF protection. The only way to avoid this is to ensure
    that subdomains are controlled by trusted users (or, are at least unable to set
    cookies).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 站点内的子域将能够在整个域上为客户端设置cookie。通过设置cookie并使用相应的令牌，子域将能够规避CSRF保护。避免这种情况的唯一方法是确保子域由受信任的用户控制（或者至少无法设置cookie）。
- en: Note that even without CSRF, there are other vulnerabilities, such as session
    fixation, that make giving subdomains to untrusted parties a bad idea, and these
    vulnerabilities cannot easily be fixed with current browsers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使没有CSRF，也存在其他漏洞，例如会话固定，这使得将子域分配给不受信任的方可能不是一个好主意，而且这些漏洞在当前浏览器中不能轻易修复。
- en: Edge cases
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边缘情况
- en: Certain views can have unusual requirements that mean they don't fit the normal
    pattern envisaged here. A number of utilities can be useful in these situations.
    The scenarios they might be needed in are described in the following section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 某些视图可能具有不符合此处正常模式的特殊要求。在这些情况下，一些实用程序可能会有用。它们可能需要的场景在下一节中描述。
- en: Utilities
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用程序
- en: The examples below assume you are using function-based views. If you are working
    with class-based views, you can refer to decorating class-based views in the Django
    documentation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例假定您正在使用基于函数的视图。如果您正在使用基于类的视图，可以参考Django文档中的装饰基于类的视图。
- en: django.views.decorators.csrf.csrf_exempt(view)
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: django.views.decorators.csrf.csrf_exempt(view)
- en: Most views require CSRF protection, but a few do not. Rather than disabling
    the middleware and applying `csrf_protect` to all the views that need it, enable
    the middleware and use `csrf_exempt()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数视图需要CSRF保护，但有一些不需要。与其禁用中间件并将`csrf_protect`应用于所有需要它的视图，不如启用中间件并使用`csrf_exempt()`。
- en: 'This decorator marks a view as being exempt from the protection ensured by
    the middleware. Example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器标记一个视图被中间件保护豁免。示例：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: django.views.decorators.csrf.requires_csrf_token(view)
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: django.views.decorators.csrf.requires_csrf_token(view)
- en: There are cases when `CsrfViewMiddleware.process_view` may not have run before
    your view is run-404 and 500 handlers, for example-but you still need the CSRF
    token in a form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，`CsrfViewMiddleware.process_view`可能在您的视图运行之前没有运行-例如404和500处理程序-但您仍然需要表单中的CSRF令牌。
- en: Normally the `csrf_token` template tag will not work if `CsrfViewMiddleware.process_view`
    or an equivalent like `csrf_protect` has not run. The view decorator `requires_csrf_token`
    can be used to ensure the template tag does work. This decorator works similarly
    to `csrf_protect`, but never rejects an incoming request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果`CsrfViewMiddleware.process_view`或类似`csrf_protect`没有运行，`csrf_token`模板标签将无法工作。视图装饰器`requires_csrf_token`可用于确保模板标签正常工作。这个装饰器的工作方式类似于`csrf_protect`，但从不拒绝传入的请求。
- en: 'Example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There may also be some views that are unprotected and have been exempted by
    `csrf_exempt`, but still need to include the CSRF token. In these cases, use `csrf_exempt()`
    followed by `requires_csrf_token()`. (that is, `requires_csrf_token` should be
    the innermost decorator).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能有一些未受保护的视图已经被`csrf_exempt`豁免，但仍需要包含CSRF令牌。在这些情况下，使用`csrf_exempt()`后跟`requires_csrf_token()`。（即`requires_csrf_token`应该是最内层的装饰器）。
- en: A final example is where a view needs CSRF protection under one set of conditions
    only, and mustn't have it for the rest of the time. A solution is to use `csrf_exempt()`
    for the whole view function, and `csrf_protect()` for the path within it that
    needs protection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子是，当视图仅在一组条件下需要CSRF保护，并且在其余时间不得具有保护时。解决方案是对整个视图函数使用`csrf_exempt()`，并对其中需要保护的路径使用`csrf_protect()`。
- en: 'For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: django.views.decorators.csrf.ensure_csrf_cookie(view)
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: django.views.decorators.csrf.ensure_csrf_cookie(view)
- en: This decorator forces a view to send the CSRF cookie. A scenario where this
    would be used is if a page makes a POST request via AJAX, and the page does not
    have an HTML form with a `csrf_token` that would cause the required CSRF cookie
    to be sent. The solution would be to use `ensure_csrf_cookie()` on the view that
    sends the page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器强制视图发送CSRF cookie。如果页面通过AJAX进行POST请求，并且页面没有带有`csrf_token`的HTML表单，这将导致所需的CSRF
    cookie被发送。解决方案是在发送页面的视图上使用`ensure_csrf_cookie()`。
- en: Contrib and reusable apps
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贡献和可重用应用程序
- en: Because it is possible for the developer to turn off the `CsrfViewMiddleware`,
    all relevant views in contrib apps use the `csrf_protect` decorator to ensure
    the security of these applications against CSRF. It is recommended that the developers
    of other reusable apps that want the same guarantees also use the `csrf_protect`
    decorator on their views.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发人员可以关闭`CsrfViewMiddleware`，因此贡献应用程序中的所有相关视图都使用`csrf_protect`装饰器来确保这些应用程序对CSRF的安全性。建议其他希望获得相同保障的可重用应用程序的开发人员也在其视图上使用`csrf_protect`装饰器。
- en: CSRF settings
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSRF设置
- en: 'A number of settings can be used to control Django''s CSRF behavior:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用一些设置来控制Django的CSRF行为：
- en: '`CSRF_COOKIE_AGE`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_AGE`'
- en: '`CSRF_COOKIE_DOMAIN`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_DOMAIN`'
- en: '`CSRF_COOKIE_HTTPONLY`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_HTTPONLY`'
- en: '`CSRF_COOKIE_NAME`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_NAME`'
- en: '`CSRF_COOKIE_PATH`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_PATH`'
- en: '`CSRF_COOKIE_SECURE`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_COOKIE_SECURE`'
- en: '`CSRF_FAILURE_VIEW`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSRF_FAILURE_VIEW`'
- en: See [Appendix D](apd.xhtml "Appendix D. Settings"), *Settings*, for more information
    on each of these settings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些设置的更多信息，请参见[附录D](apd.xhtml "附录D.设置")，*设置*。
- en: SOL injection protection
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOL注入保护
- en: SQL injection is a type of attack where a malicious user is able to execute
    arbitrary SQL code on a database. This can result in records being deleted or
    data leakage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是一种攻击类型，恶意用户能够在数据库上执行任意的SQL代码。这可能导致记录被删除或数据泄露。
- en: By using Django's querysets, the resulting SQL will be properly escaped by the
    underlying database driver. However, Django also gives developers power to write
    raw queries or execute custom SQL. These capabilities should be used sparingly
    and you should always be careful to properly escape any parameters that the user
    can control. In addition, you should exercise caution when using `extra()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Django的查询集，生成的SQL将由底层数据库驱动程序正确转义。但是，Django还赋予开发人员编写原始查询或执行自定义SQL的权力。这些功能应该谨慎使用，并且您应该始终小心地正确转义用户可以控制的任何参数。此外，在使用`extra()`时应谨慎。
- en: Clickjacking protection
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击劫持保护
- en: Clickjacking is a type of attack where a malicious site wraps another site in
    a frame. This type of attack occurs when a malicious site tricks a user into clicking
    on a concealed element of another site which they have loaded in a hidden frame
    or iframe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击劫持是一种攻击类型，恶意站点在框架中包裹另一个站点。当恶意站点欺骗用户点击他们在隐藏框架或iframe中加载的另一个站点的隐藏元素时，就会发生这种类型的攻击。
- en: Django contains clickjacking protection in the form of the `X-Frame-Options
    middleware` which in a supporting browser can prevent a site from being rendered
    inside a frame. It is possible to disable the protection on a per view basis or
    to configure the exact header value sent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Django包含防止点击劫持的保护，即`X-Frame-Options中间件`，在支持的浏览器中可以防止网站在框架内呈现。可以在每个视图的基础上禁用保护，或配置发送的确切标头值。
- en: The middleware is strongly recommended for any site that does not need to have
    its pages wrapped in a frame by third party sites, or only needs to allow that
    for a small section of the site.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议对于任何不需要其页面被第三方站点包裹在框架中的站点，或者只需要允许站点的一小部分进行包裹的站点使用中间件。
- en: An example of clickjacking
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击劫持的一个例子
- en: Suppose an online store has a page where a logged in user can click **Buy Now**
    to purchase an item. A user has chosen to stay logged into the store all the time
    for convenience. An attacker site might create an **I Like Ponies** button on
    one of their own pages, and load the store's page in a transparent `iframe` such
    that the **Buy Now** button is invisibly overlaid on the **I Like Ponies** button.
    If the user visits the attacker's site, clicking **I Like Ponies** will cause
    an inadvertent click on the **Buy Now** button and an unknowing purchase of the
    item.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个在线商店有一个页面，用户可以在其中点击“立即购买”来购买商品。用户选择一直保持登录以方便使用。攻击者站点可能在其自己的页面上创建一个“我喜欢小马”按钮，并以透明的`iframe`加载商店的页面，使得“立即购买”按钮被隐形地覆盖在“我喜欢小马”按钮上。如果用户访问攻击者的站点，点击“我喜欢小马”将导致无意中点击“立即购买”按钮，并无意中购买商品。
- en: Preventing clickjacking
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止点击劫持
- en: Modern browsers honor the X-Frame-Options (for more information visit [https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header](https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header))
    HTTP header that indicates whether or not a resource is allowed to load within
    a frame or iframe. If the response contains the header with a value of `SAMEORIGIN`
    then the browser will only load the resource in a frame if the request originated
    from the same site. If the header is set to `DENY` then the browser will block
    the resource from loading in a frame no matter which site made the request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器遵守 X-Frame-Options（有关更多信息，请访问 [https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header](https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header)）HTTP
    头部，该头部指示资源是否允许在框架或 iframe 中加载。如果响应包含带有 `SAMEORIGIN` 值的头部，则浏览器只会在请求源自同一站点时才在框架中加载资源。如果头部设置为
    `DENY`，则浏览器将阻止资源在框架中加载，无论哪个站点发出了请求。
- en: 'Django provides a few simple ways to include this header in responses from
    your site:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了一些简单的方法来在您的站点的响应中包含这个头部：
- en: A simple middleware that sets the header in all responses.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的中间件，可以在所有响应中设置头部。
- en: A set of view decorators that can be used to override the middleware or to only
    set the header for certain views.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组视图装饰器，可用于覆盖中间件或仅为特定视图设置头部。
- en: How to use it
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用它
- en: Setting X-Frame-Options for all responses
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为所有响应设置 X-Frame-Options
- en: 'To set the same `X-Frame-Options` value for all responses in your site, put
    `''django.middleware.clickjacking.XFrameOptionsMiddleware''` to `MIDDLEWARE_CLASSES`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要为站点中的所有响应设置相同的 `X-Frame-Options` 值，请将 `'django.middleware.clickjacking.XFrameOptionsMiddleware'`
    放到 `MIDDLEWARE_CLASSES` 中：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This middleware is enabled in the settings file generated by `startproject`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件在由 `startproject` 生成的设置文件中启用。
- en: 'By default, the middleware will set the `X-Frame-Options` header to `SAMEORIGIN`
    for every outgoing `HttpResponse`. If you want `DENY` instead, set the `X_FRAME_OPTIONS`
    setting:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，中间件将为每个传出的 `HttpResponse` 设置 `X-Frame-Options` 头部为 `SAMEORIGIN`。如果要改为
    `DENY`，请设置 `X_FRAME_OPTIONS` 设置：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When using the middleware there may be some views where you do not want the
    `X-Frame-Options` header set. For those cases, you can use a view decorator that
    tells the middleware not to set the header:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中间件时，可能存在一些视图，您不希望设置 `X-Frame-Options` 头部。对于这些情况，您可以使用视图装饰器告诉中间件不要设置头部：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Setting X-Frame-Options per view
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为每个视图设置 X-Frame-Options
- en: 'To set the `X-Frame-Options` header on a per view basis, Django provides these
    decorators:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每个视图基础上设置 `X-Frame-Options` 头部，Django 提供了这些装饰器：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that you can use the decorators in conjunction with the middleware. Use
    of a decorator overrides the middleware.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以将装饰器与中间件一起使用。使用装饰器会覆盖中间件。
- en: Limitations
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: The `X-Frame-Options` header will only protect against clickjacking in a modern
    browser. Older browsers will quietly ignore the header and need other clickjacking
    prevention techniques.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Frame-Options` 头部只会在现代浏览器中保护免受点击劫持攻击。旧版浏览器会悄悄地忽略这个头部，并需要其他点击劫持防护技术。'
- en: Browsers that support X-Frame-Options
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持 X-Frame-Options 的浏览器
- en: Internet Explorer 8+
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet Explorer 8+
- en: Firefox 3.6.9+
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 3.6.9+
- en: Opera 10.5+
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera 10.5+
- en: Safari 4+
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari 4+
- en: Chrome 4.1+
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome 4.1+
- en: SSL/HTTPS
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL/HTTPS
- en: It is always better for security, though not always practical in all cases,
    to deploy your site behind HTTPS. Without this, it is possible for malicious network
    users to sniff authentication credentials or any other information transferred
    between client and server, and in some cases-active network attackers-to alter
    data that is sent in either direction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在所有情况下部署站点在 HTTPS 后面对于安全性来说总是更好的，但并非在所有情况下都是实际可行的。如果没有这样做，恶意网络用户可能会窃取身份验证凭据或客户端和服务器之间传输的任何其他信息，并且在某些情况下，主动的网络攻击者可能会更改在任一方向上发送的数据。
- en: 'If you want the protection that HTTPS provides, and have enabled it on your
    server, there are some additional steps you may need:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望获得 HTTPS 提供的保护，并已在服务器上启用了它，则可能需要一些额外的步骤：
- en: If necessary, set `SECURE_PROXY_SSL_HEADER`, ensuring that you have understood
    the warnings there thoroughly. Failure to do this can result in CSRF vulnerabilities,
    and failure to do it correctly can also be dangerous!
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有必要，请设置 `SECURE_PROXY_SSL_HEADER`，确保您已充分理解其中的警告。不这样做可能会导致 CSRF 漏洞，并且不正确地执行也可能很危险！
- en: Set up redirection so that requests over HTTP are redirected to HTTPS.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置重定向，以便通过 HTTP 的请求被重定向到 HTTPS。
- en: This could be done using a custom middleware. Please note the caveats under
    `SECURE_PROXY_SSL_HEADER`. For the case of a reverse proxy, it may be easier or
    more secure to configure the main web server to do the redirect to HTTPS.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以通过使用自定义中间件来实现。请注意 `SECURE_PROXY_SSL_HEADER` 下的注意事项。对于反向代理的情况，配置主要的 Web 服务器来执行重定向到
    HTTPS 可能更容易或更安全。
- en: Use *secure* cookies. If a browser connects initially via HTTP, which is the
    default for most browsers, it is possible for existing cookies to be leaked. For
    this reason, you should set your `SESSION_COOKIE_SECURE` and `CSRF_COOKIE_SECURE`
    settings to `True`. This instructs the browser to only send these cookies over
    HTTPS connections. Note that this will mean that sessions will not work over HTTP,
    and the CSRF protection will prevent any `POST` data being accepted over HTTP
    (which will be fine if you are redirecting all HTTP traffic to HTTPS).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *secure* cookies。如果浏览器最初通过 HTTP 连接，这是大多数浏览器的默认设置，现有的 cookies 可能会泄漏。因此，您应该将
    `SESSION_COOKIE_SECURE` 和 `CSRF_COOKIE_SECURE` 设置为 `True`。这指示浏览器仅在 HTTPS 连接上发送这些
    cookies。请注意，这意味着会话将无法在 HTTP 上工作，并且 CSRF 保护将阻止任何通过 HTTP 接受的 `POST` 数据（如果您将所有 HTTP
    流量重定向到 HTTPS，则这将是可以接受的）。
- en: Use HTTP Strict Transport Security (HSTS). HSTS is an HTTP header that informs
    a browser that all future connections to a particular site should always use HTTPS
    (see below). Combined with redirecting requests over HTTP to HTTPS, this will
    ensure that connections always enjoy the added security of SSL provided one successful
    connection has occurred. HSTS is usually configured on the web server.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP严格传输安全（HSTS）。HSTS是一个HTTP标头，通知浏览器所有未来连接到特定站点应始终使用HTTPS（见下文）。结合将请求重定向到HTTPS，这将确保连接始终享有SSL提供的额外安全性，只要成功连接一次。HSTS通常在Web服务器上配置。
- en: HTTP strict transport security
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP严格传输安全
- en: For sites that should only be accessed over HTTPS, you can instruct modern browsers
    to refuse to connect to your domain name via an insecure connection (for a given
    period of time) by setting the Strict-Transport-Security header. This reduces
    your exposure to some SSL-stripping Man-In-The-Middle (MITM) attacks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应仅通过HTTPS访问的站点，您可以指示现代浏览器拒绝通过不安全连接（在一定时间内）连接到您的域名，方法是设置Strict-Transport-Security标头。这将减少您对某些SSL剥离中间人（MITM）攻击的风险。
- en: '`SecurityMiddleware` will set this header for you on all HTTPS responses if
    you set the `SECURE_HSTS_SECONDS` setting to a non-zero integer value.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`SECURE_HSTS_SECONDS`设置为非零整数值，`SecurityMiddleware`将在所有HTTPS响应上为您设置此标头。
- en: When enabling HSTS, it's a good idea to first use a small value for testing,
    for example, `SECURE_HSTS_SECONDS = 3600` for one hour. Each time a web browser
    sees the HSTS header from your site, it will refuse to communicate non-securely
    (using HTTP) with your domain for the given period of time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用HSTS时，最好首先使用一个小值进行测试，例如`SECURE_HSTS_SECONDS = 3600`表示一小时。每次Web浏览器从您的站点看到HSTS标头时，它将拒绝在给定时间内与您的域进行非安全通信（使用HTTP）。
- en: Once you confirm that all assets are served securely on your site (that is,
    HSTS didn't break anything), it's a good idea to increase this value so that infrequent
    visitors will be protected (31536000 seconds, that is, 1 year, is common).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认您的站点上的所有资产都安全提供（即HSTS没有破坏任何内容），最好增加此值，以便偶尔访问者受到保护（31536000秒，即1年，是常见的）。
- en: Additionally, if you set the `SECURE_HSTS_INCLUDE_SUBDOMAINS` setting to `True`,
    `SecurityMiddleware` will add the `includeSubDomains` tag to the `Strict-Transport-Security`
    header. This is recommended (assuming all subdomains are served exclusively using
    HTTPS), otherwise your site may still be vulnerable via an insecure connection
    to a subdomain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果将`SECURE_HSTS_INCLUDE_SUBDOMAINS`设置为`True`，`SecurityMiddleware`将向`Strict-Transport-Security`标头添加`includeSubDomains`标记。这是推荐的（假设所有子域都仅使用HTTPS提供服务），否则您的站点仍可能通过不安全的连接对子域进行攻击。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The HSTS policy applies to your entire domain, not just the URL of the response
    that you set the header on. Therefore, you should only use it if your entire domain
    is served via HTTPS only.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HSTS策略适用于整个域，而不仅仅是您在响应上设置标头的URL。因此，只有在整个域仅通过HTTPS提供服务时才应使用它。
- en: Browsers properly respecting the HSTS header will refuse to allow users to bypass
    warnings and connect to a site with an expired, self-signed, or otherwise invalid
    SSL certificate. If you use HSTS, make sure your certificates are in good shape
    and stay that way!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器正确尊重HSTS标头将拒绝允许用户绕过警告并连接到具有过期、自签名或其他无效SSL证书的站点。如果您使用HSTS，请确保您的证书状况良好并保持良好！
- en: If you are deployed behind a load-balancer or reverse-proxy server, and the
    `Strict-Transport-Security` header is not being added to your responses, it may
    be because Django doesn't realize that it's on a secure connection; you may need
    to set the `SECURE_PROXY_SSL_HEADER` setting.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您部署在负载均衡器或反向代理服务器后，并且未将`Strict-Transport-Security`标头添加到您的响应中，可能是因为Django没有意识到它处于安全连接中；您可能需要设置`SECURE_PROXY_SSL_HEADER`设置。
- en: Host header validation
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机标头验证
- en: Django uses the `Host` header provided by the client to construct URLs in certain
    cases. While these values are sanitized to prevent Cross Site Scripting attacks,
    a fake `Host` value can be used for Cross-Site Request Forgery, cache poisoning
    attacks, and poisoning links in emails.Because even seemingly-secure web server
    configurations are susceptible to fake `Host` headers, Django validates `Host`
    headers against the `ALLOWED_HOSTS` setting in the `django.http.HttpRequest.get_host()`
    method.This validation only applies via `get_host()`; if your code accesses the
    `Host` header directly from `request.META` you are bypassing this security protection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用客户端提供的`Host`标头在某些情况下构建URL。虽然这些值经过清理以防止跨站点脚本攻击，但可以使用虚假的`Host`值进行跨站点请求伪造、缓存污染攻击和电子邮件中的链接污染。因为即使看似安全的Web服务器配置也容易受到虚假的`Host`标头的影响，Django会在`django.http.HttpRequest.get_host()`方法中针对`ALLOWED_HOSTS`设置验证`Host`标头。此验证仅适用于`get_host()`；如果您的代码直接从`request.META`访问`Host`标头，则会绕过此安全保护。
- en: Session security
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话安全
- en: Similar to the CSRF limitations requiring a site to be deployed such that untrusted
    users don't have access to any subdomains, `django.contrib.sessions` also has
    limitations. See the session topic guide section on security for details.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSRF限制类似，要求站点部署在不受信任用户无法访问任何子域的情况下，`django.contrib.sessions`也有限制。有关详细信息，请参阅安全主题指南部分的会话主题。
- en: User-Uploaded content
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户上传的内容
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Consider serving static files from a cloud service or CDN to avoid some of these
    issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从云服务或CDN提供静态文件以避免其中一些问题。
- en: If your site accepts file uploads, it is strongly advised that you limit these
    uploads in your web server configuration to a reasonable size in order to prevent
    denial of service (DOS) attacks. In Apache, this can be easily set using the `LimitRequestBody`
    directive.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的站点接受文件上传，强烈建议您在Web服务器配置中限制这些上传的大小，以防止拒绝服务（DOS）攻击。在Apache中，可以使用`LimitRequestBody`指令轻松设置这一点。
- en: If you are serving your own static files, be sure that handlers like Apache's
    `mod_php`, which would execute static files as code, are disabled. You don't want
    users to be able to execute arbitrary code by uploading and requesting a specially
    crafted file.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在提供自己的静态文件，请确保像Apache的`mod_php`这样的处理程序已被禁用，因为它会将静态文件作为代码执行。您不希望用户能够通过上传和请求特制文件来执行任意代码。
- en: Django's media upload handling poses some vulnerabilities when that media is
    served in ways that do not follow security best practices. Specifically, an HTML
    file can be uploaded as an image if that file contains a valid PNG header followed
    by malicious HTML. This file will pass verification of the library that Django
    uses for `ImageField` image processing (Pillow). When this file is subsequently
    displayed to a user, it may be displayed as HTML depending on the type and configuration
    of your web server.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当媒体以不遵循安全最佳实践的方式提供时，Django的媒体上传处理会存在一些漏洞。具体来说，如果HTML文件包含有效的PNG标头，后跟恶意HTML，则可以将HTML文件上传为图像。这个文件将通过Django用于`ImageField`图像处理的库（Pillow）的验证。当此文件随后显示给用户时，根据您的Web服务器的类型和配置，它可能会显示为HTML。
- en: 'No bulletproof technical solution exists at the framework level to safely validate
    all user uploaded file content, however, there are some other steps you can take
    to mitigate these attacks:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架级别没有防弹的技术解决方案可以安全地验证所有用户上传的文件内容，但是，您可以采取一些其他步骤来减轻这些攻击：
- en: One class of attacks can be prevented by always serving user uploaded content
    from a distinct top-level or second-level domain. This prevents any exploit blocked
    by same-origin policy(for more information visit [http://en.wikipedia.org/wiki/Same-origin_policy](http://en.wikipedia.org/wiki/Same-origin_policy))
    protections such as cross site scripting. For example, if your site runs on `example.com`,
    you would want to serve uploaded content (the `MEDIA_URL` setting) from something
    like `usercontent-example.com`. It's not sufficient to serve content from a subdomain
    like `usercontent.example.com`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一类攻击可以通过始终从不同的顶级或二级域名提供用户上传的内容来防止。这可以防止任何被同源策略（有关更多信息，请访问[http://en.wikipedia.org/wiki/Same-origin_policy](http://en.wikipedia.org/wiki/Same-origin_policy)）阻止的利用，例如跨站脚本。例如，如果您的站点运行在`example.com`上，您希望从类似`usercontent-example.com`的地方提供上传的内容（`MEDIA_URL`设置）。仅仅从子域名（如`usercontent.example.com`）提供内容是不够的。
- en: Beyond this, applications may choose to define a whitelist of allowable file
    extensions for user uploaded files and configure the web server to only serve
    such files.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，应用程序可以选择为用户上传的文件定义一个允许的文件扩展名白名单，并配置Web服务器仅提供这些文件。
- en: Additional security tips
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全提示
- en: While Django provides good security protection out of the box, it is still important
    to properly deploy your application and take advantage of the security protection
    of the web server, operating system and other components.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Django在开箱即用时提供了良好的安全保护，但仍然很重要正确部署应用程序并利用Web服务器、操作系统和其他组件的安全保护。
- en: Make sure that your Python code is outside of the web server's root. This will
    ensure that your Python code is not accidentally served as plain text (or accidentally
    executed).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的Python代码位于Web服务器的根目录之外。这将确保您的Python代码不会被意外地作为纯文本（或意外执行）提供。
- en: Take care with any user uploaded files.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小心处理任何用户上传的文件。
- en: Django does not throttle requests to authenticate users. To protect against
    brute-force attacks against the authentication system, you may consider deploying
    a Django plugin or web server module to throttle these requests.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django不会限制对用户进行身份验证的请求。为了防止针对身份验证系统的暴力攻击，您可以考虑部署Django插件或Web服务器模块来限制这些请求。
- en: Keep your `SECRET_KEY` a secret.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持您的`SECRET_KEY`是秘密的。
- en: It is a good idea to limit the accessibility of your caching system and database
    using a firewall.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制缓存系统和数据库的可访问性是一个好主意。
- en: Archive of security issues
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全问题档案
- en: Django's development team is strongly committed to responsible reporting and
    disclosure of security-related issues, as outlined in Django's security policies.As
    part of that commitment, they maintain an historical list of issues which have
    been fixed and disclosed. For the up to date list, see the archive of security
    issues ([https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Django的开发团队坚决致力于负责任地报告和披露安全相关问题，如Django的安全政策所述。作为承诺的一部分，他们维护了一个已修复和披露的问题的历史列表。有关最新列表，请参阅安全问题档案（[https://docs.djangoproject.com/en/1.8/releases/security/](https://docs.djangoproject.com/en/1.8/releases/security/)）。
- en: Cryptographic signing
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密签名
- en: 'The golden rule of web application security is to never trust data from untrusted
    sources. Sometimes it can be useful to pass data through an untrusted medium.
    Cryptographically signed values can be passed through an untrusted channel safe
    in the knowledge that any tampering will be detected.Django provides both a low-level
    API for signing values and a high-level API for setting and reading signed cookies,
    one of the most common uses of signing in web applications.You may also find signing
    useful for the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序安全的黄金法则是永远不要相信来自不受信任来源的数据。有时通过不受信任的媒介传递数据可能是有用的。通过加密签名的值可以通过不受信任的渠道传递，以确保任何篡改都将被检测到。Django提供了用于签名值的低级API和用于设置和读取签名cookie的高级API，签名在Web应用程序中是最常见的用途之一。您可能还会发现签名对以下内容有用：
- en: Generating *recover my account* URLs for sending to users who have lost their
    password.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为失去密码的用户生成*找回我的账户*URL。
- en: Ensuring data stored in hidden form fields has not been tampered with.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保存储在隐藏表单字段中的数据没有被篡改。
- en: Generating one-time secret URLs for allowing temporary access to a protected
    resource, for example, a downloadable file that a user has paid for.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为允许临时访问受保护资源（例如，用户已支付的可下载文件）生成一次性秘密URL。
- en: Protecting the SECRET_KEY
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护SECRET_KEY
- en: When you create a new Django project using `startproject`, the `settings.py`
    file is generated automatically and gets a random `SECRET_KEY` value. This value
    is the key to securing signed data-it is vital you keep this secure, or attackers
    could use it to generate their own signed values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`startproject`创建一个新的Django项目时，`settings.py`文件会自动生成并获得一个随机的`SECRET_KEY`值。这个值是保护签名数据的关键-您必须保持它安全，否则攻击者可能会使用它来生成自己的签名值。
- en: Using the low-level API
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用低级API
- en: 'Django''s signing methods live in the `django.core.signing` module. To sign
    a value, first instantiate a `Signer` instance:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Django的签名方法位于`django.core.signing`模块中。要签名一个值，首先实例化一个`Signer`实例：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The signature is appended to the end of the string, following the colon. You
    can retrieve the original value using the `unsign` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 签名附加到字符串的末尾，跟在冒号后面。您可以使用`unsign`方法检索原始值：
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the signature or value have been altered in any way, a `django.core.signing.BadSignature`
    exception will be raised:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名或值以任何方式被更改，将引发`django.core.signing.BadSignature`异常：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, the `Signer` class uses the `SECRET_KEY` setting to generate signatures.
    You can use a different secret by passing it to the `Signer` constructor:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Signer`类使用`SECRET_KEY`设置生成签名。您可以通过将其传递给`Signer`构造函数来使用不同的密钥：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`django.core.signing.Signer` returns a signer which uses `key` to generate
    signatures and `sep` to separate values. `sep` cannot be in the URL safe base64
    alphabet. This alphabet contains alphanumeric characters, hyphens, and underscores.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.core.signing.Signer`返回一个签名者，该签名者使用`key`生成签名，`sep`用于分隔值。`sep`不能在URL安全的base64字母表中。这个字母表包含字母数字字符、连字符和下划线。'
- en: Using the salt argument
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用盐参数
- en: 'If you do not wish for every occurrence of a particular string to have the
    same signature hash, you can use the optional `salt` argument to the `Signer`
    class. Using a salt will seed the signing hash function with both the salt and
    your `SECRET_KEY`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望特定字符串的每次出现都具有相同的签名哈希，可以使用`Signer`类的可选`salt`参数。使用盐将使用盐和您的`SECRET_KEY`对签名哈希函数进行种子处理：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using salt in this way puts the different signatures into different namespaces.
    A signature that comes from one namespace (a particular salt value) cannot be
    used to validate the same plaintext string in a different namespace that is using
    a different salt setting. The result is to prevent an attacker from using a signed
    string generated in one place in the code as input to another piece of code that
    is generating (and verifying) signatures using a different salt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用盐将不同的签名放入不同的命名空间。来自一个命名空间（特定盐值）的签名不能用于验证使用不同盐设置的不同命名空间中的相同纯文本字符串。结果是防止攻击者使用在代码中的一个地方生成的签名字符串作为输入到另一段使用不同盐生成（和验证）签名的代码。
- en: Unlike your `SECRET_KEY`, your salt argument does not need to stay secret.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与您的`SECRET_KEY`不同，您的盐参数不需要保密。
- en: Verifying timestamped values
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证时间戳值
- en: '`TimestampSigner` is a subclass of `Signer` that appends a signed timestamp
    to the value. This allows you to confirm that a signed value was created within
    a specified period of time:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimestampSigner`是`Signer`的子类，它附加了一个签名的时间戳到值。这允许您确认签名值是在指定的时间段内创建的：'
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`sign(value)` signs `value` and appends the current timestamp.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign(value)`签名`value`并附加当前时间戳。'
- en: '`unsign(value, max_age=None)` checks if `value` was signed less than `max_age`
    seconds ago, otherwise raises `SignatureExpired`. The `max_age` parameter can
    accept an integer or a `datetime.timedelta` object.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsign(value, max_age=None)`检查`value`是否在`max_age`秒之内签名，否则会引发`SignatureExpired`。`max_age`参数可以接受整数或`datetime.timedelta`对象。'
- en: Protecting complex data structures
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护复杂的数据结构
- en: 'If you wish to protect a list, tuple or dictionary you can do so using the
    signing module''s `dumps` and `loads` functions. These imitate Python''s pickle
    module, but use JSON serialization under the hood. JSON ensures that even if your
    `SECRET_KEY` is stolen an attacker will not be able to execute arbitrary commands
    by exploiting the pickle format:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望保护列表、元组或字典，可以使用签名模块的`dumps`和`loads`函数。这些函数模仿了Python的pickle模块，但在底层使用JSON序列化。JSON确保即使您的`SECRET_KEY`被盗，攻击者也无法利用pickle格式执行任意命令：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because of the nature of JSON (there is no native distinction between lists
    and tuples) if you pass in a tuple, you will get a list from `signing.loads(object)`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON的性质（没有本地区分列表和元组的区别），如果传入元组，您将从`signing.loads(object)`得到一个列表：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`django.core.signing.dumps(obj, key=None, salt=''django.core.signing'', compress=False)`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.core.signing.dumps(obj, key=None, salt=''django.core.signing'', compress=False)`'
- en: Returns URL-safe, sha1 signed base64 compressed JSON string. Serialized object
    is signed using `TimestampSigner`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回URL安全的，经过sha1签名的base64压缩的JSON字符串。序列化对象使用`TimestampSigner`进行签名。
- en: '`django.core.signing.loads(string, key=None, salt=''django.core.signing'',
    max_age=None)`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.core.signing.loads(string, key=None, salt=''django.core.signing'',
    max_age=None)`'
- en: Reverse of `dumps()`, raises `BadSignature` if signature fails. Checks `max_age`
    (in seconds) if given.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumps()`的反向操作，如果签名失败则引发`BadSignature`。如果给定，检查`max_age`（以秒为单位）。'
- en: Security middleware
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全中间件
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your deployment situation allows, it's usually a good idea to have your front-end
    web server perform the functionality provided by the `SecurityMiddleware`. That
    way, if there are requests that aren't served by Django (such as static media
    or user-uploaded files), they will have the same protections as requests to your
    Django application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的部署情况允许，通常最好让前端Web服务器执行`SecurityMiddleware`提供的功能。这样，如果有一些请求不是由Django提供的（例如静态媒体或用户上传的文件），它们将具有与请求到您的Django应用程序相同的保护。
- en: The `django.middleware.security.SecurityMiddleware` provides several security
    enhancements to the request/response cycle. Each one can be independently enabled
    or disabled with a setting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`django.middleware.security.SecurityMiddleware`为请求/响应周期提供了几个安全增强功能。每个功能都可以通过设置独立启用或禁用。'
- en: '`SECURE_BROWSER_XSS_FILTER`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_BROWSER_XSS_FILTER`'
- en: '`SECURE_CONTENT_TYPE_NOSNIFF`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_CONTENT_TYPE_NOSNIFF`'
- en: '`SECURE_HSTS_INCLUDE_SUBDOMAINS`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_HSTS_INCLUDE_SUBDOMAINS`'
- en: '`SECURE_HSTS_SECONDS`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_HSTS_SECONDS`'
- en: '`SECURE_REDIRECT_EXEMPT`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_REDIRECT_EXEMPT`'
- en: '`SECURE_SSL_HOST`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_SSL_HOST`'
- en: '`SECURE_SSL_REDIRECT`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECURE_SSL_REDIRECT`'
- en: For more on security headers and these settings, see [Chapter 17](ch17.xhtml
    "Chapter 17. Django Middleware"), *Django Middleware*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安全标头和这些设置的更多信息，请参阅[第17章](ch17.xhtml "第17章. Django中间件")*Django中间件*。
- en: What's next?
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In the next chapter, we will expand on the quick install guide from [Chapter
    1](ch01.xhtml "Chapter 1. Introduction to Django and Getting Started"), *Introduction
    to Django and Getting Started* and look at some additional installation and configuration
    options for Django.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展来自[第1章](ch01.xhtml "第1章. Django简介和入门")的快速安装指南，*Django简介和入门*，并查看Django的一些额外安装和配置选项。
