- en: Starvation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿
- en: In this chapter, we will discuss the concept of starvation and its potential
    causes in concurrent programming. We will cover a number of readers-writers problems,
    which are prime examples of starvation, and we will simulate them in example Python
    code. This chapter will also cover the relationship between deadlock and starvation,
    as well as some potential solutions for starvation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论并发编程中饥饿的概念及其潜在原因。我们将涵盖一些读者-写者问题，这些问题是饥饿的主要例子，并且我们将在示例Python代码中模拟它们。本章还将涵盖死锁和饥饿之间的关系，以及饥饿的一些潜在解决方案。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic idea behind starvation, its root causes, and some more relevant concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饥饿背后的基本思想、其根本原因和一些更相关的概念
- en: A detailed analysis of the readers-writers problem, which is used to illustrate
    the complexity of starvation in a concurrent system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者-写者问题的详细分析，用于说明并发系统中饥饿的复杂性
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了Python 3
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python) 下载GitHub存储库
- en: During this chapter, we will be working with the subfolder titled `Chapter13`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter13`的子文件夹进行工作
- en: Check out the following video to see the Code in Action: [http://bit.ly/2r3caw8](http://bit.ly/2r3caw8)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例： [http://bit.ly/2r3caw8](http://bit.ly/2r3caw8)
- en: The concept of starvation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿的概念
- en: '**Starvation** is a problem in concurrent systems, in which a process (or a
    thread) cannot gain access to the necessary resources in order to proceed with
    its execution and, therefore, cannot make any progress. In this section, we will
    look into the characteristics of a starvation situation, analyze the most common
    causes of starvation, and finally, consider a sample program that exemplifies
    starvation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**饥饿**是并发系统中的一个问题，其中一个进程（或线程）无法获得必要的资源以继续执行，因此无法取得任何进展。在本节中，我们将探讨饥饿情况的特征，分析饥饿的最常见原因，并最后考虑一个示例程序，说明饥饿的情况。'
- en: What is starvation?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是饥饿？
- en: 'It is quite common for a concurrent program to implement some sort of ordering
    between the different processes in its execution. For example, consider a program
    that has three separate processes, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并发程序通常会在其执行过程中实现不同进程之间的某种排序。例如，考虑一个具有三个独立进程的程序，如下所示：
- en: One is responsible for handling extremely pressing instructions that need to
    be run as soon as the necessary resources become available
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负责处理非常紧急的指令，一旦必要的资源可用就需要立即运行
- en: Another process is responsible for other important executions, which are not
    as essential as the tasks in the first process
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个进程负责其他重要的执行，这些执行不像第一个进程中的任务那样重要
- en: The last one handles miscellaneous, very infrequent tasks
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个处理杂项、非常不频繁的任务
- en: Furthermore, these three process need to utilize the same resources in order
    to execute their respective instructions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这三个进程需要利用相同的资源来执行各自的指令。
- en: Intuitively, we have every reason to implement a specification that allows the
    first process to have the highest priority of execution and access to resources,
    then the second process, and then the last process, with the lowest priority.
    However, imagine situations in which the first two processes (with higher priorities)
    run so often that the third process cannot execute its instructions; anytime the
    third process needs to run, it checks to see whether the resources are available
    to be used and finds out that one of the other, higher-priority processes is using
    them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，我们有充分理由实施一个规范，允许第一个进程具有最高的执行优先级和资源访问权限，然后是第二个进程，最后是优先级最低的最后一个进程。然而，想象一下，前两个进程（优先级较高）运行得如此频繁，以至于第三个进程无法执行其指令；每当第三个进程需要运行时，它都会检查资源是否可用，并发现其他优先级更高的进程正在使用它们。
- en: 'This is a situation of starvation: the third process is given no opportunity
    to execute and, therefore, no progress can be made with that process. In a typical
    concurrent program, it is quite common to have more than three processes at different
    priority levels, yet the situation is fundamentally similar: some processes are
    given more opportunities to run and, therefore, they are constantly executing.
    Others have lower priorities and cannot access the necessary resources to execute.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个饥饿的情况：第三个进程没有机会执行，因此，该进程无法取得任何进展。在典型的并发程序中，很常见有多于三个不同优先级的进程，然而情况基本相似：一些进程获得更多运行的机会，因此它们不断执行。其他进程优先级较低，无法访问必要的资源来执行。
- en: Scheduling
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度
- en: In the next few subsections, we will be discussing the potential candidates
    that cause starvation situations. Most of the time, a poorly coordinated set of scheduling
    instructions is the main cause of starvation. For example, a considerably naive
    algorithm that deals with three separate tasks might implement constant communication
    and interaction between the first two tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将讨论导致饥饿情况的潜在原因。大多数情况下，一组调度指令的协调不佳是饥饿的主要原因。例如，处理三个独立任务的相当天真的算法可能会在前两个任务之间实现不断的通信和交互。
- en: This setup leads to the fact that the execution flow of the algorithm switches
    solely between the first and second tasks, while the third finds itself idle and
    unable to make any progress with its execution; in this case, because it is starved
    of CPU execution flow. Intuitively, we can identify the root of the problem as
    the fact that the algorithm allows the first two tasks to always dominate the
    CPU, and hence, effectively prevents any other task to also utilize the CPU. A
    characteristic of a good scheduling algorithm is the ability to distribute the
    execution flow and allocate the resources equally and appropriately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置导致算法的执行流程仅在第一和第二个任务之间切换，而第三个任务发现自己处于空闲状态，无法在执行中取得任何进展；在这种情况下，因为它被剥夺了CPU的执行流程。直观地，我们可以确定问题的根源在于算法允许前两个任务始终主导CPU，因此有效地阻止了任何其他任务也利用CPU。一个良好调度算法的特征是能够平均和适当地分配执行流程和资源。
- en: As mentioned previously, many concurrent systems and programs implement a specific
    order of priority, in terms of process and thread execution. This implementation
    of ordered scheduling may very likely lead to the starvation of processes and
    threads of lower priorities and can result in a condition called **priority inversion**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，许多并发系统和程序实现了特定的优先级顺序，以进程和线程的执行为基础。这种有序调度的实现很可能会导致低优先级的进程和线程饥饿，并且可能导致一种称为**优先级倒置**的情况。
- en: Suppose that, in your concurrent program, you have process A of the highest
    priority, process B of a medium priority, and finally, process C of the lowest
    priority; process C would most likely be put in the situation of starvation. Additionally,
    if the execution of process A, the prioritized process, is dependent on the completion
    of process C, which is already in starvation, then process A might never be able
    to complete its execution, either, even though it is given the highest priority
    in the concurrent program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在您的并发程序中，您有最高优先级的进程A，中等优先级的进程B，最后是最低优先级的进程C；进程C很可能会陷入饥饿的情况。此外，如果优先级进程A的执行取决于已经处于饥饿状态的进程C的完成，那么即使在并发程序中给予了最高优先级，进程A也可能永远无法完成其执行。
- en: 'The following diagram further illustrates the concept of priority inversion:
    a high-priority task running from the time **t2** to **t3** needs to access some
    resources, which are being utilized by a low-priority task:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进一步说明了优先级倒置的概念：一个从时间**t2**到**t3**运行的高优先级任务需要访问一些资源，而这些资源正在被低优先级任务利用：
- en: '![](assets/d4c74468-db4a-4a70-88a1-84de39731b88.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d4c74468-db4a-4a70-88a1-84de39731b88.png)'
- en: Diagram of priority inversion
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级倒置的图表
- en: To reiterate, combining starvation and priority inversion can lead to a situation
    where even the high-priority tasks are unable to execute their instructions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，结合饥饿和优先级倒置可能导致即使高优先级任务也无法执行它们的指令的情况。
- en: Causes of starvation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿的原因
- en: 'With the complexity of designing a scheduling algorithm in mind, let us discuss
    the specific causes of starvation. The situations that we described in the preceding
    section indicate some potential causes of the situation of starvation. However,
    starvation can arise from a number of sources, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到设计调度算法的复杂性，让我们讨论饥饿的具体原因。我们在前面的部分描述的情况表明了饥饿情况的一些潜在原因。然而，饥饿可能来自多种来源，如下所示：
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU, and hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高优先级的进程（或线程）主导着CPU的执行流程，因此，低优先级的进程（或线程）没有机会执行它们自己的指令。
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources, and hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions. This situation is similar to the first one,
    but addresses the priority of accessing resources, instead of the priority of
    the execution itself.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高优先级的进程（或线程）主导着不可共享资源的使用，因此，低优先级的进程（或线程）没有机会执行它们自己的指令。这种情况类似于第一种情况，但是涉及访问资源的优先级，而不是执行本身的优先级。
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but, as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait infinitely.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低优先级的进程（或线程）正在等待资源来执行它们的指令，但是一旦资源变得可用，具有更高优先级的其他进程（或线程）立即获得访问权限，因此低优先级的进程（或线程）将无限等待。
- en: There are other causes of starvation, as well, but the preceding are the most
    common root causes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他导致饥饿的原因，但前述是最常见的根本原因。
- en: Starvation's relationship to deadlock
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿与死锁的关系
- en: Interestingly, deadlock situations can also lead to starvation, as the definition
    of starvation states that if there is a process (or a thread) that is unable to
    make any progress because it cannot gain access to the necessary process, the
    process (or thread) is experiencing starvation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，死锁情况也可能导致饥饿，因为饥饿的定义表明，如果有一个进程（或线程）由于无法获得必要的进程而无法取得任何进展，那么该进程（或线程）正在经历饥饿。
- en: 'Recall our example of deadlock, the Dining Philosophers problem, illustrated
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们的死锁示例，餐桌哲学家问题，如下所示：
- en: '![](assets/7477edae-1949-42f9-a756-dbc4ecb6fd28.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7477edae-1949-42f9-a756-dbc4ecb6fd28.png)'
- en: An illustration of the Dining Philosophers problem
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 餐桌哲学家问题的插图
- en: When deadlock occurs for this situation, no philosopher can obtain the necessary
    resources to execute their instructions (each philosopher is required to have
    two forks to start eating). Each philosopher that is in a deadlock is therefore
    also in a state of starvation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当死锁发生时，没有哲学家可以获得执行他们指令所需的资源（每个哲学家需要两把叉子才能开始吃饭）。处于死锁状态的每个哲学家也处于饥饿状态。
- en: The readers-writers problem
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者-写者问题
- en: The readers-writers problem is one of the classic and most complex examples
    in the field of computer science, illustrating problems that might occur in a
    concurrent program. Throughout the analysis of the different variations of the
    readers-writers problem, we will reveal more about starvation, as well as its
    common causes. We will also simulate the problem in Python, so that a deeper understanding
    of the problem can be gained.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 读者-写者问题是计算机科学领域中经典和最复杂的例子之一，它展示了并发程序中可能出现的问题。通过分析读者-写者问题的不同变体，我们将更多地了解饥饿问题及其常见原因。我们还将在Python中模拟这个问题，以便更深入地理解这个问题。
- en: Problem statement
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题陈述
- en: In a readers-writers problem, first and foremost, we have a shared resource,
    which, in most cases, is a text file. Different threads interact with that text
    file; each is either a reader or a writer. A **reader** is a thread that simply
    accesses the shared resource (the text file) and reads in the data included in
    that file, while a **writer** is a thread that accesses, and possibly mutates,
    the contents of the text file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在读者-写者问题中，首先，我们有一个共享资源，大多数情况下是一个文本文件。不同的线程与该文本文件交互；每个线程都是读者或写者。**读者**是一个简单地访问共享资源（文本文件）并读取其中包含的数据的线程，而**写者**是一个访问并可能改变文本文件内容的线程。
- en: We know that writers and readers cannot access the shared resources simultaneously
    since if a thread is writing data to the file, no other thread should be accessing
    the file to read any data from it. The goal of the readers-writers problem is
    therefore to find a correct and efficient way to design and coordinate the scheduling
    of these reader and writer thread. A successful implementation of that goal is
    not only that the program as a whole executes in the most optimized way, but also
    that all threads are given sufficient opportunity to execute their instructions
    and no starvation can occur. Additionally, the shared resource (the text file)
    needs to be handled appropriately, so that no data will be corrupted.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道写者和读者不能同时访问共享资源，因为如果一个线程正在向文件写入数据，其他线程就不应该访问文件以从中读取任何数据。因此，读者-写者问题的目标是找到一种正确和高效的方式来设计和协调这些读者和写者线程的调度。成功实现这个目标不仅意味着整个程序以最优化的方式执行，而且所有线程都有足够的机会执行它们的指令，不会发生饥饿。此外，需要适当地处理共享资源（文本文件），以便不会损坏数据。
- en: 'The following diagram further illustrates the setup of the readers-writers
    problem:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进一步说明了读者-写者问题的设置：
- en: '![](assets/6d69fd3c-9f98-4006-9a5a-f3a165eaaab6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d69fd3c-9f98-4006-9a5a-f3a165eaaab6.png)'
- en: Diagram of readers-writers problem
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 读者-写者问题的图表
- en: The first readers-writers problem
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个读者-写者问题
- en: As we mentioned, the problem asks us to come up with a scheduling algorithm,
    so that readers and writers can access the text file appropriately and efficiently,
    without mishandling/corrupting the data that is included. A naive solution to
    this problem is to impose a lock on the text file, so that it becomes a non-shareable
    resource; this means that only one thread (either a reader or a writer) can access
    (and potentially manipulate) the text file at any given time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，这个问题要求我们提出一个调度算法，以便读者和写者可以适当和高效地访问文本文件，而不会错误处理/损坏其中包含的数据。对这个问题的一个天真的解决方案是对文本文件施加锁定，使其成为一个不可共享的资源；这意味着在任何给定时间只有一个线程（无论是读者还是写者）可以访问（并可能操纵）文本文件。
- en: 'Yet, this approach simply equates to a sequential program: if the shared resource
    can be utilized by only one thread at a given time, none of the processing time
    between different threads can be overlapped, and effectively, the execution becomes
    sequential. Therefore, this is not an optimal solution, as it is taking advantage
    of concurrent programming.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法只是等同于一个顺序程序：如果共享资源一次只能被一个线程使用，不同线程之间的处理时间就不能重叠，实际上，执行变成了顺序的。因此，这不是一个最佳解决方案，因为它没有充分利用并发编程。
- en: 'One insight regarding the reader threads can lead to a more optimal solution
    to this problem: since readers simply read in the text file and do not alter the
    data in it, multiple readers can be allowed to access the text file simultaneously.
    Indeed, even if more than one reader is fetching data from the text file at the
    same time, the data is not being changed in any way, and the consistency and accuracy
    of the data is therefore maintained.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于读者线程的一个见解可以导致对这个问题更优化的解决方案：由于读者只是读取文本文件中的数据而不改变它，可以允许多个读者同时访问文本文件。实际上，即使有多个读者同时从文本文件中获取数据，数据也不会以任何方式改变，因此数据的一致性和准确性得到了维护。
- en: Following this approach, we will implement a specification in which no reader
    will be kept waiting if the shared resource is being opened for reading by another
    reader. Specifically, in addition to a lock on the shared resource, we will also
    have a counter for the number of readers currently accessing the resource. If,
    at any point in the program, that counter goes from zero to one (in other words,
    at least one reader is starting to access the resource), we will lock the resource
    from the writers; similarly, whenever the counter decreases to zero (in other
    words, no reader is asking for access to the resource), we will release the lock
    on the resource, so that writers can access it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们将实现一个规范，其中如果共享资源正在被另一个读者打开进行读取，那么不会让任何读者等待。具体来说，除了对共享资源的锁定，我们还将有一个计数器，用于记录当前正在访问资源的读者数量。如果在程序的任何时刻，该计数器从零增加到一（换句话说，至少有一个读者开始访问资源），我们将锁定资源，使写者无法访问；同样，每当计数器减少到零（换句话说，没有读者请求访问资源），我们将释放对资源的锁定，以便写者可以访问它。
- en: This specification is efficient for the readers, in the sense that, once the
    first reader has accessed the resource and placed a lock on it, no writers can
    access it, and the subsequent readers will not have to re-lock it until the last
    reader finishes reading the resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范对读者来说是高效的，因为一旦第一个读者访问了资源并对其进行了锁定，就没有写者可以访问它，而后续的读者在最后一个读者完成对资源的阅读之前不必重新对其进行锁定。
- en: 'Let us try to implement this solution in Python. If you have already downloaded
    the code for this book from the GitHub page, go ahead and navigate to the `Chapter13`
    folder. Let us take a look at the `Chapter13/example1.py` file; specifically,
    the `writer()` and `reader()` functions, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Python中实现这个解决方案。如果你已经从GitHub页面下载了本书的代码，请前往`Chapter13`文件夹。让我们看一下`Chapter13/example1.py`文件；具体来说，是`writer()`和`reader()`函数，如下所示：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding script, the `writer()` function, which is to be called by
    a `threading.Thread` instance (in other words, a separate thread), specifies the
    logic of the writer threads that we discussed previously: accessing the shared
    resource (in this case, the global variable, `text`, which is simply a Python
    string) and writing some data to the resource. Note that we are putting all of
    its instructions inside a `while` loop, to simulate the constant nature of the
    application (writers and readers constantly try to access the shared resource).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，`writer()`函数由`threading.Thread`实例（换句话说，一个单独的线程）调用，指定了我们之前讨论的写者线程的逻辑：访问共享资源（在本例中是全局变量`text`，它只是一个Python字符串）并向资源写入一些数据。请注意，我们将所有指令放在一个`while`循环中，以模拟应用程序的不断性质（写者和读者不断尝试访问共享资源）。
- en: We can also see the reader logic in the `reader()` function. Before asking for
    access to the shared resource, each reader will increment a counter for the number
    of readers that are currently active and trying to access the resource. Similarly,
    after reading data off the file, each reader needs to decrement the number of
    readers. During this process, if a reader is the first reader to access the file
    (in other words, when the counter is one), it will put a lock on the file, so
    that no writers can access it; conversely, when a reader is the last reader to
    read the file, it has to release that lock.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`reader()`函数中看到读者逻辑。在请求访问共享资源之前，每个读者都会增加一个当前活动并试图访问资源的读者数量的计数器。类似地，在从文件中读取数据后，每个读者都需要减少读者的数量。在这个过程中，如果一个读者是第一个访问文件的读者（换句话说，当计数器为1时），它将对文件进行锁定，以便没有写者可以访问它；相反，当一个读者是最后一个读者读取文件时，它必须释放该锁。
- en: 'One note about the handling of that counter of readers: you might have noticed
    that we are using a lock object named `rcounter` when incrementing/decrementing
    the counter variable (`rcount`). This is a method that is used to avoid a race
    condition, which is another common concurrency-related problem, for the counter
    variable; specifically, without the lock, multiple threads can be accessing and
    altering the counter variable at the same time, but the only way to ensure the
    integrity of the data is for this counter variable to be handled sequentially.
    We will discuss race conditions (and the practice that is used to avoid them)
    in more detail in the next chapter.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于读者计数器的处理，你可能已经注意到我们在增加/减少计数器变量（`rcount`）时使用了一个名为`rcounter`的锁对象。这是一种方法，用来避免计数器变量的竞争条件，这是另一个常见的并发相关问题；具体来说，没有锁定，多个线程可以同时访问和修改计数器变量，但确保数据的完整性的唯一方法是按顺序处理这个计数器变量。我们将在下一章更详细地讨论竞争条件（以及用于避免它们的实践）。
- en: 'Going back to our current script, in the main program, we will set up the `text`
    variable, the counter for readers, and two lock objects (for the reader counter
    and the shared resource, respectively). We are also initializing and starting
    three reader threads and two writer threads, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们当前的脚本，在主程序中，我们将设置`text`变量，读者计数器和两个锁对象（分别用于读者计数器和共享资源）。我们还初始化并启动了三个读者线程和两个写者线程，如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note that, since the instructions of the reader and writer
    threads are both wrapped in `while` loops, the script, when started, will run
    infinitely. You should cancel the Python execution after around 3-4 seconds, when
    enough output has been produced so that the general behavior of the program can
    be observed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，由于读者和写者线程的指令都包裹在`while`循环中，因此当启动脚本时，它将无限运行。在产生足够的输出以观察程序的一般行为后，应在大约3-4秒后取消Python执行。
- en: 'The following code shows the first few lines of output that I obtained after
    running the script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本后，以下代码显示了我获得的输出的前几行：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, there is a specific pattern in the preceding output: all of
    the threads that were accessing the shared resource were readers. In fact, throughout
    my entire output, no writer was able to access the file, and therefore, the `text`
    variable only contains the initial string, `This is some text.`, and was not altered
    in any way. The output that you obtain should also have the same pattern (the
    shared resource not being altered).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在前面的输出中有一个特定的模式：所有访问共享资源的线程都是读者。实际上，在我整个输出中，没有写者能够访问文件，因此`text`变量只包含初始字符串`This
    is some text.`，并且没有以任何方式进行修改。你获得的输出也应该具有相同的模式（共享资源未被修改）。
- en: In this case, the writers are experiencing starvation, as none of them are able
    to access and use the resource. This is a direct result of our scheduling algorithm;
    since multiple readers are allowed to access the text file simultaneously, if
    there are multiple readers accessing the text file frequently enough, it will
    create a continuous stream of readers going through the text file, giving no room
    for a writer to attempt to access the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，写者们正在经历饥饿，因为他们都无法访问和使用资源。这是我们调度算法的直接结果；由于允许多个读者同时访问文本文件，如果有多个读者频繁访问文本文件，将会创建一个连续的读者流通过文本文件，不给写者尝试访问文件留下空间。
- en: This scheduling algorithm inadvertently gives priority to the readers over the
    writers, and is therefore called **readers-preference**. So, this design is undesirable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调度算法无意中给了读者优先于写者，因此被称为**读者优先**。因此，这种设计是不可取的。
- en: The second readers-writers problem
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个读者-写者问题
- en: The problem with the first approach is that, when a reader is accessing the
    text file and a writer is waiting for the file to be unlocked, if another reader
    starts its execution and wants to access the file, it will be given priority over
    the writer that has already been waiting. Additionally, if more and more readers
    keep requesting access to the file, the writer will be waiting infinitely, and
    that was what we observed in our first code example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法的问题在于，当一个读者正在访问文本文件并且一个写者正在等待文件被解锁时，如果另一个读者开始执行并且想要访问文件，它将优先于已经等待的写者。此外，如果越来越多的读者继续请求访问文件，写者将无限等待，这就是我们在第一个代码示例中观察到的情况。
- en: To address this problem, we will implement the specification that, once a writer
    makes a request to access the file, no reader should be able to jump in line and
    access the file before that writer. To do this, we will have an additional lock
    object in our program, to specify whether a writer is waiting for the file, and
    consequently, whether a reader thread can attempt to read the file; we will call
    this lock `read_try`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将实现规范，即一旦写者请求访问文件，就不应该有读者能够插队并在该写者之前访问文件。为此，我们将在程序中添加一个额外的锁对象，以指定是否有写者正在等待文件，因此是否读者线程可以尝试读取文件；我们将称这个锁为`read_try`。
- en: Similar to how the first of the readers accessing the text file always locks
    it from the writers, we will now have the first writer of the multiple that are
    waiting to access the file lock `read_try`, so that no reader can, again, jump
    in line before those writers that requested access before it. As we discussed
    in reference to the readers, since we are keeping track of the number of writers
    waiting for the text file, we will need to implement a counter for the number
    of writers, and its corresponding lock, in our program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个读者总是锁定文本文件不同，我们现在将等待访问文件的多个写者中的第一个写者锁定`read_try`，以便没有读者可以再次在它之前请求访问的那些写者之前插队。正如我们在读者方面讨论的那样，由于我们正在跟踪等待文本文件的写者数量，我们需要在程序中实现写者数量及其相应的锁的计数器。
- en: 'The `Chapter13/example2.py` file contains the code for this implementation,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter13/example2.py`文件包含了此实现的代码，如下所示：'
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compared to our first solution to the problem, the main program remains relatively
    the same (except for the initialization of the `read_try` lock, the `wcount` counter,
    and its lock, `wcounter`), but in our `writer()` function, we are locking `read_try`
    as soon as there is at least one writer waiting to access the file; when the last
    writer finishes its execution, it will release the lock, so that any reader waiting
    for the file can now access it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对问题的第一个解决方案相比，主程序保持相对不变（除了初始化`read_try`锁、`wcount`计数器及其锁`wcounter`之外），但在我们的`writer()`函数中，一旦有至少一个写者等待访问文件，我们就会锁定`read_try`；当最后一个写者完成执行时，它将释放锁，以便任何等待文件的读者现在可以访问它。
- en: 'Again, to see the output produced by the program, we will have it run for 3-4
    seconds, and then cancel the execution, as the program would otherwise run forever.
    The following is the output that I obtained via this script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了查看程序产生的输出，我们将让它运行3-4秒，然后取消执行，因为程序否则将永远运行。以下是我通过此脚本获得的输出：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It can be observed that, while some readers were able to access the text file
    (indicated by the first four lines of my output), once a writer gained access
    to the shared resource, no reader was able to access it anymore. The rest of my
    output included messages about writing instructions: `Writing being done by`,
    and so on. As opposed to what we saw in the first solution of the readers-writers
    problem, this solution is giving priority to writers, and, as a consequence, the
    readers are starved. This is therefore called **writers-preference**.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，虽然一些读者能够访问文本文件（由我的输出的前四行表示），但一旦写者获得对共享资源的访问权，就再也没有读者能够访问它了。我的输出的其余部分包括有关写入指令的消息：`Writing
    being done by`等等。与我们在读者-写者问题的第一个解决方案中看到的情况相反，这个解决方案给了写者优先权，因此读者被饿死。因此，这被称为**写者优先**。
- en: The priority that writers were given over readers resulted from the fact that,
    while only the first and the last writers have to acquire and release the `read_try`
    lock, respectively, each and every reader wanting to access the text file have
    to interact with that lock object individually. Once `read_try` is locked by a
    writer, no reader can even attempt to execute its instructions, let alone try
    to access the text file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 写者优先于读者的优先级是由于只有第一个和最后一个写者必须分别获取和释放`read_try`锁，而每个想要访问文本文件的读者都必须单独与该锁对象交互。一旦`read_try`被写者锁定，没有读者甚至可以尝试执行其指令，更不用说尝试访问文本文件了。
- en: There are cases in which some readers are able to gain access to the text file,
    if the readers are initialized and executed before the writers (for example, in
    our program, the readers were the first three elements, and the writers were the
    last two, in our list of threads). However, once a writer is able to access the
    file and acquire the `read_try` lock during its execution, starvation will most
    likely occur for the readers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，如果读者在写者之前初始化并执行（例如，在我们的程序中，读者是前三个元素，写者是线程列表中的最后两个），则一些读者可以访问文本文件。然而，一旦写者能够在执行期间访问文件并获取`read_try`锁，读者很可能会饿死。
- en: This solution is also not desirable, as it gives higher priority to the writer
    threads in our program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案也不理想，因为它在我们的程序中给了写者线程更高的优先级。
- en: The third readers-writers problem
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三个读者-写者问题
- en: You have seen that both of the solutions that we tried to implement can result
    in starvation, by not giving equal priorities to the separate threads; one can
    starve the writers, and the other can starve the readers. A balance between these
    two approaches might give us an implementation with equal priorities among the
    readers and writers, and hence, solve the problem of starvation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到我们尝试实现的两种解决方案都可能导致饥饿，因为没有给予不同线程相等的优先级；一种可能会使写入者饿死，另一种可能会使读者饿死。这两种方法之间的平衡可能会给我们一个实现，使读者和写者之间具有相等的优先级，从而解决饥饿问题。
- en: 'Recall this: in our second approach, we are placing a lock on a reader''s attempt
    to access the text file, requiring that no writer will be starved once it starts
    waiting for the file. In this solution, we will implement a lock that also utilizes
    this logic, but is then applied to both readers and writers. All of the threads
    will then be subjected to the constraints of the lock, and equal priority will
    hence be achieved among the separate threads.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下：在我们的第二种方法中，我们在读者尝试访问文本文件时放置了一个锁，要求一旦写者开始等待文件，就不会使其饿死。在这个解决方案中，我们将实现一个锁，该锁也利用这种逻辑，但然后应用于读者和写者。然后，所有线程将受到锁的约束，因此在不同线程之间将实现相等的优先级。
- en: Specifically, this is a lock that specifies whether a thread will be given access
    to the text file at a given moment; we will call this the **service lock**. Each
    writer or reader has to try to acquire this service lock before executing any
    of its instructions. A writer, having obtained this service lock, will also attempt
    to obtain the resource lock and release the service lock immediately thereafter.
    The writer will then execute its writing logic and finally release the resource
    lock at the end of its execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这是一个锁，指定在特定时刻是否允许线程访问文本文件；我们将其称为**服务锁**。每个写者或读者在执行任何指令之前都必须尝试获取此服务锁。写者在获得此服务锁后，还将尝试获取资源锁，并立即释放服务锁。然后，写者将执行其写入逻辑，并最终在执行结束时释放资源锁。
- en: 'Let us take a look at the `writer()` function in the `Chapter13/example3.py`
    file for our implementation in Python, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Chapter13/example3.py`文件中我们在Python中的实现的`writer()`函数，如下所示：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A reader, on the other hand, will also need to acquire the service lock first.
    Since we are still allowing multiple readers to access the resource at the same
    time, we are implementing the reader counter and its corresponding lock.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，读者也需要首先获取服务锁。由于我们仍然允许多个读者同时访问资源，我们正在实现读者计数器及其相应的锁。
- en: The reader will acquire the service lock and the counter lock, increment the
    reader counter (and potentially, lock the resource), and then release the service
    lock and counter lock, sequentially. Now, it will actually read data off the text
    file, and finally, it will decrement the reader counter, and will potentially
    release the resource lock, if it is the last reader to access the file at that
    time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 读者将获取服务锁和计数器锁，增加读者计数器（可能锁定资源），然后依次释放服务锁和计数器锁。现在，它将实际从文本文件中读取数据，最后，它将减少读者计数器，并在那时是最后一个读者访问文件时，可能释放资源锁。
- en: 'The `reader()` function contains this specification, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader()`函数包含以下规范：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in our main program, we initialize the text string, the reader counter,
    all of the necessary locks, and the reader and writer threads, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主程序中，我们初始化文本字符串、读者计数器、所有必要的锁以及读者和写者线程，如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that, we are commenting the code that prints out the current content of
    the text file in the `reader()` function for readability for our output later
    on. Run the program for 3-4 seconds, and then cancel it. The following output
    is what I obtained on my personal computer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在对`reader()`函数中打印文本文件当前内容的代码进行注释，以便后续输出更易读。运行程序3-4秒，然后取消。以下输出是我在我的个人电脑上获得的：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pattern that we have with this current output is that the readers and writers
    are able to access the shared resource cooperatively and efficiently; all of the
    readers and writers are executing their instructions, and no thread is being starved
    by this scheduling algorithm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前输出的模式是，读者和写者能够合作和高效地访问共享资源；所有读者和写者都在执行其指令，没有线程被这个调度算法饿死。
- en: Note that as you work with a reader-writer problem in your concurrent program,
    you do not have to reinvent the wheel regarding the approaches that we just discussed.
    PyPI actually has an external library called `readerwriterlock` that contains
    the implementation of the three approaches in Python, as well as supports for
    timeouts. Navigate to [https://pypi.org/project/readerwriterlock/](https://pypi.org/project/readerwriterlock/) to
    find out more about the library and its documentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您在并发程序中处理读者-写者问题时，您不必重新发明我们刚刚讨论的方法。PyPI实际上有一个名为`readerwriterlock`的外部库，其中包含了Python中三种方法的实现，以及对超时的支持。访问[https://pypi.org/project/readerwriterlock/](https://pypi.org/project/readerwriterlock/)了解更多关于该库及其文档的信息。
- en: Solutions to starvation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 饥饿的解决方案
- en: 'Through an analysis of different approaches to the readers-writers problem,
    you have seen the key to solving starvation: since some threads will be starved
    if they are not given a high priority in accessing the shared resources, implementing
    fairness in the execution of all of the threads will prevent starvation from occurring.
    Fairness, in this case, does not require a program to forgo any order or priority
    that it has imposed on the different threads; but to implement fairness, a program
    needs to ensure that all threads are given sufficient opportunities to execute
    their instructions.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析不同的读者-写者问题的方法，您已经看到解决饥饿的关键：由于如果某些线程在访问共享资源时没有得到高优先级，它们将会被饿死，因此在所有线程的执行中实施公平性将防止饥饿的发生。在这种情况下，公平性并不要求程序放弃对不同线程施加的任何顺序或优先级；但为了实施公平性，程序需要确保所有线程有足够的机会执行它们的指令。
- en: 'Keeping this idea in mind, we can potentially address the problem of starvation
    by implementing one (or a combination) of the following approaches:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这个想法，我们可以通过实施以下方法之一（或组合）来解决饥饿问题：
- en: '**Increasing the priority of low-priority threads**: As we did with the writer
    threads in the second approach and the reader threads in the third approach to
    the readers-writers problem, prioritizing the threads that would otherwise not
    have any opportunity to access the shared resource can successfully eliminate
    starvation.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加低优先级线程的优先级**：就像我们在读者-写者问题的第二种方法中对写者线程和第三种方法中对读者线程所做的那样，优先考虑那些本来没有机会访问共享资源的线程，可以成功地消除饥饿。'
- en: '**First-in-first-out thread queue**: To ensure that a thread that started waiting
    for the shared resource before another thread will be able to acquire the resource
    before the other thread, we can keep track of the threads requesting access in
    a first-in-first-out queue.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先进先出线程队列**：为了确保一个线程在另一个线程之前开始等待共享资源，可以跟踪请求访问的线程，并将其保存在先进先出队列中。'
- en: '**Other methods**: Several methods can also be implemented to balance the selection
    frequency of different threads. For example, a priority queue that also gives
    gradually increasing priority to threads that have been waiting in the queue for
    a long time, or if a thread has been able to access the shared resource for many
    times, it will be given less priority, and so on.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他方法**：还可以实施几种方法来平衡不同线程的选择频率。例如，一个优先级队列也会逐渐增加等待时间较长的线程的优先级，或者如果一个线程能够多次访问共享资源，它将被给予较低的优先级，依此类推。'
- en: Solving starvation in your concurrent program can be a rather complex and involved
    process, and a deep understanding of its scheduling algorithm, combined with an
    understanding of how processes and threads interact with the shared resources,
    is necessary during the process. As you saw in the example of the readers-writers
    problem, it can also take several implementations and revisions of different approaches
    to arrive at a good solution to starvation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决并发程序中的饥饿问题可能是一个相当复杂和涉及深入理解调度算法的过程，结合对进程和线程如何与共享资源交互的理解在这个过程中是必要的。正如您在读者-写者问题的示例中所看到的，解决饥饿问题可能需要多种实现和不同方法的修订，才能得到一个好的解决方案。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Starvation is a problem in concurrent systems in which a process (or thread)
    cannot gain access to the necessary resources to proceed with its execution and,
    therefore, cannot make any progress. Most of the time, a poorly coordinated set
    of scheduling instructions is the main cause of starvation; deadlock situations
    can also lead to starvation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 饥饿是并发系统中的一个问题，其中一个进程（或线程）无法获得必要的资源来继续执行，因此无法取得任何进展。大多数情况下，调度指令的不良协调是饥饿的主要原因；死锁情况也会导致饥饿。
- en: The readers-writers problem is one of the classic and most complex examples
    in the field of computer science, illustrating problems that might occur in a
    concurrent program. Through an analysis of different approaches to the readers-writers
    problem, you have gained insight regarding how starvation can be solved with different
    scheduling algorithms. Fairness is an essential element of a good scheduling algorithm,
    and, by making sure that the priority is distributed appropriately among different
    processes and threads, starvation can be eliminated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 读者-写者问题是计算机科学领域中经典和最复杂的例子之一，它说明了并发程序中可能出现的问题。通过分析不同的读者-写者问题的方法，您已经了解到如何使用不同的调度算法解决饥饿问题。公平性是一个良好调度算法的重要元素，通过确保优先级在不同进程和线程之间适当分配，可以消除饥饿。
- en: 'In the next chapter, we will discuss the last of the three common problems
    of concurrent programming: race conditions. We will cover the basic foundation
    and causes of race conditions, relevant concepts, and the connection of race conditions
    to other concurrency-related problems.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并发编程的三个常见问题中的最后一个：竞争条件。我们将涵盖竞争条件的基本基础和原因，相关概念，以及竞争条件与其他并发相关问题的联系。
- en: Questions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is starvation, and why is it undesirable in a concurrent program?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是饥饿，为什么在并发程序中是不可取的？
- en: What are the underlying causes of starvation? What are the common high-level
    causes of starvation that can manifest from the underlying cause?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饥饿的根本原因是什么？可以从根本原因中产生的饥饿的常见高级原因是什么？
- en: What is the connection between deadlock and starvation?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁和饥饿之间有什么联系？
- en: What is the readers-writers problem?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是读者-写者问题？
- en: What is the first approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第一种方法是什么？为什么在那种情况下会出现饥饿？
- en: What is the second approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第二种方法是什么？为什么在那种情况下会出现饥饿？
- en: What is the third approach to the readers-writers problem? Why does it successfully
    address starvation?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者-写者问题的第三种方法是什么？为什么它成功地解决了饥饿问题？
- en: What are some common solutions to starvation?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饥饿的一些常见解决方案是什么？
- en: Further reading
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Parallel Programming with Python*, by Jan Palach, Packt Publishing Ltd, 2014'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用Python进行并行编程》，作者Jan Palach，Packt Publishing Ltd，2014
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python并行编程食谱》，作者Giancarlo Zaccone，Packt Publishing Ltd，2015
- en: '*Starvation and Fairness* ([tutorials.jenkov.com/java-concurrency/starvation-and-fairness](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html)),
    by Jakob Jenkov'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《饥饿和公平》（tutorials.jenkov.com/java-concurrency/starvation-and-fairness），作者Jakob
    Jenkov
- en: '*Faster Fair Solution for the Reader-Writer Problem*, V.Popov and O.Mazonka'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《读者-写者问题的更快公平解决方案》，V.Popov和O.Mazonka
