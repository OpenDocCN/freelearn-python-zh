- en: Chapter 21
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21章
- en: Tips and Tricks with Decision Control Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 决策控制结构的技巧和窍门
- en: 21.1 Introduction
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1 简介
- en: This chapter is dedicated to teaching you some useful tips and tricks that can
    help you write “better” code. You should always keep them in mind when you design
    your own algorithms, or even your own Python programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于教你一些有用的技巧和窍门，这些技巧和窍门可以帮助你编写“更好”的代码。在设计你自己的算法或甚至你自己的Python程序时，你应该始终牢记这些技巧。
- en: These tips and tricks can help you increase your code's readability and help
    make the code shorter or even faster. Of course there is no single perfect methodology
    because on one occasion the use of a specific tip or trick may help, but on another
    occasion the same tip or trick may have exactly the opposite result. Most of the
    time, code optimization is a matter of programming experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧和窍门可以帮助你提高代码的可读性，并帮助使代码更短甚至更快。当然，没有单一完美的方法，因为有时使用特定的技巧或窍门可能会有帮助，但在另一种情况下，同样的技巧或窍门可能会有完全相反的结果。大多数时候，代码优化是编程经验的问题。
- en: '![](img/remember.jpg)Smaller algorithms are not always the best solution to
    a given problem. In order to solve a specific problem, you might write a very
    short algorithm that unfortunately proves to consume a lot of CPU time. On the
    other hand, you may solve the same problem with another algorithm which, even
    though it seems longer, calculates the result much faster.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/remember.jpg)较小的算法并不总是解决特定问题的最佳方案。为了解决特定的问题，你可能编写一个非常短的算法，不幸的是，这个算法证明消耗了大量的CPU时间。另一方面，你可能用另一个算法解决相同的问题，尽管它看起来更长，但计算结果要快得多。'
- en: 21.2 Choosing a Decision Control Structure
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2 选择决策控制结构
- en: The following diagram can help you decide which decision control structure is
    a better choice for a given problem depending on the number of variables checked.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下图可以帮助你根据检查的变量数量决定哪种决策控制结构更适合给定的问题。
- en: '![Image](img/chapter21-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter21-01.png)'
- en: '![](img/notice.jpg)This diagram recommends the best option, not the only option.
    For example, when there are more than two cases for one variable, it is not wrong
    to use a nested decision control structure instead. The proposed multiple-alternative
    decision structure, though, is more convenient.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/notice.jpg)此图推荐最佳选项，而非唯一选项。例如，当有一个变量有超过两个情况时，使用嵌套决策控制结构并非错误。然而，所提出的多重选择决策结构更为方便。'
- en: 21.3 Streamlining the Decision Control Structure
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3 简化决策控制结构
- en: Look carefully at the following flowchart fragment given in general form.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看以下给出的通用形式的流程图片段。
- en: '![Image](img/chapter21-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter21-02.png)'
- en: As you can see, two identical statements or blocks of statements exist at the
    beginning and two other identical statements or blocks of statements exist at
    the end of both paths of the dual-alternative decision structure. This means that,
    regardless of the result of Boolean_Expression, these statements are executed
    either way. Thus, you can simply move them outside and (respectively) right before
    and right after the dual-alternative decision structure, as shown in this equivalent
    structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在双分支决策控制结构的两条路径的开始和结束处都存在两个相同的语句或语句块。这意味着，无论布尔表达式的结果如何，这些语句都会被执行。因此，你可以简单地将它们移到外面，以及（分别）在双分支决策控制结构之前和之后，如图所示的这个等效结构。
- en: '![Image](img/chapter21-03.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter21-03.png)'
- en: '![](img/notice.jpg)The same tip can be applied to any decision control structure,
    as long as an identical statement or block of statements exists in all paths.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/notice.jpg)同样的技巧可以应用于任何决策控制结构，只要所有路径中存在相同的语句或语句块。'
- en: '![](img/notice.jpg)There are cases where this tip cannot be applied. For instance,
    you cannot move a statement (or block of statements) right before the decision
    control structure if this statement affects the Boolean expression of the structure.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/notice.jpg)有些情况下，这个技巧不能应用。例如，如果你不能移动一个语句（或语句块）在决策控制结构之前，如果这个语句影响了结构的布尔表达式。'
- en: Are you still confused? Next, you will find some exercises that can help you
    to understand better.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还是感到困惑吗？接下来，你将找到一些练习，可以帮助你更好地理解。
- en: Exercise 21.3-1 “Shrinking” the Algorithm
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.3-1 “缩小”算法
- en: Redesign the following flowchart using fewer statements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更少的语句重新设计以下流程图。
- en: '![Image](img/chapter21-04.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter21-04.png)'
- en: Solution
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: As you can see, the statement y ← a * 2 exists in both paths of the dual-alternative
    decision structure. This means that, regardless of the result of the Boolean expression,
    this statement is executed either way. Therefore, you can simply move the statement
    outside and right before the dual-alternative decision structure, as follows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，语句 y ← a * 2 存在于双分支决策结构的两条路径中。这意味着，无论布尔表达式的结果如何，这个语句都会被执行。因此，你可以简单地将这个语句移动到双分支决策结构的外面，并在其前面，如下所示。
- en: '![Image](img/chapter21-05.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-05.png)'
- en: Exercise 21.3-2 “Shrinking” the Python Program
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.3-2 “缩小” Python 程序
- en: Rewrite the following Python program using fewer statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更少的语句重写以下 Python 程序。
- en: a = int(input())
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 0:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y = a * 4
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: y = a * 4
- en: print(y)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 'else:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: y = a * 3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: y = a * 3
- en: print(y)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: Solution
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: As you can see, the statement print(y) exists in both paths of the dual-alternative
    decision structure. This means that, regardless of the result of the Boolean expression,
    this statement is executed either way. Therefore, you can simply move the statement
    outside and right after the dual-alternative decision structure, as shown here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，语句 print(y) 存在于双分支决策结构的两条路径中。这意味着，无论布尔表达式的结果如何，这个语句都会被执行。因此，你可以简单地将这个语句移动到双分支决策结构的外面，并紧随其后，如下所示。
- en: a = int(input())
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 0:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y = a * 4
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: y = a * 4
- en: 'else:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: y = a * 3
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: y = a * 3
- en: print(y)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: Exercise 21.3-3 “Shrinking” the Algorithm
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.3-3 “缩小” 算法
- en: Redesign the following flowchart using fewer statements and then write the corresponding
    Python program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更少的语句重新设计以下流程图，然后编写相应的 Python 程序。
- en: '![Image](img/chapter21-06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-06.png)'
- en: Solution
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: If you try to move the Write y statement outside of the multiple-alternative
    decision structure, the resulting flowchart that follows is definitely not equivalent
    to the initial one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将写入 y 语句移出多分支决策结构，得到的流程图肯定与初始的流程图不等价。
- en: '![Image](img/chapter21-07.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-07.png)'
- en: This is because of the last path on the right side which, in the initial flowchart,
    didn't include the Write y statement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为右侧的最后一条路径，在初始流程图中没有包含写入 y 语句。
- en: Examine both flowcharts to see whether they produce the same result. For example,
    suppose a user enters a wrong number. In both flowcharts, the flow of execution
    goes to the Write "Wrong Number" statement. After that, the initial flowchart
    executes no other statements whereas, the second flowchart executes an extra Write
    y statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个流程图是否产生相同的结果。例如，假设用户输入了一个错误的数字。在两个流程图中，执行流程都会转到写入 "Wrong Number" 语句。之后，初始流程图不再执行其他语句，而第二个流程图则执行了一个额外的写入
    y 语句。
- en: '![](img/remember.jpg)You cannot move a statement or block of statements outside
    of a decision control structure if it does not exist in all paths.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)你不能将一个语句或语句块移出决策控制结构之外，如果它在所有路径中都不存在。'
- en: You may now wonder whether there is any other way to move the Write y statement
    outside of the multiple-alternative decision structure. The answer is “yes”, but
    you need to slightly rearrange the flowchart. You need to completely remove the
    last path on the right and use a brand new decision control structure in the beginning
    to check whether or not the user-provided number is wrong. One possible solution
    is shown here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道是否还有其他方法可以将写入 y 语句移出多分支决策结构。答案是“是的”，但你需要稍微调整流程图。你需要完全移除右侧的最后一条路径，并在开始时使用一个新的决策控制结构来检查用户提供的数字是否错误。一个可能的解决方案如下。
- en: '![Image](img/chapter21-08.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-08.png)'
- en: and the Python program is
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序如下
- en: a = float(input())
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: 'if a >= 30:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a >= 30:'
- en: print("Wrong Number")
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: print("Wrong Number")
- en: 'else:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'if a < 10:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a < 10:'
- en: y = a * 2
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = a * 2
- en: 'elif a < 20:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif a < 20:'
- en: y = a / 2
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = a / 2
- en: 'else:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: y = a + 2
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = a + 2
- en: print(y)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: '21.4 Logical Operators – to Use, or not to Use: That is the Question!'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4 逻辑运算符 – 使用与否：这是一个问题！
- en: There are some cases in which you can use a logical operator instead of nested
    decision control structures, and this can lead to increased readability. Take
    a look at the following flowchart fragment given in general form.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以使用逻辑运算符而不是嵌套的决策控制结构，这可以提高可读性。看看以下给出的通用形式的流程图片段。
- en: '![Image](img/chapter21-09.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-09.png)'
- en: As you can see, the statement or block of statements 1 is executed only when
    both Boolean expressions evaluate to True. The statement or block of statements
    2 is executed in all other cases. Therefore, this flowchart fragment can be redesigned
    using the AND logical operator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，语句或语句块1仅在两个布尔表达式都评估为真时执行。语句或语句块2在所有其他情况下执行。因此，可以使用AND逻辑运算符重新设计此流程图片段。
- en: '![Image](img/chapter21-10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-10.png)'
- en: Now, let's take a look at another flowchart fragment given in general form.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个以一般形式给出的流程图片段。
- en: '![Image](img/chapter21-11.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-11.png)'
- en: In this flowchart fragment, the statement or block of statements 2 is executed
    when either Boolean_Expression_1 evaluates to True or Boolean_Expression_2 evaluates
    to True. Therefore, you can redesign this flowchart fragment using the OR logical
    operator as shown here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此流程图片段中，当布尔表达式_1或布尔表达式_2评估为真时，执行语句或语句块2。因此，可以使用OR逻辑运算符重新设计此流程图片段，如下所示。
- en: '![Image](img/chapter21-12.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-12.png)'
- en: '![](img/notice.jpg)Obviously, these methodologies can be adapted to be used
    on nested decision control structures as well.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/notice.jpg](img/notice.jpg)显然，这些方法也可以适应用于嵌套决策控制结构。'
- en: Exercise 21.4-1 Rewriting the Code
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.4-1 代码重写
- en: Rewrite the following Python program using logical operators.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符重写以下Python程序。
- en: today = input()
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: today = input()
- en: name = input()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: name = input()
- en: 'if today == "February 16":'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天是"February 16"：
- en: 'if name == "Loukia":'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 name == "Loukia"：
- en: print("Happy Birthday!!!")
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印("Happy Birthday!!!")
- en: 'else:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("No match!")
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印("No match!")
- en: 'else:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("No match!")
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("No match!")
- en: Solution
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The print("Happy Birthday!!!") statement is executed only when both Boolean
    expressions evaluate to True. The statement print("No match!") is executed in
    all other cases. Therefore, you can rewrite the Python program using the and logical
    operator.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个布尔表达式都评估为真时，执行打印("Happy Birthday!!!")语句。当所有其他情况下，执行打印("No match!")语句。因此，可以使用and逻辑运算符重写Python程序。
- en: today = input()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: today = input()
- en: name = input()
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: name = input()
- en: 'if today == "February 16" and name == "Loukia":'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天是"February 16"并且名字是"Loukia"：
- en: print("Happy Birthday!!!")
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("Happy Birthday!!!")
- en: 'else:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("No match!")
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("No match!")
- en: Exercise 21.4-2 Rewriting the Code
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.4-2 代码重写
- en: Rewrite the following Python program using logical operators.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符重写以下Python程序。
- en: a = int(input())
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: y = 0
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 10:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a > 10：
- en: y += 1
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: y += 1
- en: 'elif b > 20:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif b > 20:'
- en: y += 1
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: y += 1
- en: 'else:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: y -= 1
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: y -= 1
- en: print(y)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(y)
- en: Solution
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The y += 1 statement is executed when either variable a is greater than 10 or
    variable b is greater than 20\. Therefore, you can rewrite the Python program
    using the or logical operator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量a大于10或变量b大于20时，执行y += 1语句。因此，你可以使用or逻辑运算符重写Python程序。
- en: a = int(input())
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: y = 0
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 10 or b > 20:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a > 10 或 b > 20：
- en: y += 1
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: y += 1
- en: 'else:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: y -= 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: y -= 1
- en: print(y)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(y)
- en: 21.5 Merging Two or More Single-Alternative Decision Structures
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5 合并两个或更多单分支决策结构
- en: Sometimes, you may design an algorithm that contains two or more single-alternative
    decision structures in a row, each of which evaluates the same Boolean expression.
    An example is shown here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能设计一个包含两个或更多连续单分支决策结构的算法，每个都评估相同的布尔表达式。以下是一个示例。
- en: '![Image](img/chapter21-13.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-13.png)'
- en: When a situation like this occurs, you can just merge all single-alternative
    decision structures to a single one, as follows.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现这种情况时，你可以将所有单分支决策结构合并为一个，如下所示。
- en: '![Image](img/chapter21-14.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter21-14.png)'
- en: '![](img/remember.jpg)The single-alternative decision structures need to be
    adjacent to each other. If any statement exists between them, you can''t merge
    them unless you are able to move this statement to somewhere else in your code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/remember.jpg](img/remember.jpg)单分支决策结构需要彼此相邻。如果它们之间有任何语句，除非你能将这个语句移动到代码的另一个地方，否则你不能合并它们。'
- en: Exercise 21.5-1 Merging the Decision Control Structures
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.5-1 合并决策控制结构
- en: In the following Python program, merge the single-alternative decision structures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下Python程序中，合并单分支决策结构。
- en: a = int(input())
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 0:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a > 0：
- en: print("Hello")
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("Hello")
- en: 'if a > 0:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a > 0：
- en: print("Hermes")
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("Hermes")
- en: Solution
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The first and second decision control structures are evaluating exactly the
    same Boolean expressions, so they can simply be merged into a single one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个决策控制结构正在评估完全相同的布尔表达式，因此它们可以简单地合并成一个。
- en: The Python program becomes
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序变为
- en: a = int(input())
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 0:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: print("Hello")
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello")
- en: print("Hermes")
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hermes")
- en: Exercise 21.5-2 Merging the Decision Control Structures
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 21.5-2 合并决策控制结构
- en: In the following Python program, merge as many single-alternative decision structures
    as possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Python 程序中，尽可能多地合并单分支决策结构。
- en: a = int(input())
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: y = 0
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 0:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y += a + 1
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: y += a + 1
- en: b = int(input())     [[More…]](more.html#more_21_5_2_1)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())     [[更多…]](more.html#more_21_5_2_1)
- en: 'if not(a <= 0):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '如果不是(a <= 0):'
- en: print("Hello Hera")
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Hera")
- en: a += 1     [[More…]](more.html#more_21_5_2_2)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: a += 1     [[更多…]](more.html#more_21_5_2_2)
- en: 'if a > 0:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: print("Hallo Welt")
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hallo Welt")
- en: print(y)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: Solution
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Upon closer examination, it's evident that the first and second decision control
    structures are evaluating exactly the same Boolean expression. Specifically, negating
    a > 0 gives a <= 0, and a second negation of a <= 0 (using the not operator this
    time) yields not(a <= 0). Thus, a > 0 is in fact equivalent to not(a <= 0).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察后，很明显第一个和第二个决策控制结构正在评估完全相同的布尔表达式。具体来说，否定 a > 0 得到 a <= 0，a <= 0 的第二次否定（这次使用
    not 操作符）得到 not(a <= 0)。因此，a > 0 实际上等同于 not(a <= 0)。
- en: '![](img/remember.jpg)Two negations result in an affirmative.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![记住](img/remember.jpg)两次否定产生肯定。'
- en: However, between the first and second decision control structures there is the
    statement b = int(input()), which prevents you from merging them into a single
    one. Fortunately, this statement can be moved to the beginning of the program
    since it doesn't really affect the rest of the flow of execution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第一个和第二个决策控制结构之间有语句 b = int(input())，这阻止了你将它们合并成一个。幸运的是，这个语句可以被移动到程序的开头，因为它实际上不影响执行流程的其余部分。
- en: On the other hand, between the second and third decision control structures
    there is the statement a += 1, which also prevents you from merging; unfortunately,
    this statement cannot be moved anywhere else because it does affect the rest of
    the flow of execution (the second and third decision control structures are dependent
    upon this statement). Thus, the third decision control structure cannot be merged
    with the first and second ones!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在第二个和第三个决策控制结构之间有语句 a += 1，这也阻止了你合并；不幸的是，这个语句不能移动到其他地方，因为它确实影响了执行流程的其余部分（第二个和第三个决策控制结构依赖于这个语句）。因此，第三个决策控制结构不能与第一个和第二个合并！
- en: The final Python program looks like this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 Python 程序看起来是这样的。
- en: a = int(input())
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: y = 0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 0:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y += a + 1
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: y += a + 1
- en: print("Hello Hera")
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Hera")
- en: a += 1
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: a += 1
- en: 'if a > 0:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: print("Hallo Welt")
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hallo Welt")
- en: print(y)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 21.6 Replacing Two Single-Alternative Decision Structures with a Dual-Alternative
    One
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.6 将两个单分支决策结构替换为双分支结构
- en: Take a look at the next example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下一个例子。
- en: 'if x > 40:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 40:'
- en: '#Do something'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#做某事'
- en: 'if x <= 40:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x <= 40:'
- en: '#Do something else'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '#做其他事情'
- en: The first decision control structure evaluates variable x to test if it is bigger
    than 40, and right after that, a second decision control structure evaluates the
    same variable again to test if it is less than or equal to 40!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个决策控制结构评估变量 x 以测试它是否大于 40，紧接着，第二个决策控制结构再次评估同一个变量以测试它是否小于或等于 40！
- en: This is a very common “mistake” that novice programmers make. They use two single-alternative
    decision structures even though one dual-alternative decision structure can accomplish
    the same thing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种新手程序员非常常见的“错误”。他们使用两个单分支决策结构，尽管一个双分支决策结构就能完成相同的事情。
- en: The previous example can be rewritten using only one dual-alternative decision
    structure, as shown here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子可以用一个双分支决策结构重写，如下所示。
- en: 'if x > 40:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 40:'
- en: '#Do something'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#做某事'
- en: 'else:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '#Do something else'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#做其他事情'
- en: Even though both examples are absolutely correct and work perfectly well, the
    second alternative is better. The CPU needs to evaluate only one Boolean expression,
    which results in faster execution time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个例子都是绝对正确的并且工作得很好，但第二个方案更好。CPU 只需要评估一个布尔表达式，这会导致更快的执行时间。
- en: '![](img/notice.jpg)The two single-alternative decision structures must be adjacent
    to each other. If any statement exists between them, you can''t “merge” them (that
    is, replace them with a dual-alternative decision structure) unless you can move
    this statement to somewhere else in your code.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)两个单分支决策结构必须相邻。如果它们之间有任何语句存在，你不能“合并”它们（即用双分支决策结构替换它们），除非你可以将这个语句移动到代码的其他地方。'
- en: Exercise 21.6-1 “Merging” the Decision Control Structures
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习21.6-1 “合并”决策控制结构
- en: In the following Python program, “merge” as many single-alternative decision
    structures as possible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的Python程序中，尽可能多地“合并”单分支决策结构。
- en: a = int(input())
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: y = 0
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 0:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y += a
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: y += a
- en: b = int(input())
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: 'if not(a > 0):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not(a > 0):'
- en: print("Hello Zeus")
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Zeus")
- en: 'if y > 0:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y > 0:'
- en: print(y + 5)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: print(y + 5)
- en: y += a
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: y += a
- en: 'if y <= 0:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y <= 0:'
- en: print(y + 12)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: print(y + 12)
- en: Solution
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: The first decision control structure evaluates variable a to test if it is greater
    than zero, and just right after that the second decision control structure evaluates
    variable a again to test if it is not greater than zero. Even though there is
    the statement b = int(input()) between them, this statement can be moved somewhere
    else because it doesn't really affect the rest of the flow of execution. Therefore,
    the first and second decision control structures can be merged!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个决策控制结构评估变量a以测试它是否大于零，紧接着第二个决策控制结构再次评估变量a以测试它是否不大于零。尽管它们之间有b = int(input())这个语句，但这个语句可以被移动到其他地方，因为它实际上不影响执行流程的其余部分。因此，第一个和第二个决策控制结构可以被合并！
- en: On the other hand, between the third and fourth decision control structures
    there is the statement y += a which prevents you from merging. This statement
    cannot be moved anywhere else because it does affect the rest of the flow of execution
    (the third and fourth decision control structures are dependent upon this statement).
    Therefore, the third and fourth decision control structures cannot be merged!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在第三个和第四个决策控制结构之间有y += a这个语句，这阻止了你合并。这个语句不能移动到其他地方，因为它确实影响了执行流程的其余部分（第三个和第四个决策控制结构依赖于这个语句）。因此，第三个和第四个决策控制结构不能合并！
- en: The final Python program becomes
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的Python程序变为
- en: a = int(input())
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: y = 0
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 0:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y += a
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: y += a
- en: 'else:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Hello Zeus")
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Zeus")
- en: 'if y > 0:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y > 0:'
- en: print(y + 5)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print(y + 5)
- en: y += a
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: y += a
- en: 'if y <= 0:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y <= 0:'
- en: print(y + 12)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: print(y + 12)
- en: 21.7 Put the Boolean Expressions Most Likely to be True First
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.7 将最可能为真的布尔表达式放在最前面
- en: The multiple-alternative decision structure often needs to check several Boolean
    expressions before deciding which statement or block of statements to execute.
    In the next decision control structure,
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 多分支决策结构通常需要在决定执行哪个语句或语句块之前检查几个布尔表达式。在下一个决策控制结构中，
- en: 'if Boolean_Expression_1:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if Boolean_Expression_1:'
- en: A statement or block of statements 1
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第1个语句或语句块
- en: 'elif Boolean_Expression_2:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif Boolean_Expression_2:'
- en: A statement or block of statements 2
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第2个语句或语句块
- en: 'elif Boolean_Expression_3:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif Boolean_Expression_3:'
- en: A statement or block of statements 3
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第3个语句或语句块
- en: the program first tests if Boolean_Expression_1 is True. If not, it tests if
    Boolean_Expression_2 is True, and if not, it tests Boolean_Expression_3\. However,
    what if Boolean_Expression_1 is False most of the time and Boolean_Expression_3
    is True most of the time? This means that time is wasted testing Boolean_Expression_1,
    which is usually False, before testing Boolean_Expression_3, which is usually
    True.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先测试布尔表达式Boolean_Expression_1是否为真。如果不是，它测试布尔表达式Boolean_Expression_2是否为真，如果不是，它测试布尔表达式Boolean_Expression_3。然而，如果布尔表达式Boolean_Expression_1大部分时间都是假的，而布尔表达式Boolean_Expression_3大部分时间都是真的，这意味着在测试通常为真的布尔表达式Boolean_Expression_3之前，浪费了测试通常为假的布尔表达式Boolean_Expression_1的时间。
- en: To make your programs more efficient, you can put the Boolean expressions that
    are most likely to be True at the beginning, and the Boolean expressions that
    are most likely to be False at the end, as follows.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的程序更高效，你可以将最可能为真的布尔表达式放在前面，最可能为假的布尔表达式放在后面，如下所示。
- en: 'if Boolean_Expression_3:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'if Boolean_Expression_3:'
- en: A statement or block of statements 3
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第3个语句或语句块
- en: 'elif Boolean_Expression_2:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif Boolean_Expression_2:'
- en: A statement or block of statements 2
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第2个语句或语句块
- en: 'elif Boolean_Expression_1:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif Boolean_Expression_1:'
- en: A statement or block of statements 1
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第1个语句或语句块
- en: '![](img/remember.jpg)Although this change may seem nonessential, every little
    bit of time that you save can add up to make your programs run faster and more
    efficiently.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)尽管这种改变可能看起来并不重要，但节省的每一丁点时间都可以让你的程序运行得更快、更高效。'
- en: Exercise 21.7-1 Rearranging the Boolean Expressions
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习21.7-1 重新排列布尔表达式
- en: According to research, America's favorite pets are dogs, with cats at second
    place, guinea pigs next, and parrots coming in last. In the following Python program,
    rearrange the Boolean expressions to make the program run faster and more efficiently
    for most of the cases.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 根据研究，美国最受欢迎的宠物是狗，其次是猫，接下来是豚鼠，鹦鹉排在最后。在下面的Python程序中，重新排列布尔表达式，使程序在大多数情况下运行更快、更高效。
- en: kind = input("What is your favorite pet? ")
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: kind = input("你最喜欢的宠物是什么？ ")
- en: 'if kind == "Parrots":'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'if kind == "Parrots":'
- en: print("It screeches!")
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: print("它尖叫！")
- en: 'elif kind == "Guinea pig":'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Guinea pig":'
- en: print("It squeaks")
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: print("它吱吱叫")
- en: 'elif kind == "Dog":'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Dog":'
- en: print("It barks")
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: print("它汪汪叫")
- en: 'elif kind == "Cat":'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Cat":'
- en: print("It meows")
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print("它喵喵叫")
- en: Solution
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: For this research, you can rearrange the Python program to make it run a little
    bit faster for most of the cases.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项研究，你可以重新排列Python程序，使其在大多数情况下运行得更快。
- en: kind = input("What is your favorite pet? ")
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: kind = input("你最喜欢的宠物是什么？ ")
- en: 'if kind == "Dog":'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'if kind == "Dog":'
- en: print("It barks")
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: print("它汪汪叫")
- en: 'elif kind == "Cat":'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Cat":'
- en: print("It meows")
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: print("它喵喵叫")
- en: 'elif kind == "Guinea pig":'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Guinea pig":'
- en: print("It squeaks")
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: print("它吱吱叫")
- en: 'elif kind == "Parrots":'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif kind == "Parrots":'
- en: print("It screeches!")
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: print("它尖叫！")
- en: '21.8 Review Questions: True/False'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.8 复习问题：判断题
- en: Choose true or false for each of the following statements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 选择以下每个陈述的真假。
- en: 1)Smaller algorithms are always the best solution to a given problem.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 1)较小的算法总是给定问题的最佳解决方案。
- en: 2)You can always move a statement outside, and right before, a dual-alternative
    decision structure as long as it exists at the beginning of both paths of the
    decision structure.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 2)只要它在决策结构的两条路径的开始处存在，你就可以始终将一个语句移到双选择决策结构之前。
- en: 3)You can always use a logical operator instead of nested decision control structures
    to increase readability.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 3)你可以始终使用逻辑运算符而不是嵌套决策控制结构来提高可读性。
- en: 4)Two single-alternative decision structures can be merged into one single-alternative
    decision only when they are in a row and when they evaluate equivalent Boolean
    expressions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 4)只有当两个单选择决策结构连续排列并且评估等价的布尔表达式时，它们才能合并为一个单选择决策结构。
- en: 5)Conversion from a dual-alternative decision structure to two single-alternative
    decision structures is always possible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 5)将双选择决策结构转换为两个单选择决策结构总是可能的。
- en: 6)Two single-alternative decision structures can be replaced by one dual-alternative
    decision only when they are in a row and only when they evaluate the same Boolean
    expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 6)只有当两个单选择决策结构连续排列并且评估相同的布尔表达式时，它们才能被一个双选择决策结构所替代。
- en: '21.9 Review Questions: Multiple Choice'
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.9 复习问题：多项选择题
- en: Select the correct answer for each of the following statements.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 选择以下每个陈述的正确答案。
- en: 1)The following two programs
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 1)以下两个程序
- en: a = int(input())
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 40:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 2)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: a += 1
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: a += 1
- en: 'else:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(a * 2)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: a += 5
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: a += 5
- en: a = int(input())
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: print(a * 2)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: 'if a > 40:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: a += 1
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: a += 1
- en: 'else:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: a += 5
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: a += 5
- en: a)produce the same result.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: a)产生相同的结果。
- en: b)do not produce the same result.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: b)不会产生相同的结果。
- en: c)none of the above
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: c)以上都不是
- en: 2)The following two programs
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2)以下两个程序
- en: a = int(input())
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 40:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 2)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: 'if a > 40:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 3)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 3)
- en: a = int(input())
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 40:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 2)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: print(a * 3)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 3)
- en: a)produce the same results, but the left program is faster.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: a)产生相同的结果，但左边的程序更快。
- en: b)produce the same results, but the right program is faster.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: b)产生相同的结果，但正确的程序更快。
- en: c)do not produce the same results.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: c)不会产生相同的结果。
- en: d)none of the above
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: d)以上都不是
- en: 3)The following two programs
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 3)以下两个程序
- en: a = int(input())
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 40:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 2)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: 'else:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(a * 3)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 3)
- en: a = int(input())
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: 'if a > 40:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 40:'
- en: print(a * 2)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 2)
- en: 'if a <= 40:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a <= 40:'
- en: print(a * 3)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: print(a * 3)
- en: a)produce the same result(s), but the left program is faster.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: a)产生相同的结果，但左边的程序更快。
- en: b)produce the same result(s), but the right program is faster.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: b)产生相同的结果，但正确的程序更快。
- en: c)do not produce the same result(s).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: c)不会产生相同的结果。
- en: d)none of the above
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: d)以上都不是
- en: 21.10 Review Exercises
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.10 复习练习
- en: Complete the following exercises.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习。
- en: 1)Rewrite the following Python program using fewer statements.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 1)使用更少的语句重写以下Python程序。
- en: y = int(input())
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())
- en: 'if y > 0:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y > 0:'
- en: x = int(input())
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: a = x * 4 * y
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: a = x * 4 * y
- en: print(y)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: a += 1
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: a += 1
- en: 'else:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: x = int(input())
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: a = x * 2 * y + 7
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: a = x * 2 * y + 7
- en: print(y)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: a -= 1
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: a -= 1
- en: print(a)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: print(a)
- en: 2)Redesign the following flowchart using fewer statements.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 2)使用更少的语句重新设计以下流程图。
- en: '![Image](img/chapter21-15.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter21-15.png)'
- en: 3)Rewrite the following Python program using fewer statements.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 3)使用更少的语句重写以下Python程序。
- en: a = float(input())
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: 'if a < 1:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a < 1:'
- en: y = 5 + a
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: y = 5 + a
- en: print(y)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 'elif a < 5:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif a < 5:'
- en: y = 23 / a
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: y = 23 / a
- en: print(y)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 'elif a < 10:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif a < 10:'
- en: y = 5 * a
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: y = 5 * a
- en: print(y)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 'else:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Error!")
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: print("错误！")
- en: 4)Rewrite the following Python program using logical operators.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 4)使用逻辑运算符重写以下Python程序。
- en: day = int(input())
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: day = int(input())
- en: month = int(input())
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: month = int(input())
- en: name = input()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: name = input()
- en: 'if day == 16:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'if day == 16:'
- en: 'if month == 2:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'if month == 2:'
- en: 'if name == "Loukia":'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if name == "Loukia":'
- en: print("Happy Birthday!!!")
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("生日快乐！！！")
- en: 'else:'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("No match!")
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("没有匹配！")
- en: 'else:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("No match!")
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("没有匹配！")
- en: 'else:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("No match!")
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: print("没有匹配！")
- en: 5)A teacher asks her students to rewrite the following Python program without
    using logical operators.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 5)一位老师要求她的学生重写以下Python程序，不使用逻辑运算符。
- en: a = float(input())
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: b = float(input())
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: b = float(input())
- en: c = float(input())
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: c = float(input())
- en: 'if a > 10 and c < 2000:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 10 and c < 2000:'
- en: d = (a + b + c) / 12
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: d = (a + b + c) / 12
- en: print("The result is:", d)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: print("结果是：", d)
- en: 'else:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Error!")
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: print("错误！")
- en: 'One student wrote the following Python program:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一名学生编写了以下Python程序：
- en: a = float(input())
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: b = float(input())
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: b = float(input())
- en: c = float(input())
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: c = float(input())
- en: 'if a > 10:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 10:'
- en: 'if c < 2000:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'if c < 2000:'
- en: d = (a + b + c) / 12
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d = (a + b + c) / 12
- en: print("The result is:", d)
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("结果是：", d)
- en: 'else:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Error!")
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误！")
- en: Determine if the program operates the same way for all possible paths as the
    one provided by the teacher. If not, try to modify it and make it work the same
    way.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 确定程序对于所有可能的路径是否与老师提供的程序操作方式相同。如果不相同，尝试修改它并使其以相同的方式工作。
- en: 6)Rewrite the following Python program using only single-alternative decision
    structures.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 6)使用单分支决策结构重写以下Python程序。
- en: a = float(input())
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: b = float(input())
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: b = float(input())
- en: c = float(input())
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: c = float(input())
- en: 'if a > 10:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 10:'
- en: 'if b < 2000:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'if b < 2000:'
- en: 'if c != 10:'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if c != 10:'
- en: d = (a + b + c) / 12
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d = (a + b + c) / 12
- en: print("The result is:", d)
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("结果是：", d)
- en: 'else:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Error!")
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: print("错误！")
- en: 7)In the following Python program, replace the two single-alternative decision
    structures by one dual-alternative decision structure.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 7)在以下Python程序中，将两个单分支决策结构替换为一个双分支决策结构。
- en: a = int(input())
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: y = 3
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: y = 3
- en: 'if a > 0:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y = y * a
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: y = y * a
- en: b = int(input())
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: 'if not(a <= 0):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not(a <= 0):'
- en: print("Hello Zeus")
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: print("你好，宙斯")
- en: print(y, b)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: print(y, b)
- en: 8)Rewrite the following Python program, using only one dual-alternative decision
    structure.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 8)使用一个双分支决策结构重写以下Python程序。
- en: a = float(input())
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: a = float(input())
- en: y = 0
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0
- en: 'if a > 0:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > 0:'
- en: y = y + 7
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: y = y + 7
- en: b = float(input())
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: b = float(input())
- en: 'if not(a > 0):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not(a > 0):'
- en: print("Hello Zeus")
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: print("你好，宙斯")
- en: 'if a <= 0:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a <= 0:'
- en: print(abs(a))
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: print(abs(a))
- en: print(y)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: print(y)
- en: 9)According to research from 2013, the most popular operating system on tablet
    computers was iOS, with Android being in second place and Microsoft Windows in
    last place. In the following Python program, rearrange the Boolean expressions
    to make the program run more efficiently for most of the cases.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 9)根据2013年的研究，平板电脑上最受欢迎的操作系统是iOS，其次是Android，最后是微软Windows。在以下Python程序中，重新排列布尔表达式，使程序在大多数情况下运行更高效。
- en: os = input("What is your tablet's OS? ")
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: os = input("你的平板电脑的操作系统是什么？")
- en: 'if os == "Windows":'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'if os == "Windows":'
- en: print("Microsoft")
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: print("微软")
- en: 'elif os == "iOS":'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif os == "iOS":'
- en: print("Apple")
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: print("苹果")
- en: 'elif os == "Android":'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif os == "Android":'
- en: print("Google")
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: print("谷歌")
