- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Designing Jeeves
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Jeeves
- en: In *Chapter 1*, *Understanding Microservices*, we said that the natural way
    to build a microservices-based app is to start with a monolithic version that
    implements all the features, and then to split it into microservices that make
    the most sense. When you are designing software, you have enough to worry about
    with the flow of information through the system, meeting requirements, and working
    out how it all fits together. Having a design that encounters reality is when
    you start getting a good idea of what types of components you should have, and
    as you gain experience, it will become easier to spot potential microservices
    earlier on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*理解微服务*中，我们提到构建基于微服务的应用的自然方式是从实现所有功能的单体版本开始，然后将其拆分为最有意义的微服务。当你设计软件时，你需要担心的事情很多，包括信息在系统中的流动、满足需求以及弄清楚所有部分如何配合。当设计遇到现实时，你开始对应该拥有哪些类型的组件有一个良好的认识，随着经验的积累，你将更容易在早期就发现潜在的微服务。
- en: In this chapter, we will go through this process by building a monolithic application
    and implementing the required features. We will cover how each component works
    and why it's there, as well as how information flows through the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过构建单体应用并实现所需功能来经历这个过程。我们将涵盖每个组件的工作原理以及为什么它存在，以及信息如何在系统中流动。
- en: 'The chapter is organized into two main sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个主要部分：
- en: Presentation of our application and its user stories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用及其用户故事的介绍
- en: How Jeeves can be built as a monolithic application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Jeeves构建为一个单体应用
- en: Of course, in reality, the splitting process happens over time once the monolithic
    app design has some time to mature. But for the purpose of this book, we'll assume
    that the first version of the application has been used for a while and offered
    us some insights as to how it can be split in the right way, thanks to our time
    machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实中，拆分过程是在单体应用设计经过一段时间成熟后逐渐发生的。但为了本书的目的，我们将假设应用的第一版已经使用了一段时间，并为我们提供了关于如何正确拆分的见解，这要归功于我们的时间机器。
- en: The Jeeves bot
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jeeves机器人
- en: '**Jeeves** is an example application that was created for this book. Don''t
    look for it in the Apple or Play Store, as it''s not released or deployed for
    real users.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jeeves**是本书创建的一个示例应用。不要在苹果或谷歌应用商店中寻找它，因为它尚未发布或部署给真实用户。'
- en: 'However, the application does work, and you can study its different components
    on GitHub in the PythonMicroservices organization: [https://github.com/PythonMicroservices/](https://github.com/PythonMicroservices/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用确实可以工作，你可以在GitHub的PythonMicroservices组织中研究其不同的组件：[https://github.com/PythonMicroservices/](https://github.com/PythonMicroservices/)。
- en: We will be connecting to Slack, a popular communication platform, primarily
    used to send text messages in channels, similar to the older IRC service. Jeeves
    will be our personal assistant—a name taken from the stories of *P. G. Wodehouse*—and
    used for other software bots and at least one search engine. We will be using
    the name for its familiarity and not because of any connection with other people's
    work. The Jeeves presented here offers an interactive service to users of a Slack
    workspace and can be easily adapted to other chat environments. It also offers
    a web view to configure essential settings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接到Slack，这是一个流行的通信平台，主要用于在频道中发送文本消息，类似于较老的IRC服务。Jeeves将是我们的人工智能助手——这个名字来源于P.
    G. Wodehouse的故事——用于其他软件机器人以及至少一个搜索引擎。我们使用这个名字是因为它的熟悉度，而不是因为它与其他人的工作有任何联系。这里展示的Jeeves为Slack工作空间的用户提供了一种交互式服务，并且可以轻松地适应其他聊天环境。它还提供了一个网页视图来配置基本设置。
- en: Once Jeeves is connected to a Slack workspace, a user can send the bot messages
    and receive replies. Users can also visit the web page and register for any third-party
    services they might need to connect to thanks to the standard OAuth2 mechanism.
    See more at [https://oauth.net/2/](https://oauth.net/2/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Jeeves连接到Slack工作空间，用户就可以向机器人发送消息并接收回复。用户还可以访问网页并注册他们可能需要连接的任何第三方服务，这要归功于标准的OAuth2机制。更多信息请参阅[https://oauth.net/2/](https://oauth.net/2/)。
- en: We will be using **Strava** ([https://www.strava.com](https://www.strava.com))
    as an example of a third-party site, although this could easily be GitHub, Google
    services, Atlassian's JIRA, or some other useful service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以**Strava** ([https://www.strava.com](https://www.strava.com))作为一个第三方网站的例子，尽管这同样可以容易地是GitHub、谷歌服务、Atlassian的JIRA或其他一些有用的服务。
- en: The OAuth2 standard is based on the idea of authorizing a third-party application
    to call a service with an access token that is unique to the user of the service.
    The token is generated by the service and usually has a limited scope in what
    calls can be performed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2标准基于授权第三方应用程序使用具有用户服务唯一访问令牌调用服务的想法。令牌由服务生成，通常具有有限的调用范围。
- en: Let's dive into the features through their user stories.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过它们的使用故事深入了解功能。
- en: User stories
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户故事
- en: Firstly, what should our application do? A good way to describe our goals is
    by covering the desired behavior in different scenarios. If you've been involved
    in Agile development before, this will be familiar in the guise of "user stories."
    User stories are very simple descriptions of all the interactions a user can have
    with an application, and is often the first high-level document that is written
    when a project starts, as some of the stories appear in the justification or proposal
    for the work to begin.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的应用程序应该做什么？描述我们的目标的一个好方法是通过覆盖不同场景中期望的行为。如果你之前参与过敏捷开发，这将以“用户故事”的形式熟悉。用户故事是对用户可以与应用程序进行的所有交互的非常简单的描述，通常是项目开始时编写的第一份高级文档，因为一些故事出现在开始工作的理由或提案中。
- en: 'Attempting to fill lots of detail early on can also make life harder; start
    with high-level stories and add detail as they are revisited. Sometimes a user
    story might be discarded if it''s not feasible—it depends very much on how the
    work progresses and on the feasibility of each idea. User stories are also helpful
    to detect when it''s worth splitting a feature into its microservice: a story
    that stands on its own could be a good candidate.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 试图一开始就填充大量细节也可能使生活变得更困难；从高级故事开始，并在回顾时添加细节。有时，如果某个用户故事不可行，它可能会被丢弃——这非常取决于工作的进展以及每个想法的可行性。用户故事还有助于检测何时值得将一个功能拆分为其微服务：一个独立存在的用户故事可能是一个很好的候选者。
- en: 'For Jeeves, we can start with this small set:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Jeeves，我们可以从以下这个小集合开始：
- en: As a Slack workspace user, I can send messages to a bot and get updates about
    the weather without leaving Slack
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Slack工作空间用户，我可以向机器人发送消息并获取关于天气的更新，而无需离开Slack
- en: As a Slack workspace user, I expect the bot to remember facts that I have told
    it about myself, such as my location
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Slack工作空间用户，我期望机器人能记住我告诉它的关于我的事实，例如我的位置
- en: As a Slack workspace user, I can visit the bot's control panel and authenticate
    third-party services, such as GitHub and Strava
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Slack工作空间用户，我可以访问机器人的控制面板并验证第三方服务，例如GitHub和Strava
- en: As an admin of the bot, I can get statistics regarding the bot's usage
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为机器人的管理员，我可以获取有关机器人使用情况的统计数据
- en: As an admin of the bot, I can disable or change the configuration of various
    features
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为机器人的管理员，我可以禁用或更改各种功能的配置
- en: As a user, I can create an account on a third-party site that the bot knows
    about, and then use the bot to perform tasks there
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以在机器人所知的第三方网站上创建账户，然后使用机器人执行那里的任务
- en: 'There are already a few components emerging from this set of user stories.
    In no particular order, these are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个用户故事集合中已经出现了一些组件。不分先后，如下所示：
- en: The app needs to store the contents of some types of messages it receives. These
    may be stored against a specific Slack identity.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要存储它接收到的某些类型消息的内容。这些内容可能针对特定的Slack身份进行存储。
- en: A user should be able to navigate to a web interface for third-party site authentication.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够导航到第三方网站认证的Web界面。
- en: The app will authenticate web users with a password or a URL with a provided
    token.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序将使用密码或提供的令牌的URL对Web用户进行身份验证。
- en: The app should be able to perform periodic scheduled tasks to alert the user
    if a condition is true, such as for bad weather.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该能够执行周期性的计划任务，如果条件为真，则提醒用户，例如恶劣天气。
- en: These descriptions are enough to get us started. The next section describes
    how the application can be designed and coded.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些描述足以让我们开始。下一节将描述应用程序的设计和编码方式。
- en: Monolithic design
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一架构
- en: This section presents extracts from the source code of the monolithic version
    of Jeeves. If you want to study it in detail, then the whole application can be
    found at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了 Jeeves 单体版本源代码的摘录。如果您想详细了解，整个应用程序可以在[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith)找到。
- en: The first thing to consider is the retrieval of data from Slack into our application.
    There will be a single endpoint for this, as Slack sends all its events to the
    URL that the application developer configures. Later on, we can also add other
    endpoints to work with other environments, such as IRC, Microsoft Teams, or Discord.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是从 Slack 中检索数据到我们的应用程序。为此将有一个单独的端点，因为 Slack 将所有事件发送到应用程序开发者配置的 URL。稍后，我们还可以添加其他端点来处理其他环境，例如
    IRC、Microsoft Teams 或 Discord。
- en: We will also need a small interface to allow people to adjust the settings outside
    Slack, as controlling third-party authentication tokens and updating permissions
    for those tools is much easier using a web page. We will also need a small database
    to store all this information, along with other settings that we want our microservice
    to have.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个小的界面，以便人们可以在 Slack 之外调整设置，因为使用网页控制第三方身份验证令牌和更新这些工具的权限要容易得多。我们还需要一个小型数据库来存储所有这些信息，以及我们希望我们的微服务拥有的其他设置。
- en: Lastly, we will need some code to actually perform the actions our bot should
    do on behalf of the person who has sent it messages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一些代码来实际执行我们的机器人代表发送消息的人应该执行的操作。
- en: 'A design pattern that is often referred to when building applications is the
    **Model-View-Controller** (**MVC**) pattern, which separates the code into three
    parts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建应用程序时，经常提到的一个设计模式是 **模型-视图-控制器**（**MVC**）模式，它将代码分为三个部分：
- en: '**Model**: This manages the data'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：管理数据'
- en: '**View**: This displays the model for a particular context (web view, PDF view,
    and so on)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：显示特定上下文（网页视图、PDF 视图等）的模型'
- en: '**Controller**: This manipulates the model to change its state'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：通过操作模型来改变其状态'
- en: '`SQLAlchemy` is a library that can aid with the model part, allowing us to
    specify tables, relationships, and wrappers around reading and writing data in
    our Python source code. In a microservice, the view and controller distinction
    can be a bit vague, because what is called a view is a function that receives
    a request and sends back a response—and that function can both display and manipulate
    the data, allowing it to act as both a View and as a Controller.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLAlchemy` 是一个库，可以帮助我们处理模型部分，允许我们在 Python 源代码中指定表、关系以及读取和写入数据的包装器。在微服务中，视图和控制器的区别可能有些模糊，因为所谓的视图是一个接收请求并发送响应的函数——这个函数既可以显示也可以操作数据，使其既能作为视图也能作为控制器。'
- en: The Django project uses **Model-View-Template** (**MVT**) to describe that pattern,
    where View is the Python callable, and Template is the template engine, or whatever
    is in charge of producing a response in a particular format, given some data.
    `Quart` uses Jinja2 for all sorts of useful template rendering—most commonly generating
    HTML and filling in the contents with values that it obtains from variables using
    the `render_template()` function. We will use this approach for views that present
    data to a human; for API views that return JSON, we will use `json.dumps()` to
    generate the response. In any case, the first step of designing our application
    is to define the model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django 项目使用 **模型-视图-模板**（**MVT**）来描述这种模式，其中视图是 Python 可调用函数，模板是模板引擎，或者负责以特定格式生成响应的任何东西。`Quart`
    使用 Jinja2 进行各种有用的模板渲染——最常见的是生成 HTML，并使用 `render_template()` 函数从变量中获取值来填充内容。我们将使用这种方法来展示向人类展示数据的视图；对于返回
    JSON 的 API 视图，我们将使用 `json.dumps()` 来生成响应。在任何情况下，设计我们应用程序的第一步是定义模型。
- en: Model
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'In a `Quart` application based on SQLAlchemy, the model is described through
    classes, which represent the database schema. For Jeeves, the database tables
    are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 SQLAlchemy 的 `Quart` 应用程序中，模型通过类来描述，这些类代表了数据库模式。对于 Jeeves，数据库表包括：
- en: '**User**: This contains information about each user, including their credentials'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：包含有关每个用户的信息，包括他们的凭证'
- en: '**Service**: This is a list of the available services the bot can provide,
    and whether or not they are active'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这是一个列表，列出了机器人可以提供的服务以及它们是否处于活动状态'
- en: '**Log**: A log of bot activity'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：机器人活动日志'
- en: 'Using the **SQLAlchemy** ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))
    library, each table is created as a subclass of the base class provided by the
    module, allowing us to avoid duplicating effort and leaving the classes in our
    own code clean and focused on the data that we want to work with. SQLAlchemy has
    asynchronous interfaces that can be used to keep the performance benefits of our
    async application while accessing the database. To use these features, we must
    install both `sqlalchemy` and `aiosqlite`. The full example can be found in the
    code samples'' GitHub repository as the `sqlachemy-async.py` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**SQLAlchemy** ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/))库，每个表都作为模块提供的基类的子类创建，这使我们能够避免重复工作，并使我们的代码保持干净，专注于我们想要处理的数据。SQLAlchemy具有异步接口，可以在访问数据库时保持异步应用程序的性能优势。要使用这些功能，我们必须安装`sqlalchemy`和`aiosqlite`。完整的示例可以在代码样本的GitHub存储库中找到，作为`sqlachemy-async.py`文件：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `User` table mostly stores some Unicode strings, but it's also worth noting
    the two `Boolean` values that guarantee that we do not need to interpret another
    system's way of storing `True` and `False`. There is also a JSON column for storing
    entire data structures—a feature available in an increasing number of backend
    databases, including PostgreSQL and SQLite.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`表主要存储一些Unicode字符串，但值得注意的是两个`Boolean`值，它们保证了我们不需要解释另一个系统存储`True`和`False`的方式。还有一个JSON列用于存储整个数据结构——这是一个在越来越多的后端数据库中可用的功能，包括PostgreSQL和SQLite。'
- en: When used in a `Quart` app, SQLAlchemy allows us to write an interface to avoid
    writing SQL directly; instead, we can call functions that query and filter the
    data. We can go one step further and create a **data access layer** (**DAL**)
    that handles all of the database session management for us. In the following code,
    we have written an access layer that can be used as a context manager, while providing
    methods to create and find users. The `create_user` method is simply using the
    model we defined previously to create a new Python object—without all the fields,
    to make the example clearer—and then adding it to the database session, ensuring
    the data has been written out before returning the value written to the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Quart`应用中使用时，SQLAlchemy允许我们编写一个接口来避免直接编写SQL；相反，我们可以调用查询和过滤数据的函数。我们可以更进一步，创建一个**数据访问层**（**DAL**），为我们处理所有的数据库会话管理。在下面的代码中，我们编写了一个可以作为上下文管理器使用的访问层，同时提供了创建和查找用户的方法。`create_user`方法只是简单地使用我们之前定义的模型来创建一个新的Python对象——不包含所有字段，以使示例更清晰——然后将它添加到数据库会话中，确保数据在返回数据库写入的值之前已经写入。
- en: 'Building on that, we can then use the `get_all_users` method to return all
    the records stored using the `User` model, using `select()` to retrieve them,
    and `get_user` to return just one record, while using the `where` method to filter
    the results to only display the ones that match the argument provided:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在这一点上，我们可以使用`get_all_users`方法返回使用`User`模型存储的所有记录，使用`select()`来检索它们，并使用`get_user`返回单个记录，同时使用`where`方法过滤结果，只显示与提供的参数匹配的记录：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the DAL set up, we can use a feature provided by Python''s own `contextlib`
    to create an asynchronous context manager:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了DAL之后，我们可以使用Python自带的`contextlib`提供的功能来创建一个异步上下文管理器：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All of this is a lot to set up, but once done, it allows us to access any of
    the data stored behind the `User` model with only a context manager to control
    the database session. We will use all this code in our views.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置起来可能很多，但一旦完成，它就允许我们仅通过上下文管理器来控制数据库会话，就可以访问`User`模型后面存储的任何数据。我们将在我们的视图中使用所有这些代码。
- en: View and template
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看和模板
- en: 'When a request is received, a view is invoked through the URL mapping, and
    we can use the context manager we created above to query and update the database.
    The following `Quart` view will allow us to view all the users in the database
    when the `/users` endpoint is queried:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到请求时，通过URL映射调用视图，我们可以使用上面创建的上下文管理器来查询和更新数据库。以下`Quart`视图将允许我们在查询`/users`端点时查看数据库中的所有用户：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the `user_dal` context is created, we gain access to all the methods within
    it, and so we can easily call the `get_all_users` method and return the values
    to the client. Let''s put all of the above together into one example application,
    adding in some of our missing fields:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `user_dal` 上下文时，我们可以访问其中的所有方法，因此我们可以轻松调用 `get_all_users` 方法并将值返回给客户端。让我们将上述所有内容组合成一个示例应用程序，并添加一些缺失的字段：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A human-readable view
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类可读的视图
- en: 'If we were to want this information presented in an easily readable format,
    we could use a Jinja2 template and pass the results of the query to fill in the
    details:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要以易于阅读的格式呈现这些信息，我们可以使用 Jinja2 模板并将查询结果传递以填写详细信息：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Without any configuration to tell it otherwise, Jinja looks for its templates
    in a subdirectory of the Python application called `templates/`, which is often
    enough for small applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有配置来告诉它否则，Jinja 会在其 Python 应用程序的 `templates/` 子目录中查找模板，这对于小型应用程序来说通常足够了。
- en: 'Our `users.html` template has some HTML in it, but also some directives that
    are bounded by curly braces. There is a `for` loop that allows us to iterate over
    the data that is passed to the template, and we can see that instructions sent
    to Jinja are surrounded by `{% and %}`. Another common instruction in a template
    would be `{% if … %}` to only include a piece of text if the condition is true.
    Inside the `for` loop, we see some variable expansions inside `{{` and `}}`, signaling
    to Jinja that it should look for a variable with that name. It''s possible to
    apply filters to variables, which is especially useful when formatting dates.
    Here is a simple template that loops over all of the users it is given and displays
    both their email address and Slack ID:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `users.html` 模板中包含了一些 HTML 代码，但也包含了一些由花括号包围的指令。有一个 `for` 循环允许我们遍历传递给模板的数据，我们可以看到发送给
    Jinja 的指令被 `{%` 和 `%}` 包围。模板中的另一个常见指令是 `{% if … %}`，它只会在条件为真时包含一段文本。在 `for` 循环中，我们看到了一些变量扩展在
    `{{` 和 `}}` 内，这表明 Jinja 应该寻找具有该名称的变量。可以对变量应用过滤器，这在格式化日期时特别有用。以下是一个简单的模板，它遍历所有提供的用户并显示他们的电子邮件地址和
    Slack ID：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For editing data through the web, WTForms can be used to generate forms for
    each model. WTForms is a library that generates HTML forms with Python definitions,
    takes care of extracting data from incoming requests, and validating them before
    you update your model. Find out more at [http://wtforms.readthedocs.io](http://wtforms.readthedocs.io).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络编辑数据时，可以使用 WTForms 为每个模型生成表单。WTForms 是一个库，它使用 Python 定义生成 HTML 表单，负责从传入的请求中提取数据，并在更新模型之前对其进行验证。了解更多信息请访问
    [http://wtforms.readthedocs.io](http://wtforms.readthedocs.io)。
- en: The Flask-WTF project wraps WTForms for `Quart` and adds some useful integration,
    such as securing forms with **Cross-Site Request Forgery** (**CSRF**) tokens.
    Find out more at [https://flask-wtf.readthedocs.io/](https://flask-wtf.readthedocs.io/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-WTF 项目为 `Quart` 包装了 WTForms，并添加了一些有用的集成，例如使用 **跨站请求伪造**（**CSRF**）令牌来保护表单。了解更多信息请访问
    [https://flask-wtf.readthedocs.io/](https://flask-wtf.readthedocs.io/)。
- en: CSRF tokens will ensure that no malicious third-party website can send valid
    forms to your app when you are logged in. *Chapter 7*, *Securing Your Services*,
    will explain in detail how CSRF works and why it is important for your app security.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 令牌将确保在您登录时，没有恶意的第三方网站可以向您的应用程序发送有效的表单。*第 7 章*，*保护您的服务*，将详细解释 CSRF 的工作原理以及为什么它对您的应用程序安全很重要。
- en: 'The following module implements a form for the `User` table, using `FlaskForm`
    as its basis:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块实现了一个用于 `User` 表的表单，以 `FlaskForm` 为其基础：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `display` attribute is just a helper to assist the template in iterating
    into a particular ordered list of fields when rendering the form. Everything else
    is using WTForms basic fields classes to create a form for the user table. The
    WTForm's Fields documentation provides the full list at [https://wtforms.readthedocs.io/en/2.3.x/fields/](https://wtforms.readthedocs.io/en/2.3.x/fields/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`display` 属性只是模板在渲染表单时迭代特定有序字段列表的一个辅助工具。其他所有内容都是使用 WTForms 的基本字段类为用户表创建表单。WTForm
    的字段文档提供了完整的列表，请参阅 [https://wtforms.readthedocs.io/en/2.3.x/fields/](https://wtforms.readthedocs.io/en/2.3.x/fields/)。'
- en: 'Once created, `UserForm` can be used in a view that has two goals. The first
    one is to display the form on `GET` calls, and the second one is to update the
    database on `POST` calls when the user submits the form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，`UserForm` 可以在具有两个目标的视图中使用。第一个目标是显示在 `GET` 调用中的表单，第二个目标是在用户提交表单时，在 `POST`
    调用中更新数据库：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `UserForm` class has a method to validate the incoming `POST` data, using
    the validators we provide. When some data is invalid, the form instance will keep
    the list of errors in `field.errors` in case the template wants to display them
    for the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserForm` 类有一个方法来验证传入的 `POST` 数据，使用我们提供的验证器。当某些数据无效时，表单实例将保留错误列表在 `field.errors`
    中，以防模板想要向用户显示它们。'
- en: 'The `create_user.html` template iterates through the form field list, and WTForm
    takes care of rendering the proper HTML tags:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_user.html` 模板会遍历表单字段列表，WTForm 负责渲染适当的 HTML 标签：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `form.hidden_tag()` method will render all hidden fields, such as the CSRF
    token. Once this form is working, it's easy to reuse the same pattern for every
    form needed in the app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`form.hidden_tag()` 方法将渲染所有隐藏字段，例如 CSRF 令牌。一旦这个表单开始工作，就很容易为应用程序中需要的每个表单重用相同的模式。'
- en: Forms are often adjusted regularly during development and, by necessity, they
    are tightly coupled to the structure of the database. Because of this, when we
    look at splitting Jeeves up into microservices, we will consider whether these
    forms need to be provided by the database microservice to avoid schema dependencies
    appearing in other services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，表单通常会定期调整，并且由于必要性，它们与数据库的结构紧密耦合。因此，当我们考虑将 Jeeves 分解为微服务时，我们将考虑这些表单是否需要由数据库微服务提供，以避免在其他服务中出现模式依赖。
- en: Slack workspaces
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Slack 工作区
- en: 'Slack allows people to connect apps to a workspace. If you are an administrator
    of the FunCorp Slack instance, you could visit the following link and create a
    new bot user: [https://api.slack.com/apps?new_app=1](https://api.slack.com/apps?new_app=1).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Slack 允许人们将应用程序连接到工作区。如果您是 FunCorp Slack 实例的管理员，您可以访问以下链接并创建一个新的机器人用户：[https://api.slack.com/apps?new_app=1](https://api.slack.com/apps?new_app=1)。
- en: The exact process and web page layout may change—as web services frequently
    do—but there will be an opportunity to enable Event Subscriptions and provide
    a URL to which Slack messages should be sent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的流程和网页布局可能会改变——正如网络服务经常发生的那样——但将有机会启用事件订阅并提供一个 Slack 消息应发送到的 URL。
- en: 'A token will be generated, which you should copy and place in your application''s
    settings so that it can authenticate to Slack when sending messages:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个令牌，您应该将其复制并放置在应用程序的设置中，以便在发送消息时验证 Slack：
- en: '![image3.png](img/B17108_04_01.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image3.png](img/B17108_04_01.png)'
- en: 'Figure 4.1: Subscribing to Slack bot events'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：订阅 Slack 机器人事件
- en: The `Request` URL that you give to Slack will need to be reachable from Slack's
    own servers, and so running this on your laptop may not be enough. If you run
    into trouble, then using a virtual server in a cloud provider is a quick and easy
    way to get going. We will cover this in more detail in *Chapter 10*, *Deploying
    on AWS*, where we discuss deploying our application in the cloud.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供给 Slack 的 `Request` URL 需要从 Slack 自身的服务器可访问，因此仅在您的笔记本电脑上运行可能不够。如果您遇到麻烦，那么在云服务提供商中运行虚拟服务器是一种快速简单的方法来开始。我们将在第
    10 章 *Deploying on AWS* 中更详细地介绍这一点，其中我们讨论了在云中部署我们的应用程序。
- en: 'Once the bot''s endpoint is verified, it will start receiving the messages
    it has subscribed to. This means that if you have selected `app_mention` events,
    then messages that don''t mention the bot by name will not be sent, but any others
    will. Your bot will need some permissions—known as scopes—to read and send messages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证了机器人的端点，它将开始接收它已订阅的消息。这意味着如果您选择了 `app_mention` 事件，那么不提及机器人名称的消息将不会发送，但其他任何消息都会。您的机器人需要一些权限——称为作用域——以读取和发送消息：
- en: '![image2.png](img/B17108_04_02.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image2.png](img/B17108_04_02.png)'
- en: 'Figure 4.2: Example Slack bot permissions to receive messages'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：示例 Slack 机器人权限以接收消息
- en: The JSON data that is sent for an event arrives with all the data categorized.
    Using the example below, when the person types *@jeeves hello*, the API endpoint
    will receive a JSON object that identifies the workspace, the timestamp, what
    sort of event it was, what user typed it, and the component parts of the message
    itself—such as a mention (`@jeeves`) and the text, *hello*. Any user ID that is
    sent will not be recognizable to a human as they are the internal text strings
    used to represent users and workspaces. This does mean that when we connect a
    user to our application, we never really learn the username they chose in Slack
    unless we ask Slack for it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发送事件时发送的 JSON 数据会附带所有分类好的数据。以下面的例子为例，当某人输入 `@jeeves hello` 时，API 端点将接收一个 JSON
    对象，该对象标识了工作区、时间戳、事件的类型、输入的用户以及消息本身的组成部分——例如提及 (`@jeeves`) 和文本，*hello*。任何发送的用户
    ID 对人类来说都是不可识别的，因为它们是用于表示用户和工作区的内部文本字符串。这也意味着，当我们把用户连接到我们的应用程序时，除非我们向 Slack 请求，否则我们永远不会真正了解他们在
    Slack 中选择的用户名。
- en: 'Here is a trimmed copy of the JSON data our service gets when we ask for the
    weather in our Slack workspace. It is easy to see that the values for the user
    and team are not human-friendly, but the JSON is also helpful in that it has already
    broken up a potentially complicated message into sections for us so that we don''t
    need to worry about safely removing mentions of other users, links, or other special
    elements that can be in the post:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们请求 Slack 工作区中的天气时，我们的服务得到的 JSON 数据的简化副本。很容易看出用户和团队的价值不是人类友好的，但 JSON 也很有帮助，因为它已经将可能复杂的信息拆分成了我们不需要担心安全移除其他用户的提及、链接或其他特殊元素的段落：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Taking actions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行动作
- en: Our bot should be able to do useful things for the people who send it messages,
    and we should keep these actions as self-contained as possible. Even without using
    a microservice-based design, it is far safer to create well-defined boundaries
    between different components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人应该能够为发送消息的人做些有用的事情，我们应该尽可能将这些动作保持为自包含的。即使不使用基于微服务的设计，在组件之间创建明确的边界也远更安全。
- en: How do we know which action to take? After receiving a message from Slack, we
    need to understand the data we have been given and look for the appropriate keywords.
    When we find something that matches, we can then check to see what function we
    should call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道采取哪种行动？在收到 Slack 的消息后，我们需要理解我们得到的数据，并寻找适当的关键词。当我们找到匹配的内容时，我们就可以检查应该调用哪个函数。
- en: The `Quart` view we use to handle Slack messages should be as simple as possible,
    and so we do just enough processing to extract information from the data we are
    given and pass it on to a message processor. This processor is responsible for
    examining the text the bot has been sent, and deciding on a course of action.
    Arranging the code this way also means that if we add support from other chat
    services, we can use the same message processor, and so consult the same list
    of actions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来处理 Slack 消息的 `Quart` 视图应该尽可能简单，所以我们只做足够的处理来从我们提供的数据中提取信息，并将其传递给消息处理器。这个处理器负责检查机器人收到的文本，并决定采取的行动。这样安排代码也意味着，如果我们添加对其他聊天服务的支持，我们可以使用相同的消息处理器，并咨询相同的动作列表。
- en: 'We may require a more complex or dynamic action configuration later, but for
    now, let''s start with a simple mapping in the configuration file. The dictionary
    keys will be some text to look for at the start of the message, and the value
    is the name of a function to be called when it matches. Each of those functions
    will take the same arguments, to make our life simpler:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在以后需要更复杂或动态的动作配置，但现在，让我们从配置文件中的简单映射开始。字典键将是消息开头需要查找的一些文本，值是匹配时将被调用的函数的名称。这些函数中的每一个都将接受相同的参数，以使我们的生活更简单：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By using this approach, adding new actions to our bot does not involve any changes
    to the `process_message` function, and so no changes are made to the tests for
    that function; instead, we just change a dictionary near the top of the file.
    It will also be easier to move the `ACTION_MAP` into a database or configuration
    file later if we discover that this would be useful.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，向我们的机器人添加新动作不需要对 `process_message` 函数进行任何更改，因此对该函数的测试也没有任何更改；相反，我们只需更改文件顶部的字典。如果我们发现将
    `ACTION_MAP` 移入数据库或配置文件会有所帮助，那么以后也将更容易这样做。
- en: The actions might make good use of the metadata, and so we pass that information
    along. Looking up the weather, for example, can make use of any stored location
    that the person has told us about.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可能会很好地利用元数据，因此我们将这些信息传递下去。例如，查找天气时，可以利用我们被告知的任何存储位置。
- en: OAuth tokens
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth令牌
- en: '**OAuth2** ([https://oauth.net/2/](https://oauth.net/2/)) allows us to make
    an authenticated request to someone else''s site. We could request read-only access
    to someone''s Google calendar, permission to post issues to GitHub, or the ability
    to read information about our recorded exercises in a fitness application. We
    can do all of this without ever asking for someone''s password to a different
    site—something no one should ever do!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth2** ([https://oauth.net/2/](https://oauth.net/2/))允许我们向其他人的网站发送经过身份验证的请求。我们可以请求对某人的Google日历的只读访问权限，允许向GitHub发布问题，或者能够读取健身应用程序中我们记录的锻炼信息的权限。我们可以在不要求用户为不同网站提供密码的情况下完成所有这些操作——这是任何人都永远不会做的事情！'
- en: For our example, we will connect to Slack to allow the people using our bot
    to log in and update information about themselves. We can also use this to fetch
    information about them, such as the details of their Slack profile—if they allow
    us to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将连接到Slack，以便允许使用我们机器人的用户登录并更新他们自己的信息。我们还可以使用此功能获取有关他们的信息，例如他们的Slack个人资料详情——如果他们允许我们这样做的话。
- en: 'We will present people visiting a web page with a button they can use to log
    in to the site using Slack, which will send the web browser off to Slack''s page
    to authorize our application. If they agree, then our application is given a code,
    which we can then use to request an access token. That access token will let us
    contact Slack and verify that the token is still valid, and let us ask for the
    information the person has allowed us to view—or change! For this example, we
    will need HTTPS enabled and a valid site certificate. The easiest way to do this
    will be to use a proxy and a "Let''s Encrypt" certificate. We will cover setting
    up this proxy and certificate in *Chapter 7*, *Securing Your Services*. For now,
    let''s look at how we log users in:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向访问网页的人展示一个按钮，他们可以使用该按钮通过Slack登录到网站，这将使网络浏览器跳转到Slack的页面以授权我们的应用程序。如果他们同意，那么我们的应用程序将获得一个代码，然后我们可以使用该代码请求访问令牌。这个访问令牌将允许我们联系Slack并验证令牌是否仍然有效，并允许我们请求我们被允许查看或更改的信息！对于这个示例，我们需要启用HTTPS并拥有一个有效的网站证书。最简单的方法是使用代理和“Let's
    Encrypt”证书。我们将在第7章“保护你的服务”中介绍如何设置这个代理和证书。现在，让我们看看我们如何登录用户：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have introduced **aiohttp** ([https://docs.aiohttp.org/](https://docs.aiohttp.org/))
    here, which is a useful asynchronous library for making outgoing web requests.
    We are also not handling the error responses that our callback view receives,
    or storing this useful data in a database to use later on. In that view, `@login_required`
    and `current_user` are part of the authentication and authorization processes
    presented in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里介绍了**aiohttp** ([https://docs.aiohttp.org/](https://docs.aiohttp.org/))，这是一个用于发送网络请求的有用异步库。我们也没有处理我们的回调视图接收到的错误响应，或者将此有用的数据存储在数据库中以供以后使用。在那个视图中，`@login_required`和`current_user`是下一节中介绍的认证和授权过程的一部分。
- en: Authentication and authorization
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: 'Our monolithic application is almost ready but it also requires a way to handle
    authentication and authorization. Simply put:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单体应用程序几乎准备好了，但它也需要一种处理认证和授权的方法。简单来说：
- en: '**Authentication** is proving that you are who you claim to be'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**是证明你就是你声称的那个人'
- en: '**Authorization** is determining what actions you are permitted to perform'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**是确定你可以执行哪些操作'
- en: This is a careful—but critically important—distinction to make. In most services,
    there is an administrator, who must provide authentication—prove who they are—to
    be granted permission to perform configuration updates. A regular user of the
    service still must prove who they are, but the things they can do will not include
    the same access rights as used by administrators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个必须谨慎但至关重要的区分。在大多数服务中，有一个管理员，他必须提供认证——证明他们是他们所声称的人——才能获得执行配置更新的权限。服务的普通用户仍然必须证明他们是他们所声称的人，但他们可以做的事情将不包括与管理员相同的访问权限。
- en: For Jeeves, we need to connect our Slack users to our web service user interface
    so that people can authenticate with external services. We are setting up the
    third-party authentication this way so that we don't need to perform any complicated
    changes to a standard OAuth process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Jeeves，我们需要将我们的 Slack 用户与我们的网络服务用户界面连接起来，以便人们可以使用外部服务进行身份验证。我们以这种方式设置第三方身份验证，这样我们就不需要对标准的
    OAuth 流程进行任何复杂的更改。
- en: 'Since Slack uses an internal identifier for most users, we won''t see—nor do
    we need to—the friendly name they have chosen to display to other people. Instead,
    we will know them by a short nine-character string: You can view your own by checking
    your Slack profile, and it will be visible under the **More** menu. How do we
    connect that with the web interface? The quickest way would be to get a sign-in
    link from the bot. If a user sends Jeeves a message asking to log in, Jeeves can
    reply with a URL. Once visited, that URL will let the user set a password and
    use all the web features.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Slack 为大多数用户使用内部标识符，我们不会看到——也不需要看到——他们选择显示给其他人的友好名称。相反，我们将通过一个简短的九个字符的字符串来识别他们：你可以通过检查你的
    Slack 个人资料来查看自己的，它将在 **更多** 菜单下可见。我们如何将其与网页界面连接起来？最快的方式是从机器人那里获取一个登录链接。如果用户向 Jeeves
    发送消息要求登录，Jeeves 可以回复一个 URL。一旦访问，该 URL 将允许用户设置密码并使用所有网页功能。
- en: For our monolithic solution, we have just seen how we can let people log in
    using Slack without us ever having to handle a password. Using the `quart-auth`
    library makes managing session information for a user straightforward as it provides
    useful helper functions to create and store session cookies so that we will be
    remembered between visits.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的单体解决方案，我们刚刚看到我们可以让人们使用 Slack 登录，而无需我们处理密码。使用 `quart-auth` 库使得管理用户的会话信息变得简单，因为它提供了创建和存储会话cookie的有用辅助函数，这样我们就可以在访问之间被记住。
- en: 'Looking at the changes, our welcome page no longer presents the login button
    in its template, but instead now has a new decorator, `@login_required`, which
    will only allow the view to be loaded if we have declared that the current visitor
    has successfully authenticated:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些更改，我们的欢迎页面不再在其模板中显示登录按钮，而是现在有一个新的装饰器 `@login_required`，它将只允许在声明当前访客已成功认证的情况下加载视图：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If a visitor to the site is not authenticated, then their visit will be handled
    by the `errorhandler` we set, which here redirects them to the login page. The
    login page does the same job as our previous welcome page and shows the user the
    login button to press:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站访客未进行身份验证，那么他们的访问将由我们设置的 `errorhandler` 处理，这里将他们重定向到登录页面。登录页面与我们的上一个欢迎页面做同样的工作，并显示用户需要按下的登录按钮：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Slack OAuth2 process continues as it did before, and we receive a message
    in our callback. If the message indicates that things went well, then we can use
    the `AuthUser` calls of `quart-auth` and the `login_user` calls to set a session
    for this user. Let''s put the whole thing together in a working example, making
    use of the `secrets` library to generate a secure, but temporary, secret key for
    development:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Slack OAuth2 的流程与之前一样继续进行，我们会在回调中收到一条消息。如果这条消息表明一切顺利，那么我们可以使用 `quart-auth` 的
    `AuthUser` 调用和 `login_user` 调用来为该用户设置一个会话。让我们通过一个实际的工作示例将整个流程整合起来，利用 `secrets`
    库生成一个安全但临时的密钥用于开发：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you do need to store passwords, the simplest form of protection is to make
    sure that they are not stored in the clear in a database; instead, store them
    in a hashed form that cannot be converted back to the original password. That
    will minimize the risk of leaking passwords if your server is compromised. For
    the authentication process, it just means that when the user logs in, you need
    to hash the incoming password to compare it to the stored hash. Always check to
    see what the latest recommendations are for hashing algorithms, as inventing your
    own or using one that is obsolete can be very risky.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要存储密码，最简单的保护形式是确保它们不会以明文形式存储在数据库中；相反，以无法转换回原始密码的散列形式存储。这将最大限度地减少如果服务器被入侵时密码泄露的风险。对于身份验证过程，这意味着当用户登录时，你需要将传入的密码散列并与存储的散列进行比较。始终检查有关散列算法的最新建议，因为发明自己的或使用过时的算法可能非常危险。
- en: The transport layer is not usually the weak spot in application security. Thanks
    to the hard work of security professionals working on **Transport Layer Security**
    (**TLS**), we only need to concern ourselves with what happens inside the service
    once the request is received.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层通常不是应用程序安全中的弱点。多亏了在**传输层安全**（**TLS**）上工作的安全专业人士的辛勤工作，我们只需要关注请求接收后服务内部发生的事情。
- en: In the same vein, more granular permission verifications can be done by looking
    at the `current_user` variable that `quart_auth` sets in the application context.
    For example, you could use this to allow a user to change their data, but prevent
    them from changing any other users' data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过查看`quart_auth`在应用程序上下文中设置的`current_user`变量来执行更细粒度的权限验证。例如，您可以使用此功能允许用户更改他们的数据，但阻止他们更改任何其他用户的资料。
- en: Background tasks
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台任务
- en: 'So far, our application has several features that would be useful to run as
    scheduled tasks, without user interaction: our weather action could check for
    weather alerts in a user''s area and send a message to them; a calendar action
    could report on your scheduled meetings at the start of the working day; a monthly
    report of the actions that have been undertaken could be produced and emailed
    to the person looking after the bot.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序有几个功能，可以作为计划任务运行，无需用户交互：我们的天气动作可以检查用户所在地区的天气警报并向他们发送消息；日历动作可以在工作日开始时报告您的计划会议；可以生成并电子邮件发送到负责机器人的人员的关于已执行动作的月度报告。
- en: These are background tasks, and they need to run on their own outside the HTTP
    request/response cycle. Most operating systems have some form of scheduled task
    feature, such as cron on Unix or Scheduled Tasks in Windows. These features may
    not be ideal for our application, as it means we are connected to a specific platform
    when we should ideally be platform-agnostic, and able to run inside containers,
    or migrate to a serverless platform if our needs change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是后台任务，它们需要在HTTP请求/响应周期之外独立运行。大多数操作系统都有某种形式的计划任务功能，例如Unix上的cron或Windows中的计划任务。这些功能可能不适合我们的应用程序，因为这意味着我们应该在平台无关的情况下连接到特定平台，并且能够运行在容器中，或者如果我们的需求发生变化，可以迁移到无服务器平台。
- en: 'A popular way to run repetitive background tasks in Python web apps is to use
    **Celery**, a distributed task queue that can execute some work in a standalone
    process: [http://docs.celeryproject.org](http://docs.celeryproject.org).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python Web应用程序中运行重复的后台任务的一种流行方式是使用**Celery**，这是一个分布式任务队列，可以在独立进程中执行一些工作：[http://docs.celeryproject.org](http://docs.celeryproject.org)。
- en: To run these pieces of work, an intermediate called a message broker is in charge
    of passing messages back and forth between the application and Celery. For instance,
    if the app wants Celery to run something, it will add a message in the broker;
    Celery will poll it and do the job.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些工作片段时，一个称为消息代理的中间件负责在应用程序和Celery之间传递消息。例如，如果应用程序想让Celery运行某些任务，它将在代理中添加一条消息；Celery会轮询该消息并执行任务。
- en: A message broker can be any service that can store messages and provide a way
    to retrieve them. The Celery project works out of the box with **Advanced Message
    Queuing Protocol** (**AMQP**) services such as **RabbitMQ** ([http://www.rabbitmq.com](http://www.rabbitmq.com)),
    **Redis** ([http://redis.io](http://redis.io)), and **Amazon SQS** ([https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/)).
    AMQP provides a standard set of techniques for routing and delivering messages
    in a reliable way. We will be using RabbitMQ in our examples when we investigate
    the microservices design in more detail in the next chapter, where RabbitMQ will
    be responsible for making sure that messages reach their destination, and Celery
    is responsible for acting on those messages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理可以是任何可以存储消息并提供检索它们方式的任何服务。Celery项目与**高级消息队列协议**（**AMQP**）服务（如**RabbitMQ**
    ([http://www.rabbitmq.com](http://www.rabbitmq.com))）、**Redis** ([http://redis.io](http://redis.io))和**Amazon
    SQS** ([https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/))无缝工作。AMQP提供了一套标准技术，用于以可靠的方式路由和传递消息。在我们下一章更详细地研究微服务设计时，我们将使用RabbitMQ作为示例，RabbitMQ将负责确保消息到达目的地，而Celery负责对那些消息采取行动。
- en: The component that executes the job is called a worker, and Celery provides
    a class to start one. To use Celery from a `Quart` application, you can create
    a `background.py` module that instantiates a Celery object and marks your background
    tasks with an `@celery.``task` decorator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行作业的组件被称为工作进程，Celery提供了一个类来启动一个。要从`Quart`应用程序中使用Celery，你可以创建一个`background.py`模块，该模块实例化一个Celery对象，并使用`@celery.task`装饰器标记你的后台任务。
- en: In the following example, we are using Celery to set up a task that will fetch
    weather reports for every user who has a location and a Slack username set in
    our database. While, in practice, we would want people to opt-in to this feature,
    it allows us to show how a task is constructed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用Celery设置一个任务，该任务将为数据库中设置了位置和Slack用户名的每个用户获取天气报告。虽然在实际中，我们希望人们选择加入这个功能，但它允许我们展示如何构建一个任务。
- en: 'We will use the database we created earlier in this chapter and assume we have
    added a location field to it. We should also add a function to let us search for
    user accounts with a location set:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章中创建的数据库，并假设我们已经向其中添加了一个位置字段。我们还应该添加一个函数，以便我们可以搜索设置了位置的用户账户：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can set up a worker to do the task. The only difficulty is needing to
    wrap the function we call to do the work. To use the asynchronous database engine,
    it must be an `async` function, but Celery can only call synchronous functions,
    so we use a helper found in the `asgiref` library to convert it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置一个工作进程来执行任务。唯一的困难是需要将我们调用的执行工作的函数包装起来。要使用异步数据库引擎，它必须是一个`async`函数，但Celery只能调用同步函数，所以我们使用`asgiref`库中找到的辅助函数来转换它：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Celery will need RabbitMQ running in order to work—there are tutorials on RabbitMQ''s
    website, but below we assume you have Docker installed and can run containers.
    If you don''t, then don''t worry; we will discuss containers in more detail in
    *Chapter 10*, *Deploying on AWS*. We run the Celery background worker, which will
    wait for messages to arrive asking it to do work, and in another terminal, we
    start the scheduler, or beat, which will use the periodic task we set up:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Celery需要RabbitMQ运行才能工作——RabbitMQ网站上有一些教程，但以下我们假设你已经安装了Docker并且可以运行容器。如果你没有，那么不用担心；我们将在第10章*部署在AWS*中更详细地讨论容器。我们运行Celery后台工作进程，它将等待接收要求它执行工作的消息，然后在另一个终端中启动调度器或beat，它将使用我们设置的周期性任务：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This Celery worker also connects to RabbitMQ using AMQP, so that tasks can be
    triggered by sending a message through the broker. This will be especially useful
    if we don't need to send an immediate response to the caller, but instead expect
    a longer-running process to perform some tasks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Celery工作进程也使用AMQP连接到RabbitMQ，以便可以通过发送消息通过代理来触发任务。如果我们不需要立即向调用者发送响应，而是期望一个运行时间较长的进程执行一些任务，这将特别有用。
- en: 'Continuing our setup, we can look at the scheduler. Every 10 seconds is probably
    a bit too frequent for a report like this. We should instead use the crontab feature
    from Celery, which lets us specify a schedule while using the more familiar Unix
    crontab settings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的设置，我们可以看看调度器。每10秒对于这样的报告来说可能有点太频繁了。我们应该改用Celery的crontab功能，它允许我们指定一个计划，同时使用更熟悉的Unix
    crontab设置：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the Celery service is invoked by the `Quart` application by passing messages,
    it could be considered as a microservice in and of itself. That is also interesting
    in terms of deployment since both the RabbitMQ server and the Celery app can be
    deployed on another server. Our asynchronous function can then use the current
    app context to access the database, run queries, and then use the features of
    our application to run tasks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当Celery服务通过`Quart`应用程序传递消息被调用时，它可以被认为是一个本身就是一个微服务。这也从部署的角度来看很有趣，因为RabbitMQ服务器和Celery应用程序都可以部署在另一台服务器上。然后我们的异步函数可以使用当前的应用程序上下文来访问数据库，运行查询，然后使用我们应用程序的功能来运行任务。
- en: Putting together the monolithic design
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合单体设计
- en: 'This monolithic design is a solid foundation and should be the kind of result
    you would aim for in your first development iteration. Everything should be created
    with tests and documentation, as explained in *Chapter 3*, *Coding, Testing, and
    Documentation: the Virtuous Cycle*.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单体设计是一个坚实的基础，应该是你第一次开发迭代中追求的结果。一切都应该与测试和文档一起创建，正如在第3章*编码、测试和文档：良性循环*中解释的那样。
- en: 'It is a short and clean implementation on top of a relational database that
    can be deployed with a PostgreSQL, MySQL, or a cloud provider''s own SQL database.
    Thanks to the SQLAlchemy abstractions, a local version can run with SQLite 3 and
    facilitate your day-to-day development and local testing. To build this app, we''ve
    used the following extensions and libraries:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在关系型数据库之上的简洁实现，可以使用PostgreSQL、MySQL或云服务提供商自带的SQL数据库进行部署。得益于SQLAlchemy抽象，本地版本可以使用SQLite
    3运行，并便于你的日常开发和本地测试。为了构建这个应用程序，我们使用了以下扩展和库：
- en: '**aiohttp**: This handles all the outgoing HTTP requests'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aiohttp**：处理所有出站HTTP请求'
- en: '**SQLAlchemy**: This is used for the model'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy**：用于模型'
- en: '**Flask-WTF** and **WTForms**: These are used for all the forms'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask-WTF**和**WTForms**：用于所有表单'
- en: '**Celery and RabbitMQ**: These are used for background processes and periodic
    tasks'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Celery和RabbitMQ**：这些用于后台进程和周期性任务'
- en: '**quart-auth**: This is used for managing authentication and authorization'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**quart-auth**：用于管理身份验证和授权'
- en: 'The overall design can be represented in a diagram, as shown in *Figure 4.3*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 整体设计可以用图表表示，如图*图4.3*所示：
- en: '![](img/B17108_04_03.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_04_03.png)'
- en: 'Figure 4.3: The components of our first design'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：我们第一个设计中的组件
- en: A typical early deployment will put all of these services on the same server.
    It's certainly simpler that way, and it often feels straightforward to give an
    application a more powerful computer—this is known as scaling vertically. A single
    computer, whether it's a virtual machine in a cloud provider or a physical server
    in your building, has a limited number of resources available, and so there is
    a practical upper limit to vertical scaling.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的早期部署会将所有这些服务放在同一台服务器上。这样做当然更简单，而且通常给人一种直观的感觉，即给应用程序分配更强大的计算机——这被称为垂直扩展。无论是云服务提供商中的虚拟机还是你建筑中的物理服务器，单个计算机可用的资源数量是有限的，因此垂直扩展有一个实际的上限。
- en: Whether your application is running out of memory, network throughput, CPU processing
    availability, or some other bottleneck, the best solution is to update the architecture
    so that the service can be run across many different computers. This is scaling
    horizontally, and is one of the benefits of using microservices. If a microservice
    needs more I/O throughput to serve all its requests than a single computer can
    provide, that's not a problem if it can run across dozens or hundreds of computers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的应用程序是因为内存不足、网络吞吐量、CPU处理可用性，还是其他瓶颈而运行缓慢，最佳解决方案是更新架构，以便服务可以在多台不同的计算机上运行。这是水平扩展，也是使用微服务的一个好处。如果一个微服务需要比单台计算机能提供的更多I/O吞吐量来处理所有请求，那么如果它可以在几十或几百台计算机上运行，这就不成问题。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Jeeves bot is a typical web app that interacts with a database and a few
    backend services. The only unusual feature is that it receives most of its workload
    from one endpoint. Building this application with a monolithic architecture has
    allowed us to quickly iterate over several choices and get a prototype that works
    well during development and low-volume usage.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jeeves机器人是一个典型的Web应用程序，它与数据库和一些后端服务交互。唯一不寻常的特点是它的大部分工作量来自一个端点。使用单体架构构建这个应用程序使我们能够快速迭代几个选择，并得到一个在开发和低量使用期间表现良好的原型。
- en: From our discussions about the actions, it should be clear that there are good
    candidates for migration to a microservice. If we run this bot for dozens or hundreds
    of Slack workspaces, then we may find that one component is used much more than
    others, or has reliability issues that are difficult to address in the current
    architecture. How should the application scale up? What happens when an external
    service it relies upon is encountering errors? What happens if one of our own
    components—our database or message broker—goes down?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们关于动作的讨论中可以看出，有很好的候选者可以迁移到微服务。如果我们为几十或几百个Slack工作空间运行这个机器人，我们可能会发现有一个组件比其他组件使用得多，或者有难以在当前架构中解决的可靠性问题。应用程序应该如何扩展？当它依赖的外部服务遇到错误时会发生什么？如果我们的某个组件——我们的数据库或消息代理——崩溃了，会发生什么？
- en: 'In the next chapter, we will look at these issues: how to change the architecture
    of Jeeves so that it is more resilient, and how to make careful, measured changes
    to the service.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨这些问题：如何改变Jeeves的架构以使其更具弹性，以及如何对服务进行谨慎、有度的更改。
