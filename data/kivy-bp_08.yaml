- en: Chapter 8. Introducing Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 引入着色器
- en: Congratulations on making it this far! The last two chapters will somewhat stand
    out from the rest of the book, as we will take a completely different perspective
    on Kivy and dive into low-level details of the OpenGL renderer, such as the **OpenGL
    Shading Language** (**GLSL**). This will allow us to write high-performance code
    with very little overhead.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您已经走得很远了！最后两章将与本书的其他部分有所不同，因为我们将对Kivy采取完全不同的视角，深入探讨OpenGL渲染器的底层细节，例如**OpenGL着色语言**（**GLSL**）。这将使我们能够以极小的开销编写高性能代码。
- en: Starting from an unscientific introduction to OpenGL, we will proceed to writing
    a fast sprite-based engine for a starfield demonstration (basically, a screensaver)
    and finally, a shoot-em-up game (commonly abbreviated as just *shmup*). The code
    from this chapter will serve as a basis for the next one, unlike other projects
    in this book that were largely self-contained. We will lay the foundation here
    and then build upon it in the next chapter, turning a technical demo into a playable
    game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从对OpenGL的非科学介绍开始，我们将继续编写一个用于星系演示（基本上是一个屏幕保护程序）的快速精灵引擎，最后是一个射击游戏（通常简称为*shmup*）。本章的代码将作为下一章的基础，而本书中的其他项目大多是自包含的。我们将在本章打下基础，然后在下一章在此基础上构建，将技术演示转变为可玩的游戏。
- en: This chapter attempts to cover many complex topics with a sufficient level of
    detail, but it is way too short to serve as an all-encompassing reference guide.
    In addition to this, OpenGL, as a standard, evolves very quickly, introducing
    new features and deprecating the obsolete stuff. So, if you notice a discrepancy
    between the material presented in the chapter and the objective reality, please
    look it up—chances are that you're living in the bright future of computing, where
    things have changed significantly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章试图以足够的详细程度涵盖许多复杂主题，但它实在过于简短，无法作为全面参考指南。此外，作为一项标准，OpenGL的发展非常迅速，不断引入新特性并淘汰过时的内容。因此，如果您在章节中提供的材料与客观现实之间存在差异，请查阅相关资料——很可能您正处于计算技术的光明未来，那里的事物已经发生了显著变化。
- en: It should be mentioned upfront that the approach to high-performance rendering
    discussed here, despite being wildly different from the regular Kivy code, for
    the most part stays compatible with it and can be used side by side with ordinary
    widgets. Therefore, it's perfectly feasible to implement only the resource-hungry
    parts of an app in GLSL—those that will otherwise become a performance bottleneck.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提前说明的是，这里讨论的高性能渲染方法，尽管与常规的Kivy代码截然不同，但大部分仍然与之兼容，可以与普通小部件并行使用。因此，仅将应用程序中资源消耗大的部分用GLSL实现——否则这些部分将成为性能瓶颈——是完全可行的。
- en: Unscientific introduction to OpenGL
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对OpenGL的非科学介绍
- en: This section will provide a quick introduction to the basics of OpenGL. It's
    next to impossible to meaningfully summarize all the nooks and crannies of the
    standard here; hence it is "unscientific," superficial.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将快速介绍OpenGL的基本知识。在这里，几乎不可能有意义地总结标准的所有细节；因此，它被称为“非科学的”、“表面的”。
- en: OpenGL is a popular low-level graphical API. It's standardized and almost ubiquitous.
    Desktop and mobile operating systems commonly ship with an implementation of OpenGL
    (in the case of mobile, OpenGL ES, a feature-restricted subset of the standard;
    here, **ES** stands for **embedded systems**). Modern web browsers also implement
    a variant of OpenGL ES called WebGL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL是一个流行的底层图形API。它是标准化的，几乎无处不在。桌面和移动操作系统通常都附带OpenGL的实现（在移动设备上，是OpenGL ES，这是标准的一个功能受限子集；在这里，**ES**代表**嵌入式系统**）。现代网络浏览器也实现了OpenGL
    ES的一个变体，称为WebGL。
- en: Wide distribution and a well-defined compatibility makes OpenGL a good target
    for cross-platform apps, especially video games and graphical toolkits. Kivy also
    relies on OpenGL to perform rendering across all the supported platforms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的分布和明确的兼容性使OpenGL成为跨平台应用程序的良好目标，尤其是视频游戏和图形工具包。Kivy也依赖于OpenGL在所有支持的平台上进行渲染。
- en: Concepts and parallelism
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念和并行性
- en: 'OpenGL operates on basic primitives such as individual vertices and pixels
    on screen. For example, we can feed three vertices to it and render a triangle,
    thus computing color for each affected pixel (depending on the pipeline described
    in the next image). You might have guessed that working at this level of abstraction
    is extremely cumbersome. This pretty much summarizes the raison d''être of high-level
    graphical frameworks, including Kivy: they''re there to conceal the gory details
    of a rendering pipeline behind a more comfortable abstraction, such as working
    with widgets and layouts.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL在基本原语上操作，例如屏幕上的单个顶点和像素。例如，我们可以向其提供三个顶点并渲染一个三角形，从而为每个受影响的像素计算颜色（取决于下一张图中描述的管道）。你可能已经猜到，在这个抽象级别上工作非常繁琐。这基本上概括了高级图形框架（包括Kivy）的存在理由：它们的存在是为了在更舒适的抽象（例如使用小部件和布局）背后隐藏渲染管道的细节。
- en: 'The low-level rendering pipeline functions as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 低级渲染管道的工作方式如下：
- en: '![Concepts and parallelism](img/B01620_08_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![概念和并行性](img/B01620_08_01.jpg)'
- en: An OpenGL pipeline (oversimplified)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL管道（简化版）
- en: 'The complete explanation of the preceding figure is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示的完整解释如下：
- en: The application gives OpenGL an array of **vertices** (points), **indices**
    that allow us to reuse the points, and other arbitrary values (called **uniforms**).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序为OpenGL提供一个顶点数组（点）、允许我们重用这些点的**索引**，以及其他任意值（称为**统一变量**）。
- en: A **vertex shader** is invoked for every vertex, transforming it if needed and
    optionally doing other calculations. Its output is then passed to a corresponding
    fragment shader.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个顶点，都会调用**顶点着色器**，如果需要则对其进行变换，并可选择执行其他计算。然后，它的输出传递给相应的片段着色器。
- en: A **fragment shader** (sometimes called **pixel shader**) is invoked for every
    affected pixel, computing that pixel's color. More often than not, it takes into
    account the vertex shader's output but might also return, for example, a constant
    color.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个受影响的像素，都会调用**片段着色器**（有时称为**像素着色器**），计算该像素的颜色。通常，它会考虑顶点着色器的输出，但也可能返回，例如，一个常量颜色。
- en: Pixels are rendered on screen, and other bookkeeping tasks are performed; these
    tasks are of no interest to us at this point.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素在屏幕上渲染，并执行其他簿记任务；这些任务对我们来说目前没有兴趣。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A collection of vertices used together as a batch is commonly called a **model**
    or **mesh**. It is not necessarily continuous and might consist of scattered polygons
    as well; the rationale for such models will be mentioned shortly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一起用作批次的顶点集合通常称为**模型**或**网格**。它不一定是连续的，也可能由散布的多个多边形组成；这种模型的理由将在稍后提及。
- en: The "secret sauce" behind the blazing speed of OpenGL is its inherent massive
    parallelism. The functions mentioned earlier (namely, vertex and pixel shaders)
    might not be crazy fast by themselves, but as they are invoked simultaneously
    on a GPU, the delay imposed by shaders usually doesn't grow exponentially with
    the shaders' complexity; such growth can be close to linear on a decent hardware.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL背后高速运行的“秘密配方”是其固有的巨大并行性。前面提到的函数（即顶点和像素着色器）本身可能并不疯狂快速，但它们在GPU上同时调用时，着色器引入的延迟通常不会随着着色器复杂性的增加而呈指数增长；在良好的硬件上，这种增长可以接近线性。
- en: To put things in scale, given today's personal computers (at the time of writing
    this book), we're talking about multitasking and parallel programming with anywhere
    from 2 to 16 CPU cores in commodity hardware. Mid-range graphics cards, on the
    other hand, effectively have thousands of GPU cores; this makes them capable of
    running way more computations in parallel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了量化这一点，考虑到今天个人计算机（在撰写本书时），我们谈论的是具有2到16个CPU核心的通用硬件的多任务处理和并行编程。另一方面，中档显卡实际上拥有数千个GPU核心；这使得它们能够并行运行更多的计算。
- en: As a consequence though, each task runs in isolation. Unlike the threads in
    general-purpose programming, a shader cannot wait for the other shader's output
    without significantly degrading performance, except where implied by pipeline
    architecture (as mentioned earlier, a vertex shader passes values to a fragment
    shader). This restriction might be a bit mind-bending to work around as you start
    writing GLSL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个任务都是独立运行的。与通用编程中的线程不同，着色器不能在没有显著降低性能的情况下等待其他着色器的输出，除非管道架构暗示了这一点（如前所述，顶点着色器将值传递给片段着色器）。当你开始编写GLSL时，这种限制可能会让你感到有些难以理解。
- en: This is also why some algorithms can be implemented to run efficiently on GPU
    while others cannot. Interestingly, modern cryptography functions such as **bcrypt**
    are specifically designed to reduce performance of a highly parallelized implementation—this
    makes such functions inherently more secure by limiting the effectiveness of a
    brute-force attack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么一些算法可以在GPU上高效运行，而其他算法则不能。有趣的是，现代加密函数如**bcrypt**是专门设计来降低高度并行化实现的性能——这使得此类函数在本质上更加安全，因为它限制了暴力攻击的有效性。
- en: Performance gains, or lack thereof
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能提升，或缺乏提升
- en: 'It is important to understand that there are no immediate performance gains
    from using raw OpenGL calls at all times; in many cases, high-level frameworks
    such as Kivy will do just fine. For example, when rendering a polygon somewhere
    on a screen, roughly the following sequence of actions takes place:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，始终使用原始OpenGL调用并不会带来即时性能提升；在许多情况下，像Kivy这样的高级框架会做得很好。例如，当在屏幕上的某个位置渲染多边形时，大致会发生以下操作序列：
- en: The geometry and position of a polygon are defined in Python.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多边形的几何形状和位置在Python中定义。
- en: The vertices, indices, and related assets (such as textures) are uploaded to
    the graphics driver.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点、索引和相关资产（如纹理）被上传到图形驱动器。
- en: The vertex shader is invoked. It applies the necessary transformations, including
    positioning, rotation, scaling, and so on.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用顶点着色器。它应用必要的变换，包括定位、旋转、缩放等。
- en: Finally, the corresponding fragment shader is invoked; this results in a raster
    image that might be displayed on the screen.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用相应的片段着色器；这会产生可能显示在屏幕上的光栅图像。
- en: It doesn't matter whether you use Kivy widgets for this task or stick with writing
    raw OpenGL commands and GLSL shaders—both the performance and result will likely
    be the same, with negligible differences at best. This is because Kivy runs very
    similar OpenGL code behind the scenes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用Kivy小部件来完成这项任务还是坚持编写原始OpenGL命令和GLSL着色器——性能和结果可能相同，最多只有微小的差异。这是因为Kivy在幕后运行非常相似的OpenGL代码。
- en: In other words, this example bears very little potential for low-level optimization,
    and this is exactly the reason why a game such as *Kivy Bird*, consisting of scarce
    rectangles and very little else, should be implemented at the highest level of
    abstraction available. Basically, we could have optimized away the creation of
    a widget or two in Kivy Bird, but this is hardly even measurable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个例子几乎没有低级优化的潜力，这正是像*Kivy Bird*这样的游戏应该以最高级别的抽象实现的原因。基本上，我们可以在Kivy Bird中优化掉创建一个或两个小部件，但这几乎无法衡量。
- en: Improving performance
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高性能
- en: So, how do we actually boost performance? The answer is, by reducing the amount
    of work done on the Python side of things and batching similar objects together
    for rendering.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上如何提高性能呢？答案是，通过减少Python端的工作量并将相似对象批量一起渲染。
- en: Let's consider the scenario where we need to render over 9,000 similar polygons
    (a particle system, for example, autumn leaves scattered on the ground or a cluster
    of stars in space).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一个场景，我们需要渲染超过9,000个类似的多边形（例如，一个粒子系统，地面上散落的秋叶或在太空中的星团）。
- en: If we use Kivy widgets for individual polygons, we're creating a large number
    of Python objects that exist solely for the purpose of serializing themselves
    to OpenGL instructions. Moreover, each widget has its own set of vertices that
    it feeds to the graphics driver, thus issuing excessive API calls and creating
    a lot of distinct (yet very similar) meshes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为单个多边形使用Kivy小部件，我们正在创建大量仅用于将自身序列化为OpenGL指令的Python对象。此外，每个小部件都有自己的顶点集，它将其提供给图形驱动器，从而发出过多的API调用并创建大量独特（但非常相似）的网格。
- en: 'Manually, we''re able to, at the very least, do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 手动操作，我们至少可以做以下事情：
- en: Avoid the instantiation of many Python classes and just keep all the coordinates
    in an array. If we store them in a format suitable for direct OpenGL consumption,
    there is no need for the serialization step.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免实例化许多Python类，只需将所有坐标保存在一个数组中。如果我们以适合直接OpenGL消费的格式存储它们，则无需进行序列化步骤。
- en: Lump all geometry together as a single model and thus make much less API calls.
    Batching is always a nice optimization, as it allows OpenGL to do a better job
    at the parallel execution of things.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有几何形状组合成一个单一模型，从而大大减少API调用。批处理始终是一种很好的优化，因为它允许OpenGL更好地并行执行任务。
- en: We will implement the described approach by the end of this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束时实现所描述的方法。
- en: Taking a closer look at GLSL
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细看看GLSL
- en: As a language, GLSL is closely related to C; in particular, syntactically, they're
    very similar. GLSL is strongly, statically typed (more so than C).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，GLSL与C语言密切相关；特别是在语法上，它们非常相似。GLSL是强静态类型（比C语言更强）。
- en: If you aren't familiar with the C syntax, here's a very quick primer. First
    of all, unlike Python, in C-like languages, indentation is insignificant, and
    ending statements with a semicolon is mandatory. Logical blocks are enclosed in
    curly braces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉C语法，这里有一个非常快速的基础。首先，与Python不同，在类似C的语言中，缩进是不重要的，并且必须以分号结束语句。逻辑块被大括号包围。
- en: 'GLSL supports both C and C++ style comments:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL支持C和C++风格的注释：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Variable declarations are in the `[type] [name] [= optional value];` format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明格式为`[type] [name] [= optional value];`：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Functions are defined using the `[type] [name] ([arguments]) { [body of function]
    }` syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用`[type] [name] ([arguments]) { [body of function] }`语法定义：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Control structures are written like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构是这样写的：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's it for the most part; you should be able to read the GLSL code now, regardless
    of whether you have a background in C programming or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分就是这样；无论您是否有C编程背景，您现在都应该能够阅读GLSL代码。
- en: 'The entry point of a shader is designated by a `main()` function. In the following
    code, we''ll put both vertex and fragment shaders together in one file; so, there
    will be two `main()` functions per file. This is how these functions look:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的入口点由`main()`函数指定。在以下代码中，我们将将顶点着色器和片段着色器合并到一个文件中；因此，每个文件将有两个`main()`函数。这些函数看起来是这样的：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A special `void` type means absence of value, and unlike Python's `NoneType`,
    you cannot declare a variable of type `void`. In the case of the preceding `main()`
    function, both the return value and arguments are omitted; hence the function's
    declaration reads `void main(void)`. Instead of returning the result of a computation
    from the function, shaders write it to special built-in variables, `gl_Position`,
    `gl_FragColor`, and others, depending on the shader type and the desired effect.
    This also holds true for input parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`void`类型表示没有值，并且与Python的`NoneType`不同，您不能声明`void`类型的变量。在先前的`main()`函数中，返回值和参数都被省略了；因此，函数的声明读作`void
    main(void)`。着色器不是从函数返回计算结果，而是将其写入特殊内置变量，如`gl_Position`、`gl_FragColor`等，具体取决于着色器类型和所需效果。这也适用于输入参数。
- en: A GLSL type system closely reflects its usage domain. Unlike C, it has highly
    specialized types for vectors and matrices; these types support mathematical operations
    on them (so, you can multiply matrices with just the `mat1 * mat2` syntax; how
    cool is that!). In computer graphics, matrices are commonly used to mess with
    the coordinate system, as you will see shortly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL的类型系统紧密地反映了其使用域。与C语言不同，它具有高度专业化的向量矩阵类型；这些类型支持对它们的数学操作（因此，您只需使用`mat1 * mat2`语法即可乘以矩阵；这有多酷！）。在计算机图形学中，矩阵通常用于处理坐标系，您很快就会看到这一点。
- en: In the next section, we'll write a couple of simple GLSL shaders to demonstrate
    some of the concepts discussed earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写几个简单的GLSL着色器来演示之前讨论的一些概念。
- en: Using custom shaders in Kivy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kivy中使用自定义着色器
- en: 'Apart from GLSL, we also need to have the usual Python code that initializes
    the window, loads shaders, and so on. The following program will serve as a good
    starting point:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了GLSL之外，我们还需要有初始化窗口、加载着色器等常规Python代码。以下程序将作为一个良好的起点：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We created just one widget named `GlslDemo` in this example; it will host all
    the rendering. `RenderContext` is a customizable `Canvas` subclass that allows
    us to replace shaders easily, as shown in the listing. The `basic.glsl` file contains
    both vertex and fragment shaders; we will get to it in a minute.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只创建了一个名为`GlslDemo`的小部件；它将托管所有渲染。`RenderContext`是一个可定制的`Canvas`子类，允许我们轻松替换着色器，如列表所示。`basic.glsl`文件包含顶点着色器和片段着色器；我们将在下一分钟了解它。
- en: Note that this time, we aren't using the Kivy language at all, because no layout
    hierarchy is planned, so there is no accompanying `glsl.kv` file. Instead, we
    will designate the root widget manually by returning it from the `GlslApp.build()`
    method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们根本不使用Kivy语言，因为没有计划布局层次结构，所以没有相应的`glsl.kv`文件。相反，我们将通过从`GlslApp.build()`方法返回它来手动指定根小部件。
- en: The call to `EventLoop.ensure_window()` is needed, because we want to be able
    to access OpenGL features, such as the GLSL compiler, while running `GlslDemo.__init__()`.
    If there is still no application window (and more importantly, no corresponding
    OpenGL context) at that point in time, the program will crash.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调用`EventLoop.ensure_window()`，因为我们希望在运行`GlslDemo.__init__()`时能够访问OpenGL功能，例如GLSL编译器。如果在那个时间点还没有应用程序窗口（更重要的是，没有相应的OpenGL上下文），程序将会崩溃。
- en: Building the geometry
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建几何形状
- en: Before we begin writing shaders, we need something to render—a series of vertices,
    that is, a model. We'll stick with a simple rectangle that consists of two right
    triangles with a common hypotenuse (the subdivision is because baseline polygons
    are essentially triangular).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写着色器之前，我们需要一些可以渲染的内容——一系列顶点，即模型。我们将坚持使用一个简单的矩形，它由两个具有共同斜边的直角三角形组成（细分是因为基线多边形本质上都是三角形的）。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy, albeit two-dimensional for the most part, does not impose this limitation
    in any way. OpenGL, on the other hand, is inherently three-dimensional, so you
    can use realistic models seamlessly to create modern-looking games, and even mix
    them with regular Kivy widgets for UI (in-game menus and so on). This possibility
    is not further detailed in the book, but the underlying mechanics are just the
    same as described here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy虽然大部分是二维的，但它在任何方面都没有强加这种限制。另一方面，OpenGL本质上是三维的，因此你可以无缝地使用真实模型来创建现代外观的游戏，甚至可以将它们与常规Kivy小部件混合用于UI（游戏菜单等）。这本书中没有进一步详细说明这种可能性，但背后的机制与这里描述的完全相同。
- en: 'This is the updated `__init__()` method of the `GlslDemo` widget, with an explanation
    following it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GlslDemo`小部件更新的`__init__()`方法，下面是它的说明：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s walk through this function, because it''s essential to understand it
    correctly before moving on to more complex things:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个函数，因为它在继续处理更复杂的事情之前是至关重要的：
- en: When writing code that makes use of OpenGL, the first thing you'll notice is
    that there is no built-in standard format for vertices that we need to adhere
    to; instead, we need to define such a format ourselves. In the simplest case,
    we need just the position of each vertex; this is called `vPosition`. Our rectangle
    is two-dimensional, so we'll pass just two coordinates, which are floating point
    by default. Hence, we get the resulting line `(b'vPosition', 2, 'float')`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编写利用OpenGL的代码时，你首先会注意到没有内置的标准顶点格式供我们遵守；相反，我们需要自己定义这样的格式。在最简单的情况下，我们只需要每个顶点的位置；这被称为`vPosition`。我们的矩形是二维的，所以我们将传递两个坐标，默认情况下是浮点数。因此，我们得到的结果行是`(b'vPosition',
    2, 'float')`。
- en: Now that we have decided on the format of the vertices, it's time to put these
    vertices in an array that will soon be handed over to the renderer. This is exactly
    what the `vertices = (...)` line does. It's important that the tuple is flat and
    unstructured. We will define the record format separately and then pack all the
    values tightly together, without field delimiters and the like—all in the name
    of efficiency. This is also how C structs typically work.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经决定了顶点的格式，是时候将这些顶点放入一个数组中，这个数组很快就会被交给渲染器。这正是`vertices = (...)`这一行所做的。重要的是这个元组是扁平且无结构的。我们将单独定义记录格式，然后紧密地打包所有值，没有字段分隔符等——所有这些都是在效率的名义下进行的。这也是C结构通常的工作方式。
- en: Indices are needed to duplicate (reuse) vertices. More often than not, a vertex
    is used in more than one triangle. Instead of repeating it literally in the array
    of vertices, we resort to repeating its index in the array of indices—it's typically
    smaller, so the whole thing ends up taking less memory, proportional to the size
    of an individual vertex. See the next section for a more detailed explanation
    of indices.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要索引来复制（重用）顶点。通常情况下，一个顶点会被多个三角形使用。我们不会在顶点数组中直接重复它，而是通过在索引数组中重复它的索引来实现——这通常更小，因此整个结构最终占用的内存更少，与单个顶点的尺寸成比例。下一节将更详细地解释索引。
- en: With all the required data structures in place, we can finally assemble the
    mesh using the homonymous Kivy canvas instruction, `Mesh`. Now, it will be rendered
    over the course of normal widget rendering, which has a nice side effect of composability
    with other Kivy widgets. Our GLSL code can be effortlessly used in conjunction
    with all the previous developments. This is certainly a good thing.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有必需的数据结构就绪后，我们最终可以使用同名的Kivy画布指令`Mesh`组装网格。现在，它将在正常小部件渲染过程中渲染，这有一个很好的副作用，即与其他Kivy小部件的可组合性。我们的GLSL代码可以毫不费力地与所有先前的发展一起使用。这当然是一件好事。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Throughout this chapter, we have used the word *array* in a C sense—a continuous
    memory region containing homogeneous data. This is only tentatively related to
    the Python data structure having the same name; in fact, on the Python side of
    things, we're mostly using tuples or lists as a substitute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在C语言的意义上使用“数组”这个词——一个包含同质数据的连续内存区域。这与具有相同名称的Python数据结构只有试探性的关系；实际上，在Python方面，我们主要使用元组或列表作为替代。
- en: Illustrating the Indices
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示索引
- en: 'To explain OpenGL indices better, let''s visualize our example. These are our
    vertices from the preceding sample code, in the format of (*x*, *y*):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释OpenGL索引，让我们可视化我们的示例。这些是从前面的示例代码中获取的顶点，格式为(*x*, *y*)：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An index is just that—a serial number of a vertex in the `vertices` list, and
    it is zero-based. The following figure illustrates the assignment of indices to
    the vertices in this setup:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 索引只是这样——`vertices`列表中顶点的序列号，它是基于0的。以下图展示了在这个设置中对顶点分配索引的情况：
- en: '![Illustrating the Indices](img/B01620_08_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![展示索引的插图](img/B01620_08_02.jpg)'
- en: Vertices scattered on a plane
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 平面上的散点
- en: 'Right now, the vertices aren''t connected, so they form a point cloud at best,
    not a structured polygonal shape. To fix this, we need to specify the `indices`
    list—it will group the existing vertices into triangles. Its definition, again
    taken from the sample code, is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，顶点没有连接，所以它们最多形成点云，而不是有结构的多边形形状。为了解决这个问题，我们需要指定`indices`列表——它将现有的顶点分组成三角形。其定义，再次从示例代码中获取，如下所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve built two triangles here: the first one consists of vertices 0 to 2,
    and the second one out of vertices 2, 3, and 0\. Note how the 0^(th) and 2^(nd)
    vertices are reused.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建了两个三角形：第一个由顶点0到2组成，第二个由顶点2、3和0组成。注意0^(th)和2^(nd)顶点的重复使用。
- en: This is illustrated in the following figure. Never mind the colors; they are
    strictly explanatory and not "real" colors yet. We'll get to coloring things on
    the screen shortly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中得到了说明。颜色不必在意；它们完全是解释性的，还不是“真实”的颜色。我们很快就会在屏幕上给事物上色。
- en: '![Illustrating the Indices](img/B01620_08_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![展示索引的插图](img/B01620_08_03.jpg)'
- en: Building triangles out of vertices
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由顶点构建三角形
- en: This pretty much summarizes the utility and usage of indices in OpenGL-related
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上总结了在OpenGL相关代码中使用索引的用途和用法。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The tendency of optimizing in-memory sizes of data structures in OpenGL has
    very little to do with saving RAM per se—the video card interface throughput is
    a more serious bottleneck in most scenarios, so we're aiming at passing more stuff
    per frame, not just compressing data for the sake of economy. This distinction,
    while very important, makes no difference early on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中优化数据结构内存大小的趋势与节省RAM本身关系不大——在大多数情况下，显卡接口吞吐量是一个更严重的瓶颈，因此我们旨在每帧传递更多内容，而不仅仅是压缩数据以节省经济成本。这种区别虽然非常重要，但在一开始并没有什么不同。
- en: Writing GLSL
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写GLSL
- en: This is where things will get more interesting. In a moment, we'll be writing
    GLSL code that executes on a GPU. As we've already mentioned, it's C-like and
    crazy fast.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是事情变得更有趣的地方。一会儿，我们将编写在GPU上执行的GLSL代码。正如我们已经提到的，它类似于C语言，并且非常快。
- en: Let's start with the basics. Kivy expects that both the vertex and the fragment
    shaders live in the same file, delimited using a special syntax, `'---vertex'`
    and `'---fragment'` (shown in the next code snippet). It's important to stress
    out that both these delimiters and the `$HEADER$` syntax are specific to Kivy;
    they are not part of any standard, and you won't see them elsewhere.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。Kivy期望顶点着色器和片段着色器都位于同一个文件中，使用特殊语法分隔，即`'---vertex'`和`'---fragment'`（在下一个代码片段中显示）。重要的是要强调，这两个分隔符和`$HEADER$`语法都是Kivy特有的；它们不是任何标准的一部分，你不会在其他地方看到它们。
- en: 'This is how the boilerplate for a typical Kivy shader file looks:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是典型Kivy着色器文件的样板代码：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Henceforth, we'll omit most of the boilerplate code to shorten listings—but
    keep in mind that it's always assumed to be there; otherwise, things might not
    work as expected, or not at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从此以后，我们将省略大部分样板代码以缩短列表——但请记住，它始终被假定存在；否则，事情可能不会按预期工作，或者根本不会工作。
- en: The `$HEADER$` macro is context-sensitive and means different things depending
    on the type of shader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`$HEADER$`宏是上下文相关的，根据着色器的类型意味着不同的事情。'
- en: 'Inside a vertex shader, `$HEADER$` is a shortcut for roughly the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器内部，`$HEADER$`是一个大致相当于以下代码的快捷方式：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In a fragment shader, `$HEADER$` expands to the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，`$HEADER$`扩展为以下代码：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (Some not very important bits have been redacted for clarity.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （为了清晰起见，一些不太重要的部分已被删除。）
- en: Clearly, these might be subject to change in future versions of Kivy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些可能在Kivy的未来版本中发生变化。
- en: Storage classes and types
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储类和类型
- en: 'In the previous code, variables are annotated not only with a type, but also
    with a storage qualifier. Here is a quick rundown of both:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，变量不仅被注释为类型，还被注释为存储限定符。以下是两者的简要概述：
- en: '| Storage classes |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 存储类 |'
- en: '| --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `attribute` | This denotes the properties of vertices as specified by the
    vertex format. Attributes are passed from an application. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `attribute` | 这表示由顶点格式指定的顶点属性。属性由应用程序传递。|'
- en: '| `uniform` | Uniforms are global variables at the GLSL level. They are also
    passed from an application, but unlike attributes these do not vary with each
    vertex. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `uniform` | 在GLSL级别，统一变量是全局变量。它们也由应用程序传递，但与属性不同，这些变量不会随着每个顶点而变化。|'
- en: '| `varying` | These are variables passed from the vertex shader to the fragment
    shader. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `varying` | 这些是从顶点着色器传递到片段着色器的变量。|'
- en: '| **Commonly used data types** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **常用数据类型** |'
- en: '| `float` | This is the scalar floating-point variable type, similar to other
    languages. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 这是一个标量浮点变量类型，类似于其他语言。|'
- en: '| `vec2`, `vec3`, `vec4` | This is a tuple of length 2, 3, and 4; it contains
    floats. It might represent points, colors, and so on. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `vec2`, `vec3`, `vec4` | 这是一个长度为2、3和4的元组；它包含浮点数。它可以表示点、颜色等等。|'
- en: '| `mat2`, `mat3`, `mat4` | These refer to matrices of sizes 2 × 2, 3 × 3, 4
    × 4, respectively. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `mat2`, `mat3`, `mat4` | 这些分别指的是2 × 2、3 × 3、4 × 4大小的矩阵。|'
- en: '| `sampler2D` | This represents a texture that allows lookups (getting the
    color from specified coordinates). |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `sampler2D` | 这表示一个允许查找（从指定坐标获取颜色）的纹理。|'
- en: Basic shaders
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本着色器
- en: Now, without further preliminaries, let's write our first and simplest shaders
    that do nothing special.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再有更多的预备知识，让我们编写我们的第一个也是最简单的着色器，它没有任何特殊的功能。
- en: 'The default-like vertex shader reads:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的顶点着色器读取：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This transforms the location of each vertex into Kivy's preferred coordinate
    system, with the origin at the lower-left corner.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每个顶点的位置转换为Kivy首选的坐标系，原点位于左下角。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not attempt to describe the nuances of the transformation of coordinates
    here, as the topic is way too complex for an entry-level tutorial. Moreover, it
    isn't even necessary to fully understand this code, or to finish reading the book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会尝试描述坐标变换的细微差别，因为这个主题对于一个入门级教程来说太复杂了。此外，甚至不需要完全理解这段代码，或者读完这本书。
- en: If you're interested in a more comprehensive description of the topic, a nice
    short summary of the OpenGL coordinate space and the use of matrices can be found
    at [http://www.learnopengles.com/understanding-opengls-matrices/](http://www.learnopengles.com/understanding-opengls-matrices/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个主题有更全面的描述感兴趣，可以在[http://www.learnopengles.com/understanding-opengls-matrices/](http://www.learnopengles.com/understanding-opengls-matrices/)找到关于OpenGL坐标空间和矩阵使用的简洁摘要。
- en: 'The easiest fragment shader is a function that returns a constant color:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的片段着色器是一个返回常量颜色的函数：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This outputs an RGBA color equal to `#FF007F` for every pixel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这为每个像素输出一个等于`#FF007F`的RGBA颜色。
- en: 'If you run the program now, you would see output similar to the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你会看到类似于以下截图的输出：
- en: '![Basic shaders](img/B01620_08_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![基本着色器](img/B01620_08_04.jpg)'
- en: 'Basic shaders in action: default transformation and flat color'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基本着色器在实际应用中的效果：默认变换和平滑颜色
- en: Finally, we have a visible result of our ordeal. It isn't particularly interesting
    right now, but it is still better than nothing. Let's fiddle with it and see where
    this takes us.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了我们努力的结果。现在它可能并不特别有趣，但总比没有好。让我们摆弄一下，看看这会带我们走向何方。
- en: Procedural coloring
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序化着色
- en: Another lazy way to compute color, apart from always returning the same value,
    is to derive it from something that is immediately available in a corresponding
    shader, for example, fragment coordinates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了总是返回相同值之外，另一种计算颜色的懒惰方法是，从相应着色器中立即可用的某物中推导它，例如，片段坐标。
- en: 'Let''s assume that we want to compute each pixel''s RGB color as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要按照以下方式计算每个像素的 RGB 颜色：
- en: The `R` channel will be proportional to the *x* coordinate
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R` 通道将与 *x* 坐标成比例'
- en: The `G` channel will be proportional to the *y* coordinate
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G` 通道将与 *y* 坐标成比例'
- en: '`B` will be an average of `R` and `G`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B` 将是 `R` 和 `G` 的平均值。'
- en: 'This simple algorithm can be easily implemented in a fragment shader as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的算法可以很容易地在一个片段着色器中实现，如下所示：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `gl_FragCoord` built-in variable contains fragment coordinates (not necessarily
    representing a whole physical pixel) relative to the application window. A division
    by `255.0`—the size of the mesh, inlined for simplicity—is necessary to put color
    components in the range of [0...1].
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 内置变量 `gl_FragCoord` 包含相对于应用程序窗口的片段坐标（不一定代表整个物理像素）。为了将颜色分量放入 [0...1] 范围内，需要进行
    `255.0` 的除法——网格的大小，为了简单起见，内联显示。
- en: 'This replaces the previously seen flat color with a gradient as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将替换之前看到的纯色，以以下渐变的形式：
- en: '![Procedural coloring](img/B01620_08_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![过程着色](img/B01620_08_05.jpg)'
- en: Computing color based on fragment coordinates
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于片段坐标计算颜色
- en: Colorful vertices
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 彩色顶点
- en: 'A similar effect can be made data-driven by giving vertices their own colors.
    For this, we need to expand the vertex format to contain another per-vertex attribute,
    `vColor`. In Python code, this amounts to the following definition:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给顶点赋予它们自己的颜色，可以以数据驱动的方式产生类似的效果。为此，我们需要扩展顶点格式以包含另一个每顶点属性，`vColor`。在 Python
    代码中，这相当于以下定义：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With an updated format, a vertex now consists of five floats, up from two. It's
    crucial to keep the `vertices` list in sync with the format; otherwise, weird
    things will happen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的格式，顶点现在由五个浮点数组成，比之前多了两个。保持 `vertices` 列表与格式同步至关重要；否则，会发生奇怪的事情。
- en: As per our declaration, `vColor` is an RGB color, and for a vertex shader, we
    ultimately need RGBA. Instead of passing a constant alpha channel for each vertex,
    we'll pad it in the vertex shader, similar to how we expand `vPosition` from `vec2`
    to `vec4`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的声明，`vColor` 是一个 RGB 颜色，对于一个顶点着色器，我们最终需要 RGBA。我们不会为每个顶点传递一个常量 alpha 通道，而是在顶点着色器中填充它，类似于我们如何将
    `vPosition` 从 `vec2` 扩展到 `vec4`。
- en: 'This is what our revised vertex shader looks like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的修订版顶点着色器的外观：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: GLSL notations such as `vColor.rgb` and `vPosition.xy` are called *swizzling.*
    They can be used to efficiently manipulate parts of a vector, similar in concept
    to Python slices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 语法如 `vColor.rgb` 和 `vPosition.xy` 被称为 *swizzling*。它们可以用来高效地操作向量的部分，类似于
    Python 切片的概念。
- en: By itself, `vColor.rgb` simply means "take the first three vector components;"
    in Python code, we would write `vColor[:3]`. It's also possible to, for example,
    reverse the order of the color channels easily using `vColor.bgr`, or take just
    one channel using `vColor.ggg` (this will turn the resulting picture into grayscale).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来说，`vColor.rgb` 只是意味着“取前三个向量分量”；在 Python 代码中，我们会写成 `vColor[:3]`。例如，也可以轻松地使用
    `vColor.bgr` 反转颜色通道的顺序，或者只取一个通道使用 `vColor.ggg`（这将使生成的图片变为灰度图）。
- en: Up to four vector components can be addressed in this fashion, using either
    `.xyzw`, `.rgba`, or a more obscure `.stpq` notation; they all do exactly the
    same thing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以这种方式处理多达四个向量分量，使用 `.xyzw`、`.rgba` 或更神秘的 `.stpq` 语法；它们都做完全相同的事情。
- en: 'Having done this, the fragment shader becomes very simple:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，片段着色器变得非常简单：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Interestingly enough, we get color interpolation between vertices for free,
    resulting in a smooth gradient; this is how OpenGL works. The next screenshot
    depicts the output of the program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们得到了顶点之间的颜色插值，这产生了平滑的渐变；这就是 OpenGL 的工作方式。下一张截图显示了程序的输出：
- en: '![Colorful vertices](img/B01620_08_06.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![彩色顶点](img/B01620_08_06.jpg)'
- en: Passing color as a vertex attribute
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将颜色作为顶点属性传递
- en: Texture mapping
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理映射
- en: 'To wrap up this series of simple demos, let''s apply a texture to our rectangle.
    Once again, we need to expand the definition of a vertex format, this time, to
    assign texture coordinates to each vertex:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这一系列简单的演示，让我们将纹理应用到我们的矩形上。再一次，我们需要扩展顶点格式的定义，这次是为每个顶点分配纹理坐标：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Texture coordinates are usually in the [0...1] range, with the origin in the
    upper-left corner—note that this is different from the default Kivy's coordinate
    system. If, at some point, you see a texture flipped upside down for no apparent
    reason, check the texture coordinates first—they're likely the culprit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标通常在[0...1]范围内，原点在左上角——请注意，这与Kivy的默认坐标系不同。如果在某个时候，你看到纹理无缘无故地翻转过来，首先检查纹理坐标——它们很可能是罪魁祸首。
- en: 'One more thing that we need to take care of on the Python side of things is
    loading the texture and passing it to renderer. This is how it''s done:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python方面，我们还需要注意的一件事是加载纹理并将其传递给渲染器。这是如何操作的：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will load a file named `kivy.png` from the current directory and convert
    it into a usable texture. For the sake of demonstration, we will use the following
    image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从当前目录加载一个名为`kivy.png`的文件，并将其转换为可用的纹理。为了演示，我们将使用以下图像：
- en: '![Texture mapping](img/B01620_08_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![纹理映射](img/B01620_08_08.jpg)'
- en: The texture used for the demo
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用于演示的纹理
- en: 'As for the shaders, they aren''t very different from the previous iteration.
    The vertex shader simply passes texture coordinates through, untouched:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 至于着色器，它们与之前的版本没有太大区别。顶点着色器只是简单地传递未受影响的纹理坐标：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The fragment shader uses the interpolated `tex_coord0` coordinates to perform
    a lookup on the `texture0` texture, thus returning the corresponding color:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器使用插值的`tex_coord0`坐标在`texture0`纹理上执行查找，从而返回相应的颜色：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When put together, our code delivers the expected result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码组合在一起时，它会产生预期的结果：
- en: '![Texture mapping](img/B01620_08_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![纹理映射](img/B01620_08_07.jpg)'
- en: Simple GLSL texture mapping
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的GLSL纹理映射
- en: To summarize, this introduction to shaders should have given you enough courage
    to try to write your own small shader-based programs. Most importantly, don't
    feel intimidated if certain things don't make much sense—GLSL is a complex subject,
    and learning it systematically is not a small endeavor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这篇关于着色器的介绍应该已经给了你足够的勇气去尝试编写自己的小型基于着色器的程序。最重要的是，如果某些事情不太理解，不要感到害怕——GLSL是一个复杂的话题，系统地学习它不是一件小事情。
- en: It pays off, however, in giving you a much better understanding of how things
    work under the hood. Even if you don't write low-level code on a daily basis,
    you can still use this knowledge to identify and avoid performance bottlenecks
    and generally improve the architecture of your applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实有助于你更好地理解底层的工作原理。即使你每天不编写底层代码，你仍然可以使用这些知识来识别和避免性能瓶颈，并通常改善你应用程序的架构。
- en: Making the Starfield app
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作星域应用
- en: Armed with our newfound knowledge of GLSL, let's build a starfield screensaver,
    that is, a non-interactive demonstration of stars fleeing from the center of the
    screen to its sides, under the influence of an imaginary centrifugal force or
    something.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 借助我们对GLSL的新认识，让我们构建一个星域屏保，即星星在屏幕中心逃离到边缘的非交互式演示，在想象中的离心力或其他因素的影响下。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As dynamic visual effects are hard to describe unequivocally and screenshots
    aren't very helpful in this regard either, run the code that accompanies the chapter
    to get a better idea of what's going on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动态视觉效果难以明确描述，截图在这方面也不是很有帮助，因此运行本章附带的代码以更好地了解正在发生的事情。
- en: 'Conceptually, each star goes through the same action sequence:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，每颗星星都会经历相同的动作序列：
- en: It spawns randomly near the center of the screen.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会在屏幕中心附近随机生成。
- en: The star moves in the opposite direction from the screen center until it's no
    longer visible.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星星会向屏幕中心相反的方向移动，直到它不再可见。
- en: Then it respawns, going back to square one.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会重新生成，回到起点。
- en: We will also make stars accelerate and grow in size as they approach the edges
    of the screen to simulate the faux depth.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使星星在接近屏幕边缘时加速并增大尺寸，以模拟假深度。
- en: 'The following screenshot attempts (or, to be more specific, fails due to the
    highly dynamic nature of the demo) to illustrate what the end result will look
    like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图尝试（或者更具体地说，由于演示的高度动态性而失败）说明最终结果将看起来像什么：
- en: '![Making the Starfield app](img/B01620_08_09.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![制作星域应用](img/B01620_08_09.jpg)'
- en: A screenshot cannot convey the motion sickness, but it's there
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图无法传达晕动症，但它确实存在
- en: Application structure
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: The new application class bears a striking resemblance to what we did earlier
    in this chapter. Similar to the examples discussed earlier, we aren't using the
    Kivy language to describe the (non-existent) widget hierarchy, so there is no
    `starfield.kv` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新的应用程序类与我们本章早期所做的工作非常相似。类似于前面讨论的例子，我们并没有使用 Kivy 语言来描述（不存在的）小部件层次结构，因此没有 `starfield.kv`
    文件。
- en: 'The class consists of two methods, which are shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含两个方法，如下所示：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `build()` method creates and returns the root widget, `Starfield`; it will
    be in charge of all the math and rendering—basically, everything that happens
    throughout the application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`build()` 方法创建并返回根小部件 `Starfield`；它将负责所有数学和渲染——基本上，应用程序中发生的所有事情。'
- en: The `on_start()` handler tells the aforementioned root widget to update 60 times
    per second by calling its `update_glsl()` method after the application has been
    started.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_start()` 处理器告诉上述根小部件在应用程序启动后每秒更新 60 次通过调用其 `update_glsl()` 方法。'
- en: 'The `Starfield` class is also split in two: there is the usual `__init__()`
    method, which is responsible for the creation of the data structures, and the
    `update_glsl()` method, which advances the scene (calculates an updated position
    of each star) and renders stars on the screen.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Starfield` 类也被分为两部分：有常规的 `__init__()` 方法，负责创建数据结构，以及 `update_glsl()` 方法，它推进场景（计算每个恒星更新的位置）并在屏幕上渲染恒星。'
- en: Data structures and initializers
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构和初始化器
- en: 'Let''s now review the initialization code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下初始化代码：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`NSTARS` is the total number of stars; try raising or lowering it to alter
    the density of the starfield. Regarding performance, even a mediocre machine boasting
    a slow, integrated Intel video card easily supports thousands of stars. Any half-decent
    dedicated graphics hardware will handle tens of thousands of simultaneously rendered
    sprites with ease.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSTARS` 是恒星的总数；尝试增加或减少它以改变星场的密度。关于性能，即使是配备慢速集成英特尔显卡的中等机器也能轻松支持数千颗恒星。任何半数以上的专业图形硬件都能轻松处理数万同时渲染的精灵。'
- en: Unlike the previous examples, this time we will not fill the indices and vertices
    with the final, useful data right away; instead, we will prepare placeholder arrays
    that will be continuously updated later, as part of the `update_glsl()` routine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子不同，这次我们不会立即用最终的有用数据填充索引和顶点；相反，我们将准备占位符数组，稍后作为 `update_glsl()` 例程的一部分进行持续更新。
- en: 'The `vfmt` vertex format includes the following properties; a part of these
    has already been showcased in this chapter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`vfmt` 顶点格式包括以下属性；其中一部分在本章中已经展示过：'
- en: '| Vertex attribute | Its function |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 顶点属性 | 其功能|'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `vCenter` | This denotes the coordinates of the star''s center point on the
    screen |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `vCenter` | 这表示恒星在屏幕上的中心点坐标|'
- en: '| `vScale` | This is the star''s size factor, 1 being the original size (48
    × 48 pixels) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `vScale` | 这是恒星的大小因子，1 表示原始大小（48 × 48 像素）|'
- en: '| `vPosition` | This is the position of each vertex relative to the star''s
    center point |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `vPosition` | 这是每个顶点相对于恒星中心点的位置|'
- en: '| `vTexCoords0` | This refers to the texture coordinates |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `vTexCoords0` | 这指的是纹理坐标|'
- en: The property that we haven't mentioned yet, `vsize`, is the length of a single
    vertex in the array of vertices. It's computed from the vertex format as a sum
    of its middle column.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未提到的属性 `vsize` 是顶点数组中单个顶点的长度。它从顶点格式中计算出来，是其中间列的和。
- en: The `vertices` list contains nearly all data about stars that we need to retain;
    however, as it is flat and not implicitly structured, it's very unwieldy to operate
    on. This is where a helper class, `Star`, comes into play. It encapsulates the
    gory details of accessing and updating a selected entry in the array of vertices
    so that we don't have to compute offsets throughout our code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertices` 列表包含了我们需要保留的几乎所有关于恒星的数据；然而，由于它是扁平的且没有隐式结构，操作起来非常不便。这就是辅助类 `Star`
    发挥作用的地方。它封装了访问和更新顶点数组中选定条目的详细信息，这样我们就不必在代码中计算偏移量。'
- en: The `Star` class also keeps track of various properties that aren't part of
    the vertex format, that is, polar coordinates (`angle` and `distance` from the
    center) and `size`, which increases with time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Star` 类还跟踪一些不属于顶点格式的属性，即极坐标（从中心点的 `angle` 和 `distance`）以及 `size`，这些属性会随时间增加。'
- en: 'This is the initialization of the `Star` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Star` 类的初始化：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `base_idx` is the index of this star's first vertex in the array of vertices;
    we also kept a reference, `sf`, to the `Starfield` instance to be able to access
    `vertices` later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`base_idx` 是这个星星在顶点数组中的第一个顶点的索引；我们还保留了对 `Starfield` 实例的引用，`sf`，以便以后能够访问
    `vertices`。
- en: The `reset()` function, when called, reverts the star's attributes to default
    (slightly randomized) values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `reset()` 函数时，星星的属性将恢复到默认（略微随机化）的值。
- en: Advancing the scene
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推进场景
- en: 'The `Starfield.update_glsl()` method implements the algorithm of the starfield
    motion and is frequently invoked by Kivy''s clock scheduled in the `on_start()`
    handler of the application class. Its source code is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Starfield.update_glsl()` 方法实现了星系运动算法，并且经常在应用程序类的 `on_start()` 处理程序中由 Kivy
    的时钟调用。其源代码如下：'
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First off, we calculate the distance limit, `max_distance`, after which the
    stars respawn near the center of the screen. Then, we iterate over the list of
    stars, setting them in motion and enlarging them slightly on the way. Stars that
    have escaped the terminal distance are reset.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算距离限制，`max_distance`，之后星星将在屏幕中心附近重生。然后，我们遍历星星列表，让它们运动并在途中略微放大。逃离终端距离的星星将被重置。
- en: The final part of the function should look familiar. It's the same rendering
    code as seen in the preceding examples. A call to `canvas.clear()` is necessary;
    otherwise, a new mesh will be added on each call, swiftly bringing the overwhelmed
    graphics card to a grinding halt.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后部分看起来应该很熟悉。它与前面示例中看到的渲染代码相同。必须调用 `canvas.clear()`，否则每次调用都会添加一个新的网格，迅速将图形卡压到停机状态。
- en: 'The last piece of Python code that hasn''t been revealed is the `Star.update()`
    method. It refreshes the four vertices belonging to a star, writing new coordinates
    to appropriate places in the `vertices` array:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后尚未公开的 Python 代码片段是 `Star.update()` 方法。它刷新属于一颗星星的四个顶点，将新的坐标写入 `vertices` 数组中的适当位置：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `iterate()` helper is for convenience only and could have been inlined,
    but there's no such thing as superfluous readability, so let's keep it this way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate()` 辅助函数仅用于方便，本可以内联，但没有任何多余的可读性，所以让我们保持这种方式。'
- en: To reiterate (pun intended), this whole memory-mapping process serves a noble
    goal of eliminating the need to serialize our numerous objects in each frame;
    this helps performance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调（有意为之），整个内存映射过程旨在消除在每一帧中序列化我们众多对象的需求；这有助于性能。
- en: Writing a corresponding GLSL
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写相应的 GLSL
- en: 'Shaders used in the following program are also reminiscent of what we''ve seen
    earlier; they are only a little lengthier. This is the vertex shader:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中使用的着色器也让人联想到我们之前看到的；它们只是稍微长一点。这是顶点着色器：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Simply put, we're multiplying the relative coordinates of all the vertices by
    a factor of `vScale`, which resizes the mesh proportionally, and then translating
    them to the position given by a `vCenter` attribute. The `move_mat` matrix is
    the translation matrix, an affine transformation method that you might or might
    not remember from your linear algebra class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们正在将所有顶点的相对坐标乘以 `vScale` 因子，按比例调整网格大小，然后将它们平移到由 `vCenter` 属性给出的位置。`move_mat`
    矩阵是平移矩阵，这是一种你可能或可能不记得的线性代数课程中的仿射变换方法。
- en: 'To compensate, the fragment shader is very simple:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补偿，片段着色器非常简单：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Its ultimate purpose is to put this beautiful thing on the screen:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 其最终目的是将这美好的事物呈现在屏幕上：
- en: '![Writing a corresponding GLSL](img/B01620_08_10.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![编写相应的 GLSL](img/B01620_08_10.jpg)'
- en: Star texture, zoomed in
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 星系纹理，放大查看
- en: That's it. Our starfield is now finished and ready for astronomical observation
    with the unaided eye (or any other usage you can think of).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的星系现在已经完成，准备好用肉眼（或任何其他你能想到的用途）进行天文观测。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter aimed (and hopefully succeeded) to introduce you to a beautiful
    hardware-accelerated world of low-level OpenGL and GLSL development filled with
    vertices, indices, and shaders.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在（并希望成功）向您介绍一个充满顶点、索引和着色器的美丽硬件加速的低级OpenGL和GLSL开发世界。
- en: Direct programming of the GPU is an insanely powerful concept, and with this
    power always comes responsibility. Shaders are much harder to grasp than regular
    Python code; debugging might involve a fair measure of guesswork, and there is
    no convenient interactive environment, such as Python's REPL, to speak of. That
    said, there is no clear heuristic whether writing a raw GLSL would be useful for
    any particular application—it should be decided on a case-by-case basis.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 直接编程GPU是一个疯狂强大的概念，而这种力量总是伴随着责任。着色器比常规Python代码更难以掌握；调试可能需要相当程度的猜测工作，而且没有方便的交互式环境，比如Python的REPL，可以提及。尽管如此，编写原始GLSL是否对任何特定应用有用并没有明确的启发式方法——这应该根据具体情况来决定。
- en: Examples in this chapter were deliberately simple to serve as a gentle learning
    experience, not a test of cognitive abilities. This is mainly because GLSL programming
    is a very non-trivial, convoluted subject to study, with numerous books and online
    tutorials dedicated to mastering it, and this short chapter is by no means a comprehensive
    guide to all things OpenGL.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例故意设计得简单，以便作为轻松的学习体验，而不是对认知能力的测试。这主要是因为GLSL编程是一个非常复杂、错综复杂的学习主题，有众多书籍和在线教程致力于掌握它，而这短短的一章绝对不是OpenGL所有内容的全面指南。
- en: 'So far, we''ve just barely scratched the surface of what''s possible. The next
    chapter will capitalize on the code we wrote here to do a slightly more interesting
    thing: create a blazing fast shoot-em-up game.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅仅只是触及了可能性的表面。下一章将利用我们在这里编写的代码，做一些更有趣的事情：创建一个速度极快的射击游戏。
