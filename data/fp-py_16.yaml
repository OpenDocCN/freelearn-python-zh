- en: Chapter 16. Optimizations and Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。优化和改进
- en: In this chapter, we'll look at a few optimizations that we can make to create
    high performance functional programs. We'll expand on the `@lru_cache` decorator
    from [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*. We have a number of ways to implement the memoization algorithm. We'll
    also discuss how to write our own decorators. More importantly, we'll see how
    we use a `Callable` object to cache memoized results.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些优化方法，以创建高性能的函数程序。我们将扩展[第10章](ch10.html "第10章。Functools模块")中的`@lru_cache`装饰器，*Functools模块*。我们有多种方法来实现记忆化算法。我们还将讨论如何编写自己的装饰器。更重要的是，我们将看到如何使用`Callable`对象来缓存记忆化结果。
- en: We'll also look at some optimization techniques that were presented in [Chapter
    6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*.
    We'll review the general approach to tail recursion optimization. For some algorithms,
    we can combine memoization with a recursive implementation and achieve good performance.
    For other algorithms, memoization isn't really very helpful and we have to look
    elsewhere for performance improvements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究[第6章](ch06.html "第6章。递归和归约")中提出的一些优化技术，*递归和归约*。我们将回顾尾递归优化的一般方法。对于一些算法，我们可以将记忆化与递归实现结合，实现良好的性能。对于其他算法，记忆化并不是非常有帮助，我们必须寻找其他地方来提高性能。
- en: In most cases, small changes to a program will lead to small improvements in
    performance. Replacing a function with a `lambda` object will have a tiny impact
    on performance. If we have a program that is unacceptably slow, we often have
    to locate a completely new algorithm or data structure. Some algorithms have bad
    "big-O" complexity; nothing will make them magically run faster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，对程序的小改动将导致性能的小幅提升。用`lambda`对象替换函数对性能影响很小。如果我们的程序运行速度不可接受，我们通常必须找到一个全新的算法或数据结构。一些算法具有糟糕的“大O”复杂度；没有什么能让它们神奇地运行得更快。
- en: One place to start is [http://www.algorist.com](http://www.algorist.com). This
    is a resource that may help to locate better algorithms for a given problem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开始的地方是[http://www.algorist.com](http://www.algorist.com)。这是一个资源，可以帮助找到给定问题的更好算法。
- en: Memoization and caching
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化和缓存
- en: As we saw in [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The
    Functools Module*, many algorithms can benefit from memoization. We'll start with
    a review of some previous examples to characterize the kinds of functions that
    can be helped with memoization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](ch10.html "第10章。Functools模块")中看到的，*Functools模块*，许多算法可以从记忆化中受益。我们将从回顾一些先前的例子开始，以描述可以通过记忆化得到帮助的函数类型。
- en: In [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions
    and Reductions*, we looked at a few common kinds of recursions. The simplest kind
    of recursion is a tail recursion with arguments that can be easily matched to
    values in a cache. If the arguments are integers, strings, or materialized collections,
    then we can compare arguments quickly to determine if the cache has a previously
    computed result.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。递归和归约")中，我们看了一些常见的递归类型。最简单的递归类型是具有可以轻松匹配到缓存值的参数的尾递归。如果参数是整数、字符串或实例化的集合，那么我们可以快速比较参数，以确定缓存是否具有先前计算的结果。
- en: We can see from these examples that integer numeric calculations such as computing
    factorial or locating a Fibonacci number will be obviously improved. Locating
    prime factors and raising integers to powers are more examples of numeric algorithms
    that apply to integer values.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些例子中看到，像计算阶乘或查找斐波那契数这样的整数数值计算将明显改善。查找质因数和将整数提升到幂次方是更多适用于整数值的数值算法的例子。
- en: 'When we looked at the recursive version of a Fibonacci number calculator, we
    saw that it contained two tail-call recursions. Here''s the definition:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看递归版本的斐波那契数计算器时，我们发现它包含两个尾递归。以下是定义：
- en: '![Memoization and caching](graphics/B03652_16_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![记忆化和缓存](graphics/B03652_16_01.jpg)'
- en: This can be turned into a loop, but the design change requires some thinking.
    The memoized version of this can be quite fast and doesn't require quite so much
    thinking to design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以转换为一个循环，但设计变更需要一些思考。这个记忆化版本可以非常快，而且设计上不需要太多思考。
- en: The Syracuse function, shown in [Chapter 6](ch06.html "Chapter 6. Recursions
    and Reductions"), *Recursions and Reductions*, is an example of the kind of function
    used to compute fractal values. It contains a simple rule that's applied recursively.
    Exploring the Collatz conjecture ("does the Syracuse function always lead to 1?")
    requires memoized intermediate results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Syracuse函数，如[第6章](ch06.html "第6章。递归和归约")中所示，*递归和归约*，是用于计算分形值的函数的一个例子。它包含一个简单的规则，递归应用。探索Collatz猜想（“Syracuse函数是否总是导致1？”）需要记忆化中间结果。
- en: The recursive application of the Syracuse function is an example of a function
    with an "attractor," where the value is attracted to 1\. In some higher dimensional
    functions, the attractor can be a line or perhaps a fractal. When the attractor
    is a point, memoization can help; otherwise, memoization may actually be a hindrance,
    since each fractal value is unique.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Syracuse函数的递归应用是具有“吸引子”的函数的一个例子，其中值被吸引到1。在一些更高维度的函数中，吸引子可以是一条线，或者可能是一个分形。当吸引子是一个点时，记忆化可以帮助；否则，记忆化实际上可能是一个障碍，因为每个分形值都是唯一的。
- en: 'When working with collections, the benefits of caching may vanish. If the collection
    happens to have the same number of integer values, strings, or tuples, then there''s
    a chance that the collection is a duplicate and time can be saved. However, if
    a calculation on a collection will be needed more than once, manual optimization
    is best: do the calculation once and assign the results to a variable.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理集合时，缓存的好处可能会消失。如果集合恰好具有相同数量的整数值、字符串或元组，那么集合可能是重复的，可以节省时间。但是，如果需要对集合进行多次计算，手动优化是最好的：只需进行一次计算，并将结果分配给一个变量。
- en: When working with iterables, generator functions, and other lazy objects, caching
    of an overall object is essentially impossible. In these cases, memoization is
    not going to help at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理可迭代对象、生成器函数和其他惰性对象时，缓存整个对象基本上是不可能的。在这些情况下，记忆化根本不会有所帮助。
- en: Raw data that includes measurements often use floating point values. Since an
    exact equality comparison between floating point values may not work out well,
    memoizing intermediate results may not work out well either.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常包括测量的原始数据使用浮点值。由于浮点值之间的精确相等比较可能不会很好地工作，因此记忆化中间结果可能也不会很好地工作。
- en: Raw data that includes counts, however, may benefit from memoization. These
    are integers, and we can trust exact integer comparisons to (potentially) save
    recalculating a previous value. Some statistical functions, when applied to counts,
    can benefit from using the `fractions` module instead of floating point values.
    When we replace `x/y` with the `Fraction(x,y)` method, we've preserved the ability
    to do exact value matching. We can produce the final result using the `float(some_fraction)`
    method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包括计数的原始数据可能受益于记忆化。这些是整数，我们可以相信精确的整数比较可以（可能）节省重新计算先前值。一些统计函数在应用于计数时，可以受益于使用`fractions`模块而不是浮点值。当我们用`Fraction(x,y)`方法替换`x/y`时，我们保留了进行精确值匹配的能力。我们可以使用`float(some_fraction)`方法生成最终结果。
- en: Specializing memoization
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专门化记忆化
- en: The essential idea of memoization is so simple that it can be captured by the
    `@lru_cache` decorator. This decorator can be applied to any function to implement
    memoization. In some cases, we might be able to improve on the generic idea with
    something more specialized. There are a large number of potentially optimizable
    multivalued functions. We'll pick one here and look at another in a more complex
    case study.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化的基本思想是如此简单，以至于可以通过`@lru_cache`装饰器来捕捉。这个装饰器可以应用于任何函数以实现记忆化。在某些情况下，我们可能能够通过更专业的东西来改进通用的想法。有大量的潜在可优化的多值函数。我们将在这里选择一个，并在更复杂的案例研究中看另一个。
- en: 'The binomial, ![Specializing memoization](graphics/B03652_16_33.jpg), shows
    the number of ways *n* different things can be arranged in groups of size *m*.
    The value is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式，![专门化记忆化](graphics/B03652_16_33.jpg)，显示了*n*个不同的事物可以以大小为*m*的组合方式排列的数量。该值如下：
- en: '![Specializing memoization](graphics/B03652_16_34.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![专门化记忆化](graphics/B03652_16_34.jpg)'
- en: Clearly, we should cache the factorial calculations rather than redo all those
    multiplications. However, we may also benefit from caching the overall binomial
    calculation, too.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们应该缓存阶乘计算，而不是重新进行所有这些乘法。然而，我们也可能受益于缓存整体的二项式计算。
- en: 'We''ll create a C`allable` object that contains multiple internal caches. Here''s
    a helper function that we''ll need:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含多个内部缓存的可调用对象。这是我们需要的一个辅助函数：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `prod()` function computes the product of an iterable of numbers. It's defined
    as a reduction using the `*` operator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`prod()`函数计算数字的可迭代乘积。它被定义为使用`*`运算符的缩减。'
- en: 'Here''s a C`allable` object with two caches that uses this `prod()` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有两个缓存的可调用对象，它使用了`prod()`函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We created two caches: one for factorial values and one for binomial coefficient
    values. The internal `fact()` method uses the `fact_cache` attribute. If the value
    isn''t in the cache, it''s computed and added to the cache. The external `__call__()`
    method uses the `bin_cache` attribute in a similar way: if a particular binomial
    has already been calculated, the answer is simply returned. If not, the internal
    `fact()` method is used to compute a new value.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个缓存：一个用于阶乘值，一个用于二项式系数值。内部的`fact()`方法使用`fact_cache`属性。如果值不在缓存中，它将被计算并添加到缓存中。外部的`__call__()`方法以类似的方式使用`bin_cache`属性：如果特定的二项式已经被计算，答案将被简单地返回。如果没有，将使用内部的`fact()`方法计算一个新值。
- en: 'We can use the preceding `Callable` class like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用前面的`Callable`类：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows how we can create a C`allable` object from our class and then invoke
    the object on a particular set of arguments. There are a number of ways that a
    52-card deck can be dealt into 5-card hands. There are 2.6 million possible hands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们如何从我们的类创建一个可调用对象，然后在特定的参数集上调用该对象。一副52张的牌可以以5张牌的方式发出。有260万种可能的手牌。
- en: Tail recursion optimizations
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归优化
- en: 'In [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions
    and Reductions*, among many others, we looked at how a simple recursion can be
    optimized into a `for` loop. The general approach is this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。递归和缩减")中，*递归和缩减*，我们看到了如何将简单的递归优化为`for`循环，还有许多其他情况。
- en: Design the recursion. This means the base case and the recursive cases. For
    example, this is a definition of computing:![Tail recursion optimizations](graphics/B03652_16_04.jpg)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计递归。这意味着基本情况和递归情况。例如，这是一个计算的定义：![尾递归优化](graphics/B03652_16_04.jpg)
- en: 'To design the recursion execute the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计递归，请执行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the recursion has a simple call at the end, replace the recursive case with
    a `for` loop. The command is as follows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果递归在末尾有一个简单的调用，将递归情况替换为`for`循环。命令如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the recursion appears at the end of a simple function, it's described as
    a tail–call optimization. Many compilers will optimize this into a loop. Python—lacking
    this optimization in its compiler—doesn't do this kind of tail-call transformation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归出现在简单函数的末尾，它被描述为尾调用优化。许多编译器将其优化为循环。Python——由于其编译器缺乏这种优化——不会进行这种尾调用转换。
- en: This pattern is very common. Performing the tail-call optimization improves
    performance and removes any upper bound on the number of recursions that can be
    done.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常常见。进行尾调用优化可以提高性能，并消除可以执行的递归次数的上限。
- en: 'Prior to doing any optimization, it''s absolutely essential that the function
    already works. For this, a simple `doctest` string is often sufficient. We might
    use annotation on our factorial functions like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何优化之前，确保函数已经正常工作是绝对必要的。对此，一个简单的`doctest`字符串通常就足够了。我们可能会像这样在我们的阶乘函数上使用注释：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We added two edge cases: the explicit base case and the first item beyond the
    base case. We also added another item that would involve multiple iterations.
    This allows us to tweak the code with confidence.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个边缘情况：显式基本情况和超出基本情况的第一项。我们还添加了另一个涉及多次迭代的项目。这使我们可以有信心地调整代码。
- en: 'When we have a more complex combination of functions, we might need to execute
    commands like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有更复杂的函数组合时，我们可能需要执行这样的命令：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `__test__` variable is used by the `doctest.testmod()` function. All of
    the values in the dictionary associated with the `__test__` variable are examined
    for the `doctest` strings. This is a handy way to test features that come from
    compositions of functions. This is also called integration testing, since it tests
    the integration of multiple software components.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`__test__`变量由`doctest.testmod()`函数使用。与`__test__`变量关联的字典中的所有值都会被检查是否包含`doctest`字符串。这是测试由多个函数组合而成的功能的一种方便的方法。这也被称为集成测试，因为它测试了多个软件组件的集成。'
- en: 'Having working code with a set of tests gives us the confidence to make optimizations.
    We can easily confirm the correctness of the optimization. Here''s a popular quote
    that is used to describe optimization:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一组测试的工作代码使我们有信心进行优化。我们可以轻松确认优化的正确性。以下是一个常用的引用，用来描述优化：
- en: '|   | *"Making a wrong program worse is no sin."* |   |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|   | *"使一个错误的程序变得更糟并不是罪过。"* |   |'
- en: '|   | --*Jon Bentley* |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Jon Bentley* |'
- en: This appeared in the *Bumper Sticker Computer Science* chapter of *More Programming
    Pearls*, published by Addison-Wesley, Inc. What's important here is that we should
    only optimize code that's actually correct.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这出现在Addison-Wesley, Inc.出版的*More Programming Pearls*的*Bumper Sticker Computer
    Science*章节中。重要的是，我们只应该优化实际正确的代码。
- en: Optimizing storage
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化存储
- en: 'There''s no general rule for optimization. We often focus on optimizing performance
    because we have tools like the Big O measure of complexity that show us whether
    or not an algorithm is an effective solution to a given problem. Optimizing storage
    is usually tackled separately: we can look at the steps in an algorithm and estimate
    the size of the storage required for the various storage structures.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 优化没有通用规则。我们通常关注优化性能，因为我们有诸如大O复杂度度量这样的工具，它们可以告诉我们算法是否是给定问题的有效解决方案。优化存储通常是单独处理的：我们可以查看算法中的步骤，并估计各种存储结构所需的存储空间大小。
- en: In many cases, the two considerations are opposed. In some cases, an algorithm
    that has outstandingly good performance requires a large data structure. This
    algorithm can't scale without dramatic increases in the amount of storage required.
    Our goal is to design an algorithm that is reasonably fast and also uses an acceptable
    amount of storage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这两种考虑是相互对立的。在某些情况下，具有出色性能的算法需要一个大的数据结构。这种算法在没有大幅增加所需存储空间的情况下无法扩展。我们的目标是设计一个相当快速并且使用可接受的存储空间的算法。
- en: 'We may have to spend time researching algorithmic alternatives to locate a
    way to make the space-time trade off properly. There are some common optimization
    techniques. We can often follow links from Wikipedia: [http://en.wikipedia.org/wiki/Space–time_tradeoff](http://en.wikipedia.org/wiki/Space–time_tradeoff).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要花时间研究算法替代方案，以找到适当的时空权衡方式。有一些常见的优化技术。我们通常可以从维基百科上找到相关链接：[http://en.wikipedia.org/wiki/Space–time_tradeoff](http://en.wikipedia.org/wiki/Space–time_tradeoff)。
- en: One memory optimization technique we have in Python is to use an iterable. This
    has some properties of a proper materialized collection, but doesn't necessarily
    occupy storage. There are few operations (such as the `len()` function) that can't
    work on an iterable. For other operations, the memory saving feature can allow
    a program to work with very large collections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中有一种内存优化技术，即使用可迭代对象。这具有一些适当材料化集合的属性，但不一定占用存储空间。有一些操作（如`len()`函数）无法在可迭代对象上执行。对于其他操作，内存节省功能可以使程序处理非常大的集合。
- en: Optimizing accuracy
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化准确性
- en: In a few cases, we need to optimize the accuracy of a calculation. This can
    be challenging and may require some fairly advanced math to determine the limits
    on the accuracy of a given approach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，我们需要优化计算的准确性。这可能是具有挑战性的，并且可能需要一些相当高级的数学来确定给定方法的准确性限制。
- en: An interesting thing we can do in Python is replace floating point approximations
    with `fractions.Fraction` value. For some applications, this can create more accurate
    answers than floating point, because more bits are used for numerator and denominator
    than a floating point mantissa.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以用`fractions.Fraction`值替换浮点近似。对于一些应用程序，这可以比浮点更准确地创建答案，因为分子和分母使用的比特比浮点尾数更多。
- en: It's important to use `decimal.Decimal` values to work with currency. It's a
    common error to use a `float` value. When using a `float` value, additional noise
    bits are introduced because of the mismatch between `Decimal` values provided
    as input and the binary approximation used by floating point values. Using `Decimal`
    values prevents the introduction of tiny inaccuracies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`decimal.Decimal`值处理货币很重要。常见的错误是使用`float`值。使用`float`值时，由于提供的`Decimal`值与浮点值使用的二进制近似之间的不匹配，会引入额外的噪声比特。使用`Decimal`值可以防止引入微小的不准确性。
- en: In many cases, we can make small changes to a Python application to switch from
    `float` values to `Fraction` or `Decimal` values. When working with transcendental
    functions, this change isn't necessarily beneficial. Transcendental functions—by
    definition—involve irrational numbers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以对Python应用程序进行小的更改，从`float`值切换到`Fraction`或`Decimal`值。在处理超越函数时，这种更改并不一定有益。超越函数——根据定义——涉及无理数。
- en: Reducing accuracy based on audience requirements
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据观众要求降低精度
- en: For some calculations, a fraction value may be more intuitively meaningful than
    a floating point value. This is part of presenting statistical results in a way
    that an audience can understand and take action on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些计算，分数值可能比浮点值更直观地有意义。这是以一种观众可以理解并采取行动的方式呈现统计结果的一部分。
- en: For example, the chi-squared test generally involves computing the ![Reducing
    accuracy based on audience requirements](graphics/B03652_16_35.jpg) comparison
    between actual values and expected values. We can then subject this comparison
    value to a test against the ![Reducing accuracy based on audience requirements](graphics/B03652_16_35.jpg)
    cumulative distribution function. When the expected and actual values have no
    particular relationship—we can call this a null relationship—the variation will
    be random; ![Reducing accuracy based on audience requirements](graphics/B03652_16_35.jpg)
    the value tends to be small. When we accept the null hypothesis, then we'll look
    elsewhere for a relationship. When the actual values are significantly different
    from the expected values, we may reject the null hypothesis. By rejecting the
    null hypothesis, we can explore further to determine the precise nature of the
    relationship.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，卡方检验通常涉及计算实际值和预期值之间的比较。然后，我们可以将这个比较值进行测试，看它是否符合累积分布函数。当预期值和实际值没有特定的关系时-我们可以称之为空关系-变化将是随机的；值趋向于很小。当我们接受零假设时，我们将寻找其他地方的关系。当实际值与预期值显著不同时，我们可能会拒绝零假设。通过拒绝零假设，我们可以进一步探讨确定关系的确切性质。
- en: The decision is often based on the table of the ![Reducing accuracy based on
    audience requirements](graphics/B03652_16_35.jpg) **Cumulative Distribution Function**
    (**CDF**) for selected ![Reducing accuracy based on audience requirements](graphics/B03652_16_35.jpg)
    values and given degrees of freedom. While the tabulated CDF values are mostly
    irrational values, we don't usually use more than two or three decimal places.
    This is merely a decision-making tool, there's no practical difference in meaning
    between 0.049 and 0.05.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 决策通常基于选定的自由度的累积分布函数（CDF）的表格和给定的值。虽然表格化的CDF值大多是无理数值，但我们通常不会使用超过两到三位小数。这仅仅是一个决策工具，0.049和0.05之间在意义上没有实际区别。
- en: A widely used probability is 0.05 for rejecting the null hypothesis. This is
    a `Fraction` object less than 1/20\. When presenting data to an audience, it sometimes
    helps to characterize results as fractions. A value like 0.05 is hard to visualize.
    Describing a relationship has having 1 chance in 20 can help to characterize the
    likelihood of a correlation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝零假设的广泛使用概率为0.05。这是一个小于1/20的“分数”对象。当向观众呈现数据时，有时将结果描述为分数会有所帮助。像0.05这样的值很难想象。描述一个关系有20分之1的机会可以帮助表征相关性的可能性。
- en: Case study – making a chi-squared decision
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究-做出卡方决策
- en: We'll look at a common statistical decision. The decision is described in detail
    at [http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm](http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个常见的统计决策。该决策在[http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm](http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm)中有详细描述。
- en: 'This is a chi-squared decision on whether or not data is distributed randomly.
    In order to make this decision, we''ll need to compute an expected distribution
    and compare the observed data to our expectations. A significant difference means
    there''s something that needs further investigation. An insignificant difference
    means we can use the null hypothesis that there''s nothing more to study: the
    differences are simply random variation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于数据是否随机分布的卡方决策。为了做出这个决定，我们需要计算一个预期分布并将观察到的数据与我们的预期进行比较。显著差异意味着有些东西需要进一步调查。不显著的差异意味着我们可以使用零假设，即没有更多需要研究的内容：差异只是随机变化。
- en: We'll show how we can process the data with Python. We'll start with some backstory—some
    details that are not part of the case study, but often features an **Exploratory
    Data Analysis** (**EDA**) application. We need to gather the raw data and produce
    a useful summary that we can analyze.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用Python处理数据。我们将从一些背景开始-一些不属于案例研究的细节，但通常包括“探索性数据分析”（EDA）应用程序。我们需要收集原始数据并生成一个有用的摘要，以便我们可以进行分析。
- en: 'Within the production quality assurance operations, silicon wafer defect data
    is collected into a database. We might use SQL queries to extract defect details
    for further analysis. For example, a query could look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产质量保证操作中，硅晶圆缺陷数据被收集到数据库中。我们可以使用SQL查询来提取缺陷细节以进行进一步分析。例如，一个查询可能是这样的：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from this query could be a CSV file with individual defect details:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的输出可能是一个带有单个缺陷细节的CSV文件：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to summarize the preceding data. We might summarize at the SQL query
    level using the `COUNT` and `GROUP BY` statements. We might also summarize at
    the Python application level. While a pure database summary is often described
    as being more efficient, this isn't always true. In some cases, a simple extract
    of raw data and a Python application to summarize can be faster than a SQL summary.
    If performance is important, both alternatives must be measured, rather than hoping
    that the database is fastest.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要总结前面的数据。我们可以在SQL查询级别使用“COUNT”和“GROUP BY”语句进行总结。我们也可以在Python应用程序级别进行总结。虽然纯数据库摘要通常被描述为更有效，但这并不总是正确的。在某些情况下，简单提取原始数据并使用Python应用程序进行总结可能比SQL摘要更快。如果性能很重要，必须测量两种替代方案，而不是希望数据库最快。
- en: 'In some cases, we may be able to get summary data from the database efficiently.
    This summary must have three attributes: the shift, type of defect, and a count
    of defects observed. The summary data looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能能够高效地从数据库中获取摘要数据。这个摘要必须具有三个属性：班次、缺陷类型和观察到的缺陷数量。摘要数据如下：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output will show all of the 12 combinations of shift and defect type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示所有12种班次和缺陷类型的组合。
- en: 'In the next section, we''ll focus on reading the raw data to create summaries.
    This is the kind of context in which Python is particularly powerful: working
    with raw source data.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于读取原始数据以创建摘要。这是Python特别强大的上下文：处理原始源数据。
- en: We need to observe and compare shift and defect counts with an overall expectation.
    If the difference between observed counts and expected counts can be attributed
    to random fluctuation, we have to accept the null hypothesis that nothing interesting
    is going wrong. If, on the other hand, the numbers don't fit with random variation,
    then we have a problem that requires further investigation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要观察和比较班次和缺陷计数与总体预期。如果观察到的计数与预期计数之间的差异可以归因于随机波动，我们必须接受零假设，即没有发生任何有趣的错误。另一方面，如果数字与随机变化不符合，那么我们就有一个需要进一步调查的问题。
- en: Filtering and reducing the raw data with a Counter object
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Counter对象对原始数据进行过滤和归约
- en: 'We''ll represent the essential defect counts as a `collections.Counter` parameter.
    We will build counts of defects by shift and defect type from the detailed raw
    data. Here''s a function to read some raw data from a CSV file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基本缺陷计数表示为`collections.Counter`参数。我们将从详细的原始数据中按班次和缺陷类型构建缺陷计数。以下是从CSV文件中读取一些原始数据的函数：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding function will create a dictionary reader based on an open file
    provided via the `input` parameter. We've confirmed that the column names match
    the three expected column names. In some cases, we'll have extra columns in the
    file; in this case, the assertion will be something like `all((c in rdr.fieldnames)
    for c in […])`. Given a tuple of column names, this will assure that all of the
    required columns are present in the source. We can also use sets to assure that
    `set(rdr.fieldnames) <= set([...])`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将基于通过`input`参数提供的打开文件创建一个字典读取器。我们已经确认列名与三个预期列名匹配。在某些情况下，文件中会有额外的列；在这种情况下，断言将类似于`all((c
    in rdr.fieldnames) for c in […])`。给定一个列名的元组，这将确保所有必需的列都存在于源中。我们还可以使用集合来确保`set(rdr.fieldnames)
    <= set([...])`。
- en: We created a `types.SimpleNamespace` parameter for each row. In the preceding
    example, the supplied column names are valid Python variable names that allow
    us to easily turn a dictionary into a namespace. In some cases, we'll need to
    map column names to Python variable names to make this work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每一行创建了一个`types.SimpleNamespace`参数。在前面的示例中，提供的列名是有效的Python变量名，这使我们可以轻松地将字典转换为命名空间。在某些情况下，我们需要将列名映射到Python变量名以使其工作。
- en: A `SimpleNamespace` parameter allows us to use slightly simpler syntax to refer
    to items within the row. Specifically, the next generator expression uses references
    such as `row.shift` and `row.defect_type` instead of the bulkier `row['shift']`
    or `row['defect_type']` references.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleNamespace`参数允许我们使用稍微简单的语法来引用行内的项目。具体来说，下一个生成器表达式使用诸如`row.shift`和`row.defect_type`之类的引用，而不是臃肿的`row[''shift'']`或`row[''defect_type'']`引用。'
- en: We can use a more complex generator expression to do a map-filter combination.
    We'll filter each row to ignore rows with no defect code. For rows with a defect
    code, we're mapping an expression which creates a two tuple from the `row.shift`
    and `row.defect_type` references.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更复杂的生成器表达式来进行映射-过滤组合。我们将过滤每一行，忽略没有缺陷代码的行。对于有缺陷代码的行，我们正在映射一个表达式，该表达式从`row.shift`和`row.defect_type`引用创建一个二元组。
- en: In some applications, the filter won't be a trivial expression such as `row.defect_type`.
    It may be necessary to write a more sophisticated condition. In this case, it
    may be helpful to use the `filter()` function to apply the complex condition to
    the generator expression that provides the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，过滤器不会是一个像`row.defect_type`这样的简单表达式。可能需要编写一个更复杂的条件。在这种情况下，使用`filter()`函数将复杂条件应用于提供数据的生成器表达式可能会有所帮助。
- en: Given a generator that will produce a sequence of `(shift, defect)` tuples,
    we can summarize them by creating a `Counter` object from the generator expression.
    Creating this `Counter` object will process the lazy generator expressions, which
    will read the source file, extract fields from the rows, filter the rows, and
    summarize the counts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个将产生`(shift, defect)`元组序列的生成器，我们可以通过从生成器表达式创建一个`Counter`对象来对它们进行总结。创建这个`Counter`对象将处理惰性生成器表达式，它将读取源文件，从行中提取字段，过滤行，并总结计数。
- en: 'We''ll use the `defect_reduce()` function to gather and summarize the data
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`defect_reduce()`函数来收集和总结数据如下：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can open a file, gather the defects, and display them to be sure that we've
    properly summarized by shift and defect type. Since the result is a `Counter`
    object, we can combine it with other `Counter` objects if we have other sources
    of data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开一个文件，收集缺陷，并显示它们以确保我们已经按班次和缺陷类型正确进行了总结。由于结果是一个`Counter`对象，如果我们有其他数据源，我们可以将其与其他`Counter`对象结合使用。
- en: 'The `defects` value looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`defects`值如下：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have defect counts organized by shift and defect types. We'll look at alternative
    input of summarized data next. This reflects a common use case where data is available
    at the summary level.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按班次和缺陷类型组织了缺陷计数。接下来我们将看一下摘要数据的替代输入。这反映了一个常见的用例，即摘要级别的数据是可用的。
- en: Once we've read the data, the next step is to develop two probabilities so that
    we can properly compute expected defects for each shift and each type of defect.
    We don't want to divide the total defect count by 12, since that doesn't reflect
    the actual deviations by shift or defect type. The shifts may be more or less
    equally productive. The defect frequencies are certainly not going to be similar.
    We expect some defects to be very rare and others to be more common.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据后，下一步是开发两个概率，以便我们可以正确计算每个班次和每种缺陷类型的预期缺陷。我们不想将总缺陷数除以12，因为这并不反映出实际的班次或缺陷类型的偏差。班次可能生产的效率可能更或者更少相等。缺陷频率肯定不会相似。我们期望一些缺陷非常罕见，而其他一些则更常见。
- en: Reading summarized data
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取总结数据
- en: As an alternative to reading all of the raw data, we can look at processing
    only the summary counts. We want to create a `Counter` object similar to the previous
    example; this will have defect counts as a value with a key of shift and defect
    code. Given summaries, we simply create a `Counter` object from the input dictionary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读取所有原始数据的替代方案，我们可以考虑只处理摘要计数。我们想创建一个类似于先前示例的`Counter`对象；这将具有缺陷计数作为值，并具有班次和缺陷代码作为键。给定摘要，我们只需从输入字典创建一个`Counter`对象。
- en: 'Here''s a function that will read our summary data:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个读取我们的摘要数据的函数：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We require an open file as the input. We'll create a `csv.DictReader()` function
    that helps parse the raw CSV data that we got from the database. We included an
    `assert` statement to confirm that the file really has the expected data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个打开的文件作为输入。我们将创建一个`csv.DictReader()`函数，帮助解析从数据库获取的原始CSV数据。我们包括一个`assert`语句来确认文件确实具有预期的数据。
- en: We defined a `lambda` object that creates a two tuple with the key and the integer
    conversion of the count. The key is itself a two tuple with the shift and defect
    information. The result will be a sequence such as `((shift,defect), count), ((shift,defect),
    count), …)`. When we map the `lambda` to the `DictReader` parameter, we'll have
    a generator function that can emit the sequence of two tuples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`lambda`对象，它创建一个带有键和计数的两元组。键本身是一个包含班次和缺陷信息的两元组。结果将是一个序列，如`((班次，缺陷)，计数)，((班次，缺陷)，计数)，…)`。当我们将`lambda`映射到`DictReader`参数时，我们将得到一个可以发出两元组序列的生成函数。
- en: We will create a dictionary from the collection of two tuples and use this dictionary
    to build a `Counter` object. The `Counter` object can easily be combined with
    other `Counter` objects. This allows us to combine details acquired from several
    sources. In this case, we only have a single source.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个元组的集合中创建一个字典，并使用这个字典来构建一个`Counter`对象。`Counter`对象可以很容易地与其他`Counter`对象结合使用。这使我们能够结合从几个来源获取的详细信息。在这种情况下，我们只有一个单一的来源。
- en: 'We can assign this single source to the variable `defects`. The value looks
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个单一来源分配给变量`defects`。该值如下：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This matches the detail summary shown previously. The source data, however,
    was already summarized. This is often the case when data is extracted from a database
    and SQL is used to do group-by operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前显示的详细摘要相匹配。然而，源数据已经被总结。当数据从数据库中提取并使用SQL进行分组操作时，通常会出现这种情况。
- en: Computing probabilities from a Counter object
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Counter对象计算概率
- en: 'We need to compute the probabilities of defects by shift and defects by type.
    In order to compute the expected probabilities, we need to start with some simple
    sums. The first is the overall sum of all defects, which can be calculated by
    executing the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算按班次和按类型的缺陷概率。为了计算预期概率，我们需要从一些简单的总数开始。首先是所有缺陷的总数，可以通过执行以下命令来计算：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is done directly from the values in the `Counter` object assigned to the
    `defects` variable. This will show that there are 309 total defects in the sample
    set.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是直接从分配给`defects`变量的`Counter`对象的值中得到的。这将显示样本集中总共有309个缺陷。
- en: We need to get defects by shift as well as defects by type. This means that
    we'll extract two kinds of subsets from the raw defect data. The "by-shift" extract
    will use just one part of the `(shift,defect type)` key in the `Counter` object.
    The "by-type" will use the other half of the key pair.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要按班次和按类型获取缺陷。这意味着我们将从原始缺陷数据中提取两种子集。"按班次"提取将仅使用`Counter`对象中`(班次，缺陷类型)`键的一部分。"按类型"将使用键对的另一半。
- en: 'We can summarize by creating additional `Counter` objects extracted from the
    initial set of the `Counter` objects assigned to the `defects` variable. Here''s
    the by-shift summary:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从分配给`defects`变量的`Counter`对象的初始集合中提取额外的`Counter`对象来进行总结。以下是按班次总结：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've created a collection of individual `Counter` objects that have a shift,
    `s`, as the key and the count of defects associated with that shift `defects[s,d]`.
    The generator expression will create 12 such `Counter` objects to extract data
    for all combinations of four defect types and three shifts. We'll combine the
    `Counter` objects with a `sum()` function to get three summaries organized by
    shift.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一组单独的`Counter`对象，这些对象以班次`s`为键，并与该班次相关的缺陷计数`defects[s,d]`。生成器表达式将创建12个这样的`Counter`对象，以提取所有四种缺陷类型和三个班次的数据。我们将使用`sum()`函数将`Counter`对象组合起来，以获得按班次组织的三个摘要。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't use the default initial value of 0 for the `sum()` function. We must
    provide an empty `Counter()` function as an initial value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`sum()`函数的默认初始值0。我们必须提供一个空的`Counter()`函数作为初始值。
- en: 'The type totals are created with an expression similar to the one used to create
    shift totals:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类型总数的创建方式与用于创建班次总数的表达式类似：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created a dozen `Counter` objects using the defect type, `d`, as the key
    instead of shift type; otherwise, the processing is identical.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一打`Counter`对象，使用缺陷类型`d`作为键，而不是班次类型；否则，处理是相同的。
- en: 'The shift totals look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 班次总数如下：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The defect type totals look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷类型的总数如下：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've kept the summaries as `Counter` objects, rather than creating simple `dict`
    objects or possibly even `list` instances. We'll generally use them as simple
    dicts from this point forward. However, there are some situations where we will
    want proper `Counter` objects instead of reductions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将摘要保留为`Counter`对象，而不是创建简单的`dict`对象或甚至`list`实例。从这一点开始，我们通常会将它们用作简单的dict。但是，在某些情况下，我们会希望使用适当的`Counter`对象，而不是缩减。
- en: Alternative summary approaches
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代摘要方法
- en: We've read the data and computed summaries in two separate steps. In some cases,
    we may want to create the summaries while reading the initial data. This is an
    optimization that might save a little bit of processing time. We could write a
    more complex input reduction that emitted the grand total, the shift totals, and
    the defect type totals. These `Counter` objects would be built one item at a time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分两步读取数据并计算摘要。在某些情况下，我们可能希望在读取初始数据时创建摘要。这是一种优化，可能会节省一点处理时间。我们可以编写一个更复杂的输入缩减，它会输出总数、班次总数和缺陷类型总数。这些`Counter`对象将逐个构建。
- en: We've focused on using the `Counter` instances, because they seem to allow us
    flexibility. Any changes to the data acquisition will still create `Counter` instances
    and won't change the subsequent analysis.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于使用`Counter`实例，因为它们似乎为我们提供了灵活性。对数据采集的任何更改仍将创建`Counter`实例，并不会改变后续的分析。
- en: 'Here''s how we can compute the probabilities of defect by shift and by defect
    type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何计算按班次和缺陷类型计算缺陷概率的方法：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ve created two dictionaries: `P_shift` and `P_type`. The `P_shift` dictionary
    maps a shift to a `Fraction` object that shows the shift''s contribution to the
    overall number of defects. Similarly, the `P_type` dictionary maps a defect type
    to a `Fraction` object that shows the type''s contribution to the overall number
    of defects.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个字典：`P_shift`和`P_type`。`P_shift`字典将一个班次映射到一个`Fraction`对象，显示了该班次对总缺陷数的贡献。类似地，`P_type`字典将一个缺陷类型映射到一个`Fraction`对象，显示了该类型对总缺陷数的贡献。
- en: We've elected to use `Fraction` objects to preserve all of the precision of
    the input values. When working with counts like this, we may get probability values
    that make more intuitive sense to people reviewing the data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用`Fraction`对象来保留输入值的所有精度。在处理这样的计数时，我们可能会得到更符合人们直观理解的概率值。
- en: We've elected to use `dict` objects because we've switched modes. At this point
    in the analysis, we're no longer accumulating details; we're using reductions
    to compare actual and observed data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用`dict`对象，因为我们已经切换了模式。在分析的这一点上，我们不再积累细节；我们使用缩减来比较实际和观察到的数据。
- en: 'The `P_shift` data looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_shift`数据看起来像这样：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `P_type` data looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`P_type`数据看起来像这样：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A value such as 32/103 or 96/309 might be more meaningful to some people than
    0.3106\. We can easily get `float` values from `Fraction` objects, as we'll see
    later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，例如32/103或96/309可能比0.3106更有意义。我们可以很容易地从`Fraction`对象中获得`float`值，后面我们会看到。
- en: The shifts all seem to be approximately at the same level of defect production.
    The defect types vary, which is typical. It appears that the defect `C` is a relatively
    common problem, whereas the defect `B` is much less common. Perhaps the second
    defect requires a more complex situation to arise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有班次似乎在缺陷产生方面大致相同。缺陷类型有所不同，这是典型的。似乎缺陷`C`是一个相对常见的问题，而缺陷`B`则要少得多。也许第二个缺陷需要更复杂的情况才会出现。
- en: Computing expected values and displaying a contingency table
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算预期值并显示列联表
- en: The expected defect production is a combined probability. We'll compute the
    shift defect probability multiplied by the probability based on defect type. This
    will allow us to compute all 12 probabilities from all combinations of shift and
    defect type. We can weight these with the observed numbers and compute the detailed
    expectation for defects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的缺陷产生是一个综合概率。我们将计算按班次的缺陷概率乘以基于缺陷类型的概率。这将使我们能够计算所有12种概率，从所有班次和缺陷类型的组合中。我们可以用观察到的数字来加权这些概率，并计算缺陷的详细预期。
- en: 'Here''s the calculation of expected values:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期值的计算：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll create a dictionary that parallels the initial `defects Counter` object.
    This dictionary will have a sequence of two tuples with keys and values. The keys
    will be two tuples of shift and defect type. Our dictionary is built from a generator
    expression that explicitly enumerates all combinations of keys from the `P_shift`
    and `P_type` dictionaries.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个与初始`defects Counter`对象相对应的字典。这个字典将有一个包含两个元组的序列，带有键和值。键将是班次和缺陷类型的两个元组。我们的字典是从一个生成器表达式构建的，该表达式明确列举了从`P_shift`和`P_type`字典中的所有键的组合。
- en: 'The value of the `expected` dictionary looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`expected`字典的值看起来像这样：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each item of the mapping has a key with shift and defect type. This is associated
    with a `Fraction` value based on the probability of defect based on shift times,
    the probability of a defect based on defect type times the overall number of defects.
    Some of the fractions are reduced, for example, a value of 6624/309 can be simplified
    to 2208/103.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的每个项目都有一个与班次和缺陷类型相关的键。这与基于缺陷的概率的`Fraction`值相关联，基于班次的概率乘以基于缺陷类型的概率乘以总缺陷数。一些分数被简化，例如，6624/309的值可以简化为2208/103。
- en: Large numbers are awkward as proper fractions. Displaying large values as `float`
    values is often easier. Small values (such as probabilities) are sometimes easier
    to understand as fractions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大数字作为适当的分数是尴尬的。将大值显示为`float`值通常更容易。小值（如概率）有时更容易理解为分数。
- en: 'We''ll print the observed and expected times in pairs. This will help us visualize
    the data. We''ll create something that looks like the following to help summarize
    what we''ve observed and what we expect:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将成对打印观察到的和预期的时间。这将帮助我们可视化数据。我们将创建类似以下内容的内容来帮助总结我们观察到的和我们期望的：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This shows 12 cells. Each cell has values with the observed number of defects
    and an expected number of defects. Each row ends with the shift totals, and each
    column has a footer with the defect totals.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了12个单元格。每个单元格都有观察到的缺陷数和期望的缺陷数。每行以变化总数结束，每列都有一个包含缺陷总数的页脚。
- en: In some cases, we might export this data in CSV notation and build a spreadsheet.
    In other cases, we'll build an HTML version of the contingency table and leave
    the layout details to a browser. We've shown a pure text version here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会以CSV格式导出这些数据并构建电子表格。在其他情况下，我们将构建列联表的HTML版本，并将布局细节留给浏览器。我们在这里展示了一个纯文本版本。
- en: 'Here''s a sequence of statements to create the contingency table shown previously:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建先前显示的列联表的一系列语句：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This spreads the defect types across each line. We've written enough `obs exp`
    column titles to cover all defect types. For each shift, we'll emit a line of
    observed and actual pairs, followed by a shift total. At the bottom, we'll emit
    a line of footers with just the defect type totals and the grand total.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将缺陷类型分布到每一行。我们已经写了足够的`obs exp`列标题来涵盖所有的缺陷类型。对于每个变化，我们将发出一行观察到的和实际的对，然后是一个变化的总数。在底部，我们将发出一个只有缺陷类型总数和总数的页脚行。
- en: A contingency table like this one helps us to visualize the comparison between
    observed and expected values. We can compute a chi-squared value for these two
    sets of values. This will help us decide if the data is random or if there's something
    that deserves further investigation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的列联表有助于我们可视化观察值和期望值之间的比较。我们可以计算这两组数值的卡方值。这将帮助我们决定数据是否是随机的，或者是否有值得进一步调查的地方。
- en: Computing the chi-squared value
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算卡方值
- en: The ![Computing the chi-squared value](graphics/B03652_16_35.jpg) value is based
    on ![Computing the chi-squared value](graphics/B03652_16_06.jpg), where the *e*
    values are the expected values and the *o* values are the observed values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![计算卡方值](graphics/B03652_16_35.jpg)的值基于![计算卡方值](graphics/B03652_16_06.jpg)，其中*e*值是期望值，*o*值是观察值。'
- en: 'We can compute the specified formula''s value as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算指定公式的值如下：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've defined a small `lambda` to help us optimize the calculation. This allows
    us to execute the `expected[s,t]` and `defects[s,t]` attributes just once, even
    though the expected value is used in two places. For this dataset, the final ![Computing
    the chi-squared value](graphics/B03652_16_35.jpg) value is 19.18.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个小的`lambda`来帮助我们优化计算。这使我们能够只执行一次`expected[s,t]`和`defects[s,t]`属性，即使期望值在两个地方使用。对于这个数据集，最终的卡方值为19.18。
- en: There are a total of six degrees of freedom based on three shifts and four defect
    types. Since we're considering them independent, we get *2×3=6*. A chi-squared
    table shows us that anything below 12.5916 would reflect 1 chance in 20 of the
    data being truly random. Since our value is 19.18, the data is unlikely to be
    random.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基于三个变化和四种缺陷类型，总共有六个自由度。由于我们认为它们是独立的，我们得到*2×3=6*。卡方表告诉我们，低于12.5916的任何值都反映了数据真正随机的1/20的机会。由于我们的值是19.18，数据不太可能是随机的。
- en: 'The cumulative distribution function for ![Computing the chi-squared value](graphics/B03652_16_35.jpg)
    shows that a value of 19.18 has a probability of the order of 0.00387: about 4
    chances in 1000 of being random. The next step is a follow-up study to discover
    the details of the various defect types and shifts. We''ll need to see which independent
    variable has the biggest correlation with defects and continue the analysis.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![计算卡方值](graphics/B03652_16_35.jpg)的累积分布函数显示，19.18的值有大约0.00387的概率：大约1000次中有4次是随机的。下一步是进行后续研究，以发现各种缺陷类型和变化的详细信息。我们需要看看哪个自变量与缺陷有最大的相关性，并继续分析。'
- en: Instead of following up with this case study, we'll look at a different and
    interesting calculation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与进行这个案例研究不同，我们将看一个不同且有趣的计算。
- en: Computing the chi-squared threshold
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算卡方阈值
- en: The essence of the ![Computing the chi-squared threshold](graphics/B03652_16_35.jpg)
    test is a threshold value based on the number of degrees of freedom and the level
    of uncertainty we're willing to entertain in accepting or rejecting the null hypothesis.
    Conventionally, we're advised to use a threshold around 0.05 (1/20) to reject
    the null hypothesis. We'd like there to be only 1 chance in 20 that the data is
    simply random and it appears meaningful. In other words, we'd like there to be
    19 chances in 20 that the data reflects simple random variation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![计算卡方阈值](graphics/B03652_16_35.jpg)测试的本质是基于自由度的数量和我们愿意接受或拒绝零假设的不确定性水平的阈值。通常，我们建议使用约0.05（1/20）的阈值来拒绝零假设。我们希望数据只有20分之1的机会是纯粹随机的，而且它看起来是有意义的。换句话说，我们希望有20次中有19次数据反映了简单的随机变化。'
- en: The chi-squared values are usually provided in tabular form because the calculation
    involves a number of transcendental functions. In some cases, libraries will provide
    the ![Computing the chi-squared threshold](graphics/B03652_16_35.jpg) cumulative
    distribution function, allowing us to compute a value rather than look one up
    on tabulation of important values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方值通常以表格形式提供，因为计算涉及一些超越函数。在某些情况下，库将提供![计算卡方阈值](graphics/B03652_16_35.jpg)累积分布函数，允许我们计算一个值，而不是在重要值的表上查找一个值。
- en: 'The cumulative distribution function for a ![Computing the chi-squared threshold](graphics/B03652_16_35.jpg)
    value, *x*, and degrees of freedom, *f*, is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于![计算卡方阈值](graphics/B03652_16_35.jpg)值*x*和自由度*f*的累积分布函数定义如下：
- en: '![Computing the chi-squared threshold](graphics/B03652_16_07.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![计算卡方阈值](graphics/B03652_16_07.jpg)'
- en: It's common to the probability of being random as ![Computing the chi-squared
    threshold](graphics/B03652_16_08.jpg). That is, if *p > 0.05*, the data can be
    understood as random; the null hypothesis is true.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将随机性视为![计算卡方阈值](graphics/B03652_16_08.jpg)是很常见的。也就是说，如果*p > 0.05*，则数据可以被理解为随机的；零假设成立。
- en: 'This requires two calculations: the incomplete `gamma` function, ![Computing
    the chi-squared threshold](graphics/B03652_16_09.jpg), and the complete `gamma`
    function, ![Computing the chi-squared threshold](graphics/B03652_16_10.jpg). These
    can involve some fairly complex math. We''ll cut some corners and implement two
    pretty-good approximations that are narrowly focused on just this problem. Each
    of these functions will allow us to look at functional design issues.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要两个计算：不完整的`伽玛`函数，![计算卡方阈值](graphics/B03652_16_09.jpg)，和完整的`伽玛`函数，![计算卡方阈值](graphics/B03652_16_10.jpg)。这可能涉及一些相当复杂的数学。我们将简化一些步骤，并实现两个非常好的近似，专注于解决这个问题。这些函数中的每一个都将允许我们查看功能设计问题。
- en: 'Both of these functions will require a factorial calculation, ![Computing the
    chi-squared threshold](graphics/B03652_16_11.jpg). We''ve seen several variations
    on the fractions theme. We''ll use the following one:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都需要一个阶乘计算，![计算卡方阈值](graphics/B03652_16_11.jpg)。我们已经看到了几种分数主题的变化。我们将使用以下一个：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is ![Computing the chi-squared threshold](graphics/B03652_16_12.jpg):
    a product of numbers from 2 to *k* (inclusive). We''ve omitted the unit test cases.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是![计算卡方阈值](graphics/B03652_16_12.jpg)：从2到*k*（包括*k*）的数字的乘积。我们省略了单元测试案例。
- en: Computing the partial gamma value
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算部分伽玛值
- en: The partial `gamma` function has a simple series expansion. This means that
    we're going to compute a sequence of values and then do a sum on those values.
    For more information, visit [http://dlmf.nist.gov/8](http://dlmf.nist.gov/8).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 部分`伽玛`函数有一个简单的级数展开。这意味着我们将计算一系列值，然后对这些值进行求和。欲了解更多信息，请访问[http://dlmf.nist.gov/8](http://dlmf.nist.gov/8)。
- en: '![Computing the partial gamma value](graphics/B03652_16_13.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![计算部分伽玛值](graphics/B03652_16_13.jpg)'
- en: 'This series will have a sequence of terms that—eventually—become too small
    to be relevant. The calculation ![Computing the partial gamma value](graphics/B03652_16_14.jpg)
    will yield alternating signs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列将有一系列项，最终变得太小而不相关。计算![计算部分伽玛值](graphics/B03652_16_14.jpg)将产生交替的符号：
- en: '![Computing the partial gamma value](graphics/B03652_16_15.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![计算部分伽玛值](graphics/B03652_16_15.jpg)'
- en: 'The sequence of terms looks like this with *s=1* and *z=2*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当*s=1*和*z=2*时，项的序列如下：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At some point, each additional term won't have any significant impact on the
    result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，每个额外的项对结果不会产生重大影响。
- en: When we look back at the cumulative distribution function, ![Computing the partial
    gamma value](graphics/B03652_16_16.jpg), we can consider working with `fractions.Fraction`
    values. The degrees of freedom, *k*, will be an integer divided by 2\. The ![Computing
    the partial gamma value](graphics/B03652_16_35.jpg) value, *x*, may be either
    a `Fraction` or a `float` value; it will rarely be a simple integer value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾累积分布函数![计算部分伽玛值](graphics/B03652_16_16.jpg)时，我们可以考虑使用`fractions.Fraction`值。自由度*k*将是一个除以2的整数。![计算部分伽玛值](graphics/B03652_16_35.jpg)值*x*可能是`分数`或`浮点`值；它很少是一个简单的整数值。
- en: When evaluating the terms of ![Computing the partial gamma value](graphics/B03652_16_17.jpg),
    the value of ![Computing the partial gamma value](graphics/B03652_16_18.jpg) will
    involve integers and can be represented as a proper `Fraction` value. The value
    of ![Computing the partial gamma value](graphics/B03652_16_19.jpg) could be a
    `Fraction` or `float` value; it will lead to irrational values when ![Computing
    the partial gamma value](graphics/B03652_16_20.jpg) is not an `integer` value.
    The value of ![Computing the partial gamma value](graphics/B03652_16_20.jpg) will
    be a proper `Fraction` value, sometimes it will have the integer values, and sometimes
    it will have values that involve 1/2.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估计算部分伽玛值时，![计算部分伽玛值](graphics/B03652_16_17.jpg)的值将涉及整数，并且可以表示为适当的`分数`值。![计算部分伽玛值](graphics/B03652_16_18.jpg)的值可能是`分数`或`浮点`值；当![计算部分伽玛值](graphics/B03652_16_20.jpg)不是`整数`值时，它将导致无理数值。![计算部分伽玛值](graphics/B03652_16_20.jpg)的值将是一个适当的`分数`值，有时它将具有整数值，有时它将具有涉及1/2的值。
- en: The use of `Fraction` value here—while possible—doesn't seem to be helpful because
    there will be an irrational value computed. However, when we look at the complete
    `gamma` function given here, we'll see that `Fraction` values are potentially
    helpful. In this function, they're merely incidental.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`分数`值虽然可能，但似乎并不有用，因为将计算出一个无理数值。然而，当我们看这里给出的完整`伽玛`函数时，我们会发现`分数`值有潜在的帮助。在这个函数中，它们只是偶然发生的。
- en: 'Here''s an implementation of the previously explained series expansion:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前解释的级数展开的实现：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We defined a `term()` function that will yield a series of terms. We used a
    `for` statement with an upper limit to generate only 100 terms. We could have
    used the `itertools.count()` function to generate an infinite sequence of terms.
    It seems slightly simpler to use a loop with an upper bound.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`term()`函数，它将产生一系列项。我们使用了一个带有上限的`for`语句来生成只有100个项。我们可以使用`itertools.count()`函数来生成无限序列的项。使用带有上限的循环似乎更简单一些。
- en: We computed the irrational ![Computing the partial gamma value](graphics/B03652_16_19.jpg)
    value and created a `Fraction` value from this value by itself. If the value for
    *z* is also a `Fraction` value and not a `float` value then, the value for `t2`
    will be a `Fraction` value. The value for `term()` function will then be a product
    of two `Fraction` objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了无理数![计算部分伽玛值](graphics/B03652_16_19.jpg)值，并从这个值本身创建了一个`分数`值。如果*z*的值也是`分数`值而不是`浮点`值，那么`t2`的值将是`分数`值。`term()`函数的值将是两个`分数`对象的乘积。
- en: We defined a `take_until()` function that takes values from an iterable, until
    a given function is true. Once the function becomes true, no more values are consumed
    from the iterable. We also defined a small threshold value, `ε`, of ![Computing
    the partial gamma value](graphics/B03652_16_21.jpg). We'll take values from the
    `term()` function until the values are less than `ε`. The sum of these values
    is an approximation to the partial `gamma` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`take_until()`函数，它从可迭代对象中获取值，直到给定的函数为真。一旦函数变为真，就不会再从可迭代对象中获取更多的值。我们还定义了一个小的阈值`ε`，为![计算部分gamma值](graphics/B03652_16_21.jpg)。我们将从`term()`函数中获取值，直到这些值小于`ε`。这些值的总和是对部分“gamma”函数的近似。
- en: 'Here are some test cases we can use to confirm that we''re computing this properly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试案例，我们可以用来确认我们正在正确计算这个值：
- en: '![Computing the partial gamma value](graphics/B03652_16_22.jpg)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算部分gamma值](graphics/B03652_16_22.jpg)'
- en: '![Computing the partial gamma value](graphics/B03652_16_23.jpg)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算部分gamma值](graphics/B03652_16_23.jpg)'
- en: '![Computing the partial gamma value](graphics/B03652_16_24.jpg)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算部分gamma值](graphics/B03652_16_24.jpg)'
- en: The error function, `erf()`, is another interesting function. We won't look
    into it here because it's available in the Python math library.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数`erf()`是另一个有趣的函数。我们不会在这里探讨它，因为它在Python数学库中可用。
- en: Our interest is narrowly focused on the chi-squared distribution. We're not
    generally interested in the incomplete `gamma` function for other mathematical
    purposes. Because of this, we can narrow our test cases to the kinds of values
    we expect to be using. We can also limit the accuracy of the results. Most chi-squared
    tests involve three digits of precision. We've shown seven digits in the test
    data, which is more than we might properly need.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的兴趣集中在卡方分布上。我们通常不对其他数学目的的不完整“gamma”函数感兴趣。因此，我们可以将我们的测试案例限制在我们期望使用的值类型上。我们还可以限制结果的精度。大多数卡方检验涉及三位数的精度。我们在测试数据中显示了七位数，这比我们可能需要的要多。
- en: Computing the complete gamma value
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算完整的gamma值
- en: The complete `gamma` function is a bit more difficult. There are a number of
    different approximations. For more information, visit [http://dlmf.nist.gov/5](http://dlmf.nist.gov/5).
    There's a version available in the Python math library. It represents a broadly
    useful approximation that is designed for many situations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的“gamma”函数有点更难。有许多不同的近似值。有关更多信息，请访问[http://dlmf.nist.gov/5](http://dlmf.nist.gov/5)。Python数学库中有一个版本。它代表了一个广泛有用的近似值，专为许多情况而设计。
- en: 'We''re not actually interested in a general implementation of the complete
    `gamma` function. We''re interested in just two special cases: integer values
    and halves. For these two special cases, we can get exact answers, and don''t
    need to rely on an approximation.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并不对完整的“gamma”函数的一般实现感兴趣。我们只对两种特殊情况感兴趣：整数值和一半。对于这两种特殊情况，我们可以得到确切的答案，不需要依赖近似值。
- en: For integer values, ![Computing the complete gamma value](graphics/B03652_16_25.jpg).
    The `gamma` function for integers can rely on the factorial function we defined
    previously.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数值，![计算完整的gamma值](graphics/B03652_16_25.jpg)。整数的`gamma`函数可以依赖于我们之前定义的阶乘函数。
- en: 'For halves, there''s a special form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一半，有一个特殊的形式：
- en: '![Computing the complete gamma value](graphics/B03652_16_26.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![计算完整的gamma值](graphics/B03652_16_26.jpg)'
- en: This includes an irrational value, so we can only represent this approximately
    using `float` or `Fraction` objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括一个无理数值，因此我们只能使用`float`或`Fraction`对象来近似表示它。
- en: Since the chi-squared cumulative distribution function only uses the following
    two features of the complete `gamma` function, we don't need a general approach.
    We can cheat and use the following two values, which are reasonably precise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于卡方累积分布函数只使用完整“gamma”函数的以下两个特征，我们不需要一般方法。我们可以欺骗并使用以下两个值，它们相当精确。
- en: 'If we use proper `Fraction` values, then we can design a function with a few
    simple cases: an `integer` value, a `Fraction` value with 1 in the denominator,
    and a `Fraction` value with 2 in the denominator. We can use the `Fraction` value
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用适当的“分数”值，那么我们可以设计一个具有几个简单情况的函数：一个“整数”值，一个分母为1的“分数”值，以及一个分母为2的“分数”值。我们可以使用“分数”值如下：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We called the function `Gamma_Half` to emphasize that this is only appropriate
    for whole numbers and halves. For integer values, we''ll use the `fact()` function
    that was defined previously. For `Fraction` objects with a denominator of 1, we''ll
    use the same `fact()` definition: ![Computing the complete gamma value](graphics/B03652_16_25.jpg).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数称为`Gamma_Half`，以强调这仅适用于整数和一半。对于整数值，我们将使用之前定义的`fact()`函数。对于分母为1的“分数”对象，我们将使用相同的`fact()`定义：![计算完整的gamma值](graphics/B03652_16_25.jpg)。
- en: For the cases where the denominator is 2, we can use the more complex "closed
    form" value. We used an explicit `Fraction()` function for the value ![Computing
    the complete gamma value](graphics/B03652_16_27.jpg). We've also provided a `Fraction`
    approximation for the irrational value ![Computing the complete gamma value](graphics/B03652_16_28.jpg).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分母为2的情况，我们可以使用更复杂的“闭式”值。我们对值![计算完整的gamma值](graphics/B03652_16_27.jpg)使用了显式的`Fraction()`函数。我们还为无理数值![计算完整的gamma值](graphics/B03652_16_28.jpg)提供了一个`Fraction`近似值。
- en: 'Here are some test cases:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试案例：
- en: '![Computing the complete gamma value](graphics/B03652_16_29.jpg)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算完整的gamma值](graphics/B03652_16_29.jpg)'
- en: '![Computing the complete gamma value](graphics/B03652_16_30.jpg)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算完整的gamma值](graphics/B03652_16_30.jpg)'
- en: '![Computing the complete gamma value](graphics/B03652_16_31.jpg)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算完整的gamma值](graphics/B03652_16_31.jpg)'
- en: '![Computing the complete gamma value](graphics/B03652_16_32.jpg)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![计算完整的gamma值](graphics/B03652_16_32.jpg)'
- en: 'These can also be shown as proper `Fraction` values. The irrational values
    lead to large, hard-to-read fractions. We can use something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也可以显示为适当的“分数”值。无理数导致大而难以阅读的分数。我们可以使用类似这样的东西：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This provides a value where the denominator has been limited to be in the range
    of 1 to 2 million; this provides pleasant-looking six-digit numbers that we can
    use for unit test purposes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个数值，其中分母被限制在1到200万的范围内；这提供了看起来很好的六位数，我们可以用于单元测试目的。
- en: Computing the odds of a distribution being random
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算分布随机性的概率
- en: Now that we have the incomplete `gamma` function, `gamma`, and complete `gamma`
    function, `Gamma_Half`, we can compute the ![Computing the odds of a distribution
    being random](graphics/B03652_16_35.jpg) `CDF` values. The `CDF` value shows us
    the odds of a given ![Computing the odds of a distribution being random](graphics/B03652_16_35.jpg)
    value being random or having some possible correlation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了不完整的`gamma`函数，`gamma`，和完整的`gamma`函数，`Gamma_Half`，我们可以计算出分布随机性的概率值。`CDF`值向我们展示了给定值的分布随机性或可能的相关性的概率。
- en: 'The function itself is quite small:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身非常小：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We included some `docstring` comments to clarify the parameters. We created
    proper `Fraction` objects from the degrees of freedom and the chi-squared value,
    *x*. When converting a `float` value to a `Fraction` object, we'll create a very
    large fractional result with a large number of entirely irrelevant digits.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一些`docstring`注释来澄清参数。我们从自由度和卡方值*x*创建了正确的`Fraction`对象。当将一个`float`值转换为一个`Fraction`对象时，我们将得到一个非常大的分数结果，带有许多完全无关的数字。
- en: We can use `Fraction(x/2).limit_denominator(1000)` to limit the size of the
    `x/2` `Fraction` method to a respectably small number of digits. This will compute
    a correct `CDF` value, but won't lead to gargantuan fractions with dozens of digits.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Fraction(x/2).limit_denominator(1000)`来限制`x/2`的`Fraction`方法的大小为一个相当小的数字。这将计算出一个正确的`CDF`值，但不会导致有数十位数字的巨大分数。
- en: Here are some sample data called from a table of ![Computing the odds of a distribution
    being random](graphics/B03652_16_35.jpg). Visit [http://en.wikipedia.org/wiki/Chi-squared_distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution)
    for more information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些从一个表中调用的样本数据，用于计算分布随机性的概率。访问[http://en.wikipedia.org/wiki/Chi-squared_distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution)获取更多信息。
- en: 'To compute the correct `CDF` values execute the following commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算正确的`CDF`值，请执行以下命令：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Given ![Computing the odds of a distribution being random](graphics/B03652_16_35.jpg)
    and a number of degrees of freedom, our `CDF` function produces the same results
    as a widely used table of values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个自由度的值和一个自由度的数量，我们的`CDF`函数产生了与一个广泛使用的值表相同的结果。
- en: 'Here''s an entire row from a ![Computing the odds of a distribution being random](graphics/B03652_16_35.jpg)
    table, computed with a simple generator expression:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从一个表中的整行，用一个简单的生成器表达式计算出来的：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The expected values are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 预期值如下：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have some tiny discrepancies in the third decimal place.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第三位小数上有一些微小的差异。
- en: What we can do with this is get a probability from a ![Computing the odds of
    a distribution being random](graphics/B03652_16_35.jpg) value. From our example
    shown previously, the 0.05 probability for six degrees of freedom has a ![Computing
    the odds of a distribution being random](graphics/B03652_16_35.jpg) value 12.5916
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个值中得到一个概率，这个值是从一个分布随机性的概率表中获取的。从我们之前展示的例子中，自由度为6时的0.05概率对应的值为12.5916。
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The actual value we got for ![Computing the odds of a distribution being random](graphics/B03652_16_35.jpg)
    in the example was 19.18\. Here''s the probability that this value is random:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，我们得到的实际值为19.18。这是这个值是随机的概率：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This probability is 3/775, with the denominator limited to 1000\. Those are
    not good odds of the data being random.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概率是3/775，分母限制为1000。这些不是数据随机性的好概率。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at three optimization techniques. The first technique
    involves finding the right algorithm and data structure. This has more impact
    on performance than any other single design or programming decision. Using the
    right algorithm can easily reduce runtimes from minutes to fractions of a second.
    Changing a poorly used sequence to a properly used mapping, for example, may reduce
    run time by a factor of 200.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了三种优化技术。第一种技术涉及找到合适的算法和数据结构。这对性能的影响比任何其他单个设计或编程决策都要大。使用正确的算法可以轻松将运行时间从几分钟减少到几秒钟。例如，将一个使用不当的序列更改为一个正确使用的映射，可能会将运行时间减少200倍。
- en: We should generally optimize all of our recursions to be loops. This will be
    faster in Python and it won't be stopped by the call stack limit that Python imposes.
    There are many examples of how recursions are flattened into loops in other chapters,
    primarily, [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions
    and Reductions*. Additionally, we may be able to improve performance in two other
    ways. First, we can apply memoization to cache results. For numeric calculations,
    this can have a large impact; for collections, the impact may be less. Secondly,
    replacing large materialized data objects with iterables may also improve performance
    by reducing the amount of memory management required.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常应该优化我们所有的递归为循环。这在Python中会更快，而且不会被Python施加的调用堆栈限制所阻止。在其他章节中有许多递归被转换为循环的例子，主要是[第6章](ch06.html
    "第6章. 递归和简化"), *递归和简化*。此外，我们可能还可以通过两种其他方式来提高性能。首先，我们可以应用记忆化来缓存结果。对于数值计算，这可能会产生很大的影响；对于集合，影响可能会小一些。其次，用可迭代对象替换大型物化数据对象也可能通过减少所需的内存管理量来提高性能。
- en: In the case study presented in this chapter, we looked at the advantage of using
    Python for exploratory data analysis—the initial data acquisition including a
    little bit of parsing and filtering. In some cases, a significant amount of effort
    is required to normalize data from various sources. This is a task at which Python
    excels.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章介绍的案例研究中，我们看到了使用Python进行探索性数据分析的优势——初始数据获取包括一点解析和过滤。在某些情况下，需要大量的工作来规范来自各种来源的数据。这是Python擅长的任务。
- en: 'The calculation of a ![Summary](graphics/B03652_16_35.jpg) value involved three
    `sum()` functions: two intermediate generator expressions, and a final generator
    expression to create a dictionary with expected values. A final `sum()` function
    created the statistic. In under a dozen expressions, we created a sophisticated
    analysis of data that will help us accept or reject the null hypothesis.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个![Summary](graphics/B03652_16_35.jpg)值涉及三个`sum()`函数：两个中间的生成器表达式，以及一个最终的生成器表达式来创建一个带有期望值的字典。最后一个`sum()`函数创建了统计数据。在不到十几个表达式的情况下，我们创建了一种复杂的数据分析，这将帮助我们接受或拒绝零假设。
- en: 'We also evaluated some complex statistical functions: the incomplete and the
    complete `gamma` function. The incomplete `gamma` function involves a potentially
    infinite series; we truncated this and summed the values. The complete `gamma`
    function has some potential complexity, but it doesn''t happen to apply in our
    case.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还评估了一些复杂的统计函数：不完全和完全的“gamma”函数。不完全的“gamma”函数涉及潜在的无限级数；我们对此进行了截断并求和。完全的“gamma”函数具有一定的复杂性，但在我们的情况下并不适用。
- en: Using a functional approach, we can write succinct and expressive programs that
    accomplish a great deal of processing. Python isn't a properly functional programming
    language. For example, we're required to use some imperative programming techniques.
    This limitation forces away from purely functional recursions. We gain some performance
    advantage, since we're forced to optimize tail recursions into explicit loops.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能性方法，我们可以编写简洁而富有表现力的程序，完成大量处理。Python并不是一种完全的函数式编程语言。例如，我们需要使用一些命令式编程技术。这种限制迫使我们远离纯函数式递归。我们获得了一些性能优势，因为我们被迫将尾递归优化为显式循环。
- en: We also saw numerous advantages of adopting Python's hybrid style of functional
    programming. In particular, the use of Python's higher order functions and generator
    expressions give us a number of ways to write high performance programs that are
    often quite clear and simple.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了采用Python的混合式函数式编程风格的许多优势。特别是，使用Python的高阶函数和生成器表达式给了我们许多编写高性能程序的方法，这些程序通常非常清晰简单。
