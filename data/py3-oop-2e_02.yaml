- en: Chapter 2. Objects in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 Python中的对象
- en: So, we now have a design in hand and are ready to turn that design into a working
    program! Of course, it doesn't usually happen this way. We'll be seeing examples
    and hints for good software design throughout the book, but our focus is object-oriented
    programming. So, let's have a look at the Python syntax that allows us to create
    object-oriented software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在手头有一个设计，并准备将该设计转化为一个可工作的程序！当然，通常情况下不会这样发生。在整本书中，我们将看到良好软件设计的示例和提示，但我们的重点是面向对象编程。因此，让我们看一下Python语法，以便我们可以创建面向对象的软件。
- en: 'After completing this chapter, we will understand:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将了解：
- en: How to create classes and instantiate objects in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python中创建类和实例化对象
- en: How to add attributes and behaviors to Python objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向Python对象添加属性和行为
- en: How to organize classes into packages and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类组织成包和模块
- en: How to suggest people don't clobber our data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建议人们不要破坏我们的数据
- en: Creating Python classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Python类
- en: We don't have to write much Python code to realize that Python is a very "clean"
    language. When we want to do something, we just do it, without having to go through
    a lot of setup. The ubiquitous "hello world" in Python, as you've likely seen,
    is only one line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必写太多Python代码就能意识到Python是一种非常“干净”的语言。当我们想做某事时，我们只需去做，而不必经历很多设置。Python中无处不在的“hello
    world”，正如你可能已经看到的，只有一行。
- en: 'Similarly, the simplest class in Python 3 looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Python 3中最简单的类如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's our first object-oriented program! The class definition starts with
    the `class` keyword. This is followed by a name (of our choice) identifying the
    class, and is terminated with a colon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个面向对象的程序！类定义以`class`关键字开头。然后是一个名称（我们选择的）来标识类，并以冒号结束。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The class name must follow standard Python variable naming rules (it must start
    with a letter or underscore, and can only be comprised of letters, underscores,
    or numbers). In addition, the Python style guide (search the web for "PEP 8")
    recommends that classes should be named using **CamelCase** notation (start with
    a capital letter; any subsequent words should also start with a capital).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类名必须遵循标准的Python变量命名规则（必须以字母或下划线开头，只能由字母、下划线或数字组成）。此外，Python风格指南（在网上搜索“PEP 8”）建议使用**驼峰命名法**（以大写字母开头；任何后续单词也应以大写字母开头）命名类。
- en: The class definition line is followed by the class contents indented. As with
    other Python constructs, indentation is used to delimit the classes, rather than
    braces or brackets as many other languages use. Use four spaces for indentation
    unless you have a compelling reason not to (such as fitting in with somebody else's
    code that uses tabs for indents). Any decent programming editor can be configured
    to insert four spaces whenever the *Tab* key is pressed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义行后面是缩进的类内容。与其他Python结构一样，缩进用于界定类，而不是像许多其他语言一样使用大括号或方括号。除非有充分的理由（例如适应其他人使用制表符缩进的代码），否则使用四个空格进行缩进。任何体面的编程编辑器都可以配置为在按下*Tab*键时插入四个空格。
- en: Since our first class doesn't actually do anything, we simply use the `pass`
    keyword on the second line to indicate that no further action needs to be taken.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个类实际上并没有做任何事情，因此我们在第二行使用`pass`关键字来指示不需要采取进一步的行动。
- en: 'We might think there isn''t much we can do with this most basic class, but
    it does allow us to instantiate objects of that class. We can load the class into
    the Python 3 interpreter, so we can interactively play with it. To do this, save
    the class definition mentioned earlier into a file named `first_class.py` and
    then run the command `python -i first_class.py`. The `-i` argument tells Python
    to "run the code and then drop to the interactive interpreter". The following
    interpreter session demonstrates basic interaction with this class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为这个最基本的类没有太多可以做的事情，但它确实允许我们实例化该类的对象。我们可以将该类加载到Python 3解释器中，以便可以与其进行交互。为此，将前面提到的类定义保存到名为`first_class.py`的文件中，然后运行命令`python
    -i first_class.py`。`-i`参数告诉Python“运行代码，然后转到交互式解释器”。以下解释器会话演示了与该类的基本交互：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code instantiates two objects from the new class, named `a` and `b`. Creating
    an instance of a class is a simple matter of typing the class name followed by
    a pair of parentheses. It looks much like a normal function call, but Python knows
    we're "calling" a class and not a function, so it understands that its job is
    to create a new object. When printed, the two objects tell us which class they
    are and what memory address they live at. Memory addresses aren't used much in
    Python code, but here, they demonstrate that there are two distinct objects involved.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从新类实例化了两个对象，命名为`a`和`b`。创建类的实例只需简单地输入类名，后跟一对括号。它看起来很像一个普通的函数调用，但Python知道我们正在“调用”一个类而不是一个函数，因此它知道它的工作是创建一个新对象。当打印时，这两个对象告诉我们它们是哪个类，以及它们所在的内存地址。在Python代码中很少使用内存地址，但在这里，它们表明涉及了两个不同的对象。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中购买的所有Packt图书下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: Adding attributes
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加属性
- en: Now, we have a basic class, but it's fairly useless. It doesn't contain any
    data, and it doesn't do anything. What do we have to do to assign an attribute
    to a given object?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个基本的类，但它相当无用。它不包含任何数据，也不做任何事情。我们必须怎么做才能将属性分配给给定的对象？
- en: 'It turns out that we don''t have to do anything special in the class definition.
    We can set arbitrary attributes on an instantiated object using the dot notation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在类定义中我们不必做任何特殊的事情。我们可以使用点符号在实例化的对象上设置任意属性：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run this code, the two `print` statements at the end tell us the new
    attribute values on the two objects:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，结尾的两个`print`语句会告诉我们两个对象的新属性值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code creates an empty `Point` class with no data or behaviors. Then it
    creates two instances of that class and assigns each of those instances `x` and
    `y` coordinates to identify a point in two dimensions. All we need to do to assign
    a value to an attribute on an object is use the *<object>.<attribute> = <value>*
    syntax. This is sometimes referred to as **dot notation**. The value can be anything:
    a Python primitive, a built-in data type, or another object. It can even be a
    function or another class!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个没有数据或行为的空`Point`类。然后它创建了该类的两个实例，并分配给这些实例`x`和`y`坐标，以标识二维空间中的一个点。我们只需要使用*<object>.<attribute>
    = <value>*语法为对象的属性赋值。这有时被称为**点符号**。值可以是任何东西：Python原语、内置数据类型或另一个对象。甚至可以是一个函数或另一个类！
- en: Making it do something
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它做点什么
- en: Now, having objects with attributes is great, but object-oriented programming
    is really about the interaction between objects. We're interested in invoking
    actions that cause things to happen to those attributes. It is time to add behaviors
    to our classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有属性的对象很棒，但面向对象编程实际上是关于对象之间的交互。我们感兴趣的是调用导致这些属性发生变化的操作。是时候给我们的类添加行为了。
- en: 'Let''s model a couple of actions on our `Point` class. We can start with a
    called `reset` that moves the point to the origin (the origin is the point where
    `x` and `y` are both zero). This is a good introductory action because it doesn''t
    require any parameters:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟`Point`类上的一些操作。我们可以从一个名为`reset`的操作开始，将点移动到原点（原点是`x`和`y`都为零的点）。这是一个很好的入门操作，因为它不需要任何参数：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `print` statement shows us the two zeros on the attributes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`print`语句向我们展示了属性上的两个零：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A method in Python is formatted identically to a function. It starts with the
    keyword `def` followed by a space and the name of the method. This is followed
    by a set of parentheses containing the parameter list (we'll discuss that `self`
    parameter in just a moment), and terminated with a colon. The next line is indented
    to contain the statements inside the method. These statements can be arbitrary
    Python code operating on the object itself and any parameters passed in as the
    method sees fit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，方法的格式与函数完全相同。它以关键字`def`开头，后面跟着一个空格和方法的名称。然后是一组括号，其中包含参数列表（我们将在接下来讨论`self`参数），最后以冒号结束。下一行缩进包含方法内部的语句。这些语句可以是任意的Python代码，操作对象本身和任何传递给方法的参数。
- en: Talking to yourself
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自言自语
- en: The one difference between methods and normal functions is that all methods
    have one required argument. This argument is conventionally named `self`; I've
    never seen a programmer use any other name for this variable (convention is a
    very powerful thing). There's nothing stopping you, however, from calling it `this`
    or even `Martha`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和普通函数之间的唯一区别是所有方法都有一个必需的参数。这个参数通常被命名为`self`；我从未见过程序员使用其他名称来命名这个变量（约定是一件非常有力的事情）。然而，没有什么能阻止你将其命名为`this`甚至`Martha`。
- en: The `self` argument to a method is simply a reference to the object that the
    method is being invoked on. We can access attributes and methods of that object
    as if it were any another object. This is exactly what we do inside the `reset`
    method when we set the `x` and `y` attributes of the `self` object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的`self`参数只是对方法被调用的对象的引用。我们可以访问该对象的属性和方法，就好像它是另一个对象一样。这正是我们在`reset`方法中设置`self`对象的`x`和`y`属性时所做的。
- en: Notice that when we call the `p.reset()` method, we do not have to pass the
    `self` argument into it. Python automatically takes care of this for us. It knows
    we're calling a method on the `p` object, so it automatically passes that object
    to the method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用`p.reset()`方法时，我们不必将`self`参数传递给它。Python会自动为我们处理这个问题。它知道我们在调用`p`对象上的方法，所以会自动将该对象传递给方法。
- en: 'However, the method really is just a function that happens to be on a class.
    Instead of calling the method on the object, we can invoke the function on the
    class, explicitly passing our object as the `self` argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个方法实际上只是一个恰好在类上的函数。我们可以在类上调用方法，显式地将我们的对象作为`self`参数传递：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output is the same as the previous example because internally, the exact
    same process has occurred.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个示例相同，因为在内部，发生了完全相同的过程。
- en: 'What happens if we forget to include the `self` argument in our class definition?
    Python will bail with an error message:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类定义中忘记包括`self`参数会发生什么？Python会报错：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The error message is not as clear as it could be ("You silly fool, you forgot
    the `self` argument" would be more informative). Just remember that when you see
    an error message that indicates missing arguments, the first thing to check is
    whether you forgot `self` in the method definition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息并不像它本应该的那样清晰（"你这个傻瓜，你忘记了`self`参数"会更有信息量）。只要记住，当你看到指示缺少参数的错误消息时，首先要检查的是你是否在方法定义中忘记了`self`。
- en: More arguments
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多参数
- en: 'So, how do we pass multiple arguments to a method? Let''s add a new method
    that allows us to move a point to an arbitrary position, not just to the origin.
    We can also include one that accepts another `Point` object as input and returns
    the distance between them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何向方法传递多个参数呢？让我们添加一个新的方法，允许我们将一个点移动到任意位置，而不仅仅是原点。我们还可以包括一个接受另一个`Point`对象作为输入并返回它们之间距离的方法：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `print` statements at the end give us the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`print`语句给出了以下输出：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot has happened here. The class now has three methods. The `move` method
    accepts two arguments, `x` and `y`, and sets the values on the `self` object,
    much like the old `reset` method from the previous example. The old `reset` method
    now calls `move`, since a reset is just a move to a specific known location.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。这个类现在有三种方法。`move`方法接受两个参数，`x`和`y`，并在`self`对象上设置这些值，就像前面示例中的旧`reset`方法一样。旧的`reset`方法现在调用`move`，因为重置只是移动到一个特定的已知位置。
- en: The `calculate_distance` method uses the not-too-complex Pythagorean theorem
    to calculate the distance between two points. I hope you understand the math (`**`
    means squared, and `math.sqrt` calculates a square root), but it's not a requirement
    for our current focus, learning how to write methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_distance`方法使用不太复杂的勾股定理来计算两点之间的距离。我希望你理解这个数学（`**`表示平方，`math.sqrt`计算平方根），但这并不是我们当前重点学习的要求，我们的当前重点是学习如何编写方法。'
- en: 'The sample code at the end of the preceding example shows how to call a method
    with arguments: simply include the arguments inside the parentheses, and use the
    same dot notation to access the method. I just picked some random positions to
    test the methods. The test code calls each method and prints the results on the
    console. The `assert` function is a simple test tool; the program will bail if
    the statement after `assert` is `False` (or zero, empty, or `None`). In this case,
    we use it to ensure that the distance is the same regardless of which point called
    the other point''s `calculate_distance` method.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的最后显示了如何使用参数调用方法的示例代码：只需在括号内包含参数，并使用相同的点表示法访问方法。我只是随机选择了一些位置来测试这些方法。测试代码调用每个方法并在控制台上打印结果。`assert`函数是一个简单的测试工具；如果`assert`后面的语句为`False`（或零、空或`None`），程序将会中止。在这种情况下，我们使用它来确保无论哪个点调用另一个点的`calculate_distance`方法，距离都是相同的。
- en: Initializing the object
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化对象
- en: If we don't explicitly set the `x` and `y` positions on our `Point` object,
    either using `move` or by accessing them directly, we have a broken point with
    no real position. What will happen when we try to access it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不显式设置`Point`对象上的`x`和`y`位置，要么使用`move`，要么直接访问它们，我们就会得到一个没有真实位置的损坏的点。当我们尝试访问它时会发生什么呢？
- en: 'Well, let''s just try it and see. "Try it and see" is an extremely useful tool
    for Python study. Open up your interactive interpreter and type away. The following
    interactive session shows what happens if we try to access a missing attribute.
    If you saved the previous example as a file or are using the examples distributed
    with the book, you can load it into the Python interpreter with the command `python
    -i filename.py`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们试试看。"试一试看"是Python学习中非常有用的工具。打开你的交互式解释器，然后开始输入。以下交互式会话显示了如果我们尝试访问一个缺失的属性会发生什么。如果你将前面的示例保存为文件，或者正在使用本书分发的示例，你可以使用命令`python
    -i filename.py`将其加载到Python解释器中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Well, at least it threw a useful exception. We'll cover exceptions in detail
    in [Chapter 4](ch04.html "Chapter 4. Expecting the Unexpected"), *Expecting the
    Unexpected*. You've probably seen them before (especially the ubiquitous **SyntaxError**,
    which means you typed something incorrectly!). At this point, simply be aware
    that it means something went wrong.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，至少它抛出了一个有用的异常。我们将在[第4章](ch04.html "第4章。预料之外")*预料之外*中详细介绍异常。你可能以前见过它们（特别是无处不在的**SyntaxError**，它意味着你输入了错误的东西！）。在这一点上，只要意识到它意味着出了问题就可以了。
- en: The output is useful for debugging. In the interactive interpreter, it tells
    us the error occurred at **line 1**, which is only partially true (in an interactive
    session, only one line is executed at a time). If we were running a script in
    a file, it would tell us the exact line number, making it easy to find the offending
    code. In addition, it tells us the error is an `AttributeError`, and gives a helpful
    message telling us what that error means.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对于调试是有用的。在交互式解释器中，它告诉我们错误发生在**第1行**，这只是部分正确的（在交互式会话中，一次只执行一行）。如果我们在文件中运行脚本，它会告诉我们确切的行号，这样很容易找到错误的代码。此外，它告诉我们错误是`AttributeError`，并给出了一个有用的消息告诉我们这个错误是什么意思。
- en: We can catch and recover from this error, but in this case, it feels like we
    should have specified some sort of default value. Perhaps every new object should
    be `reset()` by default, or maybe it would be nice if we could force the user
    to tell us what those positions should be when they create the object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获并从这个错误中恢复，但在这种情况下，感觉我们应该指定某种默认值。也许每个新对象默认应该是`reset()`，或者也许当用户创建对象时，我们可以强制用户告诉我们这些位置应该是什么。
- en: Most object-oriented programming languages have the concept of a **constructor**,
    a special method that creates and initializes the object when it is created. Python
    is a little different; it has a constructor *and* an initializer. The constructor
    function is rarely used unless you're doing something exotic. So, we'll start
    our discussion with the initialization method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有**构造函数**的概念，这是一个特殊的方法，在创建对象时创建和初始化对象。Python有点不同；它有一个构造函数*和*一个初始化器。构造函数很少使用，除非你在做一些奇特的事情。所以，我们将从初始化方法开始讨论。
- en: The Python initialization method is the same as any other method, except it
    has a special name, `__init__`. The leading and trailing double underscores mean
    this is a special method that the Python interpreter will treat as a special case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python的初始化方法与任何其他方法相同，只是它有一个特殊的名称`__init__`。前导和尾随的双下划线意味着这是一个Python解释器将视为特殊情况的特殊方法。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never name a function of your own with leading and trailing double underscores.
    It may mean nothing to Python, but there's always the possibility that the designers
    of Python will add a function that has a special purpose with that name in the
    future, and when they do, your code will break.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要用前导和尾随的双下划线命名自己的函数。它对Python可能没有任何意义，但总有可能Python的设计者将来会添加一个具有该名称的特殊目的的函数，当他们这样做时，你的代码将会出错。
- en: 'Let''s start with an initialization function on our `Point` class that requires
    the user to supply `x` and `y` coordinates when the `Point` object is instantiated:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的`Point`类上的一个初始化函数开始，当实例化`Point`对象时，需要用户提供`x`和`y`坐标：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, our point can never go without a `y` coordinate! If we try to construct
    a point without including the proper initialization parameters, it will fail with
    a **not enough arguments** error similar to the one we received earlier when we
    forgot the `self` argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的点永远不会没有`y`坐标！如果我们试图构造一个点而没有包括正确的初始化参数，它将失败并显示一个类似于我们之前忘记`self`参数时收到的**参数不足**错误。
- en: 'What if we don''t want to make those two arguments required? Well, then we
    can use the same syntax Python functions use to provide default arguments. The
    keyword argument syntax appends an equals sign after each variable name. If the
    calling object does not provide this argument, then the default argument is used
    instead. The variables will still be available to the function, but they will
    have the values specified in the argument list. Here''s an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想让这两个参数成为必需的呢？那么，我们可以使用Python函数使用的相同语法来提供默认参数。关键字参数语法在每个变量名后添加一个等号。如果调用对象没有提供这个参数，那么将使用默认参数。变量仍然可用于函数，但它们将具有参数列表中指定的值。这里有一个例子：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the time, we put our initialization statements in an `__init__` function.
    But as mentioned earlier, Python has a constructor in addition to its initialization
    function. You may never need to use the other Python constructor, but it helps
    to know it exists, so we'll cover it briefly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将初始化语句放在`__init__`函数中。但正如前面提到的，Python除了初始化函数外还有一个构造函数。你可能永远不需要使用另一个Python构造函数，但知道它的存在是有帮助的，所以我们会简要介绍一下。
- en: The constructor function is called `__new__` as opposed to `__init__`, and accepts
    exactly one argument; the class that is being constructed (it is called *before*
    the object is constructed, so there is no `self` argument). It also has to return
    the newly created object. This has interesting possibilities when it comes to
    the complicated art of metaprogramming, but is not very useful in day-to-day programming.
    In practice, you will rarely, if ever, need to use `__new__` and `__init__` will
    be sufficient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数被称为`__new__`，而不是`__init__`，并且只接受一个参数；正在构造的类（在对象构造之前调用，因此没有`self`参数）。它还必须返回新创建的对象。当涉及到复杂的元编程时，这具有有趣的可能性，但在日常编程中并不是非常有用。实际上，你很少甚至从不需要使用`__new__`，`__init__`就足够了。
- en: Explaining yourself
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释自己
- en: Python is an extremely easy-to-read programming language; some might say it
    is self-documenting. However, when doing object-oriented programming, it is important
    to write API documentation that clearly summarizes what each object and method
    does. Keeping documentation up-to-date is difficult; the best way to do it is
    to write it right into our code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常易于阅读的编程语言；有些人可能会说它是自我说明的。然而，在进行面向对象编程时，编写清晰总结每个对象和方法做什么的API文档是很重要的。保持文档的最新状态是困难的；最好的方法是将其直接写入我们的代码中。
- en: Python supports this through the use of **docstrings**. Each class, function,
    or method header can have a standard Python string as the first line following
    the definition (the line that ends in a colon). This line should be indented the
    same as the following code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过使用**docstrings**来支持这一点。每个类、函数或方法头部都可以有一个标准的Python字符串作为定义后的第一行（以冒号结尾的行）。这一行应该与后续的代码缩进相同。
- en: Docstrings are simply Python strings enclosed with apostrophe (`'`) or quote
    (`"`) characters. Often, docstrings are quite long and span multiple lines (the
    style guide suggests that the line length should not exceed 80 characters), which
    can be formatted as multi-line strings, enclosed in matching triple apostrophe
    (`'''`) or triple quote (`"""`) characters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串只是用撇号（`'`）或引号（`"`）括起来的Python字符串。通常，文档字符串非常长，跨越多行（风格指南建议行长不超过80个字符），可以格式化为多行字符串，用匹配的三个撇号（`'''`）或三个引号（`"""`）括起来。
- en: A docstring should clearly and concisely summarize the purpose of the class
    or method it is describing. It should explain any parameters whose usage is not
    immediately obvious, and is also a good place to include short examples of how
    to use the API. Any caveats or problems an unsuspecting user of the API should
    be aware of should also be noted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串应该清楚而简洁地总结所描述的类或方法的目的。它应该解释任何使用不是立即明显的参数，并且也是包含如何使用API的简短示例的好地方。任何使用API的用户应该注意的注意事项或问题也应该被记录下来。
- en: 'To illustrate the use of docstrings, we will end this section with our completely
    documented `Point` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明文档字符串的用法，我们将以完全记录的`Point`类结束本节：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Try typing or loading (remember, it''s `python -i filename.py`) this file into
    the interactive interpreter. Then, enter `help(Point)<enter>` at the Python prompt.
    You should see nicely formatted documentation for the class, as shown in the following
    screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在交互式解释器中键入或加载（记住，是`python -i filename.py`）这个文件。然后，在Python提示符下输入`help(Point)<enter>`。你应该会看到类的精美格式化文档，如下面的屏幕截图所示：
- en: '![Explaining yourself](images/8781OS_02_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![解释自己](images/8781OS_02_01.jpg)'
- en: Modules and packages
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: Now, we know how to create classes and instantiate objects, but how do we organize
    them? For small programs, we can just put all our classes into one file and add
    a little script at the end of the file to start them interacting. However, as
    our projects grow, it can become difficult to find the one class that needs to
    be edited among the many classes we've defined. This is where **modules** come
    in. Modules are simply Python files, nothing more. The single file in our small
    program is a module. Two Python files are two modules. If we have two files in
    the same folder, we can load a class from one module for use in the other module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何创建类和实例化对象，但是我们如何组织它们呢？对于小型程序，我们可以将所有类放入一个文件中，并在文件末尾添加一个小脚本来启动它们的交互。然而，随着项目的增长，很难在我们定义的许多类中找到需要编辑的类。这就是**模块**的用武之地。模块只是Python文件，没有别的。我们小程序中的单个文件就是一个模块。两个Python文件就是两个模块。如果我们在同一个文件夹中有两个文件，我们可以从一个模块中加载一个类以在另一个模块中使用。
- en: 'For example, if we are building an e-commerce system, we will likely be storing
    a lot of data in a database. We can put all the classes and functions related
    to database access into a separate file (we''ll call it something sensible: `database.py`).
    Then, our other modules (for example, customer models, product information, and
    inventory) can import classes from that module in order to access the database.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在构建一个电子商务系统，我们可能会在数据库中存储大量数据。我们可以将所有与数据库访问相关的类和函数放入一个单独的文件中（我们将其命名为一些合理的东西：`database.py`）。然后，我们的其他模块（例如，客户模型、产品信息和库存）可以导入该模块中的类以访问数据库。
- en: The `import` statement is used for importing modules or specific classes or
    functions from modules. We've already seen an example of this in our `Point` class
    in the previous section. We used the `import` statement to get Python's built-in
    `math` module and use its `sqrt` function in our `distance` calculation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句用于导入模块或特定类或函数。我们已经在上一节的`Point`类中看到了一个例子。我们使用`import`语句获取Python的内置`math`模块，并在我们的`distance`计算中使用它的`sqrt`函数。'
- en: Here's a concrete example. Assume we have a module called `database.py` that
    contains a class called `Database`, and a second module called `products.py` that
    is responsible for product-related queries. At this point, we don't need to think
    too much about the contents of these files. What we know is that `products.py`
    needs to instantiate the `Database` class from `database.py` so that it can execute
    queries on the product table in the database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具体的例子。假设我们有一个名为`database.py`的模块，其中包含一个名为`Database`的类，以及一个名为`products.py`的第二个模块，负责与产品相关的查询。在这一点上，我们不需要太过考虑这些文件的内容。我们知道的是`products.py`需要实例化`database.py`中的`Database`类，以便可以在数据库中的产品表上执行查询。
- en: 'There are several variations on the `import` statement syntax that can be used
    to access the class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句的语法有几种变体，可以用来访问类：'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This version imports the `database` module into the `products` namespace (the
    list of names currently accessible in a module or function), so any class or function
    in the `database` module can be accessed using the `database.<something>` notation.
    Alternatively, we can import just the one class we need using the `from`...`import`
    syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将`database`模块导入`products`命名空间（模块或函数中当前可访问的名称列表），因此可以使用`database.<something>`表示法访问`database`模块中的任何类或函数。或者，我们可以使用`from`...`import`语法只导入我们需要的一个类：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If, for some reason, `products` already has a class called `Database`, and
    we don''t want the two names to be confused, we can rename the class when used
    inside the `products` module:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，`products`已经有一个名为`Database`的类，我们不希望这两个名称混淆，我们可以在`products`模块内部使用时重命名该类：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also import multiple items in one statement. If our `database` module
    also contains a `Query` class, we can import both classes using:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一条语句中导入多个项目。如果我们的`database`模块还包含一个`Query`类，我们可以使用以下语法导入两个类：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some sources say that we can import all classes and functions from the `database`
    module using this syntax:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些来源表示，我们可以使用以下语法从`database`模块中导入所有类和函数：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don't do this. Every experienced Python programmer will tell you that you should
    never use this syntax. They'll use obscure justifications such as "it clutters
    up the namespace", which doesn't make much sense to beginners. One way to learn
    why to avoid this syntax is to use it and try to understand your code two years
    later. But we can save some time and two years of poorly written code with a quick
    explanation now!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。每个有经验的Python程序员都会告诉你，你永远不应该使用这种语法。他们会使用模糊的理由，比如“它会使命名空间混乱”，这对初学者来说并不太有意义。避免使用这种语法的一个方法是使用它，并在两年后尝试理解你的代码。但我们可以通过一个快速的解释节省一些时间和两年的糟糕代码！
- en: When we explicitly import the `database` class at the top of our file using
    `from database import Database`, we can easily see where the `Database` class
    comes from. We might use `db = Database()` 400 lines later in the file, and we
    can quickly look at the imports to see where that `Database` class came from.
    Then, if we need clarification as to how to use the `Database` class, we can visit
    the original file (or import the module in the interactive interpreter and use
    the `help(database.Database)` command). However, if we use the `from database
    import *` syntax, it takes a lot longer to find where that class is located. Code
    maintenance becomes a nightmare.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在文件顶部明确导入`database`类时，使用`from database import Database`，我们可以很容易地看到`Database`类来自哪里。我们可能会在文件的后面400行使用`db
    = Database()`，我们可以快速查看导入来看`Database`类来自哪里。然后，如果我们需要澄清如何使用`Database`类，我们可以访问原始文件（或者在交互式解释器中导入模块并使用`help(database.Database)`命令）。然而，如果我们使用`from
    database import *`语法，要找到该类的位置就要花费更多的时间。代码维护变成了一场噩梦。
- en: In addition, most editors are able to provide extra functionality, such as reliable
    code completion, the ability to jump to the definition of a class, or inline documentation,
    if normal imports are used. The `import *` syntax usually completely destroys
    their ability to do this reliably.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数编辑器能够提供额外的功能，如可靠的代码补全、跳转到类的定义或内联文档，如果使用正常的导入。`import *`语法通常会完全破坏它们可靠地执行这些功能的能力。
- en: Finally, using the `import *` syntax can bring unexpected objects into our local
    namespace. Sure, it will import all the classes and functions defined in the module
    being imported from, but it will also import any classes or modules that were
    themselves imported into that file!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`import *`语法可能会将意外的对象带入我们的本地命名空间。当然，它将导入从被导入的模块中定义的所有类和函数，但它也将导入任何被导入到该文件中的类或模块！
- en: Every name used in a module should come from a well-specified place, whether
    it is defined in that module, or explicitly imported from another module. There
    should be no magic variables that seem to come out of thin air. We should *always*
    be able to immediately identify where the names in our current namespace originated.
    I promise that if you use this evil syntax, you will one day have extremely frustrating
    moments of "where on earth can this class be coming from?".
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中使用的每个名称都应该来自一个明确定义的地方，无论它是在该模块中定义的，还是从另一个模块中明确导入的。不应该有看起来像从空气中出现的魔术变量。我们应该*总是*能够立即确定我们当前命名空间中的名称来自哪里。我保证，如果你使用这种邪恶的语法，总有一天你会非常沮丧地发现“这个类到底是从哪里来的？”。
- en: Organizing the modules
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织模块
- en: As a project grows into a collection of more and more modules, we may find that
    we want to add another level of abstraction, some kind of nested hierarchy on
    our modules' levels. However, we can't put modules inside modules; one file can
    hold only one file after all, and modules are nothing more than Python files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目逐渐发展成为越来越多模块的集合，我们可能会发现我们想要添加另一层抽象，一种在我们模块级别上的嵌套层次结构。然而，我们不能将模块放在模块中；毕竟，一个文件只能容纳一个文件，而模块只不过是Python文件而已。
- en: Files, however, can go in folders and so can modules. A **package** is a collection
    of modules in a folder. The name of the package is the name of the folder. All
    we need to do to tell Python that a folder is a package is place a (normally empty)
    file in the folder named `__init__.py`. If we forget this file, we won't be able
    to import modules from that folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以放在文件夹中，模块也可以。**包**是文件夹中模块的集合。包的名称是文件夹的名称。我们只需要告诉Python一个文件夹是一个包，就是在文件夹中放置一个（通常是空的）名为`__init__.py`的文件。如果我们忘记了这个文件，我们将无法从该文件夹导入模块。
- en: 'Let''s put our modules inside an `ecommerce` package in our working folder,
    which will also contain a `main.py` file to start the program. Let''s additionally
    add another package in the `ecommerce` package for various payment options. The
    folder hierarchy will look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的模块放在我们的工作文件夹中的`ecommerce`包中，该文件夹还将包含一个`main.py`文件来启动程序。让我们另外在`ecommerce`包中添加另一个包，用于各种付款选项。文件夹层次结构将如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When importing modules or classes between packages, we have to be cautious
    about the syntax. In Python 3, there are two ways of importing modules: absolute
    imports and relative imports.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在包之间导入模块或类时，我们必须谨慎使用语法。在Python 3中，有两种导入模块的方式：绝对导入和相对导入。
- en: Absolute imports
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: '**Absolute imports** specify the complete path to the module, function, or
    path we want to import. If we need access to the `Product` class inside the `products`
    module, we could use any of these syntaxes to do an absolute import:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对导入**指定要导入的模块、函数或路径的完整路径。如果我们需要访问`products`模块内的`Product`类，我们可以使用以下任何语法来进行绝对导入：'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: or
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: or
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `import` statements use the period operator to separate packages or modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句使用句点运算符来分隔包或模块。'
- en: These statements will work from any module. We could instantiate a `Product`
    class using this syntax in `main.py`, in the `database` module, or in either of
    the two payment modules. Indeed, assuming the packages are available to Python,
    it will be able to import them. For example, the packages can also be installed
    to the Python site packages folder, or the `PYTHONPATH` environment variable could
    be customized to dynamically tell Python what folders to search for packages and
    modules it is going to import.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句将从任何模块中起作用。我们可以在`main.py`、`database`模块中或两个付款模块中使用这种语法实例化`Product`类。实际上，假设包对Python可用，它将能够导入它们。例如，包也可以安装到Python站点包文件夹中，或者`PYTHONPATH`环境变量可以被定制以动态地告诉Python要搜索哪些文件夹以及它将要导入哪些包和模块。
- en: So, with these choices, which syntax do we choose? It depends on your personal
    taste and the application at hand. If there are dozens of classes and functions
    inside the `products` module that I want to use, I generally import the module
    name using the `from ecommerce import products` syntax, and then access the individual
    classes using `products.Product`. If I only need one or two classes from the `products`
    module, I can import them directly using the `from ecommerce.proucts import Product`
    syntax. I don't personally use the first syntax very often unless I have some
    kind of name conflict (for example, I need to access two completely different
    modules called `products` and I need to separate them). Do whatever you think
    makes your code look more elegant.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这些选择，我们选择哪种语法？这取决于你个人的口味和手头的应用。如果`products`模块内有几十个类和函数，我想要使用，通常我会使用`from
    ecommerce import products`语法导入模块名称，然后使用`products.Product`访问单个类。如果我只需要`products`模块中的一个或两个类，我可以直接使用`from
    ecommerce.proucts import Product`语法导入它们。我个人不经常使用第一种语法，除非我有某种名称冲突（例如，我需要访问两个完全不同的名为`products`的模块并且需要将它们分开）。做任何你认为使你的代码看起来更优雅的事情。
- en: Relative imports
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'When working with related modules in a package, it seems kind of silly to specify
    the full path; we know what our parent module is named. This is where **relative
    imports** come in. Relative imports are basically a way of saying find a class,
    function, or module as it is positioned relative to the current module. For example,
    if we are working in the `products` module and we want to import the `Database`
    class from the `database` module next to it, we could use a relative import:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个包中使用相关模块时，指定完整路径似乎有点愚蠢；我们知道我们的父模块叫什么。这就是**相对导入**的用武之地。相对导入基本上是一种说法，即按照当前模块的位置来查找类、函数或模块。例如，如果我们在`products`模块中工作，我们想要从旁边的`database`模块导入`Database`类，我们可以使用相对导入：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The period in front of `database` says "u*se the database module inside the
    current package"*. In this case, the current package is the package containing
    the `products.py` file we are currently editing, that is, the `ecommerce` package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`前面的句点表示“*在当前包内使用数据库模块*”。在这种情况下，当前包是包含我们当前正在编辑的`products.py`文件的包，也就是`ecommerce`包。'
- en: 'If we were editing the `paypal` module inside the `ecommerce.payments` package,
    we would want to say "u*se the database package inside the parent package*" instead.
    This is easily done with two periods, as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编辑`ecommerce.payments`包中的`paypal`模块，我们想说“*使用父包内的数据库包*”，这很容易通过两个句点来完成，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can use more periods to go further up the hierarchy. Of course, we can also
    go down one side and back up the other. We don''t have a deep enough example hierarchy
    to illustrate this properly, but the following would be a valid import if we had
    an `ecommerce.contact` package containing an `email` module and wanted to import
    the `send_mail` function into our `paypal` module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的句点来进一步上升层次。当然，我们也可以向下走一边，然后向上走另一边。我们没有足够深的示例层次结构来正确说明这一点，但是如果我们有一个包含`email`模块的`ecommerce.contact`包，并且想要将`send_mail`函数导入到我们的`paypal`模块中，以下将是一个有效的导入：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This import uses two periods to say, *the parent of the payments package*, and
    then uses the normal `package.module` syntax to go back *up* into the contact
    package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入使用两个句点来表示*payments包的父级*，然后使用正常的`package.module`语法来返回*up*到contact包。
- en: Finally, we can import code directly from packages, as opposed to just modules
    inside packages. In this example, we have an `ecommerce` package containing two
    modules named `database.py` and `products.py`. The database module contains a
    `db` variable that is accessed from a lot of places. Wouldn't it be convenient
    if this could be imported as `import ecommerce.db` instead of `import ecommerce.database.db`?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接从包中导入代码，而不仅仅是包内的模块。在这个例子中，我们有一个名为`database.py`和`products.py`的`ecommerce`包，数据库模块包含一个从许多地方访问的`db`变量。如果这可以被导入为`import
    ecommerce.db`而不是`import ecommerce.database.db`，那不是很方便吗？
- en: 'Remember the `__init__.py` file that defines a directory as a package? This
    file can contain any variable or class declarations we like, and they will be
    available as part of the package. In our example, if the `ecommerce/__init__.py`
    file contained this line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住定义目录为包的`__init__.py`文件？这个文件可以包含我们喜欢的任何变量或类声明，并且它们将作为包的一部分可用。在我们的例子中，如果`ecommerce/__init__.py`文件包含这一行：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then access the `db` attribute from `main.py` or any other file using
    this import:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从`main.py`或任何其他文件中使用这个导入来访问`db`属性：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It might help to think of the `__init__.py` file as if it was an `ecommerce.py`
    file if that file were a module instead of a package. This can also be useful
    if you put all your code in a single module and later decide to break it up into
    a package of modules. The `__init__.py` file for the new package can still be
    the main point of contact for other modules talking to it, but the code can be
    internally organized into several different modules or subpackages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果把`__init__.py`文件看作是一个`ecommerce.py`文件，如果该文件是一个模块而不是一个包，这可能有所帮助。如果您将所有代码放在一个单独的模块中，然后决定将其拆分为多个模块的包，`__init__.py`文件仍然可以是其他模块与其交流的主要联系点，但代码可以在内部组织成几个不同的模块或子包。
- en: I recommend not putting all your code in an `__init__.py` file, though. Programmers
    do not expect actual logic to happen in this file, and much like with `from x
    import *`, it can trip them up if they are looking for the declaration of a particular
    piece of code and can't find it until they check `__init__.py`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要把所有的代码都放在一个`__init__.py`文件中。程序员不希望在这个文件中发生实际的逻辑，就像`from x import *`一样，如果他们正在寻找特定代码的声明并且找不到直到他们检查`__init__.py`，这可能会让他们困惑。
- en: Organizing module contents
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织模块内容
- en: 'Inside any one module, we can specify variables, classes, or functions. They
    can be a handy way to store the global state without namespace conflicts. For
    example, we have been importing the `Database` class into various modules and
    then instantiating it, but it might make more sense to have only one `database`
    object globally available from the `database` module. The `database` module might
    look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一个模块内，我们可以指定变量、类或函数。它们可以是一种方便的方式来存储全局状态而不会发生命名空间冲突。例如，我们一直在将`Database`类导入到各个模块中，然后实例化它，但是只有一个全局可用的`database`对象可能更有意义，来自`database`模块。`database`模块可能如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we can use any of the import methods we''ve discussed to access the `database`
    object, for example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用我们讨论过的任何导入方法来访问`database`对象，例如：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A problem with the preceding class is that the `database` object is created
    immediately when the module is first imported, which is usually when the program
    starts up. This isn''t always ideal since connecting to a database can take a
    while, slowing down startup, or the database connection information may not yet
    be available. We could delay creating the database until it is actually needed
    by calling an `initialize_database` function to create the module-level variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类的一个问题是，`database`对象在模块首次导入时立即创建，这通常是在程序启动时。这并不总是理想的，因为连接到数据库可能需要一段时间，从而减慢启动速度，或者数据库连接信息可能尚不可用。我们可以延迟创建数据库，直到实际需要它，通过调用`initialize_database`函数来创建模块级变量：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `global` keyword tells Python that the database variable inside `initialize_database`
    is the module level one we just defined. If we had not specified the variable
    as global, Python would have created a new local variable that would be discarded
    when the method exits, leaving the module-level value unchanged.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`关键字告诉Python，`initialize_database`内部的数据库变量是我们刚刚定义的模块级变量。如果我们没有将变量指定为全局的，Python会创建一个新的局部变量，当方法退出时会被丢弃，从而保持模块级值不变。'
- en: As these two examples illustrate, all module-level code is executed immediately
    at the time it is imported. However, if it is inside a method or function, the
    function will be created, but its internal code will not be executed until the
    function is called. This can be a tricky thing for scripts (such as the main script
    in our e-commerce example) that perform execution. Often, we will write a program
    that does something useful, and then later find that we want to import a function
    or class from that module in a different program. However, as soon as we import
    it, any code at the module level is immediately executed. If we are not careful,
    we can end up running the first program when we really only meant to access a
    couple functions inside that module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这两个例子所说明的，所有模块级代码都会在导入时立即执行。但是，如果它在方法或函数内部，函数会被创建，但它的内部代码直到调用函数时才会被执行。对于执行脚本（比如我们电子商务示例中的主要脚本）来说，这可能是一个棘手的问题。通常，我们会编写一个执行有用操作的程序，然后后来发现我们想要从另一个程序中导入该模块中的一个函数或类。然而，一旦我们导入它，任何模块级别的代码都会立即执行。如果我们不小心，我们可能会在真正只想要访问该模块中的一些函数时运行第一个程序。
- en: To solve this, we should always put our startup code in a function (conventionally,
    called `main`) and only execute that function when we know we are running the
    module as a script, but not when our code is being imported from a different script.
    But how do we know this?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该总是将我们的启动代码放在一个函数中（通常称为`main`），并且只在我们知道我们正在作为脚本运行模块时执行该函数，而不是在我们的代码被从另一个脚本中导入时执行。但是我们怎么知道这一点呢？
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Every module has a `__name__` special variable (remember, Python uses double
    underscores for special variables, such as a class's `__init__` method) that specifies
    the name of the module when it was imported. When the module is executed directly
    with `python module.py`, it is never imported, so the `__name__` is arbitrarily
    set to the string `"__main__"`. Make it a policy to wrap all your scripts in an
    `if __name__ == "__main__":` test, just in case you write a function you will
    find useful to be imported by other code someday.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个`__name__`特殊变量（记住，Python使用双下划线表示特殊变量，比如类的`__init__`方法），它指定了模块在导入时的名称。当模块直接用`python
    module.py`执行时，它不会被导入，所以`__name__`被任意设置为字符串`"__main__"`。制定一个规则，将所有脚本都包裹在`if __name__
    == "__main__":`测试中，以防你写的某个函数有一天会被其他代码导入。
- en: So, methods go in classes, which go in modules, which go in packages. Is that
    all there is to it?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方法放在类中，类放在模块中，模块放在包中。这就是全部吗？
- en: 'Actually, no. This is the typical order of things in a Python program, but
    it''s not the only possible layout. Classes can be defined anywhere. They are
    typically defined at the module level, but they can also be defined inside a function
    or method, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并非如此。这是Python程序中的典型顺序，但并非唯一可能的布局。类可以在任何地方定义。它们通常在模块级别定义，但也可以在函数或方法内部定义，就像这样：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `format_string` function accepts a string and optional formatter object,
    and then applies the formatter to that string. If no formatter is supplied, it
    creates a formatter of its own as a local class and instantiates it. Since it
    is created inside the scope of the function, this class cannot be accessed from
    anywhere outside of that function. Similarly, functions can be defined inside
    other functions as well; in general, any Python statement can be executed at any
    time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_string`函数接受一个字符串和可选的格式化器对象，然后将该格式化器应用于该字符串。如果没有提供格式化器，它会创建一个自己的格式化器作为本地类并实例化它。由于它是在函数的作用域内创建的，这个类不能从函数外部的任何地方访问。同样，函数也可以在其他函数内部定义；一般来说，任何Python语句都可以在任何时候执行。'
- en: These inner classes and functions are occasionally useful for one-off items
    that don't require or deserve their own scope at the module level, or only make
    sense inside a single method. However, it is not common to see Python code that
    frequently uses this technique.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内部类和函数偶尔对于不需要或不值得拥有自己的作用域的一次性项目是有用的，或者只在单个方法内部有意义。然而，很少见到频繁使用这种技术的Python代码。
- en: Who can access my data?
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁可以访问我的数据？
- en: Most object-oriented programming languages have a concept of access control.
    This is related to abstraction. Some attributes and methods on an object are marked
    private, meaning only that object can access them. Others are marked protected,
    meaning only that class and any subclasses have access. The rest are public, meaning
    any other object is allowed to access them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有访问控制的概念。这与抽象有关。对象上的一些属性和方法被标记为私有，意味着只有该对象可以访问它们。其他的被标记为受保护，意味着只有该类和任何子类才能访问。其余的是公共的，意味着任何其他对象都可以访问它们。
- en: Python doesn't do this. Python doesn't really believe in enforcing laws that
    might someday get in your way. Instead, it provides unenforced guidelines and
    best practices. Technically, all methods and attributes on a class are publicly
    available. If we want to suggest that a method should not be used publicly, we
    can put a note in docstrings indicating that the method is meant for internal
    use only (preferably, with an explanation of how the public-facing API works!).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python不这样做。Python并不真的相信强制性的法律可能会在某一天妨碍你。相反，它提供了不受约束的指导方针和最佳实践。从技术上讲，类上的所有方法和属性都是公开可用的。如果我们想表明一个方法不应该公开使用，我们可以在文档字符串中放置一个注释，指出该方法仅供内部使用（最好还要解释公共API的工作原理！）。
- en: By convention, we should also prefix an attribute or method with an underscore
    character, `_`. Python programmers will interpret this as *"this is an internal
    variable, think three times before accessing it directly"*. But there is nothing
    inside the interpreter to stop them from accessing it if they think it is in their
    best interest to do so. Because if they think so, why should we stop them? We
    may not have any idea what future uses our classes may be put to.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们还应该用下划线字符`_`作为属性或方法的前缀。Python程序员会将其解释为“这是一个内部变量，在直接访问之前要三思”。但是在解释器内部并没有任何东西阻止他们在认为有利的情况下访问它。因为如果他们这样认为，我们为什么要阻止他们呢？我们可能不知道我们的类将来可能被用来做什么。
- en: 'There''s another thing you can do to strongly suggest that outside objects
    don''t access a property or method: prefix it with a double underscore, `__`.
    This will perform **name mangling** on the attribute in question. This basically
    means that the method can still be called by outside objects if they really want
    to do it, but it requires extra work and is a strong indicator that you demand
    that your attribute remains private. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事可以强烈建议外部对象不要访问属性或方法：用双下划线`__`作为前缀。这将对相关属性进行**名称混淆**。这基本上意味着如果外部对象真的想要调用这个方法，它仍然可以这样做，但需要额外的工作，并且强烈表明你要求你的属性保持私有。例如：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we load this class and test it in the interactive interpreter, we can see
    that it hides the plain text string from the outside world:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载这个类并在交互式解释器中测试它，我们会发现它隐藏了外部世界的纯文本字符串：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It looks like it works; nobody can access our `plain_text` attribute without
    the passphrase, so it must be safe. Before we get too excited, though, let''s
    see how easy it can be to hack our security:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它起作用了；没有人可以在没有密码的情况下访问我们的`plain_text`属性，所以它一定是安全的。然而，在我们过于兴奋之前，让我们看看有多容易就能破解我们的安全性：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Oh no! Somebody has hacked our secret string. Good thing we checked! This is
    Python name mangling at work. When we use a double underscore, the property is
    prefixed with `_<classname>`. When methods in the class internally access the
    variable, they are automatically unmangled. When external classes wish to access
    it, they have to do the name mangling themselves. So, name mangling does not guarantee
    privacy, it only strongly recommends it. Most Python programmers will not touch
    a double underscore variable on another object unless they have an extremely compelling
    reason to do so.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不！有人已经破解了我们的秘密字符串。幸好我们检查了！这就是Python名称混淆的工作原理。当我们使用双下划线时，属性会以`_<classname>`为前缀。当类内部的方法访问变量时，它们会自动解除混淆。当外部类希望访问它时，它们必须自己进行名称混淆。因此，名称混淆并不能保证隐私，它只是强烈建议。大多数Python程序员不会轻易触碰另一个对象上的双下划线变量，除非他们有极其充分的理由这样做。
- en: However, most Python programmers will not touch a single underscore variable
    without a compelling reason either. Therefore, there are very few good reasons
    to use a name-mangled variable in Python, and doing so can cause grief. For example,
    a name-mangled variable may be useful to a subclass, and it would have to do the
    mangling itself. Let other objects access your hidden information if they want
    to, just let them know, using a single-underscore prefix or some clear docstrings,
    that you think this is not a good idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数Python程序员不会轻易触碰一个下划线变量，除非有充分的理由。因此，在Python中很少有使用名称混淆变量的好理由，这样做可能会带来麻烦。例如，名称混淆变量可能对子类有用，它必须自己进行混淆。如果其他对象想要访问你的隐藏信息，就让它们访问吧，只要让它们知道，使用单下划线前缀或一些清晰的文档字符串，你认为这不是一个好主意。
- en: Third-party libraries
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方库
- en: 'Python ships with a lovely standard library, which is a collection of packages
    and modules that are available on every machine that runs Python. However, you''ll
    soon find that it doesn''t contain everything you need. When this happens, you
    have two options:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python附带了一个可爱的标准库，其中包含了一系列在运行Python的每台机器上都可用的包和模块。然而，你很快会发现它并不包含你所需要的一切。当发生这种情况时，你有两个选择：
- en: Write a supporting package yourself
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己编写一个支持包
- en: Use somebody else's code
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用别人的代码
- en: 'We won''t be covering the details about turning your packages into libraries,
    but if you have a problem you need to solve and you don''t feel like coding it
    (the best programmers are extremely lazy and prefer to reuse existing, proven
    code, rather than write their own), you can probably find the library you want
    on the **Python Package Index** (**PyPI**) at [http://pypi.python.org/](http://pypi.python.org/).
    Once you''ve identified a package that you want to install, you can use a tool
    called `pip` to install it. However, `pip` does not come with Python, but Python
    3.4 contains a useful tool called `ensurepip`, which will install it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何将你的包转换成库，但是如果你有一个需要解决的问题，而你又不想编写代码（最好的程序员非常懒惰，更喜欢重用现有的经过验证的代码，而不是编写自己的代码），你可能可以在**Python包索引**（**PyPI**）[http://pypi.python.org/](http://pypi.python.org/)上找到你想要的库。一旦确定了要安装的包，你可以使用一个叫做`pip`的工具来安装它。然而，`pip`并不随Python一起提供，但Python
    3.4包含一个有用的工具叫做`ensurepip`，它会安装它：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This may fail for you on Linux, Mac OS, or other Unix systems, in which case,
    you'll need to become root to make it work. On most modern Unix systems, this
    can be done with `sudo python -m ensurepip`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在Linux、Mac OS或其他Unix系统上失败，如果是这样，你需要成为root用户才能使其工作。在大多数现代Unix系统上，可以使用`sudo
    python -m ensurepip`来完成这个操作。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using an older version of Python than Python 3.4, you'll need to
    download and install `pip` yourself, since `ensurepip` doesn't exist. You can
    do this by following the instructions at [http://pip.readthedocs.org/](http://pip.readthedocs.org/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 3.4之前的版本，你需要自己下载并安装`pip`，因为`ensurepip`不存在。你可以按照[http://pip.readthedocs.org/](http://pip.readthedocs.org/)上的说明来做这件事。
- en: 'Once `pip` is installed and you know the name of the package you want to install,
    you can install it using syntax such as:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`pip`并且知道要安装的包的名称，你可以使用以下语法来安装它：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, if you do this, you'll either be installing the third-party library
    directly into your system Python directory, or more likely, get an error that
    you don't have permission to do so. You could force the installation as an administrator,
    but common consensus in the Python community is that you should only use system
    installers to install the third-party library to your system Python directory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这样做，你要么将第三方库直接安装到系统Python目录中，要么更有可能收到你没有权限这样做的错误。你可以强制以管理员身份安装，但Python社区的普遍共识是，你应该只使用系统安装程序将第三方库安装到系统Python目录中。
- en: 'Instead, Python 3.4 supplies the `venv` tool. This utility basically gives
    you a mini Python installation called a *virtual environment* in your working
    directory. When you activate the mini Python, commands related to Python will
    work on that directory instead of the system directory. So when you run `pip`
    or `python`, it won''t touch the system Python at all. Here''s how to use it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 3.4提供了`venv`工具。这个工具基本上为你在工作目录中提供了一个叫做*虚拟环境*的迷你Python安装。当你激活这个迷你Python时，与Python相关的命令将在该目录上运行，而不是在系统目录上运行。因此，当你运行`pip`或`python`时，它不会影响系统Python。以下是如何使用它：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Typically, you'll create a different virtual environment for each Python project
    you work on. You can store your virtual environments anywhere, but I keep mine
    in the same directory as the rest of my project files (but ignored in version
    control), so first we `cd` into that directory. Then we run the `venv` utility
    to create a virtual environment named `env`. Finally, we use one of the last two
    lines (depending on the operating system, as indicated in the comments) to activate
    the environment. We'll need to execute this line each time we want to use that
    particular virtualenv, and then use the command `deactivate` when we are done
    working on this project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会为你工作的每个Python项目创建一个不同的虚拟环境。你可以将虚拟环境存储在任何地方，但我把我的放在与其余项目文件相同的目录中（但在版本控制中被忽略），所以首先我们`cd`进入那个目录。然后我们运行`venv`工具来创建一个名为`env`的虚拟环境。最后，我们使用最后两行中的一行（取决于操作系统，如注释中所示）来激活环境。每次我们想要使用特定的虚拟环境时，都需要执行这行命令，然后在完成这个项目的工作时使用`deactivate`命令。
- en: Virtual environments are a terrific way to keep your third-party dependencies
    separate. It is common to have different projects that depend on different versions
    of a particular library (for example, an older website might run on Django 1.5,
    while newer versions run on Django 1.8). Keeping each project in separate virtualenvs
    makes it easy to work in either version of Django. Further, it prevents conflicts
    between system-installed packages and `pip` installed packages if you try to install
    the same package using different tools.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境是保持第三方依赖项分开的绝佳方式。通常会有不同的项目依赖于特定库的不同版本（例如，一个较旧的网站可能在Django 1.5上运行，而更新的版本则在Django
    1.8上运行）。将每个项目放在单独的虚拟环境中可以轻松地在Django的任一版本中工作。此外，如果尝试使用不同的工具安装相同的包，它可以防止系统安装的软件包和`pip`安装的软件包之间发生冲突。
- en: Case study
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie it all together, let's build a simple command-line notebook application.
    This is a fairly simple task, so we won't be experimenting with multiple packages.
    We will, however, see common usage of classes, functions, methods, and docstrings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了把所有这些联系在一起，让我们构建一个简单的命令行笔记本应用程序。这是一个相当简单的任务，所以我们不会尝试使用多个包。然而，我们会看到类、函数、方法和文档字符串的常见用法。
- en: 'Let''s start with a quick analysis: notes are short memos stored in a notebook.
    Each note should record the day it was written and can have tags added for easy
    querying. It should be possible to modify notes. We also need to be able to search
    for notes. All of these things should be done from the command line.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个快速分析开始：笔记是存储在笔记本中的简短备忘录。每个笔记应记录写作日期，并可以添加标签以便进行简单查询。应该可以修改笔记。我们还需要能够搜索笔记。所有这些事情都应该从命令行完成。
- en: The obvious object is the `Note` object; less obvious one is a `Notebook` container
    object. Tags and dates also seem to be objects, but we can use dates from Python's
    standard library and a comma-separated string for tags. To avoid complexity, in
    the prototype, let's not define separate classes for these objects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的对象是`Note`对象；不太明显的是`Notebook`容器对象。标签和日期似乎也是对象，但我们可以使用Python标准库中的日期和逗号分隔的字符串来表示标签。为了避免复杂性，在原型中，让我们不为这些对象定义单独的类。
- en: '`Note` objects have attributes for `memo` itself, `tags`, and `creation_date`.
    Each note will also need a unique integer `id` so that users can select them in
    a menu interface. Notes could have a method to modify note content and another
    for tags, or we could just let the notebook access those attributes directly.
    To make searching easier, we should put a `match` method on the `Note` object.
    This method will accept a string and can tell us if a note matches the string
    without accessing the attributes directly. This way, if we want to modify the
    search parameters (to search tags instead of note contents, for example, or to
    make the search case-insensitive), we only have to do it in one place.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note`对象具有`memo`本身，`tags`和`creation_date`的属性。每个笔记还需要一个唯一的整数`id`，以便用户可以在菜单界面中选择它们。笔记可以有一个修改笔记内容的方法和另一个修改标签的方法，或者我们可以让笔记本直接访问这些属性。为了使搜索更容易，我们应该在`Note`对象上放置一个`match`方法。这个方法将接受一个字符串，并且可以告诉我们笔记是否与字符串匹配，而不直接访问属性。这样，如果我们想修改搜索参数（例如搜索标签而不是笔记内容，或者使搜索不区分大小写），我们只需要在一个地方做就可以了。'
- en: The `Notebook` object obviously has the list of notes as an attribute. It will
    also need a search method that returns a list of filtered notes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notebook`对象显然具有笔记列表作为属性。它还需要一个搜索方法，返回过滤后的笔记列表。'
- en: But how do we interact with these objects? We've specified a command-line app,
    which can mean either that we run the program with different options to add or
    edit commands, or we have some kind of a menu that allows us to pick different
    things to do to the notebook. We should try to design it such that either interface
    is supported and future interfaces, such as a GUI toolkit or web-based interface,
    could be added in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何与这些对象交互？我们已经指定了一个命令行应用程序，这意味着我们可以通过不同的选项运行程序来添加或编辑命令，或者我们有一种菜单可以让我们选择对笔记本进行不同的操作。我们应该尽量设计它，以便支持任一界面，并且将来可以添加其他界面，比如GUI工具包或基于Web的界面。
- en: As a design decision, we'll implement the menu interface now, but will keep
    the command-line options version in mind to ensure we design our `Notebook` class
    with extensibility in mind.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计决策，我们现在将实现菜单界面，但会牢记命令行选项版本，以确保我们设计`Notebook`类时考虑到可扩展性。
- en: If we have two command-line interfaces, each interacting with the `Notebook`
    object, then `Notebook` will need some methods for those interfaces to interact
    with. We need to be able to `add` a new note, and `modify` an existing note by
    `id`, in addition to the `search` method we've already discussed. The interfaces
    will also need to be able to list all notes, but they can do that by accessing
    the `notes` list attribute directly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个命令行界面，每个界面都与`Notebook`对象交互，那么`Notebook`将需要一些方法让这些界面进行交互。我们需要能够`add`一个新的笔记，并且通过`id`来`modify`一个现有的笔记，除了我们已经讨论过的`search`方法。界面还需要能够列出所有的笔记，但它们可以通过直接访问`notes`列表属性来实现。
- en: 'We may be missing a few details, but that gives us a really good overview of
    the code we need to write. We can summarize all this in a simple class diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会漏掉一些细节，但这给了我们一个非常好的代码概述。我们可以用一个简单的类图总结所有这些：
- en: '![Case study](images/8781OS_02_02.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![案例研究](images/8781OS_02_02.jpg)'
- en: Before writing any code, let's define the folder structure for this project.
    The menu interface should clearly be in its own module, since it will be an executable
    script, and we may have other executable scripts accessing the notebook in the
    future. The `Notebook` and `Note` objects can live together in one module. These
    modules can both exist in the same top-level directory without having to put them
    in a package. An empty `command_option.py` module can help remind us in the future
    that we were planning to add new user interfaces.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，让我们为这个项目定义文件夹结构。菜单界面应该明显地在自己的模块中，因为它将是一个可执行脚本，并且我们将来可能会有其他可执行脚本访问笔记本。`Notebook`和`Note`对象可以一起存在于一个模块中。这些模块可以都存在于同一个顶级目录中，而不必将它们放在一个包中。一个空的`command_option.py`模块可以帮助我们在将来提醒我们计划添加新的用户界面。
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let's see some code. We start by defining the `Note` class as it seems simplest.
    The following example presents `Note` in its entirety. Docstrings within the example
    explain how it all fits together.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些代码。我们首先定义`Note`类，因为它似乎最简单。下面的示例完整地呈现了`Note`。示例中的文档字符串解释了它们如何完美地配合在一起。
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before continuing, we should quickly fire up the interactive interpreter and
    test our code so far. Test frequently and often because things never work the
    way you expect them to. Indeed, when I tested my first version of this example,
    I found out I had forgotten the `self` argument in the `match` function! We''ll
    discuss automated testing in [Chapter 10](ch10.html "Chapter 10. Python Design
    Patterns I"), *Python Design Patterns I*. For now, it suffices to check a few
    things using the interpreter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该快速启动交互式解释器并测试到目前为止的代码。经常测试，因为事情从来不按照你的期望工作。事实上，当我测试这个示例的第一个版本时，我发现我忘记了`match`函数中的`self`参数！我们将在[第10章](ch10.html
    "Chapter 10. Python Design Patterns I")中讨论自动化测试，*Python设计模式I*。目前，只需使用解释器检查一些东西就足够了：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It looks like everything is behaving as expected. Let''s create our notebook
    next:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都表现如预期。让我们接下来创建我们的笔记本：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''ll clean this up in a minute. First, let''s test it to make sure it works:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会整理一下。首先，让我们测试一下，确保它能正常工作：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It does work. The code is a little messy though; our `modify_tags` and `modify_memo`
    methods are almost identical. That's not good coding practice. Let's see how we
    can improve it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有效。但代码有点混乱；我们的`modify_tags`和`modify_memo`方法几乎是相同的。这不是良好的编码实践。让我们看看如何改进它。
- en: 'Both methods are trying to identify the note with a given ID before doing something
    to that note. So, let''s add a method to locate the note with a specific ID. We''ll
    prefix the method name with an underscore to suggest that the method is for internal
    use only, but of course, our menu interface can access the method if it wants
    to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都试图在对笔记进行操作之前识别具有特定ID的笔记。因此，让我们添加一个方法来定位具有特定ID的笔记。我们将在方法名前加上下划线来表示该方法仅供内部使用，但当然，我们的菜单界面可以访问该方法，如果它想要的话：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This should work for now. Let''s have a look at the menu interface. The interface
    simply needs to present a menu and allow the user to input choices. Here''s our
    first try:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该暂时有效。让我们来看看菜单界面。该界面只需显示菜单并允许用户输入选择。以下是我们的第一次尝试：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code first imports the notebook objects using an absolute import. Relative
    imports wouldn't work because we haven't placed our code inside a package. The
    `Menu` class's `run` method repeatedly displays a menu and responds to choices
    by calling functions on the notebook. This is done using an idiom that is rather
    peculiar to Python; it is a lightweight version of the command pattern that we
    will discuss in [Chapter 10](ch10.html "Chapter 10. Python Design Patterns I"),
    *Python Design Patterns I*. The choices entered by the user are strings. In the
    menu's `__init__` method, we create a dictionary that maps strings to functions
    on the menu object itself. Then, when the user makes a choice, we retrieve the
    object from the dictionary. The `action` variable actually refers to a specific
    method, and is called by appending empty brackets (since none of the methods require
    parameters) to the variable. Of course, the user might have entered an inappropriate
    choice, so we check if the action really exists before calling it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先使用绝对导入导入笔记本对象。相对导入不起作用，因为我们还没有将我们的代码放入一个包中。`Menu`类的`run`方法重复显示菜单，并通过调用笔记本上的函数来响应选择。这是一种对Python相当特殊的习语；它是命令模式的一个轻量级版本，我们将在[第10章](ch10.html
    "第10章。Python设计模式I")中讨论，*Python设计模式I*。用户输入的选择是字符串。在菜单的`__init__`方法中，我们创建了一个将字符串映射到菜单对象本身的函数的字典。然后，当用户做出选择时，我们从字典中检索对象。`action`变量实际上是指特定的方法，并通过在变量后附加空括号（因为没有一个方法需要参数）来调用它。当然，用户可能输入了不合适的选择，所以我们在调用之前检查这个动作是否真的存在。
- en: Each of the various methods request user input and call appropriate methods
    on the `Notebook` object associated with it. For the `search` implementation,
    we notice that after we've filtered the notes, we need to show them to the user,
    so we make the `show_notes` function serve double duty; it accepts an optional
    `notes` parameter. If it's supplied, it displays only the filtered notes, but
    if it's not, it displays all notes. Since the `notes` parameter is optional, `show_notes`
    can still be called with no parameters as an empty menu item.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 各种方法都要求用户输入并调用与之关联的`Notebook`对象上的适当方法。对于`search`实现，我们注意到在过滤了笔记之后，我们需要向用户显示它们，所以我们让`show_notes`函数充当双重职责；它接受一个可选的`notes`参数。如果提供了，它只显示过滤后的笔记，但如果没有提供，它会显示所有笔记。由于`notes`参数是可选的，`show_notes`仍然可以作为一个空菜单项调用，不带参数。
- en: 'If we test this code, we''ll find that modifying notes doesn''t work. There
    are two bugs, namely:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试这段代码，我们会发现修改笔记不起作用。有两个错误，即：
- en: The notebook crashes when we enter a note ID that does not exist. We should
    never trust our users to enter correct data!
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入一个不存在的笔记ID时，笔记本会崩溃。我们永远不应该相信我们的用户输入正确的数据！
- en: Even if we enter a correct ID, it will crash because the note IDs are integers,
    but our menu is passing a string.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们输入了正确的ID，它也会崩溃，因为笔记ID是整数，但我们的菜单传递的是字符串。
- en: 'The latter bug can be solved by modifying the `Notebook` class''s `_find_note`
    method to compare the values using strings instead of the integers stored in the
    note, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个错误可以通过修改`Notebook`类的`_find_note`方法来解决，使用字符串而不是笔记中存储的整数进行比较，如下所示：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We simply convert both the input (`note_id`) and the note's ID to strings before
    comparing them. We could also convert the input to an integer, but then we'd have
    trouble if the user had entered the letter "a" instead of the number "1".
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在比较之前将输入（`note_id`）和笔记的ID都转换为字符串。我们也可以将输入转换为整数，但如果用户输入字母"a"而不是数字"1"，那么我们就会遇到麻烦。
- en: 'The problem with users entering note IDs that don''t exist can be fixed by
    changing the two `modify` methods on the notebook to check whether `_find_note`
    returned a note or not, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改笔记本上的两个`modify`方法，可以解决用户输入不存在的笔记ID的问题，检查`_find_note`是否返回了一个笔记，如下所示：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method has been updated to return `True` or `False`, depending on whether
    a note has been found. The menu could use this return value to display an error
    if the user entered an invalid note. This code is a bit unwieldy though; it would
    look a bit better if it raised an exception instead. We'll cover those in [Chapter
    4](ch04.html "Chapter 4. Expecting the Unexpected"), *Expecting the Unexpected*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法已经更新为根据是否找到笔记返回`True`或`False`。菜单可以使用这个返回值来显示错误，如果用户输入了无效的笔记。不过，这段代码有点笨重；如果它引发异常会好看一些。我们将在[第4章](ch04.html
    "第4章。预料之外")中介绍，*预料之外*。
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write some object-oriented code. The goal is to use the principles and syntax
    you learned in this chapter to ensure you can use it, instead of just reading
    about it. If you've been working on a Python project, go back over it and see
    if there are some objects you can create and add properties or methods to. If
    it's large, try dividing it into a few modules or even packages and play with
    the syntax.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些面向对象的代码。目标是使用本章学到的原则和语法，确保你可以使用它，而不仅仅是阅读它。如果你一直在做一个Python项目，回过头来看看，看看是否有一些对象可以创建，并添加属性或方法。如果项目很大，尝试将其分成几个模块，甚至包，并尝试使用语法。
- en: If you don't have such a project, try starting a new one. It doesn't have to
    be something you intend to finish, just stub out some basic design parts. You
    don't need to fully implement everything, often just a `print("this method will
    do something")` is all you need to get the overall design in place. This is called
    **top-down design**, in which you work out the different interactions and describe
    how they should work before actually implementing what they do. The converse,
    **bottom-up design**, implements details first and then ties them all together.
    Both patterns are useful at different times, but for understanding object-oriented
    principles, a top-down workflow is more suitable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样的项目，试着开始一个新的项目。它不必是你打算完成的东西，只需勾勒出一些基本的设计部分。你不需要完全实现所有东西，通常只需要一个`print("this
    method will do something")`就足以让整体设计就位。这被称为**自顶向下的设计**，在这种设计中，你先解决不同的交互并描述它们应该如何工作，然后再实际实现它们。相反的**自底向上的设计**，先实现细节，然后将它们全部联系在一起。这两种模式在不同的时候都很有用，但是对于理解面向对象的原则来说，自顶向下的工作流更合适。
- en: 'If you''re having trouble coming up with ideas, try writing a to-do application.
    (Hint: It would be similar to the design of the notebook application, but with
    extra date management methods.) It can keep track of things you want to do each
    day, and allow you to mark them as completed.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想法上遇到困难，可以尝试编写一个待办事项应用程序。（提示：它会类似于笔记本应用程序的设计，但会有额外的日期管理方法。）它可以跟踪你每天想要做的事情，并允许你标记它们为已完成。
- en: Now, try designing a bigger project. It doesn't have to actually do anything,
    but make sure you experiment with the package and module importing syntax. Add
    some functions in various modules and try importing them from other modules and
    packages. Use relative and absolute imports. See the difference, and try to imagine
    scenarios where you would want to use each one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试设计一个更大的项目。它不一定要实际做任何事情，但确保你尝试使用包和模块导入语法。在各种模块中添加一些函数，并尝试从其他模块和包中导入它们。使用相对导入和绝对导入。看看它们之间的区别，并尝试想象你何时想要使用每种导入方式。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how simple it is to create classes and assign properties
    and methods in Python. Unlike many languages, Python differentiates between a
    constructor and an initializer. It has a relaxed attitude toward access control.
    There are many different levels of scope, including packages, modules, classes,
    and functions. We understood the difference between relative and absolute imports,
    and how to manage third-party packages that don't come with Python.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Python中创建类并分配属性和方法是多么简单。与许多其他语言不同，Python区分了构造函数和初始化器。它对访问控制有一种放松的态度。有许多不同级别的作用域，包括包、模块、类和函数。我们理解了相对导入和绝对导入之间的区别，以及如何管理不随Python一起提供的第三方包。
- en: In the next chapter, we'll learn how to share implementation using inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用继承来共享实现。
