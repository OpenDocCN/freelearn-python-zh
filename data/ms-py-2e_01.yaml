- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started – One Environment per Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南 – 每个项目一个环境
- en: In this chapter, you’ll learn about the different ways of setting up Python
    environments for your projects and how to use multiple Python versions on a single
    system outside of what your package manager offers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解为项目设置不同Python环境的方法，以及如何在单个系统上使用除包管理器提供的之外的多版本Python。
- en: After the environment is set up, we will continue with the installation of packages
    using both the **Python Package Index** (**PyPI**) and `conda-forge`, the package
    index that is coupled with Anaconda.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 环境设置完成后，我们将继续使用**Python包索引**（**PyPI**）和`conda-forge`（与Anaconda耦合的包索引）来安装包。
- en: Lastly, we will look at several methods of keeping track of project dependencies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨几种跟踪项目依赖的方法。
- en: 'To summarize, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下主题将被涵盖：
- en: Creating environments using `venv`, `pipenv`, `poetry`, `pyenv`, and `anaconda`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`venv`、`pipenv`、`poetry`、`pyenv`和`anaconda`创建环境
- en: Package installation through `pip`, `poetry`, `pipenv`, and `conda`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`pip`、`poetry`、`pipenv`和`conda`安装包
- en: Managing dependencies using `requirements.txt`, `poetry`, and `pipenv`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`requirements.txt`、`poetry`和`pipenv`管理依赖项
- en: Virtual environments
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: The Python ecosystem offers many methods of installing and managing packages.
    You can simply download and extract code to your project directory, use the package
    manager from your operating system, or use a tool such as `pip` to install a package.
    To make sure your packages don’t collide, it is recommended that you use a virtual
    environment. A virtual environment is a lightweight Python installation with its
    own package directories and a Python binary copied (or linked) from the binary
    used to create the environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python生态系统提供了许多安装和管理包的方法。你可以简单地下载并解压代码到你的项目目录，使用操作系统的包管理器，或者使用像`pip`这样的工具来安装一个包。为了确保你的包不会冲突，建议你使用虚拟环境。虚拟环境是一个轻量级的Python安装，它有自己的包目录和从创建环境时使用的二进制文件复制（或链接）的Python二进制文件。
- en: Why virtual environments are a good idea
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么虚拟环境是一个好主意
- en: 'It might seem like a hassle to create a virtual environment for every Python
    project, but it offers enough advantages to do so. More importantly, there are
    several reasons why installing packages globally using `pip` is a really bad idea:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个Python项目创建虚拟环境可能看起来有些麻烦，但它提供了足够的优势来这样做。更重要的是，有多个原因说明使用`pip`全局安装包是一个非常糟糕的主意：
- en: Installing packages globally usually requires elevated privileges (such as `sudo`,
    `root`, or `administrator`), which is a huge security risk. When executing `pip
    install <package>`, the `setup.py` of that package is executed as the user that
    executed the `pip install` command. That means that if the package contains malware,
    it now has superuser privileges to do whatever it wants. Don’t forget that anyone
    can upload a package to PyPI ([pypi.org](http://pypi.org)) without any vetting.
    As you will see later in this book, it only takes a couple of minutes for anyone
    to create and upload a package.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局安装包通常需要提升权限（如`sudo`、`root`或`administrator`），这是一个巨大的安全风险。当执行`pip install <package>`时，该包的`setup.py`将以执行`pip
    install`命令的用户身份执行。这意味着如果包包含恶意软件，它现在拥有超级用户权限去做任何它想做的事情。别忘了任何人都可以上传包到PyPI（[pypi.org](http://pypi.org)）而无需任何审查。正如你将在本书后面看到的，任何人创建和上传一个包只需要几分钟。
- en: Depending on how you installed Python, it can mess with the existing packages
    that are installed by your package manager. On an Ubuntu Linux system, that means
    you could break `pip` or even `apt` itself because a `pip install -U <package>`
    installs and updates both the package and all of the dependencies.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你如何安装Python，它可能会与你的包管理器安装的现有包发生冲突。在Ubuntu Linux系统上，这意味着你可能会破坏`pip`甚至`apt`本身，因为`pip
    install -U <package>`会安装和更新包及其所有依赖项。
- en: It can break your other projects. Many projects try their best to remain backward
    compatible, but every `pip install` could pull in new/updated dependencies that
    could break compatibility with other packages and projects. The Django Web Framework,
    for example, changes enough between versions that many projects using Django will
    need several changes after an upgrade to the latest release. So, when you’re upgrading
    Django on your system to the latest version and have a project that was written
    for a previous version, your project will most likely be broken.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会破坏你的其他项目。许多项目尽力保持向后兼容，但每次`pip install`都可能引入新的/更新的依赖项，这可能会破坏与其他包和项目的兼容性。例如，Django
    Web框架在不同版本之间的变化足够大，以至于使用Django的许多项目在升级到最新版本后可能需要进行几个更改。所以，当你将系统上的Django升级到最新版本，并且有一个为旧版本编写的项目时，你的项目很可能会被破坏。
- en: It pollutes your list of packages, making it hard to keep track of your project’s
    dependencies.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会污染你的包列表，使得跟踪你的项目依赖变得困难。
- en: In addition to alleviating the issues above, there is a major advantage as well.
    You can specify the Python version (assuming you have it installed) when creating
    the virtual environment. This allows you to test and debug your projects in multiple
    Python versions easily while keeping the exact same package versions beyond that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缓解上述问题外，还有一个主要优势。在创建虚拟环境时，你可以指定Python版本（假设你已经安装了它）。这允许你轻松地在多个Python版本中测试和调试你的项目，同时保持除那之外的确切相同的包版本。
- en: Using venv and virtualenv
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用venv和virtualenv
- en: 'You are probably already familiar with `virtualenv`, a library used to create
    a virtual environment for your Python installation. What you might not know is
    the `venv` command, which has been included with Python since version 3.3 and
    can be used as a drop-in replacement for `virtualenv` in most cases. To keep things
    simple, I recommend creating a directory where you keep all of your environments.
    Some people opt for an `env`, .`venv`, or `venv` directory within the project,
    but I advise against that for several reasons:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经熟悉了`virtualenv`，这是一个用于为你的Python安装创建虚拟环境的库。你可能不知道的是`venv`命令，它自Python 3.3版本以来就被包含在内，并且在大多数情况下可以作为`virtualenv`的替代品使用。为了简化问题，我建议创建一个目录来保存你所有的环境。有些人选择在项目内部使用`env`、`.venv`或`venv`目录，但我基于几个原因不建议这样做：
- en: Your project files are important, so you probably want to back them up as often
    as possible. By keeping the bulky environment with all of the installed packages
    outside of your backups, your backups become faster and lighter.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目文件很重要，所以你可能希望尽可能频繁地备份它们。通过将包含所有已安装包的庞大环境保存在备份之外，你的备份会更快、更轻。
- en: Your project directory stays portable. You can even keep it on a remote drive
    or flash drive without having to worry that the virtual environment will only
    work on a single system.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目目录保持可移植性。你甚至可以将其保存在远程驱动器或闪存驱动器上，而不用担心虚拟环境只能在单个系统上工作。
- en: It prevents you from accidentally adding the virtual environment files to your
    source control system.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以防止你意外地将虚拟环境文件添加到你的源代码控制系统中。
- en: If you do decide to keep your virtual environment inside your project directory,
    make sure that you add that directory to your `.gitignore` file (or similar) for
    your version control system. And if you want to keep your backups faster and lighter,
    exclude it from the backups. With correct dependency tracking, the virtual environment
    should be easy enough to rebuild.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实决定将虚拟环境放在你的项目目录中，请确保将该目录添加到你的`.gitignore`文件（或类似文件）中，以便于你的版本控制系统。如果你想更快、更轻地备份，请将其排除在备份之外。有了正确的依赖跟踪，虚拟环境应该足够容易重建。
- en: Creating a venv
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建venv
- en: Creating a `venv` is a reasonably simple process, but it varies slightly according
    to the operating system being used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`venv`是一个相对简单的过程，但根据所使用的操作系统，它略有不同。
- en: The following examples use the `virtualenv` module directly, but for ease I
    recommend using `poetry` instead, which is covered later in this chapter. This
    module will automatically create a virtual environment for you when you first
    use it. Before you make the step up to `poetry`, however, it is important to understand
    how virtual environments work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例直接使用`virtualenv`模块，但为了方便，我建议使用稍后在本章中介绍的`poetry`，这个模块会在首次使用时自动为你创建虚拟环境。然而，在你升级到`poetry`之前，了解虚拟环境的工作原理是非常重要的。
- en: Since Python 3.6, the `pyvenv` command has been deprecated in favor of `python
    -m venv`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.6以来，`pyvenv`命令已被弃用，转而使用`python -m venv`。
- en: In the case of Ubuntu, the `python3-venv` package has to be installed through
    `apt` because the Ubuntu developers have mutilated the default Python installation
    by not including `ensurepip`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 的案例中，必须通过 `apt` 安装 `python3-venv` 包，因为 Ubuntu 开发者通过不包含 `ensurepip`
    来破坏了默认的 Python 安装。
- en: 'For Linux/Unix/OS X, using `zsh` or `bash` as a shell, it is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux/Unix/OS X，使用 `zsh` 或 `bash` 作为 shell，操作如下：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And for Windows `cmd.exe` (assuming `python.exe` is in your `PATH`), it is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 的 `cmd.exe`（假设 `python.exe` 已添加到你的 `PATH`），操作如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'PowerShell is also supported and can be used in a similar fashion:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 也支持类似的方式使用：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first command creates the environment and the second activates the environment.
    After activating the environment, commands such as `python` and `pip` use the
    environment-specific versions, so `pip` `install` only installs within your virtual
    environment. A useful side effect of activating the environment is the prefix
    with the name of your environment, which is `(your_env)` in this case.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建环境，第二个命令激活环境。激活环境后，`python` 和 `pip` 等命令将使用特定版本的环境，因此 `pip install` 只会在你的虚拟环境中安装。激活环境的一个有用副作用是在命令前加上环境名称的前缀，在这个例子中是
    `(your_env)`。
- en: Note that we are **not** using `sudo` or other methods of elevating privileges.
    Elevating privileges is both unnecessary and a potential security risk, as explained
    in the *Why virtual environments are a good idea* section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们**不**使用 `sudo` 或其他提升权限的方法。提升权限既是不必要的，也可能是一个潜在的安全风险，如 *Why virtual environments
    are a good idea* 部分所述。
- en: 'Using `virtualenv` instead of `venv` is as simple as replacing the following
    command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `virtualenv` 而不是 `venv` 的方法很简单，只需替换以下命令：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'with this one:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An additional advantage of using `virtualenv` instead of `venv`, in that case,
    is that you can specify the Python interpreter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `virtualenv` 而不是 `venv` 的一个额外优点是，你可以指定 Python 解释器：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whereas with the `venv` command, it uses the currently running Python installation,
    so you need to change it through the following invocation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 而使用 `venv` 命令时，它会使用当前运行的 Python 安装，因此你需要通过以下调用来更改它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Activating a venv/virtualenv
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活 venv/virtualenv
- en: 'Every time you get back to your project after closing the shell, you need to
    reactivate the environment. The activation of a virtual environment consists of:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你关闭 shell 后回到项目，都需要重新激活环境。虚拟环境的激活包括：
- en: Modifying your `PATH` environment variable to use `envs\your_env\Script` or
    `envs/your_env/bin` for Windows or Linux/Unix, respectively
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的 `PATH` 环境变量，对于 Windows 使用 `envs\your_env\Script`，对于 Linux/Unix 则使用 `envs/your_env/bin`。
- en: Modifying your prompt so that instead of `$`, you see `(your_env) $`, indicating
    that you are working in a virtual environment
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的提示符，使其显示为 `(your_env) $` 而不是 `$`，这表明你正在虚拟环境中工作。
- en: In the case of `poetry`, you can use the `poetry shell` command to create a
    new shell with the activated environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `poetry` 的案例中，你可以使用 `poetry shell` 命令来创建一个新的带有激活环境的 shell。
- en: While you can easily modify those manually, an easier method is to run the `activate`
    script that was generated when creating the virtual environment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以轻松手动修改这些设置，但一个更简单的方法是运行创建虚拟环境时生成的 `activate` 脚本。
- en: 'For Linux/Unix with `zsh` or `bash` as the shell, it is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `zsh` 或 `bash` 作为 shell 的 Linux/Unix，操作如下：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Windows using `cmd.exe`, it is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `cmd.exe` 的 Windows，操作如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For Windows using PowerShell, it is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 PowerShell 的 Windows，操作如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By default, the PowerShell permissions might be too restrictive to allow this.
    You can change this policy for the current PowerShell session by executing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PowerShell 的权限可能过于严格，不允许这样做。你可以通过执行以下操作来更改当前 PowerShell 会话的策略：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you wish to permanently change it for every PowerShell session for the current
    user, execute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为当前用户的所有 PowerShell 会话永久更改它，请执行以下操作：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Different shells, such as `fish` and `csh`, are also supported by using the
    `activate.fish` and `activate.csh` scripts, respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 支持不同的 shell，如 `fish` 和 `csh`，分别使用 `activate.fish` 和 `activate.csh` 脚本。
- en: 'When not using an interactive shell (with a cron job, for example), you can
    still use the environment by using the Python interpreter in the `bin` or `scripts`
    directory for Linux/Unix or Windows, respectively. Instead of running `python
    script.py` or `/usr/bin/python script.py`, you can use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用交互式 shell（例如，使用 cron 作业时），你仍然可以使用 Python 解释器在 `bin` 或 `scripts` 目录中运行 Linux/Unix
    或 Windows，分别代替运行 `python script.py` 或 `/usr/bin/python script.py`，你可以使用：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that commands installed through `pip` (and `pip` itself) can be run in
    a similar fashion:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过 `pip` 安装的命令（以及 `pip` 本身）可以以类似的方式运行：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Installing packages
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'Installing packages within your virtual environment can be done using `pip`
    as normal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的虚拟环境中安装包可以使用 `pip` 正常进行：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The great advantage comes when looking at the list of installed packages:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看已安装包的列表时，这是一个巨大的优势：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because our environment is isolated from the system, we only see the packages
    and dependencies that we have explicitly installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的环境与系统隔离，所以我们只能看到我们明确安装的包和依赖项。
- en: Fully isolating the virtual environment from the system Python packages can
    be a downside in some cases. It takes up more disk space and the package might
    not be in sync with the C/C++ libraries on the system. The PostgreSQL database
    server, for example, is often used together with the `psycopg2` package. While
    binaries are available for most platforms and building the package from the source
    is fairly easy, it can sometimes be more convenient to use the package that is
    bundled with your system. That way, you are certain that the package is compatible
    with both the installed Python and PostgreSQL versions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，完全隔离虚拟环境与系统 Python 包可能是一个缺点。它占用更多的磁盘空间，并且包可能与系统上的 C/C++ 库不同步。例如，PostgreSQL
    数据库服务器通常与 `psycopg2` 包一起使用。虽然大多数平台都有可用的二进制文件，并且从源代码构建包相对容易，但有时使用与系统捆绑的包可能更方便。这样，你可以确信该包与已安装的
    Python 和 PostgreSQL 版本兼容。
- en: 'To mix your virtual environment with system packages, you can use the `--system-site-packages`
    flag when creating the environment:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的虚拟环境与系统包混合，你可以在创建环境时使用 `--system-site-packages` 标志：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When enabling this flag, the environment will have the system Python environment
    `sys.path` appended to your virtual environment’s `sys.path`, effectively providing
    the system packages as a fallback when an `import` from the virtual environment
    fails.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用此标志时，环境将把系统 Python 环境的 `sys.path` 追加到你的虚拟环境的 `sys.path` 中，从而在虚拟环境中的 `import`
    失败时，将系统包作为后备提供。
- en: Explicitly installing or updating a package within your virtual environment
    will effectively hide the system package from within your virtual environment.
    Uninstalling the package from your virtual environment will make it reappear.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的虚拟环境中明确安装或更新一个包将有效地隐藏系统包在你的虚拟环境中。从你的虚拟环境中卸载该包将使其重新出现。
- en: 'As you might suspect, this also affects the results of `pip freeze`. Luckily,
    `pip freeze` can be told to only list the packages local to the virtual environment,
    which excludes the system packages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，这也影响了 `pip freeze` 的结果。幸运的是，`pip freeze` 可以被指示只列出虚拟环境本地的包，从而排除系统包：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Later in this chapter, we will discuss `pipenv,` which transparently handles
    the creation of the virtual environment for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论 `pipenv`，它为你透明地处理虚拟环境的创建。
- en: Using pyenv
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pyenv
- en: The `pyenv` library makes it really easy to quickly install and switch between
    multiple Python versions. A common issue with many Linux and Unix systems is that
    the package managers opt for stability over recency. In most cases, this is definitely
    an advantage, but if you are running a project that requires the latest and greatest
    Python version, or a really old version, it requires you to compile and install
    it manually. The `pyenv` package makes this process really easy for you but does
    still require the compiler to be installed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyenv` 库使得快速安装和切换多个 Python 版本变得非常容易。许多 Linux 和 Unix 系统的一个常见问题是包管理器选择稳定性而不是最新性。在大多数情况下，这确实是一个优点，但如果你正在运行一个需要最新和最佳
    Python 版本或非常旧版本的项目，那么你需要手动编译和安装它。`pyenv` 包使这个过程对你来说变得非常容易，但仍然需要安装编译器。'
- en: A nice addition to `pyenv` for testing purposes is the `tox` library. This library
    allows you to run your tests on a whole list of Python versions simultaneously.
    The usage of `tox` is covered in *Chapter 10,* *Testing and Logging – Preparing
    for Bugs*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，`pyenv` 的一个很好的补充是 `tox` 库。这个库允许你同时运行你的测试在一系列 Python 版本上。`tox` 的使用在 *第
    10 章*，*测试和日志记录 – 准备处理错误* 中有介绍。
- en: 'To install `pyenv`, I recommend visiting the `pyenv` project page, since it
    depends highly on your operating system and operating system version. For Linux/Unix,
    you can use the regular `pyenv` installation manual or the `pyenv-installer` ([https://github.com/pyenv/pyenv-installer](https://github.com/pyenv/pyenv-installer))
    one-liner, if you deem it safe enough:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `pyenv`，我建议访问 `pyenv` 项目页面，因为它高度依赖于你的操作系统和操作系统版本。对于 Linux/Unix，你可以使用常规的
    `pyenv` 安装手册或 `pyenv-installer` ([https://github.com/pyenv/pyenv-installer](https://github.com/pyenv/pyenv-installer))
    一行命令，如果你认为足够安全的话：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure that you follow the instructions given by the installer. To ensure
    `pyenv` works properly, you will need to modify your `.zshrc` or `.bashrc`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保遵循安装程序给出的说明。为了确保 `pyenv` 正确工作，你需要修改你的 `.zshrc` 或 `.bashrc` 文件。
- en: 'Windows does not support `pyenv` natively (outside of Windows Subsystem for
    Linux) but has a `pyenv` fork available: [https://github.com/pyenv-win/pyenv-win#installation](https://github.com/pyenv-win/pyenv-win#installation%20)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 不原生支持 `pyenv`（除了 Windows Subsystem for Linux），但有一个可用的 `pyenv` 分支：[https://github.com/pyenv-win/pyenv-win#installation](https://github.com/pyenv-win/pyenv-win#installation%20)
- en: 'After installing `pyenv`, you can view the list of supported Python versions
    using:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `pyenv` 后，你可以使用以下命令查看支持的 Python 版本列表：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The list is rather long, but can be shortened with `grep` on Linux/Unix:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表相当长，但在 Linux/Unix 上使用 `grep` 可以缩短：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you’ve found the version you like, you can install it through the `install`
    command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到你喜欢的版本，你可以通过 `install` 命令来安装它：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `pyenv install` command takes an optional `--debug` parameter, which builds
    a debug version of Python that makes debugging C/C++ extensions possible using
    a debugger such as `gdb`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyenv install` 命令接受一个可选的 `--debug` 参数，它构建一个调试版本的 Python，使得使用像 `gdb` 这样的调试器调试
    C/C++ 扩展成为可能。'
- en: 'Once the Python version has been built, you can activate it globally, but you
    can also use the `pyenv-virtualenv` plugin ([https://github.com/pyenv/pyenv-virtualenv](https://github.com/pyenv/pyenv-virtualenv))
    to create a `virtualenv` for your newly created Python environment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了 Python 版本，你可以全局激活它，但你也可以使用 `pyenv-virtualenv` 插件 ([https://github.com/pyenv/pyenv-virtualenv](https://github.com/pyenv/pyenv-virtualenv))
    为你新创建的 Python 环境创建一个 `virtualenv`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'you can see in the preceding example, as opposed to the `venv` and `virtualenv`
    commands, `pyenv virtualenv` automatically creates the environment in the `~/.pyenv/versions/<version>/envs/`
    directory so you’re not allowed to fully specify your own path. You can change
    the base path (`~/.pyenv/`) through the `PYENV_ROOT` environment variable, however.
    Activating the environment using the `activate` script in the environment directory
    is still possible, but more complicated than it needs to be since there’s an easy
    shortcut:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，与 `venv` 和 `virtualenv` 命令相比，`pyenv virtualenv` 自动在 `~/.pyenv/versions/<version>/envs/`
    目录中创建环境，因此不允许你完全指定自己的路径。然而，你可以通过 `PYENV_ROOT` 环境变量更改基本路径（`~/.pyenv/`）。使用环境目录中的
    `activate` 脚本激活环境仍然是可能的，但这比必要的要复杂，因为有一个简单的快捷方式：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that the environment is activated, you can run environment-specific commands,
    such as `pip`, and they will only modify your environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在环境已经激活，你可以运行特定于环境的命令，例如 `pip`，并且它们只会修改你的环境。
- en: Using Anaconda
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Anaconda
- en: Anaconda is a distribution that supports both the Python and R programming languages.
    It is much more than simply a virtual environment manager, though; it’s a whole
    different Python distribution with its own virtual environment system and even
    a completely different package system. In addition to supporting PyPI, it also
    supports `conda-forge`, which features a very impressive number of packages focused
    on scientific computing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 是一个支持 Python 和 R 编程语言的发行版。尽管它不仅仅是虚拟环境管理器；它是一个完全不同的 Python 发行版，拥有自己的虚拟环境系统和甚至一个完全不同的包系统。除了支持
    PyPI，它还支持 `conda-forge`，该系统拥有大量专注于科学计算的包。
- en: For the end user, the most important difference is that packages are installed
    through the `conda` command instead of `pip`. This brings a much more advanced
    dependency check when installing packages. Whereas `pip` will simply install a
    package and all of its dependencies without regard for other installed packages,
    `conda` will look at all of the installed packages and make sure it won’t install
    a version that is not supported by the installed packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户来说，最重要的区别是，包是通过`conda`命令而不是`pip`安装的。这为安装包时带来了更高级的依赖性检查。而`pip`会简单地安装一个包及其所有依赖项，而不考虑其他已安装的包，`conda`则会查看所有已安装的包，并确保不会安装一个不支持已安装包的版本。
- en: The `conda` package manager is not alone in smart dependency checking. The `pipenv`
    package manager (discussed later in this chapter) does something similar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`conda`包管理器在智能依赖性检查方面并不孤单。`pipenv`包管理器（本章稍后讨论）也做了类似的事情。'
- en: Getting started with Anaconda Navigator
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用Anaconda Navigator
- en: 'Installing Anaconda is quite easy on all common platforms. For Windows, OS
    X, and Linux, you can go to the Anaconda site and download the (graphical) installer:
    [https://www.anaconda.com/products/distribution#Downloads](https://www.anaconda.com/products/distribution#Downloads)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有常见平台上安装Anaconda都非常简单。对于Windows、OS X和Linux，您可以访问Anaconda网站并下载（图形）安装程序：[https://www.anaconda.com/products/distribution#Downloads](https://www.anaconda.com/products/distribution#Downloads)
- en: 'Once it’s installed, the easiest way to continue is by launching Anaconda Navigator,
    which should look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，继续的最简单方法是启动Anaconda Navigator，它应该看起来像这样：
- en: '![](img/B15882_01_01.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_01_01.png)'
- en: 'Figure 1.1: Anaconda Navigator – Home'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Anaconda Navigator – 主页
- en: 'Creating an environment and installing packages is pretty straightforward as
    well:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境和安装包同样简单明了：
- en: Click on the **Environments** button on the left.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**环境**按钮。
- en: Click on the **Create** button below.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下面的**创建**按钮。
- en: Enter your name and Python version.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的姓名和Python版本。
- en: Click on **Create** to create your environment and wait a bit until Anaconda
    is done:![](img/B15882_01_02.png)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**以创建您的环境，并稍等片刻，直到Anaconda完成安装:![](img/B15882_01_02.png)
- en: 'Figure 1.2: Anaconda Navigator – Creating an environment'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.2：Anaconda Navigator – 创建环境
- en: Once Anaconda has finished creating your environment, you should see a list
    of installed packages. Installing packages can be done by changing the filter
    of the package list from **Installed** to **All**, marking the checkbox near the
    packages you want to install, and applying the changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Anaconda完成了环境的创建，您应该会看到一个已安装包的列表。安装包可以通过将包列表的过滤器从**已安装**更改为**所有**，勾选您想要安装的包旁边的复选框，并应用更改来完成。
- en: While creating an environment, Anaconda Navigator shows you where the environment
    will be created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建环境时，Anaconda Navigator会显示环境将被创建的位置。
- en: Getting started with conda
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用conda
- en: While Anaconda Navigator is a really nice tool to use to get an overview, being
    able to run your code from the command line can be convenient too. With the `conda`
    command, that is luckily very easy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Anaconda Navigator是一个非常好的工具，可以用来获取概览，但能够从命令行运行代码也很方便。使用`conda`命令，这很幸运地非常简单。
- en: 'First, you need to open the `conda` shell. You can do this from Anaconda Navigator
    if you wish, but you can also run it straightaway. On Windows, you can open Anaconda
    Prompt or Anaconda PowerShell Prompt from the start menu. On Linux and OS X, the
    most convenient method is to initialize the shell integration. For zsh, you can
    use:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要打开`conda` shell。如果您愿意，可以从Anaconda Navigator中这样做，但您也可以直接运行它。在Windows上，您可以从开始菜单打开Anaconda
    Prompt或Anaconda PowerShell Prompt。在Linux和OS X上，最方便的方法是初始化shell集成。对于zsh，您可以使用：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For other shells, the process is similar. Note that this process modifies your
    shell configuration to automatically activate the `base` environment every time
    you open a shell. This can be disabled with a simple configuration option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他shell，过程类似。请注意，此过程会修改您的shell配置，以便每次打开shell时自动激活`base`环境。这可以通过简单的配置选项来禁用：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If automatic activation is not enabled, you will need to run the `activate`
    command to get back into the `conda base` environment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动激活未启用，您需要运行`activate`命令才能回到`conda base`环境：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If, instead of the `conda base` environment, you wish to activate the environment
    you created earlier, you need to specify the name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想激活您之前创建的环境而不是`conda base`环境，您需要指定名称：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you have not created the environment yet, you can do so using the command
    line as well:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建环境，你也可以使用命令行来创建：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To list the available environments, you can use the `conda info` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的环境，可以使用`conda info`命令：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Installing conda packages
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装conda包
- en: 'Now it’s time to install a package. For `conda` packages, you can simply use
    the `conda install` command. For example, to install the `progressbar2` package
    that I maintain, use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是安装包的时候了。对于`conda`包，你可以简单地使用`conda install`命令。例如，要安装我维护的`progressbar2`包，可以使用以下命令：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now you can run Python and see that the package has been installed and is working
    properly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行Python，看到包已经安装并且运行正常：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another way to verify whether the package has been installed is by running
    the `conda` `list` command, which lists the installed packages similarly to `pip
    list`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种验证包是否已安装的方法是运行`conda list`命令，它以类似于`pip list`的方式列出已安装的包：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Installing PyPI packages
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装PyPI包
- en: 'With PyPI packages, we have two options within the Anaconda distribution. The
    most obvious is using `pip`, but this has the downside of partially circumventing
    the `conda` dependency checker. While `conda install` will take the packages installed
    through PyPI into consideration, the `pip` command might upgrade packages undesirably.
    This behavior can be improved by enabling the `conda`/`pip` interoperability setting,
    but this seriously impacts the performance of `conda` commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Anaconda发行版中，对于PyPI包，我们有两种选项。最明显的是使用`pip`，但这有一个缺点，就是部分绕过了`conda`依赖检查器。虽然`conda
    install`会考虑通过PyPI安装的包，但`pip`命令可能会不希望地升级包。可以通过启用`conda`/`pip`互操作性设置来改善这种行为，但这会严重影响`conda`命令的性能：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Depending on how important fixed versions or `conda` performance is for you,
    you can also opt for converting the package to a `conda` package:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据固定版本或`conda`性能对你有多重要，你也可以选择将包转换为`conda`包：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have a package, we can modify the files if needed, but using the
    automatically generated files works most of the time. All that is left now is
    to build and install the package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包，如果需要，我们可以修改文件，但使用自动生成的文件大多数时候都足够了。现在剩下的只是构建和安装包：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And now we are done! The package has been installed through `conda` instead
    of `pip`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了！包是通过`conda`而不是`pip`安装的。
- en: Sharing your environment
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分享你的环境
- en: 'When collaborating with others, it is essential to have environments that are
    as similar as possible to avoid debugging local issues. With `pip`, we can simply
    create a requirements file by using `pip freeze`, but that will not include the
    `conda` packages. With `conda`, there’s actually an even better solution, which
    stores not only the dependencies and versions but also the installation channels,
    environment name, and environment location:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当与他人协作时，拥有尽可能相似的环境是至关重要的，以避免调试本地问题。使用`pip`，我们可以简单地通过`pip freeze`创建一个需求文件，但这不会包括`conda`包。使用`conda`，实际上有一个更好的解决方案，它不仅存储了依赖和版本，还包括了安装渠道、环境名称和环境位置：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Installing the packages from that environment file can be done while creating
    the environment:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建环境时，可以安装从该环境文件中获取的包：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or they can be added to an existing environment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以被添加到现有环境中：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Managing dependencies
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖
- en: The simplest way of managing dependencies is storing them in a `requirements.txt`
    file. In its simplest form, this is a list of package names and nothing else.
    This file can be extended with version requirements and can even support environment-specific
    installations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖的最简单方法是存储在`requirements.txt`文件中。在其最简单的形式中，这是一个包名称列表，没有其他内容。此文件可以扩展以包含版本要求，甚至可以支持特定环境的安装。
- en: A fancier method of installing and managing your dependencies is by using a
    tool such as `poetry` or `pipenv`. Internally, these use the regular `pip` installation
    method, but they build a full dependency graph of all the packages. This makes
    sure that all package versions are compatible with each other and allows the parallel
    installation of non-dependent packages.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和管理依赖的一种更高级的方法是使用像`poetry`或`pipenv`这样的工具。内部，这些工具使用常规的`pip`安装方法，但它们构建了所有包的完整依赖图。这确保了所有包版本之间都是兼容的，并允许并行安装非依赖包。
- en: Using pip and a requirements.txt file
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pip和requirements.txt文件
- en: The `requirements.txt` format allows you to list all of the dependencies of
    your project as broadly or as specifically as you feel is necessary. You can easily
    create this file yourself, but you can also tell `pip` to generate it for you,
    or even to generate a new file based on a previous `requirements.txt` file so
    you can view the changes. I recommend using `pip freeze` to generate an initial
    file and cherry-picking the dependencies (versions) you want.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 格式允许您以广泛或具体的方式列出您项目的所有依赖项。您可以轻松地自己创建此文件，也可以告诉 `pip` 为您生成它，甚至根据之前的
    `requirements.txt` 文件生成新文件，以便您可以查看更改。我建议使用 `pip freeze` 生成初始文件，并选择您想要的依赖项（版本）。'
- en: 'For example, assuming that we run `pip freeze` in our virtual environment from
    before:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们之前在我们的虚拟环境中运行了 `pip freeze`：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we store that file in a `requirements.txt` file, install a package, and
    look at the difference, we get this result:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将该文件存储在 `requirements.txt` 文件中，安装一个包，并查看差异，我们得到以下结果：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the `pip freeze` command automatically detected the addition
    of the `six`, `progressbar2`, and `python-utils` packages, and it immediately
    pinned those versions to the currently installed ones.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`pip freeze` 命令自动检测了 `six`、`progressbar2` 和 `python-utils` 包的添加，并立即将这些版本锁定到当前已安装的版本。
- en: 'The lines in the `requirements.txt` file are understood by `pip` on the command
    line as well, so to install a specific version, you can run:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 文件中的行在命令行上也被 `pip` 理解，因此要安装特定版本，您可以运行：'
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Version specifiers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本指定符
- en: 'Often, pinning a version as strictly as that is not desirable, however, so
    let’s change the requirements file to only contain what we actually care about:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将版本严格锁定通常不是我们想要的，所以让我们将需求文件更改为只包含我们真正关心的内容：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If someone else wants to install all of the requirements in this file, they
    can simply tell `pip` to include that requirement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人想安装此文件中的所有需求，他们可以简单地告诉 `pip` 包含该需求：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, `pip` checks to see whether all packages are installed and will
    install or update them if needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`pip` 会检查所有包是否已安装，并在需要时安装或更新它们。
- en: '`-r requirements.txt` works recursively, allowing you to include multiple requirements
    files.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r requirements.txt` 以递归方式工作，允许您包含多个需求文件。'
- en: 'Now let’s assume we’ve encountered a bug in the latest version and we wish
    to skip it. We can assume that only this specific version is affected, so we will
    only blacklist that version:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们遇到了最新版本中的错误，我们希望跳过它。我们可以假设只有这个特定的版本受到影响，因此我们只会将该版本列入黑名单：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lastly, we should talk about wildcards. One of the most common scenarios is
    needing a specific major version number but still wanting the latest security
    update and bug fixes. There are a few ways to specify these:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该谈谈通配符。最常见的情况之一是需要特定的主要版本号，但仍然想要最新的安全更新和错误修复。有几种方式可以指定这些：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the compatible release pattern (~=), you can select the newest version
    that is within the same major release but is at least the specified version.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用兼容的发布模式 (~=)，您可以选择同一主要版本中最新的版本，但至少是指定的版本。
- en: 'The version identification and dependency specification standard is described
    thoroughly in PEP 440:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 版本标识和依赖性指定标准在 PEP 440 中有详细描述：
- en: '[https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)'
- en: Installing through source control repositories
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过源控制仓库安装
- en: 'Now let’s say that we’re really unlucky and there is no working release of
    the package yet, but it has been fixed in the `develop` branch of the Git repository.
    We can install that either through `pip` or through a `requirements.txt` file,
    like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们非常不幸，该包还没有可用的有效版本，但它已经被修复在 Git 仓库的 `develop` 分支中。我们可以通过 `pip` 或通过一个 `requirements.txt`
    文件来安装它，如下所示：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may notice that `pip` not only installed the package but actually did a
    `git clone` to `your_env/src/progressbar2`. This is an optional step caused by
    the `--editable` (short option: `-e`) flag, which has the additional advantage
    that every time you re-run the command, the `git` clone will be updated. It also
    makes it rather easy to go to that directory, modify the code, and create a pull
    request with a fix.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到 `pip` 不仅安装了包，而且还执行了 `git clone` 到 `your_env/src/progressbar2`。这是由 `--editable`（简写选项：`-e`）标志引起的可选步骤，它还有额外的优势，即每次您重新运行命令时，`git
    clone` 都会更新。这也使得进入该目录、修改代码并创建带有修复的 pull request 变得相当容易。
- en: In addition to Git, other source control systems such as Bazaar, Mercurial,
    and Subversion are also supported.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Git之外，还支持其他源代码控制系统，如Bazaar、Mercurial和Subversion。
- en: Additional dependencies using extras
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展添加额外依赖
- en: 'Many packages offer optional dependencies for specific use cases. In the case
    of the `progressbar2` library, I have added `tests` and `docs` extras to install
    the test or documentation building dependencies needed to run the tests for the
    package. Extras can be specified using square brackets separated by commas:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件包为特定用例提供可选依赖。在`progressbar2`库的情况下，我添加了`tests`和`docs`扩展来安装运行包测试或构建文档所需的依赖。扩展可以通过用逗号分隔的方括号指定：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Conditional dependencies using environment markers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境标记的条件依赖
- en: 'If your project needs to run on multiple systems, you will most likely encounter
    dependencies that are not required on all systems. One example of this is libraries
    that are required on some operating systems but not on others. An example of this
    is the `portalocker` package I maintain; on Linux/Unix systems, the locking mechanisms
    needed are supported out of the box. On Windows, however, they require the `pywin32`
    package to work. The `install_requires` part of the package (which uses the same
    syntax as `requirements.txt`) contains this line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目需要在多个系统上运行，你很可能会遇到不是所有系统都需要的依赖项。一个例子是某些操作系统需要但其他操作系统不需要的库。例如，我维护的`portalocker`包；在Linux/Unix系统上，所需的锁定机制是默认支持的。然而，在Windows上，它们需要`pywin32`包才能工作。包的`install_requires`部分（使用与`requirements.txt`相同的语法）包含以下行：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This specifies that on Windows, the `pywin32` package is required, and version
    `226` was blacklisted due to a bug.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了在Windows上需要`pywin32`软件包，由于一个错误，版本`226`被列入黑名单。
- en: In addition to `platform_system`, there are several more markers, such as `python_version`
    and `platform_machine` (contains architecture `x86_64`, for example).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`platform_system`之外，还有几个其他标记，例如`python_version`和`platform_machine`（例如包含`x86_64`架构）。
- en: 'The full list of markers can be found in PEP 496: [https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在PEP 496中找到完整的标记列表：[https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/)。
- en: 'One other useful example of this is the `dataclasses` library. This library
    has been included with Python since version 3.7, so we only need to install the
    backport for older Python versions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的例子是`dataclasses`库。这个库从Python 3.7版本开始就包含在Python中，所以我们只需要为旧版本的Python安装回溯包：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Automatic project management using poetry
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`poetry`进行自动项目管理
- en: The `poetry` tool provides a really easy-to-use solution for creating, updating,
    and sharing your Python projects. It’s also very fast, which makes it a fantastic
    starting point for a project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry`工具提供了一个非常易于使用的解决方案，用于创建、更新和共享你的Python项目。它也非常快速，这使得它成为项目的绝佳起点。'
- en: Creating a new poetry project
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的`poetry`项目
- en: 'Starting a new project is very easy. It will automatically handle virtual environments,
    dependencies, and other project-related tasks for you. To start, we will use the
    `poetry init` wizard:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新项目非常简单。它会自动为你处理虚拟环境、依赖项和其他项目相关任务。要开始，我们将使用`poetry init`向导：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Following these few questions, it automatically creates a `pyproject.toml`
    file for us that contains all the data we entered and some automatically generated
    data. As you may have noticed, it automatically prefilled several values for us:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这几个问题，它会自动为我们创建一个包含所有输入数据和一些自动生成数据的`pyproject.toml`文件。正如你可能已经注意到的，它会自动为我们预填入几个值：
- en: The project name. This is based on the current directory name.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称。这是基于当前目录名称。
- en: The version. This is fixed to `0.1.0`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本。这是固定为`0.1.0`。
- en: 'The author field. This looks at your `git` user information. This can be set
    using:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者字段。这会查看你的`git`用户信息。这可以通过以下方式设置：
- en: '[PRE51]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Python version. This is based on the Python version you are running `poetry`
    with, but it can be customized using `poetry init --python=...`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本。这是基于你运行`poetry`时使用的Python版本，但可以通过`poetry init --python=...`进行自定义。
- en: 'Looking at the generated `pyproject.toml`, we can see the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的`pyproject.toml`，我们可以看到以下内容：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Adding dependencies
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Once we have the project up and running, we can now add dependencies:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目启动并运行，我们现在可以添加依赖项：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This automatically installs the package, adds it to the `pyproject.toml` file,
    and adds the specific version to the `poetry.lock` file. After this command, the
    `pyproject.toml` file has a new line added to the `tool.poetry.dependencies` section:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会自动安装包，将其添加到`pyproject.toml`文件中，并将特定版本添加到`poetry.lock`文件中。在此命令之后，`pyproject.toml`文件在`tool.poetry.dependencies`部分添加了一行新内容：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `poetry.lock` file is a bit more specific. Whereas the `progressbar2` dependency
    could have a wildcard version, the `poetry.lock` file stores the exact version,
    the file hashes, and all the dependencies that were installed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry.lock`文件要具体一些。虽然`progressbar2`依赖项可以有通配符版本，但`poetry.lock`文件存储了确切的版本、文件哈希以及所有已安装的依赖项：'
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'By having all this data, we can build or rebuild a virtual environment for
    a `poetry`-based project on another system exactly as it was created on the original
    system. To install, upgrade, and/or downgrade the packages exactly as specified
    in the `poetry.lock` file, we need a single command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有所有这些数据，我们可以在另一个系统上构建或重建一个基于`poetry`的项目虚拟环境，使其与原始系统上创建的完全一致。为了按照`poetry.lock`文件中指定的方式安装、升级和/或降级包，我们需要一个单独的命令：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is very similar to how the `npm` and `yarn` commands work if you are familiar
    with those.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉`npm`和`yarn`命令，这与你所熟悉的方式非常相似。
- en: Upgrading dependencies
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级依赖项
- en: In the previous examples, we simply added a dependency without specifying an
    explicit version. Often this is a safe approach, as the default version requirement
    will allow for any version within that major version.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是添加了一个依赖项，而没有指定显式的版本。通常这是一个安全的方法，因为默认版本要求将允许该主要版本内的任何版本。
- en: If the project uses normal Python versioning or semantic versioning (more about
    that in *Chapter 18,* *Packaging - Creating Your Own Libraries or Applications*),
    that should be perfect. At the very least, all of my projects (such as progressbar2)
    are generally both backward and largely forward compatible, so simply fixing the
    major version is enough. In this case, `poetry` defaulted to version `^3.55.0`,
    which means that any version newer than or equal to 3.55.0, up to (but not including)
    4.0.0, is valid.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目使用常规Python版本或语义版本（更多关于这一点在*第18章*，*打包 - 创建您自己的库或应用程序*），那应该很完美。至少，我的所有项目（如progressbar2）通常都是向后兼容和大部分向前兼容的，所以仅仅修复主要版本就足够了。在这种情况下，`poetry`默认设置为版本`^3.55.0`，这意味着任何大于或等于3.55.0的版本，直到（但不包括）4.0.0都是有效的。
- en: 'Due to the `poetry.lock` file, a `poetry install` will result in those exact
    versions being installed instead of the new versions, however. So how can we upgrade
    the dependencies? For this purpose, we will start by installing an older version
    of the `progressbar2` library:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`poetry.lock`文件，`poetry install`将导致安装那些确切版本，而不是新版本。那么我们如何升级依赖项？为此，我们将首先安装`progressbar2`库的较旧版本：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we will relax the version in the `pyproject.toml` file to `^3.1.0`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`pyproject.toml`文件中的版本放宽到`^3.1.0`：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once we have done this, a `poetry install` will still keep the `3.1.0` version,
    but we can make `poetry` update the dependencies for us:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，`poetry install`仍然会保留`3.1.0`版本，但我们可以让`poetry`为我们更新依赖项：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, poetry has nicely updated the dependencies in our project while still adhering
    to the requirements we set in the `pyproject.toml` `file`. If you set the version
    requirements of all packages to `*`, it will always update everything to the latest
    available versions that are compatible with each other.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`poetry`已经很好地更新了我们的项目依赖项，同时仍然遵守我们在`pyproject.toml`文件中设定的要求。如果你将所有包的版本要求设置为`*`，它将始终更新到彼此兼容的最新版本。
- en: Running commands
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行命令
- en: 'To run a single command using the `poetry` environment, you can use `poetry
    run`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`poetry`环境运行单个命令，你可以使用`poetry run`：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For an entire development session, however, I would suggest using the `shell`
    command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于整个开发会话，我建议使用`shell`命令：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After this, you can run all Python commands as normal, but these will now be
    running from the activated virtual environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你可以像往常一样运行所有Python命令，但现在这些命令将是从激活的虚拟环境中运行的。
- en: 'For cron jobs this is similar, but you will need to make sure that you change
    directories first:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于cron作业来说，情况类似，但你需要确保首先更改目录：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This command runs every day at 03:00 (24-hour clock, so A.M.).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令每天凌晨3点（24小时制，所以是上午）运行。
- en: 'Note that cron might not be able to find the `poetry` command due to having
    a different environment. In that case, I would recommend using the absolute path
    to the `poetry` command, which can be found using `which`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于环境不同，cron 可能找不到 `poetry` 命令。在这种情况下，我建议使用 `poetry` 命令的绝对路径，这可以通过 `which`
    命令找到：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Automatic dependency tracking using pipenv
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pipenv 进行自动依赖项跟踪
- en: For large projects, your dependencies can change often, which makes the manual
    manipulation of the `requirements.txt` file rather tedious. Additionally, having
    to create a virtual environment before you can install your packages is also a
    pretty repetitive task if you work on many projects. The `pipenv` tool aims to
    transparently solve these issues for you, while also making sure that all of your
    dependencies are compatible and updated. And as a final bonus, it combines the
    strict and loose dependency versions so you can make sure your production environment
    uses the exact same versions you tested.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型项目，您的依赖项可能会经常变化，这使得手动操作 `requirements.txt` 文件相当繁琐。此外，在安装包之前必须创建虚拟环境，如果您在多个项目上工作，这也是一项相当重复的任务。`pipenv`
    工具旨在为您透明地解决这些问题，同时确保所有依赖项都是兼容和更新的。作为最后的额外好处，它结合了严格和宽松的依赖项版本，这样您就可以确保您的生产环境使用与您测试时完全相同的版本。
- en: 'Initial usage is simple; go to your project directory and install a package.
    Let’s give it a try:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 初始使用很简单；进入您的项目目录并安装一个包。让我们试一试：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That’s quite a bit of output even when abbreviated. But let’s look at what
    happened:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是简化的输出也相当多。但让我们看看发生了什么：
- en: A virtual environment was created.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个虚拟环境。
- en: A `Pipfile` was created, which contains the dependency as you specified it.
    If you specify a specific version, that will be added to the `Pipfile`; otherwise,
    it will be a wildcard requirement, meaning that any version will be accepted as
    long as there are no conflicts with other packages.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个 `Pipfile`，其中包含您指定的依赖项。如果您指定了特定版本，它将被添加到 `Pipfile` 中；否则，它将是一个通配符要求，这意味着只要没有与其他包冲突，任何版本都将被接受。
- en: A `Pipfile.lock` was created containing the exact list of packages and versions
    as installed. This allows an identical install on a different machine with the
    exact same versions.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个包含已安装包和版本的 `Pipfile.lock`，这允许在不同的机器上使用完全相同的版本进行相同的安装。
- en: 'The generated `Pipfile` contains the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `Pipfile` 包含以下内容：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And the `Pipfile.lock` is a bit larger, but immediately shows another advantage
    of this method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `Pipfile.lock` 稍大一些，但立即显示了这种方法的优势：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, in addition to the exact package versions, the `Pipfile.lock`
    contains the hashes of the packages as well. In this case, the package provides
    both a `.tar.gz` (source) and a `.whl` (wheel) file, which is why there are two
    hashes. Additionally, the `Pipfile.lock` contains all packages installed by `pipenv`,
    including all dependencies.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了确切的包版本外，`Pipfile.lock` 还包含了包的哈希值。在这种情况下，该包提供了 `.tar.gz`（源文件）和 `.whl`（wheel文件），这就是为什么有两个哈希值。此外，`Pipfile.lock`
    包含了 `pipenv` 安装的所有包，包括所有依赖项。
- en: Using these hashes, you can be certain that during a deployment, you will receive
    the exact same file and not some corrupt or even malicious file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些哈希值，您可以确信在部署过程中，您将收到完全相同的文件，而不会是损坏的甚至恶意文件。
- en: Because the versions are completely fixed, you can also be certain that anyone
    deploying your project using the `Pipfile.lock` will get the exact same package
    versions. This is very useful when working together with other developers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本完全固定，您也可以确信任何使用 `Pipfile.lock` 部署您项目的用户都将获得完全相同的包版本。当与其他开发者合作工作时，这非常有用。
- en: 'To install all the necessary packages as specified in the `Pipfile` (even for
    the initial install), you can simply run:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `Pipfile` 中指定的所有必要包（即使是初始安装），您只需运行：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Any time you run `pipenv install package`, the `Pipfile` will be automatically
    modified with your changes and checked for incompatible packages. The big downside
    is that `pipenv` can become terribly slow for large projects. I have encountered
    multiple projects where a no-op `pip install` would take several minutes due to
    the fetching and checking of the entire dependency graph. In most cases, it’s
    still worth it, however; the added functionality can save you a lot of headaches.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行`pipenv install package`时，`Pipfile`将自动根据你的更改进行修改，并检查是否存在不兼容的包。但最大的缺点是`pipenv`对于大型项目可能会变得非常慢。我遇到过多个项目，其中无操作的`pip
    install`命令需要几分钟的时间，因为需要检索和检查整个依赖图。然而，在大多数情况下，这样做仍然是值得的；增加的功能可以为你节省很多麻烦。
- en: Don’t forget to run your regular Python commands with the `pipenv run` prefix
    or from `pipenv shell`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用`pipenv run`前缀或从`pipenv shell`运行你的常规Python命令。
- en: Updating your packages
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新你的包
- en: 'Because of the dependency graph, you can easily update your packages without
    having to worry about dependency conflicts. With one command, you’re done:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖图，你可以轻松更新你的包，而无需担心依赖冲突。一条命令就可以完成：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Should you still encounter issues with the versions because some packages haven’t
    been checked against each other, you can fix that by specifying the versions of
    the package you do or do not want:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然因为某些包没有相互检查而遇到版本问题，你可以通过指定你想要或不需要的包的版本来修复这个问题：
- en: '[PRE69]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By running that command, the `packages` section of the `Pipfile` changes to:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行该命令，`Pipfile`中的`packages`部分将更改为：
- en: '[PRE70]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Deploying to production
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到生产环境
- en: Getting the exact same versions on all of your production servers is absolutely
    essential to prevent hard-to-trace bugs. For this very purpose, you can tell `pipenv`
    to install everything as specified in the `Pipenv.lock` file while still checking
    to see whether `Pipfile.lock` is out of date. With one command, you have a fully
    functioning production virtual environment with all packages installed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有生产服务器上获取完全相同的版本对于防止难以追踪的错误至关重要。为此，你可以告诉`pipenv`安装`Pipenv.lock`文件中指定的所有内容，同时检查`Pipfile.lock`是否过时。一条命令就可以拥有一个完全功能的生产虚拟环境，其中包含所有已安装的包。
- en: 'Let’s create a new directory and see if it all works out:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的目录，看看一切是否顺利：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All of the versions are exactly as expected and ready for use.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 所有版本都完全符合预期，并已准备好使用。
- en: Running cron commands
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行cron命令
- en: 'To run your Python commands outside of the `pipenv shell`, you can use the
    `pipenv run` prefix. Instead of `python`, you would run `pipenv run python`. In
    normal usage, this is a lot less practical than activating the `pipenv shell`,
    but for non-interactive sessions, such as cron jobs, this is an essential feature.
    For example, a cron job that runs at 03:00 (24-hour clock, so A.M.) every day
    would look something like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`pipenv shell`之外运行你的Python命令，你可以使用`pipenv run`前缀。而不是`python`，你会运行`pipenv run
    python`。在正常使用中，这比激活`pipenv shell`要少用得多，但对于非交互式会话，如cron作业，这是一个基本功能。例如，每天凌晨3:00（24小时制，所以是上午）运行的cron作业可能看起来像这样：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Exercises
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Many of the topics discussed in this chapter already gave full examples, leaving
    little room for exercises. There are additional resources to discover, however.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的许多主题已经提供了完整的示例，几乎没有留下练习的空间。然而，还有其他资源可以探索。
- en: Reading the Python Enhancement Proposals (PEPs)
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读Python增强提案（PEPs）
- en: 'A good way to learn more about the topics discussed in this chapter (and all
    the following chapters) is to read the PEP pages. These proposals were written
    before the changes were accepted into the Python core. Note that not all of the
    PEPs on the Python site have been accepted, but they will remain on the Python
    site:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 了解本章（以及所有后续章节）讨论的主题的一个好方法是阅读PEP页面。这些提案是在更改被接受到Python核心之前编写的。请注意，Python网站上并非所有PEP都被接受，但它们将保留在Python网站上：
- en: 'PEP 440 – Version Identification and Dependency Specification: [https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 440 – 版本标识和依赖规范：[https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)
- en: 'PEP 496 – Environment Markers: [https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 496 – 环境标记：[https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/)
- en: Combining pyenv and poetry or pipenv
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合pyenv和poetry或pipenv
- en: Even though the chapter did not cover it, there is nothing stopping you from
    telling `poetry` or `pipenv` to use a `pyenv`-based Python interpreter. Give it
    a try!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使本章没有涉及，也没有什么阻止你告诉 `poetry` 或 `pipenv` 使用基于 `pyenv` 的 Python 解释器。试试看吧！
- en: Converting an existing project to a poetry project
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将现有项目转换为 poetry 项目
- en: Part of this exercise should be to either create a brand new `pyproject.toml`
    or to convert an existing `requirements.txt` file to a `pyproject.toml`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的一部分应该是创建一个新的 `pyproject.toml` 文件，或者将现有的 `requirements.txt` 文件转换为 `pyproject.toml`。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned why virtual environments are useful and you discovered
    several implementations of them and their advantages. We explored how to create
    virtual environments and how to install multiple different Python versions. Finally,
    we covered how to manage the dependencies for your Python projects.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了为什么虚拟环境是有用的，你发现了它们的几个实现及其优点。我们探讨了如何创建虚拟环境以及如何安装多个不同的 Python 版本。最后，我们介绍了如何管理
    Python 项目的依赖项。
- en: Since Python is an interpreted language, it is easily possible to run code from
    the interpreter directly instead of through a Python file.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 是一种解释型语言，因此直接从解释器运行代码而不是通过 Python 文件运行是很容易的。
- en: The default Python interpreter already features command history and depending
    on your install, basic autocompletion.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Python 解释器已经具有命令历史记录，并且根据你的安装，还提供基本的自动补全功能。
- en: But with alternative interpreters we can have many more features in our interpreter
    such as syntax highlighting, smart autocompletion which includes documentation,
    and more.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用替代解释器，我们可以在解释器中获得更多功能，例如语法高亮、智能自动补全（包括文档）等。
- en: The next chapter will show us several alternative interpreters and their advantages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向我们展示几个替代解释器和它们的优点。
- en: Join our community on Discord
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
