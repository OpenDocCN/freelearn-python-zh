- en: 'Chapter 4. Tasklist II: Databases and AJAX'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：任务列表 II：数据库和 AJAX
- en: In this chapter, we will refactor our tasklist application. It will use a database
    engine on the server to store items and will use jQuery's AJAX functionality to
    dynamically update the contents of the web application. On the server side, we
    will learn how to use Python's bundled SQLite database engine. On the presentation
    side, we will encounter jQuery UI's event system and will learn how to react to
    mouse clicks.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将重构我们的任务列表应用程序。它将在服务器上使用数据库引擎来存储条目，并使用 jQuery 的 AJAX 功能动态更新网络应用程序的内容。在服务器端，我们将学习如何使用
    Python 的内置 SQLite 数据库引擎。在展示方面，我们将遇到 jQuery UI 的事件系统，并学习如何响应用户的鼠标点击。
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn some benefits of using a database engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用数据库引擎的一些好处
- en: Get familiar with SQLite, a database engine distributed with Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 SQLite，Python 一起分发的数据库引擎
- en: Implement a password database with SQLite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite 实现密码数据库
- en: Learn how to design and develop a database-driven tasklist application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何设计和开发一个数据库驱动的任务列表应用程序
- en: Implement a test framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个测试框架
- en: Learn how to make a web application more responsive using AJAX calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 AJAX 调用使网络应用程序更具响应性
- en: See how to implement interactive applications without`<form>` elements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何在不使用`<form>`元素的情况下实现交互式应用程序
- en: So let's get on with it...
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧...
- en: The advantages of a database compared to a filesystem
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统相比，数据库的优势
- en: 'Storing records on a filesystem as separate files might be simple but does
    have several drawbacks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录存储在文件系统上的单独文件中可能很简单，但确实有几个缺点：
- en: You have to define your own interface for accessing these files and parsing
    their contents. This is much more serious than it may sound because it compels
    you to develop and test a lot of specific functionality that you would otherwise
    get more or less for free from an existing library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须定义自己的接口来访问这些文件并解析其内容。这比听起来要严重得多，因为它迫使您开发并测试大量您本可以从现有库中免费获得的具体功能
- en: Accessing single files is much slower than selecting records from a table in
    a database. That might be workable as long as you know which record you want (as
    is the case in our tasklist application) but it certainly isn't workable when
    you want to select records based on the value of some attribute. This would necessitate
    opening each and every file and checking whether some attribute matches your criteria.
    On a data collection of hundreds of items or more, this would be prohibitively
    slow
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问单个文件比从数据库表中选择记录要慢得多。如果您知道您想要哪个记录（就像在我们的任务列表应用程序中那样），这可能可行，但如果你想要根据某些属性的值来选择记录，那就绝对不可行。这将需要打开每个文件并检查某些属性是否与您的标准匹配。在一个包含数百个或更多条目的数据集中，这将非常慢
- en: Also, it is difficult to implement transactions. If we want to guarantee that
    a set of actions will either be successful as a whole or will be rolled back if
    some part of it doesn't succeed, we will have to implement very sophisticated
    code ourselves if we want to use files on a filesystem
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，实现事务也很困难。如果我们想保证一组操作要么全部成功，要么在部分操作失败时回滚，那么如果我们想在文件系统上使用文件，我们就必须自己编写非常复杂的代码
- en: When using files on a filesystem, it is a nuisance to define and maintain relations
    between records, and although our tasklist application is about as simple as it
    gets, almost any other application has more than one logical object and relations
    between them, so this is a serious issue.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在文件系统上使用文件时，定义和维护记录之间的关系很麻烦，尽管我们的任务列表应用程序非常简单，但几乎任何其他应用程序都有多个逻辑对象以及它们之间的关系，因此这是一个严重的问题。
- en: Choosing a database engine
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个数据库引擎
- en: There are many database engines available that can be accessed from Python,
    both commercial and open source (http://wiki.python.org/moin/DatabaseInterfaces).
    Choosing the right database is not a trivial task as it might not only depend
    on functional requirements, but also on performance, the available budget, and
    hard to define requirements like easy maintenance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可供 Python 访问的数据库引擎有很多，包括商业的和开源的（http://wiki.python.org/moin/DatabaseInterfaces）。选择正确的数据库不是一件简单的事情，因为它不仅可能取决于功能需求，还可能取决于性能、可用预算以及难以定义的需求，如易于维护。
- en: 'In the applications we develop in this book, we have chosen to use the SQLite
    database engine ([http://www.sqlite.org](http://http://www.sqlite.org)) for a
    number of reasons. First, it is free and included in Python''s standard distribution.
    This is important for people writing books because it means that everyone who
    is able to run Python has access to the SQLite database engine as well. However,
    this is not a toy database: as a matter of fact, SQLite is a database that is
    used in many smartphones and high-profile applications like Firefox to store things
    like configurations and bookmarks. Furthermore, it is reliable and robust and,
    on top of that, quite fast.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们开发的应用程序中，我们选择使用SQLite数据库引擎（[http://www.sqlite.org](http://http://www.sqlite.org)）出于多个原因。首先，它是免费的，并且包含在Python的标准发行版中。这对写书的人来说很重要，因为它意味着能够运行Python的每个人都可以访问SQLite数据库引擎。然而，这并不是一个玩具数据库：事实上，SQLite是许多智能手机和像Firefox这样的高知名度应用程序中使用的数据库，用于存储配置和书签等信息。此外，它可靠且健壮，而且速度相当快。
- en: 'It does have some drawbacks as well: first of all, it uses its own dialect
    of SQL (the language used to interact with the database) but to be fair, most
    database engines use their own dialect.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实也有一些缺点：首先，它使用自己的SQL方言（用于与数据库交互的语言），但公平地说，大多数数据库引擎都使用自己的方言。
- en: More seriously, the focus of SQLite is on embedded systems, the most visible
    consequence of that is that it doesn't have facilities to limit user access to
    a subset of tables and columns. There is just a single file on the filesystem
    that holds the contents of the database and the access rights to the file are
    determined by the filesystem on which it resides.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更严重的是，SQLite的重点在于嵌入式系统，最明显的后果是它没有提供限制用户访问表和列子集的功能。在文件系统中只有一个文件包含数据库的内容，对该文件的访问权限由其所在的文件系统决定。
- en: 'The final issue is not so much a drawback as a point of serious attention:
    SQLite does not enforce types. In many databases, the type defined for column
    determines rigidly what you can store in that column. When a column is defined
    as an INTEGER, the database engine, in general, won''t allow you to store a string
    or a boolean value, whereas, SQLite does. This isn''t as strange as it sounds
    once you compare it with the way Python manages variables. In Python, it is perfectly
    valid to define a variable and assign an integer to it, and later assign a string
    to the same variable. A variable in Python is just like a column in SQLite; it
    is just a pointer to a value and that value is not simply the value itself but
    also has an explicitly associated type.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题与其说是缺点，不如说是一个需要认真注意的点：SQLite不强制执行类型。在许多数据库中，为列定义的类型严格决定了你可以存储在该列中的内容。当一列被定义为INTEGER时，通常数据库引擎不会允许你存储字符串或布尔值，而SQLite则允许这样做。一旦你将其与Python管理变量的方式进行比较，这并不像听起来那么奇怪。在Python中，定义一个变量并将其分配一个整数是完全可以接受的，稍后可以将字符串分配给同一个变量。Python中的变量就像SQLite中的列一样；它只是一个指向值的指针，而这个值不仅仅是值本身，还与一个显式关联的类型相关联。
- en: The combination of availability, reliability, and a type system closely resembling
    Python's native way of dealing with values makes SQLite a very suitable database
    engine in many applications, although specific applications may have requirements
    that may be better served by other database engines, like PostgreSQL or MySQL.
    The latter might be an attractive alternative if your application will run on
    a web server that already provides MySQL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性、可靠性和类型系统与Python原生处理值的方式紧密相似，这使得SQLite在许多应用程序中成为一个非常适合的数据库引擎，尽管具体的应用程序可能需要其他数据库引擎，如PostgreSQL或MySQL来更好地满足需求。如果您的应用程序将在已经提供MySQL的Web服务器上运行，那么后者可能是一个有吸引力的替代方案。
- en: Database-driven authentication
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库驱动认证
- en: 'Before we start designing a database-driven tasklist application, let''s first
    familiarize ourselves with SQLite in the context of a seemingly much simpler set
    of requirements: storing username/password combinations in a database and refactoring
    the Logon class to interact with this database.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计数据库驱动的任务列表应用程序之前，让我们首先熟悉SQLite在看似更简单的一组要求中的使用情况：在数据库中存储用户名/密码组合，并重构Logon类以与该数据库交互。
- en: 'The functional requirements are deceptively simple: to verify whether a username/password
    combination is valid, all we have to do is verify that the username/password combination
    given is present in the table of usernames and passwords. Such a table consists
    of two columns, one named `username` and the other named `password`. As it is
    never a good idea to store a collection of passwords in plaintext, we encrypt
    the passwords with a hash function so even if the password database is compromised,
    the bad guys will have a difficult time retrieving the passwords. This means,
    of course, that we have to hash a given password with the same hash function before
    comparing it to the stored password for the username but that doesn''t add much
    complexity.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 功能需求看似简单：验证用户名/密码组合是否有效，我们只需确认提供的用户名/密码组合是否存在于用户名和密码表中。这样的表包含两列，一列名为`username`，另一列名为`password`。由于将密码以明文形式存储从来都不是一个好主意，我们使用哈希函数加密密码，这样即使密码数据库被破坏，坏人也会很难恢复密码。这意味着，当然，我们必须使用相同的哈希函数对给定的密码进行哈希处理，然后再将其与存储的用户名对应的密码进行比较，但这并不会增加太多复杂性。
- en: What does add complexity is the fact that CherryPy is multi-threaded, meaning
    that CherryPy consists of multiple lightweight processes accessing the same data.
    And although the developers of SQLite maintain the opinion that threads are evil
    ([http://www.sqlite.org/faq.html#q6](http://www.sqlite.org/faq.html#q6)), threads
    make perfect sense in situations where a lot of time in the application is spent
    on waiting. This certainly is the case in web applications that spend a lot of
    time waiting for network traffic to complete, even in this time of broadband connections.
    The most effective way of using this waiting time is to enable a different thread
    to serve another connection so more users might enjoy a better interactive experience.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 增加复杂性的是，CherryPy是多线程的，这意味着CherryPy由多个轻量级进程访问相同的数据组成。尽管SQLite的开发者认为线程是邪恶的([http://www.sqlite.org/faq.html#q6](http://www.sqlite.org/faq.html#q6))，但在应用程序中花费大量时间等待的情况下，线程是非常有意义的。这当然适用于花费大量时间等待网络流量完成的Web应用程序，即使在宽带连接的时代也是如此。利用这种等待时间最有效的方法是启用不同的线程来服务另一个连接，这样更多的用户可以享受到更好的交互体验。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Hash functions** (or Cryptographic hash functions to be more specific) convert
    any input string to an output string of limited length in such a way that it is
    very unlikely that two input strings that are different produce the same output.
    Also, conversion from input to output is a one way operation or at least it will
    cost a large amount of computing power to construct the input from the output.
    There are many useful hash functions known, the most popular ones are available
    in Python''s `hashlib` module. The specific hash function we use here is called
    `SHA1`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希函数**（或者更具体地说，加密哈希函数）以某种方式将任何输入字符串转换为有限长度的输出字符串，使得两个不同的输入字符串产生相同输出字符串的可能性非常低。此外，从输入到输出的转换是一个单向操作，或者至少从输出构造输入将需要大量的计算能力。已知有许多有用的哈希函数，其中最流行的是Python的`hashlib`模块中可用的。我们这里使用的特定哈希函数称为`SHA1`。'
- en: More about hashing can be found in the Python documentation at [http://docs.python.org/py3k/library/hashlib.html](http://docs.python.org/py3k/library/hashlib.html),
    or on Wikipedia at [http://en.wikipedia.org/wiki/Cryptographic_hash_function](http://en.wikipedia.org/wiki/Cryptographic_hash_function).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于哈希的信息可以在Python文档中找到，链接为[http://docs.python.org/py3k/library/hashlib.html](http://docs.python.org/py3k/library/hashlib.html)，或者在维基百科上查看[http://en.wikipedia.org/wiki/Cryptographic_hash_function](http://en.wikipedia.org/wiki/Cryptographic_hash_function)。
- en: However, in SQLite, the connection object cannot be shared among threads. This
    doesn't mean that that we cannot use SQLite in a multi-threaded environment (despite
    the evilness of threads), but it does mean we have to make sure that if we want
    to access the same SQLite database from different threads, each thread must use
    a connection object that is exclusively created for that thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在SQLite中，连接对象不能在多个线程之间共享。这并不意味着我们不能在多线程环境中使用SQLite（尽管线程是邪恶的），但这确实意味着如果我们想从不同的线程访问相同的SQLite数据库，每个线程都必须使用为该线程独家创建的连接对象。
- en: Fortunately, it is quite easy to instruct CherryPy to call a function the moment
    it starts a new thread and let that function create a new connection to our database,
    as we will see in the next section. If we would employ many different threads,
    this might be wasteful because the connection objects use some memory, but with
    a few tens of threads this doesn't pose much of a problem (The default number
    of threads in CherryPy is 10 and can be configured with the `server.thread_pool`
    configuration option). If the memory consumption is a problem, there are alternative
    solutions available, for example, in the form of a separate worker thread that
    handles all database interaction or a small pool of such threads. A starting point
    for this might be [http://tools.cherrypy.org/wiki/Databases](http://tools.cherrypy.org/wiki/Databases).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，指导 CherryPy 在启动新线程时调用一个函数，并让该函数创建一个新的数据库连接，这相当简单，我们将在下一节中看到。如果我们使用许多不同的线程，这可能会造成浪费，因为连接对象会占用一些内存，但只有几十个线程，这并不会造成太大的问题（CherryPy
    的默认线程数是 10，可以通过 `server.thread_pool` 配置选项进行配置）。如果内存消耗是一个问题，还有其他解决方案可用，例如，可以是一个单独的工作线程来处理所有数据库交互，或者是一小群这样的线程。这个起点可能是[http://tools.cherrypy.org/wiki/Databases](http://tools.cherrypy.org/wiki/Databases)。
- en: Time for action authentication using a database
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库进行行动认证
- en: To illustrate how to use database-driven user authentication, run `logondbapp.py`.
    It will present you with a logon screen very similar to the one shown in the previous
    chapter. You may enter the built-in username/password combination of admin/admin,
    after which you will be presented with a welcoming page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用数据库驱动的用户认证，运行 `logondbapp.py`。它将向您展示一个登录界面，与上一章中显示的非常相似。您可以输入内置的用户名/密码组合
    admin/admin，之后您将看到一个欢迎页面。
- en: In order to make this mini application work with the database-driven version
    of user authentication, all we have to do is replace the reference to an instance
    of the Logon class to one of the `LogonDB` class, as highlighted in the following
    code (the full code is available as `logondbapp.py):`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个迷你应用程序能够与基于数据库的用户认证版本一起工作，我们只需要将 Logon 类的实例引用替换为 `LogonDB` 类的一个实例，如以下代码中高亮显示的那样（完整的代码作为
    `logondbapp.py` 提供）：`
- en: '**Chapter4/logondbdb.py**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter4/logondbdb.py**'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another important difference with the previous implementation is the highlighted
    definition of a `connect()` function that should be called for each new thread
    that is started by CherryPy. It calls the `connect()` method of the `LogonDB`
    instance to create a database connection object unique for a given thread. We
    register this function with the `cherrypy.engine.subscribe()` function and make
    it call our `connect()` function at the start of each new thread CherryPy starts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的实现相比，另一个重要的区别是高亮显示的 `connect()` 函数的定义，这个函数应该在 CherryPy 启动每个新线程时调用。它调用 `LogonDB`
    实例的 `connect()` 方法来创建一个针对给定线程唯一的数据库连接对象。我们使用 `cherrypy.engine.subscribe()` 函数注册这个函数，并让它在每个
    CherryPy 启动的新线程开始时调用我们的 `connect()` 函数。
- en: What just happened?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The database-centered version of our `Logon` class, `LogonDB` inherits a lot
    from `Logon`. Specifically, all HTML-related logic is reused. `LogonDB` does override
    the `__init__()` method to store a path to a database file and makes sure the
    database is initialized using the `initdb()` method, if it does not yet exist
    (highlighted). It also overrides the `checkpass()` method because this method
    must now verify the existence of a valid username/password pair against a database
    table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `Logon` 类的数据库版本 `LogonDB` 从 `Logon` 类继承了很多内容。具体来说，所有与 HTML 相关的逻辑都被重用了。`LogonDB`
    重写了 `__init__()` 方法来存储数据库文件的路径，并确保如果数据库文件不存在，则使用 `initdb()` 方法初始化数据库（高亮显示）。它还重写了
    `checkpass()` 方法，因为这个方法现在必须验证有效的用户名/密码对是否存在于数据库表中。
- en: '**Chapter4/logondb.py**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter4/logondb.py**'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The definition of the database consists of a single table `pwdb` that is defined
    in the highlighted line (and only if that table does not yet exist). The `pwdb`
    table consists of two columns, namely, `username` and `password`. By marking both
    columns as `not null`, we ensure that we cannot enter empty values in any of them.
    The `username` column is also marked as `unique` because a username may only occur
    once. This database schema of a single table can be depicted in the following
    diagram where each column has a header with a name and several lines that list
    the attributes of a certain column (as our database design gets more elaborate,
    we will rely more on these diagrams and less on a detailed expose of the SQL code):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的定义由一个名为 `pwdb` 的单表组成，该表在突出显示的行中定义（并且只有当该表尚不存在时）。`pwdb` 表由两列组成，即 `username`
    和 `password`。通过将这两列都标记为 `not null`，我们确保不能在它们中输入任何空值。`username` 列也被标记为 `unique`，因为用户名只能出现一次。这种单表数据库模式可以用以下图表表示，其中每个列都有一个带有名称的标题和列出特定列属性的几行（随着我们的数据库设计变得更加复杂，我们将更多地依赖这些图表，而不是详细展示
    SQL 代码）：
- en: '| Pwdb |   |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Pwdb |   |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Username | password |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 密码 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| not nullunique | not null |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| not nullunique | not null |'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Anyone familiar with other dialects of SQL might have noticed that the column
    definitions lack any kind of type. This is deliberate: SQLite allows us to store
    any kind of value in a column, just as Python allows us to store any kind of value
    in a variable. The type of the value is directly associated with the value, not
    with the column or variable. SQLite does support the notion of affinity or preferred
    type and we will encounter that in other tables we will create in this book.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉其他 SQL 方言的人可能会注意到列定义缺少任何类型。这是故意的：SQLite 允许我们在列中存储任何类型的值，就像 Python 允许我们在变量中存储任何类型的值一样。值的类型直接与值相关联，而不是与列或变量相关联。SQLite
    支持亲和力或首选类型的概念，我们将在本书中创建的其他表中遇到这一点。
- en: Besides creating a table, if needed (in the `initdb()` method, highlighted),
    we also initialize it with a username/password combination of admin/admin if the
    admin username is not yet there. If it is, we leave it as it is because we do
    not want to reset an altered password, but we do want to make sure that there
    is an admin username present. This is accomplished by the `insert or ignore` statement
    because the `insert` of an `admin` username into a table that already contains
    one would fail because of the unique constraint. Adding the non standard or `ignore`
    clause will ignore such an occurrence, in other words, it will not insert a new
    record with a username of admin if it is already there.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建表（在 `initdb()` 方法中突出显示）之外，如果需要，我们还会用管理员/管理员组合（admin/admin）初始化它，如果管理员用户名尚不存在。如果它已经存在，我们就让它保持原样，因为我们不希望重置已更改的密码，但我们确实想确保存在一个管理员用户名。这是通过
    `insert or ignore` 语句实现的，因为将 `admin` 用户名插入到已包含一个的表中会因唯一约束而失败。添加非标准或 `ignore` 子句将忽略此类情况，换句话说，如果已经存在，它将不会插入具有管理员用户名的记录。
- en: The `insert` statement also illustrates that we store passwords not as plaintext,
    but as hashed values (that are extremely hard to convert back to plaintext again).
    The hash method we use here is SHA1 and is imported as `hash()` from Python's
    `hashlib` module. The conversion from plaintext is handled by the `_dohash()`
    static method (marked as private by leading underscore in its name but note that
    in Python, this is a convention only, as there really aren't any private methods).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 语句还说明了我们存储密码不是以明文形式，而是以散列值（这些散列值非常难以再次转换为明文）的形式。我们在这里使用的散列方法是 SHA1，它作为
    `hash()` 从 Python 的 `hashlib` 模块导入。从明文到散列值的转换由 `_dohash()` 静态方法（通过其名称前的下划线标记为私有，但请注意，在
    Python 中，这仅是一种约定，因为实际上并没有真正的私有方法）处理。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The way we store passwords in this example is still not safe enough for production
    environments, but implementing a more secure solution is out of scope for this
    book. I strongly suggest reading [http://www.aspheute.com/english/20040105.asp](http://www.aspheute.com/english/20040105.asp)
    for more on this subject.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们存储密码的方式对于生产环境来说仍然不够安全，但实现更安全的解决方案超出了本书的范围。我强烈建议阅读 [http://www.aspheute.com/english/20040105.asp](http://www.aspheute.com/english/20040105.asp)
    了解更多关于这个主题的内容。
- en: The `initdb()` method also takes care of creating an object that can be used
    to store data that is local to a thread with the `threading.local()` function.
    Because, normally, all data in threads is shared, we have to use this function
    to create a place to store a database connection object that is different for
    each thread. If we were to store such a connection object in a global variable,
    each thread would have access to the same database connection and this is not
    allowed in SQLite.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`initdb()` 方法还负责使用 `threading.local()` 函数创建一个对象，该对象可以用来存储线程本地的数据。因为通常线程中的所有数据都是共享的，我们必须使用这个函数来创建一个地方来存储每个线程不同的数据库连接对象。如果我们把这样的连接对象存储在全局变量中，每个线程都会访问相同的数据库连接，这是SQLite不允许的。'
- en: The fact that we store passwords as hashed values implies that checking username/password
    combinations necessarily involves converting a plaintext password as well before
    it can be checked for existence. This is implemented in the `checkpass()` method
    (highlighted). The password argument is converted with the `_dohash()` method
    before being passed to the `execute()` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密码存储为散列值的事实意味着检查用户名/密码组合必然涉及到在检查存在性之前将明文密码转换为散列值。这通过 `checkpass()` 方法（突出显示）实现。密码参数在传递给
    `execute()` 方法之前，使用 `_dohash()` 方法进行转换。
- en: The SQL statement itself then counts the number of rows in the `pwdb` table
    that contain the given username and (hashed) password and retrieves the result.
    The result is a single row containing a single value, the number of matching rows.
    If this is one, we have a valid username/password combination, otherwise we don't.
    We do not discriminate between the cases where the username is unknown or whether
    there is more than a single row containing the same username. This is because
    the latter situation is unlikely to happen because of the `unique` constraint
    on the username column.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 语句本身计算 `pwdb` 表中包含给定用户名和（散列的）密码的行数，并检索结果。结果是包含单个值的单行，即匹配行的数量。如果这个数量是1，我们就有一个有效的用户名/密码组合，否则没有。我们不会区分用户名未知的情况或是否存在多个包含相同用户名的行。这是因为后者由于用户名列上的
    `unique` 约束而不太可能发生。
- en: Have a go hero adding new username/passwords
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试添加新的用户名/密码的英雄
- en: Our `LogonDB` class does not yet have a method to add a new username/password
    combination to the database. How would you implement one?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LogonDB` 类还没有一个方法可以将新的用户名/密码组合添加到数据库中。你将如何实现一个？
- en: 'Hint: You need to provide both an exposed method that offers a page with a
    form where one can enter a new username and password and a method that may act
    as an action attribute in a`<form>` element and that is passed the username and
    password as parameters.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你需要提供一个公开的方法，该方法提供一个带有表单的页面，可以在其中输入新的用户名和密码，以及一个可能作为 `<form>` 元素的 action
    属性的方法，并将用户名和密码作为参数传递。
- en: Note that this method has to check not only that the user is authenticated but
    also that the user that adds the new username/password is the admin, otherwise
    everyone could add new accounts! A sample implementation is already provided in
    `logondb.py`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法必须检查用户是否已认证，而且还必须检查添加新用户名/密码的用户是否是管理员，否则每个人都可以添加新账户！`logondb.py` 中已经提供了一个示例实现。
- en: Tasklist II storing tasks in a database
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tasklist II 存储任务到数据库中
- en: Now that we have seen how we may use a database engine to store persistent data
    and how to access this data from a CherryPy application, let's apply this new
    knowledge to the tasklist application we designed in the previous chapter. Of
    course, there is more to an application than storing data and we will also revamp
    the user interface in order to make it more responsive and slightly simpler to
    maintain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用数据库引擎来存储持久数据，以及如何从 CherryPy 应用程序中访问这些数据，让我们将新知识应用到我们在上一章中设计的任务列表应用程序中。当然，一个应用程序不仅仅是存储数据，我们还将重新设计用户界面，使其更具响应性，并且稍微简单一些以维护。
- en: Improving interactivity with AJAX
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 AJAX 提高交互性
- en: 'When you look at the difference between applications that are standalone on
    a PC versus a web application, you might notice few differences at a first glance.
    However, if you look more closely, there is a major difference: In the standalone
    application when something changes in the display, only those onscreen elements
    are redrawn that are actually modified.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看独立于PC的独立应用程序与Web应用程序之间的差异时，你可能会在第一眼看到一些细微的差异。然而，如果你更仔细地观察，你会发现一个主要差异：在独立应用程序中，当显示发生变化时，只有实际修改的屏幕元素会被重新绘制。
- en: In traditional web pages, this is completely different. Clicking a button that
    changes the sort order of a list, for example, might not only retrieve and redraw
    that list again, but would retrieve a complete page, including all side bars,
    navigation headers, advertisements, and what not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的网页中，这完全不同。例如，点击一个改变列表排序顺序的按钮，可能会不仅检索并重新绘制那个列表，还可能检索一个完整的页面，包括所有侧边栏、导航标题、广告等等。
- en: If that unmodified content is slow to retrieve over the internet, the whole
    web page might feel sluggish, even more so if the whole webpage is waiting for
    the arrival of the last piece of information to display itself in its full glory.
    When web pages evolved to mimic applications, this difference in the interactive
    experience quickly became a nuisance and people started thinking about solutions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未修改的内容在互联网上检索缓慢，整个网页可能会感觉反应迟缓，尤其是如果整个网页都在等待最后一块信息的到来以展示其全部魅力。当网页发展到模仿应用程序时，这种交互体验的差异很快变成了一个麻烦，人们开始考虑解决方案。
- en: 'One of the most prominent of those solutions is AJAX. It''s an abbreviation
    for asynchronous JavaScript and XML, that is, a method to retrieve data by using
    the browser''s built-in JavaScript capabilities. Nowadays, every browser supports
    AJAX and the jQuery library smoothes out most browser inconsistencies. The XML
    part in the name is no longer relevant as the data that might be retrieved with
    an AJAX call might be just about anything: besides XML and its close cousin HTML,
    **JavaScript Object Notation** (JSON) is a popular format to transmit data that
    might be processed even more simply than XML by the JavaScript interpreter in
    the browser.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案中最突出的一种是 AJAX。它是异步 JavaScript 和 XML 的缩写，即一种使用浏览器内置的 JavaScript 功能检索数据的方法。如今，每个浏览器都支持
    AJAX，jQuery 库平滑了大多数浏览器的不一致性。名称中的 XML 部分不再相关，因为 AJAX 调用可能检索的数据几乎可以是任何东西：除了 XML
    和其近亲 HTML 之外，**JavaScript 对象表示法**（JSON）是一种流行的数据传输格式，它可以通过浏览器中的 JavaScript 解释器比
    XML 更简单地处理数据。
- en: 'The asynchronous bit in the AJAX name is still relevant, however: most AJAX
    calls that retrieve data return immediately without waiting for the result. However,
    they do call a function when the data retrieval is complete. This ensures that
    other parts of the application are not stalled and that the overall interactive
    experience of the web application can be improved.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 名称中的异步部分仍然相关：大多数 AJAX 调用在检索数据后会立即返回，而不等待结果。然而，当数据检索完成时，它们会调用一个函数。这确保了应用程序的其他部分不会停滞，并且可以改善整个
    Web 应用程序的交互体验。
- en: Time for action getting the time with AJAX
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AJAX 获取时间的时间操作
- en: Enter the following code and run it. If you point your web browser to the familiar
    [http://localhost:8080](http://localhost:8080) address, you will see something
    similar to the picture below with the time changing every five seconds or so.
    (The code is also available as `timer.py)`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并运行它。如果你将你的网络浏览器指向熟悉的 [http://localhost:8080](http://localhost:8080) 地址，你将看到下面的图片，时间大约每五秒变化一次。（代码也作为
    `timer.py` 提供）
- en: '![Time for action getting the time with AJAX](img/3746_4_1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用 AJAX 获取时间的时间操作](img/3746_4_1.jpg)'
- en: What just happened?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Our small CherryPy application offers just two methods (both highlighted in
    the code). The `index()` method returns a minimalistic HTML page with some static
    text and a small piece of JavaScript that takes care of retrieving the current
    time from the server. It also features a `time()` method that simply returns the
    current time as plain text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小 CherryPy 应用程序只提供两种方法（在代码中都已突出显示）。`index()` 方法返回一个极简的 HTML 页面，其中包含一些静态文本和一小段
    JavaScript 代码，负责从服务器检索当前时间。它还包含一个 `time()` 方法，该方法简单地返回纯文本格式的当前时间。
- en: '**Chapter4/timer.py**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter4/timer.py**'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The magic is in that small piece of JavaScript (highlighted). This script is
    executed once the static page is loaded and it calls the `setInterval()` method
    of the `window` object. The arguments to the `setInterval()` method are an anonymous
    function and a time interval in milliseconds. We set the time interval to five
    seconds. The function passed to `setInterval()` is called at the end of each interval.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法在于那小块 JavaScript（已突出显示）。此脚本在静态页面加载后执行，并调用 `window` 对象的 `setInterval()` 方法。`setInterval()`
    方法的参数是一个匿名函数和一个以毫秒为单位的时间间隔。我们将时间间隔设置为五秒。传递给 `setInterval()` 的函数在每个间隔结束时被调用。
- en: In this example, we pass an anonymous function to `setInterval()` that relies
    on jQuery's `ajax()` function to retrieve the time. The `ajax()` function's only
    argument is an object that may contain numerous options. The `url` option tells
    which URL to use to retrieve the data from, in this case, the relative URL `time`
    (relative to the page that serves the content the script is embedded in, `/`,
    so it actually refers to `http://localhost:8080/time)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向 `setInterval()` 传递一个匿名函数，该函数依赖于 jQuery 的 `ajax()` 函数来检索时间。`ajax()`
    函数的唯一参数是一个对象，该对象可能包含许多选项。`url` 选项告诉使用哪个 URL 来检索数据，在这种情况下，相对 URL `time`（相对于嵌入脚本的页面提供的内容，`/`，因此它实际上指的是
    `http://localhost:8080/time`)。
- en: The `cache` option is set to `false` to prevent the browser from using a cached
    result when instructed to get the time URL it has seen already. This is ensured
    by the underlying JavaScript library by appending an extra `_` parameter (that
    is the name of this parameter which consists of a single underscore) to the URL.
    This extra parameter contains a random number, so the browser will regard each
    call as a call to a new URL. The `time()` method is defined to accept this parameter
    because otherwise CherryPy would raise an exception, but the contents of the parameter
    are ignored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache` 选项被设置为 `false` 以防止浏览器在指令获取它已经看到的 URL 的时间时使用缓存的结果。这是通过底层 JavaScript
    库通过在 URL 后附加一个额外的 `_` 参数（即该参数的名称，由一个单下划线组成）来确保的。这个额外的参数包含一个随机数，因此浏览器会将每次调用视为对新的
    URL 的调用。`time()` 方法被定义为接受此参数，因为否则 CherryPy 会引发异常，但参数的内容会被忽略。'
- en: 'The `success` option is set to a function that will be called when the data
    is successfully received. This function will receive three arguments when called:
    the data that was retrieved by the `ajax()` function, the status, and the original
    request object. We will only use the data here.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`success` 选项被设置为当数据成功接收时将被调用的函数。当函数被调用时，它将接收三个参数：由 `ajax()` 函数检索到的数据、状态和原始请求对象。我们在这里只使用数据。'
- en: We select the`<div>` element with the `time` ID and replace its contents by
    passing the data to its `html()` method. Note that even though the `time()` method
    just produces text, it could just as easily have returned text containing some
    markup this way.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择具有 `time` ID 的 `<div>` 元素，并通过将其数据传递给其 `html()` 方法来替换其内容。请注意，尽管 `time()`
    方法只是生成文本，但它也可以通过这种方式返回包含一些标记的文本。
- en: We explicitly instructed the `ajax()` function not to cache the result of the
    query, but instead we could also decorate our `time()` method with CherryPy's
    `expires` tool. This would instruct the `time()` method to insert the correct
    http headers in response to instruct the browser not to cache the results. This
    is illustrated in the following code (available in `timer2.py):`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确指令 `ajax()` 函数不要缓存查询的结果，但我们也可能用 CherryPy 的 `expires` 工具装饰我们的 `time()` 方法。这将指令
    `time()` 方法在响应中插入正确的 http 头部，以指示浏览器不要缓存结果。这在上面的代码（在 `timer2.py` 中可用）中得到了说明。
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the `@cherrypy.tools.expires` decorator means we do not have to instruct
    the `ajax()` method not to cache the result, which gives us the option to use
    a shortcut method. The JavaScript code may then be rewritten to use jQuery''s
    `load()` method, shown as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@cherrypy.tools.expires` 装饰器意味着我们不必指令 `ajax()` 方法不要缓存结果，这给了我们使用快捷方法的选择。然后，JavaScript
    代码可以被重写为使用 jQuery 的 `load()` 方法，如下所示：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `load()` method is passed the URL where it will retrieve the data and, upon
    success, will replace the contents of the selected `DOMelement` with the data
    it received.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 方法被传递了它将从中检索数据的 URL，并且在成功的情况下，会用接收到的数据替换选定的 `DOM元素` 的内容。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'jQuery provides many AJAX shortcut methods and all these methods share a common
    set of defaults that may be set using the `ajaxSetup()` function. For example,
    to make sure all AJAX methods will not cache any returned result, we could call
    it like this: `$.ajaxSetup({cache:false})`;'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了许多 AJAX 快捷方法，并且所有这些方法都共享一组通用的默认设置，可以使用 `ajaxSetup()` 函数来设置。例如，为了确保所有
    AJAX 方法都不会缓存任何返回的结果，我们可以这样调用它：`$.ajaxSetup({cache:false})`；
- en: Redesigning the Tasklist application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新设计任务列表应用程序
- en: 'The tasklist application will consist of two parts: an authentication part
    for which we will reuse the `LogonDB` class and new `TaskApp` class. The `TaskApp`
    class will implement the methods necessary to deliver the page with an overview
    of all tasks for the authenticated user plus additional methods to respond to
    AJAX requests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表应用程序将包括两部分：一个用于身份验证的部分，我们将重用 `LogonDB` 类和新的 `TaskApp` 类。`TaskApp` 类将实现提供已验证用户所有任务概览页面所需的方法，以及响应
    AJAX 请求的额外方法。
- en: Instead of a filesystem, SQLite will be used to store the tasks for all users.
    Note that this is a separate database from the one used to store usernames and
    passwords. Such a setup allows us to keep the authentication functionality separate
    from other concerns, allowing for easier reuse. Once the user is authenticated,
    we do, of course, use his/her username to identify the tasks belonging to him/her.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于文件系统，SQLite 将被用来存储所有用户的任务。请注意，这是一个与用于存储用户名和密码的数据库分开的独立数据库。这样的设置使我们能够将身份验证功能与其他关注点分开，从而便于重用。一旦用户通过身份验证，我们当然会使用他的/她的用户名来识别属于他/她的任务。
- en: Access to the task database will be encapsulated in a `tasklistdb` module. It
    provides classes and methods to retrieve, add, and modify tasks for a given user.
    It is not concerned with checking access permission, as this is the responsibility
    of the `TaskApp` class. You can picture this separation as a two layer model,
    the top layer checking user credentials and serving content, and the bottom layer
    actually interfacing with a database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对任务数据库的访问将被封装在 `tasklistdb` 模块中。它提供了类和方法来检索、添加和修改特定用户的任务。它不关心检查访问权限，因为这属于 `TaskApp`
    类的责任。你可以将这种分离想象成一个双层模型，顶层检查用户凭据并提供服务，底层实际与数据库交互。
- en: '![Redesigning the Tasklist application](img/3746OS_04_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![重新设计任务列表应用程序](img/3746OS_04_02.jpg)'
- en: Database design
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库设计
- en: The design of our task database (the database *schema)* is very straightforward.
    It consists of a single table, which contains columns to define a task.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务数据库（数据库 *模式*）的设计非常简单。它由一个包含定义任务的列的单个表组成。
- en: '| Task |   |   |   |   |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 任务 |   |   |   |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| task_id | description | duedate | completed | user_id |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| task_id | description | duedate | completed | user_id |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| integerprimary keyautoincrement |   |   |   |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| integerprimary keyautoincrement |   |   |   |   |'
- en: Most columns do not have a specific type defined, as SQLite will let us store
    anything in a column. Furthermore, most columns do not have special constraints
    except for the `task_id` column that we designate to be the primary key. We do
    explicitly type the `task_id` column as an integer and designate it as `autoincrement`.
    This way, we do not have to set the value of this column explicitly, but a new
    unique integer will be inserted for us every time we add a new task to the table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数列没有定义特定的类型，因为 SQLite 允许我们在列中存储任何内容。此外，大多数列没有特殊的约束，除了我们指定的 `task_id` 列，我们将其指定为主键。我们明确地将
    `task_id` 列类型指定为整数，并指定为 `autoincrement`。这样，我们不必显式设置此列的值，每次我们向表中添加新任务时，都会为我们插入一个新的唯一整数。
- en: Time for action creating the task database
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务数据库的时间
- en: First, let us take some time to familiarize with the steps necessary to create
    a new database from Python.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们花些时间熟悉创建新数据库所需的步骤。
- en: Enter the following code and run it (It is also available as `taskdb1.py)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并运行它（它也作为 `taskdb1.py` 提供）。
- en: '**Chapter4/taskdb1.py**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/taskdb1.py**'
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will create a temporary database in memory and defines a task table. It also
    populates this table with a number of tasks using INSERT statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在内存中创建一个临时数据库，并定义一个任务表。它还使用 INSERT 语句向此表填充多个任务。
- en: What just happened?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: After establishing a connection to the database, the first task is to create
    the `task` table (highlighted). Here we use the `executescript()` method of the
    `connection` object, because this method allows us to pass more than one SQL statement
    in one go. Here our database schema consists of a single `create` statement so
    the `execute()` method would do just as well, but normally when creating a database,
    we create a number of tables and then passing all necessary SQL statements together
    is very convenient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立数据库连接后，第一个任务是创建`task`表（已突出显示）。在这里，我们使用`connection`对象的`executescript()`方法，因为这个方法允许我们一次传递多个SQL语句。在这里，我们的数据库模式由一个单独的`create`语句组成，所以`execute()`方法也可以做到这一点，但通常在创建数据库时，我们会创建多个表，然后将所有必要的SQL语句一起传递是非常方便的。
- en: When you look at the `create` statement, you may notice it features a `if not
    exists` clause. This is completely redundant in this example because a freshly
    opened in-memory database is always empty, but should our database reside on disk,
    it might contain all the tables we want already. Once we have created the table,
    we commit our changes to the database with the `commit()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看`create`语句时，你可能注意到它包含一个`if not exists`子句。在这个例子中，这是完全多余的，因为一个新打开的内存数据库总是空的，但如果我们数据库位于磁盘上，它可能已经包含我们想要的全部表。一旦我们创建了表，我们就使用`commit()`方法将我们的更改提交到数据库。
- en: The second highlighted line shows how we may create an insert statement that
    will insert new records in the task table. The values we will insert are placeholders,
    each represented by a question mark. In the next four lines, we execute this insert
    statement and supply a tuple of values that will be inserted in place of those
    placeholders.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行突出显示的行显示了如何创建一个插入语句，该语句将向任务表插入新记录。我们将插入的值是占位符，每个占位符都由一个问号表示。在接下来的四行中，我们执行这个插入语句，并提供一个包含将被插入占位符位置的值的元组。
- en: Time for action retrieving information with select statements
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择语句检索信息的操作时间
- en: In SQL, the `select` statement can be used to retrieve records from a database.
    How would you express a query to retrieve all tasks belonging to the user john?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，`select`语句可以用来从数据库中检索记录。你将如何表达一个查询来检索属于用户john的所有任务？
- en: 'Answer: `select * from task where user_id = ''john''`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：`select * from task where user_id = 'john'`
- en: We may implement this in Python as follows (only relevant lines shown, complete
    implementation is available as `taskdb2.py):`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此在Python中实现如下（仅显示相关行，完整的实现可在`taskdb2.py`中找到）：
- en: '**Chapter4/tasktdb2.py**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/任务tdb2.py**'
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What just happened?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first line in the code is normally placed just after establishing a connection
    to the database and ensures that any row returned from a `fetchone()` or `fetchall()`
    method are not plain tuples, but `sqlite3.Row` objects. These objects behave just
    like tuples, but their fields can be indexed by the name of the column they represent
    as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行通常放置在建立数据库连接之后，并确保从`fetchone()`或`fetchall()`方法返回的任何行都不是普通的元组，而是`sqlite3.Row`对象。这些对象的行为就像元组一样，但它们的字段可以通过它们所代表的列的名称进行索引。
- en: The query is executed by passing it to the `execute()` method of the cursor
    attribute (highlighted) and the results are then retrieved with the `fetchall()`
    method that will return a list of tuples, each tuple representing a matching record,
    its elements equal to the columns. We print some of those elements by indexing
    the tuples with the column names we are interested in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查询通过将其传递给游标的`execute()`方法（已突出显示）来执行，然后使用`fetchall()`方法检索结果，该方法将返回一个元组列表，每个元组代表一个匹配的记录，其元素等于列。我们通过索引我们感兴趣的列名来打印这些元素的一部分。
- en: 'When `taskdb2.py` is run, the output will show a list of task records, each
    with a date and a description:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`taskdb2.py`时，输出将显示一个任务记录列表，每个记录都有一个日期和描述：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pop quiz using variable selection criteria
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变量选择标准进行的小测验
- en: Most of the time we would like to pass the `user_id` to match as a variable.
    As we saw in the insert statements used in `taskdb1.py`, it is possible to construct
    a query using `?` as placeholders. This way, we could pass a variable containing
    a `user_id` to the execute method. How would you refactor the code to select all
    records for a user whose `user_id` is contained in the variable `username?`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们希望传递`user_id`作为变量进行匹配。正如我们在`taskdb1.py`中使用的插入语句中看到的，使用`?`作为占位符来构造查询是可能的。这样，我们可以将包含`user_id`的变量传递给执行方法。你将如何重构代码以选择包含在变量`username`中的`user_id`的所有记录？
- en: TaskDB interfacing with the database
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskDB与数据库接口
- en: Now we are ready to take on the real implementation of the database interface
    needed for the tasklist application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实现任务列表应用程序所需的数据库接口的实际代码了。
- en: The database interface layer will have to provide functionality to initialize
    a database and to provide thread-safe ways to create, retrieve, update, and delete
    tasks (collectively, often called **CRUD)** as well as list all tasks for a given
    user. The code to do this is contained in two classes, `Task` and `TaskDB` (both
    available in `tasklistdb.py). TaskDB` encapsulates the connection to the database
    and contains code to initialize the database as well as methods to retrieve a
    selection of tasks and to create new tasks. These tasks are implemented as instances
    of the `Task` class and a `Task` instance may be updated or deleted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库接口层必须提供初始化数据库的功能，并提供创建、检索、更新和删除任务（统称为 **CRUD**）的线程安全方式，以及为给定用户列出所有任务的功能。执行这些操作的代码包含在两个类中，`Task`
    和 `TaskDB`（两者都位于 `tasklistdb.py` 文件中）。`TaskDB` 封装了数据库连接，并包含初始化数据库的代码以及检索任务选择和创建新任务的方法。这些任务作为
    `Task` 类的实例实现，`Task` 实例可以被更新或删除。
- en: Time for action connecting to the database
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候连接到数据库了
- en: Let's first have a look at the `TaskDB` class. It consists of a constructor
    `__init__()` that takes the filename where the database will reside as a parameter.
    It calls a private method to initialize this database, and like the `LogonDB`
    class, creates some storage to hold connection objects for each thread (highlighted).
    It also defines a `connect()` method that should be called once for each thread
    and stores a thread-specific connection object. It also sets the `row_factory`
    attribute of the connection to `sqlite3.Row`. This causes the tuples returned
    by, for example, `fetchall()` to have their fields named after the columns they
    represent. This makes sense as `t['user_id']` is a lot more self documenting than
    `t[1]`, for example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `TaskDB` 类。它由一个构造函数 `__init__()` 组成，该构造函数接受数据库将驻留的文件名作为参数。它调用一个私有方法来初始化这个数据库，并且像
    `LogonDB` 类一样，为每个线程创建一些存储来保存连接对象（已突出显示）。它还定义了一个 `connect()` 方法，该方法应该为每个线程调用一次，并存储一个特定于线程的连接对象。它还将连接的
    `row_factory` 属性设置为 `sqlite3.Row`。这会导致例如 `fetchall()` 返回的元组具有它们所代表的列的名称。这对于 `t['user_id']`
    比如来说，比 `t[1]` 这样的方式更有自解释性。
- en: '**Chapter4/tasklistdb.py**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/tasklistdb.py**'
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What just happened?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The code for the `__init__()` method did not initialize any table in the database
    itself, but delegated this to the `_initdb()` method. This method starts with
    an underscore so it is private by convention (but by convention only). It is meant
    to be called just from `__init__()` and initializes the database, if necessary.
    It opens a connection to the database and executes a multiline statement (highlighted).
    Here we use `create if not exists` to create the `task` table, but only if it
    is not already present. So if we start the application for the first time, the
    database will be completely empty and this statement will create a new table named
    task. If we start the application again later, this statement will not do anything.
    Before closing the connection, we commit our changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法的代码并没有在数据库中初始化任何表，而是委托给 `_initdb()` 方法。这个方法以下划线开头，因此按照惯例是私有的（但仅按惯例）。它的目的是仅从
    `__init__()` 中调用，并在必要时初始化数据库。它打开到数据库的连接并执行一个多行语句（已突出显示）。在这里，我们使用 `create if not
    exists` 来创建 `task` 表，但仅当它尚未存在时。因此，如果我们第一次启动应用程序，数据库将完全为空，这个语句将创建一个名为 task 的新表。如果我们稍后再次启动应用程序，这个语句将不会做任何事情。在关闭连接之前，我们提交我们的更改。'
- en: '**Chapter4/tasklistdb.py**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/tasklistdb.py**'
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Time for action storing and retrieving information
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候存储和检索信息了
- en: The final part of the `TaskDB` class defines three methods, `create()` that
    will create a completely new `Task` instance, `retrieve()` that will fetch a task
    from the `task` table given a `task_id` and return it as a `Task` instance, and
    `list()` that will return a list of `task_ids` for a given user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskDB` 类的最后一部分定义了三个方法，`create()` 方法将创建一个全新的 `Task` 实例，`retrieve()` 方法将根据给定的
    `task_id` 从 `task` 表中检索一个任务，并将其作为 `Task` 实例返回，还有 `list()` 方法将返回给定用户的 `task_ids`
    列表。'
- en: We separated `retrieve()` and `list()` because retrieving an object complete
    with all its attributes might be quite expensive and not always needed. For example,
    if we were to select a list with thousands of tasks, we would likely display them
    as a page of about twenty tasks each. If we were to retrieve complete information
    for all those tasks, we might have to wait a while, so we might choose to instantiate
    only a first page-full of them and fetch the rest on an as-needed basis as the
    users step through the pages. We will encounter this pattern a few more times
    in this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `retrieve()` 和 `list()` 分离，因为检索一个包含所有属性的完整对象可能相当昂贵，并且并不总是需要的。例如，如果我们选择一个包含数千个任务的列表，我们可能会将它们显示为每页大约二十个任务的页面。如果我们需要检索所有这些任务的完整信息，我们可能需要等待一段时间，所以我们可能会选择仅实例化第一页的全部，并在用户翻页时按需获取其余部分。在这本书中，我们还会遇到这种模式几次。
- en: The `create()` method itself simply passes on all parameters to the `Task` constructor
    together with the thread local storage that holds the database connection. It
    returns the resulting `Task` instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 方法本身只是将所有参数传递给 `Task` 构造函数，以及包含数据库连接的线程局部存储。它返回生成的 `Task` 实例。'
- en: The `retrieve()` method takes the username and the ID of the task to retrieve.
    The username is taken as a sanity check, but not strictly necessary. If a record
    is found that matches both the `task_id` and the `username`, a `Task` instance
    is created and returned (highlighted). If no such record could be found, a `KeyError`
    exception is raised.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieve()` 方法接受用于检索的用户名和任务 ID。用户名作为合理性检查，但不是严格必要的。如果找到与 `task_id` 和 `username`
    都匹配的记录，则创建并返回一个 `Task` 实例（高亮显示）。如果没有找到这样的记录，则抛出 `KeyError` 异常。'
- en: The `list()` method returns a list of `task_ids` for a given user. It constructs
    this list from the list of tuples returned by taking the first (and only) item
    from each tuple (highlighted).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()` 方法返回给定用户的 `task_ids` 列表。它通过从每个元组的第一个（也是唯一一个）元素中获取来构造这个列表（高亮显示）。'
- en: '**Chapter4/tasklistdb.py**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/tasklistdb.py**'
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The constructor for `Task` takes a number of optional parameters together with
    a mandatory username and a `taskdb` parameter that point to the thread local data
    that holds the database connections. If the `duedate` parameter is not given,
    it assigns it the date of today (highlighted).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 构造函数接受一些可选参数，包括强制性的用户名和一个指向包含数据库连接的线程局部数据的 `taskdb` 参数。如果未提供 `duedate`
    参数，它将分配今天的日期（高亮显示）。'
- en: What just happened?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The construction of Task instances in the previous code deserves a closer look.
    Based on the value of the `id` parameter, the constructor can do two things.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中 `Task` 实例的构建值得仔细研究。根据 `id` 参数的值，构造函数可以执行两件事。
- en: If the `id` is known, this `Task` instance is constructed based on data just
    retrieved from a database query so there is nothing more to be done as all parameters
    are already stored as instance variables.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知 `id`，则此 `Task` 实例将基于从数据库查询中检索到的数据构建，因此不需要做更多的事情，因为所有参数都已作为实例变量存储。
- en: However, if `id` is not given (or `None)`, we apparently are creating a completely
    new `Task` that is not already present in the database. Therefore, we have to
    insert it into the task table using an `insert` statement (highlighted).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有提供 `id`（或 `None`），我们显然正在创建一个全新的 `Task` 实例，它尚未存在于数据库中。因此，我们必须使用 `insert`
    语句将其插入到任务表中（高亮显示）。
- en: We do not pass a new `task_id` as a value to this `insert` statement, but one
    will be created for us because we defined the `task_id` column as `integer primary
    key autoincrement`. This generated number is available from the cursor's `lastrowid`
    attribute and we store that for later reuse. All this is quite SQLite-specific,
    for more information, refer to the information box.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将新的 `task_id` 作为值传递给这个 `insert` 语句，但因为它将 `task_id` 列定义为 `integer primary
    key autoincrement`，所以会为我们创建一个。这个生成的数字可以通过游标的 `lastrowid` 属性获取，并且我们将它存储起来以供以后重用。所有这些都是
    SQLite 特有的，更多详细信息，请参考信息框。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only an `integer primary key` column can be defined as `autoincrement` and only
    an `integer primary key autoincrement` column will mapped to the internal `rowid`
    column (and that is not even a real column). All this is very useful, but also
    quite SQLite-specific. More information on this subject can be found on the SQLite
    FAQ at [http://www.sqlite.org/faq.html](http://www.sqlite.org/faq.html) and in
    the section on rowid in the SQL reference at [http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`integer primary key`列可以被定义为`autoincrement`，只有`integer primary key autoincrement`列会被映射到内部的`rowid`列（而且这甚至不是一个真正的列）。所有这些都是非常有用的，但也非常具有SQLite特性。关于这个主题的更多信息可以在SQLite
    FAQ中找到，网址为[http://www.sqlite.org/faq.html](http://www.sqlite.org/faq.html)，以及SQL参考中关于rowid的部分，网址为[http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid)。
- en: '**Chapter4/tasklistdb.py**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter4/tasklistdb.py**'
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Time for action updating and deleting information
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新和删除信息的时机
- en: Updating the record for a `Task` is all about constructing the correct `update`
    query. `update` will alter any records that match the conditions in the `where`
    clause. It will change only those columns mentioned in its `set` clause so we
    start by constructing this `set` clause (highlighted).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Task`记录的操作主要是构造正确的`update`查询。`update`会更改与`where`子句中条件匹配的任何记录。它只会更改其`set`子句中提到的列，所以我们首先构造这个`set`子句（已突出显示）。
- en: Joining a list of parameters and interpolating it into an SQL query might be
    a bit overdone but if we later want to add an extra attribute, this would be very
    simple (and our SQL query string now fits on a single line, making it a lot easier
    to read and typeset).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数列表连接并插入到SQL查询中可能有点过度，但如果我们稍后想添加一个额外的属性，这将非常简单（而且我们的SQL查询字符串现在可以放在一行中，这使得它更容易阅读和排版）。
- en: Once we have executed the insert, we check the number of rows affected. This
    value is available as the `rowcount` attribute of the `cursor` object and should
    be `1` as we used the unique `task_id` to select the records. If it isn't `1`,
    something strange has happened and we roll back the insert and raise an exception.
    If it went well, we commit our changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了插入操作，我们会检查受影响的行数。这个值可以通过`cursor`对象的`rowcount`属性获得，并且应该为`1`，因为我们使用了唯一的`task_id`来选择记录。如果不是`1`，那么就发生了奇怪的事情，我们会回滚插入操作并抛出异常。如果一切顺利，我们会提交我们的更改。
- en: '**Chapter4/tasklistdb.py**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter4/tasklistdb.py**'
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To delete a task with a given task ID, all we have to do is execute a `delete
    query` on the `task` table with an expression in the `where` clause that matches
    our `task_id`, just like we did for an update. We do check that our delete query
    affects a single record only (highlighted) and roll back otherwise. This shouldn't
    happen, but it is better to be safe than sorry.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除具有给定任务ID的任务，我们只需在`task`表上执行一个`delete query`，在`where`子句中有一个表达式与我们的`task_id`匹配，就像我们为更新所做的那样。我们确实检查我们的删除查询只影响一条记录（已突出显示），否则回滚。这种情况不应该发生，但宁可信其有，不可信其无。
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testing
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'Developing software without testing it is a little bit like driving a car with
    your eyes closed: if the road is straight you might get surprisingly far, but
    chances are you will crash within a few seconds. Testing, in other words, is good.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有测试的情况下开发软件有点像闭着眼睛开车：如果道路是直的，你可能会走得很远，但很可能会在几秒钟内撞车。换句话说，测试是好的。
- en: It does take time, however, to test an application thoroughly, so it makes sense
    to automate the testing process as much as possible. If tests can be executed
    easily, it encourages developers to run these tests often. This is desirable when
    the implementation changes. It can also act as a sanity check just before a new
    release. So although writing serious tests may sometimes take about as long as
    writing the code itself, this is a solid investment, as it might prevent many
    unwelcome surprises if the code is changed or the environment in which the code
    is deployed is altered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，彻底测试一个应用程序确实需要时间，因此尽可能自动化测试过程是有意义的。如果测试可以轻松执行，这将鼓励开发者经常运行这些测试。当实现发生变化时，这是非常理想的。它还可以在发布新版本之前作为一个理智的检查。所以尽管编写严肃的测试可能有时需要花费与编写代码一样多的时间，但这是一种稳健的投资，因为它可能防止许多不愉快的惊喜，如果代码被更改或代码部署的环境发生变化。
- en: There are many aspects of an application that you might like to test, but not
    all lend themselves to automatic testing, like user interaction (although tools
    like Selenium can get you quite far. More information on this tool is available
    at [http://seleniumhq.org/)](http://seleniumhq.org/)). However, other parts are
    quite simple to automate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想测试应用程序的许多方面，但并非所有都适合自动测试，例如用户交互（尽管像 Selenium 这样的工具可以让你走得很远。关于这个工具的更多信息可以在
    [http://seleniumhq.org/](http://seleniumhq.org/) 找到）)。然而，其他部分相当简单就可以自动化。
- en: Python comes with a `unittest` module that simplifies the task of repeatedly
    testing small functional units of code. The idea of unit testing is to isolate
    small chunks of code and define its expected behavior by asserting any number
    of expectations. If one of those assertions fails, the test fails. (There is much
    more to unit testing than can be fully covered in this book. Here we cover just
    the bare minimum to get a taste of the possibilities and we cover a few examples
    that are intended to give you enough information to understand the test suites
    supplied with the example code for this book. If you would like to read more on
    unit testing in Python, a good starting point would be *Python Testing* by *Daniel
    Arbuckle, Packt Publishing*, 978-1-847198-84-6).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置的 `unittest` 模块简化了重复测试代码小功能单元的任务。单元测试的想法是隔离小块代码，并通过断言任何数量的期望来定义其预期行为。如果这些断言中的任何一个失败，测试就会失败。（单元测试的内容远不止这本书能完全涵盖的。在这里，我们只介绍最基本的内容，以让你尝到一些可能性，并介绍一些旨在让你了解示例代码中提供的测试套件的例子。如果你想要了解更多关于
    Python 单元测试的信息，一个好的起点是 *Daniel Arbuckle 著，Packt Publishing 出版，978-1-847198-84-6*
    的 *Python Testing*）。
- en: Python's `unittest` module contains a number of classes and functions that enable
    us to write and run groups of tests and their associated assertions. For example,
    say we have a module called `factorial` that defines a function `fac()` to calculate
    a factorial.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `unittest` 模块包含许多类和函数，使我们能够编写和运行测试组及其相关的断言。例如，假设我们有一个名为 `factorial`
    的模块，它定义了一个名为 `fac()` 的函数来计算阶乘。
- en: A factorial of a number n is the product of all numbers from 1 to n inclusive.
    For example, `fac(4) = 4 * 3 * 2 * 1 = 24`. Zero is an exceptional case as the
    factorial of 0 = 1\. Factorials are only defined for integers >= 0, so we design
    our code to raise `ValueError` exceptions if the argument `n` is not an `int`
    or is negative (highlighted). The factorial itself is calculated recursively.
    If `n` is either zero or one, we return one, otherwise we return the factorial
    of `n` minus one times `n:`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数 n 的阶乘是从 1 到 n（包括 n）所有数的乘积。例如，`fac(4) = 4 * 3 * 2 * 1 = 24`。0 是一个特例，因为 0
    的阶乘等于 1。阶乘只对整数 >= 0 定义，因此我们设计我们的代码，如果参数 `n` 不是一个 `int` 或者是负数（突出显示），则抛出 `ValueError`
    异常。阶乘本身是通过递归计算的。如果 `n` 是零或一，我们返回一，否则我们返回 `n` 减一的阶乘乘以 `n`：
- en: '**Chapter4/factorial.py**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/factorial.py**'
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code is available as `factorial.py`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以 `factorial.py` 的形式提供。
- en: Time for action testing factorial.py
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 factorial.py 的行动时间
- en: 'The test suite to accompany `factorial.py` is called `test_factorial.py`. Run
    it and you should see output similar to this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随 `factorial.py` 的测试套件被称为 `test_factorial.py`。运行它，你应该看到类似以下的输出：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Three tests were executed and apparently everything went ok.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了三个测试，显然一切顺利。
- en: What just happened?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The code in `test_factorial.py` starts by importing both the module we want
    to test (factorial) and the `unittest` module. Then we define a single class named
    `Test` (highlighted) derived from `unittest.TestCase`. By deriving from this class,
    our class will be distinguishable as a test case to the test runner and will provide
    us with a number of **assertion** methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_factorial.py` 中的代码首先导入我们想要测试的模块（阶乘）和 `unittest` 模块。然后我们定义一个名为 `Test`（突出显示）的单个类，它继承自
    `unittest.TestCase`。通过继承这个类，我们的类将被测试运行器识别为测试用例，并将为我们提供一系列 **断言** 方法。'
- en: 'Our `Test` class may consist of any number of methods. The ones with names
    starting with `test_` will be recognized as tests by the test runner. Because
    the names of failing tests will be printed, it is useful to give these tests sensible
    names reflecting their purpose. Here we define three such methods: `test_number(),
    test_zero()`, and `test_illegal()`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Test` 类可以包含任何数量的方法。以 `test_` 开头名称的方法将被测试运行器识别为测试。因为失败测试的名称将被打印出来，所以给这些测试起一个反映其目的的合理名称是有用的。在这里，我们定义了三个这样的方法：`test_number()`、`test_zero()`
    和 `test_illegal()`。
- en: '**Chapter4/test_factorial.py**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/test_factorial.py**'
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`test_number()` tests a number of regular cases to see if our function returns
    something reasonable. In this case, we check three different numbers and use the
    `assertEquals()` method inherited from the `TestCase` class to check that the
    value calculated (passed as the second argument) equals the expected value (the
    first argument).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_number()`测试了多个常规案例，以查看我们的函数是否返回合理的结果。在这种情况下，我们检查了三个不同的数字，并使用从`TestCase`类继承的`assertEquals()`方法来检查计算出的值（作为第二个参数传递）是否等于预期的值（第一个参数）。'
- en: '`test_zero()` asserts that the special case of zero indeed returns 1\. It again
    uses the `assertEqual()` method to check whether the expected value (1) matches
    the value returned.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_zero()`断言零的特殊情况确实返回1。它再次使用`assertEqual()`方法来检查预期的值（1）是否与返回的值匹配。'
- en: '`test_illegal()` finally asserts that only positive arguments are accepted
    (or rather it asserts that negative values correctly raise a `ValueError` exception)
    and that arguments to `fac()` should be `int` or raise a `ValueError` as well.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_illegal()`最终断言只接受正数参数（或者更确切地说，它断言负值正确地引发了一个`ValueError`异常），并且`fac()`的参数应该是`int`或者也应该引发`ValueError`。'
- en: It utilizes the method `assertRaises()` provided by `TestCase. assertRaises()`
    will return an object that can be used as a context manager in a with statement.
    Effectively, it will catch any exception and check whether it is an expected one.
    If not, it will flag the test as failed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了`TestCase`提供的`assertRaises()`方法。`assertRaises()`将返回一个对象，该对象可以用作with语句中的上下文管理器。实际上，它将捕获任何异常并检查它是否是预期的异常。如果不是，它将标记测试为失败。
- en: 'These methods show a familiar pattern in unit testing: a fairly small number
    of tests check whether the unit behaves correctly in normal cases, while the bulk
    of the tests are often devoted to special cases (often referred to as edge cases).
    And, just as important, serious effort is spent on testing that illegal cases
    are correctly flagged as such.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在单元测试中显示出一种熟悉的模式：相当少量的测试检查单元在正常情况下是否表现正确，而大部分测试通常都致力于特殊案例（通常被称为边界案例）。同样重要的是，对非法案例被正确标记为非法的测试投入了大量的努力。
- en: The last thing we find in `test_factorial.py` is a call to `unittest.main()`,
    the test runner. It will look for any defined classes deriving from `TestCase`
    and run any method that starts with `test_`, tallying the results.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_factorial.py`的最后，我们发现了一个对测试运行器`unittest.main()`的调用。它将寻找任何从`TestCase`派生的定义好的类，并运行任何以`test_`开头的方法，统计结果。
- en: Now what have we gained?
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在我们得到了什么？
- en: If we would change, for example, the implementation of `fac()` to something
    that does not use recursion like the following code, we could rapidly check that
    it behaves as expected by running `test_factorial.py` again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变`fac()`的实现，例如，不使用递归的代码如下，我们可以通过再次运行`test_factorial.py`来快速检查它是否按预期工作。
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The special case handling remains the same, but the highlighted line shows that
    we now calculate the factorial with Python's `reduce()` function from the `functools`
    module. The `reduce()` function will apply a function to the first pair of items
    in a list and then again to the result of this and each remaining item. The product
    of all numbers in a list can be calculated by passing `reduce()` a function that
    will return the product of two arguments, in this case, our lambda function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊情况的处理保持不变，但突出显示的行显示我们现在使用`functools`模块中的`reduce()`函数来计算阶乘。`reduce()`函数将一个函数应用于列表中的第一对项目，然后再次应用于这个结果和每个剩余的项目。通过传递`reduce()`一个将返回两个参数乘积的函数，在这种情况下，我们的lambda函数，可以计算出列表中所有数字的乘积。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on the `reduce()` function can be found in the documentation of the `functools`
    module, Python''s powerful functional programming library: [http://docs.python.org/py3k/library/functools.html](http://docs.python.org/py3k/library/functools.html).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`reduce()`函数的信息可以在`functools`模块的文档中找到，这是Python强大的函数式编程库：[http://docs.python.org/py3k/library/functools.html](http://docs.python.org/py3k/library/functools.html)。
- en: Pop quiz spotting the error
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答：找出错误
- en: Can you anticipate any errors in the previous code? Which test method will fail?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能预测前一段代码中可能出现的任何错误吗？哪个测试方法会失败？
- en: '`test_number()`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_number()`'
- en: '`test_zero()`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_zero()`'
- en: '`test_illegal()`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_illegal()`'
- en: Time for action writing unit tests for tasklistdb.py
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为tasklistdb.py编写单元测试的时间
- en: 'Run `test_tasklistdb.py` (provided in the code distribution for this chapter).
    The output should be a list of test results:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`test_tasklistdb.py`（本章节代码分发中提供）。输出应该是一个测试结果列表：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What just happened?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Let us look at one of the classes defined in `test_tasklistdb.py, DBentityTest.
    DBentityTest` contains a number of methods starting with `test_`. These are the
    actual tests and they verify whether some common operations like retrieving or
    deleting tasks behave as expected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在`test_tasklistdb.py`中定义的一个类，`DBentityTest`。`DBentityTest`包含许多以`test_`开头的方法。这些是实际的测试，它们验证一些常见操作（如检索或删除任务）是否按预期执行。
- en: '**Chapter4/test_tasklistdb.py**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/test_tasklistdb.py**'
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All these `test_` methods depend on an initialized database containing at least
    one task and an open connection to this database. Instead of repeating this setup
    for each test, `DBentityTest` contains the special method `setUp()` (highlighted)
    that removes any test database lingering around from a previous test and then
    instantiates a `TestDB` object. This will initialize the database with proper
    table definitions. Then it connects to this new database and creates a single
    task object. All tests now can rely upon their initial environment to be the same.
    The corresponding `tearDown()` method is provided to close the database connection
    and remove the database file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`test_`方法都依赖于一个初始化的数据库，该数据库至少包含一个任务和一个对此数据库的开放连接。为了避免为每个测试重复此设置，`DBentityTest`包含一个特殊的方法`setUp()`（突出显示），它会删除任何之前测试中遗留的测试数据库，然后实例化一个`TestDB`对象。这将使用适当的表定义初始化数据库。然后它连接到这个新数据库并创建一个单独的任务对象。现在所有测试都可以依赖于它们的初始环境是相同的。提供了一个相应的`tearDown()`方法来关闭数据库连接并删除数据库文件。
- en: The file that is used to store the temporary database is created with the `mkstemp()`
    function from Python's `tempfile` module and stored in the global variable database.
    (mkstemp() returns the number of the file handle of the opened as well, which
    is immediately used to close the file as we are only interested in the name of
    the file.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储临时数据库的文件是用Python的`tempfile`模块中的`mkstemp()`函数创建的，并存储在全局变量`database`中。（`mkstemp()`还返回打开文件的文件句柄编号，我们立即使用它来关闭文件，因为我们只对文件名感兴趣。）
- en: 'The `test_list()` and `test_delete()` methods feature a new assertion: `assertListEqual()`.
    This assertion checks whether two lists have the same items (and in the same order,
    hence the `sorted()` calls). The `unittest` module contains a whole host of specialized
    assertions that can be applied for specific comparisons. Check Python''s online
    documentation for the `unittest` module for more details (http://docs.python.org/py3k/library/unittest.html).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_list()`和`test_delete()`方法引入了一个新的断言：`assertListEqual()`。这个断言检查两个列表是否有相同的项（并且顺序相同，因此有`sorted()`调用）。`unittest`模块包含一系列专门用于特定比较的断言。有关`unittest`模块的更多详细信息，请检查Python的在线文档（http://docs.python.org/py3k/library/unittest.html）。'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the modules we develop in this book come bundled with a suite of unit
    tests. We will not examine those tests in any detail, but it might be educational
    to check some of them. You should certainly use them if you experiment with the
    code as that is exactly what they are for.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们开发的大多数模块都附带了一套单元测试。我们不会对这些测试进行任何详细检查，但检查其中的一些可能是有教育意义的。如果你在实验代码时，你肯定应该使用它们，因为这正是它们的目的。
- en: Designing for AJAX
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为AJAX设计
- en: Using AJAX to retrieve data not only has the potential to make the tasklist
    application more responsive, but it will also make it simpler. This is achieved
    because the HTML will be simpler as there will be no need for the many`<form>`
    elements we created to accommodate the various delete and done buttons. Instead,
    we will simply act on click events bound to buttons and call small methods in
    our CherryPy application. All these functions have to do is perform the action
    and return ok, whereas in the previous version of our application, we would have
    to return a completely new page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AJAX检索数据不仅有可能使任务列表应用程序更响应，而且还会使其更简单。这是因为HTML将更简单，因为将不需要我们为适应各种删除和完成按钮而创建的许多`<form>`元素。相反，我们将简单地处理按钮的点击事件，并调用我们的CherryPy应用程序中的小方法。所有这些函数必须做的只是执行操作并返回ok，而在我们应用程序的先前版本中，我们必须返回一个全新的页面。
- en: 'In fact, apart from a number of`<script>` elements in the`<head>`, the core
    HTML in the body is rather short (the`<header>` element and the extra elements
    in the`<div>` element with a `taskheader` class are omitted for brevity):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，除了`<head>`中的几个`<script>`元素外，主体中的核心HTML相当简短（为了简洁起见，省略了`<header>`元素和具有`taskheader`类的`<div>`元素中的额外元素）：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The`<div>` element containing the input fields and a submit button takes up
    most of the space. It structures the elements that make up the line that allows
    the user to add new tasks. The`<div>` element with the ID `items` will hold a
    list of tasks and will be initialized and managed by the JavaScript code using
    AJAX calls.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 包含输入字段和提交按钮的 `<div>` 元素占据了大部分空间。它结构化了允许用户添加新任务的元素。具有 ID `items` 的 `<div>` 元素将保存任务列表，并将通过
    AJAX 调用初始化和管理。
- en: 'The JavaScript code in `tasklistajax.js` serves a number of goals:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklistajax.js` 中的 JavaScript 代码实现了多个目标：'
- en: Initializing the list of items
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化项目列表
- en: Styling and enhancing UI elements with interactive widgets (like a `datepicker)`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式小部件（如 `datepicker`）进行样式设计和增强 UI 元素
- en: Maintaining and refreshing the list of tasks based on button clicks
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据按钮点击维护和刷新任务列表
- en: Let's have a look at `tasklistajax.js`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `tasklistajax.js`。
- en: '**Chapter4/static/js/tasklistajax.js**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/static/js/tasklistajax.js**'
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line establishes the defaults for all AJAX calls that we will use.
    It makes sure that the browser will not cache any results.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置了所有我们将使用的 AJAX 调用的默认值。它确保浏览器不会缓存任何结果。
- en: Initializing the list of items once the page is loaded is done in the final
    highlighted line of code. It calls the `load()` method with a URL that will be
    handled by our application and will return a list of tasks. If the call to `load()`
    is successful, it will not only insert this data in the selected`<div>` element,
    but also call the function `itemmakeup()` passed to it as a second argument. That
    function, `itemmakeup()`, is defined in the beginning of the file. It will style
    any`<button>` element with a `done-button` or `del-button` class with a suitable
    icon. We do not add any event handlers to those buttons here, which is done elsewhere
    as we will see shortly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面加载后初始化项目列表是在代码的最后一行突出显示的。它使用一个将被我们的应用程序处理的 URL 调用 `load()` 方法，并将返回任务列表。如果
    `load()` 调用成功，它不仅会在选定的 `<div>` 元素中插入这些数据，还会调用作为第二个参数传递给它的函数 `itemmakeup()`。该函数
    `itemmakeup()` 在文件开头定义。它将为具有 `done-button` 或 `del-button` 类的任何 `<button>` 元素添加合适的图标。我们在这里不会添加任何事件处理器到这些按钮，这将在稍后完成。
- en: Next, we use the `sort` plugin to sort the items (highlighted), that is, we
    select any input field with the `duedate` class that are children of the`<div>`
    element with the ID `items` (we do not want to consider input fields that are
    part of the new item div for example).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `sort` 插件对项目（突出显示）进行排序，即选择任何具有 `duedate` 类的输入字段，这些字段是具有 ID `items`
    的 `<div>` 元素的子元素（我们不希望考虑例如新项目 `<div>` 中的输入字段）。
- en: 'The sort plugin is available as sort.js and is based on code by James Padolsey:
    [http://james.padolsey.com/javascript/sorting-elements-with-jquery/](http://james.padolsey.com/javascript/sorting-elements-with-jquery/).
    The plugin will sort any list of HTML elements and takes two arguments. The first
    argument is a comparison function that will return either 1 or -1 and the second
    argument is a function that when given an element will return the element that
    should actually be moved around. This allows us to compare the values of child
    elements while swapping the parent elements they are contained in.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 排序插件以 sort.js 的形式提供，基于詹姆斯·帕多塞（James Padolsey）的代码：[http://james.padolsey.com/javascript/sorting-elements-with-jquery/](http://james.padolsey.com/javascript/sorting-elements-with-jquery/)。该插件可以排序任何HTML元素列表，并接受两个参数。第一个参数是一个比较函数，它将返回1或-1，第二个参数是一个函数，当给定一个元素时，将返回应该实际移动的元素。这允许我们在交换包含它们的父元素的同时比较子元素的值。
- en: For example, here we compare the due dates. That is, the content of the selected`<input>`
    elements, as retrieved by their `val()` method, but we sort not the actual input
    fields but their parents, the`<div>` elements containing all elements that make
    up a task.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我们比较的是截止日期。也就是说，通过它们的 `val()` 方法检索的所选 `<input>` 元素的内容，但我们不是对实际的输入字段进行排序，而是对包含构成任务的全部元素的
    `<div>` 元素进行排序。
- en: Finally, `itemmakeup()` makes sure any button marked with a `done` class is
    disabled as is any input element with that class to prevent completed tasks from
    being altered and changes any input element with an `editable-date` class into
    a datapicker widget to allow the user to choose a completion date before marking
    a task as done.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`itemmakeup()` 确保带有 `done` 类的任何按钮都被禁用，以及具有该类的任何输入元素，以防止修改已完成任务，并将具有 `editable-date`
    类的任何输入元素转换为数据选择器小部件，以便用户在标记任务为已完成之前选择完成日期。
- en: Click handlers
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击处理器
- en: Besides styling elements, the `$(document).ready()` function adds click handlers
    to the add, done, and delete buttons (highlighted).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了样式化元素外，`$(document).ready()`函数还为添加、完成和删除按钮添加了点击处理器（突出显示）。
- en: Only one add button is created when the page is created, so we can add a click
    handler with the `click()` method. However, new done and delete buttons may appear
    each time the list of items is refreshed. To ensure that freshly appearing buttons
    that match the same selection criteria receive the same event handler as the ones
    present now, we call the `live()` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面创建时，只创建一个添加按钮，因此我们可以使用`click()`方法添加点击处理器。然而，每次刷新项目列表时，新的完成和删除按钮可能会出现。为了确保新出现的与现有按钮具有相同选择标准的按钮接收相同的事件处理器，我们调用`live()`方法。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jQuery's `live()` method will make sure any event handler is attached to any
    element that matches some criterion, now or in the future. More on jQuery's event
    methods can be found at [http://api.jquery.com/category/events/](http://api.jquery.com/category/events/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`live()`方法将确保任何事件处理器都附加到任何现在或将来符合某些标准的元素上。有关jQuery事件方法的更多信息，请参阅[http://api.jquery.com/category/events/](http://api.jquery.com/category/events/)。
- en: Apart from the way we bind an event handler to a button, the actions associated
    with a click are similar for all buttons. We retrieve the data we want to pass
    to the server by selecting the appropriate input elements from among the button's
    siblings with the `siblings()` method. As each task is represented by its own`<div>`
    element in the list and the`<button>` and`<input>` elements are all children of
    that`<div>` element, so selecting sibling input elements only ensures that we
    refer to elements of a single task only.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将事件处理器绑定到按钮的方式外，所有按钮的点击操作都是相似的。我们通过从按钮的兄弟元素中选择适当的输入元素，使用`siblings()`方法检索要传递给服务器的数据。由于每个任务都由列表中的自己的`<div>`元素表示，而`<button>`和`<input>`元素都是该`<div>`元素的子元素，因此选择兄弟输入元素仅确保我们引用的是单个任务的元素。
- en: 'To get a better understanding of what we are selecting with the `siblings()`
    method, take a look at some of the (simplified) HTML that is generated for the
    list of items:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解我们使用`siblings()`方法选择的元素，请查看为项目列表生成的某些（简化后的）HTML代码：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So each`<div>` that represents a task contains a number of`<input>` elements
    and some`<button>` elements. The siblings of any`<button>` element are the elements
    within the same`<div>` (without the button itself).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代表任务的每个`<div>`都包含多个`<input>`元素和一些`<button>`元素。任何`<button>`元素的兄弟元素是同一`<div>`内的元素（不包括按钮本身）。
- en: When we have gathered the relevant data from the input elements, this data is
    then passed to a `get()` call. The `get()` function is another AJAX shortcut that
    will make an HTTP GET request to the URL given as its first argument (a different
    URL for each button type). The data passed to the `get()` function is appended
    to the GET request as parameters. Upon success, the function passed as the third
    argument to `get()` is called. This is the same `itemmakeup()` function that refreshes
    the list of items that was used when the page was first loaded.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从输入元素收集到相关数据后，这些数据随后被传递给一个`get()`调用。`get()`函数是另一个AJAX快捷方式，它将向其第一个参数（每个按钮类型都不同）指定的URL发出HTTP
    GET请求。传递给`get()`函数的数据作为参数附加到GET请求中。成功后，将调用`get()`的第三个参数传递的函数。这是在页面首次加载时用于刷新项目列表的相同`itemmakeup()`函数。
- en: The application
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: With the JavaScript to implement the interactivity and the means to access the
    database in place, we still have to define a class that can act as a CherryPy
    application. It is available as `taskapp.py` and here we show the relevant bits
    only (Its `index()` method is omitted because it simply delivers the HTML shown
    earlier).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现交互性和访问数据库的手段就绪之后，我们仍然需要定义一个可以作为CherryPy应用程序的类。它作为`taskapp.py`提供，这里我们只展示相关的部分（省略了`index()`方法，因为它只是简单地传递了之前显示的HTML）。
- en: '**Chapter4/taskapp.py**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/taskapp.py**'
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The constructor for `TaskApp` stores a reference to a `LogonDB` instance in
    order to be able to call its `checkauth()` method in exposed methods to authenticate
    a user. It also stores the `logoffpath`, a URL to a page that will end the user's
    session. The `dbpath` argument is the filename of the file that holds the tasklist
    database. It is used to create an instance of `TaskDB`, used in subsequent methods
    to access the data (highlighted).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskApp`的构造函数存储对`LogonDB`实例的引用，以便在公开的方法中调用其`checkauth()`方法以验证用户。它还存储`logoffpath`，这是一个指向将结束用户会话的页面的URL。`dbpath`参数是包含任务列表数据库的文件名。它用于创建一个`TaskDB`实例，在后续方法中使用以访问数据（突出显示）。'
- en: The `connect()` method should be called for each new CherryPy thread and simply
    calls the corresponding method on the `TaskDB` instance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个新的CherryPy线程，应该调用`connect()`方法，它简单地调用`TaskDB`实例上的相应方法。
- en: 'To service the AJAX calls of the application, `TaskApp` exposes four short
    methods: `list()` to generate a list of tasks, `add()` to add a new task, and
    `done()` and `delete()` to mark a task as done or to remove a task respectively.
    All take a dummy argument named `_` (a single underscore) that is ignored. It
    is added by the AJAX call in the browser to prevent caching of the results.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理应用程序的AJAX调用，`TaskApp`公开了四个简短的方法：`list()`用于生成任务列表，`add()`用于添加新任务，以及`done()`和`delete()`分别用于标记任务为完成或删除任务。所有这些方法都接受一个名为`_`（单个下划线）的占位符参数，该参数被忽略。它是通过浏览器中的AJAX调用添加的，以防止结果缓存。
- en: '`list()` is the longer one and starts out with authenticating the user making
    the request (highlighted). If the user is logged in, this will yield the username.
    This username is then passed as an argument to the `taskdb.list()` method to retrieve
    a list of task IDs belonging to this user.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`是最长的一个，它从验证发出请求的用户开始（突出显示）。如果用户已登录，这将产生用户名。然后，将此用户名作为参数传递给`taskdb.list()`方法，以检索属于此用户的所有任务ID。'
- en: With each ID, a `Task` instance is created that holds all information for that
    task (highlighted). This information is used to construct the HTML that makes
    up the task as visualized on screen. Finally, all HTML of the individual tasks
    is joined and returned to the browser.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ID都会创建一个`Task`实例，该实例包含该任务的所有信息（突出显示）。这些信息用于构建构成屏幕上可视化的任务的HTML。最后，所有单个任务的HTML都被连接起来并返回给浏览器。
- en: '**Chapter4/taskapp.py**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/taskapp.py**'
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The other methods are quite similar to each other. `add()` takes `description`
    and `duedate` as arguments and passes them together with the username it got after
    authentication of the user to the `create()` method of the `TaskDB` instance.
    It returns ''ok'' to indicate success. (Note that an empty string would do just
    as well: it''s the return code that matters, but this makes it more obvious to
    anyone reading the code).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法彼此之间非常相似。`add()`方法接受`description`和`duedate`作为参数，并将它们与用户认证后获得的用户名一起传递给`TaskDB`实例的`create()`方法。它返回`ok`以表示成功。（注意，空字符串也可以做到这一点：重要的是返回代码，但这使得代码阅读者更容易理解）。
- en: The `delete()` method (highlighted) has one relevant argument, `id`. This ID
    is used together with the username to retrieve a `Task` instance. This instance's
    `delete()` method is then called to remove this task from the database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法（突出显示）有一个相关的参数，`id`。此ID与用户名一起使用，以检索一个`Task`实例。然后调用此实例的`delete()`方法，从数据库中删除此任务。'
- en: The `done()` method (highlighted) also takes an `id` argument together with
    `completed`. The latter either holds a date or is empty, in which case it is set
    to today's date. A `Task` instance is retrieved in the same manner as for the
    `delete()` method, but now its `completed` attribute is set with the contents
    of the argument of the same name and its `update()` method is called to synchronize
    this update with the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`方法（突出显示）也接受一个`id`参数和`completed`参数。后者要么包含一个日期，要么为空，在这种情况下，它被设置为今天的日期。以与`delete()`方法相同的方式检索`Task`实例，但现在将其`completed`属性设置为同名参数的内容，并调用其`update()`方法以同步此更新与数据库。'
- en: '**Chapter4/taskapp.py**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/taskapp.py**'
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Time for action putting it all together
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起的时间
- en: 'Now that we have all the requisite components in place (that is, `tasklistdb.py,
    taskapp.py`, and `tasklistajax.js)`, it is straightforward to put them together.
    If you run the code below (available as `tasklist.py)` and point your browser
    at [http://localhost:8080/](http://localhost:8080/), you will get a familiar looking
    login screen and after entering some credentials (username admin and password
    admin are configured by default) the resulting screen will look almost the same
    as the application we developed in the previous chapter, as illustrated in the
    following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有必要的组件（即`tasklistdb.py`、`taskapp.py`和`tasklistajax.js`），将它们组合起来就很简单了。如果你运行下面的代码（作为`tasklist.py`提供）并将你的浏览器指向[http://localhost:8080/](http://localhost:8080/)，你将看到一个熟悉的登录界面。在输入一些凭据（默认配置的用户名是admin，密码也是admin）后，结果界面将几乎与我们在上一章中开发的应用程序相同，如下面的截图所示：
- en: '![Time for action putting it all together](img/3746_4_3.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容整合在一起的时间](img/3746_4_3.jpg)'
- en: What just happened?
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'For the CherryPy application, we need a root class that can act as the root
    of the tree of pages we serve the user. Again, we call this class simply `Root`
    and assign an instance of our `TaskApp` application to the task variable and an
    instance of the `LogonDB` application to the logon variable (highlighted in the
    code below). Together with the `index()` method, this will create a tree of pages
    looking like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CherryPy应用程序，我们需要一个根类，它可以作为我们为用户服务的页面树的根。再次强调，我们把这个类简单地命名为`Root`，并将我们的`TaskApp`应用程序的一个实例分配给`task`变量，将`LogonDB`应用程序的一个实例分配给`logon`变量（在下面的代码中突出显示）。与`index()`方法一起，这将创建一个看起来像这样的页面树：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the user starts on the top-level page or on the logon page, he/she will be
    redirected to the `/task` page after successful authentication. Below the `/task`
    page are, of course, the other pages that implement the server side of the AJAX
    communications like, for example, `/task/add`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户从顶级页面或登录页面开始，在成功认证后，他/她将被重定向到`/task`页面。在`/task`页面下方，当然还有其他实现AJAX通信服务器端的页面，例如`/task/add`。
- en: '**Chapter4/tasklist.py**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4章/tasklist.py**'
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before the CherryPy application is started in the usual way by calling the `quickstart()`
    function, we first initialize the authentication database and create a function
    `connect()` (highlighted). This is the function we will register with CherryPy
    to execute each time CherryPy starts a new thread. The function will create a
    connection to the SQLite databases containing the authentication and tasklist
    data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以通常的方式通过调用`quickstart()`函数启动CherryPy应用程序之前，我们首先初始化认证数据库并创建一个名为`connect()`（突出显示）的函数。这是我们将在CherryPy启动每个新线程时注册的函数。该函数将创建连接到包含认证和任务列表数据的SQLite数据库。
- en: Have a go hero refreshing the itemlist on a regular basis
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试定期刷新项目列表
- en: If you were to access your tasklist from home and keep the application open
    and later access it from, for example, your work, any changes made to the list
    from work wouldn't be visible at home unless you refreshed the page manually.
    This is because there is nothing implemented to refresh the list of tasks regularly;
    it is refreshed only after some action is initiated by clicking a button.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从家里访问任务列表并保持应用程序打开，然后从例如工作地点访问它，除非你手动刷新页面，否则你在工作地点对列表所做的任何更改都不会在家庭中可见。这是因为没有实现定期刷新任务列表的功能；它只在点击按钮发起某些操作后才会刷新。
- en: 'How could you implement a regular refresh? Hint: in the first AJAX example,
    we encountered JavaScript''s `setInterval()` method. Can you devise a way to let
    it replace the contents of the`<div>` element containing the list of tasks using
    the `load()` method?'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你该如何实现定期刷新？提示：在第一个AJAX示例中，我们遇到了JavaScript的`setInterval()`方法。你能想出一个方法，使用`load()`方法让它替换包含任务列表的`<div>`元素的
    内容吗？
- en: An example implementation is available in `tasklistajax2.js`. You can either
    rename it to `tasklistajax.js` and run `tasklist.py` or run `tasklist2.py`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklistajax2.js`中提供了一个示例实现。你可以将其重命名为`tasklistajax.js`并运行`tasklist.py`，或者运行`tasklist2.py`。'
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about using a database to store persistent
    data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于使用数据库来存储持久数据的知识。
- en: 'Specifically, we covered:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: The benefits of using a database engine
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库引擎的好处
- en: How to use SQLite, a database engine distributed with Python
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python附带分发的SQLite数据库引擎
- en: How to implement a password database
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现密码数据库
- en: How to design and develop a database-driven tasklist application
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计和开发一个数据库驱动的任务列表应用程序
- en: How to implement unit tests with Python's `unittest` module
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Python 的 `unittest` 模块实现单元测试
- en: How to make a web application more responsive using AJAX calls
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 AJAX 调用来使 Web 应用程序更具响应性
- en: We also discussed how to make a web application respond to mouse clicks and
    request new data from the server without using`<form>` elements but using jQuery's
    `click()` and `live()` methods.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何使 Web 应用程序能够响应用户的鼠标点击，并从服务器请求新数据，而不使用 `<form>` 元素，而是使用 jQuery 的 `click()`
    和 `live()` 方法。
- en: Now that we've made the first step in using a database, we're ready to create
    more elaborate databases designs, consisting of more than a single table, and
    look at the methods to define relations between these tables which is the topic
    of the next chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经迈出了使用数据库的第一步，我们准备创建更复杂的数据库设计，包括多个表，并探讨定义这些表之间关系的方法，这是下一章的主题。
