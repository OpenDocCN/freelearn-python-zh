- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Extending the TC1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展TC1
- en: In this chapter, you will learn how to expand the functionality of the TC1 simulator
    that we designed in [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091). We also look
    at some of the elements of the design of a simulator, including input/output techniques
    and data validation, and describe how the simulator can display the state of a
    processor as it executes instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何扩展我们在[*第6章*](B19624_06.xhtml#_idTextAnchor091)中设计的TC1模拟器的功能。我们还探讨了一些模拟器设计元素，包括输入/输出技术和数据验证，并描述了模拟器如何显示处理器在执行指令时的状态。
- en: TC1 is a compromise. Initially, it was designed to support teaching the basics
    of computer architecture. It is an aid to understanding instruction encoding,
    instruction format trade-offs, the execution of an instruction, addressing modes,
    and the ability to design and implement an instruction set.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TC1是一个折衷方案。最初，它被设计用来支持教授计算机架构的基础知识。它是理解指令编码、指令格式权衡、指令执行、寻址模式和设计并实现指令集的辅助工具。
- en: 'Here, we look at ways of expanding TC1 by, for example, discussing how new
    instructions can be added. Finally, we deal with a topic that we have omitted
    so far: how to create a computer architecture with variable-length instructions.
    That is, individual instructions can be an integer multiple of the basic word
    length.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们探讨通过讨论如何添加新指令等方式来扩展TC1的方法。最后，我们处理一个迄今为止我们尚未涉及的话题：如何创建具有可变长度指令的计算机架构。也就是说，单个指令可以是基本字长的一个整数倍。
- en: The TC1 CPU simulator executes instructions one by one and prints the contents
    of the registers, program counter, and status flags after each instruction is
    executed. You can use this information to debug assembly-level programs. Often,
    when you look at the data, you find that the results are not what was expected;
    for example, you might want to execute a loop 9 times but execute it 10 times
    because you made an error in testing for the end of the loop.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TC1 CPU 模拟器逐条执行指令，并在每条指令执行后打印寄存器、程序计数器和状态标志的内容。你可以使用这些信息来调试汇编级程序。通常，当你查看数据时，你会发现结果并不是你所预期的；例如，你可能想执行循环9次，但执行了10次，因为你测试循环结束时的错误。
- en: We have three issues to deal with. The first is displaying the data. How do
    we display the data and how do we format it? Should the contents of a register
    be displayed as a decimal value, a binary string of 1s and 0s, or as hexadecimal
    characters?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个问题要处理。第一个是显示数据。我们如何显示数据以及如何格式化它？寄存器的内容应该显示为十进制值、由1和0组成的二进制字符串，还是以十六进制字符的形式显示？
- en: Another design issue is whether to store historic data. That is, do we store
    the registers and flags after each instruction has been executed in an array so
    that we can look at values in previous operations?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个设计问题是是否存储历史数据。也就是说，我们在每条指令执行后在数组中存储寄存器和标志，以便我们可以查看先前操作中的值？
- en: Finally, how do we proceed? The TC1 simulator executes an instruction every
    time the *Enter* key is pressed. This provides a great way of stepping through
    a program but becomes infeasible when a loop requires 1,000 instructions to be
    executed before you get to the part of the program of interest. We will demonstrate
    how you can leave the single-step mode, execute a batch of instructions, and return
    to the single-step mode.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们如何进行？TC1模拟器每次按下*Enter*键时都会执行一条指令。这为逐步执行程序提供了一个很好的方法，但当循环需要执行1000条指令才能到达你感兴趣的程序部分时，这变得不可行。我们将演示如何退出单步模式，执行一批指令，然后返回单步模式。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的程序：[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07)。
- en: Another look at python’s input and output
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视Python的输入和输出
- en: Here, we go into a little more detail about data input and output mechanisms,
    as these topics are so important in the design of a simulator because formatting
    data is all-important to the interpretation of the data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更详细地讨论数据输入和输出机制，因为这些主题在模拟器设计中非常重要，因为数据的格式化对于数据的解释至关重要。
- en: Let’s have another look at input in Python. Inputting data from the keyboard
    is very easy. To input text, you write `x = input()` and that’s it. When this
    statement is encountered, Python waits for your input. You enter the text and
    terminate it with a return (*Enter* key). If you just enter a return without text,
    the value of `x` will be a null string – that is, ' '. The data you input is stored
    in text form.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看 Python 中的输入。从键盘输入数据非常简单。要输入文本，你写下 `x = input()`，就这样。当遇到这个语句时，Python
    会等待你的输入。你输入文本并使用回车（*Enter* 键）结束。如果你只是输入一个回车而没有文本，`x` 的值将是一个空字符串——即 ' '。你输入的数据以文本形式存储。
- en: 'Python lets you display a prompt before receiving the input; for example, you
    can write the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你在接收输入之前显示一个提示；例如，你可以写下以下内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because the input is in character form, you must convert numeric values into
    integer form before using them. It’s easy to perform conversions into decimal,
    binary, or hexadecimal, as the following examples show. You just add the number
    base as a second parameter to the `int()` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输入是字符形式，所以在使用之前必须将数值转换为整数形式。像以下示例所示，转换为十进制、二进制或十六进制很容易。你只需将数字基数作为 `int()`
    函数的第二个参数添加即可：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s consider a more sophisticated example. We’ll input an instruction such
    as `ADD R3,R7`,`$12FA` and extract the three integers `3`, `7`, and `0x12FA`.
    In this example, a $ prefix indicates a hexadecimal value (a convention used by
    Motorola).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更复杂的例子。我们将输入一个指令，例如 `ADD R3,R7`,`$12FA` 并提取三个整数 `3`, `7`, 和 `0x12FA`。在这个例子中，一个
    $ 前缀表示十六进制值（Motorola 使用的约定）。
- en: 'The following code performs this operation. The input uses a `replace` function
    to convert all commas into spaces. We combine the replace operation with the input
    operation to create compact code. The input is followed by a `split` function
    to convert the string into tokens:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行此操作。输入使用 `replace` 函数将所有逗号转换为空格。我们将替换操作与输入操作结合起来以创建紧凑的代码。输入后面跟着一个 `split`
    函数，将字符串转换为标记：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, we examine each of the four tokens in turn and extract the parameter
    as an integer (`t1`, `t2`, `t3`, and `t4`). Consider `t4`. The `p[3]` expression
    extracts the `"$12FA"` string. The second index, `[1:]`, extracts all characters
    after the first one to give `"12FA"`. This is still a character string. The final
    operation, int`(p[3]`[1:]`,`16`)`, converts the parameter string in hexadecimal
    form into the integer `4858`. The output produced by a second example, `ADD r3,r7,$1102`,
    was `ADD 3` `7 4354`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们依次检查四个标记，并将参数作为整数提取出来（`t1`，`t2`，`t3` 和 `t4`）。考虑 `t4`。`p[3]` 表达式提取了 `"$12FA"`
    字符串。第二个索引 `[1:]` 提取第一个字符之后的所有字符，给出 `"12FA"`。这仍然是一个字符串。最后的操作 `int(p[3][1:],'16')`
    将十六进制形式的参数字符串转换为整数 `4858`。第二个示例 `ADD r3,r7,$1102` 的输出是 `ADD 3 7 4354`。
- en: 'As we’ve already seen, Python lets you put several equates on a line – for
    example, `a,b,c = p,q,r`. This results in the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，Python 允许你在一行上放置多个等式——例如，`a,b,c = p,q,r`。这会导致以下结果：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shorthand is useful when dealing with simple equates (usually during an
    initialization process). Some programmers prefer not to use this technique as
    it can reduce program readability. Let’s test the preceding fragment of code.
    We’ve added some `print` statements between the operations so that we can follow
    what’s going on as the code is executed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写在与简单等式（通常在初始化过程中）打交道时很有用。一些程序员不喜欢使用这种技术，因为它可能会降低程序的可读性。让我们测试前面代码片段。我们在操作之间添加了一些
    `print` 语句，这样我们就可以在代码执行时跟踪正在发生的事情：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is next. Note that when we print `t1` to `t4`, the numeric value
    of the hexadecimal operand is given in its decimal form:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是输出。注意，当我们打印 `t1` 到 `t4` 时，十六进制操作数的数值以十进制形式给出：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next section looks at how we format data such as numbers so that they can
    be made much easier for the reader to understand; for example, sometimes you might
    wish to represent the decimal 42 as `101010` and sometimes as `00101010` or `002A`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨如何格式化数据，例如数字，以便使读者更容易理解；例如，有时你可能希望将十进制的 42 表示为 `101010`，有时作为 `00101010`
    或 `002A`。
- en: Displaying data
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示数据
- en: We now look more deeply at the ways in which data can be displayed in Python.
    When you are observing the execution of a program, you want to see what has changed
    after each instruction has been executed. A computer’s state is determined by
    the contents of its registers and memory, the program counter, and its status
    bits, plus its memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更深入地探讨在Python中显示数据的方式。当你观察程序执行时，你希望看到在每条指令执行后发生了什么变化。计算机的状态由其寄存器和内存的内容、程序计数器和其状态位以及其内存决定。
- en: How do we display data? Since data can represent anything you want it to, the
    data in a register has no intrinsic meaning. By convention, CPU simulators represent
    data in hexadecimal form. This is partially because each 16-bit register holds
    4 hexadecimal characters and that provides a rather convenient way for humans
    to handle data (try remembering 16-bit strings of 1s and 0s). Some simulators
    permit binary, hex, or decimal displays, and others allow data to be displayed
    as characters (i.e., the data is assumed to be ASCII-encoded).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何显示数据？由于数据可以代表任何你想要它代表的东西，寄存器中的数据没有固有的意义。按照惯例，CPU模拟器以十六进制形式表示数据。这部分的理由是每个16位寄存器包含4个十六进制字符，这为人类处理数据提供了一个相当方便的方式（尝试记住16位的1和0的字符串）。一些模拟器允许以二进制、十六进制或十进制显示，而其他模拟器允许将数据以字符形式显示（即，数据假定是ASCII编码的）。
- en: As well as choosing the base in which we display numbers, we must choose the
    formatting in order to make it easy to read (e.g., aligning groups of characters).
    Like all high-level computer languages, Python provides ways of formatting printed
    data. And like formatting in most other languages, I am tempted to describe Python’s
    formatting as a bit inelegant.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择我们显示数字的基数外，我们还必须选择格式以便于阅读（例如，对齐字符组）。像所有高级计算机语言一样，Python提供了格式化打印数据的方法。而且，就像大多数其他语言的格式化一样，我倾向于将Python的格式化描述为有点不够优雅。
- en: We do not have the space to do justice to Python’s formatting here. We simply
    provide some examples and enough information for you to modify them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有足够的空间来公正地介绍Python的格式化。我们只是提供了一些示例和足够的信息，以便你可以修改它们。
- en: 'One thing we need to print in a simulator is the instruction. That could not
    be simpler because it’s a string. So, we can write the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中我们需要打印的是指令。这很简单，因为它是一个字符串。所以，我们可以写出以下代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks up the string item (instruction) at the `pcOld` address and prints
    it. Since `pc` is modified during an instruction cycle, we print the old value
    at the start of the current cycle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`pcOld`地址查找字符串项（指令）并打印它。由于`pc`在指令周期中会被修改，所以我们打印当前周期开始时的旧值。
- en: 'But each instruction is going to be of a different length (depending on the
    number of operands), and that means the next item printed on the same line will
    not be vertically aligned. We often need to print the instruction within a predefined
    frame. We can do this with the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但每个指令的长度都不同（取决于操作数的数量），这意味着在同一行上打印的下一个项目将不会垂直对齐。我们经常需要在预定义的框架内打印指令。我们可以用以下方法做到这一点：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are using the`.format()`method. The `"{:<23}"` expression controls the format.
    The integer `23` is the width of the text in characters. The < symbol indicates
    that the string is left-justified. If we’d wanted it right-justified, we would
    have used >. The value following `format()` is the string to be printed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.format()`方法。`"{:<23}"`表达式控制格式。整数`23`是文本的字符宽度。<符号表示字符串是左对齐的。如果我们想让它右对齐，我们会使用>。`format()`后面的值是要打印的字符串。
- en: 'Suppose we want to display the eight registers on the same line, each as a
    six-character hexadecimal value. First, consider the following Python code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在同一行上显示八个寄存器，每个寄存器作为一个六字符的十六进制值。首先，考虑以下Python代码：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When executed, this code prints the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，它会打印以下内容：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We set up a variable, `z`, for the `0x4ace` hexadecimal value and use `print("%06x"
    %z)` to display it as hex characters. The printed value is `004ace` because two
    leading zeros have been inserted. The formatting mechanism is `"%06x" %z`. The
    first component, `"`%`06x"`, specifies the format of the six-digit hex value that
    follows. It’s the first % that indicates the formatting. %`z` indicates the value
    to be printed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`0x4ace`十六进制值设置了一个变量`z`，并使用`print("%06x" %z)`来以十六进制字符显示它。打印的值是`004ace`，因为插入了两个前导零。格式化机制是`"%06x"
    %z`。第一个组件`"`%`06x"`指定了后续六位十六进制值的格式。第一个%表示格式化。`%z`表示要打印的值。
- en: The escape character
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: Python’s `print` mechanism is easy to use; for example, `print('Answer =',a)`
    displays anything in quotes as a literal, and the value of any variables that
    appear in the `print` statement. You can have as many quoted items and variables
    as you want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`print`机制易于使用；例如，`print('Answer =',a)`将引号内的任何内容显示为字面量，并在`print`语句中出现的任何变量的值。你可以有任意多的引号项和变量。
- en: 'The `print` statement also allows formatting by using an *escape character*
    that gives the following character a special meaning. In Python, the escape character
    is `''` `\''`. If the escape is followed by `''n''`, it is equivalent to a new
    line; if the escape is followed by `''t''`, it is equivalent to a tab. Consider
    the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`语句还允许使用转义字符进行格式化，该转义字符给以下字符赋予特殊含义。在Python中，转义字符是`\''`。如果转义符后面跟着`''n''`，它相当于换行；如果转义符后面跟着`''t''`，它相当于制表符。考虑以下：'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output from this code is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note how this has been printed on two lines due to `''\n''` and the two values
    tabbed by `''\t''`. You can control the size of the tab, as the following example
    shows. The `expandtabs()` method sets the tab width (number of spaces) to the
    parameter provided. In this case, we have embedded the tab into a string and set
    the tab width to `6`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这是如何因为`'\n'`和两个由`'\t'`制表符分隔的值而打印在两行的。你可以控制制表符的大小，如下例所示。`expandtabs()`方法将制表符宽度（空格数）设置为提供的参数。在这种情况下，我们将制表符嵌入到字符串中，并将制表符宽度设置为`6`：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some of the other escape sequences are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些转义序列如下：
- en: '`\’`     Single quote'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\’`     单引号'
- en: '`\\`     Backslash'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`     反斜杠'
- en: '`\r`     Enter (return)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`     回车（返回）'
- en: '`\b`     Backspace'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`     退格'
- en: '`\f`     Form feed (move to the same spot on the line below)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\f`     换页（移动到下一行的相同位置）'
- en: '`\xhh`   Hexadecimal character value (e.g., `\x41` would print `A` because
    `0x41` is the ASCII value for A)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\xhh`   十六进制字符值（例如，`\x41`会打印`A`，因为`0x41`是字母A的ASCII值）'
- en: Escaping the escape
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义转义
- en: 'There are occasions when you wish to escape the escape character and use the
    backslash as a printable character. In that case, you precede the string to be
    printed with either `r` or `R`. Note the `r` letter goes outside the string quotation
    marks, as in this example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望转义转义字符，并使用反斜杠作为可打印字符。在这种情况下，你需要在要打印的字符串之前加上`r`或`R`。注意`r`字母位于字符串引号之外，如下例所示：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下结果：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we use `R` to suppress `\n` as a newline command and print
    the actual `\n`. The second `\n` is not preceded by `R` and therefore acts as
    the newline command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`R`来抑制`\n`作为换行命令，并打印实际的`\n`。第二个`\n`没有以`R`开头，因此它作为换行命令。
- en: To and from ASCII
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从ASCII到ASCII
- en: I was lucky enough to be around at the birth of the microprocessor and I built
    a Motorola 6000 microprocessor system from the individual chips (including the
    display). At that time, I did not have any commercial software and I had to convert
    between ASCII characters and their numeric values myself. Life is easier today.
    Python provides two functions that allow you to convert between numeric and ASCII
    values. These are `ord()` and `chr()`. If you write `x = ord('B')`, the value
    of `x` would be its ASCII equivalent, `0x42` or `01000010` in binary. Similarly,
    if you write `y = chr(0x41)`, the value of `y` would be `'A'`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我很幸运能见证微处理器的诞生，并从单个芯片（包括显示器）构建了一个Motorola 6000微处理器系统。当时，我没有任何商业软件，我必须自己将ASCII字符和它们的数值进行转换。今天的生活更容易。Python提供了两个函数，允许你在数值和ASCII值之间进行转换。这些是`ord()`和`chr()`。如果你写`x
    = ord('B')`，`x`的值将是它的ASCII等效值，`0x42`或二进制的`01000010`。同样，如果你写`y = chr(0x41)`，`y`的值将是`'A'`。
- en: Binary and hexadecimal strings
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制和十六进制字符串
- en: 'Before we look at formatted strings in detail, consider the following simple
    example of console input using the Python interpreter. The text in bold is the
    output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细查看格式化字符串之前，考虑以下使用Python解释器的控制台输入的简单示例。粗体的文本是输出：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create an `x` variable equal to `12345` and create a new `y` value that is
    the hex version of `x`. Then, we print it and get the expected result of `0x3039`.
    Next, we create a new variable, `z`, where `z = y + 1`. This generates an error
    message because `y` is a text string and we cannot add the integer `1` to it.
    In the next line, we perform the addition again, but this time, we convert the
    hex string into integer form with `int(y,16)`. Now, we can print `z` as a decimal
    integer or as a hexadecimal string using `print(hex(z))`. In short, Python makes
    it easy to handle decimal, hexadecimal, and binary values, but you must be very
    careful to remember to ensure that you convert between string and integer forms
    where necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`x`变量，其值为`12345`，并创建一个新的`y`值，它是`x`的十六进制版本。然后，我们打印它，得到预期的`0x3039`结果。接下来，我们创建一个新的变量`z`，其中`z
    = y + 1`。这会生成一个错误信息，因为`y`是一个文本字符串，我们不能将其与整数`1`相加。在下一行，我们再次执行加法操作，但这次，我们使用`int(y,16)`将十六进制字符串转换为整数形式。现在，我们可以使用`print(hex(z))`将`z`打印为十进制整数或十六进制字符串。简而言之，Python使得处理十进制、十六进制和二进制值变得容易，但你必须非常小心，确保在必要时在字符串和整数形式之间进行转换。
- en: 'Because we are dealing with binary numbers, it makes sense to display the output
    of TC1 in binary or hexadecimal formats. Suppose we wish to convert a decimal
    integer value into a *binary* string. Consider the following where we convert
    an integer, `p`, into a binary string and then print it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是二进制数，因此以二进制或十六进制格式显示TC1的输出是有意义的。假设我们希望将十进制整数值转换为*二进制*字符串。考虑以下内容，我们将整数`p`转换为二进制字符串，然后打印它：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `"{0:b}"` expression is the key to the formatting. It is a string enclosed
    in curly brackets. `0` tells it to print from the first character of the string
    and `b` signifies binary. This produces the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`"{0:b}"`表达式是格式化的关键。它是一个用大括号括起来的字符串。`0`告诉它从字符串的第一个字符开始打印，`b`表示二进制。这会产生以下输出：'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So far, so good. But what if we want the output to be justified with a fixed
    number of characters – for example, 16? The following demonstrates such formatting
    when we convert 26 and `2033` into binary format:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但如果我们希望输出以固定数量的字符对齐——例如，16个字符？以下展示了将26和`2033`转换为二进制格式时的这种格式化：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only change to the format string is from `"{0:b}"` to `"{0:16b}"`. That
    is, we have inserted the field-width of 16 characters before b. The effect of
    `16` is to define a 16-bit width for the string. The string is padded with spaces
    on the left. The output of this code is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串的唯一更改是从`"{0:b}"`到`"{0:16b}"`。也就是说，我们在`b`之前插入了16个字符的字段宽度。`16`的效果是为字符串定义一个16位的宽度。字符串在左侧用空格填充。此代码的输出如下：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In a lot of computer texts, it is normal to pad binary and decimal values with
    leading zeros on the left, rather than spaces. We can do this with a small change
    in the format. We insert `0` before the field width – that is, `"{0:0`16`b}"`.
    Now consider the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多计算机文本中，通常会在二进制和十进制值的前面填充前导零，而不是空格。我们可以通过格式的小幅改动来实现这一点。我们在字段宽度之前插入`0`——即`"{0:0`16`b}"`。现在考虑以下内容：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This gives an output where the numbers are displayed in 16 bits and padded
    with leading zeros, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个输出，其中数字以16位显示，并使用前导零填充，如下所示：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Hexadecimal values are treated in the same way by substituting `x` for `b`
    in the `format` statement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制值通过在`format`语句中将`x`替换为`b`以相同的方式处理：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This gives the following output. As you can see, it’s analogous to the binary
    version:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出。如您所见，它与二进制版本类似：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Of course, we can combine both print formats (i.e., binary and hexadecimal),
    as in this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以结合两种打印格式（即二进制和十六进制），如下例所示：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We print two numbers, one in a binary format and one in a hexadecimal format.
    In the first case, the number is padded to 16 bits with leading zeros, and in
    the second case, it’s padded to 4 characters with leading zeros.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了两个数字，一个以二进制格式，一个以十六进制格式。在第一种情况下，数字被填充到16位，并带有前导零，而在第二种情况下，它被填充到4个字符，并带有前导零。
- en: 'We print the result twice. In the second case, prefixes are added to the values
    to indicate the base. If the first number, `xBin`, is binary, we can concatenate
    “`0b`” simply by using a “+” symbol to add `0b` immediately before the binary
    string. The output from this code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了两次结果。在第二种情况下，添加了前缀到值以指示基数。如果第一个数字`xBin`是二进制，我们可以通过使用“+”符号简单地将“`0b`”添加到二进制字符串之前来连接“`0b`”。此代码的输出如下：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can generalize the string method format as `"someString".format(<parameter
    list>`. This string method takes the string and inserts parameters into it that
    appear in the parameter list. You have to insert *placeholders* in the form of
    `{a:b}` into the string, which will receive the parameters when the string is
    printed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将字符串方法格式概括为 `"someString".format(<参数列表>)`。这个字符串方法将字符串插入到参数列表中出现的参数。您必须在字符串中插入
    *占位符* 的形式 `{a:b}`，当字符串打印时，这些占位符将接收参数。
- en: 'Suppose you were printing a table of the powers of integers in the form x,
    x2, x3, x4\. We could write the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在打印整数幂的表格，形式为 x，x²，x³，x⁴。我们可以写出以下内容：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Each parameter placeholder is of the form`{`a`:b}`where the first element,
    a, is the position of the parameter in the list of parameters in the format. The
    second element, `b`, determines how the parameter is printed. In this case, it
    is a number and the letter `d`. The number defines the parameter’s width, and
    `d` indicates that it’s decimal; for example, the last parameter is specified
    as `{`3`:6d}`, which indicates the fourth parameter is a decimal integer taking
    six places. The following demonstrates the output from this fragment of code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数占位符的形式为 `{`a`:b}`，其中第一个元素 a 是参数在格式参数列表中的位置。第二个元素 `b` 决定了参数的打印方式。在这种情况下，它是一个数字和字母
    `d`。数字定义了参数的宽度，而 `d` 表示它是十进制；例如，最后一个参数指定为 `{`3`:6d}`，表示第四个参数是一个十进制整数，占六位。以下展示了这段代码的输出：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to demonstrate the versatility of this approach, the next example
    prints the same table of powers but using a different format. As well as decimal,
    we also use binary and hexadecimal. Note that you only have to change b in `{`a`:b}`
    to change the base; for example, `{`6`:x}` tells the `print` statement to print
    the seventh parameter in hexadecimal format:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种方法的通用性，下一个示例将打印相同的幂表，但使用不同的格式。除了十进制，我们还使用了二进制和十六进制。请注意，您只需将 `{`a`:b}`
    中的 b 改为 b 即可更改基数；例如，`{`6`:x}` 告诉 `print` 语句以十六进制格式打印第七个参数：
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note you can write x*x*x, or `x**3`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您可以写 x*x*x，或者 `x**3`。
- en: 'The following output demonstrates the results of this formatting technique:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出展示了这种格式化技术的结果：
- en: '[PRE46]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have repeated the example with a few modifications. It is not necessary
    to give the order of the parameters if they are to be printed sequentially; for
    example, the first parameter specification can be written as `{:2d}` instead of
    `{0:2d}`. We’ve also changed the spacing to demonstrate how the width parameters
    operate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对示例进行了一些修改。如果参数要按顺序打印，则不需要给出参数的顺序；例如，第一个参数规范可以写成 `{:2d}` 而不是 `{0:2d}`。我们还更改了间距以展示宽度参数如何操作：
- en: '[PRE47]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Consider the following examples of the `format` mechanism. Here, we use the
    symbols “`<`, `>`, `^`” to control formatting. In order, these symbols force left
    justification, right justification, and centering within the stated width.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `format` 机制的示例。在这里，我们使用符号“`<`, `>`, `^`”来控制格式化。依次，这些符号强制左对齐、右对齐和在指定的宽度内居中对齐。
- en: 'The following code prints the decimal integer `123` first in decimal form,
    using the three modifiers, and then in binary form using the same three modifiers.
    In each case, we have specified a width of 10 characters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码首先以十进制形式打印十进制整数 `123`，使用三个修饰符，然后以二进制形式使用相同的三个修饰符。在每种情况下，我们都指定了 10 个字符的宽度：
- en: '[PRE48]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output generated by this code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由这段代码生成的输出如下：
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We are now going to provide three examples of how strings representing numbers
    can be printed. The first demonstrates the formatting of individual numbers in
    integer, hexadecimal, binary, and real forms. The second example shows how we
    can take a list of registers, join them as a single string, and print their values.
    This is very useful in displaying data when stepping through instructions during
    a simulation. The third example demonstrates the successive steps in processing
    a hexadecimal value into the desired format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将提供三个示例，说明表示数字的字符串如何打印。第一个示例演示了以整数、十六进制、二进制和实数形式格式化单个数字。第二个示例展示了我们可以如何将寄存器列表合并为一个字符串，并打印它们的值。这在模拟中逐步执行指令时显示数据非常有用。第三个示例演示了将十六进制值处理成所需格式的连续步骤。
- en: Example 1 – Formatting numbers
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1 – 格式化数字
- en: 'The following demonstrates this formatting mechanism, where we print several
    variables and a string. This uses a format specifier such as `%05d`, which means
    five decimal digits with leading zeros, and a placeholder such as `%x`, which
    means print the value of `x` in the format specified by %05d:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了这种格式化机制，其中我们打印了几个变量和一个字符串。这使用了一个格式说明符，例如 `%05d`，它表示带有前导零的五个十进制数字，以及一个占位符，例如
    `%x`，它表示按照 %05d 指定的格式打印 `x` 的值：
- en: '[PRE56]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This `print` statement displays the following (note hexadecimal appears in
    lowercase):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `print` 语句显示了以下内容（注意十六进制以小写形式出现）：
- en: '[PRE57]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Example 2 – Printing a list of register values in hexadecimal form
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2 – 以十六进制形式打印寄存器值列表
- en: 'Consider the following expression with an 8-register array filled with data
    in various formats:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式，其中有一个包含各种格式数据的 8 寄存器数组：
- en: '[PRE58]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This expression prints the string ‘`Registers =`’`,` followed by a second string
    that contains eight four-character hexadecimal values. To create the second string,
    we use the string `join()` method. The string comprehension iterates over the
    registers applying the formatting structure to each element. That is, it reads
    `r[0]`, converts it into a string format, and then joins it to its left-hand neighbor
    (which is initially an empty string). This is repeated eight times and then that
    string is printed as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式打印了字符串‘`寄存器 =`’`,`，然后是一个包含八个四字符十六进制值的第二个字符串。为了创建第二个字符串，我们使用了字符串 `join()`
    方法。字符串推导式遍历寄存器，将格式化结构应用于每个元素。也就是说，它读取 `r[0]`，将其转换为字符串格式，然后将其与其左侧邻居（最初是一个空字符串）连接起来。这重复了八次，然后按照以下方式打印该字符串：
- en: '[PRE59]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Example 3 – Successively processing a decimal value into the desired hex format
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 3 – 依次将十进制值处理成所需的十六进制格式
- en: 'Consider the following sequence where we successively process the decimal value
    44,350 until it is displayed in hexadecimal format in uppercase without the `0x`
    indicator prefix:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下序列，我们依次处理十进制值 44,350，直到它以大写形式显示为没有 `0x` 指示前缀的十六进制格式：
- en: '[PRE60]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have described, briefly, how numbers can be formatted. Formatting is necessary
    if the printed output is to be read by humans, especially if you are simulating
    a computer where patterns of 1s and 0s are important. There are several ways of
    formatting data, and this section provided only an introduction to this topic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地描述了如何格式化数字。如果打印的输出要由人类阅读，特别是如果你正在模拟一个其中 1 和 0 的模式很重要的计算机，格式化是必要的。有几种格式化数据的方法，本节仅提供了这个主题的介绍。
- en: Input validation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入验证
- en: In this section, I will introduce the notion of data validation. Historically,
    some of the major errors involving computers have been caused by a failure to
    check input data. TC1 doesn’t perform source data checking; you can write `ADDL
    R1,R2,10` or `ADDL z1,z2,10` with the same result. Why? Because when the assembler
    sees `ADDL`, it looks for three parameters. It takes the first parameter, let’s
    call this `p1`, and reads the register number by `regnum = int(`p1[1:]`)`. Only
    the second and successive characters of `p1` are recorded, and the “R” is ignored.
    You can write `R1` or even `?1`. This makes programming in assembly language easier;
    you can use any letter you want to represent a register. On the other hand, it
    encourages poor programming techniques and increases the dangers associated with
    mistyped input.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍数据验证的概念。历史上，一些涉及计算机的主要错误是由未能检查输入数据造成的。TC1 不执行源数据检查；你可以编写 `ADDL R1,R2,10`
    或 `ADDL z1,z2,10`，结果相同。为什么？因为当汇编器看到 `ADDL` 时，它会寻找三个参数。它取第一个参数，让我们称它为 `p1`，并通过
    `regnum = int(`p1[1:]`)` 读取寄存器号。只有 `p1` 的第二个和后续字符被记录下来，“R”被忽略。你可以写 `R1` 或甚至 `?1`。这使得汇编语言编程更容易；你可以使用任何字母来表示寄存器。另一方面，它鼓励了不良的编程技术，并增加了与输入错误相关的危险。
- en: Validating data
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证数据
- en: Since the TC1 assembler doesn’t perform error-checking on the input, if you
    make an error, it’s likely that the program will crash, leaving you to do your
    own debugging. Good software performs error-checking, which ranges from the simple
    detection of invalid instructions to the exact pinpointing of all errors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TC1 汇编器不对输入进行错误检查，如果你犯了错误，程序很可能会崩溃，让你自己进行调试。好的软件会进行错误检查，这从简单的无效指令检测到精确地定位所有错误。
- en: Here, we demonstrate how you can read a line of code and check for several types
    of common errors – for example, invalid opcodes, invalid instruction formats (too
    many or two few operands), typos (typing `T6` instead of `R6`), and registers
    out of range (entering `R9`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何读取一行代码并检查几种常见的错误类型——例如，无效的操作码、无效的指令格式（操作数过多或过少）、拼写错误（将 `T6` 键入为 `R6`）以及超出范围的寄存器（输入
    `R9`）。
- en: The purpose of this section is to show how you can add your own modifications
    to TC1\. A formal way of dealing with the problem would be to construct a grammar
    for the assembly language and then build a parser to determine whether the input
    conforms to that grammar. We are going to take a simpler and more ad hoc approach.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的在于展示如何向 TC1 添加自己的修改。处理问题的正式方法是为汇编语言构造一个语法，然后构建一个解析器以确定输入是否符合该语法。我们将采取更简单、更具体的方法。
- en: 'If the current instruction is `x =` ''`ADD r1 r2 r3`'', the `y = x.split(`''
    ''`)` operation converts it into a list of tokens: `y = [`''`ADD`''`,` ''`R1`''`,`
    ''`R2`''`,` ''`R3`''`]`. We can extract the first token with `jj = y[0]`, which
    should be a valid mnemonic (in this example, we are forgetting about any labels).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前指令是 `x =` '`ADD r1 r2 r3`'，则 `y = x.split(`' '`)` 操作将其转换为一系列标记的列表：`y = [`'`ADD`'`,`
    '`R1`'`,` '`R2`'`,` '`R3`'`]`。我们可以使用 `jj = y[0]` 提取第一个标记，它应该是一个有效的助记符（在这个例子中，我们忽略任何标签）。
- en: 'The first test to perform is on the validity of the instruction. Assume that
    all mnemonics have been defined in a list or directory called `codes`. All we
    have to do is to look it up in the `codes` directory using the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要进行的测试是检查指令的有效性。假设所有助记符都已定义在名为 `codes` 的列表或目录中。我们只需使用以下方法在 `codes` 目录中查找它：
- en: '[PRE61]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Python keywords are shaded. This expression sets the `error` variable to `1`
    if this instruction is not in the dictionary. Then, we can test `error` and take
    whatever action is necessary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python 关键字被阴影显示。此表达式将 `error` 变量设置为 `1`，如果此指令不在字典中。然后，我们可以测试 `error` 并采取必要的行动。
- en: 'The next step is to use the name of the instruction to look up its details,
    and then check whether that instruction requires parameters. Remember that our
    dictionary entries have a two-component tuple, with the first component being
    the instruction’s format (i.e., the number of operands required) and the second
    being the actual operation code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用指令的名称来查找其详细信息，然后检查该指令是否需要参数。请记住，我们的字典条目是一个包含两个元素的元组，第一个元素是指令的格式（即所需的操作数数量），第二个是实际的操作码：
- en: '[PRE62]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It looks up the instruction (i.e., `y[0]`) in the dictionary and returns its
    value, which is a tuple, such as `(8:12)`. The first element of the tuple, `form[0]`,
    describes the instruction’s operands and the second is the opcode (which is not
    of interest here). The parameters required by the instruction are determined by
    `form[0]`. Consider the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它在字典中查找指令（即 `y[0]`），并返回其值，该值是一个元组，例如 `(8:12)`。元组的第一个元素 `form[0]` 描述了指令的操作数，第二个是操作码（在这里不感兴趣）。指令所需的参数由
    `form[0]` 确定。考虑以下代码：
- en: '[PRE63]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The four bits of the format code represent `rD`, `rS1`, `rs2`, and a literal.
    TC1 instructions have several valid formats; for example, if `opType = 0b`1`00`1
    `= 9`, then the format defines an instruction with a destination register and
    a literal such as `LDRL` R3 25\. We’ve used bold and shading to demonstrate the
    relationship between the bits of the format code and the actual instruction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 格式代码的四位表示 `rD`、`rS1`、`rs2` 和一个字面量。TC1 指令有几种有效的格式；例如，如果 `opType = 0b`1`00`1 `=
    9`，则该格式定义了一个具有目标寄存器和字面量（如 `LDRL` R3 25）的指令。我们使用粗体和阴影来展示格式代码的位与实际指令之间的关系。
- en: 'The preceding code uses an `if…else` to get the length (the number of tokens
    including the opcode) of each instruction. All we then have to do is to count
    the number of tokens in the current instruction and see whether it’s the same
    as the expected value (i.e., the total length). The following code performs this
    check:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `if…else` 来获取每个指令的长度（包括操作码的标记数）。我们接下来只需计算当前指令的标记数，并查看它是否与预期值（即总长度）相同。下面的代码执行此检查：
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We set the error number to `2` or `3` if the number of tokens doesn’t match
    the expected value. After both tests, there is a `continue` statement. The effect
    of `continue` is to drop to the end of the current block and abandon further error-testing
    (because we know this current instruction is in error).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果令牌的数量与预期值不匹配，我们将错误号设置为`2`或`3`。在两次测试之后，有一个`continue`语句。`continue`的效果是跳到当前块的末尾并放弃进一步的错误测试（因为我们知道当前指令是错误的）。
- en: Once we have established a valid instruction and the correct number of operands,
    the next step is to check each operand. An operand must be of the form `R0` to
    `R7` (or a literal).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了一个有效的指令和正确的操作数数量，下一步就是检查每个操作数。操作数必须是`R0`到`R7`（或字面量）的形式。
- en: 'We use the format information to test for each operand in turn. Here, we just
    deal with the first operand, `rD` (the destination register):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用格式信息依次测试每个操作数。在这里，我们只处理第一个操作数，`rD`（目标寄存器）：
- en: '[PRE66]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first line of this code tests whether the leftmost bit of `format` is 1
    or 0 by ANDing the format code with `0b1000` and testing for `0b1000`. If the
    result is `true`, then we need to check for the first register operand, which
    is the second token – that is, `y[1]`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的第一行通过将格式代码与`0b1000`进行AND操作并测试`0b1000`来检查`format`的最左位是1还是0。如果结果是`true`，则需要检查第一个寄存器操作数，即第二个令牌——即`y[1]`。
- en: 'Because we are going to test for three operands, we have created a `syntaxText`
    function that takes the token as a parameter and returns two parameters: `error`
    and `q`. The value of `error` is the error code returned (`0` for no error, and
    `q` is the number of the register). The Python code for the `syntaxTest` function
    is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要测试三个操作数，我们创建了一个`syntaxText`函数，该函数接受令牌作为参数并返回两个参数：`error`和`q`。`error`的值是返回的错误代码（无错误时为`0`，`q`是寄存器的编号）。`syntaxTest`函数的Python代码如下：
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Three tests are performed, one for each type of error that we are looking for.
    The first test is to check whether the first character of the token is `'R'` .
    If it is not `'R'` , a return is made with the error code `4`, and the dummy or
    default register number is set to `0`. The second test looks for a numeric value
    for the register (the characters following the `'R'`, which is `token[1:]`). The
    third test checks whether the number is greater than `7` and returns an error
    code if it is. Finally, when the last line is reached, a return is made with the
    error code `0` and the appropriate register number. Note that we don’t need to
    use an `elif` because if an `if` yields `True`, the code is exited via `return()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了三次测试，针对我们寻找的每种错误类型。第一次测试是检查令牌的第一个字符是否为`'R'`。如果不是`'R'`，则返回错误代码`4`，并将虚拟或默认寄存器号设置为`0`。第二次测试寻找寄存器的数值（`'R'`后面的字符，即`token[1:]`）。第三次测试检查该数字是否大于`7`，如果是，则返回错误代码。最后，当到达最后一行时，返回错误代码`0`和适当的寄存器号。请注意，我们不需要使用`elif`，因为如果`if`返回`True`，代码将通过`return()`退出。
- en: This routine is called up to three times in the event of an instruction having
    a format code of `0b1110` corresponding to a register-to-register operation such
    as `ADD R1 R2 R3`. In this exercise, we do not check the literal. If you wish
    to add that check, it would be necessary to check for an integer in the range
    0 to 65,535 or -32,766 to 32,755 (plus a number beginning with `%` if it’s binary
    or `0x` if it’s hexadecimal).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指令的格式代码为`0b1110`，则此例程会被调用多达三次，这对应于寄存器到寄存器的操作，如`ADD R1 R2 R3`。在此练习中，我们不检查字面量。如果您想添加此检查，则需要检查范围在0到65,535或-32,766到32,755之间的整数（如果是二进制，则以`%`开头；如果是十六进制，则以`0x`开头）。
- en: Using the `continue` statement
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`continue`语句
- en: When testing for errors, do you test for each error in a statement or do you
    stop once you have found an error?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试错误时，你是逐个测试语句中的每个错误，还是一旦找到错误就停止？
- en: 'The code uses a `continue` statement whenever an error is found to bypass further
    testing. An unfortunate side effect is that `continue` takes you past the end
    of the loop and begins the next iteration; that is, you can’t print the nature
    of the error. The solution is to print any errors found in the previous iteration
    at the start of the loop. Of course, this causes a problem on the first iteration
    because there is no previous error value. That is easily fixed by setting `error`
    to zero before beginning the loop. The following code demonstrates this approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现错误时，代码使用 `continue` 语句来跳过进一步的测试。不幸的是，`continue` 会让你跳过循环的末尾并开始下一次迭代；也就是说，你无法打印出错误的性质。解决方案是在循环开始时打印出上一次迭代中发现的任何错误。当然，这会在第一次迭代中引起问题，因为没有先前的错误值。这可以通过在开始循环之前将
    `error` 设置为零来轻松解决。以下代码演示了这种方法：
- en: '[PRE68]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this fragment of code, `error` is tested to determine whether an error occurred
    in the previous cycle. If `error` is not `0`, the `printError` function is called
    to print the error number and type. Using a function code to do the printing enhances
    the readability of the program.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`error` 被测试以确定前一个周期是否发生了错误。如果 `error` 不是 `0`，则调用 `printError` 函数来打印错误编号和类型。使用函数代码进行打印增强了程序的可读性。
- en: 'The code for an error-testing routine is given next. This is not intended to
    be a complete program, but a demonstration of the way in which you can extend
    a program to include error-testing on the input data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个给出的是错误测试例程的代码。这不是一个完整的程序，而是演示了如何将错误测试扩展到输入数据中的方法：
- en: '[PRE69]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Checking parameters – using dictionaries
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查参数——使用字典
- en: The next example provides another look at parameter checking. It examines the
    mnemonic and predicate of each instruction and checks whether it represents a
    valid operation. It stops after finding an error. In other words, it will detect
    only one error in `INC R9,R2` even though there are two errors (i.e., too many
    operands and the first operand is out of range).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例提供了对参数检查的另一种看法。它检查每条指令的助记符和谓词，并检查它是否代表一个有效的操作。它会在找到错误后停止。换句话说，它将在 `INC
    R9,R2` 中检测到两个错误（即操作数过多且第一个操作数超出范围），即使只有一个错误。
- en: 'We also expand the use of the Python dictionary. Previously, we tested for
    a valid register operand by checking that the initial character was ‘R’ and that
    this was followed by a number in the range of 0 to 7\. Since there are only eight
    register names (R0 to R7), it’s easy to employ a dictionary in error checking:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还扩展了 Python 字典的使用。以前，我们通过检查初始字符是否为 'R' 以及其后是否跟有 0 到 7 范围内的数字来测试有效的寄存器操作数。由于只有八个寄存器名称（R0
    到 R7），在错误检查中采用字典是很容易的：
- en: '[PRE70]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The dictionary, `regSet`, contains the register names (the keys) and the corresponding
    value. Because we do so much register checking, it’s convenient to create a function,
    `regTest`, to perform the check. This function takes two parameters. The first
    is a string, `tokNam`, that gives the register a name, and the second parameter
    is the token being tested – for example, `regTest('rD',predicate[0])`. The reason
    for passing a name to the function is so that the function can print the name
    of the operand in error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 词典 `regSet` 包含寄存器名称（键）及其对应的值。由于我们进行了大量的寄存器检查，因此创建一个名为 `regTest` 的函数来执行检查是方便的。此函数接受两个参数。第一个参数是一个字符串
    `tokNam`，它为寄存器赋予一个名称，第二个参数是要测试的令牌——例如，`regTest('rD',predicate[0])`。将名称传递给函数的原因是使函数能够打印出错误操作数的名称。
- en: 'The function returns two values: an error code and the number of the register.
    If an error is detected, the register value of `0` is returned as a default. The
    function is given here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回两个值：一个错误代码和寄存器的编号。如果检测到错误，则默认返回寄存器值 `0`。此函数如下所示：
- en: '[PRE71]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Testing for validity is easy. The `if token in regSet:` condition checks whether
    this parameter is in the register set. If it is, we read the value of the register
    from the dictionary and return its value. If the token is not in the register
    set, an error message is printed (using `tokNam` to display the faulty value),
    and an error message number `4` is reported back.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 检查有效性很容易。`if token in regSet:` 条件检查此参数是否在寄存器集中。如果是，我们从字典中读取寄存器的值并返回其值。如果令牌不在寄存器集中，则打印错误消息（使用
    `tokNam` 显示错误值），并返回错误消息编号 `4`。
- en: Using `regSet.get(token)` is a little heavy-handed. We do not actually need
    to read the register value. If it is in the set of valid registers, we can use
    `int(token[1])` to extract the register number from the name. The advantage of
    using the dictionary mechanism is that we can amend the code to add new registers
    such as `SP`, `PC`, and so on if we want. We can rename registers or even use
    aliases; for example, if we use the `R7` register as a temporary register, we
    could enter `, {. . . 'R6':6, 'R7':7,` 'T':7`}` and then write either `INC R7`
    or `INC T`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regSet.get(token)`有点过于直接。我们实际上不需要读取寄存器值。如果它在有效寄存器集中，我们可以使用`int(token[1])`从名称中提取寄存器号。使用字典机制的优势在于，如果我们想添加新的寄存器，如`SP`、`PC`等，我们可以修改代码。我们可以重命名寄存器或甚至使用别名；例如，如果我们使用`R7`寄存器作为临时寄存器，我们可以输入`{'.
    . . 'R6':6, 'R7':7, 'T':7}`，然后可以写`INC R7`或`INC T`。
- en: We have also experimented with a new instruction dictionary. Some of the information
    in the dictionary is redundant because it can be derived from other information
    (e.g., the length can be derived from the format). However, we adopted the following
    system because we may change the program at a later date.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还尝试了一个新的指令字典。字典中的一些信息是冗余的，因为可以从其他信息中推导出来（例如，长度可以从格式中推导出来）。然而，我们采用了以下系统，因为我们可能在以后改变程序。
- en: In the previous version of the assembler, we used a dictionary in which each
    entry had a key that was a mnemonic and a two-element tuple – for example, `'INC':(8,12)`.
    The first element of the tuple was a format code that expressed the operands required
    by the mnemonic, and the second element was the instruction’s opcode.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编器的上一个版本中，我们使用了一个字典，其中每个条目都有一个键，该键是一个助记符和一个两个元素的元组——例如，`'INC':(8,12)`。元组的第一个元素是一个格式代码，表示助记符所需的操作数，第二个元素是指令的指令码。
- en: 'In this example, we are using a four-element tuple to provide the following
    information:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个四个元素的元组来提供以下信息：
- en: '`rD, rS1, rS2, literal` (as before).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rD, rS1, rS2, literal`（如前所述）。'
- en: '**Style**: The style describes the class of instruction – for example, mnemonic
    only, mnemonic plus literal, mnemonic plus register plus literal, and so on. There
    is a direct relationship between format and style.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风格**：风格描述了指令的类型——例如，仅助记符、助记符加文字、助记符加寄存器加文字等。格式和风格之间存在直接关系。'
- en: '**Length**: The length gives the number of tokens in the instruction – that
    is, the mnemonic plus its operands. This is equivalent to the number of 1s in
    the format plus 1.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度**：长度给出指令中的标记数——即助记符及其操作数。这相当于格式中1的数量加1。'
- en: The instruction’s opcode.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令的指令码。
- en: The initial processing of an instruction is given by the following code. In
    section 1 (light shading), the mnemonic is read from the input token string (i.e.,
    the first element). That may or may not be followed by additional parameters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的初始处理如下所示。在第1节（浅色阴影）中，从输入标记字符串（即第一个元素）读取助记符。可能或可能不跟有其他参数。
- en: The mnemonic is used to access the `codes` dictionary to check whether it’s
    valid. The error code is set to `1` (invalid operation) and a `continue` statement
    forces a drop to the end of the loop (further input testing is not necessary as
    the instruction is not valid).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 助记符用于访问`codes`字典以检查其是否有效。错误代码设置为`1`（无效操作），并且`continue`语句强制跳转到循环的末尾（由于指令无效，不需要进一步输入测试）。
- en: The code with the light gray background reads the tuple with the four data elements
    associated with the mnemonic and extracts the individual parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 背景为浅灰色的代码读取与助记符相关的四个数据元素并提取单个参数。
- en: 'The three lines beginning with “`if opCode == 1:`” read the operation to determine
    whether the instruction was “`STOP`”. If it was `STOP`, the `sys.exit()` operation
    terminates the program. Note that we have to use `import sys` at the start of
    the program to import the library of system functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以“`if opCode == 1:`”开头的三行读取操作以确定指令是否是“`STOP`”。如果是`STOP`，则`sys.exit()`操作终止程序。请注意，我们必须在程序开始时使用`import
    sys`导入系统函数库：
- en: '[PRE72]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The final two blocks in the preceding code fragment with a dark gray background
    perform error-detecting operations. They both get the number of tokens from the
    instruction and then compare that number to the value for this instruction. In
    the first case, an error of `2` indicates too few tokens, and in the second case,
    an error of `3` indicates too many tokens.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有两个带有深灰色背景的最终代码块执行错误检测操作。它们都从指令中获取令牌数量，然后将其与这个指令的值进行比较。在第一种情况下，错误`2`表示令牌太少，而在第二种情况下，错误`3`表示令牌太多。
- en: At this stage, we have determined that the instruction is valid and has the
    correct number of operands. The next stage is to check the operands. The check
    is performed according to the style of the instruction. There are seven styles.
    Style 1 has no further checking because there is no operand (e.g., for `NOP`).
    We will just look at the checking for style 6, which corresponds to instructions
    with a mnemonic, `rD1`, `rS1`, and a literal such as `ADD R1,R2,25`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经确定指令是有效的，并且具有正确的操作数数量。下一个阶段是检查操作数。检查是根据指令的风格进行的。有七种风格。风格1没有进一步的检查，因为没有操作数（例如，对于`NOP`）。我们只看一下风格6的检查，它对应于具有助记符、`rD1`、`rS1`和类似`ADD
    R1,R2,25`的常量的指令。
- en: We call the `regTest` function first with the ‘`rD`’ parameter to tell it we
    are testing for the destination register and the `predicate[0]` token, which is
    the first parameter. This returns an error flag and the value of the register.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`regTest`函数的`'rD'`参数来告诉它我们正在测试目标寄存器，以及`predicate[0]`令牌，这是第一个参数。这返回一个错误标志和寄存器的值。
- en: 'Because we perform two tests (register `rD` and `rS1`), we must use two error
    names: `e1` for the first and `e2` for the second test. If we used `error` as
    the variable in both cases, a non-error second result would clear the first error.
    The line `if (e1 != 0) or (e2 != 0): error = 4` returns `error` with the appropriate
    error status independent of which register was in error. `continue` at the end
    of this block skips further error checking for this instruction:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '因为我们执行了两个测试（寄存器`rD`和`rS1`），我们必须使用两个错误名称：第一个测试使用`e1`，第二个测试使用`e2`。如果我们在这两种情况下都使用`error`作为变量，非错误第二个结果将清除第一个错误。`if
    (e1 != 0) or (e2 != 0): error = 4`这一行返回`error`，带有适当的错误状态，与哪个寄存器出错无关。在这个代码块末尾的`continue`跳过对这个指令的进一步错误检查：'
- en: '[PRE73]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is the main loop. An instruction is input and then checked for errors.
    As in earlier examples, the instruction is processed for validity first and the
    mnemonic is checked to see whether it is in codes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主循环。输入一条指令，然后检查错误。与早期示例一样，首先处理指令的有效性，然后检查助记符是否在代码中：
- en: '[PRE74]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Having looked at input validation, we now look at how we can control the display
    of *useful* information during a simulation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看输入验证之后，我们现在来看看我们如何在模拟期间控制显示*有用*的信息。
- en: Tracing and breakpoints
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跟踪和断点
- en: 'When you simulate a computer, you have to show what is happening during the
    simulation. Consequently, you have to answer the following three questions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你模拟计算机时，你必须展示模拟过程中发生的事情。因此，你必须回答以下三个问题：
- en: When do you display data?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你何时显示数据？
- en: How do you display the data?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何显示数据？
- en: What do you display?
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你显示什么？
- en: When you have completed this section, you will be able to construct your own
    instruction tracing facilities.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这一部分后，你将能够构建自己的指令跟踪功能。
- en: CPU simulators execute one instruction at a time. At the end of an instruction,
    the state of the computer (i.e., its registers, status flags, and memory) can
    be displayed. This mode is called *single-stepping*. Every time you hit *Enter*,
    an instruction is executed and the machine’s status is displayed on the screen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CPU模拟器一次执行一条指令。在指令结束时，计算机的状态（即其寄存器、状态标志和内存）可以显示。这种模式称为*单步执行*。每次你按下*Enter*键，就会执行一条指令，并在屏幕上显示机器的状态。
- en: Stepping through instructions sequentially, one by one, has limitations. What
    if there’s a 3-instruction loop that clears, say, 1,000 locations in an array?
    Do you expect someone to hit the *Enter* key 3,000 times to trace past this operation?
    We need a means of stepping past the boring bits of a program and jumping to the
    interesting bits – that is, a mechanism that lets us execute some instructions
    as a batch, without having to hit *return* after each instruction has been executed
    or printing the results of that execution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 逐条顺序执行指令有局限性。如果有一个3条指令的循环，比如清除数组中的1,000个位置，你会期望有人按3,000次*Enter*键来跟踪这个操作吗？我们需要一种方法来跳过程序中无聊的部分，直接跳到有趣的部分——也就是说，一种机制，允许我们将一些指令作为一个批次执行，而无需在每条指令执行后按*return*键或打印执行结果。
- en: 'Suppose we create a variable, `trace`, and then, at the end of the `execute`
    loop, print the appropriate data if `trace` is `1` and jump to the next instruction
    without printing data if `trace =` `0`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建一个变量，`trace`，然后在`execute`循环的末尾，如果`trace`是`1`，则打印适当的数据；如果`trace =` `0`，则跳到下一条指令而不打印数据：
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The CPU state is printed after each instruction only if `trace = 1`. How do
    we turn `trace` on and off? Turning `trace` off is easy; all you need do is read
    the keyboard input when single-stepping, and turn `trace` off if a particular
    character or string is entered. However, once `trace` is `0`, we’ve lost control,
    and instructions are executed until the program is terminated.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`trace = 1`时，CPU状态才会在每条指令后打印。我们如何开启和关闭`trace`？关闭`trace`很简单；你只需要在单步执行时读取键盘输入，如果输入了特定的字符或字符串，就关闭`trace`。然而，一旦`trace`是`0`，我们就失去了控制，指令会一直执行，直到程序终止。
- en: One solution is to set up a trace count, with the number of instructions to
    be executed before `trace` is turned on again; for example, entering `T 10`, would
    turn off tracing, execute 10 instructions without displaying anything, and then
    turn tracing on again. Defining a fixed number of instructions to execute is not
    always helpful, as it requires the programmer to count the number of instructions
    to be executed before a point of interest is reached. The programmer may not always
    know that.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是设置一个跟踪计数，即再次开启跟踪之前要执行的指令数量；例如，输入`T 10`，将关闭跟踪，执行10条指令而不显示任何内容，然后再次开启跟踪。定义一个固定的指令数量来执行并不总是有帮助，因为它要求程序员在到达感兴趣的点之前计算要执行的指令数量。程序员可能并不总是知道这一点。
- en: A better solution is to turn tracing on when a specific point in the assembly
    language program, called a *breakpoint,* is reached. A breakpoint can be the value
    of the program counter, a label, or a specific instruction. Typically, the value
    of the program counter at which you wish to display machine status is stored in
    a table of breakpoints. Execution continues (without any display) until a breakpoint
    is encountered and the CPU state is displayed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是在达到汇编语言程序中的特定点时开启跟踪，这个点被称为*断点*。断点可以是程序计数器的值、标签或特定的指令。通常，你希望在显示机器状态时程序计数器的值存储在断点表中。执行将继续（没有任何显示），直到遇到断点并显示CPU状态。
- en: 'The following fragment of Python demonstrates this approach. It is not a computer
    simulator and has only three instructions (`nop`, `test`, and `test1`), which
    do nothing, plus `stop`. The program is intended to demonstrate a possible approach
    to the implementation of single-stepping and breakpoints. At the end of each instruction
    cycle, several choices are possible:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码片段展示了这种方法。它不是一个计算机模拟器，只有三条指令（`nop`、`test`和`test1`），它们什么都不做，加上`stop`。该程序旨在展示实现单步执行和断点的可能方法。在每个指令周期结束时，有几种选择：
- en: Show the machine status after the execution of this instruction
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示执行此指令后的机器状态
- en: Wait for keyboard input before executing the next cycle
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行下一个周期之前等待键盘输入
- en: Print the machine status at a specific breakpoint (address or instruction)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定的断点（地址或指令）打印机器状态
- en: The following code uses different fonts and background shading to highlight
    the various functional parts of the code. The first two sections are the setting
    up and initialization of variables, and (shaded) the main program execution loop.
    This loop does nothing other than step through instructions that are `nop` (no
    operation); `test` and `test1` are just used as markers. The `stop` instruction
    serves to terminate execution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用不同的字体和背景阴影来突出显示代码的不同功能部分。前两个部分是变量设置和初始化，以及（阴影部分）主程序执行循环。这个循环除了遍历`nop`（无操作）指令外不做任何事情；`test`和`test1`仅用作标记。`stop`指令用于终止执行。
- en: 'Note that, when tracing, we require a second program counter, `pcOld`, because
    `pc` gets incremented during the `fetch` cycle and we need to display it before
    it was modified:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在跟踪时，我们需要第二个程序计数器`pcOld`，因为`pc`在`fetch`周期中会增加，我们需要在它被修改之前显示它：
- en: '[PRE76]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Initially, `trace` is set to `1`, indicating that we are in a *single-step*
    mode. After displaying the program counter and instruction, the program waits
    for keyboard input. The code that does this is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`trace`被设置为`1`，表示我们处于单步模式。在显示程序计数器和指令后，程序等待键盘输入。执行此操作的代码如下：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If the input is a return (i.e., `enter`), the loop is terminated by `continue`
    and the next instruction cycle is executed. If you enter `t` followed by an integer
    (e.g., `t 13`), the integer is transferred to the `count` variable and `t` is
    set to `0`. Setting `t` to `0` turns off the single-step mechanism, and instructions
    are executed without printing the machine status or waiting for a keyboard input
    at the end of each cycle. At the end of each cycle, the `count` variable is decremented.
    When `count` becomes `0`, `trace` is set to `1` and the single-step mode is re-entered.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是回车（即`enter`），则通过`continue`终止循环并执行下一个指令周期。如果你输入`t`后跟一个整数（例如，`t 13`），则整数会被转移到`count`变量，而`t`被设置为`0`。将`t`设置为`0`会关闭单步机制，指令将在不打印机器状态或等待每个周期末的键盘输入的情况下执行。在每个周期末，`count`变量会递减。当`count`变为`0`时，`trace`被设置为`1`，并重新进入单步模式。
- en: If you enter `b` followed by an integer (e.g., `b 21`), a breakpoint at address
    `21` is recorded in the breakpoint table (a dictionary). You can enter more than
    one breakpoint and it will be saved in the dictionary. Each breakpoint is an address
    in the program being executed. When the program counter reaches that address,
    the system status is displayed. For example, if you were to enter the sequence
    `b 12`, `b 30`, `t 50` (each on a separate line), the simulator would set breakpoints
    at addresses `12` and `30`, and then execute 50 cycles without displaying any
    data. However, if the program counter becomes either `12` or `30` during this
    period, the machine status will be printed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`b`后跟一个整数（例如，`b 21`），则在断点表中（一个字典）记录地址`21`的断点。你可以输入多个断点，并且它们将被保存在字典中。每个断点都是正在执行的程序中的地址。当程序计数器达到该地址时，会显示系统状态。例如，如果你输入序列`b
    12`、`b 30`、`t 50`（每行一个），模拟器会在地址`12`和`30`设置断点，然后执行50个周期而不显示任何数据。然而，如果在这一期间程序计数器变为`12`或`30`，则会打印机器状态。
- en: 'Similarly, you can enter an instruction that will be loaded into the `traceCodes`
    table. This behaves exactly like the PC breakpoint. When an instruction that’s
    in the `traceCodes` table is encountered, the machine status is displayed. Thus,
    the simulator provides four modes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以输入一个将被加载到`traceCodes`表中的指令。这的行为与PC断点完全相同。当遇到`traceCodes`表中的指令时，会显示机器状态。因此，模拟器提供了四种模式：
- en: Execute instruction step by step
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐条执行指令
- en: Execute *n* instructions without displaying system status (the silent mode)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行*n*条指令而不显示系统状态（静默模式）
- en: Execute instructions in silent mode but stop and display if a breakpoint address
    is encountered
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静默模式下执行指令，但在遇到断点地址时停止并显示
- en: Execute instructions in silent mode but stop and display if a specific opcode
    is encountered
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在静默模式下执行指令，但在遇到特定操作码时停止并显示
- en: 'Of course, the program can be extended to more exotic forms of breakpoints
    that take account of register data, memory data, or any combination of events.
    For example, you could permit breakpoints of the following form:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，程序可以扩展到考虑寄存器数据、内存数据或任何事件组合的更奇特形式的断点。例如，你可以允许以下形式的断点：
- en: '[PRE78]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Some simulators let you set a breakpoint on a change of instruction flow – that
    is, after any jump, branch, or subroutine call. That’s very useful for tracing
    the execution of a complex program.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模拟器允许你在指令流改变时设置断点——即在任何跳转、分支或子程序调用之后。这对于跟踪复杂程序的执行非常有用。
- en: 'The following is the output of a short session with this fragment program.
    Remember that it is intended to be a demonstration of the principles involved,
    rather than an actual working system:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是使用此程序片段的简短会话的结果。请记住，它的目的是展示涉及的原则，而不是一个实际工作的系统：
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The next step is to demonstrate how the simulated computer can be extended by
    adding new instructions. We demonstrate what parts of the code have to be modified
    and how you can create new instructions of arbitrary complexity. For example,
    if you were developing a computer to be used primarily for playing chess, you
    could create an instruction, `ROOK R1,R2`, that takes the position of a rook in
    register `R2` and calculates the legal positions it could move to and put them
    in `R1`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是演示如何通过添加新指令来扩展模拟计算机。我们演示了哪些代码部分需要修改，以及如何创建任意复杂性的新指令。例如，如果你正在开发主要用于下棋的计算机，你可以创建一个指令`ROOK
    R1,R2`，该指令获取寄存器`R2`中罗克的位置，并计算它可以移动到且合法的位置，并将它们放入`R1`。
- en: Adding new instructions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新指令
- en: So far, we have provided a modest set of instructions for TC1\. In this section,
    we show how to add a new instruction to the TC1’s repertoire in order to see what’s
    involved in extending an instruction set. In fact, this is a remarkably straightforward
    task.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为TC1提供了一套基本的指令。在本节中，我们展示了如何向TC1的指令集中添加一条新指令，以便了解扩展指令集所涉及的内容。实际上，这是一个非常直接的任务。
- en: The first step is to choose a mnemonic and unique opcode and insert them into
    the table of code. We’ve arranged the instruction set to leave some unallocated
    code (e.g., code beginning with `11`). The second step is to write the code to
    interpret the new instruction.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是选择一个助记符和唯一的操作码，并将它们插入到代码表中。我们已经安排了指令集，留出一些未分配的代码（例如，以`11`开头的代码）。第二步是编写解释新指令的代码。
- en: First example – putting two memory locations in ascending order
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个示例——将两个内存位置按升序排列
- en: 'Let’s create an instruction that takes the contents of two consecutive locations
    in memory and puts the largest number in the first location at the lower address
    (i.e., it orders them). This instruction takes a single parameter, a pointer register,
    and reads the numeric value pointed at by the register. We’ll assume that the
    register is `r[i]`. The instruction compares this number with the value stored
    at address `r[i] + 1`, and swaps them if the second number is higher than the
    one at the `r[i]` location. In pseudocode, this is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一条指令，该指令从内存中的两个连续位置获取内容，并将较大的数字放在较低地址的第一个位置（即，对它们进行排序）。这条指令接受一个参数，即指针寄存器，并读取寄存器所指向的数值。我们假设寄存器是`r[i]`。该指令将这个数字与地址`r[i]
    + 1`存储的值进行比较，如果第二个数字比`r[i]`位置的数字大，则交换它们。在伪代码中，如下所示：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We will call the instruction `ORD` (order numbers) and write it as `ORD r0`.
    The binary code is `1110000 rrr 00…0` (where `rrr` is the 3-bit register field)
    and is assigned to this instruction. `'ORD':(8,112)` is entered in the Python
    dictionary of instructions. The opcode is `112` and the parameter allocation code
    in binary is `1000` (i.e., 8), because the only parameter required is `Rd`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个指令命名为`ORD`（排序数字），并写成`ORD r0`。二进制代码是`1110000 rrr 00…0`（其中`rrr`是3位寄存器字段）并分配给这个指令。`'ORD':(8,112)`被输入到Python指令字典中。操作码是`112`，二进制参数分配代码是`1000`（即8），因为只需要一个参数`Rd`。
- en: 'The new instruction is detected in the execution part of the program:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新指令在程序的执行部分被检测到：
- en: '[PRE81]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is followed by the Python version of the preceding pseudocode. We can
    write the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后是前面伪代码的Python版本。我们可以写出以下内容：
- en: '[PRE82]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'What could be simpler? The following code provides a testbed for the instruction.
    We fill memory with random numbers and then request a memory address. The data
    at that address is exchanged with the data at the next address to create an ordered
    pair. Note that this example does not use global variables: the registers and
    memory are passed to the function as parameters. To simplify testing, it is assumed
    that the memory address is in the `r[0]` register:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这能有多简单？以下代码提供了一个指令的测试平台。我们用随机数填充内存，然后请求一个内存地址。该地址的数据与下一个地址的数据交换，以创建一个有序对。请注意，此示例不使用全局变量：寄存器和内存作为参数传递给函数。为了简化测试，假设内存地址在
    `r[0]` 寄存器中：
- en: '[PRE83]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Second example – adding a bit-reversal instruction
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个示例 – 添加位反转指令
- en: Let’s add a more complicated instruction to the TC1 instruction set. Suppose
    you want to reverse the order of bits in a register so that the binary code `1100111000101001`
    in `r0` becomes `1001010001110011`. Assume that the new instruction is `REV r0`,
    which reverses the 16 bits in `r0` and returns the result in r0.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在TC1指令集中添加一个更复杂的指令。假设你想要反转寄存器中位的顺序，使得 `r0` 中的二进制代码 `1100111000101001` 变为
    `1001010001110011`。假设新的指令是 `REV r0`，它反转 `r0` 中的16位，并将结果返回到 `r0`。
- en: 'How do we reverse bits? Consider the four bits 1101 and assume they are in
    T1 (*see Fig 7.1*). Suppose we shift the bits one place left so that the bit that
    leaves the left-hand end of T1 goes into the right-hand end of T2, and then we
    shift T2 one place to the right. We repeat that operation four times. *Figure
    7**.1* shows what we get:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何反转位？考虑四个位 1101，并假设它们在T1中（*见图7.1*）。假设我们将位向左移动一位，这样离开T1左端的位就进入T2的右端，然后我们将T2向右移动一位。我们重复这个操作四次。*图7**.1*显示了我们会得到什么：
- en: '![Figure 7.1 – Shifting one register’s output into a second register’s input
    to reverse a string](img/Figure_7.1_B19624.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 将一个寄存器的输出移入第二个寄存器的输入以反转字符串](img/Figure_7.1_B19624.jpg)'
- en: Figure 7.1 – Shifting one register’s output into a second register’s input to
    reverse a string
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 将一个寄存器的输出移入第二个寄存器的输入以反转字符串
- en: 'We have reversed the order of the bits. If the register to be shifted is `op1`,
    then we can write the Python code as follows. This code is in the form of a function
    that can be called from the instruction interpreter:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经反转了位序。如果需要移位的寄存器是 `op1`，那么我们可以将Python代码编写如下。这段代码是一个函数，可以从指令解释器中调用：
- en: '[PRE85]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can now change the code of TC1 to incorporate this. There are three steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改TC1的代码以包含这个功能。这里有三个步骤：
- en: '`''REV'':(8,113)`, into the `codes` dictionary. 8 indicates `1000` in binary
    and informs the computer that the reverse instruction requires the destination
    `rD` register to be specified by the instruction. 113 is the opcode, which is
    `0b1110001` in binary.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''REV'':(8,113)`，到 `codes` 字典中。8表示二进制的 `1000`，并通知计算机反向指令需要通过指令指定目标 `rD` 寄存器。113是操作码，二进制表示为
    `0b1110001`。'
- en: '**Step 2**: In the opcode interpretation list, insert the new entry:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤2**：在操作码解释列表中插入新的条目：'
- en: '[PRE86]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This checks whether the current instruction is `0b1110001` (i.e., 161 decimal)
    and calls the r`everseBits()` function to perform the required operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查当前指令是否为 `0b1110001`（即十进制的161）并调用 `reverseBits()` 函数来执行所需的操作。
- en: '`reverseBits` function into the Python code. This instruction replaces the
    data in the `rD` register with the bits reversed.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `reverseBits` 函数添加到Python代码中。此指令用反转的位替换 `rD` 寄存器中的数据。
- en: Suppose that we wanted a non-destructive instruction that did not overwrite
    the register containing the bits to be reversed – that is `REV r0,r1`. What changes
    would we need?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个非破坏性指令，该指令不会覆盖包含要反转的位的寄存器 – 即 `REV r0,r1`。我们需要进行哪些更改？
- en: 'First, we would need a new instruction format code. We have to specify two
    registers: the source and destination register. The code in the directory would
    now be `''REV'': (12,113)` because the opcode parameter value would be `1100`
    in binary or `12` in decimal. The other change would be to the instruction interpreter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们需要一个新的指令格式代码。我们必须指定两个寄存器：源寄存器和目标寄存器。现在目录中的代码将是 `''REV'': (12,113)`，因为操作码参数值将是二进制的
    `1100` 或十进制的 `12`。其他更改将是针对指令解释器的：'
- en: '[PRE87]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that we have changed the instruction format for minimal changes to the
    code (in this case, it’s just the change of source register from `op0` to `op1`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经为了最小化代码更改而更改了指令格式（在这种情况下，只是将源寄存器从 `op0` 更改为 `op1`）。
- en: A new comparison operation
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个新的比较操作
- en: 'Suppose you are performing an operation on a string where you have to find
    the *middle* of the string. You can do this by stepping in from both ends until
    you get to the middle. But there are *two* types of middle. A string with an odd
    number of characters has a character in its middle. A string with an even number
    of characters has no middle character; it has two characters next to each other.
    Consider these two examples:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在对一个字符串进行操作，需要找到字符串的*中间位置*。你可以通过从两端逐步接近中间位置来完成这个操作。但是有两种类型的中间位置。字符数量为奇数的字符串在其中间有一个字符。字符数量为偶数的字符串没有中间字符；它有两个相邻的字符。考虑以下两个例子：
- en: '`String 1: 12`34`567`Odd number of characters'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`String 1: 12`34`567`字符数量为奇数'
- en: '`String 2: 123`45`678`Even number of characters'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`String 2: 123`45`678`字符数量为偶数'
- en: String 1 has an odd number of characters and 4 is the center. String 2 has an
    even number of characters, and 4 and 5 are on either side of the middle.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: String 1有奇数个字符，4是中心。String 2有偶数个字符，4和5位于中间的两侧。
- en: Suppose we are stepping through a string using two pointers, one at each end.
    As we step in from both sides, one pointer goes up and the other goes down. When
    we get to the middle, either the pointers are the same (odd length) or the pointers
    differ by one (even length).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用两个指针遍历一个字符串，每个指针位于一端。当我们从两端逐步接近时，一个指针向上移动，另一个指针向下移动。当我们到达中间时，指针要么相同（奇数长度），要么相差一个（偶数长度）。
- en: 'It would be nice to have a compare operation that compares two values and returns
    equality if either they are the same or if the second one differs from the first
    by +1\. The new instruction, `CMPT` (*compare together*), does this. For example,
    `CMPT` `r4,r6` sets the `z` bit to `1` if the contents of `r4` and `r6` are the
    same, or if the contents of `r4` are one less than the contents of `r6`. The code
    to do this is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个比较操作可以比较两个值，并在它们相同或第二个值比第一个值大1时返回相等，那将会很方便。新的指令`CMPT`（*比较一起*）就是这样做的。例如，`CMPT`
    `r4,r6`会将`z`位设置为`1`，如果`r4`和`r6`的内容相同，或者如果`r4`的内容比`r6`的内容少1。执行此操作的代码如下：
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As you can see, this performs two tests on the pointers, one for equality and
    one for higher by 1, and combines the test results using a Boolean `or` operator;
    that is, if the pointers are `x` and `y`, then the test is true `if x = y` is
    true or if `x + 1 = y` is true.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这执行了两个指针测试，一个是等于测试，另一个是加1的测试，并使用布尔`or`运算符组合测试结果；也就是说，如果指针是`x`和`y`，那么测试为真当`x
    = y`为真或者`x + 1 = y`为真。
- en: 'This instruction is not implemented in a real processor. Why not if it’s a
    great idea? Well, first, it would be used in only a small number of programs requiring
    this particular operation. It takes up silicon real estate on the chip that is
    hardly ever used. That’s a waste of precious resources. Second, machine code is
    mostly generated by compilers, and it’s not easy to design compilers that use
    special-purpose operations such as this effectively. Third, this instruction performs
    three operations: comparing `p` and `q`, adding 1 to `q`, comparing `p` and `q+1`.
    Consequently, it takes longer to execute than single-operation instructions. That
    reduces the efficiency of the computer.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令在真实处理器中并未实现。为什么一个很好的想法没有被实现呢？首先，它只会在需要这种特定操作的少数程序中使用。它占据了芯片上几乎从未使用的硅空间，这是一种资源的浪费。其次，机器代码主要是由编译器生成的，设计出能够有效使用这种特殊操作（如本例所示）的编译器并不容易。第三，这个指令执行了三个操作：比较`p`和`q`，将`q`加1，比较`p`和`q+1`。因此，它的执行时间比单操作指令长。这降低了计算机的效率。
- en: In the next section, you will be introduced to the notion of instructions with
    fields that have variable lengths. Real machines do not have this facility. The
    reason for including this section is to demonstrate instruction decoding and bit
    processing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解到具有可变长度字段的指令的概念。真实机器并不具备这种功能。包含这一节的原因是为了展示指令解码和位处理。
- en: Variable-length instructions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变长度指令
- en: This short section provides ideas for experimentation with instructions and
    their formats and extends your understanding of instructions, their structure,
    and the trade-off involved in creating instruction sets. It is not designed to
    illustrate a real computer.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节提供了关于实验指令及其格式的想法，并扩展了你对于指令、其结构和在创建指令集时涉及的权衡的理解。它并不是为了展示一个真实的计算机。
- en: Like many computers, TC1 has *fixed-length fields* in its opcode; that is, the
    number of bits dedicated to each field is fixed and does not vary from instruction
    to instruction. There are always 16 bits in the literal field, even if the current
    instruction does not require a literal. Wasteful indeed. Since the purpose of
    TC1 is experimentation, we demonstrate how you might make the number of registers
    variable (i.e., user-definable). Adding more registers speeds up computation by
    requiring fewer memory accesses. However, there is a price; where do you get the
    extra bits that would be needed to specify the registers? Do you take the extra
    register bits from the opcode field (reducing the number of different instructions),
    or do you take them from the literal field (reducing the maximum size of a literal
    that can be loaded in a single instruction)? Or do you implement multiple banks
    of registers and switch in a new set of registers (called *windowing*) as a temporary
    measure?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多计算机一样，TC1的指令码中有*固定长度的字段*；也就是说，每个字段分配的位数是固定的，并且不会随指令而变化。字面量字段始终有16位，即使当前指令不需要字面量也是如此。确实很浪费。由于TC1的目的是实验，我们展示了如何使寄存器的数量可变（即用户定义）。增加更多的寄存器可以通过减少内存访问次数来加速计算。然而，这也有代价；你从哪里获得指定寄存器所需的额外位？你是从指令码字段中取出额外的寄存器位（减少不同指令的数量），还是从字面量字段中取出（减少单条指令中可以加载的最大字面量大小）？或者你实现多个寄存器组，并临时切换到新的寄存器集（称为*分页*）？
- en: Here, we provide some code that we used to experiment with variable register
    sizes. This is not a complete program. All it does is let you enter the size of
    register fields and then run a test by creating a *dummy* instruction. It’s a
    dummy instruction because the opcode is set to `1111110` and the literal field
    is all zeros. It just tests the ability to place the register fields at appropriate
    points in an instruction and automatically adjust the length of the literal field.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一些用于实验可变寄存器大小的代码。这不是一个完整的程序。它所做的只是让你输入寄存器字段的尺寸，然后通过创建一个*虚拟*指令来运行测试。这是一个虚拟指令，因为指令码被设置为
    `1111110`，字面量字段全部为零。它只是测试了在指令中适当位置放置寄存器字段并自动调整字面量字段长度的能力。
- en: '*Figure 7**.2* provides the output of a single run of this program. The inputs
    are in bold. You can see that the register fields have been selected as 3, 3,
    and 5 bits wide. The instruction is `ADD R7,R2,R31` (note that the only data extracted
    is `7`, `2`, and `31`, as we are not interested in the actual instruction):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2* 提供了该程序单次运行的输出。输入项以粗体显示。你可以看到寄存器字段已被选为3位、3位和5位宽。指令是 `ADD R7,R2,R31`（注意，我们只提取了
    `7`、`2` 和 `31`，因为我们对实际的指令不感兴趣）：'
- en: '![Figure 7.2 – Demonstration of variable-length fields](img/Figure_7.2_B19624.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 变长字段演示](img/Figure_7.2_B19624.jpg)'
- en: Figure 7.2 – Demonstration of variable-length fields
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 变长字段演示
- en: The final binary instruction is given with each of its fields in a different
    style for clarity. You can see that the register fields have been placed in the
    correct positions in the instruction and the remaining bits (the literal field)
    are padded with zeros.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的二进制指令以不同的样式给出，以便于清晰。你可以看到寄存器字段已放置在指令的正确位置，而剩余的位（字面量字段）用零填充。
- en: 'It may seem strange to have register fields of different widths. That means
    that some parameters in an instruction can access more registers than others.
    Such a facility can be useful; for example, you could use some of the registers
    as special-purpose registers (e.g., a stack pointer), or they could be used to
    hold frequently accessed constants (such as `0`, `1`, or `2`):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎拥有不同宽度的寄存器字段有些奇怪。这意味着指令中的某些参数可以访问比其他参数更多的寄存器。这种功能可能很有用；例如，你可以将一些寄存器用作专用寄存器（例如，栈指针），或者它们可以用来存储频繁访问的常量（例如
    `0`、`1` 或 `2`）：
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Running this code with some sample values gives the following output (*Figure
    7**.3*). As you can see, the register files have been inserted into the opcode:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些示例值运行此代码会得到以下输出（*图7.3*）。正如你所见，寄存器文件已被插入到指令码中：
- en: '[PRE91]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![Figure 7.3 – Demonstration of variable-length operand fields](img/Figure_7.3_B19624.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 变长操作数字段演示](img/Figure_7.3_B19624.jpg)'
- en: Figure 7.3 – Demonstration of variable-length operand fields
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 变长操作数字段演示
- en: A variable-length instruction machine
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变长指令机器
- en: 'Throughout this text, we have demonstrated machines with fixed-length instruction
    words. Computers based on this paradigm frequently fall into the RISC category.
    However, classic CISC machines (from the humble 8080 and 6800 to the less humble
    8086 and 68000 microprocessors) had variable-length instructions, as we’ve already
    pointed out. Consider the following example of a stream of variable-length instructions,
    where `1` represents a 1-word instruction, `2` represents a 2-word instruction,
    and so on (*Figure 7**.4*):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们已经展示了具有固定长度指令字的机器。基于这种范例的计算机通常属于RISC类别。然而，经典的CISC机器（从朴素的8080和6800到不那么朴素的8086和68000微处理器）具有可变长度的指令，正如我们之前已经指出的。考虑以下可变长度指令流的示例，其中`1`代表1个字长的指令，`2`代表2个字长的指令，依此类推（*图7.4*）：
- en: '![Figure 7.4 – Instruction stream with variable-length opcodes](img/Figure_7.4_B19624.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.4 – 指令流的可变长度操作码](img/Figure_7.4_B19624.jpg)'
- en: Figure 7.4 – Instruction stream with variable-length opcodes
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 指令流的可变长度操作码
- en: As instructions are executed, they must be decoded and the appropriate number
    of bytes appended to the current instruction. A problem with this approach is
    that it makes look-ahead processing difficult because you do not know where future
    instructions begin and end until you’ve decoded the current instruction.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当指令执行时，它们必须被解码，并将适当数量的字节附加到当前指令。这种方法的一个问题是它使得前瞻处理变得困难，因为你不知道未来的指令从哪里开始和结束，直到你解码了当前指令。
- en: Here, we’re going to demonstrate a very simple variable-length machine that
    uses 8-bit words and an instruction can be 8, 16, 24, or 32 bits long. An operation
    like `nop` is 8 bits, `branch` is 16 bits, `move` is 24 bits, and `add` is 32
    bits. The instruction itself is 8 bits (in the demonstration, we use only 5 bits
    for simplicity). An instruction is read and the two most-significant bits determine
    the total number of bytes required by this instruction.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将演示一个非常简单的使用8位字和指令长度可以是8、16、24或32位的可变长度机器。例如，`nop`指令是8位，`branch`指令是16位，`move`指令是24位，`add`指令是32位。指令本身是8位（在演示中，我们为了简单起见只使用了5位）。指令被读取，并且两个最高有效位确定该指令所需的字节数。
- en: The number of registers used by this machine is … none! For the sake of simplicity,
    and fun, we decided to make all instructions memory-based.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此机器使用的寄存器数量……没有！为了简单和有趣，我们决定使所有指令基于内存。
- en: 'Consequently, we need two counters: one that counts the instructions and one
    that counts the bytes. For example, the instruction sequence in *Table 7.1* demonstrates
    the *instruction address* (sequential) and the *memory address* of the first byte
    of an instruction. Here, instructions vary from 1 byte (`stop`) to 4 bytes (`add`):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要两个计数器：一个用于计数指令，另一个用于计数字节。例如，*表7.1*中的指令序列演示了*指令地址*（顺序）和指令第一个字节的*内存地址*。在这里，指令从1字节（`stop`）到4字节（`add`）不等：
- en: '| **Code** | **Instruction address** | **Memory address** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **指令地址** | **内存地址** |'
- en: '| --- | --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ld``28,7` | `0` | 0 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `ld``28,7` | `0` | 0 |'
- en: '| `ld``27,2` | `1` | 3 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `ld``27,2` | `1` | 3 |'
- en: '| `ld``26,1` | `2` | 6 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `ld``26,1` | `2` | 6 |'
- en: '| `add 28,28,26` | `3` | 9 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `add 28,28,26` | `3` | 9 |'
- en: '| `dec 26` | `4` | 13 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `dec 26` | `4` | 13 |'
- en: '| `bne 3` | `5` | 15 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `bne 3` | `5` | 15 |'
- en: '| `stop` | `6` | 17 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | `6` | 17 |'
- en: '| Next free space | `7` | `18` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 下一个空闲空间 | `7` | `18` |'
- en: Table 7.1 – Instruction and memory addresses for variable-length code
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – 可变长度代码的指令和内存地址
- en: Here, we have used simple numeric addresses. Some addresses are literal bytes;
    for example, `ld 28,7` means load memory location `28` with the number `7`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了简单的数字地址。一些地址是字面字节；例如，`ld 28,7`表示将内存位置`28`加载为数字`7`。
- en: 'The following code provides a program to implement such a computer. Note that
    the actual program is supplied as a list. This program does not have the textual
    flexibility of TC1; it’s a simple demonstration. An instruction is entered in
    lowercase text with commas separating the parameters. All values are in decimal.
    However, limited symbolic names are permitted; for example, `abc: equ 12` binds
    the number `12` to the symbolic name `abc:`. Note the need for a colon after the
    name.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码提供了一个实现此类计算机的程序。请注意，实际程序以列表形式提供。此程序没有TC1的文本灵活性；它是一个简单的演示。指令以小写文本输入，参数之间用逗号分隔。所有值均为十进制。然而，允许有限的符号名称；例如，`abc:
    equ 12`将数字`12`绑定到符号名称`abc:`。注意名称后面需要冒号。'
- en: All data is either a number or a memory address; for example, `add 12,13,20`
    adds the contents of memory location `13` to the contents of memory location `20`
    and puts the sum in memory location `12`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据要么是数字，要么是内存地址；例如，`add 12,13,20`将内存位置`13`的内容加到内存位置`20`的内容上，并将和放入内存位置`12`。
- en: A branch requires an actual address. Branching is absolute (direct) and not
    program counter-relative. To branch to the instruction beginning at address `16`,
    you write `bra 16`. However, symbolic names are supported and you can write `bra
    abc:`, provided that the target is labeled with `abc:`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分支需要一个实际的地址。分支是绝对的（直接）的，而不是程序计数器相关的。要分支到地址`16`开始的指令，你写下`bra 16`。然而，支持符号名称，你可以写`bra
    abc:`，前提是目标被标记为`abc:`。
- en: In this simulator, the instruction counter is incremented by one every time
    a new instruction is read. However, the memory counter is incremented every time
    a new byte is added to this instruction. The added bytes may be 1, 2, 3, or 4.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模拟器中，每当读取一个新的指令时，指令计数器增加一。然而，每当向这个指令添加一个新的字节时，内存计数器就会增加。添加的字节可能是1、2、3或4。
- en: 'Since you have to give a byte branch address, you not only have to count the
    number of instructions branched but also the number of bytes branched. To do this,
    we create a mapping table that maps the instruction address to the byte address.
    This table is called `map[]`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你必须给出一个字节分支地址，你不仅必须计算分支的指令数量，还要计算分支的字节数。为此，我们创建一个映射表，将指令地址映射到字节地址。这个表被称为`map[]`：
- en: '[PRE92]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `lookUp{}` dictionary describes each instruction with a binary key and
    a value consisting of a mnemonic. The `allOps{}` dictionary consists of a key
    (the mnemonic) and a tuple containing the instruction length and opcode:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookUp{}`字典使用二进制键和由助记符组成的值来描述每个指令。`allOps{}`字典由一个键（助记符）和一个包含指令长度和操作码的元组组成：'
- en: '[PRE94]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The next step after removing equates is to clean up the source code and deal
    with labels:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除等价项之后的下一步是清理源代码并处理标签：
- en: '[PRE95]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We now go through the code, but not in execution mode. We create a memory counter,
    mc, that acts rather like a program counter but serves to keep track of the instructions
    in memory:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遍历代码，但不是在执行模式下。我们创建一个内存计数器，mc，它作用类似于程序计数器，但用于跟踪内存中的指令：
- en: '[PRE96]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now we can execute the code by stepping through the instructions in memory
    using a program counter. However, the program counter is incremented by the length
    of each instruction after the current instruction has been read:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用程序计数器逐步通过内存中的指令来执行代码。然而，程序计数器是在读取当前指令之后根据每个指令的长度增加的：
- en: '[PRE98]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'After looking up the opcode, we use an `if...elif` construct to examine successive
    mnemonics to determine the current operation. Note the dummy no-operation is implemented
    by Python’s pass, which does nothing:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找操作码之后，我们使用`if...elif`结构来检查后续的助记符，以确定当前操作。注意，通过Python的pass实现的空操作被实现为不执行任何操作：
- en: '[PRE100]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `cmp` compare operation subtracts two operands and sets the z-bit to `1`
    if the result is zero. Otherwise, `z` is set to `0`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`比较操作从两个操作数中减去，如果结果是零，则将z位设置为`1`。否则，`z`被设置为`0`：'
- en: '[PRE101]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'At the end of the `execute` loop, we get input from the keyboard. This simply
    introduces a wait until the *Enter*/*return* key is hit before the next instruction
    is executed. The remaining Python code formats the output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`循环结束时，我们从键盘获取输入。这只是在执行下一个指令之前引入一个等待，直到按下*Enter*/*return*键。剩余的Python代码格式化输出：
- en: '[PRE102]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We have only briefly touched on the topic of variable-length instructions. In
    principle, it’s a very simple idea. An instruction is read, decoded, and executed.
    As each instruction is fetched into the computer, it has to be decoded and the
    program counter advanced by the number of words taken up by the current instruction.
    In practice, this creates problems because branch addresses are no longer just
    the number of instructions from the branch but also the number of memory locations
    taken up by those instructions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是简要地触及了可变长度指令的主题。原则上，这是一个非常简单的想法。指令被读取、解码和执行。随着每个指令被装入计算机，它必须被解码，程序计数器必须根据当前指令占用的字数前进。在实践中，这会产生问题，因为分支地址不再只是从分支到指令的数量，还包括这些指令占用的内存位置数量。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The previous chapter introduced TC1, a Python-based computer simulator that
    could be used to develop and test instruction set architectures. In this chapter,
    we explored aspects of simulator design in more depth.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了TC1，这是一个基于Python的计算机模拟器，可用于开发和测试指令集架构。在这一章中，我们更深入地探讨了模拟器设计方面的内容。
- en: We looked at how you can create new instructions and add them to TC1’s instruction
    set. Advanced instructions that perform a lot of special-purpose computation were
    once the province of the classic CISC processor, such as the Motorola 68K family.
    Then, with the rise of the RISC architecture and its stress on simplicity and
    single-cycle instructions, the CISC processor seemed about to go out of fashion.
    However, many modern computers have incorporated complex instructions for special
    applications such as data encoding, image processing, and AI applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何创建新的指令并将它们添加到TC1的指令集中。执行大量专用计算的先进指令曾经是经典CISC处理器的领域，例如摩托罗拉68K系列。然后，随着RISC架构的兴起及其对简单性和单周期指令的强调，CISC处理器似乎即将过时。然而，许多现代计算机已经集成了用于特殊应用（如数据编码、图像处理和人工智能应用）的复杂指令。
- en: We looked a little more deeply at how you can check the input of a simulator
    and ensure that errors in data and instructions can be detected.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更深入地研究了如何检查模拟器的输入并确保可以检测到数据和指令中的错误。
- en: We also looked at various topics in Python programming, such as data formatting.
    In principle, printing data the way you want it to look is easy. In practice,
    it is a little more complicated (not least because there are several methods of
    formatting data).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了Python编程的各个主题，例如数据格式化。原则上，以你想要的方式打印数据是很容易的。实际上，这要复杂一些（至少因为存在几种数据格式化的方法）。
- en: This chapter expanded on the notion of tracing a program while it is being executed
    and demonstrated some of the techniques involved in printing the data you want
    to see during a simulator run.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了在程序执行时跟踪程序的概念，并演示了在模拟器运行期间打印所需查看的数据所涉及的一些技术。
- en: As well as looking at new instructions, we explored the concept of variable-length
    instructions. We started with a demonstration of how you could change the number
    of bits in each register address field at runtime to change the number of addressable
    registers. This is not a realistic factor in instruction set design (at the moment),
    but there was a period when register windows became popular and you could, indeed,
    expand the number of registers.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看新的指令外，我们还探讨了可变长度指令的概念。我们从演示如何通过在运行时更改每个寄存器地址字段中的位数来改变可寻址寄存器的数量开始。这在指令集设计中（目前）不是一个现实的因素，但曾经有一段时间寄存器窗口变得流行，你确实可以扩展寄存器的数量。
- en: We introduced the notion of variable-length instructions when each instruction
    can be an integer number of multiples of the computer’s word length. This approach
    allows instructions with an unlimited level of complexity at the price of more
    complicated decoding mechanisms. We demonstrated the design of a primitive variable
    instruction length machine that could easily be expanded to a simulator with the
    full complexity of TC1.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当每条指令都可以是计算机字长整数倍时，我们引入了可变长度指令的概念。这种方法允许指令具有无限复杂的级别，但代价是更复杂的解码机制。我们演示了一种原始的可变指令长度机器的设计，它可以很容易地扩展到具有TC1完整复杂性的模拟器。
- en: The next chapter returns to the simulator and looks at several simulators for
    different types of architecture.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章回到模拟器，探讨了不同类型架构的几个模拟器。
