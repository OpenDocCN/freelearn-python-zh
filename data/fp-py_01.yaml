- en: Chapter 1. Introducing Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍函数式编程
- en: Functional programming defines a computation using expressions and evaluation—often
    encapsulated in function definitions. It de-emphasizes or avoids the complexity
    of state change and mutable objects. This tends to create programs that are more
    succinct and expressive. In this chapter, we'll introduce some of the techniques
    that characterize functional programming. We'll identify some of the ways to map
    these features to **Python**. Finally, we'll also address some ways in which the
    benefits of functional programming accrue when we use these design patterns to
    build Python applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程使用表达式和求值来定义计算，通常封装在函数定义中。它淡化或避免了状态变化和可变对象的复杂性。这往往会创建更简洁和表达力更强的程序。在本章中，我们将介绍一些表征函数式编程的技术。我们将确定一些将这些特性映射到**Python**的方法。最后，我们还将讨论一些使用这些设计模式构建Python应用程序时函数式编程的好处。
- en: Python has numerous functional programming features. It is not a purely functional
    programming language. It offers enough of the right kinds of features that it
    confers to the benefits of functional programming. It also retains all optimization
    power available from an imperative programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有许多函数式编程特性。它不是一个纯粹的函数式编程语言。它提供了足够多的正确类型的特性，使其具有函数式编程的好处。它还保留了从命令式编程语言中获得的所有优化能力。
- en: We'll also look at a problem domain that we'll use for many of the examples
    in this book. We'll try to stick closely to **Exploratory Data Analysis** (**EDA**)
    because its algorithms are often good examples of functional programming. Furthermore,
    the benefits of functional programming accrue rapidly in this problem domain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一个问题领域，我们将在本书的许多示例中使用它。我们将尽量紧密地遵循**探索性数据分析**（**EDA**），因为它的算法通常是函数式编程的很好的例子。此外，函数式编程的好处在这个问题领域中迅速积累。
- en: Our goal is to establish some essential principles of functional programming.
    The more serious Python code will begin in [Chapter 2](ch02.html "Chapter 2. Introducing
    Some Functional Features"), *Introducing Some Functional Features*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是建立一些函数式编程的基本原则。更严肃的Python代码将从[第2章](ch02.html "第2章 介绍一些函数式特性") *介绍一些函数式特性*开始。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll focus on Python 3 features in this book. However, some of the examples
    might also work in Python 2.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将专注于Python 3的特性。然而，一些示例也可能在Python 2中工作。
- en: Identifying a paradigm
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定一个范式
- en: 'It''s difficult to be definitive on what fills the universe of programming
    paradigms. For our purposes, we will distinguish between just two of the many
    programming paradigms: **Functional** **programming** and **Imperative** **programming**.
    One important distinguishing feature between these two is the concept of state.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确定编程范式的宇宙中填充了什么。对于我们的目的，我们将区分许多编程范式中的两种：**函数式编程**和**命令式编程**。这两者之间的一个重要区别是状态的概念。
- en: In an imperative language, like Python, the state of the computation is reflected
    by the values of the variables in the various namespaces. The values of the variables
    establish the state of a computation; each kind of statement makes a well-defined
    change to the state by adding or changing (or even removing) a variable. A language
    is imperative because each statement is a command, which changes the state in
    some way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式语言中，比如Python，计算的状态由各个命名空间中变量的值反映出来。变量的值建立了计算的状态；每种语句都通过添加、改变（甚至删除）变量来对状态进行明确定义的改变。一种语言是命令式的，因为每个语句都是一个命令，以某种方式改变状态。
- en: Our general focus is on the assignment statement and how it changes state. Python
    has other statements, such as `global` or `nonlocal`, which modify the rules for
    variables in a particular namespace. Statements like `def`, `class`, and `import`
    change the processing context. Other statements like `try`, `except`, `if`, `elif`,
    and `else` act as guards to modify how a collection of statements will change
    the computation's state. Statements like `for` and `while`, similarly, wrap a
    block of statements so that the statements can make repeated changes to the state
    of the computation. The focus of all these various statement types, however, is
    on changing the state of the variables.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一般重点是赋值语句以及它如何改变状态。Python还有其他语句，比如`global`或`nonlocal`，它们修改特定命名空间中变量的规则。像`def`、`class`和`import`这样的语句改变了处理上下文。其他语句，比如`try`、`except`、`if`、`elif`和`else`，作为守卫来修改一组语句如何改变计算状态。类似地，像`for`和`while`这样的语句包装了一块语句，以便这些语句可以重复地改变计算的状态。然而，所有这些不同类型的语句的重点都在于改变变量的状态。
- en: Ideally, each statement advances the state of the computation from an initial
    condition toward the desired final outcome. This "advances the computation" assertion
    can be challenging to prove. One approach is to define the final state, identify
    a statement that will establish this final state, and then deduce the precondition
    required for this final statement to work. This design process can be iterated
    until an acceptable initial state is derived.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个语句都会从初始条件推进计算状态，朝着期望的最终结果。这个“推进计算”断言可能很难证明。一种方法是定义最终状态，找到一个语句来建立这个最终状态，然后推断出这个最终语句需要的前提条件。这个设计过程可以迭代，直到得出一个可接受的初始状态。
- en: In a functional language, we replace state—the changing values of variables—with
    a simpler notion of evaluating functions. Each function evaluation creates a new
    object or objects from existing objects. Since a functional program is a composition
    of a function, we can design lower-level functions that are easy to understand,
    and we will design higher-level compositions that can also be easier to visualize
    than a complex sequence of statements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，我们用函数的评估来替换状态——变量的变化值。每个函数评估都会从现有对象创建一个新对象或多个对象。由于函数式程序是函数的组合，我们可以设计易于理解的低级函数，并且我们将设计更高级的组合，这些组合也可以比复杂的语句序列更容易可视化。
- en: Function evaluation more closely parallels mathematical formalisms. Because
    of this, we can often use simple algebra to design an algorithm, which clearly
    handles the edge cases and boundary conditions. This makes us more confident that
    the functions work. It also makes it easy to locate test cases for formal unit
    testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数评估更接近数学形式主义。因此，我们经常可以使用简单的代数来设计一个算法，清楚地处理边界情况和边界条件。这使我们更有信心函数能够正常工作。它还使得很容易找到正式单元测试的测试用例。
- en: It's important to note that functional programs tend to be relatively succinct,
    expressive, and efficient when compared to imperative (object-oriented or procedural)
    programs. The benefit isn't automatic; it requires a careful design. This design
    effort is often easier than functionally similar procedural programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，与命令式（面向对象或过程式）程序相比，函数式程序往往相对简洁、表达力强、高效。这种好处并不是自动的；它需要仔细的设计。这种设计工作通常比功能上类似的过程式编程更容易。
- en: Subdividing the procedural paradigm
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将过程式范例细分
- en: We can subdivide imperative languages into a number of discrete categories.
    In this section, we'll glance quickly at the procedural versus object-oriented
    distinction. What's important here is to see how object-oriented programming is
    a subset of imperative programming. The distinction between procedural and object-orientation
    doesn't reflect the kind of fundamental difference that functional programming
    represents.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将命令式语言细分为许多离散的类别。在本节中，我们将快速浏览过程式与面向对象的区别。重要的是要看到面向对象编程是命令式编程的一个子集。过程式和面向对象的区别并不反映函数式编程所代表的基本差异。
- en: We'll use code examples to illustrate the concepts. For some, this will feel
    like reinventing a wheel. For others, it provides a concrete expression of abstract
    concepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用代码示例来说明这些概念。对于一些人来说，这将感觉像是重复造轮子。对于其他人来说，这提供了对抽象概念的具体表达。
- en: 'For some kinds of computations, we can ignore Python''s object-oriented features
    and write simple numeric algorithms. For example, we might write something like
    the following to get the range of numbers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些计算，我们可以忽略Python的面向对象特性，编写简单的数值算法。例如，我们可以编写类似以下内容来获取数字范围：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've made this program strictly procedural, avoiding any explicit use of Python's
    object features. The program's state is defined by the values of the variables
    `s` and `n`. The variable, `n`, takes on values such that 1 ≤ `n` < 10\. As the
    `loop` involves an ordered exploration of values of `n`, we can prove that it
    will terminate when `n == 10`. Similar code would work in C or Java using their
    primitive (non-object) data types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使这个程序严格过程化，避免了对Python对象特性的显式使用。程序的状态由变量`s`和`n`的值定义。变量`n`取值使得1 ≤ `n` < 10。由于`loop`涉及对`n`值的有序探索，我们可以证明当`n
    == 10`时它将终止。类似的代码也可以在C或Java中使用它们的原始（非对象）数据类型。
- en: 'We can exploit **Python''s** **Object**-**Oriented** **Programming** (**OOP**)
    features and create a similar program:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用**Python**的**面向对象**编程（**OOP**）特性，创建一个类似的程序：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This program produces the same result but it accumulates a stateful collection
    object, `m`, as it proceeds. The state of the computation is defined by the values
    of the variables `m` and `n`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序产生了相同的结果，但它在进行过程中积累了一个有状态的集合对象`m`。计算的状态由变量`m`和`n`的值定义。
- en: The syntax of `m.append(n)` and `sum(m)` can be confusing. It causes some programmers
    to insist (wrongly) that Python is somehow not purely Object-oriented because
    it has a mixture of the `function()`and `object.method()` syntax. Rest assured,
    Python is purely Object-oriented. Some languages, like **C++**, allow the use
    of primitive data type such as `int`, `float`, and `long`, which are not objects.
    Python doesn't have these primitive types. The presence of prefix syntax doesn't
    change the nature of the language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`m.append(n)`和`sum(m)`的语法可能会让人感到困惑。这导致一些程序员错误地坚持认为Python在某种程度上不是纯粹的面向对象，因为它混合了`function()`和`object.method()`的语法。请放心，Python是纯粹的面向对象。一些语言，比如**C++**，允许使用诸如`int`、`float`和`long`之类的原始数据类型，这些类型不是对象。Python没有这些原始类型。前缀语法的存在并不改变语言的本质。'
- en: 'To be pedantic, we could fully embrace the object model, the subclass, the
    `list` class, and add a `sum` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要严谨一些，我们可以完全拥抱对象模型，子类，`list`类，并添加一个`sum`方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we initialize the variable, `m`, with the `SummableList()` class instead
    of the `list()` method, we can use the `m.sum()` method instead of the `sum(m)`
    method. This kind of change can help to clarify the idea that Python is truly
    and completely object-oriented. The use of prefix function notation is purely
    syntactic sugar.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`SummableList()`类而不是`list()`方法初始化变量`m`，我们可以使用`m.sum()`方法而不是`sum(m)`方法。这种改变有助于澄清Python确实是完全面向对象的想法。前缀函数表示法的使用纯粹是一种语法糖。
- en: All three of these examples rely on variables to explicitly show the state of
    the program. They rely on the `assignment` statements to change the values of
    the variables and advance the computation toward completion. We can insert the
    `assert` statements throughout these examples to demonstrate that the expected
    state changes are implemented properly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个例子都依赖于变量来明确显示程序的状态。它们依赖于`assignment`语句来改变变量的值，并推进计算向完成的方向。我们可以在这些例子中插入`assert`语句来证明预期的状态变化被正确实现。
- en: The point is not that imperative programming is broken in some way. The point
    is that functional programming leads to a change in viewpoint, which can, in many
    cases, be very helpful. We'll show a function view of the same algorithm. Functional
    programming doesn't make this example dramatically shorter or faster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重点不在于命令式编程在某种程度上有问题。重点在于函数式编程导致了观点的改变，这在许多情况下可能非常有帮助。我们将展示相同算法的函数视图。函数式编程并不会使这个例子变得更短或更快。
- en: Using the functional paradigm
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用功能范式
- en: 'In a functional sense, the sum of the multiples of 3 and 5 can be defined in
    two parts:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能的角度来看，3和5的倍数之和可以分为两部分：
- en: The sum of a sequence of numbers
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数字的和
- en: A sequence of values that pass a simple test condition, for example, being multiples
    of three and five
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列通过简单测试条件的值，例如，是3和5的倍数
- en: 'The sum of a sequence has a simple, recursive definition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的和有一个简单的递归定义：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve defined the sum of a sequence in two cases: the **base** **case** states
    that the sum of a zero length sequence is 0, while the **recursive** **case**
    states that the sum of a sequence is the first value plus the sum of the rest
    of the sequence. Since the recursive definition depends on a shorter sequence,
    we can be sure that it will (eventually) devolve to the base case.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两种情况下序列的和：**基本情况**表明长度为零的序列的和为0，而**递归情况**表明序列的和是第一个值加上剩余序列的和。由于递归定义依赖于一个更短的序列，我们可以确定它最终会退化为基本情况。
- en: The `+` operator on the last line of the preceding example and the initial value
    of 0 in the base case characterize the equation as a sum. If we change the operator
    to `*` and the initial value to 1, it would just as easily compute a product.
    We'll return to this simple idea of generalization in the following chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面例子的最后一行上的`+`运算符和基本情况中的初始值0将方程式刻画为一个和。如果我们将运算符改为`*`并将初始值改为1，它同样可以轻松地计算出一个乘积。我们将在接下来的章节中回到这个泛化的简单想法。
- en: 'Similarly, a sequence of values can have a simple, recursive definition, as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一系列值可以有一个简单的递归定义，如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this function, we've compared a given value, `v`, against the upper bound,
    `n`. If `v` reaches the upper bound, the resulting list must be empty. This is
    the base case for the given recursion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将给定的值`v`与上限`n`进行比较。如果`v`达到上限，结果列表必须为空。这是给定递归的基本情况。
- en: There are two more cases defined by the given `filter_func()` function. If the
    value of `v` is passed by the `filter_func()` function, we'll create a very small
    list, containing one element, and append the remaining values of the `until()`
    function to this list. If the value of `v` is rejected by the `filter_func()`
    function, this value is ignored and the result is simply defined by the remaining
    values of the `until()` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`filter_func()`函数定义了另外两种情况。如果`v`的值被`filter_func()`函数传递，我们将创建一个非常小的列表，包含一个元素，并将`until()`函数的剩余值附加到这个列表。如果`v`的值被`filter_func()`函数拒绝，这个值将被忽略，结果将简单地由`until()`函数的剩余值定义。
- en: We can see that the value of `v` will increase from an initial value until it
    reaches `n`, assuring us that we'll reach the base case soon.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`v`的值将从初始值增加，直到达到`n`，确保我们很快就会达到基本情况。
- en: 'Here''s how we can use the `until()` function to generate the multiples of
    3 or 5\. First, we''ll define a handy `lambda` object to filter values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`until()`函数来生成3或5的倍数。首先，我们将定义一个方便的`lambda`对象来过滤值：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (We will use lambdas to emphasize succinct definitions of simple functions.
    Anything more complex than a one-line expression requires the `def` statement.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将使用lambda来强调简单函数的简洁定义。任何比一行表达式更复杂的东西都需要`def`语句。）
- en: 'We can see how this lambda works from the command prompt in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令提示符中看到这个lambda是如何工作的，以下是一个例子：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function can be used with the `until()` function to generate a sequence
    of values, which are multiples of 3 or 5.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以与`until()`函数一起使用，生成一系列值，这些值是3或5的倍数。
- en: 'The `until()` function for generating a sequence of values works as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`until()`函数用于生成一系列值的工作如下：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use our recursive `sum()` function to compute the sum of this sequence
    of values. The various functions, such as `sum()`, `until()`, and `mult_3_5()`
    are defined as simple recursive functions. The values are computed without restoring
    to use intermediate variables to store state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的递归`sum()`函数来计算这些值的和。各种函数，如`sum()`，`until()`和`mult_3_5()`都被定义为简单的递归函数。这些值是在不恢复使用中间变量来存储状态的情况下计算出来的。
- en: We'll return to the ideas behind this purely functional recursive function definition
    in several places. It's important to note here that many functional programming
    language compilers can optimize these kinds of simple recursive functions. Python
    can't do the same optimizations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几个地方回到这个纯函数递归函数定义的思想。这里重要的是要注意，许多函数式编程语言编译器可以优化这些简单的递归函数。Python无法进行相同的优化。
- en: Using a functional hybrid
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用一个功能混合
- en: 'We''ll continue this example with a mostly functional version of the previous
    example to compute the sum of the multiples of 3 and 5\. Our **hybrid** functional
    version might look like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续这个例子，使用前一个例子的大部分功能版本来计算3和5的倍数的和。我们的**混合**功能版本可能如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've used **nested** **generator** **expressions** to iterate through a collection
    of values and compute the sum of these values. The `range(1, 10)` method is an
    iterable and, consequently, a kind of generator expression; it generates a sequence
    of values ![Using a functional hybrid](graphics/B03652_01_01.jpg). The more complex
    expression, `n for n in range(1, 10) if n%3==0 or n%5==0`, is also an iterable
    expression. It produces a set of values ![Using a functional hybrid](graphics/B03652_01_02.jpg).
    A variable, `n`, is bound to each value, more as a way of expressing the contents
    of the set than as an indicator of the state of the computation. The `sum()` function
    consumes the iterable expression, creating a final object, 23.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用**嵌套**的**生成器****表达式**来迭代一系列值并计算这些值的和。`range(1, 10)`方法是一个可迭代的，因此也是一种生成器表达式；它生成一系列值![Using
    a functional hybrid](graphics/B03652_01_01.jpg)。更复杂的表达式，`n for n in range(1, 10)
    if n%3==0 or n%5==0`，也是一个可迭代表达式。它产生一组值![Using a functional hybrid](graphics/B03652_01_02.jpg)。一个变量`n`绑定到每个值，更像是一种表达集合内容的方式，而不是计算状态的指示器。`sum()`函数消耗可迭代表达式，创建一个最终对象，23。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The bound variable doesn't change once a value is bound to it. The variable,
    `n`, in the loop is essentially a shorthand for the values available from the
    `range()` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个值绑定到变量上，绑定变量就不会改变。循环中的变量`n`本质上是`range()`函数可用值的简写。
- en: The `if` clause of the expression can be extracted into a separate function,
    allowing us to easily repurpose this with other rules. We could also use a higher-order
    function named `filter()` instead of the `if` clause of the generator expression.
    We'll save this for [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"),
    *Higher-order Functions*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的`if`子句可以提取到一个单独的函数中，这样我们就可以轻松地将其用于其他规则。我们还可以使用一个名为`filter()`的高阶函数，而不是生成器表达式的`if`子句。我们将这个留到[第5章](ch05.html
    "第5章。高阶函数")，*高阶函数*。
- en: 'As we work with generator expressions, we''ll see that the bound variable is
    at the blurry edge of defining the state of the computation. The variable, `n`,
    in this example isn''t directly comparable to the variable, `n`, in the first
    two imperative examples. The `for` statement creates a proper variable in the
    local namespace. The generator expression does not create a variable in the same
    way as a `for` statement does:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用生成器表达式时，我们会发现绑定变量处于定义计算状态的模糊边缘。在这个例子中，变量`n`并不直接可比较前两个命令式例子中的变量`n`。`for`语句在本地命名空间中创建一个适当的变量。生成器表达式不会像`for`语句那样创建一个变量：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because of the way Python uses namespaces, it might be possible to write a function
    that can observe the `n` variable in a generator expression. However, we won't.
    Our objective is to exploit the functional features of Python, not to detect how
    those features have an object-oriented implementation under the hood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python使用命名空间的方式，可能可以编写一个函数来观察生成器表达式中的`n`变量。但我们不会这样做。我们的目标是利用Python的函数式特性，而不是检测这些特性在底层是如何实现的。
- en: Looking at object creation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看看对象的创建
- en: In some cases, it might help to look at intermediate objects as a history of
    the computation. What's important is that the history of a computation is not
    fixed. When functions are commutative or associative, then changes to the order
    of evaluation might lead to different objects being created. This might have performance
    improvements with no changes to the correctness of the results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，查看中间对象作为计算的历史可能有所帮助。重要的是计算的历史并不是固定的。当函数是可交换的或者是可结合的时，对评估顺序的更改可能导致创建不同的对象。这可能会在不改变结果的正确性的情况下带来性能改进。
- en: 'Consider this expression:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个表达式：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are looking at a variety of potential computation histories with the same
    result. Because the `+` operator is commutative and associative, there are a large
    number of candidate histories that lead to the same result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在研究多种潜在的计算历史，但结果相同。因为`+`运算符是可交换和可结合的，有大量的候选历史可以导致相同的结果。
- en: 'Of the candidate sequences, there are two important alternatives, which are
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在候选序列中，有两个重要的替代方案，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first case, we fold in values working from left to right. This is the
    way Python works implicitly. Intermediate objects 3 and 6 are created as part
    of this evaluation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们从左到右折叠值。这是Python隐式工作的方式。中间对象3和6是作为这个评估的一部分创建的。
- en: In the second case, we fold from right-to-left. In this case, intermediate objects
    7 and 9 are created. In the case of simple integer arithmetic, the two results
    have identical performance; there's no optimization benefit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们从右到左折叠。在这种情况下，中间对象7和9被创建。在简单的整数算术情况下，这两个结果的性能是相同的；没有优化的好处。
- en: When we work with something like the `list` append, we might see some optimization
    improvements when we change the association rules.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类似`list` append的东西时，当我们改变关联规则时，可能会看到一些优化改进。
- en: 'Here''s a simple example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, there's some benefit in working from left to right.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从左到右工作有一些好处。
- en: What's important for functional design is the idea that the `+` operator (or
    `add()` function) can be used in any order to produce the same results. The `+`
    operator has no hidden side effects that restrict the way this operator can be
    used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数式设计来说，重要的是`+`运算符（或`add()`函数）可以以任何顺序使用来产生相同的结果。`+`运算符没有隐藏的副作用，限制了该运算符的使用方式。
- en: The stack of turtles
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乌龟的堆栈
- en: When we use Python for functional programming, we embark down a path that will
    involve a hybrid that's not strictly functional. Python is not **Haskell**, **OCaml**,
    or **Erlang**. For that matter, our underlying processor hardware is not functional;
    it's not even strictly object-oriented—CPUs are generally procedural.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Python进行函数式编程时，我们踏上了一条不严格函数式的混合路径。Python不是Haskell、OCaml或Erlang。同样，我们的底层处理器硬件也不是函数式的；它甚至不是严格的面向对象的——CPU通常是过程式的。
- en: '|   | *All programming languages rest on abstractions, libraries, frameworks
    and virtual machines. These abstractions, in turn, may rely on other abstractions,
    libraries, frameworks and virtual machines. The most apt metaphor is this: the
    world is carried on the back of a giant turtle. The turtle stands on the back
    of another giant turtle. And that turtle, in turn, is standing on the back of
    yet another turtle.**It''s turtles all the way down.* |   |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   | *所有编程语言都依赖于抽象、库、框架和虚拟机。这些抽象反过来又可能依赖于其他抽象、库、框架和虚拟机。最恰当的比喻是：世界是由一只巨大的乌龟背负着的。这只乌龟站在另一只巨大的乌龟背上。而那只乌龟又站在另一只乌龟的背上。**这是无穷无尽的乌龟。*
    |   |'
- en: '|   | --*Anonymous     * |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   | --*匿名     * |'
- en: There's no practical end to the layers of abstractions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层次没有实际的终点。
- en: More importantly, the presence of abstractions and virtual machines doesn't
    materially change our approach to designing software to exploit the functional
    programming features of Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，抽象和虚拟机的存在并不会实质性地改变我们利用Python的函数式编程特性来设计软件的方法。
- en: Even within the functional programming community, there are more pure and less
    pure functional programming languages. Some languages make extensive use of `monads`
    to handle stateful things like filesystem input and output. Other languages rely
    on a hybridized environment that's similar to the way we use Python. We write
    software that's generally functional with carefully chosen procedural exceptions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在函数式编程社区内，也有更纯净和不那么纯净的函数式编程语言。一些语言广泛使用`monads`来处理像文件系统输入和输出这样的有状态的事物。其他语言依赖于类似于我们使用Python的混合环境。我们编写的软件通常是功能性的，但有精心选择的程序性例外。
- en: 'Our functional Python programs will rely on the following three stacks of abstractions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数式Python程序将依赖以下三个抽象层次的堆栈：
- en: Our applications will be functions—all the way down—until we hit the objects
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序将是函数——一直到最后都是对象
- en: The underlying Python runtime environment that supports our functional programming
    is objects—all the way down—until we hit the turtles
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持我们函数式编程的底层Python运行时环境是对象——一直到最后都是对象
- en: The libraries that support Python are a turtle on which Python stands
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Python的库是Python所依赖的一个对象
- en: The operating system and hardware form their own stack of turtles. These details
    aren't relevant to the problems we're going to solve.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和硬件构成了它们自己的一堆对象。这些细节与我们要解决的问题无关。
- en: A classic example of functional programming
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的一个经典例子
- en: As part of our introduction, we'll look at a classic example of functional programming.
    This is based on the classic paper *Why Functional Programming Matters* by John
    Hughes. The article appeared in a paper called *Research Topics in Functional
    Programming*, edited by D. Turner, published by Addison-Wesley in 1990.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们介绍的一部分，我们将看一个函数式编程的经典例子。这是基于约翰·休斯的经典论文*为什么函数式编程很重要*。这篇文章发表在一篇名为*Research
    Topics in Functional Programming*的论文中，由D. Turner编辑，1990年由Addison-Wesley出版。
- en: 'Here''s a link to the paper *Research Topics in Functional Programming*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一篇关于函数式编程的论文*Research Topics in Functional Programming*的链接：
- en: '[http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)'
- en: 'This discussion of functional programming in general is profound. There are
    several examples given in the paper. We''ll look at just one: the Newton-Raphson
    algorithm for locating the roots of a function. In this case, the function is
    the square root.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于函数式编程的讨论是深刻的。论文中给出了几个例子。我们只看一个：用于定位函数的根的牛顿-拉弗森算法。在这种情况下，函数是平方根。
- en: It's important because many versions of this algorithm rely on the explicit
    state managed via `loops`. Indeed, the Hughes paper provides a snippet of the
    **Fortran** code that emphasizes stateful, imperative processing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为这个算法的许多版本都依赖于通过“循环”管理的显式状态。事实上，休斯的论文提供了一段强调有状态的命令式处理的**Fortran**代码片段。
- en: 'The backbone of this approximation is the calculation of the next approximation
    from the current approximation. The `next_()` function takes `x`, an approximation
    to the `sqrt(n)` method and calculates a next value that brackets the proper root.
    Take a look at the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个近似的基础是从当前近似值计算下一个近似值。`next_()`函数接受`x`，一个`sqrt(n)`方法的近似值，并计算一个下一个值，该值将包围正确的根。看下面的例子：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function computes a series of values ![A classic example of functional
    programming](graphics/B03652_01_03.jpg). The distance between the values is halved
    each time, so they'll quickly get to converge on the value such that![A classic
    example of functional programming](graphics/B03652_01_04.jpg), which means ![A
    classic example of functional programming](graphics/B03652_01_05.jpg). We don't
    want to call the method `next()` because this name would collide with a built-in
    function. We call it the `next_()` method so that we can follow the original presentation
    as closely as possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算一系列值。每次值之间的距离减半，所以它们很快就会收敛到这样一个值，使得![A classic example of functional programming](graphics/B03652_01_04.jpg)，这意味着![A
    classic example of functional programming](graphics/B03652_01_05.jpg)。我们不想调用`next()`方法，因为这个名称会与内置函数冲突。我们将其称为`next_()`方法，以便我们尽可能地遵循原始的演示。
- en: 'Here''s how the function looks when used in the command prompt:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当在命令提示符中使用该函数时，它的样子是这样的：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve defined the `f()` method as a `lambda` that will converge on ![A classic
    example of functional programming](graphics/B03652_01_06.jpg). We started with
    1.0 as the initial value for ![A classic example of functional programming](graphics/B03652_01_07.jpg).
    Then we evaluated a sequence of recursive evaluations: ![A classic example of
    functional programming](graphics/B03652_01_08.jpg), ![A classic example of functional
    programming](graphics/B03652_01_09.jpg) and so on. We evaluated these functions
    using a generator expression so that we could round off each value. This makes
    the output easier to read and easier to use with `doctest`. The sequence appears
    to converge rapidly on ![A classic example of functional programming](graphics/B03652_01_06.jpg).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`f()`方法定义为一个`lambda`，它将收敛到![A classic example of functional programming](graphics/B03652_01_06.jpg)。我们从1.0开始作为![A
    classic example of functional programming](graphics/B03652_01_07.jpg)的初始值。然后我们评估了一系列递归评估：![A
    classic example of functional programming](graphics/B03652_01_08.jpg)，![A classic
    example of functional programming](graphics/B03652_01_09.jpg)等等。我们使用生成器表达式来评估这些函数，这样我们可以四舍五入每个值。这样输出更容易阅读，并且更容易与`doctest`一起使用。这个序列似乎很快就会收敛到![A
    classic example of functional programming](graphics/B03652_01_06.jpg)。
- en: 'We can write a function, which will (in principle) generate an infinite sequence
    of ![A classic example of functional programming](graphics/B03652_01_10.jpg)values
    converging on the proper square root:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数，它（原则上）会生成一个无限序列的值，这些值会收敛到正确的平方根：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will generate approximations using a function, `f()`, and an initial
    value, `a`. If we provide the `next_()` function defined earlier, we'll get a
    sequence of approximations to the square root of the `n` argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将使用函数`f()`和初始值`a`生成近似值。如果我们提供之前定义的`next_()`函数，我们将得到一个近似于`n`参数的平方根的序列。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `repeat()` function expects the `f()` function to have a single argument,
    however, our `next_()` function has two arguments. We can use a `lambda` object,
    `lambda x: next_(n, x)`, to create a partial version of the `next_()` function
    with one of two variables bound.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数期望`f()`函数有一个参数，然而我们的`next_()`函数有两个参数。我们可以使用一个`lambda`对象`lambda
    x: next_(n, x)`来创建`next_()`函数的一个部分版本，其中一个变量被绑定。'
- en: The Python generator functions can't be trivially recursive, they must explicitly
    iterate over the recursive results, yielding them individually. Attempting to
    use a simple `return repeat(f, f(a))` will end the iteration, returning a generator
    expression instead of yielding the sequence of values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python生成器函数不能简单地递归，它们必须显式地迭代递归结果，逐个产生它们。尝试使用简单的`return repeat(f, f(a))`将结束迭代，返回一个生成器表达式而不是产生值的序列。
- en: 'We have two ways to return all the values instead of returning a generator
    expression, which are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以返回所有的值，而不是返回一个生成器表达式，如下所示：
- en: 'We can write an explicit `for` `loop` as follows:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式编写显式的`for`循环：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use the `yield` `from` statement as follows:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`yield from`语句如下：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both techniques of yielding the values of a recursive generator function are
    equivalent. We'll try to emphasize `yield from`. In some cases, however, the `yield`
    with a complex expression will be more clear than the equivalent mapping or generator
    expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 递归生成器函数产生值的两种技术是等价的。我们将尝试强调`yield from`。然而，在某些情况下，带有复杂表达式的`yield`会比等价的映射或生成器表达式更清晰。
- en: Of course, we don't want the entire infinite sequence. We will stop generating
    values when two values are so close to each other that we can call either one
    the square root we're looking for. The common symbol for the value, which is close
    enough, is the Greek letter **Epsilon**, **ε**, which can be thought of as the
    largest error we will tolerate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望整个无限序列。当两个值非常接近时，我们将停止生成值，这样我们可以称其中一个为我们正在寻找的平方根。接近的值的常用符号是希腊字母**Epsilon**，**ε**，它可以被认为是我们将容忍的最大误差。
- en: 'In Python, we''ll have to be a little clever about taking items from an infinite
    sequence one at a time. It works out well to use a simple interface function that
    wraps a slightly more complex recursion. Take a look at the following code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们需要对从无限序列中取出项的方法进行一些巧妙的处理。使用一个简单的接口函数来包装稍微复杂的递归是很好的。看一下以下代码片段：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've defined an internal function, `head_tail()`, which accepts the tolerance,
    `ε`, an item from the iterable sequence, `a`, and the rest of the iterable sequence,
    `iterable`. The next item from the `iterable` bound to a name `b`. If ![A classic
    example of functional programming](graphics/B03652_01_11.jpg), then the two values
    that are close enough together that we've found the square root. Otherwise, we
    use the `b` value in a recursive invocation of the `head_tail()` function to examine
    the next pair of values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个内部函数`head_tail()`，它接受公差`ε`、可迭代序列中的一个项`a`和可迭代序列的其余部分`iterable`。从`iterable`中绑定到名称`b`的下一个项。如果![A
    classic example of functional programming](graphics/B03652_01_11.jpg)，那么这两个值足够接近，我们已经找到了平方根。否则，我们使用`b`值在`head_tail()`函数的递归调用中来检查下一对值。
- en: Our `within()` function merely seeks to properly initialize the internal `head_tail()`
    function with the first value from the `iterable` parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`within()`函数仅仅是为了正确地使用`iterable`参数中的第一个值来初始化内部的`head_tail()`函数。
- en: Some functional programming languages offer a technique that will put a value
    back into an `iterable` sequence. In Python, this might be a kind of `unget()`
    or `previous()` method that pushes a value back into the iterator. Python iterables
    don't offer this kind of rich functionality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言提供了一种将值放回到可迭代序列中的技术。在Python中，这可能是一种将值放回迭代器的`unget()`或`previous()`方法。Python的可迭代对象并不提供这种丰富的功能。
- en: 'We can use the three functions `next_()`, `repeat()`, and `within()` to create
    a square root function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`next_()`、`repeat()`和`within()`这三个函数来创建一个平方根函数，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've used the `repeat()` function to generate a (potentially) infinite sequence
    of values based on the `next_(n,x)` function. Our `within()` function will stop
    generating values in the sequence when it locates two values with a difference
    less than `ε`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`repeat()`函数基于`next_(n,x)`函数生成了一个（可能是）无限的值序列。当我们的`within()`函数找到两个差值小于`ε`的值时，它将停止生成序列中的值。
- en: When we use this version of the `sqrt()` method, we need to provide an initial
    seed value, `a0`, and an `ε` value. An expression like `sqrt(1.0, .0001, 3)` will
    start with an approximation of 1.0 and compute the value of ![A classic example
    of functional programming](graphics/B03652_01_12.jpg) to within 0.0001\. For most
    applications, the initial `a0` value can be 1.0\. However, the closer it is to
    the actual square root, the more rapidly this method converges.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个版本的`sqrt()`方法时，我们需要提供一个初始种子值`a0`和一个`ε`值。像`sqrt(1.0, .0001, 3)`这样的表达式将从1.0的近似值开始，并计算出![A
    classic example of functional programming](graphics/B03652_01_12.jpg)的值，精确到0.0001。对于大多数应用程序，初始的`a0`值可以是1.0。然而，它越接近实际的平方根，这种方法收敛得越快。
- en: The original example of this approximation algorithm was shown in the Miranda
    language. It's easy to see that there are few profound differences between Miranda
    and Python. The biggest difference is Miranda's ability to construct `cons`, a
    value back into an `iterable`, doing a kind of `unget`. This parallelism between
    Miranda and Python gives us confidence that many kinds of functional programming
    can be easily done in Python.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种近似算法的原始示例是在Miranda语言中展示的。很容易看出Miranda和Python之间有一些深刻的区别。最大的区别是Miranda能够构造`cons`，将一个值返回到`iterable`，做一种`unget`。Miranda和Python之间的这种并行性使我们相信，许多种类的函数式编程可以在Python中轻松完成。
- en: Exploratory Data Analysis
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: Later in this book, we'll use the field of EDA as a source for concrete examples
    of functional programming. This field is rich with algorithms and approaches to
    working with complex datasets; functional programming is often a very good fit
    between the problem domain and automated solutions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将以探索性数据分析领域为具体例子，详细介绍函数式编程。这个领域充满了处理复杂数据集的算法和方法；函数式编程通常是问题领域和自动化解决方案之间非常好的契合。
- en: 'While details vary from author to author, there are several widely accepted
    stages of EDA. These include the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管细节因作者而异，但探索性数据分析通常包括以下几个广泛接受的阶段：
- en: 'Data preparation: This might involve extraction and transformation for source
    applications. It might involve parsing a source data format and doing some kinds
    of data scrubbing to remove unusable or invalid data. This is an excellent application
    of functional design techniques.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备：这可能涉及从源应用程序中提取和转换。它可能涉及解析源数据格式并进行某些类型的数据清洗，以删除不可用或无效的数据。这是功能设计技术的一个很好的应用。
- en: 'Data exploration: This is a description of the available data. This usually
    involves the essential statistical functions. This is another excellent place
    to explore functional programming. We can describe our focus as univariate and
    bivariate statistics but that sounds too daunting and complex. What this really
    means is that we''ll focus on mean, median, mode, and other related descriptive
    statistics. Data exploration may also involve data visualization. We''ll skirt
    this issue because it doesn''t involve very much functional programming. I''ll
    suggest that you use a toolkit like `SciPy`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据探索：这是对可用数据的描述。这通常涉及基本的统计函数。这是另一个探索函数式编程的绝佳场所。我们可以将我们的重点描述为一元和二元统计，但这听起来太艰难和复杂了。这实际上意味着我们将专注于均值、中位数、众数和其他相关的描述统计。数据探索也可能涉及数据可视化。我们将绕过这个问题，因为它并不涉及太多的函数式编程。我建议您使用像`SciPy`这样的工具包。
- en: 'Visit the following link to get more information how SciPY works and its usage:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接，了解SciPY的工作原理和用法：
- en: '[https://www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing](https://www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing)
    or [https://www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization](https://www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing](https://www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing)
    或 [https://www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization](https://www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization)'
- en: 'Data modeling and machine learning: This tends to be proscriptive as it involves
    extending a model to new data. We''re going to skirt this because some of the
    models can become mathematically complex. If we spend too much time on these topics,
    we won''t be able to focus on functional programming.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据建模和机器学习：这往往是规定性的，因为它涉及将模型扩展到新数据。我们将绕过这一点，因为一些模型可能在数学上变得复杂。如果我们在这些主题上花费太多时间，就无法专注于函数式编程。
- en: 'Evaluation and comparison: When there are alternative models, each must be
    evaluated to determine which is a better fit for the available data. This can
    involve ordinary descriptive statistics of model outputs. This can benefit from
    functional design techniques.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估和比较：当存在替代模型时，必须评估每个模型，以确定哪个更适合可用数据。这可能涉及模型输出的普通描述统计。这可以从功能设计技术中受益。
- en: The goal of EDA is often to create a model that can be deployed as a decision
    support application. In many cases, a model might be a simple function. A simple
    functional programming approach can apply the model to new data and display results
    for human consumption.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: EDA的目标通常是创建一个可以部署为决策支持应用程序的模型。在许多情况下，模型可能是一个简单的函数。简单的函数式编程方法可以将模型应用于新数据，并显示结果供人类消费。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've looked at programming paradigms with an eye toward distinguishing the
    functional paradigm from two common imperative paradigms. Our objective in this
    book is to explore the functional programming features of Python. We've noted
    that some parts of Python don't allow purely functional programming; we'll be
    using some hybrid techniques that meld the good features of succinct, expressive
    functional programming with some high-performance optimizations in Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从编程范式的角度看了函数式范式与两种常见的命令式范式的区别。我们在本书中的目标是探索Python的函数式编程特性。我们注意到Python的一些部分不允许纯粹的函数式编程；我们将使用一些混合技术，将简洁、表达丰富的函数式编程特性与Python中的一些高性能优化相结合。
- en: In the next chapter, we'll look at five specific functional programming techniques
    in detail. These techniques will form the essential foundation for our hybridized
    functional programming in Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细介绍五种特定的函数式编程技术。这些技术将构成我们在Python中混合使用的函数式编程的基本基础。
