- en: Introduction to the Basics of RESTful Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful架构基础介绍
- en: A web service is a software service or a software functionality provided by
    one set of computing devices to another set of computing devices. These devices
    communicate using established or standardized communication protocols through
    the **World Wide Web** (**WWW**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是一套计算设备向另一套计算设备提供的软件服务或软件功能。这些设备通过万维网（**WWW**）使用既定或标准化的通信协议进行通信。
- en: 'This chapter intends to refresh your understanding of a few fundamental concepts
    of the web and its architecture, and the way it is evolving, hoping to lay a firm
    foundation for RESTful service designs and applications. The following topics
    are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在刷新你对Web及其架构的一些基本概念的理解，以及其演变的方式，希望为RESTful服务设计和应用打下坚实的基础。本章涵盖了以下主题：
- en: A brief history of the WWW and its evolution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 万维网（WWW）的简要历史及其演变
- en: WWW layers and architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 万维网层和架构
- en: Web API development models and REST-based service communication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API开发模型和基于REST的服务通信
- en: A brief introduction to service-oriented architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务导向架构的简要介绍
- en: Resource-oriented architecture principles and characteristics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源导向架构原则和特性
- en: Introduction to REST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST介绍
- en: REST constraints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST约束
- en: RESTful qualifiers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful限定符
- en: REST architecture goals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构目标
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As this book deals with intermediate to advanced topics of RESTful design patterns,
    we expect you to have a good understanding of web service concepts and their unique
    functions. As mentioned earlier, this chapter is an attempt to refresh your understanding
    of various fundamental concepts of the WWW, its evolution, and the types of web
    services it offers, so there are no formal technical requirements for this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书涉及RESTful设计模式的中级到高级主题，我们期望你对Web服务概念及其独特功能有很好的理解。如前所述，本章试图刷新你对万维网、其演变以及它提供的各种Web服务类型的理解，因此本章没有正式的技术要求。
- en: Evolution of web technologies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络技术演变
- en: Generally, the aim of this book is to provide more elaborate RESTful patterns;
    however, this section intends to give you a quick introduction to web services
    and their evolution since the early 1990s, giving you exciting facts about Web
    1.0 through to Web 3.0, and then moving on to details about **service-oriented
    architecture** (**SOA**) and **resource-oriented architecture** (**ROA**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本书的目的是提供更详细的RESTful模式；然而，本节旨在快速介绍自20世纪90年代初以来的Web服务及其演变，提供关于Web 1.0到Web 3.0的激动人心的事实，然后转向关于**服务导向架构**（**SOA**）和**资源导向架构**（**ROA**）的详细信息。
- en: As you are aware, today's web is a universe in itself, with a massive amount
    of interlinked web-based apps, images, videos, photos, and various interactive
    content. Which web technologies have made this possible, where did it start, how
    has it evolved over time, and how does it enable web app developers to develop
    amazing and interactive web experiences?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，今天的网络是一个宇宙本身，拥有大量的相互链接的基于Web的应用程序、图像、视频、照片和各种交互式内容。哪些Web技术使这一切成为可能，它从哪里开始，它是如何随着时间的推移而演变的，以及它是如何使Web应用程序开发者能够开发出令人惊叹的交互式Web体验的？
- en: 'The following diagram provides a brief overview of the **WWW** and its evolution
    over time. Please note that each web version has its enabling technologies mentioned
    in the corresponding box:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了万维网及其随时间演变的简要概述。请注意，每个Web版本在其对应的框中提到了其启用技术：
- en: '![](img/edc4e212-cfcd-48d2-9854-1ee91cb46f20.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edc4e212-cfcd-48d2-9854-1ee91cb46f20.png)'
- en: Let's discuss **Web 3.0** more and focus on web services and their evolution
    as part of the third generation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地讨论**Web 3.0**，并关注作为第三代的一部分的Web服务及其演变。
- en: Learning about Web 3.0
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Web 3.0
- en: The following sections focus on Web 3.0 and the evolution and history of web
    services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将重点介绍Web 3.0以及Web服务的演变和历史。
- en: Web 3.0 is generally referred to as executing semantic web, or read-write-execute
    web. Web 3.0 decentralizes services such as search, social media, and chat applications
    that are dependent on a single organization to function. Semantic and web services
    are the primary constituents of Web 3.0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Web 3.0通常被称为执行语义网，或读写执行网。Web 3.0将搜索、社交媒体和聊天应用等依赖单一组织运作的服务去中心化。语义和Web服务是Web 3.0的主要组成部分。
- en: 'The following diagram depicts layers of typical Web 3.0 constructs. The semantic
    web layers are **Static Web**, **Translations**, and **Rich Internet Applications**
    (**RIA**) or **Rich Web** built on top of the internet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描绘了典型Web 3.0结构的层级。语义网层包括**静态Web**、**翻译**和基于互联网的**富互联网应用**（**RIA**）或**富Web**：
- en: '![](img/b53c03ab-9a12-4416-bace-8c50a0940505.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53c03ab-9a12-4416-bace-8c50a0940505.png)'
- en: The layered structure of Web 3.0
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web 3.0的分层结构
- en: This data-driven web adjusts according to the user's searches, for instance, if
    a user searches for architecture patterns, the advertisements shown are more relevant
    to architecture and patterns; it even remembers your last search and combines
    the last searched queries as well. Interesting isn't it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据驱动的网络会根据用户的搜索进行调整，例如，如果用户搜索架构模式，显示的广告将更相关于架构和模式；它甚至能记住您的最后搜索，并将最后搜索的查询结合起来。有趣，不是吗？
- en: 'What you see in the following diagram is a Web 3.0 stack, with various building
    blocks as URI, Unicode representations, syntax (XML/JSON), RDFS taxonomies, and
    so on; they constitute a Web 3.0 stack:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中您可以看到Web 3.0栈，它由各种构建块组成，如URI、Unicode表示、语法（XML/JSON）、RDFS分类法等；它们构成了Web 3.0栈：
- en: '![](img/734504ea-6241-4d82-a09d-1b2ed8e47508.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/734504ea-6241-4d82-a09d-1b2ed8e47508.png)'
- en: 'Web 3.0 stack (Ref: [https://www.w3.org/DesignIssues/w3.org ](https://www.w3.org/DesignIssues))'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web 3.0 栈（参考：[https://www.w3.org/DesignIssues/w3.org ](https://www.w3.org/DesignIssues)）
- en: Let's move on to the web service architecture, the specifications, and the communication
    protocols, as they are the fundamentals before we move to ROA, SOA, and **Representational
    State Transfer** (**REST**) or RESTful services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论网络服务架构、规范和通信协议，因为它们是我们转向ROA、SOA以及**表示状态转移**（**REST**）或RESTful服务之前的基础。
- en: Learning about web service architecture
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解网络服务架构
- en: Web services are a method of communication between two computing devices over
    a network, and the communication happens in standardized ways (and specifications)
    for the integration of heterogeneous web applications using XML/JSON, SOAP, WSDL,
    and UDDI. XML/JSON is the data format that provides metadata for the data that
    it contains; SOAP is used to transfer data; WSDL is used for defining available
    services to be consumed, and UDDI will have the list of services available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是在网络中两个计算设备之间进行通信的方法，通信以标准化的方式（和规范）发生，用于使用XML/JSON、SOAP、WSDL和UDDI集成异构网络应用程序。XML/JSON是提供所包含数据元数据的格式；SOAP用于传输数据；WSDL用于定义可消费的服务，而UDDI将列出可用的服务。
- en: '**Web services architecture** (**WSA**) mandates the presence of certain characteristics,
    and suggests a few optional ones, when developing any web service.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务架构**（**WSA**）在开发任何网络服务时要求某些特性的存在，并建议一些可选的特性。'
- en: 'WSA consists of three significant roles, as you can see in the following diagram,
    and they are as follow:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WSA由三个重要角色组成，如下图中所示，它们如下：
- en: '**Service Provider**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供者**'
- en: '**Service Consumer**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务消费者**'
- en: '**Service Broker**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务代理**'
- en: 'This is shown in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中展示：
- en: '![](img/4d66be7e-0052-4982-b678-3e19000d81ef.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d66be7e-0052-4982-b678-3e19000d81ef.png)'
- en: The **Service Requestor** finds the **Service Provider** through **UDDI**, and
    contacts the provider using the **Simple Object Access Protocol** (**SOAP**).
    The **Service Provider** then validates the service request and responds to the
    requestor with XML/JSON as a service response.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务请求者**通过**UDDI**找到**服务提供者**，并使用**简单对象访问协议**（**SOAP**）与提供者联系。然后，**服务提供者**验证服务请求，并以XML/JSON作为服务响应向请求者做出响应。'
- en: Discussing the web API
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论网络API
- en: So far, we have discussed the fundamentals of the client-server/web services
    paradigm, and the way they communicate with standard protocols; however, we are
    yet to touch upon REST-based communication and after all, that's what this book
    is about. This section will cover the introduction of web APIs, and how a web
    API is a development model for web services. The communication between the devices
    is REST-based. RESTful APIs do not use/require XML- based web service protocols,
    such as SOAP or WSDL, to support their interfaces, but they use simplified representations
    instead.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经讨论了客户端/服务器/网络服务的范式基础，以及它们如何通过标准协议进行通信；然而，我们尚未触及基于REST的通信，毕竟这正是本书的主题。本节将介绍网络API的介绍，以及网络API是如何成为网络服务开发模型。设备之间的通信是基于REST的。RESTful
    API不使用/需要基于XML的网络服务协议，如SOAP或WSDL来支持它们的接口，而是使用简化的表示。 '
- en: 'The following diagram depicts the web **API** and their simplified representations
    as the client side and the server side are exposed to each other through high-level
    interfaces:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了网络**API**及其作为客户端和服务器端通过高级接口相互暴露的简化表示：
- en: '![](img/b4daea8e-1bdc-4025-bf83-6f5317999d5c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4daea8e-1bdc-4025-bf83-6f5317999d5c.png)'
- en: So the web **API,** as shown in the preceding diagram, is available on both
    the client side and the server side. The client-side interfaces are generally
    exposed as JavaScript or browser plugins, and the server-side interfaces are generally
    exposed through the web as JSON/XML. Some of the key terminologies that we will
    come across concerning web APIs are endpoint, **uniform resource identifier**
    (**URI**), and resources.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如图所示，网络**API**在客户端和服务器端都是可用的。客户端接口通常以JavaScript或浏览器插件的形式暴露，而服务器端接口通常通过Web以JSON/XML的形式暴露。我们将遇到的一些关于网络API的关键术语包括端点、**统一资源标识符**（**URI**）和资源。
- en: The web API is an **application programming interface** (**API**) for *either*
    a web server or for a web browser. So, Web API is a concept or methodology for
    accessing any API (available over the web) through the HTTP protocol. There are
    many categories of APIs, SOAP, XML-RPC, JSON-RPC, REST, and so on. APIs can be
    developed with any programming language such as Java, .NET, and many more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API是针对*任何*网络服务器或网络浏览器的**应用程序编程接口**（**API**）。因此，Web API是通过HTTP协议访问任何API（可在网络上获得）的概念或方法。存在许多API类别，如SOAP、XML-RPC、JSON-RPC、REST等。API可以用任何编程语言开发，如Java、.NET等。
- en: So now you have got an idea of what is a Web API is and where REST API development
    fits into the Web API landscape, let's move on and see more details of SOA, ROA,
    REST, RESTful APIs, and their key constituents in the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经了解了什么是Web API以及REST API开发在Web API领域中的位置，让我们继续前进，看看下一节中SOA、ROA、REST、RESTful
    API及其关键组成部分的更多细节。
- en: Learning about service-oriented architecture
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解面向服务的架构
- en: Service-oriented architecture is an architectural style of web services. It
    defines some standards and lays down best approaches to design and develop a web
    service. Any web service is the logical representation of repeatable business
    activities that have a specified outcome, such as retrieving a weather report
    for a particular city, accessing stock prices for a given stock, updating a record
    to an inventory service, and so on. SOA is self-contained, and also provides guidelines
    to combine a service with other services as well. Another fact about SOA is that
    it is a black box (or abstract) to the service consumer who consumes it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构（Service-oriented architecture）是一种网络服务的架构风格。它定义了一些标准，并规定了设计和发展网络服务的最佳方法。任何网络服务都是具有特定结果的重复性业务活动的逻辑表示，例如获取特定城市的天气预报，访问给定股票的股价，更新库存服务的记录，等等。SOA是自包含的，同时也提供了将服务与其他服务结合的指南。关于SOA的另一个事实是，它对于使用它的服务消费者来说是一个黑盒（或抽象）。
- en: In short, SOA is essentially a collection of services, those services communicate
    with each other, and a service is an operation or a function that is well defined,
    self-contained, and independent of other service contexts and states. Services
    are applications hosted on application servers and interact with other applications
    through interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，SOA本质上是一组服务，这些服务相互通信，而一个服务是一个定义良好、自包含且独立于其他服务上下文和状态的操作或函数。服务是托管在应用服务器上的应用程序，并通过接口与其他应用程序交互。
- en: SOA is not a technology or a programming language; it's a set of principles,
    procedures, and methodologies to develop a software application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SOA不是一种技术或编程语言；它是一套原则、程序和方法，用于开发软件应用程序。
- en: Learning about resource-oriented architecture
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解面向资源架构
- en: Resource-oriented architecture is a foundation of the semantic web (please refer
    to the *Web 3.0* section of this chapter). The idea of ROA is to use basic, well-understood,
    and well-known web technologies (HTTP, URI, and XML) along with the core design
    principles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 面向资源架构（Resource-oriented architecture）是语义网的基础（请参阅本章的*Web 3.0*部分）。ROA的理念是使用基本、易于理解和广泛认可的Web技术（HTTP、URI和XML）以及核心设计原则。
- en: As we all know, the primary focus of web services is to connect information
    systems, and ROA defines a structural design or set of guidelines to support and
    implement interactions within any connected resources. Any business entity can
    be represented as a resource, and it can be made accessible through a URI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Web服务的重点是连接信息系统，而ROA定义了一种结构设计或一系列指南，以支持并实现任何连接资源内的交互。任何业务实体都可以表示为资源，并且可以通过URI使其可访问。
- en: For example, in an organization's human resource system, each employee is an
    entity, and salary, employee details, and profiles are associations (descriptors)
    of that entity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个组织的人力资源系统中，每位员工都是一个实体，而薪资、员工详情和档案是该实体的关联（描述符）。
- en: 'The following is a quick comparison table for object-oriented and resource-oriented
    concepts, and it gives a quick insight as to what ROA is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个面向对象和资源导向概念的快速比较表，它快速概述了ROA是什么：
- en: '| **Objects in object-oriented architecture** | **Resources in ROA** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **面向对象架构中的对象** | **ROA中的资源** |'
- en: '| Every entity is defined as an object | Entities are services |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 每个实体都被定义为对象 | 实体是服务 |'
- en: '| An object has attributes and actions | A service has descriptions and contracts
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 对象具有属性和动作 | 服务具有描述和契约 |'
- en: '| Objects need to maintain state to interact | Interacts over the network with
    a defined location or address |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 对象需要维护状态以进行交互 | 通过定义的位置或地址在网络中进行交互 |'
- en: Resource-oriented design
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源导向设计
- en: The resource-oriented design section intends to walk you through the ROA design
    guidelines, design principles, and characteristics, along with its properties
    as well. Having introduced ROA properties, we will look at REST architecture in
    subsequent sections.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 资源导向设计部分旨在向您介绍ROA设计指南、设计原则和特性，以及其属性。在介绍了ROA属性之后，我们将在后续章节中探讨REST架构。
- en: ROA-based web services describe a self-discoverable entity, and modeling is
    based on its logical form (unlike services, as they are based on the technical
    form).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于ROA的Web服务描述了一个可发现的自发现实体，其建模基于其逻辑形式（与服务不同，因为它们基于技术形式）。
- en: 'Let''s look at the basic blocks of ROA such as resources, representations,
    and so on in the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图中ROA的基本块，如资源、表示法等：
- en: '![](img/f716574d-a35a-4c2d-acad-b460d819b94f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f716574d-a35a-4c2d-acad-b460d819b94f.png)'
- en: The blocks in the preceding diagram represent the typical structure of ROA and
    give an idea of how resources are consumed by the service consumers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的块代表了ROA的典型结构，并给出了服务消费者如何消费资源的想法。
- en: 'Let''s briefly consider the concepts and properties of ROA, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要考虑ROA的概念和属性，如下所示：
- en: '**Resource providers**: Resource providers expose the resources for the service
    consumers to invoke the services with HTTP methods. Microsoft Azure and Amazon
    AWS are simple examples of resource providers.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源提供者**：资源提供者向服务消费者公开资源，以便他们可以使用HTTP方法调用服务。微软Azure和亚马逊AWS是资源提供者的简单例子。'
- en: '**Resource**: A resource is an explicit reference to an entity that can be
    identified and assigned and, most importantly, referenced as a resource. Some
    examples of resources could be servers, devices, web pages, JavaScript, or the
    latest version of software, the latest defect in software, a directory or list
    of information about an organization, and so on.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：资源是对一个可识别、可分配的实体的明确引用，并且最重要的是，可以作为资源进行引用。资源的例子可能包括服务器、设备、网页、JavaScript或软件的最新版本、软件的最新缺陷、一个组织的目录或信息列表等。'
- en: '**Resource name**: The resource name is the unique name or identification for
    the resource. So, no two resources can point to the same data. For instance, the
    latest version of software is 2.0.9.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源名称**：资源名称是资源的唯一名称或标识。因此，没有两个资源可以指向相同的数据。例如，软件的最新版本是2.0.9。'
- en: '**Resource representation**: Resource representation is the useful information
    about the current state of a resource, specified with a specific format, in a
    specific language.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源表示**：资源表示是关于资源当前状态的有用信息，以特定的格式和特定的语言进行指定。'
- en: '**Resource link and connectedness**: Represents (linkage) another resource
    or the resource itself. Connectedness is all about how reliable and relevant the
    resource''s links are.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源链接和连通性**：表示（链接）另一个资源或资源本身。连通性完全关乎资源链接的可靠性和相关性。'
- en: '**Resource interface**: The resource interface is an interface for accessing
    the resource and handling its state.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源接口**：资源接口是访问资源并处理其状态的接口。'
- en: '**Addressability**: Addressability is exposing datasets or functionalities
    as a resource, and the addressability of a resource happens through URIs.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可寻址性**：可寻址性是将数据集或功能作为资源暴露出来，资源的可寻址性是通过 URI 实现的。'
- en: '**Statelessness**: Statelessness is maintaining the isolation and independence
    of client and server states. Every request from the client should be self-contained.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：无状态是保持客户端和服务器状态的隔离和独立性。来自客户端的每个请求都应该自包含。'
- en: '**The uniform interface**: Every service needs to use the HTTP interface the
    same way, such as `GET`, `POST`, `PUT`, `DELETE`, and so on. The uniform interface
    simply means using some common nomenclature that is interpreted the same way across
    the web. For example, `GET` does mean get (read) something.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：每个服务都需要以相同的方式使用 HTTP 接口，例如 `GET`、`POST`、`PUT`、`DELETE` 等。统一接口简单来说就是使用一些通用的命名法，这些命名法在互联网上被统一解释。例如，`GET`
    确实意味着获取（读取）某些内容。'
- en: 'The following table summarizes the HTTP operations that can be used to implement
    an ROA-based web service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了可用于实现基于 ROA 的 Web 服务的 HTTP 操作：
- en: '| **HTTP operation** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 操作** | **描述** |'
- en: '| `GET` | Read the resource representations |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 读取资源表示 |'
- en: '| `PUT` | Create a new resource |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 创建新资源 |'
- en: '| `DELETE` | Delete the resource (optionally linked resource as well) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源（可选地删除相关资源） |'
- en: '| `POST` | Modify the resource |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 修改资源 |'
- en: '| `HEAD` | Meta information of the resource |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 资源元信息 |'
- en: The preceding table shows the HTTP methods to implement ROA.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上表显示了实现 ROA 的 HTTP 方法。
- en: The benefits of ROA
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROA 的好处
- en: 'The following are the benefits of ROA:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出 ROA 的好处：
- en: '**Independent of client contracts**: Free from interface agreements/contract
    formulations, that is, no need to formulate the contact as the entire web is based
    on HTTP operations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立于客户端合约**：不受接口协议/合约制定的影响，也就是说，无需制定合约，因为整个网络都是基于 HTTP 操作。'
- en: '**Explicit state**: As the resource itself represents states, servers won''t
    receive unknown application specific payloads; the server does not have to keep
    track of the client who called the server, and also the client doesn''t need to
    know which server it has talked to.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式状态**：由于资源本身代表状态，服务器不会接收到未知的应用特定有效负载；服务器不需要跟踪调用服务器的客户端，客户端也不需要知道它已经与哪个服务器交谈过。'
- en: '**Scalability and performance**: Scalability with ROA is shown by characteristics
    such as no contract boundaries, explicit states, and freeing up the clients from
    the server''s stickiness(session). The performance improvement regarding response
    time for the ROA caching, load-balancing, indexing, and searching play a significant
    role in improving performance.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和性能**：ROA 的可扩展性体现在无合约边界、显式状态以及从服务器粘性（会话）中解放客户端等特性。关于 ROA 缓存、负载均衡、索引和搜索的响应时间性能改进在提高性能方面发挥着重要作用。'
- en: A process of creating an affinity between a client and a specific server by
    a load balancer is called **session stickiness**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过负载均衡器在客户端和特定服务器之间创建亲和力的过程称为 **会话粘性**。
- en: A contract or agreement is fundamentally a collection of metadata that defines
    many aspects of an underlying software program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 合同或协议本质上是一组元数据，它定义了底层软件程序许多方面。
- en: Beginning with REST
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 REST 开始
- en: So far, we have looked at ROA and a set of guidelines, such as statelessness,
    resources, addressability, uniform resources, and so on. Those guidelines are
    the fundamental implementation of REST architecture. As this book is all about
    RESTful patterns, we are going to explore more about the REST architectural style
    in this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 ROA 和一系列指南，例如无状态、资源、可寻址性、统一资源等。这些指南是 REST 架构的基本实现。由于本书全部关于 RESTful
    模式，我们将在本节中进一步探讨 REST 架构风格。
- en: 'The REST concepts were submitted as a PhD dissertation by Roy Fielding. The
    fundamental principle of REST is to use the **HTTP** protocol for data communication
    (between distributed hypermedia systems), and it revolves around the concept of
    resources where each and every component considered as a resource, and those resources
    are accessed by the common interfaces using **HTTP** methods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: REST概念是由Roy Fielding提交的博士论文。REST的基本原则是使用**HTTP**协议进行数据通信（在分布式超媒体系统之间），并且它围绕资源的概念展开，其中每个组件都被视为资源，这些资源通过**HTTP**方法使用通用接口进行访问：
- en: '![](img/7d73d789-a00e-4d47-8ccb-dd4bdcb431d0.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d73d789-a00e-4d47-8ccb-dd4bdcb431d0.png)'
- en: An example implementation of an ROA/REST service
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ROA/REST服务的示例实现
- en: The preceding diagram shows you where REST stands in the ROA architecture and
    how it can be accessed by different consumers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了REST在ROA架构中的位置以及它如何被不同的消费者访问。
- en: REST is an architectural style and not a programming language or technology.
    It provides guidelines for distributed systems to communicate directly using the
    existing principles and protocols of the web to create web services and APIs, without
    the need for SOAP or any other sophisticated protocols.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种架构风格，而不是一种编程语言或技术。它为分布式系统提供了使用现有网络原则和协议直接进行通信的指南，以创建Web服务和API，无需SOAP或其他复杂协议。
- en: The REST architecture is simple and provides access to resources so that the
    REST client accesses and renders the resources on the client side. In REST style,URI
    or Global IDs helps to identify each resource. As you know REST uses several resources
    representations to represent its type such as XML, JSON, Text, images and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构简单，提供对资源的访问，以便REST客户端在客户端端访问和渲染资源。在REST风格中，URI或全局ID有助于识别每个资源。正如您所知，REST使用多种资源表示形式来表示其类型，如XML、JSON、文本、图像等。
- en: REST architecture style constraints
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST架构风格约束
- en: 'There are design rules that are applied to establish the different characteristics
    of the REST architectural style, which are referred to as REST constraints:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些设计规则应用于确定REST架构风格的特性，这些规则被称为REST约束：
- en: '![](img/894615f0-631a-4b3a-a38b-7b4d5750e9ea.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/894615f0-631a-4b3a-a38b-7b4d5750e9ea.png)'
- en: REST architectural style constraints
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构风格约束
- en: 'The preceding diagram depicts REST constraints in a typical web/internet-based
    application. The following are the REST constraints:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了典型基于Web/互联网的应用程序中的REST约束。以下是一些REST约束：
- en: Client-server
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: Statelessness
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cacheable
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存
- en: Uniform interface
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Layered systems
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: Code on demand
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求时提供代码
- en: Beginning with client-server
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从客户端-服务器开始
- en: 'The client-server architecture or model helps in the separation of concerns
    between the user interface and data storage:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构或模型有助于在用户界面和数据存储之间分离关注点：
- en: '![](img/b5b024be-6070-4979-be88-294d0e1831f0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5b024be-6070-4979-be88-294d0e1831f0.png)'
- en: The client and server
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器
- en: 'Let''s discuss the client and server in the context of ROA as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式在ROA的背景下讨论客户端和服务器：
- en: '**Client**: It is the component that is the requestor of a service and sends
    requests for various types of services to the server'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：它是请求服务的组件，向服务器发送各种类型服务的请求'
- en: '**Server**: It is the component that is the service provider and continuously
    provides services to the client as per the requests'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：它是服务提供者组件，根据请求持续向客户端提供服务'
- en: Clients and servers typically comprise distributed systems that communicate
    over a network.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通常由分布式系统组成，它们通过网络进行通信。
- en: The client in client-server architecture
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端在客户端-服务器架构中
- en: There is no upper bound on the number of clients that can be serviced by a single
    server. It is also not mandatory that the client and server should reside in separate
    systems. Both client and server can reside in the same system, based on the hardware
    configuration of the system and the type of functionality or service provided
    by the server. The communication between client and server happens through the
    exchange of messages using a request-response pattern. The client basically sends
    a request for a service, and the server returns a response. This request-response
    pattern of communication is an excellent example of inter-process communication.
    For this communication to happen efficiently, it is necessary to have a well-defined
    communication protocol that lays down the rules of communication, such as the
    format of request messages, response messages, error handling, and so on. All
    communication protocols that are used for client-server communication work in
    the application layer of the protocol stack. To further streamline the process
    of client-server communication, the server sometimes implements a specific API
    that can be used by the client for accessing any specific service from the server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单个服务器可以服务的客户端数量没有上限。客户端和服务器是否位于不同的系统中也不是强制性的。根据系统的硬件配置和服务器提供的功能或服务类型，客户端和服务器可以位于同一系统中。客户端和服务器之间的通信是通过使用请求-响应模式交换消息来实现的。客户端基本上发送一个服务请求，服务器返回一个响应。这种通信的请求-响应模式是进程间通信的一个优秀例子。为了使这种通信高效进行，有必要有一个定义良好的通信协议，该协议规定了通信规则，例如请求消息的格式、响应消息、错误处理等。所有用于客户端-服务器通信的通信协议都在协议栈的应用层工作。为了进一步简化客户端-服务器通信的过程，服务器有时会实现一个特定的API，客户端可以使用该API从服务器访问任何特定的服务。
- en: The service in client-server architecture
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构中的服务
- en: The term service used in the context of client-server architecture refers to
    the abstraction of a resource. The resource could be of any type and based on
    the one provided by the server (service); the server is named accordingly. For
    example, if the server provides web pages, it is called a **web server**, and
    if the server provides files, it is called a **file server**, and so on. A server
    can receive requests from any number of clients at a specific point in time. But
    any server will have its own limitations about its processing capabilities. Often,
    it becomes necessary for a server to prioritize the incoming requests and service
    them as per their priority. The scheduling system present in the server helps
    the server with the assignment of priorities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器架构的上下文中使用的术语“服务”指的是资源的抽象。资源可以是任何类型，基于服务器（服务）提供的资源；服务器据此命名。例如，如果服务器提供网页，它被称为**Web服务器**；如果服务器提供文件，它被称为**文件服务器**，等等。服务器可以在特定时间点接收来自任何数量客户端的请求。但任何服务器都将有其自己的处理能力限制。通常，服务器需要优先处理传入的请求，并按优先级提供服务。服务器中存在的调度系统帮助服务器分配优先级。
- en: 'Client-server benefits are in addition to separation of concerns and help with
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器的好处除了关注点的分离外，还有助于以下方面：
- en: Improving the portability of the user interface
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高用户界面的可移植性
- en: Improving scalability by simplifying server implementations
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过简化服务器实现来提高可扩展性
- en: Developing with standalone, independent testable components
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立、可测试的组件进行开发
- en: Understanding statelessness
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无状态
- en: The statelessness constraint helps services to be more scalable and reliable.
    Statelessness, in the REST context, means that all the client requests to the
    server carry all the information as explicit (stated), so that the server understands
    the requests, treats them as independent, and those client requests keep the server
    independent of any stored contexts. Keeping the session state within the client
    is important to manage this constraint in the services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态约束有助于服务更加可扩展和可靠。在REST的上下文中，无状态意味着所有客户端对服务器的请求都携带所有信息作为显式（声明）的，这样服务器就能理解请求，将它们视为独立的，并且这些客户端请求使服务器独立于任何存储的上下文。将会话状态保持在客户端内对于管理这种约束在服务中非常重要。
- en: 'The following diagram shows the **Service Consumer** (client) and the **Service
    States** are independent and managed within the client and server respectively:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 **服务消费者**（客户端）和**服务状态**是独立的，并且分别在客户端和服务器内部进行管理：
- en: '![](img/8a9d71d7-0c74-4ecd-be48-40ab48c13250.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a9d71d7-0c74-4ecd-be48-40ab48c13250.png)'
- en: Statelessness (managing states independently)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态（独立管理状态）
- en: 'The statelessness constraint imposes significant restrictions on the kind of
    communications allowed between services and consumers, to achieves its design
    goals. The following are the restrictions to achieve statelessness:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态约束对服务与消费者之间允许的通信类型施加了重大限制，以实现其设计目标。以下是无状态实现的限制：
- en: It is the complete responsibility of the client to store and handle all the
    application states and the related information on the client side.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端完全负责在客户端存储和处理所有应用程序状态及其相关信息。
- en: The client is responsible for sending any state information to the server whenever
    it's needed.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端负责在需要时向服务器发送任何状态信息。
- en: No session stickiness or session affinity on the server for the calling request
    (client).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于调用请求（客户端）的服务器上没有会话粘性或会话亲和力。
- en: The server also needs to include any necessary information that the client may
    need to create a state on its side.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器还需要包含客户端可能需要创建状态的任何必要信息。
- en: 'HTTP interactions involve two kinds of states, application state and resource
    state, and statelessness applies to both. Let''s see how the statelessness constraint
    is handled in each state:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP交互涉及两种状态，应用程序状态和资源状态，无状态适用于两者。让我们看看无状态约束在每个状态中是如何处理的：
- en: '**Application state:** The data that is stored on the server side and helps
    to identify the incoming client request, using the previous interaction details
    with current context information'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序状态**：存储在服务器端的数据，有助于通过当前上下文信息识别传入的客户端请求，使用之前交互的详细信息。'
- en: '**Resource state:** This is referred to as a resource representation, and it
    is independent of the client (the client doesn''t need to know this state unless
    it is available as response is needed), and this is the current state of the server
    at any given point in time'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源状态**：这被称为资源表示，它与客户端无关（客户端不需要知道此状态，除非需要作为响应），这是服务器在任何给定时间点的当前状态。'
- en: 'The statelessness constraint of REST applies to the application state, that
    is, being free only on the application state and nothing to do with resource state.
    Twitter''s API is the best example of a stateless service `(GET: https://api.twitter.com/1.1/direct_messages.json?since_id=xxx&amp;count=x)`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'REST的无状态约束适用于应用程序状态，即仅在应用程序状态上自由，与资源状态无关。Twitter的API是无状态服务的最佳示例（GET: https://api.twitter.com/1.1/direct_messages.json?since_id=xxx&count=x）。'
- en: Advantages and disadvantages of statelessness
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态的优缺点
- en: 'The following are some advantages of statelessness:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是无状态的某些优点：
- en: As the server does not need to manage any session, deploying the services to
    any number of servers is possible, and so scalability will never be a problem
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器不需要管理任何会话，因此可以将服务部署到任意数量的服务器上，因此可扩展性永远不会成为问题。
- en: No states equals less complexity; no session (state) synchronize logic to handle
    at the server side
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态等于更少的复杂性；无需在服务器端处理会话（状态）同步逻辑。
- en: As the service calls (requests) can be cached by the underlying application,
    the statelessness constraint brings down the server's response time, that is,
    it improves performance with regard to response time
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于底层应用程序可以缓存服务调用（请求），无状态约束降低了服务器的响应时间，即提高了响应时间方面的性能。
- en: Seamless integration/implementation with HTTP protocols is possible as HTTP
    is itself a stateless protocol
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与HTTP协议的无缝集成/实现是可能的，因为HTTP本身就是一个无状态协议。
- en: Improves visibility as each request is its own resource and can be treated as
    an independent request
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了可见性，因为每个请求都是其自身的资源，可以被视为一个独立请求。
- en: Improves reliability as it can recover from partial failures
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了可靠性，因为它可以从部分故障中恢复。
- en: 'The following are some disadvantages of statelessness:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是无状态的某些缺点：
- en: Increase per-interaction overhead
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加了每次交互的开销。
- en: Each request of webservices needs to get additional information so that it get
    parsed (interpreted) so that the server understands the client state from the
    incoming request and takes care of the client / server sessions if needed
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务的每个请求都需要获取额外的信息，以便进行解析（解释），以便服务器能够从传入的请求中理解客户端状态，并在需要时处理客户端/服务器会话。
- en: Caching constraint in REST
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST中的缓存约束
- en: '**Caching** is the ability to store frequently accessed data (a response in
    this context) to serve the client requests, and never having to generate the same
    response more than once until it needs to be. Well-managed caching eliminates
    partial or complete client-server interactions and still serves the client with
    the expected response. Obviously, caching brings scalability and also performance
    benefits with faster response times and reduced server load.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是指存储频繁访问的数据（在此上下文中为响应）以服务客户端请求的能力，并且不需要在需要之前生成相同的响应超过一次。良好的缓存管理可以消除部分或全部的客户端-服务器交互，并仍然以预期的响应服务客户端。显然，缓存带来了可扩展性和性能优势，包括更快的响应时间和减少服务器负载。'
- en: 'As you can see in the next diagram, the service consumer (**Client**) receives
    the response from the cache and not from the server itself, and a few other responses
    are directly from the server as well. So, caching helps with the partial or complete
    elimination of some interactions between the service consumers and so helps to
    improve efficiency and performance (reduced latency time in response):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下一张图中可以看到，服务消费者（**客户端**）从缓存接收响应，而不是从服务器本身接收，还有一些其他响应直接来自服务器。因此，缓存有助于减少或完全消除服务消费者与服务器之间的某些交互，从而有助于提高效率和性能（减少响应的延迟时间）：
- en: '![](img/6e67959d-f479-4edd-8a23-eb490f82590b.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e67959d-f479-4edd-8a23-eb490f82590b.png)'
- en: 'There are different caching strategies or mechanisms available, such as browser
    caches, proxy caches, and gateway caches (reverse-proxy), and there are several
    ways that we can control the cache behavior, such as through pragma, expiration
    tags, and so on. The following table gives a glimpse of the various cache control
    headers one use to can fine-tune cache behaviors:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的缓存策略或机制有多种，例如浏览器缓存、代理缓存和网关缓存（反向代理），我们可以通过多种方式来控制缓存行为，例如通过pragma、过期标签等。以下表格展示了可以用来微调缓存行为的各种缓存控制头：
- en: '| **Headers** | **Description** | **Samples** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **头信息** | **描述** | **示例** |'
- en: '| Expires | Header attribute to represent date/time after which the response
    is considered stale | Expires: Fri, 12 Jan 2018 18:00:09 GMT |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| Expires | 表示响应被认为是过时的日期/时间头属性 | Expires: Fri, 12 Jan 2018 18:00:09 GMT |'
- en: '| Cache-control | A  header that defines various directives (for both requests
    and responses) that are followed by caching mechanisms | `Max age=4500`, cache-extension
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| Cache-control | 定义了各种指令的头信息（适用于请求和响应），这些指令被缓存机制遵循 | `Max age=4500`, cache-extension
    |'
- en: '| E-Tag | Unique identifier for server resource states | ETag:`uqv2309u324klm`
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| E-Tag | 服务器资源状态的唯一标识符 | ETag:`uqv2309u324klm` |'
- en: '| Last-modified | Response header helps to identify the time the response was
    generated | Last-modified: Fri, 12 Jan 2018 18:00:09 GMT |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| Last-modified | 响应头帮助识别响应生成的时间 | Last-modified: Fri, 12 Jan 2018 18:00:09
    GMT |'
- en: For more about cache-control directives. Please refer to [https://tools.ietf.org/html/rfc2616#section-14.9](https://tools.ietf.org/html/rfc2616#section-14.9).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于缓存控制指令的信息，请参阅 [https://tools.ietf.org/html/rfc2616#section-14.9](https://tools.ietf.org/html/rfc2616#section-14.9)。
- en: Benefits of caching
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存的好处
- en: 'Obviously, there are a lot of benefits to caching frequently accessed data,
    and the following are the significant ones:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，缓存频繁访问的数据有很多好处，以下是一些显著的好处：
- en: Reduced bandwidth
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少带宽
- en: Reduced latency (faster response time)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少延迟（更快的响应时间）
- en: Reduced load on the server
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减轻服务器负载
- en: Hide network failures and serve a client with the response
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏网络故障，并以响应服务客户端
- en: The cache constraint builds upon the client-server and stateless ones, with
    the requirement that responses are implicitly or explicitly labeled as cacheable
    or non-cacheable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存约束建立在客户端-服务器和无状态约束的基础上，要求响应被隐式或显式地标记为可缓存或不可缓存。
- en: Understanding the uniform interface
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解统一接口
- en: 'As we mentioned earlier in the uniform interface section as part of ROA, REST-based
    services can use the HTTP interface, such as `GET`, `POST`, `PUT`, `DELETE`, and
    so on, to maintain uniformity across the web. The intention of a uniform interface
    is to retain some common vocabulary across the internet. For example, `GET` does
    mean to get (read) something from the server. The services can independently evolve
    as their interfaces simplify and decouple the architecture, and the uniform interface
    brings a uniform vocabulary to those resources as well. The following diagram
    depicts the combination of **HTTP Methods** and the **Resource Names** for **Uniform
    Interfaces**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在 ROA 的统一接口部分提到的，基于 REST 的服务可以使用 HTTP 接口，如 `GET`、`POST`、`PUT`、`DELETE`
    等，以保持整个网络的统一性。统一接口的目的是在互联网上保留一些共同词汇。例如，`GET` 的确意味着从服务器获取（读取）某些内容。服务可以独立发展，随着其接口的简化和架构的解耦，统一接口也为这些资源带来了统一的词汇。以下图表展示了
    **HTTP 方法** 和 **资源名称** 对于 **统一接口** 的组合：
- en: '![](img/d1473845-d354-476f-96d3-a1cb33edbad8.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1473845-d354-476f-96d3-a1cb33edbad8.png)'
- en: 'There are four guiding principles suggested by Fielding that constitute the
    necessary constraints to satisfy the uniform interface, and they are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Fielding 提出的四个指导原则构成了满足统一接口的必要约束，具体如下：
- en: Identification of resources
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源识别
- en: Manipulation of resources
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源操作
- en: Self-descriptive messages
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自描述消息
- en: Hypermedia as the engine of application state
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态引擎
- en: We will see each constraint in detail in the following sections.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细讨论每个约束。
- en: Identification of resources
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源识别
- en: As we have seen in earlier sections, a resource represents a named entity in
    a web application, and it is usually a **Uniform Resource Locator** (**URL**).
    So, an entity can be identified and assigned as a resource by an explicit reference
    to it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在早期章节中看到的，资源代表网络应用程序中的一个命名实体，它通常是 **统一资源定位符**（**URL**）。因此，一个实体可以通过对其的显式引用来识别并分配为资源。
- en: 'A URL in a web application is usually a link, and it is in fact a URI. For
    example, a home page URI, [https://developer.twitter.com](https://developer.twitter.com),
    uniquely identifies the concept of a specific website''s root resource. In REST
    constraints, the URIs we use are described as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序中的 URL 通常是一个链接，实际上它是一个 URI。例如，主页 URI，[https://developer.twitter.com](https://developer.twitter.com)，唯一标识了特定网站根资源的概念。在
    REST 约束中，我们使用的 URI 描述如下：
- en: The semantics of the mapping of the URI to a resource must not change. For instance,
    Twitter's [https://api.twitter.com/1.1/statuses/retweets/:id.json](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweets-id)
    as a URI may never change, and of course the contents or values will keep improving,
    according to the latest updates.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI 映射到资源的语义不得改变。例如，Twitter 的 [https://api.twitter.com/1.1/statuses/retweets/:id.json](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweets-id)
    作为 URI 可能永远不会改变，当然内容或值会根据最新更新不断改进。
- en: Resource identification is independent of its values so two resources could
    point to the same data at some point, but they are not the same resource.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源识别与其值无关，因此两个资源可能在某个时刻指向相同的数据，但它们不是同一个资源。
- en: For example, URI 1, [https://api.twitter.com/1.1/statuses/retweets/:id.json](https://api.twitter.com/1.1/statuses/retweets/:id.json),
    returns a collection up to 100 of the most recent retweets of a tweet (specified
    by the ID).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，URI 1，[https://api.twitter.com/1.1/statuses/retweets/:id.json](https://api.twitter.com/1.1/statuses/retweets/:id.json)，返回一个包含最多
    100 条最近转发的推文（通过 ID 指定）的集合。
- en: The other URI 2, [https://api.twitter.com/1.1/statuses/retweeters/ids.json](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids),
    [responds with a collection of 100 user IDs (maximum) belonging to users who have
    retweeted the tweet (specified by the ID parameter)](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个 URI 2，[https://api.twitter.com/1.1/statuses/retweeters/ids.json](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids)，[返回一个包含最多
    100 个用户 ID 的集合，这些用户 ID 属于已经转发推文（通过 ID 参数指定）的用户](https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids)。
- en: The second method offers similar data to the first method (statuses/retweets)
    and may produce the same results or combinations, but both methods certainly represent
    a different resource.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法提供了与第一种方法（状态/转发）类似的数据，并可能产生相同的结果或组合，但两种方法确实代表了不同的资源。
- en: URIs bring benefits such as only one way to access a resource, dynamic media
    types for resource responses (serve the media type at the time it is requested)
    with the help of the Accept headers, and clients accessing those dynamic resources
    do not need to change any identifiers if any change is made in the response content
    type.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI带来了好处，如只有一个访问资源的方式，动态媒体类型用于资源响应（在请求时提供媒体类型）借助Accept头，以及访问这些动态资源的客户端在响应内容类型发生变化时不需要更改任何标识符。
- en: Manipulation of resources
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源操作
- en: Resources, once identified, can be returned by the server in a different format,
    such as JSON, XML, HTML, PNG,  SVG, and so on. These formats are a representation
    of the identified resources, and the client will understand the list of possible
    well-defined formats or media types (also called **Multipurpose Internet Mail
    Extension** (**MIME**)) from the headers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别资源，服务器就可以以不同的格式返回资源，例如JSON、XML、HTML、PNG、SVG等。这些格式是已识别资源的表示，客户端将从头部了解可能的定义良好的格式或媒体类型列表（也称为**多用途互联网邮件扩展**（**MIME**））。
- en: The resource's representation is manipulated or processed by clients. The application
    needs to support more than one representation of the same resource and the same
    URI; in other words, the same exact resource is represented by different clients
    in different ways.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 资源表示被客户端操纵或处理。应用程序需要支持同一资源的多种表示和相同的URI；换句话说，相同的资源由不同的客户端以不同的方式表示。
- en: Let's take an example; a document might be represented as JSON to an automated
    program, but as HTML to a web browser. The purpose of these representations is
    to provide a way to interact with the resource, and so the clients can indicate
    the intended representations they wish to receive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子；一个文档可能被表示为JSON给自动化程序，但作为HTML给网页浏览器。这些表示的目的在于提供一种与资源交互的方式，因此客户端可以表明他们希望接收的预期表示。
- en: 'The preceding conceptual distinction allows the resource to be represented
    in different ways without changing its identifiers. It is possible with the HTTP
    header (Accept) getting passed to the server by the clients in each request. The
    resources are updated or added by sending representations from the client by the
    RESTful application. The following diagram is a sample representation format,
    captured for a sample request from my Postman tool:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的概念区分允许资源以不同的方式表示，而不会改变其标识符。这是通过客户端在每次请求中通过HTTP头（Accept）传递给服务器的。资源通过RESTful应用程序发送表示来更新或添加。以下图是一个示例表示格式，它捕捉了我Postman工具的一个示例请求：
- en: '![](img/baddf899-562a-437b-8ed5-553548562a7f.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baddf899-562a-437b-8ed5-553548562a7f.png)'
- en: So, the decoupling of the resource's representation from the URI is one of the
    crucial aspects of REST.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，资源表示与URI的解耦是REST的关键方面之一。
- en: 'The following list shows various content-type representation formats (as headers)
    that one can use in the request or response:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了可以在请求或响应中使用（作为标题）的各种内容类型表示格式：
- en: Text/HTML, text/CSS, text/JavaScript
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Text/HTML, text/CSS, text/JavaScript
- en: Application/XML, application/JSON, application/x-www-form-urlencoded
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Application/XML, application/JSON, application/x-www-form-urlencoded
- en: Image (SVG, JPG, PNG, and so on)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像（SVG、JPG、PNG等）
- en: '**Postman** is a tool that helps us to interact with REST APIs. It offers a
    very friendly user interface that can quickly test the APIs by constructing requests
    and reading responses. [Chapter 6](adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml),
    *RESTful Services API Testing and Security* of this book provides more information
    about the Postman tool and its wider abilities to test RESTful APIs.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman**是一个帮助我们与REST API交互的工具。它提供了一个非常友好的用户界面，可以通过构建请求和读取响应来快速测试API。[第6章](adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml)，本书的*RESTful服务API测试和安全*提供了更多关于Postman工具及其更广泛的测试RESTful
    API能力的信息。'
- en: Self-descriptive messages
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自描述消息
- en: A client's request and server's response are messages; those messages should
    be stateless and self-descriptive. They can have a body and metadata. RESTful
    applications operate on the notion of constrained message types (`GET`, `HEAD`,
    `OPTIONS`, `PUT`, `POST`, and `DELETE`) and they are fully understood by both
    the server and the client.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的请求和服务器端的响应都是消息；这些消息应该是无状态的且自描述的。它们可以包含正文和元数据。RESTful 应用操作于受约束的消息类型（`GET`、`HEAD`、`OPTIONS`、`PUT`、`POST`
    和 `DELETE`）的概念，并且被服务器和客户端完全理解。
- en: A resource's desired state can be represented within a client's request message.
    A resource's current state may be embodied within the response message that comes
    back from a server. As an example, a wiki page editor client may use a request
    message to transfer a representation that suggests a page update (new state) for
    a server-managed web page (resource). It is up to the server to accept or deny
    the client's request.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 资源期望的状态可以表示在客户端的请求消息中。资源当前的状态可能体现在从服务器返回的响应消息中。例如，一个维基页面编辑器客户端可能使用请求消息来传输表示，该表示建议更新服务器管理的网页（资源）的新状态。服务器决定接受或拒绝客户端的请求取决于服务器。
- en: 'Self-descriptive messages may include metadata to convey additional details
    regarding the resource state, the representation format and size, and even the
    message itself. An HTTP message provides headers for organizing the various types
    of metadata into uniform fields. The following diagram depicts a sample request
    and its headers, and the server response for the same request along with its headers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 自描述消息可能包括元数据，以传达有关资源状态、表示格式和大小以及甚至消息本身的额外细节。HTTP 消息提供了头部，用于将各种类型的元数据组织成统一的字段。以下图表展示了一个示例请求及其头部，以及针对同一请求的服务器响应及其头部：
- en: '![](img/dba3d5a4-86a9-4508-bb00-01c5553a305f.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dba3d5a4-86a9-4508-bb00-01c5553a305f.png)'
- en: 'So a self-descriptive message in REST style is all about not maintaining state
    between client and server, and needs to carry enough information about itself
    or explain with explicit states. So in the following table, you can see the self-descriptive
    messages with examples:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 REST 风格下的自描述消息就是关于客户端和服务器之间不维护状态，并且需要携带足够关于自身的信息或用显式状态进行解释。所以，在以下表格中，你可以看到带有示例的自描述消息：
- en: '| **Resource** | `GET` | `PUT` | `POST` | `DELETE` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **资源** | `GET` | `PUT` | `POST` | `DELETE` |'
- en: '|  `booktitles.com/resources` | Get all resources belonging to the collection
    | Replace with another collection | Create the collection | Delete the whole collection
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `booktitles.com/resources` | 获取属于该集合的所有资源 | 替换为另一个集合 | 创建该集合 | 删除整个集合 |'
- en: '|  `booktitles.com/resources/title18` | Lookup for title 18 | Modify title
    18 | Create new resource as title 18 | Delete title 18 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `booktitles.com/resources/title18` | 查找第 18 个标题 | 修改第 18 个标题 | 创建新的资源作为第
    18 个标题 | 删除第 18 个标题 |'
- en: Hypermedia as the Engine of Application State
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态引擎
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is one of the
    most critical constraints; without addressing it, services cannot be termed RESTful
    services. However, before we get into the details of HATEOAS, let''s get a brief
    idea about the **Richardson Maturity Model** (**RMM**) as it is an essential reference
    and serves as a guide to any RESTful services to follow the HATEOAS constraints.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态引擎**（**HATEOAS**）是其中最重要的约束之一；如果不解决它，服务就不能被称为 RESTful 服务。然而，在我们深入探讨
    HATEOAS 的细节之前，让我们先简要了解一下 **理查德森成熟度模型**（**RMM**），因为它是一个重要的参考，并作为任何 RESTful 服务遵循
    HATEOAS 约束的指南。'
- en: 'The RMM is a model developed by Leonard Richardson, and it breaks down the
    principal elements of the REST approach to **Resources**, **HTTP Verbs**, and
    **Hypermedia Controls**. The following diagram depicts the RMM''s four levels,
    and those levels are used to grade the APIs; that is, the better the API adheres
    to these constraints, the higher the scores are:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: RMM 是由伦纳德·理查德森开发的一个模型，它将 REST 方法的主要元素分解为 **资源**、**HTTP 动词** 和 **超媒体控制**。以下图表展示了
    RMM 的四个级别，这些级别被用来评估 API；也就是说，API 越遵守这些约束，得分就越高：
- en: '![](img/0be91c7a-d407-4a44-8139-bdd53eccdd89.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0be91c7a-d407-4a44-8139-bdd53eccdd89.png)'
- en: So, an API is fully qualified to be a RESTful API only when it scores **Level-3**.
    We will see more guidelines for how APIs can be RESTful APIs later in this chapter.
    However, now you know why we touched on the RMM here before we move on to HATEOAS.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有当 API 得分达到 **Level-3** 时，它才完全有资格成为 RESTful API。我们将在本章的后面部分看到更多关于如何使 API
    成为 RESTful API 的指南。然而，现在你知道为什么我们在转向 HATEOAS 之前在这里提到了 RMM。
- en: Once the client gets the initial response to its resource request from the server,
    it should be able to move to the next application state by picking up hyperlinks
    from the same received response.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端从服务器收到其资源请求的初始响应，它应该能够通过从同一响应中获取超链接来移动到下一个应用状态。
- en: Let's take an example to explain the preceding statement. Say a client will
    `POST` a representation of a new `TODO` item to the server, then the state of
    the Task Manager application will change by growing the list of the `TODO` item
    and both `POST` and `GET` are accomplished via hypermedia links.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来解释前面的陈述。假设一个客户端将新`TODO`项的表示`POST`到服务器，然后任务管理器应用程序的状态将通过增加`TODO`项列表而改变，而`POST`和`GET`都是通过超媒体链接完成的。
- en: Resource representations are shared by sending self-descriptive messages to
    any identified resources. Then, they change the state of the application, and
    the client with the received hypermedia links will move to the next application
    state.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向任何已识别的资源发送自描述消息来共享资源表示。然后，它们改变应用程序的状态，并且具有接收到的超媒体链接的客户端将移动到下一个应用状态。
- en: In an HTML browser, `GET` methods are accomplished by clicking on anchor tags
    (`<a>`) that have an HREF attribute, and HREF contains a resource URI. `POST`
    methods are achieved by pressing the Submit button within a `<form>` tag that
    has an action URI attribute. The anchor (`<a>`) and form (`<form>`) tag elements
    were sent to the client as part of the representation of the client requested
    resource.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML浏览器中，`GET`方法是通过点击具有HREF属性的锚标签（`<a>`）来完成的，HREF包含资源URI。`POST`方法是通过在具有action
    URI属性的`<form>`标签内按下提交按钮来实现的。锚（`<a>`）和表单（`<form>`）标签元素作为客户端请求的资源表示的一部分发送给客户端。
- en: The web contracts (sharing representations) are expressed regarding media types;
    a client that calls the service would know the media types and how to process
    the content as well. So the application enables the server to inform the client
    of possible ways to change its application state via hypermedia.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 网络合约（共享表示）是关于媒体类型的；调用服务的客户端将知道媒体类型以及如何处理内容。因此，应用程序使服务器能够通过超媒体通知客户端改变其应用状态的可能方式。
- en: Some media types work well (in harmony) with the web, and they are called **hypermedia**
    formats. The formats that host URIs and links are hypermedia formats.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一些媒体类型与网络很好地（和谐地）工作，它们被称为**超媒体**格式。包含URI和链接的格式是超媒体格式。
- en: Plain old XML is not hypermedia-friendly as it doesn't carry the links and protocols.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的XML并不适合超媒体，因为它不携带链接和协议。
- en: 'The following diagram depicts a sample JSON response from a server without
    and then **With HATEOAS** (with links and HREFs):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了服务器在没有和**带有HATEOAS**（带有链接和HREFs）的情况下返回的样本JSON响应：
- en: '![](img/1c9713f8-a8c6-4124-9115-652915fd92a5.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c9713f8-a8c6-4124-9115-652915fd92a5.png)'
- en: 'Before we conclude this section, let''s have a recap of HATEOAS:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结这一节之前，让我们回顾一下HATEOAS：
- en: HATEOAS means an application state representation (resource) that includes links
    to related resources. The absence or presence of a link on a page is an essential
    part of the resource's current state and so is essential for the RESTful APIs.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS意味着一个包含指向相关资源链接的应用状态表示（资源）。页面上链接的存在或缺失是资源当前状态的一个基本部分，因此对于RESTful API来说是至关重要的。
- en: A URI is a differentiator of REST architectural style, and defining the URIs
    is really critical, as it will be around for a very long time. So it is crucial
    to evaluate the links (when they change), keeping their future in mind, or put
    it in a simpler way, the *URI should stay the same regardless of the many changes
    its representations go through*. There is an interesting read about this at [https://www.w3.org/Provider/Style/URI.html.en](https://www.w3.org/Provider/Style/URI.html.en);
    it supports this point in great detail, and we encourage you to have a look.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI是REST架构风格的区分器，定义URI非常重要，因为它将存在很长时间。因此，考虑到它们的未来，评估链接（当它们改变时）是至关重要的，或者简单地说，*URI应该在其表示经历许多变化后保持不变*。关于这一点有一个有趣的阅读材料在[https://www.w3.org/Provider/Style/URI.html.en](https://www.w3.org/Provider/Style/URI.html.en)；它详细支持了这个观点，我们鼓励您查看。
- en: Layered systems
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层系统
- en: 'In general, a layered system consists of layers with different units of functionality.
    The essential characteristics of layered systems are that a Layer communicates
    by means of pre-defined interfaces and communicate only with the layer above or
    layer below, and the layers above rely on the layers below to it to perform its
    functions. Layers can be added, removed, modified, or reordered as the architecture
    evolves. Consider the following diagram of layers:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分层系统由具有不同功能单元的层组成。分层系统的基本特征是层通过预定义的接口进行通信，并且只与上层或下层通信，上层的层依赖于下层的层来执行其功能。随着架构的发展，层可以添加、删除、修改或重新排序。考虑以下层的图示：
- en: '![](img/afb40908-19e7-428c-adae-2bd8a2ba2b12.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb40908-19e7-428c-adae-2bd8a2ba2b12.png)'
- en: 'So, let''s start with an example. The REST style allows services to make use
    of a layered system architecture where we deploy the REST APIs on server A, store
    data on server B, and authenticate with server C. The client calling the REST
    API doesn''t have any knowledge of the servers the services use:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从一个例子开始。REST 风格允许服务利用分层系统架构，其中我们在服务器 A 上部署 REST API，在服务器 B 上存储数据，并通过服务器
    C 进行身份验证。调用 REST API 的客户端对所使用的服务器没有任何了解：
- en: '![](img/f3969d73-0cab-4fb3-aa1d-3fd5b1769ec4.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3969d73-0cab-4fb3-aa1d-3fd5b1769ec4.png)'
- en: The REST architectural style suggests services can consist of multiple architectural
    layers. The layers will have published service contracts or intermediaries. The
    logic within a given layer cannot have knowledge beyond the immediate layers above
    or below it within the solution hierarchy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: REST 架构风格建议服务可以由多个架构层组成。这些层将具有已发布的服务合同或中间件。给定层中的逻辑不能超出解决方案层次结构中直接上层或下层的层。
- en: Intermediaries are the layers present between the client and the server and
    can be added or removed, more importantly, without changing the interfaces between
    components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是存在于客户端和服务器之间的层，可以添加或删除，更重要的是，不会改变组件之间的接口。
- en: 'The intermediaries have the following properties:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件具有以下特性：
- en: Intermediaries can be event-driven middleware components to establish processing
    layers between consumers and services
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件可以是事件驱动的中间件组件，在消费者和服务之间建立处理层
- en: They can be proxies (selected by the client to provide interfaces with data
    translation services, enhanced performance, or security protections)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也可以是代理（由客户端选择，以提供数据转换服务、增强性能或安全保护）
- en: They can be gateways as well (chosen by the server or the network, and used
    for data translation, security enforcement, and performance enhancements)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也可以是网关（由服务器或网络选择，用于数据转换、安全实施和性能提升）
- en: A client may not be able to tell whether it is connected to the services directly
    with the server endpoint, or to an intermediary before reaching the actual server.
    Intermediary servers help to attain improved system scalability by having load
    balancers and shared caches. Layers may also enforce security policies for their
    calling clients.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可能无法判断它是直接连接到服务器的端点，还是连接到实际服务器之前的中间件。中间件服务器通过拥有负载均衡器和共享缓存来帮助实现系统可扩展性的提升。层还可以为其调用客户端实施安全策略。
- en: 'It would be helpful for us to understand a few applications of layered systems
    (design), so let''s look at the following points:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 了解分层系统（设计）的一些应用将对我们有所帮助，因此让我们看看以下要点：
- en: Enables the service clients to invoke the services; the service that is called
    by the client doesn't reveal any information about other services it's using to
    process the client requests. In other words, the service consumer (client) only
    knows about the service it directly calls and doesn't know about other services
    consumed by the called service to process its requests.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许服务客户端调用服务；被客户端调用的服务不透露任何关于它用于处理客户端请求的其他服务的任何信息。换句话说，服务消费者（客户端）只知道它直接调用的服务，不知道被调用服务所消费的其他服务。
- en: The messages between the client and the server are processed by intermediaries helping
    to free the clients from the runtime message processing logic and making them
    unaware of how those messages are processed in other layers as well.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的消息由中间件处理，帮助客户端从运行时消息处理逻辑中解放出来，并使其不知道这些消息在其他层是如何处理的。
- en: It's very critical for stability and scalability to add or remove layers in
    the layered system without any changes to the service consumers.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分层系统中，在不改变服务消费者的情况下添加或删除层对于稳定性和可扩展性至关重要。
- en: Request and response messages won't divulge any details to the recipients about
    which layer the message comes from.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应消息不会向接收者透露任何关于消息来自哪一层的细节。
- en: 'While layered systems bring additional latency and overhead as a drawback,
    there are trade-offs that are the benefits of layers and layered system designs,
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分层系统作为缺点带来了额外的延迟和开销，但权衡利弊，层和分层系统设计的好处如下：
- en: Encapsulates legacy services
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装遗留服务
- en: Introduces intermediaries
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入中间件
- en: Limits system complexity
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制系统复杂性
- en: Improves scalability
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可扩展性
- en: Code on demand
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按需代码
- en: In distributed computing, **code on demand** (**COD**) is any technology that
    enables the server to send the software code to the clients to be executed on
    the client computer upon request from the client's software. Some well-known examples
    of the COD paradigm on the web are Java applets, the Adobe ActionScript language
    for the Flash player, and JavaScript.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算中，**按需代码**（**COD**）是指任何能够使服务器根据客户端软件的请求，将软件代码发送到客户端并在客户端计算机上执行的技术。网络中COD范例的知名例子包括Java小程序、Adobe
    ActionScript语言（用于Flash播放器）和JavaScript。
- en: 'The following can also be called the advantages of COD:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也可以称为COD的优点：
- en: COD is the optional constraint of REST and intends to allow business logic within
    the client web browser, applets, JavaScript, and ActionScript (Flash). I think
    video on demand sites are good examples of COD, as the video data files are downloaded
    and played according to the client system's specifications.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COD是REST的可选约束，旨在允许在客户端网络浏览器、小程序、JavaScript和ActionScript（Flash）中实现业务逻辑。我认为按需视频网站是COD的好例子，因为视频数据文件是根据客户端系统的规格下载和播放的。
- en: Only one optional constraint according to REST architectural style and it is
    COD. COD allow it clients to be flexible because the server that decides how specific
    items need to be handled on the client side. For instance, with COD, a client
    may download action scripts such as JavaScript, Applets (not widely used these
    days), Flex scripts to encrypt the client-server communication, so the underlying
    servers won’t aware of any specific encryption methods used in the process.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据REST架构风格，只有一个可选约束，即COD。COD允许客户端具有灵活性，因为服务器决定在客户端如何处理特定项目。例如，使用COD，客户端可以下载动作脚本，如JavaScript、小程序（如今不太常用）、Flex脚本以加密客户端-服务器通信，这样底层服务器就不会意识到在过程中使用了任何特定的加密方法。
- en: COD can also be applied to services and service consumers. For instance, service
    design can enable the servers to dynamically defer some portions of logic to the
    service client programs. This approach of delaying code execution to the client
    side is justifiable when service logic can be executed by the consumer more efficiently
    or effectively.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COD也可以应用于服务和服务消费者。例如，服务设计可以使服务器动态地将一些逻辑部分推迟到服务客户端程序。当服务逻辑可以由消费者更有效地或更有效地执行时，将代码执行延迟到客户端的做法是合理的。
- en: RESTful applications may very well be able to utilize clients that support COD.
    For instance, web browsers can allow servers to return scripts or links that can
    be executed at the client side. This sort of additional code execution helps to
    expand the capabilities of the client, without needing the user to install new
    client software.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful应用程序可能非常能够利用支持COD的客户端。例如，网络浏览器可以允许服务器返回可以在客户端执行的脚本或链接。这种额外的代码执行有助于扩展客户端的功能，而无需用户安装新的客户端软件。
- en: In the COD style, a client component has access to a set of resources, but not
    the know-how of how to process them. It sends a request to a remote server for
    the code representing that know-how, receives that code, and executes it locally.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在按需代码风格中，客户端组件可以访问一组资源，但不知道如何处理这些资源。它向远程服务器发送请求以获取表示这些知识的代码，接收该代码并在本地执行它。
- en: However, the down side of using COD is reduces the visibility of the underlying
    API, and not every API prefers these kind of flexibility.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用COD的缺点是降低了底层API的可见性，并不是每个API都喜欢这种灵活性。
- en: COD is classified as optional; architectures that do not use this feature can
    still be considered RESTful.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: COD被视为可选的；不使用此功能的架构仍可被视为RESTful。
- en: RESTful service mandates
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful服务规范
- en: In one of the online discussion forums, Roy Fielding recorded his frustration
    about a service that claims to be RESTful, but that service is a mere HTTP-based
    interface. The service was not fulfilling all the necessary REST architecture
    constraints. He even said that if the Engine of Application State (and hence the
    API) is not being driven by hypertext, then it *cannot* be RESTful and *cannot*
    be a REST API*.*
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个在线讨论论坛中，罗伊·菲尔德记录了他对一种声称自己是RESTful的服务的不满，但这种服务仅仅是基于HTTP的接口。该服务没有满足所有必要的REST架构约束。他甚至说，如果应用状态引擎（以及因此API）不是由超文本驱动的，那么它*不能*是RESTful的，*不能*是REST
    API*.*
- en: With that said, any services that need to be termed RESTful must strictly adhere
    to the mandatory REST architecture constraints. Those constraints are design rules
    that are applied to establish the distinct characteristics of the REST architectural
    style.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，任何需要被称为RESTful的服务都必须严格遵循强制性的REST架构约束。这些约束是应用于建立REST架构风格独特特性的设计规则。
- en: 'Roy, the founder of the REST style, enforces the following REST constraints
    as mandatory for any web service to be qualified as RESTful. These mandatory constraints
    are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: REST风格的创始人罗伊，强制执行以下REST约束，作为任何要被认定为RESTful的Web服务的强制性要求。这些强制性约束如下：
- en: Client-server
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: Statelessness
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cache
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Interface/uniform contract
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口/统一契约
- en: Layered system
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: The optional REST constraint is COD (architectures that do not use this feature
    can still be considered RESTful)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的REST约束是COD（不使用此功能的架构仍可被认为是RESTful）
- en: Each constraint is a predetermined design decision and will have positive and
    negative influences on the services. However, these constraints are meant to provide
    a better architecture that resembles the web (perhaps positive impacts balanced
    with negative consequences).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个约束都是一个预定的设计决策，并将对服务产生积极和消极的影响。然而，这些约束旨在提供更好的架构，使其类似于网络（可能是积极影响与消极后果的平衡）。
- en: There may be a need for potential trade-offs when deviating from REST constraints.
    Ensure those trade-offs don't weaken or eliminate the mandated constraints. If
    so, that architecture may no longer conform to REST, or in other words, the services
    (architecture) are not RESTful.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在偏离REST约束时，可能需要做出潜在的权衡。确保这些权衡不会削弱或消除规定的约束。如果是这样，该架构可能就不再符合REST，换句话说，服务（架构）就不是RESTful的。
- en: Architectural goals of REST
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST的架构目标
- en: 'The REST architectural style brings a set of properties that help to establish
    the design goals that are embedded in the application of REST constraints. These
    properties are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构风格带来了一组属性，有助于建立嵌入在REST约束应用中的设计目标。这些属性如下：
- en: Performance
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Scalability
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Simplicity
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性
- en: Modifiability
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可修改性
- en: Visibility
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Portability
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性
- en: Reliability
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Testability
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: The preceding properties signify a target state of software architecture and
    fundamental qualities of the WWW. Adhering to REST constraints in design decisions
    helps to achieve the preceding listed goals, and, of course, these properties
    can be further improved with more design decisions that are not necessarily parts
    of REST. However, as quoted in the *RESTful services mandate* section, a web service,
    to be called a RESTful service, should adhere to the RESTful constraints.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 前述属性标志着软件架构的目标状态和万维网的基本品质。在设计决策中遵循REST约束有助于实现上述列出的目标，当然，这些属性可以通过更多不是REST必要部分的设计决策进一步改进。然而，正如在*RESTful服务要求*部分引用的那样，一个被称为RESTful服务的Web服务应该遵守RESTful约束。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's summarize what we have covered in this chapter and what we can take away
    in the context of the REST architectural style. We started with a brief history
    of the evolution of the World Wide Web, its layers, and its architecture. Then
    we moved on to the web API, a development model for web services, and how REST-based
    services communicate with existing web protocols with simplified representations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所涵盖的内容，以及我们在REST架构风格背景下可以吸取的教训。我们从一个关于万维网演变、其层和其架构的简要历史开始。然后我们转向Web
    API，它是Web服务的一个开发模型，以及基于REST的服务如何通过简化的表示与现有的Web协议进行通信。
- en: We looked briefly at SOA and also in more detail at ROA. We covered the purpose
    of ROA (to use simplified, well-understood and well-known web technologies along
    with core design principles), its principles, and its characteristics as well.
    After setting the ground with ROA, we got introduced to the concept of REST; the
    mandatory constraints of REST architecture, such as client-server, statelessness,
    cacheable, uniform interface, and layered systems; and also the optional code
    on demand constraints.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地探讨了SOA，并更详细地研究了ROA。我们涵盖了ROA的目的（使用简化、易于理解和广泛认可的Web技术以及核心设计原则），其原则以及其特性。在为ROA打下基础之后，我们了解了REST的概念；REST架构的强制性约束，如客户端-服务器、无状态、可缓存、统一接口和分层系统；以及可选的按需代码约束。
- en: As part of a uniform interface, we learned its four guiding principles, which
    are the identification of resources, manipulation of resources, self-descriptive
    messages, and HATEOAS, and we also touched upon the importance of the RMM to get
    a foundation for building RESTful services.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作为统一接口的一部分，我们学习了其四个指导原则，即资源的识别、资源的操作、自描述消息和HATEOAS，我们还简要提到了RMM的重要性，以获得构建RESTful服务的基础。
- en: This chapter described in detail the five mandatory constraints and how in Roy's
    view they define an architectural style as RESTful. It is critical to understand
    what makes REST RESTful and what does not.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细描述了五个强制性约束以及Roy如何看待它们定义了RESTful的架构风格。理解什么是RESTful以及什么不是RESTful至关重要。
- en: We concluded this chapter with a quick introduction to the software architecture
    properties of the WWW, and how REST constraints help to achieve the architecture
    goals of REST, such as performance, scalability, and simplicity.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过快速介绍WWW的软件架构属性以及REST约束如何帮助实现REST的架构目标，如性能、可扩展性和简单性来结束这一章，这些目标包括性能、可扩展性和简单性。
- en: I hope you have enjoyed this chapter. In the next chapter, we will learn about
    API design strategies, such as self-service enablement, resource collaboration,
    and how to address security and scalability concerns along with RESTful API guidelines
    and constituents.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你们喜欢这一章。在下一章中，我们将学习API设计策略，例如自助服务启用、资源协作，以及如何解决安全性和可扩展性问题，同时遵循RESTful API指南和组成部分。
