- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to PyCharm – the Most Popular IDE for Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 简介 – 最受欢迎的 Python 集成开发环境
- en: Welcome to the second edition of *Hands-On Application Development with PyCharm*!
    Most programmers have the objective to build robust, high-quality software that
    can stand the test of time. The most important step to reach this goal is choosing
    the correct language. With so many languages out there, which is the best one
    to choose? A stellar programmer will take many things about the language into
    consideration. One of the most important aspects of the programming language to
    consider is the support tools that are necessary for the development stages. The
    **Python** programming language is rumored to enable great productivity compared
    to many other languages. Python’s famous *batteries included* philosophy embodies
    this idea by bundling a powerful standard library, a code editor, and a debugger.
    Everything is built into the language’s normal installer, which is available from
    [https://www.python.org](https://www.python.org). There’s just one small problem,
    at least for me – Microsoft.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到《PyCharm 实战应用开发》的第二版！大多数程序员的目标是构建健壮、高质量的软件，这些软件能够经受时间的考验。实现这一目标最重要的步骤是选择正确的语言。在这么多语言中，哪一种是最好的选择呢？一位杰出的程序员会考虑很多关于语言的因素。在编程语言中需要考虑的最重要方面之一是开发阶段所需的工具支持。据说
    **Python** 编程语言与其他许多语言相比，能够极大地提高生产力。Python 著名的 *batteries included* 哲学通过捆绑一个强大的标准库、一个代码编辑器和调试器来体现这一理念。所有这些都被整合到了语言的正常安装程序中，可以从
    [https://www.python.org](https://www.python.org) 获取。但至少对我来说，有一个小问题——微软。
- en: I know what you’re thinking. You’ve just mentally prepared yourself for a protracted
    rant from one of those **Unix**/**Linux** guys complaining about the big, bad
    evil that is Microsoft. I’m not going to do that because I’m not sure I’m a Linux
    guy. I mean, I do have an awful lot of cargo pants in my closet. I can’t help
    it. They’re just so roomy and you can carry all of your stuff without dragging
    a bag around with you. I’ll also admit to having a great many T-shirts with emblems,
    logos, or statements that maybe only 5% of the people I encounter will understand.
    These T-shirts are very funny, but the only grins I get are from my colleagues.
    The more I think about it, I’m not a Linux guy. To me, Linux is a tool. Sometimes,
    it’s the right one, but sometimes, it isn’t. Since I’m not a Linux fanboy, that
    can’t be the reason for my statement that Microsoft is the problem. The real reason
    is quite the opposite. About 30 or so years ago, Microsoft did something massively
    right. They created the first really good commercially available **integrated
    development** **environment** (**IDE**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你们在想什么。你们已经在心理上准备好听一位那些 **Unix**/**Linux** 的人抱怨微软这个大坏蛋了。但我不打算这么做，因为我并不确定自己是不是一个
    Linux 的人。我的意思是，我确实有很多条卡其裤在衣柜里。我无法控制自己。它们真是太宽松了，你可以携带所有东西而不需要拖着包走来走去。我还要承认，我有很多带有徽章、标志或可能只有我遇到的5%的人能理解的说法的T恤。这些T恤非常有趣，但我得到的唯一笑容都是来自我的同事。越想越觉得，我并不是一个
    Linux 的人。对我来说，Linux 只是一个工具。有时候，它是正确的选择，但有时候，它并不是。既然我不是一个 Linux 迷，那么这不能成为我声称微软是问题的原因。真正的理由正好相反。大约30年前，微软做了一件非常正确的事情。他们创造了第一个真正好的商业化的
    **集成开发** **环境** (**IDE**)。
- en: In truth, it may have been more than 30 years ago, and there may have been others
    before it. However, many “senior developers” in the software business today got
    their start with a Microsoft product called **Visual Basic** (**VB**). OK; this
    is the part where the language snobs sneer and hold their noses as though they
    were just presented with a plate of Brussels sprouts, or maybe a dirty diaper,
    but let’s reel it back in. 30 years ago, most people rocking home computers only
    had a handful of options. **Beginners All-Purpose Symbolic Instruction Code**
    (**BASIC**) shipped with just about every computer made from 1978 forward. It
    was an age when not even Apple had a **graphical user interface** (**GUI**) on
    their **operating system** (**OS**). That didn’t happen until 1983 when Apple
    released Lisa. We had mice, and we could create programs capable of working with
    pointing devices, but the OS didn’t have a windowing system. They didn’t need
    a windowing system because back then, computers could only run one program at
    a time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这可能是30多年前的事情了，也许在此之前就有其他类似的产品。然而，今天软件行业的许多“资深开发者”都是从微软的**Visual Basic**（**VB**）产品开始起步的。好吧；这就是那些语言精英们开始嘲笑并皱起鼻子，好像刚刚被端上了一盘卷心菜，或者可能是一块脏尿布，但让我们回到正题。30年前，那些拥有家用电脑的人只有少数几个选择。**所有用途符号指令代码**（**BASIC**）几乎与1978年以后的每台计算机一起发货。那是一个连苹果公司都没有在其**操作系统**（**OS**）上提供**图形用户界面**（**GUI**）的时代。这种情况直到1983年苹果发布Lisa才改变。我们有了鼠标，可以创建能够与指针设备协同工作的程序，但操作系统没有窗口系统。当时，计算机一次只能运行一个程序，所以不需要窗口系统。
- en: Writing desktop software for computers that lacked OS-level support for Windows
    was hard. There were no **software development kits** (**SDKs**) or **application
    programming interfaces** (**APIs**) to handle any of the heavy lifting. Writing
    software was mostly an exercise in tedium. You had to write hundreds of lines
    of box-drawing boilerplate code in a tool that was barely better than Notepad.
    Then, one day in 1991, the year I graduated from the University of Oklahoma, it
    all changed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为那些缺乏Windows操作系统级别支持的计算机编写桌面软件是件困难的事情。没有**软件开发工具包**（**SDK**）或**应用程序编程接口**（**API**）来处理任何繁重的工作。编写软件几乎是一项单调乏味的练习。你必须在几乎和记事本一样糟糕的工具中编写数百行框绘制样板代码。然而，就在1991年，也就是我从俄克拉荷马大学毕业后的一年，一切都变了。
- en: Microsoft released a version of BASIC that included the ability to create **desktop
    GUIs** right there in the development environment. They called it *Visual Basic*.
    The first versions ran in **Microsoft’s Disk Operating System** (**MS-DOS**),
    but later, we got support for Windows, Windows 2, and then Windows 3.1\. Windows
    3.1 was significant because that’s when we got true multitasking if our PC was
    equipped with an 80386 processor. PCs were no longer limited to running one program
    at a time, and the Windows OS made mouse-driven interaction ubiquitous.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 微软发布了一个版本的BASIC，它允许在开发环境中直接创建**桌面GUI**。他们称之为*Visual Basic*。最初版本在**微软的磁盘操作系统**（**MS-DOS**）上运行，但后来我们得到了对Windows、Windows
    2和Windows 3.1的支持。Windows 3.1的重要性在于，那时如果我们的PC配备了80386处理器，我们就能得到真正的多任务处理。PC不再受限于一次只能运行一个程序，Windows操作系统使得鼠标驱动的交互变得无处不在。
- en: 'Things got interesting with VB. Instead of coding an interface, you drew the
    interface. The IDE included a palette of components and a window. You could draw
    buttons, text boxes, and anything else you needed, directly onto the window. After
    you drew them, you would then “wire them together” with event handlers. What you
    drew was what showed up when you ran the program. The VB **user interface** (**UI**)
    was ultimately carried over into Microsoft’s Visual Studio. Even today, Visual
    Studio 2022 continues with the same features that were so groundbreaking in 1991\.
    *Figure 1**.1* shows the toolkit used to draw visual UIs for Windows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在VB（Visual Basic）时代，事情变得有趣起来。你不再需要编写接口代码，而是直接绘制界面。IDE（集成开发环境）中包含了一系列组件和窗口。你可以在窗口上直接绘制按钮、文本框以及其他你需要的东西。绘制完成后，你再用事件处理器将它们“连接”起来。你绘制的内容就是程序运行时显示的内容。VB的**用户界面**（**UI**）最终被整合进了微软的Visual
    Studio。即使今天，Visual Studio 2022仍然保留了1991年那些开创性的功能。*图1.1*展示了用于绘制Windows可视化UI的工具集：
- en: '![Figure 1.1: The Visual Studio IDE originated as a product called Visual Basic
    in 1991\. It defined the standards for what a good IDE should be](img/B19644_Figure_1.01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：Visual Studio IDE起源于1991年的Visual Basic产品。它定义了优秀IDE应该具备的标准](img/B19644_Figure_1.01.jpg)'
- en: 'Figure 1.1: The Visual Studio IDE originated as a product called Visual Basic
    in 1991\. It defined the standards for what a good IDE should be'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Visual Studio IDE起源于1991年的Visual Basic产品。它定义了良好IDE应该具备的标准
- en: The VB3 IDE that began my career introduced even more ground-breaking features
    that my smug, cargo-pants-wearing Unix colleagues could only dream of. They were
    still fighting over vi’s superiority over Emacs, or vice versa, depending on whom
    you asked. Meanwhile, VB3 had colored syntax highlighting, support for editing
    multiple files, a graphical interface editor for drawing buttons and other screen
    widgets, and a visual programming tool that tied code, events, and GUI elements
    together. It had a debugging system you could use by simply clicking a line number.
    Doing so would create a red dot – a breakpoint in the code where the execution
    would stop during a test run, allowing the developer to inspect the state of the
    running program. It was pure coder nerd-vana! Love them or hate them, Microsoft’s
    VB IDEs defined what IDEs are supposed to be today. Nobody who has learned to
    code using a Microsoft IDE, whether it be a legacy language or a modern one, is
    willing to accept anything less than that experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那个开启我职业生涯的VB3 IDE引入了更多革命性的特性，我的那些自负、穿着工装裤的Unix同事只能梦想拥有。他们还在争论vi和Emacs谁更优越，或者反过来，这取决于你问的是谁。与此同时，VB3拥有彩色语法高亮、支持编辑多个文件、用于绘制按钮和其他屏幕小部件的图形界面编辑器，以及将代码、事件和GUI元素结合在一起的视觉编程工具。它有一个调试系统，你可以通过简单地点击行号来使用。这样做会在代码中创建一个红色圆点——一个在测试运行期间执行会停止的断点，允许开发者检查正在运行的程序的状态。这是一个纯粹的程序员乌托邦！无论你喜欢还是讨厌，微软的VB
    IDE定义了今天IDE应该是什么样子。任何使用微软IDE学习编码的人，无论是传统语言还是现代语言，都不愿意接受低于那种体验的东西。
- en: With every language that I’ve learned since, the first thing I always do is
    find the very best IDE available that offers those features I can’t live without.
    When I started working with Python 3 about six years ago, I found PyCharm. I used
    it to perform a full re-write on a complex **software-as-a-service** (**SaaS**)
    product, which took me about 18 months to complete. It was trial by fire. In this
    book, I intend to share what I learned, complete with scorch marks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我开始学习每一种语言以来，我总是首先寻找提供我无法离开的特性的最佳IDE。大约六年前，当我开始使用Python 3时，我发现了PyCharm。我用它对一个复杂的**软件即服务**（SaaS）产品进行了全面的重写，这个过程花费了我大约18个月的时间。这是一次真正的火炼。在这本书中，我打算分享我所学到的知识，包括所有的经验教训。
- en: Throughout this book, we will be learning about the general interface of the
    PyCharm IDE, along with customizations and extensions to help you adapt your tools
    to the kind of work you’ll be doing with Python. This first chapter discusses
    the merits of IDEs in general. I’ll provide a comparison of the most common tools
    used for Python development. Some of them are very good while others, despite
    being widely used, are fairly primitive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将学习PyCharm IDE的一般界面，以及自定义和扩展，以帮助您将工具适应您将使用Python进行的类型的工作。第一章讨论了IDE的一般优点。我将提供最常用于Python开发的工具的比较。其中一些非常好，而其他一些，尽管被广泛使用，但相当原始。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The purpose of PyCharm as a Python IDE and some notable details on its developing
    company, JetBrains
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm作为Python IDE的目的以及其开发公司JetBrains的一些显著细节
- en: The usage of PyCharm within the community and a breakdown of which professions
    tend to utilize PyCharm the most
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm在社区中的使用情况以及哪些职业倾向于最频繁地使用PyCharm
- en: A comprehensive outline regarding the advantages and disadvantages of using
    PyCharm, in comparison to other Python editors/IDEs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份关于使用PyCharm相对于其他Python编辑器/IDE的优缺点全面概述
- en: The differences between the Professional and Community editions of PyCharm and
    the additional functionalities that the paid edition offers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm专业版和社区版之间的区别以及付费版提供的额外功能
- en: On the other hand, if you have already decided that PyCharm is the Python IDE
    for you, feel free to jump to [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installing and Configuring PyCharm*, to go through the installation and registration
    process. If you have already downloaded and successfully set up PyCharm on your
    system, you might want to begin at the second section of this book, starting from
    [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters and*
    *Virtual Environments*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你已经决定PyCharm是你需要的Python IDE，那么请随意跳转到[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置PyCharm*，开始安装和注册过程。如果你已经下载并在你的系统上成功设置了PyCharm，你可能想从本书的第二部分开始，从[*第3章*](B19644_03.xhtml#_idTextAnchor052)，*自定义解释器和虚拟环境*开始。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is introductory, so we won’t be coding yet and the technical requirements
    are nil. It’s [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014) and I know you’re
    all fired up and ready to go and nil is boring. So, let’s get moving!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是入门性的，所以我们不会编写代码，技术要求为零。这是[*第1章*](B19644_01.xhtml#_idTextAnchor014)，我知道你们都热情洋溢，准备出发，零是无聊的。所以，让我们开始吧！
- en: 'First, here is what you will need to be successful with this book:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是你成功使用本书所需的东西：
- en: A computer. I know! It’s obvious, but I pride myself on being complete and leaving
    nothing to chance!
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台电脑。我知道！这很明显，但我以我的全面性而自豪，不留任何余地！
- en: An OS. This works best if it is installed on your computer already since we
    won’t cover how to do that in this book. Windows, macOS, Linux – it’s all the
    same as far as this book is concerned because PyCharm works in all three, and
    the UI is nearly identical in each environment.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统。如果它已经安装在你的电脑上，这将是最有效的，因为我们不会在这本书中介绍如何安装它。Windows、macOS、Linux——就本书而言，它们都是一样的，因为PyCharm在这三个环境中都能运行，并且每个环境的UI几乎相同。
- en: An installation of Python. We’re going to be using Python 3 exclusively in this
    book. There are a few different “flavors” of Python 3 but for the most part, the
    plain old Python 3 from [https://www.python.org](https://www.python.org) will
    be fine. We’ll get into those “flavors” later when we start talking about virtual
    environments in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing
    Interpreters and Virtual Environments*. If revision numbers give you comfort,
    the latest release at the time I’m writing this book is 3.11.1\. The Python revision
    I’m using in that production SaaS app I mentioned earlier is 3.8\. If your Python
    3 installation is older than that, you should update it.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Python。在这本书中，我们将仅使用Python 3。Python 3有几个不同的“风味”，但大部分情况下，从[https://www.python.org](https://www.python.org)下载的普通Python
    3就足够了。我们将在[*第3章*](B19644_03.xhtml#_idTextAnchor052)，*自定义解释器和虚拟环境*中讨论这些“风味”。如果修订号让你感到安心，我在写这本书时的最新版本是3.11.1。我之前提到的那个生产SaaS应用中使用的Python版本是3.8。如果你的Python
    3安装版本比这更旧，你应该更新它。
- en: At some point, a **GitHub** account might come in handy since I will be sharing
    the code from the book using a **Git** repository.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个时候，拥有一个**GitHub**账户可能会很有用，因为我会使用**Git**仓库分享书中的代码。
- en: The continued success of Python
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的持续成功
- en: 'In the first edition of this book, the author titled this section *The recent
    rise of Python*. Time has passed and I’m picking up where he left off. I think
    it’s important to point out that the *recent* rise has more or less continued
    since the first edition of this book was published. Python has continued to be
    one of the most popular and widely adopted languages for some very good reasons.
    One of those reasons is that Python stresses readability and uses a simple syntax.
    This allows newcomers to the language, and indeed to the field of software development,
    a quick path to success. Contrast that with the previously normal experience of
    forcing college and university students to learn C or C++ as their first language.
    These languages are terse and complicated and generally have a poor track record
    when it comes to developer productivity. Sure, C and C++ are powerful languages
    and can produce the most performant software available. However, in my experience,
    a language that can take you from “Hello World” to being able to produce useful
    software in a short period trumps the performance gains in all but the most extreme
    cases. **Guido van Rossum**, the creator of Python, compares the quickness of
    Python to other languages in his paper *OMG-DARPA-MCC Workshop on Compositional
    Software Architecture*. In the paper, van Rossum states that development in Python
    is estimated to be 3-5 times faster than that in Java, and 5-10 times faster than
    that in C/C++. Keeping this difference in mind, we can easily understand why Python
    is being so widely adopted. After all, time is money. You can find Guido van Rossum’s
    complete essay here: [http://www.python.org/doc/essays/omg-darpa-mcc-position/](http://www.python.org/doc/essays/omg-darpa-mcc-position/).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，作者将这一节标题为*Python的近期兴起*。时间已经过去，我将继续他留下的部分。我认为指出*近期*的兴起自本书第一版出版以来大致持续至今是很重要的。Python继续成为最受欢迎和广泛采用的语言之一，有非常好的理由。其中之一是Python强调可读性并使用简单的语法。这使得语言的新手，以及软件开发领域的初学者，能够快速成功。与此相对比的是，之前通常的做法是强迫大学生和大学生学习C或C++作为他们的第一语言。这些语言简洁而复杂，通常在开发者生产力方面有着糟糕的记录。当然，C和C++是强大的语言，可以产生最高性能的软件。然而，根据我的经验，一种可以在短时间内从“Hello
    World”到能够快速产生有用软件的语言，在所有但最极端的情况下，都胜过性能的提升。Python的创造者**吉多·范罗苏姆**在他的论文*OMG-DARPA-MCC关于组合软件架构的工作坊*中将Python的快速与其他语言进行了比较。在论文中，范罗苏姆表示，Python的开发速度估计比Java快3-5倍，比C/C++快5-10倍。考虑到这个差异，我们可以很容易地理解为什么Python被如此广泛地采用。毕竟，时间就是金钱。你可以在这里找到吉多·范罗苏姆的完整文章：[http://www.python.org/doc/essays/omg-darpa-mcc-position/](http://www.python.org/doc/essays/omg-darpa-mcc-position/)。
- en: The comparison between Python and Java or C/C++ is a weak one since these languages
    are designed and used for different applications. C and C++ are used when very
    high performance is required. Most OSs are written in C++, as are real-time systems
    such as those you’d find in a Tesla automobile or modern spacecraft. It isn’t
    necessarily fair to compare specific productivity between Python and C++ because
    they aren’t used to make the same types of applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python与Java或C/C++进行比较是微不足道的，因为这些语言是为不同的应用程序设计和使用的。当需要非常高的性能时，会使用C和C++。大多数操作系统都是用C++编写的，包括你在特斯拉汽车或现代航天器中找到的实时系统。比较Python和C++的具体生产力并不一定公平，因为它们不是用来制作相同类型的应用程序的。
- en: 'Java, on the other hand, is used to develop the same types of applications
    for which you might use Python: enterprise and web applications. Java, though,
    requires a lot of boilerplate. This means a developer has to create a lot of code
    and structures just to support the application’s existence before they can even
    think about writing code for the application itself. This boilerplate is largely
    absent from Python. Furthermore, Java relies on a very rigid, static object-oriented
    paradigm. Python, in contrast, is far more flexible, offering a dynamic programming
    model. Even though the two languages are used to make the same type of application,
    Python gives you some serious shortcuts, owing to its more flexible paradigm.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java，另一方面，被用于开发你可能使用Python来开发的相同类型的应用程序：企业级和Web应用程序。然而，Java需要大量的模板代码。这意味着开发者必须编写大量的代码和结构，仅仅是为了支持应用程序的存在，他们才能开始考虑为该应用程序本身编写代码。Python中几乎没有这种模板代码。此外，Java依赖于一个非常严格、静态的面向对象范式。相比之下，Python要灵活得多，提供了一种动态的编程模型。尽管这两种语言都用于制作相同类型的应用程序，但Python由于其更灵活的范式，为你提供了一些严重的捷径。
- en: 'These factors that comprise Python’s strengths, along with many others, have
    coalesced to form a very accessible development language supported by a community
    of raving fans. That community is still growing by introducing coding to a gamut
    of fields and professions distinct from those of us who historically focus solely
    on traditional application development. At the time of writing, the **TIOBE Index**,
    a ranking system for the popularity of programming languages, ranks Python as
    the number one language, as seen in *Figure 1**.2*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构成 Python 强大优势的因素，以及许多其他因素，共同凝聚成了一种非常易于使用的开发语言，得到了一群狂热粉丝的支持。这个社区仍在通过将编程引入与我们历史上仅专注于传统应用开发截然不同的众多领域和职业中不断壮大。在撰写本文时，**TIOBE
    指数**，一个用于编程语言流行度的排名系统，将 Python 排名为第一语言，如*图 1.2*所示：
- en: '![Figure 1.2: TIOBE rankings show Python to be the most popular language](img/B19644_Figure_1.02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：TIOBE 排名显示 Python 是最受欢迎的语言](img/B19644_Figure_1.02.jpg)'
- en: 'Figure 1.2: TIOBE rankings show Python to be the most popular language'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：TIOBE 排名显示 Python 是最受欢迎的语言
- en: Python has a huge standard library that provides anything you might need to
    build any kind of software you can imagine. If that statement proves false for
    your specific project, there is a vast third-party and largely open source ecosystem
    consisting of hundreds of thousands of libraries upon which you can build. You
    can find a catalog of these libraries at [https://pypi.org](https://pypi.org).
    Taking all this together, a new software developer can go from idea and zero Python
    experience to a production application very quickly. This process can be greatly
    accelerated by a good IDE.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有一个庞大的标准库，提供了你构建任何类型软件可能需要的任何东西。如果这个声明对你特定的项目不成立，那么有一个庞大的第三方和主要开源的生态系统，由数十万个库组成，你可以在此基础上构建。你可以在[https://pypi.org](https://pypi.org)找到这些库的目录。将所有这些因素综合考虑，一个新软件开发者可以从零
    Python 经验到生产应用程序非常快。这个过程可以通过一个好的 IDE 大大加速。
- en: The philosophy of IDEs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDEs 的哲学
- en: Back when I was your age, things were different. That is, of course, unless
    we are the same age, in which case everything was the same. We didn’t have the
    internet. When we wanted to learn new coding languages and techniques or understand
    the history of our craft, we were required to take a sacred pilgrimage. One year,
    I smuggled in a Polaroid. You can see the pictures I took in *Figure 1**.3*. You
    should understand that all of what I am about to tell you is both true and a closely
    guarded industry secret. Just so we’re clear, you didn’t hear this from me.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我年轻时，情况是不同的。当然，除非我们同龄，那样的话一切都会相同。我们没有互联网。当我们想要学习新的编程语言和技术，或者理解我们手艺的历史时，我们必须进行一次神圣的朝圣之旅。有一年，我偷带了一台宝丽来相机。你可以在*图
    1.3*中看到我拍的照片。你应该明白，我即将告诉你的所有内容都是真实的，同时也是被严格保守的行业秘密。为了明确起见，你没有从我这里听到这些。
- en: Hidden somewhere in a mystic range of mountains, seekers of great coding wisdom
    would ascend the 10,000 stairs by the light of the full moon in search of the
    Master. The journey was not easy, and the wisdom imparted had to be hard-earned.
    It was on one such crusade that I learned why good IDEs are so important. The
    Master said, “If you know the language, and you know the IDE, you need not fear
    the result of a hundred deployments.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个神秘的山脉深处，寻求伟大编程智慧的寻道者会在满月的光辉下攀登万级台阶，以寻找大师。这段旅程并不容易，所获得的智慧也必须是通过辛勤努力获得的。正是在这样的远征中，我学会了为什么好的
    IDE 如此重要。大师说：“如果你懂得语言，又懂得 IDE，你就不必担心一百次部署的结果。”
- en: "![Figure 1.3: High in the sacred mountains, up the 10,000 stairs\uFEFF,\uFEFF\
    \ lies the monastery where I learned to code](img/B19644_Figure_1.03.jpg)"
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：在神圣的山脉之巅，沿着万级台阶，坐落着我学习编程的寺庙](img/B19644_Figure_1.03.jpg)'
- en: 'Figure 1.3: High in the sacred mountains, up the 10,000 stairs, lies the monastery
    where I learned to code'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：在神圣的山脉之巅，沿着万级台阶，坐落着我学习编程的寺庙
- en: The Master often speaks in riddles, so let me explain. *Deployment* refers to
    a published iteration or an **increment** of your software. In most professional
    circumstances, the objective is to publish your software. If our objective is
    to publish, the next sticking point is that we must know a programming language.
    I assume you have at least a tacit understanding of programming in Python. That
    just leaves the Master’s reference to the IDE.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大师经常用谜语说话，所以让我来解释一下。*部署*指的是软件的发布迭代或**增量**。在大多数专业情况下，目标是发布软件。如果我们的目标是发布，下一个难点是我们必须知道一种编程语言。我假设你对Python编程至少有一个默许的理解。那么，只剩下大师对IDE的引用了。
- en: There are several classes of tools a developer might use to develop Python code.
    The Python language can be considered an interpreted language. We could argue
    that when it runs, some of the code is optimized into C code and cached, but at
    this stage, we aren’t worried about that level of detail. The point is that a
    Python program exists as simple plain text files and can be executed in that form.
    Contrast this with statically compiled languages such as C, C++, C#, Java, or
    Go. Those and many other languages require the code in the text files to undergo
    a compilation phase where a new executable file is produced. In C#, you can’t
    simply execute a `.cs` file. You need to compile it into a binary, then execute
    the binary. Since Python executes its code directly via the Python interpreter,
    the level of tooling needed to work on Python can be very simple. Essentially,
    any text editor will do. There are three levels of editor capability to choose
    from.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能会使用几种工具来开发Python代码。Python语言可以被认为是一种解释型语言。我们可以争论，当它运行时，一些代码被优化成C代码并缓存，但在这个阶段，我们并不关心这个层面的细节。重点是Python程序以简单的纯文本文件的形式存在，并且可以以这种形式执行。这与静态编译语言如C、C++、C#、Java或Go形成对比。这些以及许多其他语言要求文本文件中的代码经过编译阶段，生成新的可执行文件。在C#中，你不能简单地执行一个`.cs`文件。你需要将其编译成二进制文件，然后执行该二进制文件。由于Python通过Python解释器直接执行其代码，因此用于Python的工具级别可以非常简单。基本上，任何文本编辑器都可以。可以选择三种编辑器功能级别。
- en: The first is a simple text editor. Simple text editors are generally limited
    to opening, editing, and saving text. They are generic tools designed to work
    with any kind of text file, from grocery lists to `systemd` configurations. In
    Windows, you might know it as *Notepad*. On a Mac, you might use *TextPad*, and
    if you are rocking a Linux desktop such as `systemd` configuration is, don’t sweat
    it; it’s a system administration file on Linux. I just needed something that sounded
    complicated to characterize the more complex end of the text file gamut.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种是简单的文本编辑器。简单的文本编辑器通常限于打开、编辑和保存文本。它们是通用工具，旨在与任何类型的文本文件一起工作，从购物清单到`systemd`配置文件。在Windows上，你可能知道它叫做*记事本*。在Mac上，你可能使用*TextPad*，如果你在使用像`systemd`配置这样的Linux桌面，别担心；它是一个Linux的系统管理文件。我只是需要一个听起来很复杂的东西来描述文本文件范围更复杂的一端。
- en: 'The second evolution of programming editors is called *enhanced editors*. These
    editors are purposefully designed to work with technical files. Some popular examples
    include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编程编辑器的第二次进化被称为*增强型编辑器*。这些编辑器专门设计用于处理技术文件。以下是一些流行的例子：
- en: Visual Studio Code
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Atom
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Notepad++
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Notepad++
- en: UltraEdit
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UltraEdit
- en: Sublime Text
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text
- en: JetBrains Fleet
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Fleet
- en: Bluefish Editor
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bluefish编辑器
- en: IDLE (the editor that ships with Python)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDLE（随Python一起提供的编辑器）
- en: 'These tools are designed to work with a wide range of programming languages
    and can generally be easily customized to add support for emerging languages.
    Enhanced editors offer some common features that make a developer’s life a little
    nicer, such as these:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具旨在与各种编程语言一起工作，并且通常可以轻松定制以添加对新兴语言的支持。增强型编辑器提供了一些使开发者的生活更加舒适的常见功能，例如以下这些：
- en: Syntax highlighting, which color codes keywords and other semantic elements
    in your code.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法高亮，它将代码中的关键字和其他语义元素着色。
- en: Macros, which allow the developer to record and play back common keystrokes
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏，允许开发者记录和回放常见的快捷键
- en: Project and file organization to allow easy switching between multiple files
    that make up a project
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目和文件组织，以便于在构成项目的多个文件之间轻松切换
- en: Rudimentary code completion to reduce the amount of typing needed to write your
    code
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的代码补全，以减少编写代码时所需的输入量
- en: Plugin support for other niceties such as linters, spell checkers, file previews
    for your code, and more
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件支持其他小工具，如代码检查器、拼写检查器、代码预览等更多功能
- en: Over time, some of these enhanced editors have become very robust because you
    can customize and expand their capabilities. When you consider these tools as
    they are right out of the box, they are more useful and specialized than general
    text editors, but they fall short of qualifying as IDEs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，一些增强型编辑器已经变得非常健壮，因为你可以自定义和扩展它们的功能。当你考虑这些工具作为它们直接从盒子里出来时，它们比通用文本编辑器更有用和专业化，但它们不足以成为IDE。
- en: 'At the top of the code editor food chain is the **IDE**. If you were to look
    inside the cockpit of a fighter plane from the World War I era, you’d see a few
    simple controls and nothing more. If that’s a text editor, the IDE is the cockpit
    of a Boeing 747 aircraft. Every tool a developer could ever desire or need is
    crammed into a comparably complex UI. IDEs contain all the features of an enhanced
    text editor, but usually offer the following additional enhancements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编辑器的食物链顶端是**IDE**。如果你要从一战时期的战斗机驾驶舱内部看，你会看到一些简单的控制装置，再无其他。如果那是一个文本编辑器，IDE就像是波音747飞机的驾驶舱。每个开发者可能需要的或渴望的工具都被塞进了一个相对复杂的用户界面中。IDE包含了增强文本编辑器的所有功能，但通常还提供以下附加增强：
- en: Some easy ways to run your code right from the editor.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些直接从编辑器运行代码的简单方法。
- en: Tooling to help manage your source code repository, such as **Git** or **Subversion**.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助管理你的源代码仓库的工具，例如**Git**或**Subversion**。
- en: An integrated, easy-to-use debugger, which allows you to pause the execution
    of a running program and inspect or alter its current state.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集成、易于使用的调试器，它允许你暂停正在运行的程序并检查或修改其当前状态。
- en: Tools to help you write automated tests such as unit tests and run and visualize
    the results.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助你编写自动化测试，如单元测试，并运行和可视化结果的工具。
- en: Complex code completion is based on the introspection or indexing of the code
    in your project. In modern IDEs, this is enhanced using **artificial** **intelligence**
    (**AI**).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的代码补全基于项目代码的反射或索引。在现代IDE中，这通过使用**人工** **智能**（**AI**）得到增强。
- en: Profiling tools to help you find execution bottlenecks.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助你找到执行瓶颈的剖析工具。
- en: Integrated tooling to help with supplementary systems, such as databases.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成工具，帮助管理辅助系统，如数据库。
- en: Tools for deploying your code to a server or cloud environment right from the
    IDE.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IDE中直接部署你的代码到服务器或云环境的工具。
- en: 'Some popular examples of IDEs include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IDE的流行例子包括以下：
- en: Visual Studio (this is different from Visual Studio Code)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（这与Visual Studio Code不同）
- en: PyCharm
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm
- en: IntelliJ IDEA
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: NetBeans
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans
- en: Apple Xcode
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple Xcode
- en: Xamarin Studio
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin Studio
- en: Eclipse
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: As you can see, the IDE is the most powerful weapon in your coding arsenal.
    It is important to use the best one available to you. If you are new to software
    development, or maybe even not-so-new, you might wonder why the enhanced editors
    are so popular. At the time of writing, roughly 50% of developers use Visual Studio
    Code, which is not on my list of IDEs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，IDE是你编码武器库中最强大的武器。使用最好的IDE对你来说非常重要。如果你是软件开发的新手，或者甚至不是那么新手，你可能想知道为什么增强型编辑器如此受欢迎。在撰写本文时，大约50%的开发者使用Visual
    Studio Code，但这不在我的IDE列表中。
- en: Many developers prefer a more “lightweight” development environment. This is
    especially true of frontend web developers who swear by Sublime Text and Visual
    Studio Code. In truth, they need all the features of the IDE, and they use them,
    but they are spread out across different tools they use throughout the day. A
    frontend developer relies on profilers and debuggers that run in web browsers
    and they don’t need those tools in an IDE. Instead, they can get a simpler editor
    that downloads quickly, installs simply, and runs instantly when they click the
    icon in their OS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢一个更“轻量级”的开发环境。这对于前端Web开发者来说尤其如此，他们发誓使用Sublime Text和Visual Studio Code。事实上，他们需要IDE的所有功能，他们也确实在使用它们，但这些功能分散在他们每天使用的不同工具中。前端开发者依赖于在浏览器中运行的剖析器和调试器，他们不需要在IDE中这些工具。相反，他们可以获取一个更简单的编辑器，这个编辑器下载快速，安装简单，点击操作系统中的图标即可立即运行。
- en: I submit that if you are doing full stack web development or mobile development,
    or you need to work servers or containers, an IDE is a better choice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，如果你在进行全栈Web开发或移动开发，或者需要处理服务器或容器，IDE是一个更好的选择。
- en: There exists a certain class of software developer who swears you should never
    use anything other than the simplest possible tools. They believe that reliance
    on a tool to do coding and related hard work diminishes the overall mastery and
    accomplishment needed to be considered proficient. I couldn’t disagree more. One
    year, while at the monastery, the Master told me a story of a great swordsman
    from Japan named Miyamoto Musashi. In his day, every samurai knew of Musashi as
    the greatest living swordsman and all the samurai wanted to take a shot at defeating
    him. Back then, duels were usually fought to the death. One day, a dueling challenger
    met Musashi as he was getting off a boat. Musashi was unarmed. The challenger
    waited until Musashi could fashion a wooden sword, called a *bokken*, from one
    of the boat’s oars, which he intended to use in the dual. Legend has it Musashi
    made a fool of that challenger and left him alive, much to the challenger’s disgrace.
    Musashi, the Master said, was the finest warrior who ever lived, and his skill
    with a sword has never since been matched. However, if the objective were simply
    to defeat him, I could have easily done so with a machine gun.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一种特定的软件开发者，他们发誓你永远不应该使用除了最简单可能的工具以外的任何东西。他们认为，依赖工具来完成编码和相关的艰苦工作会减少被认为是熟练所需的总体掌握和成就。我完全不同意。有一年，在修道院的时候，大师给我讲了一个关于日本一位伟大的剑客宫本武藏的故事。在他那个时代，每个武士都知道宫本武藏是当时最伟大的剑客，所有的武士都想要尝试击败他。当时，决斗通常是生死之战。有一天，一个决斗挑战者在宫本武藏下船时遇到了他。宫本武藏没有带武器。挑战者等到宫本武藏从船的桅杆上制作出一把木剑，即*bokken*，他打算用它来进行决斗。据传说，宫本武藏让那个挑战者出丑，并且让他活着离开，这对挑战者来说是一种耻辱。大师说，宫本武藏是有史以来最优秀的战士，他的剑术至今无人能敌。然而，如果目标仅仅是击败他，我可以用机关枪轻易做到。
- en: In my opinion, limiting the tools you use owing to a sense of pride in your
    capability, or lack thereof, is foolish. The objective of a software developer
    is to ship software, usually on an unforgiving deadline. It isn’t to waste time
    trying to prove yourself to someone else’s standards, unless, of course, you’re
    a degree-seeking student. I’m sure there are a few of you reading this book. Play
    the game and do what your professors say. You should realize that once you graduate,
    everything changes. You will be expected to produce code quickly, accurately,
    and consistently. This is best achieved via the automation available in a good
    IDE. You should choose the best tool for the job at hand. I found PyCharm helped
    me to become productive while I was learning the Python language. When you start,
    and you’re not using an editor that corrects your line spacing and indents, you’re
    going to make a lot of silly mistakes. It’s frustrating. I’d think to myself,
    “If I were using C#, I’d be done by now.” I was even tempted to abandon Python
    and PyCharm for something more comfortable. However, that’s not what I wanted
    to do.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，因为对自己能力的自豪或缺乏自信而限制使用的工具是愚蠢的。软件开发者的目标是交付软件，通常是在一个不容宽恕的截止日期之前。这并不是为了试图证明自己符合别人的标准，除非，当然，你是寻求学位的学生。我相信这本书的读者中有一小部分人。玩好这个游戏，按照你的教授们说的去做。你应该意识到，一旦你毕业，一切都会改变。你将需要快速、准确、一致地编写代码。这最好通过一个好的集成开发环境（IDE）中可用的自动化来实现。你应该为手头的任务选择最好的工具。我发现PyCharm帮助我在学习Python语言时变得高效。当你开始时，如果你没有使用一个可以纠正你的行间距和缩进的编辑器，你将会犯很多愚蠢的错误。这很令人沮丧。我会想，“如果我现在用C#，我现在就完成了。”我甚至想放弃Python和PyCharm，去选择更舒适的东西。然而，那并不是我想做的。
- en: PyCharm will underline all those silly mistakes for you and correct them with
    the touch of a button! I learned, after seeing those mistakes underlined over
    and over, what to do when I’m using an editor without code inspection. Today,
    when I am working in other languages, I still use Python rules. Having learned
    Python with the help of PyCharm, I was able to ship faster, learn faster, and
    improve my code in other languages and tools. Do me a favor and never let anybody
    tell you you’re not a *real developer* because you didn’t do something their way.
    If they persist, tell them nano is better than vi or Emacs, and just walk away.
    Such a statement will probably cause their head to explode.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 会为你自动标记所有那些愚蠢的错误，并一键纠正！在我看到这些错误被反复标记后，我学会了在使用没有代码检查功能的编辑器时应该怎么做。如今，当我用其他语言工作时，我仍然使用
    Python 规则。在 PyCharm 的帮助下学习 Python，我能够更快地交付、更快地学习，并在其他语言和工具中改进我的代码。请帮个忙，永远不要让任何人告诉你你不是**真正的开发者**，因为你没有按照他们的方式做事。如果他们坚持，告诉他们
    nano 比 vi 或 Emacs 更好，然后离开。这样的声明可能会让他们的大脑炸裂。
- en: I’d like to make one more comment about Visual Studio Code. This editor has
    evolved through plugins to the point where it can compete with a fully featured
    IDE. However, this comes at a cost compared to a professionally developed IDE
    such as PyCharm. To get the identical features you’d find in PyCharm in Visual
    Studio Code, you’d need to install a large number of plugins. These plugins are
    all written by the community, which means they are all independent development
    efforts. These plugins will never work as cohesively as the base features you
    will find in an IDE such as PyCharm. This is also true when comparing Visual Studio
    with Visual Studio Code. Try creating a C# project in Visual Studio versus Visual
    Studio Code and you’ll find the process is dreamy and smooth in Visual Studio.
    Visual Studio Code, on the other hand, requires a lot of command-line work and
    lots of weird plugin installations. The experience just isn’t the same. The same
    observation holds with other editors such as vim, which can be heavily customized.
    You’ll spend a week messing with plugins and open source scripts to achieve, at
    best, partial parity with an IDE’s out-of-the-box functionality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想对 Visual Studio Code 说一点。这个编辑器通过插件的发展已经到了可以与功能齐全的 IDE 竞争的地步。然而，与 PyCharm
    这样的专业开发 IDE 相比，这需要付出代价。要在 Visual Studio Code 中获得 PyCharm 中找到的相同功能，你需要安装大量的插件。这些插件都是由社区编写的，这意味着它们都是独立开发的工作。这些插件永远不会像
    PyCharm 这样的 IDE 中的基础功能那样协同工作。当比较 Visual Studio 与 Visual Studio Code 时，这一点同样适用。尝试在
    Visual Studio 和 Visual Studio Code 中创建 C# 项目，你会发现 Visual Studio 的过程梦幻般顺畅。另一方面，Visual
    Studio Code 需要进行大量的命令行操作和奇怪的插件安装。体验完全不同。对于其他编辑器，如可以高度定制的 vim，也有同样的观察。你可能会花一周的时间摆弄插件和开源脚本，以实现与
    IDE 开箱即用功能的部分相似性。
- en: PyCharm as a Python IDE
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 作为 Python IDE
- en: It’s all well and good to talk about tool comparisons common to other languages.
    But we don’t care about that, do we? We want to know our options for Python! The
    best IDEs are typically specialized. PyCharm is specialized in working with Python.
    That’s it. When you create a new project in PyCharm, you’ll see options for Python
    projects and nothing else. Contrast this experience with Visual Studio. In my
    opinion, Visual Studio is the only close competitor to PyCharm when it comes to
    working with Python projects. When a project is created in Visual Studio, you
    will most likely spend a good five minutes trying to wade through the myriad of
    options. The IDE supports dozens of languages, and that is compounded by a dozen
    project types such as web, desktop, and others. Visual Studio is trying to be
    all things to all developers. PyCharm only wants to play with Python developers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然谈论与其他语言通用的工具比较很好，但我们并不关心那个，对吧？我们想知道 Python 的选项！最好的 IDE 通常都是专业的。PyCharm 专注于与
    Python 一起工作。仅此而已。当你使用 PyCharm 创建新项目时，你会看到 Python 项目的选项，没有其他选项。将这种体验与 Visual Studio
    进行对比。在我看来，Visual Studio 是 Python 项目中 PyCharm 的唯一接近的竞争对手。在 Visual Studio 中创建项目时，你很可能会花上好几分钟试图浏览众多选项。该
    IDE 支持数十种语言，并且由于有网页、桌面和其他十几种项目类型，这种支持被放大了。Visual Studio 正在试图成为所有开发者的万能工具。PyCharm
    只想与 Python 开发者玩耍。
- en: 'PyCharm itself was created with a few design goals in mind:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 本身是在几个设计目标下创建的：
- en: Intelligent coding assistance
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能编码辅助
- en: Streamlined programming tools
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程化编程工具
- en: Web development options
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页开发选项
- en: Scientific computing support
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学计算支持
- en: Visual debugging and performance profiling
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视调试和性能分析
- en: 'We’ll take a look at each of these design goals in turn, but first, I need
    to point something out. At the time I’m writing this, PyCharm is about to go through
    a big change. JetBrains is working on a brand-new user experience. By the time
    this book is published, there is a strong chance that this new UI will be the
    default. If you’re new to PyCharm, you should understand that you’re going to
    see it in two different ways for a while. The classic UI will continue to be available
    in the product for a time, allowing us to ease into the new experience. I’ve decided
    I’m going to embrace the new UI given the time between the first edition and this
    one is a few years. That said, it bears mentioning that you’re going to see the
    classic UI alongside the new UI until probably late 2024 when the old UI is no
    longer maintained. It will become deprecated and one day will disappear into the
    sands of time like Shelley’s fabled statue of Ozymandias:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次查看这些设计目标，但首先，我需要指出一点。在我撰写这篇文章的时候，PyCharm 即将经历一次重大变革。JetBrains 正在开发全新的用户体验。到这本书出版时，有很大可能性这个新用户界面将成为默认界面。如果你是
    PyCharm 的新用户，你应该知道你将暂时以两种不同的方式看到它。经典用户界面将在产品中继续存在一段时间，让我们能够逐渐适应新体验。鉴于第一版和这一版之间相隔几年，我决定我将接受新用户界面。话虽如此，值得一提的是，你将看到经典用户界面与新用户界面并排存在，直到可能到
    2024 年晚些时候，当旧用户界面不再维护时。它将变得过时，并有一天会像雪莱传说中的奥西曼迪亚斯雕像一样消失在时间的沙尘中：
- en: '![Figure 1.4: The new UI (top) compared to the classic UI (bottom)](img/B19644_Figure_1.04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：新用户界面（顶部）与经典用户界面（底部）的比较](img/B19644_Figure_1.04.jpg)'
- en: 'Figure 1.4: The new UI (top) compared to the classic UI (bottom)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：新用户界面（顶部）与经典用户界面（底部）的比较
- en: '*Figure 1**.4* shows the two UIs side by side. The design objective of the
    new UI is to reduce the clutter in the interface. They’re not wrong on that point.
    As the tool has grown over the years, more and more features have been crammed
    into the menus, making the UI a little bit daunting for new users. The biggest
    thing to realize is that most of the things you’d find in the menu are still there,
    but the menu system itself is hidden beneath the hamburger icon in the top-left
    corner of the screen. Don’t worry; I’ll cover this in detail later. As I write
    this, there is a setting we’ll review in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installing and Configuring PyCharm*, that allows you to toggle between the classic
    and new UIs.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1**.4* 展示了两个用户界面并排。新用户界面的设计目标是减少界面上的杂乱。在这方面他们并没有错。随着工具这些年的发展，越来越多的功能被塞进了菜单，使得界面对于新用户来说有点令人畏惧。最重要的是要意识到，你会在菜单中找到的大部分内容仍然存在，但菜单系统本身隐藏在屏幕左上角的汉堡图标下面。别担心，我会在稍后详细说明这一点。在我撰写这篇文章的时候，有一个设置我们将在
    [*第 2 章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置 PyCharm* 中进行回顾，它允许你在经典用户界面和新用户界面之间切换。'
- en: I wanted to point this out now because you’re about to see some screenshots,
    and if you’ve seen the old UI, you might think you’ve picked up the wrong book.
    You haven’t. Just the opposite. If I time this right, you’ll be the only one with
    the right book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在就指出这一点，因为你们即将看到一些截图，如果你已经看到了旧用户界面，你可能会认为你拿错了书。你没有。恰恰相反。如果我能准确把握时间，你将是唯一拥有正确书籍的人。
- en: Intelligent coding assistance
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能编码辅助
- en: I’m going to tell you something my wife says all the time. I’m very lazy. Wait.
    That came out wrong. She is saying that I’m lazy. I’m not saying that she is saying
    she is lazy. Sheesh. Writing is hard! I almost dug a hole there, didn’t I?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我要告诉你我妻子经常说的一句话。我非常懒惰。等等。我说错了。她是在说我懒惰。我并不是说她是在说她自己懒惰。哎呀。写作太难了！我差点在那里挖了个坑，不是吗？
- en: She’s not wrong. As a developer, I am essentially very lazy. I refuse to spend
    hours or even minutes doing something the long way. The Greeks had a legend about
    a guy named Sisyphus who was cursed to push a stone up a steep hill. As soon as
    he reached the top, the stone would roll back down the hill. Sisyphus was stuck
    in an infinite loop with no *Cmd*/*Ctrl* + *C* option on his keyboard.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 她并没有说错。作为一个开发者，我本质上非常懒惰。我拒绝花几个小时甚至几分钟去做一些事情。希腊有一个关于名叫西西弗斯的男人的传说，他被诅咒推一块石头上陡峭的山坡。一旦他到达山顶，石头就会滚回山脚下。西西弗斯被困在一个没有
    *Cmd*/*Ctrl* + *C* 选项的无限循环中。
- en: 'Here’s one thing I know: Sisyphus was not a software developer! Any software
    developer would have rolled that stone exactly twice, after which they would have
    spent eternity devising a system of pulleys and cranes controlled by an IoT device.
    Naturally, the microcontroller would be running a Python script. I digress.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件事我知道：西西弗斯不是软件开发者！任何软件开发者都会把那块石头推上两次，然后他们会花费永恒的时间设计一套由物联网设备控制的滑轮和起重机系统。当然，微控制器会运行Python脚本。我跑题了。
- en: 'What *some* (I say in my head looking in my unsuspecting wife’s direction)
    might call lazy, I call *efficient*! As a developer, I want to create maximum
    effect with minimal effort in everything I do. Writing code is complicated. You
    are writing instructions for the most stubborn and unintelligent object ever devised.
    Coding is worse than trying to teach a 2-year-old to tie their shoes. Trust me,
    I’ve done both! Coders must be extremely specific and verbose in their explanation
    of any operations they want to perform. Furthermore, things are made worse by
    the language developers out there who tend to want to force users to write a bunch
    of boilerplate code. I’m talking about the excise code that has nothing to do
    with the code you want to write or the problem you want to solve. Python generally
    avoids this, so let me give an example of possibly the worst offender: Java.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为*懒惰*的某些人（我在心里对着我那毫无戒心的妻子说），我称之为*高效*！作为一个开发者，我想在每一件事上都用最少的努力创造最大的效果。写代码是复杂的。你正在为最固执、最不智能的对象编写指令。编码比试图教一个两岁的孩子系鞋带还要糟糕。相信我，我两者都尝试过！编码者必须在对任何他们想要执行的操作的解释中非常具体和详尽。此外，事情变得更糟，因为一些开发者倾向于强迫用户编写大量的样板代码。我指的是与你想写的代码或你想解决的问题无关的冗余代码。Python通常避免这种情况，所以让我给你举一个可能是最糟糕的例子：Java。
- en: Back in the day when I was a wee lad, Java was all the rage. There was this
    caste of corporate programmers involved with Java who thought up something called
    **Enterprise Java Beans** (**EJBs**). EJBs were supposed to be the epitome of
    module programming with reusable objects. It was an absolute beating to implement.
    Rather than simply making a class, which is all you need, you had to create a
    special file structure with various folders and manifest files to expose what
    was in the bean, and it was all compiled into a special format. It turned out
    that the special format was nothing more than a ZIP file. It took a lot of work
    just to make an EJB, which meant developers had to make a ton of files and write
    a lot of code just to get started on the functionality they needed to express
    to get their work done. That’s what we mean by *boilerplate*. Boilerplate is generally
    useless but necessary because, without it, the code doesn’t work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我小时候，Java可是风靡一时。有一群与Java相关的企业程序员，他们想出了叫做**企业JavaBeans**（**EJBs**）的东西。EJBs本应成为模块化编程和可重用对象的典范。实现起来相当费劲。你不仅要创建一个简单的类，这是你唯一需要的，还要创建一个特殊的文件结构，包括各种文件夹和清单文件，以暴露bean中的内容，然后所有内容都要编译成一种特殊格式。结果发现，这种特殊格式不过是一个ZIP文件。仅仅为了创建一个EJB就需要做很多工作，这意味着开发者必须创建大量的文件和编写大量的代码，才能开始实现他们需要表达的功能。这就是我们所说的*样板代码*。样板代码通常是无用的，但又是必要的，因为没有它，代码就无法工作。
- en: All IDEs have evolved because of this phenomenon. PyCharm evolved from JetBrains’
    Java IDE, IntelliJ. Python doesn’t usually have a lot of boilerplate required
    for your code to work, but it does come up. There are two kinds of boilerplate.
    The boilerplate needed to make old-school EJBs work is the bad kind. The boilerplate
    generated as a means to jumpstart your project is the good kind. As we’ll see,
    PyCharm, as with most IDEs, generates a folder structure, a set of files, and
    some basic code to get you started. That can be considered boilerplate. But in
    this case, that code isn’t retained. It is replaced by the real code for your
    project. The code generated by the IDE is just a mental prompt to get you going.
    It prevents you from having to create your project’s starting point by hand.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有IDE都是因为这个现象而演变的。PyCharm是从JetBrains的Java IDE IntelliJ演变而来的。Python通常不需要很多样板代码来使代码工作，但确实会出现。样板代码有两种。使老式的EJBs工作的样板代码是坏的那一种。作为启动项目的一种手段而生成的样板代码是好的那一种。正如我们将看到的，PyCharm，就像大多数IDE一样，会生成一个文件夹结构，一组文件和一些基本代码，以帮助你开始。这可以被认为是样板代码。但在这个例子中，这些代码并没有保留。它们被你的项目的真实代码所取代。IDE生成的代码只是给你一个心理提示，让你开始。它防止你必须手动创建项目的起点。
- en: 'All this is great, but boilerplate code generation isn’t what we usually think
    about when we hear “intelligent coding assistance.” We usually think of the feature
    pioneered by Microsoft called **IntelliSense**. If you’ll allow me to anthropomorphize
    the IDE for a moment, this feature watches as you type your code. All the while,
    the IDE is thinking about what you’re trying to do. When it sees a way it can
    help, such as by completing a word or line for you automatically, it presents
    that as an option. I have an intelligent person completing all my sentences for
    me: she’s my wife. When she completes my sentences for me, they are usually more
    organized and intelligent than they would have been if I were on my own. (This
    might be another reason she thinks I’m lazy.)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很棒，但样板代码生成并不是我们通常在听到“智能编码辅助”时想到的。我们通常想到的是微软开创的名为**IntelliSense**的功能。如果你允许我暂时将IDE拟人化，这个功能会观察你输入代码的过程。在此期间，IDE会思考你试图做什么。当它看到可以帮助你的方式，比如自动为你完成一个单词或一行，它会将这个选项呈现出来。我有一个智能的人帮我完成所有句子：她就是我的妻子。当她帮我完成句子时，它们通常比我自己完成时更有组织和智慧。（这可能是她认为我懒惰的另一个原因。）
- en: I want to point out that not all tools with an IntelliSense-like feature are
    created equally. When you see this feature in an enhanced editor, it usually works
    differently than it would in an IDE. In enhanced editors, they use keyword lists
    to highlight and autocomplete the elements of a language. Really good enhanced
    editors might index your code and recognize variable and function names and use
    statistics to give you the most likely completion first. That option is generally
    followed by a long list of noise comprising every possibility that exists for
    a given completion. Code completion is becoming very advanced with the introduction
    of AI tools, and this makes the difference between IDEs and enhanced editors a
    little muddier, at least on this point. Tools such as GitHub’s Copilot can not
    only autocomplete variable names and keywords but also write entire sections of
    your code automatically.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，并非所有具有类似IntelliSense功能的工具都是同等创建的。当你在一个增强编辑器中看到这个功能时，它通常与在IDE中的工作方式不同。在增强编辑器中，它们使用关键字列表来突出显示和自动完成语言的元素。真正优秀的增强编辑器可能会索引你的代码，识别变量和函数名称，并使用统计信息来首先提供最可能的完成选项。这个选项通常后面跟着一个长长的列表，包含给定完成选项的每一个可能性。随着AI工具的引入，代码完成变得越来越高级，这至少在这个问题上使得IDE和增强编辑器之间的区别变得有些模糊。像GitHub的Copilot这样的工具不仅可以自动完成变量名和关键字，还可以自动编写你代码的整个部分。
- en: It is important to remember, at least as I write this, that those AI features
    are not part of the IDE or enhanced editor. They are implemented as plugins. Since
    this is true, I’ll continue espousing the merits of IDEs, and PyCharm in particular,
    based solely on the merits of the software by itself. We’ll discuss plugins in
    [*Chapter 16*](B19644_16.xhtml#_idTextAnchor401), *More Possibilities with* *PyCharm
    Plugins*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在我写这篇文章的时候，重要的是要记住，这些AI功能不是IDE或增强编辑器的一部分。它们作为插件实现。既然这是真的，我会继续宣扬IDE的优点，尤其是PyCharm的优点，仅基于软件本身的优点。我们将在[*第16章*](B19644_16.xhtml#_idTextAnchor401)中讨论插件，*PyCharm插件带来的更多可能性*。
- en: While enhanced editors might present you with a long list of possibilities for
    your code completion, PyCharm can analyze your code and perform more intelligent
    autocompletion. You also get code analysis, such as duplicate code warnings. A
    common antipattern in software development is copying and pasting code across
    or even within the same project. It’s a terrible but common thing to see. PyCharm
    will spot duplicate code and flag it for you so that you can be reminded to refactor
    the duplicated code into a function or module that can be reused and maintained
    in one location.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然增强编辑器可能会为你提供代码完成的可能性的长列表，但PyCharm可以分析你的代码并执行更智能的自动完成。你还可以获得代码分析，例如重复代码警告。软件开发中的一个常见反模式是在项目之间或甚至在同一项目内部复制和粘贴代码。看到这种糟糕但常见的事情是令人沮丧的。PyCharm会检测到重复的代码并为你标记，这样你就可以被提醒将重复的代码重构为一个函数或模块，该函数或模块可以在一个位置重用和维护。
- en: PyCharm can also perform a static analysis of your code. This type of analysis
    is looking for antipatterns within the code itself; for example, PyCharm will
    detect dead code like that shown in *Figure 1**.5*. Concerning Python development,
    PyCharm will automatically format your indentations and give you critical feedback
    on how your code conforms to **PEP-8** conventions, which are stylistic requirements
    you must meet to be considered *pythonic* (that’s a good thing).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm还可以对你的代码执行静态分析。这种分析是在寻找代码本身中的反模式；例如，PyCharm将检测如*图1**.5*中所示的死代码。关于Python开发，PyCharm将自动格式化你的缩进，并对你代码是否符合**PEP-8**约定提供关键反馈，这些是必须满足的样式要求，以被认为是*pythonic*（这是一件好事）。
- en: 'For example, if you were to type the following code into a new file in PyCharm,
    you’d see PyCharm’s warning that you have created unreachable code on line 13\.
    The text on that line is highlighted. Hovering your mouse over this highlighted
    line reveals what is wrong:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要在PyCharm的新文件中输入以下代码，你会看到PyCharm的警告，指出你在第13行创建了不可达的代码。该行的文本被突出显示。将鼠标悬停在突出显示的行上会显示错误信息：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `print_hi` function starts innocuously enough by printing to the console
    whatever is passed into the function within the `name` argument. After that, we
    create a loop that will run 25 times. On each run of the loop, we print out `x`,
    which contains the current iteration. When the counter variable, `x`, reaches
    12, the loop exits via the `return` function, which, as luck has it, is on line
    12\. I assure you, this is purely a coincidence. Since the loop returns on line
    12, the code on line 13 will never be reached:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_hi`函数最初是无害的，它将`name`参数中传递给函数的任何内容打印到控制台。之后，我们创建一个循环，它将运行25次。在每次循环运行中，我们打印出包含当前迭代的`x`。当计数器变量`x`达到12时，通过`return`函数退出循环，幸运的是，这个函数就在第12行。我向你保证，这纯粹是巧合。由于循环在第12行返回，第13行的代码将永远不会被执行：'
- en: '![Figure 1.5: PyCharm will highlight many common coding mistakes such as this
    one. The code on line 13 is unreachable, which is indicated when you hover your
    mouse over the highlighted code](img/B19644_Figure_1.05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：PyCharm将突出显示许多常见的编码错误，例如这个错误。当你在突出显示的代码上悬停鼠标时，会显示不可达的代码](img/B19644_Figure_1.05.jpg)'
- en: 'Figure 1.5: PyCharm will highlight many common coding mistakes such as this
    one. The code on line 13 is unreachable, which is indicated when you hover your
    mouse over the highlighted code'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：PyCharm将突出显示许多常见的编码错误，例如这个错误。第13行的代码不可达，当你将鼠标悬停在突出显示的代码上时，会有所指示
- en: PyCharm also allows you to navigate between files in a complex project by helping
    you find where functions, variables, and classes are defined, as well as where
    they are used. Over time, you’ll learn a set of keystrokes that will allow you
    to move anywhere in your project without your fingers leaving the keyboard.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm还允许你通过帮助你找到函数、变量和类的定义位置以及它们的使用位置，在复杂的项目中导航文件。随着时间的推移，你会学会一套快捷键，让你可以在项目中任意移动，而无需离开键盘。
- en: In essence, PyCharm’s intelligent coding assistance allows you to worry less
    about mistakes and more about your logic and requirements, which allows you to
    complete your code more quickly with fewer mistakes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，PyCharm的智能编码辅助让你可以少担心错误，更多地关注你的逻辑和需求，这让你可以更快地完成代码，错误更少。
- en: Streamlined programming tools
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程简化的编程工具
- en: 'Writing code is but one activity a developer performs each day in pursuit of
    a project deadline. Great developers also spend time debugging, testing, and profiling
    their products to produce the best possible result. We also need to deal with
    pushing code to testing servers, refactoring (other people’s) bad code, working
    with databases, and dealing with containers. There is tooling in PyCharm for each
    of these processes and more. When I write complicated web applications in PyCharm,
    the only tools I usually have open are PyCharm and a web browser: two tools each
    on their own monitor.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码是开发者每天为了追求项目截止日期而执行的一项活动。伟大的开发者也会花时间调试、测试和性能分析他们的产品，以产生最佳结果。我们还需要处理将代码推送到测试服务器、重构（别人的）糟糕代码、与数据库合作以及处理容器。PyCharm为这些过程以及更多提供了工具。当我使用PyCharm编写复杂的Web应用程序时，我通常只打开PyCharm和一个网络浏览器：每个工具都在自己的显示器上。
- en: The PyCharm debugger
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyCharm调试器
- en: My favorite feature and the one that got me excited the first time I used PyCharm
    is the debugger. PyCharm’s debugger is great. It is much better than the standard
    debugger you get with Python itself. Python ships with a debugger called **Python
    Debugger** (**pdb**). In my humble opinion, I’d rather eat bugs off the sidewalk
    than use this tool. I alluded to this earlier in this chapter. I grew up using
    Microsoft debuggers and simply nothing else will do. PyCharm’s debugger works
    exactly as I would expect. Click your mouse at the line where you want execution
    to stop to make a breakpoint and click the debug button in the IDE, and the program
    runs and stops at the indicated line. You will get a screen where you can inspect
    both the state of the stack as well as the terminal output. It’s very simple to
    use, and I’ll be showing you how to do so in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging,* *and Profiling.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的功能，也是我第一次使用PyCharm时感到兴奋的功能是调试器。PyCharm的调试器很棒。它比Python本身提供的标准调试器要好得多。Python附带一个名为**Python
    Debugger**（**pdb**）的调试器。据我拙见，我宁愿从人行道上吃虫子也不愿使用这个工具。我在本章前面提到了这一点。我从小使用Microsoft调试器，其他任何东西都无法替代。PyCharm的调试器工作方式完全符合我的预期。在您想要程序停止执行的那一行点击鼠标以设置断点，然后在IDE中点击调试按钮，程序就会运行并在指定的行停止。您将得到一个屏幕，您可以检查堆栈的状态以及终端输出。它非常简单易用，我将在[*第6章*](B19644_06.xhtml#_idTextAnchor145)，“无缝测试、调试和性能分析”中向您展示如何使用它。
- en: Running tests with the graphical test runner
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图形测试运行器运行测试
- en: Testing tools are integrated in the form of test runners. PyCharm supports all
    the major testing frameworks, including **pytest**, **nose**, and the regular
    unit test features from the standard library. Again, I’m coming from experiencing
    some very good IDEs, and in this case, I’m remembering Eclipse and Visual Studio,
    which both include graphical test runners. The adage *If the bar is green, the
    code is clean* is visually implemented in PyCharm. You can see an example in *Figure
    1**.6*. You can run your tests and see a list display showing what passed and
    what failed, though it is a list rather than a bar. You can then rerun your failing
    tests until they work.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具以测试运行器的形式集成。PyCharm支持所有主要的测试框架，包括**pytest**、**nose**以及标准库中的常规单元测试功能。再次强调，我来自一些非常优秀的IDE的使用经验，在这种情况下，我正在回忆Eclipse和Visual
    Studio，它们都包括图形测试运行器。谚语“如果条形是绿色的，代码就是干净的”在PyCharm中得到了视觉上的实现。您可以在*图1**.6*中看到一个示例。您可以运行您的测试，并看到一个显示通过和失败的列表，尽管它是一个列表而不是条形图。然后您可以重新运行失败的测试，直到它们通过。
- en: 'I’ll give you a simple example. In `main.py` within this chapter’s source code,
    I have one file called `main.py` and another called `test_main.py`. The content
    of `main.py` is a simple function that adds two numbers together:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我会给你一个简单的例子。在本章源代码的`main.py`中，我有一个名为`main.py`的文件，还有一个名为`test_main.py`的文件。`main.py`的内容是一个简单的函数，用于将两个数字相加：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the `test_main.py` file, there is a simple unit test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test_main.py`文件中，有一个简单的单元测试：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Test` class contains two tests: one that will pass and one that will automatically
    fail. I usually make the automatically failing test first just to make sure I
    have my test class set up properly. Then, later, I remove the fail because of
    my dopamine addiction, which is only satisfied by green checkmarks in the test
    runner, as seen in *Figure 1**.6*. If I right-click on `test_main.py`, as seen
    in *Figure 1**.5*, I’ll get an option to run the tests within the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test`类包含两个测试：一个会通过，另一个会自动失败。我通常先创建一个自动失败的测试，以确保我的测试类设置正确。然后，稍后，由于我的多巴胺成瘾，我会移除失败，因为只有测试运行器中的绿色勾选才能满足我，如图*图1**.6*所示。如果我在`test_main.py`上右键点击，如图*图1**.5*所示，我会得到一个选项来运行文件中的测试：'
- en: '![Figure 1.6: Right-click the test_main.py file and click Run ‘Python tests
    in test…’ to run the unit tests contained within the file](img/B19644_Figure_1.06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：右键点击test_main.py文件，然后点击“在test…中运行Python测试”来运行文件中的单元测试](img/B19644_Figure_1.06.jpg)'
- en: 'Figure 1.6: Right-click the test_main.py file and click Run ‘Python tests in
    test…’ to run the unit tests contained within the file'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：右键点击test_main.py文件，然后点击“在test…中运行Python测试”来运行文件中的单元测试
- en: 'Look to the lower-left corner in *Figure 1**.7*, which shows the test run’s
    completion, and you’ll see a list of tests that passed or failed with either a
    green check or a yellow X showing failure. Like all figures in this book, which
    are printed in black and white, you won’t see the colors. Color ink is expensive,
    and your father is right, money doesn’t grow on trees:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下左下角的**图1.7**，它显示了测试运行的完成情况，你会看到一个通过或失败的测试列表，用绿色勾号或黄色X表示失败。像这本书中的所有图一样，它们都是用黑白打印的，所以你看不到颜色。彩色墨水很贵，你父亲是对的，钱不是从树上长出来的：
- en: "![Figure 1.7: PyCharm’s built-in test runner shows a traditional pass/fail\
    \ list (lowe\uFEFFr-left pane) to indicate passing and failing tests](img/B19644_Figure_1.07.jpg)"
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：PyCharm内置的测试运行器显示传统的通过/失败列表（左下窗格）以指示通过和失败的测试](img/B19644_Figure_1.07.jpg)'
- en: 'Figure 1.7: PyCharm’s built-in test runner shows a traditional pass/fail list
    (lower-left pane) to indicate passing and failing tests'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：PyCharm内置的测试运行器显示传统的通过/失败列表（左下窗格）以指示通过和失败的测试
- en: PyCharm’s profiling tools
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyCharm的剖析工具
- en: Similarly, code profiling is built in and easy to use. You can click the **Profile**
    button to run the code. When the program exits, you will get a graph of each function
    call, along with the time and resources consumed by the call. This makes it easy
    to spot unrealized opportunities for improvement concerning the speed of execution
    and resource consumption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，代码剖析是内置的，并且易于使用。你可以点击**剖析**按钮来运行代码。当程序退出时，你将得到每个函数调用的图表，以及调用消耗的时间和资源。这使得很容易发现有关执行速度和资源消耗的未实现改进机会。
- en: 'Consider the possibility that you have an algorithm in your program that might
    not be performing as you’d like. I know, I know, it would never happen to you,
    so supposed you just got hired, and the person they fired wrote this horribly
    performing algorithm. Maybe pretend it is 1956, and the guy who got fired from
    your new employer, New York Life Insurance Company, was one **Edward Harry Friend**.
    Friend wrote a paper titled *Sorting on Electronic Computer Systems*, which is
    likely the first published instance of an algorithm we know today as **bubble
    sort**. If Friend had written his algorithm in Python 3, it might look a little
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种可能性，即你的程序中可能有一个算法，它的表现可能并不如你所期望。我知道，我知道，这种情况绝不会发生在你身上，所以假设你刚刚被雇佣，而被解雇的人编写了这个表现糟糕的算法。也许假装现在是1956年，你新雇主纽约人寿保险公司解雇的那个人是**爱德华·哈里·弗莱德**。弗莱德写了一篇题为《电子计算机系统中的排序》的论文，这可能是我们今天所知的**冒泡排序**算法首次公开发表的实例。如果弗莱德用Python
    3编写他的算法，它可能看起来有点像这样：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Friend has just created a function that accepts a list as an argument, which
    in our case will be an array of integers. The objective is to sort these numbers.
    To do this, let’s create two loops, one inside the other:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 弗莱德刚刚创建了一个接受列表作为参数的函数，在我们的例子中，这将是一个整数数组。目标是排序这些数字。为了做到这一点，让我们创建两个循环，一个嵌套在另一个里面：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within these loops, each number is compared with the number before it. If it
    is determined those two numbers are out of order, they are swapped. In the next
    run of the loop, this happens again with the next two numbers, and this continues
    until it reaches the end of the list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些循环中，每个数字都会与它前面的数字进行比较。如果确定这两个数字顺序颠倒，它们就会被交换。在循环的下一轮运行中，这种情况会再次发生在下一个两个数字上，并且这个过程会一直持续到列表的末尾。
- en: If you’ve studied algorithms at all, you’ve probably heard of bubble sort, and
    you’ve been warned as to why it is not used. It is very slow. We have a `for`
    loop within another `for` loop, which is fine if the size of your unsorted list
    is small. But this algorithm slows down at a logarithmic rate as the list of numbers
    grows. Algorithm performance is measured using **big O notation**. I don’t want
    to turn this into an algorithm book, so I’ll just tell you that a loop inside
    another loop will scale poorly in terms of performance. In big O notation, we
    classify this algorithm as *O*(*n*2). That’s bad.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究过算法，你可能听说过冒泡排序，并且已经被警告过为什么它不被使用。它非常慢。我们在一个`for`循环内部又嵌套了一个`for`循环，如果未排序的列表大小很小，这是可以的。但是随着数字列表的增长，这个算法以对数速度减慢。算法性能是用**大O符号**来衡量的。我不想把这个变成一本算法书，所以我只会告诉你，在一个循环内部嵌套另一个循环在性能方面会表现不佳。在大O符号中，我们将这个算法归类为*O*(*n*2)。这很糟糕。
- en: In plain English, this means that if you double the count of numbers to sort
    (*n*), then your algorithm will take 22 or 4 times longer to process. If you multiply
    your count’s size by 5, then it becomes 52 or 25 times slower. The bigger the
    list, the slower it sorts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话说，这意味着如果你将需要排序的数字数量（*n*）加倍，那么你的算法处理时间将延长 22 或 4 倍。如果你将计数的大小乘以 5，那么它将变慢
    52 或 25 倍。列表越大，排序越慢。
- en: 'To show off the performance tool, we’re going to give this test run a list
    of 100,000 numbers to sort. Now is a good time to point out I’m running an Intel
    i9 processor. If you’re a student or some other budget-constrained consumer rocking
    an i3 processor (or worse), you might want to take the list of numbers down a
    few zeros if you want to try this out. It takes a good while on my i9:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示性能工具，我们将给这个测试运行一个包含 100,000 个数字的列表进行排序。现在是一个指出我正在运行英特尔 i9 处理器的好时机。如果你是一个学生或预算受限的消费者，使用的是
    i3 处理器（或更差），如果你想要尝试这个，你可能需要将数字列表的大小减少几个零。在我的 i9 上，这需要相当长的时间：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s finish the test code by calling the function and printing the results:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用函数并打印结果来完成测试代码：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll cover the profiling tool extensively in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, but for now, let’s just run this
    code with the profiler and review the result. To run the profiler on the `performance.py`
    file, simply right-click the file and click **More Run/Debug**, then **Profile
    ‘performance’**, as shown in *Figure 1**.8*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 6 章*](B19644_06.xhtml#_idTextAnchor145)中详细介绍性能分析工具，*无缝测试、调试和性能分析*，但现在，让我们只是运行这段代码并查看结果。要在
    `performance.py` 文件上运行性能分析器，只需右键单击文件，然后点击**更多运行/调试**，然后**分析‘性能’**，如图 *图 1.8* 所示：
- en: '![Figure 1.8: Right-click the file you’d like to profile and click More Run/Debug
    | Profile ‘performance’ to see a performance profile](img/B19644_Figure_1.08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8：右键单击你想要分析性能的文件，然后点击更多运行/调试 | 分析‘性能’以查看性能分析](img/B19644_Figure_1.08.jpg)'
- en: 'Figure 1.8: Right-click the file you’d like to profile and click More Run/Debug
    | Profile ‘performance’ to see a performance profile'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：右键单击你想要分析性能的文件，然后点击更多运行/调试 | 分析‘性能’以查看性能分析
- en: 'Remember, if you use the same code I did, this will take a long time to run,
    especially on a slower computer. Feel free to adjust the size of the list downward
    if it’s taking too long to run. The result is a `.pstat` file that displays as
    a table in PyCharm. Again, we’ll cover this more extensively in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*. You can see the performance report
    in *Figure 1**.9*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你使用和我一样的代码，这将需要很长时间才能运行，尤其是在较慢的计算机上。如果你运行时间过长，请随意调整列表的大小。结果是一个 `.pstat`
    文件，在 PyCharm 中显示为表格。我们将在[*第 6 章*](B19644_06.xhtml#_idTextAnchor145)中更详细地介绍这一点，*无缝测试、调试和性能分析*。你可以在
    *图 1.9* 中查看性能报告：
- en: '![Figure 1.9: PyCharm’s resource profiler shows the performance bottlenecks
    in a running program](img/B19644_Figure_1.09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9：PyCharm 的资源分析器显示了运行程序中的性能瓶颈](img/B19644_Figure_1.09.jpg)'
- en: 'Figure 1.9: PyCharm’s resource profiler shows the performance bottlenecks in
    a running program'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：PyCharm 的资源分析器显示了运行程序中的性能瓶颈
- en: As you can see, 84.4% of the program’s time is spent in the `bubble_sort` function,
    which is the bottleneck. PyCharm has told you where to concentrate your refactoring
    efforts to improve the performance of your program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序 84.4% 的时间都花在了 `bubble_sort` 函数中，这是瓶颈。PyCharm 已经告诉你应该在哪里集中重构努力来提高你程序的性能。
- en: Publishing from the IDE
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 IDE 发布
- en: When you need to publish your code to a testing server, and you aren’t using
    a continuous integration system for that, you can use PyCharm. To be clear, you
    should use a continuous integration system, but I often use the PyCharm features
    early in a project before the continuous integration system is operational to
    get code up for stakeholders to play with. You can deploy using **file transfer
    protocol** (**FTP**) or **secure file transfer protocol** (**SFTP**), or copy
    directly to a network share for a quick and easy way to share your progress with
    anyone who might want to review it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将代码发布到测试服务器，而你又没有使用持续集成系统时，你可以使用 PyCharm。为了明确起见，你应该使用持续集成系统，但我在项目初期，在持续集成系统运行之前，经常使用
    PyCharm 的功能来将代码上传给利益相关者进行测试。你可以使用**文件传输协议**（**FTP**）或**安全文件传输协议**（**SFTP**）进行部署，或者直接复制到网络共享，以便快速轻松地与任何可能想要审查的人分享你的进度。
- en: Refactoring tools
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构工具
- en: 'PyCharm has robust refactoring tools you’d expect from a proper IDE. If you
    want to change a variable name, or even a method signature on a function, right-click
    and select the **Refactor** tool. Rest assured the changes you make will carry
    over to all related instances in your project, not just in the file you are editing.
    *Figure 1**.10* shows an example of this in action:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 拥有您从合适的 IDE 中期望的强大重构工具。如果您想更改变量名，或者甚至更改函数上的方法签名，右键单击并选择**重构**工具。请放心，您所做的更改将应用到项目中所有相关的实例，而不仅仅是您正在编辑的文件中。*图
    1*.*10*展示了这一功能的示例：
- en: "![Figure 1.10: PyCharm has a full \uFEFFselection of refactoring tools available](img/B19644_Figure_1.10.jpg)"
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10：PyCharm 提供了完整的重构工具选择](img/B19644_Figure_1.10.jpg)'
- en: 'Figure 1.10: PyCharm has a full selection of refactoring tools available'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：PyCharm 提供了完整的重构工具选择
- en: In addition to renaming a variable or function, there are other actions you
    can perform, such as changing the method signature and changing the structure
    of your object-oriented classes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重命名变量或函数之外，您还可以执行其他操作，例如更改方法签名和更改面向对象类的结构。
- en: Working with databases in PyCharm
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 PyCharm 中与数据库协同工作
- en: 'If you work with databases, the Professional edition of PyCharm includes a
    graphical table editor and SQL support for dozens of popular databases. Check
    it out in *Figure 1**.11*. I’ll talk more about the Professional edition of PyCharm
    a little later in this chapter; we’ll have a whole chapter on the database features
    in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding Database Management*
    *with PyCharm*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您与数据库工作，PyCharm 的专业版包括图形化表格编辑器和对数十种流行数据库的 SQL 支持。请参阅*图 1*.*11*。我将在本章稍后更详细地介绍
    PyCharm 的专业版；我们将在[*第 11 章*](B19644_11.xhtml#_idTextAnchor266)“使用 PyCharm 理解数据库管理”中有一个专门章节介绍数据库功能：
- en: '![Figure 1.11: PyCharm has a robust and complete set of tools for working with
    relational databases such as Oracle, SQL Server, Postgres, and many more](img/B19644_Figure_1.11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11：PyCharm 提供了一套强大且完整的工具，用于处理关系型数据库，如 Oracle、SQL Server、Postgres 以及更多](img/B19644_Figure_1.11.jpg)'
- en: 'Figure 1.11: PyCharm has a robust and complete set of tools for working with
    relational databases such as Oracle, SQL Server, Postgres, and many more'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：PyCharm 提供了一套强大且完整的工具，用于处理关系型数据库，如 Oracle、SQL Server、Postgres 以及更多
- en: As you can see, a great many relational and NoSQL databases are directly supported.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，许多关系型和非关系型数据库都直接得到支持。
- en: Remote development, containers, and virtual machines
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程开发、容器和虚拟机
- en: Finally, but not exhaustively, PyCharm has features for working with remote
    systems via **SSH**, local virtual machines using HashiCorp’s **Vagrant**, and
    extensive support for **Docker** containers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但并非详尽无遗，PyCharm 还提供了通过 **SSH** 与远程系统协同工作的功能，使用 HashiCorp 的 **Vagrant** 进行本地虚拟机，以及对
    **Docker** 容器的广泛支持。
- en: This isn’t an exhaustive list of what PyCharm can do for you, but by now, you
    get the point. Every tool you might need is integrated into the development environment.
    That’s probably why they called it an *integrated* *development environment*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是 PyCharm 可以为你做的所有事情的详尽列表，但到现在，你应该明白了。你可能需要的每一个工具都集成到了开发环境中。这可能是他们称之为*集成*开发环境的原因。
- en: Web development options
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络开发选项
- en: I’d wager that more than half the developers working in Python need, at some
    point, a web project. Whether you’re like me and you’re making a SaaS offering
    as a fully realized web application, or you are doing rocket science and you need
    a way to visualize and interactively share your latest fast-Fourier transform
    on deep space radio emissions data, web projects are usually inevitable. I’m not
    a scientist and I made that up. If the last sentence made sense to anyone, it
    was pure coincidence.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，超过一半在 Python 中工作的开发者，在某个时刻都需要一个网络项目。无论你是像我一样，正在制作一个作为完全实现网络应用的 SaaS 产品，还是你在进行火箭科学，需要一种方式来可视化和交互式地分享你最新的关于深空无线电发射数据的快速傅里叶变换，网络项目通常是不可避免的。我不是科学家，我编造了那句话。如果最后一句对任何人有意义，那纯粹是巧合。
- en: Working with web projects offers a new and separate layer of complexity. Most
    use three-tier designs commonly expressed with the **model-view-controller** (**MVC**)
    pattern. If you’re not sure what this means, stay tuned because there’s a whole
    section of this book dedicated to web development. For now, this means the application
    has a frontend where the user can interact, a middle tier containing connective
    logic, and a database tier for structured data storage and retrieval. Only the
    middle tier is done in Python. We’ll extensively cover web development in later
    chapters, but for now, I want to tell you about the level of tooling you get with
    PyCharm.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Web 项目一起工作提供了一层新的、独立的复杂性。大多数使用三层设计，通常用 **模型-视图-控制器**（**MVC**）模式表示。如果你不确定这是什么意思，请继续关注，因为本书有一个专门介绍
    Web 开发的部分。现在，这意味着应用程序有一个用户可以与之交互的前端，一个包含连接逻辑的中层，以及一个用于结构化数据存储和检索的数据库层。只有中层是用 Python
    实现的。我们将在后面的章节中广泛介绍 Web 开发，但现在，我想告诉你 PyCharm 提供的工具水平。
- en: The company that made PyCharm, JetBrains, makes a variety of IDEs targeted at
    different languages. One of their IDEs is specifically targeted toward web development.
    It is called **WebStorm**. I said earlier that good IDEs target one language.
    WebStorm targets JavaScript; specifically, we’re talking about full stack JavaScript.
    Modern JavaScript execution occurs in two places. Traditionally, JavaScript was
    always executed in the browser. About 10 years ago, **Node.js** was released and
    JavaScript was released from the confines of the browser window and allowed to
    run on the backend.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 制作 PyCharm 的公司 JetBrains 制作了一系列针对不同语言的 IDE。他们中的一个 IDE 专门针对 Web 开发。它被称为 **WebStorm**。我之前说过，好的
    IDE 针对一种语言。WebStorm 针对的是 JavaScript；具体来说，我们谈论的是全栈 JavaScript。现代 JavaScript 执行发生在两个地方。传统上，JavaScript
    总是在浏览器中执行。大约 10 年前，**Node.js** 发布了，JavaScript 脱离了浏览器窗口的束缚，并允许在后台运行。
- en: 'Earlier, I alluded to a robust set of features in PyCharm for working with
    databases. JetBrains also has an IDE that targets SQL database developers called
    **DataGrip**. As it happens, the Professional edition of PyCharm includes the
    entire feature set available in WebStorm and DataGrip. When you buy the Professional
    edition, you’re getting three JetBrains products in one package: PyCharm, WebStorm,
    and DataGrip. When you use PyCharm to work on web projects, you need all three
    feature sets and they are there for you in the Professional edition.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到了 PyCharm 中用于数据库工作的强大功能集。JetBrains 还有一个针对 SQL 数据库开发者的 IDE，名为 **DataGrip**。事实上，PyCharm
    的专业版包含了 WebStorm 和 DataGrip 中可用的全部功能集。当你购买专业版时，你将获得一个包含三个 JetBrains 产品的套餐：PyCharm、WebStorm
    和 DataGrip。当你使用 PyCharm 处理 Web 项目时，你需要所有这三个功能集，它们在专业版中为你准备好了。
- en: Scientific computing support
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 科学计算支持
- en: 'The growth of the data science field has played an important role in the growth
    of Python itself, and Python is now the most common programming tool used in scientific
    projects (even more common than **R**). Notable functionalities included in PyCharm
    that facilitate data science work are the integration of **IPython**, **Jupyter**
    notebooks, and an interactive console. The support for scientific computing in
    PyCharm is detailed in section four of this book, starting from [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318),
    *Turning On Scientific Mode*. PyCharm also provides a customized view that optimally
    organizes workspaces in a scientific project called **SciView**, which is shown
    in *Figure 1**.12*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学领域的发展在 Python 自身的发展中发挥了重要作用，Python 现在是科学项目中使用的最常见编程工具（甚至比 **R** 更常见）。PyCharm
    中包含的显著功能，有助于数据科学工作，包括 **IPython**、**Jupyter** 笔记本和交互式控制台。PyCharm 中对科学计算的支持在本书的第四章中详细说明，从
    [*第 13 章*](B19644_13.xhtml#_idTextAnchor318)，*开启科学模式* 开始。PyCharm 还提供了一个名为 **SciView**
    的定制视图，它以最佳方式组织科学项目中的工作空间，如图 *1**.12* 所示：
- en: '![Figure 1.12: SciView in PyCharm grants access to scientific visualization
    tools via a slick interface](img/B19644_Figure_1.12.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12：SciView 在 PyCharm 中通过简洁的界面提供对科学可视化工具的访问](img/B19644_Figure_1.12.jpg)'
- en: 'Figure 1.12: SciView in PyCharm grants access to scientific visualization tools
    via a slick interface'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：SciView 在 PyCharm 中通过简洁的界面提供对科学可视化工具的访问
- en: Understanding the Professional, Community, and Educational editions
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解专业版、社区版和教育版
- en: 'There are three editions to PyCharm. I’ve alluded to two, because the third
    is a special version that is only useful to teachers, and the focus of this book
    is application development, not software development instruction. I’ll tell you
    about each, but I know what you want is a feature comparison chart. You’ll find
    it in *Figure 1**.13*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm有三个版本。我已经提到了两个，因为第三个是一个特殊版本，仅适用于教师，而本书的重点是应用开发，而不是软件开发教学。我会告诉你每个版本的情况，但我知道你想要的是一个功能比较图表。你可以在*图1.13*中找到它：
- en: '|  | **PyCharm Professional** | **PyCharm Community** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  | **PyCharm专业版** | **PyCharm社区版** |'
- en: '| Cost | Paid | Free |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 付费 | 免费 |'
- en: '| Intelligent Python editor | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 智能Python编辑器 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |'
- en: '| Graphical debugger and test runner | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 图形调试器和测试运行器 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |'
- en: '| Code navigation and refactor tools | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 代码导航和重构工具 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |'
- en: '| Code inspection | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    | ![Checkmark with solid fill](img/B19644_Figure_1.13.png) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 代码检查 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |'
- en: '| Git, Subversion, and other source control tools | ![Checkmark with solid
    fill](img/B19644_Figure_1.13.png) | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Git、Subversion和其他源代码控制工具 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |'
- en: '| Scientific tools | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 科学工具 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) |  |'
- en: '| Web development with HTML, JavaScript, CSS, and so on | ![Checkmark with
    solid fill](img/B19644_Figure_1.13.png) |  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 使用HTML、JavaScript、CSS等进行Web开发 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png)
    |  |'
- en: '| Python web framework support | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Python Web框架支持 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) |  |'
- en: '| Performance profiling | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 性能分析 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) |  |'
- en: '| Remote development, containers, and so on | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 远程开发、容器等 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) |  |'
- en: '| Database and SQL support | ![Checkmark with solid fill](img/B19644_Figure_1.13.png)
    |  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 数据库和SQL支持 | ![勾选标记，实心填充](img/B19644_Figure_1.13.png) |  |'
- en: 'Figure 1.13: A feature comparison chart showing the features contained in the
    free Community edition versus the paid Professional version'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：一个功能比较图表，显示了免费社区版与付费专业版所包含的功能
- en: The **Community edition** is free but only offers a limited set of features
    compared to the Professional edition. It is perfect for working on projects that
    only entail working with Python. The product I work on has a set of Python scripts
    that batch-process large amounts of data. Everything happens in Python and this
    is the perfect use case for the Community edition. If all you need is a terrific
    Python IDE, use the free version. The Community edition is also perfect if you
    are just working on automation scripts, such as graphics pipelines for 3D computer
    graphics, or general IT task automation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**社区版**是免费的，但与专业版相比，只提供有限的功能集。它非常适合仅涉及Python工作的项目。我正在开发的产品有一套Python脚本，用于批量处理大量数据。所有操作都在Python中进行，这正是社区版的完美用例。如果你只需要一个出色的Python
    IDE，请使用免费版本。如果你只是在编写自动化脚本，例如3D计算机图形的图形管线或一般IT任务自动化，社区版也非常合适。'
- en: The **Professional edition** has all the features of the free version but adds
    web development, database, remote development, containerization, and scientific
    project types. This is aimed at professionals who produce publishable software
    projects. While it is not free, JetBrains is pretty good about keeping it affordable
    with several pricing options, depending on how you are using the tool. Solo developers
    may obtain licenses at a lower price point than corporate developers. There are
    also ways to get the Professional edition free of charge, such as proving that
    you are using PyCharm on a **fully open source software** (**FOSS**) project.
    Start-up companies might be eligible for a 50% discount, and if you’re teaching
    in a code boot camp or a university setting, you may also qualify for free professional
    licenses. Since these things can fluctuate over time, you should check the JetBrains
    website for full details at [https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**专业版**拥有免费版的所有功能，并增加了网页开发、数据库、远程开发、容器化和科学项目类型。这是针对那些制作可发布软件项目的专业人士。虽然它不是免费的，但JetBrains通过提供多种定价选项，使其保持可负担性，具体取决于您如何使用该工具。独立开发者可能以比企业开发者更低的价位获得许可证。还有方法可以免费获得专业版，例如证明您正在使用PyCharm进行**完全开源软件**（**FOSS**）项目。初创公司可能有资格获得50%的折扣，如果您在代码训练营或大学环境中教学，您也可能有资格获得免费的专业许可证。由于这些信息可能会随时间变化，您应检查JetBrains网站上的完整详情，网址为[https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)。'
- en: I said earlier there are three editions of PyCharm, and we’ve only covered two.
    The **Educational edition** is aimed at teachers and university professors developing
    curricula to teach Python. This edition can create and play back interactive lessons
    right in the IDE. It is only valuable to teachers, instructors, and content creators.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到PyCharm有三个版本，我们只介绍了两个。**教育版**旨在为教师和大学教授开发用于教授Python的课程。这个版本可以直接在IDE中创建和回放交互式课程。它只对教师、讲师和内容创作者有价值。
- en: In this book, I will focus on the features present in the Community edition
    and the Professional edition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将专注于社区版和专业版中存在的功能。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Python language itself, as well as the background
    behind Python IDEs in general and, specifically, PyCharm.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Python语言本身，以及Python IDEs的一般背景和PyCharm的具体情况。
- en: We also discussed the usability of PyCharm for Python programmers. Specifically,
    to be able to take full advantage of all the features and functionalities that
    PyCharm offers without becoming too dependent on the IDE, a programmer should
    first master the fundamentals of the Python language and its core syntax. We also
    looked at comparisons between PyCharm itself and various other Python editors/IDEs
    and the reason why PyCharm is considered the best development environment of them
    all.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了PyCharm对Python程序员的可用性。具体来说，为了能够充分利用PyCharm提供的所有功能和功能，而不过度依赖IDE，程序员应首先掌握Python语言及其核心语法的基础知识。我们还探讨了PyCharm本身与各种其他Python编辑器/IDE的比较以及为什么PyCharm被认为是所有开发环境中的最佳。
- en: 'Finally, we compared the two editions of PyCharm that are available for download:
    the paid Professional edition and the free Community edition. If you are working
    with large, complex projects with many moving parts, including database management,
    web development languages, and viewability in scientific reports, then you will
    most likely benefit from using the Professional edition.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们比较了两种可下载的PyCharm版本：付费的专业版和免费的社区版。如果您正在处理大型、复杂的项目，包括数据库管理、网页开发语言和科学报告中可查看性，那么您很可能将从使用专业版中受益。
- en: In the next chapter, you will learn how to download PyCharm, set it up on your
    system, and configure its environment for your Python projects. This will serve
    as the first step in getting started with PyCharm, after which we will start discussing
    the specific features PyCharm offers that this book covers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何下载PyCharm，在您的系统上设置它，并为其Python项目配置其环境。这将是开始使用PyCharm的第一步，之后我们将开始讨论本书涵盖的PyCharm提供的特定功能。
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试您对本章知识的掌握：
- en: Programmers typically develop their code with an editor or an IDE. What is the
    difference between the two, and which one is PyCharm?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员通常使用编辑器或集成开发环境（IDE）来编写代码。两者之间有什么区别，PyCharm又是哪一种？
- en: Why might some think that an IDE for Python development might be inappropriate
    or unnecessary?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么有些人可能会认为 Python 开发的 IDE 可能不合适或不必要？
- en: What are some key features of PyCharm? Of those features, which give PyCharm
    an edge over other editors/IDEs?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm 的一些关键特性是什么？在这些特性中，哪些使 PyCharm 在其他编辑器/IDE 中具有优势？
- en: What advantage does PyCharm have over editors such as Visual Studio Code or
    vim, which can be configured to perform many of the same features offered by PyCharm?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm 相比于可以配置以执行 PyCharm 提供的许多相同功能的编辑器（如 Visual Studio Code 或 vim）有哪些优势？
- en: What are the three editions of PyCharm? What are the key differences between
    them?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm 有哪三个版本？它们之间有哪些关键区别？
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Be sure to check out the companion website for this book at [http://pycharm-book.com](http://pycharm-book.com).
    To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看这本书的配套网站[http://pycharm-book.com](http://pycharm-book.com)。要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Friend, Edward H. *Sorting on Electronic Computer Systems*. *Journal of the
    ACM (JACM)* 3.3 (1956): 134-168.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Friend, Edward H. 《电子计算机系统中的排序》。*《ACM 期刊 (JACM)*》3.3 (1956): 134-168。'
- en: 'Nguyen, Quan. *Hands-On Application Development with PyCharm: Accelerate your
    Python applications using practical coding techniques in PyCharm*. Packt Publishing
    Ltd, 2019.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nguyen, Quan. 《使用 PyCharm 进行实战应用开发：利用 PyCharm 中的实用编码技巧加速 Python 应用程序开发》。Packt
    Publishing Ltd, 2019。
- en: Shelley, Percy B. *Ozymandias*. [https://www.poetryfoundation.org/poems/46565/ozymandias](https://www.poetryfoundation.org/poems/46565/ozymandias).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shelley, Percy B. 《奥西曼提亚斯》。[https://www.poetryfoundation.org/poems/46565/ozymandias](https://www.poetryfoundation.org/poems/46565/ozymandias)。
- en: Wikipedia contributors. (2022, December 19). *Bubble sort*. Wikipedia. [https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科贡献者。 (2022, 12月19日)。*冒泡排序*。维基百科。[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)。
