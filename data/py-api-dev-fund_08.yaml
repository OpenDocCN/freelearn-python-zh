- en: 8\. Pagination, Searching, and Ordering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 分页、搜索和排序
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Implement the pagination function using Flask-SQLAlchemy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-SQLAlchemy实现分页功能
- en: Serialize the paginated result using marshmallow for the frontend display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用marshmallow序列化分页结果以供前端显示
- en: Build the API with search function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用搜索功能构建API
- en: Sort and order the returned records in your own way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以你自己的方式对返回的记录进行排序和排序
- en: Test all these features using Postman
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman测试所有这些功能
- en: This chapter covers pagination and how to change the order in which recipes
    are listed, as well as how to add search functionality for recipes and ingredients.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了分页以及如何更改食谱列表的顺序，以及如何为食谱和成分添加搜索功能。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we implemented the `user avatar` and `recipe cover
    image upload` functions. We worked on the image compression function to improve
    the performance of image loading speed. Once an image has been uploaded, users
    can retrieve the URL of the image through an API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了`用户头像`和`食谱封面图像上传`功能。我们处理了图像压缩功能以提高图像加载速度的性能。一旦上传了图像，用户可以通过API检索图像的URL。
- en: In this chapter, we will work on paginating recipe data. We will explain why
    we need to perform pagination. This is an important step in optimizing our API.
    We will also discuss some more important functions, including searching and ordering,
    which I am sure you have come across in other online applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理分页食谱数据。我们将解释为什么我们需要执行分页。这是优化我们的API的重要步骤。我们还将讨论一些更重要的功能，包括搜索和排序，我相信你在其他在线应用中已经遇到过。
- en: Pagination
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页
- en: In the testing environment, we may only have a few developers putting recipes
    on the Smilecook platform. There are only a handful of recipes there and performance
    is never a concern. However, in the production environment, that is, after the
    platform has been launched for public use, there could be thousands of users sharing
    recipes on the platform. If you consider social media platforms such as Facebook,
    then the volume will be even bigger.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，我们可能只有几个开发者将食谱放在Smilecook平台上。那里只有少数几个食谱，性能从未成为问题。然而，在生产环境中，即平台向公众开放后，可能会有成千上万的用户在平台上分享食谱。如果你考虑像Facebook这样的社交媒体平台，那么数量将更大。
- en: That's why we need to introduce pagination. Pagination means instead of querying
    the whole population of records from the database, we just query a handful of
    them. When the user wants to see more, they can always go to the next page. For
    example, when you're browsing a shopping site, usually, you will view the items
    for sale a page at a time. Each page may display 40 items, and you have to navigate
    to subsequent pages to view all the items that are available. This is the nature
    of pagination.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要引入分页。分页意味着我们不是从数据库中查询所有记录的总体，我们只查询其中的一小部分。当用户想要查看更多内容时，他们总是可以转到下一页。例如，当你浏览购物网站时，通常你一次会查看一页的商品。每一页可能显示40个商品，你必须导航到后续页面来查看所有可用的商品。这就是分页的本质。
- en: The number of records that are shown per page is limited by the page's size.
    This way, there will be a huge saving in server loading time and data transfer
    time, and, most importantly, it will enhance the user's navigation experience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每页显示的记录数受页面大小的限制。这样，服务器加载时间和数据传输时间将大大节省，最重要的是，这将增强用户的导航体验。
- en: The good thing here is that we are using a web framework to build our API. This
    kind of common function has already been thought of. We just need to use Flask-SQLAlchemy
    to help us build a paginated API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里好的一点是，我们正在使用Web框架来构建我们的API。这类常见功能已经被考虑到了。我们只需要使用Flask-SQLAlchemy来帮助我们构建分页API。
- en: Paginated APIs
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页API
- en: 'A paginated API means that when you query the API, only the data records on
    the current page will be returned. It also includes other information, such as
    the total number of records, the total number of pages, links to other pages,
    and so on. The following is a sample response from a paginated API. It is a serialized
    pagination object, so it is in JSON format:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分页API意味着当你查询API时，只会返回当前页面的数据记录。它还包括其他信息，例如记录总数、总页数、其他页面的链接等。以下是一个分页API的示例响应。它是一个序列化的分页对象，因此它是以JSON格式表示的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, you can see the following attributes in the HTTP response:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到HTTP响应中的以下属性：
- en: '`first`: The link to the first page'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`: 首页的链接'
- en: '`last`: The link to the last page'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last`: 最后一页的链接'
- en: '`prev`: The link to the previous page'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prev`: 上一页的链接'
- en: '`next`: The link to the next page'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: 下一页的链接'
- en: '`page`: The current page'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 当前页'
- en: '`pages`: The total number of pages'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages`: 总页数'
- en: '`per_page`: The number of records per page'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`per_page`: 每页的记录数'
- en: '`total`: The total number of records'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total`: 总记录数'
- en: '`data`: The actual data records on this page'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 此页上的实际数据记录'
- en: These attributes are automatically generated by the pagination object in Flask-SQLAlchemy.
    We just need to serialize the pagination object using marshmallow so that we can
    return the result in JSON format to the frontend client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性由 Flask-SQLAlchemy 中的分页对象自动生成。我们只需要使用 marshmallow 序列化分页对象，这样我们就可以以 JSON
    格式将结果返回给前端客户端。
- en: 'Exercise 50: Implementing Pagination on the Published Recipes Retrieval Function'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 50：在已发布菜谱检索函数中实现分页
- en: 'Now that we''ve discussed the importance of pagination, we want to add this
    functionality to our Smilecook platform. We''ll begin to work on that in this
    exercise. Let''s get started:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了分页的重要性，我们想在 Smilecook 平台上添加这个功能。我们将从这个练习开始着手。让我们开始吧：
- en: 'Create `pagination.py` in the `schema` folder and import the necessary modules
    and functions:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `schema` 文件夹中创建 `pagination.py` 并导入必要的模块和函数：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the `PaginationSchema` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PaginationSchema` 类：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this step, we can see that `PaginationSchema` inherits from `marshmallow.Schema`.
    `PaginationSchema` is used to serialize the pagination object from Flask-SQLAlchemy.
    The `links` attribute is a custom field, which means that we can specify how we
    are going to serialize it. The `get_pagination_links` function will be created
    in *step 4*.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步中，我们可以看到 `PaginationSchema` 继承自 `marshmallow.Schema`。`PaginationSchema`
    用于序列化 Flask-SQLAlchemy 中的分页对象。`links` 属性是一个自定义字段，这意味着我们可以指定如何序列化它。`get_pagination_links`
    函数将在 *步骤 4* 中创建。
- en: Note
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We've explained the other attributes here already. These attributes are required
    in the HTTP response, and so we need to add them to the schema.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经在这里解释了其他属性。这些属性在 HTTP 响应中是必需的，因此我们需要将它们添加到模式中。
- en: 'We can have a different key name in the final JSON response. For example, if
    we want to show `total_count` as the key name instead of `total`, we can use the
    `attribute` parameter like this: `total_count = fields.Integer(dump_only=True,
    attribute=''total'')`.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终 JSON 响应中可以有不同的键名。例如，如果我们想将 `total_count` 作为键名而不是 `total`，我们可以使用 `attribute`
    参数，如下所示：`total_count = fields.Integer(dump_only=True, attribute='total')`。
- en: 'Add the following `get_url` method to `PaginationSchema`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `get_url` 方法添加到 `PaginationSchema`：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PaginationSchema.get_url` method is used to generate the URL of the page
    based on the page number. It is taking in the page number parameter and adding
    that to the `request` argument's dictionary. Finally, it encodes and returns the
    new URL, including the page number, as an argument.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PaginationSchema.get_url` 方法用于根据页码生成页面URL。它接收页码参数并将其添加到 `request` 参数的字典中。最后，它对新的URL进行编码并返回，包括页码，作为参数。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An example of this is if `request.base_url` is `http://localhost:5000/recipes`,
    and `urlencode (query_args)` is giving us `per_page=2&page=1`. The format function
    will stitch them together and return the new URL, that is, `http://localhost:5000/recipes?per_page=2&page=1`.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果 `request.base_url` 是 `http://localhost:5000/recipes`，并且 `urlencode (query_args)`
    给我们 `per_page=2&page=1`。格式化函数将它们拼接在一起并返回新的URL，即 `http://localhost:5000/recipes?per_page=2&page=1`。
- en: 'Add the `get_pagination_links` method to `PaginationSchema`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `get_pagination_links` 方法添加到 `PaginationSchema`：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PaginationSchema.get_pagination_links` method is used to generate URL links
    to different pages. It gets the page's information from `paginated_objects` and
    relies on the `get_url` method we built in *step 3* to generate the links.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PaginationSchema.get_pagination_links` 方法用于生成指向不同页面的URL链接。它从 `paginated_objects`
    获取页面信息，并依赖于我们在 *步骤 3* 中构建的 `get_url` 方法来生成链接。'
- en: 'Next, import `PaginationSchema` in `schemas/recipe.py`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `schemas/recipe.py` 中导入 `PaginationSchema`：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Delete the following code in `schemas/recipe.py`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `schemas/recipe.py` 中的以下代码：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This part of the code has been removed because we are building a pagination
    function. We no longer need to wrap multiple data records with the `data` key.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分代码已被删除，因为我们正在构建分页函数。我们不再需要用 `data` 键包装多个数据记录。
- en: 'Define `RecipePaginationSchema`, which inherits from `PaginationSchema` in
    `schema/pagination.py`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `RecipePaginationSchema`，它从 `schema/pagination.py` 中的 `PaginationSchema`
    继承：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may recall, the attribute name in the final JSON response will be `data`
    here, because that is how it has been defined in `RecipePaginationSchema`. `attribute
    = 'items'` means that it is getting the source data from the `items` to attribute
    in `the pagination` objects.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所回忆的那样，最终JSON响应中的属性名在这里将是`data`，因为这是在`RecipePaginationSchema`中定义的。`attribute
    = 'items'`意味着它从`items`获取源数据到`pagination`对象的属性。
- en: 'Now, import `acs` and `desc` from `sqlalchemy` into `model/recipe.py` and modify
    the `get_all_published` method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`acs`和`desc`从`sqlalchemy`导入到`model/recipe.py`中，并修改`get_all_published`方法：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `get_all_published` method we built here is used to leverage the `paginate`
    method from Flask-SQLAlchemy. We will filter and order the records, then the paginate
    method takes the `page` and `per_page` parameters and generates a pagination object.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里构建的`get_all_published`方法用于利用Flask-SQLAlchemy的`paginate`方法。我们将过滤和排序记录，然后`paginate`方法接收`page`和`per_page`参数并生成一个分页对象。
- en: 'Import `fields, use_kwargs` and `RecipePaginationSchema` into `resources/recipe.py`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fields`、`use_kwargs`和`RecipePaginationSchema`导入到`resources/recipe.py`中：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declare the `recipe_pagination_schema` attribute in `resources/recipe.py` in
    order to serialize the paginated recipes:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/recipe.py`中声明`recipe_pagination_schema`属性，以便序列化分页的菜谱：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Modify the `RecipeListResource.get` method in `resources/recipe.py` in order
    to return the paginated recipes:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`resources/recipe.py`中的`RecipeListResource.get`方法，以便返回分页的菜谱：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we have added the `@user_kwargs` decorator to the `RecipeListResource.get`
    method. The default value for the `page` parameter is 1, while the default value
    for the `per_page` parameter is 20\. This means that if nothing is passed in,
    we will be getting the first page with the first 20 recipe records.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已将`@user_kwargs`装饰器添加到`RecipeListResource.get`方法中。`page`参数的默认值是1，而`per_page`参数的默认值是20。这意味着如果没有传入任何内容，我们将获取第一页，包含前20个菜谱记录。
- en: Then, we pass these two parameters into the `get_all_published` method to get
    the pagination object back. Finally, the paginated recipes will be serialized
    and returned to the frontend client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这两个参数传递给`get_all_published`方法以获取分页对象。最后，分页的菜谱将被序列化并返回给前端客户端。
- en: Here, we have successfully implemented the pagination function and displayed
    the result. In the next exercise, we will test the pagination functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经成功实现了分页功能并显示了结果。在下一个练习中，我们将测试分页功能。
- en: 'Exercise 51: Testing the Pagination Functions'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习51：测试分页功能
- en: 'In this exercise, we will test the pagination functions that we have just built.
    We will be creating eight recipes in our Smilecook application, and we will publish
    all of them. Then, we will simulate a user scenario in which we will get back
    all the recipes, page by page. Let''s get started:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试我们刚刚构建的分页功能。我们将在我们的Smilecook应用程序中创建八个菜谱，并将它们全部发布。然后，我们将模拟一个用户场景，我们将逐页获取所有菜谱。让我们开始吧：
- en: Click on the **Collections** tab.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**集合**标签。
- en: 'Then, select the **POST Token** request and **Send** a request. This is to
    login to a user account. The result is shown in the following screenshot:![Figure
    8.1: Sending the POST Token request'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**POST Token**请求并**发送**请求。这是为了登录用户账户。结果如下截图所示：![图8.1：发送POST Token请求
- en: '](img/C15309_08_01.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_08_01.jpg]'
- en: 'Figure 8.1: Sending the POST Token request'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：发送POST Token请求
- en: 'Create eight recipes by running the following `httpie` command in the PyCham
    console. The `{token}` placeholder should be replaced with the access token we
    obtained in *step 2*:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在PyCham控制台中运行以下`httpie`命令创建八个菜谱。将`{token}`占位符替换为我们第二步中获得的访问令牌：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can also create the recipes one by one using Postman. We are using the `httpie`
    command here because it's faster.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以使用Postman逐个创建菜谱。我们在这里使用`httpie`命令是因为它更快。
- en: 'Publish all eight recipes using the following `httpie` command. Replace the
    `{token}` placeholder with the access token. Make sure that the recipe IDs in
    the URLs are referring to the recipes we created in the previous step:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`httpie`命令发布所有八个菜谱。将`{token}`占位符替换为访问令牌。确保URL中的菜谱ID指的是我们在上一步中创建的菜谱：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have created and published eight recipes. Next, we will get the recipes
    back page by page with a page size of two recipes.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们已经创建并发布了八个菜谱。接下来，我们将以每页两个菜谱的大小逐页获取菜谱。
- en: Click on `per_page`, `2`) into `first`, `last`, and `next` pages. We can't see
    `prev` here because we are on the first page. There is a total of five pages,
    and we have two records per page. You can also see the **sorted** recipe details
    in the HTTP response.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`per_page`，`2`)到`first`、`last`和`next`页面。我们在这里看不到`prev`，因为我们是在第一页。总共有五页，每页有两条记录。你还可以在HTTP响应中看到**排序**后的食谱详情。
- en: 'Next, let''s test whether the links in the recipes are working properly. We
    just need to click on the `next` URL link, which will open a new tab in Postman
    with the request URL populated (`http://localhost:5000/recipes?per_page=2&page=2`).
    Then, we just need to click on **Send** to send the request. The result is shown
    in the following screenshot:![Figure 8.3: Testing the links in the recipes'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们测试食谱中的链接是否正常工作。我们只需点击`next` URL链接，这将在Postman中打开一个新标签页，并填充请求URL（`http://localhost:5000/recipes?per_page=2&page=2`）。然后，我们只需点击**发送**来发送请求。结果如下截图所示：![图8.3：测试食谱中的链接
- en: '](img/C15309_08_03.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_08_03.jpg)'
- en: 'Figure 8.3: Testing the links in the recipes'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：测试食谱中的链接
- en: Here, we can see that there are links to the `first`, `last`, `next`, and `prev`
    pages. We can also see that we are currently on page 2\. All the recipe data is
    there as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有指向`first`、`last`、`next`和`prev`页面的链接。我们还可以看到我们目前在第2页。所有的食谱数据都在这里。
- en: We have successfully created our pagination function. Now, I will leave it to
    your capable hands to test it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了分页函数。现在，我将把它交给你来测试。
- en: The benefit of pagination is that you are able to segregate thousands of records
    into pages. Data is retrieved in a page by page manner, and that will reduce the
    server's workload. But what if the user is setting a page size of, say, 100,000?
    How can we prevent a user from exploiting the system loophole? What we can do
    is pass the `max_per_page` parameter for pagination. That will limit the maximum
    page size the user can set. If the user is setting a page size bigger than the
    maximum page size, then the maximum page size will be used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 分页的好处是你可以将成千上万的记录分页。数据是按页检索的，这将减少服务器的负载。但是，如果用户设置的页面大小为，比如说，100,000呢？我们如何防止用户利用系统漏洞？我们可以做的是传递分页的`max_per_page`参数。这将限制用户可以设置的页面大小的最大值。如果用户设置的页面大小超过最大页面大小，则将使用最大页面大小。
- en: 'Activity 13: Implementing Pagination on the User-Specific Recipe Retrieval
    API'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十三：在用户特定食谱检索API上实现分页
- en: 'We implemented and tested the pagination function on our all published recipe
    retrieval APIs in the previous exercise. In this activity, we will work on the
    pagination function in the user-specific recipe retrieval API. The corresponding
    API can be found in `UserRecipeListResource`, which is used to get the recipes
    from a specific author. Follow these steps to complete this activity:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们实现了并测试了所有已发布食谱检索API的分页函数。在这个活动中，我们将处理用户特定食谱检索API的分页函数。相应的API可以在`UserRecipeListResource`中找到，它用于获取特定作者的食谱。按照以下步骤完成此活动：
- en: Modify the `get_all_by_user` method in `model/recipe.py`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`model/recipe.py`中的`get_all_by_user`方法。
- en: Import `RecipePaginationSchema` into `resources/user.py`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RecipePaginationSchema`导入到`resources/user.py`中。
- en: Declare the `recipe_pagination_schema` attribute in `resources/user.py`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中声明`recipe_pagination_schema`属性。
- en: Modify the `UserRecipeListResource.get` method in `resources/user.py`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`resources/user.py`中的`UserRecipeListResource.get`方法。
- en: Add the `@user_kwargs` decorator for `UserRecipeListResource.get`. It takes
    a few parameters, including `page`, `per_page`, and `visibility`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserRecipeListResource.get`添加`@user_kwargs`装饰器。它包含一些参数，包括`page`、`per_page`和`visibility`。
- en: Note
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 332.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第332页找到。
- en: Now, you should have completed the pagination function for the user recipe.
    Let's follow the same routine and test the function in the next activity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经完成了用户食谱的分页函数。让我们遵循同样的程序，在下一个活动中测试这个函数。
- en: 'Activity 14: Testing Pagination on the User-Specific Recipe Retrieval API'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十四：测试用户特定食谱检索API的分页
- en: 'In this activity, we will test the user recipe pagination function that we
    just built. We published eight recipes in the previous exercise. We will use them
    here as our test subjects. We are going to create a request in Postman and test
    whether we can get them back, page by page. Follow these steps to complete this
    activity:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将测试我们刚刚构建的用户食谱分页功能。我们在之前的练习中发布了八个食谱。我们将使用它们作为我们的测试对象。我们将创建一个 Postman
    请求并测试我们是否可以逐页获取它们。按照以下步骤完成此活动：
- en: Get all the recipes by the author from the previous exercise using Postman,
    page by page, with a page size of two.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman，按页获取上一练习中作者的所有食谱，每页两个。
- en: Click the next URL in the `links` to query for the next two records.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `links` 中的下一个 URL 来查询下两条记录。
- en: Note
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 334.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 334 页找到。
- en: Recipe Searching
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 食谱搜索
- en: In the previous exercises, we implemented the `pagination` function and also
    saw the benefits of using it. This can greatly reduce the number of recipes that
    are going back to users in one go. From the user's perspective, they can browse
    through different pages to look for the recipe they want.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们实现了 `pagination` 函数，并看到了使用它的好处。这可以大大减少一次性返回给用户的所有食谱的数量。从用户的角度来看，他们可以浏览不同的页面来查找他们想要的食谱。
- en: A better way for the user to look for a recipe is by searching. The search function
    is an essential function on the internet. Look at the search giant Google; their
    search engine brings in huge amounts of revenue. Of course, we are not going to
    implement anything of the scale of Google in our Smilecook application. We will
    be just doing a simple text matching search here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户查找食谱的更好方式是通过搜索。搜索功能是互联网上的一个基本功能。看看搜索巨头 Google；他们的搜索引擎带来了巨大的收入。当然，我们不会在我们的
    Smilecook 应用程序中实现像 Google 那样规模的东西。我们在这里将只进行简单的文本匹配搜索。
- en: In the next exercise, we will implement the search function in our Smilecook
    platform. We will build a recipe searching API that allows the client to provide
    a `q` parameter to search for specific recipes by name or recipe description.
    This can be done by using the `LIKE` comparison operator. The `LIKE` operator
    works by matching the search string with the target string. We can use `%` in
    the search string as a wildcard. If it's not a exact match here it is more like
    a `SIMILAR TO` matching. So, the `%Chicken%` search string will match with the
    `Hainanese Chicken Rice` string.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将在我们的 Smilecook 平台上实现搜索功能。我们将构建一个允许客户端提供 `q` 参数以通过名称或食谱描述搜索特定食谱的食谱搜索
    API。这可以通过使用 `LIKE` 比较运算符来完成。`LIKE` 运算符通过将搜索字符串与目标字符串匹配来工作。我们可以在搜索字符串中使用 `%` 作为通配符。如果这里不是精确匹配，那么它更像是
    `SIMILAR TO` 匹配。所以，`%Chicken%` 搜索字符串将与 `Hainanese Chicken Rice` 字符串匹配。
- en: Perhaps a better choice of comparison operator would be `ILIKE`. `LIKE` is case-sensitive,
    while `ILIKE` is case-insensitive. For example, we can't match `Thai Red Curry`
    with `%curry%` using the `LIKE` operator. You can see that `C` is uppercase here.
    However, if we use `ILIKE`, it will match perfectly fine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更好的比较运算符选择是 `ILIKE`。`LIKE` 是大小写敏感的，而 `ILIKE` 是大小写不敏感的。例如，我们无法使用 `LIKE` 运算符匹配
    `Thai Red Curry` 与 `%curry%`。你可以看到这里的 `C` 是大写的。然而，如果我们使用 `ILIKE`，它将完美匹配。
- en: 'Take a look at the following table to see how the comparison operator works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下表格，了解比较运算符是如何工作的：
- en: '![Figure 8.4: Comparison operators'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4：比较运算符](img/C15309_08_04.jpg)'
- en: '](img/C15309_08_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4：比较运算符](img/C15309_08_04.jpg)'
- en: 'Figure 8.4: Comparison operators'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8.4：比较运算符
- en: In our Smilecook platform, we don't want our search to be that strict. The search
    should be case-insensitive. Now, let's see how we can add this function to our
    Smilecook platform.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Smilecook 平台上，我们不希望我们的搜索那么严格。搜索应该是大小写不敏感的。现在，让我们看看我们如何将这个功能添加到我们的 Smilecook
    平台上。
- en: 'Exercise 52: Implementing the Search Function'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 52：实现搜索功能
- en: 'Having learned about the recipe searching concept, we want to implement this
    as a function in our Smilecook platform. To do this, we will be adding a `q` parameter
    that will pass the search string into the API. Then, we will use the search string
    to look for the recipes we require. Let''s get started:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了食谱搜索概念后，我们想在我们的 Smilecook 平台上实现这个功能。为此，我们将添加一个 `q` 参数，该参数将搜索字符串传递到 API 中。然后，我们将使用搜索字符串来查找我们需要的食谱。让我们开始吧：
- en: 'Import `or_` from `sqlalchemy` into `models/recipe.py`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `or_` 从 `sqlalchemy` 导入到 `models/recipe.py`：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Modify the `Recipe.get_all_published` method in `models/recipe.py` so that
    it gets all the published recipes that satisfy the search criteria:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `models/recipe.py` 中的 `Recipe.get_all_published` 方法，使其获取所有满足搜索条件的已发布食谱：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is used to assign the search pattern to the variable `keyword`.
    Then, it searches the `name` and `description` fields by this keyword.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码用于将搜索模式分配给变量 `keyword`。然后，它通过这个关键字搜索 `name` 和 `description` 字段。
- en: 'Modify `RecipeListResource` in `resources/recipe.py`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `resources/recipe.py` 中的 `RecipeListResource`：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We added the `q` parameter to the `user_kwargs` decorator and the `get` function.
    The default for this `q` value is an empty string. The `q` parameter will also
    be passed into the `get_all_published` function.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `user_kwargs` 装饰器和 `get` 函数中添加了 `q` 参数。这个 `q` 参数的默认值是一个空字符串。这个 `q` 参数也将传递给
    `get_all_published` 函数。
- en: Now we are done with the search function. Next, we are going to test this function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了搜索功能。接下来，我们将测试这个功能。
- en: 'Exercise 53: Testing the Search Function'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习53：测试搜索功能
- en: 'In this exercise, we will be testing the search function that we have just
    built. We will test by searching for recipes that contain the `fried rice` string
    in the name or description. Let''s get started:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试我们刚刚构建的搜索功能。我们将通过搜索包含 `fried rice` 字符串的食谱来测试。让我们开始吧：
- en: Click on the `RecipeList` request and select the **Params** tab.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `RecipeList` 请求并选择 **参数** 选项卡。
- en: Insert the first key-value pair (`q`, `fried rice`).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第一个键值对 (`q`, `fried rice`)。
- en: Insert the second key-value pair (`per_page`, `2`).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第二个键值对 (`per_page`, `2`)。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.5: Searching for recipes that contain the "fried rice" string in the name or
    description'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图8.5：搜索包含“fried rice”字符串的食谱
- en: '](img/C15309_08_05.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_08_05.jpg)'
- en: 'Figure 8.5: Searching for recipes that contain the "fried rice" string in the
    name or description'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：搜索包含“fried rice”字符串的食谱
- en: Here, we can see four fried rice recipe records, divided into two pages.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到四个炒饭食谱记录，分为两页。
- en: 'Next, test whether the links in the recipes are still working properly. We
    just need to click on the next URL link, which will open a new tab in Postman
    with the request URL populated (`http://localhost:5000/recipes?q=fried+rice&per_page=2&page=2`).
    Then, we just need to click on **Send** to send the request. The result is shown
    in the following screenshot:![Figure 8.6: Testing whether the links in the recipes
    are working'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，测试食谱中的链接是否仍然正常工作。我们只需点击下一个URL链接，这将在Postman中打开一个新标签页，并填充请求URL (`http://localhost:5000/recipes?q=fried+rice&per_page=2&page=2`)。然后，我们只需点击
    **发送** 来发送请求。结果如下截图所示：![图8.6：测试食谱中的链接是否工作
- en: '](img/C15309_08_06.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_08_06.jpg)'
- en: 'Figure 8.6: Testing whether the links in the recipes are working'
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：测试食谱中的链接是否工作
- en: From the result, we can that we are now on `page 2`. The recipe records are
    also sorted by creation time. The latest recipe is placed on the top.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到我们现在在第 `2` 页。食谱记录也按创建时间排序。最新的食谱位于顶部。
- en: So far, we have created the pagination and searching functions. This is a great
    achievement, but we are not done yet. We need to continue enhancing our Smilecook
    application. Without further ado, let's move on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了分页和搜索功能。这是一个巨大的成就，但我们还没有完成。我们需要继续增强我们的 Smilecook 应用程序。无需多言，让我们继续前进。
- en: Sorting and Ordering
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和排序
- en: Sorting is another important feature that helps user navigation. Again, when
    we build any application, we need to keep the user experience in mind. Our application
    could eventually store millions of recipes, so we need to provide an easy way
    for our users to navigate the recipes and find the recipe they want.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是另一个重要的功能，有助于用户导航。再次强调，当我们构建任何应用程序时，我们需要考虑用户体验。我们的应用程序最终可能存储数百万个食谱，因此我们需要提供一个简单的方法，让我们的用户能够浏览食谱并找到他们想要的食谱。
- en: Previously, the recipes that we sent back were sorted by time by default. Let's
    implement some other sorting criteria in our Smilecook application. We can still
    keep the default sorting criteria such as time, but we want to allow the user
    to define the searching criteria they want; for example, they can specify that
    they want the recipes to be sorted by cooking time. This is a possibility as the
    user may want to cook a quick meal, which means they will only be interested in
    recipes with short cooking times.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们发送回的食谱默认按时间排序。让我们在我们的 Smilecook 应用程序中实现一些其他的排序标准。我们仍然可以保留默认的排序标准，如时间，但我们希望允许用户定义他们想要的搜索标准；例如，他们可以指定他们想要按烹饪时间排序的食谱。这是一个可能性，因为用户可能想要快速烹饪，这意味着他们只对烹饪时间短的食谱感兴趣。
- en: For our Smilecook application, sorting and ordering can be done by adding the
    `sort` and `order` parameters. We can put the sorting criteria (for example, `created_at`,
    `cook_time`, or `num_of_servings`) into the `sort` parameter, and we can use `created_at`
    as the default. The `order` parameter is used to specify whether it is `asc` (ascending
    order) or `desc` (descending order). We can put `desc` as the default.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Smilecook 应用程序，排序和排序可以通过添加 `sort` 和 `order` 参数来完成。我们可以将排序标准（例如，`created_at`、`cook_time`
    或 `num_of_servings`）放入 `sort` 参数中，我们可以使用 `created_at` 作为默认值。`order` 参数用于指定是 `asc`（升序）还是
    `desc`（降序）。我们可以将 `desc` 作为默认值。
- en: 'In terms of the syntax, if we want our SQLAlchemy query result to be sorted
    in ascending order, we can do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法方面，如果我们想要我们的 SQLAlchemy 查询结果按升序排序，我们可以这样做：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we want it to be sorted in descending order, we can just use `desc`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要按降序排序，我们只需使用 `desc`：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of `cls.is_published=True`, you can also use the SQLAlchemy column operator,
    that is, `cls.is_published.is_(True)`. You will get the same result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `cls.is_published=True`，您还可以使用 SQLAlchemy 列操作符，即 `cls.is_published.is_(True)`。您将得到相同的结果。
- en: In the next exercise, we will implement the sorting and ordering functions in
    our Smilecook platform. This will make our application more user-friendly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将实现 Smilecook 平台的排序和排序功能。这将使我们的应用程序更加用户友好。
- en: 'Exercise 54: Implementing Sorting and Ordering'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 54：实现排序和排序
- en: 'In this exercise, we will implement the sorting and ordering functions in our
    Smilecook platform. We will be adding the `sort` and `order` parameters to the
    get all published recipes API so that users can perform sorting and ordering on
    the published recipes. Let''s get started:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现 Smilecook 平台的排序和排序功能。我们将向获取所有已发布食谱的 API 中添加 `sort` 和 `order` 参数，以便用户可以对已发布的食谱进行排序和排序。让我们开始吧：
- en: 'In `resources/recipe.py`, use the `use_kwargs` `method` in the decorator to
    add two parameters (`sort`, `order`) to the `RecipeListResource.get` method. Set
    the default values for these two parameters to `created_at` and `desc`, respectively:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/recipe.py` 中，使用装饰器中的 `use_kwargs` `方法` 向 `RecipeListResource.get`
    方法添加两个参数（`sort`、`order`）。分别为这两个参数设置默认值 `created_at` 和 `desc`：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Restrict the `sort` parameter to accept only the `created_at`, `cook_time`,
    and `num_of_servings` values. If other values are passed in, then we''ll default
    to `created_at`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 `sort` 参数只接受 `created_at`、`cook_time` 和 `num_of_servings` 的值。如果传入其他值，则默认为
    `created_at`：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Restrict the `order` parameter to accept only the `asc` and `desc` values.
    If other values are passed in, then we''ll default to `desc`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 `order` 参数只接受 `asc` 和 `desc` 的值。如果传入其他值，则默认为 `desc`：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Pass the `sort` and `order` parameters into the `get_all_published` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sort` 和 `order` 参数传递给 `get_all_published` 函数：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `get_all_published` method in `models/recipe.py` so that it looks
    as follows. It takes in two additional parameters, that is, `sort` and `order`,
    to define the logic:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `models/recipe.py` 中的 `get_all_published` 方法，使其如下所示。它接受两个额外的参数，即 `sort` 和
    `order`，以定义逻辑：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have created the sorting and ordering functions. Not many changes were
    made to the code. Next, we are going to test our implementation using Postman.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经创建了排序和排序函数。代码没有做太多修改。接下来，我们将使用 Postman 测试我们的实现。
- en: 'Exercise 55: Testing the Sorting and Ordering Feature'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 55：测试排序和排序功能
- en: 'In the previous exercise, we created customized ordering functions. Users should
    be able to order the recipe records in our Smilecook platform by their specified
    column, and in either ascending or descending order. In this exercise, we will
    test whether that is really the case. We will pass the `sort` and `order` parameters
    into Postman and verify them. Let''s get started:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们创建了自定义排序函数。用户应该能够通过指定的列对Smilecook平台上的食谱记录进行排序，无论是升序还是降序。在这个练习中，我们将测试这是否真的可行。我们将传递`sort`和`order`参数到Postman并验证它们。让我们开始吧：
- en: We will send a request to get all the recipe records back. Then, sort the data
    by `cook_time` in ascending order. First, click on the `RecipeList` request and
    select the **Params** tab.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将发送一个请求以获取所有食谱记录。然后，按`cook_time`升序排序数据。首先，点击`RecipeList`请求并选择**Params**标签页。
- en: Insert the first key-value pair (`sort`, `cook_time`).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第一个键值对（`sort`，`cook_time`）。
- en: Insert the second key-value pair (`order`, `desc`).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第二个键值对（`order`，`desc`）。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.7: Sending a request to get all the recipe records back'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图8.7：发送请求以获取所有食谱记录](img/C15309_08_07.jpg)
- en: '](img/C15309_08_07.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_08_07.jpg](img/C15309_08_07.jpg)'
- en: 'Figure 8.7: Sending a request to get all the recipe records back'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：发送请求以获取所有食谱记录
- en: From the preceding search result, we can see that the recipe's `cook_time` is
    sorted in ascending order. The first recipe's `cook_time` is 20 minutes, whereas
    the second one is 30 minutes.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的搜索结果中，我们可以看到食谱的`cook_time`是按升序排序的。第一个食谱的`cook_time`是20分钟，而第二个是30分钟。
- en: Send a request to get all the recipe records back. Then, sort the data by `num_of_servings`
    in descending order. Click on `RecipeList` and select the **Params** tab.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求以获取所有食谱记录。然后，按`num_of_servings`降序排序数据。点击`RecipeList`并选择**Params**标签页。
- en: Insert the first key-value pair (`sort`, `num_of_servings`).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第一个键值对（`sort`，`num_of_servings`）。
- en: Insert the second key-value pair (`order`, `desc`).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入第二个键值对（`order`，`desc`）。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.8: Sending a request and sorting the data by num_of_servings in descending order'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下截图所示：![图8.8：发送请求并按num_of_servings降序排序数据](img/C15309_08_08.jpg)
- en: '](img/C15309_08_08.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_08_08.jpg](img/C15309_08_08.jpg)'
- en: 'Figure 8.8: Sending a request and sorting the data by num_of_servings in descending
    order'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：按num_of_servings降序发送请求并排序数据
- en: From the preceding search result, we can see that the recipe's `num_of_servings`
    has been sorted in descending order. The first recipe's `num_of_servings` is for
    five people, whereas the second one is for four people.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的搜索结果中，我们可以看到食谱的`num_of_servings`已经按降序排序。第一个食谱的`num_of_servings`是为五人准备的，而第二个是为四人准备的。
- en: Now, you have finished developing and testing all the functions you have learned
    about in this chapter. Next, we will complete an activity to ensure you have the
    flexibility to use what we have learned so far.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经完成了本章所学所有功能的开发和测试。接下来，我们将完成一个活动，以确保你能够灵活地使用到目前为止所学的内容。
- en: 'Activity 15: Searching for Recipes with Specific Ingredients'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：搜索含有特定成分的食谱
- en: 'In this activity, we will search the recipes using a specific attribute. We
    will add a new `ingredients` attribute and then pass in parameters to search through
    the recipe. Follow these steps to complete this activity:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用特定的属性搜索食谱。我们将添加一个新的`ingredients`属性，然后传递参数以搜索食谱。按照以下步骤完成此活动：
- en: Add the ingredients attribute to the `Recipe` model.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将成分属性添加到`Recipe`模型中。
- en: Run Flask-Migrate to update the database.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Flask-Migrate以更新数据库。
- en: Add the `ingredients` attribute to `RecipeSchema`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ingredients`属性添加到`RecipeSchema`。
- en: Modify the `RecipeResource.patch` method to support the `ingredients` attribute
    update.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipeResource.patch`方法以支持`ingredients`属性更新。
- en: Modify the `Recipe.get_all_published` method so that you can search through
    the ingredients.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Recipe.get_all_published`方法，以便可以通过成分进行搜索。
- en: Create two recipes with the `ingredients` attribute and publish them.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个带有`ingredients`属性的食谱并发布它们。
- en: Search for the recipes using the `ingredients` attribute.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ingredients`属性搜索食谱。
- en: Note
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 336.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第336页找到。
- en: Congratulations! You have completed this activity. Now, please work on the assessments
    to test your understanding of this chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了这个活动。现在，请进行评估，以测试你对本章内容的理解。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We have implemented a lot of great features in this chapter that allows users
    to find the recipe information they want in a simple and efficient manner. The
    pagination function we implemented allows the user to quickly find out how many
    recipes there are in total and navigate them page by page. It also saves the server's
    resources as it doesn't need to render thousands of recipes in one go.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了许多出色的功能，使用户能够以简单高效的方式找到他们想要的食谱信息。我们实现的分页功能允许用户快速了解总共有多少食谱，并逐页浏览。它还节省了服务器的资源，因为它不需要一次性渲染成千上万的食谱。
- en: The search function is another time-saving feature. Users can now look for the
    recipes they want by performing a simple search. We have also completed the sorting
    and ordering functions in the Smilecook application, which provide a better browsing
    experience for users.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索功能是另一个节省时间的特性。用户现在可以通过简单的搜索来查找他们想要的食谱。我们还在Smilecook应用程序中完成了排序和排序功能，这为用户提供了更好的浏览体验。
- en: So far, we have created almost all of the user functions we need. Our Smilecook
    platform development is nearing its end. In the next chapter, we will work on
    internal system optimization, such as HTTP caching and rate-limiting.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎创建了所有需要的用户功能。我们的Smilecook平台开发即将结束。在下一章中，我们将致力于内部系统优化，例如HTTP缓存和速率限制。
