- en: 5\. Object Serialization with marshmallow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 使用 marshmallow 进行对象序列化
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Create a schema for serialization/deserialization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为序列化/反序列化创建一个模式
- en: Validate the data in a client request
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证客户端请求中的数据
- en: Perform data filtering before displaying the data to the client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向客户端显示数据之前执行数据过滤
- en: Use the HTTP PATCH method to partially update data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP PATCH 方法部分更新数据
- en: This chapter covers serialization and deserialization, as well as data filtering
    and validation with marshmallow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了序列化和反序列化，以及使用 marshmallow 的数据过滤和验证。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In this era of information explosion, the correctness of data is crucially important.
    We need to ensure that the data passed in by the client is in the format we expect.
    For example, we expect the `cooking time` variable to be a data type integer with
    a value of 30, but the client could pass in a string data type, with `value =
    "thirty minutes"`. They mean the same thing, and both are understandable to human
    beings but the system won't be able to interpret them. In this chapter, we will
    learn about data validation, making sure the system only takes valid data. The
    marshmallow package not only helps us to verify the client's data but also to
    verify the data that we send back. This ensures data integrity in both directions,
    which will greatly improve the quality of the system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息爆炸的时代，数据的正确性至关重要。我们需要确保客户端传入的数据是我们期望的格式。例如，我们期望 `cooking time` 变量是一个整型数据，值为
    30，但客户端可能会传入一个字符串数据类型，`value = "thirty minutes"`。它们意味着相同的事情，并且两者对人类来说都是可理解的，但系统无法解释它们。在本章中，我们将学习数据验证，确保系统只接受有效数据。marshmallow
    包不仅帮助我们验证客户端的数据，还验证我们发送回的数据。这确保了双向数据完整性，将大大提高系统的质量。
- en: 'In this chapter, we will focus on doing three essential things: first, we will
    modify the `User` class and add in the API verification. This is mainly to show
    the basic functions of marshmallow. We''ll then modify the `Recipe` class, add
    a custom authentication method, and optimize the code. Finally, a new feature
    will be added, which allows us to query all the recipes of a specific user and
    filter the recipes with different publish statuses by the visibility parameter.
    With this in mind, let''s move on to the first topic: **Serialization** versus
    **Deserialization**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注做三件重要的事情：首先，我们将修改 `User` 类并添加 API 验证。这主要是为了展示 marshmallow 的基本功能。然后，我们将修改
    `Recipe` 类，添加自定义认证方法，并优化代码。最后，将添加一个新功能，允许我们查询特定用户的全部食谱，并通过可见性参数过滤不同发布状态的食谱。考虑到这一点，让我们继续探讨第一个主题：**序列化**与**反序列化**。
- en: Serialization versus Deserialization
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化与反序列化
- en: '![Figure 5.1: Serialization versus deserialization'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1：序列化与反序列化'
- en: '](img/C15309_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_05_01.jpg)'
- en: 'Figure 5.1: Serialization versus deserialization'
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.1：序列化与反序列化
- en: An object is something that lives in the application memory. We can invoke its
    method or access its attributes in our application. However, when we want to transfer
    or store an object, we will have to convert it into a storable or transferrable
    format, and that format will be a stream of bytes. It can then be stored in a
    text file, in a database, or be transmitted over the internet. The process of
    converting an object to a stream of bytes is called serialization. This stream
    of bytes persists the state of the object so that it can be recreated later. The
    recreation of the object from a stream of bytes is called deserialization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是存在于应用程序内存中的东西。我们可以在应用程序中调用其方法或访问其属性。然而，当我们想要传输或存储对象时，我们必须将其转换为可存储或可传输的格式，而这个格式将是一串字节。然后它可以存储在文本文件中，存储在数据库中，或通过互联网传输。将对象转换为字节流的过程称为序列化。这串字节流持久化对象的当前状态，以便稍后可以重新创建。从字节流中重新创建对象的过程称为反序列化。
- en: Serialization/deserialization is an essential part of RESTful API development.
    During actual development, the data validation related to business logic will
    often be included in the serialization and deserialization implementation processes
    as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化/反序列化是 RESTful API 开发的一个关键部分。在实际开发过程中，与业务逻辑相关的数据验证通常会包含在序列化和反序列化的实现过程中。
- en: marshmallow
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: marshmallow
- en: '**marshmallow** itself is an excellent package for serialization and deserialization
    in Python, as well as providing validation features. It allows developers to define
    schemas, which can be used to represent a field in various ways (required and
    validation), and automatically perform validation during deserialization. We will
    start by implementing a data validation function in this chapter. We will implement
    it using the marshmallow package to ensure that the information the user entered
    is correct. We will work with you through various exercises and activities to
    test serialization and deserialization afterward with Postman.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**marshmallow** 本身是一个用于Python中序列化和反序列化的优秀包，同时也提供了验证功能。它允许开发者定义模式，这些模式可以用不同的方式（必需和验证）来表示字段，并在反序列化过程中自动执行验证。在本章中，我们将首先实现一个数据验证函数。我们将使用
    marshmallow 包来实现它，以确保用户输入的信息是正确的。我们将通过各种练习和活动与您一起测试使用Postman之后的序列化和反序列化。'
- en: A Simple Schema
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单模式
- en: 'We will be using the `Schema` class from marshmallow to specify the fields
    for the objects that we want to serialize/deserialize. Without knowing the schema
    of the objects and how we want to serialize the fields, we can''t perform serialization
    or deserialization. In the following example, you can see we have a simple `SimpleSchema`
    class, which extends `marshmallow.Schema`, and there are two fields defined there,
    `id` and `username`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 marshmallow 的 `Schema` 类来指定我们想要序列化/反序列化的对象的字段。如果我们不知道对象的模式以及我们想要如何序列化字段，我们就无法执行序列化或反序列化。在下面的示例中，你可以看到一个简单的
    `SimpleSchema` 类，它扩展了 `marshmallow.Schema`，并且那里定义了两个字段，`id` 和 `username`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The data type of the fields are defined using the `marshmallow` fields. From
    the preceding example, the `id` field is an `username` field is a **string**.
    There are a number of different data types in marshmallow, including **Str**,
    **Int**, **Bool**, **Float**, **DateTime**, **Email**, **Nested**, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的类型使用 `marshmallow` 字段定义。从前面的示例中，`id` 字段是一个 `username` 字段是一个 **字符串**。在 marshmallow
    中有几种不同的数据类型，包括 **Str**、**Int**、**Bool**、**Float**、**DateTime**、**Email**、**Nested**
    等。
- en: With the schema specified, we can start doing object serialization and deserialization.
    We can serialize objects in our application and return them in the HTTP response.
    Or, the other way round, we can take in a request from users and deserialize that
    into an object so that it can be used in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了模式之后，我们可以开始进行对象的序列化和反序列化。我们可以在我们的应用程序中序列化对象并在HTTP响应中返回它们。或者反过来，我们可以接收用户的请求并将它反序列化为一个对象，以便在应用程序中使用。
- en: Field Validation
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段验证
- en: 'We can also add field-level validation during serialization/deserialization.
    Again, this can be done in the schema definition. For example, if we want to specify
    a field as mandatory, we can add in the `required=True` argument. Using the same
    `SimpleSchema` example, we can specify the `username` field as mandatory as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在序列化/反序列化过程中添加字段级验证。同样，这可以在模式定义中完成。例如，如果我们想指定一个字段为必需的，我们可以添加 `required=True`
    参数。使用相同的 `SimpleSchema` 示例，我们可以指定 `username` 字段为必需的，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If this `SimpleSchema` is used to deserialize the JSON request from the user
    and the `username` field is not filled in there, there will be an error message,
    `Validation errors`, and the HTTP status code will be **400 Bad Request**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此 `SimpleSchema` 来反序列化用户的JSON请求，并且 `username` 字段没有填写，将会出现错误信息，“验证错误”，并且HTTP状态码将是**400
    Bad Request**：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we will learn how to customize deserialization methods.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习如何自定义反序列化方法。
- en: Customizing Deserialization Methods
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义反序列化方法
- en: We can also customize the way we want to deserialize certain fields. We can
    do so by using `Method` fields in marshmallow. A `Method` field receives an optional
    `deserialize` argument, which defines how the field should be deserialized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以自定义我们想要反序列化的某些字段的格式。我们可以通过在 marshmallow 中使用 `Method` 字段来实现这一点。一个 `Method`
    字段接收一个可选的 `deserialize` 参数，它定义了字段应该如何反序列化。
- en: 'From the following `SimpleSchema` example, we can define a custom method to
    deserialize the `password` field. We just need to pass in the `deserialize=''load_password''`
    argument. It will invoke the `load_password` method to deserialize the `password`
    field:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的 `SimpleSchema` 示例中，我们可以定义一个自定义方法来反序列化 `password` 字段。我们只需要传递 `deserialize='load_password'`
    参数。它将调用 `load_password` 方法来反序列化 `password` 字段：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the next section, we will learn how to use the `UserSchema` design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用 `UserSchema` 设计。
- en: UserSchema Design
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserSchema 设计
- en: Now we have learned why we need to use `Schema` and how we can define a schema,
    we will start to work on that in our `Smilecook` application. In the case of user
    registration, we will expect the user to fill in their information on a web form,
    and then send the details in JSON format to the server. Our `Smilecook` application
    will then deserialize it to be a `User` object, which can be worked on in our
    application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了为什么需要使用 `Schema` 以及如何定义一个模式，我们将在我们的 `Smilecook` 应用程序中开始工作。在用户注册的情况下，我们期望用户在一个网页表单中填写他们的信息，然后将详细信息以
    JSON 格式发送到服务器。我们的 `Smilecook` 应用程序然后将它反序列化为 `User` 对象，这样我们就可以在我们的应用程序中对其进行操作。
- en: 'We will, therefore, need to define a `UserSchema` class to specify the expected
    attributes in the JSON request coming from the frontend. We will need the following
    fields:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要定义一个 `UserSchema` 类来指定前端发送的 JSON 请求中期望的属性。我们需要以下字段：
- en: '`id`: Use `fields.Int()` to represent an integer. In addition, `dump_only=True`
    means that this property is only available for serialization, not deserialization.
    This is because `id` is autogenerated, not passed in by the user.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：使用 `fields.Int()` 来表示一个整数。此外，`dump_only=True` 表示这个属性仅适用于序列化，不适用于反序列化。这是因为
    `id` 是自动生成的，不是由用户传入的。'
- en: '`username`: Use `fields.String()` to represent a string and apply `required=True`
    to indicate that this property is mandatory. When the client sends JSON data without
    the username, there will be a validation error.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：使用 `fields.String()` 来表示一个字符串，并应用 `required=True` 来表示这个属性是必须的。当客户端发送没有用户名的
    JSON 数据时，将出现验证错误。'
- en: '`email`: Use `fields.Email()` to indicate that `email` format is needed, and
    apply `required=True` to indicate that this property is mandatory.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：使用 `fields.Email()` 来指示需要 `email` 格式，并应用 `required=True` 来表示这个属性是必须的。'
- en: '`password:fields.Method()` is a `Method` field. The `Method` field here receives
    an optional `deserialize` argument, which defines how the field should be deserialized.
    We use `deserialize=''load_password''` to indicate that the `load_password(self,
    value)` method will be invoked when using `load()` deserialization. Please note
    that this `load_password(self, value)` method will only be invoked during `load()`
    deserialization.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password:fields.Method()` 是一个 `Method` 字段。这里的 `Method` 字段接收一个可选的 `deserialize`
    参数，它定义了字段应该如何进行反序列化。我们使用 `deserialize=''load_password''` 来表示当使用 `load()` 反序列化时将调用
    `load_password(self, value)` 方法。请注意，这个 `load_password(self, value)` 方法仅在 `load()`
    反序列化期间被调用。'
- en: '`created_at:fields.DateTime()` represents the time format, and `dump_only=True`
    means that this property will only be available in serialization.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at:fields.DateTime()` 表示时间格式，`dump_only=True` 表示这个属性将仅在序列化时可用。'
- en: '`updated_at:fields.DateTime()` represents the time format, and `dump_only=True`
    means that this property will only be available in serialization.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at:fields.DateTime()` 表示时间格式，`dump_only=True` 表示这个属性将仅在序列化时可用。'
- en: In our next exercise, we will install the marshmallow package in our `Smilecook`
    project. Then, we will define the `UserSchema` and use it in `UserListResource`
    and `UserResource`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个练习中，我们将在 `Smilecook` 项目中安装 marshmallow 包。然后，我们将定义 `UserSchema` 并将其用于
    `UserListResource` 和 `UserResource`。
- en: 'Exercise 33: Using marshmallow to Validate the User Data'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 33：使用 marshmallow 验证用户数据
- en: 'Firstly, we will perform data verification using marshmallow. We will install
    the `marshmallow` package and build `UserSchema`, and then use it in `UserListResource`
    to transmit the `User` object:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 marshmallow 进行数据验证。我们将安装 `marshmallow` 包并构建 `UserSchema`，然后将其用于 `UserListResource`
    以传输 `User` 对象：
- en: 'We will first install the marshmallow package. Please enter the following in
    `requirements.txt`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装 marshmallow 包。请在 `requirements.txt` 中输入以下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the `pip install` command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `pip install` 命令：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the result that follows:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a folder under the `Smilecook` project and name it `schemas`. We will
    store all our schema files here.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Smilecook` 项目下创建一个文件夹，命名为 `schemas`。我们将在这里存储所有的模式文件。
- en: 'Create a `user.py` file under that and enter the following code. Use a schema
    to define the basic structure of the content of our expected client request. The
    following code creates `UserSchema` to define the attributes we will receive in
    the client request:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该目录下创建一个 `user.py` 文件，并输入以下代码。使用模式来定义我们期望客户端请求内容的基本结构。以下代码创建 `UserSchema` 以定义我们将接收到的客户端请求中的属性：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before defining `UserSchema`, we need to first import `Schema` and `fields`
    from marshmallow. All self-defined marshmallow schemas must inherit `marshmallow.Schema`.
    Then, we import `hash_password`, and we define four attributes: `id`, `username`,
    `email`, and `password` in `UserSchema`.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义`UserSchema`之前，我们首先需要从marshmallow导入`Schema`和`fields`。所有自定义的marshmallow模式都必须继承`marshmallow.Schema`。然后，我们导入`hash_password`，并在`UserSchema`中定义四个属性：`id`、`username`、`email`和`password`。
- en: 'Add the following code in `resources/user.py`. We will first import the `UserSchema`
    class from the previous step and instantiate two `UserSchema` objects here. One
    of them is for use in public, and we can see that the email is excluded:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中添加以下代码。我们将首先从上一步导入`UserSchema`类，并在本处实例化两个`UserSchema`对象。其中一个用于公共用途，我们可以看到电子邮件被排除在外：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For our `user` resource, when the authenticated user accesses its `users/<username>`
    endpoint, they can get `id`, `username`, and `email`. But if they are not authenticated
    or are accessing other people's `/users/<username>` endpoint, the email address
    will be hidden.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的`用户`资源，当认证用户访问其`users/<username>`端点时，他们可以获取`id`、`username`和`email`。但如果他们未认证或访问其他人的`/users/<username>`端点，则电子邮件地址将被隐藏。
- en: 'We will then modify `UserListResource` to the following to validate the data
    in the user''s request:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`UserListResource`如下，以验证用户请求中的数据：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the same `UserListResource.post`, we will proceed if there is no error.
    It will then check whether `username` and `email` exist, and if everything is
    fine, we will use `User(**data)` to create a user instance, the `**data` will
    give us keyword arguments for the `User` class, then we use `user.save()` to store
    things in the database:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`UserListResource.post`中，如果没有错误，我们将继续进行。它将检查`username`和`email`是否存在，如果一切正常，我们将使用`User(**data)`创建用户实例，`**data`将为`User`类提供关键字参数，然后我们使用`user.save()`将事物存储在数据库中：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, also in `UsersLitResource.post`, we use `user_schema.dump(user).data`
    to return the successfully registered user data. It will contain `id`, `username`,
    `created_at`, `updated_at`, and `email`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`UsersLitResource.post`中，我们也使用`user_schema.dump(user).data`来返回成功注册的用户数据。它将包含`id`、`username`、`created_at`、`updated_at`和`email`：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will modify `UserResource`. We will see the difference between with
    and without filtering email using `user_schema` and `user_public_schema` here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`UserResource`。在这里，我们将看到使用`user_schema`和`user_public_schema`进行电子邮件过滤和不进行过滤之间的区别：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When a user sends a request to `/users/<username/`, we will get their username.
    If a user can't be found, we will get `user_schema.dump(user).data`, which contains
    all the information. Otherwise, `user_public_schema.dump(user).data` will be used,
    which excludes the email information. Finally, it returns data with the HTTP status
    code **200 OK**.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户向`/users/<username/>`发送请求时，我们将获取他们的用户名。如果找不到用户，我们将获取`user_schema.dump(user).data`，其中包含所有信息。否则，将使用`user_public_schema.dump(user).data`，它不包括电子邮件信息。最后，它将返回带有HTTP状态码**200
    OK**的数据。
- en: 'Next, we will modify `MeResource`. It will be serialized using `user_schema.dump(user).data`,
    which contains all the information of the user:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`MeResource`。它将使用`user_schema.dump(user).data`进行序列化，其中包含用户的所有信息：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save `app.py` and right-click on it to run the application. Flask will then
    be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure 5.2:
    Run the application and then run Flask on the localhost'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`app.py`，然后右键单击它以运行应用程序。然后Flask将在本地主机（`127.0.0.1`）的端口`5000`上启动并运行：![图5.2：运行应用程序，然后在本地主机上运行Flask]
- en: '](img/C15309_05_02.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片C15309_05_02.jpg]'
- en: 'Figure 5.2: Run the application and then run Flask on the localhost'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图5.2：运行应用程序，然后在本地主机上运行Flask]'
- en: So, we have finished adding marshmallow to the picture. From now onward, when
    we transfer the `User` object between the frontend and backend, it will first
    be serialized/deserialized. In the process, we can leverage the data validation
    functions provided by marshmallow to make our API endpoints even more secure.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了将棉花糖添加到图片中的工作。从现在开始，当我们在前端和后端之间传输`User`对象时，它将首先进行序列化/反序列化。在这个过程中，我们可以利用marshmallow提供的数据验证函数来使我们的API端点更加安全。
- en: 'Exercise 34: Testing the User Endpoint before and after Authentication'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习34：在认证前后测试用户端点
- en: We implemented different user schemas in the previous exercise one for private
    viewing and one for public viewing. In this exercise, we are going to test whether
    they work as expected. We will check the data in the HTTP response and verify
    whether we get different user information before and after authentication. We
    want to hide the user's email address from the public, to protect user privacy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们实现了不同的用户模式，一个用于私有查看，一个用于公共查看。在这个练习中，我们将测试它们是否按预期工作。我们将检查 HTTP 响应中的数据，并验证在认证前后我们是否得到不同的用户信息。我们希望从公共中隐藏用户的电子邮件地址，以保护用户隐私。
- en: We will do the whole test using Postman. Let's get started!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postman 进行整个测试。让我们开始吧！
- en: Check the `user` details before the user has logged in. We shouldn't see the
    user's email address in the result. Click on the **Collections** tab.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录前检查 `user` 详情。我们不应该在结果中看到用户的电子邮件地址。点击 **集合** 选项卡。
- en: Select the **GET User** request.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **GET User** 请求。
- en: Enter `http://localhost:5000/users/james` in the URL field. You can replace
    the username `James` with any username that is appropriate.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 URL 字段中输入 `http://localhost:5000/users/james`。你可以将用户名 `James` 替换为任何合适的用户名。
- en: Click `user` details. And in the response body, we can see the user details
    for James. We can see the `username`, `created_at`, `updated_at`, and `id`, but
    not the email address.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `user` 详情。在响应体中，我们可以看到 James 的用户详情。我们可以看到 `username`、`created_at`、`updated_at`
    和 `id`，但没有电子邮件地址。
- en: 'Now, let''s login using Postman. Select the **POST Token** request. Click **Send**
    to log in. The result is shown in the following screenshot:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Postman 登录。选择 **POST Token** 请求。点击 **发送** 进行登录。结果如下所示：
- en: '![Figure 5.4: Log in and select the POST Token request'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图 5.4：登录并选择 POST Token 请求'
- en: '](img/C15309_05_04.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_05_04.jpg)'
- en: 'Figure 5.4: Log in and select the POST Token request'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.4：登录并选择 POST Token 请求
- en: You will then see the response body for the access token and the refresh token.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你会看到访问令牌和刷新令牌的响应体。
- en: Check the `user` details after the user has logged in. You should see the user's
    email address in the result. Click on the **Collections** tab. Choose to **GET
    User**. Select the **Headers** tab.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录后检查 `user` 详情。你应该在结果中看到用户的电子邮件地址。点击 **集合** 选项卡。选择 **GET User**。选择 **头部**
    选项卡。
- en: Enter `Authorization` in the `Bearer {token}` in the `JWT` token we got in *step
    5*.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们获得的 JWT 令牌的 `Bearer {token}` 中输入 `Authorization`。
- en: 'Click **Send** to check the user details for James. The result is shown in
    the following screenshot:![Figure 5.5: Checking the details after the user has
    logged in'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 检查 James 的用户详情。结果如下所示：![图 5.5：用户登录后查看详情
- en: '](img/C15309_05_05.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_05_05.jpg)'
- en: 'Figure 5.5: Checking the details after the user has logged in'
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.5：用户登录后查看详情
- en: You will then see the return response. In the response body, we can see the
    user details for James. We can see all his information, including his email address.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到返回的响应。在响应体中，我们可以看到 James 的用户详情。我们可以看到他的所有信息，包括电子邮件地址。
- en: So, by using the `exclude` parameter in the user schema, we can easily exclude
    certain sensitive fields from showing up in the HTTP response. Apart from the
    `exclude` parameter, marshmallow also has the `include` parameter, which you can
    explore more yourself if you are interested.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用用户模式中的 `exclude` 参数，我们可以轻松地排除某些敏感字段在 HTTP 响应中显示。除了 `exclude` 参数之外，marshmallow
    还有一个 `include` 参数，如果你感兴趣，可以自己进一步探索。
- en: RecipeSchema Design
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RecipeSchema 设计
- en: So, we have done the serialization/deserialization for the `User` object. Now
    we are going to design the schema for the `Recipe` object. In the case of the
    `Recipe` update, we will expect the user to fill in updated recipe details on
    a web form, and then send the details in JSON format to the server. Our `Smilecook`
    application will then deserialize it to be a `Recipe` object, which can be worked
    on in our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经对 `User` 对象进行了序列化和反序列化。现在我们将为 `Recipe` 对象设计模式。在 `Recipe` 更新的情况下，我们期望用户在一个网页表单中填写更新的食谱详情，然后将详情以
    JSON 格式发送到服务器。我们的 `Smilecook` 应用程序然后将它反序列化为 `Recipe` 对象，我们可以在应用程序中对其进行操作。
- en: '`RecipeSchema` should inherit `marshmallow.Schema` and contains the following
    attributes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipeSchema` 应该继承 `marshmallow.Schema` 并包含以下属性：'
- en: '`id`: Use `fields.Int()` to represent an integer, and apply `dump_only=True`
    to specify that this property is only available for serialization.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 使用 `fields.Int()` 来表示一个整数，并应用 `dump_only=True` 来指定这个属性仅用于序列化。'
- en: '`name`: Use `fields.String()` to represent a string and apply `required=True`
    to indicate that this attribute is required.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：使用 `fields.String()` 来表示一个字符串，并应用 `required=True` 来指示此属性是必需的。'
- en: '`description`: Use `fields.String()` to represent a string.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：使用 `fields.String()` 来表示一个字符串。'
- en: '`num_of_servings`: Use `fields.Int()` to represent an integer.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_of_servings`：使用 `fields.Int()` 来表示一个整数。'
- en: '`cook_time`: Use `fields.Int()` to represent an integer.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cook_time`：使用 `fields.Int()` 来表示一个整数。'
- en: '`directions`: Use `fields.String()` to represent a string.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directions`：使用 `fields.String()` 来表示一个字符串。'
- en: '`is_publish`: Use `fields.Boolean()` to represent a Boolean, and apply `dump_only=True`
    to specify that this attribute is only available for serialization.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_publish`：使用 `fields.Boolean()` 来表示布尔值，并应用 `dump_only=True` 来指定此属性仅可用于序列化。'
- en: '`author`: This attribute is used to display the author of the recipe.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`：此属性用于显示菜谱的作者。'
- en: '`created_at`: Use `fields.DateTime` to represent the format of the time, and
    `dump_only=True` means that this attribute is only available for serialization.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：使用 `fields.DateTime` 来表示时间的格式，`dump_only=True` 表示此属性仅可用于序列化。'
- en: '`updated_at`: Use `fields.DateTime` to represent the format of the time, and
    `dump_only=True` means that this attribute is only available for serialization.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated_at`：使用 `fields.DateTime` 来表示时间的格式，`dump_only=True` 表示此属性仅可用于序列化。'
- en: 'Exercise 35: Implementing RecipeSchema'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 35：实现 RecipeSchema
- en: 'Now we have the `RecipeSchema` design in mind. In this exercise, we will learn
    more about marshmallow by implementing `RecipeSchema`. Not only can we just validate
    the data type of `fields`, but we can also build our own validation function.
    Let''s get started:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构思了 `RecipeSchema` 的设计。在这个练习中，我们将通过实现 `RecipeSchema` 来学习更多关于 marshmallow
    的知识。我们不仅可以验证 `fields` 的数据类型，还可以构建自己的验证函数。让我们开始吧：
- en: 'First, we import `schema`, `fields`, `post_dump`, `validate`, `validates`,
    and `ValidationError` and create the `recipe schema` by entering the following
    code in `schemas/recipe.py`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 `schema`、`fields`、`post_dump`、`validate`、`validates` 和 `ValidationError`，并在
    `schemas/recipe.py` 文件中输入以下代码来创建 `recipe schema`：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can perform additional validation for a field by passing in the `validate`
    argument. We use `validate.Length(max=100)` to limit the maximum length of this
    attribute to `100`. When it exceeds `100`, it will trigger a validation error.
    This can prevent users from passing in an extremely long string, which will create
    a burden on our database. Using the `validation` function from marshmallow, that
    can be easily prevented.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过传递 `validate` 参数来对字段执行额外的验证。我们使用 `validate.Length(max=100)` 来限制此属性的最大长度为
    `100`。当它超过 `100` 时，将触发验证错误。这可以防止用户传递过长的字符串，从而给我们的数据库带来负担。使用 marshmallow 的 `validation`
    函数可以轻松防止这种情况。
- en: 'Then, we define the `validate_num_of_servings(n)` method in `RecipeSchema`,
    which is a customized validation function. This will validate that this attribute
    has a minimum of `1` and cannot be greater than `50`. If its value doesn''t fall
    within this range, it will raise an error message:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `RecipeSchema` 中定义 `validate_num_of_servings(n)` 方法，这是一个自定义的验证函数。这将验证此属性的最小值为
    `1`，且不能大于 `50`。如果其值不在此范围内，它将引发错误信息：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the `num_of_servings` attribute in `RecipeSchema`. Use `validate=validate_num_of_servings`
    to link to our custom function, which will verify the number of servings of this
    recipe:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `RecipeSchema` 中添加 `num_of_servings` 属性。使用 `validate=validate_num_of_servings`
    来链接到我们的自定义函数，该函数将验证此菜谱的份量数：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is another way for us to add a customized validation method. We can add
    the `cooktime` attribute in `RecipeSchema`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过添加自定义验证方法来添加另一个方法。我们可以在 `RecipeSchema` 中添加 `cooktime` 属性：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in `RecipeSchema`, use the `@validates(''cook_time'')` decorator to define
    the validation method. When validating the `cook_time` property, it will call
    the `validate_cook_time` method to specify that the cooking time should be between
    1 minute and 300 minutes:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `RecipeSchema` 中，使用 `@validates('cook_time')` 装饰器来定义验证方法。当验证 `cook_time`
    属性时，它将调用 `validate_cook_time` 方法来指定烹饪时间应在 1 分钟到 300 分钟之间：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On top of the `schemas/recipe.py` file, import `UserSchema` from marshmallow,
    because we will display the author information for the recipe together when displaying
    the recipe information:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `schemas/recipe.py` 文件之上，导入 `UserSchema` 从 marshmallow，因为我们将在显示菜谱信息时一起显示作者信息：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in `RecipeSchema`, define the attribute `author`. We use `fields.Nested`
    to link this attribute to an external object, which is `UserSchema` in this case:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`RecipeSchema`中定义属性`author`。我们使用`fields.Nested`将此属性链接到外部对象，在这种情况下是`UserSchema`：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To avoid any confusion, this attribute is named `author` in the JSON response,
    but the original attribute name is the `user`. In addition, `dump_only=True` means
    that this attribute is only available for serialization. Finally, add `only=['id',
    ' username']` to specify that we will only show the user's ID and username.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免任何混淆，此属性在JSON响应中命名为`author`，但原始属性名是`user`。此外，`dump_only=True`表示此属性仅可用于序列化。最后，添加`only=['id',
    'username']`以指定我们只显示用户的ID和用户名。
- en: 'In addition, we add the `@post_dump(pass_many=True)` decorator so that further
    processing can be done when the recipe is serialized. The code is as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们添加了`@post_dump(pass_many=True)`装饰器，以便在配方序列化时进行进一步处理。代码如下：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the case of returning only one recipe, it will be simply returned in a JSON
    string. But when we are returning multiple recipes, we will store the recipes
    in a list and return them using the `{''data'': data}` format in JSON. This format
    will be beneficial for us when we develop the pagination feature.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在只返回一个配方的情况下，它将简单地以JSON字符串的形式返回。但是当我们返回多个配方时，我们将配方存储在列表中，并使用JSON中的`{''data'':
    data}`格式返回它们。这种格式将对我们开发分页功能有益。'
- en: 'The code in `schemas/recipe.py` should now look like the following – please
    review it:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`schemas/recipe.py`中的代码现在应该如下所示——请检查它：'
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we have completed the recipe schema, we can start to use it in the related
    resources.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们完成了配方模式，我们就可以开始在相关资源中使用它。
- en: 'We will then modify `resources/recipe.py` as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将修改`resources/recipe.py`如下所示：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first import `RecipeSchema` from `schemas.recipe`,then define the `recipe_schema`
    variable and `recipe_list_schema`; they are for storing single and multiple recipes.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先从`schemas.recipe`导入`RecipeSchema`，然后定义`recipe_schema`变量和`recipe_list_schema`；它们用于存储单个和多个配方。
- en: 'Modify the `RecipeListResource` `get` method to return all the published recipes
    back to the client by using the `recipe_list_schema.dump(recipes).data` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipeListResource`的`get`方法，使用`recipe_list_schema.dump(recipes).data`方法将所有已发布的配方返回给客户端：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `RecipeListResource` `post` method to use the recipe schema:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipeListResource`的`post`方法以使用配方模式：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After receiving the JSON data, the data is verified by `recipe_schema.load(data=json_data)`.
    If there is an error, it will return `Recipe(**data)` will be used to create a
    `recipe` object, then specify it as the currently logged-in user's ID via `recipe.user_id
    = current_user`. The recipe will then be saved to the repository via `recipe.save()`,
    and finally, converted to JSON using `recipe_schema.dump(recipe).data` to the
    client, with a HTTP status code **201 CREATED** message.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接收到JSON数据后，通过`recipe_schema.load(data=json_data)`验证数据。如果有错误，将使用`Recipe(**data)`创建一个`recipe`对象，然后通过`recipe.user_id
    = current_user`将其指定为当前登录用户的ID。然后，通过`recipe.save()`将配方保存到存储库，并最终使用`recipe_schema.dump(recipe).data`将JSON转换为客户端，并带有HTTP状态码**201
    CREATED**消息。
- en: 'Because the rendering of our data has been done through marshmallow, we don''t
    need the `data` method in the recipe, so we can delete the `data` method in `model/recipe.py`.
    That is, delete the following code from the file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的数据渲染是通过棉花糖完成的，因此我们不需要在配方中使用`data`方法，所以我们可以从`model/recipe.py`中删除`data`方法。也就是说，从文件中删除以下代码：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have finished the implementation. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.6: Run the application and then Flask on the localhost'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了实现。右键单击它以运行应用程序。然后Flask将在本地主机（`127.0.0.1`）的端口`5000`上启动并运行：![图5.6：运行应用程序，然后在本地主机上运行Flask
- en: '](img/C15309_05_06.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_06.jpg)'
- en: 'Figure 5.6: Run the application and then Flask on the localhost'
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：运行应用程序，然后在本地主机上运行Flask
- en: So, we have just completed the work on `RecipeSchema`, as well as modifying
    the API endpoints to transmit the object using the serialization/deserialization
    approach. In the next exercise, we will test whether our implementation works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚完成了`RecipeSchema`的工作，以及修改API端点以使用序列化/反序列化方法传输对象。在下一个练习中，我们将测试我们的实现是否有效。
- en: 'Exercise 36: Testing the Recipe API'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：测试配方API
- en: To test whether the serialization/deserialization of the object works, we will
    again need to test it in Postman. This exercise is to test creating and getting
    all our recipe details using Postman.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试对象的序列化/反序列化是否正常工作，我们还需要在Postman中再次进行测试。这个练习是为了测试使用Postman创建和获取所有食谱详情。
- en: First, log in to the account. Our previous token was only valid for 15 minutes.
    If it expires, we need to log in again via `/token` or reacquire the token using
    the **Refresh** Token. Click on the **Collections** tab.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录账户。我们之前的令牌只有效15分钟。如果它过期，我们需要通过`/token`再次登录或使用**Refresh**令牌重新获取令牌。点击**Collections**标签页。
- en: Select the **POST** **Token** request.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**POST Token**请求。
- en: 'Click **Send** to log in. The result is shown in the following screenshot:![Figure
    5.7: Log in to the account and select the POST Token request'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**进行登录。结果如下所示：![图5.7：登录账户并选择POST Token请求
- en: '](img/C15309_05_07.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.9：发布ID为4的食谱](img/C15309_05_07.jpg)'
- en: 'Figure 5.7: Log in to the account and select the POST Token request'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.7：登录账户并选择POST Token请求
- en: You will then see the return response, **HTTP Status is 200 OK**, meaning the
    login was successful, and we will see the access token in the response body. This
    access token will be used in later steps.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到返回的响应，**HTTP状态是200 OK**，表示登录成功，我们将在响应体中看到访问令牌。这个访问令牌将在后续步骤中使用。
- en: Next, we will create a new recipe. Click on the **Collections** tab. Choose
    **POST RecipeList**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的食谱。点击**Collections**标签页。选择**POST RecipeList**。
- en: Select the `Authorization` in the `Bearer {token}` in the `JWT` token we got
    in our previous step.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们上一步获取的JWT令牌中的`Bearer {token}`中选择`Authorization`。
- en: 'Select the **Body** tab. Fill in the recipe details as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**标签页。按照以下内容填写食谱详情：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Click **Send** to create a new recipe. The result is shown in the following
    screenshot:![Figure 5.8: Creating a new recipe'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Send**创建一个新的食谱。结果如下所示：![图5.8：创建一个新的食谱
- en: '](img/C15309_05_08.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.9：发布ID为4的食谱](img/C15309_05_08.jpg)'
- en: 'Figure 5.8: Creating a new recipe'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.8：创建一个新的食谱
- en: You will then see the return response, **HTTP Status is 201 CREATED**, meaning
    the new recipe has been created successfully. In the response body, we can see
    the recipe details. We can also see the author's details shown in a nested format.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到返回的响应，**HTTP状态是201 CREATED**，表示新食谱已成功创建。在响应体中，我们可以看到食谱详情。我们还可以看到以嵌套格式显示的作者详情。
- en: Then, we will publish the recipe with `id = 4`. Click on the `http://localhost:5000/recipes/4/publish`
    in **Enter request URL**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`id = 4`发布食谱。点击**Enter request URL**中的`http://localhost:5000/recipes/4/publish`。
- en: 'Select the `Authorization` in the `Bearer {token}` in the `id = 4`. The result
    is shown in the following screenshot:![Figure 5.9: Publish the recipe with ID
    4'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`id = 4`的`Bearer {token}`中选择`Authorization`。结果如下所示：![图5.9：发布ID为4的食谱
- en: '](img/C15309_05_09.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.9：发布ID为4的食谱](img/C15309_05_09.jpg)'
- en: 'Figure 5.9: Publish the recipe with ID 4'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.9：发布ID为4的食谱
- en: You will then see the return response, HTTP Status is **204 NO CONTENT**, meaning
    it is published successfully. You will see no content in the body.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到返回的响应，HTTP状态是**204 NO CONTENT**，表示已成功发布。你将在正文中看到没有内容。
- en: 'Then, we will get all the recipes back. Select the **GET RecipeList** request.
    Click **Send** to get all the recipes back. The result is shown in the following
    screenshot:![Figure 5.10: Getting all the recipes back by selecting the GET RecipeList
    request'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将获取所有食谱。选择**GET RecipeList**请求。点击**Send**以获取所有食谱。结果如下所示：![图5.10：通过选择GET
    RecipeList请求获取所有食谱
- en: '](img/C15309_05_10.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.7：登录账户并选择POST Token请求](img/C15309_05_10.jpg)'
- en: 'Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request'
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.10：通过选择GET RecipeList请求获取所有食谱
- en: You will then see the return response, HTTP Status is 200 **OK**, meaning we
    have successfully retrieved all the recipe details. In the response body, we can
    see that there is a list of data, which contains all the published recipes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到返回的响应，HTTP状态是**200 OK**，表示我们已成功检索到所有食谱详情。在响应体中，我们可以看到一个数据列表，其中包含所有已发布的食谱。
- en: So, we have successfully implemented and tested the serialization (creating
    the recipe) and deserialization (retrieving the recipe) on the recipe-related
    API endpoints. We are making good progress here!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功实现了对食谱相关API端点的序列化（创建食谱）和反序列化（检索食谱）的测试。我们在这一方面取得了良好的进展！
- en: The PATCH Method
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PATCH方法
- en: We have been using the `PUT` HTTP method all along for data updates. However,
    the actual usage of the `PUT` method is to `PUT /items/1` means to replace everything
    in `/items/1`. If this item already exists, it will be replaced. Otherwise, it
    will create a new item. `PUT` must contain all attribute data for `items/1`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用`PUT`HTTP方法进行数据更新。然而，`PUT`方法的实际用法是`PUT /items/1`意味着替换`/items/1`中的所有内容。如果该项目已存在，它将被替换。否则，它将创建一个新的项目。`PUT`必须包含`items/1`的所有属性数据。
- en: 'This doesn''t seem to work very well in all cases. If you just want to update
    only one of the attributes of `items/1`, you need to retransmit all the attributes
    of `items/1` to the server, which is not efficient at all. So, there is a new
    HTTP method: `PATCH` method was invented to do a partial update. With this method,
    we need to pass in only the attributes that need to be modified to the server.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎在所有情况下都不太有效。如果你只想更新`items/1`的其中一个属性，你需要重新传输`items/1`的所有属性到服务器，这非常低效。因此，有一个新的HTTP方法：`PATCH`方法被发明出来以进行部分更新。使用此方法，我们只需要将需要修改的属性传递到服务器。
- en: 'Exercise 37: Using the PATCH Method to Update the Recipe'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习37：使用PATCH方法更新食谱
- en: 'In this exercise, we will change the recipe update method from `PUT` to `PATCH`.
    We will also use the serialization/deserialization approach to transmit the recipes.
    Finally, we will test our changes in Postman, to make sure things work as expected.
    The aim of this exercise is to reduce the bandwidth and server processing resources
    when we update the recipe data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将将食谱更新方法从`PUT`更改为`PATCH`。我们还将使用序列化/反序列化方法来传输食谱。最后，我们将在Postman中测试我们的更改，以确保一切按预期工作。这个练习的目的是在更新食谱数据时减少带宽和服务器处理资源：
- en: 'Create the `patch` method in `RecipeListResource`. We will first use `request.get_json()`
    to get the JSON recipe details sent by the client, and then use `recipe_schema.load(data=json_data,
    partial=(''name'',))` to validate the data format. We are using `partial=(''name'',)`
    because the original name is a required field in the schema. When the client only
    wants to update a single attribute, using `partial` allows us to specify that
    the `Name` attribute is optional, so no error will occur even though we are not
    passing in this attribute:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecipeListResource`中创建`patch`方法。我们首先使用`request.get_json()`获取客户端发送的JSON食谱详细信息，然后使用`recipe_schema.load(data=json_data,
    partial=('name',))`来验证数据格式。我们使用`partial=('name',)`是因为原始名称是模式中的必填字段。当客户端只想更新单个属性时，使用`partial`允许我们指定`Name`属性是可选的，因此即使我们没有传递此属性也不会发生错误：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, in the same `patch` method, we will check whether there is an error message.
    If any, it will return the **HTTP Status Code 400 Bad Request** error message.
    If the validation passes, then check whether the user has permission to update
    this recipe. If not, **HTTP status code Forbidden 403** will be returned:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在同一个`patch`方法中，我们将检查是否有错误消息。如果有，它将返回**HTTP状态码400错误请求**的错误消息。如果验证通过，然后检查用户是否有权更新此食谱。如果没有，将返回**HTTP状态码禁止403**：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We continue to work on the same `patch` method. `recipe.name = data.get(''name'')
    or recipe.name` means it will try to get the name of the key value of the data.
    If this value exists, it will be used. Otherwise, `recipe.name` will stay the
    same. This is basically how we do the update:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续在同一个`patch`方法上工作。`recipe.name = data.get('name') or recipe.name`意味着它将尝试获取数据的键值名称。如果此值存在，它将被使用。否则，`recipe.name`将保持不变。这基本上是我们如何进行更新的：
- en: '[PRE30]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same `patch` method, we use the `save` method to save everything to
    the database and return the recipe data in JSON format:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`patch`方法中，我们使用`save`方法将所有内容保存到数据库，并以JSON格式返回食谱数据：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we have the new `patch` method ready. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.11: Run the application and then run Flask on the localhost'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了新的`patch`方法。右键单击它以运行应用程序。Flask将在本地主机（`127.0.0.1`）的端口`5000`上启动并运行：![图5.11：运行应用程序然后在本地主机上运行Flask
- en: '](img/C15309_05_06.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_05_06.jpg](img/C15309_05_06.jpg)'
- en: 'Figure 5.11: Run the application and then run Flask on the localhost'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：运行应用程序然后在本地主机上运行Flask
- en: 'Next, we are going to update the recipe with `id = 4`. We will update only
    two fields: `num_of_servings,` and `cook_time`.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`id = 4`更新食谱。我们只更新两个字段：`num_of_servings`和`cook_time`。
- en: Click on the **Collections** tab. Choose the **PUT Recipe** request. Change
    the **HTTP** method from **PUT** to **PATCH**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**收藏夹**选项卡。选择**PUT Recipe**请求。将**HTTP**方法从**PUT**更改为**PATCH**。
- en: Select the `Authorization` in the `Bearer {token}` in the `JWT` token we got
    in our previous exercise.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前练习中获得的 `JWT` 令牌中的 `Bearer {token}` 中选择 `Authorization`。
- en: 'Select the **Body** tab. Type the following in the **Body** field:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Body** 选项卡。在 **Body** 字段中输入以下内容：
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Click **Send** to update the recipe. The result is shown in the following screenshot:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 **发送** 更新食谱。结果如下截图所示：
- en: '![Figure 5.12: Updating the recipe'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.12：更新食谱]'
- en: '](img/C15309_05_12.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C15309_05_12.jpg]'
- en: 'Figure 5.12: Updating the recipe'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.12：更新食谱
- en: You will then see the return response `num_of_servings` and `cook_time` is updated.
    We can also see the `updated_at` timestamp has been automatically updated as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到返回的响应中 `num_of_servings` 和 `cook_time` 已更新。我们还可以看到 `updated_at` 时间戳也已自动更新。
- en: Searching for Authors and Unpublished Recipes
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索作者和未发布的食谱
- en: On the `Smilecook` platform, there will be many different foodies from around
    the world (here, we call them authors) to share their recipes. Among these outstanding
    authors, we will definitely have a favorite author, and we will definitely want
    to learn all of their recipes. Therefore, we have added a new endpoint (or function),
    which is to list the recipes of a specific author. This endpoint not only lists
    all the recipes published by a particular gourmet but can also allow the author
    to search all of their own published/unpublished recipes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Smilecook`平台上，将会有来自世界各地的许多不同的美食爱好者（在这里，我们称他们为作者）分享他们的食谱。在这些杰出的作者中，我们肯定会有一个喜欢的作者，并且我们肯定想学习他们所有的食谱。因此，我们增加了一个新的端点（或功能），即列出特定作者的食谱。这个端点不仅列出了某个美食家发布的所有食谱，还可以允许作者搜索他们所有已发布/未发布的食谱。
- en: Using the webargs Package to Parse the Request Arguments
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `webargs` 包解析请求参数
- en: The request arguments, also known as the query string, are the arguments that
    we can pass in through the URL. For example, in the URL `http://localhost/testing?abc=123`,
    `abc=123` is the request argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请求参数，也称为查询字符串，是我们可以通过URL传递的参数。例如，在URL `http://localhost/testing?abc=123` 中，`abc=123`
    是请求参数。
- en: '`GET http://localhost:5000/user/{username}/recipes`, to get all the published
    recipes from a particular author. For this endpoint, we will pass in the visibility
    request argument. The `visibility` request argument can have a value of `public`,
    `private`, or `all`. The default value is `public`. If it is `private` or `all`,
    the user needs to be authenticated first.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET http://localhost:5000/user/{username}/recipes`，以获取特定作者的已发布食谱。对于这个端点，我们将传递可见性请求参数。`visibility`
    请求参数可以具有 `public`、`private` 或 `all` 的值。默认值是 `public`。如果是 `private` 或 `all`，用户需要先进行认证。'
- en: 'If you want to get only the unpublished recipes, you can add the request argument
    `visibility=private`. So, the URL will look like this: `http://localhost:5000/user/{username}/recipes?visibility=private`.
    The `webargs` package provides functions to parse this `visibility=private` argument
    in the URL, and then our `Smilecook` application will know this request is asking
    for private information in the recipe. Our `Smilecook` application will then determine
    whether the authenticated user is the author. If they are, it will return all
    the unpublished recipes. Otherwise, there is no permission for the user to see
    the unpublished recipes.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想获取未发布的食谱，可以添加请求参数 `visibility=private`。因此，URL 将看起来像这样：`http://localhost:5000/user/{username}/recipes?visibility=private`。`webargs`
    包提供了解析这个 `visibility=private` 参数的函数，然后我们的 `Smilecook` 应用程序将知道这个请求是要求获取食谱的私人信息。然后，我们的
    `Smilecook` 应用程序将确定认证用户是否是作者。如果是，它将返回所有未发布的食谱。否则，用户没有权限查看未发布的食谱。
- en: 'Exercise 38: Implementing Access Control on Recipes'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 38：在食谱上实现访问控制
- en: 'In this exercise, we are going to implement access control on recipes. So,
    only authenticated users will be able to see all of their own recipes, including
    unpublished ones. The user will pass in the `visibility` mode by using the `request`
    argument. We use `webargs` to parse the visibility mode and return published,
    unpublished, or all recipes accordingly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现食谱的访问控制。因此，只有认证用户才能看到他们所有的食谱，包括未发布的食谱。用户将通过使用 `request` 参数传递 `visibility`
    模式。我们使用 `webargs` 解析可见模式，并相应地返回已发布、未发布或所有食谱：
- en: 'Create the `get_all_by_user` method in the `Recipe` class in `models/recipe.py`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `models/recipe.py` 中的 `Recipe` 类中创建 `get_all_by_user` 方法：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method needs to take in `user_id` and `visibility`. If the `visibility`
    is not defined, the default will be `public`. If the `visibility` is `public`,
    it will get all the recipes by `user_id` and `is_publish=True`. If the visibility
    is `private`, it will search for the recipe with `is_publish=False`. If the visibility
    is not `public` or `private`, it will get all the recipes of this user.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法需要接收 `user_id` 和 `visibility`。如果 `visibility` 未定义，则默认为 `public`。如果 `visibility`
    是 `public`，它将根据 `user_id` 和 `is_publish=True` 获取所有食谱。如果 `visibility` 是 `private`，它将搜索
    `is_publish=False` 的食谱。如果 `visibility` 不是 `public` 或 `private`，它将获取此用户的全部食谱。
- en: 'We will install the `webargs` package, which is a package for interpreting
    and verifying HTTP arguments (for example, `visibility`). Please add the following
    package in `requirements.txt`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将安装 `webargs` 包，这是一个用于解释和验证 HTTP 参数（例如，`visibility`）的包。请在 `requirements.txt`
    中添加以下包：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Install the package using the following command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装包：
- en: '[PRE35]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see a result like the following:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下类似的结果：
- en: '[PRE36]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Import the necessary modules, functions, and classes in `resources/user.py`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/user.py` 中导入必要的模块、函数和类：
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, import `webargs.fields` and `webargs.flaskparser.use_kwargs`, then we
    will need to use the recipe data, so we also need to import the recipe model and
    schema.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，导入 `webargs.fields` 和 `webargs.flaskparser.use_kwargs`，然后我们需要使用食谱数据，因此还需要导入食谱模型和模式。
- en: 'Then, we will declare the `recipe_list_schema` variable. Use `RecipeSchema`
    with the `many=True` parameter. This is to show that we will have multiple recipes:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将声明 `recipe_list_schema` 变量。使用 `RecipeSchema` 并带有 `many=True` 参数。这是为了表明我们将有多个食谱：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will then create the `UserRecipeListResource` class. This resource is mainly
    for getting the recipes under a specific user. Please refer to the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建 `UserRecipeListResource` 类。此资源主要用于获取特定用户的食谱。请参考以下代码：
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, define `@jwt_optional` to mean that this endpoint can be accessed without
    a user being logged in. Then, use `@use_kwargs({''visibility'': fields.Str(missing=''public'')})`
    to specify that we expect to receive the parameters of `visibility` here. If the
    parameter is absent, the default will be public. The `visibility` parameter will
    then be passed into `def get(self, username, visibility)`.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '首先，定义 `@jwt_optional` 表示此端点可以在用户未登录的情况下访问。然后，使用 `@use_kwargs({''visibility'':
    fields.Str(missing=''public'')})` 指定我们期望在这里接收 `visibility` 参数。如果参数不存在，默认将是 `public`。然后，`visibility`
    参数将被传递到 `def get(self, username, visibility)`。'
- en: 'We will implement access control in `UserRecipeListResource.get`. If the username
    (the author of the recipe) is the currently authenticated user, then they can
    see all the recipes, including the private ones. Otherwise, they can only see
    the published recipes:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `UserRecipeListResource.get` 中实现访问控制。如果用户名（食谱的作者）是当前认证的用户，则他们可以查看所有食谱，包括私有的。否则，他们只能查看已发布的食谱：
- en: '[PRE40]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The user is then obtained by `User.get_by_username(username=username)`. If the
    user cannot be found, will return a HTTP status code `get_jwt_identity()` and
    save it to the `current_user` variable.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后通过 `User.get_by_username(username=username)` 获取用户。如果用户找不到，将返回 HTTP 状态码 `get_jwt_identity()`
    并将其保存到 `current_user` 变量中。
- en: Based on the user and their permission, we will display a different set of recipes.
    After the recipe is obtained, `recipe_list_schema.dump(recipes).data` is used
    to convert the recipes into JSON format and return to the client with HTTP Status
    Code is **200 OK**.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据用户及其权限，我们将显示不同的食谱集合。在获取食谱后，使用 `recipe_list_schema.dump(recipes).data` 将食谱转换为
    JSON 格式，并带有 HTTP 状态码 **200 OK** 返回给客户端。
- en: 'Then, import `UserRecipeListResource` in `app.py`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `app.py` 中导入 `UserRecipeListResource`：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we add the following endpoint:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下端点：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we have finished the implementation. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.13: Run Flask on the localhost'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了实现。右键单击它以运行应用程序。Flask 将在本地主机 (`127.0.0.1`) 的端口 `5000` 上启动并运行：![图 5.13：在本地主机上运行
    Flask
- en: '](img/C15309_05_13.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_13.jpg)'
- en: 'Figure 5.13: Run Flask on the localhost'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.13：在本地主机上运行 Flask
- en: Now we have learned how to use `webargs` to parse `request` arguments and have
    applied that to our `Smilecook` application. Next, as usual, we want to test and
    make sure that it works.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用 `webargs` 解析 `request` 参数，并将其应用于我们的 `Smilecook` 应用程序。接下来，像往常一样，我们想要测试并确保它正常工作。
- en: 'Exercise 39: Retrieving Recipes from a Specific Author'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 39：从特定作者检索食谱
- en: 'This exercise is to test what we implemented in our last exercise. We will
    make sure the API is parsing the visibility mode that the user passes in and returns
    different sets of recipes accordingly. We will use a specific user (James) for
    testing. We will see that before and after authentication, the user will be able
    to see different sets of recipes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是为了测试我们在上一个练习中实现的内容。我们将确保API能够解析用户传入的可见性模式，并相应地返回不同的食谱集合。我们将使用特定的用户（James）进行测试。我们将看到在认证前后，用户将能够看到不同的食谱集合：
- en: We will get all the published recipes for a particular user before they have
    logged in. First, click on the **Collections** tab.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录之前，我们将获取特定用户的全部已发布食谱。首先，点击**收藏集**标签。
- en: Add a new request under the `UserRecipeList` and save.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserRecipeList`下添加一个新的请求并保存。
- en: Select the newly created `http://localhost:5000/users/james/recipes` in the
    **URL** field (change the username if necessary).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**URL**字段中选择新创建的`http://localhost:5000/users/james/recipes`（如有必要，更改用户名）。
- en: 'Click **Send** to check all the published recipes under this particular user
    (James here). The result is shown in the following screenshot:![Figure 5.14: Get
    all the published recipes for a user before they have logged in'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**以检查特定用户（此处为James）下的所有已发布食谱。结果如下所示：![图5.14：在用户登录之前获取用户的全部已发布食谱
- en: '](img/C15309_05_14.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_14.jpg)'
- en: 'Figure 5.14: Get all the published recipes for a user before they have logged
    in'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.14：在用户登录之前获取用户的全部已发布食谱
- en: You will then see the return response. The HTTP status code **200 OK** here
    indicates that the request has succeeded and, in the body, we can see one published
    recipe under this author.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您将看到返回的响应。这里的HTTP状态码**200 OK**表示请求已成功，在正文中，我们可以看到这位作者下有一个已发布的食谱。
- en: 'Similar to the previous step, we will see whether we can get all the recipes
    under a particular user before the user has logged in – it shouldn''t be allowed.
    Select the `visibility`. Set `all`. Click **Send** to check all the recipes under
    this particular user. The result is shown in the following screenshot:![Figure
    5.15: Check all the recipes under a particular user'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一步类似，我们将查看在用户登录之前是否可以获取特定用户下的所有食谱——这不应该被允许。选择`可见性`。设置为`all`。点击**发送**以检查特定用户下的所有食谱。结果如下所示：![图5.15：检查特定用户下的所有食谱
- en: '](img/C15309_05_15.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_15.jpg)'
- en: 'Figure 5.15: Check all the recipes under a particular user'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.15：检查特定用户下的所有食谱
- en: You will then see the return response. The HTTP status code **200 OK** here
    indicates that the request has succeeded, and in the body again, though we are
    asking for all recipes, we can only see one published recipe under this author
    because the user hasn't logged in.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您将看到返回的响应。这里的HTTP状态码**200 OK**表示请求已成功，在正文中再次显示，尽管我们请求所有食谱，但我们只能看到这位作者下有一个已发布的食谱，因为用户尚未登录。
- en: 'Log in and click on the **Collections** tab. Select the **POST** **Token**
    request. Click **Send** to check all the recipes under this particular user. The
    result is shown in the following screenshot:![Figure 5.16: Select the POST Token
    request and send the request'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录并点击**收藏集**标签。选择**POST** **Token**请求。点击**发送**以检查特定用户下的所有食谱。结果如下所示：![图5.16：选择POST令牌请求并发送请求
- en: '](img/C15309_05_16.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_16.jpg)'
- en: 'Figure 5.16: Select the POST Token request and send the request'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.16：选择POST令牌请求并发送请求
- en: You will then see the return response. The **HTTP status code 200 OK** here
    indicates that the request has succeeded, and in the body, we can get the access
    token and refresh token that we will use in the next step.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，您将看到返回的响应。这里的**HTTP状态码200 OK**表示请求已成功，在正文中，我们可以获取到我们将用于下一步的访问令牌和刷新令牌。
- en: 'Select the `Authorization` in the `Bearer {token}` in the **Value** field,
    where the token is the **JWT** token we got in our previous step. Click **Send**
    to query. The result is shown in the following screenshot:![Figure 5.17: Use the
    JWT token and send to query'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**值**字段中选择`Bearer {token}`中的`Authorization`，其中令牌是我们上一步中获得的**JWT**令牌。点击**发送**进行查询。结果如下所示：![图5.17：使用JWT令牌并发送查询
- en: '](img/C15309_05_17.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_05_17.jpg)'
- en: 'Figure 5.17: Use the JWT token and send to query'
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.17：使用JWT令牌并发送查询
- en: You will then see the return response. The **HTTP status code 200 OK** here
    indicates that the request has succeeded. In the response body, we can get all
    the recipes under this user, including the unpublished ones.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到返回的响应。这里的**HTTP状态码200 OK**表示请求已成功。在响应体中，我们可以获取此用户下的所有食谱，包括未发布的食谱。
- en: This testing exercise concluded what we have learned about the `webargs` package,
    as well as testing the new access control functions we added for viewing recipes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试练习总结了我们对`webargs`包的了解，以及测试了我们为查看食谱添加的新访问控制功能。
- en: 'Activity 8: Serializing the recipe Object Using marshmallow'
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动八：使用Marshmallow序列化食谱对象
- en: In this activity, we want you to work on the serialization of the `RecipeResource.get`
    method. We did serialization for `User` and `RecipeList` in previous exercises.
    Now, it is your turn to work on this last one.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们希望您专注于`RecipeResource.get`方法的序列化。我们之前在练习中已经对`User`和`RecipeList`进行了序列化。现在，轮到您处理这个最后的任务了。
- en: Currently, `RecipeResource.get` is returning the `recipe` object using `recipe.data()`.
    We want you to replace that by serializing the `recipe` object using marshmallow.
    The `recipe` object should be converted into JSON format and return to the frontend
    client-side. To do that, you will modify `recipe_schema` in `resources/recipe.py`.
    You are also required to test your implementation using Postman at the end.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`RecipeResource.get`正在使用`recipe.data()`返回`recipe`对象。我们希望您用Marshmallow序列化`recipe`对象来替换它。`recipe`对象应转换为JSON格式并返回到前端客户端。为此，您需要修改`resources/recipe.py`中的`recipe_schema`。您还必须在最后使用Postman测试您的实现。
- en: 'The following are the steps to perform:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Modify the recipe schema, to include all attributes except for `email`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改食谱模式，包括所有属性，除了`email`。
- en: Modify the `get` method in `RecipeResource` to serialize the `recipe` object
    into JSON format using the recipe schema.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RecipeResource`中的`get`方法修改为使用食谱模式将`recipe`对象序列化为JSON格式。
- en: Run the application so that Flask will start and run on the localhost.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，以便Flask在本地主机上启动和运行。
- en: Test the implementation by getting one specific published recipe in Postman.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Postman获取一个特定的已发布食谱来测试实现。
- en: Note
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for the activity can be found on page 312.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第312页找到。
- en: After this activity, you should have a good understanding of how to use schema
    to serialize objects. We have the flexibility to specify the attributes that need
    to be serialized, and how they are going to be serialized. Attributes that linked
    to another object can be serialized as well. As you can see from this activity,
    the author's information is included in this recipe response.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动之后，您应该对如何使用模式来序列化对象有很好的理解。我们可以灵活地指定需要序列化的属性以及它们的序列化方式。与另一个对象链接的属性也可以进行序列化。正如您从这个活动中可以看到的，作者信息包含在这个食谱响应中。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned a lot of things. The data verification of an
    API through marshmallow is very important. This function should also be constantly
    updated in the production environment to ensure that the information we receive
    is correct.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多。通过Marshmallow进行API数据验证非常重要。这个功能在生产环境中也应该不断更新，以确保我们接收到的信息是正确的。
- en: In this chapter, we started with the verification of registered members and
    then talked about basic verification methods, such as setting mandatory fields,
    performing data type validation, and so on. Apart from data validation, marshmallow
    can be used for data filtering as well. We can use the `exclude` parameter to
    display the user email field. Based on what we learned, we then developed customized
    verifications for our application, such as verifying the length of the recipe
    creation time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先从注册成员的验证开始，然后讨论了基本验证方法，例如设置必填字段、执行数据类型验证等。除了数据验证之外，Marshmallow还可以用于数据过滤。我们可以使用`exclude`参数来显示用户电子邮件字段。基于我们所学的内容，我们随后为我们的应用程序开发了定制的验证，例如验证食谱创建时间的长度。
- en: At the end of this chapter, we added the functionality to get all the recipes
    written by our favorite author. Then, we searched for different publish statuses
    through the `visibility` parameter and applied access control accordingly.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们添加了获取我们最喜欢的作者所写所有食谱的功能。然后，我们通过`visibility`参数搜索不同的发布状态，并相应地应用访问控制。
