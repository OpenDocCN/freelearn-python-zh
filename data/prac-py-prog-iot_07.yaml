- en: Connecting Your Raspberry Pi to the Physical World
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的Raspberry Pi连接到物理世界
- en: In this chapter, we will explore hardware and software concepts related to connecting
    your Raspberry Pi to the physical world. We will be covering popular numbering
    schemes that are used by GPIO libraries to refer to the GPIO header pins on your
    Raspberry Pi and provide an overview of popular GPIO libraries, in addition to
    the GPIOZero and PiGPIO libraries that we used in earlier chapters. As we will
    learn, understanding GPIO numbering schemes is crucial to ensure your understanding
    of how GPIO libraries work with GPIO pins.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与将您的Raspberry Pi连接到物理世界相关的硬件和软件概念。我们将介绍由GPIO库使用的流行编号方案，以引用您的Raspberry
    Pi上的GPIO引脚，并概述流行的GPIO库，除了我们在之前章节中使用的GPIOZero和PiGPIO库。正如我们将会了解的那样，理解GPIO编号方案对于确保您理解GPIO库如何与GPIO引脚一起工作至关重要。
- en: Our journey will also include a conceptual overview and discussion of the many
    different ways in which electronics can be interfaced with our Raspberry Pi before
    we will finish with a detailed exercise and practical demonstration of two important
    electronic concepts—**Pulse-Width Modulation** (**PWM**) and analog-to-digital
    conversion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对Raspberry Pi的许多不同方式进行电子接口的概念概述和讨论之前，我们的旅程还将包括对两个重要的电子概念-**脉宽调制**（**PWM**）和模数转换的详细练习和实际演示。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Understanding Raspberry Pi pin numbering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Raspberry Pi引脚编号
- en: Exploring popular Python GPIO libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索流行的Python GPIO库
- en: Exploring Raspberry Pi electronic interfacing options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Raspberry Pi的电子接口选项
- en: Interfacing with an analog-to-digital converter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模数转换器进行接口
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章的练习，您需要以下物品：
- en: Raspberry Pi 4 Model B
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4 Model B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: A minimum of Python version 3.5
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本是3.5或更高，代码示例应该可以在Raspberry Pi 3 Model B或Raspbian
    OS的不同版本上无需修改即可运行。
- en: You will find this chapter's source code in the `chapter05` folder in the GitHub
    repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的以下URL中的`chapter05`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install Python libraries required for the code in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令来设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项是从`requirements.txt`中安装的：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO:** The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**RPi.GPIO**: The RPi.GPIO library ([https://sourceforge.net/p/raspberry-gpio-python/wiki/Home](https://sourceforge.net/p/raspberry-gpio-python/wiki/Home))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPi.GPIO**：RPi.GPIO库（[https://sourceforge.net/p/raspberry-gpio-python/wiki/Home](https://sourceforge.net/p/raspberry-gpio-python/wiki/Home)）'
- en: '**ADS1X15**: The ADS11x5 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADS1X15**：ADS11x5 ADC库（[https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15)）'
- en: 'Besides the preceding installations, we require a few physical electronic components
    for the exercise in this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述的安装，我们在本章的练习中还需要一些物理电子组件：
- en: 1 x 5 mm red LED
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 5 mm红色LED
- en: 1 x 200 Ω resistor—its color bands will be red, black, brown, and then gold
    or silver
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 200 Ω电阻器-其色带将是红色，黑色，棕色，然后是金色或银色
- en: 1 x ADS1115 ADC break-out module (for example, [https://www.adafruit.com/product/1085](https://www.adafruit.com/product/1085))
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x ADS1115 ADC拆分模块（例如，[https://www.adafruit.com/product/1085](https://www.adafruit.com/product/1085)）
- en: 2 x 10 kΩ potentiometers (any value in the range 10K to 100K will be suitable)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 10 kΩ电位器（范围在10K到100K之间的任何值都适用）
- en: A breadboard
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Male-to-female and male-to-male jumper cables (also called DuPont cables)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母对母和母对公跳线（也称为杜邦线）
- en: Understanding Raspberry Pi pin numbering
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Raspberry Pi引脚编号
- en: You will have noticed by now that your Raspberry Pi has a lot of pins sticking
    out of it! Since [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*, and all subsequent chapters, we have referenced
    these pins by referring to them, for example, as *GPIO Pin 23*, but what does
    this mean? It's time we understand this in more detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到您的Raspberry Pi上有很多引脚突出！自[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)
    *使用Python和物联网入门*以及所有后续章节中，我们已经通过引用它们来引用这些引脚，例如*GPIO引脚23*，但这是什么意思？是时候我们更详细地了解这一点了。
- en: 'There are three common ways in which a Raspberry Pi''s GPIO pins may be referenced,
    as illustrated in *Figure 5.1*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的方式可以引用Raspberry Pi的GPIO引脚，如*图5.1*所示：
- en: '![](assets/012865d7-2318-4b7a-b5af-2f3b06f7e29a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/012865d7-2318-4b7a-b5af-2f3b06f7e29a.png)'
- en: Figure 5.1 – GPIO pin numbering schemes
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - GPIO引脚编号方案
- en: In all of the previous chapters, we've been talking about GPIO pins from the
    perspective of PiGPIO, which uses the **Broadcom** or **BCM**numbering scheme.
    BCM is the most common scheme used in Python-based GPIO libraries, and the GPIO
    libraries that we will discuss shortly all use BCM exclusively or by default.
    However, it is useful to know that other schemes exist because it will help when
    reading or debugging code fragments you come across on the internet and other
    resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的所有章节中，我们一直从PiGPIO的角度讨论GPIO引脚，它使用**Broadcom**或**BCM**编号方案。BCM是Python GPIO库中最常用的方案，我们将很快讨论的GPIO库都专门或默认使用BCM。然而，了解其他方案的存在是有用的，因为它将有助于阅读或调试您在互联网和其他资源上遇到的代码片段。
- en: The terms *GPIO* and pin can be rather loosely used when it comes to identifying
    pins. You need to interpret wording such as *GPIO 23* or *Pin 23* with consideration
    of the context and scheme in which it is being used.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO和引脚这两个术语在识别引脚时可能会被宽泛使用。您需要解释诸如*GPIO 23*或*引脚23*之类的用语，考虑到它所使用的上下文和方案。
- en: 'Let''s explore these alternatives as shown in *Figure 5.1*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些替代方案，如*图5.1*所示：
- en: '**Broadcom/BCM Numbering**: This refers to the GPIO numbering of the Broadcom
    chip in your Raspberry Pi. With BCM numbering, when we say *GPIO 23,* we mean
    *GPIO 23* as labeled in a BCM pin-out diagram. This is the scheme we are using with
    the GPIOZero and PiGPIO examples presented in this book.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Broadcom/BCM编号**：这指的是树莓派中Broadcom芯片的GPIO编号。使用BCM编号时，当我们说*GPIO 23*时，我们指的是在BCM引脚图中标记为*GPIO
    23*。这是我们在本书中使用的方案，用于GPIOZero和PiGPIO示例。'
- en: '**Physical/Board/P1 Header**: In this numbering scheme, the physical pin numbers
    of the P1 header are used, for instance, BCM GPIO 23 = Physical Pin 16.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理/板/P1标头**：在这种编号方案中，使用P1标头的物理引脚编号，例如，BCM GPIO 23 = 物理引脚16。'
- en: '**WiringPi**: This is a popular C GPIO library called WiringPi that introduced
    its own pin mapping scheme. Due to the maturity of WiringPi (there is a Python
    port), you will come across this scheme from time to time—continuing our example,
    BCM GPIO 23 = Physical Pin 16 = WiringPi Pin 4.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WiringPi**：这是一个名为WiringPi的流行的C GPIO库，引入了自己的引脚映射方案。由于WiringPi的成熟度（有一个Python端口），您会不时遇到这个方案——继续我们的例子，BCM
    GPIO 23 = 物理引脚16 = WiringPi引脚4。'
- en: 'There are also other methods and naming used to reference pins and interfaces
    to be aware of, and they include the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他用于引用引脚和接口的方法和命名，需要注意的包括以下内容：
- en: '**Virtual Filesystem**: There is a virtual filesystem mounted at `/sys` for
    general GPIO access,`/dev/*i2c` for I2C, `/dev/*spi*` for SPI, and `/sys/bus/w1/devices/*`
    for 1-wire devices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟文件系统**：在`/sys`上挂载了一个虚拟文件系统，用于一般GPIO访问，`/dev/*i2c`用于I2C，`/dev/*spi*`用于SPI，`/sys/bus/w1/devices/*`用于1-wire设备。'
- en: '**Alternative Pin Functions**: The preceding BCM diagram in *Figure 5.1* lists
    GPIO pin numbers, together with alternative pin functions such as PWM0, I2C0,
    and SPI0 in parentheses. These represent alternative roles a pin can perform beyond
    basic digital I/O.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替代引脚功能**：*图5.1*中的前面的BCM图表列出了GPIO引脚编号，以及括号中的PWM0、I2C0和SPI0等替代引脚功能。这些代表了引脚可以执行的基本数字I/O之外的替代角色。'
- en: '**Bus/Channel Numbers**: For SPI and I2C interfacing and hardware PWM, it''s
    common for a library to use the bus or channel number. For example, we can use
    BCM GPIO 18 as a general-purpose digital input and output, or we can use it in
    its alternate function mode as a hardware PWM output as PWM channel 0.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线/通道编号**：对于SPI和I2C接口以及硬件PWM，库通常会使用总线或通道编号。例如，我们可以使用BCM GPIO 18作为通用数字输入和输出，或者我们可以在其备用功能模式下将其用作PWM通道0的硬件PWM输出。'
- en: The [pinout.xyz](https://pinout.xyz) website is a great resource for exploring
    pin naming, alternative functions, and scheme mappings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[pinout.xyz](https://pinout.xyz)网站是一个探索引脚命名、替代功能和方案映射的好资源。'
- en: You now have an understanding of the different schemes that can be used to refer
    to GPIO pins on a Raspberry Pi. While the BCM scheme tends to be the most common
    and universal amongst Python-based GPIO libraries, it is imperative to never just
    assume that a GPIO library, code example, and even a breadboard layout or schematic
    diagram you are working with uses the BCM scheme to reference GPIO pins. A mismatch
    between the scheme used in code and the scheme used to physically wire electronics
    to the Raspberry Pi's GPIO pins is a common mistake that causes a circuit not
    to work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了在树莓派上引用GPIO引脚可以使用的不同方案。虽然BCM方案往往是基于Python的GPIO库中最常见和通用的方案，但绝对不能假设一个GPIO库、代码示例，甚至是您正在使用的面包板布局或原理图图使用BCM方案来引用GPIO引脚。代码中使用的方案与用于将电子设备连接到树莓派的GPIO引脚的方案之间的不匹配是导致电路无法工作的常见错误。
- en: I often see people (and I've done the same!) blame their wiring or believe an
    electronic component must be faulty when their circuit does not work with a code
    example they found somewhere online. As a first step toward diagnosis, check that
    the pin numbering scheme the code is using matches the scheme you used to wire
    the circuit to the Raspberry Pi's GPIO pins.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到人们（我自己也这样做过！）在他们的电路与他们在网上找到的代码示例不匹配时，责怪他们的接线或认为电子元件必须是有故障的。作为诊断的第一步，请检查代码使用的引脚编号方案是否与您用来连接树莓派的GPIO引脚的方案相匹配。
- en: Now that we understand the use and importance of different GPIO numbering schemes,
    let's move on and review popular Python GPIO libraries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了不同GPIO编号方案的使用和重要性，让我们继续并审查流行的Python GPIO库。
- en: Exploring popular Python GPIO libraries
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索流行的Python GPIO库
- en: If you are anything like me, when you first start with a Raspberry Pi, you probably
    just want to control *things.* Today, for many developers, their first point of
    contact with physical computing using a Raspberry Pi will be via the official
    Raspberry Pi website and with the GPIOZero library. However, after you've been
    tinkering with simple electronics such as buttons, LEDs, and motors for a while,
    you'll want to undertake more complex interfacing. If you've taken this step—or
    are about to—you may find yourself in the somewhat confusing world of GPIO libraries
    and options. This section is here to help you to navigate this path by presenting
    the more popular options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，当你第一次开始使用树莓派时，你可能只是想控制*东西*。如今，对于许多开发人员来说，使用树莓派进行物理计算的第一步将是通过官方树莓派网站和GPIOZero库。然而，当你玩弄按钮、LED和电机等简单电子设备一段时间后，你可能会想要进行更复杂的接口。如果你已经迈出了这一步，或者即将迈出这一步，你可能会发现自己处于GPIO库和选项的令人困惑的世界。本节旨在通过介绍更受欢迎的选项来帮助你在这条道路上导航。
- en: I maintain a summary and comparison table of Python GPIO libraries (including
    additional libraries not listed in the following sections) at [https://10xiot.com/gpio-comp-table](https://10xiot.com/gpio-comp-table).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[https://10xiot.com/gpio-comp-table](https://10xiot.com/gpio-comp-table)上维护了一个Python
    GPIO库的摘要和比较表（包括以下部分未列出的其他库）。
- en: We'll start our GPIO Library overview with GPIOZero.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从GPIOZero开始对GPIO库进行概述。
- en: Reviewing GPIOZero – simple interfacing for beginners
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查GPIOZero-初学者的简单接口
- en: The focus of the GPIOZero library is on simplicity, making it a no-fuss library
    for beginners getting into physical computing and interfacing electronics. It
    achieves ease-of-use by abstracting away the underlying technical complexity and
    allows you to write code that deals with *devices* and *peripherals* such as LEDs,
    buttons, and common sensors, rather than writing lower-level code that directly
    manages pins.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero库的重点是简单性，使其成为初学者进入物理计算和接口电子设备的无忧库。它通过抽象化底层技术复杂性来实现易用性，并允许您编写处理*设备*和*外围设备*（如LED、按钮和常见传感器）的代码，而不是编写直接管理引脚的低级别代码。
- en: Technically, GPIOZero is not actually a full-fledged GPIO library in terms of
    how it interacts with GPIO pin hardware. It is a simplifying wrapper around other
    GPIO libraries that are employed to do the actual GPIO grunt work. In [Chapter
    2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting Started with Python and
    IoT*, we saw a push button and LED example in both GPIOZero and PiGPIO that illustrated
    this point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，GPIOZero实际上并不是一个完整的GPIO库，它是围绕其他用于执行实际GPIO grunt工作的GPIO库的简化包装器。在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中，*使用Python和IoT入门*，我们看到了在GPIOZero和PiGPIO中的一个按钮和LED示例，说明了这一点。
- en: 'Here are the key highlights of GPIOZero in a nutshell:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GPIOZero的主要亮点：
- en: '**Description**: High-level GPIO Library designed for beginners'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：为初学者设计的高级GPIO库'
- en: '**Pros**: Easy to learn and use with excellent documentation and many examples'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：易于学习和使用，具有出色的文档和许多示例'
- en: '**Cons**: Limited in scope for use beyond simple electronic interfacing'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：在简单的电子接口之外的用途上有限'
- en: '**Website**: [https://gpiozero.readthedocs.io](https://gpiozero.readthedocs.io/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：[https://gpiozero.readthedocs.io](https://gpiozero.readthedocs.io/)'
- en: Next, we will review RPi.GPIO, a popular low-level GPIO library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将审查RPi.GPIO，一个流行的低级GPIO库。
- en: Reviewing RPi.GPIO – a low-level GPIO for beginners
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查RPi.GPIO-初学者的低级GPIO
- en: We mentioned previously that the essence of GPIOZero is writing code that deals
    with devices and components. Well, RPi**.**GPIO takes a different and more classical
    approach where we write code that works with and manages GPIO pins directly. RPi.GPIO
    is a popular low-level introduction to Raspberry Pi and electronics, so you will
    find many examples using it across the internet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，GPIOZero的本质是编写处理设备和组件的代码。而RPi.GPIO采用了一种不同且更经典的方法，我们编写的代码直接与GPIO引脚进行交互和管理。RPi.GPIO是树莓派和电子学的流行低级介绍，因此您会发现许多使用它的示例在互联网上。
- en: The GPIOZero documentation has a great section on RPi.GPIO, where it explains
    equivalent code examples in both GPIOZero and RPi.GPIO. This is a great resource
    to start learning lower-level pin level programming concepts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero文档中有一个关于RPi.GPIO的很好的部分，其中它解释了在GPIOZero和RPi.GPIO中等效的代码示例。这是一个很好的资源，可以开始学习更低级别的引脚级编程概念。
- en: There is also a library named RPIO that was created as a performance drop-in replacement
    for RPi.GPIO. RPIO is not currently maintained and does not work with the Raspberry
    Pi Model 3 or 4.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为RPIO的库，它被创建为RPi.GPIO的性能替代品。RPIO目前没有维护，并且不适用于树莓派3或4型号。
- en: 'Here are the key highlights of RPI.GPIO in a nutshell:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是RPI.GPIO的主要亮点：
- en: '**Description:** Lightweight low-level GPIO'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：轻量级低级GPIO'
- en: '**Pros**: Mature library with many code examples to be found on the internet'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：成熟的库，在互联网上可以找到许多代码示例'
- en: '**Cons**: Lightweight means that it is not a performance-orientated library
    and there''s no hardware-assisted PWM'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：轻量级意味着它不是面向性能的库，没有硬件辅助的PWM'
- en: '**Website**: [https://pypi.python.org/pypi/RPi.GPIO](https://pypi.python.org/pypi/RPi.GPIO)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：[https://pypi.python.org/pypi/RPi.GPIO](https://pypi.python.org/pypi/RPi.GPIO)'
- en: Next, we will look at another high-level library designed for controlling complex
    devices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一看另一个用于控制复杂设备的高级库。
- en: Reviewing Circuit Python and Blinka – interfacing for complex devices
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查Circuit Python和Blinka-用于复杂设备的接口
- en: Blinka is a Python compatibility layer for Circuit Python ([circuitpython.org](http://circuitpython.org/)),
    a version of Python designed for microcontrollers. It's created and championed
    by the electronics company Adafruit, which distributes many electronic breakout
    boards and gadgets. Adafruit provides quality high-level Circuit Python drivers
    for many of its product lines, essentially carrying forward the GPIOZero ease-of-use
    idea to more complex devices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Blinka是Circuit Python（[circuitpython.org](http://circuitpython.org/)）的Python兼容层，这是专为微控制器设计的Python版本。它由电子公司Adafruit创建和支持，该公司分发许多电子扩展板和小工具。Adafruit为其许多产品系列提供高质量的Circuit
    Python驱动程序，基本上延续了GPIOZero易用性的理念，适用于更复杂的设备。
- en: We are going to use Blinka and the Circuit Python driver library for an ADS1115
    ADC breakout module later in this chapter to add analog-to-digital capabilities
    to our Raspberry Pi.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将使用Blinka和Circuit Python驱动程序库来为我们的Raspberry Pi添加模拟到数字功能，以使用ADS1115
    ADC扩展模块。
- en: 'Here are the key highlights of Blinka in a nutshell:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Blinka的主要亮点：
- en: '**Summary**: High-level library for controlling complex devices'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要**：用于控制复杂设备的高级库'
- en: '**Pros**: Makes using supported devices extremely easy irrespective of your
    level of experience'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：无论您的经验水平如何，都可以轻松使用支持的设备'
- en: '**Cons**: For basic IO, it uses RPi.GPIO, so it has the same basic limitations'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：对于基本IO，它使用RPi.GPIO，因此具有相同的基本限制'
- en: '**Website**: [https://pypi.org/project/Adafruit-Blinka](https://pypi.org/project/Adafruit-Blinka/)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：[https://pypi.org/project/Adafruit-Blinka](https://pypi.org/project/Adafruit-Blinka/)'
- en: Next, we will cover Pi.GPIO, a powerful low-level GPIO library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍Pi.GPIO，一个功能强大的低级GPIO库。
- en: Reviewing PiGPIO – a low-level GPIO library
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾PiGPIO - 低级GPIO库
- en: PiGPIO is considered one of the most complete GPIO library options for the Raspberry
    Pi in terms of features and performance. Its core is implemented in C, and there
    is an official port available for Python.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能和性能方面，PiGPIO被认为是树莓派最完整的GPIO库选项之一。其核心是用C实现的，并且有一个官方的Python端口可用。
- en: 'Architecturally, PiGPIO is comprised of two parts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，PiGPIO由两部分组成：
- en: The **pigpiod daemon service** provides socket and pipe access to the underlying PiGPIO
    C library.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pigpiod守护程序服务**提供对底层PiGPIO C库的套接字和管道访问。'
- en: The **PiGPIO client libraries** interact with the pigpiod service using sockets
    or pipes. It's this design that makes Remote GPIO features over a network possible
    with PiGPIO.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO客户端库**使用套接字或管道与pigpiod服务进行交互。正是这种设计使得PiGPIO可以通过网络实现远程GPIO功能。'
- en: 'Here are the key highlights of PiGPIO in a nutshell:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PiGPIO的主要亮点：
- en: '**Description**: An advanced low-level GPIO library'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：高级低级GPIO库'
- en: '**Pros**: Number of features available'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：提供了许多功能'
- en: '**Cons**: Additional setup necessary; simple documentation assumes knowledge
    of the underlying concepts'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：需要额外的设置；简单的文档假设了对底层概念的了解'
- en: '**Website (Python Port)**: [http://abyz.me.uk/rpi/pigpio/python.html](http://abyz.me.uk/rpi/pigpio/python.html)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站（Python端口）**：[http://abyz.me.uk/rpi/pigpio/python.html](http://abyz.me.uk/rpi/pigpio/python.html)'
- en: Before we move on to our next library, I want to draw your attention to a feature
    that is unique to this library and is very useful—remote GPIO.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个库之前，我想提醒您一个这个库独有且非常有用的功能 - 远程GPIO。
- en: Exploring remote GPIO with PiGPIO (and GPIOZero)
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PiGPIO（和GPIOZero）探索远程GPIO
- en: Once you have started the pigpiod service on a Raspberry Pi (covered in *[Chapter
    1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml), Setting Up Your Development Environment*),
    there are two ways to make your code remote, and by remote, I mean that your program
    code can be running on any computer (not just a Raspberry Pi) and control a remote
    Raspberry Pi's GPIOs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在树莓派上启动了pigpiod服务（在*[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml) 设置您的开发环境*中介绍），有两种方法可以使您的代码远程运行，通过远程，我的意思是您的程序代码可以在任何计算机上运行（不仅仅是树莓派），并控制远程树莓派的GPIO。
- en: '**Method 1**: This method involves passing the remote Raspberry Pi''s IP or
    host address to the PiGPIO constructor. Using this approach, you can also interface
    with multiple Raspberry Pi GPIOs by just creating additional instances of `pigpio.pi()`.
    For instance, in the following example, any methods called on the `pi` instance
    will be executed on the `192.168.0.4` host that has the pigpiod service running:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法1**：此方法涉及将远程树莓派的IP或主机地址传递给PiGPIO构造函数。使用这种方法，您还可以通过创建额外的`pigpio.pi()`实例来与多个树莓派GPIO进行接口。例如，在以下示例中，对`pi`实例调用的任何方法将在运行pigpiod服务的`192.168.0.4`主机上执行：'
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Method 2**: A second method involves setting an environment variable on the
    computer and running your Python code (your Python code just needs to use the
    default PiGPIO constructor, `pi = pigpio.pi()`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法2**：第二种方法涉及在计算机上设置环境变量并运行您的Python代码（您的Python代码只需要使用默认的PiGPIO构造函数，`pi =
    pigpio.pi()`）：'
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remote GPIO can be a great development aid, but will add latency into your code's
    interaction with GPIO pins as data is transmitted over the network. This means
    it may not be desirable for non-development releases. Button presses, as an example,
    can feel less responsive, and for use cases where fast timing is important, remote
    GPIO may be impractical.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 远程GPIO可以成为一个很好的开发辅助工具，但会增加代码与GPIO引脚交互的延迟，因为数据通过网络传输。这意味着它可能不适用于非开发版本。例如，按钮按下可能感觉不够灵敏，对于需要快速定时的用例，远程GPIO可能不切实际。
- en: You may remember from [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, that GPIOZero can use a PiGPIO *Pin Factory*,
    and when it does, GPIOZero automatically gets remote GPIO capabilities for free!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml) *使用Python和物联网入门*中提到，GPIOZero可以使用PiGPIO
    *引脚工厂*，当这样做时，GPIOZero自动获得免费的远程GPIO功能！
- en: Finally, because it's a unique feature of the PiGPIO library, all of your code
    must use this library if we want remote GPIO features. If you install third-party
    Python libraries to drive an electronic device and it uses (for example) RPi.GPIO,
    this device is not remote GPO-enabled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为这是PiGPIO库的一个独特特性，如果我们想要远程GPIO功能，所有的代码都必须使用这个库。如果你安装第三方Python库来驱动一个电子设备，并且它使用（例如）RPi.GPIO，这个设备就不支持远程GPIO。
- en: Next, we will look at two common lower-level libraries for I2C and SPI communication.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下两个常见的用于I2C和SPI通信的低级库。
- en: Reviewing SPIDev and SMBus – dedicated SPI and I2C libraries
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查SPIDev和SMBus - 专用的SPI和I2C库
- en: When working with I2C and SPI-enabled devices, you will encounter the SPIDev
    and SMBus libraries (or comparable alternatives). SPIDev is a popular lower-level
    Python library for use with SPI communications, while SMBus2 is a popular lower-level
    Python library for use with I2C and SMBus communication. These two libraries are
    not general-purpose libraries—they cannot be used for basic digital I/O pin control.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用I2C和SPI设备时，你将会遇到SPIDev和SMBus库（或类似的替代品）。SPIDev是一个用于SPI通信的流行的低级Python库，而SMBus2是一个用于I2C和SMBus通信的流行的低级Python库。这两个库不是通用库，不能用于基本的数字IO引脚控制。
- en: When starting out, it is unlikely that you will want or need to use I2C or SPI
    libraries such as these directly. Instead, you will use higher-level Python libraries
    to work with an SPI- or I2C-enabled device that, underneath, would be using lower-level
    libraries like these to communicate with the physical device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始时，你不太可能直接使用这些I2C或SPI库。相反，你将使用更高级的Python库来处理SPI或I2C设备，而这些库在底层会使用这些低级库来与物理设备进行通信。
- en: 'Here are the key highlights of SPIDev and SMBus2 in a nutshell:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SPIDev和SMBus2的主要亮点：
- en: '**Description**: These are lower-level libraries for SPI and I2C interfacing.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：这些是用于SPI和I2C接口的低级库。'
- en: '**Pros**: Using a lower-level library gives you full control over an SPI or
    I2C device. Many high-level convenience wrappers only expose the most commonly
    needed features.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：使用低级库可以完全控制SPI或I2C设备。许多高级便利包只暴露最常用的功能。'
- en: '**Cons**: Leveraging these lower-level libraries requires you to interpret
    and understand how to interface with electronics using low-level data protocols
    and bit manipulation techniques.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：利用这些低级库需要你解释和理解如何使用低级数据协议和位操作技术与电子设备进行接口。'
- en: '**SPIDev website**: [https://pypi.org/project/spidev](https://pypi.org/project/spidev/)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SPIDev网站**：[https://pypi.org/project/spidev](https://pypi.org/project/spidev/)'
- en: '**SMBus2 website**: [https://pypi.org/project/smbus2](https://pypi.org/project/smbus2/)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMBus2网站**：[https://pypi.org/project/smbus2](https://pypi.org/project/smbus2/)'
- en: To complete this section on GPIO libraries, let me briefly discuss why this
    book is primarily based around the PiGPIO library.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成关于GPIO库的部分，让我简要讨论一下为什么这本书主要基于PiGPIO库。
- en: Why PiGPIO?
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么PiGPIO？
- en: You may have wondered why, of all of the options, I chose to use PiGPIO predominantly
    in this book. As a reader of this book, I'm assuming you have a good grounding
    in programming and technical concepts, and that working with and learning a library
    such as PiGPIO is not beyond your capabilities. PiGPIO is a comprehensive library
    if you are intending to extend your learning beyond the basics offered by libraries
    such as GPIOZero and RPi.GPIO and build more complex IoT projects in Python.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么在所有的选择中，我选择在这本书中主要使用PiGPIO。作为这本书的读者，我假设你在编程和技术概念方面有很好的基础，并且使用和学习PiGPIO这样的库不会超出你的能力范围。如果你打算在Python中构建更复杂的物联网项目，并超越GPIOZero和RPi.GPIO提供的基础知识，PiGPIO是一个全面的库。
- en: You will find the PiGPIO API and documentation is broken down into beginner,
    intermediate, and advanced sections, so in practice and while learning, you can
    mix and match how you use the library API depending on your experience level and
    needs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现PiGPIO的API和文档被分为初学者、中级和高级部分，因此在实践和学习过程中，你可以根据自己的经验水平和需求混合使用库的API。
- en: We have now completed our exploration of several popular GPIO libraries and
    reviewed their basic architecture and design. Next, we will turn our attention
    to alternative methods through which we can connect and control electronics with
    our Raspberry Pi.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对几种流行的GPIO库的探索，并审查了它们的基本架构和设计。接下来，我们将把注意力转向通过其他方法连接和控制树莓派上的电子设备。
- en: Exploring Raspberry Pi electronic interfacing options
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索树莓派的电子接口选项
- en: We've just covered the software side of GPIO, so now we will turn our attention
    to the electronics side. The Raspberry Pi provides many standard ways to interface
    both simple and complex electronics. Often, your choice of electronic components
    and modules will dictate which interfacing technique you need to use, while sometimes
    you may get a choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚涵盖了GPIO的软件部分，现在我们将把注意力转向电子方面。树莓派提供了许多标准的接口方式，可以连接简单和复杂的电子设备。通常，你的电子元件和模块的选择将决定你需要使用哪种接口技术，有时你可能会有选择的余地。
- en: Irrespective of whether you have a choice, your knowledge of the different options
    will help you to understand the how and why behind a circuit and its accompanying
    code and help you to diagnose and resolve any issues you may encounter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否有选择，你对不同选项的了解将帮助你理解电路及其相应代码背后的原因，并帮助你诊断和解决可能遇到的任何问题。
- en: In the following section, we will explore the concepts, followed by a practical
    exercise. We'll start with digital IO.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探索概念，然后进行实际练习。我们将从数字IO开始。
- en: Understanding digital IO
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数字IO
- en: 'Each of the Raspberry Pi GPIO pins can perform digital input and output. Digital
    simply means something is either fully on or fully off—there is no middle ground.
    We''ve been working with simple digital IO in previous chapters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的每个GPIO引脚都可以执行数字输入和输出。数字简单地意味着某物要么完全开启，要么完全关闭——没有中间状态。在之前的章节中，我们一直在处理简单的数字IO：
- en: Our LED was either on or off.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的LED要么是开启的，要么是关闭的。
- en: Our button was either pressed (on) or non-pressed (off).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的按钮要么被按下（开启），要么未被按下（关闭）。
- en: 'You will come across several interchangeable terms used to describe digital
    states, including the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您将遇到几个可互换使用的术语来描述数字状态，包括以下内容：
- en: On = High = True = 1
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开 = 高 = 真 = 1
- en: Off = Low = False = 0
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭 = 低 = 假 = 0
- en: Digital IO is a form of basic IO. Analog IO is another, so we will explore it
    next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数字IO是一种基本IO形式。模拟IO是另一种，因此我们将在下面探讨它。
- en: Understanding analog IO
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模拟IO
- en: Whereas digital deals with fully on and off states, analog deals with degrees—on,
    off, or somewhere in-between. Think of a window in your house. In a digital world,
    it could be fully open (digital high) or fully closed (digital low); however,
    in reality, it's analog in that we can open it somewhere between fully closed
    and fully open, for example, a quarter open.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 而数字处理完全开启和关闭状态，模拟处理程度——开启、关闭或介于两者之间。想象一下你家里的窗户。在数字世界中，它可以完全打开（数字高）或完全关闭（数字低）；然而，在现实中，它是模拟的，我们可以将其打开到完全关闭和完全打开之间的某个位置，例如，打开四分之一。
- en: 'Simple and common examples of analog electronic components include the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟电子元件的简单和常见示例包括以下内容：
- en: '**Potentiometers (also known as pots)**: This is a dial or slider that produces
    a range of resistance values. Real-world examples include volume controls and
    header thermostat controls.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电位器（也称为旋钮）**：这是一个产生一系列电阻值的旋钮或滑块。现实世界的例子包括音量控制和加热器恒温控制。'
- en: '**Light-Dependent-Resistors (LDRs)**: These are electronic components to measure
    light levels, and you find these in automatic night lights.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光敏电阻（LDR）**：这些是用于测量光照水平的电子元件，您会在自动夜灯中找到它们。'
- en: '**Thermistors**: These are electronic components for measuring temperature
    that you might find in heaters, fridges, or anywhere where temperature is measured.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热敏电阻**：这些是用于测量温度的电子元件，您可能会在加热器、冰箱或任何需要测量温度的地方找到它们。'
- en: The Raspberry Pi does not come with analog IO capabilities, so we need to use
    external electronics known as an **Analog-to-Digital-Converter** (**ADC**) to
    read analog input, and this will be a core focus of a practical example later
    in this chapter in the section entitled *Interfacing with an analog-to-digital
    converter*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派没有模拟IO功能，因此我们需要使用外部电子设备，称为**模数转换器**（**ADC**）来读取模拟输入，这将是本章后面一个实际示例的核心重点，标题为*与模数转换器进行接口*。
- en: To output an analog signal, we have two options—either use a **Digital-to-Analog
    Converter** (**DAC**) or use a digital technique known as PWM to produce an analog-style
    signal from a digital output. We will not be covering DACs in this book; however,
    we will be exploring PWM in depth, which we will do next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出模拟信号，我们有两个选择——要么使用**数模转换器**（**DAC**），要么使用称为PWM的数字技术从数字输出产生类似模拟的信号。我们不会在本书中涵盖DAC，但是我们将深入探讨PWM，接下来我们将进行。
- en: Understanding **Pulse-Width Modulation**
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解**脉宽调制**
- en: '**Pulse-Width Modulation** or **PWM** is a technique to produce an average
    voltage on a pin somewhere between fully on (high) and fully off (low) by rapidly
    pulsing the pin on and off. In this way, it''s a little like providing a pseudo-analog
    output from a digital pin and is used for all sorts of control applications, such
    as altering the brightness of LEDs, motor speed control, and servo angle control.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉宽调制**或**PWM**是一种通过快速脉冲引脚的开和关来产生介于完全开启（高电平）和完全关闭（低电平）之间的平均电压的技术。通过这种方式，它有点像从数字引脚提供伪模拟输出，并且用于各种控制应用，例如改变LED的亮度、电机速度控制和舵机角度控制。'
- en: 'PWM is defined by two main characteristics:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: PWM由两个主要特征定义：
- en: '**Duty cycle**: The percentage of time the pin is high'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**占空比**：引脚高电平的时间百分比'
- en: '**Frequency**: The time period during which the duty cycle repeats'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：占空比重复的时间周期'
- en: 'As illustrated in *Figure 5.2 *(and for a set frequency), a 50% duty cycle
    means the pin is high half of the time and low half of the time, while a 25% duty
    cycle means the pin is high only 25% of the time. And while not pictured, a 0%
    duty cycle would mean the pin is high 0% of the time (always low), so it''s effectively
    off, while a 100% duty cycle is always high:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.2*所示（对于固定频率），50%的占空比意味着引脚高电平占一半时间，低电平占一半时间，而25%的占空比意味着引脚只有25%的时间是高电平。虽然没有画出来，0%的占空比意味着引脚高电平占0%的时间（始终低电平），因此实际上是关闭的，而100%的占空比则始终是高电平：
- en: '![](assets/ab7ce801-b7f3-4099-b5e8-8c760b93da32.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab7ce801-b7f3-4099-b5e8-8c760b93da32.png)'
- en: Figure 5.2 – PWM duty cyclesThe preceding diagram is taken from [https://en.wikipedia.org/wiki/File:Duty_Cycle_Examples.png](https://en.wikipedia.org/wiki/File:Duty_Cycle_Examples.png),
    author, Thewrightstuff. It falls under CC BY-SA 4.0: [https://creativecommons.org/licenses/by-sa/4.0/deed.en](https://creativecommons.org/licenses/by-sa/4.0/deed.en).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - PWM占空比上述图表摘自[https://en.wikipedia.org/wiki/File:Duty_Cycle_Examples.png](https://en.wikipedia.org/wiki/File:Duty_Cycle_Examples.png)，作者为Thewrightstuff。它属于CC
    BY-SA 4.0：[https://creativecommons.org/licenses/by-sa/4.0/deed.en](https://creativecommons.org/licenses/by-sa/4.0/deed.en)。
- en: Using PWM is easy on the Raspberry Pi, although there are alternative approaches
    for creating the PWM signal, which we will look at next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上使用PWM很容易，尽管有其他方法可以创建PWM信号，我们将在下面看到。
- en: Creating PWM signals
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建PWM信号
- en: 'Different GPIO libraries approach PWM signal generation in different ways.
    Three common techniques are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的GPIO库以不同的方式生成PWM信号。三种常见的技术如下：
- en: '**Software PWM**: The frequency and duty cycle timing of a PWM signal are produced
    in code and can be made available on any GPIO pin. This is the least accurate
    method of creating PWM signals because the timing can be adversely affected by
    a busy Raspberry Pi CPU.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件PWM**：PWM信号的频率和占空比定时由代码生成，并且可以在任何GPIO引脚上使用。这是创建PWM信号的最不准确的方法，因为定时可能会受到繁忙的树莓派CPU的不利影响。'
- en: '**Hardware-timed PWM**: The PWM timing is performed using DMA and PWM/PCM hardware
    peripherals. It''s highly accurate and is available on any GPIO pin.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件定时PWM**：使用DMA和PWM/PCM硬件外设进行PWM定时。它非常精确，并且适用于任何GPIO引脚。'
- en: '**Hardware PWM**: Hardware PWM is provided entirely via hardware and is the
    most accurate method of creating PWM signals. The Raspberry Pi has two dedicated
    hardware PWM channels, labeled PWM0 via GPIO pins 18 and 12 and PWM1 via GPIO
    pins 13 and 19 (refer to *Figure 5.1*).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件PWM**：硬件PWM完全通过硬件提供，并且是创建PWM信号的最准确的方法。树莓派有两个专用的硬件PWM通道，通过GPIO引脚18和12标记为PWM0，通过GPIO引脚13和19标记为PWM1（参见*图5.1*）。'
- en: It's not enough to just connect something to GPIOs 12, 13, 18, or 19 in order
    to get hardware PWM. These GPIOs are the BCM GPIOs that have PWM listed as their *alternative* functions.
    If you want to use hardware PWM, then two basic requirements must be met. Firstly,
    the GPIO library you are using must provide support for hardware PWM. Secondly,
    you must use the library and its hardware PWM functionality correctly, which would
    be detained in the library API documentation. Pins that share a common hardware
    PWM channel both get the same duty cycle and frequency applied to them, so while
    there are four hardware PWM pins, there are only two unique PWM signals.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅连接到GPIO 12、13、18或19并不能获得硬件PWM。这些GPIO是BCM GPIO，其*替代*功能列出了PWM。如果要使用硬件PWM，必须满足两个基本要求。首先，您使用的GPIO库必须支持硬件PWM。其次，您必须正确使用库及其硬件PWM功能，这将在库的API文档中详细说明。共享相同硬件PWM通道的引脚将获得相同的占空比和频率，因此虽然有四个硬件PWM引脚，但只有两个唯一的PWM信号。
- en: Which PWM technique to use will always depend on what you are trying to build
    and how accurate the PWM signal needs to be. Sometimes, you will have direct control
    over which GPIO library (and hence PWM technique) you use for your projects, while
    other times—especially when using third-party higher-level Python libraries—you'll
    be forced to use whatever PWM techniques the library developer used.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用哪种PWM技术将始终取决于您要构建的内容以及PWM信号需要多精确。有时，您将直接控制您的项目使用的GPIO库（因此PWM技术），而其他时候——特别是在使用第三方更高级的Python库时——您将被迫使用库开发人员使用的任何PWM技术。
- en: As a general rule, when I am in control of the GPIO library choice, I avoid
    software PWM wherever possible. If I'm developing using PiGPIO, then I favor hardware-timed
    PWM simply because I can use it on any GPIO pin.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，当我控制GPIO库选择时，尽可能避免使用软件PWM。如果我使用PiGPIO进行开发，那么我更倾向于使用硬件定时PWM，因为我可以在任何GPIO引脚上使用它。
- en: 'In relation to the GPIO libraries that we covered earlier, their support for
    PWM is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前介绍的GPIO库，它们对PWM的支持如下：
- en: '**GPIOZero**: Inherits the PWM method available from its Pin Factory implementation'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：继承自其引脚工厂实现的PWM方法'
- en: '**RPi.GPIO**: Software PWM only'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPi.GPIO**：仅支持软件PWM'
- en: '**PiGPIO**: Hardware-timed PWM and hardware PWM'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：硬件定时PWM和硬件PWM'
- en: '**Blinka**: Hardware PWM only'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blinka**：仅支持硬件PWM'
- en: You can attach external hardware PWM modules to your Raspberry Pi (usually by
    I2C) that will give you more hardware PWM outputs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以连接外部硬件PWM模块到您的树莓派（通常通过I2C），这将给您更多的硬件PWM输出。
- en: Now that we've seen three ways that PWM signals can be created, we will look next at
    SPI, I2C, and 1-wire interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了PWM信号可以被创建的三种方式，接下来我们将看SPI、I2C和1-wire接口。
- en: Understanding SPI, I2C, and 1-wire interfaces
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SPI、I2C和1-wire接口
- en: '**Serial Peripheral Interface Circuit** (**SPI**), **Inter-Integrated Circuit**
    (**I2C**), and 1-wire are standardized communication interfaces and protocols
    that allow non-trivial electronics to communicate with each other. These protocols
    can be employed either directly at a low level through a bit of manipulation and
    math, or indirectly by using higher-level party Python driver modules to work
    with electronic peripherals, with the latter being more common for general use
    cases.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行外围接口电路**（**SPI**）、**I2C**和1-wire是标准化的通信接口和协议，允许非平凡的电子设备进行通信。这些协议可以直接通过一些操作和数学运算来使用，也可以通过使用更高级的Python驱动程序模块间接地与电子外围设备一起工作，后者对于一般用途更为常见。'
- en: 'Examples of devices that work through these protocols include the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些协议工作的设备的示例包括以下内容：
- en: Analog-to-digital converters (SPI or I2C)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模数转换器（SPI或I2C）
- en: LED lighting strips and LCD displays (SPI or I2C)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED灯带和LCD显示器（SPI或I2C）
- en: Environmental sensors such as temperature sensors (1-wire)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境传感器，如温度传感器（1-wire）
- en: We will explore I2C in more detail later in this chapter when we connect an
    analog-to-digital converter to our Raspberry Pi.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后我们将更详细地探讨I2C，当我们连接模数转换器到树莓派时。
- en: Finally, we have serial communication and UART.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有串行通信和UART。
- en: Understanding the serial / UART protocol
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解串行/UART协议
- en: '**Universal Asynchronous Receiver/Transmitter** (**UART**) is a serial communication
    protocol that has been around for a very long time and in common use before the prevalence
    of USB. UART actually refers to the electronic hardware used to implement the
    serial protocol, although it can be implemented in pure software.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用异步收发器**（**UART**）是一种已经存在很长时间并且在USB普及之前广泛使用的串行通信协议。UART实际上是指用于实现串行协议的电子硬件，尽管它也可以在纯软件中实现。'
- en: Today, SPI or I2C tend to be used in preference to UART. GPS receivers are a
    common example where serial communication still prevails. If you have ever connected
    an Arduino to a PC for flashing or debugging, it's a serial communication protocol
    that the devices are using, with UART hardware being present in the Arduino.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，SPI或I2C往往优先于UART。GPS接收器是串行通信仍然普遍存在的一个常见例子。如果您曾经将Arduino连接到PC进行烧录或调试，那么设备使用的是串行通信协议，Arduino中存在UART硬件。
- en: We have now learned many of the standard ways that we can use to interface electronics
    with our Raspberry Pi, including analog and digital electronics, PWM, wire protocols
    such as I2C and SPI, and serial communication. We will start to see many of these
    interfacing options in practice and get a feel for what type of electronics use
    which type of interface as we proceed through this book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了许多标准的方法，可以用来将电子设备与树莓派进行接口连接，包括模拟和数字电子、PWM、I2C和SPI等线路协议以及串行通信。随着我们在本书中的继续，我们将开始看到许多这些接口选项的实际应用，并了解哪种类型的接口适用于哪种类型的电子设备。
- en: Next, we will see some of the concepts we have covered so far in this chapter
    by adding an analog-to-digital converter to our Raspberry Pi.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过向树莓派添加模数转换器来看一下本章我们已经涵盖的一些概念。
- en: Interfacing with an analog-to-digital converter
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模数转换器进行接口连接
- en: Congratulations on getting this far. I suspect you're itching to get into some
    code after all that reading!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您走到了这一步。我猜想您在阅读了这么多之后迫不及待地想要开始编写一些代码了！
- en: 'We will change pace now and apply some of the knowledge we just covered to
    add an ADS1115 analog-to-digital converter to your Raspberry Pi. An example of
    a typical ADS1115 breakout module is pictured in *Figure 5.3*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将改变步调，并应用我们刚刚学到的知识，向您的树莓派添加一个ADS1115模数转换器。一个典型的ADS1115分立模块的示例如下图所示：
- en: '![](assets/20b42eaa-eff1-41af-88a7-f50d944fa1a6.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20b42eaa-eff1-41af-88a7-f50d944fa1a6.png)'
- en: Figure 5.3 – ADS1115 breakout module
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - ADS1115分立模块
- en: An ADC is a very handy addition because this alone opens you up to the world
    of analog components and gadgets that are otherwise not usable with the Raspberry
    Pi.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ADC是一个非常方便的附加功能，因为这样就可以让您接触到模拟元件和设备的世界，否则这些设备是无法与树莓派一起使用的。
- en: As part of this practical exercise, we are going to connect two potentiometers
    (also known as pots) to the ADS1115 and read in their values in Python. We will
    use these values to create a PWM signal by varying its duty cycle and frequency.
    We'll see the effects of varying these parameters by observing how it affects
    the LED and how the waveform changes in a program called PiScope, which is a part
    of the PiGPIO family of utilities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个实际练习的一部分，我们将连接两个电位器（也称为电位器）到ADS1115，并在Python中读取它们的值。我们将使用这些值来通过改变其占空比和频率来创建PWM信号。我们将通过观察它如何影响LED以及波形在一个名为PiScope的程序中如何变化来看到改变这些参数的效果，这是PiGPIO系列实用程序的一部分。
- en: We'll revisit potentiometers in more detail in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml) *软件工程师的电子学101*中更详细地讨论电位器。
- en: To perform the following exercise, remember we need the electronic components
    listed in the *Technical requirements* section at the start of this chapter, including
    an ADS1115 breakout module. The ADS1115 is a common and powerful analog-to-digital
    converter that connects to its master (in our case, a Raspberry Pi) using I2C.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行以下练习，请记住我们需要本章开头列出的电子元件，包括ADS1115分立模块。ADS1115是一种常见且功能强大的模数转换器，它使用I2C连接到其主设备（在我们的案例中是树莓派）。
- en: 'Here are the core specifications of the ADS1115 pulled from its datasheet that
    we require for our exercise:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们从其数据表中提取的ADS1115的核心规格，这些规格是我们练习所需的：
- en: '**Working voltage**: 2 to 5 volts (so we know it will work with the Raspberry
    Pi''s 3.3-volt logic)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作电压**：2至5伏特（所以我们知道它将与树莓派的3.3伏逻辑兼容）'
- en: '**Interface**: I2C'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：I2C'
- en: '**Default I2C address**: 0x48'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认I2C地址**：0x48'
- en: 'The terminals on the ADS1115 are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ADS1115上的端子如下：
- en: '**Vcc & GND**: Power for the device.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vcc & GND**：设备的电源。'
- en: '**SCL**: Clock signal, used to synchronize communication between the master
    and slave.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL**：时钟信号，用于同步主从之间的通信。'
- en: '**SDA**: Data signal, used to send data between the Raspberry Pi and the ADS1115.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**：数据信号，用于在树莓派和ADS1115之间发送数据。'
- en: '**ADDR**: This terminal can be used to change the default address if required.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADDR**：如果需要，此端子可用于更改默认地址。'
- en: '**ALTR**: Alert signal for advanced usage (we won''t be needing this).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALTR**：高级用途的警报信号（我们不需要这个）。'
- en: '**A0** - **A3**: Analog input channels (we will connect Pots to A0 and A1).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A0** - **A3**：模拟输入通道（我们将把电位器连接到A0和A1）。'
- en: Make sure you have the I2C interface enabled on your Raspberry Pi before proceeding.
    We covered the steps to enable interfaces, including I2C, in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml),
    *Setting Up Your Development Environment.*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您的树莓派上已启用I2C接口。我们在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)
    *设置您的开发环境*中介绍了启用接口（包括I2C）的步骤。
- en: First, let's start by building the circuit we require on our breadboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从在面包板上构建我们需要的电路开始。
- en: Building the ADS1115 ADC circuit
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建ADS1115 ADC电路
- en: 'Let''s build our breadboard circuit for this chapter''s exercise. We will build
    our circuits in a series of steps, starting with placing the core components as
    illustrated in the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为本章的练习建立我们的面包板电路。我们将分步构建我们的电路，首先放置核心元件，如下图所示：
- en: '![](assets/815f2ede-d682-4275-8433-f9546e74b8f7.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/815f2ede-d682-4275-8433-f9546e74b8f7.png)'
- en: Figure 5.4 – Breadboard ADC circuit (part 1 of 3)The overall arrangement and
    placement of discrete components and wires on a breadboard are not overly important.
    However, the connections created between the components and wires are vitally
    important! If you need a refresher on breadboards, how they work, and, most importantly,
    how the holes are electrically connected, please refer back to [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 面包板ADC电路（3部分之一）面包板上离散元件和导线的整体布置和放置并不是特别重要。然而，元件和导线之间创建的连接非常重要！如果您需要关于面包板、它们的工作原理以及最重要的是孔如何电气连接的复习，请参阅[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)
    *Python和物联网入门*。
- en: 'Here is how to lay out the component on your breadboard. The following step
    numbers match the numbered black circles in *Figure 5.4*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在面包板上布置组件的方法。以下步骤编号与*图5.4*中编号的黑色圆圈相匹配：
- en: Position the ADS1115 on your breadboard.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115放在面包板上。
- en: Position potentiometer VR1 on your breadboard. The illustrated potentiometers
    are full-size potentiometers. If you have a different size, their leg configuration
    may span fewer breadboard holes.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR1放在面包板上。所示的电位器是全尺寸电位器。如果您有不同尺寸的电位器，它们的引脚配置可能跨越较少的面包板孔。
- en: Position the potentiometer VR2 on your breadboard.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR2放在面包板上。
- en: Position the resistor on your breadboard.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电阻放在面包板上。
- en: Position the LED on your breadboard, paying attention to ensure that its cathode leg
    shares the same row as the resistor (illustrated at holes D29 and E29).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED放在面包板上，注意确保其阴极腿与电阻共享同一行（在D29和E29孔上说明）。
- en: 'Next, we wire up the ADS1115 as illustrated here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式连接ADS1115：
- en: '![](assets/a18ec6ce-48fb-4da8-b93e-af0d064f7f56.png)Figure 5.5 – Breadboard
    ADC circuit (part 2 of 3)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a18ec6ce-48fb-4da8-b93e-af0d064f7f56.png)图5.5 - 面包板ADC电路（第2部分）'
- en: 'Here are the steps to follow. This time, the following step numbers match the
    numbered black circles in *Figure 5.5*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤。这次，以下步骤编号与*图5.5*中编号的黑色圆圈相匹配：
- en: Connect the Raspberry Pi +3.3 volt pin to the breadboard positive power rail.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的+3.3伏引脚连接到面包板的正电源轨。
- en: Connect the VDD terminal on the ADS1115 to the breadboard positive power rail.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115上的VDD端子连接到面包板的正电源轨。
- en: Connect the GND terminal on the ADS1115 to the breadboard negative power rail.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115上的GND端子连接到面包板的负电源轨。
- en: Connect the Raspberry Pi GND pin to the breadboard negative power rail.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GND引脚连接到面包板的负电源轨。
- en: Connect the SCL pin on your Raspberry Pi to the SCL terminal on the ADS1115.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的SCL引脚连接到ADS1115上的SCL端子。
- en: Connect the SDA pin on your Raspberry Pi to the SDA terminal on the ADS1115.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的SDA引脚连接到ADS1115上的SDA端子。
- en: 'Finally, we wire up the LED, resistor, and potentiometers, as illustrated in
    the following diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将LED、电阻和电位器连接起来，如下图所示：
- en: '![](assets/0bfe52c2-e0ed-4643-b94a-e9b175cc0a46.png)Figure 5.6 – Breadboard
    ADC circuit (part 3 of 3)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bfe52c2-e0ed-4643-b94a-e9b175cc0a46.png)图5.6 - 面包板ADC电路（第3部分） '
- en: 'Here are the steps to follow. This time, the following step numbers match the
    numbered black circles in *Figure 5.6*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤。这次，以下步骤编号与*图5.6*中编号的黑色圆圈相匹配：
- en: Connect the A0 terminal on the ADS1115 to the center leg of potentiometer VR1.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115上的A0端子连接到电位器VR1的中间腿。
- en: Connect the A1 terminal on the ADS1115 to the center leg of potentiometer VR2.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115上的A1端子连接到电位器VR2的中间腿。
- en: Connect the upper leg of potentiometer VR1 to the breadboard negative power
    rail.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR1的上腿连接到面包板的负电源轨。
- en: Connect the lower leg of potentiometer VR1 to the breadboard positive power
    rail.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR1的下腿连接到面包板的正电源轨。
- en: Connect the upper leg of potentiometer VR2 to the breadboard negative power
    rail.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR2的上腿连接到面包板的负电源轨。
- en: Connect the lower leg of potentiometer VR2 to the breadboard positive power
    rail.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器VR2的下腿连接到面包板的正电源轨。
- en: Connect the upper leg of the resistor to the breadboard negative power rail.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电阻的上腿连接到面包板的负电源轨。
- en: Connect the anode leg of the LED to BCM GPIO 12 / PWM 0 on your Raspberry Pi.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED的阳极腿连接到树莓派的BCM GPIO 12 / PWM 0上。
- en: Well done! You have now completed this circuit. For your reference, a semantic
    diagram depicting the breadboard circuit is shown in *Figure 5.7*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您现在已经完成了这个电路。供您参考，*图5.7*显示了描述面包板电路的语义图。
- en: As a reminder, we covered an example on how to read a semantic diagram back
    in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting Started with
    Python and IoT*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中介绍了如何阅读语义图的示例，*Python和物联网入门*。
- en: 'I encourage you to trace around this semantic diagram while referring back
    to the breadboard layout to understand how the lines and labels on the diagram
    relate back to the pictured components and wires on the breadboard. Investing
    the time to understand how paired schematic diagrams and breadboard circuits relate
    to one another will assist and increase your ability to create breadboard layouts
    directly from a schematic diagram:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您在参考面包板布局时围绕这个语义图进行追踪，以了解图表上的线条和标签如何与面包板上的组件和导线相关联。投资时间来理解成对的原理图和面包板电路如何相互关联将有助于增强您直接从原理图创建面包板布局的能力：
- en: '![](assets/95c0a63b-bd3b-46c6-9483-926af6fb94d3.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95c0a63b-bd3b-46c6-9483-926af6fb94d3.png)'
- en: Figure 5.7 – ADC circuit semantic diagram
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - ADC电路语义图
- en: With the circuit complete, let's check that the ADS1115 can be seen by our Raspberry
    Pi.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 电路完成后，让我们检查一下树莓派是否能够看到ADS1115。
- en: Making sure the ADS1115 is connected to your Raspberry Pi
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保ADS1115已连接到您的树莓派
- en: I2C devices are identified to their master (that is, our Raspberry Pi) by a
    unique address, and the default address for the ADS1115 is 0x48\. Since I2C devices
    are addressed, multiple devices can share the same I2C channels (pins) on a Raspberry
    Pi.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: I2C设备通过唯一地址（即我们的树莓派）标识其主设备，并且ADS1115的默认地址为0x48。由于I2C设备是有地址的，多个设备可以共享树莓派上的相同I2C通道（引脚）。
- en: You can change the I2C devices on most IC2 devices if you have multiple devices
    sharing the same address. This is the purpose of the ADDR terminal on the ADS1115,
    and you can find instructions for its use in the ADS1115 datasheet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个设备共享相同地址，您可以更改大多数IC2设备上的I2C设备。这是ADS1115上的ADDR端子的目的，您可以在ADS1115数据表中找到其使用说明。
- en: 'Raspbian OS contains the `i2cdetect` utility that queries the Raspberry Pi''s
    I2C interface for connected devices. Run the following in a Terminal:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian OS包含`i2cdetect`实用程序，用于查询树莓派的I2C接口以查找连接的设备。在终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `-y` option assumes we answer yes to any prompts. `1` is the I2C bus number.
    It''s always `1` on the Raspberry Pi 3 or 4. We expect to see the output like
    this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y`选项假设我们对任何提示都回答是。`1`是I2C总线号。在树莓派3或4上始终是`1`。我们期望看到这样的输出：'
- en: '[PRE4]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fact that we see `48` (hex address) is indicative that our Raspberry Pi
    has detected the ADS1115\. If you do not get this result, check your wiring and
    make sure I2C has been enabled as described in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml),
    *Setting Up Your Development Environment*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`48`（十六进制地址）表明我们的树莓派已经检测到了ADS1115。如果您没有得到这个结果，请检查您的接线，并确保I2C已经按照[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)中描述的方式启用。
- en: Now that we have verified that our ADS1115 is visible to our Raspberry Pi, let's
    proceed and read the two potentiometers as analog input.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们的ADS1115对我们的树莓派是可见的，让我们继续读取两个电位器作为模拟输入。
- en: Reading analog input with the ADS1115
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ADS1115读取模拟输入
- en: Now that we have our ADS1115 connected to our Raspberry Pi, it's time to learn
    how to use it to read in analog values, specifically the analog values created
    by our two potentiometers. We will use these analog values shortly to produce
    a PWM signal, which in turn will control the brightness of our LED.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的ADS1115连接到我们的树莓派，是时候学习如何使用它来读取模拟值，特别是我们两个电位器产生的模拟值。我们很快将使用这些模拟值来产生PWM信号，进而控制LED的亮度。
- en: The code we are about to cover can be found in the file `chapter05/analog_input_ads1115.py`.
    Please review this file before continuing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将涵盖的代码可以在文件`chapter05/analog_input_ads1115.py`中找到。请在继续之前查看此文件。
- en: 'Start by running the program in a Terminal:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行程序：
- en: '[PRE5]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should receive a stream of output similar to the following (your value
    and volts numbers will be different):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该收到类似以下内容的输出流（您的值和伏特数将不同）：
- en: '[PRE6]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Turn the two potentiometers and watch the output change—specifically, you will
    notice the numbers reported for value and volts change. The value and voltage
    will be in the following ranges:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转动两个电位器并观察输出的变化-具体来说，您会注意到报告的值和伏特数会发生变化。值和电压将在以下范围内：
- en: value in the range 0 to 26294 (or thereabouts)
  id: totrans-247
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值范围在0到26294之间（或附近）
- en: voltage in the range 0 to 3.3 volts (or thereabouts)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电压范围在0到3.3伏特（或附近）
- en: 'The output will be as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE7]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we'll discuss more in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*, analog input is about reading voltages,
    in our case here, between 0 volts/GND (our reference voltage) and +3.3 volts.
    The integer value is the raw output of the ADS1115, and what its maximum value
    is will depend on how the ADS1115 IC is configured (we're using the defaults).
    The voltage value is derived from this raw value using math based on the ADS1115
    configuration. All of the gooey details are in the ADS1115 datasheet and the library
    source code if you are interested.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中讨论的那样，*软件工程师的电子学101*，模拟输入是关于读取电压的，就我们这里而言，电压在0伏特/GND（我们的参考电压）和+3.3伏特之间。整数值是ADS1115的原始输出，它的最大值取决于ADS1115
    IC的配置方式（我们使用默认配置）。电压值是根据ADS1115配置的数学计算得出的。如果您感兴趣，所有细节都在ADS1115数据表和库源代码中。
- en: Beneath the surface of a high-level ADC library, many low-level settings influence
    how the ADC chip works (just check its datasheet). Different library authors may
    implement these settings differently or use different default settings. What this
    means in practice is that two libraries for the same ADC might output different
    raw values (and some libraries might not even provide this value to the programmer).
    So, never make assumptions about what the expected raw output value will be, and
    instead rely on the voltage measurement, which is always the source of truth.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级ADC库的表面下，许多低级设置会影响ADC芯片的工作方式（只需查看其数据表）。不同的库作者可能以不同的方式实现这些设置，或者使用不同的默认设置。实际上，这意味着相同ADC的两个库可能输出不同的原始值（有些库甚至可能不会向程序员提供这个值）。因此，永远不要假设预期的原始输出值是什么，而是依靠电压测量，这总是真相的来源。
- en: As you adjust the two potentiometers, do not get worried if the exact ends of
    these ranges do not marry up precisely to 0 and 3.3 volts, or if the values randomly
    twitch a little. This fuzzy result is expected when we deal with analog electronics.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调整两个电位器时，如果确切的范围末端与0和3.3伏特不完全匹配，或者值随机地微微抖动，不要担心。当我们处理模拟电子时，这种模糊的结果是预期的。
- en: Next, we will examine the code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查代码。
- en: Understanding the code
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解代码
- en: Now that we have seen the basic operation of our ADS1115 ADC, it's time to have
    a look at the accompanying code to understand how we query the ADS1115 in Python
    to get analog readings. What we learn below will lay the foundations for the analog
    interfacing programs that we will see in *part 3* of this book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了ADS1115 ADC的基本操作，是时候看一下相应的代码，了解我们如何在Python中查询ADS1115以获取模拟读数。我们下面学到的内容将为本书的*第3部分*中我们将看到的模拟接口程序奠定基础。
- en: We will commence our code walk-through with the imports.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入开始我们的代码漫步。
- en: Imports
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入
- en: 'There are two ways we can use the ADS1115 with our Raspberry Pi with Python:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种方法在树莓派上使用ADS1115与Python：
- en: Read the ADS1115 datasheet and use a lower-level I2C such as SMBus to implement
    the data protocol used by the device.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读ADS1115数据表，并使用较低级别的I2C，如SMBus来实现设备使用的数据协议。
- en: Find a ready-made Python library available through PyPi that we can install
    using `pip`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个现成的Python库，通过PyPi可以使用`pip`安装。
- en: 'There are several ready-made Python modules available to use with the ADS1115\.
    We are using the Adafruit Binka ADS11x5 ADC library that we installed through
    `requirement.txt` at the start of this chapter:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个现成的Python模块可用于与ADS1115一起使用。我们使用了通过`requirement.txt`在本章开始时安装的Adafruit Binka
    ADS11x5 ADC库：
- en: '[PRE8]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Starting at line (1), we see the `board` and `busio` imports from Circuit Python
    (Blinka), while the last two imports starting with `adafruit` are from the Adafruit
    ADS11x5 ADC library and are used to configure the ADS1115 module and read its
    analog input, which we are going to look at next.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1行开始，我们看到了来自Circuit Python（Blinka）的`board`和`busio`导入，而以`adafruit`开头的最后两个导入来自Adafruit
    ADS11x5 ADC库，并用于配置ADS1115模块并读取其模拟输入，我们将在下面看到。
- en: ADS1115 setup and configuration
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ADS1115设置和配置
- en: 'At line (2) in the following code block, we use the `busio` import to create
    an I2C interface with Circuit Python/Blika. The `board.SLC` and `board.SDA` parameters indicate
    we are using the dedicated I2C channel (alternative functions of GPIO 2 and 3)
    on the Raspberry Pi:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第2行，我们使用`busio`导入来创建一个与Circuit Python/Blika的I2C接口。`board.SLC`和`board.SDA`参数表示我们正在使用树莓派上的专用I2C通道（GPIO
    2和3的替代功能）：
- en: '[PRE9]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we create an instance of `ADS.ADS1115` using the pre-configured I2C interface
    and assign it to the `ads` variable. From this point forward in the code, when
    we interact with our ADS1115 module, we will use this instance.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用预配置的I2C接口创建`ADS.ADS1115`的实例，并将其分配给`ads`变量。从此刻起，在代码中，当我们与ADS1115模块交互时，我们将使用这个实例。
- en: Next, let's consider the global variables.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑全局变量。
- en: Global variables
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'At line (3) in the following code snippet, we start with a few quasi-constants
    defining the maximum and minimum voltages we expect to receive through the analog
    input. When you ran the code previously, your end range voltages probably were
    not exactly 0 and 3.3 volts. This occurrence is expected, and it can make a program
    feel like the Pots do not reach the ends of their rotation. The value assigned
    to `A_IN_EDGE_ADJ` is used to compensate for this in code. We will revisit this
    variable in the next section:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段的第3行，我们从几个准常量开始，定义了我们希望通过模拟输入接收的最大和最小电压。当您之前运行代码时，您的端电压范围可能并不完全是0和3.3伏特。这种情况是可以预期的，并且可能会使程序感觉像电位器无法达到其旋转的端点。`A_IN_EDGE_ADJ`的值用于在代码中进行补偿。我们将在下一节重新访问这个变量：
- en: '[PRE10]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, starting at line (4), we create two `AnalogIn` instances relating to
    the `A0` and `A1` inputs of the ADS1115 that are connected to our Pots. It''s
    through these variables that we determine how much a user has rotated our frequency
    and duty cycle potentiometers:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从第4行开始，我们创建了两个与连接到我们的电位器的ADS1115的`A0`和`A1`输入相关的`AnalogIn`实例。通过这些变量，我们确定用户旋转了我们的频率和占空比电位器的程度：
- en: '[PRE11]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we come to the program's entry point where we will read our analog inputs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来到程序的入口点，我们将在这里读取我们的模拟输入。
- en: Program entry point
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序入口点
- en: Our program continuously loops, reading our analog input values for each pot
    and prints formatted output to the Terminal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序不断循环，读取每个电位器的模拟输入值，并将格式化输出打印到终端。
- en: 'At line (5), we see how to access the integer value from the frequency pot
    using `frequency_ch.value` and the voltage value using `frequency_ch.voltage`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5行，我们看到如何使用`frequency_ch.value`访问频率电位器的整数值，并使用`frequency_ch.voltage`访问电压值：
- en: '[PRE12]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, notice that the program is wrapped in a try/except block that will
    capture *Ctrl* + *C* so that we can perform a clean-up using `i2c.deinit()`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意程序被包裹在一个try/except块中，以捕获*Ctrl* + *C*，以便我们可以使用`i2c.deinit()`进行清理。
- en: Now that we have seen how to read analog input using our ADS1115, next, we will
    integrate the LED.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何使用ADS1115读取模拟输入，接下来，我们将集成LED。
- en: Using PWM to control an LED
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PWM控制LED
- en: Now we will add the LED into the code, only we'll be doing this differently
    to what we've done in previous chapters. The purpose of the LED for this exercise
    is to visually see the effects of changing the duty cycle and frequency characteristics
    of PWM. We will use the analog inputs of the two Pots to define the PWM duty cycle
    and frequency.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将LED添加到代码中，只是我们将以与之前章节不同的方式进行。此练习中LED的目的是为了直观地看到改变PWM的占空比和频率特性的效果。我们将使用两个电位器的模拟输入来定义PWM的占空比和频率。
- en: The code we discuss in this section extends the analog code example we just
    covered in `chapter05/analog_input_ads1115.py` to use PiGPIO to create a hardware
    PWM signal.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的代码扩展了我们刚刚在`chapter05/analog_input_ads1115.py`中涵盖的模拟代码示例，以使用PiGPIO创建硬件PWM信号。
- en: 'Two additional source code files are provided with this book that implement
    hardware-timed PWM using PiGPIO and software PWM using RPi.GPIO:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了另外两个源代码文件，分别使用PiGPIO实现硬件定时PWM和使用RPi.GPIO实现软件PWM：
- en: '`chapter05/pwm_hardware_timed.py`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter05/pwm_hardware_timed.py`'
- en: '`chapter05/pwm_software.py`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter05/pwm_software.py`'
- en: Their overall code is similar, with the differences being the methods and input
    parameters used to invoke PWM. We will revisit these files again in the upcoming
    section, *Visualizing software and hardware-timed PWM*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的整体代码类似，不同之处在于用于调用PWM的方法和输入参数。我们将在接下来的部分再次访问这些文件，*可视化软件和硬件定时PWM*。
- en: 'The code we are about to cover can be found in the `chapter05/pwm_hardware.py` file.
    Please review this file before continuing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将讨论的代码可以在`chapter05/pwm_hardware.py`文件中找到。请在继续之前查看此文件：
- en: 'Run the program in a Terminal and observe the output:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行程序并观察输出：
- en: '[PRE13]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adjust the Pots until the frequency reads 60 Hz and the duty cycle reads 0%.
    The LED should not be lit. The LED is unlit because the duty cycle is at 0%, so
    GPIO 12 (PWM0) is always low. Very slowly turn the duty cycle Pot to increase
    the duty cycle and observe the LED slowly increase in brightness. At a 100% duty
    cycle, GPIO 12 (PWM0) is always high 100% of the time and the LED is at its full
    brightness.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整电位器，直到频率读取为60赫兹，占空比读取为0%。LED不应点亮。LED未点亮是因为占空比为0%，因此GPIO 12（PWM0）始终为低电平。非常缓慢地转动占空比电位器以增加占空比，并观察LED缓慢增加亮度。在100%的占空比下，GPIO
    12（PWM0）始终为高电平100%的时间，LED处于全亮状态。
- en: If you are finding that the duty cycle printed on the Terminal does not reach
    0% or 100% at either end of the Pot's movement range, try increasing the value
    of `A_IN_EDGE_ADJ` in your code (try +0.02 for starters). Also, tweak this adjustment
    if you experience a similar issue with the frequency range and dial.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现终端上打印的占空比在Pot移动范围的任一端都没有达到0%或100%，请尝试增加代码中`A_IN_EDGE_ADJ`的值（首先尝试+0.02）。如果您在频率范围和刻度上遇到类似问题，也可以调整此参数。
- en: Rotate the duty cycle dial until it reads less than 100% (for example, 98%),
    and then adjust the frequency dial. The LED blinks on and off at this frequency.
    As you lower the frequency toward zero, the LED blinks slower. For most people,
    at around 50-60 Hz, the LED will be blinking so fast that it appears to be just
    on. Remember that if the duty cycle is 0% or 100%, the frequency dial does not
    work! That's because at either end of the duty cycle, the PWM signal is fully
    off or on—it's not pulsing and hence frequency has no meaning.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转占空比刻度，直到它显示小于100%（例如98%），然后调整频率刻度。LED以这个频率闪烁。当你将频率降低到零时，LED会闪烁得更慢。对于大多数人来说，在大约50-60赫兹时，LED会闪烁得如此之快，以至于它看起来就像是一直开着。请记住，如果占空比为0%或100%，频率刻度不起作用！这是因为在占空比的任一端，PWM信号完全关闭或打开——它不是脉冲，因此频率没有意义。
- en: Let's examine the code that makes this work.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下让这个工作的代码。
- en: Understanding the code
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解代码
- en: This example is using the hardware PWM features offered by PiGPIO. The ADS1115-related
    code is the same as our previous example, so we will not cover it again here.
    We'll start by looking at the additional global variables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了PiGPIO提供的硬件PWM功能。与我们之前的示例相同，ADS1115相关的代码也是一样的，所以我们不会在这里再次介绍它。我们将首先看看额外的全局变量。
- en: Global variables
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'At line (1) and (2) in the following code block, we define two variables for
    the minimum and maximum duty cycle and frequency values. These values come from
    the API documentation for the PiGPIO `hardware_PWM()` method, which we will see
    in use shortly:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第1行和第2行，我们定义了两个变量，用于最小和最大占空比和频率值。这些值来自PiGPIO `hardware_PWM()`方法的API文档，我们很快就会看到它们的使用：
- en: '[PRE14]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have capped `MAX_FREQ` to 60 Hz for our demonstration so our human eyes can
    observe the effects in the LED.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`MAX_FREQ`限制为60赫兹，以便我们的肉眼可以观察LED的效果。
- en: Next, we have a custom function to map value ranges.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个自定义函数来映射值范围。
- en: Range mapping function
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围映射函数
- en: 'At line (3), we have a function named `map_value()`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们有一个名为`map_value()`的函数：
- en: '[PRE15]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The purpose of this method is to map an input range of values into another range
    of values. For example, we use this function to map the analog input voltage range
    0-3.3 volts into a frequency range 0-60\. You will frequently use a value-mapping
    function like this when working with analog inputs to map raw analog input values
    into more meaningful values for your code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的目的是将一个输入值范围映射到另一个值范围。例如，我们使用这个函数将模拟输入电压范围0-3.3伏特映射到0-60的频率范围。在处理模拟输入时，您经常会使用这样的值映射函数，将原始模拟输入值映射为代码中更有意义的值。
- en: Next, we are ready to create the PWM signal.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备创建PWM信号。
- en: Generating the PWM signal
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成PWM信号
- en: This next code fragment is found in the main `while` loop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段位于主`while`循环中。
- en: 'At lines (4) and (5), we are reading in the voltage values from the frequency
    and duty cycle Pots, before using the `map_value()` function to convert the voltage
    range of 0-3.3 volts into our desired frequency and duty cycle ranges we saw defined
    as global variables. Notice that we are also formatting the duty cycles as a percentage
    value for display purposes:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行和第5行，我们从频率和占空比Pots中读取电压值，然后使用`map_value()`函数将0-3.3伏特的电压范围转换为我们在全局变量中定义的所需频率和占空比范围。请注意，我们还将占空比格式化为百分比值以供显示：
- en: '[PRE16]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At line (6), we use `pi.hardware_PWM()` to use the Raspberry Pi's PWM hardware
    to generate a PWM signal on the LED's pin.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们使用`pi.hardware_PWM()`来使用树莓派的PWM硬件在LED引脚上生成PWM信号。
- en: Now that we have seen the effects of varying the frequency and duty cycles on
    an LED, we will perform an exercise to visualize a PWM signal with a logic analyzer.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了改变LED频率和占空比的效果，我们将进行一个练习，使用逻辑分析仪来可视化PWM信号。
- en: Visually exploring PWM with PiScope
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PiScope进行PWM的可视化探索
- en: Let's do an exercise and see the PWM waveform in a logic analyzer, which is
    a piece of equipment used to visualize electronic signals. While the general principles
    behind PWM are technically simple, to aid learning when starting out, it can be
    helpful to visualize what a PWM signal looks like and observe how it changes visually as
    its duty cycle and frequency change.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个练习，看看逻辑分析仪中的PWM波形，逻辑分析仪是一种用于可视化电子信号的设备。尽管PWM背后的一般原理在技术上很简单，但在刚开始学习时，通过可视化PWM信号的外观和观察其随着占空比和频率的变化而发生的变化，可以帮助学习。
- en: PiGPIO contains a software logic analyzer we can use for this purpose. Now,
    I need to point out that it's a basic software logic analyzer and in no way compares
    to professional-grade equipment, however, for our example and education, it will
    work a treat and cost us nothing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: PiGPIO包含一个我们可以用于此目的的软件逻辑分析仪。现在，我需要指出的是，这是一个基本的软件逻辑分析仪，绝对不能与专业设备相比，但是对于我们的示例和教育来说，它将非常有效，并且不会花费我们任何费用。
- en: 'Let''s download, install, and run PiScope. Here are the steps to follow:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们下载、安装并运行PiScope。以下是要遵循的步骤：
- en: 'First, we must install PiScope. Run the following commands to download, compile,
    and install PiScope:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装PiScope。运行以下命令来下载、编译和安装PiScope：
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run PiScope with the following command:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行PiScope：
- en: '[PRE18]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I'd recommend shutting down any resource-heavy applications before starting
    PiScope and performing this exercise. The following screenshots do not show all
    GPIOs like yours would by default because I've turned some off via the menu Misc
    | GPIOs**. **If you, too, turn off GPIOs from the display, remember to leave on
    SDA (GPIO 2) and/or SCL (GPIO 3) for this exercise as this creates a continuous
    input signal for PiScope, which keeps the display moving in time. Without this
    continuous input, PiScope pauses the display when there is no signal input so
    our example will keep pausing the display at the duty cycle or frequencies of
    0, which will make the demonstration feel clunky.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在启动PiScope并进行此练习之前关闭任何资源密集型应用程序。由于我通过菜单关闭了一些GPIO，所以下面的屏幕截图并不像您的默认情况下那样显示所有GPIO。**如果您也关闭了显示器上的GPIO，请记住保留SDA（GPIO
    2）和/或SCL（GPIO 3）以进行此练习，因为这会为PiScope创建一个连续的输入信号，使显示器保持时间运动。如果没有这个连续的输入，PiScope会在没有信号输入时暂停显示，因此我们的示例将在占空比或频率为0时暂停显示，这将使演示感觉笨拙。
- en: Make sure the `chapter05/pwm_hardware.py` program is running in a Terminal.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`chapter05/pwm_hardware.py`程序在终端中运行。
- en: 'Slowly turn the duty cycle and frequency dials and observe how the PWM signal
    changes on row number 12\. Keeping our frequency range very low (for example,
    0 to 60 Hz) means we can observe the PWM signal easily in the PiScope logic analyzer:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 慢慢地转动占空比和频率旋钮，并观察第12行上PWM信号的变化。保持我们的频率范围非常低（例如0到60赫兹）意味着我们可以在PiScope逻辑分析仪中轻松观察PWM信号：
- en: '![](assets/a962eccd-2d44-444e-ae1c-51a64831fcb1.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a962eccd-2d44-444e-ae1c-51a64831fcb1.png)'
- en: Figure 5.8 – 25% duty cycle at 10 Hz
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 - 10赫兹下的25%占空比
- en: The preceding screenshot shows a 25% duty cycle at 10 Hz. If you examine the
    last row in the screenshot, you will notice that GPIO 12 is high for 25% of a
    single cycle and low for 75%.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的屏幕截图显示了10赫兹下的25%占空比。如果您检查屏幕截图中的最后一行，您会注意到GPIO 12在单个周期中高电平占25%，低电平占75%。
- en: 'The following screenshot shows a 75% duty cycle at 10 Hz. If you examine the
    last row in the screenshot, you will notice that GPIO 12 is high for 75% of a
    single cycle and low for 25%:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了10赫兹下的75%占空比。如果您检查屏幕截图中的最后一行，您会注意到GPIO 12在单个周期中高电平占75%，低电平占25%：
- en: '![](assets/dc005bb3-581d-4361-a5dd-c1ae77287bfa.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc005bb3-581d-4361-a5dd-c1ae77287bfa.png)'
- en: Figure 5.9 – 75% duty cycle at 10 Hz
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 - 10赫兹下的75%占空比
- en: We have now seen what a PWM signal waveform looks like visually using PiScope,
    which is a free and basic software logic analyzer provided by the developer of
    PiGPIO. Our primary purpose behind visualizing PWM signals as an exercise was
    to provide a visual aid to help you to understand PWM and its duty cycle and frequency
    properties.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经通过PiScope看到了PWM信号波形的可视化，PiScope是PiGPIO开发者提供的免费基本软件逻辑分析仪。我们将PWM信号可视化的主要目的是为了提供一个视觉辅助工具，帮助您理解PWM及其占空比和频率特性。
- en: In practice, when you are starting out and integrating with basic electronics,
    you probably won't need a logic analyzer or even the need to visualize signals.
    However, as you advance your knowledge and as you need to debug electronic integration
    problems at the electronics level, I hope this basic introduction to the use of
    logic analyzers proves useful and points you in the right direction for further
    inquiries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当您刚开始并与基本电子集成时，您可能不需要逻辑分析仪，甚至不需要可视化信号。然而，随着您的知识的提升以及在电子集成问题的调试上的需求，我希望这个对逻辑分析仪的基本介绍能够帮助您，并指引您进一步探索的方向。
- en: Next, we'll point you toward the Python source files that demonstrate alternative
    PWM techniques.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指向演示替代PWM技术的Python源文件。
- en: Visualizing software and hardware-timed PWM
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化软件和硬件定时PWM
- en: 'Our code examples from the previous sections, *Using PWM to control an LED*,
    and *Visually exploring PWM with PiScope*, both created a PWM signal using your
    Raspberry Pi''s PWM hardware. Accompanying the code for this chapter and listed
    in the following table are alternative implementations that demonstrate the use
    of hardware-timed and software-generated PWM signals. You may recall that we discussed
    these alternatives back in the section entitled *Creating PWM signals*:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前章节的代码示例，*使用PWM控制LED*和*使用PiScope进行PWM可视化*，都是使用树莓派的PWM硬件创建PWM信号。本章的代码以及下表中列出的替代实现演示了硬件定时和软件生成的PWM信号的使用。您可能还记得我们在*创建PWM信号*部分讨论过这些替代方案：
- en: '| File | Details |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 详情 |'
- en: '| --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pwm_hardware.py` | This is hardware PWM using PiGPIO (this is the code we''ve
    seen in this chapter). You must use a PWM hardware GPIO pin 12, 13, 18, or 19.
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `pwm_hardware.py` | 这是使用PiGPIO的硬件PWM（这是本章中看到的代码）。您必须使用PWM硬件GPIO引脚12、13、18或19。|'
- en: '| `pwm_hardware_timed.py` | This is a hardware-timed PWM using PiGPIO. This
    will work with any GPIO pin. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `pwm_hardware_timed.py` | 这是使用PiGPIO的硬件定时PWM。这将适用于任何GPIO引脚。|'
- en: '| `pwm_software.py` | This is software PWM using RPi.GPIO (PiGPIO does not
    provide software PWM). This will work with any GPIO pin. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `pwm_software.py` | 这是使用RPi.GPIO的软件PWM（PiGPIO不提供软件PWM）。这将适用于任何GPIO引脚。|'
- en: Functionally, these examples are the same in that they will change your LED's
    brightness, and I predict that you will find that hardware and software PWM perform
    similarly. As you turn the frequency Pot's dial, the change to the LED and PiScope
    will feel smooth, while the hardware-timed PWM will feel a little chunky. This
    is because the hardware-timed frequencies (in PiGPIO) must be 1 of 18 predetermined
    values so the frequency progression as you adjust the pot is not incremental and
    linear, but instead jumps to/from the next predefined frequency. You'll see these predefined
    frequencies in an array in `pwm_hardware-timed.py`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这些示例是相同的，它们将改变LED的亮度，我预测您会发现硬件和软件PWM的表现相似。当您转动频率旋钮时，LED和PiScope的变化会感觉平滑，而硬件定时PWM会感觉有些生硬。这是因为硬件定时频率（在PiGPIO中）必须是18个预定值中的一个，因此当您调整旋钮时，频率的变化不是逐渐的和线性的，而是跳到/从下一个预定义的频率。您将在`pwm_hardware-timed.py`中的数组中看到这些预定义的频率。
- en: As mentioned previously, software PWM is the least reliable method of producing
    PWM signals because it is susceptible to distortion if your Raspberry Pi's CPU
    gets busy.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，软件PWM是产生PWM信号的最不可靠的方法，因为如果您的树莓派CPU变得繁忙，它容易失真。
- en: 'You can try to create and visualize PWM distortion with these steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试使用以下步骤创建和可视化PWM失真：
- en: Run `pwm_software.py` and set the duty cycle to high (for example, 98%) and
    the frequency to 60 Hz. Do not use a 100% duty cycle because this is a fully-on
    state and you would visually get a horizontal line, not repeating square waveforms.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`pwm_software.py`并将占空比设置为高（例如98%），频率为60赫兹。不要使用100%的占空比，因为这是一个完全开启的状态，你会看到一个水平线，而不是重复的方波形。
- en: Start a resource-intensive program on your Raspberry Pi—something that will
    put a load on the CPU. For example, try closing and relaunching the Chrome web
    browser.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的树莓派上启动一个资源密集型程序，比如尝试关闭并重新启动Chrome浏览器。
- en: 'If you closely observe the LED, it may flicker occasionally as the PWM signal
    is distorted. Alternatively, you may be able to observe the waveform distort in
    PiScope, as indicated by the arrows in the following screenshot. You will notice
    the width of the bars is not uniform when that the signal is distorting:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您仔细观察LED，您可能会注意到PWM信号在某些时候会闪烁。或者，您可以在PiScope中观察到波形失真，如下截图中的箭头所示。当信号失真时，您会注意到条的宽度不均匀：
- en: '![](assets/0401f0ad-c4ee-4350-8fe5-84a947ed2ee2.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0401f0ad-c4ee-4350-8fe5-84a947ed2ee2.png)'
- en: Figure 5.10 – Distortions in the PWM signal, 50% duty cycle at 50 Hz
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 - PWM信号中的失真，50%占空比，50赫兹
- en: Well done. You've just completed a detailed practical exercise using an ADS1115
    to extend your Raspberry Pi so that you can also interface it with analog electronics.
    Along the way, you also learned how to produce a PWM signal with Python, saw the
    effects of varying this signal on an LED, and observed the signal visually with
    PiScope.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。您刚刚完成了一个详细的实际练习，使用ADS1115扩展了您的树莓派，以便您还可以将其与模拟电子设备进行接口。在此过程中，您还学会了如何使用Python产生PWM信号，看到了这个信号对LED的影响，并用PiScope进行了可视化观察。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well done on getting this far, as there has certainly been a lot to get our
    heads around! As a recap, we explored common numbering schemes for referencing
    GPIO pins and reviewed popular GPIO libraries for Python. We also looked at the
    various interfacing methods used to connect electronics to your Raspberry Pi and
    performed a practical exercise to add an ADC to your Raspberry Pi and use it to
    visually explore PWM concepts with an LED and the PiScope logic analyzer.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好，因为肯定有很多东西需要我们理解！回顾一下，我们探讨了用于引用GPIO引脚的常见编号方案，并回顾了Python的流行GPIO库。我们还研究了用于将电子设备连接到树莓派的各种接口方法，并进行了一个实际练习，向您的树莓派添加ADC，并使用它来通过LED和PiScope逻辑分析仪进行可视化探索PWM概念。
- en: Your understanding of the fundamental concepts we explored and experimented
    with during this chapter will help you to understand how your Raspberry Pi interfaces
    to electronic components and devices and has provided you with a first-hand appreciation
    of how we interact with analog components (for instance, our potentiometers) and
    complex devices (that is, our ADS1115). We will be using and building on many
    of these fundamentals as we progress through the remainder of this book.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您对我们在本章中探讨和实验的基本概念的理解将有助于您理解树莓派如何与电子元件和设备进行接口，并让您第一手地了解我们如何与模拟元件（例如我们的电位计）和复杂设备（即我们的ADS1115）进行交互。在本书的其余部分，我们将使用和建立许多这些基本原理。
- en: This chapter has been largely software library and code-focused. However, in
    the next chapter, *Electronics 101 for the Software Engineer,* we will turn our
    attention to electronic concepts and common circuits that are used to interface
    electronics to a Raspberry Pi.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注软件库和代码。然而，在下一章《软件工程师的电子学101》中，我们将把注意力转向电子概念和用于将电子设备与树莓派进行接口的常见电路。
- en: Questions
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束时，这里有一系列问题供您测试对本章材料的了解。您将在书的*评估*部分找到答案：
- en: What serial communication interface allows devices to be daisy-chained?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种串行通信接口允许设备进行级联连接？
- en: You have an I2C device but do not know its address. How can you find it?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您有一个I2C设备，但不知道它的地址。您该如何找到它？
- en: You have started using a new GPIO Python library for the first time but can't
    seem to get any GPIO pins to work. What do you need to check?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您第一次开始使用一个新的GPIO Python库，但似乎无法使任何GPIO引脚工作。您需要检查什么？
- en: You are using PiGPIO on Windows with Remote GPIO to drive a remote Raspberry
    Pi. Now, you try to install a third-party device driver library but it's failing
    to install under Windows However, you find it installed successfully on the Raspberry
    Pi. What is the likely problem?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在Windows上使用PiGPIO和远程GPIO驱动远程树莓派。现在，您尝试安装一个第三方设备驱动程序库，但在Windows下安装失败，但您发现它在树莓派上成功安装了。可能的问题是什么？
- en: 'True or false: The Raspberry Pi has pins for both 3.3 volts and 5 volts, so
    you can use either voltage when working with GPIO pins?'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：树莓派上有3.3伏和5伏的引脚，因此在使用GPIO引脚时可以使用任一电压？
- en: You have created a robot that uses servos. During simple testing, everything
    seemed fine. However, now that you have finished, you notice the servos randomly
    twitch. Why?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个使用舵机的机器人。在简单测试期间，一切都很正常。然而，现在您完成了，您注意到舵机会随机抽搐。为什么？
- en: When the robot's servos move, you notice a lightning bolt icon on your monitor
    or display is going blank. Why could this be happening?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当机器人的舵机移动时，您会注意到显示器上出现了一个闪电图标，或者显示器变黑了。这可能是为什么？
- en: Further reading
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The GPIOZero website has a range of examples showing functionally equivalent
    examples using both GPIOZero and RPi.GPIO. This is a great introductory resource
    for understanding lower-level GPIO programming concepts and techniques:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: GPIOZero网站提供了一系列示例，展示了使用GPIOZero和RPi.GPIO的功能等效示例。这是一个很好的入门资源，可以帮助理解更低级别的GPIO编程概念和技术：
- en: '[https://gpiozero.readthedocs.io/en/stable/migrating_from_rpigpio.html](https://gpiozero.readthedocs.io/en/stable/migrating_from_rpigpio.html)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gpiozero.readthedocs.io/en/stable/migrating_from_rpigpio.html](https://gpiozero.readthedocs.io/en/stable/migrating_from_rpigpio.html)'
- en: 'The following links contain additional material concerning the interfaces and
    concepts that we have discussed in this chapter:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接包含了有关本章讨论的接口和概念的额外材料：
- en: 'SPI interface: [https://en.wikipedia.org/wiki/Serial_Peripheral_Interface](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPI接口：[https://en.wikipedia.org/wiki/Serial_Peripheral_Interface](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)
- en: I2C interface: [https://en.wikipedia.org/wiki/I%C2%B2C](https://en.wikipedia.org/wiki/I%C2%B2C)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C接口：[https://en.wikipedia.org/wiki/I%C2%B2C](https://en.wikipedia.org/wiki/I%C2%B2C)
- en: 1-wire interface:  [https://en.wikipedia.org/wiki/1-Wire](https://en.wikipedia.org/wiki/1-Wire)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-wire接口：[https://en.wikipedia.org/wiki/1-Wire](https://en.wikipedia.org/wiki/1-Wire)
- en: PWM: [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWM：[https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation)
- en: Potentiometers: [https://en.wikipedia.org/wiki/Potentiometer](https://en.wikipedia.org/wiki/Potentiometer)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电位器：[https://en.wikipedia.org/wiki/Potentiometer](https://en.wikipedia.org/wiki/Potentiometer)
- en: 'ADS1115 datasheet: [http://www.ti.com/lit/gpn/ads1115](http://www.ti.com/lit/gpn/ads1115)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADS1115数据表：[http://www.ti.com/lit/gpn/ads1115](http://www.ti.com/lit/gpn/ads1115)
