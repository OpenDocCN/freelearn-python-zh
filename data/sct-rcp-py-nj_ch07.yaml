- en: Python Enhancement Proposals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 增强提案
- en: 'In this chapter, we will look at **P****ython Enhancement Proposals (PEPs)**.
    PEPs are like **Requests for Comments** (**RFCs**); they allow interested parties
    to provide input on the path Python should take in the future. In this chapter,
    we will discuss the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 **Python 增强提案 (PEPs**)。PEPs 类似于 **请求评论 (RFCs**)；它们允许感兴趣的相关方就 Python
    应该采取的未来路径提供反馈。在本章中，我们将讨论以下内容：
- en: What are PEPs?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 PEPs？
- en: PEP 556 – Threaded garbage collection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 556 – 线程垃圾回收
- en: PEP 554 – Multiple subinterpreters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 554 – 多个子解释器
- en: PEP 551 – Security transparency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 551 – 安全透明度
- en: PEP 543 – Unified TLS API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 543 – 统一 TLS API
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Any programming language that is maintained requires regular updates to patch
    problems, as well as to provide new features. Python uses PEPs to propose new
    features, collect community input, and document design decisions. Thus, it is
    important to understand how the PEP process works, and to also look at some PEPs
    to see what they involve and their possible ramifications for the language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何维护的编程语言都需要定期更新以修复问题，以及提供新特性。Python 使用 PEPs 提出新特性，收集社区反馈，并记录设计决策。因此，了解 PEP
    流程的工作方式，并查看一些 PEPs 以了解它们涉及的内容及其对语言的潜在影响是很重要的。
- en: What are PEPs?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 PEPs？
- en: PEPs are design documents that provide information to the Python community,
    describing new features (or proposed new features) for Python, its processes,
    or its environment. PEPs provide technical information, as well as the rationale
    for the document.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PEPs 是设计文档，为 Python 社区提供信息，描述 Python 的新特性（或提议的新特性）、其流程或其环境。PEPs 提供技术信息，以及文档的合理性。
- en: As used by the Python foundation, PEPs are the primary mechanism for communicating
    with the Python community as a whole. One requirement for PEP authorship is to
    build a consensus among the community members and document any dissenting opinions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 基金会使用 PEPs 作为与整个 Python 社区沟通的主要机制。PEP 作者的一个要求是在社区成员之间建立共识，并记录任何不同意见。
- en: PEPs are kept as text files by the Python foundation, in a **content versioning
    system** (**CVS**). This versioning system acts as the historical record for each
    PEP, documenting the changes to the document, from first draft to final acceptance.
    As the CVS is based on GitHub, normal Git commands can be used to access documents,
    or they can be viewed via a browser at [https://github.com/python/peps.](https://github.com/python/peps)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PEPs 由 Python 基金会以文本文件的形式保存，在一个 **内容版本控制系统 (CVS**) 中。这个版本控制系统充当每个 PEP 的历史记录，记录了从初稿到最终接受期间文档的变更。由于
    CVS 基于 GitHub，可以使用常规的 Git 命令来访问文档，或者可以通过浏览器在 [https://github.com/python/peps.](https://github.com/python/peps)
    上查看。
- en: 'Three types of PEP are available:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 PEP 类型有三种：
- en: '**Standard track**: These describe a new feature or implementation for Python.
    They are also used to describe standards for interoperability outside of the standard
    Python library for current versions; later PEPs will provide for support within
    the standard library. A good example of this is the `from __future__` module for
    Python 2, from when Python 3 was being developed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准轨道**：这些描述了 Python 的新特性或实现。它们也用于描述当前版本标准 Python 库之外的标准；后续的 PEP 将提供在标准库中的支持。一个很好的例子是
    Python 2 的 `from __future__` 模块，这是在 Python 3 开发期间。'
- en: '**Information track**: These describe Python design issues, or provide guidelines/information
    to the community, but they don''t discuss new feature proposals. These PEPs don''t
    require community consensus, nor are they official recommendations, so Python
    users are free to use or ignore informational PEPs, as desired.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息轨道**：这些描述 Python 设计问题，或向社区提供指南/信息，但它们不讨论新特性提案。这些 PEPs 不需要社区共识，也不是官方推荐，因此
    Python 用户可以自由选择使用或忽略信息性 PEPs。'
- en: '**Process tracks**: These describe a Python process or propose a change to
    a process. They are similar to Standard PEPs, but are applicable to areas outside
    of the Python language itself. They frequently require community consensus before
    implementation, and, because they are more than just informational, they generally
    require adherence. They make changes to the Python ecosystem, not the language,
    so the implications can affect how the language is used.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程轨道**：这些描述了 Python 的流程或提议对流程的变更。它们与标准 PEPs 类似，但适用于 Python 语言本身之外的区域。它们在实施前通常需要社区共识，并且由于它们不仅仅是信息性的，因此通常需要遵守。它们对
    Python 生态系统进行变更，而不是对语言进行变更，因此影响可能会影响语言的使用。'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'As this is more of a procedural chapter than a coding chapter, this section
    will discuss the process of creating, submitting, and maintaining a PEP:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这部分更多地是关于程序而不是编码，本节将讨论创建、提交和维护 PEP 的过程：
- en: Like many great things, the first step to creating a PEP is developing a new
    idea for Python. Just like the Unix environment expects programs to do one thing
    only, PEPs should only explain one key idea. Small improvements, such as enhancements
    or patches, typically don't need a full PEP, and can be submitted into the Python
    development process through a ticket submission.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像许多伟大的事物一样，创建 PEP 的第一步是为 Python 开发一个新想法。就像 Unix 环境期望程序只做一件事一样，PEP 应该只解释一个关键想法。小的改进，如增强或补丁，通常不需要完整的
    PEP，可以通过提交工单的方式提交到 Python 开发流程中。
- en: The most successful PEPs hone in on one focused topic, and PEP editors have
    the right to reject PEPs that they consider too broad in topic or unfocused in
    their proposal. If a submitter has any doubts, it is better to submit multiple
    PEPs than try to discuss many overlapping ideas.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最成功的 PEP 都集中在单一主题上，PEP 编辑有权拒绝他们认为主题过于宽泛或提案不集中的 PEP。如果提交者有任何疑问，提交多个 PEP 比尝试讨论许多重叠的想法更好。
- en: Every PEP must have a champion—the person who will write the PEP using the prescribed
    format, monitor and manage discussions about the PEP, and build the community
    consensus for the PEP. While the PEP champion is normally the author, it doesn't
    have to be, as in the case of an organization making a PEP; the champion is simply
    the person who advocates for the PEP the most.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 PEP 都必须有一个支持者——这个人将使用规定的格式编写 PEP，监控和管理关于 PEP 的讨论，并建立 PEP 的社区共识。虽然 PEP 支持者通常是作者，但这并不一定，例如，一个组织提出
    PEP 的情况；支持者只是最积极倡导 PEP 的人。
- en: Prior to drafting a PEP, interest in the idea should be determined; obviously,
    trying to champion an unwanted idea is an uphill battle and could potentially
    lead to backlash. The best way to solicit interest is by posting to some of the
    core Python contact groups via `python-list@python.org` or `python-ideas@python.org`.
    Obviously, there are many other Python forums, blogs, and other community locales
    online, but those are considered the official solicitation sites.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在起草 PEP 之前，应该确定对该想法的兴趣；显然，试图推广一个不受欢迎的想法是一场艰难的战斗，可能会引发反弹。最佳方式是通过 `python-list@python.org`
    或 `python-ideas@python.org` 在一些核心 Python 联系组中发布帖子。显然，还有许多其他 Python 论坛、博客和其他在线社区地点，但那些被认为是官方的征集站点。
- en: One of the benefits of judging community interest prior to drafting the PEP
    is to ensure the idea hasn't already been rejected before; internet searches aren't
    guaranteed to find all of the ideas that have been proposed in the past. It also
    ensures that the idea has merit within the community and isn't just a pet-project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在起草 PEP 之前评估社区兴趣的一个好处是确保该想法尚未被拒绝；互联网搜索并不能保证找到过去提出的所有想法。这也确保了该想法在社区中有价值，而不仅仅是一个个人项目。
- en: Once the community has been canvassed and the idea is deemed good enough for
    a PEP, a draft PEP should be created and submitted to the `python-ideas` mailgroup.
    This allows the author to ensure the document is properly formatted and gain feedback
    prior to formal submission.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦社区进行了调查，并且该想法被认为足够好以形成 PEP，就应该创建一个草案 PEP 并提交到 `python-ideas` 邮件组。这允许作者确保文档格式正确，并在正式提交之前获得反馈。
- en: 'To actually submit a PEP to the Python GitHub site, a pull request must be
    made:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 PEP 实际提交到 Python GitHub 网站，必须提交一个拉取请求：
- en: First, fork the PEP repository and create a file named `pep-9999.rst`. This
    is the file that will contain your PEP document.
  id: totrans-26
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，克隆 PEP 仓库并创建一个名为 `pep-9999.rst` 的文件。这个文件将包含你的 PEP 文档。
- en: Push this to your GitHub fork and submit a pull request.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其推送到你的 GitHub 分支并提交一个拉取请求。
- en: The PEP will be reviewed by the editors for formatting and structure.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 将由编辑人员审查其格式和结构。
- en: If approved, the PEP will receive a formal PEP number and be assigned to one
    of the three tracks, as appropriate. It will also receive the *Draft* status.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果获得批准，PEP 将获得一个正式的 PEP 编号，并分配到三个轨道之一，具体视情况而定。它还将获得 *草案* 状态。
- en: Reasons for a PEP not being approved include duplicate submission (normally,
    a similar idea was submitted by someone else), being deemed technically unsound
    or unfeasible, insufficient motivation for the PEP, lack of backwards compatibility
    (obviously, this is not relevant between Python 2 and Python 3), or not keeping
    with the Python philosophy.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PEP不被批准的原因包括重复提交（通常，其他人提交了类似的想法），被认为技术上不可行或不切实际，PEP动机不足，缺乏向后兼容性（显然，这在Python
    2和Python 3之间不相关），或者不符合Python哲学。
- en: As updates are made to a PEP, the changes can be checked in by a developer with
    git push permissions.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着PEP的更新，更改可以通过具有git push权限的开发者进行检查。
- en: After an official PEP number has been assigned, the draft PEP can be discussed
    on the `python-ideas` mailgroup. Eventually, however, standard track PEPs must
    be sent to the `python-dev` list for review.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分配了官方PEP编号后，草稿PEP可以在`python-ideas`邮件组上进行讨论。然而，最终，标准跟踪PEP必须发送到`python-dev`列表进行审查。
- en: 'Standard track PEPs comprise two parts: a design document, and a reference
    implementation. It is suggested that a prototype implementation be submitted with
    the PEP as a sanity check, to show that the idea is feasible.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准跟踪PEP包括两部分：设计文档和参考实现。建议与PEP一起提交原型实现，作为合理性检查，以表明该想法是可行的。
- en: Once the PEP is complete and ready for final submission, final consideration
    is made by Guido van Rossum, the leader of the Python Foundation, or one of his
    selected cadre. For a PEP to be accepted, it must have a complete description
    of the proposal, the proposed enhancement must be an improvement for the Python
    language or ecosystem, any interpreter implementations must not affect performance
    or capabilities or otherwise interfere with operations, and the implementation
    must meet the pythonic sensibilities of Guido van Rossum.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦PEP完成并准备最终提交，最终考虑将由Python基金会领导人Guido van Rossum或他选定的干部进行。为了使PEP被接受，它必须有一个完整的提案描述，所提出的增强必须是对Python语言或生态系统的改进，任何解释器实现不得影响性能或功能，或以其他方式干扰操作，并且实现必须符合Guido
    van Rossum的Python风格感。
- en: 'Once a PEP has been accepted, the reference implementation is completed and
    incorporated into the main Python code repository. At that point, the PEP will
    be labeled *Finished*. Other status markers include: *Deferred* (PEP progress
    is put on hold), *Rejected* (PEP is declined by Van Rossum), and *Withdrawn* (PEP
    is removed from the pipeline by the author).'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦PEP被接受，参考实现将被完成并纳入主Python代码库。到那时，PEP将被标记为*完成*。其他状态标记包括：*推迟*（PEP进展被搁置），*拒绝*（PEP被Van
    Rossum拒绝），和*撤回*（PEP被作者从流程中移除）。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The required parts for a PEP to be accepted include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PEP被接受所需的必要部分包括以下内容：
- en: '**A preamble**: This includes the PEP number, a short title, the names of others,
    and so on.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前言**：这包括PEP编号、简短标题、其他人的姓名等。'
- en: '**Abstract**: A short description of the issue addressed in the PEP.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要**：对PEP中解决的问题的简要描述。'
- en: '**License**: Each PEP must be either placed in the public domain or licensed
    under the Open Publication License.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可**：每个PEP必须置于公共领域或根据开放出版许可进行许可。'
- en: '**Specification**: Technical specs that describe the syntax and semantics of
    new language features, detailed enough to allow interoperable implementations
    in alternate Python implementations, that is, CPython, Jython, IronPython, PyPy,
    and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范**：描述新语言特征的语法和语义的技术规范，详细到足以允许在替代Python实现中实现互操作性，即CPython、Jython、IronPython、PyPy等。'
- en: '**Motivation**: Why the author created the PEP, and what inadequacies currently
    exist in the Python ecosystem.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动机**：作者创建PEP的原因，以及Python生态系统中目前存在的不足。'
- en: '**Rationale**: This expands on the specification by describing the motivation
    behind the PEP and why certain decisions were made regarding the implementation.
    It includes a discussion of alternative designs considered and related work, such
    as how this feature is implemented in other languages. There should also be evidence
    of community consensus and important issues raised within the community during
    the discussion process.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理由**：通过描述PEP背后的动机以及为什么在实现方面做出了某些决定来扩展规范。它包括对考虑的替代设计和相关工作的讨论，例如在其他语言中如何实现此功能。还应该有社区共识的证据和讨论过程中在社区中提出的重要问题。'
- en: '**Backwards compatibility**: Any known issues regarding backwards compatibility
    are addressed in this section. Proposed fixes for these incompatibilities must
    be included; not accounting for (or including insufficient) methods may result
    in immediate rejection of the PEP.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容性**：本节中解决了有关向后兼容性的任何已知问题。必须包括这些不兼容性的建议修复；未考虑（或包括不足）的方法可能导致 PEP 立即被拒绝。'
- en: '**Reference implementation**: Although it is not necessary during the draft
    and comments period, a final implementation must be provided prior to a PEP receiving
    *Final* status. The implementation must include all relevant test code and documentation
    for inclusion in the Python language reference or standard library reference.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考实现**：虽然在草案和评论期间不是必需的，但在 PEP 接收 *Final* 状态之前，必须提供一个最终实现。该实现必须包括所有相关的测试代码和文档，以便包含在
    Python 语言参考或标准库参考中。'
- en: PEPs are written in reStructuredText (such as Python docstrings), which allows
    them to be human-readable, yet easily parsed into HTML.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 以 reStructuredText（如 Python 文档字符串）编写，这使得它们易于阅读，同时可以轻松解析为 HTML。
- en: PEP 556 – Threaded garbage collection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 556 – 线程化垃圾回收
- en: PEP 556 and the following PEPs are included to show recent PEP submissions that
    are potentially interesting, due to their impact on the Python ecosystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 556 及其后续 PEP 包括了最近提交的 PEP，这些 PEP 由于其对 Python 生态系统的影响而可能是有趣的。
- en: PEP 556 was created in September, 2017, and is currently in *Draft* status.
    It is expected to be included in Python v3.7\. It proposes a new mode of operation
    for Python's garbage collection. The new mode would allow implicit collection
    to occur within a dedicated thread, rather than synchronously with the CPU.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 556 于 2017 年 9 月创建，目前处于 *草案* 状态。预计它将被包含在 Python v3.7 中。它提出了 Python 垃圾回收的新操作模式。新模式将允许在专用线程中发生隐式收集，而不是与
    CPU 同步进行。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To discuss this PEP, we need to have a discussion about how garbage collection
    works within Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论这个 PEP，我们需要讨论在 Python 中垃圾回收是如何工作的。
- en: Garbage collection is handled by the `gc` module. While garbage collection is
    provided by Python by default, it is actually an optional feature. Using the module,
    garbage collection can be turned off, or the collection frequency can be modified;
    it also allows for debugging options. Further, it provides the ability to access
    objects that the collector identified, but cannot directly de-allocate. Python's
    garbage collector acts in conjunction with reference counting, which is one reason
    why it can be turned off.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收由 `gc` 模块处理。虽然 Python 默认提供了垃圾回收，但实际上这是一个可选功能。使用该模块，可以关闭垃圾回收，或修改收集频率；它还提供了调试选项。此外，它还提供了访问收集器识别但无法直接重新分配的对象的能力。Python
    的垃圾回收器与引用计数一起工作，这也是它可以被关闭的一个原因。
- en: Implicit garbage collection occurs based on the system determining that resources
    are over-allocated. When a new allocation request is made, the system reviews
    the program stats to determine which objects can be collected to allow the new
    resource to be made.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式垃圾回收基于系统确定资源过度分配。当提出新的分配请求时，系统会审查程序状态以确定哪些对象可以被收集，以便为新资源腾出空间。
- en: Explicit garbage collection occurs when a programmatic collection call is made
    via the Python API, for example, `gc.collect`. While this can be done by the programmer,
    such as when a file is explicitly closed, it can also occur from the underlying
    interpreter when an object is no longer being referenced.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 Python API 调用程序性收集调用时，例如 `gc.collect`，会发生显式垃圾回收。虽然这可以由程序员完成，例如在显式关闭文件时，但也可以由底层解释器在对象不再被引用时发生。
- en: Historically, the Python garbage collector has operated synchronously when performing
    implicit collections. This results in the program execution pausing within the
    current thread and running the garbage collector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Python 垃圾回收器在执行隐式收集时是同步操作的。这导致程序在当前线程中暂停执行，并运行垃圾回收器。
- en: The problem comes from the fact that, when reclaiming resources, finalization
    code within the objects may be executed, such as `__del__` methods and weak references.
    Weak references to objects do not keep these objects *alive* enough to prevent
    garbage collection. If the only remaining references to an object are weak, then
    the garbage collector is free to destroy the object and reallocate its resources.
    Until the object is destroyed, any weak references can call and return the referenced
    object, regardless of whether there are strong references available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 问题源于在回收资源时，对象内部的最终化代码可能会被执行，例如`__del__`方法和弱引用。指向对象的弱引用不足以保持这些对象*存活*，以防止垃圾回收。如果对象仅剩的引用是弱引用，那么垃圾回收器就可以自由地销毁该对象并重新分配其资源。直到对象被销毁，任何弱引用都可以调用并返回引用的对象，无论是否有强引用可用。
- en: Weak references are commonly used to implement a cache or map of large objects,
    when the need to keep the large object around just because it is referenced by
    the cache or map isn't necessary. In other words, weak references allow large
    objects to be removed from memory once they are no longer actively used; if the
    object is cached or mapped to associations, there is no need to keep it around,
    as those references don't have a primary affect on the object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用通常用于实现缓存或大对象的映射，当不需要因为缓存或映射而保留大对象时。换句话说，弱引用允许一旦大对象不再被积极使用，就可以将其从内存中移除；如果对象被缓存或映射到关联中，就没有必要保留它，因为那些引用对对象没有主要影响。
- en: When finalization code exists to clean up the system when an object is closed
    and dereferenced, the active thread is paused until the finalization process is
    complete; for example, notifying other objects, or even other systems, that the
    object is no longer available. Pausing running code to handle these housekeeping
    chores can result in an internal state that causes problems when the code is restarted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在用于在对象关闭和取消引用时清理系统的最终化代码时，活动线程会暂停，直到最终化过程完成；例如，通知其他对象，甚至其他系统，该对象不再可用。暂停正在运行的代码来处理这些维护工作可能会导致在代码重新启动时出现问题的内部状态。
- en: Hence, this PEP is aimed at this thread-state problem. When the running thread
    is paused and then restarted, it is fundamentally more difficult to deal with,
    rather than in multithreaded synchronization, where control is just switched between
    threads. Rather than forcing the developer to deal with problems that crop up
    when reentering the original thread, every time the thread is paused, this PEP
    addresses the issue by allowing garbage collection to occur in a separate thread,
    thus allowing the use of well-established multithreading principles.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个PEP旨在解决线程状态问题。当运行线程暂停然后重新启动时，这比在多线程同步中更难处理，在多线程同步中，控制只是在不同线程之间切换。而不是强迫开发者处理在重新进入原始线程时出现的问题，每次线程暂停时，这个PEP通过允许在单独的线程中进行垃圾回收来解决该问题，从而允许使用成熟的线程原则。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'As this is a PEP, there is no real code to create, unlike in previous chapters.
    What we will do is cover the details of the proposal and how they are intended
    to be implemented:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个PEP，我们不需要创建真正的代码，与前面的章节不同。我们将要涵盖提案的细节以及它们打算如何实现：
- en: 'Two new APIs would be added to the `gc` module:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向`gc`模块添加两个新的API：
- en: The `gc.set_mode(mode)` API configures the garbage-collection mode between serial
    and threaded. If it is currently set to threaded, but the setting is switched
    to serial, the function waits for the garbage collection thread to complete before
    changing.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.set_mode(mode)` API配置垃圾回收模式在串行和线程之间。如果当前设置为线程，但设置被切换到串行，该函数会在更改之前等待垃圾回收线程完成。'
- en: The `gc.get_mode()` API returns the current mode of operation.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_mode()` API返回当前的操作模式。'
- en: The collection mode can be switched between the two options, so it is recommended
    that it be set at the beginning of a program, or when child processes are created.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在两种选项之间切换收集模式，因此建议在程序开始时或创建子进程时设置。
- en: The actual implementation happens through adding the flag `gc_is_threaded` to
    the `gc` module; internally, a thread lock is added, to prevent multiple garbage
    collection instances from running simultaneously.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际实现是通过向`gc`模块添加`gc_is_threaded`标志来完成的；内部，添加了一个线程锁，以防止多个垃圾回收实例同时运行。
- en: In addition, two private functions, `threading._ensure_dummy_thread(name)` and
    `threading._remove_dummy_thread(thread)`, are added to the `threading` module.
    The former creates a thread with the provided name, whereas the latter removes
    the thread from the module's internal state.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还向`threading`模块添加了两个私有函数，`threading._ensure_dummy_thread(name)` 和 `threading._remove_dummy_thread(thread)`。前者使用提供的名称创建一个线程，而后者从模块的内部状态中删除线程。
- en: These functions allow the current thread to provide the name of the garbage
    collection thread when called within a finalization callback.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些函数允许当前线程在最终化回调中调用时提供垃圾回收线程的名称。
- en: 'Pseudocode is provided, demonstrating how the actual code would be implemented
    in the `gc` Python module as C code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了伪代码，演示了实际代码如何在`gc` Python模块中以C代码的形式实现：
- en: '`callback_collect.txt` simply enhances the current function by running garbage
    collection, up to the current object generation:'
  id: totrans-70
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_collect.txt` 通过运行垃圾回收，增强当前函数，直到当前对象生成：'
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`collect_gens.txt` is much the same, as it doesn''t modify the existing functionality.
    It is designed to collect all objects, as determined by the heuristic algorithm:'
  id: totrans-72
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect_gens.txt` 与之相似，因为它不修改现有功能。它旨在收集所有对象，由启发式算法确定：'
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`lock_collect.txt` demonstrates how garbage collection will be handled in a
    thread-safe manner; that is, the thread is locked during collection:'
  id: totrans-74
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock_collect.txt` 展示了垃圾回收将如何以线程安全的方式处理；即在收集期间锁定线程：'
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`sched_gc.txt` ensures that garbage collection is in the threaded mode, and
    then requests the collection of resources, when available:'
  id: totrans-76
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sched_gc.txt` 确保垃圾回收处于线程模式，并在资源可用时请求回收：'
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`implicit_gc.txt` doesn''t modify the existing code. It simply calls for collection
    if the heuristic algorithm determines it is necessary:'
  id: totrans-78
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`implicit_gc.txt` 不修改现有代码。它只是在启发式算法确定必要时调用收集：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`gc_malloc.txt` allocates the memory resources to support a garbage collection
    object:'
  id: totrans-80
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_malloc.txt` 为支持垃圾回收对象分配内存资源：'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`gc_thread.txt` spawns the garbage collection thread when called for:'
  id: totrans-82
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_thread.txt` 在被调用时启动垃圾回收线程：'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`gc_set_mode.txt` actually sets the garbage collection mode, between serial
    and threaded:'
  id: totrans-84
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_set_mode.txt` 实际上设置了垃圾回收模式，在串行和线程之间：'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`gc_get_mode.txt` is a getter function that simply reports whether the garbage
    collector is threaded or serial:'
  id: totrans-86
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_get_mode.txt` 是一个获取函数，它简单地报告垃圾收集器是线程化的还是串行的：'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`gc_collect.txt` represents a simple function that locks the thread and calls
    for garbage collection of the current object generation:'
  id: totrans-88
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc_collect.txt` 表示一个简单的函数，它锁定线程并调用当前对象生成的垃圾回收：'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, all of the preceding code is just pseudocode, representing how the C
    code would be implemented in the Python interpreter. It is not production code,
    and any attempt to use it as-is will fail.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有前面的代码只是伪代码，表示C代码如何在Python解释器中实现。这不是生产代码，任何尝试直接使用它的尝试都将失败。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The reason the default mode for garbage collection isn't changed to handle threads
    is because, while it would work for programs that are already multithreaded, single-threaded
    programs see finalization calls within the main thread. Changing this behavior
    may result in bugs in the program, related to finalizers existing outside of the
    main thread.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的垃圾回收模式没有改变以处理线程的原因是，虽然它适用于已经多线程的程序，但单线程程序在主线程中看到终结调用。改变这种行为可能会导致程序中的错误，与主线程外存在的终结器相关。
- en: It also causes problems if the program is written to use forking for concurrency.
    Forking from a single-threaded program is fine, as that is its intended use, but
    when forking from a multithreaded program, errors can creep into the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序被编写为使用分叉进行并发，它也会引起问题。从单线程程序中分叉是正常的，因为那是它的预期用途，但当你从多线程程序中分叉时，错误可能会悄悄进入系统。
- en: Due to compatibility issues, garbage collection currently waits for the collection
    process to end before the main thread is recalled. Thus, while it may make sense
    to have explicit collection on a separate thread as well as implicit collection,
    it wouldn't really alleviate any synchronization issues when the thread restarts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性问题，垃圾回收目前等待收集过程结束后才恢复主线程。因此，虽然显式收集在单独的线程上以及隐式收集可能是有意义的，但这并不能真正缓解线程重启时的同步问题。
- en: Inherent in the nature of multithreading, using a threaded garbage collector
    results in a slight delay for implicit collections when compared to serial collection.
    This delay may affect the system's memory allocation profile for some applications,
    but is expected to be minimal.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程的本质中，使用线程化的垃圾收集器与串行收集相比，在隐式收集时会有轻微的延迟。这种延迟可能会影响某些应用程序的系统内存分配配置文件，但预计将是微不足道的。
- en: Since the pseudocode shows thread locking in several places, there could be
    implications for CPU usage. However, it is far more expensive, in terms of processing
    power, to crawl the chain of object pointers during the garbage collection process
    itself. Such crawling is almost a brute-force process, and doesn't lend itself
    easily to CPU speculation, superscalar execution, and other marvels of modern
    CPU design.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于伪代码在几个地方显示了线程锁定，这可能会对CPU使用产生影响。然而，在垃圾收集过程中本身遍历对象指针链要昂贵得多，从处理能力上来说。这种遍历几乎是一种暴力过程，并且不容易适应CPU推测、超标量执行和现代CPU设计的其他奇迹。
- en: PEP 554 – Multiple subinterpreters
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 554 – 多个子解释器
- en: PEP 554 was created in September, 2017, and is currently in *Draft* status.
    It is projected for inclusion in Python v3.8\. This PEP discusses the potential
    of creating an `interpreters` module, allowing access to multiple interpreters
    within the same process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 554于2017年9月创建，目前处于*草案*状态。预计将包含在Python v3.8中。本PEP讨论了创建一个`interpreters`模块的潜力，允许在同一个进程中访问多个解释器。
- en: Multiple interpreters, also known as subinterpreters, have been a feature of
    Python since version 1.5\. While most developers are aware of the normal Python
    interpreter, either through the interactive Python console or simply by executing
    code, there is the ability to support multiple, independent interpreters within
    the same process, and, if needed, within the same thread. The subinterpreters
    can be switched between by using the `PyThreadState_Swap()` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 多个解释器，也称为子解释器，自Python 1.5版本以来就是Python的一个特性。虽然大多数开发者通过交互式Python控制台或简单地执行代码而了解到常规Python解释器，但它们能够在同一个进程中支持多个独立的解释器，如果需要，甚至可以在同一个线程中。可以通过使用`PyThreadState_Swap()`函数在子解释器之间切换。
- en: Each subinterpreter is a nearly complete, separate Python environment for code
    execution. Each interpreter has separate and independent versions of all import
    modules, system paths, and even `STDIN`, `STDOUT`, and `STDERR` streams. Extension
    modules can be shared between subinterpreters by making shallow copies of the
    module's initialization dictionary; that is, the module is effectively a single,
    copied instance between the subinterpreters, rather than re-initialized each time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子解释器都是一个几乎完整的、独立的Python环境，用于代码执行。每个解释器都有所有导入模块、系统路径以及甚至`STDIN`、`STDOUT`和`STDERR`流的独立和独立版本。可以通过制作模块初始化字典的浅拷贝来在子解释器之间共享扩展模块；也就是说，模块在子解释器之间实际上是一个单一的、复制的实例，而不是每次都重新初始化。
- en: What this PEP aims to accomplish is to make subinterpreters a part of the Python
    standard library by providing high-level interfaces to the subinterpreters, much
    like the current `threading` module. The module will also allow for data sharing
    between each interpreter, rather than object sharing; that is, while objects are
    independent in each interpreter, they can still share data between themselves,
    (again, like threads).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PEP旨在通过提供对子解释器的高级接口，使子解释器成为Python标准库的一部分，类似于当前的`threading`模块。该模块还将允许每个解释器之间进行数据共享，而不是对象共享；也就是说，虽然每个解释器中的对象是独立的，但它们之间仍然可以共享数据，(再次，就像线程一样)。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Again, this section will present pseudocode provided in the PEP, though it
    looks like Python code, to demonstrate how the PEP would work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，本节将展示PEP中提供的伪代码，尽管它看起来像Python代码，以展示PEP将如何工作：
- en: '`interpreter_isolate.txt` demonstrates running code in an isolated manner within
    an interpreter:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_isolate.txt`演示了在解释器中独立运行代码的方式：'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`interpreter_spawn_thread.txt` shows an interpreter spawning a thread to run
    Python code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_spawn_thread.txt`显示了解释器生成一个线程来运行Python代码：'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `interpreter_prepopulate.txt`, an interpreter is pre-populated with imported
    modules, which are initialized; then, the interpreter waits for a call to actually
    do the work:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`interpreter_prepopulate.txt`中，解释器预先填充了导入的模块，这些模块被初始化；然后，解释器等待调用以实际执行工作：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`interpreter_exception.txt` shows an interpreter handling an exception, which
    isn''t much different from normal operation, other than having a new interpreter
    created:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_exception.txt` 展示了解释器处理异常，除了创建了一个新的解释器外，与正常操作没有太大区别：'
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`interpreter_synch.txt` demonstrates the creation of two subinterpreters, and
    synchronizing between them with a data channel:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_synch.txt` 展示了创建两个子解释器，并使用数据通道在它们之间进行同步：'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`interpreter_data_share.txt` shows several interpreters being created and sharing
    file data:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_data_share.txt` 展示了几个解释器的创建和共享文件数据：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`interpreter_marshal.txt` demonstrates object passing via `marshal`. Marshaling
    data is similar to pickling or shelving, but, whereas those two modules are designed
    for general objects, `marshal` is designed for Python-compiled code in `.pyc`
    files:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_marshal.txt` 展示了通过 `marshal` 进行对象传递。序列化数据类似于 pickling 或 shelving，但这两个模块是为通用对象设计的，而
    `marshal` 是为 Python 编译的代码在 `.pyc` 文件中设计的：'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`interpreter_pickle.txt` shows subinterpreters sharing serialized data using
    `pickle`*:*'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interpreter_pickle.txt` 展示了子解释器使用 `pickle` 共享序列化数据：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`subinterpreter_module.txt` simply shows how to use a subinterpreter to run
    a module:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subinterpreter_module.txt` 简单展示了如何使用子解释器运行一个模块：'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`subinterpreter_script.txt`, similar to `subinterpreter_module.txt` in the
    preceding code, has an interpreter running a script. This could also be used for
    zip archives and directories:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subinterpreter_script.txt`，类似于前面代码中的 `subinterpreter_module.txt`，有一个解释器在运行脚本。这也可以用于
    zip 存档和目录：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`subinterpreter_pool.txt` shows several subinterpreters being spawned to create
    a pool, then executing code using a thread executor:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subinterpreter_pool.txt` 展示了创建一个池并生成多个子解释器，然后使用线程执行器执行代码：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The concept of multiple interpreters is not dissimilar to multiprocessing. Each
    interpreter is (relatively) isolated from the others, like multiple processes;
    yet, externally, the system appears to be running just a single process. This
    means that system performance and resource use are significantly better than in
    true multiprocessing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多个解释器的概念与多进程并不相似。每个解释器（相对）与其他解释器隔离，就像多个进程一样；但从外部看，系统似乎只运行一个进程。这意味着系统性能和资源使用比真正的多进程要好得多。
- en: It also increases the security profile of the system, because there is some
    leakage between the different interpreters, such as file descriptors, built-in
    types, singletons, and underlying static module data. They don't require modifications
    to the isolation of processes to pass data or otherwise interact with the system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提高了系统的安全性，因为不同解释器之间存在一些泄漏，例如文件描述符、内置类型、单例和底层静态模块数据。它们不需要修改进程的隔离来传递数据或以其他方式与系统交互。
- en: Another benefit of subinterpreters is that they provide a method of Python concurrency
    that allows for the simultaneous use of multiple CPUs (like multiprocessing) while
    functioning like independent, isolated threads, which is currently prevented,
    due to the GIL. Hence, while there is some overlap with existing programming methods,
    it could provide an alternate form of concurrency, without the problems of other
    parallel processing paradigms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 子解释器的另一个好处是，它们提供了一种 Python 并发方法，允许在像独立、隔离的线程一样工作的同时，同时使用多个 CPU（如多进程）。由于 GIL
    的存在，这目前是被阻止的。因此，尽管与现有的编程方法有一些重叠，但它可以提供另一种并发形式，而不存在其他并行处理范例的问题。
- en: Subinterpreters provide improved security because, by nature, they are isolated
    from each other, with each interpreter having its own memory block to play with.
    This contrasts with threads, which have a shared memory pool, by design, to facilitate
    data communications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 子解释器提供了改进的安全性，因为它们本质上彼此隔离，每个解释器都有自己的内存块来操作。这与线程形成对比，线程设计上共享一个内存池，以促进数据通信。
- en: Channels
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: Subinterpreters are able to share data via channels; the Go language does this
    as well, as the concept comes from **Communicating Sequential Processes** (CSP),
    which describes interactions within concurrent systems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 子解释器能够通过通道共享数据；Go 语言也是如此，因为这一概念来自**通信顺序过程**（CSP），它描述了并发系统内的交互。
- en: 'Channels provide two modes: send and receive. In Python''s case, one interpreter
    opens a channel to another. When data is sent, it is actually data derived from
    an object; when it is received, that data is converted back into the original
    object. In this way, objects can be passed between different interpreters without
    actually having access to the objects themselves.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Channels提供两种模式：发送和接收。在Python的情况下，一个解释器向另一个解释器打开一个通道。当发送数据时，实际上是来自一个对象的数据；当接收数据时，该数据被转换回原始对象。这样，可以在不同的解释器之间传递对象，而不必实际访问这些对象本身。
- en: Implicit calls to channels are accomplished via `send()`, `recv()`*,* and `close()`
    calls. This eliminates the need for explicit functions such as `add_channel()`
    and `remove_channel()` on an interpreter object, which would just add extraneous
    functionality to the Python API.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`send()`、`recv()`*和`close()`调用实现通道的隐式调用。这消除了在解释器对象上显式函数（如`add_channel()`和`remove_channel()`）的需求，这些函数只会给Python
    API添加额外的功能。
- en: Channels allow many-to-many connections between interpreters, whereas normal
    data pipes only support one-to-one connections. Both are FIFO data transfers,
    so the simplicity of using pipes eliminates the ability to handle simultaneous
    data transfers between multiple interpreters. Pipes also require naming the pipes,
    whereas channels are simply available for use.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Channels允许多个解释器之间进行多对多连接，而正常的数据管道只支持一对一连接。两者都是FIFO数据传输，因此使用管道的简单性消除了在多个解释器之间处理同时数据传输的能力。管道还需要命名管道，而通道则简单可用。
- en: Data queues and channels are very similar, with the main difference being that
    queues allow data buffering. However, this would cause problems with the sending
    and receiving of channel data, as channels support process blocking, so queues
    were determined to not be a viable solution for subinterpreter communications.
    Plus, queues can be built using channels, if their functionality is necessary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据队列和通道非常相似，主要区别在于队列允许数据缓冲。然而，这会给通道数据的发送和接收带来问题，因为通道支持进程阻塞，所以队列被确定不是子解释器通信的可行解决方案。此外，如果需要，可以使用通道构建队列。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The only documented use of subinterpreters is in `mod_wsgi` and **Java Embedded
    Python (JEP)**. This is possibly due to their hidden nature. Though multiple interpreters
    have been available since the early days of Python, and they provide a number
    of features comparable to multithreading and multiprocessing, they simply aren't
    commonly used. To be honest, this author wasn't aware of them until finding this
    PEP, but they sound very useful for certain parallel-processing projects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 子解释器的唯一记录用途是在`mod_wsgi`和**Java嵌入式Python (JEP)**中。这可能是由于它们的隐藏性质。尽管从Python的早期阶段起就提供了多个解释器，并且它们提供了一些与多线程和多进程相当的功能，但它们并不常用。坦白说，作者直到找到这个PEP之前都不知道它们，但它们听起来对于某些并行处理项目非常有用。
- en: PEP 551 – Security transparency
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 551 – 安全透明度
- en: PEP 551 is from August, 2017, and is in *Draft *status; it is also expected
    to be implemented in version 3.7\. It is designed to improve visibility into Python's
    behavior through security tools. Specifically, it attempts to prevent malicious
    uses of Python, to detect and report malicious use, and to detect attempts to
    bypass detection. The caveat is that this PEP would require user intervention,
    in the sense that they would be responsible for customizing and building Python
    for their particular environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 551 是2017年8月发布的，目前处于*草案*状态；它也预计将在3.7版本中实现。它的设计目的是通过安全工具提高对Python行为的可见性。具体来说，它试图防止Python的恶意使用，检测并报告恶意使用，以及检测绕过检测的尝试。需要注意的是，这个PEP将需要用户干预，也就是说，他们将对为他们特定环境定制和构建Python负责。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some discussion of software security is required before delving into the specifics
    of this PEP. This ensures that a common level of knowledge is available to readers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这个PEP的具体细节之前，需要对软件安全进行一些讨论。这确保了读者可以拥有一个共同的知识水平。
- en: General security
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般安全
- en: In software, many vulnerabilities are due to bugs that allow remote code execution
    or privilege escalation. One of the worst vulnerabilities is the **advanced persistent
    threat** (**APT**). An APT occurs when an attacker gains access to a network,
    installs software on one or more systems, then uses that software to retrieve
    data from the network, such as passwords, financial information, and so on. While
    most APTs attempt to hide their activity, ransomware and hardware attacks are
    notable for being very *loud and proud* in announcing that they are on the network.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，许多漏洞是由于允许远程代码执行或权限提升的bug引起的。最严重的漏洞之一是**高级持续性威胁**（**APT**）。APT发生在攻击者获得对网络的访问权限，在一台或多台系统上安装软件，然后使用该软件从网络中检索数据，如密码、财务信息等。尽管大多数APT试图隐藏其活动，但勒索软件和硬件攻击因其非常*高调且自豪*地宣布它们在网络中而引人注目。
- en: The systems that are infected first are often not the end targets; they are
    simply the most accessible. However, these infected systems act as pivot points
    to greater prizes within the network. For example, a developer's computer, connected
    to the internet as well as internal networks, may provide direct access for an
    attacker to get into production systems. As many low-grade systems as possible
    may be infected, just to make complete eradication more difficult.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先被感染的系统通常不是最终目标；它们只是最易访问的。然而，这些被感染的系统充当网络中更大奖品的支点。例如，连接到互联网以及内部网络的开发者的电脑，可能为攻击者提供直接访问生产系统的途径。尽可能多的低级系统可能被感染，只是为了使彻底根除更加困难。
- en: The biggest problem with detecting such malware is an inability to see exactly
    what is happening to systems on the network. While most systems have logging capabilities,
    capturing everything overloads system administrators with data, trying to find
    the needles in a progressively larger haystack. In addition, logs take up space
    very quickly, and there is only so much space that can be allocated to log files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 检测此类恶意软件的最大问题是无法确切看到网络中系统所发生的情况。虽然大多数系统都有日志记录功能，但捕获所有数据会使得系统管理员数据过载，试图在日益增大的堆肥中寻找针。此外，日志很快就会占用大量空间，而日志文件可以分配的空间是有限的。
- en: Not only that, but logs are frequently filtered to display only errors and similar
    problems, not minor discrepancies. A properly written APT program shouldn't be
    causing such errors, so they wouldn't be detected by a normal log review. One
    possible way to do this is to write the malware to use the tools that are already
    installed on the target system, so malware use will be hidden within the normal,
    expected traffic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，日志通常会被过滤，只显示错误和类似问题，而不是微小的差异。一个编写良好的APT程序不应该导致此类错误，因此它们不会被正常的日志审查所检测。一种可能的方法是将恶意软件编写为使用目标系统上已经安装的工具，这样恶意软件的使用就会隐藏在正常的、预期的流量中。
- en: Python and security
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python和安全
- en: 'Python is popular for security purposes, both positive and negative, as it
    is commonly found on servers, as well as developer machines. It allows for the
    ability to execute code without having to use pre-compiled binaries, and it has
    zero internal auditing. For example, `launch_malware.py` (provided within the
    PEP) shows how easy it is to download, decrypt, and execute malicious software
    using a single Python command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python因其常见于服务器和开发机器而受到安全目的的欢迎，无论是积极的还是消极的。它允许执行代码而无需使用预编译的二进制文件，并且没有内部审计。例如，`launch_malware.py`（在PEP中提供）展示了使用单个Python命令下载、解密和执行恶意软件是多么容易：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code tells the Python interpeter to execute the command that is provided.
    That command imports two libraries (`urllib.request` and `base64`*)*, then tells
    the system to execute a command that was decoded from a `base64`-encoded file
    that is downloaded from a web site.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码告诉Python解释器执行提供的命令。该命令导入两个库（`urllib.request`和`base64`*），然后告诉系统执行从网站下载的`base64`编码文件解码后的命令。
- en: Currently, most security-scanning tools that rely on signature files or otherwise
    recognizable code will not register this command as malicious, as `base64` encoding
    is frequently good enough to fool these systems. Because there is no file access,
    and assuming that Python is listed as an approved system application that is allowed
    to access the network and internet, this command would bypass any checks to block
    file access, check permissions, automated auditing and login, and verification
    of approved applications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数依赖于签名文件或其他可识别代码的安全扫描工具不会将此命令识别为恶意，因为`base64`编码通常足以欺骗这些系统。由于没有文件访问，并且假设Python被列为允许访问网络和互联网的批准系统应用程序，此命令将绕过任何阻止文件访问、检查权限、自动审计和登录以及验证批准应用程序的检查。
- en: Because no system is 100% secure, especially if it has to communicate to other
    systems, many security professionals assume their systems have been attacked but
    they just haven't discovered the attacks yet. Hence, detection, tracking, and
    removal of malware is the main focus of security activities. This is where Python
    comes in; the ability to see what the Python runtime interpreter is doing at any
    given time can help indicate whether malicious, or at least unusual, activity
    is occurring.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有系统是100%安全的，特别是如果它必须与其他系统通信，许多安全专家假设他们的系统已经被攻击，但他们还没有发现攻击。因此，检测、跟踪和移除恶意软件是安全活动的主要焦点。这就是Python发挥作用的地方；能够看到Python运行时解释器在任何给定时间正在做什么可以帮助指示是否正在发生恶意或至少异常的活动。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The core part of this PEP is the introduction of two APIs that enable sysadmins
    to integrate Python into their security setup. The key factor is that these APIs
    don''t impose certain restrictions on how the systems should be configured, or
    their behavior:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本PEP的核心是引入了两个API，使系统管理员能够将Python集成到他们的安全设置中。关键因素是这些API不对系统的配置或行为施加某些限制：
- en: The audit hook API allows operations to generate messages and pass them up the
    stack to the operator. These operations are normally buried within the Python
    runtime or standard library, preventing normal access to them, such as module
    imports, DNS resolution, or dynamic code compilation.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审计钩子API允许操作生成消息并将它们传递到堆栈上的操作员。这些操作通常被埋藏在Python运行时或标准库中，防止正常访问它们，例如模块导入、DNS解析或动态代码编译。
- en: 'The following code shows how the PEP defines the API in the C code underlying
    Python. The new Python APIs for audit hooks are shown in `audit_hook_api.py`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了PEP如何在Python的底层C代码中定义API。新的Python审计钩子API显示在`audit_hook_api.py`中：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An audit hook is added by calling `sys.addaudithook()` in Python code, or `PySys_AddAuditHook()`
    for a lower-level call to the C code. Hooks cannot be deleted or replaced. Existing
    hooks are cognizant of auditing, so adding a new hook (which is audited) can cause
    an existing hook to raise an exception if it is attempted to add a new hook:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Python代码中调用`sys.addaudithook()`或在C代码的底层调用`PySys_AddAuditHook()`，可以添加审计钩子。钩子不能被删除或替换。现有的钩子了解审计，因此添加新的钩子（也是被审计的）可能会导致现有的钩子抛出异常，如果尝试添加新的钩子：
- en: When something of interest occurs, `sys.audit()` is called. The string argument
    is the name of the event, and the remaining arguments are whatever the developer
    determines to be necessary to provide for auditing.
  id: totrans-160
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生感兴趣的事情时，调用`sys.audit()`。字符串参数是事件的名称，其余参数是开发者认为为审计所必需的任何内容。
- en: During auditing, each hook is reviewed in a FIFO manner. If a hook returns an
    exception, later hooks are ignored, and the Python interpreter should quit (generally
    speaking). Of course, the developer is free to determine what happens when an
    exception occurs, such as logging the event, aborting the operation, or killing
    the process.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在审计过程中，每个钩子以先进先出（FIFO）的方式被审查。如果钩子返回异常，则忽略后续的钩子，Python解释器应该退出（一般来说）。当然，开发者可以自由决定异常发生时会发生什么，例如记录事件、中止操作或终止进程。
- en: If no hooks have been set when an audit occurs, nothing much should happen.
    The audit call should have a minimal effect on the system, as the arguments should
    just be references to existing data, rather than calculations.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在审计发生时没有设置任何钩子，则不会发生太多事情。审计调用应该对系统的影响最小，因为参数应该是现有数据的引用，而不是计算。
- en: Since hooks may be Python objects, they need to be freed when the `finalize`
    function is called. In addition to releasing hooks, `finalize` will also relinquish
    any heap memory used. While it is a private function, it does trigger an event
    for all audit hooks, to ensure unexpected calls are logged.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于钩子可能是 Python 对象，因此在调用 `finalize` 函数时需要释放它们。除了释放钩子之外，`finalize` 还将释放任何使用的堆内存。虽然这是一个私有函数，但它确实触发了所有审计钩子的事件，以确保记录意外的调用。
- en: The verified open hook API is designed to provide a way to identify files that
    can be executed versus those that cannot. Obviously, this is an important feature
    for security systems to prevent executing commands, code, or data that shouldn't
    be allowed to run in a particular environment. The following code defines the
    C code for the API.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证开放钩子 API 设计为提供一种方法来识别可执行文件与不可执行文件。显然，这对于安全系统来说是一个重要功能，可以防止执行在特定环境中不应允许运行的命令、代码或数据。以下代码定义了
    API 的 C 代码。
- en: 'The Python API for the verified open hook is shown in `hook_handler_api.py`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 验证开放钩子的 Python API 显示在 `hook_handler_api.py` 中：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Python API function is designed to be a complete replacement for `open(str(path),
    "rb")`, and its default behavior is to open a file for binary read-only access.
    When the function is called with a hook that is set, the hook will receive the
    path argument and immediately return its value, which should be an open, file-like
    object that reads raw bytes.
  id: totrans-167
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python API 函数旨在完全替代 `open(str(path), "rb")`，其默认行为是以二进制只读方式打开文件。当函数调用时设置钩子，钩子将接收路径参数并立即返回其值，该值应该是一个打开的、类似文件的对象，用于读取原始字节。
- en: This design is to allow a `BytesIO` instance if the file has already been read
    into memory, to perform any necessary verification regarding whether the file
    content is allowed to be executed. If it is determined that the file shouldn't
    be executed, an exception is raised by the hook, as well as any additional auditing
    messages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计允许在文件已被读入内存的情况下使用 `BytesIO` 实例，执行有关文件内容是否允许执行所需的任何验证。如果确定文件不应执行，钩子将引发异常，以及任何额外的审计消息。
- en: All import and execution functionality involving code files will be changed
    to use `open_for_import()`. However, it is important to note that any calls to
    `compile()`*,* `exec()`*,* and `eval()` will not use this function; a specific
    audit hook, including the code from these calls, is necessary to validate the
    code. Most imported code will go through the API for `compile()`, so redundant
    verification should be avoided.
  id: totrans-169
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有涉及代码文件的导入和执行功能都将更改为使用 `open_for_import()`。然而，重要的是要注意，对 `compile()`、`exec()`
    和 `eval()` 的任何调用都不会使用此函数；需要特定的审计钩子，包括这些调用中的代码，以验证代码。大多数导入的代码将通过 `compile()` 的
    API 进行，因此应避免重复验证。
- en: PEP 543 – Unified TLS API
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 543 – 统一 TLS API
- en: PEP 543 was introduced in October, 2016, for Python version 3.7, and is still
    in *Draft* status. Its goal is to define a standard TLS interface for Python,
    as a collection of abstract base classes. This interface would allow Python to
    bind to TLS libraries other than OpenSSL, to reduce dependence on the OpenSSL
    environment. By using abstract classes, programs can still use the Python interface
    for the standard `ssl` module, while actually using a different security library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 543 于 2016 年 10 月推出，用于 Python 3.7 版本，目前仍处于 *草案* 状态。其目标是定义一个标准的 TLS 接口，作为一系列抽象基类。此接口将允许
    Python 绑定到除 OpenSSL 之外的其他 TLS 库，以减少对 OpenSSL 环境的依赖。通过使用抽象类，程序仍然可以使用标准 `ssl` 模块的
    Python 接口，同时实际上使用不同的安全库。
- en: With the `ssl` module as a part of the Python standard library, it naturally
    has become the go-to tool for TLS encryption. However, some developers would prefer
    to use a different library other than OpenSSL, and incorporating these alternate
    libraries into their programs requires them to learn how to do it effectively,
    while maintaining a cohesive experience for the target platform.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `ssl` 模块成为 Python 标准库的一部分，它自然地成为了 TLS 加密的首选工具。然而，一些开发者可能更愿意使用除 OpenSSL 之外的其他库，将这些替代库集成到他们的程序中需要他们学习如何有效地进行操作，同时保持目标平台的一致体验。
- en: 'The following is a list of problems with the current Python TLS configuration:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前 Python TLS 配置存在的问题：
- en: Improvements in OpenSSL, such as higher-security TLS, cannot be easily accomplished
    without recompiling Python to use the new OpenSSL version. There are third-party
    bindings to OpenSSL, but using them requires adding another level of compatibility
    into a program.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不重新编译 Python 使用新的 OpenSSL 版本的情况下，无法轻松实现 OpenSSL 的改进，如更高安全的 TLS。存在对 OpenSSL
    的第三方绑定，但使用它们需要在程序中添加另一个兼容性层级。
- en: The Windows OS does not include a copy of OpenSSL, so any Python distributions
    need to include OpenSSL to ensure its availability to developers and users. This
    turns the Python dev team into OpenSSL redistributors, with all the responsibilities
    associated with that role, such as ensuring security updates are delivered when
    OpenSSL vulnerabilities are discovered.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 操作系统不包含 OpenSSL 的副本，因此任何 Python 发行版都需要包含 OpenSSL 以确保其对开发者和用户可用。这使得 Python
    开发团队成为 OpenSSL 的重新分发者，并承担与该角色相关的所有责任，例如确保在发现 OpenSSL 漏洞时提供安全更新。
- en: macOS is in a similar situation. Python distributions either need OpenSSL included
    with them, like Windows, or need to be linked to the OS-level OpenSSL library.
    Unfortunately, Apple has deprecated linking to the OS library, and the library
    itself has been unsupported for several years. At this point, the only thing to
    do is provide OpenSSL with Python for macOS, which leads to the same problems
    as on Windows.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 处于类似的情况。Python 发行版要么需要包含 OpenSSL，就像 Windows 一样，要么需要链接到操作系统级别的 OpenSSL
    库。不幸的是，苹果已经弃用了链接到操作系统库的方式，并且该库本身已经停止支持多年。此时，唯一能做的就是为 macOS 提供 Python 的 OpenSSL，这会导致与
    Windows 上相同的问题。
- en: Many OSes do not allow their system encryption certificate databases to be accessed
    by OpenSSL. This requires users to either look for alternate locations to get
    their root-level trust certificates, or to export the OS certificates to OpenSSL.
    Even if OpenSSL is able to access the system-level certs, validation checks may
    be different between the libraries, resulting in unexpected behavior when using
    native tools.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多操作系统不允许 OpenSSL 访问其系统加密证书数据库。这要求用户要么寻找其他位置以获取其根级信任证书，要么将操作系统证书导出到 OpenSSL。即使
    OpenSSL 能够访问系统级证书，库之间的验证检查可能不同，在使用原生工具时可能导致意外行为。
- en: For users and developers who would prefer to use alternative TLS libraries,
    such as for support for TLS 1.3 or for embedded implementations of Python, the
    primary option is to use third-party libraries to interface with their TLS library
    of choice, or to figure out how to force their selected library into Python's
    `ssl` module API.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于希望使用替代 TLS 库的用户和开发者，例如支持 TLS 1.3 或 Python 的嵌入式实现，主要选项是使用第三方库来与其选择的 TLS 库进行接口，或者找出如何强制所选库进入
    Python 的 `ssl` 模块 API。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The PEP proposes several new abstract base classes, and an interface that accesses
    these classes. They can be used to access TLS functionality without being tightly
    linked to OpenSSL:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 提出了几个新的抽象基类，以及一个访问这些类的接口。它们可以用来访问 TLS 功能，而无需紧密绑定到 OpenSSL：
- en: 'The following interfaces, currently used by Python, require standardization:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是由 Python 当前使用的接口，需要标准化：
- en: Configuring TLS, currently set by the `ssl.SSLContext` class.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 TLS，目前由 `ssl.SSLContext` 类设置。
- en: In-memory buffer for encryption/decryption without actual I/O, currently set
    by the `ssl.SSLObject` class.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于加密/解密的无实际 I/O 的内存缓冲区，目前由 `ssl.SSLObject` 类设置。
- en: Wrapping a socket object, currently done via `ssl.SSLSocket`.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装套接字对象，目前通过 `ssl.SSLSocket` 实现。
- en: Putting the TLS configuration to the wrapper objects indicated previously, currently
    done by `ssl.SSLContext`.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 TLS 配置放入之前指示的包装对象中，目前通过 `ssl.SSLContext` 实现。
- en: Specifying the TLS cipher suites, currently handled by using the OpenSSL cipher
    suite strings.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 TLS 密码套件，目前通过使用 OpenSSL 密码套件字符串处理。
- en: Specifying application-layer protocols for the TLS handshake.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 TLS 握手的应用层协议。
- en: Specifying TLS versions.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 TLS 版本。
- en: Reporting errors to the calling function, currently done via `ssl.SSLError`.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向调用函数报告错误，目前通过 `ssl.SSLError` 实现。
- en: Specifying the client/server certificates to load.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要加载的客户端/服务器证书。
- en: Specifying the trust database to use when validating certificates.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定在验证证书时使用的信任数据库。
- en: Accessing these interfaces at runtime.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时访问这些接口。
- en: In light of the buffers and sockets mentioned in the preceding list, the PEP
    aims to provide an abstract base class for wrapped buffers, but a concrete class
    for wrapped sockets.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于前面提到的缓冲区和套接字，这个 PEP 旨在提供一个包装缓冲区的抽象基类，但对于包装套接字则提供一个具体类。
- en: This creates the problem that a small number of TLS libraries won't be able
    to be bound to the abstract class, because those libraries can't provide a wrapped
    buffer implementation, such as an I/O abstraction layer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个问题，即少数 TLS 库无法绑定到抽象类，因为这些库无法提供包装缓冲区实现，例如 I/O 抽象层。
- en: When specifying TLS cipher suites, abstract classes won't work. So, this PEP
    aims to provide a better API for cipher suite configuration, which can be updated
    to support different cipher suites based on the necessary implementation.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定 TLS 加密套件时，抽象类不会工作。因此，这个 PEP 的目标是提供一个更好的 API 用于加密套件配置，可以根据必要的实现更新以支持不同的加密套件。
- en: 'When specifying the client/server certificates to load, a problem comes from
    the possibility that the private certificate key could become available in memory;
    that is, it could potentially be extracted from process memory. Thus, the certificate
    model needs to allow for implementations to provide a higher level of security
    by preventing key extraction, while also allowing for implementations that cannot
    meet the same requirements. The lower standard would simply maintain the current
    methodology: loading the certificate from in-memory buffer or from a file.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当指定要加载的客户端/服务器证书时，问题来自于私钥证书可能成为内存中的可能；也就是说，它可能从进程内存中提取出来。因此，证书模型需要允许实现提供更高层次的安全性，通过防止密钥提取，同时允许无法满足相同要求的实现。较低的标准将简单地维持当前的方法：从内存缓冲区或从文件中加载证书。
- en: Specifying a trust database is difficult, because different TLS implementations
    vary in how they allow users to select their trust stores. Some implementations
    use specified formats only used by that particular implementation, while others
    may not allow for specifying stores that don't include their default trust store.
    Therefore, this PEP defines a trust store model that requires little information
    regarding the form of the store.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定信任数据库很困难，因为不同的 TLS 实现允许用户选择他们的信任存储的方式各不相同。一些实现仅使用特定实现专用的指定格式，而其他实现可能不允许指定不包括其默认信任存储的存储库。因此，这个
    PEP 定义了一个信任存储模型，该模型对存储的形式要求很少信息。
- en: Because `ssl.SSLContext` manages different features (holding and managing configurations,
    as well as using configurations to build wrappers), it is proposed to split these
    responsibilities into separate objects.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `ssl.SSLContext` 管理不同的功能（持有和管理配置，以及使用配置来构建包装器），因此建议将这些责任分割成单独的对象。
- en: The `ssl` module provides a server with the ability to modify the TLS configuration
    in response to a client's request for a hostname. This allows the server to change
    the certificate chain to match the chain needed for the hostname.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssl` 模块提供了一个服务器，它能够根据客户端对主机名的请求修改 TLS 配置。这允许服务器更改证书链以匹配所需的主机名证书链。'
- en: However, this method doesn't work for other TLS implementations. Those ones
    frequently provide a return value from the callback, indicating which configuration
    changes need to be made. This requires an object that can accept and hold the
    TLS configuration.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法不适用于其他 TLS 实现。那些实现通常从回调中返回一个值，指示需要做出哪些配置更改。这需要一个可以接受并持有 TLS 配置的对象。
- en: 'Therefore, the PEP proposes splitting `SSLContext` into separate objects: `TLSConfiguration`
    acts as a container for the configuration, while the `ClientContext` and `ServerContext`
    objects are instantiated by `TLSConfiguration`*.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个 PEP 提出将 `SSLContext` 分割成单独的对象：`TLSConfiguration` 作为配置的容器，而 `ClientContext`
    和 `ServerContext` 对象由 `TLSConfiguration` 实例化*。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The PEP goes into further detail on how the API would actually be implemented,
    examples of how different TLS libraries provide the same functionality, and so
    on. There are a lot of details that aren't relevant to this book, but for those
    readers interested in utilizing TLS libraries in their projects, the details are
    worth reviewing, as the changes should be showing up in a future version of Python.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PEP 进一步详细说明了 API 的实际实现方式，不同 TLS 库提供相同功能的示例，等等。有许多与本书无关的细节，但对于那些希望在项目中使用 TLS
    库的读者来说，这些细节值得审查，因为这些更改应该会在 Python 的未来版本中显示出来。
- en: Documenting with LyX
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LyX 进行文档编写
- en: 'This chapter will cover Python documentation. Specifically, we will discuss
    how to document code, both within your program and through external documents.
    We will cover:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖Python文档。具体来说，我们将讨论如何在程序内部和通过外部文档记录代码。我们将涵盖：
- en: Python documentation tools and techniques
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文档工具和技术
- en: In-line comments and the `dir` command
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行内注释和`dir`命令
- en: Using docstrings
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用docstrings
- en: Using PyDoc help
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyDoc帮助
- en: HTML reports
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML报告
- en: Using `reStructuredText` files
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reStructuredText`文件
- en: Using the Sphinx documentation program
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sphinx文档程序
- en: Using the LaTeX and LyX document preparation programs
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LaTeX和LyX文档准备程序
- en: Introduction
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Documenting code is the bane of many a programmer's existence. While code documentation
    is important, some programmers prefer to leave that work to technical writers.
    Others will provide a bare minimum of information, sometimes as README files or
    other external documents. Generally speaking, unless a program is supported by
    a company or organization, homebrew software has just enough information to tell
    you how to use it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码是许多程序员的噩梦。虽然代码文档很重要，但一些程序员更喜欢将这项工作留给技术作家。其他人会提供最少的信息，有时是作为README文件或其他外部文档。一般来说，除非程序由公司或组织支持，否则自制的软件只需提供足够的信息来告诉用户如何使用它。
- en: To be honest, some documentation comes across as being notes from the development
    timeline, rather than useful documentation. Many authors give up on installing
    a program because the documentation is inadequate, particularly when troubleshooting
    a bad install.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，一些文档看起来像是开发时间线上的笔记，而不是有用的文档。许多作者因为文档不充分而放弃安装程序，尤其是在调试不良安装时。
- en: Python documentation tools and techniques
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python文档工具和技术
- en: When writing code documentation, there are a number of tools and techniques
    to choose from. In this section, we will discuss some of the most common methods
    used by developers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码文档时，有众多工具和技术可供选择。在本节中，我们将讨论开发者们常用的几种常见方法。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '**Code obfuscation**: First, a quick diversion into how to make your code difficult
    to read. There are valid reasons to obfuscate your code and make it difficult
    to read, such as attempting to prevent reverse-engineering. Other people just
    like the challenge; consider the International Obfuscated C Code Contest ([http://ioccc.org](http://ioccc.org)).'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码混淆**：首先，简要介绍一下如何使代码难以阅读。混淆代码并使其难以阅读有合理的理由，例如尝试防止逆向工程。其他人只是喜欢挑战；可以考虑国际混淆C代码竞赛([http://ioccc.org](http://ioccc.org))。'
- en: On the other hand, making your code difficult to read can be an attempt to create
    malware that can bypass detection programs. One example is `JSF**k`, which converts
    JavaScript code into the atomic parts of JavaScript using only six different symbols,
    as shown in `jsf.js` from [http://www.jsfuck.com](http://www.jsfuck.com). The
    file demonstrates the obfuscated equivalent of `alert("This was a hidden message")`,
    but any valid JavaScript code can be replicated using the `JSF**k` utility. As
    a matter of fact, jQuery has been encoded into a fully-functional, drop-in replacement
    `JSF**k` version (jQuery Screwed), using only the six characters available.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使代码难以阅读可能是创建可以绕过检测程序的恶意软件的尝试。一个例子是`JSF**k`，它仅使用六个不同的符号将JavaScript代码转换为JavaScript的原子部分，如[http://www.jsfuck.com](http://www.jsfuck.com)中的`jsf.js`所示。该文件展示了`alert("This
    was a hidden message")`的混淆等效代码，但任何有效的JavaScript代码都可以使用`JSF**k`实用程序进行复制。实际上，jQuery已经被编码成一个功能齐全的、即插即用的`JSF**k`版本（jQuery
    Screwed），仅使用六个可用的字符。
- en: '**Code as documentation**: Code as documentation is probably the most basic
    level of documentation available, as it requires no additional information to
    be included, besides the code itself. Naturally, this requires the code to be
    written in a manner that makes it readily apparent what the code is doing and
    how it does it.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码作为文档**：代码作为文档可能是最基础的文档形式，因为它除了代码本身外不需要包含任何额外信息。自然地，这要求代码以使代码所执行的操作及其方式一目了然的方式进行编写。'
- en: 'While every language, theoretically, is capable of self-documenting itself,
    some are worse than others. Perl is commonly cited as a bad language, as it was
    designed to be quick to write scripts, but in a very concise manner; if a lot
    of effort was made initially, it will pay off later by making it easier to write
    programs (compared to writing a simple script in C). As such, if you aren''t familiar
    with Perl, even a non-obfuscated script can be nearly impossible to read; see
    this example of Perl code (`perl_interactive.pl`):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，每种语言都有能力自我文档化，但有些语言比其他语言更差。Perl 通常被引用为一个糟糕的语言，因为它被设计成快速编写脚本，但方式非常简洁；如果一开始投入大量努力，那么在编写程序时将会得到回报（与用
    C 语言编写简单脚本相比）。因此，如果你不熟悉 Perl，即使是未加密的脚本也可能几乎无法阅读；请参见以下 Perl 代码示例 (`perl_interactive.pl`)：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code creates a Perl interactive shell. Because Perl doesn't have
    an interactive interpreter like Python, you have to coerce the system to create
    one for you. As mentioned, if you don't know how to read Perl, it doesn't provide
    you with any help.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个 Perl 交互式外壳。因为 Perl 没有像 Python 那样的交互式解释器，你必须说服系统为你创建一个。正如之前提到的，如果你不知道如何阅读
    Perl，它不会为你提供任何帮助。
- en: Source code should be easily readable on its own, as it is the only true representation
    of your program; everything else is subject to human forgetfulness, as it is more
    likely to not be updated when the code is modified. This means using intelligent
    names for variables, functions, and so on; they should be indicative of what they
    do. This way, even with no other information, someone reading it can at least
    make a guess as to what the code is supposed to do.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码应该能够独立阅读，因为它是程序的唯一真实表示；其他一切都是受人类遗忘的影响，因为当代码被修改时，它们更有可能不会被更新。这意味着使用智能名称为变量、函数等命名；它们应该表明它们的作用。这样，即使没有其他信息，阅读它的人至少可以猜测代码预期要做什么。
- en: '**Comments**: To this author, in-line comments are the minimum level of effort
    when it comes to documenting code. Unfortunately, too many online code samples
    don''t have comments, forcing the reader to either look at external documentation
    or manually parse out what the code is doing.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注释**：对于本文作者来说，内联注释是编写代码时文档化的最低努力水平。不幸的是，太多的在线代码示例没有注释，迫使读者要么查看外部文档，要么手动解析代码的功能。'
- en: Online debates have occurred regarding comments, as some other programmers don't
    believe in comments, thinking that code should be self-documenting. Others feel
    that a simple, one-line comment explaining what a function is supposed to be doing
    is much easier and quicker to read and understand than spending ten minutes walking
    the code, especially if the original developer aimed to get the job done in as
    few lines as possible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于注释的在线辩论已经发生，因为一些程序员不相信注释，认为代码应该是自我文档化的。其他人则认为，一个简单的一行注释解释函数应该做什么，比花十分钟阅读代码更容易、更快地阅读和理解，尤其是如果原始开发者旨在用尽可能少的行数完成任务。
- en: '**dir command**: While not something a programmer does directly, Python allows
    the use of the `dir` command to list all of the functions and attributes available
    for a given module. Thus, using intelligent names for these items means that a
    simple `dir` call can provide a lot of information quickly.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**dir 命令**：虽然程序员不会直接使用它，但 Python 允许使用 `dir` 命令列出给定模块中所有可用的函数和属性。因此，为这些项目使用智能名称意味着简单的
    `dir` 调用可以快速提供大量信息。'
- en: '**Docstrings**: Docstrings are the lifeblood of Python documentation. They
    provide in-code documentation about the code, such as specifications of what parameters
    a function receives and what it returns when called. They also provide a brief
    synopsis of what each part of the code is supposed to do, in plain language.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Docstrings**：Docstrings 是 Python 文档的生命线。它们提供了关于代码的代码内文档，例如函数接收的参数和被调用时返回的内容的规范。它们还提供了代码每个部分预期要做什么的简要概述，用普通语言表达。'
- en: '**PyDoc**: PyDoc is a built-in Python tool-set that leverages docstrings to
    provide useful information to the user. It is most easily utilized when calling
    `help(<object>)`.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PyDoc**：PyDoc 是一个内置的 Python 工具集，它利用 docstrings 为用户提供有用的信息。在调用 `help(<对象>)`
    时，它最容易使用。'
- en: The preceding list isn't all-inclusive, but it does cover the features we will
    discuss in the rest of this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并不全面，但它确实涵盖了本章剩余部分我们将要讨论的功能。
- en: Inline comments and the dir command
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联注释和 dir 命令
- en: The simplest and most common way to document code is to simply add comments
    while writing the code. This can range from simple `TODO` reminders for the developers,
    to an explanation of why the developer coded something in a particular way.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码最简单和最常见的方式就是在编写代码时添加注释。这可以是从简单提醒开发者注意的`TODO`到解释开发者为何以特定方式编写代码的解释。
- en: As seen previously, comments in Python code start with a hash mark, `#`, and
    continue to the end of the line. Multi-line comments can be made by adding a hash
    mark at the beginning of each line, or triple quotation marks can be used instead.
    Keep in mind, though, that certain tools don't know about triple-quoted comments,
    so it's better to use them sparingly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python代码中的注释以井号`#`开头，并持续到行尾。多行注释可以通过在每行开头添加井号或使用三引号来实现。然而，请注意，某些工具不了解三引号注释，因此最好谨慎使用。
- en: The problem with in-line comments is that they can only be seen if you are actively
    looking at the code. While we will discuss ways to access in-code comments, these
    basic one-liners are not actively culled by documentation parsers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 行内注释的问题在于，只有当你主动查看代码时才能看到它们。虽然我们将讨论访问代码注释的方法，但这些基本的单行注释不会被文档解析器主动提取。
- en: 'If, however, you want to see what functions a module provides to the developer,
    using the `dir()` function is one easy way of doing that. The following is information
    about what the `dir()` function provides:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想查看模块提供给开发者的函数，使用`dir()`函数是一种简单的方法。以下是一些关于`dir()`函数提供的信息：
- en: '![](img/12509504-eb12-4004-aab4-cc88734aa852.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12509504-eb12-4004-aab4-cc88734aa852.png)'
- en: 'The following example shows `dir()` being used to show all of the functions
    available within the `math` module (which must be imported first):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用`dir()`来显示`math`模块（必须先导入）中所有可用的函数：
- en: '![](img/f7378978-e599-4083-800d-9f225208a10a.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7378978-e599-4083-800d-9f225208a10a.png)'
- en: There isn't a lot of extremely useful information when using `dir()`, but it
    can help if you only need to know what functions and attributes are available
    to you, without having to dig into more detailed documentation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dir()`时，并没有很多非常有用的信息，但如果只需要知道可用的函数和属性，而不必深入研究更详细的文档，它可能会有所帮助。
- en: This is a good time to review how Python uses underscores. Entries with two
    leading underscores, such as `__doc__` from the screenshot, are attributes associated
    with the Python interpreter, and should not normally be directly called by the
    developer. Also, since they are predefined for Python's use, their names shouldn't
    be reused for a different purpose within a program. For example, using `__name__`
    as a variable name can result in program errors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好时机来回顾Python如何使用下划线。例如，截图中的`__doc__`这样的条目是与Python解释器关联的属性，通常不应由开发者直接调用。此外，由于它们是为Python的使用预定义的，因此它们的名称不应在程序中用于其他目的。例如，使用`__name__`作为变量名可能会导致程序错误。
- en: Single leading underscores indicate pseudo-private items. Because Python doesn't
    have public/private attributes like other languages, programmers have to be a
    little more cognizant of what they are trying to do. Pseudo-private items can
    be used like normal items; the underscore simply tells anyone looking at the code
    that the pseudo-private items shouldn't be used outside their intended area.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 单个前导下划线表示伪私有项。由于Python不像其他语言那样有公共/私有属性，程序员必须更加注意他们试图做什么。伪私有项可以像普通项一样使用；下划线只是告诉查看代码的人，伪私有项不应在它们预期之外的区域使用。
- en: 'In addition, pseudo-private items won''t be imported when using `from <module>
    import *`. This is part of their private nature. They will, however, be imported
    when using `import <module>`. Thus, to ensure all functions and attributes are
    available to you when importing a module, you need to use the regular `import`.
    Of course, accessing those items will require you to clarify them using dot-nomenclature:
    `<module>.<item>`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，伪私有项在使用`from <module> import *`时不会被导入。这是它们私有性质的一部分。然而，当使用`import <module>`时，它们将被导入。因此，为了确保在导入模块时所有函数和属性都可用，需要使用常规的`import`。当然，访问这些项需要使用点命名法来明确它们：`<module>.<item>`。
- en: Using docstrings
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文档字符串
- en: Docstrings are triple-quoted strings that have special significance within Python.
    When used, they form the `__doc__` attribute of an object. While not using docstrings
    is fine, and there are many examples of projects that don't have them if you do
    use them, it is worth looking at PEP 257 to see how to do them right. While violating
    the guidelines in the PEP won't hurt your code but may make other programmers
    question you, it will really hurt if you try to use tools such as Docutils, as
    they expect docstrings to be properly formatted.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串是具有特殊意义的Python中的三引号字符串。当使用时，它们形成对象的`__doc__`属性。虽然不使用文档字符串是可以的，而且如果你使用它们，有很多项目没有文档字符串的例子，但查看PEP
    257以了解如何正确使用它们是值得的。虽然违反PEP中的指南不会损害你的代码，但可能会让其他程序员质疑你，但如果你尝试使用像Docutils这样的工具，这将会真正造成伤害，因为它们期望文档字符串格式正确。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Docstrings are the very first items in a module, function, class, or method;
    if they are put elsewhere, chances are, tools that won't recognize them as docstrings.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串是一个模块、函数、类或方法中的第一个项目；如果它们放在其他地方，那么这些工具可能不会将它们识别为文档字符串。
- en: 'Docstrings can be single or multi-line, as shown in the following, `docstring_example.py`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串可以是单行或多行的，如下面的`docstring_example.py`所示：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By convention, single-line docstrings are for obvious use cases. The reason
    triple quotes are used, even for one line, is to easily allow for future expansion
    of the docstring, if needed.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，单行文档字符串用于明显的用例。即使是一行，也使用三引号的原因是，如果需要，可以轻松地扩展文档字符串。
- en: A single-line docstring should be considered a summary statement of the object
    and should end with a period, as it should describe what the object does, that
    is, *Does this* or *Returns this*. They shouldn't be a description of the action;
    for example, *Returns the pathname of the root-level object*.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单行文档字符串应被视为对象的总结语句，并以句号结束，因为它应该描述对象做什么，即*这是做什么*或*返回这个*。它们不应该是动作的描述；例如，*返回根级别对象的路径名*。
- en: You'll note that, in the preceding example, both docstrings failed to follow
    this guidance. As these are guidelines and not hard-and-fast rules, this is allowed.
    This author just feels more comfortable explaining what is going on within the
    docstring, even if it is redundant to the actual code. This comes back to the
    fact that it is easier to read what something does and then see the code that
    implements it, than having to decipher exactly what the code is supposed to do.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前面的例子中，这两个文档字符串都没有遵循这一指导原则。因为这些是指导原则而不是铁的规则，所以这是允许的。这位作者只是觉得在文档字符串中解释正在发生的事情更舒服，即使它与实际代码重复。这回到了这样一个事实，即阅读某物做什么然后看到实现它的代码比试图确切地弄清楚代码应该做什么要容易得多。
- en: 'Multi-line docstrings have the summary statement, just like single-line docstrings,
    but then they continue with more information. The additional information can be
    anything the programmer feels is important, though PEP 257 provides guidelines
    for different objects. These are paraphrased in the following for one-stop-shopping:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多行文档字符串有总结语句，就像单行文档字符串一样，但随后会继续提供更多信息。这些附加信息可以是程序员认为重要的任何内容，尽管PEP 257为不同的对象提供了指南。以下是对这些指南的概述，以便一站式购物：
- en: Class docstrings should have one blank line between the end of the docstring
    and the first method. They should summarize the class's behavior, and list both
    public methods and instance variables.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类文档字符串应该在文档字符串的结尾和第一个方法之间有一个空行。它们应该总结类的行为，并列出公共方法和实例变量。
- en: If the class will be subclassed, and there is an interface for the subclasses,
    the subclass interface should be listed separately in the docstring. The class
    constructor should have its own docstring in the `__init__` method.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类将被子类化，并且有子类接口，则应在文档字符串中单独列出子类接口。类构造函数应在`__init__`方法中拥有自己的文档字符串。
- en: If a class is a subclass of another and primarily inherits its behavior, the
    subclass's docstring should indicate this and show the differences. The word `override`
    should be used to indicate where a subclass method replaces an inherited method.
    The word `extend` should indicate where a subclass method calls an inherited method
    and adds functionality.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类是另一个类的子类并且主要继承其行为，子类的文档字符串应该表明这一点并显示差异。使用“覆盖”一词来表示子类方法替换继承方法的地方。使用“扩展”一词来表示子类方法调用继承方法并添加功能的地方。
- en: Module docstrings should list the classes, exceptions, functions, and other
    objects that are exportable, with a one-line summary of each.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文档字符串应列出可导出的类、异常、函数和其他对象，并对每个对象提供一行总结。
- en: Package docstrings (located in the `__init__.py` module for the package) should
    list the modules and subpackages exported by the package.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包文档字符串（位于包的`__init__.py`模块中）应列出包导出的模块和子包。
- en: Function/method docstrings should summarize behavior and document all arguments
    (required and optional), return values, side-effects, exceptions, and restrictions
    on when the function or method can be called. Any keyword arguments should also
    be noted.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法文档字符串应总结行为并记录所有参数（必需和可选）、返回值、副作用、异常以及函数或方法可以调用的限制。任何关键字参数也应予以说明。
- en: Another related part of docstrings are doctests. Doctests are actually handled
    by the `doctest` module, and look for texts within a docstring that look like
    interactive Python sessions, complete with the `>>>` prompt. Any such code is
    executed as it was entered by the user within an interactive shell, and compared
    to the expected results.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个与文档字符串相关的部分是doctests。实际上，doctests是由`doctest`模块处理的，并寻找文档字符串中看起来像交互式Python会话的文本，包括`>>>`提示符。任何这样的代码都会像用户在交互式外壳中输入一样执行，并与预期结果进行比较。
- en: 'Doctests are commonly used to ensure docstrings are kept up-to-date by testing
    that the examples work with any changes to the code itself—for regression testing
    by checking that test files still work, and in tutorial development that includes
    input/output examples. The following is an example of a doctest (`doctest.py`):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests通常用于确保文档字符串保持最新，通过测试示例是否与代码本身的任何更改兼容来做到这一点——通过回归测试检查测试文件是否仍然有效，以及在教程开发中包含输入/输出示例。以下是一个doctest（`doctest.py`）的示例：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One of the hardest parts is writing tests to simulate an interactive session,
    as the following screenshot demonstrates:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最难的部分是编写测试来模拟交互会话，如下面的截图所示：
- en: '![](img/42761ba9-f9ba-4636-8cc4-683a5f68cc79.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/42761ba9-f9ba-4636-8cc4-683a5f68cc79.png)'
- en: 'At first glance, it looks like it should be the same answer. The problem comes
    in lining up the `doctest` output with where it would be if the command was manually
    typed in. However, when the test is correctly written, an uninformative response
    is provided by the system, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它看起来应该给出相同的答案。问题在于将`doctest`输出与手动输入命令时的输出对齐。然而，当测试正确编写时，系统会提供一个无用的响应，如下所示：
- en: '![](img/f3051b4c-cbcd-4cea-bad5-be7a77f90ffa.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f3051b4c-cbcd-4cea-bad5-be7a77f90ffa.png)'
- en: 'This just means that all of the tests passed, much like how using the `unittest`
    module to create tests returns only a `.` for a successful test. To get something
    more meaningful, or to see how the test was conducted, you have to provide the
    `-v` option to the command, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着所有测试都通过了，就像使用`unittest`模块创建测试只返回一个`.`来表示成功的测试一样。要获得更有意义的结果，或者要查看测试是如何进行的，你必须向命令提供`-v`选项，如下所示：
- en: '![](img/4f31df96-1e60-45ed-b110-c66ce86dfae1.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4f31df96-1e60-45ed-b110-c66ce86dfae1.png)'
- en: There's a lot more to doctests than could be covered here, but what we covered
    is sufficient for most needs. The documentation goes into things such as pulling
    tests from external test files, rather than directly in line with the code; how
    to deal with exceptions; and similar material, as well as the backend details
    of how the doctest engine works.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所涵盖的doctests远不止这些，但对于大多数需求来说已经足够了。文档深入探讨了从外部测试文件中提取测试，而不是直接与代码同行；如何处理异常；以及类似的内容，以及doctest引擎的后端工作细节。
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following is a screenshot of the docstring for Python''s `random` module:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对Python的`random`模块文档字符串的截图：
- en: '![](img/a38f6110-6d85-4f9b-ae72-9aa3f9c43462.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a38f6110-6d85-4f9b-ae72-9aa3f9c43462.png)'
- en: 'This information doesn''t really tell you a lot about the module, as it is
    simply a description of it. To get more comprehensive information, you would have
    to use `help(random)`*,* as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息并不能真正告诉你很多关于模块的信息，因为它只是对它的描述。要获取更全面的信息，你必须使用`help(random)`*，如下所示：
- en: '![](img/3565ab9f-5817-442a-abb6-779a4451e062.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/3565ab9f-5817-442a-abb6-779a4451e062.png)'
- en: This listing actually continues on for more than 20 pages of formatted text,
    much like Unix `man` pages. But this is everything you need to know about a module
    and what it contains; so, if you happen to not have internet access but need to
    know how to use a Python module, this is one way of doing it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表实际上包含超过20页的格式化文本，就像Unix的`man`页面一样。但是，这里包含了你需要了解的关于模块及其包含内容的所有信息；因此，如果你没有互联网访问但需要了解如何使用Python模块，这是一种方法。
- en: 'You can also do this with individual elements within a module. For example,
    the following screenshot shows the results of `help(random.seed)`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对模块中的单个元素这样做。例如，以下截图显示了`help(random.seed)`的结果：
- en: '![](img/1723dfae-a334-45c4-8bbb-8e402d3467a1.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1723dfae-a334-45c4-8bbb-8e402d3467a1.png)'
- en: 'This same information is available by using `print(random.seed.__doc__)`, if
    you prefer that route:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种方式，可以使用`print(random.seed.__doc__)`来获取相同的信息：
- en: '![](img/036bc2b0-f510-48d8-bc4d-df127fb0fd8f.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/036bc2b0-f510-48d8-bc4d-df127fb0fd8f.png)'
- en: Using PyDoc help
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyDoc帮助
- en: If you use docstrings appropriately, you can harness the power of PyDoc, which
    is a built-in Python toolset that can extract docstrings and other information
    and format them into easy-to-read text. While there are many other tools available,
    PyDoc comes with Python, so you can be sure of it being available (as long as
    you have access to the Python standard library).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你适当地使用docstrings，你可以利用PyDoc的力量，这是一个内置的Python工具集，可以提取docstrings和其他信息，并将它们格式化为易于阅读的文本。虽然有许多其他工具可用，但PyDoc与Python一起提供，所以你可以确信它可用（只要你有访问Python标准库的能力）。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: PyDoc is accessed by using the `help()` function, as seen previously. While
    built-in objects can have multiple pages of information, your code doesn't have
    to be as elaborate, unless you want it to be. Depending on the Python version
    being used, you don't have to import the module you want help on, but it is generally
    better to import it, just to make sure.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，通过使用`help()`函数可以访问PyDoc。虽然内置对象可能有多个信息页面，但你的代码不必如此复杂，除非你希望它如此。根据使用的Python版本，你不需要导入你想要帮助的模块，但通常最好导入它，以确保。
- en: Looking back at the preceding `random()` example, you can see that a lot of
    information is available via `help()`; of course, it is all dependent on how much
    information the developer decides to put into the docstrings. Functionally, the
    output is very much like using the Unix `man` command to view online command manuals.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾先前的`random()`示例，你可以看到通过`help()`可以获得大量信息；当然，这完全取决于开发者决定放入docstrings中的信息量。从功能上讲，输出与使用Unix的`man`命令查看在线命令手册非常相似。
- en: 'One of the great things about `help()` is that it can be used on any Python
    object, not just modules, when calling `help(list)`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`help()`的一个优点是它可以用于任何Python对象，而不仅仅是模块，当调用`help(list)`时：'
- en: '![](img/a2829ffb-75b0-42b6-be9a-d30f9892cebd.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2829ffb-75b0-42b6-be9a-d30f9892cebd.png)'
- en: 'You can even look at the functions and methods that are included with a Python
    object, such as `help(list.pop)`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你甚至可以查看Python对象包含的函数和方法，例如`help(list.pop)`：
- en: '![](img/b058342b-d126-4e4f-96f8-e8169357ee11.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b058342b-d126-4e4f-96f8-e8169357ee11.png)'
- en: 'In addition to using the name of the object type (for example, `list`), you
    can even use the actual object structure, as shown with `help([].sort)`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '除了使用对象类型的名称（例如，`list`），你甚至可以使用实际的对象结构，如下所示：`help([].sort)`:'
- en: '![](img/c1dc3e3b-64cc-4fd2-b01c-fd94643352d2.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1dc3e3b-64cc-4fd2-b01c-fd94643352d2.png)'
- en: The preceding examples show why following the recommended docstring guidelines
    is so important. There is an expected way for the information to be displayed,
    and, as a developer, you don't know what methods users of your code will use to
    access the help features available for Python. At a minimum, internal consistency
    within your project is important, even if you don't follow the official Python
    guidelines.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先前的示例展示了遵循推荐的docstring指南为什么如此重要。信息展示有一个预期的格式，作为一个开发者，你不知道你的代码用户将使用什么方法来访问Python的帮助功能。至少，在你的项目中保持内部一致性是很重要的，即使你不遵循官方的Python指南。
- en: HTML reports
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML报告
- en: For people who prefer a more visual help tool, or prefer to keep a browser open,
    PyDoc includes the ability to create HTML files from the official Python documentation.
    Depending on the version of Python being used, there are several different ways
    to access the HTML information.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喜欢更直观的帮助工具，或者喜欢保持浏览器打开状态的人来说，PyDoc提供了从官方Python文档创建HTML文件的能力。根据使用的Python版本，有几种不同的方式可以访问HTML信息。
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Starting in Python 3.2, help web pages can be opened by using `python -m pydoc
    -b`. If you have both Python 2 and 3 installed, you can specify which Python version
    you desire to work with; for example, `python3 -m pydoc -b`*.* If you are using
    Python 2, then use the command `python -m pydoc -p <port>`. The port number can
    be 0, which will pick a random, unused port address for the web server.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Python 3.2 开始，可以使用 `python -m pydoc -b` 打开帮助网页。如果您同时安装了 Python 2 和 3，您可以指定您希望使用的
    Python 版本；例如，`python3 -m pydoc -b`*.* 如果您正在使用 Python 2，则使用命令 `python -m pydoc
    -p <端口号>`。端口号可以是 0，这将随机选择一个未使用的端口号作为 Web 服务器。
- en: 'Regardless of which version you use, it should open up a web page similar to
    the following screenshot:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论您使用哪个版本，它都应该打开一个类似于以下截图的网页：
- en: '![](img/1fc57159-1c5b-4926-9739-bf58db8746df.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fc57159-1c5b-4926-9739-bf58db8746df.png)'
- en: 'All of the modules available in Python are shown as hyperlinks. You can also
    search for entries via the *Search* box; alternatively, if you know the name of
    the module you''re interested in, enter it directly into the Get box. When clicking
    on the hyperlinks, you will get the same information provided on the Python website
    or by using the `help()` command, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 中所有可用的模块都显示为超链接。您也可以通过 *搜索* 框进行搜索；或者，如果您知道您感兴趣的模块名称，可以直接将其输入到获取框中。点击超链接时，您将获得与
    Python 网站或使用 `help()` 命令提供的信息相同，如下所示：
- en: '![](img/4ed1b35e-7a5c-402f-ba78-d411e4f9aa27.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ed1b35e-7a5c-402f-ba78-d411e4f9aa27.png)'
- en: 'In addition to the built-in modules, if you run PyDoc from a virtual environment,
    you''ll receive information about the virtual environment, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了内置模块外，如果您从虚拟环境运行 PyDoc，您将收到有关虚拟环境的信息，如下所示：
- en: '![](img/3d2ce927-264a-4a99-a416-5ad997cfe50e.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d2ce927-264a-4a99-a416-5ad997cfe50e.png)'
- en: This way, you can not only view the default modules available within Python,
    but you can see what has has been placed in your virtual environment, if desired.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您不仅可以查看 Python 中可用的默认模块，还可以查看是否在虚拟环境中放置了某些内容。
- en: 'An alternative way to access the help files is by using the command `python
    -m pydoc -g`, which opens up a generic-looking window to launch the browser window
    or to search it directly, shown as follows (you will need to have the `python-tk`
    package installed for this to run):'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用命令 `python -m pydoc -g` 可以以另一种方式访问帮助文件，该命令打开一个看起来通用的窗口以启动浏览器窗口或直接搜索，如下所示（您需要安装
    `python-tk` 软件包才能运行此操作）：
- en: '![](img/67dec03a-c990-4934-a29f-43284875e116.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67dec03a-c990-4934-a29f-43284875e116.png)'
- en: 'If you enter information in the search bar, you will get a little information,
    but not much, shown as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在搜索栏中输入信息，您将获得一些信息，但不多，如下所示：
- en: '![](img/ab7087ce-97de-4383-807e-4e1ee5e6da4f.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab7087ce-97de-4383-807e-4e1ee5e6da4f.png)'
- en: 'In this case, if we go to `multiprocessing.pool`, as in step 3 earlier, we
    can see that the information is presented in a similar web page; obviously, however,
    the information is different, because this is Python 2.7, whereas the previous
    example was Python 3.6.5:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们转到 `multiprocessing.pool`，就像前面步骤 3 中那样，我们可以看到信息以类似网页的形式呈现；然而，显然信息是不同的，因为这是
    Python 2.7，而前面的例子是 Python 3.6.5：
- en: '![](img/2dc4bc3c-d8e1-4789-8422-bb7755ba7dc6.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dc4bc3c-d8e1-4789-8422-bb7755ba7dc6.png)'
- en: The preceding screenshot shows the same information as in step 3 above, but
    the formatting is different because it is for Python 2.7.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示的信息与步骤 3 中的信息相同，但格式不同，因为它是针对 Python 2.7 的。
- en: Using reStructuredText files
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 reStructuredText 文件
- en: Plain text, by definition, is limited in what information it can provide; that
    is, there is no metadata inherent in a text file (apart from what is provided
    by the filesystem). In other words, there is no way to bold, italicize, or otherwise
    augment raw text, to provide some sort of contextual information.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，纯文本在提供信息方面有限；也就是说，文本文件中没有固有的元数据（除了文件系统提供的信息）。换句话说，没有方法可以加粗、斜体或其他方式增强原始文本，以提供某种上下文信息。
- en: A number of markup languages have been developed over the years, with HTML being
    a prime example this. However, HTML is a little heavy for in-code documentation
    purposes. Something more like Wikitext ([https://en.wikipedia.org/wiki/Help:Wikitext](https://en.wikipedia.org/wiki/Help:Wikitext))
    would make more sense, as it uses simple ASCII characters to provide context to
    raw text. Hence, PEP 287 proposes the **reStructuredText** (**reST**) markup be
    used for structured text documentation within Python docstrings, PEPs, and other
    documents that require structured markup. Of course, plain text docstrings are
    not deprecated; reST simply provides more options, for developers who want to
    be more expressive in their documentation[.](https://en.wikipedia.org/wiki/Help:Wikitext)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，已经开发了许多标记语言，HTML是其中的一个主要例子。然而，HTML对于代码文档来说有点过于复杂。更类似于Wikitext（[https://en.wikipedia.org/wiki/Help:Wikitext](https://en.wikipedia.org/wiki/Help:Wikitext)）的东西会更有意义，因为它使用简单的ASCII字符为原始文本提供上下文。因此，PEP
    287建议使用**reStructuredText**（**reST**）标记来为Python docstrings、PEPs和其他需要结构化标记的文档中的结构化文本提供标记。当然，纯文本docstrings没有被弃用；reST只是为希望在其文档中更具表现力的开发者提供了更多选项[。](https://en.wikipedia.org/wiki/Help:Wikitext)
- en: The official location for reST documentation can be found at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: reST官方文档的位置可以在[http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html)找到。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you want to work with reST on its own, you can install the Docutils program
    ([http://docutils.sourceforge.net/index.html)](http://docutils.sourceforge.net/index.html).
    [This tool allows you to convert reST into HTML, LaTeX, man pages, XML, or other
    formats.](http://docutils.sourceforge.net/index.html)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在单独的reST上工作，你可以安装Docutils程序（[http://docutils.sourceforge.net/index.html](http://docutils.sourceforge.net/index.html)）。[这个工具允许你将reST转换为HTML、LaTeX、man页面、XML或其他格式。](http://docutils.sourceforge.net/index.html)
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you just want to include reST in your Python documentation, the following
    is a quick introduction on how the basic syntax works; at the end are screenshots
    of how all of these look in practice (a more thorough demonstration is available
    at [http://docutils.sourceforge.net/docs/user/rst/demo.html](http://docutils.sourceforge.net/docs/user/rst/demo.html)):'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只想在Python文档中包含reST，以下是一个关于基本语法如何工作的快速介绍；最后是一些截图，展示了这些在实际中的应用（更详细的演示可在[http://docutils.sourceforge.net/docs/user/rst/demo.html](http://docutils.sourceforge.net/docs/user/rst/demo.html)找到）：
- en: The paragraph is the most basic pattern in reST. It is simply a block of text
    separated from other text blocks by a single, blank line. The blocks must have
    the same indentation, starting at the left edge. Indenting paragraphs results
    in offset paragraphs, typically used to show quoted text.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落是reST中最基本的模式。它只是一个由单个空行与其他文本块分隔的文本块。这些块必须具有相同的缩进，从左侧边缘开始。缩进段落会产生偏移段落，通常用于显示引用文本。
- en: 'Inline markup can be performed by using asterisks, that is, `*italics*` and
    `**bold**`. Monospaced, literal text is denoted with double-backticks: [PRE27].
    Note that any special characters that would normally mark up text are expressed
    literally, and not interpreted as markup.'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联标记可以通过使用星号来实现，即`*斜体*`和`**粗体**`。等宽的、字面意义的文本用双反引号表示：[PRE27]。请注意，任何通常用于标记文本的特殊字符都应按字面意义表达，而不是作为标记解释。
- en: To use special characters, reST is semi-intelligent. Using a single asterisk
    will not cause any markup to occur. To mark-off text with asterisks without it
    being marked up, use double-backticks, or escape the asterisk by using `\*`.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用特殊字符，reST是半智能的。使用单个星号不会引起任何标记发生。要使用星号标记文本而不进行标记，请使用双反引号，或者使用`\*`来转义星号。
- en: 'Lists can be created in three ways: enumerated, bulleted, or definitions. Enumerated
    lists start with either a number or a letter, followed by a `.`, `)`, or `()`;
    that is, `1.`, `A)`, and `(i)` are all valid.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以通过三种方式创建：编号列表、无序列表或定义列表。编号列表以数字或字母开头，后跟一个`.`、`)`或`()`；例如，`1.`、`A)`和`(i)`都是有效的。
- en: Bullets are created using either `*`, `+`, or `-`. The symbol that appears depends
    on the character used. Sub-bullets need two spaces from the original to be recognized.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表项可以通过使用`*`、`+`或`-`来创建。出现的符号取决于使用的字符。子列表项需要从原始文本中缩进两个空格才能被识别。
- en: Definition lists, while classified as lists, are more like special-purpose paragraphs.
    They consist of a term and, on the following line, an intended definition block.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义列表，虽然被归类为列表，但更像是一种特殊用途的段落。它由一个术语和在其下一行上的预期定义块组成。
- en: Preformatted code samples can be indicated by using `::`. The `::` symbol appears
    on the line prior to the indented code block; think of a quoted paragraph preceded
    by a line that ends in `::`. The preformatting ends when the indentation returns
    to normal.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用 `::` 来指示预格式化代码示例。`::` 符号出现在缩进代码块之前的行上；想象一下一个以 `::` 结尾的行开始的引用段落。预格式化在缩进返回正常时结束。
- en: 'Section headers are indicated by using a series of characters directly underneath
    a line of text. The characters must be of the same length as the text. Each set
    of characters is assumed to be at the same heading level, so don''t just pick
    characters randomly. Any of the following characters are allowed: ``- _ : ` ~
    '' " ^ * + = # < >``.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用一系列字符直接位于文本行下方来指示章节标题。这些字符的长度必须与文本相同。每一组字符都假定处于相同的标题级别，因此不要随机选择字符。以下字符都是允许的：``-
    _ : ` ~ '' " ^ * + = # < >``。'
- en: The title and subtitle are designated similarly to section headers, except that
    both the lines above and below the text have a series of characters, rather than
    just the line below, as in headers.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题和副标题的指定方式与章节标题类似，不同之处在于文本上方和下方的行都有一系列字符，而不仅仅是下方，就像标题一样。
- en: Images are included by using `.. image::`, followed by the image location. The
    image can be on a local drive or on the internet.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `.. image::` 后跟图像位置来包含图像。图像可以位于本地驱动器或互联网上。
- en: 'The following is an example of all of the items discussed earlier, with the
    raw ST and the output next to it:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个早期讨论的所有项目的示例，包括原始的 reST 和其输出：
- en: '![](img/a8fcb46a-2cd9-4056-8458-63741a392ba6.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8fcb46a-2cd9-4056-8458-63741a392ba6.png)'
- en: The preceding screenshot shows the generic HTML template for the online reST
    editor.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了在线 reST 编辑器的通用 HTML 模板。
- en: 'The following screenshot shows how the exact same reST markup can be converted
    into a completely different look by the parsing engine:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了相同的 reST 标记可以通过解析引擎转换成完全不同的外观：
- en: '![](img/ce830d3b-52f6-419e-b68e-5c960599bd7c.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce830d3b-52f6-419e-b68e-5c960599bd7c.png)'
- en: The preceding screenshot shows an alternate HTML template that can be used with
    the online reST editor.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了可以与在线 reST 编辑器一起使用的备用 HTML 模板。
- en: Using the Sphinx documentation program
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sphinx 文档程序
- en: Sphinx was written for Python documentation and is used extensively in official
    document creation. As a matter of fact, all of the documentation on the Python
    site is generated by Sphinx. Even the Sphinx website is written in reST and converted
    to HTML.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是为 Python 文档编写的，并且在官方文档创建中被广泛使用。事实上，Python 网站上的所有文档都是通过 Sphinx 生成的。甚至
    Sphinx 网站也是用 reST 编写的，并转换为 HTML。
- en: Sphinx can convert reST into HTML, PDF, ePub, Texinfo, and man pages. The program
    is also extensible, for example, via plugins, to generate mathematical notations
    from formulas or highlight source code.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 可以将 reST 转换为 HTML、PDF、ePub、Texinfo 和 man 页面。该程序还可以通过插件等方式扩展，例如从公式生成数学符号或突出显示源代码。
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download Sphinx via `pip` or system installation, such as with `apt install`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `pip` 或系统安装，例如使用 `apt install` 下载 Sphinx。
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once installed, it is suggested you move to the project directory, as the program
    defaults to looking for files in the current directory. This is not required,
    however, as you can always change the configuration later.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，建议您切换到项目目录，因为程序默认在当前目录中查找文件。然而，这不是必需的，因为您以后总是可以更改配置。
- en: 'Run the following command at the command prompt: `sphinx-quickstart`. You will
    walk through an interactive configuration session, as follows:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中运行以下命令：`sphinx-quickstart`。您将进入一个交互式配置会话，如下所示：
- en: '![](img/f27daa9d-5634-4c9f-a44d-41c61753e995.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f27daa9d-5634-4c9f-a44d-41c61753e995.png)'
- en: The questions are generally self-explanatory, but be sure to check the documentation
    if something doesn't make sense. Don't panic, however, if you just pick the defaults
    and don't get the results expected. This process is simply creating the default
    configuration files, which can be manually modified later.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题通常是自解释的，但如果你发现某些内容不清楚，请务必检查文档。不过，如果你只是选择了默认设置而没有得到预期的结果，也不要慌张。这个过程只是简单地创建默认配置文件，这些文件可以在以后手动修改。
- en: A key thing to point out is that, if you want to use your docstrings to generate
    your documentation, ensure that you select `autodoc` for installation.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要指出的是，如果您想使用您的 docstrings 生成文档，确保您在安装时选择 `autodoc`。
- en: 'In your directory, you should now see some new files, specifically `conf.py`
    and `index.rst`. These are used to allow Sphinx to operate:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的目录中，你现在应该看到一些新文件，特别是`conf.py`和`index.rst`。这些文件用于允许Sphinx运行：
- en: '`conf.py`, naturally enough, is the config file for Sphinx. It is the primary
    location for setting up Sphinx, and entries made during the quickstart process
    are stored here.'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf.py`自然地是Sphinx的配置文件。它是设置Sphinx的主要位置，快速启动过程中创建的条目存储在这里。'
- en: '`index.rst` is the primary file for telling Sphinx how to create the final
    documentation. It basically tells Sphinx which modules, classes, and so on, to
    include in the documentation.'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.rst` 是告诉Sphinx如何创建最终文档的主要文件。它基本上告诉Sphinx要包含哪些模块、类等。'
- en: 'By default, `conf.py` looks for files in `PYTHONPATH`; if you are looking to
    use files in another location, make sure that you set it up correctly, at the
    top of the file. Specifically, remove the comments from `import os`, `import sys`,
    and the `sys.path.insert()` line (and update the path as needed), as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`conf.py` 在`PYTHONPATH` 中查找文件；如果你想要使用其他位置的文件，确保你正确设置它，在文件顶部。具体来说，取消注释`import
    os`、`import sys` 和 `sys.path.insert()` 行（并根据需要更新路径），如下所示：
- en: '![](img/96eda21f-a2a7-49d8-982d-b81180bafa42.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96eda21f-a2a7-49d8-982d-b81180bafa42.png)'
- en: As this example has Sphinx running in the same directory as the module, there
    was no need to change the path.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个示例中Sphinx运行在与模块相同的目录下，因此没有必要更改路径。
- en: 'If you set up `conf.py` to use `autodoc`, the next step is relatively easy.
    Go to `index.rst` and tell Sphinx to automatically find the information for the
    documentation. The easiest way to do this is to take a look at [http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc](http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc),
    which explains how to automatically import all desired modules and retrieve the
    docstrings from them. The following is a screenshot of the entries made for this
    example; specifically, the `automodule` and sub-entries were added. Everything
    else is at its default value:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你设置`conf.py`使用`autodoc`，下一步相对简单。转到`index.rst`并告诉Sphinx自动查找文档信息。最简单的方法是查看[http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc](http://www.sphinx-doc.org/en/stable/ext/autodoc.html#module-sphinx.ext.autodoc)，它解释了如何自动导入所有所需的模块并从中检索文档字符串。以下是为这个示例创建的条目的截图；具体来说，添加了`automodule`和子条目。其他所有内容都使用默认值：
- en: '![](img/78c2613d-3c7b-4423-b617-2b070dd7a514.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78c2613d-3c7b-4423-b617-2b070dd7a514.png)'
- en: The `automodule` object (and the module name) tells Sphinx the name of the Python
    module to import. As a reminder, the module name is simply the Python filename,
    without the `.py` extension.
  id: totrans-354
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automodule` 对象（以及模块名称）告诉Sphinx要导入的Python模块的名称。提醒一下，模块名称只是Python文件名，不带`.py`扩展名。'
- en: The `members` object automatically gathers documentation for all public classes,
    methods, and functions that have docstrings. If you don't use it, only the docstring
    for the main object (a module, in this case) will be imported.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`members` 对象自动收集所有公共类、方法和函数的文档。如果你不使用它，只有主对象（在这种情况下是模块）的文档字符串将被导入。'
- en: The `undoc-members` object does the same thing, except it will get objects that
    don't have docstrings. Obviously, the information for these items will be limited,
    as compared to a docstring.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undoc-members` 对象执行相同的功能，但它将获取没有文档字符串的对象。显然，与文档字符串相比，这些项目的信息将有限。'
- en: The `show-inheritance` object specifies that the inheritance tree for the module
    will be included. Needless to say, if you aren't using inheritance, this won't
    do much good.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show-inheritance` 对象指定将包含模块的继承树。不用说，如果你没有使用继承，这不会有多大帮助。'
- en: 'Once you have the configuration and index files set, you can run the command
    `make html`, to generate the HTML files for your project. You may run into errors,
    as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你设置了配置和索引文件，你可以运行命令`make html`，为你的项目生成HTML文件。你可能会遇到错误，如下所示：
- en: '![](img/e78e2d57-254e-49f0-9f13-e2417511f4d2.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e78e2d57-254e-49f0-9f13-e2417511f4d2.png)'
- en: 'These errors actually mean that the source code doesn''t have the spacing requirements
    expected by reST. The following screenshot is part of the code used in this example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误实际上意味着源代码没有满足reST预期的间距要求。以下截图是本例中使用的代码的一部分：
- en: '![](img/3aca498a-650c-4a74-ae92-3630b5111ca5.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aca498a-650c-4a74-ae92-3630b5111ca5.png)'
- en: Specifically, a blank line is required between each grouping within the docstring;
    that is, the `param` entries are separate from `except`, which is separated from
    `return`*.* When the HTML command was run, the blank lines between these items
    were not present.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在文档字符串中的每个分组之间都需要一个空行；也就是说，`param`条目与`except`分开，而`except`又与`return`分开*.*
    当运行HTML命令时，这些项目之间的空行不存在。
- en: 'When you finally correct all of the problems, you should get a successful make,
    as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您最终纠正所有问题后，应该会得到一个成功的make，如下所示：
- en: '![](img/0e0a578b-d4b9-4761-a2d7-a506a4a0a1ab.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e0a578b-d4b9-4761-a2d7-a506a4a0a1ab.png)'
- en: Now, you can go into the target directory and look for `index.html` in the `_build/html`
    directory (assuming that you used the default values).
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以进入目标目录，在`_build/html`目录中查找`index.html`（假设您使用了默认值）。
- en: 'When you open it, you should see something like this:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您打开它时，您应该会看到如下内容：
- en: '![](img/bebb963d-7149-43ff-bd1f-9337e5bc3fcf.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bebb963d-7149-43ff-bd1f-9337e5bc3fcf.png)'
- en: 'If you don''t like the default theme, there are a number of other themes included
    with Sphinx. Obviously, given that it is HTML, you can make your own, as well.
    Here is the included theme, *scrolls*:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不喜欢默认主题，Sphinx还包含了许多其他主题。显然，鉴于它是HTML，您也可以创建自己的主题。以下是一个包含的主题，*scrolls*：
- en: '![](img/17933854-5138-488a-96e0-cb4cf371a278.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17933854-5138-488a-96e0-cb4cf371a278.png)'
- en: Using LaTeX and LyX document preparation programs
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LaTeX和LyX文档准备程序
- en: When preparing external documentation (not docstrings or other in-code documentation),
    most people resort to Microsoft Word or another word processor, though nowadays
    HTML is a viable option, as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备外部文档（不是文档字符串或其他代码中的文档）时，大多数人会求助于Microsoft Word或其他文字处理软件，尽管如今HTML也是一个可行的选择。
- en: This final section will discuss an alternative to word processors. Word processors
    are **WYSIWYG**, which stands for **What You See Is What You Get**; in other words,
    what you see on the screen is essentially what you'll see in the finished product.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论文字处理程序的替代方案。文字处理程序是**WYSIWYG**，代表**所见即所得**；换句话说，屏幕上所见的就是最终产品中的样子。
- en: One alternative that we will discuss here is document processors. While they
    tend to look similar to word processors, document processors emphasize the layout
    of the document's components, rather than formatting text. In other words, document
    processors are **WYSIWYM **(**What You See Is What You Mean**). With these programs,
    what is seen on the screen is not representative of how the final product will
    look.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的一个替代方案是文档处理程序。虽然它们看起来与文字处理程序相似，但文档处理程序强调文档组件的布局，而不是文本的格式。换句话说，文档处理程序是**WYSIWYM**（**所见即所得**）。在这些程序中，屏幕上所见并不代表最终产品的外观。
- en: LyX (pronounced *licks*) is one of the more popular document processors. It
    acts as a graphical frontend to the LaTeX typesetting system, and can be used
    for documents ranging from books and notes to letters and academic papers.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: LyX（发音为*licks*）是更受欢迎的文档处理程序之一。它作为LaTeX排版系统的图形前端，可用于从书籍和笔记到信件和学术论文的各种文档。
- en: LyX allows the user to state what type of component a particular part of the
    paper is; for example, a chapter, heading, paragraph, and so on. Then, the backend
    software handles formatting it. This enables the user to simply write the document
    and not worry about how the document will look.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: LyX允许用户声明文档中特定部分的组件类型；例如，章节、标题、段落等。然后，后端软件处理格式化。这使得用户只需简单地编写文档，无需担心文档的外观。
- en: LyX relies on LaTeX (pronounced *lateck*, as the X is actually the Greek letter
    Chi), which is a typesetting and document preparation system. When using LaTeX
    directly, the user writes a document in plain text, using markup tags to identify
    what different parts should be in the final document.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: LyX依赖于LaTeX（发音为*lateck*，因为X实际上是希腊字母Chi），这是一个排版和文档准备系统。当直接使用LaTeX时，用户使用纯文本编写文档，使用标记标签来标识最终文档中不同部分的内容。
- en: LaTeX is widely used in Academia, as it has support for mathematical equations,
    creates print-ready documents, supports multiple languages, and doesn't have the
    memory problems a word processor has, meaning that a user is less likely to have
    a system crash when writing large documents with graphics.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: LaTeX在学术界广泛使用，因为它支持数学方程式，创建打印就绪的文档，支持多种语言，并且没有文字处理程序那样的内存问题，这意味着用户在编写包含图形的大文档时不太可能遇到系统崩溃。
- en: 'LyX and LaTeX are properly written in camelCase, as the *T* and *X* are actually
    Greek letters: *T = tau* and *X = chi*.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: LyX 和 LaTeX 正确地使用驼峰命名法，因为 T 和 X 实际上是希腊字母：*T = tau* 和 *X = chi*。
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use LyX, you can download the binary installer from the LyX website ( [https://www.lyx.org/Download](https://www.lyx.org/Download))
    or use a Linux package manager to download it; for example, `apt install lyx`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 LyX，你可以从 LyX 网站下载二进制安装程序（[https://www.lyx.org/Download](https://www.lyx.org/Download)）或使用
    Linux 软件包管理器下载它；例如，`apt install lyx`。
- en: You can install LaTeX separately, but it is recommended to just install LyX,
    as LaTeX is included with it, and you gain access to a LaTeX GUI, as well.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单独安装 LaTeX，但建议只安装 LyX，因为 LaTeX 已包含在内，您还可以访问 LaTeX 图形用户界面。
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'When you first open LyX, you are presented with a window very similar to a
    word processor, as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你第一次打开 LyX 时，你会看到一个与文字处理器非常相似的窗口，如下所示：
- en: '![](img/6725fa83-91f5-47a3-ac20-9de99ff81b57.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6725fa83-91f5-47a3-ac20-9de99ff81b57.png)'
- en: It is highly recommended you take a look at the documents under the Help menu,
    particularly the Introduction and Tutorial. Doing so will only take a few hours,
    at most, but they explains the majority of the basic features of LyX.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强烈建议您查看帮助菜单下的文档，特别是介绍和教程。这样做最多只需要几个小时，但它们解释了 LyX 大多数基本功能。
- en: 'Of special note is the drop-down box in the top-left corner, labeled Standard
    in the screenshot. This is the Environment interface for determining what a text
    component is. The following options are available through this menu:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别值得一提的是截图左上角的下拉框，在截图中标为“标准”。这是用于确定文本组件的环境界面。通过此菜单可用的选项如下：
- en: '`Standard`: Normal paragraph.'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标准`: 正常段落。'
- en: '`LyX-Code`: LyX-specific commands.'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LyX-代码`: LyX 特定的命令。'
- en: '`Quotation`: Always indents the first line of a paragraph, and uses the same
    line spacing throughout.'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引用`: 总是缩进段落的第 一行，并且在整个段落中使用相同的行间距。'
- en: '`Quote`: Uses extra spacing to separate paragraphs, and never indents the first
    line.'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引用`: 使用额外的间距来分隔段落，并且永远不会缩进第一行。'
- en: '`Verse`: Used for poetry or songwriting.'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`诗歌`: 用于诗歌或歌词创作。'
- en: '`Verbatim`: Preformatted, monospace text.'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Verbatim`: 预格式化，等宽文本。'
- en: '`Separator`: Allows for splitting lists.'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分隔符`: 允许分割列表。'
- en: '`Labeling`: Assigns a definition to a word.'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: 将定义分配给一个单词。'
- en: '`Itemize`: Bulleted list.'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`项目符号`: 项目符号列表。'
- en: '`Enumerate`: Sequential list.'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`列举`: 顺序列表。'
- en: '`Description`: Similar to Labeling, but with a different format.'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`: 与标签类似，但格式不同。'
- en: '`Part/Part*`: Equivalent to a chapter. For this, and the following items, `<name>*`
    indicates that no number is included; otherwise, the number of the item is included
    by default.'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`部分/部分*`: 等同于章节。对于此以及以下项目，`<name>*` 表示不包含编号；否则，项目默认包含编号。'
- en: '`Section/Section*`: Section within a chapter.'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`章节/章节*`: 章节内的部分。'
- en: '`Subsection/Subsection*`: Part of a section.'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`副节/副节*`: 节的一部分。'
- en: '`Subsubsection/Subsubsection*`: Part of a subsection.'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`副标题/副标题*`: 子节的一部分。'
- en: '`Paragraph/Paragraph*`: Bolds a paragraph.'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`段落/段落*`: 粗体段落。'
- en: '`Subparagraph/Subparagraph*`: Indented version of Paragraph.'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`副段落/副段落*`: 段落的缩进版本。'
- en: '`Title/Author/Date`: Self-explanatory.'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题/作者/日期`: 自解释。'
- en: '`Address/Right Address`: Primarily used for letters; the only difference is
    the justification of the address.'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地址/右地址`: 主要用于信件；唯一的区别是地址的对齐方式。'
- en: '`Abstract`: Executive-style summary of the document.'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摘要`: 文档的执行摘要。'
- en: '`Bibliography`: Manually creates a reference section.'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`参考文献`: 手动创建参考部分。'
- en: In addition to these, LyX provides for the auto-creation of a table of contents,
    index, and bibliography. It can also handle text wrapping around graphics, the
    captioning of graphics, programming code, tables, floating text boxes, colorizing
    text, rotated text, and so on.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了这些，LyX 还提供自动创建目录、索引和参考文献的功能。它还可以处理文本绕图、图形标题、编程代码、表格、浮动文本框、文本着色、旋转文本等等。
- en: 'The following is a screenshot of the LyX Tutorial section, as written within
    the editor:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在编辑器中编写的 LyX 教程部分的截图：
- en: '![](img/f2f3cd24-6304-43f3-acf2-37b202255c4e.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2f3cd24-6304-43f3-acf2-37b202255c4e.png)'
- en: 'Here is the same section, when converted to a PDF:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是当转换为 PDF 时的相同部分：
- en: '![](img/5c307ed9-aa57-47cb-8e30-03b0615703ae.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c307ed9-aa57-47cb-8e30-03b0615703ae.png)'
- en: 'Here is the same section in raw LaTeX markup:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是相同部分的原始 LaTeX 标记：
- en: '![](img/d4d51b3b-6747-4645-a586-fc397c2ec695.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4d51b3b-6747-4645-a586-fc397c2ec695.png)'
- en: 'As a final example, more relevant to programmers, here is a screenshot of this
    author''s first book, *Learning to Program Using Python*, which was written entirely
    in LyX:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的例子，对于程序员来说更为相关，以下是这位作者第一本书的屏幕截图，书名为《使用 Python 学习编程》，这本书完全是用 LyX 编写的：
- en: '![](img/13501f74-2d4c-4e5a-965b-92d1338ce079.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13501f74-2d4c-4e5a-965b-92d1338ce079.png)'
- en: 'The following is that same section in a PDF:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在 PDF 中的相同部分：
- en: '![](img/6a885e0f-e053-4217-8b2e-930162f49270.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a885e0f-e053-4217-8b2e-930162f49270.png)'
- en: There's more...
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Like many Unix-oriented tools, LaTeX can be difficult to work with, especially
    when it comes to troubleshooting. LyX itself is fairly straightforward, as it
    is essentially just a graphical wrapper around LaTeX. Therefore, if problems are
    going to develop, it will be within the underlying TeX environment.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多面向 Unix 的工具一样，LaTeX 使用起来可能比较困难，尤其是在故障排除方面。LyX 本身相当直观，因为它本质上只是 LaTeX 的图形包装器。因此，如果出现问题，它将在底层的
    TeX 环境中发生。
- en: Problems will occur when attempting to generate PDF files or otherwise export
    your LyX file to another file format. Frequently, these issues can be resolved
    by installing additional software, which can sometimes be identified within the
    error message.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成 PDF 文件或以其他方式将您的 LyX 文件导出为其他文件格式时，可能会出现问题。通常，这些问题可以通过安装额外的软件来解决，这些软件有时可以在错误信息中找到。
- en: For example, during the creation of this book, this author had a problem creating
    a PDF copy of the Tutorial, because an error kept occurring when converting the
    EPS images to PDF images. This was ultimately resolved by using `apt-cache search
    epstopdf`, as determined by the error message. This revealed that the required
    tool is located in `texlive-font-utils`, which would not have been immediately
    apparent. Fortunately, after installation, the PDF export worked.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在创建这本书的过程中，这位作者遇到了一个问题，无法创建教程的 PDF 复制，因为在将 EPS 图像转换为 PDF 图像时不断出现错误。这个问题最终通过使用
    `apt-cache search epstopdf` 解决，这是根据错误信息确定的。这揭示了所需的工具位于 `texlive-font-utils` 中，这并不立即明显。幸运的是，安装后，PDF
    导出工作正常。
- en: All of this discussion is to emphasize that, while LyX and LaTeX are extremely
    powerful and useful tools, it takes a significant commitment to use them. A basic
    installation may not provide the tools necessary for your project. However, if
    you make that commitment, it can be a very useful environment not only for code
    documentation, but also for the creation of any document. There are even a number
    of Python tools listed in PyPI that can interact with the core TeX language.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些讨论都是为了强调，虽然 LyX 和 LaTeX 是非常强大和有用的工具，但使用它们需要做出重大的承诺。基本安装可能不会提供您项目所需的工具。然而，如果您做出这种承诺，它可以是一个非常有用的环境，不仅适用于代码文档，还适用于创建任何文档。PyPI
    上甚至列出了许多可以与核心 TeX 语言交互的 Python 工具。
