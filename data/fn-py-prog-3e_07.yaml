- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: Complex Stateless Objects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的无状态对象
- en: Many of the examples we’ve looked at have either been functions using atomic
    (or scalar) objects, or relatively simple structures built from small tuples.
    We can often exploit Python’s immutable `typing.NamedTuple` as a way to build
    complex data structures. The class-like syntax seems much easier to read than
    the older `collections.namedtuple` syntax.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所查看的许多示例要么是使用原子（或标量）对象的函数，要么是由小元组构建的相对简单的结构。我们经常可以利用 Python 的不可变 `typing.NamedTuple`
    来构建复杂的数据结构。类样式的语法似乎比旧的 `collections.namedtuple` 语法更容易阅读。
- en: One of the beneficial features of object-oriented programming is the ability
    to create complex data structures incrementally. In some respects, an object can
    be viewed as a cache for results of functions; this will often fit well with functional
    design patterns. In other cases, the object paradigm provides for property methods
    that include sophisticated calculations to derive data from an object’s properties.
    Using properties of an otherwise immutable class is also a good fit for functional
    design ideas.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个有益特性是能够增量地创建复杂的数据结构。在某种程度上，一个对象可以被视为函数结果的缓存；这通常与函数式设计模式很好地结合。在其他情况下，对象范式提供了包含从对象属性派生数据的复杂计算的属性方法。使用其他方面不可变的类的属性也适合于函数式设计思想。
- en: 'In this chapter, we’ll look at the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: How we create and use `NamedTuple` and frozen `@dataclass` definitions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何创建和使用 `NamedTuple` 和冻结的 `@dataclass` 定义。
- en: Ways that immutable `NamedTuple` or frozen `@dataclass` objects can be used
    instead of stateful object classes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变的 `NamedTuple` 或冻结的 `@dataclass` 对象代替有状态对象类的方法。
- en: How to use the popular third-party `pyrsistent` package instead of stateful
    object classes. This is not part of the standard library, and requires a separate
    install.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用流行的第三方 `pyrsistent` 包代替有状态对象类。这不是标准库的一部分，需要单独安装。
- en: Some techniques to write generic functions outside any polymorphic class definition.
    While we can rely on callable classes to create a polymorphic class hierarchy,
    in some cases, this might be a needless overhead in a functional design. This
    will touch on using the `match` statement for identifying types or structures.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些在没有任何多态类定义的情况下编写泛型函数的技术。虽然我们可以依赖可调用类来创建多态类层次结构，但在某些情况下，这可能在功能设计中是一个不必要的开销。这将涉及使用
    `match` 语句来识别类型或结构。
- en: While frozen dataclasses and `NamedTuple` subclasses are nearly equivalent,
    a frozen dataclass omits the sequence features that a `NamedTuple` includes. Iterating
    over the members of a `NamedTuple` object is a confusing feature; a dataclass
    doesn’t suffer from this potential problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然冻结的数据类和 `NamedTuple` 子类几乎等价，但冻结的数据类省略了 `NamedTuple` 包含的序列特征。迭代 `NamedTuple`
    对象的成员是一个令人困惑的特性；数据类不会受到这种潜在问题的困扰。
- en: We’ll start our journey by looking at using `NamedTuple` subclasses.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看使用 `NamedTuple` 子类来开始我们的旅程。
- en: 7.1 Using tuples to collect data
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 使用元组收集数据
- en: 'In [Chapter 3](Chapter_03.xhtml#x1-510003), [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003),
    we showed two common techniques to work with tuples. We’ve also hinted at a third
    way to handle complex structures. We can go with any of the following techniques,
    depending on the circumstances:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)
    中，我们展示了两种处理元组的常见技术。我们还暗示了处理复杂结构的第三种方法。我们可以根据具体情况选择以下任何一种技术：
- en: Use lambdas (or functions created with the `def` statement) to select a named
    item based on the index
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda（或使用 `def` 语句创建的函数）根据索引选择一个命名项目
- en: Use lambdas (or `def` functions) with multiple positional parameters coupled
    with `*args` to assign a tuple of items to parameter names
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带多个位置参数的 lambda（或 `def` 函数）与 `*args` 相结合，将项目元组分配给参数名称
- en: Use a `NamedTuple` class to select an item by attribute name or index
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `NamedTuple` 类通过属性名或索引选择一个项目
- en: Our trip data, introduced in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004), has a rather complex structure.
    The data started as an ordinary time series of position reports. To compute the
    distances covered, we transposed the data into a sequence of legs with a start
    position, end position, and distance as a nested three-tuple.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004) 中引入的行程数据具有相当复杂的结构。数据最初是一组位置报告的普通时间序列。为了计算覆盖的距离，我们将数据转置成一个包含起始位置、结束位置和距离作为嵌套三元的腿序列。
- en: 'Each item in the sequence of legs looks as follows as a three-tuple:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 路段序列中的每个项目看起来如下，作为一个三元组：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first two items are the starting and ending points. The third item is the
    distance between the points. This is a short trip between two points on the Chesapeake
    Bay.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个项目是起始点和结束点。第三个项目是两点之间的距离。这是一次在切萨皮克湾两点之间的短途旅行。
- en: A nested tuple of tuples can be rather difficult to read; for example, expressions
    such as `some_leg[0][0]` aren’t very informative.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套元组元组可能相当难以阅读；例如，`some_leg[0][0]`这样的表达式并不很有信息量。
- en: 'Let’s look at the three alternatives for selecting values out of a tuple. The
    first technique involves defining some simple selection functions that can pick
    items from a tuple by index position:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从元组中选择值的三种方法。第一种技术涉及定义一些简单的选择函数，这些函数可以通过索引位置从元组中挑选项目：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With these definitions, we can use `latitude(start(some_leg))` to refer to
    a specific piece of data. It looks like this code example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，我们可以使用`latitude(start(some_leg))`来引用特定的数据。代码示例如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It’s awkward to provide type hints for lambdas. The following shows how this
    becomes complex-looking:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为lambda表达式提供类型提示有些尴尬。以下显示了这如何变得复杂：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The type hint must be provided as part of the assignment statement. This tells
    mypy that the object named `start` is a callable function that accepts a single
    parameter of a type named `Leg` and returns a result of the `Point` type. A function
    created with the `def` statement will usually have an easier-to-read type hint.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示必须作为赋值语句的一部分提供。这告诉mypy，名为`start`的对象是一个可调用的函数，它接受一个类型为`Leg`的单个参数，并返回一个`Point`类型的结果。使用`def`语句创建的函数通常具有更易于阅读的类型提示。
- en: 'A variation on this first technique for collecting complex data uses the `*parameter`
    notation to conceal some details of the index positions. The following are some
    selection functions that are evaluated with the `*` notation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种收集复杂数据的第一种技术的变体使用`*parameter`符号来隐藏索引位置的某些细节。以下是一些使用`*`符号评估的选择函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With these definitions, we can extract specific pieces of data from a tuple.
    We’ve used the `_s` suffix to emphasize the need to use star, `*`, when evaluating
    these lambdas. It looks like this code example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，我们可以从元组中提取特定数据。我们使用了`_s`后缀来强调在评估这些lambda表达式时需要使用星号`*`。代码示例如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This has the advantage of a little more clarity in the function definitions.
    The association between position and name is given by the list of parameter names.
    It can look a little odd to see the `*` operator in front of the tuple arguments
    to these selection functions. This operator is useful because it maps each item
    in a tuple to a parameter of the function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这在函数定义中提供了一点点更清晰的优点。位置与名称之间的关系由参数名称列表给出。在选区函数的元组参数前看到`*`运算符可能看起来有点奇怪。这个运算符很有用，因为它将元组中的每个项目映射到函数的参数。
- en: While these are very functional, the syntax for selecting individual attributes
    can be confusing. Python offers two object-oriented alternatives, `NamedTuple`
    and the frozen `@dataclass`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些功能非常强大，但选择单个属性的语法可能令人困惑。Python提供了两种面向对象的替代方案，`NamedTuple`和冻结的`@dataclass`。
- en: 7.2 Using NamedTuple to collect data
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 使用NamedTuple收集数据
- en: 'The second technique for collecting data into a complex structure is `typing.NamedTuple`.
    The idea is to create a class that is an immutable tuple with named attributes.
    There are two variations available:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据收集到复杂结构中的第二种技术是`typing.NamedTuple`。其想法是创建一个不可变的元组类，具有命名属性。有两种变体可用：
- en: The `namedtuple` function in the `collections` module.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections`模块中的`namedtuple`函数。'
- en: The `NamedTuple` base class in the `typing` module. We’ll use this almost exclusively
    because it allows explicit type hinting.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing`模块中的`NamedTuple`基类。我们将几乎只使用它，因为它允许显式类型提示。'
- en: 'In the following examples, we’ll use nested `NamedTuple` classes such as the
    following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用嵌套的`NamedTuple`类，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This changes the data structure from simple anonymous tuples to named tuples
    with type hints provided for each attribute. Here’s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据结构从简单的匿名元组更改为具有为每个属性提供类型提示的命名元组。以下是一个示例：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `first_leg` object was built as the `LegNT` subclass of the `NamedTuple`
    class. This object contains two other named tuple objects and a float value. Using
    `first_leg.start.latitude` will fetch a particular piece of data from inside the
    tuple structure. The change from prefix function names to postfix attribute names
    can be seen as a helpful emphasis. It can also be seen as a confusing shift in
    the syntax.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`first_leg` 对象被构建为 `NamedTuple` 类的 `LegNT` 子类。此对象包含两个其他命名元组对象和一个浮点值。使用 `first_leg.start.latitude`
    将从元组结构内部获取特定的数据。从前缀函数名称到后缀属性名称的变化可以被视为一种有用的强调。它也可以被视为语法上的混淆变化。'
- en: The `NT` suffix in the names is not a recommended practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中的 `NT` 后缀不是推荐的做法。
- en: We’ve included the suffix in the book to emphatically distinguish among similar-looking
    solutions to the problem of defining a useful class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中加入了后缀，以明确区分定义有用类时类似外观的解决方案。
- en: In actual applications, we’d choose one definition, and use the simplest, clearest
    names possible, avoiding needless suffixes that clutter up textbooks like this
    one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们会选择一个定义，并使用尽可能简单、清晰的名称，避免不必要的后缀，以免像这样的教科书变得杂乱。
- en: Replacing simple `tuple()` functions with appropriate `LegNT()` or `PointNT()`
    function calls is important. This changes the processing that builds the data
    structure. It provides an explicitly named structure with type hints that can
    be checked by the mypy tool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用适当的 `LegNT()` 或 `PointNT()` 函数调用替换简单的 `tuple()` 函数很重要。这改变了构建数据结构的过程。它提供了一个具有类型提示的显式命名结构，该结构可以通过
    mypy 工具进行检查。
- en: 'For example, take a look at the following code snippet to create point pairs
    from source data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看以下代码片段以从源数据创建点对：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This requires an iterable object whose individual items are a list of strings.
    A CSV reader, or KML reader, can do this. The `pick_lat_lon()` function picks
    two values from the row. The generator expression applies the `pick_lat_lon()`
    function to the data source. The final generator expression creates a somewhat
    more useful two-tuple from the two string values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个可迭代的对象，其单个项是一个字符串列表。CSV 读取器或 KML 读取器可以做到这一点。`pick_lat_lon()` 函数从行中选取两个值。生成器表达式将
    `pick_lat_lon()` 函数应用于数据源。最终的生成器表达式从两个字符串值创建了一个更有用的二元组。
- en: 'The preceding code would be changed to the following code snippet to create
    `Point` objects:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将更改为以下代码片段以创建 `Point` 对象：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PointNT()` constructor has been injected into the code. The data type that
    is returned is revised to be `Iterator[PointNT]`. It’s clear that this function
    builds `Point` objects instead of anonymous two-tuples of floating-point coordinates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointNT()` 构造函数已被注入到代码中。返回的数据类型已修订为 `Iterator[PointNT]`。很明显，这个函数构建的是 `Point`
    对象，而不是匿名浮点坐标二元组。'
- en: 'Similarly, we can introduce the following to build the complete trip of `LegNT`
    objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以引入以下内容来构建完整的 `LegNT` 对象序列：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The processing is defined as a sequence of generator expressions, each one of
    which is lazy and operates on a single object. The `path_iter` object uses two
    generator functions, `row_iter_kml()` and `float_lat_lon()`, to read the rows
    from a KML file, pick fields, and convert them to `Point` objects. The `pair_iter()`
    object uses the `legs()` generator function to yield overlapping pairs of `Point`
    objects showing the start and end of each leg.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理被定义为一系列生成器表达式，每个表达式都是懒惰的，并且对单个对象进行操作。`path_iter` 对象使用两个生成器函数 `row_iter_kml()`
    和 `float_lat_lon()` 来从 KML 文件中读取行，选择字段，并将它们转换为 `Point` 对象。`pair_iter()` 对象使用 `legs()`
    生成器函数产生重叠的 `Point` 对象对，显示每条腿的起点和终点。
- en: The `trip_iter` generator expression creates the final `LegNT` objects from
    pairs of `Point` objects. These generated objects are consumed by the `list()`
    function to create a single list of legs. The `haversine()` function from [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), is used to compute the
    distance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`trip_iter` 生成器表达式从 `Point` 对象的成对中创建最终的 `LegNT` 对象。这些生成的对象被 `list()` 函数消耗，以创建一个单一的腿列表。来自
    [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004) 的 `haversine()`
    函数用于计算距离。'
- en: The rounding is applied in this function for two reasons. First, as a practical
    matter, 0.0001 nautical miles is about 20 cm (7 inches). Pragmatically, rounding
    to 0.001 nautical miles involves fewer digits that offer a false sense of precision.
    Second–and more important–it makes the unit testing more reliable across platforms
    if we avoid looking at all the digits of a floating-point number.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中应用四舍五入有两个原因。首先，从实际的角度来看，0.0001海里大约是20厘米（7英寸）。从实用主义的角度来看，将海里四舍五入到0.001海里涉及更少的数字，这会给人一种虚假的精确感。其次——更重要的是——如果我们避免查看浮点数的所有数字，这将使单元测试在各个平台上的可靠性更高。
- en: 'The final `trip` object is a sequence of `LegNT` instances. It will look as
    follows when we try to print it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`trip`对象是一系列`LegNT`实例。当我们尝试打印它时，它将如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s important to note that the `haversine()` function was written to use simple
    tuples. We’ve reused this function with a `NamedTuple` class instance. As we carefully
    preserved the order of the arguments, this small change in representation from
    anonymous tuple to named tuple was handled gracefully by Python.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`haversine()`函数是为了使用简单的元组而编写的。我们已经使用`NamedTuple`类实例重用了这个函数。由于我们仔细地保留了参数的顺序，从匿名元组到命名元组的这种表示形式的小变化被Python优雅地处理了。
- en: 'Since this is a class definition, we can easily add methods and properties.
    This ability to add features to a `NamedTuple` makes them particularly useful
    for computing derived values. We can, for example, more directly implement the
    distance computation as part of the `Point` class, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个类定义，我们可以轻松地添加方法和属性。将功能添加到`NamedTuple`的能力使它们特别适用于计算派生值。例如，我们可以更直接地将距离计算作为`Point`类的一部分来实现，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given this definition of the `PointE` class, we have encapsulated the functions
    for working with points and distances. This can be helpful because it gives the
    reader a single place to look for the relevant attributes and methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`PointE`类的这个定义，我们已经封装了处理点和距离的功能。这可能很有帮助，因为它为读者提供了一个查找相关属性和方法的单个位置。
- en: Within the body of the `PointE` class, we can’t easily refer to the class. The
    class name doesn’t exist within the body of the `class` statement. The mypy tool
    lets us use a string instead of a class name to resolve these rare cases when
    a class needs to refer to itself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PointE`类的主体中，我们无法轻松地引用类。类名不存在于`class`语句的主体中。mypy工具让我们可以使用字符串而不是类名来解析这些罕见的案例，当类需要引用自身时。
- en: 'We can use this class as shown in the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下示例来使用这个类：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In most cases, the `NamedTuple` class definition adds clarity. The use of `NamedTuple`
    will lead to a change from function-like prefix syntax to object-like suffix syntax.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`NamedTuple`类定义增加了清晰度。使用`NamedTuple`将导致从函数式前缀语法变为对象式后缀语法。
- en: 7.3 Using frozen dataclasses to collect data
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 使用冻结的数据类收集数据
- en: The third technique for collecting data into a complex structure is the frozen
    `@dataclass`. The idea is to create a class that is an immutable collection of
    named attributes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据收集到复杂结构中的第三种技术是冻结的`@dataclass`。其想法是创建一个包含命名属性的不可变集合的类。
- en: 'Following the example from the previous section, we can have nested dataclasses
    such as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 沿用上一节的示例，我们可以有如下嵌套数据类：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve used a decorator, `@dataclass(frozen=True)`, in front of the class definition
    to create an immutable (known as ”frozen”) dataclass. The decorator will add a
    number of functions for us, building a fairly sophisticated class definition without
    our having to provide anything other than the attributes. For more information
    on decorators, see [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design
    Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类定义前使用了装饰器`@dataclass(frozen=True)`来创建一个不可变（称为“冻结”）的数据类。装饰器将为我们添加一些函数，构建一个相当复杂但无需我们提供任何其他内容的类定义。有关装饰器的更多信息，请参阅[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)。
- en: 'This also changes the data structure from simple anonymous tuples to a class
    definition with type hints provided for each attribute. Here’s an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这也改变了数据结构，从简单的匿名元组变为具有为每个属性提供类型提示的类定义。以下是一个示例：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `first_leg` object was built as the `LegDC` instance. This object contains
    two other `PointDC` objects and a float value. Using `first_leg.start.latitude`
    will fetch a particular attribute of the object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`first_leg`对象被构建为`LegDC`实例。此对象包含两个其他`PointDC`对象和一个浮点值。使用`first_leg.start.latitude`将检索对象的特定属性。'
- en: The `DC` suffix in the names is not a recommended practice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中的`DC`后缀不是一个推荐的做法。
- en: We’ve included the suffix in the book to emphatically distinguish among similar-looking
    solutions to the problem of defining a useful class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中加入了后缀，以明确区分定义有用类时类似外观的解决方案。
- en: In actual applications, we’d choose one definition, and use the simplest, clearest
    names possible, avoiding needless suffixes that clutter up textbooks like this
    one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们会选择一个定义，并使用尽可能简单、清晰的名字，避免不必要的后缀，以免像这样的教科书变得杂乱无章。
- en: Replacing a `()` tuple construction with appropriate `LegDC()` or `PointDC()`
    constructors builds a more sophisticated data structure than anonymous tuples.
    It provides an explicitly named structure with type hints that can be checked
    by the mypy tool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将`()`元组构造替换为适当的`LegDC()`或`PointDC()`构造函数，可以构建比匿名元组更复杂的数据结构。它提供了一个具有类型提示的显式命名结构，这些提示可以通过mypy工具进行检查。
- en: 'Comparing frozen dataclasses with `NamedTuple` instances can lead to a ”Which
    is better?” discussion. There are a few tradeoffs here. Most notably, a `NamedTuple`
    object is extremely simple: it ties up relatively little memory and offers few
    methods. A dataclass, on the other hand, can have a great deal of built-in functionality,
    and can tie up more memory. We can manage this using the `slots=True` argument
    with the `@dataclass` decorator, something we’ll address later in this section.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 比较冻结的数据类与`NamedTuple`实例可能会引发“哪个更好？”的讨论。这里有一些权衡。最值得注意的是，`NamedTuple`对象极其简单：它占用的内存相对较少，提供的方法也较少。另一方面，数据类可以拥有大量的内置功能，并且可以占用更多的内存。我们可以通过使用`@dataclass`装饰器的`slots=True`参数来管理这一点，我们将在本节稍后讨论。
- en: Additionally, a `NamedTuple` object is a sequence of values. We can use an iterator
    over the tuple’s attributes, a processing option that seems to create nothing
    but confusion. Iterating over the values without using the names subverts the
    essential design concept of naming the members of the tuple.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个`NamedTuple`对象是一系列值的序列。我们可以使用元组属性的迭代器，这似乎只会造成混淆的处理选项。在不使用名字的情况下迭代值，违背了为元组的成员命名的基本设计概念。
- en: A simple procedure for evaluating memory use is to create millions of instances
    of a class and see how much memory is allocated for the Python runtime. This works
    out best because Python object size involves a recursive walk through all of the
    associated objects, each of which has its own complex sizing computation. Generally,
    we only care about aggregate memory use for a large collection of objects, so
    it’s more effective to measure that directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 评估内存使用的一个简单方法是创建数百万个类的实例，并查看为Python运行时分配了多少内存。这是因为Python对象的大小涉及到对所有相关对象的递归遍历，每个对象都有自己的复杂大小计算。通常，我们只关心大量对象的总内存使用，因此直接测量更为有效。
- en: 'Here is one class definition to support a script designed to evaluate the size
    of 1,000,000 `NamedTuple` objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个类定义，用于支持一个旨在评估100万个`NamedTuple`对象大小的脚本：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can then define a function to create a million objects, assigning them to
    a variable, `big_sequence`. The function can then report the amount of memory
    allocated by the Python runtime. This function will involve some odd-looking overheads.
    The documentation for the `getallocatedblocks()` function advises us to clear
    the type cache with the `sys._clear_type_cache()` function and force garbage collection
    via the `gc.collect()` function to clean up the objects that are no longer referenced.
    These two steps should compact memory to the smallest size, and provide more repeatable
    reports on the use of storage by this sequence of objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个函数来创建一百万个对象，将它们分配给变量`big_sequence`。然后该函数可以报告Python运行时分配的内存量。这个函数将涉及一些看起来很奇怪的开销。`getallocatedblocks()`函数的文档建议我们使用`sys._clear_type_cache()`函数清除类型缓存，并通过`gc.collect()`函数强制垃圾回收来清理不再被引用的对象。这两个步骤应该将内存压缩到最小尺寸，并提供关于该对象序列存储使用情况的更可重复的报告。
- en: 'The following function creates a million instances of a given type and displays
    the allocated memory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数创建了一个给定类型的百万个实例，并显示了Python运行时分配的内存：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Evaluating this function with different class definitions will reveal how much
    storage is occupied by 1,000,000 objects of that class. We can use `sizing(LargeNT)`
    to see the space taken up by a `NamedTuple` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的类定义评估此函数将揭示该类100万个对象占用的存储空间。我们可以使用`sizing(LargeNT)`来查看`NamedTuple`类占用的空间。
- en: We’ll need to define alternatives, of course. We can define a frozen dataclass.
    Additionally, we can use `@dataclass(frozen=True,`` slots=True)` to see what impact
    the use of `__slots__` has on the object sizing. The bodies of the classes must
    all have the same attributes in the same order to simplify construction of the
    objects by the `sizing()` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要定义替代方案。我们可以定义一个冻结的数据类。此外，我们可以使用`@dataclass(frozen=True, slots=True)`来查看`__slots__`的使用对对象大小的影响。类体必须具有相同的属性，并且顺序相同，以简化`
    sizing()`函数构建对象。
- en: 'The actual results are highly implementation-specific, but the author’s results
    on macOS Python 3.10.0 show the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际结果高度依赖于具体实现，但作者在macOS Python 3.10.0上的结果显示如下：
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Class Kind | Blocks Allocated |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 分配的块 |'
- en: '| LargeNT | 5,035,408 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| LargeNT | 5,035,408 |'
- en: '| LargeDC | 7,035,404 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| LargeDC | 7,035,404 |'
- en: '| LargeDC_Slots | 5,035,569 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| LargeDC_Slots | 5,035,569 |'
- en: '| Baseline | 35,425 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 基准 | 35,425 |'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: This suggests that a `@dataclass` will use about 40% more memory than a `NamedTuple`
    or a `@dataclass` with `slots=True`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`@dataclass`将比`NamedTuple`或带有`slots=True`的`@dataclass`使用大约40%更多的内存。
- en: This also suggests that a radically different design—one that uses iterators
    to avoid creating large in-memory collections—can use substantially less memory.
    What’s important is to have a correct solution in hand, and then explore alternative
    implementations to see which makes most effective use of the machine resources.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这还表明，一种根本不同的设计——使用迭代器来避免创建大型内存集合——可以显著减少内存使用。重要的是要有一个正确的解决方案，然后探索替代实现，以查看哪种方法最有效地利用机器资源。
- en: How to implement a complicated initialization is the most telling distinction
    among the various class definition approaches. We’ll look at that next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现复杂的初始化是各种类定义方法之间最明显的区别。我们将在下一节中探讨这一点。
- en: 7.4 Complicated object initialization and property computations
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 复杂对象初始化和属性计算
- en: 'When working with data in unhelpful formats, it often becomes necessary to
    build Python objects from source data that has a different structure or different
    underlying object types. There are two overall ways to treat object creation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理无用的数据格式时，通常需要从具有不同结构或不同底层对象类型的源数据中构建Python对象。处理对象创建有两种总体方法：
- en: It’s part of the application as a whole. Data should be decomposed by a parser
    and recomposed into useful Python objects. This is the approach we’ve taken in
    previous examples.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是整个应用程序的一部分。数据应由解析器分解，并重新组合成有用的Python对象。这是我们之前示例中采用的方法。
- en: It’s part of the object’s class definition. Source data should be provided more
    or less in its raw form, and the class definition will perform the necessary conversions.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是对象类定义的一部分。源数据应尽可能以原始形式提供，类定义将执行必要的转换。
- en: 'This distinction is never simple, nor crisp. Pragmatic considerations will
    identify the best approach for each unique case of building a Pythonic object
    from source data. The two examples that point to the distinct choices available
    are the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别从不简单，也不清晰。实用主义考虑将确定为从源数据构建Python对象的最佳方法。以下两个例子指出了可用的不同选择：
- en: 'The `Point` class: The syntax for geographic points is highly variable. A common
    approach is simple floating-point degree numbers. However, some sources provide
    degrees and minutes. Others might provide separate degrees, minutes, and seconds.
    Further, there are also Open Location Codes, which encode latitude and longitude.
    (See [https://maps.google.com/pluscodes/](https://maps.google.com/pluscodes/)
    for more information.) All of these various parsers should not be part of the
    class.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point` 类：地理点的语法非常多变。一种常见的方法是简单的浮点度数。然而，一些来源提供度数和分钟。其他可能提供单独的度数、分钟和秒。此外，还有开放位置码，它编码纬度和经度。（更多信息请参阅[https://maps.google.com/pluscodes/](https://maps.google.com/pluscodes/)。）所有这些不同的解析器都不应成为类的一部分。'
- en: 'The `LegNT` (or `LegDC`) class: The leg includes two points and a distance.
    The distance can be seeded as a simple value. It can also be computed as a property.
    A third choice is to use a sophisticated object builder. In effect, our `get_trip()`
    function (defined in [Using NamedTuple to collect data](#x1-1550002)) has implicitly
    included an object builder for `LegNT` objects.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LegNT`（或`LegDC`）类：腿包括两个点和一段距离。距离可以作为一个简单值来设置。它也可以作为一个属性来计算。第三种选择是使用一个复杂的对象构建器。实际上，我们的`get_trip()`函数（在[使用NamedTuple收集数据](#x1-1550002)中定义）已经隐式地包含了一个`LegNT`对象的构建器。'
- en: 'Using `LegNT(start,`` end,`` round(haversine(start,`` end),`` 4))` to create
    a `LegNT` instance isn’t wrong, but it makes a number of assumptions that need
    to be challenged. Here are some of the assumptions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LegNT(start, end, round(haversine(start, end), 4))`来创建`LegNT`实例并没有错，但它做了一些需要挑战的假设。以下是一些假设：
- en: The application should always use `haversine()` to compute distances.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该始终使用`haversine()`来计算距离。
- en: The application should always pre-compute the distance. This is often an optimization
    question. Computing a distance once and saving it is helpful if every leg’s distance
    will be examined. If distances are not always needed, it can be less expensive
    to compute the distance only when required.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该始终预先计算距离。这通常是一个优化问题。如果每个腿的距离都会被检查，那么计算一次并保存距离是有帮助的。如果距离不是总是需要的，那么仅在需要时计算距离可能更节省成本。
- en: We always want to create `LegNT` instances. We’ve already seen cases where we
    might want a `@dataclass` implementation. In the next section, we’ll look at a
    `pyrsistent.PRecord` implementation.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是希望创建`LegNT`实例。我们已经看到了可能需要`@dataclass`实现的情况。在下一节中，我们将查看`pyrsistent.PRecord`实现。
- en: One general way to encapsulate the construction of `LegNT` instances is to use
    a `@classmethod` to handle complex initialization. Additionally, a `@dataclass`
    provides some additional initialization techniques.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 封装`LegNT`实例构建的一个通用方法是使用`@classmethod`来处理复杂的初始化。此外，`@dataclass`提供了一些额外的初始化技术。
- en: 'A slightly better way to define a `NamedTuple` initialization is shown in the
    following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个更好的定义`NamedTuple`初始化的例子：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compare the above definition, which eagerly computes the distance, with the
    following, which lazily computes the distance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述立即计算距离的定义与以下延迟计算距离的定义进行比较：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both of these class definitions have an identical `create()` method. We can
    use `EagerLeg.create(start,`` end)` or `LazyLeg.create(start,`` end)` without
    breaking anything else in the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类定义都有一个相同的`create()`方法。我们可以使用`EagerLeg.create(start, end)`或`LazyLeg.create(start,
    end)`而不会破坏应用中的其他部分。
- en: What’s most important is that the decision to compute values eagerly or lazily
    becomes a decision that we can alter at any time. We can replace these two definitions
    to see which has higher performance for our specific application’s needs. The
    distance computation, similarly, is now part of this class, making it easier to
    define a subclass to make a change to the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，决定是否立即计算值或延迟计算值，这个决定可以随时更改。我们可以替换这两个定义，看看哪个更适合我们特定应用的需求。同样，距离计算现在也是这个类的一部分，这使得定义一个子类来更改应用变得更加容易。
- en: 'A dataclass offers a somewhat more complex and flexible interface for object
    construction: a `__post_init__()` method. This method is evaluated after the object’s
    fields have their values assigned, permitting eager calculation of derived values.
    This, however, can’t work for frozen dataclasses. The `__post_init__()` method
    can only be used for non-frozen dataclasses to eagerly compute additional values
    from the provided initialization values.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类提供了一个相对复杂且灵活的对象构建接口：一个`__post_init__()`方法。此方法在对象的字段值分配后执行，允许对派生值进行立即计算。然而，这对于冻结的数据类是不适用的。`__post_init__()`方法只能用于非冻结数据类，以便从提供的初始化值中立即计算额外的值。
- en: For dataclasses, as well as `NamedTuple` classes, a `@classmethod` creator is
    a good design pattern for doing initialization that involves eagerly computing
    attribute values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据类以及`NamedTuple`类，一个`@classmethod`创建器是一个好的设计模式，用于涉及立即计算属性值的初始化。
- en: 'As a final note on initialization, there are three different syntax forms for
    creating named tuple objects. Here are the three choices:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于初始化的说明，创建命名元组对象有三种不同的语法形式。以下是三种选择：
- en: 'We can provide the values positionally. This works well when the order of the
    parameters is obvious. It looks like this:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以按位置提供值。当参数的顺序明显时，这效果很好。看起来是这样的：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can unpack a sequence using the `*` operator. This, too, requires the ordering
    of parameters be obvious. For example:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`*`运算符解包一个序列。这也要求参数的顺序明显。例如：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use explicit keyword assignment. This has the advantage of making the
    parameter names clear and avoids hidden assumptions about ordering. Here’s an
    example:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用显式的关键字赋值。这有利于使参数名称清晰，并避免了关于排序的隐藏假设。以下是一个示例：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These examples show one way to package the initialization of complex objects.
    What’s important is to avoid state change in these objects. A complex initialization
    is done exactly once, providing a single, focused place to understand how the
    object’s state was established. For this reason, it’s imperative for the initialization
    to be expressive of the object’s purpose as well as flexible to permit change.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了封装复杂对象初始化的一种方法。重要的是要避免在这些对象中发生状态变化。复杂的初始化只执行一次，提供了一个单一、集中的地方来理解对象状态是如何建立的。因此，初始化必须能够表达对象的目的，同时也要灵活，以便允许变化。
- en: 7.5 Using pyrsistent to collect data
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 使用pyrsistent收集数据
- en: In addition to Python’s `NamedTuple` and `@dataclass` definitions, we can also
    use the `pyrsistent` module to create more complex object instances. The huge
    advantage offered by the `pyrsistent` module is that the collections are immutable.
    Instead of updating in place, a change to a collection works through a general-purpose
    ”evolution” object that creates a new immutable object with the changed value.
    In effect, what appears to be a state-changing method is actually an operator
    creating a new object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python的`NamedTuple`和`@dataclass`定义之外，我们还可以使用`pyrsistent`模块创建更复杂的对象实例。`pyrsistent`模块提供的巨大优势是集合是不可变的。而不是就地更新，集合的更改通过一个通用“进化”对象来完成，该对象创建一个新的具有更改值的不可变对象。实际上，看似状态改变的方法实际上是一个创建新对象的运算符。
- en: 'The following example shows how to import the `pyrsistent` module and create
    a mapping structure with names and values:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何导入`pyrsistent`模块并使用名称和值创建映射结构：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can’t change the value of this object, but we can evolve an object `v` to
    a new object, `v2`. This object has the same starting values, but also includes
    a changed attribute value. It looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能改变这个对象的值，但我们可以将对象`v`进化为新的对象`v2`。这个对象具有相同的起始值，但还包括一个更改的属性值。看起来是这样的：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The original object, `v`, is immutable, and its value hasn’t changed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 原始对象`v`是不可变的，其值没有改变：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It can help to think of this operation as having two parts. First, the original
    object is cloned. After the cloning, the changes are applied. In the above example,
    the `set()` method was used to provide a new key and value. We can create the
    evolution separately and apply it to an object to create a clone with changes
    applied. This seems ideal for an application where an audit history of changes
    is required.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于将这个操作想象成有两个部分。首先，原始对象被克隆。在克隆之后，应用更改。在上面的例子中，使用了`set()`方法提供新的键和值。我们可以单独创建进化，并将其应用于对象以创建一个应用了更改的克隆。这似乎非常适合需要更改审计历史记录的应用程序。
- en: Note that we had to prevent using two examples as unit test cases. This is because
    the order of the keys isn’t fixed. It’s easy to check that the keys and values
    match our expectations, but a simplistic comparison with a dictionary literal
    doesn’t always work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不防止使用两个示例作为单元测试用例。这是因为键的顺序是不固定的。很容易检查键和值是否符合我们的预期，但与字典字面量的简单比较并不总是有效。
- en: 'The `PRecord` class is appropriate for defining complex objects. These objects
    are similar in some ways to a `NamedTuple`. We’ll revisit our waypoint and leg
    data model using `PRecord` instances. The definitions are given in the following
    example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRecord`类适用于定义复杂对象。这些对象在某些方面类似于`NamedTuple`。我们将使用`PRecord`实例重新审视我们的航点和路段数据模型。定义如下所示：'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each field definition uses the sophisticated `field()` function to build the
    definition of the attribute. In addition to a sequence of types, this function
    can specify an invariant condition that must be true for the values, an initial
    value, whether or not the field is mandatory, a factory function that builds appropriate
    values, and a function to serialize the value into a string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段定义都使用复杂的 `field()` 函数来构建属性的定义。除了类型序列之外，此函数还可以指定必须对值有效的不可变条件、初始值、字段是否为必需的、构建适当值的工厂函数以及将值序列化为字符串的函数。
- en: The PR suffix in the names is not a recommended practice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中的 PR 后缀不是一个推荐的做法。
- en: We’ve included the suffix in the book to emphatically distinguish among similar-looking
    solutions to the problem of defining a useful class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中包含了后缀，以明确区分类似的问题定义的有用类的类似解决方案。
- en: In actual applications, we’d choose one definition, and use the simplest, clearest
    names possible, avoiding needless suffixes that clutter up textbooks like this
    one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们会选择一个定义，并使用尽可能简单、清晰的名称，避免不必要的后缀，以免像这样的教科书变得杂乱。
- en: 'As an extension to these definitions, we could convert the point value into
    a more useful format using a serializer function. This requires some formatting
    details because there’s a slight difference in the way latitudes and longitudes
    are displayed. Latitudes include ”N” or ”S” and longitudes include ”E” or ”W”:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些定义的扩展，我们可以使用序列化函数将点值转换为更有用的格式。这需要一些格式化细节，因为纬度和经度的显示方式略有不同。纬度包括 “N” 或 “S”，经度包括
    “E” 或 “W”：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function can be included as part of the field definition for the `PointPR`
    class; we must provide the function as the `serializer=` parameter of the `field()`
    factory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以作为 `PointPR` 类的字段定义的一部分包含；我们必须将函数作为 `field()` 工厂函数的 `serializer=` 参数提供：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This lets us print a point in a nicely formatted style:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们能够以优雅的格式打印一个点：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These definitions will provide nearly identical processing capabilities to the
    `NamedTuple` and `@dataclass` examples shown earlier. We can, however, leverage
    some additional features of the `pyrsistent` package to create `PVector` objects,
    which will be immutable sequences of waypoints in a trip. This requires a few
    small changes to previous applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义将提供与之前展示的 `NamedTuple` 和 `@dataclass` 示例几乎相同的处理能力。然而，我们可以利用 `pyrsistent`
    包的一些附加功能来创建 `PVector` 对象，这些对象将是旅行中航点的不可变序列。这需要对先前应用程序进行一些小的更改。
- en: 'The definition of the `get_trip()` function using `pyrsistent` can look like
    this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pyrsistent` 定义 `get_trip()` 函数可能看起来像这样：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first change is relatively large. Instead of rewriting the `float_lat_lon()`
    function to return a `PointPR` object, we left this function alone. We used the
    `PRecord.create()` method to convert a dictionary into a `PointPR` instance. Given
    the two `PointPR` objects and the distance, we can create a `LegPR` object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改相对较大。我们不是将 `float_lat_lon()` 函数重写为返回 `PointPR` 对象，而是保留了此函数。我们使用 `PRecord.create()`
    方法将字典转换为 `PointPR` 实例。给定两个 `PointPR` 对象和距离，我们可以创建一个 `LegPR` 对象。
- en: 'Earlier in this chapter, we showed a version of the `legs()` function that
    returned `typing.NamedTuple` instances with the raw data for each point along
    a leg. The `_asdict()` method of a `NamedTuple` will translate the tuple into
    a dictionary. The tuple’s attribute names will be keys in the dictionary. The
    transformation can be seen in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们展示了 `legs()` 函数的一个版本，该版本返回包含每条腿上每个点的原始数据的 `typing.NamedTuple` 实例。`NamedTuple`
    的 `_asdict()` 方法将元组转换为字典。元组的属性名称将是字典中的键。这种转换可以在以下示例中看到：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This can then be provided to the `PointPR.create()` method to create a proper
    `PointPR` instance that will be used in the rest of the application. The initial
    `PointNT` object can be discarded, having served as a bridge between input parsing
    and building more useful Python objects. In the long run, it’s a good idea to
    revisit the underlying `legs()` function to rewrite it to work with `pyrsistent`
    record definitions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将它提供给 `PointPR.create()` 方法来创建一个合适的 `PointPR` 实例，该实例将在应用程序的其余部分中使用。初始的
    `PointNT` 对象可以被丢弃，因为它已经作为输入解析和构建更有用的 Python 对象之间的桥梁。从长远来看，重新审视底层的 `legs()` 函数并将其重写为与
    `pyrsistent` 记录定义一起工作是一个好主意。
- en: Finally, instead of assembling a `list` from the iterator, we assembled a `PVector`
    instance, using the `pvector()` function. This has many of the same properties
    as the built-in list class, but is immutable. Any changes will create a clone
    of the object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不是从迭代器中组装一个`list`，而是使用`pvector()`函数组装一个`PVector`实例。这具有与内置列表类许多相同的属性，但不可变。任何更改都将创建对象的克隆。
- en: These high-performance, immutable collections are helpful ways to be sure an
    application behaves in a functional manner. The handy serialization into JSON-friendly
    notation makes these class definitions ideal for applications that make use of
    JSON. Web servers, in particular, can benefit from using these class definitions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高性能、不可变的集合是确保应用程序以函数式方式行为的有帮助的方法。这些便于序列化为JSON友好格式的类定义非常适合使用JSON的应用程序。特别是，Web服务器可以从使用这些类定义中受益。
- en: 7.6 Avoiding stateful classes by using families of tuples
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6 通过使用元组家族避免有状态类
- en: In several previous examples, we’ve shown the idea of wrap-unwrap design patterns
    that allow us to work with anonymous and named tuples. The point of this kind
    of design is to use immutable objects that wrap other immutable objects instead
    of mutable instance variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个先前的例子中，我们展示了wrap-unwrap设计模式的概念，这种模式允许我们处理匿名和命名元组。这种设计的目的在于使用包装其他不可变对象的不可变对象，而不是可变实例变量。
- en: 'A common statistical measure of correlation between two sets of data is the
    Spearman’s rank correlation. This compares the rankings of two variables. Rather
    than trying to compare values, which might have different units of measure, we’ll
    compare the relative orders. For more information, visit: [https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm](https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数据集之间常见的统计相关度度量是斯皮尔曼秩相关度。这比较了两个变量的排名。我们不是试图比较值，这些值可能具有不同的度量单位，而是比较相对顺序。更多信息，请访问：[https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm](https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm)。
- en: Computing the Spearman’s rank correlation requires assigning a rank value to
    each observation. It seems like we should be able to use `enumerate(sorted())`
    to do this. Given two sets of possibly correlated data, we can transform each
    set into a sequence of rank values and compute a measure of correlation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斯皮尔曼秩相关度需要为每个观测值分配一个秩值。看起来我们应该能够使用`enumerate(sorted())`来完成这个任务。给定两组可能相关的数据，我们可以将每组数据转换为一个秩值的序列，并计算相关度度量。
- en: We’ll apply the wrap-unwrap design pattern to do this. We’ll wrap data items
    with their rank for the purposes of computing the correlation coefficient.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用wrap-unwrap设计模式来完成这个任务。我们将用计算相关系数的目的来包装数据项及其秩。
- en: 'In [Chapter 3](Chapter_03.xhtml#x1-510003), [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003),
    we showed how to parse a simple dataset. We’ll extract the four samples from that
    dataset as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)中，我们展示了如何解析一个简单的数据集。我们将按照以下方式从该数据集中提取四个样本：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The resulting collection of data has four different series of data combined
    in each row. A `series()` function was defined in [Generators for lists, dicts,
    and sets](Chapter_03.xhtml#x1-610001), back in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003), to extract
    the pairs for a given series from the overall row.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据集的每一行都组合了四个不同的数据系列。在[第3章](Chapter_03.xhtml#x1-510003)，[列表、字典和集合的生成器](Chapter_03.xhtml#x1-610001)中定义了一个`series()`函数，用于从整体行中提取给定系列的配对。
- en: 'The definition looked like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义看起来是这样的：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The argument to this function is an iterable of some source type (usually a
    string). The result of this function is an iterable series of two-tuples from
    the source type. When working with CSV files, strings are the expectation. It’s
    much nicer for the result to be a named tuple.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的参数是一个源类型的可迭代对象（通常是一个字符串）。此函数的结果是从源类型生成的两个元组的可迭代序列。当处理CSV文件时，期望结果是命名元组。
- en: 'Here’s a named tuple for each pair:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每对都有一个命名元组：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’ll introduce a transformation to convert anonymous tuples into named tuples
    or dataclasses:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一种转换，将匿名元组转换为命名元组或数据类：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `RawPairIter` type definition describes the intermediate output from the
    `series()` function. This function emits an iterable sequence of two-tuples. The
    `pairs` lambda object is a callable that expects an iterable and will produce
    a list of `Pair` named tuples or dataclass instances.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`RawPairIter`类型定义描述了`series()`函数的中间输出。这个函数发出一个包含两个元组的可迭代序列。`pairs`lambda对象是一个可调用的对象，它期望一个可迭代对象，并将产生一个`Pair`命名元组或数据类实例的列表。'
- en: 'The following shows how the `pairs()` function and the `series()` function
    are used to create pairs from the original data:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如何使用`pairs()`函数和`series()`函数从原始数据创建对：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each of these series is a list of `Pair` objects. Each `Pair` object has `x`
    and `y` attributes. The data looks as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列中的每一个都是`Pair`对象的列表。每个`Pair`对象都有`x`和`y`属性。数据看起来如下：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ll break the rank ordering problem into two parts. First, we’ll look at a
    generic, higher-order function that we can use to assign ranks to any attribute.
    For example, it can rank a sample according to either the the `x` or `y` attribute
    value of a `Pair` object. Then, we’ll define a wrapper around the `Pair` object
    that includes the various rank order values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将排名排序问题分为两部分。首先，我们将查看一个通用的高阶函数，我们可以用它来为任何属性分配排名。例如，它可以按`Pair`对象的`x`或`y`属性值对样本进行排名。然后，我们将定义一个围绕`Pair`对象的包装器，包括各种排名顺序值。
- en: So far, this seems like a place where we can wrap each pair, sort them into
    order, then use a function like `enumerate()` to assign ranks. It turns out that
    this approach isn’t really the proper algorithm for rank ordering.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这似乎是一个我们可以包裹每一对，按顺序排序，然后使用像`enumerate()`这样的函数来分配排名的地方。但结果是，这种方法并不是真正的排名排序算法。
- en: While the essence of rank ordering is being able to sort the samples, there’s
    another important part of this. When two observations have the same value, they
    should get the same rank. The general rule is to average the positions of equal
    observations. The sequence `[0.8,`` 1.2,`` 1.2,`` 2.3,`` 18]` should have rank
    values of 1, 2.5, 2.5, 4, 5\. The two ties with ranks of 2 and 3 have the midpoint
    value of 2.5 as their common rank.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然排名排序的本质是能够对样本进行排序，但这还有另一个重要部分。当两个观测值具有相同的值时，它们应该获得相同的排名。一般规则是平均相等观测值的位次。序列`[0.8,
    1.2, 1.2, 2.3, 18]`应该有排名值1, 2.5, 2.5, 4, 5。排名为2和3的两个平局值的中点值为2.5，作为它们的共同排名。
- en: A consequence of this is that we don’t really need to sort all of the data.
    We can, instead, create a dictionary with a given attribute value and all of the
    samples that share the attribute value. All these items have a common rank. Given
    this dictionary, the keys need to be processed in ascending order. For some collections
    of data, there may be significantly fewer keys than original sample objects being
    ranked.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致的结果是我们实际上并不需要对所有数据进行排序。相反，我们可以创建一个包含给定属性值及其共享属性值的所有样本的字典。所有这些项目都有一个共同的排名。给定这个字典，键需要按升序处理。对于某些数据集，键的数量可能比原始样本对象要少得多。
- en: 'The rank ordering function works in two passes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 排名排序函数分为两个阶段：
- en: First, it builds a dictionary listing samples with duplicate values. We can
    call this the `build_duplicates()` phase.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它构建一个字典，列出具有重复值的样本。我们可以称之为`build_duplicates()`阶段。
- en: Second, it emits a sequence of values, in ranked order, with a mean rank order
    for the items with the same value. We can call this the `rank_output()` phase.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，它按排名顺序发出一系列值，对于具有相同值的项，有一个平均排名顺序。我们可以称之为`rank_output()`阶段。
- en: 'The following function implements the two-phase ordering via two embedded functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数通过两个嵌套函数实现了两阶段排序：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, this rank ordering function has two internal functions to transform
    a list of samples to a list of two-tuples, each pair having the assigned rank
    and the original sample object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个排名排序函数有两个内部函数，用于将样本列表转换为包含分配的排名和原始样本对象的元组列表。
- en: To keep the data structure type hints simple, the base type of the sample tuple
    is defined as `BaseT`, which can be any of the string, integer, or float types.
    The essential ingredient here is a simple, hashable, and comparable object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持数据结构类型提示简单，样本元组的基类型定义为`BaseT`，可以是任何字符串、整数或浮点类型。这里的本质成分是一个简单、可哈希且可比较的对象。
- en: Similarly, the `DataT` type is any type for the raw samples; the claim is that
    it will be used consistently throughout the function, and it’s two internal functions.
    This is an intentionally vague claim, because any kind of `NamedTuple`, dataclass,
    or `PRecord` will work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`DataT` 类型是原始样本的任何类型；声称它将在整个函数中一致使用，并且有两个内部函数。这是一个故意模糊的声明，因为任何类型的 `NamedTuple`、dataclass
    或 `PRecord` 都可以工作。
- en: The `build_duplicates()` function works with a stateful object to build the
    dictionary that maps keys to values. This implementation relies on the tail-call
    optimization of a recursive algorithm. The arguments to `build_duplicates()` expose
    the internal state as argument values. A base case for a recursive definition
    is when `data_iter` is empty.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_duplicates()` 函数与一个有状态的对象一起工作，构建将键映射到值的字典。这种实现依赖于递归算法的尾调用优化。`build_duplicates()`
    的参数将内部状态作为参数值暴露出来。递归定义的一个基本情况是当 `data_iter` 为空时。'
- en: Similarly, the `rank_output()` function could be defined recursively to emit
    the original collection of values as two-tuples with the assigned rank values.
    What’s shown is an optimized version with two nested `for` statements. To make
    the rank value computation explicit, it includes the low end of the range (`base+1`),
    the high end of the range (`base+dups`), and computes the midpoint of these two
    values. If there is only a single duplicate, the rank value is `(2*base+2)/2`,
    which has the advantage of being a general solution, resulting in `base+1`, in
    spite of extra computations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`rank_output()` 函数可以被递归定义，以将原始值集合作为带有分配的排名值的元组输出。下面展示的是一个包含两个嵌套 `for` 语句的优化版本。为了使排名值的计算明确，它包括范围的低端（`base+1`）、高端（`base+dups`），并计算这两个值的中间点。如果只有一个重复值，排名值是
    `(2*base+2)/2`，它具有一般解的优势，即使在额外的计算中也会得到 `base+1`。
- en: The dictionary of duplicates has the type hint of `dict[BaseT,`` list[tuple[BaseT,`` ...]]]`,
    because it maps a sample attribute value, `BaseT`, to lists of the original data
    item type, `tuple[BaseT,`` ...]`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重复值的字典类型提示为 `dict[BaseT, list[tuple[BaseT, ...]]]`，因为它将样本属性值 `BaseT` 映射到原始数据项类型
    `tuple[BaseT, ...]` 的列表。
- en: 'The following is how we can test this to be sure it works. The first example
    ranks individual values. The second example ranks a list of pairs, using a lambda
    to pick the key value from each pair:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何测试以确保它工作的方法。第一个例子对单个值进行排名。第二个例子对一对列表进行排名，使用 lambda 从每个对中选取键值：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The sample data included two identical values. The resulting ranks split positions
    2 and 3 to assign position 2.5 to both values. This confirms that the function
    implements the common statistical practice for computing the Spearman’s rank-order
    correlation between two sets of values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 样本数据包含两个相同的值。结果排名将位置 2 和 3 分开，将位置 2.5 分配给两个值。这证实了该函数实现了计算两组值之间斯皮尔曼等级相关系数的常见统计惯例。
- en: The `rank()` function involves rearranging the input data as part of discovering
    duplicated values. If we want to rank on both the x and y values in each pair,
    we need to reorder the data twice.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank()` 函数涉及到重新排列输入数据，作为发现重复值的一部分。如果我们想在每对中的 x 和 y 值上进行排名，我们需要对数据进行两次重新排序。'
- en: 7.6.1 Computing Spearman’s rank-order correlation
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.1 计算斯皮尔曼等级相关系数
- en: 'The Spearman rank-order correlation is a comparison between the rankings of
    two variables. It neatly bypasses the magnitude of the values, and it can often
    find a correlation even when the relationship is not linear. The formula is as
    follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 斯皮尔曼等级相关系数是两个变量等级的比较。它巧妙地绕过了值的幅度，并且当关系不是线性的情况下，它通常可以找到相关性。公式如下：
- en: '![ 6∑ (rx − ry)2 ρ = 1− -----2------- n(n − 1) ](img/file63.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![ 6∑ (rx − ry)2 ρ = 1− -----2------- n(n − 1) ](img/file63.jpg)'
- en: This formula shows us that we’ll be summing the differences in rank r[x], and
    r[y], for all of the pairs of observed values. This requires computing ranks on
    both x and y variables. This means merging the two rank values into a single,
    composite object with ranking combined with the original raw sample.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式表明，我们将对所有观察值对中的排名 r[x] 和 r[y] 的差异进行求和。这需要计算 x 和 y 变量的排名。这意味着将两个排名值合并成一个单一的复合对象，其中排名与原始原始样本结合。
- en: 'The target class could look like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类可能看起来如下：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This can be built by first ranking on one variable, then computing a second
    ranking of the raw data. For a simple dataset with a few variables, this isn’t
    terrible. For more than a few variables, this becomes needlessly complicated.
    The function definitions, in particular for ranking, would all be nearly identical,
    suggesting a need to factor out the common code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过首先对一个变量进行排序，然后计算原始数据的第二个排序来实现。对于具有少量变量的简单数据集，这并不糟糕。对于超过几个变量的情况，这变得没有必要地复杂。特别是对于排序的功能定义，它们几乎都是相同的，这表明需要提取出公共代码。
- en: It works out much better to depend on using the `pyrsistent` module to create,
    and evolve, the values in a dictionary that accumulate ranking values. We can
    use a `PRecord` pair that has a dictionary of rankings and the original data.
    The dictionary of rankings is an immutable `PMap`. This means that any attempt
    to make a change will lead to evolving a new instance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于使用`pyrsistent`模块来创建和演变字典中的值，效果会好得多，该字典累积排序值。我们可以使用一个包含排名字典和原始数据的`PRecord`对。排名的字典是一个不可变的`PMap`。这意味着任何尝试进行更改都将导致演变一个新的实例。
- en: The instance, after being evolved, is immutable. We can clearly separate the
    accumulation of state from processing objects that do not have any further state
    changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 经过演变后，实例是不可变的。我们可以清楚地将状态的累积与处理没有进一步状态更改的对象分开。
- en: 'Here’s our `PRecord` subclass that contains the ranking mapping and the original,
    raw data:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的包含排名映射和原始、原始数据的`PRecord`子类：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Within each `Ranked_XY`, the `PMap` dictionary provides a mapping from the variable
    name to the ranking value. The raw data is the original sample. We want to be
    able to use `sample.rank[attribute_name]` to extract the ranking for a specific
    attribute.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`Ranked_XY`中，`PMap`字典提供了从变量名到排名值的映射。原始数据是原始样本。我们希望能够使用`sample.rank[attribute_name]`来提取特定属性的排名。
- en: 'We can reuse our generic `rank()` function to build the essential information
    that contains a ranking and the raw data. We can then merge each new ranking into
    a `Ranked_XY` instance. The following function definition will compute rankings
    for two attributes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用通用的`rank()`函数来构建包含排名和原始数据的基本信息。然后我们可以将每个新的排名合并到一个`Ranked_XY`实例中。以下函数定义将计算两个属性的排名：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve built an initial list of `Ranked_XY` objects with empty ranking dictionaries.
    For each attribute of interest, we’ll use the previously defined `rank()` function
    to create a sequence of rank values and raw objects. The `for` clause of the generator
    decomposes the ranking two-tuple into `r`, the ranking, and `original`, the raw
    source data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个包含空排名字典的`Ranked_XY`对象的初始列表。对于每个感兴趣的属性，我们将使用先前定义的`rank()`函数来创建一系列排名值和原始对象。生成器的`for`子句将排名的双元组分解为`r`（排名）和`original`（原始源数据）。
- en: 'From each pair of values from the underlying `rank()` function, we’ve made
    two changes to the `pyrsistent` module’s data structures. We’ve used the following
    expression to create a new dictionary of the previous rankings merged with this
    new ranking:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从底层`rank()`函数的每一对值中，我们对`pyrsistent`模块的数据结构进行了两项更改。我们使用了以下表达式来创建一个包含先前排名和新排名的新字典：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The result of this becomes part of the `original.set(rank=...)` expression to
    create a new `Rank_XY` object using the newly evolved rank, `PMap` instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果成为`original.set(rank=...)`表达式的一部分，用于创建一个新的`Rank_XY`对象，使用新演变的排名和`PMap`实例。
- en: 'The `.set()` method is an ”evolver”: it creates a new object by applying a
    new state to an existing object. These changes by evolution are important because
    they result in new, immutable objects.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`.set()`方法是一个“演变器”：它通过将新状态应用于现有对象来创建一个新的对象。这些通过演变产生的变化很重要，因为它们导致新的、不可变的对象。'
- en: The `#`` type:`` ignore`` [arg-type]` comment is required to silence a mypy
    warning. The type information used internally by the `pyrsistent` module isn’t
    visible to mypy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '需要使用`# type: ignore [arg-type]`注释来抑制mypy警告。`pyrsistent`模块内部使用的类型信息对mypy不可见。'
- en: 'A Python version of a rank correlation function depends on the `sum()` and
    `len()` functions, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本的排名相关函数依赖于`sum()`和`len()`函数，如下所示：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve created `Rank_XY` objects for each `Pair` object. Given this, we can then
    subtract the `r_x` and `r_y` values from those pairs to compare their difference.
    We can then square and sum the differences.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个`Pair`对象创建了`Rank_XY`对象。鉴于这一点，我们可以从这些对中减去`r_x`和`r_y`值来比较它们的差异。然后我们可以对差异进行平方和求和。
- en: See [Avoiding stateful classes by using families of tuples](#x1-1590006) earlier
    in this chapter for the definition of the `Pair` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，请参阅[通过使用元组族避免状态类](#x1-1590006)以了解`Pair`类的定义。
- en: Again, we’ve had to suppress mypy warnings related to the lack of detailed internal
    type hints in the `pyrsistent` module. Because this works properly, we feel confident
    in silencing the warnings.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不得不抑制与`pyrsistent`模块中缺乏详细内部类型提示相关的mypy警告。因为这样工作正常，所以我们有信心关闭这些警告。
- en: A good article on statistics will provide detailed guidance on what the coefficient
    means. A value around 0 means that there is no correlation between the data ranks
    of the two series of data points. A scatter plot shows a random scattering of
    points. A value around +1 or -1 indicates a strong relationship between the two
    values. A graph of the pairs would show a clear line or simple curve.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇好的统计文章将提供关于系数含义的详细指导。数值约为0表示两个数据点的数据排名之间没有相关性。散点图显示点随机分布。数值约为+1或-1表示两个值之间存在强关系。成对的图形将显示一条清晰的直线或简单的曲线。
- en: 'The following is an example based on Anscombe’s quartet series:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于安斯康姆四重奏系列的示例：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this particular dataset, the correlation is strong.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定数据集，相关性很强。
- en: 'In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we showed how to compute the Pearson correlation coefficient. The function we
    showed, `corr()`, worked with two separate sequences of values. We can use it
    with our sequence of `Pair` objects as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](Chapter_04.xhtml#x1-740004)中，[使用集合](Chapter_04.xhtml#x1-740004)，我们展示了如何计算皮尔逊相关系数。我们展示的函数`corr()`与两个单独的值序列一起工作。我们可以用以下方式使用我们的`Pair`对象序列：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We’ve unwrapped the `Pair` objects to get the raw values that we can use with
    the existing `corr()` function. This provides a different correlation coefficient.
    The Pearson value is based on how well the standardized values compare between
    two sequences. For many datasets, the difference between the Pearson and Spearman
    correlations is relatively small. For some datasets, however, the differences
    can be quite large.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解包了`Pair`对象，以获取我们可以与现有的`corr()`函数一起使用的原始值。这提供了不同的相关系数。皮尔逊值基于标准化值在两个序列之间的比较程度。对于许多数据集，皮尔逊和斯皮尔曼相关系数之间的差异相对较小。然而，对于某些数据集，差异可能相当大。
- en: To see the importance of having multiple statistical tools for exploratory data
    analysis, compare the Spearman and Pearson correlations for the four sets of data
    in Anscombe’s quartet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到拥有多个统计工具进行探索性数据分析的重要性，比较安斯康姆四重奏中的四组数据的斯皮尔曼和皮尔逊相关系数。
- en: 7.7 Polymorphism and type pattern matching
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7 多态性和类型模式匹配
- en: Some functional programming languages offer some clever approaches to the problem
    of working with statically typed function definitions. The problem is that many
    functions we’d like to write are entirely generic with respect to data type. For
    example, most of our statistical functions are identical for `int` or `float`
    numbers, as long as the division returns a value that is a subclass of `numbers.Real`.
    The types `Decimal`, `Fraction`, and `float` should all work almost identically.
    In many functional languages, sophisticated type or type-pattern matching rules
    are used by the compiler to allow a single generic definition to work for multiple
    data types.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言提供了一些巧妙的方法来解决与静态类型函数定义一起工作的问题。问题是许多我们想写的函数在数据类型上完全是通用的。例如，我们的大多数统计函数对于`int`或`float`数字都是相同的，只要除法返回一个`numbers.Real`子类的值。`Decimal`、`Fraction`和`float`类型都应该几乎以相同的方式工作。在许多函数式语言中，编译器使用复杂的类型或类型模式匹配规则，允许单个通用定义适用于多个数据类型。
- en: Instead of the (possibly) complex features of statically typed functional languages,
    Python changes the approach dramatically. Python uses dynamic selection of the
    final implementation of an operator based on the data types being used. In Python,
    we always write generic definitions. The code isn’t bound to any specific data
    type. The Python runtime will locate the appropriate operations based on the types
    of the actual objects in use. The 6.1\. Arithmetic conversions and 3.3.8\. Emulating
    numeric types sections of the language reference manual and the `numbers` module
    in the standard library provide details on how this mapping from operation to
    special method name works.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态类型函数式语言的（可能）复杂特性不同，Python在方法上进行了戏剧性的改变。Python使用基于所使用的数据类型的动态选择操作符最终实现。在Python中，我们总是编写通用定义。代码不绑定到任何特定的数据类型。Python运行时会根据实际使用对象的类型定位适当的操作。语言参考手册中的6.1.算术转换和3.3.8.模拟数值类型部分以及标准库中的`numbers`模块提供了关于这种从操作到特殊方法名映射的详细信息。
- en: In Python, there’s no compiler to certify that our functions are expecting and
    producing the proper data types. We generally rely on unit testing and the mypy
    tool for this kind of type checking.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有编译器来证明我们的函数期望并产生正确的数据类型。我们通常依赖于单元测试和mypy工具来进行这种类型检查。
- en: 'In rare cases, we might need to have different behavior based on the types
    of data elements. We have two ways to tackle this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，我们可能需要根据数据元素的类型有不同的行为。我们有两种方法来解决这个问题：
- en: We can use the `match` statement to distinguish the different cases. This replaces
    sequences of `isinstance()` functions to compare argument values against types.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`match`语句来区分不同的案例。这取代了比较参数值与类型的`isinstance()`函数序列。
- en: We can create class hierarchies that provide alternative implementations for
    methods.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建提供方法替代实现的类层次结构。
- en: In some cases, we’ll actually need to do both so that we can include appropriate
    data type conversions for an operation. Each class is responsible for the coercion
    of argument values to a type it can use. The alternative is to return the special
    `NotImplemented` object, which forces the Python runtime to continue to search
    for a class that implements the operation and handles the required data types.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们实际上需要同时进行操作，以便包括适当的数据类型转换。每个类都负责将参数值强制转换为它可以使用的类型。另一种选择是返回特殊的`NotImplemented`对象，这会强制Python运行时继续搜索实现操作并处理所需数据类型的类。
- en: The ranking example in the previous section is tightly bound to the idea of
    applying rank-ordering to simple pairs. It’s bound to the `Pair` class definition.
    While this is the way the Spearman correlation is defined, a multivariate dataset
    has a need to do rank-order correlation among all the variables.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的排名示例紧密绑定到将等级排序应用于简单对的概念。它绑定到`Pair`类定义。虽然这是Spearman相关性的定义方式，但多元数据集需要对所有变量进行等级排序相关性。
- en: 'The first thing we’ll need to do is generalize our idea of rank-order information.
    The following is a `NamedTuple` value that handles a tuple of ranks and a raw
    data object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是将我们的等级信息概念进行泛化。以下是一个处理等级和原始数据对象的`NamedTuple`值：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can provide a sequence of rankings, each computed with respect to a different
    variable within the raw data. We might have a data point that has a rank of 2
    for the `’key1’` attribute value and a rank of 7 for the `’key2’` attribute value.
    A typical use of this kind of class definition is shown in this example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一系列排名，每个排名都是相对于原始数据中的不同变量计算的。我们可能有一个数据点，对于`’key1’`属性值具有2的排名，而对于`’key2’`属性值具有7的排名。这种类定义的典型用法在以下示例中显示：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The row of raw data in this example is a dictionary with two keys for the two
    attribute names. There are two rankings for this particular item in the overall
    list. An application can get the sequence of rankings as well as the original
    raw data item.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的原始数据行是一个包含两个键的字典，这两个键对应于两个属性名称。在这个整体列表中，这个特定项目有两个排名。应用程序可以获取排名序列以及原始数据项。
- en: We’ll add some syntactic sugar to our ranking function. In many previous examples,
    we’ve required either an iterable or a concrete collection. The `for` statement
    is graceful about working with either one. However, we don’t always use the `for`
    statement, and for some functions, we’ve had to explicitly use `iter()` to make
    an iterator from an iterable collection. (We’ve also been forced sometimes to
    use `list()` to materialize an iterable into a concrete collection object.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的排名函数中添加一些语法糖。在许多之前的示例中，我们要求提供一个可迭代对象或具体的集合。`for`语句在处理这两个对象时都很优雅。然而，我们并不总是使用`for`语句，对于某些函数，我们不得不显式地使用`iter()`将可迭代集合转换为迭代器。（有时我们也被迫使用`list()`将可迭代对象实体化为具体的集合对象。）
- en: 'Looking back at the `legs()` function shown in [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), we saw this definition:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下在[第4章](Chapter_04.xhtml#x1-740004)中展示的`legs()`函数，[处理集合](Chapter_04.xhtml#x1-740004)，我们看到了以下定义：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This only works for an `Iterator` object. If we want to use a sequence, we’re
    forced to insert `iter(some_sequence)` to create an iterator from the sequence.
    This is annoying and error-prone.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这只适用于`Iterator`对象。如果我们想使用序列，我们被迫插入`iter(some_sequence)`来从序列创建迭代器。这是令人烦恼且容易出错的。
- en: 'The traditional way to handle this situation is with an `isinstance()` check,
    as shown in the following code snippet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况的传统方式是使用`isinstance()`检查，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This example includes a type check to handle the small difference between a
    `Sequence` object and an `Iterator`. Specifically, when the argument value is
    a sequence, the `legs()` function uses `iter()` to create an `Iterator` from the
    `Sequence`, and calls itself recursively with the derived value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含一个类型检查，用于处理`Sequence`对象和`Iterator`之间的细微差异。具体来说，当参数值是一个序列时，`legs()`函数使用`iter()`将`Sequence`转换为`Iterator`，并递归地使用派生值调用自身。
- en: 'This can be done in a slightly nicer and more general manner with type matching.
    The idea is to handle the variable argument types with a `match` statement that
    applies any needed conversions to a uniform type that can be processed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过类型匹配以一种更优雅和更通用的方式完成。想法是使用`match`语句处理可变参数类型，并将所需的转换应用于可以处理的统一类型：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example has shown how we can match types to make it possible to work with
    either sequences or iterators. A great many other type matching capabilities can
    be implemented in a similar fashion. It may be helpful, for example, to work with
    string or float values, coercing the string values to float.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了我们如何匹配类型，使其能够使用序列或迭代器。以类似的方式可以实现许多其他类型匹配功能。例如，处理字符串或浮点值时，可以将字符串值强制转换为浮点数可能很有帮助。
- en: It turns out that a type check isn’t the only solution to this specific problem.
    The `iter()` function can be applied to iterators as well as concrete collections.
    When the `iter()` function is applied to an iterator, it does nothing and returns
    the iterator. When applied to a collection, it creates an iterator from the collection.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，类型检查并不是解决这个特定问题的唯一方法。`iter()`函数可以应用于迭代器和具体集合。当`iter()`函数应用于迭代器时，它不执行任何操作并返回迭代器。当应用于集合时，它从集合中创建一个迭代器。
- en: The objective of the `match` statement is to avoid the need to use the built-in
    `isinstance()` function. The `match` statement provides more matching alternatives
    with an easier-to-read syntax.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`语句的目标是避免使用内置的`isinstance()`函数。`match`语句提供了更多易于阅读的语法匹配选项。'
- en: 7.8 Summary
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8 摘要
- en: In this chapter, we looked at different ways to use `NamedTuple` subclasses
    to implement more complex data structures. The essential features of a `NamedTuple`
    are a good fit with functional design. They can be created with a creation function
    and accessed by position as well as name.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用`NamedTuple`子类实现更复杂数据结构的多种方法。`NamedTuple`的基本特征与函数式设计非常契合。它们可以通过创建函数创建，并通过位置和名称访问。
- en: Similarly, we looked at frozen dataclasses as an alternative to `NamedTuple`
    objects. The use of a dataclass seems slightly superior to a `NamedTuple` subclass
    because a dataclass doesn’t also behave like a sequence of attribute values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们将冻结的数据类视为`NamedTuple`对象的替代品。使用数据类的效果似乎略优于`NamedTuple`子类，因为数据类不会像属性值序列那样表现。
- en: We looked at how immutable objects can be used instead of stateful object definitions.
    The core technique for replacing state changes is to wrap objects in larger objects
    that contain derived values.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用不可变对象代替有状态对象定义。替换状态变化的核心技术是将对象包装在包含派生值的大对象中。
- en: We also looked at ways to handle multiple data types in Python. For most arithmetic
    operations, Python’s internal method dispatch locates proper implementations.
    To work with collections, however, we might want to handle iterators and sequences
    slightly differently using the `match` statement.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了在 Python 中处理多种数据类型的方法。对于大多数算术运算，Python 的内部方法调度定位适当的实现。然而，要处理集合，我们可能想要使用
    `match` 语句以稍微不同的方式处理迭代器和序列。
- en: In the next two chapters, we’ll look at the `itertools` module. This standard
    library module provides a number of functions that help us work with iterators
    in sophisticated ways. Many of these tools are examples of higher-order functions.
    They can help a functional design stay succinct and expressive.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将探讨 `itertools` 模块。这个标准库模块提供了一些函数，帮助我们以复杂的方式处理迭代器。这些工具中的许多是高阶函数的例子。它们可以帮助函数式设计保持简洁和表达性。
- en: 7.9 Exercises
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于 Packt Publishing 在 GitHub 上提供的代码。请参阅 [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到 GitHub 上提供的代码包括一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与 GitHub 仓库中已经提供的单元测试用例相同。读者应将书中的示例函数名替换为自己的解决方案，以确认其工作。
- en: 7.9.1 Frozen dictionaries
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.1 冻结字典
- en: A dictionary with optional key values can be a source of confusing state change
    management. Python’s implementation of objects generally relies on an internal
    dictionary, named `__dict__`, to keep an object’s attribute values. This is easy
    to mirror in application code, and it can create problems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 带有可选键值的字典可能成为混淆的状态变化管理来源。Python 对象的实现通常依赖于一个名为 `__dict__` 的内部字典，以保持对象的属性值。这在应用程序代码中很容易镜像，并可能引起问题。
- en: 'While dictionary updates can be confusing, the previously described use case
    seems rare. A much more common use of dictionaries is to load a mapping from a
    source, and then use the mapping during later processing. One example is a dictionary
    that contains translations from source encodings to more useful numeric values.
    It might use a mapping value like this: `{"y":`` 1,`` "Y":`` 1,`` "n":`` 0,`` "N":`` 0}`.
    In this case, the dictionary is created once, and does not change state after
    that. It’s effectively frozen.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字典更新可能会令人困惑，但之前描述的使用案例似乎很少见。字典的一个更常见的用途是从源加载映射，然后在后续处理中使用该映射。一个例子是包含从源编码到更有用的数值的映射的字典。它可能使用这样的映射值：`{"y":1,
    "Y":1, "n":0, "N":0}`。在这种情况下，字典只创建一次，之后不再改变状态。它实际上是冻结的。
- en: 'Python doesn’t have a built-in frozen dictionary class. One approach to defining
    this class is to extend the built-in `dict` class, adding a mode change. There
    would be two modes: “load” and “query.” A dictionary in “load” mode can have keys
    and values created. A dictionary in “query” mode, however, does not permit changes.
    This includes refusing to go back to “load” mode. This is an extra layer of stateful
    behavior that permits or denies the underlying mapping behavior.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内置的冻结字典类。定义此类的一个方法是通过扩展内置的 `dict` 类，添加一个模式切换。这将有两种模式：“加载”和“查询”。在“加载”模式下，字典可以创建键和值。然而，在“查询”模式下，字典不允许更改。这包括拒绝返回到“加载”模式。这是额外一层有状态的行为，允许或拒绝底层映射行为。
- en: The dictionary class has a long list of special methods like `__setitem__()`
    and `update()` that change the internal state. The Python Language Reference,
    section 3.3.7 Emulating Container Types, provides a detailed list of methods that
    change the state of a mapping. Additionally, the Library Reference, in a section
    named Mapping Types – dict, provides a list of methods for the built-in `dict`
    class. Finally, the `collections.abc` module also defines some of the methods
    that mappings must implement.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 字典类包含一系列特殊方法，如`__setitem__()`和`update()`，这些方法会改变内部状态。《Python语言参考》第3.3.7节“模拟容器类型”提供了一个详细的方法列表，这些方法会改变映射的状态。此外，《库参考》中名为“映射类型
    – dict”的章节提供了一个内置`dict`类的方法列表。最后，`collections.abc`模块也定义了一些映射必须实现的方法。
- en: 'Work out the list of methods that must be implemented with code like the following
    example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例代码实现必须实现的方法列表：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Given the list of methods that need this kind of wrapper, comment on the value
    of having a frozen mapping. Contrast the work required to implement this class
    with the possible confusion from a stateful dictionary. Provide a cost-benefit
    justification for either writing this class or setting the idea aside and looking
    for a better solution. Recall that dictionary key look-ups are very fast, relying
    on a hash computation instead of a lengthy search.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 给定需要这种类型包装器的方法列表，评论拥有一个冻结映射的价值。对比实现这个类所需的工作与状态字典可能引起的混淆。为编写这个类或搁置这个想法并寻找更好的解决方案提供成本效益的理由。回想一下，字典键查找非常快，依赖于哈希计算而不是漫长的搜索。
- en: 7.9.2 Dictionary-like sequences
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.2 类似字典的序列
- en: Python doesn’t have a built-in frozen dictionary class. One approach to defining
    this class is to leverage the `bisect` module to build a list. The list is maintained
    in sorted order, and the `bisect` module can do relatively rapid searches of a
    sorted list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有内置的冻结字典类。定义这个类的一种方法是通过利用`bisect`模块构建一个列表。列表保持排序状态，`bisect`模块可以对排序列表进行相对快速搜索。
- en: For an unsorted list, the complexity of finding a specific item in a sequence
    of n items is O(n). For a sorted list, the `bisect` module can reduce this to
    O(log [2]n), a significant reduction in time for a large list. (And, of course,
    a dictionary’s hashed lookup is generally O(1), which is better still.)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个未排序的列表，在n个元素的序列中查找特定项的复杂度是O(n)。对于已排序的列表，`bisect`模块可以将这个复杂度降低到O(log [2]n)，这对于大型列表来说是一个显著的时间减少。（当然，字典的哈希查找通常是O(1)，这更好。）
- en: The dictionary class has a long list of special methods like `__setitem__()`
    and `update()` that change the internal state. The previous exercise provides
    some pointers for locating all of the special methods that are relevant to building
    a dictionary.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 字典类包含一系列特殊方法，如`__setitem__()`和`update()`，这些方法会改变内部状态。前一个练习提供了一些定位所有与构建字典相关的特殊方法的提示。
- en: A function to build a sorted list can wrap `bisect.insort_left()`. A function
    to query the sorted list can leverage `bisect.bisect_left()` to locate and then
    return the value associated with a key that’s in the list, or raise a `KeyError`
    exception for an item that’s not in the list.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个构建排序列表的函数可以包装`bisect.insort_left()`。一个查询排序列表的函数可以利用`bisect.bisect_left()`定位并返回列表中与键关联的值，或者对于列表中不存在的项抛出`KeyError`异常。
- en: Build a small demo application that creates a dictionary from a source file,
    then does several thousand randomized retrievals from that dictionary. Compare
    the time required to run the demo using the built-in `dict` against the `bisect`-based
    dictionary-like list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个小型演示应用程序，从源文件创建字典，然后从该字典中进行数千次随机检索。比较使用内置`dict`和基于`bisect`的类似字典列表运行演示所需的时间。
- en: Using the built-in `sys.getallocatedblocks()`, compare the memory used by a
    list of values and the memory used by a dictionary of values. For this to be meaningful,
    the dictionary will need several thousand keys and values. A pool of random numbers
    and randomly generated strings can be useful for this comparison.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`sys.getallocatedblocks()`，比较值列表和值字典使用的内存。为了使这个比较有意义，字典需要几千个键和值。一组随机数和随机生成的字符串可以用于这个比较。
- en: 7.9.3 Revise the rank_xy() function to use native types
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.3 修改rank_xy()函数以使用原生类型
- en: In the [Computing Spearman’s rank-order correlation](#x1-1600001) section, we
    presented a `rank_xy()` function that created a `pyrsistent.PMap` object with
    various ranking positions. This was contained within a `PRecord` subclass.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在[计算斯皮尔曼等级相关](#x1-1600001)部分，我们介绍了一个`rank_xy()`函数，该函数创建了一个包含各种排名位置的`pyrsistent.PMap`对象。这包含在一个`PRecord`子类中。
- en: First, rewrite the function (and the type hints) to use either a named tuple
    or a dataclass instead of a `PRecord` subclass. This replaces one immutable object
    with another.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重写函数（以及类型提示）以使用命名元组或数据类而不是`PRecord`子类。这用一个不可变对象替换了另一个。
- en: Next, consider replacing the `PMap` object with a native Python dictionary.
    Since dictionaries are mutable, what additional processing is needed to create
    a copy of a dictionary before adding a new ranking value?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑用原生Python字典替换`PMap`对象。由于字典是可变的，在添加新的排名值之前需要创建字典的副本，需要额外的哪些处理？
- en: After revising the `PMap` object to a dictionary, compare the performance of
    the `pyrsistent` objects with native objects. What conclusions can you draw?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`PMap`对象修订为字典后，比较`pyrsistent`对象与原生对象的性能。你能得出什么结论？
- en: 7.9.4 Revise the rank_corr() function
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.4 修订rank_corr()函数
- en: In the [Polymorphism and type pattern matching](#x1-1610007) section, we presented
    a way to create `RankedSample` objects that contain rankings and underlying `Rank_Data`
    objects with the raw sample value.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在[多态和类型模式匹配](#x1-1610007)部分，我们介绍了一种创建包含排名和底层`Rank_Data`对象（具有原始样本值）的`RankedSample`对象的方法。
- en: Rewrite the `rank_corr()` function to compute the rank correlations of any of
    the available values in the `rank_seq` attribute of the `RankedSample` objects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`rank_corr()`函数以计算`RankedSample`对象`rank_seq`属性中任何可用值的等级相关性。
- en: 7.9.5 Revise the legs() function to use pyrsistent
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.9.5 修订legs()函数以使用pyrsistent
- en: In the [Using pyrsistent to collect data](#x1-1580005) section, a number of
    functions were reused from earlier examples. The `legs()` function was called
    out specifically. The entire parsing pipeline, however, can be rewritten to use
    the `pyrsistent` variations on the fundamental, immutable object classes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用pyrsistent收集数据](#x1-1580005)部分，从早期示例中重用了许多函数。特别提到了`legs()`函数。然而，整个解析管道可以被重写以使用`pyrsistent`对基本不可变对象类的变体。
- en: After doing the revision, explain any improvements in the code from using one
    module consistently for the data collections. Create an application that loads
    and computes distances for a trip several thousand times. Use each of the various
    representations and accumulate timing data to see which, if any, is faster.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行修订后，解释使用一个模块一致地用于数据收集的代码中的任何改进。创建一个应用程序，该应用程序多次加载并计算行程的距离。使用各种表示形式并累积计时数据，以查看哪种（如果有的话）更快。
- en: Join our community Discord space
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Python Discord工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
