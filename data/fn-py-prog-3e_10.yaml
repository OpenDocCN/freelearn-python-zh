- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: The Functools Module
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Functools模块
- en: Functional programming considers functions to be first-class objects. We’ve
    seen several higher-order functions that accept functions as arguments or return
    functions as results. In this chapter, we’ll look at the `functools` library,
    which contains some tools to help us implement some common functional design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程将函数视为一等对象。我们已经看到了几个高阶函数，这些函数接受函数作为参数或返回函数（或生成器表达式）作为结果。在本章中，我们将探讨`functools`库，它包含一些工具帮助我们实现一些常见的函数式设计模式。
- en: We’ll look at some higher-order functions. This extends the material from [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005). We’ll continue looking
    at higher-order function techniques in [Chapter 12](Chapter_12.xhtml#x1-25000012),
    [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012), as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些高阶函数。这扩展了[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中的材料。我们还将继续在[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)中探讨高阶函数技术。
- en: 'We’ll look at the following functions in this module:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本模块中探讨以下函数：
- en: '`@cache` and `@lru_cache`: These decorators can be a huge performance boost
    for certain types of applications.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@cache`和`@lru_cache`：这些装饰器可以极大地提高某些类型应用程序的性能。'
- en: '`@total_ordering`: This decorator can help create rich comparison operators.
    Additionally, it lets us look at the more general question of object-oriented
    design mixed with functional programming.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@total_ordering`: 这个装饰器可以帮助创建丰富的比较运算符。此外，它让我们可以探讨面向对象设计与函数式编程相结合的更一般性问题。'
- en: '`partial()`: This function creates a new function from a function and some
    parameter value bindings.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial()`: 这个函数可以从一个函数和一些参数值绑定中创建一个新的函数。'
- en: '`reduce()`: This is a higher-order function that generalizes reductions such
    as `sum()`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`: 这是一个高阶函数，它泛化了如`sum()`之类的归约操作。'
- en: '`singledispatch()`: This function allows us to assemble alternative implementations
    based on the argument type. It saves us from writing the `match` statement to
    choose the implementation, keeping the implementations cleanly separated.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singledispatch()`: 这个函数允许我们根据参数类型组装不同的实现。它使我们免于编写`match`语句来选择实现，从而保持实现干净地分离。'
- en: 'We’ll defer two additional members of this library to [Chapter 12](Chapter_12.xhtml#x1-25000012),
    [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012): the `update_wrapper()`
    and `wraps()` functions. We’ll also look more closely at writing our own decorators
    in the next chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将推迟介绍这个库的另外两个成员到[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)：`update_wrapper()`和`wraps()`函数。我们还将更详细地探讨在下一章中编写我们自己的装饰器。
- en: We’ll ignore the `cmp_to_key()` function entirely. Its purpose is to help with
    converting Python 2 code to run under Python 3\. Since Python 2 is no longer being
    actively maintained, we can safely ignore this function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完全忽略`cmp_to_key()`函数。它的目的是帮助将Python 2代码转换为在Python 3下运行。由于Python 2不再被积极维护，我们可以安全地忽略这个函数。
- en: 10.1 Function tools
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1 函数工具
- en: We looked at a number of higher-order functions in [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005). Those functions either
    accept a function as an argument or return a function (or generator expression)
    as a result. All those higher-order functions have an essential algorithm that
    is customized by injecting another function. Functions such as `max()`, `min()`,
    and `sorted()` accept a `key=` function to customize their behavior. Functions
    such as `map()` and `filter()` accept a function and an iterable and apply the
    given function to the argument iterable. In the case of the `map()` function,
    the results of the function are simply yielded. In the case of the `filter()`
    function, the Boolean result of the function is used to yield or reject values
    from an iterable source.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中探讨了多个高阶函数。这些函数要么接受一个函数作为参数，要么返回一个函数（或生成器表达式）作为结果。所有这些高阶函数都有一个基本的算法，该算法通过注入另一个函数进行定制。例如`max()`、`min()`和`sorted()`函数接受一个`key=`函数来自定义其行为。例如`map()`和`filter()`函数接受一个函数和一个可迭代对象，并将给定的函数应用于参数可迭代对象。在`map()`函数的情况下，函数的结果简单地产生。在`filter()`函数的情况下，函数的布尔结果用于从可迭代源产生或拒绝值。
- en: All the functions in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order
    Functions](Chapter_05.xhtml#x1-1000005), are part of the Python `__builtins__`
    package, meaning these functions are available without the need to use the `import`
    statement. They were made ubiquitous because they seem universally useful. The
    functions in this chapter must be introduced with an `import` statement because
    they’re not quite so universally helpful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中的所有函数都是
    Python 的 `__builtins__` 包的一部分，这意味着这些函数无需使用 `import` 语句即可使用。它们之所以无处不在，是因为它们似乎普遍有用。本章中的函数必须使用
    `import` 语句引入，因为它们并不那么普遍有用。'
- en: The `reduce()` function straddles this fence. It was originally built in. After
    some discussion, it was moved from the `__builtins__` package to the `functools`
    module because of the possibility of really poor performance. Later in this chapter,
    we’ll see how seemingly simple operations can perform remarkably poorly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 函数跨越了这个界限。它最初是内置的。经过一些讨论后，它从 `__builtins__` 包移动到 `functools` 模块，因为性能可能非常糟糕。在本章的后面部分，我们将看到看似简单的操作可以表现得非常糟糕。'
- en: 10.2 Memoizing previous results with cache
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2 使用缓存存储先前结果
- en: The `@cache` and `@lru_cache` decorators transform a given function into a function
    that might perform more quickly. LRU means Least Recently Used—a finite pool of
    recently used items is retained. Items not recently used are discarded to keep
    the pool to a bounded size. The `@cache` has no storage management and requires
    a little bit of consideration to be sure it won’t consume all available memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`@cache` 和 `@lru_cache` 装饰器将给定的函数转换为一个可能运行更快的函数。LRU 表示最近最少使用——保留一个有限池的最近使用项。未最近使用的项被丢弃以保持池的大小有限。`@cache`
    没有存储管理，需要稍微考虑以确保它不会消耗所有可用内存。'
- en: 'Since these are decorators, we can apply one of them to any function that might
    benefit from caching previous results. We can use it as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是装饰器，我们可以将它们应用于任何可能从缓存先前结果中受益的函数。我们可以如下使用它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example based on [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006). We’ve applied the `@lru_cache` decorator
    to the naive Fibonacci number calculation. Because of this decoration, each evaluation
    of the `fibc(n)` function will now be checked against a cache maintained by the
    decorator. If the argument value, `n`, is in the cache, the previously computed
    result is used instead of doing a potentially expensive re-calculation. Each new
    collection of argument values and return value updates the cache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于 [第 6 章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)
    的例子。我们已将 `@lru_cache` 装饰器应用于天真斐波那契数计算。由于这个装饰，现在每次对 `fibc(n)` 函数的评估都将与装饰器维护的缓存进行检查。如果参数值
    `n` 在缓存中，则使用之前计算的结果，而不是进行可能昂贵的重新计算。每次新的参数值集合和返回值更新缓存。
- en: We highlight this example because the naive recursion is quite expensive in
    this case. The complexity of computing any given Fibonacci number, F[n] = F[n−1]
    + F[n−2], involves not merely computing F[n−1] but also F[n−2]. This tree of values
    leads to a complexity in the order of O(2^n).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调这个例子，因为在这种情况下，天真递归非常昂贵。计算任何给定斐波那契数 F[n] = F[n−1] + F[n−2] 的复杂性不仅涉及计算 F[n−1]，还涉及
    F[n−2]。这个值树导致复杂度为 O(2^n)。
- en: The argument value of `128` is the size of the cache. This is used to limit
    the amount of memory used for the cache. When the cache is full, the LRU item
    is replaced.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`128` 的参数值是缓存的大小。这用于限制缓存使用的内存量。当缓存满时，LRU 项将被替换。'
- en: 'We can try to confirm the benefits empirically using the `timeit` module. We
    can execute the two implementations 1,000 times each to see how the timing compares.
    Using the `fib(20)` and `fibc(20)` methods shows just how costly this calculation
    is without the benefit of caching. Because the naive version is so slow, the `timeit`
    number of repetitions was reduced to only 1,000\. Here are the results (in seconds):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `timeit` 模块尝试从经验上确认这些好处。我们可以分别执行这两个实现 1,000 次，以查看时间比较。使用 `fib(20)` 和
    `fibc(20)` 方法显示了没有缓存的好处，这个计算是多么昂贵。由于天真版本非常慢，`timeit` 的重复次数减少到只有 1,000 次。以下是结果（以秒为单位）：
- en: 'Naive: 3.23'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天真：3.23
- en: 'Cached: 0.0779'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存：0.0779
- en: Note that we can’t trivially use the `timeit` module on the `fibc()` function.
    The cached values will remain in place; we’ll only evaluate the complete `fibc(20)`
    calculation once, which populates values in the cache. Each of the remaining 999
    iterations will simply fetch the value from the cache. We need to actually clear
    the cache between uses of the `fibc()` function or the time drops to almost zero.
    This is done with a `fibc.cache_clear()` method built by the decorator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能简单地使用`timeit`模块在`fibc()`函数上。缓存值将保持原位；我们只会评估一次完整的`fibc(20)`计算，这将填充缓存中的值。剩下的999次迭代将简单地从缓存中获取值。我们需要在`fibc()`函数的使用之间实际清除缓存，否则时间几乎会降到零。这是通过装饰器构建的`fibc.cache_clear()`方法来完成的。
- en: The concept of memoization is powerful. There are many algorithms that can benefit
    from memoization of results. Because the `@cache` decorator applies to a function,
    it means using a functional programming approach can also lead to high-performance
    software. Functions with side effects are rarely good candidates for memoization;
    pure functions will work out best.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存化的概念非常强大。有许多算法可以从结果缓存中受益。因为`@cache`装饰器适用于函数，这意味着使用函数式编程方法也可以导致高性能软件。具有副作用的功能很少是缓存的好候选；纯函数将工作得最好。
- en: 'We’ll look at one more example of the benefits of caching. This will involve
    a small computation that also has repeated values. The number of combinations
    of p things taken in groups of r is often stated as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再来看一个缓存好处的例子。这涉及到一个小计算，也有重复的值。从p个事物中取r个一组组合的数量通常表述如下：
- en: '![( ) p = ----p!--- r r!(p− r!) ](img/file97.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![（ ）p = ----p!--- r r!(p− r!) ](img/file97.jpg)'
- en: This binomial function involves computing three factorial values. It might make
    sense to use the `@cache` decorator on a factorial function. A program that calculates
    a number of binomial values will not need to re-compute all of those factorials.
    For cases where similar values are computed repeatedly, the speedup can be impressive.
    For situations where the cached values are rarely reused, the overheads of maintaining
    the cached values may outweigh any speedups.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二项式函数涉及到计算三个阶乘值。在阶乘函数上使用`@cache`装饰器可能是有意义的。计算多个二项式值的程序不需要重新计算所有这些阶乘。对于重复计算相似值的情况，速度提升可能会非常显著。对于缓存值很少被重用的情况，维护缓存值的开销可能会超过任何速度提升。
- en: 'We’ve omitted the details of the actual binomial function. It’s only one line
    of code. Caching a built-in function is done like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了实际二项式函数的细节。它只有一行代码。缓存内置函数的方式如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This applies the decorator to an existing function. For more information on
    this approach to decoration, see [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator
    Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将装饰器应用于现有函数。有关这种装饰方法的信息，请参阅[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)。
- en: 'When evaluating a binomial function repeatedly, we see the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当反复评估二项式函数时，我们会看到以下情况：
- en: 'Naive factorial: 0.174'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始阶乘：0.174
- en: 'Cached factorial: 0.046'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存阶乘：0.046
- en: It’s important to recognize that the cache is a stateful object. This design
    pushes the edge of the envelope on purely functional programming. One functional
    ideal is to avoid changes of state. This concept of avoiding stateful variables
    is exemplified by a recursive function; the current state is contained in the
    argument values, and not in the changing values of variables. We’ve seen how tail-call
    optimization is an essential performance improvement to ensure that this idealized
    recursion actually works nicely with the available processor hardware and limited
    memory budgets. In Python, we can do this tail-call optimization manually by replacing
    the tail recursions with a `for` loop. Caching is a similar kind of optimization;
    we must implement it manually as needed, knowing that it isn’t purely functional
    programming.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到缓存是一个有状态的对象。这种设计将纯函数式编程推向了极致。一个函数式理想是避免状态变化。这种避免有状态变量的概念通过递归函数得到了体现；当前状态包含在参数值中，而不是变量变化的值中。我们已经看到尾调用优化是如何确保这种理想化的递归实际上与可用的处理器硬件和有限的内存预算良好工作的必要性能改进。在Python中，我们可以通过将尾递归替换为`for`循环来手动进行尾调用优化。缓存是一种类似类型的优化；我们必须根据需要手动实现它，知道它不是纯函数式编程。
- en: 'Further, if our design is centered on pure functions—free of side effects—then
    there are no problems with introducing caching. Applying an `@cache` decorator
    to a function that has side effects, for example, the `print()` function, will
    create confusion: we’ll note that evaluations of `print()` with the same argument
    values won’t produce any output because the result value, `None`, will be fetched
    from cache.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的设计以纯函数为中心——没有副作用——那么引入缓存不会有问题。例如，将`@cache`装饰器应用于具有副作用的函数（例如`print()`函数），将产生混淆：我们会注意到具有相同参数值的`print()`评估不会产生任何输出，因为结果值`None`将是从缓存中检索的。
- en: 'In principle, each call to a function with a cache has two results: the expected
    result and a new `cache` object available for future evaluations of the function.
    Pragmatically, in our example, the `cache` object is encapsulated inside the decorated
    version of the `fibc()` function, and it isn’t available for inspection or manipulation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，对具有缓存的函数的每次调用都有两个结果：预期的结果和可用于函数未来评估的新`cache`对象。在实践中，在我们的例子中，`cache`对象封装在`fibc()`函数的装饰版本中，并且不可用于检查或操作。
- en: Caching is not a panacea. Applications that work with float values might not
    benefit much from memoization because float values are often approximations. The
    least-significant bits of a float value should be seen as random noise that can
    prevent the exact equality test in the `@lru_cache` or `@cache` decorator from
    working.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存并非万能。与浮点值一起工作的应用程序可能不会从记忆化中获得太多好处，因为浮点值通常是近似值。浮点值的最低有效位应被视为随机噪声，这可能会阻止`@lru_cache`或`@cache`装饰器中的精确相等性测试。
- en: 10.3 Defining classes with total ordering
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3 定义具有完全排序的类
- en: The `@total_ordering` decorator is helpful for creating new class definitions
    that implement a rich set of comparison operators. This might apply to numeric
    classes that subclass `numbers.Number`. It may also apply to semi-numeric classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@total_ordering`装饰器对于创建实现丰富比较运算符的新类定义很有帮助。这可能适用于子类`numbers.Number`的数值类。它也可能适用于半数值类。'
- en: As an example of a semi-numeric class, consider a playing card. It has a numeric
    rank and a symbolic suit. The suit, for example, may not matter for some games.
    Like ordinary integers, cards have an ordering. We often sum the point values
    of each card, making them number-like. However, multiplication of cards, card
    × card, doesn’t really make any sense; a card isn’t quite like a number.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为半数值类的一个例子，考虑一副扑克牌。它有一个数值等级和一个符号花色。例如，花色对某些游戏可能并不重要。像普通整数一样，牌有顺序。我们经常将每张牌的点数相加，使它们像数字一样。然而，牌的乘法，即牌×牌，实际上并没有什么意义；牌并不完全像数字。
- en: 'We can almost emulate a playing card with a `NamedTuple` base class as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以用一个以`NamedTuple`为基类的`PlayingCard`来模拟一副扑克牌，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This model suffers from a profound limitation: all comparisons between cards
    will include both the rank and the suit. This leads to the following awkward behavior
    when we compare the two of spades against the two of clubs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型存在一个深刻的局限性：所有牌的比较都将包括等级和花色。这导致当我们比较黑桃2和梅花2时出现以下尴尬的行为：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default comparison rule is fine for some games. It does not work well for
    those games in which comparisons focus on rank and ignore suit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认比较规则对某些游戏来说很好。对于比较重点在等级而忽略花色的游戏，它不起作用。
- en: For some games, it can be better for the default comparisons between cards to
    be based on only their rank.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些游戏，默认的牌比较最好只基于它们的等级。
- en: 'The following class definition is appropriate for games where the suit isn’t
    a primary concern:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类定义适用于对花色不是主要关注的游戏：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class extends the `NamedTuple` class. We’ve provided a `__str__()` method
    to print a string representation of a `Card2` object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`NamedTuple`类。我们提供了一个`__str__()`方法来打印`Card2`对象的字符串表示形式。
- en: There are two comparisons defined—one for equality and one for ordering. A wide
    variety of comparisons can be defined, and the `@total_ordering` decorator handles
    the construction of the remaining comparisons. In this case, the decorator creates
    `__le__()`, `__gt__()`, and `__ge__()` from these two definitions. The default
    implementation of `__ne__()` uses `__eq__()`; this works without using a decorator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两种比较——一种用于相等性，一种用于排序。可以定义各种比较，`@total_ordering`装饰器处理剩余比较的构建。在这种情况下，装饰器从这两个定义中创建了`__le__()`、`__gt__()`和`__ge__()`。`__ne__()`的默认实现使用`__eq__()`；这不需要使用装饰器也能工作。
- en: Both the methods provided in this class allow two kinds of comparisons—between
    `Card2` objects, and also between a `Card2` object and an integer. The type hint
    must be `Any` to remain compatible with the superclass definition of `__eq__()`
    and `__lt__()`. It’s clear that it could be narrowed to `Union[Card2,`` int]`,
    but this conflicts with the definition inherited from the superclass.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程提供的两种方法允许两种比较类型——`Card2`对象之间的比较，以及`Card2`对象与整数的比较。类型提示必须是`Any`，以保持与`__eq__()`和`__lt__()`超类定义的兼容性。很明显，它可以缩小到`Union[Card2,
    int]`，但这与从超类继承的定义相冲突。
- en: 'First, this class offers proper comparison of only the ranks, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个类只提供对等级的比较，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use this class for a number of simulations with simplified syntax to
    compare ranks of cards. Furthermore, the decorator builds a rich set of comparison
    operators as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个类进行许多具有简化语法的模拟，以比较牌的等级。此外，装饰器构建了一个丰富的比较操作符集，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We didn’t need to write all of the comparison method functions; they were generated
    by the decorator. The decorator’s creation of operators isn’t perfect. In our
    case, we’ve asked for comparisons with integers as well as between `Card` instances.
    This reveals some problems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写所有的比较方法函数；它们是由装饰器生成的。装饰器创建操作符并不完美。在我们的情况下，我们要求与整数以及`Card`实例之间的比较。这揭示了一些问题。
- en: Operations such as the `c4c`` >`` 3` and `3`` <`` c4c` comparisons would raise
    `TypeError` exceptions because of the way the operators are resolved to find a
    class that implements the comparison. This exposes a limitation of the methods
    created by the `@total_ordering` decorator. Specifically, the generated methods
    won’t have clever type matching rules. If we need type matching in all of the
    comparisons, we’ll need to write all of the methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作符解析的方式，`c4c > 3`和`3 < c4c`这样的比较会引发`TypeError`异常。这暴露了由`@total_ordering`装饰器创建的方法的局限性。具体来说，生成的方法不会有聪明的类型匹配规则。如果我们需要在所有比较中进行类型匹配，我们需要编写所有的方法。
- en: 10.4 Applying partial arguments with partial()
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4 使用partial()应用部分参数
- en: The `partial()` function leads to something called a partial application. A
    partially applied function is a new function built from an old function and a
    subset of the required argument values. It is closely related to the concept of
    currying. Much of the theoretical background is not relevant here, since currying
    doesn’t apply directly to the way Python functions are implemented. The concept,
    however, can lead us to some handy simplifications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`函数导致一种称为部分应用的东西。部分应用函数是从旧函数和所需参数值的一个子集构建的新函数。它与柯里化概念密切相关。由于柯里化并不直接应用于Python函数的实现方式，因此大部分理论背景在这里并不相关。然而，这个概念可以引导我们进行一些实用的简化。'
- en: 'We can look at trivial examples as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看如下简单的例子：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve created the function `exp2(y)`, which is the `pow(2,`` y)` function. The
    `partial()` function binds the first positional parameter to the `pow()` function.
    When we evaluate the newly created `exp2()` function, we get values computed from
    the argument bound by the `partial()` function, plus the additional argument provided
    to the `exp2()` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了函数`exp2(y)`，它是`pow(2, y)`函数。`partial()`函数将第一个位置参数绑定到`pow()`函数。当我们评估新创建的`exp2()`函数时，我们得到由`partial()`函数绑定的参数计算出的值，以及提供给`exp2()`函数的额外参数。
- en: The bindings of positional parameters are handled in a strict left-to-right
    order. Functions that accept keyword parameters can also be provided when building
    the partially applied function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数的绑定按照严格的从左到右的顺序处理。在构建部分应用函数时，也可以提供接受关键字参数的函数。
- en: 'We can also create this kind of partially applied function with a lambda form
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用如下lambda形式创建这种部分应用函数：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Neither is clearly superior. The use of `partial()` can help a reader understand
    the design intent. The use of a lambda may not have the same explanatory power.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都没有明显的优势。使用`partial()`可以帮助读者理解设计意图。使用lambda可能没有同样的解释力。
- en: Partial functions can be very handy in a context where we want to avoid repeating
    argument values to a function. We may, for example, be normalizing data after
    computing the mean and standard deviation. These normalized values are sometimes
    called Z-scores. While we can define a function `z(mean:`` float,`` stdev:`` float,`` score:`` float)`` ->`` float:`,
    this has the clutter of many argument values that don’t change once the mean and
    standard deviation are known.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '部分函数在需要避免向函数重复传递参数值的情况下非常有用。例如，我们可能在计算了平均值和标准差之后对数据进行归一化。这些归一化值有时被称为Z分数。虽然我们可以定义一个函数
    `z(mean: float, stdev: float, score: float) -> float`，但这会有很多参数值，而这些参数值在平均值和标准差已知后不会改变。'
- en: 'We prefer something like the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢以下示例：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The creation of the `z_value()` partial function is not – strictly speaking
    – needed. Having this function can clarify the expression that creates the `normalized_some_data`
    object. Using `z_value(x)` seems slightly more readable than `z_value(m,`` std,`` x)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `z_value()` 部分函数并不是——严格来说——必需的。拥有这个函数可以使创建 `normalized_some_data` 对象的表达式更加清晰。使用
    `z_value(x)` 比使用 `z_value(m, std, x)` 稍微更易读。
- en: We’ll return to the `partial()` function in [Chapter 13](Chapter_13.xhtml#x1-26600013),
    [The PyMonad Library](Chapter_13.xhtml#x1-26600013), and look at how we can accomplish
    this same kind of function definition using currying.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第13章[《PyMonad库》](Chapter_13.xhtml#x1-26600013)中回到 `partial()` 函数，并探讨如何使用柯里化实现这种类型的函数定义。
- en: 10.5 Reducing sets of data with the reduce() function
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5 使用 reduce() 函数减少数据集
- en: The `sum()`, `len()`, `max()`, and `min()` functions are, in a way, all specializations
    of a more general algorithm expressed by the `reduce()` function. See [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005) for more on these functions.
    The `reduce()` function is a higher-order function that folds a binary operation
    into each pair of items in an iterable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`、`len()`、`max()` 和 `min()` 函数在某种程度上都是 `reduce()` 函数表达的一个更通用算法的特殊化。参见第5章[《高阶函数》](Chapter_05.xhtml#x1-1000005)了解更多关于这些函数的信息。`reduce()`
    函数是一个高阶函数，它将二元操作折叠到可迭代对象的每一对元素中。'
- en: 'A sequence object is given as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个序列对象如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The expression `reduce(lambda`` x,`` y:`` x+y,`` d)` will fold in `+` operators
    to the list as if we were evaluating the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式 `reduce(lambda x, y: x+y, d)` 将折叠 `+` 操作符到列表中，就像我们正在评估以下内容：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It can help to include `()` to show the effective left-to-right grouping as
    follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `()` 可以帮助显示有效的从左到右的分组，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Python’s standard interpretation of expressions involves a left-to-right evaluation
    of operators. Consequently, a fold left doesn’t involve a change in meaning. Many
    functional programming languages including Haskell and OCaml (among many others)
    offer a fold-right alternative. When used in conjunction with recursion, a compiler
    can do a number of clever optimizations. This isn’t available in Python; a reduction
    is always left to right.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对表达式的标准解释涉及操作符的从左到右评估。因此，左折叠不涉及意义的改变。包括 Haskell 和 OCaml 在内的许多函数式编程语言都提供了折叠右的替代方案。当与递归结合使用时，编译器可以进行许多聪明的优化。这在
    Python 中不可用；归约始终是从左到右的。
- en: 'We can also provide an initial value as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以提供初始值，如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we don’t supply an initial value, the initial value from the sequence is
    used as the initialization. Providing an initial value is essential when there’s
    a `map()` function as well as a `reduce()` function. The following is how the
    right answer is computed with an explicit `0` initializer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供初始值，则使用序列的初始值作为初始化。当存在 `map()` 函数以及 `reduce()` 函数时，提供初始值是至关重要的。以下是如何使用显式的
    `0` 初始化器计算正确答案的示例：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we omit the initialization of `0`, the `reduce()` function uses the first
    item as an initial value. This value does not have the transformation function
    applied, which leads to the wrong answer. In effect, the `reduce()` without a
    proper initial value is computing this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了 `0` 的初始化，`reduce()` 函数将使用第一个项目作为初始值。这个值没有应用转换函数，这会导致错误的答案。实际上，没有适当初始值的
    `reduce()` 函数正在计算以下内容：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This kind of mistake is part of the reason why `reduce()` must be used carefully.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误是为什么 `reduce()` 必须谨慎使用的原因之一。
- en: 'We can define a number of common and built-in reductions using the `reduce()`
    higher-order function as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `reduce()` 高阶函数定义多个常见和内置的归约操作，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `sum2()` reduction function is the sum of squares, useful for computing
    the standard deviation of a set of samples. This `sum()` reduction function mimics
    the built-in `sum()` function. The `count()` reduction function is similar to
    the `len()` function, but it can work on an iterable, whereas the `len()` function
    can only work on a materialized collection object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum2()`归约函数是平方和，用于计算样本集的标准差。这个`sum()`归约函数模仿了内置的`sum()`函数。`count()`归约函数类似于`len()`函数，但它可以在可迭代对象上工作，而`len()`函数只能在工作集合对象上工作。'
- en: The `cast()` functions notify mypy of the intended types for the lambda objects.
    Without this, the default type hint for a lambda object is `Any`, which isn’t
    the intent for these functions. The type hint `FloatFT` describes a float function
    that accepts two float argument values and returns a float object as a result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`cast()`函数通知mypy lambda对象的预期类型。如果没有这个，lambda对象的默认类型提示是`Any`，这不是这些函数的意图。类型提示`FloatFT`描述了一个接受两个浮点参数值并返回浮点对象的浮点函数。'
- en: The `min()` and `max()` functions mimic the built-in reductions. Because the
    first item of the iterable is used for initialization, these two functions will
    work properly. If we provided an initial value to these `reduce()` functions,
    we might incorrectly use a value that never occurred in the original iterable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`和`max()`函数模仿内置的归约。因为可迭代的第一个项用于初始化，所以这两个函数将正常工作。如果我们为这些`reduce()`函数提供了初始值，我们可能会错误地使用一个在原始可迭代中从未出现过的值。'
- en: 'The complexity of the type hints is a suggestion that lambda objects don’t
    convey enough information to tools like mypy. While a lambda is valid Python,
    it can be difficult to examine in detail. This leads to the following tip:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的复杂性是lambda对象没有向工具如mypy传达足够信息的建议。虽然lambda是有效的Python，但很难详细检查。这导致了以下提示：
- en: A good design uses small function definitions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的设计使用小的函数定义。
- en: A complete function definition lets us provide default values, documentation,
    and `doctest` test cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的函数定义让我们能够提供默认值、文档和`doctest`测试用例。
- en: 10.5.1 Combining map() and reduce()
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.1 结合map()和reduce()
- en: 'We can see how to build higher-order functions around these foundational definitions.
    We can define a map-reduce function that combines the `map()` and `reduce()` functions
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如何围绕这些基础定义构建高阶函数。我们可以定义一个map-reduce函数，如下结合`map()`和`reduce()`函数：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This definition has a few formal type constraints. First, the `source` iterator
    produces some consistently typed data. We’ll bind the source type to the `ST`
    type variable to show where consistent types are required. Second, the provided
    `map_fun()` function accepts one argument of whatever type could be bound to `ST`
    and produces a float object. Third, the provided `reduce_fun()` function will
    reduce float objects to return a result of the same type. Because mypy is aware
    of the way Python operators work with integers as well as float values, this works
    in an integer context as well as a float context.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义有几个形式上的类型约束。首先，`source`迭代器产生一些类型一致的数据。我们将源类型绑定到`ST`类型变量，以显示在哪里需要一致的类型。其次，提供的`map_fun()`函数接受一个可以绑定到`ST`的任何类型的参数，并产生一个浮点对象。第三，提供的`reduce_fun()`函数将浮点对象归约，返回相同类型的结果。因为mypy了解Python运算符与整数以及浮点值的工作方式，这既适用于整数上下文也适用于浮点上下文。
- en: 'We can build a sum-of-squares reduction using the `map_fun()` and `reduce_fun()`
    functions separately as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`map_fun()`和`reduce_fun()`函数分别构建平方和归约，如下所示：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we’ve used a `lambda`` y:`` y**2` argument value as a mapping
    to square each value. The reduction is the `lambda`` x,`` y:`` x+y` argument value.
    We don’t need to explicitly provide an initial value because the initial value
    will be the first item in the iterable after the provided `map_fun()` lambda has
    squared it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们使用了一个`lambda y: y**2`参数值作为映射，将每个值平方。归约是`lambda x, y: x+y`参数值。我们不需要显式提供初始值，因为初始值将是`map_fun()`
    lambda平方后的可迭代中的第一个项。'
- en: 'The `lambda`` x,`` y:`` x+y` argument value is the `+` operator. Python offers
    all of the arithmetic operators as short functions in the `operator` module. (We’ll
    look at this in [Chapter 11](Chapter_11.xhtml#x1-23500011), [The Toolz Package](Chapter_11.xhtml#x1-23500011).)
    The following is how we can slightly simplify our map-reduce operation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda x, y: x+y` 参数值是 `+` 操作符。Python 在 `operator` 模块中提供了所有算术运算符作为简短函数。（我们将在第
    11 章[工具包](Chapter_11.xhtml#x1-23500011)中看到这一点。）以下是如何稍微简化我们的 map-reduce 操作：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve used the `operator.add` function to sum our values instead of the longer
    lambda form.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `operator.add` 函数来求和我们的值，而不是使用较长的 lambda 形式。
- en: 'The following is how we can count values in an iterable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在可迭代对象中计数值的方法：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve used the `lambda`` y:`` 1` parameter to map each value to the value `1`.
    The count is then reduced using a lambda or the `operator.add` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用了 `lambda y: 1` 参数将每个值映射到值 `1`。然后使用 lambda 或 `operator.add` 函数进行归约计数。'
- en: The general-purpose `reduce()` function allows us to create any species of reduction
    from a large dataset to a single value. There are some limitations, however, on
    what we should do with the `reduce()` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 `reduce()` 函数允许我们从大量数据集中创建任何类型的归约到单个值。然而，在使用 `reduce()` 函数时，有一些限制。
- en: 10.5.2 Using the reduce() and partial() functions
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.2 使用 reduce() 和 partial() 函数
- en: As we saw earlier, the `reduce()` function has a provision for an initial value.
    The default initial value is zero. This initial value seeds the reduction and
    will be the default value if the source iterable is empty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所看到的，`reduce()` 函数有一个初始值的选项。默认的初始值是零。这个初始值是归约的种子，如果源可迭代对象为空，它将是默认值。
- en: 'In the following example, we’ve provided an absurd initial value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们提供了一个荒谬的初始值：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The initial value provided to the `reduce()` function is a string. Because the
    iterable source of data, `d` is empty, no operations were performed and the initial
    value is the final result, even though it’s absurdly invalid.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `reduce()` 函数的初始值是一个字符串。因为数据源 `d` 为空，没有执行任何操作，所以初始值是最终结果，尽管它荒谬地无效。
- en: 'We note a complication here when we try to create a partial function using
    `reduce()`: there’s no sensible way to provide an initial value. This stems from
    the following root cause: the `reduce()` function has no keyword parameters. For
    some reductions, we need to provide values for the first and third positional
    parameters to the `reduce()` function.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用 `reduce()` 创建一个部分函数时，我们注意到这里有一个复杂的问题：没有合理的方法来提供初始值。这源于以下根本原因：`reduce()`
    函数没有关键字参数。对于某些归约操作，我们需要为 `reduce()` 函数的前两个位置参数提供值。
- en: 'Here’s the result of attempting to combine `partial()` and `reduce()`. The
    following example definitions of partial functions do not work correctly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是尝试组合 `partial()` 和 `reduce()` 的结果。以下部分函数的定义不正确：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `psum2()` function should compute a sum of squares of a source of values.
    As we’ll see, this does not work as hoped. Here’s an example of trying to use
    these functions based on the `partial()` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`psum2()` 函数应该计算值源的平方和。正如我们将看到的，这并没有按预期工作。以下是基于 `partial()` 函数尝试使用这些函数的示例：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The sum-of-squares defined as a partial does not use a proper initialization
    for the sequence of values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为部分函数定义的平方和没有使用适当的值序列初始化。
- en: The reduction should start with 0\. It will apply the lambda to each value,
    and sum `0`` +`` 2**2`, `0`` +`` 2**2`` +`` 4**2`, etc. In actual fact, it starts
    with the first of the values, `2`. Then it applies the lambda to the remaining
    values, computing `2`` +`` 4**2`, `2`` +`` 4**2`` +`` 4**2`, etc.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 归约应该从 0 开始。它将对每个值应用 lambda，并计算 `0 + 2**2`，`0 + 2**2 + 4**2` 等。实际上，它从第一个值开始，即
    `2`。然后它将对剩余的值应用 lambda，计算 `2 + 4**2`，`2 + 4**2 + 4**2` 等。
- en: There’s no work-around using `partial()`. A lambda must be used in these cases
    where we’d like to apply a transformation while using `reduce()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `partial()` 没有可行的解决方案。在这些情况下，如果我们想在应用 `reduce()` 时进行转换，必须使用 lambda 表达式。
- en: A partial function is an important technique for simplifying a particularly
    complicated calculation. When there are numerous parameters, few of which change,
    then a partial function can be helpful. A partial function can make it easier
    to refactor a complex computation to use alternative implementations of discrete
    parts. Since each discrete part is a separately defined function, unit testing
    can confirm that the results are as expected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是一种简化特别复杂计算的重要技术。当有众多参数，其中很少改变时，部分函数可能很有帮助。部分函数可以使将复杂计算重构为使用离散部分的替代实现变得更加容易。由于每个离散部分都是一个单独定义的函数，单元测试可以确认结果是否符合预期。
- en: 'The limitation around the `reduce()` function is a result of a function with
    two properties:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`函数的限制是以下具有两个特性的函数的结果：'
- en: Only positional parameters
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有位置参数
- en: The parameters being provided in an awkward order
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的参数顺序很尴尬
- en: In the case of `reduce()`, the initial value comes after the source of values,
    making it difficult to provide via `partial()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reduce()`的情况下，初始值位于值源之后，这使得通过`partial()`提供变得困难。
- en: 10.5.3 Using the map() and reduce() functions to sanitize raw data
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.3 使用map()和reduce()函数清洗原始数据
- en: When doing data cleansing, we’ll often introduce filters of various degrees
    of complexity to exclude invalid values. We may also include a mapping to sanitize
    values in the cases where a valid but improperly formatted value can be replaced
    with a valid and proper value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据清洗时，我们经常会引入各种复杂程度的过滤器来排除无效值。我们还可以在有效但格式不正确的值可以被替换为有效且正确格式的值的情况下，包括一个映射来清洗值。
- en: 'We might produce the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会产生以下输出：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve defined a mapping, the `comma_fix()` function, that will convert data
    from a nearly correct string format into a usable floating-point value. This will
    remove the comma character. Another common variation could remove dollar signs
    and convert to `decimal.Decimal`. We’ve left this as an exercise for the reader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个映射，即`comma_fix()`函数，它将数据从几乎正确的字符串格式转换为可用的浮点数值。这将移除逗号字符。另一种常见的变体可以移除美元符号并转换为`decimal.Decimal`。我们将这个作为练习留给读者。
- en: We’ve also defined a map-reduce operation that applies a given cleaner function,
    the `comma_fix()` function in this case, to the data before doing a `reduce()`
    function, using the `operator.add` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个map-reduce操作，它将给定的清洗函数（在这种情况下是`comma_fix()`函数）应用于`reduce()`函数之前的数据，使用`operator.add`方法。
- en: 'We can apply the previously described function as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式应用之前描述的函数：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’ve cleaned the data by fixing the commas, as well as computing a sum. The
    syntax is very convenient for combining these two operations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过修复逗号以及计算总和来清洗数据。这种语法对于结合这两个操作非常方便。
- en: 'We have to be careful, however, of using the cleaning function more than once.
    If we’re also going to compute a sum of squares, we really should not execute
    the following kinds of processing steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须小心不要多次使用清洗函数。如果我们还打算计算平方和，我们真的不应该执行以下类型的处理步骤：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using `clean_sum()` expressions more than once means we’ll do the comma-fixing
    operation more than once on the source data. This is a poor design. It would be
    better to cache the intermediate numeric results of the `comma_fix()` function.
    Using a `@cache` decorator can help. Materializing the sanitized intermediate
    values as a temporary sequence object is better. Comparing the performance of
    different caching options is left as an exercise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 多次使用`clean_sum()`表达式意味着我们将在源数据上多次执行逗号修复操作。这是一个糟糕的设计。更好的做法是缓存`comma_fix()`函数的中间数值结果。使用`@cache`装饰器可以帮助。将清洗的中间值作为临时序列对象实体化会更好。比较不同缓存选项的性能作为练习留给读者。
- en: 10.5.4 Using the groupby() and reduce() functions
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.4 使用groupby()和reduce()函数
- en: A common requirement is to summarize data after partitioning it into groups.
    We can use a `defaultdict(list)` method to partition data. We can then analyze
    each partition separately. In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004), we looked at some ways to group
    and partition. In [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008),
    we looked at others.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是在将数据分组后总结数据。我们可以使用`defaultdict(list)`方法来分组数据。然后我们可以分别分析每个分组。在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中，我们探讨了分组和分区的几种方法。在[第8章](Chapter_08.xhtml#x1-1700008)，[Itertools模块](Chapter_08.xhtml#x1-1700008)中，我们探讨了其他方法。
- en: 'The following is some sample data that we need to analyze:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要分析的一些样本数据：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ve got a sequence of raw data values with a key (a short string) and a measurement
    for each key (a float value).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列原始数据值，每个值都有一个键（一个简短字符串）和每个键的测量值（一个浮点值）。
- en: 'One way to produce usable groups from this data is to build a dictionary that
    maps a key to a list of members in this groups, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据中产生可用的组的一种方法是为每个键到该组成员列表的映射构建一个字典，如下所示：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will separate each item in the iterable into a group based on the key.
    The iterable source of data is described using a type variable of `DT`, representing
    the type of each data item. The `key()` function is used to extract a key value
    from each item. This function produces an object of some key type, `KT`, that
    is generally distinct from the original data item type, `DT`. When looking at
    the sample data, the type of each data item is a tuple. The keys are of type `str`.
    The callable function for extracting a key transforms a tuple into a string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据键将可迭代的每个项分离到组中。数据源的可迭代表述使用类型变量 `DT`，表示每个数据项的类型。`key()` 函数用于从每个项中提取键值。这个函数产生一个某种键类型的对象，`KT`，通常与原始数据项类型
    `DT` 不同。在查看样本数据时，每个数据项的类型是元组。键的类型是 `str`。用于提取键的可调用函数将元组转换为字符串。
- en: This key value extracted from each data item is used to append each item to
    a list in the `pd` dictionary. The `defaultdict` object is defined as mapping
    each key, `KT`, to a list of the data items, `list[DT]`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个数据项中提取的这个键值用于将每个项追加到 `pd` 字典中的列表中。`defaultdict` 对象被定义为将每个键 `KT` 映射到数据项列表
    `list[DT]`。
- en: The resulting value of this function matches the results of the `itertools.groupby()`
    function. It’s an iterable sequence of the `(group`` key,`` iterator)` tuples.
    The group key value will be of the type produced by the key function. The iterator
    will provide a sequence of the original data items.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果与 `itertools.groupby()` 函数的结果相匹配。它是一个可迭代的 `(group key, iterator)` 元组序列。组键值将是键函数产生的类型。迭代器将提供原始数据项的序列。
- en: 'The following is the same feature defined with the `itertools.groupby()` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用 `itertools.groupby()` 函数定义的相同功能：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The important difference in the inputs to each function is that the `groupby()`
    function version requires data to be sorted by the key, whereas the
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数输入的重要区别在于，`groupby()` 函数版本要求数据按键排序，而
- en: '`defaultdict` version doesn’t require sorting. For very large sets of data,
    the sort can be expensive, measured in both time and storage.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 版本不需要排序。对于非常大的数据集，排序可能非常昂贵，无论是从时间还是存储的角度来看。'
- en: 'Here’s the core partitioning operation. This might be used prior to filtering
    out a group, or it might be used prior to computing statistics for each group:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是核心分区操作。这可能在过滤出组之前使用，或者在使用每个组的统计数据之前使用：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can summarize this grouped data as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些分组数据总结如下：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The results of the `partition()` functions will be a sequence of (key, iterator)
    two-tuples. The `summarize()` function accepts the two-tuple and decomposes it
    into the key and the iterator over the original data items. In this function,
    the data items are defined as `tuple[KT,`` float]`, a key of some type, `KT`,
    and a numeric value. From each two-tuple in the `item_iter` iterator we want the
    value portion, and we use a generator expression to create a tuple of only the
    values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()` 函数的结果将是一个包含 (key, iterator) 双元组的序列。`summarize()` 函数接受这个双元组，并将其分解为键和原始数据项的迭代器。在这个函数中，数据项被定义为
    `tuple[KT, float]`，其中 `KT` 是某种类型的键，`float` 是数值。从 `item_iter` 迭代器中的每个双元组中，我们想要的是值部分，我们使用生成器表达式来创建只包含值的元组。'
- en: We can also use the expression `map(snd,`` item_iter)` to pick the second item
    from each of the two-tuples. This requires a definition of `snd`` =`` lambda`` x:`` x[1]`
    or perhaps `snd`` =`` operator.itemgetter(1)`. The name `snd` is a short form
    of second.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以使用表达式 `map(snd, item_iter)` 来从每个双元组中选取第二个元素。这需要一个 `snd = lambda x: x[1]`
    或 `snd = operator.itemgetter(1)` 的定义。`snd` 是 second 的简称。'
- en: 'We can use the following command to apply the `summarize()` function to each
    partition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将 `summarize()` 函数应用于每个分区：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This uses the `starmap()` function from the `itertools` module. See [Chapter 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008). An alternative definition
    using the `partition_s()` function is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了 `itertools` 模块中的 `starmap()` 函数。参见[第8章](Chapter_08.xhtml#x1-1700008)，[迭代工具模块](Chapter_08.xhtml#x1-1700008)。使用
    `partition_s()` 函数的另一种定义如下：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Both will provide us with summary values for each group. The resulting group
    statistics look as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将为我们提供每个组的汇总值。结果分组统计如下：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The variance can be used as part of a χ² (chi-squared) test to determine if
    the null hypothesis holds for this data. The null hypothesis asserts that there’s
    nothing to see: the variance in the data is essentially random. We can also compare
    the data between the four groups to see if the various means are consistent with
    the null hypothesis or if there is some statistically significant variation.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 方差可以作为 χ²（卡方）测试的一部分来使用，以确定对于这些数据，零假设是否成立。零假设断言没有东西可看：数据中的方差基本上是随机的。我们还可以比较四个组之间的数据，以查看各种均值是否与零假设一致，或者是否存在某种统计上显著的差异。
- en: 10.5.5 Avoiding problems with reduce()
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.5 避免reduce()的问题
- en: 'There is a dark side to the `reduce()` function. We must avoid expressions
    like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 函数存在一个阴暗面。我们必须避免以下类似的表达式：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This does work, because Python will apply the generic `add` operator between
    two operands, which are strings. However, it will compute a large number of intermediate
    string objects, a relatively costly operation. An alternative is the `"".join(list_of_strings)`
    expression. A little study with `timeit` reveals that the `string.join()` approach
    is more efficient than the generic `reduce()` version. We’ll leave the data collection
    and analysis as an exercise for the reader.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，因为Python将在两个操作数之间应用通用的 `add` 操作符，这两个操作数是字符串。然而，它将计算大量的中间字符串对象，这是一个相对昂贵的操作。一个替代方案是
    `"".join(list_of_strings)` 表达式。通过 `timeit` 进行一点研究可以揭示，`string.join()` 方法比通用的 `reduce()`
    版本更有效。我们将数据收集和分析留给读者作为练习。
- en: In general, it’s best to scrutinize `reduce()` operations where the function
    provided creates or modifies a collection of some kind. It’s possible to have
    a superficially simple-looking expression that creates very large intermediate
    results. For example, we might write `reduce(accumulate_details,`` some_source,`` {})`
    without thinking of the way the `accumulate_details()` function updates a dictionary.
    We might be better off looking at ways to rewrite the underlying `accumulate_details()`
    function to accept a sequence instead of a single item.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好仔细审查由提供的函数创建或修改某种集合的 `reduce()` 操作。可能有一个表面上看起来很简单但会创建非常大的中间结果的表达式。例如，我们可能会写出
    `reduce(accumulate_details, some_source, {})`，而没有考虑到 `accumulate_details()` 函数如何更新字典。我们可能更倾向于查看重写底层
    `accumulate_details()` 函数的方法，使其接受一个序列而不是单个项。
- en: 10.6 Handling multiple types with singledispatch
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6 使用 singledispatch 处理多种类型
- en: We’ll often have functions which have similar semantics but distinct implementations
    based on the type of data presented. We might have a function that works for either
    a subclass of `NamedTuple`, or `TypedDict`. The syntax for working with these
    objects is distinct, and we can’t use a single, generic Python function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会遇到具有相似语义但基于数据类型具有不同实现的函数。我们可能有一个适用于 `NamedTuple` 的子类或 `TypedDict` 的函数。处理这些对象的语法是不同的，我们无法使用单个通用的Python函数。
- en: 'We have the following choices for working with data of distinct types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下几种选择来处理不同类型的数据：
- en: Use the `match` statement with a `case` clause for each distinct type.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有每个不同类型的 `case` 子句的 `match` 语句。
- en: Use the `@singledispatch` decorator to define a number of closely-related functions.
    This will create the necessary type-matching `match` statement for us.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@singledispatch` 装饰器定义多个密切相关函数。这将为我们创建必要的类型匹配 `match` 语句。
- en: A small example arises when working with US postal data and spreadsheets. It’s
    common for a US postal ZIP code to be misinterpreted as an integer (or float)
    value. The town of Andover, MA, for example, has a postal code of 01810\. A spreadsheet
    might misinterpret this as an integer, 1810, dropping the leading zero.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理美国邮政数据和电子表格时，会出现一个小例子。美国邮政的ZIP代码通常会被误解为整数（或浮点）值。例如，马萨诸塞州的安多弗镇有一个邮政编码为01810。电子表格可能会将其误解为整数1810，忽略了前面的零。
- en: 'When working with US postal data, we often need a function to normalize ZIP
    codes as string values, restoring any dropped leading zero values. This function
    will have at least the following three cases:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理美国邮政数据时，我们经常需要一个函数来将邮政编码作为字符串值标准化，恢复任何丢失的前导零值。这个函数至少有以下三种情况：
- en: An integer value needs to be converted to a string and have leading zeroes restored.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数值需要转换为字符串，并恢复前导零。
- en: A float value, similarly, needs to be converted to a string and have the leading
    zeroes restored.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，浮点值也需要转换为字符串，并恢复前导零。
- en: A string value may be a five-digit ZIP code or a nine-digit ZIP code. Depending
    on the application, we might want to truncate the ZIP codes to ensure they are
    uniform.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串值可能是一个五位数的邮政编码或一个九位数的邮政编码。根据应用，我们可能想要截断邮政编码以确保它们是一致的。
- en: While we can use a `match` statement to handle these three cases, we can also
    define several closely-related functions. The `@singledispatch` decorator lets
    us define a ”default” function, used when no type matching is possible. We can
    then overload this function with additional definitions for each of the data types
    we want to process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`match`语句来处理这三种情况，但我们也可以定义几个密切相关函数。`@singledispatch`装饰器让我们定义一个“默认”函数，用于在无法进行类型匹配时使用。然后，我们可以通过为每个我们想要处理的数据类型添加额外的定义来重载这个函数。
- en: 'Here is the suite of definitions for a single `zip_format()` function. We’ll
    start with the base definition, used when no other definition will work:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是单个`zip_format()`函数的定义套件。我们将从基础定义开始，这是在没有其他定义可以工作的情况下使用的：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `@singledispatch` decorator will create a new decorator, using the name
    of the function, `zip_format`. This new `@zip_format` decorator can then use be
    used to create alternative, overloaded definitions. These definitions imply a
    `match` statement to distinguish among the alternatives based on type matching
    rules.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`@singledispatch`装饰器将创建一个新的装饰器，使用函数的名称`zip_format`。这个新的`@zip_format`装饰器可以用来创建替代的重载定义。这些定义隐含了一个`match`语句，根据类型匹配规则来区分这些替代方案。'
- en: 'Here are the alternative definitions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是替代定义：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that each alternative function uses a name, `_`, that will be ignored.
    The functions will all be combined into a single `zip_format()` function that
    will dispatch an appropriate implementation based on the type of the argument
    value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个替代函数都使用一个将被忽略的名称`_`。这些函数将全部组合成一个单一的`zip_format()`函数，该函数将根据参数值的类型分派适当的实现。
- en: It’s also important to note that these functions do not all need to be defined
    in the same module. We can provide a module with foundational definitions. Additional
    modules can then import the base definitions and register their unique implementation
    functions. This permits expansion by adding alternative implementations at the
    module level.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，这些函数不一定都需要定义在同一个模块中。我们可以提供一个包含基础定义的模块。然后，其他模块可以导入这些基础定义并注册它们独特的实现函数。这允许在模块级别通过添加替代实现来扩展。
- en: 10.7 Summary
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7 摘要
- en: In this chapter, we’ve looked at a number of functions in the `functools` module.
    This library module provides a number of functions that help us create sophisticated
    functions and classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了`functools`模块中的许多函数。这个库模块提供了一些函数，帮助我们创建复杂的函数和类。
- en: We’ve looked at the `@cache` and `@lru_cache` decorators as ways to boost certain
    types of applications with frequent re-calculations of the same values. These
    two decorators are of tremendous value for certain kinds of functions that take
    integer or string argument values. They can reduce processing by simply implementing
    memoization. The `@lru_cache` has an upper bound on the memory it will use; this
    is good for a domain with an unknown size.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了`@cache`和`@lru_cache`装饰器作为提升某些类型应用的方法，这些应用经常需要重新计算相同的值。这两个装饰器对于某些接受整数或字符串参数值的函数非常有价值。它们可以通过实现记忆化来减少处理。`@lru_cache`有一个内存使用的上限；这对于一个未知大小的域来说是个优点。
- en: We looked at the `@total_ordering` function as a decorator to help us build
    objects that support rich ordering comparisons. This is at the fringe of functional
    programming, but is very helpful when creating new kinds of numbers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`@total_ordering`函数作为一个装饰器来查看，以帮助我们构建支持丰富排序比较的对象。这处于函数式编程的边缘，但在创建新类型的数字时非常有帮助。
- en: The `partial()` function creates a new function with the partial application
    of argument values. As an alternative, we can build a lambda with similar features.
    The use case for this is ambiguous.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`函数创建了一个具有部分应用参数值的新的函数。作为替代，我们也可以构建具有类似特征的lambda表达式。这种用例是不明确的。'
- en: We also looked at the `reduce()` function as a higher-order function. This generalizes
    reductions like the `sum()` function. We’ll use this function in several examples
    in later chapters. This fits logically with the `filter()` and `map()` functions
    as an important higher-order function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了`reduce()`函数作为高阶函数。它将像`sum()`函数这样的归约泛化。我们将在后续章节的几个示例中使用此函数。这与`filter()`和`map()`函数作为重要的高阶函数的逻辑相符。
- en: The `@singledispatch` decorator can help us to create a number of functions
    with similar semantics, but distinct data types for the argument values. This
    prevents the overhead of an explicit `match` statement. As the software evolves,
    we can add definitions to the collection of alternatives.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`@singledispatch`装饰器可以帮助我们创建具有相似语义但不同数据类型参数值的多个函数。这避免了显式`match`语句的开销。随着软件的发展，我们可以向替代集合中添加定义。'
- en: In the next chapter, we’ll look at a collection of small topics. We’ll examine
    the `toolz` package, which provides some alternatives to the built-in `itertools`
    and `functools` modules. This alternative has a number of new features. It also
    has some overlapping features that are considered from a different perspective,
    making them more useful for some applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一系列小主题。我们将检查`toolz`包，它提供了一些内置的`itertools`和`functools`模块的替代方案。这个替代方案有几个新特性。它还有一些重叠的特性，从不同的角度考虑，使它们在某些应用中更有用。
- en: We’ll also see some additional use of the `operator` module. This module makes
    some Python operators available as functions, letting us simplify our own function
    definitions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到`operator`模块的一些额外用途。此模块使一些Python运算符作为函数可用，使我们能够简化自己的函数定义。
- en: We’ll also look at some techniques to design flexible decision-making and to
    allow expressions to be evaluated in a non-strict order.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨一些设计灵活决策和允许表达式以非严格顺序评估的技术。
- en: 10.8 Exercises
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub存储库中已提供的单元测试用例相同。读者应将书中的示例函数名称替换为自己的解决方案以确认其工作。
- en: 10.8.1 Compare string.join() and reduce()
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.1 比较`string.join()`和`reduce()`
- en: 'In the [Avoiding problems with reduce()](#x1-2270005) section of this chapter,
    we noted that we can combine a list of string values into a single string in the
    following two ways:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[避免reduce()问题](#x1-2270005)部分，我们注意到我们可以以下两种方式将字符串值列表合并成一个字符串：
- en: '`reduce(operator.add,`` list_of_strings,`` "")`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce(operator.add, list_of_strings, "")`'
- en: '`"".join(list_of_strings)`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"".join(list_of_strings)`'
- en: One of these is considerably more efficient than the other. Use the `timeit`
    module to find out which is more efficient. The efficiency gain is dramatic, and
    it can be helpful to know what the ratio of time between these two approaches
    is.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一比另一个效率高得多。使用`timeit`模块找出哪个更高效。效率提升是显著的，了解这两种方法之间的时间比可能很有帮助。
- en: It’s also important to know how the two approaches scale with larger and larger
    collections of strings. To this end, build a small module that exercises the above
    two expressions with collections of strings. Use collections with sizes 100, 200,
    300, ..., 900 as a way to see how the work scales with the number of strings being
    concatenated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 了解两种方法如何随着字符串集合的增大而扩展也很重要。为此，构建一个小模块，使用字符串集合来练习上述两个表达式。使用大小为 100、200、300、...、900
    的集合，以查看工作如何随着连接字符串的数量而扩展。
- en: 10.8.2 Extend the comma_fix() function
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.2 扩展 comma_fix() 函数
- en: In the [Using the map() and reduce() functions to sanitize raw data](#x1-2250003)
    section, we defined a mapping, the `comma_fix()` function, that will convert data
    from a nearly correct string format into a usable floating-point value. This will
    remove the comma character.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 map() 和 reduce() 函数清理原始数据](#x1-2250003) 部分，我们定义了一个映射，即 `comma_fix()` 函数，它将数据从几乎正确的字符串格式转换为可用的浮点值。这将移除逗号字符。
- en: This function has a misleading name. It’s really a string-to-float conversion
    that tolerates some punctuation. A better name might be `tolerant_str_to_float()`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的名称具有误导性。它实际上是一个可以容忍一些标点的字符串到浮点数的转换。一个更好的名称可能是 `tolerant_str_to_float()`。
- en: Define and test a tolerant string-to-decimal conversion function. This should
    remove dollar signs, as well as commas, and convert the remaining string to `decimal.Decimal`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并测试一个容忍字符串到十进制的转换函数。这应该移除美元符号以及逗号，并将剩余的字符串转换为 `decimal.Decimal`。
- en: Define and test a tolerant string-to-int conversion function. This should parallel
    the `tolerant_str_to_float()` by removing only comma characters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并测试一个容忍字符串到整数的转换函数。这应该与 `tolerant_str_to_float()` 平行，仅移除逗号字符。
- en: 10.8.3 Revise the clean_sum() function
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.8.3 修改 clean_sum() 函数
- en: In the [Using the map() and reduce() functions to sanitize raw data](#x1-2250003)
    section, we defined a `clean_sum()` function to cleanse and sum a collection of
    raw string values. For a simple case like computing a mean, this involves a single
    pass over the data doing conversion and computation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 map() 和 reduce() 函数清理原始数据](#x1-2250003) 部分，我们定义了一个 `clean_sum()` 函数来清理和求和一组原始字符串值。对于像计算均值这样的简单情况，这涉及到对数据进行转换和计算的单次遍历。
- en: For a more complex operation, like variance or standard deviation, multiple
    passes can be burdensome because the string conversion is done repeatedly. This
    suggests the `clean_sum()` function is a poor design.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像方差或标准差这样的更复杂操作，多次遍历可能会很繁琐，因为字符串转换是重复进行的。这表明 `clean_sum()` 函数是一个糟糕的设计。
- en: 'The first requirement is a function to compute the mean, variance, and standard
    deviation of string data:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求是一个计算字符串数据的均值、方差和标准差的函数：
- en: '![ ∑ --x∈D-x- mean (D ) = len(D ) ](img/file102.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ --x∈D-x- mean (D ) = len(D ) ](img/file102.jpg)'
- en: '![ ∑ (x-−-mean-(D-))2 var(D ) = len(D )− 1 x∈D ](img/file103.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ (x-−-mean-(D-))2 var(D ) = len(D )− 1 x∈D ](img/file103.jpg)'
- en: '![stdev(D ) = ∘var-(D-) ](img/file104.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![stdev(D ) = ∘var-(D-) ](img/file104.jpg)'
- en: One design alternative is to cache the intermediate numeric results of the `comma_fix()`
    function. Use the `@cache` decorator to define a `comma_fix()` function. (This
    function should be renamed to something a little more explicit, like `str_to_float()`.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一种设计替代方案是缓存 `comma_fix()` 函数的中间数字结果。使用 `@cache` 装饰器定义一个 `comma_fix()` 函数。（这个函数应该重命名为更明确的名字，比如
    `str_to_float()`。）
- en: Create a very large collection of randomized numeric strings and see which alternative
    is faster.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个非常大的随机数字字符串集合，并查看哪种替代方案更快。
- en: Another design alternative is to materialize the sanitized intermediate values.
    Create a temporary sequence object with the purely numeric values, and then compute
    the various statistical measures on these purely numeric lists.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设计替代方案是具体化清理后的中间值。创建一个只包含纯数字值的临时序列对象，然后在这些纯数字列表上计算各种统计度量。
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we presented a way to use `sys.getallocatedblocks()` to understand how much memory
    was being used by Python. This procedure can be applied here to see which caching
    alternative uses the least memory.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)
    中，我们介绍了一种使用 `sys.getallocatedblocks()` 来了解 Python 使用了多少内存的方法。这个程序可以应用于此处，以查看哪种缓存替代方案使用的内存最少。
- en: Present the results to show which design alternative is best for performance
    and memory use.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 展示结果以显示哪种设计替代方案在性能和内存使用方面最佳。
- en: Join our community Discord space
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
