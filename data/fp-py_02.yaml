- en: Chapter 2. Introducing Some Functional Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。介绍一些函数式特性
- en: Most of the features of functional programming are already first-class parts
    of Python. Our goal in writing functional Python is to shift our focus away from
    imperative (procedural or object-oriented) techniques to the maximum extent possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的大多数特性已经是Python的一等部分。我们在编写函数式Python时的目标是尽可能地将我们的注意力从命令式（过程式或面向对象）技术转移。
- en: 'We''ll look at each of the following functional programming topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究以下每个函数式编程主题：
- en: First-class and higher-order functions, which are also known as pure functions.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等和高阶函数，也称为纯函数。
- en: Immutable Data.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据。
- en: Strict and non-strict evaluation. We can also call this eager vs. lazy evaluation.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格和非严格评估。我们也可以称之为急切 vs. 懒惰评估。
- en: Recursion instead of an explicit loop state.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归而不是显式循环状态。
- en: Functional type systems.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式类型系统。
- en: This should reiterate some concepts from the first chapter. Firstly, that purely
    functional programming avoids the complexities of explicit state maintained via
    variable assignment. Secondly, that Python is not a purely functional language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该重申第一章的一些概念。首先，纯函数式编程避免了通过变量赋值维护显式状态的复杂性。其次，Python不是一个纯函数式语言。
- en: We don't offer a rigorous definition of functional programming. Instead, we'll
    locate some common features that are indisputably important. We'll steer clear
    of the blurry edges.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不提供对函数式编程的严格定义。相反，我们将找到一些不容置疑重要的共同特征。我们将避开模糊的边缘。
- en: First-class functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一等函数
- en: Functional programming is often succinct and expressive. One way to achieve
    this is by providing functions as arguments and return values for other functions.
    We'll look at numerous examples of manipulating functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通常简洁而富有表现力。实现这一点的一种方法是将函数作为其他函数的参数和返回值。我们将看到许多操纵函数的例子。
- en: For this to work, functions must be first-class objects in the runtime environment.
    In programming languages such as C, a function is not a runtime object. In Python,
    however, functions are objects that are created (usually) by the `def` statements
    and can be manipulated by other Python functions. We can also create a function
    as a callable object or by assigning `lambda` to a variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，函数必须是运行时环境中的一等对象。在诸如C之类的编程语言中，函数不是运行时对象。然而，在Python中，函数是由`def`语句创建的对象，可以被其他Python函数操纵。我们也可以通过将`lambda`分配给变量来创建一个可调用对象的函数。
- en: 'Here''s how a function definition creates an object with attributes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义如何创建具有属性的对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've created an object, `example`, that is of class `function()`. This object
    has numerous attributes. The `__code__` object associated with the function object
    has attributes of its own. The implementation details aren't important. What is
    important is that functions are first-class objects, and can be manipulated just
    like all other objects. We previously displayed the values of two of the many
    attributes of a function object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`example`的对象，它是`function()`类的对象。这个对象有许多属性。与函数对象关联的`__code__`对象有它自己的属性。实现细节并不重要。重要的是函数是一等对象，可以像所有其他对象一样被操纵。我们之前显示了函数对象的许多属性中的两个值。
- en: Pure functions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: To be expressive, a function used in a functional programming design will be
    free from the confusion created by side effects. Using pure functions can also
    allow some optimizations by changing evaluation order. The big win, however, stems
    from pure functions being conceptually simpler and much easier to test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达，函数在函数式编程设计中使用将不受副作用创建的混乱的影响。使用纯函数也可以通过改变评估顺序来实现一些优化。然而，最大的优势来自于纯函数在概念上更简单，更容易测试。
- en: To write a pure function in Python, we have to write local-only code. This means
    we have to avoid the `global` statements. We need to look closely at any use of
    `nonlocal`; while it is a side effect in another scope, it's confined to a `nested`
    function definition. This is an easy standard to meet. Pure functions are a common
    feature of Python programs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中编写纯函数，我们必须编写仅限于本地的代码。这意味着我们必须避免使用`global`语句。我们需要仔细查看任何使用`nonlocal`；虽然它是另一个作用域中的副作用，但它局限于`nested`函数定义。这是一个容易满足的标准。纯函数是Python程序的一个常见特性。
- en: There isn't a trivial way to guarantee a Python function is free from side effects.
    It is easy to carelessly break the pure function rule. If we ever want to worry
    about our ability to follow this rule, we could write a function that uses the
    `dis` module to scan a given function's `__code__.co_code` compiled code for global
    references. It could report on use of internal closures, and the `__code__.co_freevars`
    `tuple` method as well. This is a rather complex solution to a rare problem; we
    won't pursue it further.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种简单的方法来保证Python函数没有副作用。很容易粗心地违反纯函数规则。如果我们想担心我们能否遵循这个规则，我们可以编写一个使用`dis`模块扫描给定函数的`__code__.co_code`编译代码的全局引用的函数。它还可以报告内部闭包的使用，以及`__code__.co_freevars`
    `tuple`方法。这是一个对一个罕见问题的相当复杂的解决方案；我们不会进一步追求它。
- en: A Python `lambda` is a pure function. While this isn't a highly recommended
    style, it's certainly possible to create pure functions via `lambda` values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`lambda`是一个纯函数。虽然这不是一个高度推荐的风格，但通过`lambda`值可以创建纯函数。
- en: 'Here''s a function created by assigning `lambda` to a variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将`lambda`分配给变量创建的一个函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We created a pure function using `lambda` and assigned this to the variable
    `mersenne`. This is a callable object with a single argument value that returns
    a single value. Because lambda's can't have assignment statements, they're always
    pure functions and suitable for functional programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`lambda`创建了一个纯函数，并将其分配给变量`mersenne`。这是一个可调用对象，具有一个参数值，返回一个值。因为lambda不能有赋值语句，它们总是纯函数，适用于函数式编程。
- en: Higher-order functions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: We can achieve expressive, succinct programs using higher-order functions. These
    are functions that accept a function as an argument or return a function as a
    value. We can use higher-order functions as a way to create composite functions
    from simpler functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用高阶函数实现富有表现力、简洁的程序。这些函数接受一个函数作为参数，或者返回一个函数作为值。我们可以使用高阶函数来从简单的函数中创建复合函数。
- en: Consider the Python `max()` function. We can provide a function as an argument
    and modify how the `max()` function behaves.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Python的`max()`函数。我们可以提供一个函数作为参数，并修改`max()`函数的行为。
- en: 'Here''s some data we might want to process:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些我们可能想要处理的数据：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can apply the `max()` function as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样应用`max()`函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default behavior is to simply compare each `tuple` in the sequence. This
    will return the `tuple` with the largest value on position 0.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是简单地比较序列中的每个`tuple`。这将返回在位置0上具有最大值的`tuple`。
- en: 'Since the `max()` function is a higher-order function, we can provide another
    function as an argument. In this case, we''ll use `lambda` as the function; this
    is used by the `max()` function, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`max()`函数是一个高阶函数，我们可以提供另一个函数作为参数。在这种情况下，我们将使用`lambda`作为函数；这将被`max()`函数使用，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `max()` function applies the supplied `lambda` and returns
    the tuple with the largest value in position 1.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`max()`函数应用了提供的`lambda`，并返回了位置1中最大值的元组。
- en: Python provides a rich collection of higher-order functions. We'll see examples
    of each of Python's higher-order functions in later chapters, primarily in [Chapter
    5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions.* We'll
    also see how we can easily write our own higher-order functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了丰富的高阶函数集合。我们将在后面的章节中看到Python的每个高阶函数的示例，主要在[第5章](ch05.html "第5章。高阶函数")中，*高阶函数*。我们还将看到如何轻松地编写我们自己的高阶函数。
- en: Immutable data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变数据
- en: Since we're not using variables to track the state of a computation, our focus
    needs to stay on immutable objects. We can make extensive use of `tuples` and
    `namedtuples` to provide more complex data structures that are immutable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用变量来跟踪计算的状态，我们的重点需要放在不可变对象上。我们可以广泛使用`tuples`和`namedtuples`来提供更复杂的不可变数据结构。
- en: The idea of immutable objects is not foreign to Python. There can be a performance
    advantage to using immutable `tuples` instead of more complex mutable objects.
    In some cases, the benefits come from rethinking the algorithm to avoid the costs
    of object mutation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的概念对Python并不陌生。使用不可变的`tuples`而不是更复杂的可变对象可能会带来性能优势。在某些情况下，好处来自于重新思考算法，以避免对象变异的成本。
- en: We will avoid class definitions (almost) entirely. It can seem like it's anathema
    to avoid objects in an **Object**-**Oriented** **Programming** (**OOP**) language.
    Functional programming simply doesn't need stateful objects. We'll see this throughout
    this book. There are reasons for defining `callable` objects; it is a tidy way
    to provide `namespace` for closely-related functions, and it supports a pleasant
    level of configurability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将几乎完全避免类定义。在**面向对象**(**OOP**)语言中避免对象似乎是一种厌恶。函数式编程根本不需要有状态的对象。我们将在本书中看到这一点。有理由定义`callable`对象；这是一种为密切相关的函数提供`namespace`的整洁方式，并且支持愉快的可配置性。
- en: 'We''ll look at a common design pattern that works well with immutable objects:
    the `wrapper()` function. A list of tuples is a fairly common data structure.
    We will often process this list of tuples in one of the two following ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个与不可变对象很好配合的常见设计模式：`wrapper()`函数。元组列表是一种相当常见的数据结构。我们经常以以下两种方式之一处理这个元组列表：
- en: '**Using** **Higher-order Functions**: As shown earlier, we provided `lambda`
    as an argument to the `max()` function: `max(year_cheese, key=lambda yc: yc[1])`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用高阶函数**：如前所示，我们将`lambda`作为`max()`函数的参数提供：`max(year_cheese, key=lambda yc:
    yc[1])`'
- en: '**Using the Wrap-Process-Unwrap pattern**: In a functional context, we should
    call this the `unwrap(process(wrap(structure)))` pattern'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Wrap-Process-Unwrap模式**：在一个函数上下文中，我们应该称之为`unwrap(process(wrap(structure)))`模式'
- en: 'For example, look at the following command snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的命令片段：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This fits the three-part pattern, although it might not be obvious how well
    it fits.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合三部分模式，尽管它可能不明显地符合得很好。
- en: 'First, we wrap, using `map(lambda yc: (yc[1],yc), year_cheese)`. This will
    transform each item into a two tuple with a key followed by the original item.
    In this example, the comparison key is merely `yc[1]`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们使用`map(lambda yc: (yc[1],yc), year_cheese)`进行包装。这将把每个项目转换成一个带有原始项目后面的两个元组。在这个例子中，比较键仅仅是`yc[1]`。'
- en: Second, do the processing using the `max()` function. Since each piece of data
    has been simplified to a two tuple with position zero used for comparison, we
    don't really need the higher-order function feature of the `max()` function. The
    default behavior of the `max()` function is exactly what we require.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，使用`max()`函数进行处理。由于每个数据片段都被简化为一个用于比较的两个元组，我们实际上不需要`max()`函数的高阶函数特性。`max()`函数的默认行为正是我们需要的。
- en: Finally, we unwrap using the subscript `[1]`. This will pick the second element
    of the two tuple selected by the `max()` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用下标`[1]`进行解包。这将选择`max()`函数选定的两个元组中的第二个元素。
- en: 'This kind of `wrap` and `unwrap` is so common that some languages have special
    functions with names like `fst()` and `snd()` that we can use as a function prefix
    instead of a syntactic suffix of `[0]` or `[1]`. We can use this idea to modify
    our wrap-process-unwrap example, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`wrap`和`unwrap`是如此常见，以至于一些语言有特殊的函数，名称如`fst()`和`snd()`，我们可以使用作为函数前缀，而不是语法后缀`[0]`或`[1]`。我们可以使用这个想法来修改我们的wrap-process-unwrap示例，如下：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We defined a `snd()` function to pick the second item from a `tuple`. This provides
    us with an easier-to-read version of `unwrap(process(wrap()))`. We used `map(lambda...
    , year_cheese)` to `wrap` our raw data items. We used `max()` function as the
    processing and, finally, the `snd()` function to extract the second item from
    the tuple.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`snd()`函数来选择`元组`中的第二个项目。这为我们提供了一个更易读的版本`unwrap(process(wrap()))`。我们使用`map(lambda...
    , year_cheese)`来`wrap`我们的原始数据项。我们使用`max()`函数作为处理，最后使用`snd()`函数从元组中提取第二个项目。
- en: In [Chapter 13](ch13.html "Chapter 13. Conditional Expressions and the Operator
    Module"), *Conditional Expressions and the Operator Module*, we'll look at some
    alternatives to `lambda` functions like `fst()` and `snd()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章. 条件表达式和操作符模块")中，*条件表达式和操作符模块*，我们将看一些替代`lambda`函数的选择，比如`fst()`和`snd()`。
- en: Strict and non-strict evaluation
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格和非严格评估
- en: Functional programming's efficiency stems, in part, from being able to defer
    a computation until it's required. The idea of lazy or non-strict evaluation is
    very helpful. It's so helpful that Python already offers this feature.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的效率部分来自于能够推迟计算直到需要。懒惰或非严格评估的想法非常有帮助。它是如此有帮助，以至于Python已经提供了这个特性。
- en: In Python, the logical expression operators `and`, `or`, and `if-then-else`
    are all non-strict. We sometimes call them *short-circuit* operators because they
    don't need to evaluate all arguments to determine the resulting value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，逻辑表达式运算符`and`、`or`和`if-then-else`都是非严格的。我们有时称它们为*短路*运算符，因为它们不需要评估所有参数来确定结果值。
- en: 'The following command snippet shows the `and` operator''s non-strict feature:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令片段显示了`and`运算符的非严格特性：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we execute the preceding command snippet, the left-hand side of the `and`
    operator is equivalent to `False`; the right-hand side is not evaluated. When
    the left-hand side is equivalent to `True`, the right-hand side is evaluated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行上述命令片段时，`and`运算符的左侧等同于`False`；右侧不会被评估。当左侧等同于`True`时，右侧会被评估。
- en: Other parts of Python are strict. Outside the logical operators, an expression
    is evaluated eagerly from left-to-right. A sequence of statement lines is also
    evaluated strictly in order. `Literal` lists and `tuples` require eager evaluation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python的其他部分是严格的。在逻辑运算符之外，表达式会从左到右急切地进行评估。一系列的语句行也会按顺序严格进行评估。`Literal`列表和`元组`需要急切的评估。
- en: When a class is created, the method functions are defined in a strict order.
    In the case of a class definition, the method functions are collected into a dictionary
    (by default) and order is not maintained after they're created. If we provide
    two methods with the same name, the second one is retained because of the strict
    evaluation order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被创建时，方法函数是按严格顺序定义的。在类定义的情况下，方法函数被收集到一个字典中（默认情况下），并且在创建后不保持顺序。如果我们提供了两个同名的方法，第二个方法会被保留，因为严格的评估顺序。
- en: 'Python''s generator expressions and generator functions, however, are lazy.
    These expressions don''t create all possible results immediately. It''s difficult
    to see this without explicitly logging the details of a calculation. Here is an
    example of the version of the `range()` function that has the side effect of showing
    the numbers it creates:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python的生成器表达式和生成器函数是懒惰的。这些表达式不会立即创建所有可能的结果。如果不明确记录计算的细节，很难看到这一点。这是`range()`函数的一个版本的例子，它具有显示它创建的数字的副作用：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If this function were eager, it would create all 1,024 numbers. Since it's lazy,
    it only creates numbers as requested.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数是急切的，它会创建所有1024个数字。由于它是懒惰的，它只在被请求时创建数字。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The older Python 2 `range()` function was eager and created an actual list of
    object with all of the requested numbers. Python 2 has an `xrange()` function
    that is lazy and matches the semantics of the Python 3 `range()` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的Python 2 `range()`函数是急切的，并创建了一个包含所有请求的数字的实际列表对象。Python 2有一个`xrange()`函数，它是懒惰的，并且与Python
    3的`range()`函数的语义相匹配。
- en: 'We can use this noisy `numbers()` function in a way that will show lazy evaluation.
    We''ll write a function that evaluates some, but not all, of the values from this
    iterator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以一种显示懒惰评估的方式使用这个喧闹的`numbers()`函数。我们将编写一个函数，评估这个迭代器的一些值，但不是全部值：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `sum_to()` function will not evaluate the entire result of the `numbers()`
    function. It will break after only consuming a few values from the `numbers()`
    function. We can see this consumption of values in the following log:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_to()`函数不会评估`numbers()`函数的整个结果。它只在消耗了`numbers()`函数的一些值后中断。我们可以在以下日志中看到对值的消耗：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we'll see later, Python generator functions have some properties that make
    them a little awkward for simple functional programming. Specifically, a generator
    can only be used once in Python. We have to be cautious how we use the lazy Python
    generator expressions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在后面看到的，Python生成器函数具有一些特性，使它们在简单的函数式编程中有些尴尬。具体来说，生成器在Python中只能使用一次。我们必须小心使用懒惰的Python生成器表达式。
- en: Recursion instead of a explicit loop state
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归而不是显式循环状态
- en: Functional programs don't rely on `loops` and the associated overhead of tracking
    the state of loops. Instead, functional programs try to rely on the much simpler
    approach of recursive functions. In some languages, the programs are written as
    recursions, but **Tail**-**Call** **Optimization** (**TCO**) by the compiler changes
    them to `loops`. We'll introduce some recursion here and examine it closely in
    [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions and
    Reductions*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序不依赖于`循环`和跟踪循环状态的相关开销。相反，函数式程序试图依赖于递归函数的更简单的方法。在一些语言中，程序被写成递归，但是编译器的**尾递归优化**（**TCO**）将它们改为`循环`。我们将在[第6章](ch06.html
    "第6章. 递归和规约")中介绍一些递归，并对其进行仔细的检查。
- en: We'll look at a simple iteration to test a number for being prime. A prime number
    is a natural number, evenly divisible by only 1 and itself. We can create a naïve
    and poorly performing algorithm to determine if a number has any factors between
    two and the number. This algorithm has the advantage of simplicity; it works acceptably
    for solving **Project Euler** problems. Read up on **Miller**-**Rabin** primality
    tests for a much better algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个简单的迭代来测试一个数是否为质数。质数是一个自然数，只能被1和它自己整除。我们可以创建一个天真且性能不佳的算法来确定一个数在2和该数之间是否有任何因子。这个算法的优点是简单；它可以用来解决**Project
    Euler**问题。阅读**Miller**-**Rabin**素性测试，以获得一个更好的算法。
- en: We'll use the term `coprime` to mean that two numbers have only 1 as their common
    factor. The numbers 2 and 3, for example, are `coprime`. The numbers 6 and 9,
    however, are not `coprime` because they have 3 as a common factor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用术语`互质`来表示两个数只有1作为它们的公因数。例如，数字2和3是`互质`的。然而，数字6和9不是`互质`的，因为它们有3作为公因数。
- en: 'If we want to know if a number, *n*, is prime, we actually ask this: is the
    number *n* `coprime` to all prime numbers, *p*, such that ![Recursion instead
    of a explicit loop state](graphics/B03652_02_03.jpg). We can simplify this using
    all integers, *p*, such that ![Recursion instead of a explicit loop state](graphics/B03652_02_05.jpg).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道一个数*n*是否是质数，我们实际上是在问：数字*n*是否与所有质数*p*`互质`，使得![递归而不是显式循环状态](graphics/B03652_02_03.jpg)。我们可以简化这个问题，使用所有整数*p*，使得![递归而不是显式循环状态](graphics/B03652_02_05.jpg)。
- en: 'Sometimes, it helps to formalize this as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将其形式化如下有所帮助：
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![递归而不是显式循环状态](graphics/B03652_02_02.jpg)'
- en: 'The expression could look as follows in Python:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，表达式可能如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A more direct conversion from mathematical formalism to Python would use `all(n%p
    != 0... )` but that requires strict evaluation of all values of *p*. The *not
    any* version can terminate early if a `True` value is found.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学形式转换为Python的更直接的转换将使用`all(n%p != 0... )`，但这需要严格评估所有值*p*。`not any`版本可以在找到`True`值时提前终止。
- en: 'This simple expression has a `for` loop inside it: it''s not a pure example
    of stateless functional programming. We can reframe this into a function that
    works with a collection of values. We can ask whether the number, *n*, is `coprime`
    within any value in the range ![Recursion instead of a explicit loop state](graphics/B03652_02_07.jpg)?".
    This uses the symbols, `[)`, to show a half-open interval: the lower values are
    included, and the upper value is not included. This is typical behavior of the
    Python `range()` function. We will also restrict ourselves to the domain of natural
    numbers. The square root values, for example, are implicitly truncated to `integers`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的表达式中有一个`for`循环：它不是无状态的函数式编程的纯例子。我们可以将其重新构建为一个处理值集合的函数。我们可以询问数字*n*是否在范围![递归而不是显式循环状态](graphics/B03652_02_07.jpg)内是`互质`的。这使用符号`[)`来显示半开区间：包括较小的值，不包括较大的值。这是Python
    `range()`函数的典型行为。我们还将限制自己在自然数的域内。例如，平方根值被隐式地截断为`整数`。
- en: 'We can think of the definition of prime as the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将质数的定义看作是以下内容：
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![递归而不是显式循环状态](graphics/B03652_02_09.jpg)'
- en: 'When defining a recursive function over a simple range of values, the base
    case can be an empty range. A nonempty range is handled recursively by processing
    one value combined with a range that''s narrower by one value. We might formalize
    it as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一系列简单的值上定义递归函数时，基本情况可以是一个空范围。非空范围通过处理一个值和一个比一个值更窄的范围来递归处理。我们可以将其形式化如下：
- en: '![Recursion instead of a explicit loop state](graphics/B03652_02_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![递归而不是显式循环状态](graphics/B03652_02_11.jpg)'
- en: 'This version is relatively easy to confirm by examining the two cases, which
    are given as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查以下两种情况，可以相对容易地确认这个版本：
- en: If the range is empty, ![Recursion instead of a explicit loop state](graphics/B03652_02_12.jpg),
    we evaluate something like:![Recursion instead of a explicit loop state](graphics/B03652_02_14.jpg).
    The range contains no values, so the return is a trivial `True`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果范围为空，![递归而不是显式循环状态](graphics/B03652_02_12.jpg)，我们会评估类似于：![递归而不是显式循环状态](graphics/B03652_02_14.jpg)。范围不包含任何值，因此返回值是一个微不足道的`True`。
- en: If the range is not empty, we ask something like ![Recursion instead of a explicit
    loop state](graphics/B03652_02_16.jpg). This decomposes into ![Recursion instead
    of a explicit loop state](graphics/B03652_02_18.jpg). For this example, we can
    see that the first clause is `True`, and we'll evaluate the second clause recursively.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果范围不为空，我们会询问类似于![递归而不是显式循环状态](graphics/B03652_02_16.jpg)。这可以分解为![递归而不是显式循环状态](graphics/B03652_02_18.jpg)。对于这个例子，我们可以看到第一个子句是`True`，我们将递归地评估第二个子句。
- en: 'As an exercise for the reader: this recursion can be redefined to count down
    instead of up, using `[a,b-1)` in the second case.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者的练习：可以重新定义这个递归，使其递减而不是递增，在第二种情况下使用`[a,b-1)`。
- en: As a side note, some folks like to think of the empty interval as *a* ≥ *b*,
    not *a*=*b*. This is needless, since *a* is incremented by 1 and we can easily
    guarantee that *a*≤*b*, initially. There's no way for *a* to somehow leap past
    *b* by some error in the function; we don't need to over-specify the rules for
    an empty interval.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，有些人喜欢将空区间视为*a*≥*b*，而不是*a*=*b*。这是不必要的，因为*a*每次增加1，我们可以很容易地保证*a*≤*b*，最初。没有办法让*a*通过函数中的某个错误跳过*b*；我们不需要过度指定空区间的规则。
- en: 'Here is a Python code snippet that implements this definition of prime:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实现这个质数定义的Python代码片段：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows a recursive definition of an `isprime()` function. The half-open
    interval ![Recursion instead of a explicit loop state](graphics/B03652_02_07.jpg)
    is reduced to just the low-end argument, *a*, which is renamed `coprime` in this
    function to clarify its purpose. The base case is implemented as `n < coprime*coprime`;
    the range of values from `coprime` to `1+math.sqrt(n)` would be empty.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个`isprime()`函数的递归定义。半开区间![递归而不是显式循环状态](graphics/B03652_02_07.jpg)被缩减为只有低端参数*a*，在这个函数中被重命名为`coprime`以澄清其目的。基本情况被实现为`n
    < coprime*coprime`；从`coprime`到`1+math.sqrt(n)`的值范围将为空。
- en: The non-strict `and` operation is implemented by splitting it out into a separate
    `if` statement, `if n % coprime == 0`. The `return` statement is the recursive
    call with a different `coprime` test value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非严格的`and`操作是通过将其拆分成一个单独的`if`语句来实现的，`if n % coprime == 0`。`return`语句是具有不同`coprime`测试值的递归调用。
- en: Because the recursion is the tail end of the function, this is an example of
    **Tail recursion**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为递归是函数的尾部，这是**尾递归**的一个例子。
- en: This function is embedded in a function that establishes the boundary condition
    that *n* is an odd number greater than 2\. There's no point in testing any even
    number for being prime, since 2 is the only even prime.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数嵌入在一个函数中，该函数建立了*n*是一个大于2的奇数的边界条件。没有必要测试任何偶数是否为质数，因为2是唯一的偶数质数。
- en: What's important in this example is that the two cases of this recursive function
    are quite simple to design. Making the range of values an explicit argument to
    the internal `isprime()` function allows us to call the function recursively with
    argument values that reflect a steadily shrinking interval.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中重要的是，这个递归函数的两种情况设计起来非常简单。将值范围作为内部`isprime()`函数的显式参数允许我们以反映不断缩小的区间的参数值递归调用函数。
- en: 'While this is often extremely succinct and very expressive, we have to be a
    little cautious about using recursion in Python. There are two problems that arise.
    They are stated as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这通常非常简洁和富有表现力，但我们在使用Python中的递归时必须要小心。出现了两个问题。它们如下所述：
- en: Python imposes a recursion limit to detect recursive functions with improperly
    defined base cases
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python对递归函数施加了递归限制，以检测具有不正确定义基本情况的递归函数。
- en: Python does have a compiler to do Tail-Call Optimization (TCO)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python确实有一个编译器来进行尾调用优化（TCO）。
- en: The default recursion limit is 1,000, which is adequate for many algorithms.
    It's possible to change this with the `sys.setrecursionlimit()` function. It's
    not wise to raise this arbitrarily since it might lead to exceeding the OS memory
    limitations and crashing the Python interpreter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的递归限制是1,000，对于许多算法来说是足够的。可以使用`sys.setrecursionlimit()`函数来更改这个限制。提高这个限制并不明智，因为这可能会导致超出操作系统的内存限制，并导致Python解释器崩溃。
- en: If we try a recursive `isprimer()` function on a number over 1,000,000, we'll
    run foul of the recursion limit. If we used a somehow smarter `isprimer()` function
    that only checked prime factors instead of all factors, we'd be stopped at the
    1,000th prime number, 7,919, limiting our prime testing to numbers below 62,710,561.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在一个超过1,000,000的数字上使用递归的`isprimer()`函数，我们将违反递归限制。如果我们使用了一个更聪明的`isprimer()`函数，它只检查质因数而不是所有因数，我们将在第1,000个质数7,919处停止，将我们的质数测试限制在62,710,561以下的数字。
- en: Some functional programming languages can optimize simple recursive functions
    such as our `isprimer()` function. An optimizing compiler can transform the recursive
    evaluation of the `isprimer(n, coprime+1)` method into a low-overhead `loop`.
    The optimization tends to make a hash of call stacks; debugging optimized programs
    becomes difficult. Python doesn't perform this optimization. Performance and memory
    are sacrificed for clarity and simplicity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言可以优化简单的递归函数，比如我们的`isprimer()`函数。优化编译器可以将`isprimer(n, coprime+1)`方法的递归评估转换为低开销的`循环`。优化往往会使调用堆栈混乱；调试优化程序变得困难。Python不执行这种优化。性能和内存被牺牲以换取清晰和简单。
- en: In Python, when we use a generator expression instead of a recursive function,
    we essentially do the tail-call optimization manually. We don't rely on a compiler
    for some functional language to do this optimization.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们使用生成器表达式而不是递归函数时，我们实质上是手动进行尾调用优化。我们不依赖于某些函数式语言的编译器来进行这种优化。
- en: 'Here is TCO done as a generator expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是作为生成器表达式完成的TCO：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function includes many of the functional programming principles, but it
    uses a generator expression instead of a pure recursion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包含了许多函数式编程原则，但它使用了生成器表达式而不是纯递归。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We'll often optimize a purely recursive function to use an explicit `for` `loop`
    in a generator expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会优化一个纯递归函数，使用显式的`for` `loop`来进行生成器表达式。
- en: This algorithm is slow for large primes. For composite numbers, the function
    often returns a value quickly. If used on a value such as ![Recursion instead
    of a explicit loop state](graphics/B03652_02_21.jpg), it will take a few minutes
    to show that this is prime. Clearly, the slowness comes from checking 1,518,500,249
    individual candidate factors.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法对于大质数来说很慢。对于合数，该函数通常会快速返回一个值。如果用于像![递归而不是显式循环状态](graphics/B03652_02_21.jpg)这样的值，它将花费几分钟来证明这是质数。显然，慢的原因在于检查1,518,500,249个候选因子。
- en: Functional type systems
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型系统
- en: Some functional programming languages such as **Haskell** and **Scala** are
    statically compiled, and depend on declared types for functions and their arguments.
    In order to provide the kind of flexibility Python already has, these languages
    have sophisticated type matching rules so that a generic function can be written,
    which works for a variety of related types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言，如**Haskell**和**Scala**，是静态编译的，并依赖于声明的函数和它们的参数的类型。为了提供Python已经具有的灵活性，这些语言具有复杂的类型匹配规则，以便编写一个通用函数，可以适用于各种相关类型。
- en: In Object-Oriented Python, we often use the class inheritance hierarchy instead
    of sophisticated function type matching. We rely on Python to dispatch an operator
    to a proper method based on simple name matching rules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的Python中，我们经常使用类继承层次结构，而不是复杂的函数类型匹配。我们依赖Python根据简单的名称匹配规则将运算符分派给适当的方法。
- en: Since Python already has the desired levels of flexibility, the type matching
    rules for a compiled functional language aren't relevant. Indeed, we could argue
    that the sophisticated type matching is a workaround imposed by static compilation.
    Python doesn't need this workaround because it's a dynamic language.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python已经具有所需的灵活性，编译函数语言的类型匹配规则并不相关。事实上，我们可以说，复杂的类型匹配是静态编译强加的一种变通方法。Python不需要这种变通方法，因为它是一种动态语言。
- en: In some cases, we might have to resort to using `isinstance(a, tuple)` to detect
    if an argument value is `tuple` or an individual value. This will be as rare in
    functional programs as it is in Object-Oriented Programs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能不得不诉诸于使用`isinstance(a, tuple)`来检测参数值是`tuple`还是单个值。这在函数式程序中和面向对象程序中一样罕见。
- en: Familiar territory
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉的领域
- en: One of the ideas that emerge from the previous list of topics is that most functional
    programming is already present in Python. Indeed, most functional programming
    is already a very typical and common part of Object-Oriented Programming.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的主题列表中出现的一个想法是，大多数函数式编程已经存在于Python中。事实上，大多数函数式编程已经是面向对象编程的一个非常典型和常见的部分。
- en: 'As a very specific example, a fluent **Application Program Interface** (**API**)
    is a very clear example of functional programming. If we take time to create a
    class with `return self()` in each method function, we can use it as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常具体的例子，一个流利的**应用程序接口**（**API**）是函数式编程的一个非常明显的例子。如果我们花时间创建一个类，在每个方法函数中都有`return
    self()`，我们可以这样使用它：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can just as easily write several closely-related functions that work as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地编写几个密切相关的函数，其工作如下：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've switched the syntax from traditional object-oriented suffix notation to
    a more functional prefix notation. Python uses both notations freely, often using
    a prefix version of a special method name. For example, the `len()` function is
    generally implemented by the class.`__len__()` special method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将语法从传统的面向对象的后缀表示法切换到了更具功能性的前缀表示法。Python自由地使用这两种表示法，通常使用特殊方法名的前缀版本。例如，`len()`函数通常由类的`__len__()`特殊方法实现。
- en: Of course, the implementation of the class shown above might involve a highly
    stateful object. Even then, a small change in viewpoint might reveal a functional
    approach that can lead to more succinct or more expressive programming.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上面显示的类的实现可能涉及高度状态化的对象。即使如此，观点上的微小变化可能会揭示出一个功能性的方法，可以导致更简洁或更表达的编程。
- en: The point is not that imperative programming is broken in some way, or that
    functional programming offers such a vastly superior technology. The point is
    that functional programming leads to a change in viewpoint that can—in many cases—be
    very helpful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重点不是命令式编程在某种程度上有问题，或者函数式编程提供了如此大幅度的优越技术。重点是函数式编程导致了一种观点的改变，这在许多情况下可能非常有帮助。
- en: Saving some advanced concepts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存一些高级概念
- en: We will set some more advanced concepts aside for consideration in later chapters.
    These concepts are part of the implementation of a purely functional language.
    Since Python isn't purely functional, our hybrid approach won't require deep consideration
    of these topics.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一些更高级的概念放在一边，以便在以后的章节中考虑。这些概念是纯函数语言的实现的一部分。由于Python不是纯函数的，我们的混合方法不需要深入考虑这些主题。
- en: We will identify these up-front for the benefit of folks who already know a
    functional language such as Haskell and are learning Python. The underlying concerns
    are present in all programming languages but we'll tackle them differently in
    Python. In many cases, we can and will drop into imperative programming rather
    than use a strictly functional approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提前识别这些内容，以使那些已经了解Haskell等函数语言并学习Python的人受益。这些基本问题存在于所有编程语言中，但我们将在Python中以不同的方式处理它们。在许多情况下，我们可以并且将会转入命令式编程，而不是使用严格的函数式方法。
- en: 'The topics are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 主题如下：
- en: '**Referential** **transparency**: When looking at lazy evaluation and the various
    kinds of optimization that are possible in a compiled language, the idea of multiple
    routes to the same object is important. In Python, this isn''t as important because
    there aren''t any relevant compile-time optimizations.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用透明度**：当看到惰性评估和编译语言中可能的各种优化时，多条路径指向同一对象的想法是重要的。在Python中，这并不重要，因为没有相关的编译时优化。'
- en: '**Currying**: The type systems will employ currying to reduce multiple-argument
    functions to single-argument functions. We''ll look at currying in some depth
    in [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柯里化**：类型系统将使用柯里化将多参数函数减少为单参数函数。我们将在[第11章](ch11.html "第11章。装饰器设计技术")*装饰器设计技术*中深入研究柯里化。'
- en: '**Monads**: These are purely functional constructs that allow us to structure
    a sequential pipeline of processing in a flexible way. In some cases, we''ll resort
    to imperative Python to achieve the same end. We''ll also leverage the elegant
    `PyMonad` library for this. We''ll defer this to [Chapter 14](ch14.html "Chapter 14. The
    PyMonad Library"), *The PyMonad Library*.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单子**：这些是纯函数构造，允许我们以灵活的方式结构化顺序处理管道。在某些情况下，我们将求助于命令式Python来实现相同的目标。我们还将利用优雅的`PyMonad`库。我们将把这个推迟到[第14章](ch14.html
    "第14章。PyMonad库")*PyMonad库*。'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've identified a number of features that characterize the
    functional programming paradigm. We started with first-class and higher-order
    functions. The idea is that a function can be an argument to a function or the
    result of a function. When functions become the object of additional programming,
    we can write some extremely flexible and generic algorithms.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确定了一些特征，这些特征表征了函数式编程范式。我们从头等和高阶函数开始。这个想法是一个函数可以是另一个函数的参数或函数的结果。当函数成为额外编程的对象时，我们可以编写一些非常灵活和通用的算法。
- en: The idea of immutable data is sometimes odd in an imperative and object-oriented
    programming language such as Python. When we start to focus on functional programming,
    however, we see a number of ways that state changes can be confusing or unhelpful.
    Using immutable objects can be a helpful simplification.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式和面向对象的编程语言（如Python）中，不可变数据的概念有时会显得奇怪。然而，当我们开始专注于函数式编程时，我们会看到状态变化可能会令人困惑或无益的方式。使用不可变对象可以是一个有益的简化。
- en: 'Python focuses on strict evaluation: all sub-expressions are evaluated from
    left-to-right through the statement. Python, however, does perform some non-strict
    evaluation. The `or`, `and`, and `if-else` logical operators are non-strict: all
    subexpressions are not necessarily evaluated. Similarly, a generator function
    is also non-strict. We can also call this eager vs. lazy. Python is generally
    eager but we can leverage generator functions to create lazy evaluation.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python专注于严格评估：所有子表达式都通过语句从左到右进行评估。然而，Python确实执行一些非严格评估。`or`、`and`和`if-else`逻辑运算符是非严格的：并非一定要评估所有子表达式。同样，生成器函数也是非严格的。我们也可以称之为急切与懒惰。Python通常是急切的，但我们可以利用生成器函数来实现惰性评估。
- en: While functional programming relies on recursion instead of explicit `loop`
    state, Python imposes some limitations here. Because of the stack limitation and
    the lack of an optimizing compiler, we're forced to manually optimize recursive
    functions. We'll return to this topic in [Chapter 6](ch06.html "Chapter 6. Recursions
    and Reductions"), *Recursions and Reductions*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数式编程依赖于递归而不是显式的`循环`状态，但Python在这方面施加了一些限制。由于堆栈限制和缺乏优化编译器，我们被迫手动优化递归函数。我们将在[第6章](ch06.html
    "第6章。递归和归约")*递归和归约*中回到这个话题。
- en: Although many functional languages have sophisticated type systems, we'll rely
    on Python's dynamic type resolution. In some cases, it means we'll have to write
    manual coercion among types. It might also mean that we'll have to create class
    definitions to handle very complex situations. For the most part, however, Python's
    built-in rules will work very elegantly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多函数式语言拥有复杂的类型系统，但我们将依赖于Python的动态类型解析。在某些情况下，这意味着我们将不得不在类型之间进行手动转换。这也可能意味着我们将不得不创建类定义来处理非常复杂的情况。然而，在大多数情况下，Python的内置规则将非常优雅地工作。
- en: In the next chapter, we'll look at the core concepts of pure functions and how
    these fit with Python's built-in data structures. Given this foundation, we can
    look at higher-order functions available in Python and how we can define our own
    higher-order functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨纯函数的核心概念以及这些概念如何与Python的内置数据结构配合。有了这个基础，我们可以看看Python中可用的高阶函数以及如何定义我们自己的高阶函数。
