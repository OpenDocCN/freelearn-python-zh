- en: Chapter 3. Functions, Iterators, and Generators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。函数、迭代器和生成器
- en: The core of functional programming is the use of pure functions to map values
    from the input domain to the output range. A pure function has no side effects,
    a relatively easy threshold for us to achieve in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的核心是使用纯函数将值从输入域映射到输出范围。纯函数没有副作用，在Python中相对容易实现。
- en: Avoiding side effects also means reducing our dependence on variable assignment
    to maintain the state of our computations. We can't purge the assignment statement
    from the Python language, but we can reduce our dependence on stateful objects.
    This means we need to choose among the available Python built-in data structures
    to select those that don't require stateful operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 避免副作用也意味着减少我们对变量赋值来维护计算状态的依赖。我们无法从Python语言中清除赋值语句，但我们可以减少对有状态对象的依赖。这意味着我们需要在可用的Python内置数据结构中进行选择，选择那些不需要有状态操作的数据结构。
- en: 'This chapter will present several Python features from a functional viewpoint,
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从功能的角度介绍几个Python特性，如下所示：
- en: Pure Functions, free of side effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无副作用的纯函数
- en: Functions as objects that can be passed as arguments or returned as results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为可以作为参数传递或作为结果返回的对象
- en: The use of Python strings using object-oriented suffix notation and prefix notation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象的后缀表示法和前缀表示法来使用Python字符串
- en: Using tuples and namedtuples as a way to create stateless objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组和命名元组来创建无状态对象的方法
- en: Using iterable collections as our primary design tool for functional programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可迭代集合作为我们的主要功能编程设计工具
- en: 'We''ll look at generators and generator expressions, since these are ways to
    work with collections of objects. As we noted in [Chapter 2](ch02.html "Chapter 2. Introducing
    Some Functional Features"), *Introducing Some Functional Features*, there are
    some boundary issues while trying to replace all generator expressions with recursions.
    Python imposes a recursion limit, and doesn''t automatically handle TCO: we must
    optimize recursions manually using a generator expression.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究生成器和生成器表达式，因为这些是处理对象集合的方法。正如我们在[第2章](ch02.html "第2章。介绍一些功能特性")中所指出的，*介绍一些功能特性*，在尝试用递归替换所有生成器表达式时会出现一些边界问题。Python会强加递归限制，并且不会自动处理TCO：我们必须使用生成器表达式手动优化递归。
- en: 'We''ll write generator expressions that will perform the following tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写生成器表达式来执行以下任务：
- en: Conversions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Restructuring
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: Complex calculations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂计算
- en: We'll make a quick survey of many of the built-in Python collections, and how
    we can work with collections while pursuing a functional paradigm. This might
    change our approach to working with `lists`, `dicts`, and `sets`. Writing functional
    Python encourages us to focus on tuples and immutable collections. In the next
    chapter, we'll emphasize more functional ways to work with specific kinds of collections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速调查许多内置的Python集合，以及在追求功能范式时如何使用集合。这可能会改变我们处理`lists`、`dicts`和`sets`的方式。编写功能性的Python鼓励我们专注于元组和不可变集合。在下一章中，我们将强调更多与特定类型的集合一起工作的功能性方法。
- en: Writing pure functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写纯函数
- en: 'A pure function has no side effects: there are no global changes to variables.
    If we avoid the `global` statement, we will almost meet this threshold. We also
    need to avoid changing the state mutable objects. We''ll look at a number of ways
    of ensuring these two aspects of pure functions. A reference to a value in the
    Python global using a free variable is something we can rework into a proper parameter.
    In most cases, it''s quite easy.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数没有副作用：变量没有全局变化。如果我们避免使用`global`语句，我们几乎可以达到这个标准。我们还需要避免改变状态可变对象。我们将研究确保纯函数的这两个方面的几种方法。在Python全局中引用一个值，使用自由变量是我们可以重写为适当参数的。在大多数情况下，这是相当容易的。
- en: 'Here is an example where the usage of the global statement is explained:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，解释了使用全局语句的用法：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can refactor this function to make the `global_adjustment` variable into
    a proper parameter. We would need to change each reference to this function, which
    might have a large ripple effect through a complex application. A global reference
    will be visible as a free variable in the body of a function. There will be neither
    a parameter nor an assignment for this variable, making it reasonably clear that
    it's global.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构这个函数，将`global_adjustment`变量变成一个适当的参数。我们需要改变对这个函数的每个引用，这可能会在一个复杂的应用程序中产生很大的连锁反应。全局引用将在函数体中作为自由变量可见。对于这个变量，既没有参数也没有赋值，因此可以清楚地看出它是全局的。
- en: There are many internal Python objects, which are stateful. Instances of the
    `file` class, and all file-like objects, are examples of stateful objects in common
    use. We observe that the most commonly used stateful objects in Python generally
    behave as context managers. Not all developers make use of the available context
    managers but many objects implement the required interface. In a few cases, stateful
    objects don't completely implement the context manager interface; in these cases,
    there's often a `close()` method. We can use the `contextlib.closing()` function
    to provide these objects with the proper context manager interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多内部对象，这些对象是有状态的。`file`类的实例和所有类似文件的对象都是常用的有状态对象的例子。我们观察到Python中最常用的有状态对象通常表现为上下文管理器。并非所有开发人员都使用可用的上下文管理器，但许多对象实现了所需的接口。在一些情况下，有状态对象并没有完全实现上下文管理器接口；在这些情况下，通常会有一个`close()`方法。我们可以使用`contextlib.closing()`函数为这些对象提供适当的上下文管理器接口。
- en: We can't easily eliminate all stateful Python objects, except from small programs.
    Therefore, we must manage state while still exploiting the strengths of functional
    design. Toward this end, we should always use the `with` statement to encapsulate
    stateful file objects into a well-defined scope.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法轻易消除所有有状态的Python对象，除非是小型程序。因此，我们必须在利用函数式设计的优势的同时管理状态。为此，我们应该始终使用`with`语句将有状态的文件对象封装到一个明确定义的范围内。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always use file objects in a `with` context.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 始终在`with`上下文中使用文件对象。
- en: 'We should always avoid global file objects, global database connections, and
    the associated state issues. The global file object is a very common pattern for
    handling open files. We might have a function as shown in the following command
    snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终避免全局文件对象、全局数据库连接和相关的状态问题。全局文件对象是处理打开文件的非常常见的模式。我们可能有一个如下命令片段所示的函数：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Given this context, numerous other functions can use the `ifile` and `ofile`
    variables, hoping they properly refer to the `global` files, which are left open
    for the application to use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，许多其他函数可以使用`ifile`和`ofile`变量，希望它们正确地引用应用程序要使用的`global`文件，这些文件保持打开状态。
- en: This is not a very good design, and we need to avoid it. The files should be
    proper parameters to functions, and the open files should be nested in a `with`
    statement to assure that their stateful behavior is handled properly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很好的设计，我们需要避免它。文件应该是函数的适当参数，并且打开的文件应该嵌套在`with`语句中，以确保它们的有状态行为得到适当处理。
- en: This design pattern also applies to databases. A database connection object
    can generally be provided as a formal argument to the application's functions.
    This is contrary to the way some popular web frameworks work that rely on a global
    database connection in an effort to make the database a transparent feature of
    the application. Additionally, a multithreaded web server might not benefit from
    sharing a single database connection. This suggests that there are some benefits
    of a hybrid approach that uses functional design with a few isolated stateful
    features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式也适用于数据库。数据库连接对象通常可以作为应用程序函数的形式参数提供。这与一些流行的Web框架的工作方式相反，这些框架依赖于全局数据库连接，以使数据库成为应用程序的一个透明特性。此外，多线程Web服务器可能无法从共享单个数据库连接中受益。这表明使用功能设计和一些孤立的有状态特性的混合方法有一些好处。
- en: Functions as first-class objects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: It shouldn't come as a surprise that Python functions are first-class objects.
    In Python, functions are objects with a number of attributes. The reference manual
    lists a number of special member names that apply to functions. Since functions
    are objects with attributes, we can extract the `docstring` function or the name
    of a function, using special attributes such as `__doc__` or `__name__`. We can
    also extract the body of the function via the `__code__` attribute. In compiled
    languages, this introspection is relatively complex because of the source information
    that needs to be retained. In Python, it's quite simple.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数是一等对象并不足为奇。在Python中，函数是带有许多属性的对象。参考手册列出了适用于函数的许多特殊成员名称。由于函数是带有属性的对象，我们可以使用特殊属性，如`__doc__`或`__name__`提取`docstring`函数或函数的名称。我们还可以通过`__code__`属性提取函数的主体。在编译语言中，由于需要保留源信息，这种内省相对复杂。在Python中，这很简单。
- en: We can assign functions to variables, pass functions as arguments, and return
    functions as values. We can easily use these techniques to write higher-order
    functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将函数分配给变量，将函数作为参数传递，并将函数作为值返回。我们可以轻松使用这些技术来编写高阶函数。
- en: Since functions are objects, Python already has many features required to be
    a functional programming language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是对象，Python已经具备了许多成为函数式编程语言所需的特性。
- en: Additionally, a callable object also helps us to create functions, which are
    first-class objects. We can even consider the callable class definition as a higher-order
    function. We do need to be judicious in how we use the `__init__()` method of
    a callable object; we should avoid setting stateful class variables. One common
    application is to use an `__init__()` method to create objects that fit the **Strategy
    design pattern**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可调用对象还帮助我们创建函数，这些函数是一等对象。我们甚至可以将可调用类定义视为高阶函数。我们需要谨慎地使用可调用对象的`__init__()`方法；我们应该避免设置有状态的类变量。一个常见的应用是使用`__init__()`方法创建符合**策略设计模式**的对象。
- en: A class following the Strategy design pattern depends on another object to provide
    an algorithm or parts of an algorithm. This allows us to inject algorithmic details
    at runtime, rather than compiling the details into the class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循策略设计模式的类依赖于另一个对象来提供算法或算法的部分。这允许我们在运行时注入算法细节，而不是将细节编译到类中。
- en: 'Here is an example of a callable object with an embedded Strategy object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有嵌入式策略对象的可调用对象的示例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class uses `__init__()` to save a reference to another function. We're
    not creating any stateful instance variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用`__init__()`保存对另一个函数的引用。我们没有创建任何有状态的实例变量。
- en: 'The function given as a Strategy object must raise 2 to the given power. The
    three candidate objects that we can plug into this class are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为策略对象给出的函数必须将2提升到给定的幂。我们可以将三个候选对象插入到这个类中，如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `shifty()` function raises 2 to the desired power using a left shift of
    the bits. The `multy()` function uses a naive recursive multiplication. The `faster()`
    function uses a divide and conquer strategy that will perform ![Functions as first-class
    objects](graphics/B03652_03_01.jpg) multiplications instead of *b* multiplications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`shifty()`函数使用位左移将2提升到所需的幂。`multy()`函数使用一个天真的递归乘法。`faster()`函数使用分治策略，将执行![函数作为一等对象](graphics/B03652_03_01.jpg)次乘法，而不是*b*次乘法。'
- en: 'We can create instances of our `Mersenne1` class with an embedded strategy
    algorithm, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用嵌入的策略算法创建`Mersenne1`类的实例，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows how we can define alternative functions that produce the same result
    but use different algorithms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们如何定义产生相同结果但使用不同算法的替代函数。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Python allows us to compute ![Functions as first-class objects](graphics/B03652_03_02.jpg),
    since this doesn't even come close to the recursion limits in Python. This is
    quite a large prime number, with 27 digits.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们计算![函数作为一等对象](graphics/B03652_03_02.jpg)，因为这甚至没有接近Python的递归限制。这是一个非常大的质数，有27位数。
- en: Using strings
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串
- en: Since Python strings are immutable, they're an excellent example of functional
    programming objects. A Python `string` module has a number of methods, all of
    which produce a new string as the result. These methods are pure functions with
    no side effects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python字符串是不可变的，它们是函数式编程对象的绝佳示例。Python的“string”模块有许多方法，所有这些方法都会产生一个新的字符串作为结果。这些方法是没有副作用的纯函数。
- en: The syntax for `string` method functions is postfix, where most functions are
    prefix. This means that complex string operations can be hard to read when they're
    commingled with conventional functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “string”方法函数的语法是后缀的，其中大多数函数是前缀的。这意味着当它们与常规函数混合在一起时，复杂的字符串操作可能很难阅读。
- en: When scraping data from a web page, we might have a cleaner function that applies
    a number of transformations to a string to clean up the punctuation and return
    a `Decimal` object for use by the rest of the application. This will involve a
    mixture of prefix and postfix syntax.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在从网页中抓取数据时，我们可能会有一个更干净的函数，它对字符串应用多种转换以清除标点，并返回一个供应用程序其余部分使用的“Decimal”对象。这将涉及前缀和后缀语法的混合使用。
- en: 'It might look like the following command snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像以下命令片段：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function does two replacements on the string to remove `$` and `,` string
    values. The resulting string is used as an argument to the `Decimal` class constructor,
    which returns the desired object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数对字符串进行两次替换，以删除“$”和“,”字符串值。生成的字符串被用作“Decimal”类构造函数的参数，该构造函数返回所需的对象。
- en: 'To make this more consistent, we can consider defining our own prefix functions
    for the `string` method functions, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更一致，我们可以考虑为“string”方法函数定义自己的前缀函数，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This can allow us to use `Decimal(replace(replace(text, "$", ""), ",", ""))`
    with consistent-looking prefix syntax. In this case, we simply rearrange the existing
    argument values, allowing us an additional technique. We can do this for trivial
    cases, such as the follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以使用具有一致外观的前缀语法`Decimal(replace(replace(text, "$", ""), ",", ""))`。在这种情况下，我们只是重新排列现有的参数值，允许我们使用额外的技术。我们可以对简单情况进行这样做，例如以下情况：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '12.45'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '12.45'
- en: It's not clear if this kind of consistency is a significant improvement over
    the mixed prefix and postfix notation. The issue with functions of multiple arguments
    is that the arguments wind up in various places in the expression.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚不清楚这种一致性是否比混合前缀和后缀符号的表示方式有重大改进。多参数函数的问题在于参数最终出现在表达式的各个位置。
- en: 'A slightly better approach might be to define a more meaningful prefix function
    to strip punctuation, such as the following command snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更好的方法可能是定义一个更有意义的前缀函数来去除标点，如下面的命令片段所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function will recursively remove each of the characters from the `char`
    variable. We can use it as `Decimal(remove(text, "$,"))` to make the intent of
    our string cleanup more clear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将递归地从“char”变量中删除每个字符。我们可以将其用作`Decimal(remove(text, "$,"))`，以使我们的字符串清理意图更清晰。
- en: Using tuples and namedtuples
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组和命名元组
- en: Since Python tuples are immutable objects, they're another excellent example
    of objects suitable for functional programming. A Python `tuple` has very few
    method functions, so almost everything is done through functions using prefix
    syntax. There are a number of use cases for tuples, particularly when working
    with list-of-tuple, tuple-of-tuple and generator-of-tuple constructs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python元组是不可变对象，它们是适合函数式编程的另一个绝佳示例。Python的“元组”几乎没有方法函数，因此几乎所有操作都是通过使用前缀语法的函数完成的。元组有许多用例，特别是在处理列表-元组、元组-元组和生成器-元组构造时。
- en: 'Of course, namedtuples add an essential feature to a tuple: a name that we
    can use instead of an index. We can exploit namedtuples to create objects that
    are accretions of data. This allows us to write pure functions based on stateless
    objects, yet keep data bound into tidy object-like packages.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，命名元组为元组添加了一个基本功能：我们可以使用名称而不是索引。我们可以利用命名元组来创建数据的堆积对象。这使我们能够编写基于无状态对象的纯函数，但仍然将数据绑定到整洁的对象包中。
- en: We'll almost always use tuples (and namedtuples) in the context of a collection
    of values. If we're working with single values, or a tidy group of exactly two
    values, we'll usually use named parameters to a function. When working with collections,
    however, we might need to have iterable-of-tuples or iterable-of-namedtuple constructs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是在值集合的上下文中使用元组（和命名元组）。如果我们处理单个值或精确两个值的整洁组，我们通常会将命名参数用作函数的参数。然而，在处理集合时，我们可能需要具有元组的可迭代对象或具有命名元组的可迭代对象。
- en: The decision to use a `tuple` or `namedtuple` object is entirely a matter of
    convenience. We might be working with a sequence of values as a three tuple of
    the form (number, number, number) assuming that the triple is in red, green, and
    blue order.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“元组”或“命名元组”对象的决定完全是出于方便考虑。我们可能会将一系列值作为三元组（数字，数字，数字）的形式（假设三元组按照红色、绿色和蓝色的顺序排列）。
- en: 'We can use functions to pick a three-tuple apart, as shown in the following
    command snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用函数来拆分三元组，如下面的命令片段所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, we might introduce the following command line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以引入以下命令行：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This allows us to use `item.red` instead of `red(item)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以使用`item.red`而不是`red(item)`。
- en: The functional programming application of tuples centers on the iterable-of-tuple
    design pattern. We'll look closely at a few iterable-of-tuple techniques. We'll
    look at the namedtuple techniques in [Chapter 7](ch07.html "Chapter 7. Additional
    Tuple Techniques"), *Additional Tuple Techniques*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的函数式编程应用集中在可迭代元组设计模式上。我们将仔细研究一些可迭代元组技术。我们将在[第7章](ch07.html "第7章。其他元组技术")中查看命名元组技术，*其他元组技术*。
- en: Using generator expressions
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成器表达式
- en: We've shown some examples of generator expressions already. We'll show many
    more later in the chapter. We'll introduce some more sophisticated generator techniques
    in this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了一些生成器表达式的示例。我们将在本章的后面展示更多示例。在本节中，我们将介绍一些更复杂的生成器技术。
- en: We need to mention a small bit of Python syntax here. It's common to see generator
    expressions used to create the `list` or `dict` literals via a `list` comprehension
    or a `dict` comprehension. For our purposes, a list display (or comprehension)
    is just one use of generator expressions. We can try to make a distinction between
    generator expressions outside a display and generator expressions inside a display,
    but there's nothing to be gained by this. The syntax is the same except for the
    enclosing punctuation and the semantics are indistinguishable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里提到一小部分Python语法。通常会看到生成器表达式被用来通过`list`推导或`dict`推导创建`list`或`dict`字面量。对于我们的目的，列表显示（或推导）只是生成器表达式的一种用法。我们可以尝试区分显示之外的生成器表达式和显示之内的生成器表达式，但这样做没有任何好处。语法是一样的，除了封闭的标点符号，语义是无法区分的。
- en: 'A display includes the enclosing literal syntax: `[x**2 for x in range(10)]`;
    this example is a list comprehension, which creates a list object from the enclosed
    generator expression. In this section, we''re going to focus on the generator
    expression. We''ll occasionally create a display as part of demonstrating how
    the generator works. Displays have the disadvantage of creating (potentially large)
    `collection` objects. A generator expression is lazy and creates objects only
    as required.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 显示包括封闭的文字语法：`[x**2 for x in range(10)]`；这个例子是一个列表推导，它从封闭的生成器表达式创建一个列表对象。在本节中，我们将专注于生成器表达式。我们偶尔会创建一个显示，以演示生成器的工作原理。显示的缺点是创建（可能很大的）`collection`对象。生成器表达式是惰性的，只在需要时才创建对象。
- en: 'We have to provide two important caveats on generator expressions, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供关于生成器表达式的两个重要警告，如下：
- en: Generators appear to be sequence-like except for a function such as the `len()`
    function that needs to know the size of the collection.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器看起来像是序列，除了像`len()`函数这样需要知道集合大小的函数。
- en: Generators can be used only once. After that, they appear empty.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器只能使用一次。之后，它们会变为空。
- en: 'Here is a generator function that we''ll use for some examples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们将用于一些示例的生成器函数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We're locating the prime factors of a number. If the number, *x*, is even, we'll
    yield 2 and then recursively yield all factors of *x*÷2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找一个数字的质因数。如果数字*x*是偶数，我们将产出2，然后递归地产出*x*÷2的所有因子。
- en: For odd numbers, we'll step through odd values greater than or equal to 3, to
    locate a candidate factor of the number. When we locate a factor, we'll yield
    that factor, *i*, and then recursively yield all factors of *x*÷*i*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于奇数，我们将遍历大于或等于3的奇数值，以找到数字的候选因子。当我们找到一个因子时，我们将产出该因子*i*，然后递归地产出*x*÷*i*的所有因子。
- en: In the event that we can't locate a factor, the number must be prime, so we
    can yield that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法找到一个因子，那么这个数字必须是质数，所以我们可以产出它。
- en: We handle 2 as a special case to cut the number of iterations in half. All prime
    numbers, except 2, are odd.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将2作为一个特殊情况来处理，以减少迭代次数。除了2以外，所有的质数都是奇数。
- en: We've used one important `for` loop in addition to recursion. This allows us
    to easily handle numbers that have as many as 1,000 factors. This number is at
    least as large as ![Using generator expressions](graphics/B03652_03_03.jpg), a
    number with 300 digits. Since the `for` variable, `i`, is not used outside the
    indented body of the loop, the stateful nature of the `i` variable won't lead
    to confusion if we make any changes to the body of the loop.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们除了使用递归之外，还使用了一个重要的`for`循环。这使我们能够轻松处理最多有1,000个因子的数字。这个数字至少和![使用生成器表达式](graphics/B03652_03_03.jpg)一样大，这是一个有300位数字的数字。由于`for`变量`i`在缩进的循环体之外没有被使用，`i`变量的有状态特性不会导致混淆，如果我们对循环体进行任何更改。
- en: In effect, we've done tail-call optimization, the recursive calls that count
    from 3 to ![Using generator expressions](graphics/B03652_03_04.jpg). The `for`
    loop saves us from deeply recursive calls that test every single number in the
    range.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经进行了尾递归优化，递归调用从3到![使用生成器表达式](graphics/B03652_03_04.jpg)。`for`循环使我们免受深度递归调用的影响，这些调用会测试范围内的每个数字。
- en: The other two `for` loops exist merely to consume the results of a recursive
    function that is iterable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个`for`循环只是为了消耗可迭代的递归函数的结果而存在。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In a recursive generator function, be careful of the return statement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归生成器函数中，要小心return语句。
- en: 'Do not use the following command line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用以下命令行：
- en: '`return recursive_iter(args)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`return recursive_iter(args)`'
- en: 'It returns only a generator object; it doesn''t evaluate the function to return
    the generated values. Use either of the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它只返回一个生成器对象；它不会评估函数以返回生成的值。使用以下任一种：
- en: '`for result in recursive_iter(args): yield result`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`for result in recursive_iter(args): yield result`'
- en: OR `yield from recursive_iter(args)`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`yield from recursive_iter(args)`
- en: 'As an alternative, the following command is a more purely recursive version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，以下命令是一个更纯粹的递归版本：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We defined an internal recursive function, `factor_n()`, to test factors, *n*,
    in the range ![Using generator expressions](graphics/B03652_03_05.jpg). If the
    candidate factor, *n*, is outside the range, then *x* is prime. Otherwise, we'll
    see if *n* is a factor of *x*. If so, we'll yield *n* and all factors of ![Using
    generator expressions](graphics/B03652_03_06.jpg). If *n* is not a factor, we'll
    evaluate the function recursively using *n*+2\. This recursion to test each value
    of ![Using generator expressions](graphics/B03652_03_07.jpg) can be optimized
    into a `for` loop, as shown in the previous example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个内部递归函数`factor_n()`，来测试范围内的因子*n*。如果候选因子*n*在范围之外，那么*x*就是质数。否则，我们将看看*n*是否是*x*的因子。如果是，我们将产出*n*和![使用生成器表达式](graphics/B03652_03_06.jpg)的所有因子。如果*n*不是因子，我们将递归地使用*n*+2进行函数求值。这种递归来测试![使用生成器表达式](graphics/B03652_03_07.jpg)的每个值可以被优化为一个`for`循环，就像前面的例子中所示的那样。
- en: The outer function handles some edge cases. As with other prime-related processing,
    we handle 2 as a special case. For even numbers, we'll yield 2 and then evaluate
    `pfactorsr()` recursively for *x*÷2\. All other prime factors must be odd numbers
    greater than or equal to 3\. We'll evaluate the `factors_n()` function starting
    with 3 to test these other candidate prime factors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数处理一些边缘情况。与其他与素数相关的处理一样，我们将2作为一个特殊情况处理。对于偶数，我们将产生2，然后递归地评估`pfactorsr()`以获得*x*÷2。所有其他素数因子必须是大于或等于3的奇数。我们将从3开始评估`factors_n()`函数以测试这些其他候选素数因子。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The purely recursive function can only locate prime factors of numbers up to
    about 4,000,000\. Above this, Python's recursion limit will be reached.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 纯递归函数只能找到最多约4,000,000的数字的素数因子。在这之上，Python的递归限制将被达到。
- en: Exploring the limitations of generators
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索生成器的限制
- en: 'We noted that there are some limitations of generator expressions and generator
    functions. The limitations can be observed by executing the following command
    snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到生成器表达式和生成器函数有一些限制。可以通过执行以下命令片段来观察这些限制：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first example, we saw that generator functions are not strict. They're
    lazy, and don't have a proper value until we consume the generator functions.
    This isn't a limitation, per se; this is the whole reason that generator expressions
    fit with functional programming in Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们看到生成器函数并不严格。它们是懒惰的，在我们消耗生成器函数之前没有正确的值。这并不是一个限制，这正是生成器表达式与Python中的函数式编程相匹配的整个原因。
- en: In the second example, we materialized a list object from the generator function.
    This is handy for seeing the output and writing unit test cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们从生成器函数中实现了一个列表对象。这对于查看输出和编写单元测试用例很方便。
- en: 'In the third example, we saw one limitation of generator functions: there''s
    no `len()`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，我们看到了生成器函数的一个限制：没有`len()`。
- en: 'The other limitation of generator functions is that they can only be used once.
    For example, look at the following command snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的另一个限制是它们只能使用一次。例如，看下面的命令片段：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first evaluation of the `sum()` method performed evaluation of the generator.
    The second evaluation of the `sum()` method found that the generator was now empty.
    We can only consume the values once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`方法的第一次评估执行了生成器的评估。`sum()`方法的第二次评估发现生成器现在为空了。我们只能消耗值一次。'
- en: Generators have a stateful life in Python. While they're very nice for some
    aspects of functional programming, they're not quite perfect.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在Python中有一个有状态的生命周期。虽然它们对于函数式编程的某些方面非常好，但并不完美。
- en: 'We can try to use the `itertools.tee()` method to overcome the once-only limitation.
    We''ll look at this in depth in [Chapter 8](ch08.html "Chapter 8. The Itertools
    Module"), *The Itertools Module*. Here is a quick example of its usage:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用`itertools.tee()`方法来克服一次性限制。我们将在[第8章](ch08.html "第8章。迭代工具模块")*迭代工具模块*中深入研究这个问题。这里是它的一个快速示例用法：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We created two clones of the parameter generator expression, `max_tee()` and
    `min_tee()`. This leaves the original iterator untouched, a pleasant feature that
    allows us to do very flexible combinations of functions. We can consume these
    two clones to get `maxima` and `minima` from the iterable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了参数生成器表达式的两个克隆，`max_tee()`和`min_tee()`。这使原始迭代器保持不变，这是一个令人愉快的特性，允许我们对函数进行非常灵活的组合。我们可以消耗这两个克隆来从可迭代对象中获得`maxima`和`minima`。
- en: While appealing, we'll see that this doesn't work out well in the long run.
    Once consumed, an iterable will not provide any more values. When we want to compute
    multiple kinds of reductions—for example, `sums`, `counts`, `minimums`, `maximums`—we
    need to design with this one-pass-only limitation in mind.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然吸引人，但我们会发现这在长期内并不奏效。一旦被消耗，可迭代对象将不再提供任何值。当我们想要计算多种类型的缩减，例如`sums`、`counts`、`minimums`、`maximums`时，我们需要考虑这种一次性限制。
- en: Combining generator expressions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合生成器表达式
- en: The essence of functional programming comes from the ways we can easily combine
    generator expressions and generator functions to create very sophisticated composite
    processing sequences. When working with generator expressions, we can combine
    generators in several ways.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的本质来自于我们如何轻松地组合生成器表达式和生成器函数来创建非常复杂的复合处理序列。在使用生成器表达式时，我们可以以几种方式组合生成器。
- en: One common way to combine generator functions is when we create a composite
    function. We might have a generator that computes `(f(x) for x in range())`. If
    we want to compute `g(f(x))`, we have several ways to combine two generators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 组合生成器函数的一种常见方式是当我们创建一个复合函数时。我们可能有一个计算`(f(x) for x in range())`的生成器。如果我们想计算`g(f(x))`，我们有几种方法来组合两个生成器。
- en: 'We can tweak the original generator expression as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整原始的生成器表达式如下：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While technically correct, this defeats any idea of reuse. Rather than reusing
    an expression, we rewrite it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上是正确的，但这破坏了任何重用的想法。我们不是重用一个表达式，而是重写它。
- en: 'We can also substitute one expression within another expression, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在另一个表达式中替换一个表达式，如下所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This has the advantage of allowing us to use simple substitution. We can revise
    this slightly to emphasize reuse, using the following commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，允许我们使用简单的替换。我们可以稍微修改这个以强调重用，使用以下命令：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This has the advantage of leaving the initial expression, `(f(x) for x in range())`,
    essentially untouched. All we did was assign the expression to a variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，它保留了初始表达式`(f(x) for x in range())`，基本上没有改变。我们所做的只是将表达式分配给一个变量。
- en: The resulting composite function is also a generator expression, which is also
    lazy. This means that extracting the next value from `g_f_x` will extract one
    value from `f_x`, which will extract one value from the source `range()` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的复合函数也是一个生成器表达式，也是懒惰的。这意味着从`g_f_x`中提取下一个值将从`f_x`中提取一个值，这将从源`range()`函数中提取一个值。
- en: Cleaning raw data with generator functions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器函数清理原始数据
- en: One of the tasks that arise in exploratory data analysis is cleaning up raw
    source data. This is often done as a composite operation applying several scalar
    functions to each piece of input data to create a usable data set.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性数据分析中出现的任务之一是清理原始数据源。这通常作为一个复合操作，对每个输入数据应用多个标量函数来创建一个可用的数据集。
- en: 'Let''s look at a simplified set of data. This data is commonly used to show
    techniques in exploratory data analysis. It''s called **Anscombe''s Quartet**,
    and it comes from the article, **Graphs** **in** **Statistical** **Analysis**,
    by F. J. Anscombe that appeared in *American Statistician* in 1973\. Following
    are the first few rows of a downloaded file with this dataset:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简化的数据集。这个数据通常用来展示探索性数据分析技术。它被称为**Anscombe's Quartet**，来源于F. J. Anscombe在1973年发表在*American
    Statistician*上的文章**Graphs in Statistical Analysis**。以下是一个下载文件中这个数据集的前几行：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sadly, we can''t trivially process this with the `csv` module. We have to do
    a little bit of parsing to extract the useful information from this file. Since
    the data is properly tab-delimited, we can use the `csv.reader()` function to
    iterate through the various rows. We can define a data iterator as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们不能简单地使用`csv`模块处理这个问题。我们必须对文件进行一些解析，以提取出文件中的有用信息。由于数据是正确的制表符分隔的，我们可以使用`csv.reader()`函数来遍历各行。我们可以定义一个数据迭代器如下：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We simply wrapped a file in a `csv.reader` function to create an iterator over
    rows. We can use this iterator in the following context:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将一个文件包装在`csv.reader`函数中，以创建一个行的迭代器。我们可以在以下上下文中使用这个迭代器：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The problem with this is that the first three items in the resulting iterable
    aren''t data. The Anacombe''s quartet file looks as follows when opened:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于结果可迭代对象中的前三个项目不是数据。当打开Anacombe's quartet文件时，它看起来是这样的：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to filter these rows from the iterable. Here is a function that will
    neatly excise three expected title rows, and return an iterator over the remaining
    rows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从可迭代对象中过滤这些行。下面是一个可以整洁地切除三个预期标题行，并返回剩余行的迭代器的函数：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function plucks three rows from the iterable. It asserts that each row
    has an expected value. If the file doesn't meet these basic expectations, it's
    a symptom that the file was damaged or perhaps our analysis is focused on the
    wrong file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从可迭代对象中取出三行。它断言每行都有一个预期值。如果文件不符合这些基本期望，那么这表明文件已损坏，或者我们的分析可能集中在错误的文件上。
- en: 'Since both the `row_iter()` and the `head_split_fixed()` functions expect an
    iterable as an argument value, they can be trivially combined as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`row_iter()`和`head_split_fixed()`函数都期望一个可迭代对象作为参数值，它们可以如下简单地组合：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've simply applied one iterator to the results of another iterator. In effect,
    this defines a composite function. We're not done, of course; we still need to
    convert the `strings` values to the `float` values and we also need to pick apart
    the four parallel series of data in each row.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将一个迭代器应用到另一个迭代器的结果上。实际上，这定义了一个复合函数。当然，我们还没有完成；我们仍然需要将`strings`值转换为`float`值，而且我们还需要拆分每行中的四个并行数据系列。
- en: The final conversions and data extractions are more easily done with higher-order
    functions such as `map()` and `filter()`. We'll return to those in [Chapter 5](ch05.html
    "Chapter 5. Higher-order Functions"), *Higher-order Functions*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的转换和数据提取更容易使用高阶函数，比如`map()`和`filter()`。我们将在[第5章](ch05.html "第5章。高阶函数")*高阶函数*中回到这些内容。
- en: Using lists, dicts, and sets
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表、字典和集合。
- en: A Python sequence object, like a `list`, is iterable. However, it has some additional
    features. We'll think of it as a materialized iterable. We've used the `tuple()`
    function in several examples to collect the output of a generator expression or
    generator function into a single `tuple` object. We can also materialize a sequence
    to create a `list` object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python序列对象，比如`list`，是可迭代的。但它还有一些额外的特性。我们将把它看作是一个实现的可迭代对象。我们在几个例子中使用`tuple()`函数来收集生成器表达式或生成器函数的输出到一个单一的`tuple`对象中。我们也可以实现一个序列来创建一个`list`对象。
- en: 'In Python, a list display offers simple syntax to materialize a generator:
    we just add the `[]` brackets. This is ubiquitous to the point where the distinction
    between generator expression and list comprehension is a subtlety of little practical
    importance.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，列表显示提供了简单的语法来实现生成器：我们只需添加`[]`括号。这是无处不在的，以至于生成器表达式和列表推导之间的区别在实际上并不重要。
- en: 'The following is an example to enumerate the cases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个枚举案例的例子：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first example is a generator function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是一个生成器函数。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `range(10)` function is lazy; it won't produce the 10 values until evaluated
    in a context that iterates through the values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`range(10)`函数是惰性的；在通过迭代遍历值的上下文中才会产生这10个值。'
- en: The second example shows a list composed of a single generator function. To
    evaluate this, we'll have to use `nested` loops. Something like this `[x for gen
    in [range(10)] for x in gen]`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子展示了由单个生成器函数组成的列表。要评估这个，我们将不得不使用`嵌套`循环。类似这样`[x for gen in [range(10)] for
    x in gen]`。
- en: The third example shows a `list` comprehension built from a generator expression
    that includes a generator function. The function, `range(10)`, is evaluated by
    a generator expression, `x for x in range(10)`. The resulting values are collected
    into a `list` object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子展示了从包含生成器函数的生成器表达式构建的`list`推导。函数`range(10)`通过生成器表达式`x for x in range(10)`进行评估。结果值被收集到一个`list`对象中。
- en: We can also use the `list()` function to build a list from an iterable or a
    generator expression. This also works for `set()`, `tuple()`, and `dict()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`list()`函数从可迭代对象或生成器表达式构建一个列表。这对于`set()`、`tuple()`和`dict()`也适用。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `list(range(10))` function evaluated the generator expression. The `[range(10)]`
    list literal does not evaluate the generator function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(range(10))`函数评估了生成器表达式。`[range(10)]`列表文字不评估生成器函数。'
- en: While there's shorthand syntax for `list`, `dict,` and `set` using **[]** and
    `{}`,there's no shorthand syntax for a tuple. To materialize a tuple, we must
    use the `tuple()` function. For this reason, it often seems most consistent to
    use the `list()`, `tuple()`, and `set()` functions as the preferred syntax.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有`list`、`dict`和`set`的简写语法，使用**[]**和`{}`，但没有元组的简写语法。为了实现一个元组，我们必须使用`tuple()`函数。因此，使用`list()`、`tuple()`和`set()`函数作为首选语法似乎是最一致的。
- en: 'In the data cleansing example, we used a composite function to create a list
    of four tuples. The function looked as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据清洗示例中，我们使用一个复合函数来创建四个元组的列表。函数如下所示：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We assigned the results of the composite function to a name, `data`. The data
    looks as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复合函数的结果分配给一个名为`data`的名称。数据如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We need to do a little bit more processing to make this useful. First, we need
    to pick pairs of columns from the eight tuple. We can select pair of columns with
    a function, as shown in the following command snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些更多的处理才能让它有用。首先，我们需要从八个元组中选择一对列。我们可以使用一个函数选择一对列，如下面的命令片段所示：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function picks two adjacent columns based on a number between 0 and 3\.
    It creates a `namedtuple` object from those two columns. This allows us to pick
    the *x* or *y* value from each row.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据0到3之间的数字选择两个相邻的列。它从这两列创建一个`namedtuple`对象。这使我们可以从每一行中选择*x*或*y*值。
- en: 'We can now create a tuple-of-tuples collection as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个元组集合，如下所示：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We applied the `tuple()` function to a composite function based on the `head_split_fixed()`
    and `row_iter()` methods. This will create an object that we can reuse in several
    other functions. If we don't materialize a `tuple` object, only the first sample
    will have any data. After that, the source iterator will be exhausted and all
    other attempts to access it would yield empty sequestionsnces.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`tuple()`函数应用于基于`head_split_fixed()`和`row_iter()`方法的复合函数。这将创建一个对象，我们可以在其他几个函数中重复使用。如果我们不实现一个`tuple`对象，那么只有第一个样本会有任何数据。之后，源迭代器将被耗尽，所有其他尝试访问它都将产生空的序列。
- en: The `series()` function will pick pairs of items to create the `Pair` objects.
    Again, we applied an overall `tuple()` function to materialize the resulting tuple-of-namedtuple
    sequences so that we can do further processing on each one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`series()`函数将选择一对项目来创建`Pair`对象。同样，我们对结果的元组-命名元组序列应用了一个整体的`tuple()`函数，以便我们可以对每个序列进行进一步处理。'
- en: 'The `sample_I` sequence looks like the following command snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample_I`序列看起来像下面的命令片段：'
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The other three sequences are similar in structure. The values, however, are
    quite different.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个序列的结构类似。然而，值是非常不同的。
- en: The final thing we'll need to do is create proper numeric values from the strings
    that we've accumulated so that we can compute some statistical summary values.
    We can apply the `float()` function conversion as the last step. There are many
    alternative places to apply the `float()` function, and we'll look at some choices
    in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是从我们积累的字符串中创建适当的数值，以便我们可以计算一些统计摘要值。我们可以将`float()`函数转换应用为最后一步。有许多替代的地方可以应用`float()`函数，我们将在[第5章](ch05.html
    "第5章。高阶函数")*高阶函数*中看一些选择。
- en: 'Here is an example describing the usage of `float()` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个描述`float()`函数用法的例子：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will provide the mean of the `y` value in each `Pair` object. We can gather
    a number of statistics as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供`Pair`对象中`y`值的平均值。我们可以按如下方式收集一些统计信息：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We computed a mean for the `y` values in each `pair` built from the source database.
    We created a common tuple-of-namedtuple structure so that we can have reasonably
    clear references to members of the source dataset. Using `pair.y` is a bit less
    obscure than `pair[1]`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了从源数据库构建的每个`pair`中`y`值的平均值。我们创建了一个通用的元组-命名元组结构，这样我们就可以清晰地引用源数据集的成员。使用`pair.y`比`pair[1]`更清晰一些。
- en: To reduce memory use—and increase performance—we prefer to use generator expressions
    and functions as much as possible. These iterate through collections in a lazy
    (or non-strict) manner, computing values only when required. Since iterators can
    only be used once, we're sometimes forced to materialize a collection as a `tuple`
    (or `list`) object. Materializing a collection costs memory and time, so we do
    it reluctantly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少内存使用并提高性能，我们尽可能使用生成器表达式和函数。这些以一种惰性（或非严格）的方式迭代集合，只在需要时计算值。由于迭代器只能使用一次，有时我们被迫将一个集合实现为`tuple`（或`list`）对象。实现一个集合会消耗内存和时间，所以我们不情愿地这样做。
- en: Programmers familiar with **Clojure** can match Python's lazy generators with
    the `lazy-seq` and `lazy-cat` functions. The idea is that we can specify a potentially
    infinite sequence, but only take values from it as needed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉**Clojure**的程序员可以使用`lazy-seq`和`lazy-cat`函数与Python的惰性生成器相匹配。这个想法是我们可以指定一个潜在的无限序列，但只在需要时从中取值。
- en: Using stateful mappings
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有状态的映射
- en: Python offers several stateful collections; the various mappings include the
    dict class and a number of related mappings defined in the `collections` module.
    We need to emphasize the stateful nature of these mappings and use them carefully.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几种有状态的集合；各种映射包括dict类和`collections`模块中定义的许多相关映射。我们需要强调这些映射的有状态性质，并谨慎使用它们。
- en: 'For our purposes in learning functional programming techniques in Python, there
    are two use cases for `mapping`: a stateful dictionary that accumulates a mapping
    and a frozen dictionary. In the first example of this chapter, we showed a frozen
    dictionary that was used by the `ElementTree.findall()` method. Python doesn''t
    provide an easy-to-use definition of an immutable mapping. The `collections.abc.Mapping`
    abstract class is immutable but it''s not something we can use trivially. We''ll
    dive into details in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursions and Reductions*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在学习Python中的函数式编程技术的目的，`mapping`有两种用例：累积映射的有状态字典和冻结字典。在本章的第一个例子中，我们展示了一个被`ElementTree.findall()`方法使用的冻结字典。Python没有提供一个易于使用的不可变映射的定义。`collections.abc.Mapping`抽象类是不可变的，但它不是我们可以轻易使用的东西。我们将在[第6章](ch06.html
    "第6章。递归和归约")中深入了解细节，*递归和归约*。
- en: Instead of the formality of using the `collections.abc.Mapping` abstract class,
    we can fall back on confirming that the variable `ns_map` appears exactly once
    on the left side of an assignment statement, methods such as `ns_map.update()`
    or `ns_map.pop()` are never used, and the `del` statement isn't used with map
    items.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`collections.abc.Mapping`抽象类的形式，我们可以确认变量`ns_map`在赋值语句的左侧只出现一次，方法如`ns_map.update()`或`ns_map.pop()`从未被使用，`del`语句也没有与映射项一起使用。
- en: 'The stateful dictionary can be further decomposed into two typical use cases;
    they are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的字典可以进一步分解为两种典型的用例；它们如下：
- en: A dictionary built once and never updated. In this case, we will exploit the
    hashed keys feature of the `dict` class to optimize performance. We can create
    a dictionary from any iterable sequence of (key, value) two tuples via `dict(
    sequence )`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字典只建立一次，从不更新。在这种情况下，我们将利用`dict`类的哈希键特性来优化性能。我们可以通过`dict(sequence)`从任何可迭代的(key,
    value)两元组序列创建字典。
- en: A dictionary built incrementally. This is an optimization we can use to avoid
    materializing and sorting a list object. We'll look at this in [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*. We'll look
    at the `collections.Counter` class as a sophisticated reduction. Incremental building
    is particularly helpful for memoization. We'll defer memoization until [Chapter
    16](ch16.html "Chapter 16. Optimizations and Improvements"), *Optimizations and
    Improvements*.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个逐步构建的字典。这是一个我们可以使用的优化，可以避免实现和排序列表对象。我们将在[第6章](ch06.html "第6章。递归和归约")中看到这一点，*递归和归约*。我们将把`collections.Counter`类作为一个复杂的归约。逐步构建对于记忆化特别有帮助。我们将把记忆化推迟到[第16章](ch16.html
    "第16章。优化和改进")中，*优化和改进*。
- en: 'The first example, building a dictionary once, stems from an application with
    three operating phases: gather some input, create a `dict` object, and then process
    input based on the mappings in the dictionary. As an example of this kind of application,
    we might be doing some image processing and have a specific palette of colors,
    represented by names and (R, G, B) tuples. If we use the **GNU Image Manipulation
    Program** (**GIMP**) **GNU General Public License** (**GPL**) file format, the
    color palette might look like the following command snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子，只建立一次字典，源自一个具有三个操作阶段的应用程序：收集一些输入，创建一个`dict`对象，然后根据字典中的映射处理输入。作为这种应用程序的一个例子，我们可能正在进行一些图像处理，并且有一个特定的调色板，由名称和(R,
    G, B)元组表示。如果我们使用**GNU图像处理程序**（**GIMP**）**GNU通用公共许可证**（**GPL**）文件格式，颜色调色板可能看起来像以下命令片段：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The details of parsing this file are the subject of [Chapter 6](ch06.html "Chapter 6. Recursions
    and Reductions"), *Recursions and Reductions*. What's important is the results
    of the parsing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 解析这个文件的细节是[第6章](ch06.html "第6章。递归和归约")的主题，*递归和归约*。重要的是解析的结果。
- en: 'First, we''ll assume that we''re using the following `Color` namedtuple:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们假设我们正在使用以下的`Color`命名元组：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Second, we''ll assume that we have a parser that produces an iterable of `Color`
    objects. If we materialize it as a tuple, it would look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们假设有一个产生`Color`对象可迭代的解析器。如果我们将其实现为一个元组，它看起来会像这样：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In order to locate a given color name quickly, we will create a frozen dictionary
    from this sequence. This is not the only way to get fast lookups of a color by
    name. We'll look at another option later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速定位给定的颜色名称，我们将从这个序列创建一个冻结字典。这不是获取颜色名称快速查找的唯一方法。我们稍后会看另一个选项。
- en: 'To create a mapping from a tuple, we will use the `process(wrap(iterable))`
    design pattern. The following command shows how we can create the color name mapping:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从元组创建映射，我们将使用`process(wrap(iterable))`设计模式。以下命令显示了我们如何创建颜色名称映射：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Where the sequence variable is the iterable of the `Color` objects shown previously,
    the `wrap()` element of the design pattern simply transforms each `Color` object
    , `c`, into the two tuple `(c.name, c)`. The `process()` element of the design
    uses `dict()` initialization to create a mapping from name to `Color`. The resulting
    dictionary looks as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，序列变量是先前显示的`Color`对象的可迭代对象，设计模式的`wrap()`元素简单地将每个`Color`对象`c`转换成两元组`(c.name,
    c)`。设计的`process()`元素使用`dict()`初始化来创建从名称到`Color`的映射。结果字典如下所示：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The order is not guaranteed, so you may not see Caribbean Green first.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序不能保证，所以你可能看不到加勒比绿色排在第一位。
- en: Now that we've materialized the mapping, we can use this `dict()` object in
    some later processing for repeated transformations from color name to (R, G, B)
    color numbers. The lookup will be blazingly fast because a dictionary does a rapid
    transformation from key to hash value followed by lookup in the dictionary.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了映射，我们可以在以后的一些处理中使用这个`dict()`对象，用于从颜色名称到(R, G, B)颜色数字的重复转换。查找将非常快，因为字典会快速将键转换为哈希值，然后在字典中查找。
- en: Using the bisect module to create a mapping
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bisect模块创建映射
- en: In the previous example, we created a `dict` mapping to achieve a fast mapping
    from a color name to a `Color` object. This isn't the only choice; we can use
    the `bisect` module instead. Using the `bisect` module means that we have to create
    a sorted object, which we can then search. To be perfectly compatible with the
    `dict` mapping, we can use `collections.abc.Mapping` as the base class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个`dict`映射，以实现从颜色名称到`Color`对象的快速映射。这不是唯一的选择；我们可以使用`bisect`模块。使用`bisect`模块意味着我们必须创建一个排序对象，然后进行搜索。为了与`dict`映射完全兼容，我们可以使用`collections.abc.Mapping`作为基类。
- en: The `dict` mapping uses a hash to locate items almost immediately. However,
    this requires allocating a fairly large block of memory. The `bisect` mapping
    does a search, which doesn't require as much memory, but performance can be described
    as immediate.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`映射使用哈希来几乎立即定位项。然而，这需要分配一个相当大的内存块。`bisect`映射进行搜索，不需要那么多的内存，但性能可以描述为立即。'
- en: 'A `static` mapping class looks like the following command snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`映射类看起来像以下命令片段：'
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This class extends the abstract superclass `collections.abc.Mapping`. It provides
    an initialization and implementations for three functions missing from the abstract
    definition. The `__getitem__()` method uses the `bisect.bisect_left()` function
    to search the collection of keys. If the key is found, the appropriate value is
    returned. The `__iter__()` method returns an iterator, as required by the superclass.
    The `__len__()` method, similarly, provides the required length of the collection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了抽象超类`collections.abc.Mapping`。它提供了三个函数的初始化和实现，这些函数在抽象定义中缺失。`__getitem__()`方法使用`bisect.bisect_left()`函数来搜索键的集合。如果找到键，则返回相应的值。`__iter__()`方法返回一个迭代器，如超类所需。`__len__()`方法同样提供了集合的所需长度。
- en: Another option is to start with the source code for the `collections.OrderedDict`
    class, change the superclass to `Mapping` instead of `MutableMapping`, and remove
    all of the methods that implement mutability. For more details on which methods
    to keep and which to discard, refer to the *Python Standard Library*, section
    8.4.1.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是从`collections.OrderedDict`类的源代码开始，将超类更改为`Mapping`而不是`MutableMapping`，并删除所有实现可变性的方法。有关要保留哪些方法和要丢弃哪些方法的更多详细信息，请参阅*Python标准库*第8.4.1节。
- en: 'Visit the following link for more details:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接以获取更多详细信息：
- en: '[https://docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes](https://docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes](https://docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes)'
- en: This class might not seem to embody too many functional programming principles.
    Our goal here is to support a larger application that minimizes the use of stateful
    variables. This class saves a static collection of key-value pairs. As an optimization,
    it materializes two objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类似乎并不体现太多的函数式编程原则。我们的目标是支持一个最小化使用有状态变量的更大的应用程序。这个类保存了一组静态的键值对。作为一种优化，它实现了两个对象。
- en: An application that creates an instance of this class is using a materialized
    object to perform rapid lookups of the keys. The superclass does not support updates
    to the object. The collection, as a whole, is stateless. It's not as fast as the
    built-in `dict` class, but it uses less memory and, through the formality of being
    a subclass of `Mapping`, we can be assured that this object is not used to contain
    a processing state.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此类的实例的应用程序正在使用一个实例化对象来执行对键的快速查找。超类不支持对对象的更新。整个集合是无状态的。它不像内置的`dict`类那样快，但它使用的内存更少，并且通过作为`Mapping`子类的形式，我们可以确保该对象不用于包含处理状态。
- en: Using stateful sets
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有状态集合
- en: 'Python offers several stateful collections, including the set collection. For
    our purposes, there are two use cases for a set: a stateful set that accumulates
    items, and a frozenset that is used to optimize searches for an item.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几种有状态的集合，包括set集合。对于我们的目的，集合有两种用途：一个是累积项的有状态集合，另一个是用于优化搜索项的frozenset。
- en: We can create a frozenset from an iterable in the same way as we create a `tuple`
    object from an iterable `fronzenset(some_iterable)` method; this will create a
    structure that has the advantage of a very fast `in` operator. This can be used
    in an application that gatheres data, creates a set, and then uses that frozenset
    to process some other data items.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像创建`tuple`对象一样从可迭代对象中创建frozenset，`fronzenset(some_iterable)`方法；这将创建一个具有非常快速的`in`运算符的结构。这可以用于收集数据、创建集合，然后使用那个frozenset来处理其他数据项的应用程序。
- en: 'We might have a set of colors that we will use as a kind of **chroma**-**key**:
    we will use this color to create a mask that will be used to combine two images.
    Pragmatically, a single color isn''t appropriate but a small set of very similar
    colors works best. In this case, we''ll examine each pixel of an image file to
    see if the pixel is in the chroma-key set or not. For this kind of processing,
    the chroma-key colors are loaded into a frozenset before processing the target
    images. For more information, read about chroma-key processing from the following
    link:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一组颜色，我们将使用作为一种**色度**-**键**：我们将使用这种颜色创建一个蒙版，该蒙版将用于组合两个图像。从实用的角度来看，单一颜色并不合适，但一小组非常相似的颜色效果最佳。在这种情况下，我们将检查图像文件的每个像素，以查看像素是否在色度键集中。对于这种处理，色度键颜色在处理目标图像之前加载到frozenset中。有关色度键处理的更多信息，请阅读以下链接：
- en: '[http://en.wikipedia.org/wiki/Chroma_key](http://en.wikipedia.org/wiki/Chroma_key)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Chroma_key](http://en.wikipedia.org/wiki/Chroma_key)'
- en: As with mappings—specifically the `Counter` class—there are some algorithms
    that can benefit from a memoized set of values. Some functions benefit from memoization
    because a function is a mapping between domain values and range values, a job
    for which a mapping works nicely. A few algorithms benefit from a memoized set,
    which is stateful and grows as data is processed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与映射一样 - 具体来说是`Counter`类 - 有一些算法可以从一个记忆化的值集中受益。一些函数受益于记忆化，因为函数是域值和值域之间的映射，这是映射很好的工作。一些算法受益于一个有记忆的集合，它是有状态的，并且随着数据的处理而增长。
- en: We'll return to memoization in [Chapter 16](ch16.html "Chapter 16. Optimizations
    and Improvements"), *Optimizations and Improvements*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第16章](ch16.html "第16章。优化和改进")*优化和改进*中回顾记忆化。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we looked closely at writing pure functions: free of side
    effects. The bar is low here, since Python forces us to use the `global` statement
    to write impure functions. We looked at generator functions and how we can use
    these as the backbone of functional programming.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仔细研究了编写纯函数：没有副作用。这里的标准很低，因为Python强制我们使用`global`语句来编写不纯的函数。我们研究了生成器函数以及我们如何将其用作函数式编程的支柱。
- en: We also examined the built-in collection classes to show how they're used in
    the functional paradigm. While the general ideal behind functional programming
    is to limit the use of stateful variables, the collection objects are generally
    stateful and, for many algorithms, also essential. Our goal is to be judicious
    in our use of Python's nonfunctional features.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了内置的集合类，以展示它们在函数范式中的使用方式。虽然函数式编程背后的一般理念是限制使用有状态的变量，但集合对象通常是有状态的，并且对于许多算法也是必不可少的。我们的目标是在使用Python的非函数式特性时要谨慎。
- en: 'In the next two chapters, we''ll look at higher-order functions: functions
    that accept functions as arguments as well as returning functions. We''ll start
    with an exploration of the built-in higher-order functions. In later chapters,
    we''ll look at techniques for defining our own higher-order functions. We''ll
    also look at the `itertools` and `functools` modules and their higher-order functions
    in later chapters.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将研究高阶函数：接受函数作为参数并返回函数的函数。我们将从探索内置的高阶函数开始。在后面的章节中，我们将研究定义自己的高阶函数的技术。我们还将在后面的章节中研究`itertools`和`functools`模块及其高阶函数。
