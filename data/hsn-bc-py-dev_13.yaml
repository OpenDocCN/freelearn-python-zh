- en: Cryptocurrency Wallet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币钱包
- en: In this chapter, you are going to learn how to build a desktop cryptocurrency
    wallet. You will still use the same GUI library, Qt for Python or PySide2 to create
    a desktop application. This cryptocurrency wallet can send ethers as well as ERC20
    tokens. Before building this cryptocurrency wallet, you will learn advanced features
    of the PySide2 library, such as tabs, comboboxes, size policy, and adding stretch
    to control the distribution of widgets in a layout. On top of that, you will integrate
    testing into applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何构建一个桌面加密货币钱包。您仍将使用相同的GUI库，Qt for Python或PySide2来创建桌面应用程序。这个加密货币钱包可以发送以太币和ERC20代币。在构建这个加密货币钱包之前，您将学习PySide2库的高级功能，比如标签、组合框、大小策略以及添加拉伸以控制布局中小部件的分布。此外，您还将把测试集成到应用程序中。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Advanced features of the PySide2 library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PySide2库的高级功能
- en: Pytest Qt, a library to test a Qt for a Python application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pytest Qt，用于测试Python应用程序的Qt库
- en: How to build a cryptocurrency wallet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建加密货币钱包
- en: Some considerations when building a cryptocurrency wallet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建加密货币钱包时需要考虑的一些因素
- en: Advanced features of the PySide2 library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PySide2库的高级功能
- en: This chapter requires the reader to have some knowledge of the PySide2 library.
    You should read [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend
    Decentralized Application*,first if you have not done so, as this chapter is based
    on that one. If you have familiarized yourself with building a GUI with `PySide2`,
    you are equipped with the necessary skills to build a desktop cryptocurrency wallet,
    at least from the **User Interface** (**UI**) persepective. However, the application
    that you build will be jarring to users. For example, if you incorporated a button
    in a horizontal layout and that button is the only widget in the horizontal layout,
    when you resize the window that has the horizontal layout, the button will be
    stretched to the right and left. If this is not what you want to happen, you need
    a way to tell the button to keep its width.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要读者对PySide2库有一定的了解。如果您还没有这样做，您应该先阅读[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml)
    *前端去中心化应用*，因为本章是基于那一章的。如果您已经熟悉了使用`PySide2`构建GUI，那么您就具备了构建桌面加密货币钱包所需的技能，至少从**用户界面**（**UI**）的角度来看。但是，您构建的应用程序对用户来说可能会很刺耳。例如，如果您在水平布局中加入了一个按钮，并且该按钮是水平布局中唯一的小部件，当您调整具有水平布局的窗口大小时，按钮将被拉伸到右侧和左侧。如果这不是您想要发生的，您需要一种方法告诉按钮保持其宽度。
- en: So, let's learn other features from the `PySide2` library, such as tab, size
    policy, and grid layout, so that we have the skills to make the UI of our application
    more attractive. Our application will not win the *Apple Best Design Award*, but
    at least it will be less jarring for users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从`PySide2`库中学习其他功能，比如标签、大小策略和网格布局，这样我们就有了制作应用程序UI更具吸引力的技能。我们的应用程序可能不会赢得*苹果最佳设计奖*，但至少对用户来说不会那么刺耳。
- en: In addition, in [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized
    Application*, we neglected testing. Since a cryptocurrency wallet application
    is an application that handles people's money, errors are costly. Consequently,
    we need to catch any errors before users do. We should therefore write proper
    testing for our cryptocurrency wallet. However, we will focus on testing for the
    UI part of the cryptocurrency wallet. We will not focus on testing inner methods.
    In other words, our testing will be integration testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml) *前端去中心化应用*中，我们忽略了测试。由于加密货币钱包应用程序是处理人们的资金的应用程序，错误是代价高昂的。因此，我们需要在用户之前捕捉到任何错误。因此，我们应该为我们的加密货币钱包编写适当的测试。但是，我们将专注于对加密货币钱包的UI部分进行测试。我们不会专注于测试内部方法。换句话说，我们的测试将是集成测试。
- en: 'Install the `Qt` library if you haven''t already done so. Please read [Chapter
    7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized Application*,
    for guidance on how to do this. After doing so, create a virtual environment for
    your project using the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装`Qt`库，请阅读[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml) *前端去中心化应用*，了解如何安装。之后，使用以下命令为您的项目创建一个虚拟环境：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also want to install a test library to test our application, which can be
    done by means of the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望安装一个测试库来测试我们的应用程序，可以通过以下命令来完成：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that all the libraries have been set up, let's write a simple application
    so we can test it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的库都已经设置好了，让我们写一个简单的应用程序来测试一下。
- en: Testing application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: 'Create a directory named `advanced_course_qt`. We can put all of our tutorial
    files here. Name the first script `button_and_label.py` and use the following
    code to create a button and a label for that button (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`advanced_course_qt`的目录。我们可以把所有的教程文件放在这里。将第一个脚本命名为`button_and_label.py`，并使用以下代码为该按钮创建一个按钮和一个标签（请参考以下GitLab链接上的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py)）：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the preceding code to see what this application is about. The application
    consists of a button and a label:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，看看这个应用程序是关于什么的。该应用程序由一个按钮和一个标签组成：
- en: '![](assets/62549502-1017-428a-ac5f-b1ed6284849b.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62549502-1017-428a-ac5f-b1ed6284849b.png)'
- en: 'If you click the button, the text on the label will change, as shown in the
    following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击按钮，标签上的文本将会改变，如下图所示：
- en: '![](assets/62e8a851-c9d0-42e7-ad12-ac727a7ccba6.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62e8a851-c9d0-42e7-ad12-ac727a7ccba6.png)'
- en: 'So let''s test this application. Name the test `test_button_and_label.py` and
    put it in the same directory. Use the following code block for the test application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个应用程序。将测试命名为`test_button_and_label.py`，并将其放在相同的目录中。使用以下代码块进行测试应用程序：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the test using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be aware that the `(wallet-venv) $ python test_button_and_label.py`command is
    a negligible error often used to run the test. Don't fall for it!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`(wallet-venv) $ python test_button_and_label.py`命令是一个微不足道的错误，经常用于运行测试。不要上当！
- en: In this test script, we import our `widget` class. Then, we create a test method
    that has a name starting with `test_`. This method has a parameter named `qtbot`.
    Don't change its name. `qtbot` is a special name and must not be changed. Inside
    this method, `qtbot` can be used to interact with the `widget` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试脚本中，我们导入我们的`widget`类。然后，我们创建一个以`test_`开头的测试方法。这个方法有一个名为`qtbot`的参数。不要更改它的名称。`qtbot`是一个特殊的名称，不得更改。在这个方法内部，`qtbot`可以用来与`widget`类交互。
- en: 'First of all, we instantiate a `widget` class that we want to test. Then, we
    add that `widget` instance using the `addWidget` method from `qtbot`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个我们想要测试的`widget`类。然后，我们使用`qtbot`的`addWidget`方法添加该`widget`实例：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we test the `text` on the `label` variable before clicking the button:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在单击按钮之前，我们测试`label`变量上的`text`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, we can access `label` from `widget`. This is made possible
    because we declared the `label` variable in `button_and_label.py` using the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以从`widget`中访问`label`。这是因为我们在`button_and_label.py`中使用以下代码声明了`label`变量：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you declare the label in `button_and_label.py` with the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`button_and_label.py`中使用以下代码声明标签：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then you would not be able to access `label` from the instance of `widget`
    in the test. Of course, you could circumvent that situation by creating a variable
    to hold the text of the label. However, making the `label` a `widget` instance
    property is the easiest thing to do in order to test the text of the label. You
    will use this strategy in all further tests. In a nutshell, if you want to test
    widgets (such as a label, button, or combobox), make that `widget` a property
    of its parent widget instance. Then, we move on to how we click the button widget:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将无法从测试中的`widget`实例访问`label`。当然，您可以通过创建一个变量来保存标签的文本来规避这种情况。然而，将`label`作为`widget`实例属性是测试标签文本的最简单方法。您将在所有后续测试中使用这种策略。简而言之，如果您想测试小部件（如标签、按钮或组合框），请将该`widget`作为其父小部件实例的属性。然后，我们继续讨论如何单击按钮小部件：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To click a button during testing, you use the `mouseClick` method from `qtbot`.
    The first parameter of the `mouseClick` method of `qtbot` is a button widget,
    or something that accepts a clicking event. The second parameter is an option
    to detect the nature of the mouse click event. The test in this case will only accept a
    left button click.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试期间单击按钮，您可以使用`qtbot`的`mouseClick`方法。`qtbot`的`mouseClick`方法的第一个参数是一个按钮小部件，或者是接受点击事件的东西。第二个参数是检测鼠标点击事件性质的选项。在这种情况下，测试将只接受左键点击。
- en: 'The following code is to test and display the text of a label after clicking
    the button:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是测试并显示单击按钮后标签的文本：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In building a GUI application, on occasion, we have to display a list of objects.
    In our cryptocurrency wallet, the list could hold accounts. So let''s write a
    test for that scenario. First, however, we have to create a script to display
    a list of objects. Name the script `button_and_list.py` and use the following
    code block for the script (refer to the code file on the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py)):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建GUI应用程序时，我们偶尔需要显示对象列表。在我们的加密货币钱包中，列表可以包含账户。因此，让我们为这种情况编写一个测试。但首先，我们必须创建一个脚本来显示对象列表。将脚本命名为`button_and_list.py`，并使用以下代码块进行脚本（有关完整代码，请参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py)）：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the script to see how the application appears. The following shows the
    screenshot of the button prior to clicking it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本以查看应用程序的外观。以下是单击按钮之前的按钮的屏幕截图：
- en: '![](assets/e116c5e4-dd24-4718-ab6a-9c882d979332.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e116c5e4-dd24-4718-ab6a-9c882d979332.png)'
- en: 'And the following shows the result of clicking the button:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了单击按钮的结果：
- en: '![](assets/7ee4e5c2-944b-4949-95ed-39eb0e8c382f.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ee4e5c2-944b-4949-95ed-39eb0e8c382f.png)'
- en: You have a single button here and if you click it, a new label should appear
    with text that simply reads `1`. If you click the button for a second time, a
    new label will appear at the bottom with text that reads `2`, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个按钮，如果您单击它，将会出现一个新的标签，文本简单地显示为`1`。如果您再次单击按钮，将会在底部出现一个新的标签，文本显示为`2`，依此类推。
- en: The new label that shows up after we click the button is part of the vertical
    box layout. This means that we need to make that vertical box layout the widget
    instance's property so that we can access it in the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮后出现的新标签是垂直框布局的一部分。这意味着我们需要将垂直框布局作为小部件实例的属性，以便在测试中访问它。
- en: 'Let''s write a test for this GUI script, as shown in the following code block,
    and name it `test_button_and_list.py`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个GUI脚本编写一个测试，如下面的代码块所示，并将其命名为`test_button_and_list.py`：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see in the preceding code block, after the third execution of the `mouseClick`
    method of `qtbot`, we grab the label from the vertical box layout using the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码块中所看到的，在`qtbot`的`mouseClick`方法第三次执行之后，我们使用以下代码从垂直框布局中获取标签：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We take the child widget of a widget by means of the `takeAt` method. The parameter
    that we use in this case is `2`. This means that we want to grab the third child,
    the last one. Then, we test the text of the widget using the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`takeAt`方法获取小部件的子小部件。在这种情况下我们使用的参数是`2`。这意味着我们想要获取第三个子小部件，也就是最后一个。然后，我们使用以下代码测试小部件的文本：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's create a more complicated scenario. Hitherto, everything we have tested
    has been inside one window, but what if we have an input dialog? How do we test
    a dialog?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更复杂的场景。到目前为止，我们测试的所有内容都在一个窗口内，但如果有一个输入对话框怎么办？我们如何测试对话框？
- en: 'Let''s create a GUI script that has a dialog and name it `button_and_dialog.py`:
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py)):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有对话框的GUI脚本，并将其命名为`button_and_dialog.py`：（有关完整代码，请参考以下GitLab链接的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py)）：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code to view the application. There is a button and empty space beneath
    it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码以查看应用程序。有一个按钮和空白空间在其下方：
- en: '![](assets/e948dc67-2901-4f81-9c2a-241f051f0a48.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e948dc67-2901-4f81-9c2a-241f051f0a48.png)'
- en: 'Click button and a dialog will appear, after which you should type any text
    in the input dialog and click OK:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮，然后会出现一个对话框，之后您应该在输入对话框中输入任何文本，然后点击OK：
- en: '![](assets/9d3d1205-4bdd-461c-8afa-20e9baa69f60.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d3d1205-4bdd-461c-8afa-20e9baa69f60.png)'
- en: 'The text you have inputted will appear beneath the button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入的文本将出现在按钮下方：
- en: '![](assets/5b54a19c-249e-4153-816d-e2e68a29d8b7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b54a19c-249e-4153-816d-e2e68a29d8b7.png)'
- en: 'Let''s take a look at another test script in the following code block in order
    to understand how to handle the flow involving two different windows. In this
    test method, we have another parameter besides `qtbot`, called `monkeypatch`. Name
    the test file `test_button_and_dialog.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码块中的另一个测试脚本，以了解如何处理涉及两个不同窗口的流程。在这个测试方法中，除了`qtbot`之外，我们还有另一个参数叫做`monkeypatch`。将测试文件命名为`test_button_and_dialog.py`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`monkeypatch` is used to override a dialog input. This means that the `getText`
    method of `QInputDialog` would return a `("New Text", True)` tuple when we launch
    the dialog in the test. Remember the API of `QInputDialog`? This returns a tuple.
    This tuple contains two parameters—the text that we type in the dialog, and whether
    we click the OK or Cancel buttons.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`用于覆盖对话框输入。这意味着在测试中，`QInputDialog`的`getText`方法将返回一个`("New Text",
    True)`元组。记得`QInputDialog`的API吗？这返回一个元组。这个元组包含两个参数——我们在对话框中输入的文本，以及我们是否点击了OK或取消按钮。'
- en: 'The `getText` method of `QInputDialog` accepts four parameters: the window
    instance that this dialog is based upon, the title, the label before the input
    field, and the type of input field. When you type text, such as `To the moon!`
    in the input field, and clicked the **OK** button, it returns a tuple consisting
    of the string `To the moon!` and the `boolean` value of whether you click the OK button:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`QInputDialog`的`getText`方法接受四个参数：此对话框基于的窗口实例、标题、输入字段之前的标签和输入字段的类型。当您在输入字段中输入文本，例如`To
    the moon!`，然后点击**OK**按钮时，它会返回一个元组，其中包含字符串`To the moon!`和您是否点击了**OK**按钮的`boolean`值：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, `monkeypatch` patches this method so in the testing, no dialog would
    be launched. We bypass them. It''s as if the launching dialog line is replaced
    with the following line of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`monkeypatch`会修补这个方法，因此在测试中，不会启动对话框。我们绕过它们。就好像启动对话框的行被以下代码替换了一样：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For all of these tests, we always use a button-type widget to initiate something
    (changing the text on the label). Let''s use another type of widget to change
    the label, as given in the following code block, and name the script `combobox_and_label.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些测试，我们总是使用一个按钮类型的小部件来启动某些操作（更改标签上的文本）。让我们使用另一种类型的小部件来更改标签，如下面的代码块所示，并将脚本命名为`combobox_and_label.py`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This GUI script uses combobox to change the text on the label. It sets the
    text on the label with the text from the selected option of the label. Run the
    script to see how it appears:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GUI脚本使用组合框来更改标签上的文本。它使用所选标签的文本设置标签上的文本。运行脚本以查看它的外观：
- en: '![](assets/cb21233e-8a94-4283-8442-15ac65678c0a.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb21233e-8a94-4283-8442-15ac65678c0a.png)'
- en: 'Now, let''s create a test script to test this combobox widget and name it `test_combobox_and_label.py`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个测试脚本来测试这个组合框小部件，并将其命名为`test_combobox_and_label.py`：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The key point that we can take here is the way we change the selected option
    of `combobox` with `qtbot`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里得到的关键点是使用`qtbot`更改`combobox`的选定选项的方式：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method's name is not intuitive; it accepts two parameters. The first one
    is the widget, or the combobox in this case. The second one is the option text
    in the combobox. This `keyClicks` method is not just for selecting an option in
    combobox. It could also be used to type text in the line edit. Just put the line
    edit widget in the first parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的名称不直观；它接受两个参数。第一个是小部件，或者在这种情况下是组合框。第二个是组合框中的选项文本。这个`keyClicks`方法不仅用于选择组合框中的选项。它也可以用于在行编辑中输入文本。只需将行编辑小部件放在第一个参数中。
- en: This test knowledge is sufficient for testing our cryptocurrency wallet. Before
    we jump into building our cryptocurrency wallet, let's learn about some other
    features of `PySide2`, including grid layout, tab, and size policy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试知识足以测试我们的加密货币钱包。在我们开始构建加密货币钱包之前，让我们了解一下`PySide2`的一些其他功能，包括网格布局、选项卡和大小策略。
- en: Advanced features of Qt for Python or PySide2
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt for Python或PySide2的高级功能
- en: The first thing that we want to learn about here is stretching. We know how
    to add widgets to a box layout (vertical or horizontal). However, we can configure
    to some extent how to distribute these widgets that we added into a box layout.
    Should we stretch the widgets, put the widgets on top for the horizontal layout,
    and let the space devour the rest?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在这里学习的第一件事是拉伸。我们知道如何将小部件添加到框布局（垂直或水平）。但是，我们可以在一定程度上配置如何分配这些添加到框布局中的小部件。我们应该拉伸小部件，将小部件放在水平布局的顶部，并让空间吞噬其余部分吗？
- en: 'Let''s create a script to explain this configuration of widget distribution
    in a box layout and name the script `add_stretch.py` (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来解释在框布局中小部件分布的配置，并将脚本命名为`add_stretch.py`（请参考以下GitLab链接的完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py)）：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the script to see how it looks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本查看效果：
- en: '![](assets/2001b1a9-b988-4014-a04d-6489c683e960.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2001b1a9-b988-4014-a04d-6489c683e960.png)'
- en: If you add stretching to the end of the vertical container, it would push the
    widgets to the beginning of the vertical container and let the rest be an empty
    space. If you add stretching in the beginning, it would push the widgets to the
    end of the vertical container and let the rest be an empty space. If you don't
    add any stretching, the widgets would be distributed equally across the layout.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在垂直容器的末尾添加拉伸，它会将小部件推到垂直容器的开头，并让其余部分成为空白空间。如果您在开头添加拉伸，它会将小部件推到垂直容器的末尾，并让其余部分成为空白空间。如果您不添加任何拉伸，小部件将在布局中均匀分布。
- en: In terms of the functionality of the application, it does not make any difference.
    However, it can make the UI more attractive if you choose the right options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就应用的功能而言，这并没有什么区别。但是，如果您选择正确的选项，它可以使UI更具吸引力。
- en: We always use the box layout (vertical box layout or horizontal box layout).
    The box layout suffices in most cases. Occasionally, however, you want to use
    a more complicated layout. Qt has a grid layout that is more powerful than the
    box layout.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是使用框布局（垂直框布局或水平框布局）。在大多数情况下，框布局就足够了。然而，偶尔您可能想要使用更复杂的布局。Qt有一个比框布局更强大的网格布局。
- en: 'Let''s create a script to explore the power of the grid layout and name the
    script `create_grid_window.py` (refer to the code file on the following GitLab
    link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py)):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来探索网格布局的强大功能，并将脚本命名为`create_grid_window.py`（请参考以下GitLab链接的完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py)）：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the script to see how the grid layout manages its child window:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本查看网格布局如何管理其子窗口：
- en: '![](assets/c2c8e907-efc1-463d-9333-8d8b1ddd2cd4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2c8e907-efc1-463d-9333-8d8b1ddd2cd4.png)'
- en: A grid is like a table or spreadsheet. Instead of adding a widget to a row with
    a horizontal layout, or a column with a vertical layout, you add a widget to a
    table that is composed of rows and columns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网格就像一个表格或电子表格。与水平布局的行或垂直布局的列不同，您将小部件添加到由行和列组成的表格中。
- en: 'If you want to add the widget to the first row and the first column, use the
    following statement:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将小部件添加到第一行和第一列，请使用以下语句：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first parameter indicates a row. The second parameter indicates a column.
    So if you want to add the widget to the second row and the first column, use the
    following statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示行。第二个参数表示列。因此，如果您想要将小部件添加到第二行和第一列，使用以下语句：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `addWidget` method of the grid layout accepts optional third and fourth
    parameters. The third parameter indicates how many rows you want this widget to
    extend to. The fourth parameter indicates how many columns you want this widget
    to extend to:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局的`addWidget`方法接受可选的第三和第四个参数。第三个参数指示您希望此小部件延伸到多少行。第四个参数指示您希望此小部件延伸到多少列：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you stretch the window, you will see something similar to the following
    screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拉伸窗口，您将看到类似以下截图的内容：
- en: '![](assets/19cdf235-f769-4620-9caf-ac701ea923fe.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19cdf235-f769-4620-9caf-ac701ea923fe.png)'
- en: Take a look at Label G. This stretches up to two rows and two columns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下标签G。这可以延伸到两行和两列。
- en: 'Now, let''s talk about what happens to the widget if we increase the size of
    the parent window that contains the widget. Should the widget resize along with
    it? Should the widget stay still, and allow the margin to become wider? You can
    decide on the resizing configuration with the size policy. Let''s create a script
    named `button_with_sizepolicy.py` to demonstrate size configuring this policy
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py)):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈如果增加包含小部件的父窗口的大小会发生什么。小部件是否应随之调整大小？小部件是否应保持不变，并允许边距变宽？您可以使用大小策略来决定调整大小的配置。让我们创建一个名为`button_with_sizepolicy.py`的脚本来演示大小配置策略（请参考以下GitLab链接的完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py)）：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the script to see how each button appears differently with a different
    size policy:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本以查看每个按钮如何根据不同的大小策略显示不同：
- en: '![](assets/ec08a954-b1aa-4eba-b33f-2d6c07bac46b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec08a954-b1aa-4eba-b33f-2d6c07bac46b.png)'
- en: 'Then, try to resize the window to make sense of the size policy configuration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试调整窗口大小以理解大小策略配置：
- en: '![](assets/9e0ef275-b462-4e6f-8b73-82e0d853e917.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9e0ef275-b462-4e6f-8b73-82e0d853e917.png)'
- en: '`QSizePolicy.Maximum` indicates that the widget cannot be bigger than the size
    hint, or the content of the button in this case. If you want your button to stick
    to its original size, use this size policy. `QSizePolicy.Preferred` indicates
    that it prefers a size hint but it can be larger or smaller. `QSizePolicy.Expanding`
    indicates that the widget should expand as much as possible. `QSizePolicy.Minimum`
    indicates that the widget can be expanded, but it cannot be smaller than the size
    hint. `QSizePolicy.MinimumExpanding` indicates that the widget cannot be smaller
    than the size hint, but it expands as much as possible.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSizePolicy.Maximum`表示小部件不能比大小提示更大，或者在这种情况下按钮的内容。如果您希望按钮保持其原始大小，请使用此大小策略。`QSizePolicy.Preferred`表示它更喜欢大小提示，但它可以更大或更小。`QSizePolicy.Expanding`表示小部件应尽可能扩展。`QSizePolicy.Minimum`表示小部件可以扩展，但不能小于大小提示。`QSizePolicy.MinimumExpanding`表示小部件不能小于大小提示，但尽可能扩展。'
- en: In creating a GUI application, most of the time you would not put all of your
    functionalities/widgets in a single window. Otherwise, the window would be bigger
    than the screen resolution of the monitor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建GUI应用程序时，大多数情况下您不会将所有功能/小部件放在一个窗口中。否则，窗口将比显示器的屏幕分辨率大。
- en: You could launch a dialog with a button to hold more functionalities/widgets.
    That certainly works. But what you really want is something like a controller.
    In Qt, you have **StackView**. StackView can contain many windows, but it displays
    a maximum of one window at one time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动一个对话框，其中包含一个按钮来容纳更多功能/小部件。这当然有效。但是您真正想要的是类似控制器的东西。在Qt中，您有**StackView**。StackView可以包含许多窗口，但一次只显示一个窗口。
- en: 'We wouldn''t use StackView directly. Instead, we use tabbed view. Tabbed view
    uses StackView behind the scenes. Let''s create a script to use tabbed view and
    name it `tabbed_window.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用StackView。相反，我们使用选项卡视图。选项卡视图在幕后使用StackView。让我们创建一个脚本来使用选项卡视图，并将其命名为`tabbed_window.py`：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This tabbed window has three tabs. Each tab holds a widget. The second tab even
    holds a widget that we created in a separate script, `button_and_label.py`. This
    widget, which is in the second tab, has a button and a label. To add a tab to
    a tabbed window, you use the `addTab` method. The first parameter is the widget,
    and the second parameter is the title of the tab.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项卡窗口有三个选项卡。每个选项卡都包含一个小部件。第二个选项卡甚至包含一个我们在单独的脚本`button_and_label.py`中创建的小部件。这个小部件在第二个选项卡中有一个按钮和一个标签。要向选项卡窗口添加选项卡，您可以使用`addTab`方法。第一个参数是小部件，第二个参数是选项卡的标题。
- en: 'Run the script to see how tabbed view works. In the following screenshot, we
    see Tab 1:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本查看选项卡视图的工作原理。在下面的截图中，我们看到选项卡1：
- en: '![](assets/c4710d0e-3940-4c79-8d3a-4822a3b367eb.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4710d0e-3940-4c79-8d3a-4822a3b367eb.png)'
- en: 'In the following screenshot, we see Tab 2 and the widget from `button_and_label.py`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们看到选项卡2和来自`button_and_label.py`的小部件：
- en: '![](assets/3940dbae-3c1c-4762-9ca2-ddab507b1055.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3940dbae-3c1c-4762-9ca2-ddab507b1055.png)'
- en: Building a cryptocurrency wallet
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建加密货币钱包
- en: Now that you have an understanding of other features of Qt for Python library,
    let's start to build a desktop cryptocurrency wallet. Since this is a complex
    application, we should not put everything in one file; instead, we will separate
    it into many files. We even separate the many files into different directories.
    We also want to keep this application basic enough for the purpose of a tutorial.
    Consequently, we will not put a lot of features in this application. This cryptocurrency
    wallet can create new accounts, send ethers to another account, and watch ERC20
    tokens so that we can later send some token coins to another account. However,
    it will not have complete features that you would expect from a proper cryptocurrency
    wallet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Qt for Python库的其他功能，让我们开始构建一个桌面加密货币钱包。由于这是一个复杂的应用程序，我们不应该将所有东西都放在一个文件中；相反，我们将其分成许多文件。我们甚至将许多文件分成不同的目录。我们还希望将此应用程序保持足够基本，以用于教程的目的。因此，我们不会在此应用程序中放置很多功能。这个加密货币钱包可以创建新账户，向另一个账户发送以太币，并监视ERC20代币，以便稍后将一些代币发送到另一个账户。但它不会具有您从正式加密货币钱包中期望的完整功能。
- en: 'First, let''s create a project directory and its inner directory using the
    following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令创建项目目录及其内部目录：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The main application, main library, and its configuration files are put in the
    main directory, which is the `wallet` directory. Some icons to spice up the UI
    of the application are put inside the `icons` directory. The avatar images are
    put inside the `images` directory. The test files are put inside the `tests` directory.
    The library files that are not related to blockchain and the UI are put inside
    the `tools` directory. The thread classes are put inside the `wallet_threads`
    directory. Finally, the child widgets of the main widget are put inside the `wallet_widgets`
    directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序、主库及其配置文件放在主目录`wallet`中。一些用于提升应用程序UI的图标放在`icons`目录中。头像图像放在`images`目录中。测试文件放在`tests`目录中。与区块链和UI无关的库文件放在`tools`目录中。线程类放在`wallet_threads`目录中。最后，主小部件的子小部件放在`wallet_widgets`目录中。
- en: Blockchain class
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链类
- en: Let's create a blockchain interface code in `wallet` and name the script `blockchain.py`.
    This file is responsible for connecting to the blockchain. Its responsibilities
    include checking the balance of the account, getting local accounts, sending transactions,
    and getting token information. By putting all blockchain functions inside one
    class or file, it is easier for us to debug the problem, to test the implementations,
    and to develop the functionalities. Go to [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet)
    and refer to the `blockchain.py` code file for this section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`wallet`中创建一个名为`blockchain.py`的区块链接口代码文件。这个文件负责连接到区块链。它的职责包括检查账户余额，获取本地账户，发送交易以及获取代币信息。通过将所有区块链功能放在一个类或文件中，我们更容易调试问题，测试实现，并开发功能。转到[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet)并参考本节的`blockchain.py`代码文件。
- en: This blockchain class has 10 methods to interact with the blockchain. In addition,
    it also has the generic `json` interface of the ERC20 token.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个区块链类有10个方法来与区块链交互。此外，它还具有ERC20代币的通用`json`接口。
- en: 'Let''s discuss this blockchain class file on a line-by-line basis:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论这个区块链类文件：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After importing the required libraries, we create two named tuples. So, why
    do we want to create these named tuples? Basically, we do this to avoid errors.
    Having errors in a cryptocurrency wallet is expensive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所需的库之后，我们创建了两个命名元组。那么，为什么我们要创建这些命名元组呢？基本上，我们这样做是为了避免错误。在加密货币钱包中出现错误是很昂贵的。
- en: 'Imagine you have the following function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有以下函数：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You execute the function as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样执行这个函数：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you swap the sender and the destination, in the worst case scenario, you
    get an unhandled exception and the program stops because the private key does
    not match the sender. However, what if you swap the amount and the fee? In this
    case, you send the small amount to someone with a very high fee. There are many
    ways to avoid this mistake. For example, you could use a keyword argument, as
    given in the following code block, or you could use a named tuple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你交换了发送方和接收方，在最坏的情况下，你会得到一个未处理的异常，程序会停止，因为私钥与发送方不匹配。但是，如果你交换了金额和费用呢？在这种情况下，你会向某人发送少量的代币，但支付了非常高的费用。有许多方法可以避免这个错误。例如，你可以使用关键字参数，就像下面的代码块中所示，或者你可以使用命名元组：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s move on to the `json` interface of the ERC20 token smart contract.
    This is not required when we want to send ethers: it is only required when we
    want to send token coins:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论ERC20代币智能合约的`json`接口。当我们想发送以太币时，这是不需要的：只有当我们想发送代币时才需要。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you are aware, in order to interact with a smart contract, you need the
    `json` interface (`abi`) of the smart contract. You may be wondering how we get
    this `json` interface. This is achieved through the compilation output of the
    ERC20 token smart contract. It does not matter what the name, decimal number,
    and the symbol are. As long as the interface is from the smart contract that fulfills
    the ERC20 standard, we should get the correct interface. I decided to put the
    interface in the same file as the `Blockchain` class in order to simplify matters.
    However, you could put the interface in the `json` file, and then load the `json`
    file in the `Blockchain` class file. Then, we move on to the definition of the `Blockchain`
    class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，为了与智能合约交互，你需要智能合约的`json`接口（`abi`）。你可能想知道我们如何获得这个`json`接口。这是通过ERC20代币智能合约的编译输出实现的。不管名称、小数点数量和符号是什么，只要接口来自满足ERC20标准的智能合约，我们就应该得到正确的接口。我决定将接口放在与`Blockchain`类相同的文件中，以简化事情。但是，你可以将接口放在`json`文件中，然后在`Blockchain`类文件中加载`json`文件。然后，我们继续定义`Blockchain`类：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we start the `Blockchain` class. In its initialization method, we construct
    a `w3` variable to connect to blockchain. We hardcode the connection to blockchain
    with an IPC provider. You can change this configuration if you use `HTTPProvider`,
    for example, or use a different `IPC` file path. The `tokens_file` variable is
    the file that holds all the tokens that we watch.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始`Blockchain`类。在它的初始化方法中，我们构建一个`w3`变量来连接区块链。我们使用IPC提供程序硬编码连接到区块链。如果你使用`HTTPProvider`，或者使用不同的`IPC`文件路径，你可以更改这个配置。`tokens_file`变量是保存我们监视的所有代币的文件。
- en: 'Let''s take a look at the following lines of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下代码行：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We get all local accounts with `w3.eth.accounts`, and then we get the balance
    from each account using `w3.eth.getBalance`. The local accounts are the accounts
    you created in the local node. Usually, the files are kept in the `keystore` directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`w3.eth.accounts`获取所有本地账户，然后使用`w3.eth.getBalance`从每个账户获取余额。本地账户是你在本地节点创建的账户。通常，文件保存在`keystore`目录中。
- en: 'The following code is used to create a new account in the local blockchain
    node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在本地区块链节点中创建一个新账户：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The account file will be encrypted with the password we supply. To see the private
    key, we need to decrypt the account file with the password. However, this is not
    necessary except for backup purposes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 账户文件将使用我们提供的密码进行加密。要查看私钥，我们需要用密码解密账户文件。但是，这除了备份目的外是不必要的。
- en: 'Use the following code to get the balance from an address:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码从一个地址获取余额：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The balance is in wei. Then, we convert the balance in wei to the balance in
    ethers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 余额以wei为单位。然后，我们将wei中的余额转换为以太币中的余额。
- en: 'The following code block is designed to obtain the balance of ERC20 tokens,
    but not the balance of ethers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块旨在获取ERC20代币的余额，而不是以太币的余额：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we get the contract's object that accepts two parameters – the address
    of the smart contract and the json interface. If you remember what you learned
    in `Chapter 8`, *Creating Token in Ethereum*, the ERC20 token needs to have a
    `balanceOf` method. The purpose of this method is to get the balance of the token
    from the account's address.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取接受两个参数的合同对象——智能合同的地址和json接口。如果您还记得在`第8章`中学到的内容，*在以太坊中创建代币*，ERC20代币需要有一个`balanceOf`方法。此方法的目的是从账户地址获取代币的余额。
- en: 'The following code block is used for creating a transaction of sending ethers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于创建发送以太币的交易：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, you get the `nonce`, and then you construct a transaction object. To
    send this transaction using a password, and not a private key, you need to use
    the `sendTransaction` method from the `w3.personal` object. Then, you wait until
    the transaction is confirmed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您获取`nonce`，然后构建一个交易对象。要使用密码而不是私钥发送此交易，您需要使用`w3.personal`对象的`sendTransaction`方法。然后，您等待交易得到确认。
- en: 'After learning about transactions involving the sending of ethers, let''s move
    on to the following code block, which is a method for creating a transaction whereby
    ERC20 tokens are sent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习涉及发送以太币的交易之后，让我们继续下一个代码块，这是用于创建发送ERC20代币的交易的方法：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, you get the `nonce`, and then construct a contract object. Then, you
    call the `transfer` method of this smart contract object. Remember that the ERC20
    token needs to have a `transfer` method to transfer token coins that accepts two
    parameters—the destination and the amount of token coins. Then, you execute this
    method by building a transaction from this method before passing it to the `sendTransaction`
    method from the `w3.personal` object. Finally, we wait for this transaction to
    be confirmed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您获取`nonce`，然后构建一个合同对象。然后，您调用此智能合同对象的`transfer`方法。请记住，ERC20代币需要有一个`transfer`方法来转移代币，该方法接受两个参数——目的地和代币数量。然后，通过从该方法构建交易来执行此方法，然后将其传递给`w3.personal`对象的`sendTransaction`方法。最后，我们等待此交易得到确认。
- en: 'The following code block is used to obtain the information from the token smart
    contract:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于从代币智能合同中获取信息：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we create a contract object. Then, to get the name, symbol and total
    supply, we access the `name`, `symbol`, and `totalSupply`methods from the smart
    contract. Because the name and symbol are byte objects, we need to decode it to
    string. We wrap this information in a tuple named `TokenInformation`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个合同对象。然后，为了获取名称、符号和总供应量，我们从智能合同中访问`name`、`symbol`和`totalSupply`方法。因为名称和符号是字节对象，我们需要将其解码为字符串。我们将这些信息封装在一个名为`TokenInformation`的元组中。
- en: 'The following code is a convenient way of wrapping a token information dictionary
    inside a named `tuple`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一种方便的方式，用于在命名的`tuple`中封装代币信息字典：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code is used to get all tokens that we''re watching from the
    configuration file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于从配置文件中获取我们正在观察的所有代币：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are many smart contracts for tokens out there, but we only want to use
    some of these. Consequently, we save the information pertaining to these token
    smart contracts into a `json` file. Then, we go to the last line of the file,
    which is constructing a `Blockchain` class instance:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多代币的智能合同，但我们只想使用其中的一些。因此，我们将与这些代币智能合同相关的信息保存到一个`json`文件中。然后，我们转到文件的最后一行，即构造一个`Blockchain`类实例：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We do this so that any file that imports this module would get the blockchain
    object straight away and two different files would get the same object. This is
    similar to a singleton pattern.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了让导入此模块的任何文件都可以立即获得区块链对象，并且两个不同的文件将获得相同的对象。这类似于单例模式。
- en: Thread classes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类
- en: Now, let's write thread objects in order to access the blockchain. When creating
    a transaction in a blockchain, you usually want to use a thread or non-blocking
    function. Consequently, every time we want to broadcast a transaction, we use
    these thread classes. These thread classes will use the blockchain object that
    we have described previously.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写线程对象，以便访问区块链。在区块链中创建交易时，通常希望使用线程或非阻塞函数。因此，每当我们想要广播一个交易时，我们使用这些线程类。这些线程类将使用我们之前描述的区块链对象。
- en: 'Use the following code block to create a `balance_thread.py` file in the `wallet_threads`
    directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块在`wallet_threads`目录中创建一个`balance_thread.py`文件：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This thread class is not creating any transaction in the blockchain; its purpose
    is to read the balance of the ethers in every account. So, why do we need a thread
    to read the balance? Is reading the balance supposed to be fast? Imagine you launch
    your cryptocurrency wallet, and you see your balance is 10 ethers. Then, someone
    sends you some ethers. You want your balance to be reflected as soon as possible,
    right? That is the purpose of this thread; it will check the balance of every
    account every 2 seconds. The `kill` method is designed to shut down the application
    and stop the thread from working. It is not mandatory, but if you don't do this,
    you would get an annoying warning stating that the application is destroyed while
    the thread is still running when you close your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程类不会在区块链中创建任何交易；它的目的是读取每个账户中以太币的余额。那么，为什么我们需要一个线程来读取余额呢？读取余额应该是快速的吗？想象一下，当您启动您的加密货币钱包时，您看到您的余额是10个以太币。然后，有人给您发送了一些以太币。您希望您的余额尽快反映出来，对吧？这就是这个线程的目的；它将每2秒检查一次每个账户的余额。`kill`方法旨在关闭应用程序并停止线程的工作。这不是强制性的，但如果您不这样做，当您关闭应用程序时，您会收到一个令人讨厌的警告，指出应用程序在线程仍在运行时被销毁。
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_thread.py`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`wallet_threads`目录中创建另一个线程类，并将其命名为`send_thread.py`：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The purpose of this thread class is to call the `create_send_transaction` method
    of the blockchain object. Before we run the thread, we need to call the `prepareTransaction`
    method of this thread class with a `tuple` parameter named `SendTransaction`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程类的目的是调用区块链对象的`create_send_transaction`方法。在运行线程之前，我们需要使用`SendTransaction`命名的`tuple`参数调用这个线程类的`prepareTransaction`方法。
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_token_thread.py`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`wallet_threads`目录中创建另一个线程类，并将其命名为`send_token_thread.py`：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is similar to the `SendThread` class. The purpose of this thread is to
    call the `create_send_token_transaction` method, which accepts two parameters
    this time, one tuple named `SendTransaction`, and another tuple named `TokenInformation`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`SendThread`类类似。这个线程的目的是调用`create_send_token_transaction`方法，这次接受两个参数，一个名为`SendTransaction`的元组，另一个名为`TokenInformation`的元组。
- en: Identicon and Icons
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Identicon和图标
- en: Now, let's understand what the identicon library is. The purpose of the identicon
    library is to generate a custom avatar image (such as fractal) based on the hash
    of a specific string. If you log in to StackOverflow and you don't set your profile
    image, your avatar would be generated by the identicon library.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下identicon库是什么。identicon库的目的是根据特定字符串的哈希生成一个自定义头像图像（如分形）。如果您登录StackOverflow并且没有设置个人资料图片，您的头像将由identicon库生成。
- en: 'The screenshot will appear like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 截图将会出现如下：
- en: '![](assets/9d388efc-5fb7-4d16-b502-3090b716ac56.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d388efc-5fb7-4d16-b502-3090b716ac56.png)'
- en: 'Or it will appear like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者会出现这样的情况：
- en: '![](assets/4073f739-35ad-41cd-a492-07974e4ea5d4.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4073f739-35ad-41cd-a492-07974e4ea5d4.png)'
- en: This is optional. Our cryptocurrency wallet could run fine without these avatar
    images. This is just to spice up the UI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可选的。我们的加密货币钱包可以在没有这些头像图像的情况下正常运行。这只是为了提升用户界面的吸引力。
- en: Download the file from [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py) into
    the `tools` directory. This is fine work on the part of Shin Adachi. I have modified
    it so that it works with Python 3\. You don't have to understand this file; treat
    it like a third-party library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py)下载文件到`tools`目录。这是Shin
    Adachi的出色工作。我已经修改过了，使其能够在Python 3中运行。您不必理解这个文件；把它当作一个第三方库。
- en: 'Then, create a file inside the `tools` directory, using the following code
    block to utilize this library, and name it `util.py`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`tools`目录中创建一个文件，使用以下代码块来使用这个库，并将其命名为`util.py`：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Basically, this method can render an avatar image using the account address.
    This serves to make an application a bit more attractive. Consequently,when you
    create an account, you get an avatar that is unique according to your address.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这种方法可以使用账户地址来渲染头像图像。这有助于使应用程序更具吸引力。因此，当您创建一个账户时，您会得到一个根据您的地址而独一无二的头像。
- en: 'Then, download a number of icons in the `icons` folder. You need two of these:
    `ajax-loader.gif` and `copy.svg`. You can download `copy.svg` from the free icon
    website. Any icon showing a copying action should do just fine. Then, you can
    download `ajax-loader.gif` from [http://ajaxload.info/](http://ajaxload.info/).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`icons`文件夹中下载一些图标。您需要其中的两个：`ajax-loader.gif`和`copy.svg`。您可以从免费图标网站下载`copy.svg`。任何显示复制操作的图标都可以。然后，您可以从[http://ajaxload.info/](http://ajaxload.info/)下载`ajax-loader.gif`。
- en: Building widgets
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建小部件
- en: 'Let''s create our main application using the following code block. This is
    the main entry for our cryptocurrency wallet. Name it `wallet.py`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码块创建我们的主应用程序。这是我们的加密货币钱包的主入口。将其命名为`wallet.py`：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`WalletWidget` is a tabbed window. There are three tabs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalletWidget`是一个带有选项卡的窗口。有三个选项卡：'
- en: The first tab is designed to hold an account widget. This widget is responsible
    for managing accounts (listing accounts and creating a new account).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项卡旨在容纳一个账户小部件。该小部件负责管理账户（列出账户和创建新账户）。
- en: The second tab is designed to hold a widget that a user can use to create a
    transaction to send ethers or ERC20 tokens. Anything to do with sending ethers
    or tokens is done in this widget.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个选项卡旨在容纳一个小部件，用户可以使用它来创建发送以太币或ERC20代币的交易。任何涉及发送以太币或代币的操作都是在这个小部件中完成的。
- en: The third tab is used to hold token widgets. This widget is responsible for
    watching ERC20 tokens. Watching ERC20 tokens means getting the information from
    the ERC20 custom token smart contract and making these tokens capable of being
    spent in the sending transaction widget.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个选项卡用于容纳令牌小部件。该小部件负责监视ERC20代币。监视ERC20代币意味着从ERC20自定义代币智能合约获取信息，并使这些代币能够在发送交易小部件中被花费。
- en: These three widgets will be defined in other files that will be discussed later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个小部件将在其他文件中定义，稍后将讨论。
- en: The `killThreads` method is optional. If you don't use this method, you will
    get alerts after you close the application because the thread that the application
    created has not finished its business.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`killThreads`方法是可选的。如果您不使用这个方法，当您关闭应用程序时，您将会收到警报，因为应用程序创建的线程尚未完成其任务。'
- en: Account widget
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户小部件
- en: Now, let's create the first widget in the first tab of this tabbed window. Put
    the file inside the `wallet_widgets` directory and name it `account_widget.py`.
    You will then get the full code file from the following link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在选项卡窗口的第一个选项卡中创建第一个小部件。将文件放入`wallet_widgets`目录，并将其命名为`account_widget.py`。然后，您可以从以下链接获取完整的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets)。
- en: As mentioned previously, this widget will show up in the first tab of the wallet
    tabbed window. In this tab, you will acquire listing accounts and create new account
    functionalities.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此小部件将显示在钱包选项卡窗口的第一个选项卡中。在此选项卡中，您将获得列出帐户和创建新帐户功能。
- en: 'Use the following code to import many types of widgets and classes from `PySide2`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码从`PySide2`导入许多类型的小部件和类：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also import the `blockchain` object and the `render_avatar` method, among
    other things. In addition, we will use the `balance_thread` instance, which is
    a thread to update our account's balance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了`blockchain`对象和`render_avatar`方法等其他内容。此外，我们将使用`balance_thread`实例，这是一个用于更新帐户余额的线程。
- en: 'Use the following code block to create a button that allows us to create an
    account within the widget:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块创建一个按钮，允许我们在小部件内创建一个帐户：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All of these accounts will be put in the `accounts_layout` vertical box layout.
    We get all local accounts from the blockchain object, and then we use the `addAccountToWindow`
    method to put this account in the accounts layout. After this, we put the button
    and `accounts_layout` in the main layout. Lastly, we connect the slot for the `BalanceThread`
    thread instance to the `_updateBalances` method and run the thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些帐户将放在`accounts_layout`垂直框布局中。我们从区块链对象中获取所有本地帐户，然后使用`addAccountToWindow`方法将此帐户放入accounts布局中。之后，我们将按钮和`accounts_layout`放入主布局中。最后，我们将`BalanceThread`线程实例的槽连接到`_updateBalances`方法并运行该线程。
- en: 'Use the following code to launch the input dialog and request the password:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码启动输入对话框并请求密码：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we call the `create_new_account` method of the `blockchain` object. The
    address of the new account will be sent to the `_addAccountToWindow` method, which
    will include the new account information in the vertical box layout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`blockchain`对象的`create_new_account`方法。新帐户的地址将被发送到`_addAccountToWindow`方法，该方法将在垂直框布局中包含新帐户信息。
- en: 'Next, we use the following code block to copy the address of the account to
    the clipboard:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码块将帐户的地址复制到剪贴板：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we get the clipboard object and copy the content to it. Consequently,
    in every piece of account information, there will a button that is connected to
    this method. First, however, we will show the information for this copying action
    in a tooltip. `Qcursor.pos()` is the our mouse's position. The `showText` method
    of `QtoolTip` is used to show the tooltip.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取剪贴板对象并将内容复制到其中。因此，在每个帐户信息中，都将有一个按钮连接到此方法。然而，我们将首先在工具提示中显示此复制操作的信息。`Qcursor.pos()`是我们鼠标的位置。`QtoolTip`的`showText`方法用于显示工具提示。
- en: 'There are four main widgets—the account''s address label, the button to copy
    the address of the account, the balance of this account''s label, and the avatar
    image. To display the avatar image, we can use a label. But instead of the `setText`
    method, we use the `setPixmap` method, as provided in the following code block:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的小部件——帐户地址标签、复制帐户地址的按钮、此帐户余额的标签和头像图片。为了显示头像图片，我们可以使用一个标签。但是我们使用`setPixmap`方法而不是`setText`方法，如下面的代码块中所提供的：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`setPixmap` accepts the `Qpixmap` object. If `resize_parent` is true, then
    we will increase the height of the window. We access the main window, which is
    the tabbed window, with a method called `parentWidget` . This has to be chained
    and called twice, like `self.parentWidget().parentWidget()`. The first parent
    widget is the stack view. A tabbed widget is built using the stack view.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPixmap`接受`Qpixmap`对象。如果`resize_parent`为true，则我们将增加窗口的高度。我们使用名为`parentWidget`的方法访问主窗口，即选项卡窗口。这必须链接并调用两次，如`self.parentWidget().parentWidget()`。第一个父窗口是堆栈视图。选项卡小部件是使用堆栈视图构建的。'
- en: 'Use the following code to call the `kill()` method of the `BalanceThread` instance:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码调用`BalanceThread`实例的`kill()`方法：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will tell the thread to stop its task.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉线程停止其任务。
- en: 'The next method is used by the thread instance to update the balance:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是由线程实例用于更新余额的：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`balance_widgets[account]` holds a balance label for a specific account.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`balance_widgets[account]`保存特定帐户的余额标签。'
- en: Sending a transaction widget
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送交易小部件
- en: The second widget is `SendWidget`. Create a file named `send_widget.py` inside
    the `wallet_widgets` directory. This widget is responsible for sending ethers
    or coins from the ERC20 token. For the full code in this section, go to the following
    GitLab link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个小部件是`SendWidget`。在`wallet_widgets`目录中创建一个名为`send_widget.py`的文件。此小部件负责从ERC20令牌发送以太币或硬币。有关此部分的完整代码，请转到以下GitLab链接：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets)。
- en: This widget is the most complex in the tabbed window. In this widget, we need
    to select the account of the sender, and then, based on that account, we need
    to display the balance of ethers or coins relative to the ERC20 token for this
    account. Whether or not the balance is displayed in ethers or ERC20 tokens is
    decided based on whether Ethereum or the ERC20 token is selected in another part
    of this widget. We also need to add a line edit so people can fill in the destination
    address. In addition, we need a way to choose the fee because sometimes, people
    don't mind paying a higher fee so that their transaction is processed faster.
    Then, there is a button to launch an input dialog that requests the password so
    we can create a transaction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件是选项卡窗口中最复杂的小部件。在此小部件中，我们需要选择发送方的帐户，然后根据该帐户显示与此帐户相关的以太币或ERC20令牌的余额。余额显示为以太币或ERC20令牌取决于在此小部件的另一部分中选择了以太坊还是ERC20令牌。我们还需要添加一个行编辑，以便人们可以填写目标地址。此外，我们需要一种选择费用的方式，因为有时人们不介意支付更高的费用，以便他们的交易能够更快地得到处理。然后，有一个按钮启动输入对话框，请求密码，以便我们可以创建交易。
- en: 'To import widgets and classes from the `PySide2` library, use the following
    code block:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`PySide2`库导入小部件和类，请使用以下代码块：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We also imported other things as well, such as tools to render an avatar, methods
    to interact with the blockchain, and the thread classes that create transactions
    and retrieve information regarding tokens.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了其他东西，比如渲染头像的工具，与区块链交互的方法，以及创建交易和检索有关代币信息的线程类。
- en: 'Use the following code to initialize the `SendWidget` class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码初始化`SendWidget`类：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`tokens_file` holds the `tokens.json` file. This configuration file is the
    file that contains all ERC20 tokens that we watch. `token_name` is set to `Ethereum`
    initially because, by default, our cryptocurrency wallet is supposed to handle
    Ethereum transactions, and not ERC20 tokens. In this widget, we can send ethers
    or custom tokens. Then, we call six methods to establish six inner layouts. This
    widget is composed of six layouts. The sender layout is used to choose the account
    of a sender. The destination layout is a field designed to hold the destination
    account of the transaction. The progress layout, which is hidden by default, is
    used to show that the transaction is still being confirmed after just sending
    the transaction. The token layout is used to choose whether you want to send ERC20
    token or ethers. In addition, the send layout is used to hold the send button,
    and the slider layout is used to hold the slider to choose the transaction fee.
    We also create two thread instances—the first is used to send ethers, while the
    second is used to send ERC20 tokens. For the main layout, we use the grid layout.
    This layout is used because it is easier to lay out our widgets.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokens_file`保存了`tokens.json`文件。这个配置文件包含了我们监视的所有ERC20代币。`token_name`最初设置为`Ethereum`，因为默认情况下，我们的加密货币钱包应该处理以太坊交易，而不是ERC20代币。在这个小部件中，我们可以发送以太币或自定义代币。然后，我们调用六种方法来建立六种内部布局。这个小部件由六种布局组成。发送方布局用于选择发送方的账户。目的地布局是一个设计用来保存交易目的地账户的字段。进度布局默认情况下是隐藏的，用于显示在发送交易后交易仍在确认中。代币布局用于选择您是要发送ERC20代币还是以太币。此外，发送布局用于保存发送按钮，滑块布局用于保存选择交易费用的滑块。我们还创建了两个线程实例——第一个用于发送以太币，而第二个用于发送ERC20代币。对于主布局，我们使用网格布局。这种布局更容易布置我们的小部件。'
- en: 'The following code block is a method that can be used to set up the sender
    layout section for creating a transaction widget:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置创建交易小部件的发送方布局部分的方法：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you have a combobox to choose the local account, an avatar image, and
    a balance label. If you change the value of the combobox, this would automatically
    change the text on the balance label and the avatar image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有一个下拉框来选择本地账户，一个头像图像和一个余额标签。如果您更改下拉框的值，这将自动更改余额标签和头像图像上的文本。
- en: 'The following code block is the method used to set up the destination layout
    section:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置目的地布局部分的方法：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This method mainly holds a line edit. You paste or type the destination's address
    in this line edit.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法主要是一个行编辑。您可以在这个行编辑中粘贴或输入目的地的地址。
- en: 'The following code block is a method for setting up the token layout section:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置代币布局部分的方法：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This section has an avatar for a token, the combobox to choose Ethereum or
    other ERC20 tokens, and the total supply of the ERC20 token. If we change the
    value of combobox, it will change the avatar and the total supply label. The avatar
    of the token is derived from the address of the token smart contract. However,
    Ethereum does not have the address, since it is the platform itself. So, for Ethereum,
    we use the following dummy address: `0xcccccccccccccccccccccccccccccccccccccccc`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分有一个代币的头像，下拉框可以选择以太坊或其他ERC20代币，以及ERC20代币的总供应量。如果我们改变下拉框的值，它将改变头像和总供应量标签。代币的头像来自代币智能合约的地址。然而，以太坊没有地址，因为它本身就是平台。因此，对于以太坊，我们使用以下虚拟地址：`0xcccccccccccccccccccccccccccccccccccccccc`。
- en: 'The following code block is the method used to set up the progress layout section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置进度布局部分的方法：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Basically, this is a label used to show that the transaction is being confirmed.
    In this section, there is a label used to display the loading activity indicator.
    First, we initialize the `QMovie` object that accepts a `gif` file. Then, you
    set this `Qmovie` to a label by calling the `setMovie` method of that label.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是一个标签，用于显示交易正在确认中。在这一部分，有一个标签用于显示加载活动指示器。首先，我们初始化一个接受`gif`文件的`QMovie`对象。然后，通过调用该标签的`setMovie`方法，将这个`Qmovie`设置到一个标签上。
- en: 'The following code block is a method to set up the send layout section of the
    widget to create a transaction:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置发送布局部分的方法，用于创建交易的小部件：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This section is used to hold a send button, which is connected to a callback.
    This send button is customized to make it appear more attractive by using background
    colors. The way you change the color for the button is simple:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分用于保存一个发送按钮，与一个回调连接。这个发送按钮是定制的，通过使用背景颜色使其看起来更有吸引力。更改按钮的颜色的方法很简单：
- en: 'Use the following code to get the palette object from the button and then set
    the color to that palette object:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码从按钮获取调色板对象，然后将颜色设置为该调色板对象：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we use predefined colors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用预定义的颜色。
- en: 'The following code block is used to create a slider and a label indicating
    what value we choose in a slider:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于创建滑块和指示我们在滑块中选择了什么值的标签：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The purpose of the slider is to choose the fee of the transaction. If you choose
    the bigger fee, the transaction will be processed faster.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块的目的是选择交易的费用。如果您选择更高的费用，交易将更快地处理。
- en: 'The following code block is used to choose Ethereum or the ERC20 token:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于选择以太坊或ERC20代币：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is the callback that will be executed if we change the value of the token
    combobox. We update the balance of ethers or the token of the account here. After
    doing so, we change the avatar of the token. We also update the total supply of
    the token.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们更改代币组合框的值时将执行的回调。我们在这里更新帐户的以太币或代币余额。这样做后，我们更改代币的头像。我们还更新了代币的总供应量。
- en: 'The following code block is used to choose the sender account:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于选择发送方帐户：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is the callback that will be executed if we change the value of the sender
    combobox. Here, we update the balance of ethers or tokens of the account and then
    we change the avatar of the account based on the address.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们更改发送者组合框的值时将执行的回调。在这里，我们更新帐户的以太币或代币余额，然后根据地址更改帐户的头像。
- en: 'The following code block is the method used to set the balance of the account
    to the label:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于将帐户余额设置到标签的方法：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this `updateBalanceLabel` method, we set the text for `balance_label` with
    the `get_balance` method from the `blockchain` object if we are working with Ethereum.
    If we are working with ERC20 tokens, we use the `get_token_balance` method from
    `blockchain`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateBalanceLabel`方法中，如果我们使用以太坊，我们使用`blockchain`对象的`get_balance`方法设置`balance_label`的文本。如果我们使用ERC20代币，我们使用`blockchain`的`get_token_balance`方法。
- en: 'The following code block is the method used to set the avatar:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于设置头像的方法：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This method is used to set the avatar of both the token and the account.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于设置代币和帐户的头像。
- en: 'The following code block is the callback that will be executed when we change
    the value of the fee slider:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是当我们更改费用滑块的值时将执行的回调：
- en: '[PRE71]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following code block is the method that will be executed when we click
    the Send button:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是单击发送按钮时将执行的方法：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we will be asked to provide the password in an input dialog. If we hit
    Ok, then we will set the progress label and loading activity indicator as visible.
    We construct a tuple named `SendTransaction` and then send it to the thread class
    objects that handle sending transactions either for Ethereum or ERC20 tokens.
    Finally, we run the thread.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将被要求在输入对话框中提供密码。如果我们点击确定，那么我们将设置进度标签和加载活动指示器为可见。我们构造了一个名为`SendTransaction`的元组，然后将其发送到处理发送以太币或ERC20代币交易的线程类对象。最后，我们运行线程。
- en: 'The following code block is used to hide the progress label (loading indicator)
    when the transaction is finished:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于在交易完成时隐藏进度标签（加载指示器）：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This method will be called by the thread instance after finishing the job (either
    by sending ethers or coins as ERC20 tokens).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在线程实例完成工作后被调用（无论是发送以太币还是作为ERC20代币发送硬币）。
- en: Token widget
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代币小部件
- en: The last widget is the token widget. This widget is responsible for watching
    the ERC20 token. Create `token_widget.py` inside the `wallet_widgets` directory.
    Go to the following GitLab link provided for the full code file in this section: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的小部件是代币小部件。该小部件负责监视ERC20代币。在`wallet_widgets`目录中创建`token_widget.py`。转到提供完整代码文件的以下GitLab链接：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets)。
- en: 'This last widget is in the third tab of the main widget. The purpose here is
    to watch the ERC20 token and list all ERC20 tokens that have been watched. There
    is a button to launch an input dialog,a button to ask for the address of the ERC20
    smart contract token, and then there is a vertical layout that displays all ERC20
    tokens:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的小部件在主小部件的第三个选项卡中。这里的目的是监视ERC20代币并列出所有已监视的ERC20代币。有一个按钮来启动输入对话框，一个按钮来请求ERC20智能合约代币的地址，然后有一个垂直布局来显示所有ERC20代币：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As usual, we import many things, such as rendering the avatar tool, the blockchain
    object to establish information regarding tokens from the blockchain, and a number
    of libraries to deal with filesystems. On top of that, we also import UI classes
    from `PySide2`, such as many types of widgets, and classes to attach the callback
    to widgets. Beside UI classes, we import non-UI classes from PySide2, such as
    `slot` and `signal`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入了许多东西，比如渲染头像工具、区块链对象以建立有关区块链上代币的信息，以及一些处理文件系统的库。除此之外，我们还从`PySide2`导入了UI类，比如许多类型的小部件，以及用于将回调附加到小部件的类。除了UI类，我们还从PySide2导入了非UI类，比如`slot`和`signal`。
- en: 'Use the following code block for the initialization method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块进行初始化方法：
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this initialization method, we create a button that is linked to the `watchNewToken`
    method, and then a vertical box layout to hold all token information. We also
    declare the `tokens_file` object, which holds the `tokens.json` configuration
    file. This file keeps  track of all ERC20 token-related information.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始化方法中，我们创建一个按钮，链接到`watchNewToken`方法，然后创建一个垂直框布局来容纳所有代币信息。我们还声明了`tokens_file`对象，它保存了`tokens.json`配置文件。该文件跟踪所有与ERC20代币相关的信息。
- en: 'Use the following code block to create an avatar image, a token name label,
    a token symbol label, and a token total supply label for each piece of token information:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块为每个代币信息创建一个头像图像、代币名称标签、代币符号标签和代币总供应标签：
- en: '[PRE76]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If `resize_parent` is true, this means we add token information through a dialog.
    In other words, we ask the parent window to increase its height. If `resize_parent`
    is `false`, this means that this method is called from the start.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`resize_parent`为true，这意味着我们通过对话框添加代币信息。换句话说，我们要求父窗口增加其高度。如果`resize_parent`为`false`，这意味着此方法是从开始调用的。
- en: 'The following code block is a method used to request the address of the smart
    contract with a dialog:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是用于使用对话框请求智能合约地址的方法：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If a user confirms the address of the smart contract, we get the token information
    using the `get_information_of_token` method of the `blockchain` object. This token's
    information is then put in the vertical box layout. Later, we save the token's
    information in the json file. This is done so that we can load this token information
    when we restart the application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确认了智能合约的地址，我们将使用`blockchain`对象的`get_information_of_token`方法获取代币信息。然后，将这个代币的信息放在垂直框布局中。稍后，我们将代币的信息保存在json文件中。这样做是为了在重新启动应用程序时可以加载这些代币信息。
- en: 'Before you can launch your cryptocurrency wallet, make sure you run a private
    chain first and then deploy one or two ERC20 smart contracts in this private chain.
    You can use the ERC20 smart contract source code in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml),
    *Creating Token in Ethereum*. After doing this, run the desktop cryptocurrency
    wallet using the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动加密货币钱包之前，请确保首先运行私有链，然后在私有链中部署一个或两个ERC20智能合约。您可以在[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)中使用ERC20智能合约源代码，*在以太坊中创建代币*。完成此操作后，使用以下命令运行桌面加密货币钱包：
- en: '[PRE78]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will get the final output shown in the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在以下截图中看到最终输出：
- en: '![](assets/c2647ef2-3ccf-4947-8e4f-1bdf78b2adf3.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2647ef2-3ccf-4947-8e4f-1bdf78b2adf3.png)'
- en: In the preceding screenshot, we see the Account tab showing the balance of each
    account. Make sure you have at least two accounts. If not, create one from this
    tab by clicking the Create Account button.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们看到账户选项卡显示了每个账户的余额。确保至少有两个账户。如果没有，请通过单击“创建账户”按钮从此选项卡创建一个。
- en: 'The following screenshot shows the Send tab, where we can send ethers to any
    account we choose:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了发送选项卡，我们可以向任何我们选择的账户发送以太币：
- en: '![](assets/ce0eb96c-c4ee-46fb-98a9-6817b9e0e66c.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce0eb96c-c4ee-46fb-98a9-6817b9e0e66c.png)'
- en: 'In the second tab, try to send ethers. It will take some time before the transaction
    is confirmed. Consequently, try sending ERC20 tokens to another account (but you
    have to add the ERC20 token first in the third tab), as shown in the following
    screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个选项卡中，尝试发送以太币。在交易确认之前需要一些时间。因此，尝试向另一个账户发送ERC20代币（但您必须首先在第三个选项卡中添加ERC20代币），如下截图所示：
- en: '![](assets/da2cf602-c46f-4701-8b5d-edc36a383fbb.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da2cf602-c46f-4701-8b5d-edc36a383fbb.png)'
- en: 'Finally, in the third tab, try to watch a token smart contract. Put the address
    of the smart contract address in the dialog when you click the Watch Token button:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第三个选项卡中，尝试观察一个代币智能合约。单击“观察代币”按钮时，在对话框中放入智能合约地址：
- en: '![](assets/ce1b1bdf-c3d1-4191-9c4d-e52b31190c6c.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce1b1bdf-c3d1-4191-9c4d-e52b31190c6c.png)'
- en: Your token will be reflected in the second tab.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代币将在第二个选项卡中反映出来。
- en: Test
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Let's write tests for this GUI application. These tests should not be exhaustive.
    We will create three tests, one for each tab. We will not create a test for the
    non-UI part of the application. This section is simply here to demonstrate how
    to test a UI application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个GUI应用程序编写测试。这些测试不应该是详尽无遗的。我们将创建三个测试，每个选项卡一个。我们不会为应用程序的非UI部分创建测试。本节只是为了演示如何测试UI应用程序。
- en: 'The first test for the first tab is an account widget test. Name the test `test_account.py`
    and save it inside the `tests` directory. The following code block is the test
    script:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项卡的第一个测试是一个账户小部件测试。将测试命名为`test_account.py`，并将其保存在`tests`目录中。以下代码块是测试脚本：
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this test, we test how many children the accounts layout has before we click
    a button, launch a dialog, fill in a password, and then click OK. Then, we check
    the number of children again after we create a new account. The number should
    have increased by one. For this test, we patch the dialog to make it easier for
    testing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们测试了在点击按钮、启动对话框、填写密码，然后点击确定之前，账户布局有多少子项，然后我们再次检查创建新账户后子项的数量。数量应该增加一个。为了进行这个测试，我们对对话框进行了补丁，以便更容易进行测试。
- en: This test is not comprehensive. We did not test the fail case. I will leave
    that as an exercise for the reader.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试并不全面。我们没有测试失败的情况。我将把这留给读者作为练习。
- en: 'The test for the second tab is a sending transaction widget test. Name the
    test file `test_send.py` and save it inside the `tests` directory. The test script
    is given in the following code block (refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py)):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项卡的测试是发送交易小部件测试。将测试文件命名为`test_send.py`，并将其保存在`tests`目录中。测试脚本如下所示（有关完整代码，请参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py)）：
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this test, we check the balance of the second account in the combobox. This
    second account will be the destination account. Here, we read the balance from
    the label and then we change the value of the combobox back to the first account,
    which will be the sender. After that, we set the destination account's address
    to the destination line edit. We then set the amount of ethers in the amount line
    edit and click the Send button, but remember, we need to patch the input dialog.
    Finally, we wait around 20 seconds before changing the account combobox's value
    again to be the second account. We retrieve the balance from the label and then
    we compare the difference between the old value and the new value, which should
    be 10 ethers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们检查了组合框中第二个账户的余额。这个第二个账户将是目标账户。在这里，我们从标签中读取余额，然后将组合框的值改回第一个账户，这将是发送方。之后，我们将目标账户的地址设置为目标行编辑。然后我们在金额行编辑中设置以太币的数量，并点击发送按钮，但请记住，我们需要对输入对话框进行补丁。最后，在将账户组合框的值再次更改为第二个账户之前，我们等待大约20秒。我们从标签中检索余额，然后比较旧值和新值之间的差异，应该是10以太币。
- en: 'The test for the third tab is for testing a token widget. Name this `test_token.py`
    and save it inside the `tests` directory. The test script for this test is given
    in the following code block:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项卡的测试是为了测试令牌小部件。将其命名为`test_token.py`并保存在`tests`目录中。此测试的测试脚本如下所示：
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: First, we load the address of the token smart contract in the `address.txt`
    file because we don't want to hardcode it in the test file. The strategy is the
    same as in the test of the account widget. We check how many children the vertical
    box layout has. After that is done, we click the button, launch a dialog, fill
    in the address of the smart contract, and then click OK. Next, we check again
    how many children the vertical box layout has. The number should have increased
    by 1 again.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将令牌智能合约的地址加载到`address.txt`文件中，因为我们不希望在测试文件中将其硬编码。策略与账户小部件测试中的相同。我们检查垂直框布局有多少子项。完成后，我们点击按钮，启动对话框，填写智能合约的地址，然后点击确定。接下来，我们再次检查垂直框布局有多少子项。这个数字应该再次增加1。
- en: Like I said, this test is actually not complete. We should test the token information
    as well. However, this test is a good start.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的，这个测试实际上并不完整。我们也应该测试令牌信息。但是，这个测试是一个很好的开始。
- en: 'You can run the preceding tests by using the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行前述测试：
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Considerations when building a cryptocurrency wallet
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建加密货币钱包时需要考虑的因素
- en: 'You have now created a desktop cryptocurrency wallet. However, this wallet
    is not yet complete. A cryptocurrency wallet is a vast topic that changes so often
    that a book could be written on this topic alone. There are other features you
    can implement into a cryptocurrency wallet application, such as how many blocks
    have been confirmed for this transaction. In our application, we only wait for
    one transaction, but some users may want to confirm a couple of blocks first.
    If the transaction is confirmed with only one block, there is a slight chance
    that it could be replaced with a longer block. However, after 12 blocks, the transaction
    in the block is pretty much secure and irreversible, as explained in the following
    link: [https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum](https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经创建了一个桌面加密货币钱包。但是，这个钱包还没有完全完成。加密货币钱包是一个广泛的话题，变化如此之快，以至于可以单独写一本书来讨论这个话题。您可以将其他功能实现到加密货币钱包应用程序中，比如已确认的区块数量。在我们的应用程序中，我们只等待一个交易，但有些用户可能想要先确认几个区块。如果交易仅经过一个区块的确认，那么它有一点可能被更长的区块替换。然而，经过12个区块后，区块中的交易基本上是安全且不可逆的，如下面的链接所解释的：[https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum](https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum)。
- en: Our cryptocurrency wallet is a pure cryptocurrency wallet. However, you could
    also add other features to our cryptocurrency wallet that are unrelated to the
    wallet functionality. For example, the Mist cryptocurrency wallet is not just
    a wallet; it is a decentralized application explorer as well. It can also compile
    a smart contract's source code and deploy it to the blockchain.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的加密货币钱包是一个纯粹的加密货币钱包。但是，您也可以向我们的加密货币钱包添加与钱包功能无关的其他功能。例如，Mist加密货币钱包不仅仅是一个钱包；它还是一个去中心化应用程序浏览器。它还可以编译智能合约的源代码并将其部署到区块链上。
- en: There are many features that you should implement if you want to make a fully-fledged
    cryptocurrency wallet. A number of ideas include generating a QR code, an option
    to export an encrypted private key, importing a private key, using a seed phrase
    to generate accounts, the validation of input, and remembering a password for
    a short period of time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要制作一个完整的加密货币钱包，您应该实现许多功能。一些想法包括生成二维码、导出加密私钥的选项、导入私钥、使用种子短语生成账户、输入验证以及记住密码一段时间。
- en: Here, we are building a desktop cryptocurrency wallet. A desktop application
    can have the luxury of a lot of memory and storage. However, if you are building
    a mobile cryptocurrency wallet, this is a different story. For example, a Bitcoin
    desktop cryptocurrency wallet can access the full node locally. However, you cannot
    put a full Bitcoin node on a mobile phone as it is just too big. You could, of
    course, put the full Bitcoin node on the cloud and let the mobile cryptocurrency
    wallet application access that. However, most people don't want to set up a full
    node on the cloud. As a result, any developer of a Bitcoin mobile cryptocurrency
    wallet usually uses **Simplified Payment Verification** (**SPV**). In this way,
    the Bitcoin mobile cryptocurrency wallet does not require a full Bitcoin node
    to be stored on the phone.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在构建一个桌面加密货币钱包。桌面应用程序可以拥有大量的内存和存储空间。但是，如果您正在构建一个移动加密货币钱包，情况就不同了。例如，比特币桌面加密货币钱包可以在本地访问完整节点。但是，您不能将完整的比特币节点放在手机上，因为它太大了。当然，您可以将完整的比特币节点放在云上，让移动加密货币钱包应用程序访问它。但是，大多数人不想在云上设置完整节点。因此，比特币移动加密货币钱包的任何开发者通常使用简化支付验证（SPV）。这样，比特币移动加密货币钱包就不需要在手机上存储完整的比特币节点。
- en: 'If you want to build a cryptocurrency wallet or contribute to existing cryptocurrency
    wallets, you need to bear two things in mind: security and the **user experience**
    (**UX**).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要构建加密货币钱包或为现有的加密货币钱包做出贡献，您需要牢记两件事：安全和用户体验（UX）。
- en: Security
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: A cryptocurrency wallet handles money, so you need to make it secure. Security
    is a complex topic that we will discuss briefly here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币钱包处理资金，因此您需要确保其安全。安全是一个复杂的话题，在这里我们将简要讨论。
- en: Don't install a third-party library just because you can; every library is another
    vector attack. Be conservative in bundling third-party libraries in your application.
    Our cryptocurrency wallet uses libraries from Ethereum GitHub, such as web3.py
    and Populus. That should be fine because they are core libraries. We also use
    the `PySide2` library from the Qt company. This library is a must because without
    a GUI library, there cannot be a GUI application. We also use a third-party library
    to generate an identicon avatar image. We need to be careful here. The library
    is a single file, and I have read it fully to ensure there is no hidden malware.
    Because of that, I can integrate it confidently into our application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅因为可以而安装第三方库；每个库都是另一个攻击向量。在应用程序中慎重打包第三方库。我们的加密货币钱包使用来自以太坊GitHub的库，如web3.py和Populus。这应该没问题，因为它们是核心库。我们还使用Qt公司的`PySide2`库。这个库是必不可少的，因为没有GUI库就不能有GUI应用程序。我们还使用第三方库来生成identicon头像图像。在这里我们需要小心。这个库是一个单一文件，我已经完全阅读过以确保没有隐藏的恶意软件。因此，我可以自信地将其整合到我们的应用程序中。
- en: Use a minimum number of confirmations before declaring that the transaction
    is complete. How many confirmations is good enough depends on your threat and
    risk modelling. Usually, 12 confirmations make the reversing transaction impractical.
    The Mist wallet uses 12 confirmations, while the ZCash wallet uses 10 confirmations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布交易完成之前，请使用最少数量的确认。确认次数足够多取决于您的威胁和风险建模。通常，12次确认会使撤销交易变得不切实际。Mist钱包使用12次确认，而ZCash钱包使用10次确认。
- en: You could also force the user to create a good password when creating an account
    in a cryptocurrency wallet, because most users have a tendency to create an account
    with a bad password. But be careful here; you don't want to annoy them too much.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在创建加密货币钱包的帐户时强制用户创建一个良好的密码，因为大多数用户倾向于使用糟糕的密码创建帐户。但在这里要小心；您不希望过分打扰他们。
- en: User experience
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验
- en: If an application is very secure but very hard to use, it is of no use. As a
    consequence, we need to make it less intimidating for users. The creator of Bitcoin,
    Satoshi Nakamoto, put a lot of thought into user experience when building the
    software. Previously, people used base64 format to convert binary to text. However,
    Satoshi used base58 to represent the Bitcoin address. Base58 is like base64, but
    without characters that cause confusion when it gets printed, such as I (capital
    i) and l (lower L).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序非常安全但使用起来非常困难，那就没有用了。因此，我们需要让用户感到不那么害怕。比特币的创造者中本聪在构建软件时非常注重用户体验。以前，人们使用base64格式将二进制转换为文本。然而，中本聪使用base58来表示比特币地址。Base58类似于base64，但在打印时不会引起混淆的字符，比如I（大写i）和l（小写L）。
- en: Zcash has released a UX guide for designing a cryptocurrency wallet, and this
    can be found at the following link: [https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html](https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html).
    Not everything can be implemented here because Zcash has a private transaction
    that Ethereum does not have. However, other suggestions can be implemented; for
    example, market information. Like it or not, people peg the cryptocurrency price
    to fiat money and it is a good idea to show people what the market price of 1
    ether is. If the network is congested, you should inform the user as well. You
    can suggest that the user waits or increases the transaction fee.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Zcash发布了一个关于设计加密货币钱包的用户体验指南，可以在以下链接找到：[https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html](https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html)。这里并非所有内容都可以实施，因为Zcash有以太坊没有的私人交易。然而，其他建议可以实施；例如，市场信息。不管喜欢与否，人们将加密货币价格挂钩到法定货币上，向人们展示1个以太的市场价格是个好主意。如果网络拥挤，您也应通知用户。您可以建议用户等待或增加交易费用。
- en: If you build an iOS cryptocurrency wallet, you should follow the Apple Human
    Interface Guideline. If you are building an Android cryptocurrency wallet, you
    should follow the Material Design guidelines. Be careful when choosing typography
    and the color to be used. You should do the user interview when designing a cryptocurrency
    wallet. UX is a broad subject. Balancing UX and security is a delicate art. You
    should not ignore UX when building a cryptocurrency wallet.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要构建iOS加密货币钱包，应遵循苹果人机界面指南。如果您要构建Android加密货币钱包，应遵循Material Design指南。在选择排版和颜色时要小心。在设计加密货币钱包时，应进行用户访谈。用户体验是一个广泛的主题。平衡用户体验和安全是一门微妙的艺术。在构建加密货币钱包时不应忽视用户体验。
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have familiarized ourselves with the tabbed view, size
    policy, and the grid layout of `PySide2`. Then, we also learned how to test Qt
    applications. Next, we started to build a desktop cryptocurrency wallet. We divided
    the application into many parts: the blockchain, the thread, the widget, the identicon
    tool, and the test. The blockchain part of the cryptocurrency wallet is based
    on the `web3` and `Populus` libraries and its purpose is to read and create transactions
    in the blockchain. The thread is a middleman between the UI part and the blockchain
    object when creating a transaction. The identicon tool is used to create an avatar
    image based on a specific string (usually the address of the account or the token
    smart contract''s address). The widget part is a tabbed widget that has three
    tabs. The first tab is the account widget, the second tab is the sending transaction
    widget, and the third tab is the token widget. Lastly, we created tests for this
    application.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经熟悉了`PySide2`的标签视图、大小策略和网格布局。然后，我们还学习了如何测试Qt应用程序。接下来，我们开始构建一个桌面加密货币钱包。我们将应用程序分成许多部分：区块链、线程、小部件、标识工具和测试。加密货币钱包的区块链部分是基于`web3`和`Populus`库的，其目的是在区块链中读取和创建交易。线程是在创建交易时，UI部分和区块链对象之间的中间人。标识工具用于根据特定字符串（通常是账户地址或代币智能合约地址）创建头像图像。小部件部分是一个带有三个选项卡的选项卡小部件。第一个选项卡是账户小部件，第二个选项卡是发送交易小部件，第三个选项卡是代币小部件。最后，我们为这个应用程序创建了测试。
- en: In the next chapter, we will start learning a topic beyond the scope of blockchain
    technology. This technology is called IPFS. It is still part of the decentralized
    technology, but this technology will overcome the weakness associated with the
    blockchain technology; in other words, its storage is expensive.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习区块链技术范围之外的主题。这项技术被称为IPFS。它仍然是分散式技术的一部分，但这项技术将克服与区块链技术相关的弱点；换句话说，它的存储是昂贵的。
