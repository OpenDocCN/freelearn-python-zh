- en: Chapter 11. Class Definitions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。类定义
- en: A Python object is an instance of a class. A **class** defines the behavior
    of an object via the method functions. In this chapter, we'll look at creating
    our own classes and our own objects. We'll start by looking at the basics of creating
    classes and objects. Once we've seen the essential tools, we can summarize some
    of the ways that we can class definitions to create objects, and how objects should
    interact to create the behavior we intend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python对象是类的实例。**类**通过方法函数定义了对象的行为。在本章中，我们将查看创建我们自己的类和对象。我们将从查看创建类和对象的基本知识开始。一旦我们看到了基本工具，我们就可以总结一些我们可以使用类定义来创建对象的方法，以及对象应该如何交互以实现我们期望的行为。
- en: We'll look at some elements of more sophisticated class definition. Advanced
    topics will include the concepts of class methods and static methods. An entire
    book can be written on advanced object-oriented programming in Python, so we'll
    take a broad, but shallow, approach to looking at class definitions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看更复杂类定义的一些元素。高级主题将包括类方法和静态方法的概念。关于Python的高级面向对象编程可以写成一整本书，所以我们将采取广泛但浅显的方法来查看类定义。
- en: We'll also look at the built-in abstract base classes. We can use these to simplify
    our own class definitions. In many cases, we have container-like classes that
    can leverage a base class, saving us some programming and assuring a seamless
    fit with other Python features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看内置的抽象基类。我们可以使用这些基类来简化我们自己的类定义。在许多情况下，我们有类似于容器的类，可以利用基类，这样我们可以节省一些编程工作，并确保与其他Python特性的无缝配合。
- en: Creating a class
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个类
- en: The core of the object-oriented program is the class definition. The class statement
    creates an object that is used to create instances of the class. When we create
    a new class, `SomeClass`, we can then use that `SomeClass()` function to create
    objects that share the common definitions of the class. This is the way the built-in
    classes all work; for example, the `int()` function creates an instance of the
    `int` class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象程序的核心是类定义。`class`语句创建了一个对象，用于创建类的实例。当我们创建一个新的类`SomeClass`时，我们可以使用那个`SomeClass()`函数来创建具有类共同定义的对象。这是内置类的工作方式；例如，`int()`函数创建了一个`int`类的实例。
- en: In Python, a `class` statement includes the method functions that describe the
    behavior of each instance. In addition to ordinary methods, there are several
    varieties of "special" methods which are intimately bound to the way Python operates.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`class`语句包括描述每个实例行为的函数方法。除了普通方法外，还有一些与Python操作紧密相关的“特殊”方法。
- en: We aren't obligated—in any formal way—to provide specific attributes (also called
    instance variables) for a class. The instance variables of an object are flexible,
    and are not defined in advance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有义务以任何正式的方式为类提供特定的属性（也称为实例变量）。对象的实例变量是灵活的，并且不是预先定义的。
- en: The initial clause of a `class` statement provides the class name. It can also
    name any superclasses, from which features are inherited. The bulk of the class
    body contains method definitions, created with the indented `def` statements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`语句的初始子句提供了类名。它还可以命名任何超类，从这些超类继承特性。类主体的主要内容包含方法定义，这些定义是通过缩进的`def`语句创建的。'
- en: In some cases, we don't need to provide a suite of statements. We often create
    customized exception classes like this
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不需要提供语句块。我们经常创建像这样的定制异常类
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we've provided a new class name, `MyAppError`, and specified
    that it inherits the features of the `Exception` class. We don't need to make
    any changes to that base definition; since we must provide an indented suite of
    statements, we use the pass statement to complete the syntax of the `class` statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了一个新的类名`MyAppError`，并指定它继承自`Exception`类的特性。我们不需要对该基定义进行任何修改；由于我们必须提供一个缩进的语句块，我们使用`pass`语句来完成`class`语句的语法。
- en: Since this class works like any other exception, we can use statements like
    `raise MyAppError("Some Message")` to raise an instance of this new class of exceptions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类的工作方式与任何其他异常类似，我们可以使用类似`raise MyAppError("Some Message")`的语句来引发这个新异常类的一个实例。
- en: Writing the suite of statements in a class
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中编写语句块
- en: The suite of statements inside a `class` statement is generally a collection
    of method definitions. Each method is a function that's bound to the class. The
    suite of statements can also include assignment statements; these will create
    variables that are part of the class definition as a whole.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 语句内部的语句集通常是一系列方法定义。每个方法都是一个绑定到类的函数。语句集还可以包括赋值语句；这些将创建作为整个类定义一部分的变量。'
- en: 'Here''s a simple class for an (*x*, *y*) coordinate pair:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的用于 (*x*, *y*) 坐标对的类：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've provided a class name, `Point`. We haven't explicitly provided a superclass;
    by default our new class will be a subclass of `object`. By convention, the names
    of most built-in classes, like `object`, begin with lowercase letters. All of
    the other classes that we will define should begin with uppercase letters; hence,
    our name of `Point`. We've also provided a minimal docstring for this class. In
    [Chapter 14](ch14.html "Chapter 14. Fit and Finish – Unit Testing, Packaging,
    and Documentation"), *Fit and Finish – Unit Testing, Packaging, and Documentation*,
    we'll look at expanding this docstring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个类名 `Point`。我们没有明确提供超类；默认情况下，我们的新类将是 `object` 的子类。按照惯例，大多数内置类的名称，如 `object`，以小写字母开头。我们将定义的所有其他类的名称都应该以大写字母开头；因此，我们的名称为
    `Point`。我们还为这个类提供了一个简短的文档字符串。在 [第 14 章](ch14.html "第 14 章。完善 - 单元测试、打包和文档")，*完善
    - 单元测试、打包和文档* 中，我们将探讨扩展这个文档字符串。
- en: We've defined two methods in the class. The first has a special name of `__init__()`.
    The first parameter to any method defined within a class must include the instance
    variable. This variable, usually `self`, will be the reference to the relevant
    object. When we assign a value to the variable `self.x`, this will set the `x`
    attribute of a specific instance of the `Point` class. The instance variable is
    provided implicitly when the method is called.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类中定义了两种方法。第一种方法有一个特殊的名称 `__init__()`。在类中定义的任何方法的第一参数都必须包括实例变量。这个变量，通常称为 `self`，将是相关对象的引用。当我们给变量
    `self.x` 赋值时，这将设置 `Point` 类特定实例的 `x` 属性。当方法被调用时，实例变量会隐式提供。
- en: Instead of any formal definition of the allowed instance variables, Python relies
    on the `__init__()` special method to initialize appropriate instance variables.
    By default, an object can have additional attributes added at any time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不会对允许的实例变量进行任何正式的定义，而是依赖于 `__init__()` 特殊方法来初始化适当的实例变量。默认情况下，一个对象可以在任何时候添加额外的属性。
- en: 'The second method has a special name of `__repr__()`. To be a proper method,
    the first parameter must be the instance variable, `self`. This method must return
    a string that represents our coordinate pair. If we don''t override this special
    method, we''ll get a default string representation that looks like this: `<__main__.Point
    object at 0x100623e10>`. Our implementation uses `self.__class__.__name__` to
    leverage the class of an object so that any subclass will have the proper class
    name inserted into the resulting output.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法有一个特殊的名称 `__repr__()`。为了成为一个正确的方法，第一个参数必须是实例变量 `self`。此方法必须返回一个表示我们的坐标对的字符串。如果我们不重写这个特殊方法，我们将得到一个默认的字符串表示，看起来像这样：`<__main__.Point
    object at 0x100623e10>`。我们的实现使用 `self.__class__.__name__` 来利用对象的类，以便任何子类都将正确的类名插入到输出结果中。
- en: Special method names are ubiquitous in Python. Using them allows a seamless
    integration between our classes and built-in Python features. There are a large
    number of special method names—too many to review in this book. All such names
    begin and end with `__` (two underscores). It's easy to avoid conflicts with this
    naming convention. There is no good reason to use `__` names that are part of
    our application programming; any name in this form that we choose may turn out
    to be a hidden feature of Python.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法名在 Python 中无处不在。使用它们允许我们的类与内置的 Python 功能无缝集成。有大量的特殊方法名——太多以至于无法在本书中全部审查。所有这些名称都以
    `__`（两个下划线）开始和结束。避免与这种命名约定冲突很容易。没有好的理由在我们的应用程序编程中使用 `__` 命名，我们选择的任何这种形式的名称都可能成为
    Python 的隐藏特性。
- en: Note that we did not include placeholder docstrings on the two method functions.
    We've omitted them to keep the example short, and focused on class definitions.
    In general, every method of a class will have a docstring to provide a pithy,
    helpful summary of that method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在两个方法函数中包含占位符文档字符串。我们省略了它们以使示例简短，并专注于类定义。一般来说，类的每个方法都将有一个文档字符串，以提供对该方法的简洁、有用的总结。
- en: In [Chapter 4](ch04.html "Chapter 4. Variables, Assignment and Scoping Rules"),
    *Variables, Assignment and Scoping Rules*, we introduced the concept of a namespace
    as a container for variables. The `self` variable is the object, which is a namespace
    into which we can insert attribute variables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。变量、赋值和作用域规则")中，我们介绍了命名空间的概念，它是一个用于存储变量的容器。`self`变量是对象，它是一个我们可以插入属性变量的命名空间。
- en: 'We can create an instance of a class like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样创建类的实例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've used the class name, `Point`, like a function. An empty object is created
    first. Then the argument values are provided to the `__init__()` special method
    to initialize that empty object. Note that we did not explicitly provide a value
    for the instance variable, `self`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像函数一样使用了类名`Point`。首先创建了一个空对象。然后，将参数值提供给`__init__()`特殊方法以初始化该空对象。请注意，我们没有显式地为实例变量`self`提供值。
- en: 'To execute the `__repr__()` special method, we can do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`__repr__()`特殊方法，我们可以这样做：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When an object is printed, the built-in `repr()` function is applied to get
    a string representation of the object. This built-in function relies on the `__repr__()`
    special method of an object to provide a string representation for the object.
    The object, `p_1`, was implicitly assigned to the instance variable, `self`, when
    evaluating the `__repr__()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印对象时，将应用内置的`repr()`函数以获取对象的字符串表示。此内置函数依赖于对象的`__repr__()`特殊方法来为对象提供字符串表示。在评估`__repr__()`方法时，对象`p_1`被隐式地分配给实例变量`self`。
- en: Our implementation of the `__repr__()` special method produced a string with
    the *x* and *y* coordinate values. We used `.0f` as the format specification,
    providing zero places to the right of the decimal point for the `x` and `y` attributes
    of the self instance variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`__repr__()`特殊方法产生了一个包含*x*和*y*坐标值的字符串。我们使用了`.0f`作为格式说明符，为`self`实例变量的`x`和`y`属性提供了小数点右边的零位。
- en: Using instance variables and methods
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实例变量和方法
- en: 'The `Point` class definition in the previous section included only two special
    methods. We''ll now add a third method that''s not special. Here''s the third
    method for this class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`Point`类定义只包含两个特殊方法。我们现在将添加第三个非特殊方法。这是该类的第三个方法：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method function accepts a single parameter, named `point`. The body of
    this method function uses `math.hypot()` to compute the direct distance between
    two points on the same plane.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法函数接受一个名为`point`的单个参数。此方法函数的主体使用`math.hypot()`计算同一平面上的两点之间的直接距离。
- en: 'Here''s how we can use this function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用此函数的方法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've created two `Point` objects. When the `p_1.dist(p_2)` expression is evaluated,
    the object that was assigned to the `p_1` variable will be assigned to the `self`
    variable. This is the instance of `Point` that's doing the relevant processing.
    The argument to the `dist()` method, assigned to the `p_2` variable, will be assigned
    to the `point` parameter variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个`Point`对象。当评估`p_1.dist(p_2)`表达式时，分配给`p_1`变量的对象将被分配给`self`变量。这是执行相关处理的`Point`实例。分配给`dist()`方法的参数，分配给`p_2`变量，将被分配给`point`参数变量。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we evaluate `obj.method()`, the `obj` object will be the `self` instance
    variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`obj.method()`时，`obj`对象将是`self`实例变量。
- en: 'By default, the objects we create are mutable. Here''s another method of the
    `Point` object—this changes the internal state:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们创建的对象是可变的。这是`Point`对象的另一个方法——这会改变内部状态：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method requires two values which are used to offset the coordinates of
    the `Point` object. The method assigns new values to the `x` and `y` attributes
    of the object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要两个值，这些值用于偏移`Point`对象的坐标。该方法将新值分配给对象的`x`和`y`属性。
- en: 'Here''s what happens when we use this method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用此方法时，会发生以下情况：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've evaluated the offset method associated with object `p_1`. As noted earlier,
    the `self` instance variable will be the same object referred to by `p_1`. When
    we assign a value to `self.x`, that will mutate the object referred to by `p_1`,
    setting `p_1.x`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经评估了与对象`p_1`关联的偏移方法。如前所述，`self`实例变量将与`p_1`引用的相同对象。当我们为`self.x`赋值时，这将改变`p_1`引用的对象，设置`p_1.x`。
- en: Pythonic object-oriented programming
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonic面向对象编程
- en: We've seen a few important features of Python's approach to object-orientation.
    Perhaps the most important is that Python lacks a static binding between variable
    name and type; any type of object can be assigned to any variable. Names are not
    resolved statically by a compiler. Python's dynamic name resolution means that
    we can think of our programs as being entirely generic with respect to class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Python面向对象方法的一些重要特性。也许最重要的是，Python缺乏变量名和类型之间的静态绑定；任何类型的对象都可以赋给任何变量。名称不是由编译器静态解析的。Python的动态名称解析意味着我们可以将我们的程序视为在类方面完全通用的。
- en: When we evaluate `obj.attribute` or `obj.method()`, there are two steps. First
    the name, `attribute` or `method`, must be resolved. Second the referenced attribute
    or method is evaluated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`obj.attribute`或`obj.method()`时，有两个步骤。首先，必须解析名称`attribute`或`method`。其次，评估引用的属性或方法。
- en: For the name resolution step, there are several namespaces that are searched
    to determine what the name means.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于名称解析步骤，有几个命名空间被搜索以确定名称的含义。
- en: The local namespace of the `obj` instance is searched to resolve the name. The
    object's namespace is available as `obj.__dict__`. Attribute names (and values)
    are generally found in the object's own namespace. Methods, on the other hand,
    are not generally part of an object instance.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索`obj`实例的局部命名空间以解析名称。对象的命名空间作为`obj.__dict__`可用。属性名称（和值）通常在对象的自身命名空间中找到。另一方面，方法通常不是对象实例的一部分。
- en: If the name isn't local to the object, the local namespace of the object's class
    is searched. The class namespace is available as `obj.__class__.__dict__`. Method
    names are generally found in the class's namespace. An attribute of the class
    may also be found here.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果名称不是对象的局部名称，则搜索对象类的局部命名空间。类的命名空间作为`obj.__class__.__dict__`可用。方法名称通常在类的命名空间中找到。类的属性也可能在这里找到。
- en: If the name isn't in the class, the superclasses are searched for the name.
    The entire lattice of superclasses is assembled into the `obj.__class__.__mro__`
    value. This defines the **Method Resolution Order** (**MRO**); each of the classes
    in this sequence is searched for the name.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果名称不在类中，将搜索超类以找到名称。整个超类格状结构被组装到`obj.__class__.__mro__`值中。这定义了**方法解析顺序**（**MRO**）；此序列中的每个类都会搜索该名称。
- en: Once the name has been found, Python must determine the value. For names that
    do not refer to callable methods, that is, attributes—the object referred to by
    the name is the value of the attribute. A name that refers to a callable method
    will have argument values bound and it will be evaluated as a function. The result
    of that function is the value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到名称，Python必须确定其值。对于不指向可调用方法的名称，即属性，所引用的对象是该属性的值。指向可调用方法的名称将绑定参数值，并将其作为函数评估。该函数的结果是值。
- en: The "search" described previously relies on the built-in `dict` class. This
    uses hashing to make an extremely fast determination of the presence or absence
    of a name. There's remarkably little performance cost from the sophisticated and
    flexible class behavior available in Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的“搜索”依赖于内置的`dict`类。这使用散列来快速确定名称的存在或不存在。从Python中可用的复杂和灵活的类行为中几乎没有性能成本。
- en: If an object of an inappropriate type is provided at run-time, a method name
    or attribute name won't be found in the object, and an `AttributeError` exception
    is raised. In our preceding example, we can try to evaluate `p_1.copy()`. The
    `copy` name is not defined in our class nor any of the superclasses, so an `AttributeError`
    exception is raised.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行时提供了一个不适当的类型对象，那么在对象中找不到方法名或属性名，将引发`AttributeError`异常。在我们之前的例子中，我们可以尝试评估`p_1.copy()`。`copy`这个名字既没有定义在我们的类中，也没有定义在任何超类中，所以会引发`AttributeError`异常。
- en: Trying to do type casting
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试进行类型转换
- en: While Python variables are merely names attached to objects, the underlying
    objects are very strongly typed. There's no way to assign a new value to the `__class__`
    name that defines the class of an object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python变量仅仅是附加到对象上的名称，但底层对象具有非常严格的类型。无法为新值分配`__class__`名称，该名称定义了对象的类。
- en: '**Type casts** are required by some statically-compiled languages to make it
    possible to create generic data structures. In those languages, we can cast a
    reference from one type to another type. Because of the dynamic nature of method
    resolution, there''s no need for this kind of type casting in Python.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换**在一些静态编译的语言中是必需的，以便能够创建泛型数据结构。在这些语言中，我们可以将一个类型的引用转换为另一个类型的引用。由于方法解析的动态性，Python
    中不需要这种类型的转换。'
- en: 'All Python collections can contain objects of mixed types. We can easily evaluate
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Python 集合都可以包含混合类型的对象。我们可以轻松地评估这一点：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The lambda expression, `x+1`, can be applied to an `int`, a `float`, or a `complex`
    type without resorting to any kind of type cast operation. This works because
    each class provides appropriate special method functions to implement the addition
    of an integer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式 `x+1` 可以应用于 `int`、`float` 或 `complex` 类型，而无需进行任何类型的类型转换操作。这是因为每个类都提供了适当的特殊方法函数来实现整数的加法。
- en: Designing for encapsulation and privacy
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计封装和隐私
- en: 'A common question about Python class definitions is how we can achieve **encapsulation**
    if all attribute and member names are public. Some programmers worry about this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 类定义的一个常见问题是，如果所有属性和成员名称都是公开的，我们如何实现**封装**。一些程序员对此表示担忧：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ve created an object, `p_2`. Then we modified an attribute value of the
    object without using any of the object''s method functions. This is not a failure
    to use the encapsulation design principle: the class has a properly encapsulated
    design. The class doesn''t have an implementation that can be checked statically
    by a compiler.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个对象 `p_2`。然后我们修改了该对象的一个属性值，而没有使用该对象的方法函数。这并不是没有使用封装设计原则的失败：该类有一个适当的封装设计。该类没有可以被编译器静态检查的实现。
- en: 'The Pythonic principle is summarized with the following observation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 原则可以用以下观察结果来概括：
- en: '*We''re all adults here.*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们都是成年人。*'
- en: There's no compelling reason to create the complexity of private, public, and
    protected methods and attributes of an object, because Python code is distributed
    as source and anyone can inspect the source to see what the consequences of bending
    or breaking encapsulation might be. The preferred approach is to write clear docstrings
    for classes and methods, and to provide unit tests to demonstrate that attributes
    and methods are being used properly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有充分的理由去创建私有、公开和受保护的方法和属性这种复杂性，因为 Python 代码以源代码的形式分发，任何人都可以检查源代码，以了解弯曲或破坏封装可能带来的后果。首选的方法是为类和方法编写清晰的文档字符串，并提供单元测试来证明属性和方法被正确使用。
- en: We can prefix a name with a single `_` to indicate that the method or attribute
    is not part of the public interface to a class. Python documentation tools will
    politely ignore these names so that these implementation details can be changed
    freely. Names that begin with `_` are considered to be subject to change without
    notice; depending on these names may lead to a program breaking in unexpected
    ways.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个下划线 `_` 作为前缀来表示方法或属性不是类公共接口的一部分。Python 文档工具会礼貌地忽略这些名称，以便可以自由地更改这些实现细节。以下划线开头的名称被认为是可能会在没有通知的情况下更改的；依赖于这些名称可能会导致程序以意想不到的方式崩溃。
- en: 'In some languages, "getter and setter" methods are required to expose the attributes
    of a class. In Python, we can use the object''s `__dict__` directly, simplifying
    introspection. We can also use the built-in functions `getattr()`, `setattr()`,
    and `delattr()`to work with attribute names as strings. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，需要“获取器和设置器”方法来公开类的属性。在 Python 中，我们可以直接使用对象的 `__dict__`，简化了内省。我们还可以使用内置函数
    `getattr()`、`setattr()` 和 `delattr()` 来以字符串的形式处理属性名称。例如：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This shows how we can get an attribute's names and values dynamically. In the
    first example, we looked at the object's internal namespace, `__dict__`, to get
    the attributes. In the second example, we used the built-in `getattr()` function
    to get the value of an attribute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们可以如何动态地获取属性的名字和值。在第一个例子中，我们查看对象的内部命名空间 `__dict__` 来获取属性。在第二个例子中，我们使用了内置的
    `getattr()` 函数来获取属性的值。
- en: Using properties
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性
- en: 'Python allows us to create methods that can be used as if they were attributes.
    This gives us very pleasant syntax for getting a derived value from an object.
    A method that appears to be an attribute is called a **property**. We''ll extend
    our `Point` class with two more methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许我们创建方法，它们可以用作属性。这为我们提供了从对象获取派生值时非常愉悦的语法。看起来像属性的方法定义为**属性**。我们将使用两个额外的方法定义我们的
    `Point` 类：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've defined two functions using the `@property` decorator. This decorator
    can be used with a function that has only the instance variable, `self`, as a
    parameter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@property` 装饰器定义了两个函数。这个装饰器可以与只有一个参数 `self` 的实例变量的函数一起使用。
- en: 'Here''s how we can use these properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这些属性的例子：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've accessed these methods as if they were simple attributes of the object,
    `p`. Using `p.r` and `p.`θ can be more pleasant than having to write `p.r()` and
    `p.`θ`()` in a complex formula. The preceding properties are explicitly *read-only*.
    We get an exception if we try to assign a value to `p.r` or `p.`θ.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像访问对象的简单属性一样访问了这些方法，使用 `p.r` 和 `p.θ` 比在复杂公式中写 `p.r()` 和 `p.θ()` 更愉快。前面的属性是显式**只读**的。如果我们尝试给
    `p.r` 或 `p.θ` 赋值，我们会得到一个异常。
- en: We'll return to the topic of the `@property` decorator in [Chapter 13](ch13.html
    "Chapter 13. Metaprogramming and Decorators"), *Metaprogramming and Decorators*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 13 章[《元编程和装饰器》](ch13.html "第 13 章。元编程和装饰器")中回到 `@property` 装饰器的话题。
- en: Using inheritance to simplify class definitions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承来简化类定义
- en: 'We can use **inheritance**—reuse of code from a superclass in subclasses—which
    can simplify a subclass definition. In an earlier example, we created the `MyAppError`
    class as a subclass of `Exception`. This means that all of the features of `Exception`
    will be available to `MyAppError`. This works because of the three-step search
    for a name: if a method name is not found in an object''s class, then the superclasses
    are all searched for the name.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**继承**——在子类中重用超类的代码，这可以简化子类的定义。在先前的例子中，我们创建了一个 `MyAppError` 类作为 `Exception`
    的子类。这意味着 `Exception` 的所有特性都将可用给 `MyAppError`。这是因为名称搜索的三个步骤：如果方法名在对象类中找不到，那么会搜索所有超类以查找该名称。
- en: 'Here''s an example of a subclass which overrides just one method of the parent
    class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个子类的例子，它只覆盖了父类的一个方法：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've defined a subclass of `Point` named `Manhattan_Point`. This class has
    all of the features of a `Point`. It makes a single change to the parent class.
    It provides a definition for the `dist()` method that will override the definition
    in the `Point` superclass.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Manhattan_Point` 的 `Point` 子类。这个类具有 `Point` 的所有特性。它对父类进行了一个单一的改变。它为
    `dist()` 方法提供了一个定义，该定义将覆盖 `Point` 超类中的定义。
- en: 'Here''s an example that shows how method resolution works:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了方法解析的工作原理：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve created two objects: `p_1` is an instance of `Point`, and `p_2` is an
    instance of `Manhattan_Point`. We didn''t write the `__init__()` method of `Manhattan_Point`;
    it was inherited from `Point`. When we evaluate `p_1.dist()`, we''re using the
    `dist()` method that''s part of `p_1`''s class, `Point`. When we evaluate `p_2.dist()`,
    on the other hand, we''re using the `dist()` method that''s part of `p_2`, which
    is the method of `Manhattan_Point`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个对象：`p_1` 是 `Point` 的一个实例，而 `p_2` 是 `Manhattan_Point` 的一个实例。我们没有编写 `Manhattan_Point`
    的 `__init__()` 方法；它是从 `Point` 继承的。当我们评估 `p_1.dist()` 时，我们使用的是 `p_1` 的类 `Point`
    中的 `dist()` 方法。另一方面，当我们评估 `p_2.dist()` 时，我们使用的是 `p_2` 的方法，即 `Manhattan_Point`
    的方法。
- en: Reuse through inheritance is a way to guarantee that several classes have identical
    behavior. This is an import object-oriented design principle, sometimes called
    the **Liskov Substitution Principle** (**LSP**). An instance of `Manhattan_Point`
    can be used anywhere an instance of `Point` is used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承重用是一种保证几个类具有相同行为的方法。这是一个重要的面向对象设计原则，有时被称为**Liskov 替换原则**（**LSP**）。`Manhattan_Point`
    的一个实例可以在任何需要 `Point` 的实例的地方使用。
- en: Using multiple inheritance and the mixin design pattern
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多重继承和混入设计模式
- en: Inheritance is sometimes visualized as a simple hierarchy of related classes.
    If each subclass has at most one parent class, there's a chain of relationships
    between any given subclass and the `object` superclass. This single inheritance
    model isn't always appropriate. In some cases, a class will include a number of
    disparate features that don't fit the linear ancestry idea.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 继承有时被可视化为一个简单的相关类层次结构。如果每个子类最多只有一个父类，那么任何给定的子类与 `object` 超类之间将存在一条关系链。这种单继承模型并不总是合适的。在某些情况下，一个类将包含一些不适合线性血统观念的不同特性。
- en: The `collections` abstract base class module, `collections.abc`, contains a
    number of examples of multiple inheritance. The overall design pattern here is
    to have a central class hierarchy that defines the essential features of the `List`,
    `Set`, or `Mapping` collections. Other features are included via reusable **mixin**
    classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections` 抽象基类模块，`collections.abc`，包含了许多多重继承的例子。这里的设计模式是有一个中心类层次结构，它定义了
    `List`、`Set` 或 `Mapping` 集合的基本特性。其他特性通过可重用的 **混合** 类包含在内。'
- en: For example, the `Set` class is a subclass of `Container`. Mixed into this definition
    are features from the `Sized` and `Iterable` class definitions. The `Sized` mixin
    incorporates the `__len__()` special method. The `Iterable` mixin incorporates
    the `__iter__()` special method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Set` 类是 `Container` 的子类。在这个定义中混合了 `Sized` 和 `Iterable` 类定义的特性。`Sized` 混合类包含了
    `__len__()` 特殊方法。`Iterable` 混合类包含了 `__iter__()` 特殊方法。
- en: This leads to the final class being an assembly of reusable superclasses. We
    can leverage this to create our own classes which contain different mixtures of
    features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致最终类成为可重用超类的组装。我们可以利用这一点来创建包含不同特性混合的自己的类。
- en: 'Python manages multiple inheritance by relying on the order in which classes
    are named in the `class` statement. This builds the `__mro__` value used to search
    for names in the inheritance lattice. Here''s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过依赖于 `class` 语句中类命名的顺序来管理多重继承。这构建了用于在继承图中搜索名称的 `__mro__` 值。以下是一个例子：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've imported one of the abstract base classes. When we look at the MRO, we
    see that Python will search for a name in `Mapping`, `Sized`, `Iterable`, `Container`,
    and `object`, in that order.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了一个抽象基类。当我们查看 MRO 时，我们看到 Python 将按顺序在 `Mapping`、`Sized`、`Iterable`、`Container`
    和 `object` 中搜索名称。
- en: When designing with mixin classes like this, we generally divide responsibility
    among the various classes so that we avoid any name collisions between the various
    superclasses that are used to assemble the final class definition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此类混合类进行设计时，我们通常在各个类之间分配责任，以避免在用于组装最终类定义的各种超类之间发生名称冲突。
- en: Using class methods and attributes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类方法和属性
- en: Generally, we expect objects to be stateful and classes to be stateless. While
    typical, a stateless class is not a requirement. We can create class objects which
    have attributes as well as methods. A class can also have mutable attributes,
    in the rare cases that this is necessary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们期望对象是有状态的，而类是无状态的。虽然典型，但无状态类不是必需的。我们可以创建具有属性和方法类对象的类。在罕见的情况下，类也可以有可变属性。
- en: 'One use for class variables is to create parameters that apply to all instances
    of the class. When a name is not resolved by the object instance, the class is
    searched next. Here is a small hierarchy of classes that rely on a class-level
    attribute:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量的一种用途是创建适用于类所有实例的参数。当一个名称没有被对象实例解析时，接下来将搜索类。以下是一个依赖于类级属性的类的小层次结构：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Units` class definition extends the `float` class. It introduces a class-level
    attribute named `units`. It overrides the `__repr__()` special method of `float`.
    This method uses the superclass `__repr__()` method to get the essential text
    representation of a value. It then includes the value of the `units` attribute.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Units` 类定义扩展了 `float` 类。它引入了一个名为 `units` 的类级属性。它覆盖了 `float` 的 `__repr__()`
    特殊方法。此方法使用超类的 `__repr__()` 方法来获取值的本质文本表示。然后包括 `units` 属性的值。'
- en: When we evaluate `self.units`, there will be a three-step search for this name.
    An instance of `Height` will not provide the `units` attribute. The `Height` class,
    however, will provide the `units` attribute; the value will be `inches`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估 `self.units` 时，将进行对名称的三步搜索。`Height` 的实例不会提供 `units` 属性。然而，`Height` 类将提供
    `units` 属性；其值将是 `inches`。
- en: 'When we create an instance of a `Height` object, we''ll see the units:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 `Height` 对象的实例时，我们将看到单位：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we print an instance of `Height`, the `print()` function will use the built-in
    `repr()` function to get a string representation. The `repr()` function uses the
    `__repr__()` special method of an object. We've overridden the `__repr__()` special
    method to include the text from the `units` attribute.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印 `Height` 的实例时，`print()` 函数将使用内置的 `repr()` 函数来获取字符串表示。`repr()` 函数使用对象的
    `__repr__()` 特殊方法。我们已经重写了 `__repr__()` 特殊方法，以包含 `units` 属性中的文本。
- en: Since all attributes are publicly available, we can write something like `Height.units=
    "furlongs"`, which will cause all further uses of objects of the `Height` class
    to display different units. Changing the class level attributes is generally a
    bad idea, but it is not prohibited in any formal way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有属性都是公开可用的，我们可以编写类似 `Height.units= "furlongs"` 这样的代码，这将导致所有后续使用 `Height`
    类对象的操作都会显示不同的单位。更改类级别的属性通常不是一个好主意，但并没有任何正式的禁止方式。
- en: 'Recall the policy: *We''re all adults here.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下政策：*我们都是成年人。*
- en: Using mutable class variables
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可变类变量
- en: 'Some applications may call for a properly mutable variable that''s part of
    an overall class. A class-level attribute name is found during the three-step
    search for a name: first the object, then the class, then the superclasses. This
    means that we can successfully evaluate `self.class_level_name`, even if the name
    is not in the object instance, but is defined in the class or one of the parent
    superclasses.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序可能需要一个作为整体类一部分的适当可变变量。在寻找名称的三个步骤中，会找到一个类级别的属性名称：首先查找对象，然后是类，最后是超类。这意味着即使名称不在对象实例中，而是在类或父超类中定义，我们也可以成功评估
    `self.class_level_name`。
- en: If we try to assign a class-level variable, however, using a name like `self.class_level_name`,
    we'll be creating a new attribute in the instance. The class-level name will no
    longer be visible because the instance name will now be found first.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用类似 `self.class_level_name` 的名称来分配类级别的变量，我们将在实例中创建一个新的属性。由于实例名称现在会被首先找到，类级别的名称将不再可见。
- en: 'If we want to update a class-level variable, we must explicitly use the class
    name, avoiding the self instance variable. Here''s a class which assigns a sequence
    number to each instance that is created:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新一个类级别的变量，我们必须显式地使用类名，避免使用 `self` 实例变量。以下是一个为每个创建的实例分配序列号的类：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have created a class-level variable, `counter`, which is initialized to
    zero when the class is created. The `__init__()` method will increment the class-level
    `counter` attribute. In order to avoid creating a variable in the instance, the
    class name, `Sample`, is used instead of `self`. In addition to updating `Sample.counter`,
    this method also sets two attributes of the instance: the current value of `Sample.counter`
    is assigned to the sequence attribute, and the given value for the measure is
    also saved.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类级别的变量 `counter`，当类被创建时初始化为零。`__init__()` 方法将增加类级别的 `counter` 属性。为了避免在实例中创建变量，我们使用类名
    `Sample` 而不是 `self`。除了更新 `Sample.counter`，此方法还设置实例的两个属性：将 `Sample.counter` 的当前值分配给序列属性，并将给定的测量值也保存起来。
- en: It's essential to note that, inside a method function, we can use `self.counter`
    and `Sample.counter` to access the same object. This will be true when there's
    no instance variable named `counter`. In order to assign a variable in the class,
    however, we can only use `Sample.counter`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在方法函数内部，我们可以使用 `self.counter` 和 `Sample.counter` 来访问同一个对象。当没有名为 `counter`
    的实例变量时，这将是正确的。然而，为了在类中分配变量，我们只能使用 `Sample.counter`。
- en: Writing static methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写静态方法
- en: In some cases, we'll include a method in a class that does not actually depend
    on any instance variables. In many languages, this kind of method is called **static**.
    Using the word *static* to refer to class-level features comes from C++ and Java;
    it has also been adopted for Python.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们会在类中包含一个实际上不依赖于任何实例变量的方法。在许多语言中，这种方法被称为 **静态**。使用 *静态* 一词来指代类级别的特性来自
    C++ 和 Java；它也被用于 Python。
- en: We don't have any syntax complications for class-level attributes. As we've
    seen in previous examples, any attribute that's not part of the instance will
    be searched for in the class; the distinction between instance variables and class
    variables doesn't require any additional syntax.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类级别的属性，我们没有任何语法上的复杂性。正如我们在之前的例子中所看到的，任何不属于实例的属性都会在类中搜索；实例变量和类变量之间的区别不需要任何额外的语法。
- en: A class-level method, however, cannot have an instance variable as the first
    defined parameter. This is an important syntactic change. We use the `@staticmethod`
    decorator to annotate methods that do not have an instance variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类级别的方无法将实例变量作为第一个定义的参数。这是一个重要的语法变化。我们使用`@staticmethod`装饰器来注释没有实例变量的方法。
- en: 'We''ll expand the `Sample` class shown earlier to include a validity check.
    Checking for validity isn''t a proper instance method: we should not create an
    instance with invalid values. We''ll add this method to the class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展前面展示的`Sample`类，以包括一个有效性检查。检查有效性不是一个合适的实例方法：我们不应该使用无效值创建一个实例。我们将把这个方法添加到类中：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've marked this method with the `@staticmethod` decorator. The method does
    not have a `self` variable, since it doesn't apply to an instance of the class.
    This method can only be invoked via `Sample.validate(some_value)`. The method
    will confirm that the value of the `measure` parameter is valid, or it will raise
    an exception which details the reason why the value is invalid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用`@staticmethod`装饰器标记了这个方法。这个方法没有`self`变量，因为它不适用于类的实例。这个方法只能通过`Sample.validate(some_value)`来调用。这个方法将确认`measure`参数的值是否有效，或者它会引发一个异常，详细说明为什么该值无效。
- en: 'We might use this method to create and use an instance of the `Sample` object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能使用这个方法来创建和使用`Sample`对象的实例：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll start the `try` statement by simply evaluating the `Sample.validate()`
    method. If this method does not raise an exception, the given value is valid.
    If this method does raise an exception, we''ll write an error message and continue
    processing. Often, we''ll have this kind of processing in a file input loop: we''ll
    process good data and write messages about bad data to the log.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地评估`Sample.validate()`方法来开始`try`语句。如果这个方法没有引发异常，给定的值是有效的。如果这个方法引发了异常，我们将写入一个错误消息并继续处理。通常，我们会在文件输入循环中有这种处理：我们会处理好的数据，并将关于坏数据的消息写入日志。
- en: Python also offers a `@classmethod` decorator. This is a more specialized tool.
    It provides the class as an argument instead of the instance. It allows us to
    write a method that can work with a variety of classes. This might be used in
    a metaclass.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了一个`@classmethod`装饰器。这是一个更专业的工具。它将类作为参数而不是实例提供。它允许我们编写可以与各种类一起工作的方法。这可能在元类中使用。
- en: We'll return to the topic of decorators in [Chapter 13](ch13.html "Chapter 13. Metaprogramming
    and Decorators"), *Metaprogramming and Decorators*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第13章](ch13.html "第13章。元编程和装饰器")*元编程和装饰器*中回到装饰器的话题。
- en: Using __slots__ to save storage
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`__slots__`来节省存储
- en: The default behavior of the `object` superclass is to create a `dict` for an
    object's attributes. This provides fast resolution of names. It means that an
    object can have attributes added and changed very freely. Because a hash is used
    to locate the attribute by name, the internal `dict` object can consume quite
    a bit of memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`超类的默认行为是为对象的属性创建一个`dict`。这提供了快速的名称解析。这意味着对象可以非常自由地添加和更改属性。由于使用哈希来通过名称定位属性，内部的`dict`对象可能会消耗相当多的内存。'
- en: We can modify the behavior of the `object` superclass by providing a list of
    specific attribute names when we create a class. When we assign these names to
    the specially named `__slots__` variable, these will be the only available attributes.
    A `dict` is not created, and memory use is reduced considerably.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在创建类时提供一个特定的属性名称列表来修改`object`超类的行为。当我们将这些名称分配给特别命名的`__slots__`变量时，这些将成为唯一可用的属性。不会创建`dict`，从而大大减少了内存使用。
- en: 'If we''re working with very large datasets, we might need to use a class that
    looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理非常大的数据集，我们可能需要使用一个类似这样的类：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This class uses the `__slots__` attribute to define the only two attributes
    that can be used for an instance. This avoids using a `dict` to represent the
    attributes of instances of this class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用`__slots__`属性来定义实例可以使用的唯一两个属性。这避免了使用`dict`来表示这个类的实例属性。
- en: The ABCs of abstract base classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象基类的ABC（ABC代表Abstract Base Classes）
- en: In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, we looked at the `collections` module, which offers a number of variations
    on the mapping theme. These different kinds of collections are built on a foundation
    of abstract base classes, defined in the `collections.abc` module. Looking at
    this module exposes the common features, and the differences, among the collections.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。更复杂的数据类型") 中，我们探讨了 `collections` 模块，该模块在映射主题上提供了一些变体。这些不同类型的集合建立在
    `collections.abc` 模块中定义的抽象基类的基础上。查看这个模块可以揭示集合的共同特征以及它们之间的差异。
- en: We can see how `Sequence` is the basis for the built-in tuple `class`, and `MutableSequence`
    is the basis for the built-in `list`. The `Set` abstract base class is the basis
    for the `frozenset` built-in class, and `MutableSet` is the basis for the `set`
    class. There's no concrete implementation of the `Mapping` class, but the `dict`
    class is the built-in implementation of the `MutableMapping` class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `Sequence` 是内置元组 `class` 的基础，而 `MutableSequence` 是内置 `list` 的基础。`Set`
    抽象基类是内置 `frozenset` 类的基础，而 `MutableSet` 是内置 `set` 类的基础。`Mapping` 类没有具体的实现，但 `dict`
    类是 `MutableMapping` 类的内置实现。
- en: If we need to implement a unique kind of collection, one not already provided
    by the `collection` module, we're encouraged to use the `collections.abc` module
    as a starting point. If we leverage these common base classes, we're assured that
    our new collection will fit seamlessly with other Python features.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要实现一种独特的集合类型，这种类型不是由 `collection` 模块提供的，我们鼓励使用 `collections.abc` 模块作为起点。如果我们利用这些常见的基类，我们可以确保我们的新集合能够与其他
    Python 特性无缝结合。
- en: Writing a callable class
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可调用类
- en: The abstract base class `Callable` is defined in the `collections.abc` module.
    This class doesn't seem to have much to do with collections. It's a useful abstraction,
    nonetheless.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类 `Callable` 定义在 `collections.abc` 模块中。这个类似乎与集合没有太多关系。尽管如此，它是一个有用的抽象。
- en: A class that derives from `Callable` must define the `__call__()` special method.
    The objects created from this class are callable, and can be used as if they were
    functions. This allows us to create fairly complex functions based on a class
    definition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Callable` 派生的类必须定义 `__call__()` 特殊方法。从这个类创建的对象是可调用的，可以用作函数。这允许我们基于类定义创建相当复杂的函数。
- en: 'Here''s a function to compute the *n*th Fibonacci number. There are three relevant
    rules for computing this value:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算第 *n* 个斐波那契数的函数。计算这个值有三个相关的规则：
- en: '![Writing a callable class](img/B03671_11_01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![编写可调用类](img/B03671_11_01.jpg)'
- en: The first two Fibonacci numbers are defined as zero and one. Other Fibonacci
    numbers are the sum of the two preceding numbers. If we use a naïve algorithm,
    it's quite expensive to compute a large Fibonacci number. We can, however, define
    a `Callable` that uses an internal cache to reduce the workload to a manageable
    level. This technique is called **memoization**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个斐波那契数定义为零和一。其他斐波那契数是前两个数的和。如果我们使用一个简单的算法，计算一个大的斐波那契数是非常昂贵的。然而，我们可以定义一个使用内部缓存的
    `Callable`，以将工作量降低到可管理的水平。这种技术称为 **记忆化**。
- en: 'The class definition for a `Callable` looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable` 类的定义如下：'
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've defined a class, `Fibonacci`, which extends the `Callable` abstract base
    class. The `__init__()` method initializes a cache with two defined values for
    Fibonacci numbers. The `__call__()` method only computes a Fibonacci number, `n`,
    if the number is not already in the cache. It does this by recursive calls to
    compute Fibonacci numbers `n-1` and `n-2`. Once the result is in the cache, it
    can be returned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类，`Fibonacci`，它扩展了 `Callable` 抽象基类。`__init__()` 方法初始化一个缓存，其中包含斐波那契数的两个定义值。`__call__()`
    方法仅在数字不在缓存中时计算斐波那契数 `n`。它是通过递归调用来计算斐波那契数 `n-1` 和 `n-2` 的。一旦结果在缓存中，就可以返回。
- en: 'When we create an instance of this class, we have created a callable function.
    Given that function, we can compute Fibonacci numbers. Here''s an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建这个类的实例时，我们已经创建了一个可调用的函数。给定这个函数，我们可以计算斐波那契数。以下是一个示例：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've created an instance of the `Fibonacci` class, and assigned this to the
    variable `fib`. The `fib` object is callable; when we evaluate it with an argument
    value of six, we get the seventh Fibonacci number.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Fibonacci` 类的实例，并将其分配给变量 `fib`。`fib` 对象是可调用的；当我们用六作为参数值评估它时，我们得到第七个斐波那契数。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we''ve seen the basics of defining a class and using objects
    of that class. We''ve looked at how we create the methods that define the behavior
    of a class. The internal state of the class is the result of the various methods:
    in Python we don''t formally declare instance variables. We generally rely in
    the `__init__()` method to provide the initial or default values for the object''s
    state.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了定义类和使用该类对象的基本方法。我们探讨了如何创建定义类行为的函数。类的内部状态是各种方法的结果：在Python中，我们并不正式声明实例变量。我们通常依赖于
    `__init__()` 方法来提供对象的初始或默认值。
- en: We've looked at the way Python resolves attribute and method names by searching
    the object, the class, and then the superclasses. The method resolution order
    is based on the order the classes are presented in the initial `class` statement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了Python通过搜索对象、类以及超类来解决属性和方法名称的方式。方法解析顺序基于类在初始 `class` 语句中呈现的顺序。
- en: The `@properties` decorator can be used to create methods that have the same
    syntax as an attribute. This can help clarify otherwise complex algorithms. We've
    also looked at the `@staticmethod` decorator, which is used to create methods
    that belong to the class as a whole and are independent of any specific instance
    of the class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`@properties` 装饰器可以用来创建与属性具有相同语法的函数。这有助于阐明其他情况下可能复杂的算法。我们还探讨了 `@staticmethod`
    装饰器，它用于创建属于整个类的方法，且与类的任何特定实例无关。'
- en: In order to save some memory, we can use the `__slots__` variable. This will
    construct an object that isn't based on a `dict` for storing attributes. The object
    is quite a bit smaller, but also suffers from some limitations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些内存，我们可以使用 `__slots__` 变量。这将构建一个不基于 `dict` 存储属性的对象。这个对象要小得多，但也有一些限制。
- en: We also looked at how we can create a callable object. This is an object that
    can be used like a function, but has all of the powerful features of an object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何创建一个可调用的对象。这是一个可以像函数一样使用的对象，但具有对象的所有强大功能。
- en: In [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages, Libraries,
    and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we'll look at how we can package our functions and classes into modules. We'll
    see how modules are grouped into packages. The *Python Standard Library* is a
    collection of packages that we install with Python. We'll look at the tiny distinctions
    between modules and script files, and how we can create more complete Python applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.html "第12章。脚本、模块、包、库和应用") *脚本、模块、包、库和应用* 中，我们将探讨如何将我们的函数和类打包成模块。我们将了解模块是如何分组成包的。*Python标准库*
    是我们使用Python安装的一系列包。我们将探讨模块和脚本文件之间的微小区别，以及我们如何创建更完整的Python应用程序。
