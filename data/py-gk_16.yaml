- en: '*Chapter 12*: Building Serverless Functions using Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用Python构建无服务器函数'
- en: Serverless computing is a new model of cloud computing that separates the management
    of physical or virtual servers and infrastructure-level software, such as database
    systems, from the application itself. This model allows developers to solely focus
    on application development and enables someone else to manage the underlying infrastructure
    resources. Cloud providers are the best option to use to adopt this model. Containers
    are not only opportune for complex deployments, but they are also a breakthrough
    technology for the **serverless computing** era. In addition to containers, there
    is another form of serverless computing, which is known as **Function as a Service**
    (**FaaS**). In this new paradigm, cloud providers offer a platform to develop
    and run application functions or **serverless functions**, usually in response
    to an event or as a direct call to those functions. All public cloud providers,
    such as Amazon, Google, Microsoft, IBM, and Oracle, offer this service. The focus
    of this chapter will be on understanding and building serverless functions using
    Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算是一种新的云计算模式，它将物理或虚拟服务器的管理以及数据库系统等基础设施级软件的管理与应用程序本身分离。这种模式允许开发者专注于应用程序开发，并使其他人能够管理底层的基础设施资源。云服务提供商是采用这种模式的最优选择。容器不仅适用于复杂的部署，而且在无服务器计算时代也是一种突破性技术。除了容器之外，还有一种无服务器计算的形式，被称为**函数即服务**（**FaaS**）。在这种新范式下，云服务提供商提供了一个平台来开发和运行应用程序函数或**无服务器函数**，通常是对这些函数的直接调用或响应某个事件。所有公共云服务提供商，如亚马逊、谷歌、微软、IBM和甲骨文，都提供这项服务。本章的重点将在于理解和构建使用Python的无服务器函数。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing serverless functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍无服务器函数
- en: Understanding deployment options for serverless functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解无服务器函数的部署选项
- en: Learning how to build serverless functions with a case study
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过案例研究学习如何构建无服务器函数
- en: After completing this chapter, you should have a clear understanding of the
    role of serverless functions in cloud computing and how to build them using Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章学习后，你应该对无服务器函数在云计算中的作用以及如何使用Python构建它们有一个清晰的理解。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of the technical requirements for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为本章列出的技术要求：
- en: You will need to have Python 3.7, or later, installed on your computer.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在你的计算机上安装Python 3.7或更高版本。
- en: To deploy a serverless function in **Google Cloud Platform** (**GCP**) Cloud
    Functions, you will need a GCP account (a free trial will work fine).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在**谷歌云平台**（**GCP**）的Cloud Functions中部署无服务器函数，你需要一个GCP账户（免费试用版即可）。
- en: You will need an account (that is, a free account) with *SendGrid* for sending
    emails.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个*SendGrid*账户（即免费账户）来发送电子邮件。
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12)找到。
- en: Let's begin with an introduction to serverless functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从无服务器函数的介绍开始。
- en: Introducing serverless functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍无服务器函数
- en: A serverless function is a model that can be used to develop and execute software
    components or modules without needing to know or worry about an underlying hosting
    platform. These software modules or components are known as **Lambda functions**
    or **Cloud functions** in the public cloud providers' product offerings. Amazon
    was the first vendor that offered such serverless functions on its AWS platform
    as **AWS Lambda**. It was followed by Google and Microsoft, which offer Google
    **Cloud Functions** and **Azure Functions**, respectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数是一种模型，可以用来开发和执行软件组件或模块，而无需了解或担心底层托管平台。这些软件模块或组件在公共云服务提供商的产品中被称为**Lambda函数**或**云函数**。亚马逊是第一个在其AWS平台上提供这种无服务器函数的供应商，该函数被称为**AWS
    Lambda**。随后是谷歌和微软，分别提供**Google Cloud Functions**和**Azure Functions**。
- en: 'Typically, a serverless function has four components, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个无服务器函数有四个组件，如下所示：
- en: '![Figure 12.1 – The components of a serverless function'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 无服务器函数的组件'
- en: '](img/B17189_12_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_12_01.jpg)'
- en: Figure 12.1 – The components of a serverless function
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 无服务器函数的组件
- en: 'These four components are described next:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将描述以下四个组件：
- en: '**Functional code**: This is a programming unit that performs certain tasks
    as per the business or functional goal of the function. For example, we can write
    a serverless function to process an input stream of data or write a scheduled
    activity to check certain data resources for monitoring purposes.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式代码**：这是一个执行特定任务的编程单元，根据函数的业务或功能目标。例如，我们可以编写一个无服务器函数来处理输入数据流，或者编写一个计划活动来检查某些数据资源以进行监控目的。'
- en: '**Events**: Serverless functions are not meant to be used like microservices.
    Instead, they are meant to be used based on a trigger that can be initiated by
    an event from a pub/sub system, or they can come as HTTP calls based on an external
    event in the field such as events from field sensors.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：无服务器函数不是用来像微服务一样使用的。相反，它们是基于可以由pub/sub系统中的事件触发的触发器来使用的，或者它们可以根据外部事件（如来自现场传感器的事件）作为HTTP调用出现。'
- en: '**Outcome**: When a serverless function is triggered to do a job, there is
    an output from the function, which can either be a simple response to the caller
    or trigger the next actions to mitigate the impact of an event. One example of
    the outcome of a serverless function is to trigger another cloud service such
    as a database service or send an email to subscribed parties.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：当无服务器函数被触发执行任务时，函数会有输出，这可以是简单的对调用者的响应，或者触发后续操作以减轻事件的影响。无服务器函数的一个结果示例是触发另一个云服务，如数据库服务，或向订阅方发送电子邮件。'
- en: '**Resources**: Sometimes, functional code has to use an additional resource
    to do its job, for example, a database service or cloud storage to access or push
    files.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：有时，函数式代码需要使用额外的资源来完成其工作，例如数据库服务或云存储来访问或推送文件。'
- en: Benefits
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Serverless functions bring with them all the benefits of serverless computing,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数带来了无服务器计算的所有好处，如下所示：
- en: '**Ease of development**: Serverless functions take away infrastructure complexities
    from developers so that they can focus on the functional aspect of the program.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发简便**：无服务器函数将基础设施复杂性从开发者手中移除，使他们能够专注于程序的函数方面。'
- en: '**Built-in scalability**: Serverless functions are offered with built-in scalability
    to handle any traffic growth at any time.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置可伸缩性**：无服务器函数提供内置的可伸缩性，以处理任何时间点的任何流量增长。'
- en: '**Cost efficiency**: Serverless functions not only reduce development costs
    but also offer optimized deployment and an operational mode. Typically, this is
    a *pay-as-you-use* model that means you will only be charged for the time during
    which your function is being executed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：无服务器函数不仅降低了开发成本，还提供了优化的部署和操作模式。通常，这是一个*按使用付费*的模式，这意味着您只需为函数执行的时间付费。'
- en: '**Technology agnostic**: Serverless functions are technology agnostic. This
    means that you can build them in many programming languages using a variety of
    different cloud resources.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术无关性**：无服务器函数是技术无关的。这意味着您可以使用多种不同的云资源，在许多编程语言中构建它们。'
- en: Note that there are a few limitations to serverless functions; for instance,
    we will have less system-level control in building such functions and troubleshooting
    can be tricky without system-level access.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无服务器函数有一些限制；例如，在构建此类函数时，我们将拥有较少的系统级控制，并且没有系统级访问的情况下，故障排除可能很棘手。
- en: Use cases
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: There are several possible uses of serverless functions. For example, we can
    use such functions for data processing if we receive an event of a file upload
    in cloud storage or if we have data available through real-time streaming. In
    particular, serverless functions can be integrated with the **Internet of Things**
    (**IoT**) sensors. Typically, IoT sensors are thousands in number. Serverless
    functions possess the ability to handle the requests from such a large number
    of sensors in a scalable manner. A mobile application can use such functions as
    a backend service to perform certain tasks or process data without jeopardizing
    the mobile device resources. One practical use of serverless functions in real
    life is the **Amazon Alexa** product. It is not possible to put every skill or
    ounce of intelligence inside the Alexa device itself. Instead, it uses Amazon
    Lambda functions for these skills. Another reason why Alexa uses Amazon Lambda
    functions is the ability to scale them based on the demand. For instance, some
    functions might be used more often than others such as weather queries.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数有几种可能的用途。例如，如果我们收到云存储中文件上传的事件或通过实时流有可用数据，我们可以使用此类函数进行数据处理。特别是，无服务器函数可以与**物联网**（**IoT**）传感器集成。通常，物联网传感器数量达到数千。无服务器函数具有以可扩展的方式处理如此大量传感器请求的能力。一个移动应用程序可以使用这些函数作为后端服务来执行某些任务或处理数据，而不会损害移动设备资源。无服务器函数在现实生活中的一个实际用途是**Amazon
    Alexa**产品。不可能将每个技能或智能都放入Alexa设备本身。相反，它使用Amazon Lambda函数来实现这些技能。Alexa使用Amazon Lambda函数的另一个原因是它们可以根据需求进行扩展。例如，某些函数可能比其他函数更常用，如天气查询。
- en: In the next section, we will investigate the various deployment options for
    implementing and executing serverless functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨实现和执行无服务器函数的各种部署选项。
- en: Understanding the deployment options for serverless functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无服务器函数的部署选项
- en: 'Using a virtual machine or another runtime resource on public clouds for sporadically
    accessed applications might not be a commercially attractive solution. In such
    situations, serverless functions come to the rescue. Here, a cloud provider offers
    dynamically managed resources for your application and only charges you when your
    application is executed in response to a certain event. In other words, a serverless
    function is a backend computing method that is an on-demand and a pay-as-you-use
    service that is only offered on public clouds. We will introduce a few options
    for deploying serverless functions in the public clouds, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云上使用虚拟机或其他运行时资源来处理偶尔访问的应用程序可能不是一个具有商业吸引力的解决方案。在这种情况下，无服务器函数就派上用场了。在这里，云提供商为您的应用程序提供动态管理的资源，并且仅在您的应用程序响应某个事件时才向您收费。换句话说，无服务器函数是一种仅在公共云上提供的按需和按使用付费的后端计算方法。我们将介绍在公共云中部署无服务器函数的一些选项，如下：
- en: '**AWS Lambda**: This is considered to be one of the first service offerings
    from any of the public cloud providers. AWS Lambda functions can be written in
    Python, Node.js, Java, PowerShell, Ruby, Java, C#, and Go. AWS Lambda functions
    can be executed in response to events, such as file uploads to **Amazon S3**,
    a notification from **Amazon SNS**, or a direct API call. AWS Lambda functions
    are stateless.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Lambda**：这被认为是任何公共云提供商推出的第一个服务之一。AWS Lambda函数可以使用Python、Node.js、Java、PowerShell、Ruby、Java、C#和Go编写。AWS
    Lambda函数可以在响应事件时执行，例如将文件上传到**Amazon S3**、来自**Amazon SNS**的通知或直接API调用。AWS Lambda函数是无状态的。'
- en: '**Azure Functions**: Microsoft introduced Azure Functions almost two years
    after the launch of AWS Lambda functions. These functions can be attached to events
    within the cloud infrastructure. Microsoft provides support to build and debug
    these functions using Visual Studio, Visual Studio Code, IntelliJ, and Eclipse.
    Azure Functions can be written in C#, F#, Node.js, PowerShell, PHP, and Python.
    Additionally, Microsoft offers **Durable Functions** that allow us to write stateful
    functions in a serverless environment.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Functions**：微软在AWS Lambda函数推出近两年后推出了Azure Functions。这些函数可以附加到云基础设施中的事件上。微软提供支持，使用Visual
    Studio、Visual Studio Code、IntelliJ和Eclipse来构建和调试这些函数。Azure Functions可以使用C#、F#、Node.js、PowerShell、PHP和Python编写。此外，微软还提供了**Durable
    Functions**，允许我们在无服务器环境中编写有状态的函数。'
- en: '**Google Cloud Functions**: GCP offers Google Cloud Functions as serverless
    functions. Google Cloud Functions can be written in Python, Node.js, Go, .NET,
    Ruby, and PHP. Like its competitors, AWS Lambda and Azure Functions, Google Cloud
    Functions can be triggered by HTTP requests or by events from the Google Cloud
    infrastructure. Google allows you to use Cloud Build for the automatic testing
    and deployment of Cloud Functions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌云函数**：GCP提供谷歌云函数作为无服务器函数。谷歌云函数可以用Python、Node.js、Go、.NET、Ruby和PHP编写。像其竞争对手AWS
    Lambda和Azure Functions一样，谷歌云函数可以通过HTTP请求或谷歌云基础设施的事件触发。谷歌允许你使用Cloud Build来自动测试和部署云函数。'
- en: In addition to the top three public cloud providers, there are a few more offerings
    from other cloud providers. For example, IBM offers Cloud Functions that are based
    on the open source **Apache OpenWhisk** project. Oracle offers its serverless
    computing platform based on the open source **Fn** project. The beauty of using
    these open source projects is that you can develop and test your code locally.
    Additionally, these projects allow you to port your code from one cloud to another
    cloud or even to an on-premises environment deployment without any changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前三大公共云提供商之外，还有一些其他云提供商的更多服务。例如，IBM提供基于开源项目**Apache OpenWhisk**的云函数。Oracle提供基于开源项目**Fn**的无服务器计算平台。使用这些开源项目的美妙之处在于，你可以在本地开发和测试你的代码。此外，这些项目允许你将代码从一个云平台迁移到另一个云平台，甚至迁移到本地环境部署，而无需任何更改。
- en: It is worth mentioning another framework that is well known in serverless computing,
    called the **Serverless Framework**. This is not a deployment platform but a software
    tool that can be used locally to build and package your code for serverless deployment
    and then be used to deploy the package to one of your favorite public clouds.
    The serverless framework supports several programming languages such as Python,
    Java, Node.js, Go, C#, Ruby, and PHP.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在无服务器计算领域广为人知的另一个框架，称为**无服务器框架**。这不是一个部署平台，而是一个可以在本地使用的软件工具，可以用来构建和打包你的代码以进行无服务器部署，然后可以用来将包部署到你的首选公共云之一。无服务器框架支持多种编程语言，如Python、Java、Node.js、Go、C#、Ruby和PHP。
- en: In the next section, we will build a couple of serverless functions using Python.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Python构建几个无服务器函数。
- en: Learning how to build serverless functions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何构建无服务器函数
- en: In this section, we will investigate how to build serverless functions for one
    of the public cloud providers. Although Amazon AWS pioneered serverless functions
    in 2014 by offering AWS Lambda functions, we will use the Google Cloud Functions
    platform for our example functions. The reason for this is that we already introduced
    GCP in great detail in previous chapters, and you can leverage the same GCP account
    for the deployment of these example functions. However, we strongly recommend
    that you use the other platforms, especially if you are planning to use their
    serverless functions in the future. The core principles of building and deploying
    these functions on various cloud platforms are the same.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何为公共云提供商之一构建无服务器函数。尽管亚马逊AWS在2014年通过提供AWS Lambda函数率先推出了无服务器函数，但我们将使用谷歌云函数平台作为我们的示例函数。这样做的原因是，我们在前面的章节中已经详细介绍了GCP，并且你可以利用相同的GCP账户来部署这些示例函数。然而，我们强烈建议你使用其他平台，特别是如果你计划将来使用它们的无服务器函数的话。在各个云平台上构建和部署这些函数的核心原则是相同的。
- en: 'GCP Cloud Functions offers several ways in which to develop and deploy serverless
    functions (going forward, we will call them *Cloud Functions* in the context of
    GCP). We will explore two types of events in our example Cloud Functions, which
    can be described as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GCP云函数提供了多种开发和无服务器函数部署的方式（在GCP的上下文中，我们将它们称为*云函数*）。在我们的示例云函数中，我们将探索两种类型的事件，描述如下：
- en: The first Cloud Function will be built and deployed using the GCP Console from
    end to end. This Cloud Function will be triggered based on an HTTP call (or event).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个云函数将从头到尾使用GCP控制台构建和部署。这个云函数将基于HTTP调用（或事件）触发。
- en: The second Cloud Function will be part of a case study to build an application
    that listens to an event in the cloud infrastructure and takes an action such
    as sending an email as a response to this event. The Cloud Function used in this
    case study will be built and deployed using the Cloud **Software Development Kit**
    (**SDK**).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 Cloud Function 将是构建一个应用程序的一部分，该应用程序可以监听云基础设施中的事件，并对该事件采取行动，例如发送电子邮件作为对此事件的响应。在这个案例研究中使用的
    Cloud Function 将使用 Cloud **软件开发工具包**（**SDK**）构建和部署。
- en: We will start by building a Cloud Function using the GCP Console.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 GCP 控制台构建一个 Cloud Function。
- en: Building an HTTP-based Cloud Function using the GCP Console
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GCP 控制台构建基于 HTTP 的 Cloud Function
- en: Let's begin with the Google Cloud Function development process. We will build
    a very simple Cloud Function that provides today's date and current time for an
    HTTP trigger. Note that the HTTP trigger is the easiest way in which a Cloud Function
    can be invoked. First, we will need a GCP project. You can create a new GCP project
    using the GCP Console for this Cloud Function or an existing GCP project. The
    steps regarding how to create a GCP project and associate a billing account with
    it are discussed in [*Chapter 9*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247),
    *Python Programming for the Cloud*. Once you have a GCP project ready, building
    a new Cloud Function is a three-step process. We will explain these steps in the
    following subsections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Google Cloud Function 的开发过程开始。我们将构建一个非常简单的 Cloud Function，它为 HTTP 触发器提供今天的日期和当前时间。请注意，HTTP
    触发器是 Cloud Function 被调用的最简单方式。首先，我们需要一个 GCP 项目。您可以使用 GCP 控制台为这个 Cloud Function
    创建一个新的 GCP 项目，或者使用现有的 GCP 项目。有关如何创建 GCP 项目并将其与计费账户关联的步骤，请参阅[*第 9 章*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247)，*云端的
    Python 编程*。一旦您准备好了 GCP 项目，构建一个新的 Cloud Function 是一个三步的过程。我们将在以下小节中解释这些步骤。
- en: Configuring Cloud Function attributes
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Cloud Function 属性
- en: 'When we initiate the **Create Function** workflow from the GCP Console, we
    are prompted to provide the Cloud Function definition, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 GCP 控制台启动 **创建函数** 工作流程时，系统将提示我们提供 Cloud Function 定义，如下所示：
- en: '![Figure 12.2 – The steps to create a new Cloud Function using the GCP Console
    (1/2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 使用 GCP 控制台创建新 Cloud Function 的步骤（1/2）'
- en: '](img/B17189_12_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_12_02.jpg)'
- en: Figure 12.2 – The steps to create a new Cloud Function using the GCP Console
    (1/2)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 使用 GCP 控制台创建新 Cloud Function 的步骤（1/2）
- en: 'A high-level summary of the Cloud Function definition appears as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Function 定义的高级总结如下：
- en: We provide the `my-datetime`) and select the GCP **Region** to host this function.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供 `my-datetime`) 并选择托管此函数的 GCP **区域**。
- en: We select `HTTP` as the **Trigger type** for our function. Selecting a trigger
    for your function is the most important step. There are also other triggers available
    such as **Cloud Pub/Sub** and **Cloud Storage**. At the time of writing this book,
    GCP has added a few more triggers for evaluation purposes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `HTTP` 作为函数的 **触发类型**。为您的函数选择触发器是最重要的步骤。还有其他触发器可供选择，例如 **Cloud Pub/Sub**
    和 **Cloud Storage**。在撰写本书时，GCP 已添加了一些用于评估目的的更多触发器。
- en: For the sake of simplicity, we will allow unauthenticated access for our function.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化，我们将允许我们的函数进行未认证访问。
- en: 'After clicking on the **Save** button, we will be prompted to enter **RUNTIME,
    BUILD AND CONNECTIONS SETTINGS**, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **保存** 按钮，系统将提示我们输入 **运行时、构建和连接设置**，如下面的截图所示：
- en: '![Figure 12.3 – The steps to create a new Cloud Function using the GCP Console
    (2/2)](img/B17189_12_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 使用 GCP 控制台创建新 Cloud Function 的步骤（2/2）](img/B17189_12_03.jpg)'
- en: Figure 12.3 – The steps to create a new Cloud Function using the GCP Console
    (2/2)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 使用 GCP 控制台创建新 Cloud Function 的步骤（2/2）
- en: 'We can provide the **RUNTIME, BUILD AND CONNECTIONS SETTINGS** as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供以下 **运行时、构建和连接设置**：
- en: We can leave the runtime attributes in their default settings, but we will reduce
    the **Memory allocated** to **128 MiB** for our function. We have associated a
    default service account as a **Runtime service account** to this function. We
    will leave **Auto-scaling** to its default setting, but this can be set to a maximum
    number of instances for our function.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以保留运行时属性在默认设置，但我们将函数的 **内存分配** 减少到 **128 MiB**。我们已将默认服务账户作为 **运行时服务账户** 与此函数关联。我们将保留
    **自动扩展** 在默认设置，但可以将此设置为函数的最大实例数。
- en: We can add **Runtime environment variables** underneath the **RUNTIME** tab
    if we have such a requirement to do so. We will not add any environment variables
    for our Cloud Function.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有这样的需求，我们可以在**运行时**选项卡下添加**运行时环境变量**。我们不会为我们的云函数添加任何环境变量。
- en: Underneath the **BUILD** tab, there is an option to add **Build environment
    variables**. We will not add any variable for our Cloud Function.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建**选项卡下，有一个选项可以添加**构建环境变量**。我们不会为我们的云函数添加任何变量。
- en: Underneath the **CONNECTIONS** tab, we can leave the default settings as they
    are and allow all traffic to access our Cloud Function.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**连接**选项卡下，我们可以保留默认设置，允许所有流量访问我们的云函数。
- en: After setting the Cloud Function's runtime, build, and connection settings,
    the next step will be to add the implementation code for this Cloud Function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置云函数的运行时、构建和连接设置后，下一步将是添加此云函数的实现代码。
- en: Adding Python code to a Cloud Function
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Python代码添加到云函数中
- en: 'After clicking on the **Next** button, as shown in *Figure 12.3*, the GCP Console
    will offer us a view to define or add the function implementation details, as
    shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击如图12.3所示的**下一步**按钮后，GCP控制台将提供一个视图来定义或添加函数实现细节，如下面的截图所示：
- en: '![Figure 12.4 – The implementation steps of a Cloud Function using the GCP
    Console'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 使用GCP控制台实现云函数的步骤](img/B17189_12_04.jpg)'
- en: '](img/B17189_12_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_12_04.jpg](img/B17189_12_04.jpg)'
- en: Figure 12.4 – The implementation steps of a Cloud Function using the GCP Console
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 使用GCP控制台实现云函数的步骤
- en: 'The options that are available for adding our Python code are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于添加我们的Python代码的选项如下：
- en: We can select several runtime options such as Java, PHP, Node.js, or various
    Python versions. We selected **Python 3.8** as the **Runtime** for our Cloud Function.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择多个运行时选项，例如Java、PHP、Node.js或各种Python版本。我们选择了**Python 3.8**作为云函数的**运行时**。
- en: The **Entry point** attribute must be the name of the function in our code.
    Google Cloud Function will invoke the function in our code based on this **Entry
    point** attribute.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口点**属性必须是我们的代码中函数的名称。Google Cloud Function将根据此**入口点**属性调用我们的代码中的函数。'
- en: The Python source code can be added inline using the **Inline Editor** on the
    right-hand side; alternatively, it can be uploaded using a ZIP file from your
    local machine or even from cloud storage. We can also provide the GCP **Cloud
    Source** repository location for the source code. Here, we selected to implement
    our function using the **Inline Editor** tool.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用右侧的**内联编辑器**将Python源代码内联添加；或者，可以使用从本地机器或云存储的ZIP文件上传。我们还可以提供GCP **云源**存储库位置以存储源代码。在这里，我们选择了使用**内联编辑器**工具来实现我们的函数。
- en: 'For Python, the GCP Cloud Functions platform automatically creates two files:
    `main.py` and `requirements.txt`. The `main.py` file will have our code implementation
    and the `requirements.txt` file should contain our dependencies on third-party
    libraries.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python，GCP云函数平台会自动创建两个文件：`main.py`和`requirements.txt`。`main.py`文件将包含我们的代码实现，而`requirements.txt`文件应包含我们对第三方库的依赖。
- en: A sample code, which is shown inside the `requester` attribute in the HTTP request
    or not. Based on the `requester` attribute value, we will send a welcome message
    with today's date and time. We implemented a similar code example with two separate
    web APIs using a Flask web application in [*Chapter 9*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247),
    *Python Programming for the Cloud*, to demonstrate the capabilities of GCP App
    Engine.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个示例代码，该代码在HTTP请求中的`requester`属性内显示或未显示。根据`requester`属性值，我们将发送包含今天日期和时间的欢迎信息。我们在[*第9章*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247)，“云中的Python编程”中，使用Flask
    Web应用程序实现了类似的代码示例，以展示GCP App Engine的功能。
- en: Once we are satisfied with our Python code, we will deploy the function on the
    Google Cloud Functions platform.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对Python代码满意后，我们将在Google Cloud Functions平台上部署该函数。
- en: Deploying a Cloud Function
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署云函数
- en: The next step is to deploy this function using the **Deploy** button at the
    bottom of the screen, as shown in *Figure 12.4*. GCP will start deploying the
    function immediately, and it can take a few minutes to complete this activity.
    It is important to understand that Google Cloud Functions are deployed using containers
    just like microservices on GCP Cloud Run. The key differences are that they can
    be invoked using different types of events and they use the pay-as-you-use pricing
    model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用屏幕底部的 **部署** 按钮部署此函数，如图 *图 12.4* 所示。GCP 将立即开始部署函数，这可能需要几分钟才能完成此活动。重要的是要理解
    Google Cloud Functions 与 GCP Cloud Run 上的微服务一样，使用容器进行部署。它们的主要区别在于可以使用不同类型的事件进行调用，并且使用按使用付费的定价模式。
- en: 'Once our function has been deployed, we can duplicate it, test it, or delete
    it from the **Cloud Functions** list, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数部署后，我们可以复制它、测试它或从 **云函数** 列表中删除它，如图下所示截图：
- en: '![Figure 12.5 – The main view of Google Cloud Functions'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – Google Cloud Functions 的主视图]'
- en: '](img/B17189_12_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17189_12_05.jpg]'
- en: Figure 12.5 – The main view of Google Cloud Functions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – Google Cloud Functions 的主视图
- en: 'Now, we will quickly show you how convenient it is to test and troubleshoot
    our Cloud Function using the GCP Console. Once we have selected the `requester`
    attribute in JSON format, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将快速向您展示如何方便地使用 GCP 控制台测试和调试我们的云函数。一旦我们选择了 JSON 格式的 `requester` 属性，如下所示：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After clicking on `CURL` utility from anywhere on the internet. However, we
    have to make sure that our Cloud Function includes `allUsers` as its member with
    the role of `Cloud Functions Invoker`. This can be set underneath the **PERMISSIONS**
    tab. However, we do not recommend doing so without setting an authentication mechanism
    for your Cloud Function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上的任何地方点击 `CURL` 工具。然而，我们必须确保我们的云函数包含 `allUsers` 作为其成员，并具有 `Cloud Functions
    Invoker` 的角色。这可以在 **权限** 选项卡下设置。然而，我们不推荐在不为您的云函数设置身份验证机制的情况下这样做：
- en: '![Figure 12.6 – Testing your Cloud Function using the GCP Console'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 使用 GCP 控制台测试您的云函数]'
- en: '](img/B17189_12_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17189_12_06.jpg]'
- en: Figure 12.6 – Testing your Cloud Function using the GCP Console
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 使用 GCP 控制台测试您的云函数
- en: Building a simple Cloud Function using the GCP Console is a straightforward
    process. Next, we will explore a case study of a real-world application of Cloud
    Functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GCP 控制台构建简单的云函数是一个简单的过程。接下来，我们将探讨云函数在现实世界中的应用案例研究。
- en: Case study – building a notification app for cloud storage events
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 为云存储事件构建通知应用程序
- en: 'In this case study, we will develop a Cloud Function that is triggered for
    events on a **Google Storage bucket**. On receiving such an event, our Cloud Function
    will send an email to a predefined list of email addresses as a notification.
    The flow of this notification app with a Cloud Function appears as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我们将开发一个云函数，该函数在 **Google Storage 存储桶** 上的事件触发时执行。在接收到此类事件后，我们的云函数将向预定义的电子邮件地址列表发送电子邮件作为通知。此通知应用程序与云函数的流程如下所示：
- en: '![Figure 12.7 – A Cloud Function listening to Google storage bucket events'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 监听 Google 存储桶事件的云函数]'
- en: '](img/B17189_12_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17189_12_07.jpg]'
- en: Figure 12.7 – A Cloud Function listening to Google storage bucket events
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 监听 Google 存储桶事件的云函数
- en: 'Note that we can set our Cloud Function to listen to one or more Google Storage
    events. Google Cloud Functions supports the following Google Storage events:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以将我们的云函数设置为监听一个或多个 Google Storage 事件。Google Cloud Functions 支持以下 Google
    Storage 事件：
- en: '**finalize**: This event is created when a new file is added or replaced within
    a storage bucket.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**：当在存储桶中添加或替换新文件时创建此事件。'
- en: '**delete**: This event represents the deletion of a file from a storage bucket.
    This applies to non-versioning buckets. Note that a file is not deleted in reality,
    but it is archived if the bucket is set to use versioning.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：此事件表示从存储桶中删除文件。这适用于非版本化存储桶。请注意，实际上文件并未被删除，但如果存储桶设置为使用版本控制，则文件会被存档。'
- en: '**archive**: This event is raised when a file is archived. The archive operation
    is triggered when a file is deleted or overwritten for buckets with versioning.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存档**：当文件存档时引发此事件。存档操作是在文件被删除或覆盖时触发的，适用于具有版本控制的存储桶。'
- en: '**metadata update**: If there is any update in the metadata of a file, this
    event is created.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据更新**：如果文件元数据有任何更新，将创建此事件。'
- en: After receiving an event from a Google Storage bucket, the Cloud Function will
    extract the attributes from the context and event objects passed as arguments
    to our Cloud Function. Then, the cloud function will use a third-party email service
    (such as *SendGrid* from *Twilio*) to send the notification.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到来自 Google Storage 存储桶的事件后，Cloud Function 将从作为参数传递给我们的 Cloud Function 的上下文和事件对象中提取属性。然后，云函数将使用第三方电子邮件服务（例如来自
    *Twilio* 的 *SendGrid*）来发送通知。
- en: As a prerequisite, you have to create a free account with *SendGrid* ([https://sendgrid.com/](https://sendgrid.com/)).
    After creating an account, you will need to create at least one sender user inside
    your *SendGrid* account. Additionally, you will need to set up a secret API key
    inside the *SendGrid* account that can be used with the Cloud Function to send
    emails. Twilio SendGrid offers within the range of *100* emails per day for free,
    which is good enough for testing purposes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，你必须创建一个 *SendGrid* 的免费账户（[https://sendgrid.com/](https://sendgrid.com/)）。创建账户后，你需要在
    *SendGrid* 账户内创建至少一个发送用户。此外，你还需要在 *SendGrid* 账户内设置一个秘密 API 密钥，该密钥可以与 Cloud Function
    一起使用来发送电子邮件。Twilio SendGrid 提供每天 *100* 封免费电子邮件，这对于测试目的来说已经足够好了。
- en: 'For this case study, we will write our Python code for the Cloud Function locally
    and then deploy it to the Google Cloud Functions platform using the Cloud SDK.
    We will implement this notification application step by step, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例研究，我们将本地编写 Cloud Function 的 Python 代码，然后使用 Cloud SDK 将其部署到 Google Cloud
    Functions 平台。我们将逐步实现这个通知应用，如下所示：
- en: 'We will create a storage bucket to attach to our Cloud Function, and we will
    upload or delete files from this bucket to simulate the events of our Cloud Function.
    We can use the following Cloud SDK command to create a new bucket:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个存储桶来附加到我们的 Cloud Function，并从这个存储桶上传或删除文件来模拟 Cloud Function 的事件。我们可以使用以下
    Cloud SDK 命令来创建一个新的存储桶：
- en: '[PRE1]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To keep the generation of these events simple, we will turn off the versioning
    on our storage bucket by using the following Cloud SDK command:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化这些事件的生成，我们将使用以下 Cloud SDK 命令关闭我们的存储桶的版本控制：
- en: '[PRE2]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the storage bucket is ready, we will create a local project directory
    and set up a virtual environment using the following commands:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦存储桶准备就绪，我们将创建一个本地项目目录，并使用以下命令设置虚拟环境：
- en: '[PRE3]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will install the `sendgrid` Python package using the `pip` utility,
    as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `pip` 工具安装 `sendgrid` Python 包，如下所示：
- en: '[PRE4]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once our third-party libraries have been installed, we will need to create
    the `requirements.txt` dependencies file, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的第三方库已经安装，我们需要创建一个 `requirements.txt` 依赖文件，如下所示：
- en: '[PRE5]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will create a new Python file (`main.py`) with a `handle_storage_event`
    function within it. This function will be the entry point for our Cloud Function.
    The sample code for this entry point function is as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的 Python 文件（`main.py`），在其中包含一个 `handle_storage_event` 函数。这个函数将是我们的
    Cloud Function 的入口点。这个入口点函数的示例代码如下：
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have our Python code file (in our case, this is `main.py`) and `requirements.txt`
    files ready, we can trigger the deployment operation using the following Cloud
    SDK command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们准备好了我们的 Python 代码文件（在我们的例子中，这是 `main.py`）和 `requirements.txt` 文件，我们就可以使用以下
    Cloud SDK 命令来触发部署操作：
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we deploy our Cloud Function, we can test it by uploading a local file
    to our storage bucket using the Cloud SDK command, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们部署了 Cloud Function，我们可以通过使用 Cloud SDK 命令将本地文件上传到我们的存储桶来测试它，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: gcloud functions logs read --limit 50
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: gcloud functions logs read --limit 50
- en: '[PRE9]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For this notification app, we attached our Cloud Function to the `Finalize`
    event only. However, what if want to attach another event type as well, such as
    a `Delete` event? Well, only one Cloud Function can be attached to one trigger
    event. But hold on, a Cloud Function is a deployment entity and not the actual
    program code. This means we do not need to write or duplicate our Python code
    to handle another type of event. We can create a new Cloud Function using the
    same Python code but for the `Delete` event, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个通知应用，我们只将其 Cloud Function 附加到 `Finalize` 事件。然而，如果我们还想附加另一个事件类型，比如 `Delete`
    事件呢？嗯，一个 Cloud Function 只能附加到一个触发事件。但是等等，Cloud Function 是一个部署实体，而不是实际的程序代码。这意味着我们不需要编写或复制我们的
    Python 代码来处理另一种类型的事件。我们可以创建一个新的 Cloud Function，使用相同的 Python 代码，但针对 `Delete` 事件，如下所示：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you notice this version of the `deploy` command, the only changes we made
    were with the *name* of the Cloud Function and the *type* of the trigger event.
    This `deploy` command will create a new Cloud Function and will work in parallel
    to an earlier Cloud Function but will be triggered based on a different event
    (in this case, this is `delete`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到这个版本的`deploy`命令，我们所做的唯一更改是云函数的**名称**和触发事件的**类型**。这个`deploy`命令将创建一个新的云函数，并且将与早期创建的云函数并行工作，但将基于不同的事件触发（在这种情况下，这是`delete`）。
- en: 'To test the `delete` event with our newly added Cloud Function, we can remove
    the already uploaded file (or any file) from our storage bucket using the following
    Cloud SDK command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们新添加的云函数的`delete`事件，我们可以使用以下Cloud SDK命令从我们的存储桶中删除已上传的文件（或任何文件）：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can create more Cloud Functions using the same Python code for other storage
    events. This concludes our discussion of how to build Cloud Functions for storage
    events using the Cloud SDK. All the steps discussed using the Cloud SDK can also
    be implemented using the GCP Console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的Python代码为其他存储事件创建更多的云函数。这标志着我们使用Cloud SDK构建存储事件云函数讨论的结束。使用Cloud SDK讨论的所有步骤也可以使用GCP控制台实现。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced serverless computing and FaaS, followed by an
    analysis of the main ingredients of serverless functions. Next, we discussed the
    key benefits of serverless functions and their pitfalls. Additionally, we analyzed
    several deployment options that are available to build and deploy serverless functions,
    and these options include AWS Lambda, Azure Functions, Google Cloud Functions,
    Oracle Fn, and IBM Cloud Functions. In the final part of this chapter, we built
    a simple Google Cloud Function based on an HTTP trigger using the GCP Console.
    Then, we built a notification app based on Google storage events and a Google
    Cloud Function using the Cloud SDK. These serverless functions were deployed using
    the Google Cloud Functions platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了无服务器计算和FaaS，随后分析了无服务器函数的主要成分。接下来，我们讨论了无服务器函数的关键优势和潜在问题。此外，我们还分析了可用于构建和部署无服务器函数的几种部署选项，包括AWS
    Lambda、Azure Functions、Google Cloud Functions、Oracle Fn和IBM Cloud Functions。在本章的最后部分，我们基于HTTP触发器使用GCP控制台构建了一个简单的Google
    Cloud Function。然后，我们使用Cloud SDK构建了一个基于Google存储事件的提醒应用和Google Cloud Function。这些无服务器函数使用Google
    Cloud Functions平台进行部署。
- en: The code examples included in this chapter should provide you with some experience
    of how to use both the GCP Console and the Cloud SDK to build and deploy Cloud
    Functions. This hands-on knowledge is beneficial for anyone who is looking to
    build a career in serverless computing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的代码示例应能为您提供一些使用GCP控制台和Cloud SDK构建和部署云函数的经验。这种实践经验对于希望从事无服务器计算职业的人来说是有益的。
- en: In the next chapter, we will explore how to use Python with machine learning.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Python进行机器学习。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are serverless functions different from microservices?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器函数与微服务有何不同？
- en: What is the practical use of serverless functions in real-world examples?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器函数在现实世界中的实际用途是什么？
- en: What are Durable functions and who offers them?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是持久化函数，谁提供它们？
- en: One Cloud Function can be attached to multiple triggers. Is this true or false?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个云函数可以附加到多个触发器。这是真的还是假的？
- en: Further reading
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Serverless Computing with Google Cloud* by Richard Rose'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用Google Cloud进行无服务器计算》由Richard Rose所著
- en: '*Mastering AWS Lambda* by Yohan Wadia'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《精通AWS Lambda》由Yohan Wadia所著
- en: '*Mastering Azure Serverless Computing* by Lorenzo Barbieri and Massimo Bonanni'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《精通Azure无服务器计算》由Lorenzo Barbieri和Massimo Bonanni所著
- en: '*Google Cloud Functions Quickstart tutorials* for building and deploying Cloud
    Functions, which is available at [https://cloud.google.com/functions/docs/quickstarts](https://cloud.google.com/functions/docs/quickstarts)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Google Cloud Functions快速入门教程》用于构建和部署云函数，可在[https://cloud.google.com/functions/docs/quickstarts](https://cloud.google.com/functions/docs/quickstarts)找到
- en: Answers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Both are two different offerings of serverless computing. Typically, serverless
    functions are triggered by an event and are based on the *pay-as-you-use* model.
    In comparison, microservices are typically consumed through API calls and are
    not based on the *pay-as-you-use* model.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两种都是无服务器计算的不同提供方式。通常，无服务器函数由事件触发，并基于**按使用付费**的模式。相比之下，微服务通常通过API调用进行消费，并且不基于**按使用付费**的模式。
- en: Amazon Alexa uses AWS Lambda functions to provide intelligence and other skills
    for its users.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚马逊Alexa使用AWS Lambda函数为用户提供智能和其他技能。
- en: Durable functions are an extension of Microsoft Azure Functions, which offers
    stateful functionality in a serverless environment.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可持久函数是微软Azure Functions的扩展，它在一个无服务器环境中提供了有状态的功能。
- en: False. One Cloud Function can only be attached to a single trigger.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。一个云函数只能附加到一个触发器。
