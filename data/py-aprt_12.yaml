- en: Chapter 7 - Comprehensions, iterables, and generators
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章 - 推导式、可迭代对象和生成器
- en: The abstract notion of a *sequence of objects* is ubiquitous in programming.
    It can be used to model such widely different concepts as simple strings, lists
    of complex objects, and indefinitely long sensor output streams. It probably won’t
    surprise you to learn that Python includes some very powerful and elegant tools
    for working with sequences. In fact, Python’s support for creating and manipulating
    sequences is one of the highlights of the language for many people.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象序列*的抽象概念在编程中是无处不在的。它可以用来模拟简单的字符串、复杂对象的列表和无限长的传感器输出流等各种概念。也许你不会感到惊讶的是，Python
    包含了一些非常强大和优雅的工具来处理序列。事实上，Python 对于创建和操作序列的支持是许多人认为这门语言的亮点之一。'
- en: 'In this chapter we’ll look at three key tools that Python provides for working
    with sequences: comprehensions, iterables, and generators. *Comprehensions* comprise
    a dedicated syntax for creating various types of sequences declaratively. *Iterables*
    and the *iteration protocols* form the core abstraction and API for sequences
    and iteration in Python; they allow you define new sequence types and exert fine-grained
    control over iteration. Finally, *generators* allow us to define lazy sequences
    imperatively, a surprisingly powerful technique in many circumstances.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看到 Python 提供的三个用于处理序列的关键工具：推导式、可迭代对象和生成器。*推导式*包括了一个专门的语法，用于声明性地创建各种类型的序列。*可迭代对象*和*迭代协议*构成了
    Python 中序列和迭代的核心抽象和 API；它们允许你定义新的序列类型，并对迭代进行精细控制。最后，*生成器*允许我们以命令式的方式定义惰性序列，在许多情况下是一种令人惊讶的强大技术。
- en: Let’s jump right in to comprehensions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入推导式。
- en: Comprehensions
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推导式
- en: Comprehensions in Python are a concise syntax for describing lists, sets or
    dictionaries in a declarative or functional style. This short-hand is readable
    and expressive, meaning that comprehensions are very effective at communicating
    intent to human readers. Some comprehensions almost read like natural language,
    making them nicely self-documenting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，推导式是一种简洁的语法，用于以声明性或函数式风格描述列表、集合或字典。这种简写是可读的和表达性强的，这意味着推导式非常有效地传达了人类读者的意图。一些推导式几乎读起来像自然语言，使它们成为很好的自我文档化。
- en: List comprehensions
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表推导式
- en: 'As hinted at above, a *list comprehension* is a short-hand way of creating
    a list. It’s an expression using a succinct syntax that describes *how list elements
    are defined*. Comprehensions are much easier to demonstrate than they are to explain,
    so let’s bring up a Python REPL. First we’ll create a list of words by splitting
    a string:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，*列表推导式*是创建列表的一种简写方式。它是使用简洁的语法来描述*如何定义列表元素*的表达式。推导式比解释更容易演示，所以让我们打开一个 Python
    REPL。首先，我们将通过拆分一个字符串来创建一个单词列表：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now comes the list comprehension. The comprehension is enclosed in square brackets
    just like a literal list, but instead of literal elements it contains a fragment
    of declarative code which describes how to construct the elements of the list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是列表推导式的时候了。推导式被包含在方括号中，就像一个字面上的列表一样，但它包含的不是字面上的元素，而是一段描述如何构造列表元素的声明性代码片段。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the new list is formed by binding the name `word` to each value in `words`
    in turn and then evaluating `len(word)` to create the corresponding value in the
    new list. In other words, this constructs a new list containing the lengths of
    the string in `words`; it’s hard to imagine a much more effective way of expressing
    that new list!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，新列表是通过将名称`word`依次绑定到`words`中的每个值，然后评估`len(word)`来创建新列表中的相应值而形成的。换句话说，这构建了一个包含`words`中字符串长度的新列表；很难想象有更有效地表达这个新列表的方式了！
- en: List comprehension syntax
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表推导式语法
- en: 'The general form for a list comprehension is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的一般形式是：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is, for each `item` in the `iterable` on the right we evaluate the expression
    `expr(item)` on the left (which is almost always, but not necessarily, in terms
    of the item). We use the result of that expression as the next element of the
    list we are constructing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，对于右侧的`iterable`中的每个`item`，我们在左侧评估`expr(item)`表达式（几乎总是，但不一定是关于该项的）。我们使用该表达式的结果作为我们正在构建的列表的下一个元素。
- en: 'The comprehension above is the declarative equivalent of the following imperative
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的推导式是以下命令式代码的声明性等价物：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Elements of a list comprehension
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表推导式的元素
- en: Note that the source object over which we iterate in a list comprehension doesn’t
    need to be a list itself. It can be any object with implements the iterable protocol
    ^([15](chap21.xhtml#fn-cover-iterable-protocol-later)), such as a tuple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在列表推导式中我们迭代的源对象不需要是列表本身。它可以是任何实现了可迭代协议的对象，比如元组。
- en: 'The expression part of the comprehension can be any Python expression. Here
    we find the number of decimal digits in each of the first 20 factorials using
    `range()` — which is an iterable object — to generate the source sequence:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式的表达式部分可以是任何 Python 表达式。在这里，我们使用 `range()` 来找出前20个阶乘中每个数的十进制位数 —— `range()`
    是一个可迭代对象 —— 以生成源序列。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note also that the type of the object produced by list comprehensions is nothing
    more or less than a regular `list`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，列表推导式产生的对象类型只不过是一个普通的 `list`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It’s important to keep this fact in mind as we look at other kinds of comprehensions
    and consider how to perform iteration over infinite sequences.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看其他类型的推导式并考虑如何对无限序列进行迭代时，牢记这一点是很重要的。
- en: Set comprehensions
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'Sets support a similar comprehension syntax using, as you might expect, curly
    braces. Our previous “number of digits in factorials” result contained duplicates,
    but by building a set instead of a list we can eliminate them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 集合支持类似的推导式语法，使用的是花括号，正如你所期望的那样。我们之前的“阶乘中的数字位数”结果包含了重复项，但通过构建一个集合而不是一个列表，我们可以消除它们：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like list comprehensions, set comprehension produce standard `set` objects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表推导式类似，集合推导式产生标准的 `set` 对象：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, since sets are unordered containers, the resulting set is not *necessarily*
    stored in a meaningful order.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于集合是无序容器，所以结果集不一定以有意义的顺序存储。
- en: Dictionary comprehensions
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典理解
- en: 'The third type of comprehension is the dictionary comprehension. Like the set
    comprehension syntax, the dictionary comprehension also uses curly braces. It
    is distinguished from the set comprehension by the fact that we now provide two
    colon-separated expressions — the first for the key and the second for the value
    — which will be evaluated in tandem for each new item in the resulting dictionary.
    Here’s a dictionary we can play with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种理解类型是字典理解。与集合理解语法类似，字典理解也使用大括号。它与集合理解的区别在于，我们现在提供了两个以冒号分隔的表达式 - 第一个用于键，第二个用于值
    - 这将同时为结果字典中的每个新项目进行评估。这是一个我们可以玩的字典：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One nice use for a dictionary comprehension is to invert a dictionary so we
    can perform efficient lookups in the opposite direction:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字典理解的一个很好的用途是反转字典，这样我们就可以在相反的方向上执行高效的查找：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that dictionary comprehensions do not operate directly on dictionary sources!^([16](chap21.xhtml#fn-dictionary-sources))
    If we want both keys and values from a source dictionary, then we should use the
    `items()` method coupled with tuple unpacking to access the keys and values separately.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字典理解不直接作用于字典源！^([16](chap21.xhtml#fn-dictionary-sources)) 如果我们想要从源字典中获取键和值，那么我们应该使用`items()`方法结合元组解包来分别访问键和值。
- en: 'Should your comprehension produce some identical keys, later keys will overwrite
    earlier keys. In this example we map the first letters of words to the words themselves,
    but only the last h-word is kept:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的理解应该产生一些相同的键，后面的键将覆盖先前的键。在这个例子中，我们将单词的首字母映射到单词本身，但只保留最后一个h开头的单词：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Comprehension complexity
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解的复杂性
- en: 'Remember that there’s no limit to the complexity of the expression you can
    use in any of the comprehensions. For the sake of your fellow programmers, though,
    you should avoid going overboard. Instead, extract complex expressions into separate
    functions to preserve readability. The following is close to the limit of being
    reasonable for a dictionary comprehension:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以在任何理解中使用的表达式的复杂性没有限制。但是为了你的同行程序员着想，你应该避免过度。相反，将复杂的表达式提取到单独的函数中以保持可读性。以下是接近于字典理解的合理限制：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This uses the `glob` module to find all of the Python source files in a directory.
    It then creates a dictionary of paths to file sizes from those files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`glob`模块在目录中查找所有的Python源文件。然后它创建了一个从这些文件中的路径到文件大小的字典。
- en: Filtering comprehensions
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤理解
- en: All three types of collection comprehension support an optional filtering clause
    which allows us to choose which items of the source are evaluated by the expression
    on the left. The filtering clause is specified by adding `if <boolean expression>`
    after the sequence definition of the comprehension; if the boolean expression
    returns false for an item in the input sequence, then no value is evaluated for
    that item in the result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种集合理解类型都支持一个可选的过滤子句，它允许我们选择由左侧表达式评估的源的哪些项目。过滤子句是通过在理解的序列定义之后添加`if <boolean
    expression>`来指定的；如果布尔表达式对输入序列中的项目返回false，则在结果中不会对该项目进行评估。
- en: 'To make this interesting, we’ll first define a function that determines if
    its input is a prime number:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个有趣，我们首先定义一个确定其输入是否为质数的函数：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now use this in the filtering clause of a list comprehension to produce
    all primes less than 100:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在列表理解的过滤子句中使用这个来产生小于100的所有质数：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Combining filtering and transformation
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结合过滤和转换
- en: 'We have a slightly odd-looking `x for x` construct here because we’re not applying
    any transformation to the filtered values; the expression in terms of `x` is simply
    `x` itself. There’s nothing to stop us, however, from combining a filtering predicate
    with a transforming expression. Here’s a dictionary comprehension which maps numbers
    with exactly three divisors to a tuple of those divisors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个看起来有点奇怪的`x for x`构造，因为我们没有对过滤值应用任何转换；关于`x`的表达式只是`x`本身。然而，没有什么能阻止我们将过滤谓词与转换表达式结合起来。这是一个将具有三个约数的数字映射到这些约数的元组的字典理解：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '* * *'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅的时刻
- en: '![](images/m07----zen-simple-is-better-than-complex.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m07----zen-simple-is-better-than-complex.png)'
- en: Comprehensions are often more readable than the alternative. However it’s possible
    to over-use comprehensions. Sometimes a long or complex comprehension may be *less*
    readable than the equivalent for-loop. There is no hard-and-fast rule about when
    one form should be preferred, but be conscientious when writing your code and
    try to choose the best form for your situation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 理解通常比替代方法更易读。然而，过度使用理解是可能的。有时，一个长或复杂的理解可能比等价的for循环*更*难读。关于何时应该优先选择哪种形式没有硬性规定，但在编写代码时要谨慎，并尽量选择适合你情况的最佳形式。
- en: Above all your comprehensions should ideally be purely functional — that is
    they should have no side effects. If you need to create side effects, such as
    printing to the console during iteration, use another construct such as a for-loop
    instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的理解理想上应该是纯函数的 - 也就是说，它们不应该有任何副作用。如果你需要创建副作用，比如在迭代过程中打印到控制台，那么使用另一种构造，比如for循环。
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Iteration protocols
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代协议
- en: 'Comprehensions and for-loops are the most frequently used language features
    for performing iteration. The both take items one by one from a source and do
    something with each in turn. However, both comprehensions and for-loops iterate
    over the whole sequence by default, whereas sometimes more fine-grained control
    is needed. In this section we’ll see how you can exercise this kind of fine-grained
    control by investigating two important concepts on top of which a great deal of
    Python language behavior is constructed: *iterable* objects and *iterator* objects,
    both of which are reflected in standard Python protocols.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理解迭代的最常用语言特性是推导和for循环。它们都从源中逐个获取项目并依次处理。然而，推导和for循环默认情况下都会遍历整个序列，有时需要更精细的控制。在本节中，我们将看到如何通过研究两个重要概念来实现这种精细控制，这两个概念构成了大量Python语言行为的基础：*可迭代*对象和*迭代器*对象，这两个对象都反映在标准Python协议中。
- en: The *iterable protocol* defines an API that iterable objects must implement.
    That is, if you want to be able to iterate over an object using for-loops or comprehensions,
    that object must implement the iterable protocol. Built-in classes like `list`
    implement the iterable protocol. You can pass an object that implements the iterable
    protocol to the built-in `iter()` function to get an *iterator* for the iterable
    object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*可迭代协议*定义了可迭代对象必须实现的API。也就是说，如果要使用for循环或推导来迭代对象，该对象必须实现可迭代协议。内置类如`list`实现了可迭代协议。您可以将实现可迭代协议的对象传递给内置的`iter()`函数，以获取可迭代对象的*迭代器*。'
- en: '*Iterator*s, for their part, support the *iterator protocol*. This protocol
    requires that we can pass the iterator object to the built-in `next()` function
    to fetch the next value from the underlying collection.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*则支持*迭代器协议*。该协议要求我们可以将迭代器对象传递给内置的`next()`函数，以从底层集合中获取下一个值。'
- en: An example of the iteration protocols
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代协议的示例
- en: 'As usual, a demonstration at the Python REPL will help all of these concepts
    crystallize into something you can work with. We start with a list of the names
    of the seasons as our iterable object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在Python REPL上进行演示将有助于将所有这些概念凝结成可以操作的东西。我们从一个包含季节名称的列表作为我们的可迭代对象开始：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then ask our iterable object to give us an iterator using the `iter()` built-in:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要求可迭代对象使用内置的`iter()`给我们一个迭代器：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we request a value from the iterator using the `next()` built-in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用内置的`next()`从迭代器中请求一个值：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each call to `next()` moves the iterator through the sequence:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`next()`都会通过序列移动迭代器：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But what happens when we reach the end?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们到达末尾时会发生什么？
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In a spectacular display of liberalism, Python raises a `StopIteration` exception.
    Those of you coming from other programming languages with a more straight-laced
    approach to exceptions may find this mildly outrageous, but, really, what could
    be more exceptional than reaching the end of a collection? It only has one end
    after all!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，异常会引发`StopIteration`异常，这显示了Python的自由主义精神。那些来自对异常处理更为严格的其他编程语言的人可能会觉得这有点令人不安，但实际上，还有什么比到达集合的末尾更特殊的呢？毕竟它只有一个结束！
- en: This attempt at rationalizing the Python language design decision makes even
    more sense when one considers that the iterable series may be a potentially infinite
    stream of data. Reaching the end in that case really *would* be something to write
    home about, or indeed raise an exception for.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可迭代系列可能是潜在的无限数据流，这种尝试对Python语言设计决策进行合理化的做法更有意义。在这种情况下到达末尾确实是一件值得写信或引发异常的事情。
- en: A more practical example of the iteration protocols
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代协议的更实际的示例
- en: 'With for-loops and comprehensions at our fingertips, the utility of these lower
    level iteration protocols may not be obvious. To demonstrate a more concrete use,
    here’s a little utility function which, when passed an iterable object, returns
    the first item from that series or, if the series is empty, raises a `ValueError`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for循环和推导时，这些较低级别的迭代协议的实用性可能不太明显。为了演示更具体的用途，这里有一个小型实用函数，当传递一个可迭代对象时，它会返回该系列的第一个项目，或者如果该系列为空，则引发`ValueError`：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works as expected on any iterable object, in this case both a `list` and
    a `set`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这在任何可迭代对象上都能按预期工作，本例中包括`list`和`set`：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s worth noting that the higher-level iteration constructs, such as for-loops
    and comprehensions, are built directly upon this lower-level iteration protocol.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，高级迭代构造，如for循环和推导，直接建立在这种低级别的迭代协议之上。
- en: Generator functions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Now we come on to *generator functions*^([17](chap21.xhtml#fn-just-generator)),
    one of the most powerful and elegant features of the Python programming language.
    Python generators provide the means for describing iterable series with code in
    functions. These sequences are evaluated lazily, meaning they only compute the
    next value on demand. This important property allows them to model infinite sequences
    of values with no definite end, such as streams of data from a sensor or active
    log files. By carefully designing generator functions we can make generic stream
    processing elements which can be composed into sophisticated pipelines.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来介绍*生成器函数*^([17](chap21.xhtml#fn-just-generator))，这是Python编程语言中最强大和优雅的特性之一。Python生成器提供了使用函数中的代码描述可迭代系列的方法。这些序列是惰性求值的，这意味着它们只在需要时计算下一个值。这一重要特性使它们能够模拟没有明确定义结束的无限值序列，例如来自传感器的数据流或活动日志文件。通过精心设计生成器函数，我们可以制作通用的流处理元素，这些元素可以组合成复杂的管道。
- en: The `yield` keyword
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`yield`关键字'
- en: Generators are defined by any Python function which uses the `yield` keyword
    at least once in its definition. They may also contain the `return` keyword with
    no arguments, and just like any other function, there is an implicit `return`
    at the end of the definition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器由任何在其定义中至少使用一次`yield`关键字的Python函数定义。它们也可以包含没有参数的`return`关键字，就像任何其他函数一样，在定义的末尾有一个隐式的`return`。
- en: To understand what generators do, let’s start with a simple example at the Python
    REPL. Let’s define the generator, and then we’ll examine how the generator works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解生成器的作用，让我们从Python REPL中的一个简单示例开始。让我们定义生成器，然后我们将研究生成器的工作原理。
- en: 'Generator functions are introduced by `def`, just as for a regular Python function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数由`def`引入，就像普通的Python函数一样：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let’s call `gen123()` and assign its return value to `g`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用`gen123()`并将其返回值赋给`g`：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, `gen123()` is called just like any other Python function. But
    what has it returned?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`gen123()`就像任何其他Python函数一样被调用。但它返回了什么？
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generators are iterators
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器是迭代器
- en: '`g` is a generator object. Generators are, in fact, Python *iterators*, so
    we can use the iterator protocol to retrieve – or yield – successive values from
    the series:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`是一个生成器对象。生成器实际上是Python的*迭代器*，因此我们可以使用迭代器协议从系列中检索或产生连续的值：'
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Take note of what happens now that we’ve yielded the last value from our generator.
    Subsequent calls to `next()` raise a `StopIteration` exception, just like any
    other Python iterator:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们已经从生成器中产生了最后一个值后会发生什么。对`next()`的后续调用会引发`StopIteration`异常，就像任何其他Python迭代器一样：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because generators are iterators, and because iterators must also be iterable,
    they can be used in all the usual Python constructs which expect iterable objects,
    such as for-loops:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生成器是迭代器，而迭代器也必须是可迭代的，它们可以在所有期望可迭代对象的常规Python结构中使用，例如for循环：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Be aware that each call to the generator function returns a new generator object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对生成器函数的每次调用都会返回一个新的生成器对象：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also note how each generator object can be advanced independently:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意每个生成器对象可以独立推进：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When is generator code executed?
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器代码何时执行？
- en: 'Let’s take a closer look at how — and crucially *when* — the code in the body
    of our generator function is executed. To do this, we’ll create a slightly more
    complex generator that traces its execution with good old-fashioned print statements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们的生成器函数体中的代码是如何执行的，以及关键的*何时*执行。为了做到这一点，我们将创建一个稍微复杂一点的生成器，它将用老式的打印语句跟踪它的执行：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point the generator object has been created and returned, but none
    of the code within the body of the generator function has yet been executed. Let’s
    make an initial call to `next()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时生成器对象已经被创建并返回，但是生成器函数体内的代码尚未执行。让我们对`next()`进行初始调用：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See how, when we request the first value, the generator body runs up to and
    including the first `yield` statement. The code executes just far enough to literally
    `yield` the next value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我们请求第一个值时，生成器体运行到第一个`yield`语句为止。代码执行到足够的地方，以便字面上`yield`下一个值。
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we request the next value from the generator, execution of the generator
    function *resumes* at the point it left off, and continues running until the next
    `yield`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从生成器请求下一个值时，生成器函数的执行会在离开的地方*恢复*，并继续运行直到下一个`yield`：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After the final value has returned the next request causes the generator function
    to execute until it returns at the end of the function body, which in turn raises
    the expected `StopIteration` exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个值返回后，下一个请求会导致生成器函数执行，直到它在函数体的末尾返回，这将引发预期的`StopIteration`异常。
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we’ve seen how generator execution is initiated by calls to `next()`
    and interrupted by `yield` statements, we can progress to placing more complex
    code in our generator function body.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到生成器执行是通过对`next()`的调用来启动，并通过`yield`语句来中断，我们可以继续将更复杂的代码放在生成器函数体中。
- en: Maintaining explicit state in the generator function
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在生成器函数中保持显式状态
- en: Now we’ll look at how our generator functions, which resume execution each time
    the next value is requested, can maintain state in local variables. In the process
    of doing so, our generators will be both more interesting and more useful. We’ll
    be showing two generators which demonstrate lazy evaluation, and later we’ll combine
    them into a generator pipeline.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看我们的生成器函数如何在每次请求下一个值时恢复执行，并在本地变量中保持状态。在这个过程中，我们的生成器将变得更有趣和更有用。我们将展示两个演示惰性评估的生成器，稍后我们将把它们合并成一个生成器管道。
- en: 'The first stateful generator: `take()`'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一个有状态的生成器：`take()`
- en: 'The first generator we’ll look at is `take()` which retrieves a specified number
    of elements from the front of a sequence:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个生成器是`take()`，它从序列的前面检索指定数量的元素：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the function defines a generator because it contains at least one
    `yield` statement. This particular generator also contains a `return` statement
    to terminate the stream of yielded values. The generator uses a counter to keep
    track of how many elements have been yielded so far, returning when a request
    is made for any elements beyond that requested count.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该函数定义了一个生成器，因为它包含至少一个`yield`语句。这个特定的生成器还包含一个`return`语句来终止产生的值流。生成器使用一个计数器来跟踪到目前为止已经产生了多少元素，当请求超出请求的计数时返回。
- en: 'Since generators are lazy, and only produce values on request, we’ll drive
    execution with a for-loop in a `run_take()` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器是惰性的，并且只在请求时产生值，我们将在`run_take()`函数中使用for循环来驱动执行：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we create a source `list` named `items` which we pass to our generator
    function along with a count of `3`. Internally, the for-loop will use the iterator
    protocol to retrieve values from the `take()` generator until it terminates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`items`的源`list`，并将其与`3`一起传递给我们的生成器函数。在内部，for循环将使用迭代器协议从`take()`生成器中检索值，直到它终止。
- en: 'The second stateful generator: `distinct()`'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二个有状态的生成器：`distinct()`
- en: 'Now let’s bring our second generator into the picture. This generator function,
    called `distinct()`, eliminates duplicate items by keeping track of which elements
    it’s already seen in a `set`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把第二个生成器带入图片。这个名为`distinct()`的生成器函数通过跟踪它已经在`set`中看到的元素来消除重复项：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this generator we also make use of a control flow construct we have not
    previously seen: the `continue` keyword. The `continue` statement finishes the
    current iteration of the loop and begins the next iteration immediately. When
    executed in this case execution will be transferred back to the `for` statement,
    but as with `break` it can also be used with while-loops.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生成器中，我们还使用了一个之前没有见过的控制流构造：`continue`关键字。`continue`语句结束当前循环的迭代，并立即开始下一个迭代。在这种情况下执行时，执行将被转移到`for`语句，但与`break`一样，它也可以与while循环一起使用。
- en: 'In this case, the `continue` is used to skip any values which have already
    been yielded. We can add a `run_distinct()` function to exercise `distinct()`
    as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`continue`用于跳过已经产生的任何值。我们还可以添加一个`run_distinct()`函数来使用`distinct()`：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Understand these generators!
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解这些生成器！
- en: At this point you should spend some time exploring these two generators before
    moving on. Make sure you understand how they work and how control flows in and
    out of them as they maintain state. If you’re using an IDE to run these example,
    you can use the debugger to follow control flow by putting breakpoints in the
    generators and in the code that uses them. You can accomplish the same by using
    Python’s built-in `pdb` debugger (which we cover later) or even just by using
    old-fashioned print statements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该花一些时间探索这两个生成器，然后再继续。确保您了解它们的工作方式以及它们如何在维护状态时控制流进出。如果您正在使用IDE运行这些示例，您可以使用调试器通过在生成器和使用它们的代码中设置断点来跟踪控制流。您也可以使用Python的内置`pdb`调试器（我们稍后会介绍）或者甚至只是使用老式的打印语句来实现相同的效果。
- en: However you do it, make sure you’re really comfortable with how these generators
    work before moving to the next sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，确保在继续下一节之前，您真正了解这些生成器的工作方式。
- en: Lazy generator pipelines
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 惰性生成器管道
- en: 'Now that you understand the generators individually, we’ll arrange both of
    them into a lazy pipeline. We’ll be using `take()` and `distinct()` together to
    fetch the first three unique items from a collection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了单独的生成器，我们将把它们两个安排成一个惰性管道。我们将使用`take()`和`distinct()`一起从集合中获取前三个唯一的项目：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the `distinct()` generator only does just enough work to satisfy
    the demands of the `take()` generator which is iterating over it - it never gets
    as far as the last two items in the source list because they are not needed to
    produce the first three unique items. This lazy approach to computation is very
    powerful, but the complex control flows it produces can be difficult to debug.
    It’s often useful during development to force evaluation of all of the generated
    values, and this is most easily achieved by inserting a call to the `list()` constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`distinct()`生成器只做足够的工作来满足`take()`生成器的需求，后者正在迭代它 - 它永远不会到达源列表的最后两个项目，因为它们不需要产生前三个唯一的项目。这种对计算的懒惰方法非常强大，但它产生的复杂控制流可能很难调试。在开发过程中，强制评估所有生成的值通常很有用，最简单的方法是插入一个对`list()`构造函数的调用：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This interspersed call to `list()` causes the `distinct()` generator to exhaustively
    process its source items before `take()` does its work. Sometimes when you’re
    debugging lazily evaluated sequences, this can give you the insight you need to
    understand what’s going on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交错调用`list()`导致`distinct()`生成器在`take()`执行其工作之前彻底处理其源项目。有时，当您调试惰性计算的序列时，这可以让您了解正在发生什么。
- en: Laziness and the infinite
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 懒惰和无限
- en: 'Generators are lazy, meaning that computation only happens just-in-time when
    the next result is requested. This interesting and useful property of generators
    means they can be used to model infinite sequences. Since values are only produced
    as requested by the caller, and since no data structure needs to be built to contain
    the elements of the sequence, generators can safely be used to produce never-ending
    (or just very large) sequences like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是惰性的，这意味着计算只会在下一个结果被请求时才会发生。生成器的这种有趣和有用的特性意味着它们可以用来模拟无限序列。由于值只在调用者请求时产生，并且不需要构建数据结构来包含序列的元素，因此生成器可以安全地用于生成永无止境（或者只是非常大）的序列，比如：
- en: sensor readings
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器读数
- en: mathematical sequences (e.g. primes, factorials, etc.) ^([18](chap21.xhtml#fn-no-fibonacci))
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学序列（例如素数、阶乘等）^([18](chap21.xhtml#fn-no-fibonacci))
- en: the contents of a multi-terabyte file
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多太字节文件的内容
- en: Generating the Lucas series
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成Lucas系列
- en: 'Allow us to present a generator function for the Lucas series^([19](chap21.xhtml#fn-machete-order)):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个Lucas系列的生成器函数^([19](chap21.xhtml#fn-machete-order))：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Lucas series starts with `2, 1`, and each value after that is the sum of
    the two preceding values. So the first few value of the sequence are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Lucas系列以`2, 1`开始，之后每个值都是前两个值的和。因此，序列的前几个值是：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first `yield` produces the value `2`. The function then initializes `a`
    and `b` which hold the “previous two values” needed as the function proceeds.
    Then the function enters an infinite while-loop where:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`yield`产生值`2`。然后函数初始化`a`和`b`，它们保存着函数进行时所需的“前两个值”。然后函数进入一个无限的while循环，其中：
- en: It yields the value of `b`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它产生`b`的值
- en: '`a` and `b` are updated to hold the new “previous two” values using a neat
    application of tuple unpacking'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`和`b`被更新以保存新的“前两个”值，使用元组解包的巧妙应用'
- en: 'Now that we have a generator, it can be used like any other iterable object.
    For instance, to print the Lucas numbers you could use a loop like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个生成器，它可以像任何其他可迭代对象一样使用。例如，要打印Lucas数，您可以使用以下循环：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, since the Lucas sequence is infinite this will run forever, printing
    out values until your computer runs out of memory. Use Control-C to terminate
    the loop.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于Lucas序列是无限的，这将永远运行，打印出值，直到您的计算机耗尽内存。使用Control-C来终止循环。
- en: Generator expressions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'Generator expressions are a cross between comprehensions and generator functions.
    They use a similar syntax as comprehensions, but they result in the creation of
    a *generator object* which produces the specified sequence lazily. The syntax
    for generator expressions is very similar to list comprehensions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是推导和生成器函数之间的交叉。它们使用与推导类似的语法，但它们会产生一个*生成器对象*，该对象会懒惰地产生指定的序列。生成器表达式的语法与列表推导非常相似：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is delimited by parentheses instead of the brackets used for list comprehensions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它由括号界定，而不是用于列表推导的方括号。
- en: 'Generator expressions are useful for situations where you want the lazy evaluation
    of generators with the declarative concision of comprehensions. For example, this
    generator expression yields a list of the first one-million square numbers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式在您希望使用推导的声明性简洁性进行懒惰评估的情况下非常有用。例如，这个生成器表达式产生了前一百万个平方数的列表：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At this point, none of the squares have been created; we’ve just captured the
    specification of the sequence into a generator object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，还没有创建任何一个平方数；我们只是将序列的规范捕捉到了一个生成器对象中：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can force evaluation of the generator by using it to create a (long!) `list`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用它来创建一个（长！）`list`来强制评估生成器：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This list obviously consumes a significant chunk of memory - in this case about
    40 MB for the list object and the integer objects contained therein.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表显然消耗了大量的内存 - 在这种情况下，列表对象和其中包含的整数对象大约为40MB。
- en: Generator objects only run once
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成器对象只运行一次
- en: 'Notice that a generator object is just an iterator and, once run exhaustively
    in this way, will yield no more items. Repeating the previous statement returns
    an empty list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成器对象只是一个迭代器，一旦以这种方式耗尽，就不会再产生任何项目。重复前面的语句会返回一个空列表：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Generators are single use objects. Each time we call a generator *function*
    we create a new generator object. To recreate a generator from a generator expression
    we must execute the expression itself once more.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一次性对象。每次调用生成器*函数*时，我们都会创建一个新的生成器对象。要从生成器表达式中重新创建生成器，我们必须再次执行表达式本身。
- en: Iteration without memory
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无内存迭代
- en: 'Let’s raise the stakes by computing the sum of the first *ten* million squares
    using the built-in `sum()` function which accepts an iterable series of numbers.
    If we were to use a list comprehension we could expect this to consume around
    400 MB of memory. Using, a generator expression memory usage will be insignificant:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用内置的`sum()`函数来计算前*一千万*个平方数的和来提高赌注，该函数接受一个可迭代的数字序列。如果我们使用列表推导，我们可以期望它消耗大约400MB的内存。使用生成器表达式，内存使用将是微不足道的：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This produces a result in a second or so and uses almost no memory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一秒钟左右产生一个结果，并且几乎不使用内存。
- en: Optional parentheses
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选的括号
- en: Looking carefully, you see that in this case we didn’t supply separate enclosing
    parentheses for the generator expression in addition to those needed for the `sum()`
    function call. This elegant ability to have the parentheses used for the function
    call also serve for the generator expression aids readability. You can include
    the second set of parentheses if you wish.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，您会发现在这种情况下，我们没有为生成器表达式提供单独的括号，除了`sum()`函数调用所需的括号。这种优雅的能力使得用于函数调用的括号也可以用于生成器表达式，有助于可读性。如果您愿意，您可以包含第二组括号。
- en: Using an if-clause in generator expressions
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在生成器表达式中使用if子句
- en: 'As with comprehensions, you can include an if-clause at the end of the generator
    expression. Reusing our admittedly inefficient `is_prime()` predicate, we can
    determine the sum of those integers from the first thousand which are prime like
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与推导一样，您可以在生成器表达式的末尾包含一个if子句。重复使用我们承认效率低下的`is_prime()`谓词，我们可以这样确定前一千个整数中是质数的整数的总和：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that is is not the same thing as computing the sum of the first 1000 primes,
    which is a more awkward question because we don’t know in advance how many integers
    we need to test before we clock up a thousand primes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与计算前1000个质数的总和不同，这是一个更棘手的问题，因为我们事先不知道在我们累积了一千个质数之前需要测试多少个整数。
- en: “Batteries included” iteration tools
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “电池包含”迭代工具
- en: So far we’ve covered the many ways Python offers for creating iterable objects.
    Comprehensions, generators, and any object that follows the iterable or iterator
    protocols can be used for iteration, so it should be clear that iteration is a
    central feature of Python.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了Python提供的创建可迭代对象的许多方法。推导、生成器和遵循可迭代或迭代器协议的任何对象都可以用于迭代，因此应该清楚迭代是Python的一个核心特性。
- en: Python provides a number of built-in functions for performing common iterator
    operations. These functions form the core of a sort of *vocabulary* for working
    with iterators, and they can be combined to produce powerful statements in very
    concise, readable code. We’ve met some of these functions already, including `enumerate()`
    for producing integer indices and `sum()` for computing summation of numbers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了许多用于执行常见迭代器操作的内置函数。这些函数构成了一种用于处理迭代器的*词汇*，它们可以组合在一起，以产生非常简洁、可读的代码中的强大语句。我们已经遇到了其中一些函数，包括用于生成整数索引的`enumerate()`和用于计算数字总和的`sum()`。
- en: Introducing `itertools`
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍`itertools`
- en: In addition to the built-in functions, the `itertools` module contains a wealth
    of useful functions and generators for processing iterable streams of data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置函数之外，`itertools`模块还包含了大量用于处理可迭代数据流的有用函数和生成器。
- en: 'We’ll start demonstrating these functions by solving the first thousand primes
    problem using built-in `sum()` with two generator functions from `itertools`:
    `islice()` and `count()`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用内置的`sum()`和`itertools`中的两个生成器函数：`islice()`和`count()`来解决前一千个质数问题来开始演示这些函数。
- en: 'Earlier we made our own `take()` generator function for lazily retrieving the
    start of the sequence. We needn’t have bothered, however, because `islice()` allows
    us to perform lazy slicing similar to the built-in list slicing functionality.
    To get the first 1000 primes we need to do something like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们为了懒惰地检索序列的开头而制作了自己的`take()`生成器函数。然而，我们不需要费心，因为`islice()`允许我们执行类似于内置列表切片功能的懒惰切片。要获取前1000个质数，我们需要做类似这样的事情：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But how to generate `all_primes`? Previously, we’ve been using `range()` to
    create the raw sequences of integers to feed into our primality test, but ranges
    must always be finite, that is, bounded at both ends. What we’d like is an open
    ended version of `range()`, and that is exactly what `itertools.count()` provides.
    Using `count()` and `islice()`, our first thousand primes expression can be written
    out as:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何生成`all_primes`呢？以前，我们一直使用`range()`来创建原始的整数序列，以供我们的质数测试使用，但范围必须始终是有限的，即在两端都有界。我们想要的是`range()`的开放版本，这正是`itertools.count()`提供的。使用`count()`和`islice()`，我们的前1000个质数表达式可以写成：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This returns a special `islice` object which is iterable. We can convert it
    to a list using the list constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个特殊的`islice`对象，它是可迭代的。我们可以使用列表构造函数将其转换为列表。
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Answering our question about the sum of the first thousand primes is now easy,
    remembering to recreate the generators:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回答我们关于前1000个质数之和的问题很容易，记得重新创建生成器：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Sequences of booleans
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布尔序列
- en: Two other very useful built-ins which facilitate elegant programs are `any()`
    and `all()`. They’re equivalent to the logical operators `and` and `or` but for
    iterable series of `bool` values,
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个非常有用的内置函数是`any()`和`all()`。它们相当于逻辑运算符`and`和`or`，但适用于`bool`值的可迭代序列，
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here we’ll use `any()` together with a generator expression to answer the question
    of whether there are any prime numbers in the range 1328 to 1360 inclusive:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`any()`与生成器表达式一起来回答一个问题，即1328到1360范围内是否有任何质数：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For a completely different type of problem we can check that all of these city
    names are proper nouns with initial upper-case letters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全不同类型的问题，我们可以检查所有这些城市名称是否都是以大写字母开头的专有名词：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Merging sequences with `zip`
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`zip`合并序列
- en: 'The last built-in we’ll look at is `zip()`, which, as its name suggests, gives
    us a way to synchronise iterations over two iterable series. For example, let’s
    `zip` together two columns of temperature data, one from Sunday and one from Monday:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个内置函数是`zip()`，顾名思义，它给我们提供了一种同步迭代两个可迭代序列的方法。例如，让我们一起`zip`两列温度数据，一个来自星期日，一个来自星期一：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can see that `zip()` yields tuples when iterated. This in turn means we
    can use it with tuple unpacking in the for-loop to calculate the average temperature
    for each hour on these days:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当迭代时，`zip()`会产生元组。这反过来意味着我们可以在for循环中使用元组解包来计算这些天每小时的平均温度：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: More than two sequences with `zip()`
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`zip()`处理两个以上的序列
- en: 'In fact, `zip()` can accept any number of iterable arguments. Let’s add a third
    time-series and use other built-ins to calculate statistics for corresponding
    times:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`zip()`可以接受任意数量的可迭代参数。让我们添加第三个时间序列，并使用其他内置函数来计算相应时间的统计数据：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note how we’ve used string formatting features to control the numeric column
    width to four characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用字符串格式化功能来控制数字列的宽度为四个字符。
- en: Lazily concatenating sequences with `chain()`
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`chain()`懒惰地连接序列
- en: 'Perhaps, though, we’d like one long temperature series for Sunday, Monday and
    Tuesday. Rather than creating a new list by eagerly combining the three lists
    of temperatures, we can *lazily* concatenate iterables using `itertools.chain()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，我们想要一个长的星期日、星期一和星期二的温度序列。我们可以使用`itertools.chain()`来*懒惰地*连接可迭代对象，而不是通过急切地组合三个温度列表来创建一个新列表：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`temperatures` is an iterable object that first yields the values from `sunday`,
    followed by those from `monday`, and finally those from `tuesday`. Since it’s
    lazy, though, it never creates a single list that contains all of the elements;
    in fact, it never creates an intermediate list of any sort!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`temperatures`是一个可迭代对象，首先产生来自`星期日`的值，然后是来自`星期一`的值，最后是来自`星期二`的值。虽然它是懒惰的，但它从来不会创建一个包含所有元素的单个列表；事实上，它从来不会创建任何中间列表！'
- en: 'We can now check that all of those temperatures are above freezing point, without
    the memory impact of data duplication:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查所有这些温度是否都高于冰点，而不会造成数据重复的内存影响：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pulling it all together
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容汇总在一起
- en: 'Before we summarize, let’s pull a few pieces of what we have made together
    and leave your computer computing the Lucas primes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结之前，让我们把我们做的一些事情整合起来，让你的计算机计算卢卡斯质数：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When you’ve seen enough of these, we recommend you spend some time exploring
    the `itertools` module. The more you familiarize yourself with Python’s existing
    support for iterables, the more elegant and concise your own code will become.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看够了这些内容后，我们建议你花一些时间探索`itertools`模块。你越熟悉Python对可迭代对象的现有支持，你自己的代码就会变得更加优雅和简洁。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Comprehensions are a concise syntax for describing lists, sets and dictionaries.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解是描述列表、集合和字典的简洁语法。
- en: Comprehensions operate on a iterable source object and apply an optional predicate
    filter and a mandatory expression, both of which are usually in terms of the current
    item.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解操作可迭代源对象，并应用可选的谓词过滤器和强制表达式，这两者通常都是关于当前项目的。
- en: Iterables objects are objects over which we can iterate item-by-item.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象是我们可以逐个迭代的对象。
- en: We retrieve an iterator from an iterable object using the built-in `iter()`
    function.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用内置的`iter()`函数从可迭代对象中检索迭代器。
- en: Iterators produce items one-by-one from the underlying iterable series each
    time they are passed to the built-in `next()` function.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器每次传递给内置的`next()`函数时，都会从底层可迭代序列中逐个产生项目。
- en: Iterators raise a `StopIteration` exception when the collection is exhausted.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合耗尽时，迭代器会引发`StopIteration`异常。
- en: Generators
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器
- en: Generator functions allow us to describe sequences using imperative code.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数允许我们使用命令式代码描述序列。
- en: Generator functions contain at least one use of the `yield` keyword.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数至少包含一次使用`yield`关键字。
- en: Generators are iterators. When the iterator is advanced with `next()` the generator
    starts or resumes execution up to and including the next `yield`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是迭代器。当迭代器使用`next()`进行推进时，生成器会开始或恢复执行，直到包括下一个`yield`为止。
- en: Each call to a generator function creates a new generator object.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对生成器函数的每次调用都会创建一个新的生成器对象。
- en: Generators can maintain explicit state in local variables between iterations.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器可以在迭代之间的局部变量中维护显式状态。
- en: Generators are lazy and so can model infinite series of data.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是懒惰的，因此可以模拟无限的数据系列。
- en: Generator expressions have a similar syntactic form to list comprehensions and
    allow for a more declarative and concise way of creating generator objects.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式具有类似的语法形式，可以更声明式和简洁地创建生成器对象。
- en: Iteration tools
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代工具
- en: Python includes a rich set of tools for dealing with iterable series, both in
    the form of built-in functions such as `sum()`, `any()` and `zip()` as well as
    in the `itertools` module.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包括一套丰富的工具，用于处理可迭代系列，包括内置函数如`sum()`、`any()`和`zip()`，以及`itertools`模块中的工具。
