- en: A Gentle Introduction to Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的简介
- en: '"Give a man a fish and you feed him for a day. Teach a man to fish and you
    feed him for a lifetime."– Chinese proverb'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “授人以鱼不如授人以渔”-中国谚语
- en: 'According to Wikipedia, **computer programming** is:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，**计算机编程**是：
- en: '"...a process that leads from an original formulation of a computing problem
    to executable computer programs. Programming involves activities such as analysis,
    developing understanding, generating algorithms, verification of requirements
    of algorithms including their correctness and resources consumption, and implementation
    (commonly referred to as coding) of algorithms in a target programming language."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “……从最初的计算问题表述到可执行的计算机程序的过程。编程涉及活动，如分析、开发理解、生成算法、验证算法的要求，包括它们的正确性和资源消耗，以及在目标编程语言中实现（通常称为编码）算法。”
- en: In a nutshell, coding is telling a computer to do something using a language
    it understands.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，编码就是用计算机能理解的语言告诉计算机做某事。
- en: 'Computers are very powerful tools, but unfortunately, they can''t think for
    themselves. They need to be told everything: how to perform a task, how to evaluate
    a condition to decide which path to follow, how to handle data that comes from
    a device, such as the network or a disk, and how to react when something unforeseen
    happens, say, something is broken or missing.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是非常强大的工具，但不幸的是，它们无法自行思考。它们需要被告知一切：如何执行任务，如何评估条件以决定要遵循哪条路径，如何处理来自设备的数据，比如网络或磁盘，以及在发生意外情况时如何做出反应，比如，某物坏了或丢失了。
- en: You can code in many different styles and languages. Is it hard? I would say
    *yes* and *no*. It's a bit like writing. Everybody can learn how to write, and
    you can too. But, what if you wanted to become a poet? Then writing alone is not
    enough. You have to acquire a whole other set of skills and this will take a longer
    and greater effort.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用许多不同的风格和语言编写代码。难吗？我会说*是*和*不是*。这有点像写作。每个人都可以学会写作，你也可以。但是，如果你想成为一名诗人呢？那么仅仅写作是不够的。你还需要掌握一整套其他技能，这将需要更长时间和更大的努力。
- en: In the end, it all comes down to how far you want to go down the road. Coding
    is not just putting together some instructions that work. It is so much more!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一切都取决于你想走多远。编码不仅仅是将一些有效的指令组合在一起。它远不止如此！
- en: Good code is short, fast, elegant, easy to read and understand, simple, easy
    to modify and extend, easy to scale and refactor, and easy to test. It takes time
    to be able to write code that has all these qualities at the same time, but the
    good news is that you're taking the first step towards it at this very moment
    by reading this book. And I have no doubt you can do it. Anyone can; in fact,
    we all program all the time, only we aren't aware of it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码是简短、快速、优雅、易于阅读和理解、简单、易于修改和扩展、易于扩展和重构、易于测试。要能够同时具备所有这些品质的代码需要时间，但好消息是，通过阅读这本书，你正在迈出迈向这个目标的第一步。我毫不怀疑你能做到。任何人都可以；事实上，我们都在不知不觉中一直在编程。
- en: Would you like an example?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要一个例子吗？
- en: Say you want to make instant coffee. You have to get a mug, the instant coffee
    jar, a teaspoon, water, and the kettle. Even if you're not aware of it, you're
    evaluating a lot of data. You're making sure that there is water in the kettle
    and that the kettle is plugged in, that the mug is clean, and that there is enough
    coffee in the jar. Then, you boil the water and maybe, in the meantime, you put
    some coffee in the mug. When the water is ready, you pour it into the cup, and
    stir.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想泡速溶咖啡。你需要一个杯子，速溶咖啡罐，一茶匙，水和水壶。即使你没有意识到，你正在评估大量的数据。你要确保水壶里有水，水壶已经插上电，杯子是干净的，罐子里有足够的咖啡。然后，你煮水，也许在此期间，你把一些咖啡放在杯子里。当水煮好时，你把它倒进杯子里，然后搅拌。
- en: So, how is this programming?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这和编程有什么关系呢？
- en: Well, we gathered resources (the kettle, coffee, water, teaspoon, and mug) and
    we verified some conditions concerning them (the kettle is plugged in, the mug
    is clean, and there is enough coffee). Then we started two actions (boiling the
    water and putting coffee in the mug), and when both of them were completed, we
    finally ended the procedure by pouring water in to the mug and stirring.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们收集了资源（水壶、咖啡、水、茶匙和杯子），并验证了一些关于它们的条件（水壶已插上电，杯子是干净的，罐子里有足够的咖啡）。然后我们开始了两个动作（煮水和把咖啡放在杯子里），当它们都完成时，我们最终通过把水倒进杯子里并搅拌来结束了这个过程。
- en: 'Can you see it? I have just described the high-level functionality of a coffee
    program. It wasn''t that hard because this is what the brain does all day long:
    evaluate conditions, decide to take actions, carry out tasks, repeat some of them,
    and stop at some point. Clean objects, put them back, and so on.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到吗？我刚刚描述了一个咖啡程序的高级功能。这并不难，因为这就是大脑整天在做的事情：评估条件，决定采取行动，执行任务，重复其中一些，并在某个时刻停下来。清理物品，放回去，等等。
- en: All you need now is to learn how to deconstruct all those actions you do automatically
    in real life so that a computer can actually make some sense of them. And you
    need to learn a language as well, to instruct it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你所需要做的就是学会如何分解你在现实生活中自动执行的所有这些动作，以便计算机实际上能够理解它们。你还需要学习一种语言，来指导它。
- en: So this is what this book is for. I'll tell you how to do it and I'll try to
    do that by means of many simple but focused examples (my favorite kind).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这本书的目的。我会告诉你如何做，我会尝试通过许多简单但专注的例子来做到这一点（我最喜欢的类型）。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Python's characteristics and ecosystem
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的特点和生态系统
- en: Guidelines on how to get up and running with Python and virtual environments
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开始并运行Python和虚拟环境的指南
- en: How to run Python programs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行Python程序
- en: How to organize Python code and Python's execution model
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织Python代码和Python的执行模型
- en: A proper introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个适当的介绍
- en: I love to make references to the real world when I teach coding; I believe they
    help people retain the concepts better. However, now is the time to be a bit more
    rigorous and see what coding is from a more technical perspective.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在教编码时引用现实世界；我相信这有助于人们更好地记住概念。然而，现在是时候更严谨地从技术角度看待编码是什么了。
- en: 'When we write code, we''re instructing a computer about the things it has to
    do. Where does the action happen? In many places: the computer memory, hard drives,
    network cables, the CPU, and so on. It''s a whole *world*, which most of the time
    is the representation of a subset of the real world.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们正在指示计算机要做的事情。动作发生在哪里？在许多地方：计算机内存、硬盘、网络电缆、CPU等等。这是一个完整的*世界*，大多数时候是真实世界的一个子集的表示。
- en: If you write a piece of software that allows people to buy clothes online, you
    will have to represent real people, real clothes, real brands, sizes, and so on
    and so forth, within the boundaries of a program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写了一个允许人们在线购买衣服的软件，那么您将不得不在程序的范围内代表真实的人、真实的衣服、真实的品牌、尺寸等等。
- en: In order to do so, you will need to create and handle objects in the program
    you're writing. A person can be an object. A car is an object. A pair of socks
    is an object. Luckily, Python understands objects very well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您需要在编写的程序中创建和处理对象。一个人可以是一个对象。一辆汽车是一个对象。一双袜子是一个对象。幸运的是，Python非常了解对象。
- en: 'The two main features any object has are properties and methods. Let''s take
    a person object as an example. Typically in a computer program, you''ll represent
    people as customers or employees. The properties that you store against them are
    things like the name, the SSN, the age, if they have a driving license, their
    email, gender, and so on. In a computer program, you store all the data you need
    in order to use an object for the purpose you''re serving. If you are coding a
    website to sell clothes, you probably want to store the heights and weights as
    well as other measures of your customers so that you can suggest the appropriate
    clothes for them. So, properties are characteristics of an object. We use them
    all the time: *Could you pass me that pen?*—*Which one?*—*The black one*. Here,
    we used the *black* property of a pen to identify it (most likely among a blue
    and a red one).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象具有的两个主要特征是属性和方法。让我们以一个人对象为例。在计算机程序中，您通常将人表示为顾客或员工。您存储在他们身上的属性是姓名、社会安全号码、年龄、是否有驾照、电子邮件、性别等等。在计算机程序中，您存储了您需要的所有数据，以便使用对象来实现您的目的。如果您正在编写一个销售服装的网站，您可能还想存储客户的身高和体重以及其他测量数据，以便为他们推荐合适的衣服。因此，属性是对象的特征。我们一直在使用它们：*你能把那支笔递给我吗？*—*哪一支？*—*黑色的那支*。在这里，我们使用了笔的*黑色*属性来识别它（很可能是在蓝色和红色中）。
- en: Methods are things that an object can do. As a person, I have methods such as
    *speak*, *walk*, *sleep*, *wake up*, *eat*, *dream*, *write*, *read*, and so on.
    All the things that I can do could be seen as methods of the objects that represent
    me.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是对象可以执行的操作。作为一个人，我有诸如*说话*、*走路*、*睡觉*、*醒来*、*吃饭*、*做梦*、*写作*、*阅读*等方法。我能做的所有事情都可以看作是代表我的对象的方法。
- en: So, now that you know what objects are and that they expose methods that you
    can run and properties that you can inspect, you're ready to start coding. Coding
    in fact is simply about managing those objects that live in the subset of the
    world that we're reproducing in our software. You can create, use, reuse, and
    delete objects as you please.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在您知道对象是什么，它们公开了可以运行的方法和可以检查的属性，您已经准备好开始编码了。实际上，编码只是简单地管理我们在软件中再现的世界子集中生活的那些对象。您可以随意创建、使用、重用和删除对象。
- en: 'According to the *Data Model* chapter on the official Python documentation
    ([https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方Python文档上的*数据模型*章节（[https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)）：
- en: '"Objects are Python''s abstraction for data. All data in a Python program is
    represented by objects or by relations between objects."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “对象是Python程序中数据的抽象。Python程序中的所有数据都由对象或对象之间的关系表示。”
- en: We'll take a closer look at Python objects in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*. For now, all we need to know is that every object
    in Python has an ID (or identity), a type, and a value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中更仔细地研究Python对象，*OOP、装饰器和迭代器*。目前，我们需要知道的是Python中的每个对象都有一个ID（或标识）、类型和值。
- en: Once created, the ID of an object is never changed. It's a unique identifier
    for it, and it's used behind the scenes by Python to retrieve the object when
    we want to use it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，对象的ID就永远不会改变。这是它的唯一标识符，并且Python在幕后使用它来检索我们想要使用的对象。
- en: The type, as well, never changes. The type tells what operations are supported
    by the object and the possible values that can be assigned to it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类型也永远不会改变。类型告诉对象支持哪些操作，以及可以分配给它的可能值。
- en: We'll see Python's most important data types in [Chapter 2](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Built-in Data Types*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe)中看到Python最重要的数据类型，*内置数据类型*。
- en: The value can either change or not. If it can, the object is said to be **mutable**,
    while when it cannot, the object is said to be **immutable**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以改变，也可以不改变。如果可以改变，对象被称为**可变**，而当它不能改变时，对象被称为**不可变**。
- en: How do we use an object? We give it a name, of course! When you give an object
    a name, then you can use the name to retrieve the object and use it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用对象？当然是给它一个名字！当您给对象一个名字时，然后您可以使用该名称检索对象并使用它。
- en: In a more generic sense, objects such as numbers, strings (text), collections,
    and so on are associated with a name. Usually, we say that this name is the name
    of a variable. You can see the variable as being like a box, which you can use
    to hold data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在更一般的意义上，诸如数字、字符串（文本）、集合等对象都与一个名称相关联。通常，我们说这个名称是变量的名称。你可以把变量看作是一个盒子，你可以用它来存储数据。
- en: So, you have all the objects you need; what now? Well, we need to use them,
    right? We may want to send them over a network connection or store them in a database.
    Maybe display them on a web page or write them into a file. In order to do so,
    we need to react to a user filling in a form, or pressing a button, or opening
    a web page and performing a search. We react by running our code, evaluating conditions
    to choose which parts to execute, how many times, and under which circumstances.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你已经拥有了所有你需要的对象；现在呢？嗯，我们需要使用它们，对吧？也许我们想要通过网络连接发送它们，或者将它们存储在数据库中。也许在网页上显示它们，或者将它们写入文件。为了做到这一点，我们需要对用户填写表单、按下按钮、打开网页并执行搜索做出反应。我们通过运行我们的代码来做出反应，评估条件以选择执行哪些部分，多少次，以及在哪些情况下。
- en: And to do all this, basically we need a language. That's what Python is for.
    Python is the language we'll use together throughout this book to instruct the
    computer to do something for us.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而要做到这一切，基本上我们需要一种语言。这就是Python的用途。Python是我们在本书中一起使用的语言，用来指示计算机为我们做一些事情。
- en: Now, enough of this theoretical stuff; let's get started.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，够了这些理论的东西；让我们开始吧。
- en: Enter the Python
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Python
- en: Python is the marvelous creation of Guido Van Rossum, a Dutch computer scientist
    and mathematician who decided to gift the world with a project he was playing
    around with over Christmas 1989\. The language appeared to the public somewhere
    around 1991, and since then has evolved to be one of the leading programming languages
    used worldwide today.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python是Guido Van Rossum的杰作，他是一位荷兰计算机科学家和数学家，决定在1989年圣诞节期间把他玩耍的项目送给世界。这种语言大约在1991年左右出现在公众面前，从那时起，它已经发展成为当今世界上使用最广泛的编程语言之一。
- en: I started programming when I was 7 years old, on a Commodore VIC-20, which was
    later replaced by its bigger brother, the Commodore 64\. Its language was *BASIC*.
    Later on, I landed on Pascal, Assembly, C, C++, Java, JavaScript, Visual Basic,
    PHP, ASP, ASP .NET, C#, and other minor languages I cannot even remember, but
    only when I landed on Python did I finally have that feeling that you have when
    you find the right couch in the shop. When all of your body parts are yelling,
    *Buy this one! This one is perfect for us!*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我7岁开始学习编程，用的是Commodore VIC-20，后来换成了它的大哥Commodore 64。它的语言是BASIC。后来，我接触了Pascal、Assembly、C、C++、Java、JavaScript、Visual
    Basic、PHP、ASP、ASP .NET、C#，还有其他一些我甚至都记不起来的小语言，但直到我接触到Python，我才有了那种在商店里找到合适的沙发时的感觉。当你的全身部位都在呼喊着，“买这个！这个对我们来说完美！”
- en: It took me about a day to get used to it. Its syntax is a bit different from
    what I was used to, but after getting past that initial feeling of discomfort
    (like having new shoes), I just fell in love with it. Deeply. Let's see why.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我大约花了一天的时间来适应它。它的语法与我以前习惯的有点不同，但在克服了最初的不适感之后（就像穿上新鞋一样），我就深深地爱上了它。让我们看看为什么。
- en: About Python
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Python
- en: Before we get into the gory details, let's get a sense of why someone would
    want to use Python (I would recommend you to read the Python page on Wikipedia
    to get a more detailed introduction).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解细节之前，让我们先了解一下为什么有人会想要使用Python（我建议你阅读维基百科上的Python页面，以获得更详细的介绍）。
- en: To my mind, Python epitomizes the following qualities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Python体现了以下特质。
- en: Portability
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植性
- en: Python runs everywhere, and porting a program from Linux to Windows or Mac is
    usually just a matter of fixing paths and settings. Python is designed for portability
    and it takes care of specific **operating system** (**OS**) quirks behind interfaces
    that shield you from the pain of having to write code tailored to a specific platform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以在任何地方运行，将程序从Linux移植到Windows或Mac通常只是修复路径和设置的问题。Python被设计用于可移植性，并且它会处理特定操作系统（OS）的怪癖，这些接口会让你免于编写针对特定平台的代码的痛苦。
- en: Coherence
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连贯性
- en: Python is extremely logical and coherent. You can see it was designed by a brilliant
    computer scientist. Most of the time, you can just guess how a method is called,
    if you don't know it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python是非常逻辑和连贯的。你可以看出它是由一位杰出的计算机科学家设计的。大多数时候，如果你不知道一个方法该怎么调用，你可以猜一下。
- en: You may not realize how important this is right now, especially if you are at
    the beginning, but this is a major feature. It means less cluttering in your head,
    as well as less skimming through the documentation, and less need for mappings
    in your brain when you code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能没有意识到这一点有多重要，特别是如果你是刚开始学习的话，但这是一个重要的特点。这意味着你的头脑中没有那么多杂乱，也不需要在文档中浏览那么多，编码时也不需要在大脑中进行那么多映射。
- en: Developer productivity
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者生产力
- en: According to Mark Lutz (*Learning Python, 5th Edition*, *O'Reilly Media*), a
    Python program is typically one-fifth to one-third the size of equivalent Java
    or C++ code. This means the job gets done faster. And faster is good. Faster means
    a faster response on the market. Less code not only means less code to write,
    but also less code to read (and professional coders read much more than they write),
    less code to maintain, to debug, and to refactor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Mark Lutz（《学习Python，第5版》，O'Reilly Media）的说法，Python程序通常只有等效的Java或C++代码的五分之一到三分之一大小。这意味着工作可以更快地完成。更快是好的。更快意味着市场上更快的反应。更少的代码不仅意味着写的代码更少，而且意味着阅读的代码更少（专业的程序员读的比写的多），维护的代码更少，调试的代码更少，重构的代码更少。
- en: Another important aspect is that Python runs without the need for lengthy and
    time-consuming compilation and linkage steps, so you don't have to wait to see
    the results of your work.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的方面是Python可以在不需要冗长和耗时的编译和链接步骤的情况下运行，因此你不必等待看到你的工作成果。
- en: An extensive library
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富的库
- en: Python has an incredibly wide standard library (it's said to come with *batteries
    included*). If that wasn't enough, the Python community all over the world maintains
    a body of third-party libraries, tailored to specific needs, which you can access
    freely at the **Python Package Index** (**PyPI**). When you code Python and you
    realize that you need a certain feature, in most cases, there is at least one
    library where that feature has already been implemented for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个非常广泛的标准库（据说它是带有*内置电池*的）。如果这还不够，全世界的Python社区维护着一系列针对特定需求定制的第三方库，你可以在**Python
    Package Index**（**PyPI**）上免费访问。当你编写Python代码时，当你意识到你需要某个特定功能时，大多数情况下，至少有一个库已经为你实现了这个功能。
- en: Software quality
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件质量
- en: Python is heavily focused on readability, coherence, and quality. The language
    uniformity allows for high readability and this is crucial nowadays where coding
    is more of a collective effort than a solo endeavor. Another important aspect
    of Python is its intrinsic multiparadigm nature. You can use it as a scripting
    language, but you also can exploit object-oriented, imperative, and functional
    programming styles. It is versatile.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常注重可读性、连贯性和质量。语言的统一性使得高可读性成为可能，这在当今编码更多是集体努力而不是个人努力的情况下至关重要。Python的另一个重要方面是其固有的多范式特性。你可以将它用作脚本语言，但也可以利用面向对象、命令式和函数式编程风格。它是多才多艺的。
- en: Software integration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件集成
- en: Another important aspect is that Python can be extended and integrated with
    many other languages, which means that even when a company is using a different
    language as their mainstream tool, Python can come in and act as a glue agent
    between complex applications that need to talk to each other in some way. This
    is kind of an advanced topic, but in the real world, this feature is very important.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个重要的方面是它可以扩展和与许多其他语言集成，这意味着即使一家公司正在使用不同的语言作为他们的主流工具，Python可以作为一个粘合剂在复杂的应用程序之间起到沟通的作用。这是一个高级话题，但在现实世界中，这个特性非常重要。
- en: Satisfaction and enjoyment
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满足和享受
- en: Last, but not least, there is the fun of it! Working with Python is fun. I can
    code for 8 hours and leave the office happy and satisfied, alien to the struggle
    other coders have to endure because they use languages that don't provide them
    with the same amount of well-designed data structures and constructs. Python makes
    coding fun, no doubt about it. And fun promotes motivation and productivity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，这很有趣！使用Python很有趣。我可以编码8个小时，离开办公室时感到快乐和满意，对于其他程序员必须忍受的挣扎来说，他们使用的语言没有提供同样数量的精心设计的数据结构和构造。毫无疑问，Python让编码变得有趣。有趣促进了动力和生产力。
- en: These are the major aspects of why I would recommend Python to everyone. Of
    course, there are many other technical and advanced features that I could have
    talked about, but they don't really pertain to an introductory section like this
    one. They will come up naturally, chapter after chapter, in this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我为什么会向每个人推荐Python的主要方面。当然，还有许多其他技术和高级特性，我本可以谈论，但它们并不真正属于像这样的入门部分。它们会在这本书的每一章中自然地出现。
- en: What are the drawbacks?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有什么缺点？
- en: Probably, the only drawback that one could find in Python, which is not due
    to personal preferences, is its *execution speed*. Typically, Python is slower
    than its compiled brothers. The standard implementation of Python produces, when
    you run an application, a compiled version of the source code called byte code
    (with the extension `.pyc`), which is then run by the Python interpreter. The
    advantage of this approach is portability, which we pay for with a slowdown due
    to the fact that Python is not compiled down to machine level as are other languages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，唯一的缺点是Python的*执行速度*，这不是由于个人偏好造成的。通常情况下，Python比它的编译兄弟慢。Python的标准实现在运行应用程序时会产生一个称为字节码的源代码的编译版本（扩展名为`.pyc`），然后由Python解释器运行。这种方法的优势是可移植性，但由于Python没有像其他语言那样编译到机器级别，我们付出了速度减慢的代价。
- en: However, Python speed is rarely a problem today, hence its wide use regardless
    of this suboptimal feature. What happens is that, in real life, hardware cost
    is no longer a problem, and usually it's easy enough to gain speed by parallelizing
    tasks. Moreover, many programs spend a great proportion of the time waiting for
    IO operations to complete; therefore, the raw execution speed is often a secondary
    factor to the overall performance. When it comes to number crunching though, one
    can switch to faster Python implementations, such as PyPy, which provides an average
    five-fold speedup by implementing advanced compilation techniques (check [http://pypy.org/](http://pypy.org/)
    for reference).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python的速度在今天很少是一个问题，因此它被广泛使用，尽管有这个次优特性。实际上，硬件成本已经不再是一个问题，通常很容易通过并行化任务来提高速度。此外，许多程序花费大部分时间等待IO操作完成；因此，原始执行速度通常是整体性能的次要因素。不过，当涉及到大量计算时，人们可以切换到更快的Python实现，比如PyPy，通过实现先进的编译技术，它提供了平均五倍的加速（参考[http://pypy.org/](http://pypy.org/)）。
- en: When doing data science, you'll most likely find that the libraries that you
    use with Python, such as **Pandas** and **NumPy**, achieve native speed due to
    the way they are implemented.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据科学时，你很可能会发现你使用的Python库，如**Pandas**和**NumPy**，由于它们的实现方式，实现了本地速度。
- en: If that wasn't a good-enough argument, you can always consider that Python has
    been used to drive the backend of services such as Spotify and Instagram, where
    performance is a concern. Nonetheless, Python has done its job perfectly adequately.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是一个足够好的论点，你可以考虑Python已经被用来驱动Spotify和Instagram等服务的后端，其中性能是一个问题。尽管如此，Python已经完美地完成了它的工作。
- en: Who is using Python today?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 今天谁在使用Python？
- en: 'Not yet convinced? Let''s take a very brief look at the companies that are
    using Python today: Google, YouTube, Dropbox, Yahoo!, Zope Corporation, Industrial
    Light & Magic, Walt Disney Feature Animation, Blender 3D, Pixar, NASA, the NSA,
    Red Hat, Nokia, IBM, Netflix, Yelp, Intel, Cisco, HP, Qualcomm, and JPMorgan Chase,
    to name just a few.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还不确定？让我们简要看一下今天正在使用Python的公司：Google、YouTube、Dropbox、Yahoo!、Zope Corporation、Industrial
    Light & Magic、Walt Disney Feature Animation、Blender 3D、Pixar、NASA、NSA、Red Hat、Nokia、IBM、Netflix、Yelp、Intel、Cisco、HP、Qualcomm和JPMorgan
    Chase等等。
- en: Even games such as *Battlefield 2*, *Civilization IV*, and *QuArK* are implemented
    using Python.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至像*Battlefield 2*、*Civilization IV*和*QuArK*这样的游戏也是用Python实现的。
- en: Python is used in many different contexts, such as system programming, web programming,
    GUI applications, gaming and robotics, rapid prototyping, system integration,
    data science, database applications, and much more. Several prestigious universities
    have also adopted Python as their main language in computer science courses.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python在许多不同的领域中被使用，如系统编程、Web编程、GUI应用程序、游戏和机器人技术、快速原型设计、系统集成、数据科学、数据库应用等等。一些知名的大学也已经将Python作为他们计算机科学课程的主要语言。
- en: Setting up the environment
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Before we talk about installing Python on your system, let me tell you about
    which Python version I'll be using in this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何在你的系统上安装Python之前，让我告诉你我在本书中将使用的Python版本。
- en: Python 2 versus Python 3
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 2与Python 3
- en: 'Python comes in two main versions: Python 2, which is the past, and Python
    3, which is the present. The two versions, though very similar, are incompatible
    in some respects.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个主要版本：Python 2是过去，Python 3是现在。尽管两个版本非常相似，但在某些方面是不兼容的。
- en: In the real world, Python 2 is actually quite far from being the past. In short,
    even though Python 3 has been out since 2008, the transition phase from Version
    2 is still far from being over. This is mostly due to the fact that Python 2 is
    widely used in the industry, and of course, companies aren't so keen on updating
    their systems just for the sake of updating them, following the *if it ain't broke,
    don't fix it* philosophy. You can read all about the transition between the two
    versions on the web.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，Python 2实际上离过去还相当遥远。简而言之，尽管Python 3自2008年以来就已经发布，但从版本2过渡到版本3的阶段仍然远未结束。这主要是因为Python
    2在工业中被广泛使用，当然，公司并不急于仅仅为了更新系统而更新系统，遵循“如果它没坏，就不要修理它”的理念。你可以在网上阅读关于这两个版本之间过渡的所有信息。
- en: Another issue that has hindered the transition is the availability of third-party
    libraries. Usually, a Python project relies on tens of external libraries, and
    of course, when you start a new project, you need to be sure that there is already
    a Version-3-compatible library for any business requirement that may come up.
    If that's not the case, starting a brand-new project in Python 3 means introducing
    a potential risk, which many companies are not happy to take.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个阻碍过渡的问题是第三方库的可用性。通常，一个Python项目依赖于数十个外部库，当你开始一个新项目时，你需要确保已经有一个与Version-3兼容的库来满足任何可能出现的业务需求。如果不是这样的话，在Python
    3中开始一个全新的项目意味着引入潜在的风险，而许多公司并不愿意冒这个风险。
- en: At the time of writing, though, the majority of the most widely used libraries
    have been ported to Python 3, and it's quite safe to start a project in Python
    3 for most cases. Many of the libraries have been rewritten so that they are compatible
    with both versions, mostly harnessing the power of the `six` library (the name
    comes from the multiplication 2 x 3, due to the porting from Version 2 to 3),
    which helps introspecting and adapting the behavior according to the version used.
    According to PEP 373 ([https://legacy.python.org/dev/peps/pep-0373/](https://legacy.python.org/dev/peps/pep-0373/)),
    the **end of life** (**EOL**) of Python 2.7 has been set to 2020, and there won't
    be a Python 2.8, so this is the time when companies that have projects running
    in Python 2 need to start devising an upgrade strategy to move to Python 3 before
    it's too late.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，大多数最广泛使用的库已经移植到Python 3，并且对于大多数情况来说，在Python 3中启动项目是相当安全的。许多库已经重写，以便与两个版本兼容，主要利用了`six`库的功能（名称来源于2
    x 3的乘法，因为从版本2到3的移植），它可以帮助内省并根据使用的版本调整行为。根据PEP 373（[https://legacy.python.org/dev/peps/pep-0373/](https://legacy.python.org/dev/peps/pep-0373/)），Python
    2.7的**生命周期**（**EOL**）已经设定为2020年，不会有Python 2.8，因此对于在Python 2中运行项目的公司来说，现在是需要开始制定升级策略并在太迟之前转移到Python
    3的时候了。
- en: 'On my box (MacBook Pro), this is the latest Python version I have:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上（MacBook Pro），这是我拥有的最新Python版本：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So you can see that the version is an alpha release of Python 3.7, which will
    be released in June 2018\. The preceding text is a little bit of Python code that
    I typed into my console. We'll talk about it in a moment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到，这个版本是Python 3.7的alpha版本，将于2018年6月发布。前面的文本是我在控制台中输入的一小段Python代码。我们稍后会谈论它。
- en: All the examples in this book will be run using Python 3.7\. Even though at
    the moment the final version might still be slightly different than what I have,
    I will make sure that all the code and examples are up to date with 3.7 by the
    time the book is published.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都将使用Python 3.7运行。即使此刻最终版本可能与我所拥有的略有不同，但我会确保所有的代码和示例在书籍出版时都是最新的3.7版本。
- en: Some of the code can also run in Python 2.7, either as it is or with minor tweaks,
    but at this point in time, I think it's better to learn Python 3, and then, if
    you need to, learn the differences it has with Python 2, rather than going the
    other way around.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码也可以在Python 2.7中运行，要么就是原样，要么进行一些微小的调整，但在这个时间点上，我认为最好是学习Python 3，然后，如果需要的话，再学习它与Python
    2的区别，而不是反过来。
- en: Don't worry about this version thing though; it's not that big an issue in practice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，不要担心这个版本问题；实际上在实践中并不是那么大的问题。
- en: Installing Python
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python
- en: I never really got the point of having a *setup* section in a book, regardless
    of what it is that you have to set up. Most of the time, between the time the
    author writes the instructions and the time you actually try them out, months
    have passed. That is, if you're lucky. One version change and things may not work
    in the way that is described in the book. Luckily, we have the web now, so in
    order to help you get up and running, I'll just give you pointers and objectives.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来没有真正理解过书中为什么要有一个*设置*部分，无论您需要设置什么。大多数情况下，作者编写说明和您实际尝试它们之间已经过去了几个月。也就是说，如果您很幸运的话。一旦版本更改，书中描述的方式可能无法正常工作。幸运的是，现在我们有了网络，为了帮助您启动和运行，我只会给您一些指引和目标。
- en: I am conscious that the majority of readers would probably have preferred to
    have guidelines in the book. I doubt it would have made their life much easier,
    as I strongly believe that if you want to get started with Python you have to
    put in that initial effort in order to get familiar with the ecosystem. It is
    very important, and it will boost your confidence to face the material in the
    chapters ahead. If you get stuck, remember that Google is your friend.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道大多数读者可能更喜欢在书中获得指南。我怀疑这是否会让他们的生活变得更轻松，因为我坚信，如果您想要开始学习Python，您必须付出最初的努力，以熟悉这个生态系统。这非常重要，它将增强您面对后面章节中的材料时的信心。如果遇到困难，请记住，谷歌是您的朋友。
- en: Setting up the Python interpreter
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Python解释器
- en: First of all, let's talk about your OS. Python is fully integrated and most
    likely already installed in basically almost every Linux distribution. If you
    have a macOS, it's likely that Python is already there as well (however, possibly
    only Python 2.7), whereas if you're using Windows, you probably need to install
    it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈您的操作系统。Python已经完全集成，并且基本上几乎每个Linux发行版中都已经安装了。如果您使用macOS，很可能Python也已经安装好了（但可能只有Python
    2.7），而如果您使用Windows，您可能需要安装它。
- en: Getting Python and the libraries you need up and running requires a bit of handiwork.
    Linux and macOS seem to be the most user-friendly OSes for Python programmers;
    Windows, on the other hand, is the one that requires the biggest effort.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Python和所需的库并使其运行需要一些技巧。对于Python程序员来说，Linux和macOS似乎是最用户友好的操作系统；另一方面，Windows需要最大的努力。
- en: My current system is a MacBook Pro, and this is what I will use throughout the
    book, along with Python 3.7.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我的当前系统是MacBook Pro，这是我在整本书中将使用的系统，还有Python 3.7。
- en: 'The place you want to start is the official Python website: [https://www.python.org](https://www.python.org).
    This website hosts the official Python documentation and many other resources
    that you will find very useful. Take the time to explore it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要开始的地方是官方Python网站：[https://www.python.org](https://www.python.org)。这个网站托管了官方Python文档和许多其他资源，您会发现非常有用。花点时间去探索一下。
- en: Another excellent, resourceful website on Python and its ecosystem is [http://docs.python-guide.org](http://docs.python-guide.org).
    You can find instructions to set up Python on different operating systems, using
    different methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于Python及其生态系统的优秀资源网站是[http://docs.python-guide.org](http://docs.python-guide.org)。您可以找到使用不同方法在不同操作系统上设置Python的说明。
- en: Find the download section and choose the installer for your OS. If you are on
    Windows, make sure that when you run the installer, you check the option `install
    pip` (actually, I would suggest to make a complete installation, just to be safe,
    of all the components the installer holds). We'll talk about `pip` later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 找到下载部分，并选择适合您操作系统的安装程序。如果您使用Windows，请确保在运行安装程序时选中`安装pip`选项（实际上，我建议进行完整安装，以确保安装程序包含的所有组件都安装了）。我们稍后会讨论`pip`。
- en: Now that Python is installed in your system, the objective is to be able to
    open a console and run the Python interactive shell by typing `python`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python已经安装在您的系统中，目标是能够打开控制台并通过输入`python`来运行Python交互式shell。
- en: Please note that I usually refer to the **Python interactive shell** simply
    as the **Python console**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我通常将**Python交互式shell**简单地称为**Python控制台**。
- en: To open the console in Windows, go to the Start menu, choose Run, and type `cmd`.
    If you encounter anything that looks like a permission problem while working on
    the examples in this book, please make sure you are running the console with administrator
    rights.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows中打开控制台，转到开始菜单，选择运行，然后输入`cmd`。如果您在使用本书中的示例时遇到类似权限问题的情况，请确保以管理员权限运行控制台。
- en: On the macOS X, you can start a Terminal by going to Applications | Utilities
    | Terminal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS X上，您可以通过转到应用程序|实用程序|终端来启动终端。
- en: If you are on Linux, you know all that there is to know about the console.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux，您对控制台的了解应该已经非常全面。
- en: 'I will use the term *console* interchangeably to indicate the Linux console,
    the Windows Command Prompt, and the Macintosh Terminal. I will also indicate the
    command-line prompt with the Linux default format, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用术语*控制台*来交替指代Linux控制台，Windows命令提示符和Macintosh终端。我还将用Linux默认格式指示命令行提示符，就像这样：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you're not familiar with that, please take some time to learn the basics
    on how a console works. In a nutshell, after the `$` sign, you normally find an
    instruction that you have to type. Pay attention to capitalization and spaces,
    as they are very important.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此不熟悉，请花些时间学习控制台的基础知识。简而言之，在`$`符号后，通常会有您需要输入的指令。注意大小写和空格，它们非常重要。
- en: Whatever console you open, type `python` at the prompt, and make sure the Python
    interactive shell shows up. Type `exit()` to quit. Keep in mind that you may have
    to specify `python3` if your OS comes with Python 2.* preinstalled.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您打开哪个控制台，请在提示符处键入`python`，确保Python交互式shell显示出来。键入`exit()`退出。请记住，如果您的操作系统预装了Python
    2.*，您可能需要指定`python3`。
- en: 'This is roughly what you should see when you run Python (it will change in
    some details according to the version and OS):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Python时，大致会看到以下内容（根据版本和操作系统的不同，某些细节可能会有所变化）：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that Python is set up and you can run it, it''s time to make sure you have
    the other tool that will be indispensable to follow the examples in the book:
    virtualenv.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python已经设置好了，你可以运行它，是时候确保你有另一个在本书中跟随示例时不可或缺的工具：virtualenv。
- en: About virtualenv
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于virtualenv
- en: As you probably have guessed by its name, **virtualenv **is all about virtual
    environments. Let me explain what they are and why we need them and let me do
    it by means of a simple example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，**virtualenv**的名字，它与虚拟环境有关。让我通过一个简单的例子来解释它们是什么，为什么我们需要它们。
- en: You install Python on your system and you start working on a website for Client
    X. You create a project folder and start coding. Along the way, you also install
    some libraries; for example, the Django framework, which we'll see in depth in
    [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe), *Web Development*.
    Let's say the Django version you install for Project X is 1.7.1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你在系统上安装了Python，并开始为X客户端开发网站。你创建了一个项目文件夹并开始编码。在这个过程中，你还安装了一些库；例如，Django框架，我们将在[第14章](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe)
    *Web Development*中深入了解。假设你为X项目安装的Django版本是1.7.1。
- en: 'Now, your website is so good that you get another client, Y. She wants you
    to build another website, so you start Project Y and, along the way, you need
    to install Django again. The only issue is that now the Django version is 1.8
    and you cannot install it on your system because this would replace the version
    you installed for Project X. You don''t want to risk introducing incompatibility
    issues, so you have two choices: either you stick with the version you have currently
    on your machine, or you upgrade it and make sure the first project is still fully
    working correctly with the new version.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的网站做得很好，你得到了另一个客户Y。她希望你建立另一个网站，所以你开始了Y项目，并在这个过程中需要再次安装Django。唯一的问题是现在Django的版本是1.8，你不能在系统上安装它，因为这会替换你为X项目安装的版本。你不想冒险引入不兼容的问题，所以你有两个选择：要么你坚持使用你当前机器上的版本，要么你升级它，并确保第一个项目仍然能够正确地使用新版本。
- en: 'Let''s be honest, neither of these options is very appealing, right? Definitely
    not. So, here''s the solution: virtualenv!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，这两个选项都不是很吸引人，对吧？绝对不是。所以，这里有一个解决方案：virtualenv！
- en: virtualenv is a tool that allows you to create a virtual environment. In other
    words, it is a tool to create isolated Python environments, each of which is a
    folder that contains all the necessary executables to use the packages that a
    Python project would need (think of packages as libraries for the time being).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: virtualenv是一个允许你创建虚拟环境的工具。换句话说，它是一个创建隔离的Python环境的工具，每个环境都是一个包含了一个Python项目所需的所有必要可执行文件的文件夹（暂时把包想象成库）。
- en: So you create a virtual environment for Project X, install all the dependencies,
    and then you create a virtual environment for Project Y, installing all its dependencies
    without the slightest worry because every library you install ends up within the
    boundaries of the appropriate virtual environment. In our example, Project X will
    hold Django 1.7.1, while Project Y will hold Django 1.8.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你为X项目创建一个虚拟环境，安装所有的依赖，然后你为Y项目创建一个虚拟环境，安装所有它的依赖，而不用担心，因为你安装的每个库最终都会在适当的虚拟环境的范围内。在我们的例子中，X项目将持有Django
    1.7.1，而Y项目将持有Django 1.8。
- en: 'It is of vital importance that you never install libraries directly at the
    system level. Linux, for example, relies on Python for many different tasks and
    operations, and if you fiddle with the system installation of Python, you risk
    compromising the integrity of the whole system (guess to whom this happened...).
    So take this as a rule, such as brushing your teeth before going to bed: *always,
    always create a virtual environment when you start a new project*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，你永远不要直接在系统级别安装库。例如，Linux依赖于Python来执行许多不同的任务和操作，如果你在系统安装的Python上搞砸了，你就有可能危及整个系统的完整性（猜猜这是发生在谁身上的...）。所以把这当作一个规则，就像睡觉前刷牙一样：*每当你开始一个新项目时，一定要创建一个虚拟环境*。
- en: 'To install virtualenv on your system, there are a few different ways. On a
    Debian-based distribution of Linux, for example, you can install it with the following
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在系统上安装virtualenv，有几种不同的方法。例如，在基于Debian的Linux发行版上，你可以使用以下命令安装它：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Probably, the easiest way is to follow the instructions you can find on the
    virtualenv official website: [https://virtualenv.pypa.io](https://virtualenv.pypa.io).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，最简单的方法是按照你可以在virtualenv官方网站上找到的说明进行操作：[https://virtualenv.pypa.io](https://virtualenv.pypa.io)。
- en: You will find that one of the most common ways to install virtualenv is by using `pip`,
    a package management system used to install and manage software packages written
    in Python.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，安装virtualenv的最常见方法之一是使用`pip`，这是一个用于安装和管理用Python编写的软件包的软件包管理系统。
- en: As of Python 3.5, the suggested way to create a virtual environment is to use
    the `venv` module. Please see the [official documentation](https://docs.python.org/3.7/library/venv.html)
    for further information. However, at the time of writing, virtualenv is still
    by far the tool most used for creating virtual environments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.5开始，创建虚拟环境的建议方法是使用`venv`模块。请参阅[官方文档](https://docs.python.org/3.7/library/venv.html)以获取更多信息。然而，在撰写本文时，virtualenv仍然是创建虚拟环境最常用的工具。
- en: Your first virtual environment
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个虚拟环境
- en: It is very easy to create a virtual environment, but according to how your system
    is configured and which Python version you want the virtual environment to run,
    you need to run the command properly. Another thing you will need to do with virtualenv,
    when you want to work with it, is to activate it. Activating virtualenv basically
    produces some path juggling behind the scenes so that when you call the Python
    interpreter, you're actually calling the active virtual environment one, instead
    of the mere system one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境非常容易，但根据系统配置和您想要虚拟环境运行的Python版本，您需要正确运行命令。当您想要使用virtualenv时，另一件需要做的事情是激活它。激活virtualenv基本上在幕后进行一些路径操作，这样当您调用Python解释器时，实际上调用的是活动的虚拟环境，而不是单纯的系统环境。
- en: 'I''ll show you a full example on my Macintosh console. We will:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的Macintosh控制台上展示一个完整的示例。我们将：
- en: Create a folder named `learn.pp` under your project root (which in my case is
    a folder called `srv`, in my home folder). Please adapt the paths according to
    the setup you fancy on your box.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目根目录下创建一个名为`learn.pp`的文件夹（在我的情况下是一个名为`srv`的文件夹，在我的主文件夹中）。请根据您在系统上喜欢的设置调整路径。
- en: Within the `learn.pp` folder, we will create a virtual environment called `learnpp`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`learn.pp`文件夹中，我们将创建一个名为`learnpp`的虚拟环境。
- en: Some developers prefer to call all virtual environments using the same name
    (for example, `.venv`). This way they can run scripts against any virtualenv by
    just knowing the name of the project they dwell in. The dot in `.venv` is there
    because in Linux/macOS prepending a name with a dot makes that file or folder
    invisible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员更喜欢使用相同的名称来调用所有虚拟环境（例如`.venv`）。这样他们就可以通过知道项目名称来运行脚本来针对任何虚拟环境。`.venv`中的点是因为在Linux/macOS中，用点作为名称的前缀会使该文件或文件夹变为不可见。
- en: After creating the virtual environment, we will activate it. The methods are
    slightly different between Linux, macOS, and Windows.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟环境后，我们将激活它。在Linux、macOS和Windows之间的方法略有不同。
- en: Then, we'll make sure that we are running the desired Python version (3.7.*)
    by running the Python interactive shell.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过运行Python交互式shell来确保我们正在运行所需的Python版本（3.7.*）。
- en: Finally, we will deactivate the virtual environment using the `deactivate` command.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`deactivate`命令取消激活虚拟环境。
- en: These five simple steps will show you all you have to do to start and use a
    project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个简单的步骤将向您展示启动和使用项目所需做的一切。
- en: 'Here''s an example of how those steps might look (note that you might get a
    slightly different result, according to your OS, Python version, and so on) on
    the macOS (commands that start with a `#` are comments, spaces have been introduced
    for readability, and `⇢` indicates where the line has wrapped around due to lack
    of space):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些步骤可能的示例（请注意，根据您的操作系统、Python版本等，您可能会得到略有不同的结果）在macOS上（以`#`开头的命令是注释，空格是为了可读性引入的，`⇢`表示由于空间不足而换行的位置）：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that I had to tell virtualenv explicitly to use the Python 3.7 interpreter
    because on my box Python 2.7 is the default one. Had I not done that, I would
    have had a virtual environment with Python 2.7 instead of Python 3.7.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我不得不明确告诉virtualenv使用Python 3.7解释器，因为在我的系统上Python 2.7是默认的。如果我没有这样做，我将得到一个带有Python
    2.7而不是Python 3.7的虚拟环境。
- en: 'You can combine the two instructions for step 2 in one single command like
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将步骤2的两条指令合并为一条命令，如下所示：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I chose to be explicitly verbose in this instance, to help you understand each
    bit of the procedure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我选择明确详细地解释，以帮助您理解每个步骤。
- en: Another thing to notice is that in order to activate a virtual environment,
    we need to run the `/bin/activate` script, which needs to be sourced. When a script
    is **sourced**, it means that it is executed in the current shell, and therefore
    its effects last after the execution. This is very important. Also notice how
    the prompt changes after we activate the virtual environment, showing its name
    on the left (and how it disappears when we deactivate it). On Linux, the steps
    are the same so I won't repeat them here. On Windows, things change slightly,
    but the concepts are the same. Please refer to the official virtualenv website
    for guidance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，为了激活虚拟环境，我们需要运行`/bin/activate`脚本，这需要被源化。当脚本被**源化**时，意味着它在当前shell中执行，因此其效果在执行后持续存在。这非常重要。还要注意，在激活虚拟环境后提示符的变化，左边显示了其名称（以及在取消激活时它是如何消失的）。在Linux上，步骤是相同的，所以我不会在这里重复。在Windows上，事情略有变化，但概念是相同的。请参考官方virtualenv网站以获取指导。
- en: 'At this point, you should be able to create and activate a virtual environment.
    Please try and create another one without me guiding you. Get acquainted with
    this procedure because it''s something that you will always be doing: **we never
    work system-wide with Python**, remember? It''s extremely important.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够创建和激活虚拟环境。请尝试在没有我的指导下创建另一个。熟悉这个过程，因为这是您将一直在做的事情：**我们永远不会在系统范围内使用Python**，记住？这非常重要。
- en: So, with the scaffolding out of the way, we're ready to talk a bit more about
    Python and how you can use it. Before we do that though, allow me to speak a few
    words about the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦搭建完成，我们就准备好更多地谈论Python以及您如何使用它。在我们这样做之前，让我简要谈一下控制台。
- en: Your friend, the console
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的朋友，控制台
- en: In this era of GUIs and touchscreen devices, it seems a little ridiculous to
    have to resort to a tool such as the console, when everything is just about one
    click away.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个GUI和触摸屏设备的时代，当一切都只是一个点击之遥时，似乎有点荒谬要求使用控制台这样的工具。
- en: But the truth is every time you remove your right hand from the keyboard (or
    the left one, if you're a lefty) to grab your mouse and move the cursor over to
    the spot you want to click on, you're losing time. Getting things done with the
    console, counter-intuitive as it may be, results in higher productivity and speed.
    I know, you have to trust me on this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实是，每次你把右手从键盘上移开（或者左手，如果你是左撇子），拿鼠标并移动光标到你想点击的位置，你都在浪费时间。用控制台完成任务，尽管可能有些违反直觉，但会提高生产力和速度。我知道，你得相信我。
- en: 'Speed and productivity are important and, personally, I have nothing against
    the mouse, but there is another very good reason for which you may want to get
    well-acquainted with the console: when you develop code that ends up on some server,
    the console might be the only available tool. If you make friends with it, I promise
    you, you will never get lost when it''s of utmost importance that you don''t (typically,
    when the website is down and you have to investigate very quickly what''s going
    on).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和生产力很重要，就我个人而言，我并不反对鼠标，但还有另一个非常好的理由，你可能想要熟悉控制台：当你开发的代码最终部署到某个服务器上时，控制台可能是唯一可用的工具。如果你和它交朋友，我向你保证，当你不得不迅速调查网站崩溃时，你绝对不会迷失方向。
- en: So it's really up to you. If you're undecided, please grant me the benefit of
    the doubt and give it a try. It's easier than you think, and you'll never regret
    it. There is nothing more pitiful than a good developer who gets lost within an
    SSH connection to a server because they are used to their own custom set of tools,
    and only to that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这真的取决于你。如果你还没有决定，请给我一点怀疑的余地，试一试。比你想象的要容易，你绝不会后悔。没有什么比一个优秀的开发人员因为习惯了自己的一套定制工具而在SSH连接到服务器时迷失更令人遗憾。
- en: Now, let's get back to Python.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到Python。
- en: How you can run a Python program
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以如何运行Python程序
- en: There are a few different ways in which you can run a Python program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以运行Python程序。
- en: Running Python scripts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Python脚本
- en: Python can be used as a scripting language. In fact, it always proves itself
    very useful. Scripts are files (usually of small dimensions) that you normally
    execute to do something like a task. Many developers end up having their own arsenal
    of tools that they fire when they need to perform a task. For example, you can
    have scripts to parse data in a format and render it into another different format.
    Or you can use a script to work with files and folders. You can create or modify
    configuration files, and much more. Technically, there is not much that cannot
    be done in a script.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以用作脚本语言。事实上，它总是非常有用。脚本是文件（通常很小），通常用来执行某项任务。许多开发人员最终都会拥有自己的工具库，需要时就会使用。例如，你可以有脚本来解析数据并将其呈现为另一种不同的格式。或者你可以使用脚本来处理文件和文件夹。你可以创建或修改配置文件，等等。从技术上讲，几乎没有什么是脚本无法完成的。
- en: It's quite common to have scripts running at a precise time on a server. For
    example, if your website database needs cleaning every 24 hours (for example,
    the table that stores the user sessions, which expire pretty quickly but aren't
    cleaned automatically), you could set up a Cron job that fires your script at
    3:00 A.M. every day.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上定时运行脚本是非常常见的。例如，如果你的网站数据库每24小时需要清理一次（例如，存储用户会话的表，这些会话很快就会过期，但不会自动清理），你可以设置一个Cron作业，每天凌晨3点运行你的脚本。
- en: According to Wikipedia, the software utility Cron is a time-based job scheduler
    in Unix-like computer operating systems. People who set up and maintain software
    environments use Cron to schedule jobs (commands or shell scripts) to run periodically
    at fixed times, dates, or intervals.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，软件实用程序Cron是Unix类计算机操作系统中基于时间的作业调度程序。设置和维护软件环境的人使用Cron来安排作业（命令或shell脚本）定期在固定的时间、日期或间隔运行。
- en: I have Python scripts to do all the menial tasks that would take me minutes
    or more to do manually, and at some point, I decided to automate. We'll devote
    half of [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe), *GUIs
    and Scripts,* on scripting with Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我有Python脚本来完成所有那些如果手动完成会花费我几分钟甚至更长时间的琐碎任务，最终我决定自动化。我们将在[第12章](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe)
    *GUIs and Scripts*中的Python脚本部分进行讨论。
- en: Running the Python interactive shell
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Python交互式shell
- en: Another way of running Python is by calling the interactive shell. This is something
    we already saw when we typed `python` on the command line of our console.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种运行Python的方法是调用交互式shell。这是我们在控制台命令行中输入`python`时已经看到的东西。
- en: 'So, open a console, activate your virtual environment (which by now should
    be second nature to you, right?), and type `python`. You will be presented with
    a couple of lines that should look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，打开控制台，激活你的虚拟环境（现在应该已经成为你的第二天性了，对吧？），然后输入`python`。你会看到几行文字，应该是这样的：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Those `>>>` are the prompt of the shell. They tell you that Python is waiting
    for you to type something. If you type a simple instruction, something that fits
    in one line, that's all you'll see. However, if you type something that requires
    more than one line of code, the shell will change the prompt to `...`, giving
    you a visual clue that you're typing a multiline statement (or anything that would
    require more than one line of code).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那些`>>>`是shell的提示符。它告诉你Python正在等待你输入。如果你输入一个简单的指令，一行就能搞定，你会看到这个。但是，如果你输入的是需要多行代码的东西，shell会把提示符改成`...`，这样你就知道你正在输入多行语句（或者需要多行代码的任何东西）。
- en: 'Go on, try it out; let''s do some basic math:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，试一试吧；让我们做一些基本的数学：
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last operation is showing you something incredible. We raise `2` to the
    power of `1024`, and Python is handling this task with no trouble at all. Try
    to do it in Java, C++, or C#. It won't work, unless you use special libraries
    to handle such big numbers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的操作向你展示了一些令人难以置信的东西。我们计算`2`的`1024`次方，Python毫不费力地完成了这个任务。试着在Java、C++或C#中做这个，不会成功，除非你使用特殊的库来处理这么大的数字。
- en: I use the interactive shell every day. It's extremely useful to debug very quickly,
    for example, to check if a data structure supports an operation. Or maybe to inspect
    or run a piece of code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我每天都使用交互式外壳。它非常有用，可以快速调试，例如，检查数据结构是否支持某个操作。或者检查或运行一段代码。
- en: When you use Django (a web framework), the interactive shell is coupled with
    it and allows you to work your way through the framework tools, to inspect the
    data in the database, and many more things. You will find that the interactive
    shell will soon become one of your dearest friends on the journey you are embarking
    on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Django（一个Web框架）时，交互式外壳与之耦合，并允许您通过框架工具，检查数据库中的数据等方式来工作。您会发现交互式外壳很快会成为您在即将开始的旅程中最亲密的朋友之一。
- en: Another solution, which comes in a much nicer graphic layout, is to use **Integrated
    DeveLopment Environment** (**IDLE**). It's quite a simple IDE, which is intended
    mostly for beginners. It has a slightly larger set of capabilities than the naked
    interactive shell you get in the console, so you may want to explore it. It comes
    for free in the Windows Python installer and you can easily install it in any
    other system. You can find information about it on the Python website.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案，以更美观的图形布局呈现，是使用集成开发环境（IDE）。这是一个相当简单的IDE，主要面向初学者。它具有比控制台中获得的裸交互式外壳更多的功能，因此您可能希望探索它。它在Windows
    Python安装程序中免费提供，并且您可以轻松在任何其他系统中安装它。您可以在Python网站上找到有关它的信息。
- en: Guido Van Rossum named Python after the British comedy group, Monty Python,
    so it's rumored that the name IDLE has been chosen in honor of Eric Idle, one
    of Monty Python's founding members.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Guido Van Rossum以英国喜剧团体Monty Python的名字命名了Python，因此有传言称IDLE的名字是为了纪念Monty Python的创始成员之一Eric
    Idle而选择的。
- en: Running Python as a service
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为服务运行Python
- en: Apart from being run as a script, and within the boundaries of a shell, Python
    can be coded and run as an application. We'll see many examples throughout the
    book about this mode. And we'll understand more about it in a moment, when we'll
    talk about how Python code is organized and run.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为脚本运行，并且在shell的边界内，Python还可以编码并作为应用程序运行。我们将在本书中看到许多关于这种模式的示例。我们将在稍后讨论Python代码是如何组织和运行的时候更多地了解它。
- en: Running Python as a GUI application
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为GUI应用程序运行的Python
- en: Python can also be run as a **graphical user interface** (**GUI**). There are
    several frameworks available, some of which are cross-platform and some others
    are platform-specific. In [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe),
    *GUIs and Scripts*, we'll see an example of a GUI application created using Tkinter,
    which is an object-oriented layer that lives on top of **Tk** (Tkinter means Tk
    interface).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python也可以作为图形用户界面（GUI）运行。有几个可用的框架，其中一些是跨平台的，另一些是特定于平台的。在第12章《GUI和脚本》中，我们将看到使用Tkinter创建的GUI应用程序的示例，Tkinter是一个面向对象的层，位于Tk（Tkinter表示Tk界面）之上。
- en: Tk is a GUI toolkit that takes desktop application development to a higher level
    than the conventional approach. It is the standard GUI for **Tool Command Language** (**Tcl**),
    but also for many other dynamic languages, and it can produce rich native applications
    that run seamlessly under Windows, Linux, macOS X, and more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Tk是一个GUI工具包，它将桌面应用程序开发提升到比传统方法更高的水平。它是**Tool Command Language**（Tcl）的标准GUI，但也是许多其他动态语言的标准GUI，并且可以生成在Windows、Linux、macOS
    X等系统下无缝运行的丰富本机应用程序。
- en: Tkinter comes bundled with Python; therefore, it gives the programmer easy access
    to the GUI world, and for these reasons, I have chosen it to be the framework
    for the GUI examples that I'll present in this book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter与Python捆绑在一起；因此，它为程序员提供了轻松访问GUI世界的便利，并且出于这些原因，我选择它作为我将在本书中呈现的GUI示例的框架。
- en: 'Among the other GUI frameworks, we find that the following are the most widely
    used:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他GUI框架中，我们发现以下是最广泛使用的：
- en: PyQt
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt
- en: wxPython
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wxPython
- en: PyGTK
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyGTK
- en: 'Describing them in detail is outside the scope of this book, but you can find
    all the information you need on the Python website ([https://docs.python.org/3/faq/gui.html](https://docs.python.org/3/faq/gui.html))
    in the *What platform-independent GUI toolkits exist for Python?* section. If
    GUIs are what you''re looking for, remember to choose the one you want according
    to some principles. Make sure they:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述它们超出了本书的范围，但您可以在Python网站上找到所有您需要的信息（https://docs.python.org/3/faq/gui.html）在“Python存在哪些平台无关的GUI工具包？”部分。如果GUI是您要寻找的内容，请记住根据一些原则选择您想要的。确保它们：
- en: Offer all the features you may need to develop your project
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供您可能需要开发项目的所有功能
- en: Run on all the platforms you may need to support
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您可能需要支持的所有平台上运行
- en: Rely on a community that is as wide and active as possible
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于尽可能广泛和活跃的社区
- en: Wrap graphic drivers/tools that you can easily install/access
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装图形驱动程序/工具，您可以轻松安装/访问
- en: How is Python code organized?
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python代码是如何组织的？
- en: Let's talk a little bit about how Python code is organized. In this section,
    we'll start going down the rabbit hole a little bit more and introduce more technical
    names and concepts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈Python代码是如何组织的。在本节中，我们将开始更深入地探讨一些技术名称和概念。
- en: Starting with the basics, how is Python code organized? Of course, you write
    your code into files. When you save a file with the extension `.py`, that file
    is said to be a Python module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础开始，Python代码是如何组织的？当然，您将代码写入文件中。当您使用扩展名`.py`保存文件时，该文件被称为Python模块。
- en: If you're on Windows or macOS that typically hide file extensions from the user,
    please make sure you change the configuration so that you can see the complete
    names of the files. This is not strictly a requirement, but a suggestion.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是通常会向用户隐藏文件扩展名的Windows或macOS，请确保更改配置，以便您可以看到完整的文件名。这不是严格要求，而是一个建议。
- en: It would be impractical to save all the code that it is required for software
    to work within one single file. That solution works for scripts, which are usually
    not longer than a few hundred lines (and often they are quite shorter than that).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有软件工作所需的代码保存在一个文件中是不切实际的。这种解决方案适用于脚本，通常不超过几百行（而且通常要比这短得多）。
- en: A complete Python application can be made of hundreds of thousands of lines
    of code, so you will have to scatter it through different modules, which is better,
    but not nearly good enough. It turns out that even like this, it would still be
    impractical to work with the code. So Python gives you another structure, called **package**,
    which allows you to group modules together. A package is nothing more than a folder,
    which must contain a special file, `__init__.py`, that doesn't need to hold any
    code but whose presence is required to tell Python that the folder is not just
    some folder, but it's actually a package (note that as of Python 3.3, the `__init__.py` module
    is not strictly required any more).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的Python应用程序可能由数十万行代码组成，因此你将不得不将它分散到不同的模块中，这样做更好，但还不够好。事实证明，即使像这样，使用这些代码仍然是不切实际的。因此，Python给了你另一个结构，称为**包**，它允许你将模块组合在一起。包实际上就是一个文件夹，其中必须包含一个特殊的文件`__init__.py`，它不需要包含任何代码，但其存在是必需的，以告诉Python这个文件夹不仅仅是一个文件夹，而实际上是一个包（需要注意的是，从Python
    3.3开始，`__init__.py`模块不再是严格必需的）。
- en: 'As always, an example will make all of this much clearer. I have created an
    example structure in my book project, and when I type in my console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，举个例子会让这一切更加清晰。我在我的书项目中创建了一个示例结构，当我在控制台中输入时：
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I get a tree representation of the contents of the `ch1/example` folder, which
    holds the code for the examples of this chapter. Here''s what the structure of
    a really simple application could look like:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了`ch1/example`文件夹内容的树形表示，其中包含本章示例的代码。一个非常简单应用程序的结构可能如下所示：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see that within the root of this example, we have two modules, `core.py`
    and `run.py`, and one package: `util`. Within `core.py`, there may be the core
    logic of our application. On the other hand, within the `run.py` module, we can
    probably find the logic to start the application. Within the `util` package, I
    expect to find various utility tools, and in fact, we can guess that the modules
    there are named based on the types of tools they hold: `db.py` would hold tools
    to work with databases, `math.py` would, of course, hold mathematical tools (maybe
    our application deals with financial data), and `network.py` would probably hold
    tools to send/receive data on networks.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在这个示例的根目录中，我们有两个模块，`core.py`和`run.py`，还有一个包：`util`。在`core.py`中，可能包含我们应用程序的核心逻辑。另一方面，在`run.py`模块中，我们可能会找到启动应用程序的逻辑。在`util`包中，我希望找到各种实用工具，实际上，我们可以猜到那里的模块是根据它们所持有的工具类型命名的：`db.py`将持有与数据库工作相关的工具，`math.py`当然将持有数学工具（也许我们的应用程序处理财务数据），`network.py`可能将持有在网络上发送/接收数据的工具。
- en: As explained before, the `__init__.py` file is there just to tell Python that
    `util` is a package and not just a mere folder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`__init__.py`文件只是告诉Python`util`是一个包，而不仅仅是一个普通的文件夹。
- en: 'Had this software been organized within modules only, it would have been harder
    to infer its structure. I put a *module only* example under the `ch1/files_only`
    folder; see it for yourself:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个软件只是在模块中组织，要推断它的结构将会更加困难。我在`ch1/files_only`文件夹下放了一个*只有模块*的例子；你自己看看吧：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This shows us a completely different picture:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们展示了一个完全不同的画面：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is a little harder to guess what each module does, right? Now, consider that
    this is just a simple example, so you can guess how much harder it would be to
    understand a real application if we couldn't organize the code in packages and
    modules.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测每个模块的功能可能有点困难，对吧？现在，考虑到这只是一个简单的例子，你可以猜想如果我们不能将代码组织成包和模块，要理解一个真实应用程序会有多困难。
- en: How do we use modules and packages?
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何使用模块和包？
- en: When a developer is writing an application, it is likely that they will need
    to apply the same piece of logic in different parts of it. For example, when writing
    a parser for the data that comes from a form that a user can fill in a web page,
    the application will have to validate whether a certain field is holding a number
    or not. Regardless of how the logic for this kind of validation is written, it's
    likely that it will be needed in more than one place.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员编写应用程序时，很可能需要在不同的部分应用相同的逻辑。例如，当编写一个解析器来解析来自用户可以在网页上填写的表单的数据时，应用程序将需要验证某个字段是否包含数字。无论这种验证逻辑是如何编写的，它很可能会在多个地方被需要。
- en: 'For example, in a poll application, where the user is asked many questions,
    it''s likely that several of them will require a numeric answer. For example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个调查应用程序中，用户被问及许多问题，很可能其中几个问题需要一个数字答案。例如：
- en: What is your age?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的年龄是多少？
- en: How many pets do you own?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你拥有多少宠物？
- en: How many children do you have?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多少个孩子？
- en: How many times have you been married?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你结婚了多少次？
- en: 'It would be very bad practice to copy/paste (or, more properly said: duplicate)
    the validation logic in every place where we expect a numeric answer. This would
    violate the **don''t repeat yourself** (**DRY**) principle, which states that
    you should never repeat the same piece of code more than once in your application.
    I feel the need to stress the importance of this principle: *you should never
    repeat the same piece of code more than once in your application* (pun intended).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们期望得到一个数字答案的每个地方复制/粘贴（或者更准确地说：重复）验证逻辑是非常不好的做法。这将违反**不要重复自己**（**DRY**）原则，该原则规定你在应用程序中不应该重复相同的代码片段。我感到有必要强调这一原则的重要性：*你在应用程序中不应该重复相同的代码片段*（这是双关语）。
- en: 'There are several reasons why repeating the same piece of logic can be very
    bad, the most important ones being:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同逻辑的几个原因可能非常糟糕，最重要的原因有：
- en: There could be a bug in the logic, and therefore, you would have to correct
    it in every place that the logic is applied.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑可能存在错误，因此，您将不得不在应用逻辑的每个地方进行更正。
- en: You may want to amend the way you carry out the validation, and again you would
    have to change it in every place it is applied.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能希望修改验证的方式，再次需要在应用它的每个地方进行更改。
- en: You may forget to fix/amend a piece of logic because you missed it when searching
    for all its occurrences. This would leave wrong/inconsistent behavior in your
    application.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会忘记修复/修改一个逻辑片段，因为在搜索所有出现时错过了它。这将在您的应用程序中留下错误/不一致的行为。
- en: Your code would be longer than needed, for no good reason.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码会比需要的更长，没有好的理由。
- en: Python is a wonderful language and provides you with all the tools you need
    to apply all the coding best practices. For this particular example, we need to
    be able to reuse a piece of code. To be able to reuse a piece of code, we need
    to have a construct that will hold the code for us so that we can call that construct
    every time we need to repeat the logic inside it. That construct exists, and it's
    called a **function**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种很棒的语言，为您提供了应用所有编码最佳实践所需的所有工具。对于这个特定的例子，我们需要能够重用一段代码。为了能够重用一段代码，我们需要一个构造，它将为我们保存代码，以便我们可以在需要重复其中的逻辑时调用该构造。这个构造存在，它被称为**函数**。
- en: I'm not going too deep into the specifics here, so please just remember that
    a function is a block of organized, reusable code that is used to perform a task.
    Functions can assume many forms and names, according to what kind of environment
    they belong to, but for now this is not important. We'll see the details when
    we are able to appreciate them, later on, in the book. Functions are the building
    blocks of modularity in your application, and they are almost indispensable. Unless
    you're writing a super-simple script, you'll use functions all the time. We'll
    explore functions in [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Functions, the Building Blocks of Code*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不会深入讨论具体内容，请记住函数是一块有组织的可重用代码，用于执行任务。函数可以根据它们所属的环境的不同形式和名称，但现在这并不重要。我们将在书中稍后能够欣赏它们时看到细节。函数是应用程序中模块化的构建块，几乎是不可或缺的。除非您正在编写一个超级简单的脚本，否则您将一直使用函数。我们将在[第4章](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe)中探讨函数，*函数，代码的构建块*。
- en: 'Python comes with a very extensive library, as I have already said a few pages
    ago. Now, maybe it''s a good time to define what a library is: a **library** is
    a collection of functions and objects that provide functionalities that enrich
    the abilities of a language.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个非常广泛的库，就像我之前说过的那样。现在，也许是定义什么是库的好时机：**库**是一组函数和对象的集合，提供丰富语言功能的功能。
- en: For example, within Python's `math` library, we can find a plethora of functions,
    one of which is the `factorial` function, which of course calculates the factorial
    of a number.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Python的`math`库中，我们可以找到大量的函数，其中之一是`factorial`函数，它当然计算一个数字的阶乘。
- en: 'In mathematics, the **factorial** of a non-negative integer number *N*, denoted
    as *N!*, is defined as the product of all positive integers less than or equal
    to *N*. For example, the factorial of `5` is calculated as:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，非负整数*N*的**阶乘**，表示为*N*！，被定义为小于或等于*N*的所有正整数的乘积。例如，计算`5`的阶乘为：
- en: '`5! = 5 * 4 * 3 * 2 * 1 = 120`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`5！= 5 * 4 * 3 * 2 * 1 = 120`'
- en: The factorial of `0` is `0! = 1`, to respect the convention for an empty product.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`的阶乘是`0！= 1`，以尊重空乘积的约定。'
- en: So, if you wanted to use this function in your code, all you would have to do
    is to import it and call it with the right input values. Don't worry too much
    if input values and the concept of calling is not very clear for now; please just
    concentrate on the import part. We use a library by importing what we need from
    it, and then we use it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想在代码中使用此函数，您只需导入它并使用正确的输入值调用它。如果输入值和调用的概念现在不太清楚，不要太担心；请专注于导入部分。我们通过从中导入所需的内容来使用库，然后使用它。
- en: 'In Python, to calculate the factorial of number `5`, we just need the following
    code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，要计算数字`5`的阶乘，我们只需要以下代码：
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Whatever we type in the shell, if it has a printable representation, will be
    printed on the console for us (in this case, the result of the function call:
    `120`).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在shell中输入什么，只要它有可打印的表示，就会在控制台上为我们打印出来（在这种情况下，函数调用的结果：`120`）。
- en: So, let's go back to our example, the one with `core.py`, `run.py`, `util`,
    and so on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们回到我们的例子，那个有`core.py`，`run.py`，`util`等等的例子。
- en: In our example, the package `util` is our utility library. Our custom utility
    belt that holds all those reusable tools (that is, functions), which we need in
    our application. Some of them will deal with databases (`db.py`), some with the
    network (`network.py`), and some will perform mathematical calculations (`math.py`)
    that are outside the scope of Python's standard `math` library and, therefore,
    we have to code them for ourselves.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，包`util`是我们的实用库。我们自定义的实用工具包，其中包含我们应用程序中需要的所有可重用工具（即函数）。其中一些将处理数据库（`db.py`），一些将处理网络（`network.py`），一些将执行数学计算（`math.py`），这些都超出了Python标准`math`库的范围，因此我们必须自己编写它们。
- en: 'We will see in detail how to import functions and use them in their dedicated
    chapter. Let''s now talk about another very important concept: *Python''s execution
    model*.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细了解如何导入函数并在它们专用的章节中使用它们。现在让我们谈谈另一个非常重要的概念：*Python的执行模型*。
- en: Python's execution model
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的执行模型
- en: In this section, I would like to introduce you to a few very important concepts,
    such as scope, names, and namespaces. You can read all about Python's execution
    model in the official language reference, of course, but I would argue that it
    is quite technical and abstract, so let me give you a less formal explanation
    first.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我想向你介绍一些非常重要的概念，比如作用域、名称和命名空间。当然，你可以阅读官方语言参考手册中关于Python执行模型的所有内容，但我认为那相当技术和抽象，所以让我先给你一个不太正式的解释。
- en: Names and namespaces
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称和命名空间
- en: Say you are looking for a book, so you go to the library and ask someone for
    the book you want to fetch. They tell you something like *Second Floor, Section
    X, Row Three*. So you go up the stairs, look for Section X, and so on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在寻找一本书，所以你去图书馆，向某人询问你想要取的书。他们告诉你类似于*二楼，X区，第三排*。所以你上楼梯，寻找X区，依此类推。
- en: It would be very different to enter a library where all the books are piled
    together in random order in one big room. No floors, no sections, no rows, no
    order. Fetching a book would be extremely hard.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进入一个图书馆，那里所有的书都堆在一起，没有顺序地放在一个大房间里，那将会非常不同。没有楼层，没有区域，没有排，没有顺序。找一本书将会非常困难。
- en: 'When we write code, we have the same issue: we have to try and organize it
    so that it will be easy for someone who has no prior knowledge about it to find
    what they''re looking for. When software is structured correctly, it also promotes
    code reuse. On the other hand, disorganized software is more likely to expose
    scattered pieces of duplicated logic.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们有同样的问题：我们必须尝试组织它，以便对于没有先验知识的人来说，能够轻松找到他们正在寻找的东西。当软件结构正确时，它也促进了代码的重用。另一方面，组织混乱的软件更有可能暴露分散的重复逻辑片段。
- en: 'First of all, let''s start with the book. We refer to a book by its title and
    in Python lingo, that would be a name. Python names are the closest abstraction
    to what other languages call variables. Names basically refer to objects and are
    introduced by name-binding operations. Let''s make a quick example (notice that
    anything that follows a `#` is a comment):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从书开始。我们通过它的标题来引用一本书，在Python术语中，那将是一个名称。Python名称是其他语言称为变量的最接近的抽象。名称基本上是指对象，并且是通过名称绑定操作引入的。让我们举个快速的例子（请注意，跟在`#`后面的任何内容都是注释）：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We defined three objects in the preceding code (do you remember what are the
    three features every Python object has?):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中定义了三个对象（你还记得每个Python对象具有的三个特征是什么吗？）：
- en: 'An integer number `n` (type: `int`, value: `3`)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数`n`（类型：`int`，值：`3`）
- en: 'A string `address` (type: `str`, value: Sherlock Holmes'' address)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串`address`（类型：`str`，值：福尔摩斯的地址）
- en: 'A dictionary `employee` (type: `dict`, value: a dictionary that holds three
    key/value pairs)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字典`employee`（类型：`dict`，值：包含三个键/值对的字典）
- en: Don't worry, I know you're not supposed to know what a dictionary is. We'll
    see in [Chapter 2](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe), *Built-in
    Data Types*, that it's the king of Python data structures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，我知道你不应该知道什么是字典。我们将在[第2章](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe)中看到，*内置数据类型*，它是Python数据结构的王者。
- en: Have you noticed that the prompt changed from `>>>` to `...` when I typed in
    the definition of employee? That's because the definition spans over multiple
    lines.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，当我输入employee的定义时，提示从`>>>`变成了`...`？那是因为定义跨越了多行。
- en: 'So, what are `n`, `address`, and `employee`? They are **names**. Names that
    we can use to retrieve data within our code. They need to be kept somewhere so
    that whenever we need to retrieve those objects, we can use their names to fetch
    them. We need some space to hold them, hence: namespaces!'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`n`，`address`和`employee`是什么？它们是**名称**。我们可以使用这些名称在我们的代码中检索数据。它们需要被保存在某个地方，这样每当我们需要检索这些对象时，我们可以使用它们的名称来获取它们。我们需要一些空间来保存它们，因此：命名空间！
- en: A **namespace** is therefore a mapping from names to objects. Examples are the
    set of built-in names (containing functions that are always accessible in any
    Python program), the global names in a module, and the local names in a function.
    Even the set of attributes of an object can be considered a namespace.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**因此是从名称到对象的映射。例如内置名称集（包含在任何Python程序中始终可访问的函数）、模块中的全局名称和函数中的局部名称。甚至对象的属性集也可以被视为命名空间。'
- en: 'The beauty of namespaces is that they allow you to define and organize your
    names with clarity, without overlapping or interference. For example, the namespace
    associated with that book we were looking for in the library can be used to import
    the book itself, like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的美妙之处在于它们允许您以清晰的方式定义和组织您的名称，而不会重叠或干扰。例如，与我们在图书馆寻找的那本书相关联的命名空间可以用来导入书本本身，就像这样：
- en: '[PRE14]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We start from the `library` namespace, and by means of the dot (`.`) operator,
    we walk into that namespace. Within this namespace, we look for `second_floor`,
    and again we walk into it with the `.` operator. We then walk into `section_x`,
    and finally within the last namespace, `row_three`, we find the name we were looking
    for: `book`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`library`命名空间开始，通过点（`.`）运算符，我们进入该命名空间。在这个命名空间中，我们寻找`second_floor`，再次使用`.`运算符进入它。然后我们进入`section_x`，最后在最后一个命名空间`row_three`中，我们找到了我们要找的名称：`book`。
- en: Walking through a namespace will be clearer when we'll be dealing with real
    code examples. For now, just keep in mind that namespaces are places where names
    are associated with objects.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理真实的代码示例时，通过命名空间的遍历将更加清晰。现在，只需记住命名空间是名称与对象相关联的地方。
- en: 'There is another concept, which is closely related to that of a namespace,
    which I''d like to briefly talk about: the **scope**.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个概念，与命名空间的概念密切相关，我想简要谈谈：**作用域**。
- en: Scopes
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: 'According to Python''s documentation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python的文档：
- en: '" *A scope is a textual region of a Python program, where a namespace is directly
    accessible*."'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: “*作用域是Python程序的文本区域，其中命名空间是直接可访问的*。”
- en: Directly accessible means that when you're looking for an unqualified reference
    to a name, Python tries to find it in the namespace.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 直接可访问意味着当你寻找一个未经修饰的名称引用时，Python会尝试在命名空间中找到它。
- en: 'Scopes are determined statically, but actually, during runtime, they are used
    dynamically. This means that by inspecting the source code, you can tell what
    the scope of an object is, but this doesn''t prevent the software from altering
    that during runtime. There are four different scopes that Python makes accessible
    (not necessarily all of them are present at the same time, of course):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是静态确定的，但实际上在运行时是动态使用的。这意味着通过检查源代码，你可以知道对象的作用域是什么，但这并不阻止软件在运行时改变它。Python提供了四种不同的作用域（当然不一定同时都存在）：
- en: The **local** scope, which is the innermost one and contains the local names.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**local**作用域，是最内层的作用域，包含局部名称。'
- en: The **enclosing** scope, that is, the scope of any enclosing function. It contains
    non-local names and also non-global names.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**enclosing**作用域，即任何封闭函数的作用域。它包含非局部名称和非全局名称。'
- en: The **global** scope contains the global names.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**global**作用域包含全局名称。'
- en: The **built-in** scope contains the built-in names. Python comes with a set
    of functions that you can use in an off-the-shelf fashion, such as `print`, `all`,
    `abs`, and so on. They live in the built-in scope.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**built-in**作用域包含内置名称。Python带有一组函数，可以直接使用，例如`print`、`all`、`abs`等。它们存在于内置作用域中。'
- en: 'The rule is the following: when we refer to a name, Python starts looking for
    it in the current namespace. If the name is not found, Python continues the search
    to the enclosing scope and this continues until the built-in scope is searched.
    If a name hasn''t been found after searching the built-in scope, then Python raises
    a `NameError`** exception**, which basically means that the name hasn''t been
    defined (you saw this in the preceding example).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是：当我们引用一个名称时，Python会从当前命名空间开始查找它。如果找不到该名称，Python会继续搜索封闭作用域，直到搜索内置作用域。如果在搜索内置作用域后仍然找不到名称，那么Python会引发一个`NameError`异常，这基本上意味着该名称未被定义（你在前面的例子中看到了这一点）。
- en: 'The order in which the namespaces are scanned when looking for a name is therefore:
    **local**, **enclosing**, **global**, **built-in** (**LEGB**).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在查找名称时，命名空间的扫描顺序是：**local**，**enclosing**，**global**，**built-in**（**LEGB**）。
- en: 'This is all very theoretical, so let''s see an example. In order to show you
    local and enclosing namespaces, I will have to define a few functions. Don''t
    worry if you are not familiar with their syntax for the moment. We''ll study functions
    in [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe), *Functions,
    the Building Blocks of Code*. Just remember that in the following code, when you
    see `def`, it means I''m defining a function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常理论性的，所以让我们看一个例子。为了向你展示局部和封闭命名空间，我将不得不定义一些函数。如果你暂时不熟悉它们的语法，不要担心。我们将在[第4章](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe)中学习函数，*函数，代码的构建块*。只要记住，在下面的代码中，当你看到`def`时，这意味着我正在定义一个函数：
- en: '[PRE15]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we define the same name `m`, both in the global scope
    and in the local one (the one defined by the `local` function). When we execute
    this program with the following command (have you activated your virtualenv?):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在全局作用域和局部作用域（由`local`函数定义的作用域）中定义了相同的名称`m`。当我们使用以下命令执行此程序时（你已经激活了你的虚拟环境吗？）：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We see two numbers printed on the console: `5` and `7`.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台上看到两个数字打印出来：`5`和`7`。
- en: 'What happens is that the Python interpreter parses the file, top to bottom.
    First, it finds a couple of comment lines, which are skipped, then it parses the
    definition of the function `local`. When called, this function does two things:
    it sets up a name to an object representing number `7` and prints it. The Python
    interpreter keeps going and it finds another name binding. This time the binding
    happens in the global scope and the value is `5`. The next line is a call to the
    `print` function, which is executed (and so we get the first value printed on
    the console: `5`).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，Python解释器从文件顶部向下解析文件。首先，它找到了一对注释行，然后解析了函数`local`的定义。当调用时，该函数执行两件事：它将一个名称设置为代表数字`7`的对象，并将其打印出来。Python解释器继续前进，找到另一个名称绑定。这次绑定发生在全局作用域中，值为`5`。下一行是对`print`函数的调用，它被执行（因此我们在控制台上得到了第一个打印出来的值：`5`）。
- en: After this, there is a call to the function `local`. At this point, Python executes
    the function, so at this time, the binding `m = 7` happens and it's printed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，有一个对`local`函数的调用。此时，Python执行该函数，因此此时发生了绑定`m = 7`并打印出来。
- en: One very important thing to notice is that the part of the code that belongs
    to the definition of the `local` function is indented by four spaces on the right.
    Python, in fact, defines scopes by indenting the code. You walk into a scope by
    indenting, and walk out of it by unindenting. Some coders use two spaces, others
    three, but the suggested number of spaces to use is four. It's a good measure
    to maximize readability. We'll talk more about all the conventions you should
    embrace when writing Python code later.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件非常重要的事情需要注意，那就是属于`local`函数定义的代码部分在右侧缩进了四个空格。实际上，Python通过缩进代码来定义作用域。通过缩进进入作用域，通过取消缩进退出作用域。一些编码人员使用两个空格，其他人使用三个空格，但建议使用的空格数是四个。这是一个很好的措施，可以最大程度地提高可读性。我们稍后会谈论在编写Python代码时应该遵循的所有惯例。
- en: 'What would happen if we removed that `m = 7` line? Remember the LEGB rule.
    Python would start looking for `m` in the local scope (function `local`), and,
    not finding it, it would go to the next enclosing scope. The next one, in this
    case, is the global one because there is no enclosing function wrapped around
    `local`. Therefore, we would see two numbers `5` printed on the console. Let''s
    actually see what the code would look like:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除了`m = 7`这一行会发生什么？记住LEGB规则。Python会从局部作用域（函数`local`）开始查找`m`，如果找不到，它会继续到下一个封闭作用域。在这种情况下，下一个作用域是全局作用域，因为`local`周围没有封闭函数。因此，我们会在控制台上看到两个数字`5`打印出来。让我们实际看一下代码会是什么样子：
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `scopes2.py` will print this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`scopes2.py`将打印出这个：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As expected, Python prints `m` the first time, then when the function `local`
    is called, `m` isn't found in its scope, so Python looks for it following the
    LEGB chain until `m` is found in the global scope.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Python首次打印`m`，然后当调用函数`local`时，在它的作用域中找不到`m`，所以Python沿着LEGB链寻找，直到在全局作用域中找到`m`。
- en: 'Let''s see an example with an extra layer, the enclosing scope:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个带有额外层的例子，封闭作用域：
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running `scopes3.py` will print on the console:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`scopes3.py`将在控制台上打印：
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the `print` instruction from the function `local` is referring
    to `m` as before. `m` is still not defined within the function itself, so Python
    starts walking scopes following the LEGB order. This time `m` is found in the
    enclosing scope.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，函数`local`中的`print`指令仍然是之前的`m`。`m`仍然没有在函数本身中定义，所以Python按照LEGB顺序遍历作用域。这次`m`在封闭作用域中找到了。
- en: Don't worry if this is still not perfectly clear for now. It will come to you
    as we go through the examples in the book. The *Classes* section of the Python
    tutorial ([https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html))
    has an interesting paragraph about scopes and namespaces. Make sure you read it
    at some point if you want a deeper understanding of the subject.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果这还不是很清楚，不要担心。随着我们在书中的例子，你会慢慢理解的。Python教程的*Classes*部分（[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)）有一段有趣的关于作用域和命名空间的段落。如果你想更深入地理解这个主题，一定要在某个时候阅读它。
- en: Before we finish off this chapter, I would like to talk a bit more about objects.
    After all, basically everything in Python is an object, so I think they deserve
    a bit more attention.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我想再多谈谈对象。毕竟，基本上Python中的一切都是对象，所以我认为它们值得更多的关注。
- en: Objects and classes
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和类
- en: When I introduced objects previously in the *A proper introduction* section
    of the chapter, I said that we use them to represent real-life objects. For example,
    we sell goods of any kind on the web nowadays and we need to be able to handle,
    store, and represent them properly. But objects are actually so much more than
    that. Most of what you will ever do, in Python, has to do with manipulating objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在本章的*A proper introduction*部分介绍对象时，我说我们用它们来代表现实生活中的对象。例如，我们现在在网上销售各种商品，我们需要能够适当地处理、存储和表示它们。但对象实际上远不止于此。在Python中，你将要做的大部分事情都与操作对象有关。
- en: So, without going into too much detail (we'll do that in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*), I want to give you the *in a nutshell* kind
    of explanation about classes and objects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要深入细节（我们将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中做），我想给你一个关于类和对象的*简明扼要*的解释。
- en: 'We''ve already seen that objects are Python''s abstraction for data. In fact,
    everything in Python is an object, infact numbers, strings (data structures that
    hold text), containers, collections, even functions. You can think of them as
    if they were boxes with at least three features: an ID (unique), a type, and a
    value.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到对象是Python对数据的抽象。事实上，Python中的一切都是对象，包括数字，字符串（保存文本的数据结构），容器，集合，甚至函数。你可以把它们想象成至少具有三个特征的盒子：一个ID（唯一），一个类型和一个值。
- en: 'But how do they come to life? How do we create them? How do we write our own
    custom objects? The answer lies in one simple word: **classes**.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它们是如何产生的呢？我们如何创建它们？我们如何编写我们自己的自定义对象？答案就在一个简单的词中：**classes**。
- en: 'Objects are, in fact, instances of classes. The beauty of Python is that classes
    are objects themselves, but let''s not go down this road. It leads to one of the
    most advanced concepts of this language: **metaclasses**. For now, the best way
    for you to get the difference between classes and objects is by means of an example.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，对象是类的实例。Python的美妙之处在于类本身也是对象，但我们不要深入研究这一点。这会导致这种语言中最先进的概念之一：**元类**。现在，你理解类和对象之间的区别最好的方法是通过一个例子。
- en: Say a friend tells you, *I bought a new bike!* You immediately understand what
    she's talking about. Have you seen the bike? No. Do you know what color it is?
    Nope. The brand? Nope. Do you know anything about it? Nope. But at the same time,
    you know everything you need in order to understand what your friend meant when
    she told you she bought a new bike. You know that a bike has two wheels attached
    to a frame, a saddle, pedals, handlebars, brakes, and so on. In other words, even
    if you haven't seen the bike itself, you know the concept of *bike*. An abstract
    set of features and characteristics that together form something called *bike*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 比如一个朋友告诉你，*我买了一辆新自行车！* 你立刻明白她在说什么。你看到了自行车吗？没有。你知道它是什么颜色吗？不知道。品牌呢？也不知道。你对它了解多少？一无所知。但与此同时，你知道你需要了解的一切，以理解你的朋友告诉你她买了一辆新自行车的意思。你知道自行车有两个轮子连接在一个框架上，有一个鞍座，脚踏板，把手，刹车等等。换句话说，即使你没有看到自行车本身，你知道*自行车*的概念。一组抽象的特征和特性共同形成了所谓的*自行车*。
- en: In computer programming, that is called a **class**. It's that simple. Classes
    are used to create objects. In fact, objects are said to be **instances of classes**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，这就是所谓的**class**。就是这么简单。类用于创建对象。实际上，对象被称为**类的实例**。
- en: In other words, we all know what a bike is; we know the class. But then I have
    my own bike, which is an instance of the bike class. And my bike is an object
    with its own characteristics and methods. You have your own bike. Same class,
    but different instance. Every bike ever created in the world is an instance of
    the bike class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们都知道自行车是什么；我们知道这个类。但是我有自己的自行车，它是自行车类的一个实例。我的自行车是一个具有自己特征和方法的对象。你也有自己的自行车。同一个类，但不同的实例。世界上制造的每一辆自行车都是自行车类的一个实例。
- en: 'Let''s see an example. We will write a class that defines a bike and then we''ll
    create two bikes, one red and one blue. I''ll keep the code very simple, but don''t
    fret if you don''t understand everything about it; all you need to care about
    at this moment is to understand the difference between a class and an object (or
    instance of a class):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将编写一个定义自行车的类，然后我们将创建两辆自行车，一辆红色，一辆蓝色。我会保持代码非常简单，但如果你不完全理解它，不要担心；你现在需要关心的是理解类和对象（或类的实例）之间的区别：
- en: '[PRE21]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I hope by now I don't need to tell you to run the file every time, right? The
    filename is indicated in the first line of the code block. Just run `$ python
    filename`, and you'll be fine. But remember to have your virtualenv activated!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望到现在为止我不需要告诉你每次都要运行文件，对吧？代码块的第一行指示了文件名。只需运行`$ python filename`，你就没问题了。但记得要激活你的虚拟环境！
- en: So many interesting things to notice here. First things first; the definition
    of a class happens with the `class` statement. Whatever code comes after the `class`
    statement, and is indented, is called the body of the class. In our case, the
    last line that belongs to the class definition is the `print("Braking!")` one.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的事情要注意。首先，类的定义是通过`class`语句完成的。`class`语句之后的任何代码，并且缩进，被称为类的主体。在我们的例子中，属于类定义的最后一行是`print("Braking!")`。
- en: After having defined the class, we're ready to create instances. You can see
    that the class body hosts the definition of two methods. A method is basically
    (and simplistically) a function that belongs to a class.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了类之后，我们准备创建实例。你可以看到类主体中定义了两种方法。方法基本上（并且简单地）是属于类的函数。
- en: The first method, `__init__`, is an **initializer**. It uses some Python magic
    to set up the objects with the values we pass when we create it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法“__init__”是一个**初始化器**。它使用一些Python魔法来使用我们在创建时传递的值设置对象。
- en: Every method that has leading and trailing double underscores, in Python, is
    called a **magic method**. Magic methods are used by Python for a multitude of
    different purposes; hence it's never a good idea to name a custom method using
    two leading and trailing underscores. This naming convention is best left to Python.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个具有前导和尾随双下划线的方法都被称为**魔术方法**。Python使用魔术方法来实现多种不同的目的；因此，使用两个前导和尾随下划线命名自定义方法绝不是一个好主意。最好将这种命名约定留给Python。
- en: The other method we defined, `brake`, is just an example of an additional method
    that we could call if we wanted to brake the bike. It contains just a `print`
    statement, of course; it's an example.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的另一种方法“brake”只是一个额外方法的示例，如果我们想要刹车，我们可以调用它。当然，它只包含一个“print”语句；这只是一个例子。
- en: We created two bikes then. One has red color and a carbon fiber frame, and the
    other one has blue color and a steel frame. We pass those values upon creation.
    After creation, we print out the color property and frame type of the red bike,
    and the frame type of the blue one just as an example. We also call the `brake`
    method of the `red_bike`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两辆自行车。一辆是红色的，有碳纤维车架，另一辆是蓝色的，有钢车架。我们在创建时传递这些值。创建后，我们打印出红色自行车的颜色属性和车架类型，以及蓝色自行车的车架类型，只是一个例子。我们还调用了`red_bike`的`brake`方法。
- en: One last thing to notice. You remember I told you that the set of attributes
    of an object is considered to be a namespace? I hope it's clearer what I meant
    now. You see that by getting to the `frame_type` property through different namespaces
    (`red_bike`, `blue_bike`), we obtain different values. No overlapping, no confusion.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一件事。你还记得我告诉过你对象的属性集被认为是一个命名空间吗？我希望现在我说的更清楚了。你可以看到通过不同的命名空间（`red_bike`，`blue_bike`）获取`frame_type`属性，我们得到不同的值。没有重叠，没有混淆。
- en: The dot (`.`) operator is of course the means we use to walk into a namespace,
    in the case of objects as well.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 点（`.`）运算符当然是我们用来进入命名空间的手段，对于对象也是如此。
- en: Guidelines on how to write good code
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编写良好代码的指南
- en: 'Writing good code is not as easy as it seems. As I already said before, good
    code exposes a long list of qualities that is quite hard to put together. Writing
    good code is, to some extent, an art. Regardless of where on the path you will
    be happy to settle, there is something that you can embrace which will make your
    code instantly better: **PEP 8**.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的代码并不像看起来那么容易。正如我之前所说，良好的代码具有一长串相当难以组合的特质。在某种程度上，编写良好的代码是一种艺术。无论你愿意在哪个阶段停下来，有一件事可以让你的代码立即变得更好：**PEP
    8**。
- en: 'According to Wikipedia:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: '"Python''s development is conducted largely through the Python Enhancement
    Proposal (PEP) process. The PEP process is the primary mechanism for proposing
    major new features, for collecting community input on an issue, and for documenting
    the design decisions that have gone into Python."'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: “Python的开发主要通过Python Enhancement Proposal（PEP）过程进行。PEP过程是提出重大新功能、收集社区对问题的意见以及记录Python设计决策的主要机制。”
- en: 'PEP 8 is perhaps the most famous of all PEPs. It lays out a simple but effective
    set of guidelines to define Python aesthetics so that we write beautiful Python
    code. If you take one suggestion out of this chapter, please let it be this: use
    it. Embrace it. You will thank me later.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8可能是所有PEP中最著名的。它提出了一套简单但有效的指南，以定义Python的美学，使我们编写优美的Python代码。如果你从本章中得到一个建议，请让它成为这样：使用它。拥抱它。以后你会感谢我的。
- en: Coding today is no longer a check-in/check-out business. Rather, it's more of
    a social effort. Several developers collaborate on a piece of code through tools
    such as Git and Mercurial, and the result is code that is fathered by many different
    hands.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的编码不再是简单的签入/签出业务。相反，它更像是一种社会努力。几个开发人员通过Git和Mercurial等工具共同协作一段代码，结果是由许多不同的手所创造的代码。
- en: Git and Mercurial are probably the distributed revision control systems that
    are most used today. They are essential tools designed to help teams of developers
    collaborate on the same software.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Git和Mercurial可能是今天使用最多的分布式版本控制系统。它们是旨在帮助开发团队协作开发相同软件的基本工具。
- en: These days, more than ever, we need to have a consistent way of writing code,
    so that readability is maximized. When all developers of a company abide by PEP
    8, it's not uncommon for any of them landing on a piece of code to think they
    wrote it themselves. It actually happens to me all the time (I always forget the
    code I write).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们更需要有一种一致的编写代码的方式，以便最大限度地提高可读性。当公司的所有开发人员都遵守PEP 8时，他们中的任何一个人落在一段代码上时，都不会觉得这是别人写的。这实际上经常发生在我身上（我总是忘记我写的代码）。
- en: 'This has a tremendous advantage: when you read code that you could have written
    yourself, you read it easily. Without a convention, every coder would structure
    the code the way they like most, or simply the way they were taught or are used
    to, and this would mean having to interpret every line according to someone else''s
    style. It would mean having to lose much more time just trying to understand it.
    Thanks to PEP 8, we can avoid this. I''m such a fan of it that I won''t sign off
    a code review if the code doesn''t respect it. So, please take the time to study
    it; it''s very important.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个巨大的优势：当你阅读自己可以写的代码时，你会很容易地阅读它。没有约定，每个编码者都会按照他们最喜欢的方式或者他们被教导或者习惯的方式来构建代码，这意味着必须根据别人的风格来解释每一行。这意味着必须花费更多的时间来理解它。由于PEP
    8，我们可以避免这种情况。我是它的忠实粉丝，如果代码不遵守它，我就不会签署代码审查。所以，请花时间学习它；这非常重要。
- en: In the examples in this book, I will try to respect it as much as I can. Unfortunately,
    I don't have the luxury of 79 characters (which is the maximum line length suggested
    by PEP 8), and I will have to cut down on blank lines and other things, but I
    promise you I'll try to lay out my code so that it's as readable as possible.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我会尽量尊重它。不幸的是，我没有79个字符的奢侈（这是PEP 8建议的最大行长度），我将不得不减少空行和其他东西，但我向你保证我会尽量布置我的代码，使其尽可能可读。
- en: The Python culture
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python文化
- en: Python has been adopted widely in all coding industries. It's used by many different
    companies for many different purposes, and it's also used in education (it's an
    excellent language for that purpose, because of its many qualities and the fact
    that it's easy to learn).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经被广泛应用于所有编码行业。许多不同的公司用于许多不同的目的，它也被用于教育（因为它的许多优点和易学性，它是一个非常出色的语言）。
- en: One of the reasons Python is so popular today is that the community around it
    is vast, vibrant, and full of brilliant people. Many events are organized all
    over the world, mostly either around Python or its main web framework, Django.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Python如今如此受欢迎的一个原因是其周围的社区是庞大、充满活力和充满才华的人。世界各地都组织了许多活动，主要是围绕Python或其主要的Web框架Django。
- en: Python is open, and very often so are the minds of those who embrace it. Check
    out the community page on the Python website for more information and get involved!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Python是开放的，而且经常接受它的人的思想也是开放的。在Python网站的社区页面上查看更多信息并参与其中！
- en: There is another aspect to Python which revolves around the notion of being
    **Pythonic**. It has to do with the fact that Python allows you to use some idioms
    that aren't found elsewhere, at least not in the same form or as easy to use (I
    feel quite claustrophobic when I have to code in a language which is not Python
    now).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Python的另一个方面是围绕着**Pythonic**的概念。这与Python允许你使用一些在其他地方找不到的习语有关，至少不是以同样的形式或者不是那么容易使用（现在我在使用不是Python的语言编码时感到相当幽闭恐惧）。
- en: Anyway, over the years, this concept of being Pythonic has emerged and, the
    way I understand it, is something along the lines of *doing things the way they
    are supposed to be done in Python.*
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，多年来，Pythonic的概念已经出现了，我理解的方式是*按照Python应该被完成的方式来做事*。
- en: 'To help you understand a little bit more about Python''s culture and about
    being Pythonic, I will show you the *Zen of Python*. A lovely Easter egg that
    is very popular. Open up a Python console and type `import this`. What follows
    is the result of this line:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地了解Python的文化和Pythonic的含义，我将向你展示*Python之禅*。这是一个非常受欢迎的可爱彩蛋。打开Python控制台，输入`import
    this`。接下来是这行代码的结果：
- en: '[PRE22]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are two levels of reading here. One is to consider it as a set of guidelines
    that have been put down in a fun way. The other one is to keep it in mind, and
    maybe read it once in a while, trying to understand how it refers to something
    deeper: some Python characteristics that you will have to understand deeply in
    order to write Python the way it''s supposed to be written. Start with the fun
    level, and then dig deeper. Always dig deeper.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个阅读层次。一个是将其视为一组以有趣的方式提出的指导方针。另一个是牢记在心，并可能偶尔阅读一次，试图理解它是如何指涉更深层次的东西的：一些你必须深入理解的Python特性，以便按照它应该被编写的方式来编写Python。从有趣的层次开始，然后深入挖掘。始终深入挖掘。
- en: A note on IDEs
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于IDE的一点说明
- en: Just a few words about IDEs. To follow the examples in this book, you don't
    need one; any text editor will do fine. If you want to have more advanced features,
    such as syntax coloring and auto completion, you will have to fetch yourself an
    IDE. You can find a comprehensive list of open source IDEs (just Google Python
    IDEs) on the Python website. I personally use Sublime Text editor. It's free to
    try out and it costs just a few dollars. I have tried many IDEs in my life, but
    this is the one that makes me most productive.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IDE的一些话。为了跟随本书中的示例，你不需要一个；任何文本编辑器都可以。如果你想要更多高级功能，比如语法着色和自动补全，你就需要找一个IDE。你可以在Python网站上找到一份全面的开源IDE列表（只需谷歌Python
    IDEs）。我个人使用Sublime文本编辑器。它是免费试用的，只需几美元。我一生中尝试过许多IDE，但这是让我最有效率的一个。
- en: 'Two important pieces of advice:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重要的建议：
- en: Whatever IDE you choose to use, try to learn it well so that you can exploit
    its strengths, but *don't depend on it*. Exercise yourself to work with VIM (or
    any other text editor) once in a while; learn to be able to do some work on any
    platform, with any set of tools.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你选择使用哪种IDE，都要努力学会它，以便能够充分利用它的优势，但*不要依赖它*。偶尔练习使用VIM（或任何其他文本编辑器）；学会在任何平台上使用任何一套工具进行工作。
- en: Whatever text editor/IDE you use, when it comes to writing Python, *indentation
    is four spaces*. Don't use tabs, don't mix them with spaces. Use four spaces,
    not two, not three, not five. Just use four. The whole world works like that,
    and you don't want to become an outcast because you were fond of the three-space
    layout.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你使用什么文本编辑器/集成开发环境，在编写Python时，*缩进是四个空格*。不要使用制表符，也不要将它们与空格混合使用。使用四个空格，不是两个，不是三个，也不是五个。就使用四个。整个世界都是这样工作的，你不想因为你喜欢三个空格的布局而成为局外人。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started to explore the world of programming and that of
    Python. We've barely scratched the surface, just a little, touching concepts that
    will be discussed later on in the book in greater detail.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探索编程和Python的世界。我们只是略微触及了一些概念，这些概念将在本书的后面更详细地讨论。
- en: We talked about Python's main features, who is using it and for what, and what
    are the different ways in which we can write a Python program.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了Python的主要特性，谁在使用它以及为什么使用它，以及我们可以用哪些不同的方式编写Python程序。
- en: In the last part of the chapter, we flew over the fundamental notions of namespaces,
    scopes, classes, and objects. We also saw how Python code can be organized using
    modules and packages.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们简要介绍了命名空间、作用域、类和对象的基本概念。我们还看到了如何使用模块和包组织Python代码。
- en: On a practical level, we learned how to install Python on our system, how to
    make sure we have the tools we need, `pip` and virtualenv, and we also created
    and activated our first virtual environment. This will allow us to work in a self-contained
    environment without the risk of compromising the Python system installation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们学会了如何在系统上安装Python，如何确保我们拥有所需的工具`pip`和virtualenv，并创建并激活了我们的第一个虚拟环境。这将使我们能够在一个独立的环境中工作，而不会危及Python系统安装。
- en: Now you're ready to start this journey with me. All you need is enthusiasm,
    an activated virtual environment, this book, your fingers, and some coffee.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好和我一起开始这段旅程了。你所需要的只是热情、一个激活的虚拟环境、这本书、你的手指和一些咖啡。
- en: Try to follow the examples; I'll keep them simple and short. If you put them
    under your fingertips, you will retain them much better than if you just read
    them.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试跟着示例走；我会让它们简单而简短。如果你把它们放在指尖下，你会比仅仅阅读它们更好地记住它们。
- en: In the next chapter, we will explore Python's rich set of built-in data types.
    There's much to cover and much to learn!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Python丰富的内置数据类型。有很多内容需要涵盖和学习！
