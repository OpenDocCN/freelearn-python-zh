- en: Networking with RESTful APIs and Web Sockets Using Flask
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask进行RESTful API和Web Socket的网络连接
- en: In [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting Started
    with Python and IoT*, we created a networked IoT application based on `dweet.io`
    where you controlled an LED connected to your Raspberry Pi over the internet. Our
    first IoT application was driven purely by making API requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中，*使用Python和物联网入门*，我们创建了一个基于`dweet.io`的网络化物联网应用程序，在这个应用程序中，您可以通过互联网控制连接到树莓派的LED。我们的第一个物联网应用程序完全是通过API请求驱动的。
- en: In this chapter, we will turn our attention to alternative approaches to creating
    networked services in Python that can be accessed by both Python and non-Python
    clients. We will be looking at how to build a RESTful API server and a Web Socket
    server in Python and applying the electronic interfacing techniques we learned
    in the previous chapter to make them interact with our LED.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注Python中创建网络服务的替代方法，这些服务可以被Python和非Python客户端访问。我们将看看如何在Python中构建一个RESTful
    API服务器和一个Web Socket服务器，并应用我们在上一章学到的电子接口技术，使它们与我们的LED进行交互。
- en: After completing this chapter, you will have an understanding of two different
    approaches to building servers with Python, complete with accompanying web pages
    that interact with the servers. These two servers will provide you with an end-to-end
    reference implementation that you can use as a starting point for your own network-connected
    IoT projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将了解使用Python构建服务器的两种不同方法，包括与服务器交互的伴随网页。这两个服务器将为您提供一个端到端的参考实现，您可以将其用作自己网络连接的物联网项目的起点。
- en: Since this chapter is about networking techniques, we will continue with our
    GPIOZero-based LED from the preceding chapter merely for simplicity and abstraction
    so that our examples are to-the-point and network-focused and not cluttered by
    GPIO-related code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章是关于网络技术，我们将继续使用GPIOZero为基础的LED，仅仅是为了简化和抽象，以便我们的示例直截了当、以网络为重点，而不被GPIO相关的代码所混淆。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Flask microservices framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Flask微服务框架
- en: Creating a RESTful API service with Flask
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask创建RESTful API服务
- en: Adding a RESTful API client web page
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加RESTful API客户端网页
- en: Creating a Web Socket service with Flask-SocketIO
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-SocketIO创建Web Socket服务
- en: Adding Web Socket client web page
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Web Socket客户端网页
- en: Comparing the RESTful API and Web Socket servers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较RESTful API和Web Socket服务器
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B型
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: A minimum of Python version 3.5
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本是3.5或更高，代码示例应该可以在树莓派3型B型或不同版本的Raspbian OS上无需修改地运行。
- en: You will find this chapter's source code in the `chapter03` folder in the GitHub
    repository available here: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`chapter03`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install Python libraries required for the code in this chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令，以设置虚拟环境并安装本章所需的Python库：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Flask**: The core Flask microservices framework ([https://pypi.org/project/Flask](https://pypi.org/project/Flask))'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask**：核心Flask微服务框架（[https://pypi.org/project/Flask](https://pypi.org/project/Flask)）'
- en: '**Flask-RESTful**: A Flask extension for creating RESTful API services  ([https://pypi.org/project/Flask-RESTful](https://pypi.org/project/Flask-RESTful))'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask-RESTful**：用于创建RESTful API服务的Flask扩展（[https://pypi.org/project/Flask-RESTful](https://pypi.org/project/Flask-RESTful)）'
- en: '**Flask-SocketIO**: A Flask extension for creating Web Socket services ([https://pypi.org/project/Flask-SocketIO](https://pypi.org/project/Flask-SocketIO))'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask-SocketIO**：用于创建Web Socket服务的Flask扩展（[https://pypi.org/project/Flask-SocketIO](https://pypi.org/project/Flask-SocketIO)）'
- en: We will be working with the breadboard circuit we created in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, *Figure 2.7*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中创建的面包板电路，*使用Python和物联网入门*，*图2.7*。
- en: Introducing the Flask microservices framework
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flask微服务框架
- en: Flask is a popular and mature microservices framework for Python that you can
    use for creating APIs, websites, and just about any other networked service you
    can imagine. Flask is certainly not the only option available for Python, even
    though its maturity, range of add-ons, and extensions plus the availability of
    quality documentation and tutorials make it an excellent choice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个流行且成熟的Python微服务框架，您可以使用它来创建API、网站以及几乎任何其他您能想象到的网络服务。尽管Flask并不是Python唯一可用的选项，但其成熟性、各种附加组件和扩展，以及优质文档和教程的可用性使其成为一个绝佳的选择。
- en: We could conceivably do all of the following coding exercises in this chapter
    using just the core Flask framework; however, there are quality extensions that
    will make our life much easier. These extensions are **Flask-RESTful** for creating
    RESTful API services and **Flask-SocketIO** for building Web Socket services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们可以想象只使用核心Flask框架来完成所有以下编码练习；然而，有一些优质的扩展可以让我们的生活变得更加轻松。这些扩展包括用于创建RESTful
    API服务的**Flask-RESTful**和用于构建Web Socket服务的**Flask-SocketIO**。
- en: The official API documentation for Flask-RESTful and Flask-SocketIO (or any
    Flask extension for that matter) generally assume existing knowledge of the core
    Flask framework, classes, and terminology. If you can't seem to find answers to
    your questions in an extension's documentation, remember to check the core Flask
    API documentation also. You'll find a link to this documentation in the *Further
    reading* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful和Flask-SocketIO（或任何Flask扩展）的官方API文档通常假定已经掌握了核心Flask框架、类和术语的知识。如果在扩展的文档中找不到问题的答案，请记得查看核心Flask
    API文档。您将在*进一步阅读*部分找到指向这些文档的链接。
- en: Let's commence and create a RESTful API service in Python using Flask-RESTful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，在Python中使用Flask-RESTful创建一个RESTful API服务。
- en: Creating a RESTful API service with Flask-RESTful
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask-RESTful创建RESTful API服务
- en: In this section, we will explore our first Python-based server, which will be
    a RESTful API server implemented using the Flask-RESTful framework for Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索我们的第一个基于Python的服务器，这将是一个使用Flask-RESTful框架实现的RESTful API服务器。
- en: A RESTful API (REST stands for Representational State Transfer) is a software
    design pattern used for building web service APIs. It's a flexible pattern that
    is both technology- and protocol-independent. Its technology independence helps
    to promote interoperability between different technologies and systems, including
    different programming languages. And although it does promote protocol independence,
    it's frequently and almost always by default (or, at the least, assumed to be)
    built on top of the HTTP protocol used by web servers and web browsers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API（REST代表Representational State Transfer）是一种用于构建Web服务API的软件设计模式。它是一种灵活的模式，既独立于技术又独立于协议。其技术独立性有助于促进不同技术和系统之间的互操作性，包括不同的编程语言。虽然它确实促进了协议的独立性，但它通常默认情况下是建立在Web服务器和Web浏览器使用的HTTP协议之上的。
- en: RESTful APIs are the most common technique used today for building web services
    and APIs. In fact, it's so common that many people learn about them and use the
    design pattern without ever understanding what they are! If you are new to RESTful
    APIs, you will a link in the *Further reading* section, which I encourage you
    to review as a primer before proceeding.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是今天构建Web服务和API最常用的技术。事实上，它是如此常见，以至于许多人在没有理解它们是什么的情况下就学习并使用了这种设计模式！如果您对RESTful
    API还不熟悉，我鼓励您在*进一步阅读*部分找到一个链接，建议您在继续之前先阅读一下。
- en: Our focus in this section will be on controlling an LED with a RESTful API and
    understanding how this is implemented using Python and the Flask-RESTful framework.
    After completing this section, you will be able to leverage this RESTful API server
    a starting point for your own IoT projects and integrate it with other electronics,
    especially as learn more about electronic actuators and sensors in part 3 of this
    book, *IoT Playground*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将重点关注使用Python和Flask-RESTful框架控制LED的RESTful API以及其实现方式。完成本节后，您将能够将这个RESTful
    API服务器作为自己物联网项目的起点，并将其与其他电子设备集成，特别是在本书第3部分*物联网游乐场*中学习更多关于电子执行器和传感器的知识。
- en: For the examples in this chapter, we will assume you are working and accessing
    the Flask-based servers locally on your Raspberry Pi. These servers will also
    be accessible from another device on your local network if you use the IP address
    or hostname of your Raspberry Pi. To make the servers directly accessible over
    the internet would require configuration of your specific firewall and/or router,
    which we cannot practically cover in this book. For prototyping ideas and creating
    demos, a simple alternative to configuring firewalls and routers is to use a service
    such as Local Tunnels ([https://localtunnel.github.io/www](https://localtunnel.github.io/www))
    or Ngrok ([https://ngrok.com](https://ngrok.com)), which will help you to make
    the Flask servers on your Raspberry Pi accessible over the internet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们假设您正在树莓派上本地工作和访问基于Flask的服务器。如果使用树莓派的IP地址或主机名，这些服务器也可以从本地网络上的其他设备访问。要使服务器直接通过互联网访问，需要配置特定防火墙和/或路由器，这在本书中实际上是不可行的。对于原型设计和创建演示，一个简单的替代方法是使用Local
    Tunnels ([https://localtunnel.github.io/www](https://localtunnel.github.io/www))或Ngrok
    ([https://ngrok.com](https://ngrok.com))等服务，这将帮助您使树莓派上的Flask服务器可以通过互联网访问。
- en: We will start by running and using our RESTful API to interact with the LED
    before proceeding to review the server's source code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先运行和使用我们的RESTful API与LED进行交互，然后再审查服务器的源代码。
- en: Running and testing the Python server
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试Python服务器
- en: You will find the code in the `chapter03/flask_api_server.py` file. Please review
    this file before proceeding to get an overall idea about what it contains before
    you proceed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`chapter03/flask_api_server.py`文件中找到代码。在继续之前，请先查看此文件，以了解其包含的内容。
- en: We are running our Flask examples using Flask's built-in HTTP server. This is
    more than adequate for development purposes; however, it's not recommended for
    production usage. Consult the Flask documentation section titled *Deployment Options*
    for information on how to deploy a Flask application with production-quality web
    servers. You'll find a link in the *Further reading* section to the official Flask
    website and documentation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Flask内置的HTTP服务器运行我们的Flask示例。这对于开发目的已经足够了；但是，不建议在生产中使用。请参阅Flask文档中的*部署选项*部分，了解如何使用质量良好的Web服务器部署Flask应用程序的信息。您将在*进一步阅读*部分找到指向官方Flask网站和文档的链接。
- en: 'To test the Python server perform the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试Python服务器，请执行以下步骤：
- en: 'Run our RESTful API server with the following command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行我们的RESTful API服务器：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second to last line in the preceding code block indicates that our server
    has started successfully. Our server is running in debug mode by default, so its
    log output will be verbose and if you make any changes to `flask_api_server.py`
    or other resource files, the server will restart automatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码块中倒数第二行表示我们的服务器已成功启动。我们的服务器默认以调试模式运行，因此其日志输出将是冗长的，如果您对`flask_api_server.py`或其他资源文件进行任何更改，服务器将自动重新启动。
- en: 'If `flask_api_server.py` raises an error when started in debug mode, clear
    the file''s execute bit. This issue occurs on Unix-based systems and has to do
    with the development web server shipped with Flask. Here is the command to clear
    the execute bit:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以调试模式启动`flask_api_server.py`时出现错误，请清除文件的执行位。这个问题发生在基于Unix的系统上，与Flask附带的开发Web服务器有关。以下是清除执行位的命令：
- en: '`$ chmod -x flask_api_server.py`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ chmod -x flask_api_server.py`'
- en: We will create a web page to interact without API shortly; however, for now,
    browse to `http://localhost:5000` in a web browser and verify that you can use
    the slider on the web page to change the brightness of the LED.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将很快创建一个网页来与API进行交互；但是，现在，请在Web浏览器中浏览到`http://localhost:5000`，并验证您是否可以使用网页上的滑块来更改LED的亮度。
- en: Our example URL is `http://localhost:5000`, however, if you use your Raspberry
    Pi's IP address instead of `localhost`, you will be able to access the web page
    from another device on your local network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例URL是`http://localhost:5000`，但是，如果您使用树莓派的IP地址而不是`localhost`，您将能够从本地网络上的其他设备访问该网页。
- en: 'The following screenshot is an example of the web page you will see:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是您将看到的网页的示例：
- en: '![](assets/85cbd2b2-6946-4b27-af76-cf53623950e7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85cbd2b2-6946-4b27-af76-cf53623950e7.png)'
- en: Figure 3.1 – RESTful API client web page
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - RESTful API客户端网页
- en: We can also use the `curl` command-line tool to interact with the API. We will
    do this now to observe the input and output JSON from our API server requests.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`curl`命令行工具与API进行交互。我们现在将这样做，以观察API服务器请求的输入和输出JSON。
- en: 'Our first `curl` command in the following makes an HTTP GET request and we
    see the LED''s brightness level (a number between 0 and 100) printed on the Terminal
    in JSON (line 1). The default LED brightness when the server is started is 50
    (that is, 50% brightness):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的第一个`curl`命令，它发出HTTP GET请求，我们在终端中以JSON格式打印LED的亮度级别（在0到100之间的数字）（第1行）。服务器启动时的默认LED亮度为50（即50%亮度）：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The options for `curl` are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`的选项如下：'
- en: '`-X GET`: The HTTP method used to make the request'
  id: totrans-58
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-X GET`：用于发出请求的HTTP方法'
- en: '**<url>**:The URL to request'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<url>**：要请求的URL'
- en: 'This next command performs an HTTP POST request, and we are setting the brightness
    level to its maximum of 100 (line 2), which is returned as JSON and printed back
    to the Terminal (line 3):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个命令执行HTTP POST请求，并将亮度级别设置为最大值100（第2行），然后将其作为JSON返回并打印回终端（第3行）：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The options for `curl` are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`的选项如下：'
- en: '`-X POST`: This is the HTTP method; this time, we''re making a POST request.'
  id: totrans-63
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-X POST`：这是HTTP方法；这次我们正在发出POST请求。'
- en: '`-d` **<data>**: This is the data we want to POST to the server. We''re posting
    a JSON string.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` **<data>**：这是我们要POST到服务器的数据。我们正在发布一个JSON字符串。'
- en: '`-H` **<HTTP headers>**: These are the HTTP headers to send with the request.
    Here, we''re letting the server know that our data, `(-d)`, is JSON.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H` **<HTTP headers>**：这些是要与请求一起发送的HTTP标头。在这里，我们让服务器知道我们的数据`(-d)`是JSON。'
- en: '**<url>**:This is the URL to request.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<url>**：这是要请求的URL。'
- en: An alternative to `curl` on the command line is Postman ([getpostman.com](http://getpostman.com)).
    If you are not familiar with Postman, it's a free API development, querying, and
    testing tool that is invaluable when you are developing and testing RESTful API
    services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上`curl`的替代方案是Postman（[getpostman.com](http://getpostman.com)）。如果您不熟悉Postman，它是一个免费的API开发、查询和测试工具，在您开发和测试RESTful
    API服务时非常有价值。
- en: Try altering the level value in the preceding `curl POST` example to a number
    outside of the range 0-100 and observe the error message you receive. We will
    see shortly how this validation logic is implemented with Flask-RESTful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改前面`curl POST`示例中的级别值为超出0-100范围的数字，并观察您收到的错误消息。我们很快将看到如何使用Flask-RESTful实现此验证逻辑。
- en: Let's now proceed to look at our server source code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续查看我们的服务器源代码。
- en: Understanding the server code
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解服务器代码
- en: In this section, we will walk through our RESTful API server's source code and
    discuss the core parts to help you to understand how the server is coded and operates.
    Please keep in mind that we're about to cover many code-level artifacts that are
    specific to the Flask and Flask-RESTful frameworks, so don't get worried if, at
    first, some concepts do not make immediate sense.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将浏览我们的RESTful API服务器的源代码，并讨论核心部分，以帮助您了解服务器的编码和操作方式。请记住，我们将要涵盖许多特定于Flask和Flask-RESTful框架的代码级工件，所以如果一开始有些概念不太明确，不要担心。
- en: Once you have an understanding of the foundations and an overall idea of how
    our sever works, you'll be in an excellent position to deepen your understanding
    of Flask and Flask-RESTful by consulting their respective websites (you will find
    links in the *Further reading* section). Furthermore, you will have a solid reference
    RESTful API server that you can rework and use as a starting point for your own
    future projects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了基础知识，并对我们的服务器如何工作有了整体的概念，您将能够通过查阅它们各自的网站（您将在*进一步阅读*部分找到链接）深入了解Flask和Flask-RESTful。此外，您将拥有一个可靠的参考RESTful
    API服务器，可以重新设计并用作将来项目的起点。
- en: Please note that as we discuss the code, we will skip over any code and concepts
    that we covered in earlier chapters, such as **GPIOZero**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们讨论代码时，我们将跳过我们在早期章节中涵盖的任何代码和概念，比如**GPIOZero**。
- en: We will start by looking at the imports.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入开始。
- en: '**Imports**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'At the top of the source code file, we see the following imports:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码文件的顶部，我们看到以下导入：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Flask-related imports we see on lines (1) and (2) are all of the classes
    and functions of Flask and Flask-RESTful that we will require in our server. You
    will notice on line (3), we're importing `PWMLED` not `LED` as we have done in
    previous chapters. In this example, we're going to change the brightness of our
    LED rather than just turning it on and off. We'll cover more about PWM and  `PWMLED` as
    we proceed with this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第（1）和（2）行看到的与Flask和Flask-RESTful相关的导入都是我们在服务器中需要的Flask和Flask-RESTful的所有类和函数。您会注意到在第（3）行，我们导入的是`PWMLED`而不是我们在之前章节中所做的`LED`。在这个例子中，我们将改变LED的亮度而不仅仅是打开和关闭它。随着我们继续本章，我们将更多地涵盖PWM和`PWMLED`。
- en: Next, in our source code, we start to work with Flask and the Flask-RESTful
    extension.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的源代码中，我们开始使用Flask和Flask-RESTful扩展。
- en: '**Flask and Flask-RESTful API instance variables**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flask和Flask-RESTful API实例变量
- en: 'In the following, on line (4), we create an instance of our core Flask app
    and assign it to the `app` variable. The parameter is the name of our Flask application,
    and it''s a common convention to use `__name__` for the *root* Flask app (we only
    have a root Flask app in our example). Anytime we need to work with the core Flask
    framework, we will use the `app` variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的第4行，我们创建了核心Flask应用的一个实例，并将其分配给`app`变量。参数是我们的Flask应用的名称，使用`__name__`作为*root*
    Flask应用的常见约定（在我们的示例中只有一个root Flask应用）。每当我们需要使用核心Flask框架时，我们将使用`app`变量：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On line (5), we wrap the core Flask app with the Flask-RESTful extension and
    assign it to the `api` variable, and as we will see shortly, we use this variable
    anytime we are working with the Flask-RESTful extension. Following our `app` and
    `api` variables, we define additional global variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（5）行，我们用Flask-RESTful扩展包装核心Flask应用，并将其分配给`api`变量，正如我们很快将看到的，我们在使用Flask-RESTful扩展时会使用这个变量。在我们的`app`和`api`变量之后，我们定义了额外的全局变量。
- en: '**Global variables**'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'The following global variables are used throughout our server. First, we have
    the GPIO pin and an `led` variable, which will later be assigned a GPIOZero `PWMLED`
    instance for controlling our LED:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下全局变量在整个服务器中使用。首先，我们有GPIO引脚和一个`led`变量，稍后将为其分配一个GPIOZero `PWMLED`实例以控制我们的LED：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On line (6), we have a `state` dictionary structure that we will use to track
    the brightness level of our LED. We could have used a simple variable instead
    but have opted for a dictionary structure since it's a more versatile option because
    it will be marshaled into JSON to send back to a client, as we will see later
    on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（6）行，我们有一个`state`字典结构，我们将使用它来跟踪LED的亮度级别。我们本可以使用一个简单的变量，但选择了字典结构，因为它是一个更多功能的选项，因为它将被编组成JSON发送回客户端，我们稍后会看到。
- en: Next, we create and initialize our `led` instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建并初始化了我们的`led`实例。
- en: '**The init_led() method**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init_led()方法
- en: 'The `init_led()` method simply creates a GPIOZero `PWMLED` instance and assigns
    it to the global `led` variable that we saw previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_led()`方法只是创建一个GPIOZero `PWMLED`实例并将其分配给我们之前看到的全局`led`变量：'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We explicitly set the LED's brightness to match the value of our server's brightness state
    on line (7) to ensure the server's managed state and the LED are in sync when
    the server starts. We are dividing by 100 because `led.value` expects a float
    value in the range of 0-1, while our API will be using an integer in the range
    0-100.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（7）行，我们明确将LED的亮度设置为与服务器亮度状态的值匹配，以确保服务器的管理状态和LED在服务器启动时同步。我们除以100是因为`led.value`期望在0-1范围内的浮点值，而我们的API将使用0-100范围内的整数。
- en: Next, we start to see the code that defines our server and its service endpoints,
    starting with the code that serves the web page we visited earlier.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始看到定义我们的服务器及其服务端点的代码，从提供我们之前访问的网页的代码开始。
- en: '**Serving a web page**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供网页
- en: 'Starting on line (8), we use the Flask  `@app.route()` decorator to define
    a callback method that is invoked when the server receives an HTTP GET request
    from a client to the root URL `/`, that is, a request to `http://localhost:5000`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从第（8）行开始，我们使用Flask `@app.route()`装饰器来定义一个回调方法，当服务器从客户端接收到对根URL `/`的HTTP GET请求时，即对`http://localhost:5000`的请求时，将调用该方法：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On line (9), `render_template('index_api_client.html', pin=LED_GPIO_PIN)` is
    a Flask method use to return a templated page to the requesting client. The `pin=LED_GPIO_PIN`
    parameter is an example of how to pass a variable from Python to the HTML page
    template for rendering. We will cover the contents of this HTML file later in
    this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（9）行，`render_template('index_api_client.html', pin=LED_GPIO_PIN)`是一个Flask方法，用于向请求的客户端返回一个模板化的页面。`pin=LED_GPIO_PIN`参数是如何将一个变量从Python传递到HTML页面模板以进行渲染的示例。我们将在本章后面介绍这个HTML文件的内容。
- en: Notice, in the preceding code block on line (8), we have `@app.route(...)`.
    The presence of the `app` variable means we are using and configuring the *core*
    Flask framework here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第（8）行的前面代码块中，我们有`@app.route(...)`。`app`变量的存在意味着我们在这里使用和配置*核心*Flask框架。
- en: Returning an HTML page to the client is the only core Flask feature that we
    will cover in this book, however, there will be additional resources listed in
    the *Further reading* section for you to explore the core concepts of Flask further.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向客户端返回HTML页面是我们将在本书中涵盖的唯一核心Flask功能，但是在*进一步阅读*部分中将列出其他资源，供您进一步探索Flask的核心概念。
- en: Our next stop in code is the `LEDController` class. It's here that we are interacting
    with the LED and GPIOZero.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的下一个停靠点是`LEDController`类。在这里，我们正在与LED和GPIOZero进行交互。
- en: '**The LEDControl class**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LEDControl类
- en: 'In Flask-RESTful, API resources are modeled as Python classes that extend the `Resource` class,
    and on line (10) in the following snippet, we see the `LEDControl(Resource)` class defined
    that will contain the logic used to control our LED. Later on, we will see how
    we register this class with Flask-RESTful so that it responds to client requests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask-RESTful中，API资源被建模为扩展`Resource`类的Python类，如下片段的第（10）行中所示，我们看到了定义的`LEDControl(Resource)`类，其中包含了用于控制我们的LED的逻辑。稍后，我们将看到如何注册这个类到Flask-RESTful，以便它响应客户端请求：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On line (11), we create an instance of `RequestParser()` and assign it to the
    `args_parser` variable before configuring the parser with `add_argument()`. We
    use an instance of `RequestParser()` in Flask-RESTful to define validation rules
    for the arguments we expect our `LEDControl` resource to handle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（11）行，我们创建了`RequestParser()`的一个实例，并将其分配给`args_parser`变量，然后使用`add_argument()`配置解析器。我们在Flask-RESTful中使用`RequestParser()`的实例来定义我们期望`LEDControl`资源处理的参数的验证规则。
- en: Here, we are defining a mandatory parameter named `level`, which must be an
    integer in the range 0 to 100, as shown on line (12). We've also provided a custom
    help message for when the `level` parameter is missing or out of range.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`level`的必需参数，它必须是0到100范围内的整数，如第（12）行所示。当`level`参数缺失或超出范围时，我们还提供了一个自定义的帮助消息。
- en: We will see the use of `args_parser` when we cover the `post()` method shortly,
    but first, let's discuss the `get()` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论`post()`方法时看到`args_parser`的使用，但首先让我们讨论`get()`方法。
- en: '**The get() class method**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**get()类方法**'
- en: 'The `get()` class method handles HTTP GET requests for our `LEDControl` resource.
    It''s what handled our URL request when we tested the API previously with the
    following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`类方法处理我们的`LEDControl`资源的HTTP GET请求。这是我们之前使用以下命令测试API时处理我们的URL请求的方法：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`get()` simply returns, on line (13), the global `state` variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`只是简单地在第（13）行返回全局`state`变量：'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Flask-RESTful returns JSON responses to clients, and that''s why we return
    the `state` variable. In Python, `state` is a dictionary structure that can be
    mapped directly into a JSON format. We saw the following JSON example previously
    when we make a GET request using `curl`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful将JSON响应返回给客户端，这就是为什么我们返回`state`变量。在Python中，`state`是一个可以直接映射到JSON格式的字典结构。我们之前在使用`curl`进行GET请求时看到了以下JSON示例：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class-as-a-resource (for example, `LEDControl`) and method-to-HTTP-method
    mapping (for example, `LEDControl.get()`) is an example of how the Flask-RESTful
    extension makes RESTful API development easy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类作为资源（例如`LEDControl`）和方法到HTTP方法的映射（例如`LEDControl.get()`）是Flask-RESTful扩展如何使RESTful
    API开发变得简单的一个例子。
- en: There are also method names reserved for other HTTP request methods, including
    POST, which we cover next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他HTTP请求方法保留的方法名称，包括我们接下来要讨论的POST。
- en: '**The post() class method**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**post()类方法**'
- en: 'The `post()` class method handles HTTP POST requests made to the `LEDControl`
    resource. It is this `post()` method that received and processed our `curl POST`
    request when we made the following request earlier when we tested our server:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`post()`类方法处理发送到`LEDControl`资源的HTTP POST请求。正是这个`post()`方法接收并处理了我们之前使用`curl
    POST`请求时所做的请求：'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`post()` is more complex than our `get()` method. It is here where we change
    the brightness of our LED in response to a requesting client''s input:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`post()`比我们的`get()`方法更复杂。这是我们根据请求客户端的输入更改LED亮度的地方：'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On line (14), we use the Python `global` keyword to indicate that we will be
    altering the `state` global variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（14）行，我们使用Python的`global`关键字表示我们将修改`state`全局变量。
- en: On line (15), we see the use of `args_parser` that we discussed previously.
    It's this call to `args_parser.parse_args()` that will parse and validate the
    caller's input (remember `level` was a required argument and it must be in the
    range 0-100). If our predefined validation rules fail, the user will be issued
    with an error message, and `post()` will terminate here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（15）行，我们看到了我们之前讨论过的`args_parser`的使用。这是对`args_parser.parse_args()`的调用，它将解析和验证调用者的输入（记住`level`是一个必需参数，必须在0-100的范围内）。如果我们预定义的验证规则失败，用户将收到一个错误消息，并且`post()`将在此终止。
- en: If the arguments are valid, their values are stored in the `args` variable,
    and the code continues to line (16) where we update the global `state` variable
    with the newly requested brightness level. On line (17), we alter the physical
    LED's brightness using the GPIOZero PWMLED instance, `led`, which expects a value
    between 0.0 (off) and 1.0 (full brightness), so we're mapping our `level` input
    range of 0-100 back to 0-1\. The value of `state` is returned to the client on
    line (18).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数有效，它们的值将存储在`args`变量中，并且代码将继续到第（16）行，我们在那里使用新请求的亮度级别更新全局`state`变量。在第（17）行，我们使用GPIOZero
    PWMLED实例`led`来改变物理LED的亮度，该实例期望一个值在0.0（关闭）和1.0（全亮）之间，因此我们将0-100的`level`输入范围映射回0-1。`state`的值在第（18）行返回给客户端。
- en: Our final task is to register `LEDController` with Flask-RESTful and start the
    server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后任务是将`LEDController`注册到Flask-RESTful并启动服务器。
- en: '**LEDController registration and starting the server**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**LEDController注册和启动服务器**'
- en: After calling the `init_led()` method to initiate and default out GPIOZero `led`
    instance, we then see how to register our `LEDControl` resource with `api.add_resource()` on
    line (19).  Here, we are mapping the URL endpoint, `/led`, with our controller.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`init_led()`方法来初始化和默认输出GPIOZero `led`实例之后，我们看到了如何在第（19）行使用`api.add_resource()`注册我们的`LEDControl`资源。在这里，我们将URL端点`/led`与我们的控制器进行了映射。
- en: Notice, in the code block on line (19), we have `api.add_resource(...)`. The
    presence of the `api` variable means we are using and configuring the *Flask-RESTful
    extension* here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第（19）行的代码块中，我们有`api.add_resource(...)`。`api`变量的存在意味着我们在这里使用和配置*Flask-RESTful扩展*。
- en: 'Finally, on line (20), our server is started (in debug mode) and is ready to
    receive client requests. Notice that we use the *core* Flask instance in the `app` variable
    to start the server:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第20行，我们的服务器已经启动（调试模式），准备接收客户端请求。请注意，我们使用`app`变量中的*core* Flask实例来启动服务器：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Well done! We've just covered the build of a simple, yet, functional RESTful
    API server in Python. You'll find links in the *Further reading* section to the
    official Flask-RESTful documentation so you can take your knowledge further.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们刚刚在Python中完成了一个简单但功能齐全的RESTful API服务器的构建。您将在*进一步阅读*部分找到官方Flask-RESTful文档的链接，以便进一步扩展您的知识。
- en: As mentioned, we've used `PWMLED` in our server. Let's briefly introduce the
    term *PWM* before we proceed and review the web page that accompanies our RESTful
    API server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在服务器中使用了`PWMLED`。在继续之前，让我们简要介绍一下*PWM*这个术语，并回顾一下伴随我们的RESTful API服务器的网页。
- en: '**Introduction to PWM**'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**PWM简介**'
- en: In the proceeding example, we used `PWMLED`, not `LED`, from GPIOZero. `PWMLED` allows
    us to control the brightness of the LED using a technique known as **Pulse Width
    Modulation**, commonly abbreviated as **PWM***.*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了GPIOZero中的`PWMLED`，而不是`LED`。`PWMLED`允许我们使用一种称为**脉冲宽度调制**的技术来控制LED的亮度，通常缩写为**PWM**。
- en: PWM is a technique used to create a lower the average voltage from a source
    signal, which can be a 3.3-volt GPIO pin. We will be covering PWM and GPIO pin
    voltages in detail in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: PWM是一种用于从源信号（可以是3.3伏特的GPIO引脚）中创建平均电压的技术。我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中详细介绍PWM和GPIO引脚电压，*软件工程师的电子学101*。
- en: For our current example, briefly (and somewhat oversimplified), PWM pulses the
    LED on and off really, really fast, and our eyes observe different pulse durations
    (that are creating different voltages) manifesting as different brightness levels
    of the LED. We changed this pulse duration (known as the *duty-cycle*) using the
    `value` property of a `PWMLED` instance, that is, `led.value = state["level"]` in
    `LEDControl.post()`. In [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*, we will explore PWM in greater detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前的示例，简而言之（有些过于简化），PWM以非常快的速度打开和关闭LED，我们的眼睛观察到不同的脉冲持续时间（产生不同的电压），表现为LED的不同亮度级别。我们使用`PWMLED`实例的`value`属性来改变这个脉冲持续时间（称为*duty-cycle*），即在`LEDControl.post()`中的`led.value
    = state["level"]`。在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中，*将您的树莓派连接到物理世界*，我们将更详细地探讨PWM。
- en: We've now covered our Python-based Flask-RESTful API server and learned how
    to implement a simple and functional RESTful API server that is capable of handling
    both GET and POST requests, the two most popular ways of interacting with RESTful
    API servers. Plus, we also saw how to achieve data validation with Flask-RESTful
    as a simple and effective way to guard our server against invalid input data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了基于Python的Flask-RESTful API服务器，并学会了如何实现一个简单而功能齐全的RESTful API服务器，能够处理GET和POST请求，这是与RESTful
    API服务器交互的两种最流行的方式。此外，我们还看到了如何使用Flask-RESTful实现数据验证，这是一种简单有效的方式，可以保护我们的服务器免受无效输入数据的影响。
- en: We also learned to use the `curl` command-line tool to interact with and test
    our server. As you build, test, and debug RESTful API servers, you will find `curl` a
    useful addition to your development toolkit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了使用`curl`命令行工具与测试我们的服务器进行交互。在构建、测试和调试RESTful API服务器时，您会发现`curl`是开发工具包中的一个有用补充。
- en: Next, we will take a look at the code behind the web page that interacts with
    our API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下与我们的API交互的网页背后的代码。
- en: Adding a RESTful API client web page
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加RESTful API客户端网页
- en: The web page we are about to discuss is the one you interacted with previously
    to change the brightness of your LED when you visited `http://localhost:5000` in
    your web browser. A screenshot of the web page is shown in *Figure 3.1*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的网页是您之前与之交互以改变LED亮度的网页，当您在Web浏览器中访问`http://localhost:5000`时。网页的截图显示在*图3.1*中。
- en: As we proceed through this section, we will be learning how to build this basic
    web page using HTML and JavaScript. We will discover how to make the HTML range
    component interact with the Flask-RESTful API server that we created in the previous
    section, so that when we change the range control (that is, slide the slider), our
    LED's brightness also changes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用HTML和JavaScript构建这个基本网页。我们将发现如何使HTML范围组件与我们在上一节中创建的Flask-RESTful
    API服务器进行交互，以便当我们改变范围控件（即滑动滑块）时，我们LED的亮度也会改变。
- en: You will find the page's code in the `chapter03/templates/index_api_client.html` file. Please
    review this file before proceeding to get an overall idea about what it contains.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`chapter03/templates/index_api_client.html`文件中找到网页的代码。在继续之前，请先查看此文件，以了解其包含的内容。
- en: The `templates` folder is a special Flask folder where template files are kept.
    An HTML page is considered a template in the Flask ecosystem. You will also find
    a folder named `static`. This folder is where static files are stored. For our
    example, this is where a copy of the jQuery JavaScript library file is found.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`templates`文件夹是Flask中的一个特殊文件夹，用于存放模板文件。在Flask生态系统中，HTML页面被视为模板。您还会发现一个名为`static`的文件夹。这个文件夹是用来存放静态文件的地方。对于我们的示例，这是jQuery
    JavaScript库文件的副本所在的地方。'
- en: All files and resources referenced in a web page served from Flask are relative
    to the server's root folder. For us, this is the `chapter03` folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flask提供的网页中引用的所有文件和资源都是相对于服务器的根文件夹的。对于我们来说，这是`chapter03`文件夹。
- en: Let's walk through the web page code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍网页代码。
- en: Understanding the client-side code
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解客户端代码
- en: This section's code is JavaScript, and we will be using the jQuery JavaScript
    library. An understanding of basic JavaScript and jQuery will be essential to
    understanding the code examples that follow. If you are not familiar with jQuery,
    you can find learning resources at jQuery.com.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码是JavaScript，并且我们将使用jQuery JavaScript库。了解基本的JavaScript和jQuery对于理解接下来的代码示例至关重要。如果您不熟悉jQuery，可以在jQuery.com找到学习资源。
- en: '**JavaScript imports**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JavaScript导入**'
- en: 'We see in the following, on line (1), that we import the jQuery library that
    is contained in the `static` folder:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面看到，第1行导入了包含在`static`文件夹中的jQuery库：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we will start to cover the JavaScript functions in the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始介绍文件中的JavaScript函数。
- en: '**The getState() function**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**getState()函数**'
- en: 'The primary purpose of `getState()` is to retrieve the LED''s current state
    from the server. It uses the JQuery `get()` method to make an HTTP GET request
    to our API server''s `/led` resource. We saw, in the previous section, that the
    URL path, `/led`, is mapped to the `LEDControl` Python class, and because we''re
    making a GET request, it''s `LEDControl.get()` that will receive and handle our
    request:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`getState()`的主要目的是从服务器检索LED的当前状态。它使用JQuery的`get()`方法向我们的API服务器的`/led`资源发出HTTP
    GET请求。我们在上一节中看到，URL路径`/led`映射到`LEDControl`Python类，因为我们正在进行GET请求，所以`LEDControl.get()`将接收和处理我们的请求：'
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The server's response is contained in the `serverResponse` parameter on line
    (2), which is passed to the `updateControls()` function on line (3) to update
    the web page controls. We'll cover this method shortly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应包含在第2行的`serverResponse`参数中，它传递给第3行的`updateControls()`函数以更新网页控件。我们将很快介绍这个方法。
- en: While `getState()` gets data from our Python server, our next method, `postUpdate()`,
    sends (that is, *posts)* data to the server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`getState()`从我们的Python服务器获取数据，但我们的下一个方法`postUpdate()`发送（即*发布）数据到服务器。
- en: '**The postUpdate() function**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**postUpdate()函数**'
- en: '`postUpdate()` changes the LED''s brightness by performing an HTTP POST to
    the server. This time, it''s the `LEDControl.post()` method in our API server
    that handled the request:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`postUpdate()`通过执行HTTP POST到服务器来改变LED的亮度。这次，在我们的API服务器中处理请求的是`LEDControl.post()`方法：'
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On line (4), it receives and parses (remember `arg_parser` from `LEDControl`)
    the data in the `payload` parameter. `payload` is a JavaScript object with a `state` child
    property. We'll see this object constructed later in the web page slider's change
    event handler.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，它接收并解析（记住`arg_parser`来自`LEDControl`）`payload`参数中的数据。`payload`是一个具有`state`子属性的JavaScript对象。我们将在稍后看到这个对象是如何在网页滑块的change事件处理程序中构造的。
- en: For consistency, we also update the controls on line (5) even though, in our
    case, the `serverResponse` variable will contain the same level value as the `payload` parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致，即使在我们的情况下，`serverResponse`变量将包含与`payload`参数相同的级别值，我们也会更新第5行的控件。
- en: Next, we will see what the call to `updateControls()` on line (5) does.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到第5行对`updateControls()`的调用做了什么。
- en: '**The updateControls() function**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**updateControls()函数**'
- en: '`updateControls()` changes the visual appearance of the web page controls.
    This function receives JSON input as the `data` parameter, which is in the form: `{"level":50}`.
    Starting on line (6) and using jQuery selectors, we update the slider control
    and text on the web page to reflect the new level value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateControls()`改变了网页控件的视觉外观。这个函数接收JSON输入作为`data`参数，格式为`{"level":50}`。从第6行开始，使用jQuery选择器，我们更新了网页上的滑块控件和文本，以反映新的级别值：'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we'll see how we use JQuery to create an event handler that responds when
    we or another user changes to the web page's slider component.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用JQuery创建一个事件处理程序，当我们或另一个用户更改网页的滑块组件时，它会做出响应。
- en: '**Registering event handlers with jQuery**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用jQuery注册事件处理程序**'
- en: 'We are following jQuery best practice and using the jQuery *document ready
    function* (that is, `$(document).ready(...)`) to register the event handlers for
    our web page''s slider control and initialize our web page elements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循jQuery最佳实践，并使用jQuery的*文档就绪函数*（即`$(document).ready(...)`）来注册我们网页的滑块控件的事件处理程序并初始化我们的网页元素：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On line (7), we register an event handler for the slider controls *input* event.
    This handler function will be called when a user interacts with the slider on
    the web page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，我们为滑块控件注册了一个*input*事件的事件处理程序。当用户与网页上的滑块交互时，将调用此处理程序函数。
- en: Starting on line (8), after a user moves the slider, we extract the slider's
    new value of the slider using `val()` (which will be between 0 and 100—we'll see
    why shortly when we review the page's HTML).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从第8行开始，用户移动滑块后，我们使用`val()`提取滑块的新值（在0到100之间，我们稍后会在查看页面的HTML时看到原因）。
- en: On line (9), we create a JSON object containing our new brightness level before
    passing it to `postUpdate()`, which calls our RESTful API to change the brightness
    of our physical LED.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9行，我们创建一个包含我们新亮度级别的JSON对象，然后将其传递给`postUpdate()`，该函数调用我们的RESTful API来改变物理LED的亮度。
- en: Finally, on line (10), we call our `getState()` function, which makes an HTTP
    request to our server to get the current brightness level for the LED. As we saw
    previously, `getState()` then delegates to `updateControls()`, which then updates
    the slider and page text to reflect the LED's brightness value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第10行，我们调用我们的`getState()`函数，它向服务器发出HTTP请求，以获取LED的当前亮度级别。正如我们之前看到的，`getState()`然后委托给`updateControls()`，然后更新滑块和页面文本以反映LED的亮度值。
- en: We'll conclude this section by looking at the HTML that makes up the web page.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看组成网页的HTML来结束本节。
- en: '**The web page HTML**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网页HTML**'
- en: 'Previously in our Python server, we had the line `render_template(''index_rest_api.html'',
    pin=LED_GPIO_PIN)`. It''s the `pin` parameter in this method call that is rendered
    on our web page on line (11), represented by the template variable, `{{pin}}`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python服务器中，我们之前有一行`render_template('index_rest_api.html', pin=LED_GPIO_PIN)`。在这个方法调用中，`pin`参数在第11行呈现在我们的网页上，由模板变量`{{pin}}`表示：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we see, on line (12), our HTML slider component is restricted to the
    range of 0-100\. As we saw previously, it's the call to `getState()` in the document
    ready handler that updates the slider's value attribute to match the brightness
    level stored on the server after the web page has finished loading.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到，在第12行，我们的HTML滑块组件被限制在0-100的范围内。正如我们之前看到的，是在文档准备好的处理程序中对`getState()`的调用更新了滑块的值属性，以匹配网页加载完成后服务器上存储的亮度级别。
- en: Congratulations! We've reached a milestone now, having completed a full end-to-end
    server and client example based on RESTful APIs. Our learning about Flask and
    Flask-RESTful means we have learned to use one of the most popular and feature-rich Python libraries
    for building web services. Plus, learning to build a RESTful API server and matching
    client means we have practically implemented the most common approach used today
    for client-server communication.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在已经达到了一个里程碑，完成了一个基于RESTful API的完整端到端服务器和客户端示例。我们对Flask和Flask-RESTful的学习意味着我们已经学会了使用最受欢迎和功能丰富的Python库之一来构建Web服务。此外，学习构建RESTful
    API服务器和匹配的客户端意味着我们已经实际实现了当今用于客户端-服务器通信的最常见方法。
- en: We have barely scratched the surface of what can be achieved with Flask, Flask-RESTful,
    and RESTful APIs in general, and there is much more that can be explored. You'll
    find links in the *Further reading* section if you wish to take your understanding
    of these topics further.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了Flask、Flask-RESTful和RESTful API的一小部分，还有很多可以探索的内容。如果你希望进一步了解这些主题，你会在*进一步阅读*部分找到链接。
- en: Next, we will create the same client and server scenario we built in this section,
    only this time using Web Sockets as our transport layer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建与本节中构建的相同的客户端和服务器场景，只是这一次使用Web套接字作为我们的传输层。
- en: Creating a Web Socket service with Flask-SocketIO
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask-SocketIO创建Web套接字服务
- en: We will now implement our second Python-based server. Our overall outcome in
    this section will be similar to our RESTful API server and client that we created
    in the previous section—that is, we will be able to control our LED from a web
    browser. Our objective this time around, however, will be to create our program
    using a different technological approach using Web Sockets as our transport layer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现我们的第二个基于Python的服务器。在本节中，我们的总体目标与上一节中创建的RESTful API服务器和客户端类似，也就是说，我们将能够从Web浏览器控制我们的LED。然而，这一次我们的目标是使用不同的技术方法，使用Web套接字作为我们的传输层。
- en: Web Sockets are a full-duplex communication protocol and are a common technology
    choice where real-time client/server interaction is required. Web Sockets are
    a technology that—in my opinion and experience—is best learned through doing rather
    than reading, especially if you are new to server development. A deep discussion
    of Web Sockets is beyond the scope of this chapter; however, you'll find two links
    in the *Further reading* section covering the basics.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Web套接字是一种全双工通信协议，是实时客户端/服务器交互所需的常见技术选择。在我看来和经验中，Web套接字最好通过实践而不是阅读来学习，特别是如果你是新手服务器开发者。对Web套接字的深入讨论超出了本章的范围；但是，在*进一步阅读*部分，你会找到两个链接，涵盖了基础知识。
- en: If you are new to Web Sockets, I highly recommend reading those two resources
    as a primer before proceeding. And don't worry if the content does not sink in
    initially because I'm confident that, once you have used and understood how our
    Python Web Socket server and the accompanying Web Socket-enabled web page is implemented,
    the pieces of the larger Web Socket puzzle will start to come together.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Web套接字的新手，我强烈建议在继续之前阅读这两个资源作为入门。如果内容一开始没有理解，不要担心，因为我相信一旦你使用并理解了我们的Python
    Web套接字服务器和配套的Web套接字启用的网页是如何实现的，更大的Web套接字拼图的各个部分将开始串联起来。
- en: For our Web Socket sever build, we will use the Flask-SocketIO library, which
    is modeled after and compatible with the popular Socket.IO library for JavaScript
    ([https://socket.io](https://socket.io)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Web套接字服务器构建，我们将使用Flask-SocketIO库，该库是基于并兼容流行的JavaScript库Socket.IO ([https://socket.io](https://socket.io))。
- en: We will start by running and using our Web Socket server to interact with the
    LED before proceeding to review the server's source code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先运行和使用我们的Web套接字服务器与LED进行交互，然后再审查服务器的源代码。
- en: Running and testing the Python server
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和测试Python服务器
- en: Let's start by having a quick look at our Python Web Socket server code and
    running the server to see it in operation. This will give us a broad idea of the
    code and a first-hand demonstration of how the code works before we discuss it
    in detail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先快速查看一下我们的Python Web套接字服务器代码，并运行服务器以查看其运行情况。在我们详细讨论之前，这将给我们一个对代码的大致了解和对代码工作原理的第一手演示。
- en: You will find the Web Socket server's code in the `chapter03/flask_ws_server.py` file.
    Please review this file before proceeding.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在`chapter03/flask_ws_server.py`文件中找到Web套接字服务器的代码。请在继续之前查看这个文件。
- en: 'When you have looked through the code, we will run our server. Here are the
    steps to follow:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看了代码后，我们将运行我们的服务器。以下是要遵循的步骤：
- en: 'Run the Web Socket server with the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Web套接字服务器：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding output is similar to what we saw when we ran the RESTful API server;
    however, you can expect more output messages on your Terminal for this server.
    The additional output you will see has been truncated from the preceding example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出与我们运行RESTful API服务器时看到的类似；但是，对于这个服务器，你可以在终端上期望看到更多的输出消息。你将看到的额外输出已经从前面的示例中截断。
- en: 'If `flask_ws_server.py` raises an error when started in debug mode, clear the
    file''s execute bit. This issue occurs on Unix-based systems and has to do with
    the development web server shipped with Flask. Here the is command to clear the
    execute bit:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调试模式下启动`flask_ws_server.py`时出现错误，请清除文件的执行位。这个问题发生在基于Unix的系统上，与Flask附带的开发Web服务器有关。这里是清除执行位的命令：
- en: '`$ chmod -x flask_ws_server.py`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ chmod -x flask_ws_server.py`'
- en: 'Visit the `http://localhost:5000` URL in a web browser. You will get a web
    page with a slider as shown in *Figure 3.2*. While the visual appearance of the
    web page is similar to the RESTful API server''s web page, the underlying JavaScipt
    is different:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中访问`http://localhost:5000` URL。你会得到一个带有滑块的网页，如*图3.2*所示。虽然网页的视觉外观与RESTful
    API服务器的网页相似，但底层的JavaScript是不同的：
- en: '![](assets/00762b5d-7c34-4a7a-8105-b18a84cb08ef.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00762b5d-7c34-4a7a-8105-b18a84cb08ef.png)'
- en: Figure 3.2 – Web Socket client web page
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - Web Socket客户端网页
- en: Verify that you can use the slider on the web page to change the brightness
    of the LED.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你是否可以使用网页上的滑块来改变LED的亮度。
- en: Open a second web browser and visit `http://localhost:5000` (so now you have
    two pages open). Change the slider, and you will see that both pages stay in sync
    and in real time! And presto, you have discovered a unique advantage offered by
    Web Sockets compared to a RESTful API.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开第二个网页浏览器并访问`http://localhost:5000`（现在你有两个页面打开）。改变滑块，你会看到两个页面保持同步并实时更新！神奇的是，你已经发现了Web
    Sockets相对于RESTful API所提供的独特优势。
- en: 'Find on the web page, the line Connected to server: Yes, then perform the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页上找到连接到服务器的行：Yes，然后执行以下操作：
- en: 'Terminate the server by pressing *Ctrl *+ *C* in the Terminal, and you will
    notice the line changes to Connected to server: No.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中按下*Ctrl* + *C*来终止服务器，你会注意到行变成了连接到服务器：否。
- en: 'Restart the server again and it changes back to Connected to server: Yes.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次重新启动服务器，它会变成连接到服务器：Yes。
- en: This illustrates the bi-directional nature of Web Sockets. We'll see how this
    is implemented on the web page when we review it's JavaScript but first, we will
    review the Python code that makes up our Web Socket server.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了Web Sockets的双向性质。当我们审查它的JavaScript时，我们将看到它是如何实现的，但首先，我们将审查构成我们的Web Socket服务器的Python代码。
- en: Server code walkthrough
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器代码演示
- en: In this section, we will walk through our Python server's source code and discuss
    the core parts. Again, we'll skip over any code and concepts that we covered in
    earlier chapters. First, let's see what we're importing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将浏览我们的Python服务器源代码并讨论核心部分。同样，我们将跳过我们在早期章节中涵盖的任何代码和概念。首先，让我们看看我们正在导入什么。
- en: '**Imports**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'Near the top of the source file, we have the following imports:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件的顶部附近，我们有以下的导入：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main difference concerning our preceding imports compared to the RESTful
    API imports are on line (1), where we now import classes and functions from Flask-SocketIO.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful API导入相比，关于我们之前的导入的主要区别在于第（1）行，我们现在从Flask-SocketIO导入类和函数。
- en: Next, in our source code, we start to work with Flask and the Flask-SocketIO
    extension.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的源代码中，我们开始使用Flask和Flask-SocketIO扩展。
- en: '**Flask and Flask-RESTful API instance variables**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Flask和Flask-RESTful API实例变量**'
- en: 'On line (2), we create an instance of `SocketIO` and the Flask-SocketIO extension
    and assign it to the `socketio` variable. It''s this variable that we will use
    throughout our server to access and configure our Web Socket service:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（2）行，我们创建了一个`SocketIO`的实例和Flask-SocketIO扩展，并将其赋值给`socketio`变量。这个变量将在整个服务器中使用，以访问和配置我们的Web
    Socket服务。
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Following the creation of our SocketIO instance, we once again will server a
    web page from the default URL endpoint, `/`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了SocketIO实例之后，我们再次从默认的URL端点`/`提供一个网页。
- en: '**Serving a web page**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提供一个网页**'
- en: 'Similarly to the RESTful API example, we configure the core Flask framework
    to serve a web page from the root URL using the `@app.route()` decorator:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful API示例类似，我们配置核心Flask框架，使用`@app.route()`装饰器从根URL提供一个网页：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For our Web Socket server, this time, we are serving the HTML file, `index_web_sockets.html`,
    which we will be covering shortly in the next section, *Adding a Web Socket client
    web page*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Web Socket服务器，这一次，我们提供的是HTML文件`index_web_sockets.html`，我们将在下一节中介绍，*添加Web
    Socket客户端网页*。
- en: Next, we start to see the code that sets up and handles Web Socket event messages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始看到设置和处理Web Socket事件消息的代码。
- en: '**Connecting and disconnecting handlers**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**连接和断开处理程序**'
- en: 'From this point in code forward, we start to see the major differences between
    the RESTful API server and this Web Socket server:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的这一点开始，我们开始看到RESTful API服务器和这个Web Socket服务器之间的主要区别：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We see, on line (4), how to register a *message* or *event* handler using the
    Python decorator notation. The parameter to each `@socketio.on(<event_name>)`
    is the name of an event our server will listen for. The `connect` and `disconnect` events (in
    the following) are two reserved events. These handlers are called whenever a client
    *connects* to or *disconnects* from the server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在第（4）行，如何使用Python装饰器符号注册*message*或*event*处理程序。每个`@socketio.on(<event_name>)`的参数是我们的服务器将监听的事件的名称。`connect`和`disconnect`事件（在下面）是两个保留事件。每当客户端*连接*到服务器或*断开*连接时，这些处理程序都会被调用。
- en: You will notice, on line (5), we are logging whenever a client connects, along
    with a unique identifier for the client accessed via `request.sid`. Each client
    session with the server receives a unique SID. When you visit `http://localhost:5000`,
    you will see this connected message logged by the server. If you open two or more
    web browsers (or tabs) to this URL, you will notice that each session receives
    a unique SID.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在第（5）行，我们在客户端连接时进行了日志记录，以及通过`request.sid`访问的客户端的唯一标识符。服务器与客户端的每个会话都会收到一个唯一的SID。当你访问`http://localhost:5000`时，你会看到服务器记录这个连接消息。如果你在这个URL上打开两个或更多的网页浏览器（或标签），你会注意到每个会话都会收到一个唯一的SID。
- en: 'On line (6), we *emit* the current LED state back to the connecting client
    so it can initialize itself as required:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（6）行，我们*emit*当前LED状态回到连接的客户端，以便它可以根据需要初始化自己：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our disconnect handler on line (7)  is simply logging the fact that a client
    disconnects. As you browse away from `http://localhost:5000`, you will notice
    the server logging this message, along with the disconnecting client's `sid`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第（7）行的断开处理程序只是记录了客户端断开的事实。当你离开`http://localhost:5000`时，你会注意到服务器记录这条消息，以及断开连接的客户端的`sid`。
- en: Next, we come across the event handler that controls our LED.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了控制我们的LED的事件处理程序。
- en: '**LED handler**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**LED处理程序**'
- en: 'On line (8) in the following, we have another message handler—this time using
    a custom event named `led`. Also notice on line (9) that this event handler has
    a `data` parameter, whereas the connect and disconnect handlers in the preceding
    section had no parameters. The `data` parameter contains data sent from the client,
    and we see, on line (10), the `level` child property of `data`. All data form
    clients are strings, so here we validate the data and cast it to an integer on
    the following line. There is no equivalent built-in argument validating and parsing
    utility with Flask-SocketIO, so we must perform validation checks manually, as
    shown starting on line (11):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的第8行，我们有另一个消息处理程序——这次使用了一个名为`led`的自定义事件。还请注意在第9行，这个事件处理程序有一个`data`参数，而在前面的部分中连接和断开连接处理程序没有参数。`data`参数包含从客户端发送的数据，我们在第10行看到了`data`的`level`子属性。所有来自客户端的数据都是字符串，所以在这里我们验证数据并在下一行将其转换为整数。在Flask-SocketIO中没有等效的内置参数验证和解析实用程序，因此我们必须手动执行验证检查，就像从第11行开始所示的那样：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the following code block, on line (12), we set the LED's brightness. On line
    (13), we see the server-side use of the `emit()` method. This method call *emits*
    a message to one or more clients. The `"led"` parameter is the name of the event
    that will be consumed by a client. We've called both the client-side and server-side
    events related to LED control the same name, `led`*.* The `state` parameter is
    the data to pass to the client. Similar to the RESTful API server, it's a Python
    dictionary object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，第12行，我们设置LED的亮度。在第13行，我们看到了`emit()`方法的服务器端使用。这个方法调用*发出*一条消息给一个或多个客户端。`"led"`参数是将被客户端消耗的事件的名称。我们将LED控制相关的客户端和服务器端事件都称为相同的名称，`led`。`state`参数是要传递给客户端的数据。与RESTful
    API服务器类似，它是一个Python字典对象。
- en: 'The `broadcast=True` parameter means that this *led* message will be emitted
    to *all* connected clients, not just the client that originated the *led* message
    on the server. The broadcasting of this event is why, when you opened multiple
    web pages and changed the slider on one, the others also stayed in sync:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcast=True`参数意味着这个*led*消息将被发送到*所有*连接的客户端，而不仅仅是在服务器上发起*led*消息的客户端。这个事件的广播是为什么当您打开多个网页并在其中一个上更改滑块时，其他网页也会保持同步的原因：'
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our final task is to cover how to start our Web Socket server.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后任务是讨论如何启动我们的Web Socket服务器。
- en: '**Starting the server**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动服务器**'
- en: 'Finally, we start the server on line (14). This time, we are using the Flask-SocketIO
    instance, `socketio`, rather than the core Flask `app` instance, as we did for
    the RESTful API server:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第14行启动服务器。这一次，我们使用的是Flask-SocketIO实例`socketio`，而不是核心Flask`app`实例，就像我们为RESTful
    API服务器所做的那样：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Well done! That's our Web Socket server complete.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！这就是我们的Web Socket服务器完成了。
- en: We have now seen how we can build a Web Socket server using Python together
    with Flask-SocketIO. While the overall outcome of our Web Socket server implementation
    controls our LED similarly to our RESTful API server, what we have learned is
    a different approach to achieving the same end result. However, in addition to
    this, we demonstrated a feature provided by a Web Socket approach, which is how
    we can keep multiple web pages in sync!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用Python和Flask-SocketIO构建Web Socket服务器。虽然我们的Web Socket服务器实现的整体结果类似于我们的RESTful
    API服务器控制LED，但我们学到的是实现相同结果的不同方法。此外，除此之外，我们展示了Web Socket方法提供的一个特性，即我们如何保持多个网页同步！
- en: You will find links in the *Further reading* section to the Flask-SocketIO documentation
    so you can further your knowledge even more.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*进一步阅读*部分找到到Flask-SocketIO文档的链接，这样您就可以进一步加深您的知识。
- en: Now that we have seen the Python server implementation of a Web Socket server,
    we'll next turn our attention to the Web Socket version of the web page.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Web Socket服务器的Python服务器实现，接下来我们将把注意力转向网页的Web Socket版本。
- en: Adding a Web Socket client web page
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Web Socket客户端网页
- en: In this section, we will review the HTML web page we used to control our LED
    from our Web Socket server. An example of this page as seen in *Figure 3.2*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将审查我们用于从Web Socket服务器控制LED的HTML网页。这个页面的示例如*图3.2*所示。
- en: We will learn how to use the Socket.IO JavaScript library with our web page
    so we can send and receive *messages* (when we work in a Web Socket environment,
    we tend to refer to data as *messages)* to and from our Python Flask-SocketIO
    Web Socket server. Plus, as we explore the JavaScript and Socket.IO-related code,
    we'll discover how our client-side JavaScript code relates to our Python server-side
    code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在网页中使用Socket.IO JavaScript库，以便我们可以与我们的Python Flask-SocketIO Web Socket服务器发送和接收*消息*（当我们在Web
    Socket环境中工作时，我们倾向于将数据称为*消息*）并从中接收。此外，当我们探索JavaScript和Socket.IO相关的代码时，我们将发现我们的客户端JavaScript代码如何与我们的Python服务器端代码相关联。
- en: You will find the following web page's code in the `chapter03/templates/index_ws_client.html` file.
    Please review the contents of this file to get a broad overview of what it contains.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`chapter03/templates/index_ws_client.html`文件中找到以下网页的代码。请审查此文件的内容，以获得对其包含的内容的广泛概述。
- en: When you have reviewed our HTML file, we will continue and discuss the important
    parts of this file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已经审查了我们的HTML文件，我们将继续讨论这个文件的重要部分。
- en: Understanding the client-side code
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解客户端代码
- en: Now that you had a look through the `chapter03/templates/index_ws_client.html` file,
    it's time to discuss how this file is constructed and what it does. We will start
    our code walk-through with the additional JavaScript import we need for Web Socket
    support.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经浏览了`chapter03/templates/index_ws_client.html`文件，是时候讨论这个文件是如何构建的以及它的作用了。我们将从我们需要用于Web
    Socket支持的额外JavaScript导入开始我们的代码漫游。
- en: '**Imports**'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入**'
- en: 'Our Web Socket client requires the Socket.IO JavaScript library, and we see
    this imported on line (1). You will find a link to the Socket.IO JavaScript library
    in the *Further reading* section if you want to learn more about this library
    and how it works:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web Socket客户端需要Socket.IO JavaScript库，在第1行看到了这个导入。如果您想了解更多关于这个库以及它的工作原理，您可以在*进一步阅读*部分找到Socket.IO
    JavaScript库的链接：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Following the imports, we will see next the JavaScript that integrates with
    our Python Web Socket server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入之后，我们将看到与我们的Python Web Socket服务器集成的JavaScript。
- en: '**Socket.IO connect and disconnect handlers**'
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Socket.IO连接和断开处理程序**'
- en: 'In the `<script>` section of the file, on line (2), we create an instance of
    the `io()` class from the `socket.io` JavaScript library and assign it to the `socket` variable:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的`<script>`部分，第2行，我们创建了一个`socket.io` JavaScript库的`io()`类的实例，并将其赋值给`socket`变量：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On line (3), with `socket.on('connect', ...)`, we register a *connect* event
    listener. This handler is called every time our web page client connects successfully
    to our Python server. This is the client-side equivalent of the Python server's
    on connect handler we defined with `@socketio.on('connect')`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，通过`socket.on('connect', ...)`，我们注册了一个*connect*事件监听器。每当我们的网页客户端成功连接到我们的Python服务器时，这个处理程序都会被调用。这是客户端等价于我们用`@socketio.on('connect')`定义的Python服务器端的on
    connect处理程序。
- en: On line (4), we see the `disconnect` handler that is called every time the client
    web page loses its connection to the server. This is the client-side equivalent
    of the Python server-side `@socketio.on('disconnect')` handler.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我们看到了`disconnect`处理程序，每当客户端网页失去与服务器的连接时都会被调用。这是客户端等价于Python服务器端`@socketio.on('disconnect')`处理程序。
- en: Notice, in both handlers, we update our web page to indicate whether it has
    a connection back to the server. We saw this in operation previously when we terminated
    and restarted the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两个处理程序中，我们更新我们的网页以指示它是否与服务器建立了连接。我们之前在终止并重新启动服务器时看到了这一操作。
- en: Next, we have a handler related to our LED.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个与我们的LED相关的处理程序。
- en: '**The on LED handler**'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**关于LED处理程序**'
- en: 'On line (5), we have our `led` message handler, which is responsible for updating
    the HTML controls with the current brightness level of our LED:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5行，我们有我们的`led`消息处理程序，负责更新HTML控件与我们LED的当前亮度级别：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you review the Python server's `@socketio.on('connect')` handler, you will
    notice it contains the line `emit("led", state)`. When a new client connects to
    the server, it *emits* back to the connecting client a message containing the
    current state of our LED. It's the JavaScript `socket.on('led', ...)` part on
    line (5) that consumes this message.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾Python服务器的`@socketio.on('connect')`处理程序，您会注意到它包含了`emit("led", state)`这一行。当新客户端连接到服务器时，它会*发送*一个消息给连接的客户端，其中包含我们LED的当前状态。JavaScript的`socket.on('led',
    ...)`部分在第5行消耗了这个消息。
- en: Next, we have the jQuery document ready callback.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有jQuery文档准备好回调。
- en: '**The document ready function**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文档准备好函数**'
- en: 'The jQuery document ready callback is where we set up the event handler for
    the HTML slider:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery文档准备好回调是我们为HTML滑块设置事件处理程序的地方：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On line (6), we see how to emit a message in JavaScript. The call to `socket.emit('led',
    payload)` emits a message to the Python server with the brightness level we want
    to apply to our LED.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们看到了如何在JavaScript中发送一个消息。调用`socket.emit('led', payload)`向Python服务器发送了一个我们想要应用到LED的亮度级别的消息。
- en: It's the Python `@socketio.on('led')` handler that receives this message and
    changes the LED's brightness.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python的`@socketio.on('led')`处理程序，它接收这个消息并改变LED的亮度。
- en: If you review this Python handler, you will notice the line: `emit("led", state,
    broadcast=True)`. This line broadcasts a message with the new LED state to all
    connected clients. Each client's `socket.on('led', ...)` handler will consume
    this message and synchronize their sliders accordingly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾这个Python处理程序，您会注意到这一行：`emit("led", state, broadcast=True)`。这一行向所有连接的客户端广播了一个包含新LED状态的消息。每个客户端的`socket.on('led',
    ...)`处理程序都会消耗这个消息，并相应地同步他们的滑块。
- en: Finally, we have the HTML that makes up our web page.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有构成我们网页的HTML。
- en: '**The web page HTML**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网页HTML**'
- en: 'The only difference to the RESTful API web page is the inclusion on line (7)
    of a message to indicate whether we have a connection to the Python server:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与RESTful API网页唯一的区别是在第7行包含了一个消息，指示我们是否与Python服务器建立了连接：
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Congratulations! That's two Python servers and web page clients using two different
    transport layers you have just completed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是两个使用两种不同传输层的Python服务器和网页客户端。
- en: We have seen how to implement the same project to control an LED's brightness
    using both a RESTful API-based approach and a Web Sockets-based approach. These
    are two very common options for implementing web services and integrating a web
    page (or any client for that matter) to a backend server, so an understanding
    and appreciation of both techniques are useful so you can choose the most suitable
    technique for your own applications or for those times when you are trying to
    understand how an existing application is implemented.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用基于RESTful API的方法和基于Web Sockets的方法来实现相同的项目，以控制LED的亮度。这两种方法是实现Web服务和将网页（或任何客户端）集成到后端服务器的两种常见选项，因此了解和欣赏这两种技术是有用的，这样您就可以选择最适合自己应用的技术，或者在尝试理解现有应用的实现方式时使用。
- en: Let's recap what we have covered by comparing the approaches and learning a
    little more about which problem domains each approach is best suited for.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过比较方法并了解更多关于每种方法最适合哪些问题领域来回顾我们所涵盖的内容。
- en: Comparing the RESTful API and Web Socket servers
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较RESTful API和Web Socket服务器
- en: A RESTful-based API is conceptually similar to design, develop, and test, and
    are more commonly found across the internet where a one-way request/response data
    exchange is needed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基于RESTful的API在概念上类似于设计、开发和测试，并且更常见于互联网上，需要一种单向请求/响应数据交换。
- en: 'Here are some defining characteristics of this approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种方法的一些定义特征：
- en: The communication protocol is built around HTTP methods with GET, POST, PUT,
    and DELETE being the most common.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议是围绕HTTP方法构建的，GET、POST、PUT和DELETE是最常见的。
- en: The protocol is half-duplex in the form of request-response. The client makes
    a request and the server responds. The server cannot initiate a request to a client.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议是半双工的请求-响应形式。客户端发出请求，服务器响应。服务器不能向客户端发起请求。
- en: We have options including `curl` on the command line and GUI tools such as Postman
    to test and development RESTful APIs.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有多种选择，包括命令行上的`curl`和诸如Postman之类的GUI工具来测试和开发RESTful API。
- en: We can use a common web browser to test HTTP GET API endpoints
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用通用的网络浏览器来测试HTTP GET API端点
- en: In Python, we can use the Flask-RESTful extension to help us to build a RESTful
    API server. We model endpoints as Python classes that have class methods such
    as `.get()` and `.post()` that match HTTP request methods.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用Flask-RESTful扩展来帮助我们构建RESTful API服务器。我们将端点建模为具有类方法（例如`.get()`和`.post()`）的Python类，这些方法与HTTP请求方法匹配。
- en: For a web page client, we can use a library such as jQuery to make HTTP requests
    to our Python server.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于网页客户端，我们可以使用jQuery等库向我们的Python服务器发出HTTP请求。
- en: Web Sockets, on the other hand, are often found in chat applications and games
    where real-time two-way data exchange is needed, often with many simultaneous
    clients.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Web Sockets通常出现在聊天应用和游戏中，需要实时的双向数据交换，通常有许多同时在线的客户端。
- en: 'Here are some defining characteristics of this approach:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种方法的一些定义特征：
- en: The communication protocol is based on publishing and subscribing to messages.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议基于发布和订阅消息。
- en: The protocol is full-duplex. Both the client and the server can initiate requests
    to one another.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议是全双工的。客户端和服务器都可以相互发起请求。
- en: In Python, we can use the Flask-SocketIO extension to help us to create Web
    Socket services. We create methods and designate them as a callback handler for
    a message event.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用Flask-SocketIO扩展来帮助我们创建Web Socket服务。我们创建方法并将它们指定为消息事件的回调处理程序。
- en: For a web page client, we use the `socket.io` JavaScript library. Similar to
    Python, we create common JavaScript functions and register them with `socket.io`
    as callback handlers for message events.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于网页客户端，我们使用`socket.io` JavaScript库。与Python类似，我们创建常见的JavaScript函数，并将它们注册到`socket.io`作为消息事件的回调处理程序。
- en: Is one approach better than the other? There is no single best or one-size-fits-all
    approach, so choosing a networking approach for your IoT applications is largely
    going to depend on what you are creating and how clients are going to connect
    to and use your application. If you are new to building networked applications
    and web services in general, RESTful APIs with Flask-RESTful is a great place
    to start while you learn the concepts and experiment. This is a very common and
    widely used approach, plus if you use a tool such as Postman ([getpostman.com](http://getpostman.com))
    as your API client while developing, then you'll have a powerful and fast way
    to play with and test the APIs that you create.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方法比另一个更好吗？没有单一的最佳或一刀切的方法，因此选择物联网应用的网络方法在很大程度上取决于您正在创建什么以及客户端将如何连接和使用您的应用。如果您是新手构建网络应用和Web服务，那么在学习概念和实验的同时，使用Flask-RESTful的RESTful
    API是一个很好的起点。这是一个非常常见和广泛使用的方法，而且如果您在开发时使用像Postman（[getpostman.com](http://getpostman.com)）这样的工具作为您的API客户端，那么您将有一个强大而快速的方式来玩耍和测试您创建的API。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered in two common methods for building networked
    services with Python—RESTful APIs and Web Socket services. We built these services
    in Python using the Flask microservices framework and the Flask-RESTful and Flask-SocketIO
    extensions. After we created each server, we also created web page clients. We
    learned how to use the JavaScript jQuery library to make a RESTful API request
    and the Socket.IO JavaScript library to perform Web Socket messaging and subscribing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Python构建网络服务的两种常见方法——RESTful API和Web Socket服务。我们使用Flask微服务框架以及Flask-RESTful和Flask-SocketIO扩展在Python中构建了这些服务。在创建每个服务器之后，我们还创建了网页客户端。我们学会了如何使用JavaScript
    jQuery库发出RESTful API请求，以及使用Socket.IO JavaScript库执行Web Socket消息和订阅。
- en: With this new knowledge, you now have the foundations and a simple end-to-end
    client-server framework built using Python, HTML, JavaScript, and jQuery that
    you can expand on and experiment with to create grander IoT applications. For
    example, as you proceed through Part 3 of this book, *IoT Playground**,* and learn
    about different electronic sensors and actuators, you'll be in a position to expand
    and build upon this chapter's examples using different electronic components.
    We'll also see another example of Flask-RESTful and RESTful APIs when we reach
    [Chapter 14](fe8f7330-0472-437e-ab91-9b920d9edb98.xhtml), *Tying It All Together **–
    An IoT Christmas Tree*, where we introduce a web page that interacts with a LED
    lighting strip and servo.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新知识，您现在已经掌握了使用Python、HTML、JavaScript和jQuery构建的基础和简单的端到端客户端-服务器框架，您可以扩展和实验，以创建更宏伟的物联网应用。例如，当您通过本书的第3部分《物联网游乐场》学习不同的电子传感器和执行器时，您将能够使用不同的电子元件扩展和构建本章的示例。当我们到达《第14章》《将一切联系在一起-物联网圣诞树》时，我们将看到另一个Flask-RESTful和RESTful
    API的示例，介绍一个与LED灯带和伺服互动的网页。
- en: In [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with
    MQTT, Python, and the Mosquitto MQTT Broker*, we will look at a more advanced
    and very versatile approach to building the networking layer of IoT applications,
    this time with MQTT, the Message Queue Telemetry Transport protocol.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第4章》《使用MQTT、Python和Mosquitto MQTT Broker进行网络》，我们将看到一种更高级和非常多才多艺的方法来构建物联网应用的网络层，这次是使用MQTT，即消息队列遥测传输协议。
- en: Questions
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一些问题列表，供您测试对本章材料的了解。您将在书的*评估*部分找到答案：
- en: What feature of the Flask-RESTful extension can we use to help to validate a
    client's input data?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask-RESTful扩展的哪个特性可以帮助我们验证客户端的输入数据？
- en: What communication protocol can be used to provide real-time full-duplex communication
    between a client and a server?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么通信协议可以用于提供客户端和服务器之间的实时全双工通信？
- en: How do we perform request data validation with Flask-SocketIO?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Flask-SocketIO进行请求数据验证？
- en: What is the Flask `templates` folder?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask的`templates`文件夹是什么？
- en: When using jQuery, where should we create component event listeners and initialize
    our web page content?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用jQuery时，我们应该在哪里创建组件事件监听器并初始化我们的网页内容？
- en: What command-line tool can be used to make requests to a RESTful API service?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么命令行工具可以用来向RESTful API服务发出请求？
- en: What happens to the physical LED when we change the `value` property of a `PWMLED`
    instance?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们改变`PWMLED`实例的`value`属性时，物理LED会发生什么？
- en: Further reading
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We have mentioned the word "RESTful" a lot in this chapter, without any deep
    discussion of what it means exactly. If you want all of the details, a great introductory
    tutorial can be found on SitePoint.com:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们经常提到“RESTful”这个词，但没有深入讨论它的确切含义。如果您想了解所有细节，可以在SitePoint.com上找到一篇很好的入门教程。
- en: REST on SitePoint.com: [https://www.sitepoint.com/developers-rest-api](https://www.sitepoint.com/developers-rest-api)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SitePoint.com上的REST：[https://www.sitepoint.com/developers-rest-api](https://www.sitepoint.com/developers-rest-api)
- en: 'Our RESTful API example barely even touches the basics of Flask and Flask-RESTful
    but provides a working example that you can build upon. I encourage you to read
    at a minimum the Flask Quick Start Guide, followed by the Flask RESTful Quick
    Start Guide to get a good grounding and understanding of these two frameworks:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RESTful API示例几乎没有涉及Flask和Flask-RESTful的基础知识，但提供了一个可以构建的工作示例。我鼓励您至少阅读Flask快速入门指南，然后再阅读Flask
    RESTful快速入门指南，以获得对这两个框架的良好基础和理解：
- en: Flask Quick Start: [https://flask.palletsprojects.com/en/1.1.x/quickstart](https://flask.palletsprojects.com/en/1.1.x/quickstart/)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask快速入门：[https://flask.palletsprojects.com/en/1.1.x/quickstart](https://flask.palletsprojects.com/en/1.1.x/quickstart/)
- en: Flask-RESTful Quick Start: [https://flask-restful.readthedocs.io/en/latest/quickstart.html](https://flask-restful.readthedocs.io/en/latest/quickstart.html)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-RESTful快速入门：[https://flask-restful.readthedocs.io/en/latest/quickstart.html](https://flask-restful.readthedocs.io/en/latest/quickstart.html)
- en: 'As mentioned during the chapter in the section titled *Introducing the Flask
    microservices framework*, if you experience difficulties with Flask-RESTful and
    cannot find answers in its documentation, you should also consult the official
    core Flask documentation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本章中所述，在标题为*介绍Flask微服务框架*的部分中，如果您在Flask-RESTful中遇到困难并且在其文档中找不到答案，您还应该参考官方的核心Flask文档：
- en: Flask documentation: [https://flask.palletsprojects.com](https://flask.palletsprojects.com)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask文档：[https://flask.palletsprojects.com](https://flask.palletsprojects.com)
- en: 'We have also only scratched the surface of Web Sockets with Flask-SocketIO
    and Socket.IO. The following links point to the official Flask-SocketIO and Socket.IO
    libraries. I''ve also included two additional links that provide a generalized
    and simple introduction to Web Sockets. As a reminder, Web Sockets are a technology
    that is best learned through doing rather than reading, especially if you are
    new to server development. So, as you read introductory material on Web Sockets,
    expect core underlying concepts to be illustrated with a wide range of different
    code examples and libraries in addition to the Flask-SocketIO and Socket.IO libraries
    we used in this chapter:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还只是初步了解了使用Flask-SocketIO和Socket.IO的Web套接字。以下链接指向官方的Flask-SocketIO和Socket.IO库。我还包括了两个额外的链接，提供了关于Web套接字的通用和简单介绍。作为提醒，Web套接字是一种最好通过实践而不是阅读来学习的技术，特别是对于新手服务器开发者来说。因此，当您阅读关于Web套接字的入门材料时，期望核心潜在概念将通过各种不同的代码示例和库来进行说明，除了我们在本章中使用的Flask-SocketIO和Socket.IO库：
- en: Flask-SocketIO: [https://flask-socketio.readthedocs.io](https://flask-socketio.readthedocs.io/)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-SocketIO：[https://flask-socketio.readthedocs.io](https://flask-socketio.readthedocs.io/)
- en: Socket.IO (JavaScript library): [https://socket.io](https://socket.io/)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socket.IO（JavaScript库）：[https://socket.io](https://socket.io/)
- en: Web Socket basics: [https://www.html5rocks.com/en/tutorials/websockets/basics](https://www.html5rocks.com/en/tutorials/websockets/basics)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web套接字基础知识：[https://www.html5rocks.com/en/tutorials/websockets/basics](https://www.html5rocks.com/en/tutorials/websockets/basics)
- en: Web Socket basics: [https://medium.com/@dominik.t/what-are-web-sockets-what-about-rest-apis-b9c15fd72aac](https://medium.com/@dominik.t/what-are-web-sockets-what-about-rest-apis-b9c15fd72aac)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web套接字基础知识：[https://medium.com/@dominik.t/what-are-web-sockets-what-about-rest-apis-b9c15fd72aac](https://medium.com/@dominik.t/what-are-web-sockets-what-about-rest-apis-b9c15fd72aac)
