- en: Testing Customer Stories with Behavior-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用行为驱动开发测试客户故事
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Naming tests that sound like sentences and stories
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的命名听起来像句子和故事
- en: Testing separate doctest documents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试单独的doctest文档
- en: Writing a testable story with doctest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用doctest编写可测试的故事
- en: Writing a testable novel with doctest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用doctest编写可测试的小说
- en: Writing a testable story with Voidspace Mock and nose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Voidspace Mock和nose编写可测试的故事
- en: Writing a testable story with mockito and nose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mockito和nose编写可测试的故事
- en: Writing a testable story with Lettuce
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lettuce编写可测试的故事
- en: Using Should DSL to write succinct assertions with Lettuce
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Should DSL编写简洁的Lettuce断言
- en: Updating the project-level script to run this chapter's BDD tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新项目级别的脚本以运行本章的BDD测试
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Behavior-driven development** (**BDD**) was created as a response to **test-driven
    development** (**TDD**) by Dan North. It focuses on writing automated tests in
    a natural language that non-programmers can read.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是由Dan North作为对**测试驱动开发**（**TDD**）的回应而创建的。它专注于用自然语言编写自动化测试，以便非程序员可以阅读。'
- en: '"Programmers wanted to know where to start, what to test and what not to test,
    how much to test in one go, what to call their tests, and how to understand why
    a test fails. The deeper I got into TDD, the more I felt that my own journey had
    been less of a wax-on, wax-off process of gradual mastery than a series of blind
    alleys. I remember thinking, ''If only someone had told me that!'' far more often
    than I thought, ''Wow, a door has opened.'' I decided it must be possible to present
    TDD in a way that gets straight to the good stuff and avoids all the pitfalls." – Dan
    North'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “程序员想知道从哪里开始，要测试什么，不要测试什么，一次测试多少，如何命名他们的测试，以及如何理解为什么测试失败。我越深入TDD，就越觉得自己的旅程不是逐渐掌握的过程，而是一系列的盲目尝试。我记得当时想，‘要是当时有人告诉我该多好！’的次数远远多于我想，‘哇，一扇门打开了。’我决定一定有可能以一种直接进入好东西并避开所有陷阱的方式来呈现TDD。” – Dan
    North
- en: 'To discover more about Dan North, please visit: [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Dan North的信息，请访问：[https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)。
- en: The tests that we have written in prior unit test recipes had a style of `testThis` and
    `testThat`. BDD takes the approach of getting out of speaking programmers and
    instead shifting to a more customer-oriented perspective.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在单元测试配方中编写的测试的风格是`testThis`和`testThat`。BDD采取了摆脱程序员的说法，而转向更加以客户为导向的视角。
- en: 'Dan North goes on to point out how Chris Stevenson wrote a specialized test
    runner for Java''s JUnit that printed test results in a different way. Let''s
    take a look at the following test code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Dan North接着指出Chris Stevenson为Java的JUnit编写了一个专门的测试运行器，以不同的方式打印测试结果。让我们来看一下以下的测试代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code, when run through AgileDox ([http://agiledox.sourceforge.net/](http://agiledox.sourceforge.net/)),
    will print out in the following format:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过AgileDox运行此代码（[http://agiledox.sourceforge.net/](http://agiledox.sourceforge.net/)）时，将以以下格式打印出来：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'AgileDox does several things such as the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: AgileDox做了几件事，比如：
- en: It prints out the test name with the test suffix dropped
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打印出测试名称，去掉测试后缀
- en: It strips out the test prefix from each test method
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从每个测试方法中去掉测试前缀
- en: It converts the remainder into a sentence
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将剩余部分转换成一个句子
- en: AgileDox is a Java tool, so we won't be exploring it in this chapter. But there
    are many Python tools available, and we will look at some, including doctest,
    Voidspace Mock, `mockito`, and Lettuce. All of these tools give us the means to
    write tests in a more natural language and empower customers, QA, and test teams
    to develop story-based tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AgileDox是一个Java工具，所以我们不会在本章中探讨它。但是有许多Python工具可用，我们将看一些，包括doctest、Voidspace Mock、`mockito`和Lettuce。所有这些工具都为我们提供了以更自然的语言编写测试的手段，并赋予客户、QA和测试团队开发基于故事的测试的能力。
- en: All the tools and styles of BDD could easily fill up an entire book. This chapter
    intends to introduce the philosophy of BDD along with some strong, stable tools
    used to effectively test our system's behavior.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有BDD的工具和风格都可以轻松填满一整本书。本章旨在介绍BDD的哲学以及一些强大、稳定的工具，用于有效地测试我们系统的行为。
- en: 'For this chapter, let''s use the same shopping cart application for each recipe.
    Create a file called `cart.py` and add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，让我们为每个配方使用相同的购物车应用程序。创建一个名为`cart.py`的文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider the following, regarding this shopping cart:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下关于这个购物车的内容：
- en: It is one-based, meaning the first item and price are at `[1]`, not `[0]`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是基于一的，意味着第一个项目和价格在`[1]`，而不是`[0]`
- en: It includes the ability to have multiples of the same item
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括具有相同项目的多个项目
- en: It will calculate total price and then add taxes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将计算总价格，然后添加税收
- en: This application isn't complex. Instead, it provides us opportunities throughout
    this chapter to test various customer stories and scenarios that aren't necessarily
    confined to simple unit testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序并不复杂。相反，它为我们提供了在本章中测试各种客户故事和场景的机会，这些故事和场景不一定局限于简单的单元测试。
- en: Naming tests that sound like sentences and stories
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名测试听起来像句子和故事
- en: Test methods should read like sentences, and test cases should read like titles
    of chapters. This is part of BDD's philosophy of making tests easy to read for
    non-programmers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法应该读起来像句子，测试用例应该读起来像章节的标题。这是BDD的哲学的一部分，目的是使测试对非程序员易于阅读。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用本章开头展示的购物车应用程序。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'With the following steps, we will explore how to write a custom `nose` plugin
    that provides results in a BDD-style report:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将探讨如何编写一个自定义的`nose`插件，以BDD风格的报告提供结果：
- en: Create a file called `recipe26.py` to contain our test cases.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe26.py`的文件来包含我们的测试用例。
- en: 'Create a unittest test, where the test case represents a cart with one item,
    and the test methods read like sentences:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个unittest测试，其中测试用例表示一个带有一个物品的购物车，测试方法读起来像句子：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a unittest test, where the test case represents a cart with two items,
    and the test methods read like sentences:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个unittest测试，其中测试用例表示一个带有两个物品的购物车，测试方法读起来像句子：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a unittest test, where the test case represents a cart with no items, and
    the test methods read like sentences:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个unittest测试，其中测试用例表示一个没有物品的购物车，测试方法读起来像句子：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: BDD encourages using very descriptive sentences for method names. Several of
    these method names were shortened to fit the format of this book, and yet some
    were still too long.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: BDD鼓励使用非常描述性的句子作为方法名。其中有几个方法名被缩短以适应本书的格式，但有些仍然太长。
- en: Create another file called `recipe26_plugin.py` to contain our customized BDD
    runner.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`recipe26_plugin.py`的文件，以包含我们定制的BDD运行程序。
- en: 'Create a `nose` plugin that can be used as `–with-bdd` to print out results:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`nose`插件，可以用作`–with-bdd`来打印结果：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a handler that prints out either the module or the test method, with
    extraneous information stripped out:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个处理程序，打印出模块或测试方法，剔除多余的信息：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a handler for success, failure, and error messages:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为成功、失败和错误消息创建一个处理程序：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a new file called `recipe26_plugin.py` to contain a test runner for exercising
    this recipe.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe26_plugin.py`的新文件，其中包含一个用于执行此示例的测试运行程序。
- en: 'Create a test runner that pulls in the test cases and runs them through `nose`,
    printing out results in an easy-to-read fashion:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试运行程序，将测试用例引入并通过`nose`运行，以易于阅读的方式打印结果：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the test runner. Take a look at this screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试运行程序。看一下这个截图：
- en: '![](../images/00057.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00057.jpeg)'
- en: 'Introduce a couple of bugs in the test cases, and rerun the test runner to
    see how this alters the output:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试用例中引入一些错误，并重新运行测试运行程序，看看这如何改变输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the tests again. Take a look at this screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。看一下这个截图：
- en: '![](../images/00058.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00058.jpeg)'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The test cases are written as nouns, describing the object being tested. `CartWithTwoItems`
    describes a series of test methods centered on a shopping cart that is prepopulated
    with two items.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例被写成名词，描述正在测试的对象。`CartWithTwoItems`描述了围绕预先填充了两个物品的购物车的一系列测试方法。
- en: The test methods are written like sentences. They are strung together with underscores
    instead of spaces. They have to be prefixed with `test_`, so that unittest will
    pick them up. `test_items_should_be_in_the_same_order_as_entered` should represent
    items that should be in the same order as entered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法写成句子。它们用下划线串联在一起，而不是空格。它们必须以`test_`为前缀，这样unittest才能捕捉到它们。`test_items_should_be_in_the_same_order_as_entered`应该表示应该按输入顺序排列的物品。
- en: 'The idea is that we should be able to quickly understand what is being tested
    by putting these two together: Given a cart with two items, the items should be
    in the same order as entered.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，我们应该能够通过将这两者结合在一起来快速理解正在测试的内容：给定一个带有两个物品的购物车，物品应该按输入顺序排列。
- en: While we could read through the test code with this thought process, mentally
    subtracting out the cruft of underscores and the `test` prefix, this can become
    a real cognitive load for us. To make it easier, we coded a quick `nose` plugin
    that split up the camel-case tests and replaced the underscores with spaces. This
    led to the useful report format.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过这种思维过程阅读测试代码，但是在脑海中减去下划线和`test`前缀的琐事，这对我们来说可能会成为真正的认知负担。为了使其更容易，我们编写了一个快速的`nose`插件，将驼峰式测试拆分并用空格替换下划线。这导致了有用的报告格式。
- en: Using this type of quick tool encourages us to write detailed test methods that
    will be easy to read on output. The feedback, not just to us but to our test team
    and customers, can be very effective at fostering communications, confidence in
    software, and help with generating new test stories.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种快速工具鼓励我们编写详细的测试方法，这些方法在输出时易于阅读。反馈不仅对我们有用，而且对我们的测试团队和客户也非常有效，可以促进沟通、对软件的信心，并有助于生成新的测试故事。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The example test methods shown here were deliberately shortened to fit the format
    of the book. Don't try to make them as short as possible. Instead, try to describe
    the expected output.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例测试方法被故意缩短以适应本书的格式。不要试图使它们尽可能短。相反，试着描述预期的输出。
- en: The plugin isn't installable. This plugin was coded to quickly generate a report.
    To make it reusable, especially with `nosetests`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 插件无法安装。这个插件是为了快速生成报告而编写的。为了使其可重用，特别是与`nosetests`一起使用。
- en: Testing separate doctest documents
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试单独的doctest文档
- en: BDD doesn't require that we use any particular tool. Instead, it's more focused
    on the approach to testing. That is why it's possible to use Python `doctest` to
    write BDD test scenarios. `doctest` isn't restricted to the module's code. With
    this recipe, we will explore creating independent text files to run through Python's
    `doctest` library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BDD不要求我们使用任何特定的工具。相反，它更注重测试的方法。这就是为什么可以使用Python的`doctest`编写BDD测试场景。`doctest`不限于模块的代码。通过这个示例，我们将探讨创建独立的文本文件来运行Python的`doctest`库。
- en: If this is `doctest`, why wasn't it included in the previous chapter's recipes?
    Because the context of writing up a set of tests in a separate test document fits
    more naturally into the philosophy of BDD than with testable docstrings that are
    available for introspection when working with a library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是`doctest`，为什么它没有包含在上一章的示例中？因为在单独的测试文档中编写一组测试的上下文更符合BDD的哲学，而不是可供检查的可测试docstrings。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用本章开头展示的购物车应用程序。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will explore capturing various test scenarios
    in `doctest` files and then running them:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将探讨在`doctest`文件中捕获各种测试场景，然后运行它们：
- en: 'Create a file called `recipe27_scenario1.doctest` that contains `doctest`-style
    type tests to exercise the shopping cart:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe27_scenario1.doctest`的文件，其中包含`doctest`风格的测试，以测试购物车的操作：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that there are no quotes surrounding the text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到文本周围没有引号。
- en: 'Create another scenario in the`recipe27_scenario2.doctest` file that tests
    the boundaries of the shopping cart, as shown here:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe27_scenario2.doctest`文件中创建另一个场景，测试购物车的边界，如下所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `recipe27.py` and put in the test runner code that finds
    files ending in `.doctest` and runs them through the `testfile` method within
    `doctest`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe27.py`的文件，并放入查找以`.doctest`结尾的文件并通过`doctest`中的`testfile`方法运行它们的测试运行器代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the test suite. Take a look at this code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试套件。查看以下代码：
- en: '![](../images/00059.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00059.jpeg)'
- en: 'Run the test suite with `-v`, as shown in this screenshot:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`运行测试套件，如下截图所示：
- en: '![](../images/00060.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00060.jpeg)'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`doctest` provides the convenient `testfile` function that will exercise a
    block of pure text as if it were contained inside a docstring. This is why no
    quotations are needed compared to when we had multiple `doctest` inside docstrings.
    The text files aren''t docstrings.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`提供了方便的`testfile`函数，它将像处理文档字符串一样处理一块纯文本。这就是为什么与我们在文档字符串中有多个`doctest`时不需要引号的原因。这些文本文件不是文档字符串。'
- en: 'In fact, if we include triple quotes around the text, the tests won''t work
    correctly. Let''s take the first scenario—put `"""` at the top and bottom of the
    file, and save it as `recipe27_bad_ scenario.txt`. Now, let''s create a file called
    `recipe27.py`, and create an alternate test runner that runs our bad scenario,
    as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们在文本周围包含三引号，测试将无法正常工作。让我们以第一个场景为例，在文件的顶部和底部放上`"""`，并将其保存为`recipe27_bad_
    scenario.txt`。现在，让我们创建一个名为`recipe27.py`的文件，并创建一个替代的测试运行器来运行我们的坏场景，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get the following error message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误消息：
- en: '![](../images/00061.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00061.jpeg)'
- en: It has confused the tail-end triple quotes as part of the expected output. It's
    best to just leave them out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经混淆了尾部三引号作为预期输出的一部分。最好直接将它们去掉。
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What is so great about moving docstrings into separate files? Isn''t this the
    same thing that we were doing in the *Creating* *testable* *documentation* *with*
    *doctest* recipe discussed in [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c),
    *Running Automated Test Suites with Nose*? Yes and no. Yes, it''s technically
    the same thing: `doctest` is exercising blocks of code embedded in the test.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档字符串移动到单独的文件中有什么好处？这难道不是我们在[第2章](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c)中讨论的*使用doctest创建可测试文档*中所做的相同的事情吗？是和不是。是，从技术上讲是一样的：`doctest`正在处理嵌入在测试中的代码块。
- en: But BDD is more than simply a technical solution. It is driven by the philosophy
    of *customer-readable* *scenarios*. BDD aims to test the behavior of the system.
    The behavior is often defined by customer-oriented scenarios. Getting a hold of
    these scenarios is strongly encouraged when our customer can easily understand
    the scenarios that we have captured. It is further enhanced when the customer
    can see what passes and fails and, in turn, sees a realistic status of what has
    been accomplished.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但BDD不仅仅是一个技术解决方案。它是由*可读* *客户端* *场景*的哲学驱动的。BDD旨在测试系统的行为。行为通常由面向客户的场景定义。当我们的客户能够轻松理解我们捕捉到的场景时，这是非常鼓励的。当客户能够看到通过和失败，并且反过来看到已经完成的实际状态时，这是进一步增强的。
- en: By decoupling our test scenarios from the code and putting them into separate
    files, we have the key ingredient to making readable tests for our customers using
    `doctest`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将测试场景与代码解耦并将它们放入单独的文件中，我们可以为我们的客户使用`doctest`创建可读的测试的关键要素。
- en: Doesn't this defy the usability of docstrings?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这难道不违背了文档字符串的可用性吗？
- en: In [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c), *Running
    Automated Test Suites with Nose,* there are several recipes that show how convenient
    it is to embed examples of code usage in docstrings. They are convenient, because
    we can read the docstrings from an interactive Python shell. What do you think
    is different about pulling some of this out of the code into separate scenario
    files? Do you think there are some `doctest` that would be useful in docstrings
    and others that may serve us better in separate scenario files?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c)中，*使用Nose运行自动化测试套件*，有几个示例展示了在文档字符串中嵌入代码使用示例是多么方便。它们很方便，因为我们可以从交互式Python
    shell中读取文档字符串。你认为将其中一些内容从代码中提取到单独的场景文件中有什么不同吗？你认为有些`doctest`在文档字符串中会很有用，而其他一些可能在单独的场景文件中更好地为我们服务吗？
- en: Writing a testable story with doctest
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用doctest编写可测试的故事
- en: Capturing a succinct story in a `doctest` file is the key to BDD. Another aspect
    of BDD is providing a readable report including the results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doctest`文件中捕捉一个简洁的故事是BDD的关键。BDD的另一个方面是提供一个包括结果的可读报告。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用本章开头展示的购物车应用程序。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will see how to write a custom `doctest` runner
    to make our own report:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将看到如何编写自定义的`doctest`运行器来生成我们自己的报告：
- en: Create a new file called `recipe28_cart_with_no_items.doctest` to contain our
    `doctest` scenario.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe28_cart_with_no_items.doctest`的新文件，用于包含我们的`doctest`场景。
- en: 'Create a `doctest` scenario that exercises the shopping cart, as shown here:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`doctest`场景，演示购物车的操作，如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a new file called `recipe28.py` to contain our custom `doctest` runner.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe28.py`的新文件，用于包含我们自定义的`doctest`运行器。
- en: 'Create a customer `doctest` runner by sub classing `DocTestRunner`, as shown
    here:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过子类化`DocTestRunner`创建一个客户`doctest`运行器，如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a `report_start` function that looks for comments starting with `#` before
    an example, as shown in this code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`report_start`函数，查找示例之前以`#`开头的注释，如下所示：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a `report_success` function that conditionally prints out `ok`, as shown
    here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个有条件地打印出`ok`的`report_success`函数，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a `report_failure` function that conditionally prints out `FAIL`, as shown
    here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个有条件地打印出`FAIL`的`report_failure`函数，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a runner that replaces `doctest.DocTestRunner` with our customer runner,
    and then looks for `doctest` files to run, as shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个运行器，用我们的自定义运行器替换`doctest.DocTestRunner`，然后查找要运行的`doctest`文件，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the runner to exercise our scenario. Take a look at this screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运行器来执行我们的场景。看一下这个截图：
- en: '![](../images/00062.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00062.jpeg)'
- en: 'Use the runner to exercise our scenario with `-v`, as shown in this screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`-v`的运行器来执行我们的场景，如此截图所示：
- en: '![](../images/00063.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00063.jpeg)'
- en: 'Alter the test scenario so that one of the expected outcomes fail by using
    this code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改测试场景，使其中一个预期结果失败，使用以下代码：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice we have changed the expected outcome from `1` to `4668`, to guarantee
    a failure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将预期结果从`1`更改为`4668`，以确保失败。
- en: 'Use the runner with `-v` again, and see the results. Take a look at this screenshot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用带有`-v`的运行器，并查看结果。看一下这个截图：
- en: '![](../images/00064.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00064.jpeg)'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`doctest` provides a convenient means to write a testable scenario. For starters,
    we wrote up a series of behaviors we wanted the shopping cart application to prove.
    To polish things up, we added lot of detailed comments so that anyone reading
    this document can clearly understand things.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`提供了一种方便的方法来编写可测试的场景。首先，我们编写了一系列我们希望购物车应用程序证明的行为。为了使事情更加完善，我们添加了许多详细的评论，以便任何阅读此文档的人都能清楚地理解事情。'
- en: 'This provides us with a testable scenario. However, it leaves us short of one
    key thing: *a* *succinct* *report*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个可测试的场景。但它让我们缺少一个关键的东西：*简洁的报告*。
- en: Unfortunately, `doctest` won't print out all these detailed comments for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`doctest`不会为我们打印出所有这些详细的评论。
- en: To make this usable from a BDD perspective, we need the ability to embed selective
    comments that get printed out when the test sequence runs. To do that, we will
    subclass `doctest.DocTestRunner` and insert our version of the handling of the
    docstring.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其从BDD的角度可用，我们需要能够嵌入选择性的注释，当测试序列运行时打印出来。为此，我们将子类化`doctest.DocTestRunner`并插入我们版本的处理文档字符串的方法。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`DocTestRunner` conveniently gives us a handle on the docstring as well as
    the exact line number where the code example starts. We coded our `BddDocTestRunner`
    to look at the line preceding it, and check to see whether it started with `#`,
    our custom marker for a piece of text to print out during a test run.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocTestRunner`方便地为我们提供了文档字符串的处理方法，以及代码示例开始的确切行号。我们编写了`BddDocTestRunner`来查看其前一行，并检查它是否以`#`开头，这是我们自定义的文本在测试运行期间打印出来的标记。'
- en: A `#when` comment is considered a cause. In other words, a `when` causes one
    or more *effects*. While `doctest` will still verify the code involved with a
    `when`; for BDD purposes, we don't really care about the outcome, so we silently
    ignore it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`#when`注释被视为原因。换句话说，`when`引起一个或多个*效果*。虽然`doctest`仍将验证与`when`相关的代码；但出于BDD目的，我们并不真正关心结果，因此我们会默默地忽略它。'
- en: Any other `#` comments are considered effects. For each of these, we strip out
    the `#` and then print the sentence indented, so we can easily see which `when`
    it is tied to. Finally, we print out either `ok` or `FAIL` to indicate the results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他`#`注释都被视为效果。对于这些效果中的每一个，我们会去掉`#`，然后缩进打印出句子，这样我们就可以轻松地看到它与哪个`when`相关联。最后，我们打印出`ok`或`FAIL`来指示结果。
- en: This means we can add all the detail we want to the documentation. But for blocks
    of tests, we can add statements that will be printed as either *causes* (`#when`)
    or effects (`#anything else`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以向文档添加所有我们想要的细节。但对于测试块，我们可以添加将被打印为*原因*（`#when`）或效果（`#其他`）的语句。
- en: Writing a testable novel with doctest
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用doctest编写可测试的小说
- en: Running a series of story tests showcases your code's expected behavior. We
    have previously seen in the *Writing* *a* *testable* *story* *with* *doctest*
    recipe how to build a testable story and have it generate a useful report.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一系列故事测试展示了代码的预期行为。我们之前在*使用doctest编写可测试的故事*配方中已经看到了如何构建一个可测试的故事并生成有用的报告。
- en: With this recipe, we will see how to use this tactic to string together multiple
    testable stories to form a testable novel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个配方，我们将看到如何使用这种策略将多个可测试的故事串联起来，形成一个可测试的小说。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，我们将使用本章开头显示的购物车应用程序。
- en: We will also reuse the `BddDocTestRunner` defined in this chapter's *Writing*
    *a* *testable* *story* *with* *doctest* recipe. But we will slightly alter it
    by implementing the following steps.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重用本章中*使用doctest编写可测试故事*中定义的`BddDocTestRunner`，但我们将稍微修改它，实施以下步骤。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new file called `recipe29.py`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe29.py`的新文件。
- en: Copy the code containing the `BddDocTestRunner` from the *Writing* *a* *testable*
    *story* *with* *doctest* recipe into `recipe29.py`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含`BddDocTestRunner`的代码从*使用doctest编写可测试的故事*配方复制到`recipe29.py`中。
- en: 'Alter the `__main__` runnable to only search for this recipe''s `doctest` scenarios,
    as shown in this code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`__main__`可运行程序，仅搜索此配方的`doctest`场景，如下所示的代码：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create a new file called `recipe29_cart_we_will_load_with_identical_items.doctest`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe29_cart_we_will_load_with_identical_items.doctest`的新文件。
- en: 'Add a scenario to it that tests the cart by adding two instances of the same
    object:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加一个场景，通过添加相同对象的两个实例来测试购物车：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create another file called `recipe29_cart_we_will_load_with_two_different_items.docstest`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`recipe29_cart_we_will_load_with_two_different_items.docstest`的文件。
- en: 'In that file, create another scenario that tests the cart by adding two different
    instances, as shown in the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中，创建另一个场景，测试通过添加两个不同实例的购物车，如下所示的代码：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a new file called `recipe29_cart_that_we_intend_to_keep_empty.doctest`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe29_cart_that_we_intend_to_keep_empty.doctest`的新文件。
- en: 'In that file, create a third scenario that tests the cart by adding nothing
    and yet tries to access values outside the range, as shown in this code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件中，创建一个第三个场景，测试购物车添加了空值，但尝试访问范围之外的值，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the runner to execute our scenarios. Take a look at this screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用runner来执行我们的场景。看一下这个截图：
- en: '![](../images/00065.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00065.jpeg)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We reuse the test runner developed in the previous recipe. The key is extending
    the scenarios to ensure that we have complete coverage of the expected scenarios.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了上一个食谱中开发的测试运行器。关键是扩展场景，以确保我们完全覆盖了预期的场景。
- en: 'We need to be sure that we can handle the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们能处理以下情况：
- en: A cart with two identical items
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有两个相同物品的购物车
- en: A cart with two different items
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有两个不同物品的购物车
- en: The degenerate situation of an empty shopping cart
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空购物车的退化情况
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A valuable part of writing tests is picking useful names. In our situation,
    each testable story started with an empty cart. However, if we named each scenario
    *given an empty cart*, it would cause an overlap and not result in a very effective
    report.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的一个有价值的部分是选择有用的名称。在我们的情况下，每个可测试的故事都以一个空购物车开始。然而，如果我们将每个场景命名为*给定一个空购物车*，这将导致重叠，并且不会产生一个非常有效的报告。
- en: 'So, instead, we named them based on our story''s intention:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们根据我们故事的意图来命名它们：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This leads to:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致：
- en: Given a cart we will load with identical items
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个我们将装满相同物品的购物车
- en: Given a cart we will load with two different items
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个我们将装满两个不同物品的购物车
- en: Given a cart that we intend to keep empty
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个我们打算保持为空的购物车
- en: The purpose of these scenarios is much clearer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景的目的更加清晰。
- en: Naming scenarios are much like certain aspects of software development that
    are more a craft than a science. Tuning the performance tends to be more scientific,
    because it involves an iterative process of measurement and adjustment. But naming
    scenarios along with their causes and effects tends to be more of a craft. It
    involves communicating with all the stakeholders including QA and customers, so
    everyone can read and understand the stories.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 命名场景很像软件开发的某些方面，更像是一种工艺而不是科学。调整性能往往更具科学性，因为它涉及到一个测量和调整的迭代过程。但是命名场景以及它们的原因和影响往往更像是一种工艺。它涉及与所有利益相关者的沟通，包括QA和客户，这样每个人都可以阅读和理解故事。
- en: Don't be intimidated. Be ready to embrace change
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不要感到害怕。准备好接受变化
- en: Start writing your stories. Make them work. Then share them with your stakeholders.
    Feedback is important, and that is the purpose of using story-based testing. Be
    ready for criticism and suggested changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写你的故事。让它们起作用。然后与利益相关者分享。反馈很重要，这就是使用基于故事的测试的目的。准备好接受批评和建议的改变。
- en: Be ready for more story requests. In fact, don't be surprised if some of your
    customers or QA want to write their own stories. That is a positive sign.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好接受更多的故事请求。事实上，如果你的一些客户或QA想要编写他们自己的故事，也不要感到惊讶。这是一个积极的迹象。
- en: If you are new to this type of customer interaction, don't worry. You will develop
    valuable communication skills and build a solid professional relationship with
    your stakeholders. And at the same time, your code quality will certainly improve.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是第一次接触这种类型的客户互动，不要担心。你将培养宝贵的沟通技能，并与利益相关者建立牢固的专业关系。与此同时，你的代码质量肯定会得到提高。
- en: Writing a testable story with Voidspace Mock and nose
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Voidspace Mock和nose编写可测试的故事
- en: When our code interacts with other classes through methods and attributes, these
    are referred to as collaborators. Mocking out collaborators using Voidspace Mock
    ([http://www.voidspace.org.uk/python/mock/](http://www.voidspace.org.uk/python/mock/)),
    created by Michael Foord, provides a key tool for BDD. Mocks provide canned behavior
    compared to stubs, which provide canned states. While mocks by themselves don't
    define BDD, their usage keenly overlaps the ideas of BDD.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码通过方法和属性与其他类交互时，这些被称为协作者。使用Voidspace Mock（[http://www.voidspace.org.uk/python/mock/](http://www.voidspace.org.uk/python/mock/)）来模拟协作者，由Michael
    Foord创建，为BDD提供了一个关键工具。模拟提供了与存根提供的固定状态相比的固定行为。虽然模拟本身并不定义BDD，但它们的使用与BDD的想法密切重叠。
- en: To further demonstrate the behavioral nature of the tests, we will also use
    the `spec` plugin found in the `pinocchio` project ([http://darcs.idyll.org/~t/projects/pinocchio/doc](http://darcs.idyll.org/~t/projects/pinocchio/doc)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步展示测试的行为性质，我们还将使用`pinocchio`项目中的`spec`插件（[http://darcs.idyll.org/~t/projects/pinocchio/doc](http://darcs.idyll.org/~t/projects/pinocchio/doc)）。
- en: As stated on the project's website, Voidspace Mock is experimental. This book
    was written using version 0.7.0 beta 3\. There is the risk that more API changes
    will occur before reaching a stable 1.0 version. Given this project's high quality,
    excellent documentation, and many articles in the blogosphere, I strongly feel
    it deserves a place in this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如项目网站上所述，Voidspace Mock是实验性的。本书是使用版本0.7.0 beta 3编写的。在达到稳定的1.0版本之前，可能会发生更多的API更改的风险。鉴于这个项目的高质量、优秀的文档和博客中的许多文章，我坚信它应该在本书中占有一席之地。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter with some slight modifications:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用本章开头展示的购物车应用程序，并进行一些轻微的修改：
- en: Create a new file called `recipe30_cart.py`, and copy all the code from `cart.py`
    created in the introduction of this chapter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe30_cart.py`的新文件，并复制本章介绍中创建的`cart.py`中的所有代码。
- en: 'Alter `__init__` to add an extra `storer` attribute used for persistence:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`__init__`以添加一个额外的用于持久性的`storer`属性：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `store` method that uses the `storer` to save the cart:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个使用`storer`保存购物车的`store`方法：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a `retrieve` method that updates the internal `items` by using the `storer`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`retrieve`方法，通过使用`storer`更新内部的`items`：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The specifics of the API of the `storer` will be given further down in this
    recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`storer`的API的具体细节将在本食谱的后面给出。'
- en: 'We need to activate our virtual environment and then install Voidspace Mock
    for this recipe:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要激活我们的虚拟环境，然后为这个示例安装Voidspace Mock：
- en: 'Create a virtual environment, activate it, and verify the tools are working.
    Take a look at the following screenshot:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境，激活它，并验证工具是否正常工作。看一下下面的截图：
- en: '![](../images/00066.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: Install Voidspace Mock by typing `pip install mock`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`pip install mock`来安装Voidspace Mock。
- en: Install the latest version of Pinocchio by typing `pip install http://darcs.idyll.org/~t/projects/pinocchio-latest.tar.gz`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`pip install http://darcs.idyll.org/~t/projects/pinocchio-latest.tar.gz`来安装Pinocchio的最新版本。
- en: This version of Pinocchio raises some warnings. To prevent them, we also need
    to install `figleaf` by typing `pip install figleaf`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个版本的Pinocchio引发了一些警告。为了防止它们，我们还需要通过输入`pip install figleaf`来安装`figleaf`。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With the following steps, we will explore how to use mock to write a testable
    story:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将探讨如何使用模拟来编写可测试的故事：
- en: 'In `recipe30_cart.py`, create a `DataAccess` class with empty methods for storing
    and retrieving shopping carts:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe30_cart.py`中，创建一个具有存储和检索购物车空方法的`DataAccess`类：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new file called `recipe30.py` to write the test code.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe30.py`的新文件来编写测试代码。
- en: 'Create an automated unittest that exercises the cart by mocking out the methods
    of `DataAccess`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自动化的unittest，通过模拟`DataAccess`的方法来测试购物车：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the test using `nosetests` with the `spec` plugin:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nosetests`和`spec`插件运行测试：
- en: '![](../images/00067.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00067.jpeg)'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Mocks are test doubles that confirm method calls, which is the *behavior*. This
    is different from stubs, which provide canned data, allowing us to confirm states.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是确认方法调用的测试替身，这是*行为*。这与存根不同，存根提供了预先准备的数据，允许我们确认状态。
- en: Many mocking libraries are based on the *record*/*replay* pattern. They first
    require the test case to *record* every behavior the mock will be subjected to
    when used. Then we plug the mock into our code, allowing our code to invoke calls
    against it. Finally, we execute *replay*, and the Mock library compares the method
    calls we expected with the ones that actually happened.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模拟库都是基于*记录*/*回放*模式的。它们首先要求测试用例在使用时*记录*模拟将受到的每个行为。然后我们将模拟插入到我们的代码中，允许我们的代码对其进行调用。最后，我们执行*回放*，Mock库将比较我们期望的方法调用和实际发生的方法调用。
- en: A common issue with record/replay mocking is that, if we miss a single method
    call, our test fails. Capturing all the method calls can become very challenging
    when trying to mock out third-party systems, or dealing with variable calls that
    may be tied to complex system states.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记录/回放模拟的一个常见问题是，如果我们漏掉了一个方法调用，我们的测试就会失败。当试图模拟第三方系统或处理可能与复杂系统状态相关联的可变调用时，捕获所有方法调用可能变得非常具有挑战性。
- en: The Voidspace Mock library differs by using the *action*/*assert* pattern. We
    first generate a mock and define how we want it to react to certain *actions*.
    Then, we plug it into our code, allowing our code to operate against it. Finally,
    we *assert* what happened to the mock, only picking the operations we care about.
    There is no requirement to assert every behavior experienced by the mock.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Voidspace Mock库通过使用*action*/*assert*模式而不同。我们首先生成一个模拟对象，并定义我们希望它对某些*操作*做出反应。然后，我们将其插入到我们的代码中，使我们的代码对其进行操作。最后，我们*断言*模拟发生了什么，只选择我们关心的操作。没有必要断言模拟体验的每个行为。
- en: Why is this important? Record/replay requires that we record the method calls
    that are made by our code, third-party system, and all the other layers in the
    call chain. Frankly, we may not need this level of confirmation of behavior. Often,
    we are primarily interested in the top layer of interaction. Action/assert lets
    us cut back on the behavior calls we care about. We can set up our mock to generate
    the necessary top level actions and essentially ignore the lower level calls,
    which a record/replay mock would force us to record.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？记录/回放要求我们记录代码、第三方系统和调用链中所有其他层次的方法调用。坦率地说，我们可能并不需要这种行为的确认水平。通常，我们主要关注的是顶层的交互。操作/断言让我们减少我们关心的行为调用。我们可以设置我们的模拟对象来生成必要的顶层操作，基本上忽略较低层次的调用，而记录/回放模拟会强制我们记录这些调用。
- en: 'In this recipe, we mocked the `DataAccess` operations `store_cart` and `retrieve_cart`.
    We defined their `return_value`, and at the end of the test we asserted that they
    were called the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们模拟了`DataAccess`操作`store_cart`和`retrieve_cart`。我们定义了它们的`return_value`，并在测试结束时断言它们被调用了以下：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`cart.storer` was the internal attribute that we injected with our mock.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart.storer`是我们用模拟注入的内部属性。'
- en: Mocking a method means replacing a call to a real method with one to a mock
    object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟方法意味着用模拟对象替换对真实方法的调用。
- en: Stubbing a method means replacing a call to a real method with one to a stub.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 存根方法意味着用存根对象替换对真实方法的调用。
- en: There's more...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Because this test case focuses on storing and retrieving from the cart's perspective,
    we didn't have to define the real `DataAccess` calls. That is why we simply put
    `pass` in their method definitions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个测试用例侧重于从购物车的角度进行存储和检索，我们不必定义真实的`DataAccess`调用。这就是为什么我们在它们的方法定义中简单地放置了`pass`。
- en: This conveniently lets us work on the behavior of persistence without forcing
    us to choose whether the cart would be stored in a relational database, a NoSQL
    database, a flat file, or any other file format. This shows that our shopping
    cart and data persistence are nicely decoupled.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这方便地让我们在不强迫选择购物车存储在关系数据库、NoSQL数据库、平面文件或任何其他文件格式的情况下，处理持久性的行为。这表明我们的购物车和数据持久性很好地解耦。
- en: Tell me more about the spec nose plugin!
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉我更多关于spec nose插件！
- en: We quickly skimmed over the useful `spec` plugin for `nose`. It provides the
    same essential functionality that we coded by hand in the *Naming* *tests* *so*
    *they* *sound* *like* *sentences* *and* *stories* section. It converts test case
    names and test method names into readable results. It gives us a runnable `spec`.
    This plugin works with unittest and doesn't care whether or not we were using
    Voidspace Mock.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快地浏览了`nose`的有用的`spec`插件。它提供了与我们在*命名测试，使其听起来像句子和故事*部分手工编码的基本功能相同。它将测试用例名称和测试方法名称转换为可读的结果。它给了我们一个可运行的`spec`。这个插件可以与unittest一起使用，不关心我们是否使用了Voidspace
    Mock。
- en: Why didn't we reuse the plugin from the recipe "Naming tests so they sound like
    sentences and stories"?
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们没有重用食谱“命名测试，使其听起来像句子和故事”中的插件？
- en: Another way to phrase this question is *Why did we write that recipe's plugin
    in the first place?* An important point of using test tools is to understand how
    they work, and how to write our own extensions. The *Naming* *tests* *so* *they*
    *sound* *like* *sentences* *and* *stories* section not only discussed the philosophy
    of naming tests, but also explored ways to write `nose` plugins to support this
    need. In this recipe, our focus was on using Voidspace Mock to verify certain
    behaviors, and not on coding `nose` plugins. Producing a nice BDD report was easily
    served by the existing `spec` plugin.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个表达这个问题的方式是*我们为什么首先编写了那个食谱的插件？*使用测试工具的一个重要点是理解它们的工作原理，以及如何编写我们自己的扩展。*命名测试，使其听起来像句子和故事*部分不仅讨论了命名测试的哲学，还探讨了编写`nose`插件以支持这种需求的方法。在这个食谱中，我们的重点是使用Voidspace
    Mock来验证某些行为，而不是编写`nose`插件。通过现有的`spec`插件轻松生成漂亮的BDD报告。
- en: See also
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a testable story with mockito and nose.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用mockito和nose编写可测试的故事。*'
- en: Writing a testable story with mockito and nose
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mockito和nose编写可测试的故事
- en: When our code interacts with other classes through methods and attributes, these
    are referred to as collaborators. Mocking out collaborators using `mockito` ([http://code.google.com/p/mockito](http://code.google.com/p/mockito)
    and [http://code.google.com/p/mockito-python](http://code.google.com/p/mockito-python))
    provides a key tool for BDD. Mocks provide canned behavior, whereas stubs,  provide
    canned states. While mocks by themselves don't define BDD, their usage keenly
    overlaps the ideas of BDD.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码通过方法和属性与其他类交互时，这些被称为协作者。使用`mockito`（[http://code.google.com/p/mockito](http://code.google.com/p/mockito)和[http://code.google.com/p/mockito-python](http://code.google.com/p/mockito-python)）模拟协作者为BDD提供了一个关键工具。模拟提供了预先定义的行为，而存根提供了预先定义的状态。虽然单独的模拟本身并不定义BDD，但它们的使用与BDD的思想密切相关。
- en: To further demonstrate the behavioral nature of the tests, we will also use
    the `spec` plugin found in the `pinocchio` project ([http://darcs.idyll.org/~t/projects/
    pinocchio/doc](http://darcs.idyll.org/~t/projects/)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步展示测试的行为性质，我们还将使用`pinocchio`项目中的`spec`插件（[http://darcs.idyll.org/~t/projects/
    pinocchio/doc](http://darcs.idyll.org/~t/projects/)）。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter with some slight modifications:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用本章开头展示的购物车应用程序，并进行一些轻微的修改：
- en: Create a new file called `recipe31_cart.py` and copy all the code from `cart.py`
    created in the introduction of this chapter.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe31_cart.py`的新文件，并复制本章开头创建的`cart.py`中的所有代码。
- en: 'Alter `__init__` to add an extra `storer` attribute used for persistence:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`__init__`以添加一个额外的用于持久化的`storer`属性：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add a `store` method that uses the `storer` to save the cart:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个使用`storer`来保存购物车的`store`方法：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a `retrieve` method that updates the internal `items` by using the `storer`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`retrieve`方法，通过使用`storer`来更新内部的`items`：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The specifics of the API of the storer will be given further down in this recipe.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器的API的具体信息将在本食谱的后面给出。
- en: 'We need to activate our virtual environment and then install `mockito` for
    this recipe:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要激活我们的虚拟环境，然后为这个食谱安装`mockito`：
- en: 'Create a virtual environment, activate it, and verify the tools are working:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境，激活它，并验证工具是否正常工作：
- en: '![](../images/00068.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00068.jpeg)'
- en: Install `mockito` by typing `pip install mockito`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`pip install mockito`来安装`mockito`。
- en: Install `pinocchio` and `figleaf` using the same steps from the *Writing a testable
    story with Voidspace Mock and nose* recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与*使用Voidspace Mock和nose编写可测试的故事*食谱相同的步骤安装`pinocchio`和`figleaf`。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will explore how to use mocking to write a testable
    story:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将探讨如何使用模拟来编写可测试的故事：
- en: 'In `recipe31_cart.py`, create a `DataAccess` class with empty methods for storing
    and retrieving shopping carts:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe31_cart.py`中，创建一个`DataAccess`类，其中包含用于存储和检索购物车的空方法：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Create a new file called `recipe31.py` for writing the test code.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为编写测试代码创建一个名为`recipe31.py`的新文件。
- en: 'Create an automated unit test that exercises the cart by mocking out the methods
    of `DataAccess`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自动化的单元测试，通过模拟`DataAccess`的方法来测试购物车：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the test using `nosetests` with the `spec` plugin:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`spec`插件运行测试`nosetests`：
- en: '![](../images/00069.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00069.jpeg)'
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is very similar to the earlier recipe, *Writing* *a* *testable*
    *story* *with* *Voidspace* M*ock* *and* *nose*. For details about mocking and
    the benefits with regards to BDD, it is very useful to read that recipe.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱与之前的食谱非常相似，*使用Voidspace Mock和nose编写可测试的故事*。关于模拟和BDD的好处的详细信息，阅读那个食谱非常有用。
- en: 'Let''s compare the syntax of Voidspace Mock with `mockito` to get a feel for
    the differences. Look at the following Voidspace Mock block of code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较Voidspace Mock和`mockito`的语法，以了解它们之间的区别。看一下以下Voidspace Mock的代码块：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It shows the function `store_cart` being mocked:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了被模拟的`store_cart`函数：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`mockito` approaches this by mocking out the entire `storer` object. `mockito`
    originated as a Java mocking tool, which explains its Java-ish APIs like `thenReturn`,
    compared to Voidspace Mock''s Pythonic style of `return_value`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockito`通过模拟整个`storer`对象来实现这一点。`mockito`起源于Java的模拟工具，这解释了它的类似Java的API，如`thenReturn`，与Voidspace
    Mock的Python风格的`return_value`相比。'
- en: Some find this influence from Java on Python's implementation of `mockito` distasteful.
    Frankly, I believe that is insufficient reason to discard a library. In the previous
    example, `mockito` records the desired behavior in a more succinct fashion, something
    that would definitely offset the Java-like API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为Java对Python的`mockito`实现的影响令人不快。坦率地说，我认为这不足以丢弃一个库。在前面的例子中，`mockito`以更简洁的方式记录了期望的行为，这绝对可以抵消类似Java的API。
- en: See also
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a testable story with Voidspace Mock and nose.*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Voidspace Mock和nose编写可测试的故事。*'
- en: Writing a testable story with Lettuce
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lettuce编写可测试的故事
- en: '**Lettuce** ([http://lettuce.it](http://lettuce.it)) is a Cucumber-like BDD
    tool built for Python.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lettuce** ([http://lettuce.it](http://lettuce.it))是一个为Python构建的类似Cucumber的BDD工具。'
- en: Cucumber ([http://cukes.info](http://cukes.info)) was developed by the Ruby
    community and provides a way to write scenarios in a textual style. By letting
    our stakeholders read the stories, they can easily discern what the software is
    expected to do.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber ([http://cukes.info](http://cukes.info))是由Ruby社区开发的，提供了一种以文本方式编写场景的方法。通过让利益相关者阅读这些故事，他们可以轻松地辨别出软件预期要做的事情。
- en: This recipe shows how to install Lettuce, write a test story, and then wire
    it into our shopping cart application to exercise our code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程展示了如何安装Lettuce，编写一个测试故事，然后将其连接到我们的购物车应用程序中，以执行我们的代码。
- en: Getting ready...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好...
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter. We also need to install Lettuce and its dependencies.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将使用本章开头展示的购物车应用程序。我们还需要安装Lettuce及其依赖项。
- en: Install Lettuce by typing `pip install lettuce`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`pip install lettuce`来安装Lettuce。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will explore creating some testable stories with
    Lettuce, and wiring them to runnable Python code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将探讨如何使用Lettuce创建一些可测试的故事，并将它们连接到可运行的Python代码中：
- en: Create a new folder called `recipe32` to contain all the files in this recipe.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe32`的新文件夹，以包含本教程中的所有文件。
- en: 'Create a file named `recipe32.feature` to capture our story. Write the top-level
    description of our new feature, based on our shopping cart:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe32.feature`的文件来记录我们的故事。根据我们的购物车，编写我们新功能的顶层描述：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s first create a scenario that captures the behavior of the cart when
    it''s empty:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个场景，捕捉购物车为空时的行为：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add another scenario that shows what happens when we add cartons of milk:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个场景，展示当我们添加牛奶盒时会发生什么：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a third scenario that shows what happens when we combine a carton of milk
    and a frozen pizza:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第三个场景，展示当我们结合一盒牛奶和一份冷冻比萨时会发生什么：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s run the story through Lettuce to see what the outcome is, considering
    we haven''t linked this story to any Python code. In the following screenshot,
    it''s impossible to discern the color of the outputs. The feature and scenario
    declarations are white. `Given`, `When`, and `Then` are undefined and colored
    yellow. This shows that we haven''t tied the steps to any code yet:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过Lettuce运行故事，看看结果如何，考虑到我们还没有将这个故事与任何Python代码联系起来。在下面的截图中，很难辨别输出的颜色。特性和场景声明是白色的。`Given`，`When`和`Then`是未定义的，颜色是黄色的。这表明我们还没有将步骤与任何代码联系起来：
- en: '![](../images/00070.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.jpeg)'
- en: Create a new file in `recipe32` called `steps.py` to implement the steps needed
    to support `Given`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe32`中创建一个名为`steps.py`的新文件，以实现对`Given`的支持所需的步骤。
- en: 'Add some code to `steps.py` to implement the first `Given`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`steps.py`中添加一些代码来实现第一个`Given`：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To run the steps, we need to make sure the current path that contains the `cart.py`
    module is part of our `PYTHONPATH`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行这些步骤，我们需要确保包含`cart.py`模块的当前路径是我们的`PYTHONPATH`的一部分。
- en: For Linux and Mac OSX systems, type `export PYTHONPATH=/path/to/ cart.py`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和Mac OSX系统，输入`export PYTHONPATH=/path/to/ cart.py`。
- en: For Windows, go to Control Panel | System | Advanced, click Environment Variables,
    and either edit the existing `PYTHONPATH` variable or add a new one, pointing
    to the folder that contains `cart.py`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows系统，转到控制面板|系统|高级，点击环境变量，要么编辑现有的`PYTHONPATH`变量，要么添加一个新的变量，指向包含`cart.py`的文件夹。
- en: 'Run the stories again. It''s hard to see in the following screenshot, but `Given
    an empty cart` is now green:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行故事。在下面的截图中很难看到，但是`Given an empty cart`现在是绿色的：
- en: '![](../images/00071.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: While this screenshot only focuses on the first scenario, all three scenarios
    have the same `Given`. The code we wrote satisfied all three `Given.`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个截图只关注第一个场景，但是所有三个场景都有相同的`Given`。我们编写的代码满足了所有三个`Given`。
- en: 'Add code to `steps.py` that implements support for the first scenario''s `Then`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码到`steps.py`中，实现对第一个场景的`Then`的支持：
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the stories again and notice how the first scenario is completely passing,
    as shown in the following screenshot:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行故事，注意第一个场景完全通过了，如下图所示：
- en: '![](../images/00072.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: 'Now add code to `steps.py` to implement the steps needed for the second scenario:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`steps.py`中添加代码，以实现对第二个场景所需的步骤：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, add code to `steps.py` to implement the steps needed for the last
    scenario:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`steps.py`中添加代码来实现最后一个场景所需的步骤：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the story by typing `lettuce recipe32` and see how they are all now passing.
    In the next screenshot, we have all the tests passing and everything is green:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`lettuce recipe32`运行故事，看看它们现在都通过了。在下一个截图中，我们有所有测试都通过了，一切都是绿色的：
- en: '![](../images/00073.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: How it works...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Lettuce uses the popular `Given`/`When`/`Then` style of BDD story telling.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Lettuce使用流行的`Given`/`When`/`Then`风格的BDD故事叙述。
- en: '**Givens**: This involves setting up a scenario. This often includes creating
    objects. For each of our scenarios, we created an instance of the `ShoppingCart`.
    This is very similar to unittest''s setup method.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Givens**：这涉及设置一个场景。这通常包括创建对象。对于我们的每个场景，我们创建了一个`ShoppingCart`的实例。这与unittest的setup方法非常相似。'
- en: '**Thens**: This acts on `Given`. These are the operations we want to exercise
    in a scenario. We can exercise more than one `Then`.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thens**：这对应于`Given`。这些是我们想要在一个场景中执行的操作。我们可以执行多个`Then`。'
- en: '**Whens**: This involves testing the final results of `Then`. In our code,
    we mostly used Python asserts. In a couple of cases, where we needed to detect
    an exception, we wrapped the call with a `try-catch` block with a `throw` if the
    expected exception didn''t occur.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Whens**：这涉及测试`Then`的最终结果。在我们的代码中，我们主要使用Python的断言。在少数情况下，我们需要检测异常，我们将调用包装在`try-catch`块中，如果预期的异常没有发生，则会抛出异常。'
- en: It doesn't matter in what order we put the `Given`/`Then`/`When`. Lettuce will
    record everything so that all the Givens are listed first, followed by all the
    `When` conditions, and then all the `Then` conditions. Lettuce puts on the final
    polish by translating successive `Given`/`When`/`Then` conditions into `And` for
    better readability.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们以什么顺序放置`Given`/`Then`/`When`都无所谓。Lettuce会记录所有内容，以便所有的Givens首先列出，然后是所有的`When`条件，然后是所有的`Then`条件。Lettuce通过将连续的`Given`/`When`/`Then`条件转换为`And`来进行最后的润色，以获得更好的可读性。
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you look closely at some of the steps, you will notice some wildcards:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看一些步骤，你会注意到一些通配符：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `@step` string lets us dynamically grab parts of the string as variables
    by using pattern matchers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`@step`字符串让我们通过使用模式匹配器动态抓取字符串的部分作为变量：'
- en: The first `(.*)` is a pattern to capture `tax_rate`
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`(.*)`是一个捕获`tax_rate`的模式
- en: The second `(.*)` is a pattern to capture `total`
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`(.*)`是一个捕获`total`的模式
- en: The method definition shows these two extra variables added in. We can name
    them anything we want. This gives us the ability to actually drive the tests,
    data and all, from `recipe32.feature` and only use `steps.py` to link things together
    in a generalized way.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义显示了这两个额外添加的变量。我们可以随意命名它们。这使我们能够实际上从`recipe32.feature`驱动测试，包括所有数据，并且只使用`steps.py`以一种通用的方式将它们连接在一起。
- en: It's important to point out that actual values stored in `tax_rate` and `total`
    are Unicode strings. Because the test involves floating point numbers, we have
    to convert the variables or the `assert` fails.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要指出存储在`tax_rate`和`total`中的实际值是Unicode字符串。因为测试涉及浮点数，我们必须转换变量，否则`assert`会失败。
- en: How complex should a story be?
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个故事应该有多复杂？
- en: In this recipe, we fit everything into a single story. Our story involved all
    the various shopping cart operations. As we write more scenarios, we may expand
    this into multiple stories. This goes back to the concept discussed in the *Breaking*
    *down* *obscure* *tests* *into* *simple* *ones* section of [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using
    Unittest to Develop Basic Tests*. If we overload a single scenario with too many
    steps, it may get too complex. It is better if we can visualize a single thread
    of execution that is easy to verify at the end.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将所有内容都放入一个故事中。我们的故事涉及各种购物车操作。随着我们编写更多的场景，我们可能会将其扩展为多个故事。这回到了第1章的*将*
    *复杂* *的* *测试* *分解* *为* *简单* *的* *测试*部分中讨论的概念，*使用Unittest开发基本测试*。如果我们在一个场景中包含了太多步骤，它可能会变得太复杂。最好能够在最后轻松验证的情况下可视化单个执行线程。
- en: Don't mix wiring code with application code
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要将布线代码与应用程序代码混合在一起
- en: The project's website shows a sample building a factorial function. It has both
    the factorial function as well as the wiring in a single file. For demo purposes
    this is alright. But for actual production use, it is best to decouple the application
    from the Lettuce wiring. This encourages a clean interface and demonstrates usability.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的网站展示了一个构建阶乘函数的示例。它既有阶乘函数，也有单个文件中的布线。出于演示目的，这是可以的。但是对于实际的生产使用，最好将应用程序与Lettuce布线解耦。这鼓励了一个清晰的接口并展示了可用性。
- en: Lettuce works great using folders
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lettuce在使用文件夹时效果很好
- en: Lettuce, by default, will look for a `features` folder wherever we run it, and
    discover any files ending in `.feature`. That way it can automatically find all
    of our stories and run them.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 生菜默认情况下会在我们运行它的地方寻找一个`features`文件夹，并发现任何以`.feature`结尾的文件。这样它就可以自动找到我们所有的故事并运行它们。
- en: It is possible to override the features directory with `-s` or `–-scenarios`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-s`或`--scenarios`来覆盖features目录。
- en: See also
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Breaking* *down* *obscure* *tests* *into* *simple* *ones* section from
    [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using Unittest
    to Develop Basic Tests*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章的*将* *复杂* *的* *测试* *分解* *为* *简单* *的* *测试*部分，*使用Unittest开发基本测试*。
- en: Using Should DSL to write succinct assertions with Lettuce
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Should DSL来使用Lettuce编写简洁的断言
- en: Lettuce ([http://lettuce.it](http://lettuce.it)) is a BDD tool built for Python.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Lettuce ([http://lettuce.it](http://lettuce.it))是一个为Python构建的BDD工具。
- en: '**Should DSL** ([http://www.should-dsl.info](http://www.should-dsl.info)) provides
    a simpler way to write assertions for `Then` conditions.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**Should DSL** ([http://www.should-dsl.info](http://www.should-dsl.info))提供了一种更简单的方式来为`Then`条件编写断言。'
- en: This recipe shows how to install Lettuce and Should DSL. Then, we will write
    a test story. Finally, we will wire it into our shopping cart application using
    Should DSL to exercise our code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何安装Lettuce和Should DSL。然后，我们将编写一个测试故事。最后，我们将使用Should DSL将其与我们的购物车应用程序进行连接，以练习我们的代码。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter. We also need to install Lettuce and its dependencies
    by doing the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用本章开头展示的购物车应用程序。我们还需要通过以下方式安装Lettuce及其依赖项：
- en: Install Lettuce by typing `pip install lettuce`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入`pip install lettuce`来安装Lettuce
- en: Install Should DSL by typing `pip install should_dsl`
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入`pip install should_dsl`来安装Should DSL
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will use Should DSL to write more succinct assertions
    in our test stories:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们将使用Should DSL来在我们的测试故事中编写更简洁的断言：
- en: Create a new directory called `recipe33` to contain all the files for this recipe.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe33`的新目录，以包含此食谱的所有文件。
- en: Create a new file in `recipe33` called `recipe33.feature` to contain our test
    scenarios.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe33`中创建一个名为`recipe33.feature`的新文件，以包含我们的测试场景。
- en: 'Create a story in `recipe33.feature` with several scenarios to exercise our
    shopping cart, as follows:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recipe33.feature`中创建一个故事，其中包含几个场景来练习我们的购物车，如下所示：
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Write a set of assertions using Should DSL, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一组使用Should DSL的断言，如下所示：
- en: '[PRE50]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the story:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行故事：
- en: '![](../images/00074.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: How it works...
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous recipe (*Writing* *a* *testable* *story* *with* *Lettuce*) shows
    more details on how Lettuce works. This recipe demonstrates how to use Should
    DSL to make useful assertions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个食谱（*使用Lettuce编写可测试的故事*）展示了更多关于Lettuce如何工作的细节。这个食谱演示了如何使用Should DSL来进行有用的断言。
- en: 'Why do we need Should DSL? The simplest checks we write involve testing values
    to confirm the behavior of the shopping cart application. In the previous recipe,
    we mostly used Python assertions such as:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要Should DSL？我们编写的最简单的检查涉及测试值以确认购物车应用程序的行为。在前一个食谱中，我们主要使用了Python断言，比如：
- en: '[PRE51]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is pretty easy to understand. Should DSL offers a simple alternative,
    which is this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解。Should DSL提供了一个简单的替代方案，就是这个：
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Does this look like much of a difference? Some say yes, others say no. It is
    wordier, and for some this is easier to read. For others, it isn't.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有很大的不同吗？有人说是，有人说不是。它更啰嗦，对于一些人来说更容易阅读。对于其他人来说，它不是。
- en: 'So why are we visiting this? Because Should DSL has more than just `equal_to`.
    There are many more commands, such as these:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们要访问这个？因为Should DSL不仅仅有`equal_to`。还有许多其他命令，比如这些：
- en: '`be`: Checks identity'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be`：检查身份'
- en: '`contain, include, be_into`: Verifies whether an object is contained or contains
    another'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contain, include, be_into`：验证对象是否包含或包含另一个对象'
- en: '`be_kind_of`: Checks types'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be_kind_of`：检查类型'
- en: '`be_like`: Checks using a regular expression'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be_like`：使用正则表达式进行检查'
- en: '`be_thrown_by,throws`: Checks that an exception is thrown'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be_thrown_by,throws`：检查是否引发了异常'
- en: '`close_to`: Checks whether a value is close, given a delta'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close_to`：检查值是否接近，给定一个增量'
- en: '`end_with`: Checks whether a string ends with a given suffix'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_with`：检查字符串是否以给定的后缀结尾'
- en: '`equal_to`: Checks value equality'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_to`：检查值的相等性'
- en: '`respond_to`: Checks whether an object has a given attribute or method'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`respond_to`：检查对象是否具有给定的属性或方法'
- en: '`start_with`: Checks whether a string starts with a given prefix'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_with`：检查字符串是否以给定的前缀开头'
- en: There are other alternatives as well, but this provides a diverse set of comparisons.
    If we imagine the code needed to write assertions that check the same things,
    then things get more complex.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他替代方案，但这提供了多样的比较。如果我们想象需要编写检查相同事物的断言所需的代码，那么事情会变得更加复杂。
- en: 'For example, let''s think about confirming expected exceptions. In the previous
    recipe, we needed to confirm that an `IndexError` is thrown when accessing an
    item outside the boundaries of our cart. A simple Python `assert` didn''t work,
    so instead we coded this pattern:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑确认预期的异常。在前一个食谱中，我们需要确认在访问购物车范围之外的项目时是否引发了`IndexError`。简单的Python `assert`不起作用，所以我们编写了这个模式：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is clunky and ugly. Now, imagine a more complex, more realistic system,
    and the idea of having to use this pattern for lots of test situations where we
    want to verify that a proper exception is thrown. This can quickly become an expensive
    coding task.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这很笨拙且丑陋。现在，想象一个更复杂、更现实的系统，以及在许多测试情况下使用这种模式来验证是否引发了适当的异常。这可能很快变成一项昂贵的编码任务。
- en: 'Thankfully, Should DSL turns this pattern of exception assertion into a one-liner:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，Should DSL将这种异常断言模式转变为一行代码：
- en: '[PRE54]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is clear and concise. We can instantly understand that invoking this method
    with these arguments should throw a certain exception. If no exception is raised,
    or a different one is raised, it will fail and give us clear feedback.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清晰而简洁的。我们可以立即理解，使用这些参数调用此方法应该引发某个异常。如果没有引发异常，或者引发了不同的异常，它将失败并给我们清晰的反馈。
- en: If you notice, Should DSL requires the method call to be split up into a tuple,
    with the first element of the tuple being the method handle, and the rest being
    the arguments for the method.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，Should DSL要求将方法调用拆分为一个元组，其中元组的第一个元素是方法句柄，其余是方法的参数。
- en: There's more...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the sample code listed in this chapter, we used `|should|`. But Should DSL
    also comes with `|should_not|`. Sometimes, the condition we want to express is
    best captured with a `|should_not|`. Combined with all the matchers listed earlier,
    we have a plethora of opportunities to test things, positive or negative.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中列出的示例代码中，我们使用了`|should|`。但是Should DSL也带有`|should_not|`。有时，我们想要表达的条件最好用`|should_not|`来捕捉。结合之前列出的所有匹配器，我们有大量的机会来测试事物，无论是积极的还是消极的。
- en: But, don't forget, we can still use Python's plain old `assert` if it is easier
    to read. The idea is to have plenty of ways to express the same verification of
    behavior.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要忘记，如果阅读起来更容易，我们仍然可以使用Python的普通`assert`。关键是有很多表达相同行为验证的方式。
- en: See also
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a testable story with Lettuce.*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Lettuce编写可测试的故事。*'
- en: Updating the project-level script to run this chapter's BDD tests
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新项目级别的脚本以运行本章的BDD测试
- en: In this chapter, we have developed several tactics to write and exercise BDD
    tests. This should help us in developing new projects. An invaluable tool for
    any project is having a top-level script used to manage things such as packaging,
    bundling, and testing.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开发了几种策略来编写和练习BDD测试。这应该有助于我们开发新项目。对于任何项目来说，一个无价的工具是拥有一个顶级脚本，用于管理打包、捆绑和测试等事物。
- en: This recipe shows how to create a command-line project script that will run
    all the tests we created in this chapter using the various runners.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方显示了如何创建一个命令行项目脚本，该脚本将使用各种运行程序运行本章中创建的所有测试。
- en: Getting ready
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to have coded all the recipes from this chapter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要编写本章中的所有配方。
- en: How to do it...
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we will create a project-level script that will run
    all the test recipes from this chapter:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤，我们将创建一个项目级别的脚本，该脚本将运行本章中的所有测试配方：
- en: Create a new file called `recipe34.py`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe34.py`的新文件。
- en: 'Add code that uses the `getopt` library for parsing command-line arguments,
    as shown here:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加使用`getopt`库来解析命令行参数的代码，如下所示：
- en: '[PRE55]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a test function that uses our custom `nose` plugin, `BddPrinter`, as shown
    here:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个使用我们自定义的`nose`插件`BddPrinter`的测试函数，如下所示：
- en: '[PRE56]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a test function that exercises file-based `doctest`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试函数，执行基于文件的`doctest`：
- en: '[PRE57]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a test function that exercises multiple `doctest` using a customized `doctest`
    runner:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试函数，使用自定义的`doctest`运行器执行多个`doctest`：
- en: '[PRE58]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a test function that exercises Lettuce tests:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试函数，执行Lettuce测试：
- en: '[PRE59]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add a top-level test function that runs all of our test functions and can be
    wired to the command-line option:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个顶层测试函数，运行所有的测试函数，并可以连接到命令行选项：
- en: '[PRE60]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add some extra stub functions that represent packaging, publishing, and registration
    options:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些额外的存根函数，代表打包、发布和注册选项：
- en: '[PRE61]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add code to parse the command-line options:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码来解析命令行选项：
- en: '[PRE62]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the script with no options:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带任何选项运行脚本：
- en: '![](../images/00075.jpeg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.jpeg)'
- en: 'Run the script with `–test`:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`–test`运行脚本：
- en: '[PRE63]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the script using `--package --publish --register`. Take a look at this
    screenshot:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--package --publish --register`运行脚本。看一下这个截图：
- en: '![](../images/00076.jpeg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: How it works...
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script uses Python's `getopt` library.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用Python的`getopt`库。
- en: See also
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more details about how and why to use `getopt`, reasons to write a project-level
    script, and why we are using `getopt` instead of `optparse`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何以及为什么使用`getopt`，编写项目级别脚本的原因，以及为什么我们使用`getopt`而不是`optparse`的更多细节。
