- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Discovering TFs with RViz
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RViz发现TFs
- en: In *Part 3* of this book, you will create a robot simulation with ROS 2\. However,
    before you get started, you first need to understand what **TransForms** (**TFs**)
    are.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*第3部分*中，你将使用ROS 2创建一个机器人仿真。然而，在你开始之前，你首先需要了解**变换**（**TFs**）是什么。
- en: In ROS, a TF is the transformation between two frames in 3D space. TFs will
    be used to track the different coordinate frames of a ROS robot (or system with
    multiple robots) over time. They are used everywhere and will be the backbone
    of any robot you create.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS中，TF是3D空间中两个坐标系之间的变换。TFs将用于跟踪ROS机器人（或具有多个机器人的系统）随时间变化的不同坐标系。它们无处不在，并将成为任何你创建的机器人的骨架。
- en: To understand TFs, we will first look at an existing robot model. As we did
    back in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092), here, we will discover
    the concepts by experimenting, and you will build an intuition of how things work.
    During this phase, you will discover a few new ROS tools, including **RViz**,
    a 3D visualization package.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解TFs，我们首先将查看一个现有的机器人模型。正如我们在[*第3章*](B22403_03.xhtml#_idTextAnchor092)中所做的那样，在这里，我们将通过实验来发现这些概念，并且你将建立起对事物如何工作的直觉。在这个阶段，你将发现一些新的ROS工具，包括**RViz**，一个3D可视化包。
- en: You will see for yourself how TFs work, how they are related to each other,
    and how to visualize the TF tree for any robot. By the end of this chapter, you
    will understand what TFs are, what problems they solve, and how they are used
    in a ROS 2 application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将亲自看到TFs是如何工作的，它们是如何相互关联的，以及如何为任何机器人可视化TF树。到本章结束时，你将理解TFs是什么，它们解决了什么问题，以及它们如何在ROS
    2应用程序中使用。
- en: 'Good news: once you understand TFs, well, it’s the same principle for any ROS
    robot, so you can directly apply what you learn here to your future projects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：一旦你理解了TFs，嗯，对于任何ROS机器人来说，原理都是相同的，所以你可以直接将在这里学到的知识应用到你的未来项目中。
- en: This chapter will be quite small and quick to finish. We won’t write any code
    here, and there is no GitHub repository. All you have to do is follow the experiments.
    Not everything has to make sense right now; the goal is to get enough context
    to understand what we will be doing later. Don’t hesitate to come back to this
    chapter once you’ve finished *Part 3*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将非常简短，并且很快就能完成。我们在这里不会编写任何代码，也没有GitHub仓库。你所要做的就是跟随实验。现在不是所有东西都必须有意义；目标是获得足够的背景知识，以便理解我们稍后将要做什么。完成*第3部分*后，不要犹豫，随时回来查看本章。
- en: 'In this chapter, we will cover the following subjects:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Visualizing a robot model in RViz
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RViz中可视化机器人模型
- en: What are TFs?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFs是什么？
- en: Relationship between TFs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFs之间的关系
- en: What problem are we trying to solve with TFs?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们试图用TFs解决什么问题？
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'At the beginning of the book, I gave you two options: either installing Ubuntu
    with a dual boot or in a virtual machine.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我给了你两个选项：要么安装带有双启动的Ubuntu，要么在虚拟机中安装。
- en: If you chose the VM path, you should have been fine for all chapters in *Part
    1* and *Part 2*. For this chapter and the next two, we will use a 3D visualization
    tool (RViz) that might not work if your computer is not powerful enough.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了虚拟机路径，那么对于*第1部分*和*第2部分*的所有章节你应该都没有问题。对于本章和接下来的两章，我们将使用一个3D可视化工具（RViz），如果你的电脑不够强大，它可能无法正常工作。
- en: I would suggest first trying to run the commands from this chapter. If it doesn’t
    work well (it’s too slow, for example), then I strongly recommend you set up a
    dual boot with Ubuntu and ROS 2 (see the instructions in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048)).
    If RViz works fine, then continue like this for now. The dual boot will be required
    for [*Chapter 13*](B22403_13.xhtml#_idTextAnchor614).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议首先尝试运行本章中的命令。如果它运行得不好（例如，太慢），那么我强烈建议你设置一个双启动系统，使用Ubuntu和ROS 2（参见[*第2章*](B22403_02.xhtml#_idTextAnchor048)中的说明）。如果RViz运行良好，那么现在可以继续这样做。双启动系统将在[*第13章*](B22403_13.xhtml#_idTextAnchor614)中需要。
- en: Visualizing a robot model in RViz
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RViz中可视化机器人模型
- en: In this section, you will discover RViz. RViz allows you to visualize a robot
    model in 3D and contains many plugins and functionalities that will help you develop
    your robotics applications. With RViz, you will be able to visualize the TFs for
    a robot, so we can start to understand what they are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将发现RViz。RViz允许你在3D中可视化机器人模型，并包含许多插件和功能，这些将帮助你开发你的机器人应用程序。使用RViz，你将能够可视化机器人的TFs，因此我们可以开始理解它们是什么。
- en: As we haven’t created a robot model yet, we will use one from an existing ROS
    2 package named **urdf_tutorial**. We will load a robot model in RViz and learn
    how to navigate the software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有创建一个机器人模型，我们将使用一个名为 **urdf_tutorial** 的现有 ROS 2 包中的一个。我们将在 RViz 中加载一个机器人模型，并学习如何导航该软件。
- en: Let’s start by setting up everything we need for this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为这一章设置我们需要的所有东西。
- en: Installation and setup
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和设置
- en: First of all, there is no need to install RViz. It was already included when
    you installed ROS 2 at the beginning of the book (with the **sudo apt install**
    **ros-<distro>-desktop** command).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，没有必要安装 RViz。在本书开头安装 ROS 2 时（使用 `sudo apt install` 命令的 `ros-<distro>-desktop`），它已经被包含在内了。
- en: To visualize TFs for a robot model on RViz, we will install a new ROS package
    named **urdf_tutorial**. This package contains some existing launch files and
    robot model files (how to create a robot model will be the focus of the next chapter).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 RViz 中可视化机器人模型的 TF，我们将安装一个新的 ROS 包，名为 **urdf_tutorial**。此包包含一些现有的启动文件和机器人模型文件（下一章将重点介绍如何创建机器人模型）。
- en: If you remember, to install a ROS 2 package with **apt**, you have to start
    with **ros**, then write the name of the distribution you are using, and finally,
    add the package name. All words are separated with dashes (not underscores).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，使用 **apt** 安装 ROS 2 包时，您必须从 **ros** 开始，然后写下您正在使用的发行版名称，最后添加包名称。所有单词都由连字符（不是下划线）分隔。
- en: 'Open a terminal and install this package:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端并安装此包：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, so that you can use the package, make sure you source the environment
    or simply open a new terminal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使用该包，请确保您已源代码或简单地打开一个新的终端。
- en: Let’s now visualize a robot model.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来可视化一个机器人模型。
- en: Starting RViz with a robot model
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用机器人模型启动 RViz
- en: The **urdf_tutorial** package contains a launch file, named **display.launch.py**,
    that will start RViz and load a robot model into it. For now, we will just use
    it, and in the following chapters, we will understand how this process works so
    we can replicate it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**urdf_tutorial** 包包含一个名为 **display.launch.py** 的启动文件，它将启动 RViz 并将一个机器人模型加载到其中。现在，我们将使用它，在接下来的章节中，我们将了解这个过程是如何工作的，这样我们就可以复制它。'
- en: 'So, we need to start this launch file and also load a robot model. Where will
    we get one? There are some existing models in the **urdf_tutorial** package. To
    find them, navigate to the **share** directory where the package was installed,
    and you will find a **urdf** folder under the package name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要启动这个启动文件，并加载一个机器人模型。我们将在哪里找到它？在 **urdf_tutorial** 包中有些现有的模型。要找到它们，导航到包安装的
    **share** 目录，你将在包名称下找到一个 **urdf** 文件夹：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A **Unified Robot Description Format** (**URDF**) file is basically the description
    of a robot model. We will come back to this in the next chapter. For now, all
    we want to do is to visualize one. In the **urdf** folder, you can find several
    robot model files:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **统一机器人描述格式**（**URDF**）文件基本上是机器人模型的描述。我们将在下一章中回到这一点。现在，我们只想可视化一个。在 **urdf**
    文件夹中，你可以找到几个机器人模型文件：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can now start a robot model in RViz by launching the **display.launch.py**
    file and add the path to the robot model with an additional **model** argument
    after the launch file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过启动 **display.launch.py** 文件并在启动文件后添加一个额外的 **model** 参数来启动一个机器人模型：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid errors, it’s better to provide the absolute path to the .`urdf` file,
    even if you run the command from the same folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，最好提供 `.urdf` 文件的绝对路径，即使你从同一文件夹运行命令也是如此。
- en: 'After running the command, you should see something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该会看到类似这样的内容：
- en: "![Figure 10.1 – A robot mod\uFEFFel on RViz](img/B22403_10_1.jpg)"
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – RViz 上的机器人模型](img/B22403_10_1.jpg)'
- en: Figure 10.1 – A robot model on RViz
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – RViz 上的机器人模型
- en: 'You will get two windows: the main one (**RViz**) with the robot model, and
    a **Joint State Publisher** window with some cursors. The robot model we have
    here is a replica of a famous science-fiction movie robot. It has some wheels,
    a torso, a head, and a gripper.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到两个窗口：一个主窗口（**RViz**）带有机器人模型，以及一个带有一些光标的 **Joint State Publisher** 窗口。我们这里的机器人模型是一个著名科幻电影机器人的复制品。它有一些轮子、一个躯干、一个头部和一个夹爪。
- en: Let’s focus on the main window (**RViz**) for now. Take some time to learn how
    to navigate in the 3D space and move around the robot. You can use the left click,
    right click, and mouse wheel. For this, it’s best to have a mouse, but you could
    still manage to navigate with the touchpad of a laptop, although it’s less ergonomic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注主窗口（**RViz**）。花些时间学习如何在3D空间中导航并在机器人周围移动。你可以使用左键点击、右键点击和鼠标滚轮。为此，最好有一个鼠标，但即使使用笔记本电脑的触摸板，你也能管理导航，尽管这不太方便。
- en: You can also resize the window and the various sections inside RViz. Pretty
    much everything you see can be customized. Now that you can load a robot model
    in RViz, we will start to experiment with TFs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调整RViz窗口的大小以及内部各个部分的大小。基本上，你看到的一切都可以自定义。现在你可以在RViz中加载机器人模型，我们将开始实验TF。
- en: What are TFs?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TF是什么？
- en: 'There are two main parts in a robot model: links and TFs. In this section,
    we will visualize them both and understand how they work together.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人模型中有两个主要部分：链接和TF。在本节中，我们将可视化它们，并了解它们是如何协同工作的。
- en: Let’s start with links.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从链接开始。
- en: Links
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: Have a look at the menu on the left side of the **RViz** window. There, you
    will see, in blue bold letters, **RobotModel** and **TF**. This is what we will
    focus on in this chapter. As you can see, you can enable or disable both menus.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**RViz**窗口左侧的菜单。在那里，你会看到，用蓝色粗体字母，**RobotModel**和**TF**。这是我们本章将关注的内容。如你所见，你可以启用或禁用这两个菜单。
- en: Disable **TF**, keep **RobotModel**, and expand the menu. There, you can find
    a submenu called **Links**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用**TF**，保持**RobotModel**，并展开菜单。在那里，你可以找到一个名为**Links**的子菜单。
- en: '![Figure 10.2 – RobotModel with Links menu on RViz](img/B22403_10_2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – RViz上的RobotModel和Links菜单](img/B22403_10_2.jpg)'
- en: Figure 10.2 – RobotModel with Links menu on RViz
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – RViz上的RobotModel和Links菜单
- en: Check and uncheck some boxes. As you can see from this menu, a *link* is one
    rigid part (meaning one solid part with no articulation) of the robot. Basically,
    in ROS, a robot model will consist of a collection of rigid parts put together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择或取消选择一些复选框。如你所见，从这个菜单中，一个*链接*是机器人一个刚性部件（意味着一个没有关节的固体部件）。基本上，在ROS中，一个机器人模型将是由一系列刚性部件组成的集合。
- en: 'In this example, links are represented by basic shapes: boxes, cylinders, and
    spheres. Those rigid parts do nothing on their own, so how are they connected,
    and how do they move between each other?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，链接由基本形状表示：盒子、圆柱体和球体。这些刚性部件本身没有任何作用，那么它们是如何连接的，又是如何相互移动的呢？
- en: This is where we introduce TFs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引入TF的地方。
- en: TFs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TF
- en: Let’s now check the **TF** box. You can keep **RobotModel** checked or unchecked.
    Inside the **TF** menu, you have a submenu called **Frames**, and you can also
    enable or disable each frame for the robot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查一下**TF**复选框。你可以保持**RobotModel**复选框选中或未选中。在**TF**菜单中，有一个名为**Frames**的子菜单，你也可以为机器人启用或禁用每个框架。
- en: '![Figure 10.3 – Frames and TFs on RViz](img/B22403_10_3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – RViz上的框架和TF](img/B22403_10_3.jpg)'
- en: Figure 10.3 – Frames and TFs on RViz
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – RViz上的框架和TF
- en: The axes you see here (red, green, and blue coordinate systems) represent the
    frames, or basically the origin of each link of the robot.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的轴（红色、绿色和蓝色坐标系）代表框架，或者说机器人每个链接的起点。
- en: 'Coordinate systems follow the right-hand rule in ROS. Following *Figure 10**.4*,
    you have the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS中，坐标系遵循右手定则。根据*图10.4*，你有以下内容：
- en: X axis (red) pointing forward
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X轴（红色）向前指向
- en: Y axis (green) pointing 90 degrees to the left
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y轴（绿色）向左90度指向
- en: Z axis (blue) pointing up
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z轴（蓝色）向上指向
- en: '![Figure 10.4 – Convention for coordinate systems in ROS](img/B22403_10_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – ROS中坐标系的习惯用法](img/B22403_10_4.jpg)'
- en: Figure 10.4 – Convention for coordinate systems in ROS
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – ROS中坐标系的习惯用法
- en: The arrows that you see between each frame in *Figure 10**.3* are the relationship
    between each rigid part (link) of the robot. A TF is represented by an arrow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*图10.3*中看到的每个框架之间的箭头是机器人每个刚性部件（链接）之间的关系。TF由一个箭头表示。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There can be some confusion between the names **links**, **frames**, and **TFs**.
    Let’s make things clear:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在**links**、**frames**和**TFs**的名称之间可能会有一些混淆。让我们澄清一下：
- en: '- Link: one rigid part of a robot'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '- 链接：机器人一个刚性部件'
- en: '- Frame: the origin of a link (axis in RViz)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '- 框架：链接的起点（RViz中的轴）'
- en: '- TF: the relationship between two frames (arrow in RViz)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '- TF：两个框架之间的关系（RViz中的箭头）'
- en: So, each rigid part will be linked to another rigid part, thanks to a TF. This
    transformation defines how those two parts are placed relative to each other.
    In addition to that, the TF also defines whether the two parts are moving, and
    if so, how—translation, rotation, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个刚体部分都会通过一个TF与另一个刚体部分相连。这种变换定义了这两个部分相对于彼此的位置。此外，TF还定义了这两个部分是否在移动，如果是的话，如何移动——平移、旋转等。
- en: To make some parts of the robot move, you can move some of the cursors in the
    **Joint State Publisher** window. You will see the frames and TFs moving in RViz.
    If you also check the **RobotModel** box again, you will see the rigid parts moving
    as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使机器人的某些部分移动，你可以在**关节状态发布者**窗口中移动一些光标。你将看到在RViz中帧和TFs在移动。如果你再次检查**机器人模型**框，你也会看到刚体部分在移动。
- en: 'To better understand, here is an analogy with the human arm: we can define
    the parts of the arm as *arm* (shoulder to elbow) and *forearm* (after the elbow).
    Those two are rigid parts (here, links) and do not move on their own. Each link
    has an origin frame, and there is a TF that defines where the arm and forearm
    are connected (imagine an axis in the elbow), and how they move (in this case,
    it’s a rotation with a minimum and maximum angle).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，这里有一个与人类手臂的类比：我们可以将手臂的部分定义为*手臂*（从肩膀到肘部）和*前臂*（肘部之后）。这两个是刚体部分（在这里，是链接），并且它们不会自行移动。每个链接都有一个原点坐标系，有一个TF定义了手臂和前臂的连接位置（想象一下肘部的轴线），以及它们的运动方式（在这种情况下，是一个具有最小和最大角度的旋转）。
- en: As we will see later in this chapter, TFs are tremendously important. If the
    TFs for a robot are not correctly defined, then nothing will work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，TFs非常重要。如果机器人的TFs没有正确定义，那么什么都不会工作。
- en: Now you know what TFs are, but how are they all related to each other? As you
    can see on RViz, it seems that TFs are organized in a certain way. Let’s go one
    step further and understand what the relationship between TFs is.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了TFs是什么，但它们之间是如何相互关联的呢？正如你在RViz中看到的那样，TFs似乎是有组织地排列的。让我们再进一步，了解TFs之间的关系。
- en: Relationship between TFs
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFs之间的关系
- en: In RViz, we have seen the links (rigid parts) and TFs (connections between the
    links). Links are mostly used for visual aspects in simulation and will be useful
    to define inertial and collision properties (when we work with Gazebo). TFs define
    how links are connected, and how they move between each other.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在RViz中，我们看到了链接（刚体部分）和TFs（链接之间的连接）。链接主要用于模拟中的视觉方面，并将有助于定义惯性和碰撞属性（当我们使用Gazebo时）。TFs定义了链接是如何连接的，以及它们是如何相互移动的。
- en: In addition to that, all the TFs for a robot are organized in a particular way,
    inside a tree. Let’s explore the relationship between TFs and visualize the TF
    tree for the robot we started on RViz.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，一个机器人的所有TFs都按照特定的方式组织，在一个树结构中。让我们来探索TFs之间的关系，并在RViz中可视化我们开始时的机器人TF树。
- en: Parent and child
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父亲和子代
- en: Each TF will be connected to another TF, with a parent/child relationship. To
    see one, you can, for example, disable all TFs on RViz, and only check the **base_link**
    and **gripper_pole** frames.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TF都会连接到另一个TF，形成一个父/子关系。例如，要查看一个，你可以禁用RViz上的所有TFs，只检查**base_link**和**gripper_pole**坐标系。
- en: '![Figure 10.5 – The relationship between two frames](img/B22403_10_5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 两个坐标系之间的关系](img/B22403_10_5.jpg)'
- en: Figure 10.5 – The relationship between two frames
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 两个坐标系之间的关系
- en: As you can see in this example, an arrow is going from the **gripper_pole**
    frame to the **base_link** frame. This means that **gripper_pole** is the child
    of **base_link** (or, **base_link** is the parent of **gripper_pole**).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个例子中看到的那样，一个箭头从**gripper_pole**坐标系指向**base_link**坐标系。这意味着**gripper_pole**是**base_link**的子代（或者，**base_link**是**gripper_pole**的父代）。
- en: If you look back at *Figure 10**.3*, you can see all the frames for the robot,
    with all the relationships between them (TFs).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下*图10*.3，你可以看到机器人的所有坐标系，以及它们之间的关系（TFs）。
- en: The order of those relationships is very important. If you move **gripper_pole**
    relative to **base_link** (the **gripper_extension** cursor in the **Joint State
    Publisher** window), then anything that’s attached to **gripper_pole** (meaning
    children of **gripper_pole**) will also move with it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系的顺序非常重要。如果你将**gripper_pole**相对于**base_link**移动（在**关节状态发布者**窗口中的**gripper_extension**光标），那么连接到**gripper_pole**的任何东西（即**gripper_pole**的子代）也会随之移动。
- en: 'That makes sense: when you rotate your elbow, your forearm is moving, but also
    your wrist, hand, and fingers. They don’t move relative to the forearm, but as
    they are attached to it, they move relative to the arm.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的：当你旋转你的肘部时，你的前臂在移动，但你的手腕、手和手指也在移动。它们相对于前臂不移动，但作为它们附着在前臂上，它们相对于手臂移动。
- en: Now, you can visualize all the links and TFs on RViz, see the relationship between
    TFs, and also how they are related to each other. Let’s go further with the **/****tf**
    topic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在RViz上可视化所有的链接和TFs，看到TFs之间的关系，以及它们是如何相互关联的。让我们进一步探讨**/****tf**主题。
- en: The /tf topic
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**/tf**主题'
- en: At this point, you might think that what we did in *Part 2* of this book has
    nothing to do with what we are doing now. Well, everything we have seen here is
    still based on nodes, topics, and so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会认为我们在本书的**第2部分**中所做的一切与我们现在所做的一切没有任何关系。好吧，我们在这里看到的一切仍然基于节点、主题等等。
- en: 'Let’s list all nodes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出所有节点：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that RViz is actually started as a node (**rviz**). We also have
    the **joint_state_publisher** and **robot_state_publisher** nodes, which we will
    come back to in the following chapters of this book. Now, let’s list all topics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，RViz实际上是以一个节点（**rviz**）启动的。我们还有**joint_state_publisher**和**robot_state_publisher**节点，我们将在本书的后续章节中回到这些节点。现在，让我们列出所有主题：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that the nodes that were started are using topics to communicate
    with each other. In this topic list, we find the **/tf** topic. This topic will
    be there for any robot you create. The TFs you saw on RViz are actually the 3D
    visualization of this topic—meaning the **rviz** node is a subscriber to the **/****tf**
    topic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，那些启动的节点正在使用主题相互通信。在这个主题列表中，我们找到了**/tf**主题。这个主题将适用于你创建的任何机器人。你在RViz上看到的TF实际上是这个主题的3D可视化——这意味着**rviz**节点是**/****tf**主题的订阅者。
- en: 'You can subscribe to the topic from the terminal with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令从终端订阅主题：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you do so, you will receive lots of messages. Here is an extract:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你会收到很多消息。这里是一个摘录：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This extract matches what we previously saw on RViz. It represents the transformation
    between **base_link** and **gripper_pole**. Here are the important pieces of information
    we can get from this message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个摘录与我们之前在RViz上看到的内容相匹配。它代表了**base_link**和**gripper_pole**之间的转换。以下是我们可以从这个消息中获得的重要信息：
- en: Timestamp for the TF
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF的时间戳
- en: Parent and child frame IDs
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父亲和子帧ID
- en: The actual transformation, with a translation and a rotation
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的转换，包括平移和旋转
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The rotation is not represented by Euler angles (`x`, `y`, `z`), but by a quaternion
    (`x`, `y`, `z`, `w`). Quaternions are usually better suited for computers, but
    it’s difficult for humans to visualize them. Do not worry about this—we won’t
    really have to deal with quaternions. If you ever have to do so in the future,
    you will have access to libraries that can convert angles into something you can
    understand.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转不是用欧拉角（`x`，`y`，`z`）表示，而是用四元数（`x`，`y`，`z`，`w`）表示。四元数通常更适合计算机，但对于人类来说，可视化它们是困难的。不要担心这个问题——我们实际上并不需要处理四元数。如果你将来必须这样做，你将能够访问可以将角度转换为可理解内容的库。
- en: One important thing we can get here is that the transformation is for a specific
    time. It means that with the topic data, you can follow the evolution of all TFs
    over time. You can know where **gripper_pole** is relative to **base_link**, now
    or in the past.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里获得的一个重要信息是，转换是针对特定时间的。这意味着，通过主题数据，你可以跟随所有TFs随时间的变化。你可以知道**gripper_pole**相对于**base_link**现在或过去的位置。
- en: This **/tf** topic contains all the information we need, but it’s not really
    human-readable. That’s why we started with RViz, so we could see a 3D view with
    all the TFs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**/tf**主题包含了我们所需要的一切信息，但它并不是真正的人类可读的。这就是为什么我们开始使用RViz，这样我们就可以看到包含所有TFs的3D视图。
- en: Let’s now finish this section by printing the TF tree, so we can see all the
    relationships in one single image.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过打印TF树来完成这个部分，这样我们就可以在一张单独的图像中看到所有关系。
- en: Visualizing the TF tree
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化TF树
- en: For each robot, you can visualize the complete TF tree in a simplified way,
    so that you can see all the relationships between all the TFs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个机器人，你可以以简化的方式可视化完整的TF树，这样你就可以看到所有TFs之间的关系。
- en: 'To do that, you will need to use the **tf2_tools** package. Make sure it is
    installed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要使用**tf2_tools**包。确保它已安装：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Don’t forget to source the environment after installing the package. Now, keep
    the robot running on RViz, and execute this command in a second terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在安装包后source环境。现在，保持机器人在RViz上运行，并在第二个终端中执行此命令：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you will see with the logs, it will listen to the **/tf** topic for five
    seconds. After this, the command exits with a big log that you can ignore.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你将通过日志看到的那样，它将监听**/tf**主题五秒钟。在这之后，命令将退出并显示一个大的日志，你可以忽略它。
- en: You will get two new files, in the same directory as where you ran the command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这个命令运行的同一目录下获得两个新文件。
- en: 'Open the PDF file. You will see something like this (I’m just adding the left
    side of the image, otherwise the text would be too small to read in the book):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开PDF文件。你会看到类似这样的内容（我只是添加了图像的左侧，否则书中的文字太小，难以阅读）：
- en: '![Figure 10.6 – TF tree for a robot](img/B22403_10_6.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 机器人的TF树](img/B22403_10_6.jpg)'
- en: Figure 10.6 – TF tree for a robot
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 机器人的TF树
- en: In this file, you get all the links and TFs at once, and it’s quite clear to
    see which link is a child of which other link. Each arrow on the PDF represents
    a TF between the links.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以一次性获得所有的链接和TFs，并且可以清楚地看到哪个链接是哪个其他链接的子链接。PDF上的每个箭头都代表链接之间的一个TF（变换）。
- en: 'As you can see, the root link for that robot is named **base_link** (the name
    **base_link** is used for most robots as the first link). This link has four children:
    **gripper_pole**, **head**, **left_leg**, and **right_leg**. Then, those links
    also get more children. Here, we can clearly see all the children for the **gripper_pole**
    link.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，那个机器人的根链接被命名为**base_link**（对于大多数机器人，**base_link**被用作第一个链接的名称）。这个链接有四个子链接：**gripper_pole**、**head**、**left_leg**和**right_leg**。然后，这些链接也会有更多的子链接。在这里，我们可以清楚地看到**gripper_pole**链接的所有子链接。
- en: We can now understand that when we previously moved **gripper_pole** relative
    to **base_link**, then all children of **gripper_pole** were also moved relative
    to **base_link**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以理解，当我们之前将**gripper_pole**相对于**base_link**移动时，**gripper_pole**的所有子链接也相对于**base_link**移动了。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In ROS, one link can have several children, but only one parent. We will come
    back to this in the next chapter when we define the links and TFs ourselves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS中，一个链接可以有多个子链接，但只有一个父链接。我们将在下一章中定义链接和TFs时回到这个问题。
- en: 'In this example, we have just one robot. If you were to have several robots
    in your application, then you would have, for example, a **world** frame as the
    root link. Then, this frame would have several children: **base_link1**, **base_link2**,
    and so on. Each robot base link would be connected to the **world** frame. Thus,
    you can get a complete TF tree, not just for one robot but also for a complete
    robotics application with several robots.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只有一个机器人。如果你在你的应用中有几个机器人，那么你会有一个**world**框架作为根链接。然后，这个框架会有几个子链接：**base_link1**、**base_link2**等等。每个机器人基链接都会连接到**world**框架。因此，你可以得到一个完整的TF树，不仅是一个机器人，而且是一个包含多个机器人的完整机器人应用。
- en: 'Now, you have seen pretty much everything about TFs: what they are, how they
    are related to each other, and how they are organized. Let’s finish this chapter
    by understanding what problem we are trying to solve with TFs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了关于TFs（变换）的几乎所有内容：它们是什么，它们是如何相互关联的，以及它们是如何组织的。让我们通过理解我们试图用TFs解决的问题来结束这一章。
- en: What problem are we trying to solve with TFs?
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们试图用TFs解决什么问题？
- en: 'You have now seen what TFs are and how you can visualize them for any ROS robot.
    This is great, but now we come to the final question for this chapter: why do
    we need to care about this? What problem are we trying to solve?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了TFs是什么以及你如何为任何ROS机器人可视化它们。这是很好的，但现在我们来到了这一章的最终问题：为什么我们需要关心这个？我们试图解决什么问题？
- en: What we want to achieve
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们想要实现的目标
- en: For a robotics application to work, we want to keep track of each 3D coordinate
    frame over time. We need a structured tree for all the frames of the robot (or
    robots).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使机器人应用工作，我们希望随着时间的推移跟踪每个3D坐标框架。我们需要一个结构化的树来表示机器人的所有框架（或机器人）。
- en: 'There are two components here: we need to know where things are and when the
    transformations happened. If you remember, when we checked the **/tf** topic,
    you could see that for each parent and child frame, we had a transformation (translation
    and rotation in 3D space), and we also had a timestamp.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个组成部分：我们需要知道事物在哪里以及变换发生的时间。如果你还记得，当我们检查**/tf**主题时，你可以看到对于每个父框架和子框架，我们都有一个变换（在三维空间中的平移和旋转），我们还有一个时间戳。
- en: 'Here are some concrete examples of some questions you could need to answer
    in a robotics application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些具体的例子，说明在机器人应用中你可能需要回答的问题：
- en: For one mobile robot, where is the right wheel relative to the left wheel and
    to the base of the robot? How does the wheel movement evolve over time?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个移动机器人，右轮相对于左轮和机器人底部的位置在哪里？车轮的运动是如何随时间演变的？
- en: If you have an application with a robotic arm and a camera, then where is the
    camera relative to the base of the robot? And to the hand of the robot, so that
    the arm can correctly pick up and place objects that were detected by the camera?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个带有机械臂和摄像头的应用，那么摄像头相对于机器人底部和机械臂手的位置在哪里？这样，机械臂就可以正确地捡起和放置由摄像头检测到的物体？
- en: In another application with several mobile robots, where is each robot relative
    to the other ones?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个有多个移动机器人的应用中，每个机器人相对于其他机器人的位置在哪里？
- en: If you combine the two previous examples, where is the hand of the robotic arm
    relative to the base of one of the mobile robots?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你结合前两个例子，机械臂的手相对于移动机器人之一的底部在哪里？
- en: 'So, with TFs, we want to know the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过TFs，我们想要知道以下内容：
- en: How frames are placed relative to each other
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架相对于彼此是如何放置的
- en: How they move relative to each other and over time
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们相对于彼此以及随时间如何移动
- en: This is required for a robot to correctly work with ROS.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于机器人正确使用ROS是必需的。
- en: Now, let’s see how you would compute the TFs by yourself, and how ROS automatically
    does this for you so you don’t need to worry about it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你将如何自己计算TFs，以及ROS是如何自动为你完成这些工作，这样你就不必担心它。
- en: How to compute TFs
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何计算TFs
- en: What is a transformation exactly? A transformation is the combination of a translation
    and a rotation in space.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 变换究竟是什么？变换是空间中平移和旋转的组合。
- en: As we are working in 3D, we have three components for the translation (**x**,
    **y**, **z**), and three components for the rotation (**x**, **y**, **z**). To
    find a transformation between two frames, you will need to compute those six elements,
    using 3x3 matrices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在3D空间中工作，我们有三个平移组件（**x**、**y**、**z**），以及三个旋转组件（**x**、**y**、**z**）。要找到两个框架之间的变换，你需要计算这六个元素，使用3x3矩阵。
- en: I won’t go into any mathematical details here, but you can probably guess that
    it won’t be an easy task. Also, you need to compute this transformation for each
    frame, relative to the other frame. This increases the complexity.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里深入数学细节，但你可以猜测这不会是一个容易的任务。此外，你需要为每个框架相对于其他框架计算这个变换。这增加了复杂性。
- en: 'For example, let’s say you need to know where **left_front_wheel** is relative
    to **base_link**. Following the previous TF tree (open the PDF again), you can
    see that you need to follow this order: **base_link**, **left_leg**, **left_base**,
    and **left_front_wheel**.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要知道**left_front_wheel**相对于**base_link**的位置。按照之前的TF树（再次打开PDF），你可以看到你需要遵循以下顺序：**base_link**、**left_leg**、**left_base**和**left_front_wheel**。
- en: 'Let’s visualize that on RViz:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在RViz上可视化这一点：
- en: '![Figure 10.7 – Three transformations between four frames](img/B22403_10_7.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 四个框架之间的三个变换](img/B22403_10_7.jpg)'
- en: Figure 10.7 – Three transformations between four frames
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 四个框架之间的三个变换
- en: You will need to compute three transformations in a row so that you can get
    this **base_link** to **left_front_wheel** transformation. You will have to repeat
    this for each frame relative to all other frames (the complexity then increases
    a lot as you add more frames), and track these over time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要连续计算三个变换，以便得到从**base_link**到**left_front_wheel**的变换。你将不得不对每个相对于所有其他框架的框架重复此操作（随着你添加更多框架，复杂性会大大增加），并且跟踪这些变换随时间的变化。
- en: This sounds like a lot of work. Fortunately, we don’t have to do any of that,
    thanks to the ROS TF functionality. There is a library called **tf2**, and it
    already does that for us.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一项大量的工作。幸运的是，我们不需要做任何这些，多亏了ROS TF功能。有一个名为**tf2**的库，它已经为我们做了这些。
- en: In the end, the biggest challenge with TFs is to understand how they work. You
    will mostly not use TFs directly in your application. Several packages will handle
    that for you. The only thing we need to do is to provide a robot description that
    specifies all the links and TFs for the robot. Then, using a package named **robot_state_publisher**,
    ROS will automatically publish TFs for us. That’s what we will focus on in the
    next two chapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TFs（变换函数）最大的挑战在于理解它们是如何工作的。你通常不会直接在你的应用程序中使用TFs。有几个包会为你处理这个问题。我们唯一需要做的是提供一个机器人描述，该描述指定了机器人的所有链接和TFs。然后，使用名为**robot_state_publisher**的包，ROS将自动为我们发布TFs。这就是我们在下一章将要关注的内容。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we started something a bit different. ROS is not all about
    programming; there are many additional things that make it a great tool for robotics.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了一些不同的事情。ROS不仅仅是编程；还有很多其他东西让它成为机器人领域的优秀工具。
- en: You first discovered a 3D visualization tool used for ROS, named RViz. You will
    use this tool in most of your ROS applications. With RViz, you can visualize a
    robot model, which will be helpful when developing the model by yourself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先发现了一个用于ROS的3D可视化工具，名为RViz。你将在大多数ROS应用程序中使用这个工具。使用RViz，你可以可视化一个机器人模型，这在你自己开发模型时将非常有帮助。
- en: 'Then, you discovered what TFs are, and why they are so important in a ROS application.
    Here’s a quick recap:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你发现了TFs是什么，以及为什么它们在ROS应用程序中如此重要。这里是一个简要的回顾：
- en: We need to keep track of each 3D coordinate frame over time, for the entire
    robotics application (one or several robots).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要跟踪整个机器人应用（一个或多个机器人）中的每个3D坐标系随时间的变化。
- en: Instead of computing the transformations ourselves, we use the ROS TF functionality,
    with the `tf2` library. TFs are published on the `/``tf` topic.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不自己计算变换，而是使用ROS TF功能，通过`tf2`库。TFs在`/tf`主题上发布。
- en: TFs are organized into a structured tree that you can visualize.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFs被组织成一个你可以可视化的结构化树。
- en: A TF defines how two frames are connected, and how they move relative to each
    other, over time.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF定义了两个坐标系如何连接，以及它们随时间如何相对移动。
- en: To specify TFs for a robot, we will have to create a robot model, named *URDF*.
    This robot model will then be used by the **robot_state_publisher** node (we will
    see this a bit later) to publish the TFs. The published TFs will then be used
    by other packages in your application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定机器人的TFs，我们必须创建一个名为*URDF*的机器人模型。然后，这个机器人模型将由**robot_state_publisher**节点（我们稍后会看到）用来发布TFs。发布的TFs将被你的应用程序中的其他包使用。
- en: In the end, we won’t really interact with TFs directly. The most important thing
    in this chapter is to understand what TFs are, and why we need them. This will
    help you understand what you're doing in the next chapter, when you create a robot
    model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实际上不会直接与TFs交互。本章最重要的内容是理解TFs是什么，以及为什么我们需要它们。这将帮助你理解你在下一章创建机器人模型时所做的事情。
- en: If things are still a bit confusing for now, don’t worry too much. Continue
    with the next few chapters, and then come back to this TF chapter again and everything
    will make more sense.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在事情仍然有点令人困惑，不要过于担心。继续阅读接下来的几章，然后再次回到这个TF章节，一切都会更加清晰。
- en: Now, let’s jump to the next chapter and create our first robot model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到下一章，创建我们的第一个机器人模型。
