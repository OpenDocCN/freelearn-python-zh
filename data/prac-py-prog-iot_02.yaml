- en: Setting Up your Development Environment
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: An important yet often overlooked aspect of Python programming is how to correctly
    set up and maintain a Python project and its runtime environment. It is often
    overlooked because it presents as an optional step for the Python ecosystem. And
    while this might be fine for learning Python language fundamentals, it can quickly become
    a problem for more complex projects where we need to maintain separate code bases
    and dependencies to ensure our projects do not interfere with one another, or
    worse as we will discuss, break operating system tools and utilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python编程的一个重要但经常被忽视的方面是如何正确设置和维护Python项目及其运行时环境。它经常被忽视，因为它对于Python生态系统来说是一个可选的步骤。虽然这对于学习Python语言基础知识可能没问题，但对于需要维护独立的代码库和依赖项以确保项目不会相互干扰的更复杂的项目来说，它可能会很快成为一个问题，或者更糟糕的是，像我们将讨论的那样，破坏操作系统工具和实用程序。
- en: So, before we jump into **IoT **code and examples in later chapters, it is so
    very important for us to cover the steps required to set up a Python project and
    its run time environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在后面的章节中，当我们跳入**IoT**代码和示例时，非常重要的是我们覆盖设置Python项目及其运行时环境所需的步骤。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding your Python installation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您的Python安装
- en: Setting up a Python virtual environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Python虚拟环境
- en: Installing Python GPIO packages with `pip`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pip`安装Python GPIO包
- en: Alternative methods of executing a Python script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Python脚本的替代方法
- en: Raspberry Pi GPIO interface configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派GPIO接口配置
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the hands-0n exercises in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章的实践练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: Minimum Python version 3.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中的代码示例所基于的。可以合理地期望代码示例应该在不经修改的情况下在树莓派3型B或不同版本的Raspbian OS上工作，只要您的Python版本是3.5或更高。
- en: The full source code for this book can be found on GitHub at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT). We
    will clone this repository shortly when we come to the *Setting up a Python virtual
    environment* section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的完整源代码可以在GitHub上找到，网址如下：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。当我们来到*设置Python虚拟环境*部分时，我们将很快克隆这个存储库。
- en: Understanding your Python installation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解您的Python安装
- en: In this section, we will find out which versions of Python you have installed
    on your Raspberry Pi. As we will discover, there are two versions of Python that
    come pre-installed on Raspbian OS. Unix-based operating systems (such as Raspbian
    OS) typically have Python version 2 and 3 pre-installed because there are operating-system-level
    utilities built with Python.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将找出您的树莓派上安装了哪些Python版本。正如我们将发现的那样，在Raspbian OS上预装了两个版本的Python。基于Unix的操作系统（如Raspbian
    OS）通常预装了Python 2和3，因为有使用Python构建的操作系统级实用程序。
- en: 'To find out which versions of Python you have on your Raspberry Pi, follow
    these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出您的树莓派上安装了哪些Python版本，请按照以下步骤操作：
- en: 'Open a new Terminal and execute the `python --version` command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并执行`python --version`命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In my example, we see that Python version 2.7.16 has been installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，我们看到Python版本2.7.16已安装。
- en: 'Next, run the `python3 --version` command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`python3 --version`命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In my example, we see that the second version of Python (that is, `python3`,
    with the `3`) that is installed is version 3.7.3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，我们看到已安装的第二个Python版本（即`python3`，带有`3`）是版本3.7.3。
- en: Don't worry if the minor versions (the numbers .7.16 after the 2 and .7.3 after
    3) are not the same; it is the major versions 2 and 3 that are of interest. Python
    2 is a legacy version of Python, while Python 3 is the current and supported version
    of Python at the time of writing. When we are starting a new Python development,
    we will practically always use Python 3 unless there are legacy issues we need
    to contend with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果次要版本（2后面的.7.16和3后面的.7.3）不相同，不要担心；重要的是主要版本2和3。Python 2是Python的旧版本，而Python 3是当前支持的版本，是写作时的Python版本。当我们开始新的Python开发时，我们几乎总是使用Python
    3，除非有我们需要处理的旧问题。
- en: Python 2 officially became end-of-life in January 2020\. It is no longer maintained
    and will not receive any further enhancements, bug fixes, or security patches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2在2020年1月正式终止生命周期。它不再得到维护，也不会再接收任何进一步的增强、错误修复或安全补丁。
- en: If you are an experienced Python programmer, you may be able to discern whether
    a script is written for Python 2 or 3, but it's not always obvious by simply looking
    at a piece of code. Many new-to-Python developers experience frustrations by mixing
    up Python programs and code fragments that are meant for different Python versions.
    Always remember that code written for Python 2 is not guaranteed to be upward-comparable
    with Python 3 without modification.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一位经验丰富的Python程序员，您可能能够辨别脚本是为Python 2还是3编写的，但仅仅通过查看一小段代码通常并不明显。许多刚接触Python的开发人员在混合使用为不同Python版本编写的程序和代码片段时会感到沮丧。请记住，未经修改的Python
    2代码不能保证与Python 3向上兼容。
- en: A quick tip I can share to visually help to determine which Python version a
    code fragment is written for (if the programmer has not made it clear in the code
    comments) is to look for a `print` statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速提示我可以分享的是，要确定一个代码片段是为哪个Python版本编写的（如果程序员在代码注释中没有明确说明），可以查找`print`语句。
- en: 'If you look at the following example, you will see that there are two `print`
    statements. The first `print` statement without the parentheses is a give-away
    that it will only work with Python 2:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看下面的例子，您会发现有两个`print`语句。没有括号的第一个`print`语句表明它只能在Python 2中使用：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course, you can always run the code against both Python 2 and 3 and see what
    happens.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以始终针对Python 2和3运行代码，看看会发生什么。
- en: We have now seen that there are two Python versions available by default on
    Raspbian OS, and made mention that there are system-level utilities that are written
    in Python that reply on these versions. As Python developers, we must take care
    not to disrupt the global Python installations as this can potentially break system-level
    utilities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到Raspbian OS默认提供了两个Python版本，并提到有一些以Python编写的系统级实用程序依赖于这些版本。作为Python开发人员，我们必须小心，不要破坏全局Python安装，因为这可能会破坏系统级实用程序。
- en: We will now turn our attention to a very important Python concept, the Python
    virtual environment, which is the way we isolate or *sandbox* our own Python projects
    from the global installation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把注意力转向一个非常重要的Python概念，即Python虚拟环境，这是我们将自己的Python项目与全局安装隔离或*沙箱*的方式。
- en: Setting up a Python virtual environment
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Python虚拟环境
- en: In this section, we will discuss how Python interacts with your operating system
    installation and cover the steps necessary to set up and configure a Python development
    environment. In addition, as part of our setup process, we will clone the GitHub
    repository that contains all of the code (organized by chapter) for this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Python如何与您的操作系统安装进行交互，并介绍设置和配置Python开发环境所需的步骤。此外，作为设置过程的一部分，我们将克隆包含本书所有代码（按章节组织）的GitHub存储库。
- en: By default, Python and its package management tool, `pip`, operate globally
    at the system level and can create some confusion for Python beginners because
    this global default is in contrast to many other language ecosystems that operate
    locally on a project folder level by default. Unwearyingly working and making
    changes to the global Python environment can break Python-based system-level tools,
    and remedying the situation can become a major headache.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python及其包管理工具`pip`在系统级全局操作，并且可能会对Python初学者造成一些困惑，因为这种全局默认与许多其他语言生态系统形成对比，后者默认在项目文件夹级别本地操作。不经意地在全局Python环境中工作和进行更改可能会破坏基于Python的系统级工具，并且解决这种情况可能会成为一个主要的头痛。
- en: As a Python developer, we use Python virtual environments to sandbox our Python
    projects so they will not adversely interfere with system-level Python utilities
    or other Python projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python开发人员，我们使用Python虚拟环境来隔离我们的Python项目，以便它们不会对系统级Python实用程序或其他Python项目造成不利影响。
- en: In this book, we will be using a virtual environment tool known as `venv`, which
    comes bundled as a built-in module with Python 3.3 and above. There are other
    virtual environment tools around, all with their relative strengths and weaknesses,
    but they all share the common goal of keeping Python dependencies isolated to
    a project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用一个名为`venv`的虚拟环境工具，它作为Python 3.3及以上版本的内置模块捆绑提供。还有其他虚拟环境工具可供选择，它们各自具有相对的优势和劣势，但它们都共享一个共同的目标，即将Python依赖项隔离到一个项目中。
- en: '`virtualenv` and `pipenv` are two alternative virtual environment tool options
    that offer more features than `venv`. These alternatives are well suited for complex
    Python projects and deployments. You''ll find links to these in the *Further reading*
    section at the end of this chapter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtualenv`和`pipenv`是两种替代的虚拟环境工具选项，它们提供比`venv`更多的功能。这些替代方案非常适合复杂的Python项目和部署。您可以在本章末尾的*进一步阅读*部分找到这些链接。'
- en: 'Let''s begin and clone the GitHub repository and create a new Python virtual
    environment for this chapter''s source code. Open a new Terminal window and work
    through the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始克隆GitHub存储库并为本章的源代码创建一个新的Python虚拟环境。打开一个新的终端窗口，并按照以下步骤操作：
- en: 'Change into or create a folder where you want to store this book''s source
    code and execute the following commands. With the last command, we rename the
    cloned folder to be `pyiot`. This has been done to help shorten Terminal command
    examples throughout the book:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到或创建一个您想要存储本书源代码的文件夹，并执行以下命令。使用最后一个命令，我们将克隆的文件夹重命名为`pyiot`。这样做是为了帮助缩短本书中的终端命令示例：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, change into the `chapter01` folder, which contains the code relating
    to this chapter:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，切换到包含与本章相关的代码的`chapter01`文件夹：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following command, which creates a new Python virtual environment
    using the `venv` tool. It''s important that you type `python3` (with the 3) and remember
    that `venv` is only available with Python 3.3 and above:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，使用`venv`工具创建一个新的Python虚拟环境。重要的是您要输入`python3`（带有3），并记住`venv`仅适用于Python
    3.3及以上版本：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The options that we are passing to `python3` include `-m venv`, which tells
    the Python interpreter that we want to run the module named `venv`. The `venv` parameter
    is the name of the *folder* where your virtual environment will be created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`python3`的选项包括`-m venv`，它告诉Python解释器我们要运行名为`venv`的模块。`venv`参数是您的虚拟环境将被创建的*文件夹*的名称。
- en: While it might look confusing at first glance in the preceding command, it's
    a common convention to name a virtual environment's folder `venv`. Later in this
    chapter, in the *Anatomy of a virtual environment *section, we will explore what
    lies beneath the `venv` folder we just created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在前面的命令中乍一看可能会让人困惑，但将虚拟环境的文件夹命名为`venv`是一种常见的约定。本章的*虚拟环境解剖*部分中，我们将探讨刚刚创建的`venv`文件夹下面的内容。
- en: 'To use a Python virtual environment, we must *activate* it, which is accomplished
    with the `activate` command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Python虚拟环境，我们必须*激活*它，这可以通过`activate`命令完成：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When your Terminal has a Python virtual environment activated, all Python-related
    activity is sandboxed to your virtual environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的终端激活了Python虚拟环境时，所有与Python相关的活动都将被隔离到您的虚拟环境中。
- en: Notice in the preceding code that, after activation, the name of the virtual
    environment, `venv`, is shown as part of the Terminal prompt text, that is, `(venv)
    $`. In this book, whenever you see Terminal examples where the prompt is `(venv)
    $`, it's a reminder that commands need to be executed from within an activated
    Python virtual environment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在激活后，虚拟环境的名称`venv`会显示在终端提示文本中，即`(venv) $`。在本书中，每当您看到终端示例中的提示为`(venv) $`时，这是一个提醒，需要从激活的Python虚拟环境中执行命令。
- en: 'Next, execute `which python` (*without* the `3`) in your Terminal, and notice
    that the location of the Python executable is beneath your `venv` folder and if
    you check the version of Python, it''s Python version 3:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的终端中执行`which python`（不带`3`），请注意Python可执行文件的位置位于您的`venv`文件夹下，如果您检查Python的版本，它是Python版本3：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To leave an activated virtual environment, use the `deactivate` command as
    illustrated here:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要离开激活的虚拟环境，请使用`deactivate`命令，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice also that `(venv) $` is no longer part of the Terminal prompt text once
    the virtual environment has been deactivated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，一旦虚拟环境被停用，终端提示文本中的`(venv) $`将不再存在。
- en: Remember to type `deactivate` to leave a virtual environment, not `exit`. If
    you type `exit` in a virtual environment, it will exit the Terminal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要输入`deactivate`来离开虚拟环境，而不是`exit`。如果您在虚拟环境中输入`exit`，它将退出终端。
- en: 'Finally, now that you are outside of our Python virtual environment if you
    execute `which python` *(without* the `3`) and `python --version` again, notice
    we''re back to the default system-level Python interpreter, which is version 2:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，现在您已经退出了我们的Python虚拟环境，如果您执行`which python`（不带`3`）和`python --version`，请注意我们又回到了默认的系统级Python解释器，即版本2：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we just illustrated in the preceding examples, when we ran `python --version` in
    an *activated* virtual environment, we see that it's Python version 3 whereas
    in the last example, at the start of this chapter, the system level, `python --version`,
    was version 2, and we needed to type `python3 --version` for version 3\. In practice,
    `python` (with no number) relates to the default version of Python. Globally,
    this is version 2\. In your virtual environment, we only have one version of Python,
    which is version 3, so it becomes the default.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中所演示的，当我们在*激活*的虚拟环境中运行`python --version`时，我们看到它是Python版本3，而在上一章的最后一个示例中，系统级的`python
    --version`是版本2，我们需要输入`python3 --version`来获取版本3。在实践中，`python`（没有数字）与Python的默认版本相关联。全局来看，这是版本2。在您的虚拟环境中，我们只有一个版本的Python，即版本3，因此它成为默认版本。
- en: A virtual environment created with `venv` inherits (via a symbolic link) the
    global Python interpreter version that it was invoked with (in our case, version
    3 because the command was `python3 -m venv venv`). If you ever need to target
    a specific Python version that is different from the global version, investigate
    the `virtualenv` and `pipenv` virtual environment alternatives.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`venv`创建的虚拟环境继承（通过符号链接）调用它的全局Python解释器版本（在我们的情况下，版本3，因为命令是`python3 -m venv
    venv`）。如果您需要针对与全局版本不同的特定Python版本，可以使用`virtualenv`和`pipenv`虚拟环境替代方案。
- en: We have now seen how to create, activate, and deactivate a Python virtual environment
    and why it is important to use a virtual environment to sandbox Python projects.
    This sandboxing means we can isolate our own Python projects and their library
    dependencies from one another, and it prevents us from potentially disrupting
    the system-level installation of Python and breaking any system-level tools and
    utilities that rely on them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何创建、激活和停用Python虚拟环境，以及为什么使用虚拟环境来隔离Python项目是很重要的。这种隔离意味着我们可以将自己的Python项目及其库依赖与其他项目隔离开来，这样可以防止我们潜在地破坏系统级安装的Python并破坏依赖于它们的系统级工具和实用程序。
- en: Next, we will see how to install and manage Python packages in a virtual environment
    using `pip`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在虚拟环境中使用`pip`来安装和管理Python包。
- en: Installing Python GPIO packages with pip
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pip安装Python GPIO包
- en: In this section, we learn how to install and manage Python *packages* in a Python
    virtual environment you created and explored in the previous section. A Python
    *package* (or *library* if you prefer that term) allows us to extend the core
    Python language with new features and functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在您在上一节中创建和探索的Python虚拟环境中安装和管理Python *包*。Python *包*（或者如果您更喜欢这个术语，*库*）允许我们通过新功能和功能扩展核心Python语言。
- en: 'We will need to install many different packages throughout this book, however,
    for starters and to explore and learn the basic concepts related to package installation
    and management, we will be installing two common GPIO-related packages in this
    section that we will use throughout this book. These two packages are the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们需要安装许多不同的包，但是作为入门，为了探索和学习与包安装和管理相关的基本概念，我们将在本节中安装两个常见的与GPIO相关的包，这些包将在本书中使用。这两个包如下：
- en: The `GPIOZero` library, an entry-level and easy to use GPIO library for controlling
    simple electronics
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOZero`库，一个入门级且易于使用的GPIO库，用于控制简单的电子设备'
- en: The `PiGPIO` library, an advanced GPIO library with many features for more complex
    electronic interfacing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PiGPIO`库，一个高级GPIO库，具有许多功能，用于更复杂的电子接口'
- en: In the Python ecosystem, package management is done with the `pip` command (`pip`
    stands for *Python installs packages*). The official public package repository
    that `pip` queries is known as the *Python Package Index*, or simply `PyPi`, and
    it is available for browsing on the web at [https://pypi.org.](https://pypi.org.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python生态系统中，包管理是通过`pip`命令进行的（`pip`代表*Python installs packages*）。`pip`查询的官方公共包存储库称为*Python
    Package Index*，简称`PyPi`，可以在网上浏览[https://pypi.org.](https://pypi.org.)
- en: Similarly to `python` and `python3`, there is `pip` and `pip3`. `pip` (without
    the number) will be the *default* `pip` command that is matched to the *default*
    `python` command in a given virtual environment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`python`和`python3`，有`pip`和`pip3`。`pip`（没有数字）将是与给定虚拟环境中的*默认*`python`命令匹配的*默认*`pip`命令。
- en: There will be code examples in this book where we will be interacting with your
    Raspberry Pi's GPIO pins, so we need to install a Python package (or two) so that
    your Python code can work with your Raspberry Pi's GPIO pins. For now, we are
    just going to check for and install two GPIO-related packages. In [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*, and [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*, we will cover these GPIO
    packages and other alternatives in greater detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中会有一些代码示例，我们将与树莓派的GPIO引脚进行交互，因此我们需要安装一个或两个Python包，以便你的Python代码可以与树莓派的GPIO引脚一起工作。现在，我们只是要检查并安装两个与GPIO相关的包。在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)和[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中，我们将更详细地介绍这些GPIO包和其他替代方案。
- en: 'In your `chapter01` source code folder, you will find a file named `gpio_pkg_check.py`,
    which is replicated in the following. We will use this file as the basis to learn
    about `pip` and package management in the context of a Python virtual environment.
    This script simply reports the availability of a Python package depending on whether
    using `import` succeeds or raises an exception:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`chapter01`源代码文件夹中，你会找到一个名为`gpio_pkg_check.py`的文件，下面是它的内容。我们将使用这个文件作为学习`pip`和Python虚拟环境中包管理的基础。这个脚本根据`import`是否成功或引发异常来报告Python包的可用性：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's check for the availability of GPIO packages using `gpio_pkg_check.py` and
    with `pip`. I'll kill the suspense by telling you that they're not going to be
    available in your freshly-created virtual environment (yet), however, we are going
    to install them!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpio_pkg_check.py`和`pip`检查GPIO包的可用性。我要打破悬念告诉你，它们还不能在你新建的虚拟环境中使用，但是我们将安装它们！
- en: 'Note: They *are* already installed at the system level if you want to check
    yourself by running this script outside of your virtual environment.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你想在虚拟环境之外运行这个脚本来检查，这些包已经在系统级别安装好了。
- en: 'The following steps will walk us through the process of upgrading `pip`, exploring
    the tool''s options, and installing packages:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将引导我们升级`pip`，探索工具的选项，并安装包：
- en: 'As the first step, we will upgrade the `pip` tool. In a Terminal window, run
    the following command, remembering that all commands that follow must be performed
    in an *activated* virtual environment—meaning you should see the text `(venv)` in
    the Terminal prompt:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们将升级`pip`工具。在终端窗口中，运行以下命令，记住后续的所有命令都必须在*激活*的虚拟环境中执行——这意味着你应该在终端提示符中看到`(venv)`文本：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `upgrade` command may take a minute or two complete and will potentially
    output a lot of text to the Terminal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`upgrade`命令可能需要一两分钟才能完成，并且可能会在终端上输出大量文本。
- en: Are you facing `pip` problems? If you're getting a sea of red errors and exceptions
    when trying to install a package with `pip`, try upgrading the `pip` version as
    a first step using `pip install --upgrade pip`. It is a recommended first step
    after creating a fresh Python virtual environment to upgrade `pip`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到`pip`的问题了吗？如果在使用`pip`安装包时出现大量红色错误和异常，尝试首先升级`pip`版本，使用`pip install --upgrade
    pip`。这是在创建新的Python虚拟环境后推荐的第一步。
- en: 'With `pip` now upgraded, we can see what Python packages are already installed
    in our virtual environment using the `pip list` command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`pip`已经升级，我们可以使用`pip list`命令来查看虚拟环境中已经安装的Python包：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we see in the preceding are the default Python packages in our fresh virtual
    environment. Do not worry if the exact package list or version numbers do not
    match exactly with the example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面我们看到的是我们新建虚拟环境中的默认Python包。如果确切的包列表或版本号与示例不完全匹配，不要担心。
- en: 'Run our Python script with the `python gpio_pkg_check.py` command and observe
    that our GPIO packages are *not* installed:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python gpio_pkg_check.py`命令运行我们的Python脚本，并观察到我们的GPIO包*没有*安装：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To install our two required GPIO packages, we use the `pip install` command
    as shown in the following example:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安装我们需要的两个GPIO包，我们可以使用`pip install`命令，如下例所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, run the `pip list` command again; we will see these new packages are now
    installed in our virtual environment:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行`pip list`命令；我们将看到这些新包现在已经安装在我们的虚拟环境中：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may have noticed that there is a package called `colorzero` (this is a color
    manipulation library) that we did not install. `gpiozero` (version 1.5.0) has
    a dependency on `colorzero`, so `pip` has installed it for us automatically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到有一个叫做`colorzero`的包（这是一个颜色处理库）我们没有安装。`gpiozero`（版本1.5.0）依赖于`colorzero`，所以`pip`已经自动为我们安装了它。
- en: 'Re-run `python gpio_pkg_check.py` and we now see that our Python modules are
    available for import:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行`python gpio_pkg_check.py`，现在我们看到我们的Python模块可以被导入了：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! We now have a virtual environment with two GPIO packages installed. As
    you work on Python projects, you will inevitably install more and more packages
    and want to keep track of them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有了一个安装了两个GPIO包的虚拟环境。在你进行Python项目时，你将不可避免地安装更多的包并希望跟踪它们。
- en: 'Take a snapshot of the packages you have previously installed with the `pip
    freeze` command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip freeze`命令对你之前安装的包进行快照：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example *freezes* all installed packages into a file named `requirements.txt`,
    which is a common filename to use for this purpose.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将所有安装的包冻结到一个名为`requirements.txt`的文件中，这是一个常用的文件名。
- en: 'Look inside the `requirements.txt` file and you will see all of the Python
    packages listed together with their version numbers:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`requirements.txt`文件，你会看到所有的Python包及其版本号一起列出：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the future, if you move your Python project to another machine or a new virtual
    environment, you can use your `requirement.txt` file to install all of your captured
    packages in one go using the `pip install -r requirements.txt` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，如果您将Python项目移动到另一台机器或新的虚拟环境，您可以使用`requirement.txt`文件使用`pip install -r requirements.txt`命令一次性安装所有捕获的软件包。
- en: Our `requirements.txt` example shows we have installed GPIOZero version 1.5.0,
    the current version at the time of writing. This version has a dependency on ColorZero
    version 1.1\. It is possible that different (past or future) versions of GPIOZero
    may have different dependencies than those shown in our example, so your own `requirements.txt`
    file when performing the example exercise may be different.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`requirements.txt`示例显示我们已安装了GPIOZero版本1.5.0，这是写作时的当前版本。该版本依赖于ColorZero版本1.1。可能不同（过去或将来）版本的GPIOZero可能具有与我们示例中所示的不同的依赖关系，因此在执行示例练习时，您自己的`requirements.txt`文件可能会有所不同。
- en: We've now completed the basic installation life cycle of Python packages using `pip`.
    Note that whenever you install new packages with `pip install`, you also need
    to re-run `pip freeze > requirements.txt` to capture the new packages and their
    dependencies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用`pip`进行Python软件包的基本安装生命周期。请注意，每当您使用`pip install`安装新软件包时，您还需要重新运行`pip
    freeze > requirements.txt`来捕获新软件包及其依赖关系。
- en: 'To finish our exploration of `pip` and package management, here are a few other
    common `pip` commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们对`pip`和软件包管理的探索，这里还有一些其他常见的`pip`命令：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Congratulations! We've reached a milestone and covered the essential virtual
    environment principles that you can use for any Python project, even ones that
    are not Raspberry Pi related!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经达到了一个里程碑，并介绍了您可以用于任何Python项目的基本虚拟环境原则，即使这些项目与树莓派无关！
- en: During your Python journey, you will also come across other package installers
    and tools named `easy_install` and `setuptools`. Both have their uses; however,
    it's `pip` that you will rely on most of the time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Python之旅中，您还会遇到其他名为`easy_install`和`setuptools`的软件包安装程序和工具。两者都有其用途；但是，大多数情况下您会依赖`pip`。
- en: Now that we have seen how to create a virtual environment and install packages,
    let's take a look at a typical Python project folder structure such as `~/pyiot/chapter01` and
    discover what lies beneath the `venv` folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建虚拟环境和安装软件包，让我们来看一下典型的Python项目文件夹结构，比如`~/pyiot/chapter01`，并发现`venv`文件夹下面有什么。
- en: Anatomy of a virtual environment
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境的解剖
- en: This section relates to `venv`, which we have been using in this chapter, and will
    apply to `virtualenv` *but not* `pipenv`, which we listed as alternative virtual
    environment tools. The example is also specific to a Raspbian OS and is typical
    of a standard Unix-based OS. It's important to, at a minimum, understand the basic
    structure of a virtual environment deployment since we will be mixing our own
    Python programming code in with the files and folders that make up the virtual
    environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涉及`venv`，这是本章中我们一直在使用的，也适用于`virtualenv`，*但不适用于*我们列出的替代虚拟环境工具`pipenv`。该示例也特定于Raspbian操作系统，并且是标准Unix操作系统的典型情况。至少要了解虚拟环境部署的基本结构，因为我们将把自己的Python编程代码与组成虚拟环境的文件和文件夹混合在一起。
- en: The light weight `venv` tool that comes with Python 3.3 and above is a subset
    of `virtualenv`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级的`venv`工具随Python 3.3及以上版本一起提供，是`virtualenv`的一个子集。
- en: 'Here is the folder structure of our virtual environment. Yep, its a screenshot
    from a Mac. That''s so I could get everything on screen at once:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们虚拟环境的文件夹结构。是的，这是Mac上的屏幕截图。这样我就可以一次性将所有内容显示在屏幕上：
- en: '![](assets/4e81df10-7017-4669-ab95-0317b4f64044.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e81df10-7017-4669-ab95-0317b4f64044.png)'
- en: Figure 1.1 – Contents of a typical venv virtual environment folder
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 典型`venv`虚拟环境文件夹的内容
- en: 'The following points explain the core subfolders that are found within our `~/pyiot/chapter01` folder
    after we ran `python3 -m venv venv` and installed packages using `pip`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点解释了我们在运行`python3 -m venv venv`并使用`pip`安装软件包后，在`~/pyiot/chapter01`文件夹中找到的核心子文件夹：
- en: The `venv `folder contains all of the Python virtual environment files. There
    is no real practical need to be touching anything under this folder manually—let
    the tools do that for you. Remember that the folder is named `venv` only because
    that's what we called it when it was created.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv`文件夹包含所有Python虚拟环境文件。实际上没有必要手动触摸该文件夹下的任何内容 - 让工具为您完成。请记住，该文件夹之所以被命名为`venv`，只是因为在创建时我们这样称呼它。'
- en: The `venv/bin` folder contains the Python interpreter (in the `venv` case, there
    are symbolic links to the system interpreter) and other core Python tools, including
    `pip`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv/bin`文件夹包含Python解释器（在`venv`情况下，有符号链接到系统解释器）和其他核心Python工具，包括`pip`。'
- en: Underneath the `venv/lib` folder are all the sandboxed Python packages for the
    virtual environment, including the GPIOZero and PiGPIO packages we installed using `pip
    install`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`venv/lib`文件夹下面是虚拟环境的所有隔离的Python软件包，包括我们使用`pip install`安装的GPIOZero和PiGPIO软件包。
- en: Our Python source file, `gpio_pkg_check.py`, is in the top-level folder, `~/pyiot/chapter01`;
    however, you can create sub-folders here to help to organize your code and non-code
    files.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的Python源文件`gpio_pkg_check.py`位于顶级文件夹`~/pyiot/chapter01`中，但是您可以在这里创建子文件夹来帮助组织您的代码和非代码文件。
- en: Finally, `requirements.txt` lives by convention in the top project folder.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`requirements.txt`按照惯例存放在顶级项目文件夹中。
- en: The virtual environment folder `venv` does not actually need to be kept in the
    project folder; however, it's often convenient to have it there for activation
    with the `activate` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境文件夹`venv`实际上不需要放在项目文件夹中；但是，通常将其放在那里以便使用`activate`命令进行激活。
- en: Your `venv` folder and anything below it *should not* be added to your source
    version control system, but you should add `requirements.txt`. As long as you
    have a current `requirements.txt` file, you can always recreate your virtual environment
    and reinstate packages to a known state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`venv`文件夹及其下的任何内容*不应*添加到源版本控制系统中，但您应该添加`requirements.txt`。只要有一个当前的`requirements.txt`文件，您就可以随时重新创建您的虚拟环境并将软件包恢复到已知状态。
- en: It's important to understand that, as a Python developer, you will be mixing
    in your own programming code with files and folders that form part of the virtual
    environment system and that you should be pragmatic when selecting which files
    and folders are added to your version control system, should you be using one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，作为Python开发人员，您将在自己的编程代码中混合虚拟环境系统的文件和文件夹，并且在选择添加到您的版本控制系统中的文件和文件夹时应该是务实的，如果您正在使用版本控制系统。
- en: This last point is important since the virtual environment system can amount
    to many megabytes in size (and often many times larger than your program code) that
    does not need versioning (since we can always recreate the virtual environment
    as long as we have a `requirements.txt` file), plus it's host platform-specific
    (that is, there will be differences between Windows, Mac, and Linux), plus there
    will be differences between different virtual environment tools (for example, `venv`
    versus `pipenv`). As such, virtual environments are not generally portable in
    projects that involve many developers working on different computers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点很重要，因为虚拟环境系统的大小可能会达到几兆字节（通常比您的程序代码大几倍），不需要进行版本控制（因为只要有`requirements.txt`文件，我们就可以随时重新创建虚拟环境），而且它是特定于主机平台的（也就是说，在Windows、Mac和Linux之间会有差异），不同的虚拟环境工具之间也会有差异（例如`venv`与`pipenv`）。因此，在涉及许多开发人员在不同计算机上工作的项目中，虚拟环境通常不具备可移植性。
- en: Now that we have briefly explored the file and folders structure and the importance
    of understanding this structure, we will continue and look at alternative ways
    of running a script that is sandboxed to a virtual environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要探讨了文件和文件夹的结构以及理解这种结构的重要性，我们将继续并查看运行沙盒化到虚拟环境的脚本的替代方法。
- en: Alternative methods of executing a Python script
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行Python脚本的替代方法
- en: Let's briefly turn our attention to the alternative ways that we can execute
    a Python script. As we will learn, choosing the appropriate method is all based
    around how and from where you intend to start your script and whether your code
    requires elevated permissions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要关注一下我们可以执行Python脚本的替代方法。正如我们将要了解的那样，选择适当的方法完全取决于您打算从何处启动脚本以及您的代码是否需要提升的权限。
- en: The most common way of running a Python script is from within its virtual environment
    and with the permissions of the currently logged in user. However, there will
    be scenarios where we need to run a script as the root user or from outside an
    activated virtual environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python脚本的最常见方法是在其虚拟环境中以当前登录用户的权限运行。但是，会有一些情况需要以root用户身份运行脚本或者在未激活的虚拟环境之外运行脚本。
- en: 'Here are the ways we will explore:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要探索的方法：
- en: Using `sudo` with virtual environments
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟环境中使用`sudo`
- en: Executing Python scripts outside of their virtual environments
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其虚拟环境之外执行Python脚本
- en: Running a Python script at boot
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时运行Python脚本
- en: Let's start by learning how to run a Python script with root user permissions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习如何以root用户权限运行Python脚本开始。
- en: Using sudo within virtual environments
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在虚拟环境中使用sudo
- en: I'm sure that while working on your Raspberry Pi you have had to execute commands
    in a Terminal with the `sudo` prefix because they required root privileges. If
    you ever need to run a Python script that is in a virtual environment as root,
    you must use the full path to your virtual environment's Python interpreter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在树莓派上工作时，您必须在终端中使用`sudo`前缀来执行命令，因为它们需要root权限。如果您需要以root身份运行虚拟环境中的Python脚本，您必须使用虚拟环境的Python解释器的完整路径。
- en: 'Simply prefixing `sudo` before `python`, as shown in the following example,
    does not work under most circumstances, even if we are in the virtual environment.
    The `sudo` action will use the default Python that''s available to the root user,
    as shown in the second half of the example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，即使我们在虚拟环境中，也不能简单地在`python`之前加上`sudo`，如下例所示。`sudo`操作将使用根用户可用的默认Python，如示例的后半部分所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The correct way to run a script as root is to pass the absolute path to your
    virtual environment''s Python interpreter. We can find the absolute path using
    the `which python` command from inside an activated virtual environment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以root身份运行脚本的正确方法是传递虚拟环境的Python解释器的绝对路径。我们可以使用`which python`命令在激活的虚拟环境中找到绝对路径：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we `sudo` our virtual environment''s Python interpreter and the script
    will run *as* the root user and *within* the content of our virtual environment:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`sudo`来运行虚拟环境的Python解释器，脚本将作为root用户运行，并在我们的虚拟环境中运行：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we'll see how to run a Python script that's sandboxed in a virtual environment
    from outside of its virtual environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何从虚拟环境之外运行沙盒化到虚拟环境的Python脚本。
- en: Executing Python scripts outside of their virtual environments
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其虚拟环境之外执行Python脚本
- en: 'A natural extension to the preceding discussion on `sudo` is *how do I run
    a Python script from outside of its virtual environment?* The answer is the same
    as in the preceding section: just make sure you are using the absolute path to
    your virtual environment''s Python interpreter.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sudo`的前面讨论的自然延伸是*如何从虚拟环境之外运行Python脚本？*答案与前一节相同：只需确保您使用虚拟环境的Python解释器的绝对路径。
- en: 'Note: In the following two examples, we''re not in a virtual environment—there
    is no `$ (venv)` on the prompt. If you still need to exit your Python virtual
    environment, type `deactivate`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在以下两个示例中，我们不在虚拟环境中——提示符上没有`$ (venv)`。如果您仍然需要退出Python虚拟环境，请键入`deactivate`。
- en: 'The following command will run a script as the currently *logged in* user (which,
    by default, is the `pi` user):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将以当前*登录*用户的身份运行脚本（默认为`pi`用户）：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or to run the script as root, prefix `sudo`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者以root身份运行脚本，加上`sudo`前缀：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are using the virtual environment's Python interpreter, we are still
    sandboxed to our virtual environment and any Python packages we installed are
    available.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用虚拟环境的Python解释器，我们仍然被限制在我们的虚拟环境中，并且我们安装的任何Python包都是可用的。
- en: Next, we will learn how to make a Python script run whenever you boot your Raspberry
    Pi.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使Python脚本在您的树莓派启动时运行。
- en: Running a Python script at boot
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在启动时运行Python脚本
- en: There will come a time when you have developed an awesome IoT project and you
    want it to run automatically every time you start your Raspberry Pi. Here is one
    simple way to achieve this using a feature of `cron`, the Unix scheduler. If you
    are not familiar with the basics of `cron`, search the web for cron tutorial—you'll
    find heaps of them. I've provided curated links in the *Further reading* section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，当您开发出一个令人惊叹的IoT项目，并且希望它在每次启动树莓派时自动运行时，您可以使用`cron`的一个功能来实现这一点。如果您不熟悉`cron`的基础知识，请在网上搜索cron教程，您会找到很多。我在*进一步阅读*部分提供了精选链接。
- en: 'Here are the steps to configure cron and make a script run on boot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是配置cron并在启动时运行脚本的步骤：
- en: 'In your project folder, create a bash script. I''ve named it `run_on_boot.sh`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目文件夹中，创建一个bash脚本。我将其命名为`run_on_boot.sh`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This bash script will run a Python script using the absolute paths for both
    the script and its Python interpreter. Also, it captures any script output and
    stores it in a log file. For this example, we're simply going to run and log the
    output of `gpio_pkg_check.py` on boot. It's the last line that ties everything
    together and runs and logs our Python script. The `2>&1` part at the end is necessary
    to ensure that errors, in addition to standard output, are also logged.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bash脚本将使用脚本和其Python解释器的绝对路径运行Python脚本。此外，它会捕获任何脚本输出并将其存储在日志文件中。在这个示例中，我们将简单地在启动时运行和记录`gpio_pkg_check.py`的输出。最后一行将所有内容联系在一起并运行和记录我们的Python脚本。结尾的`2>&1`部分是必要的，以确保错误和标准输出都被记录。
- en: 'Mark the `run_on_boot.sh` file as an executable file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`run_on_boot.sh`文件标记为可执行文件：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are not familiar with the `chmod` command (*chmod* means change mode),
    what we are doing is giving the operating system permission to execute the `run_on_boot.sh` file.
    The `u+x` parameters mean *for the current **U**ser, make the file e**X**ecutable.* To
    learn more about `chmod`, you can type `chmod --help` or `man chmod` in the Terminal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`chmod`命令（*chmod*表示更改模式），我们正在给操作系统权限来执行`run_on_boot.sh`文件。`u+x`参数表示*对当前**用户，使文件可执行*。要了解更多关于`chmod`的信息，您可以在终端中输入`chmod
    --help`或`man chmod`。
- en: 'Edit your `crontab` file, which is the file where cron scheduling rules are
    stored:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑您的`crontab`文件，这是存储`cron`调度规则的文件：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following entry to your `crontab` file, using the absolute path to
    the `run_on_boot.sh` bash script we created in *step 1*:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下条目添加到您的`crontab`文件中，使用在*步骤1*中创建的`run_on_boot.sh` bash脚本的绝对路径：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do not forget the `&` character at the end of the line. This makes sure the
    script runs in the background.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在行尾加上`&`字符。这样可以确保脚本在后台运行。
- en: 'Run the `run_on_boot.sh` file manually in a Terminal to make sure it works.
    The `gpio_pkg_check.log` file should be created and contains the output of the
    Python script:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中手动运行`run_on_boot.sh`文件，以确保它可以正常工作。`gpio_pkg_check.log`文件应该被创建，并包含Python脚本的输出：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Reboot your Raspberry Pi:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动您的树莓派：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once your Raspberry Pi has finished restarting, the `gpio_pkg_check.log` file should
    now contain additional lines, indicating that the script did indeed run at boot:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的树莓派完成重新启动，`gpio_pkg_check.log`文件现在应该包含额外的行，表明脚本确实在启动时运行：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you are not seeing the additional output in the `gpio_pkg_check.log` file
    after a reboot, double-check that the absolute path you entered in `crontab` is
    correct and that it works manually as per *step 5*. Also, review the system log
    file,  `/var/log/syslog`, and search for the text, `run_on_boot.sh`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新启动后在`gpio_pkg_check.log`文件中看不到额外的输出，请仔细检查您在`crontab`中输入的绝对路径是否正确，并且按照*步骤5*手动运行。还要查看系统日志文件`/var/log/syslog`，并搜索文本`run_on_boot.sh`。
- en: Our cron**-**based example of running a script on boot is one of many options
    that are available in Unix-based operating systems such as Raspbian. Another common
    and more advanced option using `systemd` can be found on the Raspberry Pi website
    at [https://www.raspberrypi.org/documentation/linux/usage/systemd.md](https://www.raspberrypi.org/documentation/linux/usage/systemd.md).
    Irrespective of the option you prefer, the key point to remember is to ensure
    your Python scripts run from within their virtual environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于cron的在启动时运行脚本的示例是Unix操作系统（如Raspbian）中的众多选项之一。另一个常见且更高级的选项是使用`systemd`，可以在树莓派网站上找到[https://www.raspberrypi.org/documentation/linux/usage/systemd.md](https://www.raspberrypi.org/documentation/linux/usage/systemd.md)。无论您喜欢哪种选项，要记住的关键点是确保您的Python脚本在其虚拟环境中运行。
- en: We have now learned alternative methods to run a Python script, which will help
    you in the future to correctly run your Python-based IoT projects after they are
    developed or start them when your Raspberry Pi boots if required.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了运行Python脚本的替代方法，这将帮助您在将来正确地运行开发完成的基于Python的IoT项目，或者在需要时在树莓派启动时启动它们。
- en: Next, we will now move on to making sure your Raspberry Pi is set up and configured
    correctly for the GPIO and electronic interfacing that we'll be diving into in
    the next chapter, [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and* *IoT*,and subsequent chapters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保您的树莓派已正确设置和配置GPIO和电子接口，以便在下一章节[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中进行深入讨论，*使用Python和IoT入门*，以及后续章节。
- en: Configuring the GPIO interface on our Raspberry Pi
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置我们的树莓派上的GPIO接口
- en: Before we can start working with Python GPIO libraries and controlling electronics,
    one task we need to perform is to enable the GPIO interfaces on your Raspberry
    Pi. Even though we have installed Python packages for GPIO control, we have not
    told Raspbian OS that we want to use the Raspberry Pi's GPIO Pins for specific
    cases. Let's do that now.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Python GPIO库和控制电子设备之前，我们需要执行的一个任务是在您的Raspberry Pi上启用GPIO接口。尽管我们已经为GPIO控制安装了Python包，但我们还没有告诉Raspbian
    OS我们想要在特定情况下使用树莓派的GPIO引脚。现在让我们来做这件事。
- en: 'Here are the steps to follow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤：
- en: 'From your Raspbian desktop, navigate to the Raspberry menu | Preferences | Raspberry
    Pi Configuration, as shown here in *Figure 1.2*:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的Raspbian桌面，导航到Raspberry菜单|首选项|Raspberry Pi配置，如*图1.2*所示：
- en: '![](assets/ec07cbbe-83f0-4ffb-93d9-c7f6dd7ec3e3.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec07cbbe-83f0-4ffb-93d9-c7f6dd7ec3e3.png)'
- en: Figure 1.2 – Location of the Raspberry Pi Configuration menu itemAlternatively,
    interfaces can be managed at the command line with the `sudo raspi-config` command and
    navigating to the Interfacing Options menu.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - Raspberry Pi配置菜单项的位置或者，可以使用`sudo raspi-config`命令在命令行中管理接口，并导航到“接口选项”菜单。
- en: 'Enable all of the interfaces as shown in the following screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图中显示的方式启用所有接口：
- en: '![](assets/cd70385e-b006-4542-ba96-111b83dd132e.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cd70385e-b006-4542-ba96-111b83dd132e.png)'
- en: Figure 1.3 - Raspberry Pi Configuration Dialog
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - Raspberry Pi配置对话框
- en: Click the OK button.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”按钮。
- en: After you click the OK button, you may be prompted to reboot your Raspberry Pi;
    however, *do not* confirm the reboot just yet because there is one more task we
    need to perform first. We'll look at that next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击“确定”按钮后，您可能会被提示重新启动您的Raspberry Pi；然而，*不要*立即确认重新启动，因为我们还有一个任务需要先执行。我们接下来会看到这个任务。
- en: Configuring the PiGPIO daemon
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置PiGPIO守护程序
- en: We also need to start the PiGPIO daemon, which is a system service that needs
    to be running so that we can use the PiGPIO GPIO client library, which we will
    start using next in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要启动PiGPIO守护程序，这是一个系统服务，需要运行，以便我们可以使用PiGPIO GPIO客户端库，我们将在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中开始使用它，*使用Python和物联网入门*。
- en: Architecturally, the PiGPIO library comprises two parts—a server service and
    a client that communicates over local pipes or sockets to the service. We will
    cover more about this basic architecture in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，PiGPIO库包括两部分——一个服务器服务和一个客户端，它们通过本地管道或套接字与服务通信。我们将在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中更多地介绍这个基本架构，*将您的Raspberry
    Pi连接到物理世界*。
- en: 'Execute the following in a Terminal. This will start the PiGPIO daemon and
    will ensure that the PiGPIO daemon is started automatically when your Raspberry
    Pi boots:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中执行以下操作。这将启动PiGPIO守护程序，并确保当您的Raspberry Pi启动时，PiGPIO守护程序会自动启动：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, it's time to reboot your Raspberry Pi! So, take a break while your Raspberry
    Pi restarts. You deserve it because we have covered a lot!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候重新启动您的Raspberry Pi了！所以，在您的Raspberry Pi重新启动时休息一下。您值得拥有这个休息，因为我们已经涵盖了很多内容！
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the Python ecosystem that is part of a typical
    Unix-based operating system such as Raspbian OS and learned that Python is a core
    element of the operating system tooling. We then covered how to create and navigate
    a Python virtual environment so that we can *sandbox* our Python projects so they
    will not interfere with one another or the system-level Python ecosystem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了Python生态系统，这是典型的基于Unix的操作系统（如Raspbian OS）的一部分，并了解到Python是操作系统工具的核心元素。然后，我们介绍了如何创建和导航Python虚拟环境，以便我们可以*隔离*我们的Python项目，使它们不会相互干扰或与系统级Python生态系统相互干扰。
- en: Next, we learned how to use the Python package management tool, `pip`, to install
    and manage Python library dependencies from within a virtual environment, and
    we did this by installing the GPIOZero and PiGPIO libraries. And since there will
    be times that we need to execute a Python script as the root user, from outside
    its virtual environment or during boot up, we also covered these various techniques.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用Python包管理工具`pip`在虚拟环境中安装和管理Python库依赖项，并通过安装GPIOZero和PiGPIO库来实现这一点。由于我们将需要在某些时候以根用户身份执行Python脚本，从其虚拟环境外部或在启动时，我们也介绍了这些各种技术。
- en: By default, Raspbian does not have all of its GPIO interfaces enabled, so we
    performed the configuration needed to enable these features so that they are readily
    available for use in later chapters. We also started and learned how to set up
    the PiGPIO daemon service so that it starts every time your Raspberry Pi is booted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Raspbian没有启用所有的GPIO接口，因此我们进行了必要的配置以启用这些功能，以便它们在后续章节中可以随时使用。我们还启动并学习了如何设置PiGPIO守护程序服务，以便它在每次启动Raspberry
    Pi时都会启动。
- en: The core knowledge you have gained in this chapter will help you to correctly
    set up and navigate sandboxed Python development environments for your own IoT
    (and non-IoT) projects and safely install library dependencies so they do not
    interfere with your other Python projects or the system-level installation of
    Python. Your understanding of different ways of executing a Python program will
    also help you to run your projects with elevated user permissions (that is, as
    the root user), or at boot, should your project have these requirements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所获得的核心知识将帮助您正确设置和导航沙盒化的Python开发环境，用于您自己的物联网(IoT)（和非IoT）项目，并安全地安装库依赖项，以便它们不会干扰您的其他Python项目或Python的系统级安装。您对执行Python程序的不同方式的理解也将帮助您以提升的用户权限（即作为根用户）或在启动时运行您的项目，如果您的项目有这些要求的话。
- en: Next, in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting Started
    with Python and IoT,* we will jump straight into Python and electronics and create
    an end-to-end internet-enabled program that can control an LED over the internet.
    We will take a look at two alternative ways of flashing an LED using the GPIOZero
    and PiGPIO GPIO libraries before connecting our LED to the internet by using an online
    service, *dweet.io*, as our networking layer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml) *Python和物联网入门*中，我们将直接进入Python和电子领域，并创建一个端到端的互联网程序，可以通过互联网控制LED。在将LED连接到互联网之前，我们将使用GPIOZero和PiGPIO
    GPIO库的两种替代方法来闪烁LED，然后通过在线服务*dweet.io*将LED连接到互联网作为我们的网络层。
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一些问题列表，供您测试对本章材料的了解。您将在书的*评估*部分找到答案：
- en: What is the main reason why you should always use a virtual environment for
    your Python projects?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您应该始终为Python项目使用虚拟环境的主要原因是什么？
- en: Do you need to or should you place the virtual environment folder (that is,
    `venv`) under version control?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您是否需要或应该将虚拟环境文件夹（即`venv`）放入版本控制？
- en: Why create a `requirements.txt` file?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要创建`requirements.txt`文件？
- en: You need to run a Python script as the root user. What step must you take to
    ensure that the script executes in its intended virtual environment context?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要以root用户身份运行Python脚本。为确保脚本在其预期的虚拟环境上执行，您必须采取哪些步骤？
- en: What does the `source venv/bin/activate` command do?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`source venv/bin/activate`命令是做什么的？'
- en: You are in an activated virtual environment. What is the command to leave the
    virtual environment and return to the host shell?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您处于已激活的虚拟环境中。离开虚拟环境并返回主机shell的命令是什么？
- en: You created a Python project and virtual environment in PyCharm. Can you work
    on and run the project's Python scripts in a Terminal?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在PyCharm中创建了一个Python项目和虚拟环境。您能在终端上处理和运行项目的Python脚本吗？
- en: You want a GUI tool to edit and test Python code on your Raspberry Pi but do
    not have PyCharm installed. What pre-installed tool that comes with Python and
    Raspbian could you use?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想要一个GUI工具来编辑和测试树莓派上的Python代码，但没有安装PyCharm。您可以使用Python和Raspbian预安装的工具。
- en: You've advanced in your Python and electronics knowledge and are trying to hook
    up a device using I2C to your Raspberry Pi but you cannot get it to work. What
    might be the problem and how do you address it?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在Python和电子知识方面有所进步，并尝试使用I2C将设备连接到树莓派，但无法使其工作。可能的问题是什么，以及您如何解决它？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We covered the `venv` virtual environment tool in this chapter. Here are links
    to its official documentation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章介绍了`venv`虚拟环境工具。以下是它的官方文档链接：
- en: '`venv` documentation: [https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv`文档：[https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)'
- en: '`venv` tutorial: [https://docs.python.org/3/tutorial/venv.html](https://docs.python.org/3/tutorial/venv.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv`教程：[https://docs.python.org/3/tutorial/venv.html](https://docs.python.org/3/tutorial/venv.html)'
- en: 'If you would like to learn about the `virtualenv` and `pipenv` alternative
    virtual environment tools, here is their official documentation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解`virtualenv`和`pipenv`替代虚拟环境工具，这里是它们的官方文档：
- en: '`virtualenv` home page: [https://virtualenv.pypa.io/en/latest](https://virtualenv.pypa.io/en/latest/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualenv`主页：[https://virtualenv.pypa.io/en/latest](https://virtualenv.pypa.io/en/latest/)'
- en: '`pipenv` home page: [https://docs.pipenv.org/en/latest](https://docs.pipenv.org/en/latest/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipenv`主页：[https://docs.pipenv.org/en/latest](https://docs.pipenv.org/en/latest/)'
- en: 'The following is a link to the *Python Packaging Guide*. Here you will find
    a comprehensive guide regarding Python package management, including `pip` and
    the easy-install/setup tools alternatives:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*Python包装指南*的链接。在这里，您将找到有关Python包管理的全面指南，包括`pip`和easy-install/setup工具的替代方法：
- en: Python Packaging User Guide: [https://packaging.python.org](https://packaging.python.org)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包装用户指南：[https://packaging.python.org](https://packaging.python.org)
- en: 'If you wish to learn more about scheduling and cron, here are two resources
    to get you started:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望了解更多关于调度和cron的知识，这里有两个资源供您开始：
- en: An overview of cron syntax (and a GUI tool): [https://www.raspberrypi.org/documentation/linux/usage/cron.md ](https://www.raspberrypi.org/documentation/linux/usage/cron.md)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cron语法概述（以及GUI工具）：[https://www.raspberrypi.org/documentation/linux/usage/cron.md](https://www.raspberrypi.org/documentation/linux/usage/cron.md)
- en: 'A detailed tutorial on cron syntax: [https://opensource.com/article/17/11/how-use-cron-linux](https://opensource.com/article/17/11/how-use-cron-linux)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于cron语法的详细教程：[https://opensource.com/article/17/11/how-use-cron-linux](https://opensource.com/article/17/11/how-use-cron-linux)
