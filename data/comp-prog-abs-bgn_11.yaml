- en: '*Chapter 9:* When Things Go Wrong – Bugs and Exceptions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章：当事情出错时 – 虫子和异常*'
- en: Writing software can be hard, and when we write it, we will make errors. We
    will, unintentionally, introduce bugs to our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件可能很困难，当我们编写它时，我们会犯错误。我们无意中会在我们的应用程序中引入虫子。
- en: Some of them will be rather trivial to find and fix, but some can set us off
    on a wild goose chase through the code where we try to understand the reasons
    as to why things are not working the way we expect them to.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些可能很容易找到和修复，但有些可能会让我们在代码中迷失方向，试图理解为什么事情没有按照我们预期的那样工作。
- en: It is not unheard of that people spend days, and sometimes weeks, attempting
    to track down a bug. To be able to find bugs in our applications, we will need
    to understand what kinds exist and how they affect the way our applications run.
    This chapter will help us recognize them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人们花费数天甚至数周时间试图追踪虫子的情况并不少见。为了能够在我们的应用程序中找到虫子，我们需要了解存在哪些类型的虫子以及它们如何影响我们应用程序的运行方式。本章将帮助我们识别它们。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将了解以下主题：
- en: Understanding software bugs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件虫子
- en: Finding bugs using a debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器查找虫子
- en: Working with exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与异常一起工作
- en: Handling exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: In this chapter, we will also talk a bit about variables and data types. Look
    back at [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working
    with Data – Variables*, if you need to refresh your memory about these.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将简要讨论变量和数据类型。如果你需要刷新对这些内容的记忆，请回顾[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*，与数据一起工作
    – 变量*。
- en: Understanding software bugs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件虫子
- en: When writing software, things will not always go according to plan. The programs
    we create will contain bugs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，事情并不总是按照计划进行。我们创建的程序将包含虫子。
- en: 'The term *bug* to describe an error, flaw, or fault in a program dates way
    long before we had any computers. It has been recorded as a part of engineering
    jargon since the 1870s. In a letter, dated 1878, to an associate, Thomas Edison
    wrote the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用*虫子*这个词来描述程序中的错误、缺陷或故障，其历史远在我们拥有任何计算机之前。自1870年代以来，它已被记录为工程术语的一部分。在一封日期为1878年的信中，托马斯·爱迪生写给一位同事如下：
- en: '"It has been just so in all of my inventions. The first step is an intuition,
    and comes with a burst, then difficulties arise—this thing gives out and [it is]
    then that "Bugs"—as such, little faults and difficulties are called—show themselves
    and months of intense watching, study, and labor are requisite before commercial
    success or failure is certainly reached."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '"在我的所有发明中，情况都是如此。第一步是直觉，然后是一阵爆发，接着困难出现——这个玩意儿崩溃了，然后就是所谓的“虫子”——这样的小错误和困难就会显现出来，在商业成功或失败确定之前，需要数月的紧张观察、研究和劳动。"'
- en: The first mechanical pinball game, Baffle Ball, was advertised as being *free
    from bugs* in 1931, and in 1944, Isaac Asimov used the term *bug* to describe
    issues with a robot in the short story **Catch That Rabbit**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款机械弹球游戏，Baffle Ball，在1931年宣传时声称是*无虫*的，而在1944年，艾萨克·阿西莫夫在短篇小说**捕捉那只兔子**中使用了*虫子*这个词来描述机器人出现的问题。
- en: One story that has often been given tribute for being the origin of the term
    bug in software comes from Grace Hopper. In 1946, she joined the Harvard Faculty
    at the Computation Laboratory, where she continued her work on the Mark I and
    Mark II computers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个经常被赋予敬意的故事，讲述的是软件中“虫子”一词的起源，这个故事来自格蕾丝·霍珀。1946年，她加入了哈佛大学的计算实验室，在那里她继续在Mark
    I和Mark II计算机上工作。
- en: 'The Mark II computer produced errors and, after some searching, the operators
    found that the cause was a moth trapped in a relay. The moth was carefully removed
    and taped to the logbook. Under the moth, the following was written:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Mark II计算机产生了错误，经过一番搜索，操作员发现原因是一只蛾子被困在继电器中。蛾子被小心地取下并贴在日志簿上。在蛾子下面，写下了以下内容：
- en: '"First actual case of a bug being found."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"首次发现虫子的实际案例。"'
- en: 'The date in the logbook was September 9 1947, and that was the first time we
    had the term *bug* used in computer science:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 日志簿上的日期是1947年9月9日，这是第一次在计算机科学中使用*虫子*这个词：
- en: '![Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical
    Center Online Library Photograph (Public Domain [PD])](img/Figure_9.1_B15554.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 1947年在Mark II计算机中发现的蛾子 – 美国海军历史中心在线图书馆照片（公有领域 [PD]）](img/Figure_9.1_B15554.jpg)'
- en: Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical
    Center Online Library Photograph (Public Domain [PD])
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 1947年在马克II计算机中发现的蛾子 – 美国海军历史中心在线图书馆照片（公有领域 [PD]）
- en: The likelihood that an actual bug will make our programs produce the wrong output
    is almost nonexistent. It is much more likely that the source of the error is
    ourselves.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的虫子（bug）导致我们的程序产生错误输出的可能性几乎不存在。更可能的是，错误的源头是我们自己。
- en: There are many different types of bugs. To understand some of them, and to see
    what damage a bug can cause, we'll look at two incredibly expensive software bugs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的虫子。为了理解其中的一些，并看到虫子可能造成的损害，我们将查看两个极其昂贵的软件虫子。
- en: NASA's Mars Climate Orbiter
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 美国国家航空航天局的火星气候轨道器
- en: This is one of the most famous bugs in the history of computing. The Mars Climate
    Orbiter was a space probe that was launched by NASA on December 11, 1998\. Its
    mission was to study the Martian climate, atmosphere, and surface changes. On
    September 23, 1999, all communication with the spacecraft was lost. It is not
    known if it was destroyed in the Martian atmosphere or if it continued existing
    in space.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有史以来最著名的计算机错误之一。火星气候轨道器是美国国家航空航天局（NASA）于1998年12月11日发射的一颗太空探测器。它的任务是研究火星的气候、大气和表面变化。1999年9月23日，与该航天器的所有通信都丢失了。不清楚它是否在火星大气中被摧毁，或者它是否继续存在于太空中。
- en: On November 10, 1999, the Mars Climate Orbiter Mishap Investigation Board released
    a Phase I report. In it, it was made clear that the reason for the disaster was
    a bug in a piece of ground-based software provided by one of NASA's contractors.
    This software produced a result in the United States customary units (units used
    in the US, such as inch, foot, and mile) while the NASA software expected the
    input to be in SI units (the metric system).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年11月10日，火星气候轨道器事故调查委员会发布了第一阶段报告。在报告中，明确指出灾难的原因是NASA承包商提供的一块地面软件中的错误。该软件以美国习惯单位（如英寸、英尺和英里）产生结果，而NASA的软件期望输入的是国际单位制（公制系统）。
- en: The cost of this mistake was estimated at 125 million US dollars.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这次错误的成本估计为1.25亿美元。
- en: The Morris worm
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 莫里斯蠕虫
- en: In 1988, a Cornell University student named Robert Morris released a computer
    worm that was designed as a harmless experiment. It exploited some flaws in the
    Unix operating system's sendmail program that were spread from computer to computer.
    When a new computer was found, the program checked to see if this computer was
    already infected. Morris understood that this would be an easy way for system
    administrators to stop the spread and help the system identify if it was infected
    already. To compensate for this, Morris designed his worm so that it infected
    any computer that responded with a yes 1 out of 7 times.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 1988年，康奈尔大学的一名学生罗伯特·莫里斯发布了一个设计为无害实验的计算机蠕虫。它利用了Unix操作系统sendmail程序的一些漏洞，这些漏洞从一台计算机传播到另一台计算机。当发现一台新计算机时，程序会检查这台计算机是否已经感染。莫里斯明白这将是一个系统管理员停止传播并帮助系统确定是否已经感染的好方法。为了补偿这一点，莫里斯设计他的蠕虫，使其在7次中有1次响应“是”的任何计算机上都会感染。
- en: This was the big mistake that made the worm not only spread rapidly across the
    internet but also infect the same computers multiple times, disrupting the target
    machines. The Morris worm was the first known internet worm, and the cost of cleaning
    up the mess it created was an estimated 100 million US dollars. Morris was fined
    10,000 US dollars but made a good career later; he is now a professor at the Massachusetts
    Institute of Technology. A disk with the source code of the worm is on display
    at the Computer History Museum in California.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是导致蠕虫不仅迅速在互联网上传播，而且多次感染同一台计算机，破坏目标机器的大错误。莫里斯蠕虫是已知的第一种互联网蠕虫，清理它造成的混乱的成本估计为1亿美元。莫里斯被罚款10,000美元，但后来事业有成；他现在是麻省理工学院的教授。带有蠕虫源代码的磁盘在加利福尼亚州的计算机历史博物馆展出。
- en: Both of these examples show us that even a small error can have enormous consequences.
    In the first example, one single programmer made an error that went unnoticed
    in the final product. The biggest problem here is not the error that was introduced
    but that no one saw it and stopped it before it was too late.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子都告诉我们，即使是小小的错误也可能产生巨大的后果。在第一个例子中，一个程序员犯了一个错误，在最终产品中被忽视。这里最大的问题不是引入的错误，而是没有人看到它并在它太晚之前阻止它。
- en: As for the second example, here, we had a person who created something on his
    own. The nature of this program was that no one should know about the program.
    The problem here is that he had no organization behind him with other developers
    who could help him make a plan for how the program should work. It is extremely
    hard to think about all the consequences one decision will have if you are alone
    and don't have anyone else to discuss your ideas with. In the latter case, having
    other people around him would hopefully result in them telling him that the idea
    as a whole was bad and should never have been done in the first place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第二个例子，这里，我们有一个自己创造了一些东西的人。这个程序的本质是没有人应该知道这个程序。这里的问题是，他没有一个组织支持他，没有其他开发者可以帮助他制定程序应该如何工作的计划。如果你独自一人，没有其他人讨论你的想法，那么考虑一个决策将带来的所有后果是非常困难的。在后一种情况下，如果周围有其他人，他们可能会告诉他，整个想法是糟糕的，从一开始就不应该这样做。
- en: Here, we have seen two examples of what a bug is, but there are so many other
    kinds around. Due to this, the first thing we should do is attempt to define what
    a bug is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了两个关于错误的例子，但还有许多其他类型的错误。因此，我们应该做的第一件事是尝试定义什么是错误。
- en: Defining a software bug
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义软件错误
- en: 'To understand what a software bug is, we can first look at Techopedia''s definition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解什么是软件错误，我们首先可以看看Techopedia的定义：
- en: '*"A software bug is a problem causing a program to crash or produce invalid
    output. The problem is caused by insufficient or erroneous logic. A bug can be
    an error, mistake, defect, or fault, which may cause failure or deviation from
    expected results."*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '"软件错误是导致程序崩溃或产生无效输出的问题。这个问题是由逻辑不足或错误引起的。错误可能是一个错误、失误、缺陷或故障，可能导致失败或偏离预期结果。"'
- en: 'As we can see from this definition, a bug is caused by software that is not
    functioning correctly. This can result in incorrect or unexpected results. We
    can understand this if, say, we provide a program with some well-defined data.
    Here, we expect a certain result back. If the result is not what we expect, the
    reason can either be that there is something wrong with the data we provided or
    there is something wrong with the program. Let''s say we, for example, provide
    a calculator app with the following data:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义中我们可以看出，错误是由不正确运行的软件引起的。这可能导致不正确或意外的结果。如果我们向程序提供一些定义良好的数据，比如，我们可以理解这一点。在这里，我们期望得到一个特定的结果。如果结果不是我们期望的，原因可能是我们提供的数据有问题，或者程序本身有问题。比如说，我们，例如，向计算器应用程序提供以下数据：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we will expect the following result:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们期望以下结果：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we get anything else, we can say that there is a bug in our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到其他任何东西，我们可以说我们的应用程序中存在错误。
- en: The definition also says that a program can behave in unintended ways. This
    is when we expect a program to do one thing, but it turns out that it does something
    completely different. If we have a program that should turn down the thermostat
    in our home when it's reached a certain temperature, but it turns it up, then
    that would be a bug.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义还说明程序可能会以未预料的方式表现。这就是当我们期望程序做某件事时，但它却做了完全不同的事情。如果我们有一个程序，当室内温度达到一定值时应该降低恒温器，但它却将其调高，那么这就会是一个错误。
- en: Why do we have bugs in our software? There isn't a single answer to this. To
    understand this, we will need to define some different types of bugs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们的软件中会有错误？没有单一的答案。为了理解这一点，我们需要定义不同类型的错误。
- en: Understanding types of software bugs
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件错误的类型
- en: There are many different ways we can classify bugs. Here, we will look at some
    common types, see what they are, and see what they can look like.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以许多不同的方式对错误进行分类。在这里，我们将探讨一些常见的类型，看看它们是什么，以及它们可能看起来像什么。
- en: Arithmetic errors
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术错误
- en: Arithmetic bugs, as the name suggests, have to do with arithmetic operations.
    There are a few things we should look out for, as outlined in the following sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，算术错误与算术运算有关。以下几节中概述了一些我们应该注意的事项。
- en: Division by zero
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零除
- en: One such thing is division by zero. This is not only related to computers as
    we can also never perform a division where the divisor is zero. In mathematics,
    dividing by zero has no meaning, because if we do ![](img/Formula_09_001.png),
    we will get 3\. If we multiply 3 and 2, we will get 6 back. But if we take ![](img/Formula_09_002.png),
    there is no number we can multiply by zero to get back to 6.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子就是除以零。这不仅与计算机有关，我们也不能执行除数为零的除法。在数学中，除以零没有意义，因为如果我们做 ![](img/Formula_09_001.png)，我们会得到3。如果我们乘以3和2，我们会得到6。但如果我们做
    ![](img/Formula_09_002.png)，没有数字我们可以乘以零来得到6。
- en: This might seem simple enough, but sometimes, it happens anyway, especially
    when we are working with variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来足够简单，但有时，它仍然会发生，尤其是在我们处理变量时。
- en: 'Let''s assume that we have two variables that get their value somewhere in
    our application, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个变量，它们在我们的应用程序的某个地方获得值，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Later on in the program, we perform some calculations, maybe with some other
    variables, it might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序稍后部分，我们执行一些计算，可能与其他变量一起，可能看起来像这样：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the `current_temperature` variable now has the same value as `y`, which is
    `14` in our case, we will store the result, `0`, back in `y`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`current_temperature`变量现在与`y`有相同的值，在我们的例子中是`14`，我们将结果`0`存储回`y`。
- en: 'If we then did something like this, our application will crash:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做了类似这样的事情，我们的应用程序将会崩溃：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason for this is that we are dividing by zero. It might not be obvious
    that `y` is zero, so the problem is not easy to spot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们在除以零。`y`是零可能并不明显，所以这个问题并不容易发现。
- en: Arithmetic overflow/underflow
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术溢出/下溢
- en: In [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091), *Working with
    Data – Variables*, in the *Primitive data types* section, we talked about integer
    types and that they could have a fixed size. What that means is that some integer
    types have a predefined size that describes how much memory they will use. This
    also gives a variable of this type a maximum and minimum value. As long as we
    are storing values between the maximum and minimum value, there will be no problem,
    but what happens if we try to store a value that is larger or smaller than these
    values? Let's look at an example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)，“与数据一起工作 – 变量”部分，我们讨论了整型类型，并且它们可以有固定的大小。这意味着某些整型类型有一个预定义的大小，它描述了它们将使用多少内存。这也给这种类型的变量一个最大值和最小值。只要我们存储在最大值和最小值之间，就不会有问题，但如果我们尝试存储一个比这些值大或小的值会发生什么？让我们看看一个例子。
- en: We will now assume that we are using a programming language that has a data
    type called byte. This data type can store values between -128 and 127.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们假设我们正在使用一种具有名为byte的数据类型的编程语言。这种数据类型可以存储介于-128和127之间的值。
- en: 'We can create a variable of this type and assign it a value as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建这种类型的变量并给它赋值如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, what would happen if we increased this variable by one?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们增加这个变量一个值会发生什么？
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Naturally, we expect 127 + 1 will result in 128\. To our surprise, it is -128.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们期望127 + 1的结果是128。但出乎我们的意料，它是-128。
- en: The reason for this is that when we are at the maximum value a data type can
    handle and increase it by one, we will end up at the smallest number it can handle;
    in this case, -128\. If we had increased it by 2 instead of 1, we would have ended
    up with -127.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于当我们处于数据类型可以处理的最大值并增加它时，我们会到达它可以处理的最小数字；在这种情况下，-128。如果我们增加它2而不是1，我们会得到-127。
- en: This is an overflow error. If we were at the lowest value the data type can
    handle and decrease the value by one, we would go to the largest value of this
    data type. This is called an underflow error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个溢出错误。如果我们处于数据类型可以处理的最小值，并减去一个值，我们会到达这个数据类型可以处理的最大值。这被称为下溢错误。
- en: Loss of precision
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精度丢失
- en: As we mentioned in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables,* floating-point numbers are something that is
    tricky for computers to work with, and we are always faced with the risk of losing
    precision when it comes to rounding off a value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)“与数据一起工作 – 变量”中提到的，浮点数是计算机难以处理的东西，我们总是面临在舍入值时丢失精度的风险。
- en: In some languages, this can become obvious.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，这可能会变得明显。
- en: 'Let''s assume we have this code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The expected output of this program would, of course, be this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的预期输出当然是这样的：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To our surprise, some languages will instead give us this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 令我们惊讶的是，一些语言会给出这样的结果：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the computer showing the problems it has with floating-point numbers.
    If you need a refresher on how this works, go back to [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*, and read the section about floating-point numbers
    under the *Numeric type* heading.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算机显示它在浮点数方面的问题。如果您需要回顾这是如何工作的，请回到 [*第 6 章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)，*与数据一起工作
    – 变量*，并阅读 *数值类型* 下关于浮点数的部分。
- en: We could argue that an error of 0.0000000000000004 is not much, but what if
    we were working with several of these results and added them together? This error
    would now accumulate and soon, we will have a value that is way off.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争论说，0.0000000000000004 的误差并不大，但如果我们正在处理几个这样的结果并将它们相加呢？现在，这个误差会累积，很快我们就会得到一个偏离很大的值。
- en: These three are the most common arithmetic errors we will find in software.
    The next group of errors are not as fun for us programmers as they are introduced
    when our logic is incorrect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个是我们将在软件中遇到的最常见的算术错误。下一组错误对于我们程序员来说并不那么有趣，因为它们是在我们的逻辑错误时引入的。
- en: Logical errors
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑错误
- en: A logical error will usually not make a program crash but produce an unintended
    result. Unfortunately for us, there are a lot of opportunities to make logical
    errors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑错误通常不会使程序崩溃，但会产生意外的结果。不幸的是，我们有很多机会犯逻辑错误。
- en: 'We could, for example, accidentally use the wrong operator. An example would
    be if we wanted to check if somebody''s age was above 18, but we did this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会不小心使用错误的运算符。一个例子是如果我们想检查某人的年龄是否大于 18，但我们这样做：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another common thing is to forget to use less than or equal to or greater than
    or equal to. Here, we could write something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的事情是忘记使用小于等于或大于等于。在这里，我们可以写这样：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is incorrect as we actually wanted to check if the age was greater or
    equal to 18, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不正确的，因为我们实际上想检查年龄是否大于或等于 18，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another common error is to use one equals sign instead of two. Some languages
    will let us do something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是使用一个等号而不是两个。一些语言会允许我们这样做：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we intended to use the equal to operator, ==, but instead, we used the
    assignment operator, =. Some languages will interpret this as assigning value
    to age. This will give us two problems. First, we might enter the `if` statement,
    even if, in reality, we shouldn't. The other problem is that the value that was
    in the `age` variable now will be overwritten by the value `20`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们本想使用等于运算符，==，但反而使用了赋值运算符，=。一些语言会将这解释为将值赋给年龄。这将给我们带来两个问题。首先，我们可能会进入 `if`
    语句，即使实际上我们不应该这样做。另一个问题是，现在 `age` 变量中的值将被值 `20` 覆盖。
- en: One thing that has always amazed me is how hard it can be to get the logical
    operators right. Even though they are only two, it is very common that we use
    one instead of the other. Yes, even I do that at times.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一直让我感到惊讶的一件事是，正确使用逻辑运算符是多么困难。尽管它们只有两个，但我们经常用其中一个代替另一个。是的，我有时也会这样做。
- en: 'If we intend to check if the age is above `12` and below `20`, we might write
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算检查年龄是否在 `12` 到 `20` 之间，我们可能会写这样：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, what we wanted to do was this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想要做的是这样：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first example will always be true, as age will always be either greater
    than `12` or less than `20`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子总是正确的，因为年龄总是大于 `12` 或小于 `20`。
- en: These are just some examples of logical errors. They can be hard to find as
    the code is valid, meaning that the program will run, but its behavior will be
    unexpected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是逻辑错误的一些例子。由于代码是有效的，意味着程序可以运行，但其行为将是不预期的，因此它们可能很难找到。
- en: An easier group of errors to amend is when the code is written so it can't run
    because we are breaking the language syntax rules. Let's take a look at these
    in more detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编写得无法运行，因为我们违反了语言语法规则时，更容易修正的错误组出现了。让我们更详细地看看这些。
- en: Syntax errors
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: The rules that tell us how code should be written in a particular language are
    called its syntax. When we write code that does not follow the syntax rules, we
    get what is called a syntax error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们如何在特定语言中编写代码的规则被称为其语法。当我们编写的代码不遵循语法规则时，我们得到的就是所谓的语法错误。
- en: These are rather easy to spot compared to many other errors as the compiler
    or interpreter will tell us where the problem is and also give us a hint about
    what the error is.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他错误相比，这些错误相对容易发现，因为编译器或解释器会告诉我们问题所在，并给出关于错误的一些提示。
- en: Let's look at some syntax errors and investigate what message we get back that
    can assist us in fixing the error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些语法错误，并调查我们得到哪些消息可以帮助我们修复错误。
- en: Here is one syntax error. Can you spot it?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个语法错误。你能找到它吗？
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are trying to print a string, but we forgot the closing quote. Languages
    will report this error differently. As we will see, the message we get back does
    not always direct us to the real error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图打印一个字符串，但我们忘记了关闭引号。不同的语言会以不同的方式报告这个错误。正如我们将看到的，我们得到的消息并不总是直接指向真正的错误。
- en: 'Here are four examples from four different programming languages – Python,
    Go, C#, and JavaScript, respectively:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了四个不同编程语言的例子 – Python、Go、C#和JavaScript，分别：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second and third are talking about newline, while the first and last ones
    are talking about strings. We will need to learn the messages we get back from
    the language we are using. All of them will also direct us to where the error
    was discovered. In different formats, we are directed to line 1, column 12\.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个讨论的是换行符，而第一个和最后一个讨论的是字符串。我们需要了解我们使用的语言返回的消息。所有这些都会指引我们到错误被发现的位置。在不同的格式中，我们被指引到第1行，第12列。
- en: The location that's given is not always where the actual error is, it is where
    the compiler/interpreter discovered the error. If you don't find anything at the
    location given, look at the line above or sometimes some lines above this location.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的位置并不总是实际错误所在的地方，而是编译器/解释器发现错误的地方。如果你在给定的位置找不到任何东西，请查看上一行或有时是这一位置上方的一些行。
- en: 'We know from earlier chapters that we cannot name variables with a number as
    its first character. Let''s do that anyway and do something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中我们知道，我们不能用数字作为变量名的第一个字符。但让我们试试，然后做些像这样的事情：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will give us messages like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出如下消息：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see, some languages call these errors syntax errors, while others
    will name them things such as compilation errors. Again, we will need to learn
    what the language we are using is calling these errors as it will help us identify
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一些语言将这些错误称为语法错误，而其他语言则会将其称为编译错误等。再次强调，我们需要了解我们使用的语言是如何称呼这些错误的，因为这有助于我们识别它们。
- en: Often, our editor will assist us in finding syntax errors by marking them even
    before we run the application. It uses the same technique as a spellchecker in
    a MS Word processor – a wiggly red line below the error.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的编辑器会在我们运行应用程序之前帮助我们找到语法错误，甚至标记它们。它使用的技术与MS Word处理器中的拼写检查器相同 – 在错误下方有一条波浪形红线。
- en: 'Look at the following screenshot. Here, we can see that the editor had marked
    a syntax error before we tried to run the program:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图。在这里，我们可以看到在尝试运行程序之前，编辑器已经标记了一个语法错误：
- en: '![Figure 9.2 –  An editor showing a syntax error in the programming language
    Python](img/Figure_9.2_B15554_Swiggly_line.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 –  一个编辑器显示编程语言Python中的语法错误](img/Figure_9.2_B15554_Swiggly_line.jpg)'
- en: Figure 9.2 –  An editor showing a syntax error in the programming language Python
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 –  一个编辑器显示编程语言Python中的语法错误
- en: Syntax errors are, as mentioned previously, rather easy to find as the program
    will not run and we will be directed to a location close to where the error is.
    But how do we find bugs when we have logical errors? We have tools for this called
    debuggers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误，如前所述，通常很容易找到，因为程序将无法运行，并且我们会被指引到错误发生附近的位置。但当我们遇到逻辑错误时，我们该如何找到错误呢？我们为此有专门的工具，称为调试器。
- en: Finding bugs using a debugger
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器查找错误
- en: A debugger is a tool that can help us see what happens when a program is running.
    As we have already mentioned, some bugs can be hard to find and understand just
    by running the program. Often, we will discover a strange behavior in the program,
    but it might not be obvious what the reason behind this behavior is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是一种可以帮助我们看到程序运行时发生了什么的工具。正如我们已经提到的，仅通过运行程序，一些错误可能很难找到和理解。通常，我们会在程序中发现一些奇怪的行为，但可能并不明显是什么原因导致了这种行为。
- en: A debugger is an application that is tailored for a particular programming language
    and can be used to pause the application at a specified code line. At this point,
    we can inspect what values all the variables have.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是一个针对特定编程语言定制的应用程序，可以用来在指定的代码行处暂停应用程序。此时，我们可以检查所有变量的值。
- en: We can also resume the execution of the program or execute it one line at a
    time to see what happens.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以恢复程序的执行，或者逐行执行以查看会发生什么。
- en: 'Let''s try using a debugger. To do this, we first need to pick a language and
    then write a small program that contains a logical error. We can take one of the
    errors that we previously looked at:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用调试器。为此，我们首先需要选择一种语言，然后编写一个小程序，其中包含一个逻辑错误。我们可以选择我们之前查看过的错误之一：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remember that in this example, we accidentally used `or` instead of `and`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这个例子中，我们意外地使用了`or`而不是`and`。
- en: 'Let''s write this program in Python. In the following screenshot, we can see
    what it looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Python编写这个程序。在以下屏幕截图中，我们可以看到它的样子：
- en: '![Figure 9.3 – A small program written in Python that contains a logical error](img/Figure_9.3_B15554.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 包含逻辑错误的Python小程序](img/Figure_9.3_B15554.jpg)'
- en: Figure 9.3 – A small program written in Python that contains a logical error
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 包含逻辑错误的Python小程序
- en: On the first line, we declare (remember that declaring a variable means that
    we are creating it) a variable called `age` and assign the value `17` to it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们声明（记住声明一个变量意味着我们正在创建它）一个名为`age`的变量，并将其值`17`赋给它。
- en: Then comes our `if` statement, where we're checking if the age is greater than
    `12` or less than `20`. The error here is that we used `or`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我们的`if`语句，我们在这里检查年龄是否大于`12`或小于`20`。这里的错误是我们使用了`or`。
- en: 'When running this program, we get the expected output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个程序时，我们得到预期的输出：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we now change the program, that is, we assign another value to age, say
    `24`, and run it, it will not give us the predicted result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在更改程序，也就是说，我们将另一个值赋给年龄，比如说`24`，然后运行它，它将不会给出预期的结果：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see the changed program in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到更改后的程序：
- en: '![Figure 9.4 – The same program with another value for age](img/Figure_9.4_B15554.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 具有不同年龄值的相同程序](img/Figure_9.4_B15554.jpg)'
- en: Figure 9.4 – The same program with another value for age
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 具有不同年龄值的相同程序
- en: Now, let's use a debugger and explore this error. The first thing we need to
    do is set a breakpoint.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用调试器并探索这个错误。我们首先需要做的事情是设置一个断点。
- en: Breakpoints
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: A breakpoint is a way for us to say, run the program to this point, then pause
    it and show me the status of the program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是我们用来告诉程序运行到这一点，然后暂停并显示程序状态的途径。
- en: 'In the following screenshot, we can see that we have a breakpoint on the line
    containing an `if` statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们可以看到我们在包含`if`语句的行上有一个断点：
- en: '![Figure 9.5 –  A program with a breakpoint on line 3](img/Figure_9.5_B15554.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 在第3行设置断点的程序](img/Figure_9.5_B15554.jpg)'
- en: Figure 9.5 –  A program with a breakpoint on line 3
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 在第3行设置断点的程序
- en: 'If we now run the program, it will stop when it reaches this line. At this
    point, the line that contains the breakpoint has still not executed. It will look
    like what''s shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，它将在到达这一行时停止。此时，包含断点的行尚未执行。它看起来如下面的屏幕截图所示：
- en: '![Figure 9.6 – The debugger has stopped at the breakpoint](img/Figure_9.6_B15554.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 调试器已停止在断点上](img/Figure_9.6_B15554.jpg)'
- en: Figure 9.6 – The debugger has stopped at the breakpoint
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 调试器已停止在断点上
- en: The line we are about to execute is marked with a blue line. Also, note that
    this debugger is showing the `age` value in gray on line 1\. This helps us understand
    what value it currently has.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将执行的行用蓝色线条标记。此外，请注意，这个调试器在第1行以灰色显示了`age`的值。这有助于我们了解它当前具有的值。
- en: 'If we zoom out a bit, we will see that we have some other tools that have popped
    up as the program paused at this line. We can see what it looks like in the following
    screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微放大一点，我们会看到一些其他工具在程序暂停在这一行时出现。我们可以在以下屏幕截图中看到它的样子：
- en: '![Figure 9.7 – The debugger tools](img/Figure_9.7_B15554.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 调试器工具](img/Figure_9.7_B15554.jpg)'
- en: Figure 9.7 – The debugger tools
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 调试器工具
- en: 'What we see here there are several tools that are provided to us by the debugger
    application. Let''s understand what they consist of:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到调试器应用程序为我们提供的一些工具。让我们了解它们由什么组成：
- en: To the right, we see a section marked **Variables**. Here, we can see all the
    variables that are currently defined and what values they have.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧，我们看到一个标记为**变量**的部分。在这里，我们可以看到所有当前定义的变量以及它们的值。
- en: Above this window, we can see some arrows pointing in different directions.
    They are used to advance the program one step. We have some options here. The
    first one is the arrow that first goes up and then goes down (marked as **1**
    in the preceding screenshot). This is called step over. If we have a function
    call on this line, step over will not jump to that function. Instead, it will
    call that function, run all the code within it, and then stop again when it returns
    to where we currently are.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个窗口上方，我们可以看到一些指向不同方向的箭头。它们用于将程序向前推进一步。这里有一些选项。第一个是先向上然后向下的箭头（在先前的截图中被标记为**1**）。这被称为步过。如果我们在这行有函数调用，步过不会跳转到那个函数。相反，它会调用那个函数，运行其中的所有代码，然后当我们返回到当前的位置时再次停止。
- en: The next arrow, the one pointing straight down, is step into (marked as **2**).
    This will, if we have a function on this line, jump to that function and let us
    step through it.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个箭头，指向直下的箭头是进入步骤（标记为**2**）。如果我们在这行有函数，它将跳转到那个函数并允许我们逐步执行它。
- en: We can ignore the two arrows that follow and instead look at the one pointing
    straight up (marked as **3**). This one is called step out. We can use this one
    if we have stepped into a function and changed our minds.  It will run all the
    code in the function and stop again when we go back to the location we came from.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以忽略接下来的两个箭头，而是查看指向直上的箭头（标记为**3**）。这个被称为退出步骤。如果我们已经进入了一个函数并改变了主意，我们可以使用这个功能。它将运行函数中的所有代码，并在我们返回到原来的位置时再次停止。
- en: To the far left, we have some other tools that will restart the program (marked
    as **4**), resume the execution of the program (marked as **5**), pause a running
    program (marked as **6**), stop the program (marked as **7**), allow us to view
    all the breakpoints we currently have in the program (marked as **8**), and ignore
    all the breakpoints and continue to run (marked as **9**).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最左侧，有一些其他工具可以重新启动程序（标记为**4**），恢复程序的执行（标记为**5**），暂停正在运行的程序（标记为**6**），停止程序（标记为**7**），允许我们查看程序中当前的所有断点（标记为**8**），以及忽略所有断点并继续运行（标记为**9**）。
- en: 'For our problem, none of these tools will be able to help us. We know that
    the program will enter the `if` statement as the output was as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的问题，这些工具中没有一个能帮到我们。我们知道程序将进入`if`语句，因为输出如下：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead, there is another tool that might help us. In the following screenshot,
    we can see it marked with a rectangle:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 而另有一个工具可能对我们有帮助。在下面的截图中，我们可以看到它被一个矩形标记出来：
- en: '![Figure 9.8 – The evaluate expression button](img/Figure_9.8_B15554.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 评估表达式按钮](img/Figure_9.8_B15554.jpg)'
- en: Figure 9.8 – The evaluate expression button
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 评估表达式按钮
- en: 'This tool, which looks like a small calculator, is the evaluate expression
    tool. If we click it, we will see a window like the one shown in the following
    screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来像小计算器的工具是评估表达式工具。如果我们点击它，我们将看到如下截图所示的窗口：
- en: '![Figure 9.9 – The evaluate expression window](img/Figure_9.9_B15554.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 评估表达式窗口](img/Figure_9.9_B15554.jpg)'
- en: Figure 9.9 – The evaluate expression window
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 评估表达式窗口
- en: 'In the top field, we can enter an expression. This can help us understand what
    is happening. We are currently on this line:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部字段中，我们可以输入一个表达式。这可以帮助我们理解正在发生的事情。我们目前在这一行：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we enter a part of this expression into the evaluation expression tool,
    it will show us the result. Let''s take the first part of this `if` statement.
    Entering it into the tool will look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个表达式的某一部分输入到评估表达式工具中，它将显示结果。让我们以这个`if`语句的第一部分为例。将其输入到工具中看起来如下：
- en: '![Figure 9.10 – Evaluating an expression](img/Figure_9.10_B15554.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 评估一个表达式](img/Figure_9.10_B15554.jpg)'
- en: Figure 9.10 – Evaluating an expression
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 评估一个表达式
- en: Here, we can see that this part of the `if` statement is true.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个`if`语句的部分是正确的。
- en: 'If we now do the same with the second part, we will see that the result is
    false, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在对第二部分做同样的操作，我们将看到结果为假，如下截图所示：
- en: '![Figure 9.11 – Evaluating another expression](img/Figure_9.11_B15554.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 评估另一个表达式](img/Figure_9.11_B15554.jpg)'
- en: Figure 9.11 – Evaluating another expression
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 评估另一个表达式
- en: 'We can now take both of these statements, since we have written them in the
    code, and check the result, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查这两条语句的结果，因为我们已经在代码中编写了它们，如下面的屏幕截图所示：
- en: '![Figure 9.12 – Evaluating the full expression](img/Figure_9.12_B15554.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 评估整个表达式](img/Figure_9.12_B15554.jpg)'
- en: Figure 9.12 – Evaluating the full expression
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 评估整个表达式
- en: Here, we can see that the result of the full expression is true, even though
    the value is greater than the last part of the condition, `20`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到整个表达式的结果是 `true`，即使值大于条件的最后一部分，即 `20`。
- en: We can now suspect that the culprit is `or`. Let's change it to an `and` and
    see the result.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以怀疑罪魁祸首是 `or`。让我们将其更改为 `and` 并看看结果。
- en: 'In the following screenshot, we can see that the result is now evaluated to
    `false`, which is the value we expected:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到结果现在被评估为 `false`，这是我们预期的值：
- en: '![Figure 9.13 – Evaluating the expression with and instead of or](img/Figure_9.13_B15554.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 使用 or 而不是 and 评估表达式](img/Figure_9.13_B15554.jpg)'
- en: Figure 9.13 – Evaluating the expression with and instead of or
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 使用 or 而不是 and 评估表达式
- en: We can now stop the debugger and change our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以停止调试器并更改我们的代码。
- en: This was one example of when the debugger can help us understand a problem.
    We will frequently run into errors like this one, and what the problem is might
    not be obvious to us right away. As a programmer, we should learn to use the debugger,
    what features it has to offer, and how we can use it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用调试器帮助我们理解问题的一个例子。我们经常会遇到这样的错误，而问题可能一开始并不明显。作为程序员，我们应该学会使用调试器，了解它提供的功能，以及我们如何使用它。
- en: Sometimes, we have other types of errors where the syntax is correct, but still,
    the program will crash. These are called exceptions. We will move on to those
    next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会有其他类型的错误，尽管语法是正确的，但程序仍然会崩溃。这些被称为异常。我们将继续讨论这些内容。
- en: Working with exceptions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: An **exception** (short for **exceptional event** or **exceptional condition**)
    is an error or an unexpected event that occurs while a program is running. It
    is caused by a condition in the software where the program has reached a state
    where it can no longer run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常**（简称**异常事件**或**异常条件**）是指在程序运行期间发生的错误或意外事件。它是由于软件中的某种条件导致的，使得程序达到了无法继续运行的状态。'
- en: There are many reasons we can get an exception. One example could be if our
    program needs to read data from a file, but the file is not where it is supposed
    to be. Since the program has a reason to read the data from this file, a failure
    to do so will put the application in a state where it can no longer guarantee
    that its output will be correct. The best option, in this case, is just to halt
    the program and give back an error that hopefully instructs us about what the
    problem is so we can fix it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到许多导致异常的原因。一个例子可能是，如果我们的程序需要从文件中读取数据，但文件不在它应该的位置。由于程序有理由从该文件中读取数据，未能这样做将使应用程序处于无法保证其输出正确性的状态。在这种情况下，最好的选择就是停止程序并返回一个错误，希望这个错误能指导我们解决问题，以便我们可以修复它。
- en: No software developer wants to write an application that crashes. It can make
    the users of the application lose unsaved work, though the consequences might
    be even worse, depending on the nature of the program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 没有软件开发者愿意编写一个会崩溃的应用程序。尽管后果可能更严重，取决于程序的性质，但应用程序的用户可能会丢失未保存的工作。
- en: Soon, we will talk about how we can handle exceptions so that they don't crash
    our program. But before we do that, let's explore exceptions a bit so that we
    have an understanding of how they work.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将讨论如何处理异常，以便它们不会使我们的程序崩溃。但在我们这样做之前，让我们更深入地了解异常，以便我们了解它们是如何工作的。
- en: Let's look at some common reasons we get exceptions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们得到异常的一些常见原因。
- en: Common reasons for exceptions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常的常见原因
- en: 'As we saw, a missing file can be one reason we get an exception. Another common
    reason is that when we are trying to index into a sequence, we use an index that
    is larger than the sequence. Let''s take a look at an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，缺少文件可能是我们遇到异常的一个原因。另一个常见的原因是，当我们试图对一个序列进行索引时，我们使用了一个比序列更大的索引。让我们来看一个例子：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we have an array (you can read more about array''s in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*,
    Working with Data – Variables*, in the *Composite type* section). It contains
    four values; in this case, four names. We can index into this array to retrieve
    a single value, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个数组（你可以在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*，处理数据
    – 变量*，在*复合类型*部分中了解更多关于数组的信息）。它包含四个值；在这种情况下，四个名字。我们可以通过以下方式索引到这个数组以检索单个值：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will give us the following output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that the index value for the first item is 0, not 1, so the third item,
    `Cara`, has index 2.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，第一个项目的索引值是0，而不是1，所以第三个项目“Cara”的索引是2。
- en: What will happen if we use an index value that is greater than the number of
    items we have, like this?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个大于我们拥有的项目数量的索引值，会发生什么？
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is no value at this location, so the program cannot fetch it for us. The
    syntax is correct, and if we had enough values, it would work perfectly fine.
    But this time, it won't, as we have used an index for something that does not
    exist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个位置没有值，所以程序无法为我们获取它。语法是正确的，如果我们有足够的值，它将完美地工作。但这次，它不会，因为我们使用了一个不存在的索引。
- en: 'The program cannot continue at this point as it cannot guess what it should
    do. We have given an instruction that says that we want a value from this location.
    The programming language cannot just come up with a value for us. The most sensible
    thing to do at this point is to just end the program and wait for it to give us
    an error. This error might look something like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 程序无法在这个点继续运行，因为它无法猜测它应该做什么。我们给出了一个指令，表示我们想要从这个位置获取一个值。编程语言不能为我们随意生成一个值。在这种情况下，最明智的做法是直接结束程序并等待它给出错误。这个错误可能看起来像这样：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is an exception. We can see it in the output as it clearly says `IndexOutOfBoundException`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异常。我们可以在输出中看到它，因为它清楚地写着`IndexOutOfBoundException`。
- en: How much we use exceptions, and how many different exceptions we will need to
    deal with the different issues available, will differ greatly between languages.
    Some, such as Java, make heavy use of exceptions. C++, on the other hand, has
    just a handful of built-in exceptions. Then, we have languages such as Go that
    don't have exceptions at all, but instead will let a function return an error
    type alongside the real return value from the function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用异常的多少，以及我们需要处理不同问题的不同异常的数量，在语言之间有很大差异。有些语言，如Java，大量使用异常。另一方面，C++只有少数内置异常。然后，我们有像Go这样的语言，根本不使用异常，而是让函数返回一个错误类型，与函数的真实返回值一起。
- en: Some of the errors that we already have seen in this chapter will also generate
    exceptions. One such exception will happen if we divide something by zero.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到的一些错误也会生成异常。如果我们将某个数除以零，就会发生这样的异常。
- en: Most languages support exceptions. Even if the number of exceptions a programming
    language has differs, the way they work will be pretty much the same, no matter
    what language we are using. The names will differ, as well as what kinds of exceptions
    we have, but the way we work with them will be the same.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都支持异常。即使编程语言中异常的数量不同，它们的工作方式在大多数情况下都会很相似，无论我们使用什么语言。名称将不同，以及我们拥有的异常类型也会不同，但我们的处理方式将是相同的。
- en: At times, it can be hard to understand the output we get from an exception.
    The reason for this is that when we get an exception, something called the call
    stack is also printed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，理解我们从异常中获得的输出可能很困难。原因是当我们遇到异常时，还会打印出称为调用栈的东西。
- en: Exceptions and the call stack
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常和调用栈
- en: 'Imagine that we have a program and that in it, we have a `main` function. This
    function is calling another function that calls another function, and so on. We
    will have something like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个程序，并且在这个程序中，我们有一个`main`函数。这个函数正在调用另一个函数，该函数又调用另一个函数，以此类推。我们将有如下所示的内容：
- en: '![Figure 9.14 – A function that calls a function that calls a function, and
    so on](img/Figure_9.14_B15554.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 一个调用函数的函数，然后又调用另一个函数，以此类推](img/Figure_9.14_B15554.jpg)'
- en: Figure 9.14 – A function that calls a function that calls a function, and so
    on
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 一个调用函数的函数，然后又调用另一个函数，以此类推
- en: Keeping track of where we are in this chain of function calls is called the
    call stack, and that is handled by the programming language when we run the program.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪我们在函数调用链中的位置被称为调用栈，当程序运行时由编程语言处理。
- en: Now, imagine that we get an exception in the last function called **function
    c**. This function will now exit immediately and return to where it was called.
    That is **function b**. This function will also exit as soon as the control gets
    handed back to it, and we will be returned to where we came from. This time, it
    is **function a**. Again, this function will be terminated immediately, and we
    are returned to the **main** function. The last thing that will happen is that
    this function will also end. Since this was the first function that was called
    in this application, the application as a whole will end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们在最后一个调用的**function c**函数中遇到了异常。这个函数将立即退出并返回到它被调用的地方。那就是**function b**。这个函数也会在控制权交还给它时立即退出，然后我们会返回到原来的地方。这次，是**function
    a**。同样，这个函数也会立即终止，然后我们返回到**main**函数。最后发生的事情是这个函数也会结束。由于这是在这个应用程序中首先被调用的函数，整个应用程序将结束。
- en: The reason why all the functions will exit is that none of them handle the exception.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都会退出的原因是没有一个函数处理了异常。
- en: Now, we will get not only the exception information printed to the screen but
    also the call stack.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将不仅会在屏幕上打印出异常信息，还会打印出调用栈。
- en: 'To illustrate this, let''s use a very simple program like the following one:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们使用一个非常简单的程序，如下所示：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a rather silly program, but it will illustrate what will happen. At
    the bottom, we have a function called `main`. The `main` function will be called
    automatically when we run this program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当愚蠢的程序，但它将说明会发生什么。在底部，我们有一个名为`main`的函数。当我们运行这个程序时，`main`函数将被自动调用。
- en: Inside the `main` function, we call the function named function `a`. This function
    will call `function b`, which calls `function c`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们调用名为`function a`的函数。这个函数将调用`function b`，它再调用`function c`。
- en: When we enter `function c`, `function b` is still running and is waiting for
    `function c` to finish. The same thing is true for `function a`, which waits for
    `function b`. The `main` function is waiting for `function a` to finish, so at
    this point, we have four active functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入`function c`函数时，`function b`仍在运行并等待`function c`完成。对于`function a`也是一样，它等待`function
    b`完成。`main`函数等待`function a`完成，所以在这个点上，我们有四个正在运行的功能。
- en: Now, inside `function c`, we perform a division by zero, causing an exception
    to go off.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`function c`函数内部，我们执行了一个除以零的操作，导致抛出了一个异常。
- en: At this point, `function c` will exit immediately. Control will be handed back
    to `function b`, which will exit, giving the control back to `function a`, which
    exits back to `main`, and finally, the program will exit.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`function c`将立即退出。控制权将交还给`function b`，它将退出，然后将控制权交还给`function a`，它将退出回到`main`函数，最后程序将退出。
- en: 'The output we''ll get will look something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到的输出将类似于以下内容：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, all the function calls are there. How this is displayed will
    differ from language to language. Some will print all the functions in the opposite
    order. Again, this is something we will need to learn when we pick up a new language.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有的函数调用都在那里。如何显示将因语言而异。有些语言会以相反的顺序打印所有函数。这又是一件我们在学习新语言时需要学习的事情。
- en: 'The reason we get all this information is that it can help us figure out where
    things went wrong. Even if the error occurred in `function c`, the reason it happened
    might originate somewhere else. Let''s assume that the program looked as follows
    instead:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到所有这些信息的原因是它可以帮助我们找出问题所在。即使错误发生在`function c`中，它发生的原因可能起源于其他地方。让我们假设程序看起来如下所示：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, `function c` takes two arguments, and it uses these to perform the calculation.
    This happens when `function c` is called from `function b`. The problem arises
    when we pass in `10` and `0` as arguments to the call.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`function c`接受两个参数，并使用这些参数进行计算。这发生在从`function b`调用`function c`时。问题出现在我们传递`10`和`0`作为参数调用时。
- en: Since the data has its origins in `function b`, this is where the problem came
    from. `function c` does not know the origins of these two values. They might come
    from some user input, they might have been read from a file, or they may have
    come from any other source.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据起源于`function b`，问题就出在这里。`function c`不知道这两个值的来源。它们可能来自一些用户输入，可能已经从文件中读取，或者可能来自任何其他来源。
- en: To fully understand the origins of this problem, we will need the information
    that we get from the call stack as it tells us how we ended up in `function c`
    when the error occurred.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解这个问题的根源，我们需要从调用栈中获得信息，因为它告诉我们当错误发生时，我们是如何到达`function c`的。
- en: But what if we don't want the program to crash? No problem. We can write code
    that will handle exceptions. Let's look at that next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不希望程序崩溃呢？没问题。我们可以编写处理异常的代码。让我们看看下一个例子。
- en: Handling exceptions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: To understand how we can handle exceptions, we must first understand what the
    origins of a problem might be. It is only when we have understood this that we
    can insert measures to handle them correctly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何处理异常，我们首先必须理解问题的根源可能是什么。只有当我们理解了这一点，我们才能采取适当的措施来正确处理它们。
- en: 'Let''s return to our function that divides two values. Let''s say this function
    takes two arguments, as it did in our previous example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前例子中除以两个值的函数。假设这个函数接受两个参数，就像我们之前的例子一样：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should assume that this function does something more than just print this
    single line. We can mark it out with some comments, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该假设这个函数除了打印这一行之外，还做了一些其他的事情。我们可以用一些注释来标记它，如下所示：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We know that as this function divides two values, we might get an exception
    if `y` is given a value of `0`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当这个函数对两个值进行除法运算时，如果`y`被赋予`0`的值，我们可能会遇到异常。
- en: The first thing we should ask ourselves is if this is the best place to handle
    the problem. It could be, but most likely, it is not. This function is getting
    two values sent to it as arguments. Several parts of the application might use
    the function, so it has no way of knowing the source of the data that is being
    sent to it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该问自己的是，这是处理问题的最佳位置吗？可能是，但更有可能的是，它不是。这个函数接收两个作为参数传递给它。应用程序的多个部分可能会使用这个函数，因此它无法知道发送给它的数据的来源。
- en: 'What we can do, though, is check if `y` is equal to zero before we perform
    the division. Let''s do that now. At the same time, we can change the function''s
    name to `calculate` as it better reflects what the function does:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以在执行除法之前检查`y`是否等于零。现在让我们这样做。同时，我们可以将函数的名称改为`calculate`，因为它更好地反映了函数的功能：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But what should we do if `y` is zero? We cannot continue running the function
    as we would then perform the division anyway. We cannot change `y` to something
    else either, because what would we even change it to?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们遇到`y`为零的情况，我们应该怎么办？我们不能继续运行函数，因为那样我们仍然会执行除法操作。我们也不能将`y`改为其他值，因为我们应该将它改为什么？
- en: We need a way to signal to the caller of the function that we cannot accept
    a value of zero for `y`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来向函数的调用者发出信号，表明我们无法接受`y`为零的值。
- en: One way to do this would be to let the exception happen and remove the `if`
    statement again. If we did that, the caller could handle the error.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法就是让异常发生，并再次移除`if`语句。如果我们这样做，调用者就可以处理错误了。
- en: 'Let''s see how we can handle an exception when we call a function. The call
    to the function would then need to be within a special block of code called a
    `try` statement. It could look something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在调用函数时处理异常。那么，对函数的调用就需要在一个特殊的代码块中，称为`try`语句。它可能看起来像这样：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we can see that the call to the `calculate` function is located within
    a `try` block.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到对`calculate`函数的调用位于一个`try`块中。
- en: If everything is fine and we return from the function without any exception,
    the program will jump to the line after `end_catch` and resume its execution.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，并且我们在函数中没有抛出任何异常就返回，程序将跳转到`end_catch`之后的行，并继续执行。
- en: But if we get an exception and that exception is of the `ZeroDivisionError`
    type, we will end up in the block below, which begins with a `catch`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们遇到一个异常，而这个异常是`ZeroDivisionError`类型，我们最终会进入下面的代码块，它以`catch`开始。
- en: Exceptions can be caught, but we need to specify what exception it is we want
    to handle. If we get another exception, one that does not have a matching `catch`,
    the program will crash as before.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以被捕获，但我们需要指定我们想要处理哪种异常。如果我们遇到另一个异常，一个没有匹配`catch`的异常，程序将像以前一样崩溃。
- en: Calling the function like this could be a solution for us, but is it a good
    solution? Not really. Imagine that the `calculate` function is located in a different
    module that is in a different file. It might even be written by somebody else.
    In this situation, how do we know that it will perform a division and that it
    will use the second value we pass to it as the divisor in that division? We will
    most likely not know anything about that, or we should at least assume that the
    users do not know anything about how the function is written.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调用函数可能是我们的解决方案，但这真的是一个好的解决方案吗？并不。想象一下，`calculate`函数位于一个不同的模块中，该模块位于一个不同的文件中。它甚至可能是由别人编写的。在这种情况下，我们如何知道它将执行除法，并且它将使用我们传递给它的第二个值作为除数？我们很可能对此一无所知，或者我们至少应该假设用户对函数的编写方式一无所知。
- en: Therefore, we could not assume that they will use a `ZeroDivisionError` exception
    in their `catch` statement. Instead, we could give them another exception that
    might make more sense.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不能假设他们会在他们的`catch`语句中使用`ZeroDivisionError`异常。相反，我们可以给他们另一个可能更有意义的异常。
- en: 'Let''s change our `calculate` function, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`calculate`函数，如下所示：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`throw` will create another exception; this time, one called `ValueError`.
    We are also passing a string to this exception. If someone now calls our function
    and gives us a value of zero for `y`, they will get this exception with the message
    we provided.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`将创建另一个异常；这次，一个叫做`ValueError`的异常。我们还在这个异常中传递了一个字符串。如果有人现在调用我们的函数并给我们一个`y`的值为零，他们将得到我们提供的这个异常信息。'
- en: 'When they call our function, they could now check for this exception instead:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们调用我们的函数时，他们现在可以检查这个异常：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since this is the location where the bad value for `y` originated, it is much
    more likely that this is where we can change it. If this, for example, was a value
    that was given to us by the user of the program, we could give a nice error message
    back, saying that they cannot enter a value of zero.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是`y`的坏值产生的地方，我们更有可能在这里改变它。例如，如果这个值是由程序的用户给出的，我们可以返回一个友好的错误信息，说明他们不能输入零值。
- en: We can say that this is the location that *owns* the data and therefore has
    the opportunity to change it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说这是拥有数据的位置，因此有机会改变它。
- en: If we use `try…catch` blocks around calls to functions that can throw exceptions,
    the program will no longer crash. In this case, the `calculate` function will
    still exit as soon as we throw the `ValueError` exception, but since we are catching
    it right after the call to the function, we might be able to correct the problem
    and call the function again with a correct value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在可能抛出异常的函数调用周围使用`try…catch`块，程序将不再崩溃。在这种情况下，`calculate`函数仍然会在我们抛出`ValueError`异常时立即退出，但由于我们在函数调用后立即捕获它，我们可能能够纠正问题并再次用正确的值调用函数。
- en: Exceptions are a great way to handle conditions when we can't decide what to
    do due to a condition that we could not predict when we wrote the program. Without
    them, it would be very difficult to signal to other parts of the program that
    something is wrong. We should use them when we need to, but also ensure proper
    care. Exceptions always send a clear message regarding what is wrong and assist
    the author of the code that receives the exception with understanding what the
    problem is.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是在我们无法决定在编写程序时无法预测的条件下的处理条件的一种很好的方式。没有它们，向程序的其它部分发出错误信号将非常困难。我们需要在需要时使用它们，但也要确保适当的关注。异常总是发送一个关于错误的清晰信息，并帮助接收异常的代码的作者理解问题是什么。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we realized that we, as humans, make mistakes, but we can go
    back and fix them as well.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们意识到，作为人类，我们会犯错误，但我们可以回去修复它们。
- en: A software bug is an error in an application that can have several causes. Depending
    on what is behind the bug, we must approach it differently when trying to fix
    it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 软件错误是应用程序中的错误，可能有几个原因。根据错误背后的原因，我们在尝试修复它时必须采取不同的方法。
- en: In some cases, as with syntax errors, we will be told what the cause of the
    bug is right away, and even be directed to the correct location in the code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如与语法错误一样，我们将会立即被告知错误的起因，甚至会被指引到代码中的正确位置。
- en: Other bugs will be harder to find. When the programming language syntax is correct,
    but the logic is not, the program will behave in unexpected ways. To be able to
    find these bugs, we can use a tool called a debugger. It helps us track down the
    bugs by letting us pause the execution of the program and see all the values the
    variables have; it will even let us step through the execution one line at a time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 其他错误将更难找到。当编程语言语法正确，但逻辑不正确时，程序将以意想不到的方式运行。为了能够找到这些错误，我们可以使用一个名为调试器的工具。它通过允许我们暂停程序执行并查看变量的所有值来帮助我们追踪错误；它甚至允许我们逐行执行。
- en: An exceptional event is when things that should not happen still happen. In
    programming, they are referred to as exceptions. When they happen, they will immediately
    halt the execution of the program if they are not handled. Fortunately, we can
    handle them by inserting code that will only run if the exceptional event occurs
    so that we can try to fix the problem.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异常事件是指那些本不应该发生的事情仍然发生了。在编程中，这些被称为异常。当它们发生时，如果未得到处理，程序将立即停止执行。幸运的是，我们可以通过插入仅在异常事件发生时才会运行的代码来处理它们，这样我们就可以尝试解决问题。
- en: In the next chapter, we will look at different ways to approach a problem and
    create a solution with code. This is called a paradigm. A programming language
    will use one of these. As we will see, some languages will use concepts from more
    than one paradigm.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨不同的方法来解决问题，并使用代码创建解决方案。这被称为范式。编程语言将使用这些范式之一。正如我们将看到的，一些语言将使用来自多个范式的概念。
