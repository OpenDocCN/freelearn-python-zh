- en: Python Data Types and Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 数据类型和结构
- en: In this chapter, we are going to examine the Python data types in detail. We
    have already been introduced to two data types, the string, `str()`, and `list()`.
    It is often the case where we want more specialized objects to represent our data.
    In addition to the built-in types, there are several internal modules that allow
    us to address common issues when working with data structures. First, we are going
    to review some operations and expressions that are common to all data types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细检查 Python 数据类型。我们已经介绍了两种数据类型，即字符串 `str()` 和 `list()`。我们通常希望有更专业的对象来表示我们的数据。除了内置类型之外，还有一些内部模块允许我们在处理数据结构时解决常见问题。首先，我们将回顾一些对所有数据类型都通用的运算和表达式。
- en: Operations and expressions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算和表达式
- en: 'There are a number of operations that are common to all data types. For example,
    all data types, and generally all objects, can be tested for a truth value in
    some way. The following are values that Python considers `False`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多运算对所有数据类型都是通用的。例如，所有数据类型，以及通常所有对象，都可以以某种方式测试其真值。以下是在 Python 中被认为是 `False`
    的值：
- en: The `None` type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None` 类型'
- en: '`False`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`False`'
- en: An integer, float, or complex zero
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数、浮点数或复数零
- en: An empty sequence or mapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空序列或映射
- en: An instance of a user-defined class that defines a `__len__()` or `__bool__()`
    method that returns zero or `False`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类的实例，该类定义了一个返回零或 `False` 的 `__len__()` 或 `__bool__()` 方法
- en: All other values are considered `True`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都被认为是 `True`。
- en: Boolean operations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔运算
- en: 'A Boolean operation returns a value of eighter `True` or `False`. Boolean operations
    are ordered in priority, so if more than one Boolean operation occurs in an expression,
    the operation with the highest priority will occur first. The following table
    outlines the three Boolean operators in descending order of priority:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算返回 `True` 或 `False` 的值。布尔运算按优先级排序，因此如果表达式中有多个布尔运算，则优先级最高的运算将首先发生。以下表格按优先级降序概述了三个布尔运算符：
- en: '| **Operator** | **Example** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **示例** |'
- en: '| not `x` | Returns `True` if `x` is `False`; returns `False` otherwise. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 非 `x` | 如果 `x` 是 `False`，则返回 `True`；否则返回 `False`。|'
- en: '| `x` and `y` | Returns `True` if both `x` and `y` are `True`; returns `False`
    otherwise. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `x` 和 `y` | 如果 `x` 和 `y` 都为 `True`，则返回 `True`；否则返回 `False`。|'
- en: '| `x` or `y` | Returns `True` if either `x` or `y` is `True`; returns `False`
    otherwise. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `x` 或 `y` | 如果 `x` 或 `y` 中的任何一个为 `True`，则返回 `True`；否则返回 `False`。|'
- en: Both the `and` operator and the `or` operator use "short-circuiting" when evaluating
    an expression. This means Python will only evaluate an operator if it needs to.
    For example, if `x` is `True` then in an expression `x` or `y`, the `y` does not
    get evaluated since the expression is obviously `True`. In a similar way, in an
    expression `x` and `y` where `x` is `False`, the interpreter will simply evaluate
    `x` and return `False`, without evaluating `y`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 运算符和 `or` 运算符在评估表达式时使用“短路”。这意味着 Python 只会在需要时评估运算符。例如，如果 `x` 是 `True`，则在表达式
    `x or y` 中，由于表达式显然是 `True`，所以不会评估 `y`。以类似的方式，在表达式 `x and y` 中，如果 `x` 是 `False`，则解释器将简单地评估
    `x` 并返回 `False`，而不会评估 `y`。'
- en: Comparison and Arithmetic operators
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和算术运算符
- en: The standard arithmetic operators (`+`, `-`, `*`, `/`) work with all Python
    numeric types. The `//` operator gives an integer quotient, (for example, `3 //
    2` returns `1`), the exponent operator is `x ** y`, and the modulus operator,
    given by `a % b`, returns the remainder of the division `a/b`. The comparison
    operators (`<`, `<=`, `>`, `>=`, `==`, and `!=`) work with numbers, strings, lists,
    and other collection objects and return `True` if the condition holds. For collection
    objects, these operators compare the number of elements and the equivalence operator
    `== b` returns `True` if each collection object is structurally equivalent, and
    the value of each element is identical.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 标准算术运算符（`+`、`-`、`*`、`/`）与所有 Python 数值类型一起工作。`//` 运算符给出一个整数商（例如，`3 // 2` 返回 `1`），指数运算符是
    `x ** y`，而模运算符，由 `a % b` 给出，返回除法 `a/b` 的余数。比较运算符（`<`、`<=`、`>`、`>=`、`==` 和 `!=`）与数字、字符串、列表和其他集合对象一起工作，如果条件成立，则返回
    `True`。对于集合对象，这些运算符比较元素的数量，并且等价运算符 `== b` 如果每个集合对象在结构上是等效的，并且每个元素的值都相同，则返回 `True`。
- en: Membership, identity, and logical operations
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员关系、身份和逻辑运算
- en: 'Membership operators (`in`, `not in`) test for variables in sequences, such
    as lists or strings do what you would expect, `x in y` returns `True` if a variable
    `x` is found in `y`. The `is` operator compares object identity. For example,
    the following snippet shows contrast equivalence with object identity:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 成员运算符（`in`，`not in`）用于测试序列中的变量，例如列表或字符串，如你所期望的，`x in y` 如果变量 `x` 在 `y` 中找到，则返回
    `True`。`is` 运算符比较对象身份。例如，以下代码片段显示了对象身份的对比等价性：
- en: '![](img/image_02_001.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: Built-in data types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: 'Python data types can be divided into three categories: numeric, sequence,
    and mapping. There is also the `None` object that represents a `Null`, or absence
    of a value. It should not be forgotten either that other objects such as classes,
    files, and exceptions can also properly be considered *types*; however, they will
    not be considered here.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python 数据类型可以分为三类：数值型、序列型和映射型。还有一个表示空值或值不存在的 `None` 对象，也不应忘记，其他对象如类、文件和异常也可以被认为是
    *类型*；然而，这里将不会考虑它们。
- en: Every value in Python has a data type. Unlike many programming languages, in
    Python you do not need to explicitly declare the type of a variable. Python keeps
    track of object types internally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个值都有一个数据类型。与许多编程语言不同，在 Python 中，你不需要显式声明变量的类型。Python 在内部跟踪对象类型。
- en: 'Python built-in data types are outlined in the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置数据类型如下表所示：
- en: '| **Category** | **Name** | **Description** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **名称** | **描述** |'
- en: '| None | `None` | The null object. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 空值 | `None` | 空对象。|'
- en: '| Numeric | `int` | Integer. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 数值 | `int` | 整数。|'
- en: '|  | `float` | Floating point number. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  | `float` | 浮点数。|'
- en: '|  | `complex` | Complex number. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  | `complex` | 复数。|'
- en: '|  | `bool` | Boolean (True, False). |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  | `bool` | 布尔值（True，False）。|'
- en: '| Sequences | `str` | String of characters. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | `str` | 字符串。|'
- en: '|  | `list` | List of arbitrary objects. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  | `list` | 随意对象的列表。|'
- en: '|  | `Tuple` | Group of arbitrary items. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  | `Tuple` | 随意项的组。|'
- en: '|  | `range` | Creates a range of integers. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  | `range` | 创建一个整数范围。|'
- en: '| Mapping | `dict` | Dictionary of key-value pairs. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | `dict` | 键值对字典。|'
- en: '|  | `set` | Mutable, unordered collection of unique items. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | `set` | 可变、无序且元素唯一的集合。|'
- en: '|  | `frozenset` | Immutable set. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | `frozenset` | 不可变集合。|'
- en: None type
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值类型
- en: The None type is immutable and has one value, `None`. It is used to represent
    the absence of a value. It is returned by objects that do not explicitly return
    a value and evaluates to `False` in Boolean expressions. It is often used as the
    default value in optional arguments to allow the function to detect whether the
    caller has passed a value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 类型是不可变的，只有一个值，即 `None`。它用于表示值不存在。它由未显式返回值的对象返回，在布尔表达式中求值为 `False`。它通常用作可选参数的默认值，以便函数检测调用者是否传递了值。'
- en: Numeric Types
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'All numeric types, apart from `bool`, are signed and they are all immutable.
    Booleans have two possible values, `True` and `False`. These values are mapped
    to 1 and 0, respectively. The integer type, `int`, represents whole numbers of
    unlimited range. Floating point numbers are represented by the native double precision
    floating point representation of the machine. Complex numbers are represented
    by two floating point numbers. They are assigned using the `j` operator to signify
    the imaginary part of the complex number, for example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `bool` 之外的所有数值类型都是有符号的，并且都是不可变的。布尔值有两个可能的值，`True` 和 `False`。这些值分别映射到 1 和
    0。整数类型 `int` 表示无限制范围的整数。浮点数由机器的本地双精度浮点表示表示。复数由两个浮点数表示。它们使用 `j` 运算符分配，以表示复数的虚部，例如：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can access the real and imaginary parts with `a.real` and `a.imag`, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `a.real` 和 `a.imag` 分别访问实部和虚部。
- en: Representation error
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示错误
- en: 'It should be noted that the native double precision representation of floating
    point numbers leads to some unexpected results. For example, consider the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，浮点数的本地双精度表示可能导致一些意外的结果。例如，考虑以下情况：
- en: '![](img/image_02_002.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.png)'
- en: 'This is a result of the fact that most decimal fractions are not exactly representable
    as a binary fraction, which is how most underlying hardware represents floating
    point numbers. For algorithms or applications where this may be an issue, Python
    provides a `decimal` module. This module allows for the exact representation of
    decimal numbers and facilitates greater control properties such as rounding behavior,
    number of significant digits, and precision. It defines two objects, a `Decimal`
    type, representing decimal numbers, and a `Context` type, representing various
    computational parameters such as precision, rounding, and error handling. An example
    of its usage can be seen in the following snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数十进制分数不能精确地表示为二进制分数，而大多数底层硬件都是用二进制分数表示浮点数的。对于可能存在问题的算法或应用程序，Python提供了一个`decimal`模块。此模块允许精确表示十进制数，并便于控制诸如舍入行为、有效数字数量和精度等属性。它定义了两个对象，一个`Decimal`类型，表示十进制数，一个`Context`类型，表示各种计算参数，如精度、舍入和错误处理。其用法示例如下：
- en: '![](img/image_02_003.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: Here we have created a global context and set the precision to `4`. The `Decimal`
    object can be treated pretty much as you would treat an `int` or a `float`. They
    are subject to all the same mathematical operations and can be used as dictionary
    keys, placed in sets, and so on. In addition, `Decimal` objects also have several
    methods for mathematical operations, such as natural exponents, `x.exp()`, natural
    logarithms, `x.ln()`, and base 10 logarithms, `x.log10()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个全局上下文并设置了精度为`4`。`Decimal`对象可以像处理`int`或`float`一样处理。它们受到所有相同的数学运算的影响，可以用作字典键，放入集合中等。此外，`Decimal`对象还具有几个数学运算的方法，例如自然指数`x.exp()`、自然对数`x.ln()`和以10为底的对数`x.log10()`。
- en: 'Python also has a `fractions` module that implements a rational number type.
    The following example shows several ways to create fractions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个`fractions`模块，它实现了有理数类型。以下示例展示了创建分数的几种方法：
- en: '![](img/image_02_004.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004.png)'
- en: It is also worth mentioning here the `NumPy` extension. This has types for mathematical
    objects such as arrays, vectors, and matrixes, and capabilities for linear algebra,
    calculation of Fourier transforms, eigenvectors, logical operations, and much
    more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是`NumPy`扩展。它有数学对象（如数组、向量和矩阵）的类型，以及线性代数、傅里叶变换计算、特征向量、逻辑运算等功能。
- en: Sequences
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: Sequences are ordered sets of objects indexed by non-negative integers. Lists
    and tuples are sequences of arbitrary objects, strings are sequences of characters.
    String, tuple, and range objects are immutable. All sequence types have a number
    of operations in common. For all sequences, the indexing and slicing operators
    apply as described in the previous chapter. Note that for the immutable types,
    any operation will only return a value rather than actually change the value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是有序的对象集合，通过非负整数索引。列表和元组是任意对象的序列，字符串是字符的序列。字符串、元组和范围对象是不可变的。所有序列类型都有一些共同的运算。对于所有序列，索引和切片操作符的用法如前一章所述。请注意，对于不可变类型，任何操作都只会返回一个值，而不会实际更改值。
- en: 'All sequences have the following methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有序列都有以下方法：
- en: '| **Method** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `len(s)` | Number of elements in `s` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | `s`中的元素数量 |'
- en: '| `min(s, [,default=obj, key=func])` | The minimum value in `s` (alphabetically
    for strings) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `min(s, [,default=obj, key=func])` | `s`中的最小值（对于字符串按字母顺序） |'
- en: '| `max(s, [,default=obj, key=func])` | Maximum value in `s` (alphabetically
    for strings) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `max(s, [,default=obj, key=func])` | `s`中的最大值（对于字符串按字母顺序） |'
- en: '| `sum(s,[,start=0])` | The sum of the elements (returns `TypeError` if `s`
    is not numeric) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `sum(s,[,start=0])` | 元素的总和（如果`s`不是数值，则返回`TypeError`） |'
- en: '| `all(s)` | Returns `True` if all elements in `s` are True (that is, not `0`,
    `False`, or  `Null`) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `all(s)` | 如果`s`中的所有元素都是True（即不是`0`、`False`或`Null`），则返回`True` |'
- en: '| `any(s)` | Checks whether any item in `s` is `True` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `any(s)` | 检查`s`中的任何项是否为`True` |'
- en: 'In addition, all sequences support the following operations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有序列还支持以下操作：
- en: '| **Operation** | **Description** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| `s + r` | Concatenates two sequences of the same type |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `s + r` | 连接两个相同类型的序列 |'
- en: '| `s * n` | Make `n` copies of `s`, where `n` is an integer |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `s * n` | 创建`s`的`n`个副本，其中`n`是一个整数 |'
- en: '| `v1, v2 ..., vn = s` | Unpacks n variables from `s` to `v1`, `v2`, and so
    on |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `v1, v2 ..., vn = s` | 从`s`中解包n个变量到`v1`、`v2`等 |'
- en: '| `s[i]` | Indexing-returns element `i` of `s` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `s[i]` | 索引返回 `s` 的元素 `i` |'
- en: '| `s[i:j:stride]` | Slicing returns elements between `i` and `j` with optional
    stride |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `s[i:j:stride]` | 切片返回 `i` 和 `j` 之间的元素，可选步长 |'
- en: '| `x in s` | Returns `True` if element `x` is in `s` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `x in s` | 如果元素 `x` 在 `s` 中，则返回 `True` |'
- en: '| `x not in s` | Returns true if element `x` is not in `s` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `x not in s` | 如果元素 `x` 不在 `s` 中，则返回 true |'
- en: Tuples
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are immutable sequences of arbitrary objects. They are indexed by integers
    greater than zero. Tuples are **hashable**, which means we can sort lists of them
    and they can be used as keys to dictionaries. Syntactically, tuples are just a
    comma-separated sequence of values; however, it is common practice to enclose
    them in parentheses:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是由任意对象组成的不可变序列。它们可以通过大于零的整数进行索引。元组是**可哈希的**，这意味着我们可以对它们的列表进行排序，并且可以用作字典的键。在语法上，元组只是由逗号分隔的值序列；然而，通常的做法是将它们括在括号中：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is important to remember to use a trailing comma when creating a tuple with
    one element, for example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建只有一个元素的元组时，记得使用尾随逗号，例如：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Without the trailing comma, this would be interpreted as a string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有尾随逗号，这将被视为一个字符串。
- en: 'We can also create a tuple using the built-in function `tuple()`. With no argument,
    this creates an empty tuple. If the argument to `tuple()` is a sequence then this
    creates a tuple of elements of that sequence, for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用内置函数 `tuple()` 创建元组。如果没有参数，这将创建一个空元组。如果 `tuple()` 的参数是一个序列，则这将创建一个包含该序列元素的元组，例如：
- en: '![](img/image_02_005.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_005.png)'
- en: Most operators, such as those for slicing and indexing, work as they do on lists.
    However, because tuples are immutable, trying to modify an element of a tuple
    will give you a `TypeError.` We can compare tuples in the same way that we compare
    other sequences, using the `==`, `>` and `<` operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符，如切片和索引，与列表上的操作方式相同。但是，由于元组是不可变的，尝试修改元组的元素将导致 `TypeError`。我们可以使用 `==`、`>`
    和 `<` 运算符以与其他序列相同的方式比较元组。
- en: 'An important use of tuples is to allow us to assign more than one variable
    at a time by placing a tuple on the left-hand side of an assignment, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个重要用途是允许我们通过在赋值语句的左侧放置一个元组来同时分配多个变量，例如：
- en: '![](img/image_02_006.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_006.png)'
- en: 'We can actually use this multiple assignment to swap values in a tuple, for
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用这种多重赋值在元组中交换值，例如：
- en: '![](img/image_02_007.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_007.png)'
- en: A `ValueError` will be thrown if the number of values on each side of the assignment
    are not the same.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果赋值语句两边的值数量不相同，将会抛出 `ValueError`。
- en: Dictionaries
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are arbitrary collections of objects indexed by numbers, strings,
    or other immutable objects. Dictionaries themselves are mutable; however, their
    index keys must be immutable. The following table contains all the dictionary
    methods and their descriptions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是由数字、字符串或其他不可变对象索引的对象的任意集合。字典本身是可变的；然而，它们的索引键必须是不可变的。以下表格包含所有字典方法和它们的描述：
- en: '| **Method** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `len(d)` | Number of items in `d`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `len(d)` | `d` 中的项数。|'
- en: '| `d.clear()` | Removes all items from `d`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `d.clear()` | 从 `d` 中移除所有项。|'
- en: '| `d.copy()` | Makes a shallow copy of `d`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `d.copy()` | 创建 `d` 的浅拷贝。|'
- en: '| `d.fromkeys(s [,value])` | Returns a new dictionary with keys from sequence
    `s` and values set to `value`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `d.fromkeys(s [,value])` | 返回一个新的字典，其键来自序列 `s`，值设置为 `value`。|'
- en: '| `d.get(k [,v])` | Returns `d[k]` if found, or else returns `v`, or None if
    `v` is not given. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `d.get(k [,v])` | 如果找到，则返回 `d[k]`，否则返回 `v`，如果没有给出 `v`，则返回 None。|'
- en: '| `d.items()` | Returns a sequence of `key:value` pairs in `d`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `d.items()` | 返回 `d` 中的 `key:value` 对序列。|'
- en: '| `d.keys()` | Returns a sequence of keys in `d`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `d.keys()` | 返回 `d` 中的键序列。|'
- en: '| `d.pop(k [,default])` | Returns `d[k]` and removes it from `d`. If `d[k]`
    is not found, it returns default or raises `KeyError`. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `d.pop(k [,default])` | 返回 `d[k]` 并将其从 `d` 中移除。如果 `d[k]` 未找到，则返回默认值或引发 `KeyError`。|'
- en: '| `d.popitem()` | Removes a random `key:value` pair from `d` and returns it
    as a tuple. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `d.popitem()` | 从 `d` 中随机移除一个 `key:value` 对并将其作为元组返回。|'
- en: '| `d.setdefault(k [,v])` | Returns `d[k]`. If `d[k]` is not found, it returns
    `v` and sets `d[k]` to `v`. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `d.setdefault(k [,v])` | 返回 `d[k]`。如果 `d[k]` 未找到，则返回 `v` 并将 `d[k]` 设置为 `v`。|'
- en: '| `d.update(b)` | Adds all objects from `b` to `d`. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `d.update(b)` | 将 `b` 中的所有对象添加到 `d` 中。|'
- en: '| `d.values()` | Returns a sequence of values in `d`. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `d.values()` | 返回 `d` 中的值序列。|'
- en: 'Python dictionaries are the only built-in mapping type and they are similar
    to hash tables or associative arrays found in other languages. They can be thought
    of as a mapping from a set of keys to a set of values. They are created using
    the syntax `{key:value}`. For example, the following creates a dictionary mapping
    words to numerals:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典是唯一的内置映射类型，它们类似于其他语言中找到的哈希表或关联数组。它们可以被视为从一组键到一组值的映射。它们使用语法`{key:value}`创建。例如，以下创建了一个将单词映射到数字的字典：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can add keys and values as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下添加键和值：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or update multiple values using the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用以下方式更新多个值：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we inspect `d`, we get the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`d`时，我们得到以下结果：
- en: '![](img/image_02_008.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_008.png)'
- en: 'We can test for the occurrence of a value using the `in` operator, for example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`in`运算符来测试一个值的出现，例如：
- en: '![](img/image_02_009.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_009.png)'
- en: It should be noted that the `in` operator, when applied to dictionaries, works
    in a slightly different way to when it is applied to a list. When we use the `in`
    operator on a list, the relationship between the time it takes to find an element
    and the size of the list is considered linear. That is, as the size of the list
    gets bigger, the corresponding time it takes to find an element grows, at most,
    linearly. The relationship between the time an algorithm takes to run compared
    to the size of its input is often referred to as its time complexity. We will
    talk more about this important topic in the next (and subsequent) chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，当`in`运算符应用于字典时，其工作方式与应用于列表时略有不同。当我们使用`in`运算符在列表上时，找到元素所需的时间与列表大小之间的关系被认为是线性的。也就是说，随着列表大小的增加，找到元素所需的时间最多以线性方式增长。算法运行时间与其输入大小之间的关系通常被称为其时间复杂度。我们将在下一章（以及随后的章节）中更多地讨论这个重要的话题。
- en: In contrast to the `list` object, when the `in` operator is applied to dictionaries,
    it uses a hashing algorithm and this has the effect of the increase in time for
    each lookup almost independent of the size of the dictionary. This makes dictionaries
    extremely useful as a way to work with large amounts of indexed data. We will
    talk more about this important topic of rates of growth hashing in [Chapter 4](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml),
    *Lists and pointer structures*, and [Chapter 13](48e9b010-a4c9-4cc3-9ae0-de772639da37.xhtml), *Implementations,
    applications and tools*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与`list`对象相比，当`in`运算符应用于字典时，它使用哈希算法，并且这种算法的效果是几乎独立于字典大小的查找时间增加。这使得字典作为处理大量索引数据的方式变得极其有用。我们将在[第4章](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml)，*列表和指针结构*，以及[第13章](48e9b010-a4c9-4cc3-9ae0-de772639da37.xhtml)，*实现、应用和工具*中更多地讨论这个重要的话题——哈希增长速率。
- en: Notice when we print out the `key:value` pairs of the dictionary it does so
    in no particular order. This is not a problem since we use specified keys to look
    up each dictionary value rather than an ordered sequence of integers as is the
    case for strings and lists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们打印出字典的`key:value`对时，它并不按特定顺序打印。这并不是一个问题，因为我们使用指定的键来查找每个字典值，而不是像字符串和列表那样使用有序的整数序列。
- en: Sorting dictionaries
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典排序
- en: 'If we want to do a simple sort on either the keys or values of a dictionary,
    we can do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对字典的键或值进行简单的排序，我们可以这样做：
- en: '![](img/image_02_010.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_010.png)'
- en: Note that the first line in the preceding code sorts the keys according to alphabetical
    order, and the second line sorts the values in order of integer value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到上述代码中的第一行按字母顺序对键进行排序，而第二行按整数值对值进行排序。
- en: 'The `sorted()` method has two optional arguments that are of interest: `key`
    and `reverse`. The key argument has nothing to do with the dictionary keys, but
    rather is a way of passing a function to the sort algorithm to determine the sort
    order. For example, in the following code, we use the `__getitem__` special method
    to sort the dictionary keys according to the dictionary values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`方法有两个可选参数值得关注：`key`和`reverse`。`key`参数与字典键无关，而是将函数传递给排序算法以确定排序顺序的一种方式。例如，在以下代码中，我们使用`__getitem__`特殊方法根据字典值对字典键进行排序：'
- en: '![](img/image_02_011.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_011.png)'
- en: 'Essentially, what the preceding code is doing is for every `key` in `d` to
    use the corresponding value to sort. We can also sort the values according to
    the sorted order of the dictionary keys. However, since dictionaries do not have
    a method to return a `key` by using its value, the equivalent of the `list.index`
    method for lists, using the optional `key` argument to do this is a little tricky.
    An alternative approach is to use a list comprehension, as the following example
    demonstrates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实际上是在对`d`中的每个`key`使用相应的值进行排序。我们也可以根据词典键的排序顺序对值进行排序。然而，由于词典没有通过值返回`key`的方法，类似于列表的`list.index`方法，使用可选的`key`参数来做这一点有点棘手。一个替代方法是使用列表推导，以下示例演示了这一点：
- en: '![](img/image_02_012.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_012.png)'
- en: 'The `sorted()` method also has an optional reverse argument, and unsurprisingly,
    this does exactly what it says, reverses the order of the sorted list, for example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`方法还有一个可选的`reverse`参数，不出所料，它确实做了它所说的，反转排序列表的顺序，例如：'
- en: '![](img/image_02_013.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_013.png)'
- en: 'Now, let''s say we are given the following dictionary, English words as keys
    and French words as values. Our task is to place these string values in correct
    numerical order:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们得到了以下词典，以英语单词为键，法语单词为值。我们的任务是将这些字符串值放置在正确的数值顺序中：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, when we print this dictionary out, it will be unlikely to print
    in the correct order. Because all keys and values are strings, we have no context
    for numerical ordering. To place these items in correct order, we need to use
    the first dictionary we created, mapping words to numerals as a way to order our
    English to French dictionary:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们打印这个词典时，它不太可能按正确的顺序打印。因为所有键和值都是字符串，我们没有数值排序的上下文。为了将这些项放置在正确的顺序中，我们需要使用我们最初创建的词典，将单词映射到数字，作为我们英语到法语词典排序的方式：
- en: '![](img/image_02_014.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_014.png)'
- en: 'Notice we are using the values of the first dictionary, `d`, to sort the keys
    of the second dictionary, `d2`. Since our keys in both dictionaries are the same,
    we can use a list comprehension to sort the values of the French to English dictionary:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用第一个词典`d`的值来对第二个词典`d2`的键进行排序。由于我们两个词典中的键是相同的，我们可以使用列表推导来对法语到英语词典的值进行排序：
- en: '![](img/image_02_015.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_015.png)'
- en: 'We can, of course, define our own custom method that we can use as the `key`
    argument to the `sorted` method. For example, here we define a function that simply
    returns the last letter of a string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以定义自己的自定义方法，并将其用作`sorted`方法的`key`参数。例如，这里我们定义了一个函数，它简单地返回一个字符串的最后一个字母：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then use this as the `key` to our `sorted` function to sort each element
    by its last letter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个值作为`sorted`函数的`key`参数来按每个元素的最后一个字母进行排序：
- en: '![](img/image_02_016.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_016.png)'
- en: Dictionaries for text analysis
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本分析词典
- en: 'A common use of dictionaries is to count the occurrences of like items in a
    sequence; a typical example is counting the occurrences of words in a body of
    text. The following code creates a dictionary where each word in the text is used
    as a key and the number of occurrences as its value. This uses a very common idiom
    of nested loops. Here we are using it to traverse the lines in a file in an outer
    loop and the keys of a dictionary on the inner loop:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 词典的常见用途是计算序列中类似项的出现的次数；一个典型的例子是计算文本中单词的出现次数。以下代码创建了一个词典，其中文本中的每个单词用作键，出现次数作为其值。这使用了一个非常常见的嵌套循环的习语。在这里，我们使用它在外层循环中遍历文件的行，在内层循环中遍历词典的键：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will return a dictionary with an element for each unique word in the text
    file. A common task is to filter items such as these into subsets we are interested
    in. You will need a text file saved in the same directory as you run the code.
    Here we have used `alice.txt`, a short excerpt from *Alice in Wonderland*. To
    obtain the same results, you can download `alice.txt` from [davejulian.net/bo5630](http://davejulian.net/bo5630),
    or use a text file of your own. In the following code, we create another dictionary,
    `filtered`, containing a subset of items from `count`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含文本文件中每个唯一单词的元素的词典。一个常见的任务是过滤这些项到我们感兴趣的子集中。你需要一个与运行代码相同的目录中的文本文件。在这里，我们使用了`alice.txt`，这是《爱丽丝梦游仙境》的一个简短摘录。要获得相同的结果，你可以从[davejulian.net/bo5630](http://davejulian.net/bo5630)下载`alice.txt`，或者使用你自己的文本文件。在以下代码中，我们创建另一个包含`count`中子集的词典`filtered`：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we print the filtered dictionary, we get the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印过滤后的词典时，我们得到以下内容：
- en: '![](img/image_02_017.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_017.png)'
- en: Note the use of the **dictionary comprehension** used to construct the filtered
    dictionary. Dictionary comprehensions work in an identical way to the list comprehensions
    we looked at in [Chapter 1](bed519dd-40d8-4bfd-a721-184d8ea37555.xhtml), *Python
    Objects, Types, and Expressions*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用**字典推导**来构建过滤字典。字典推导与我们在[第1章](bed519dd-40d8-4bfd-a721-184d8ea37555.xhtml)，“Python对象、类型和表达式”中看到的列表推导以相同的方式工作。
- en: Sets
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Sets are unordered collections of unique items. Sets are themselves mutable,
    we can add and remove items from them; however, the items themselves must be immutable.
    An important distinction with sets is that they cannot contain duplicate items.
    Sets are typically used to perform mathematical operations such as intersection,
    union, difference, and complement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的唯一项目集合。集合本身是可变的，我们可以从中添加和删除项目；然而，项目本身必须是不可变的。与集合的一个重要区别是它们不能包含重复的项目。集合通常用于执行诸如交集、并集、差集和补集之类的数学运算。
- en: Unlike sequence types, set types do not provide any indexing or slicing operations.
    There are also no keys associated with values, as is the case with dictionaries.
    There are two types of set objects in Python, the mutable `set` object and the
    immutable `frozenset` object. Sets are created using comma-separated values within
    curly braces. By the way, we cannot create an empty set using `a={}`, because
    this will create a dictionary. To create an empty set, we write either `a=set()`
    or `a=frozenset()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与序列类型不同，集合类型不提供任何索引或切片操作。与字典的情况一样，也没有与值关联的键。Python中有两种集合对象，可变集合`set`对象和不可变`frozenset`对象。集合是通过在大括号内使用逗号分隔的值来创建的。顺便说一下，我们不能使用`a={}`创建一个空集合，因为这将会创建一个字典。要创建一个空集合，我们可以写`a=set()`或`a=frozenset()`。
- en: 'Methods and operations of sets are described in the following table:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的方法和操作如下表所述：
- en: '| **Method** | **Operators** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **运算符** | **描述** |'
- en: '| `len(s)` |  | Returns the number of elements in `s` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` |  | 返回`s`中元素的数量 |'
- en: '| `s.copy()` |  | Returns a shallow copy of `s` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` |  | 返回`s`的浅拷贝 |'
- en: '| `s.difference(t)` | `s - t- t2 - ...` | Returns a set of all items in `s`
    but not in `t` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference(t)` | `s - t- t2 - ...` | 返回`s`中但不在`t`中的所有项目的集合 |'
- en: '| `s.intersection(t)` |  | Returns a set of all items in both `t` and `s` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection(t)` |  | 返回`t`和`s`中所有项目的集合 |'
- en: '| `s.isdisjoint(t)` |  | Returns True if `s` and `t` have no items in common
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdisjoint(t)` |  | 如果`s`和`t`没有共同的项目，则返回True |'
- en: '| `s.issubset(t)` | `s <= t``s < t (s != t)` | Returns True if all items in
    `s` are also in `t` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `s.issubset(t)` | `s <= t``s < t (s != t)` | 如果`s`中的所有项目也在`t`中，则返回True |'
- en: '| `s.issuperset(t)` | `s >= t``s > t (s != t)` | Returns True if all items
    in `t` are also in `s` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `s.issuperset(t)` | `s >= t``s > t (s != t)` | 如果`t`中的所有项目也在`s`中，则返回True
    |'
- en: '| `s.symmetric_difference(t)` | `s ^ t` | Returns a set of all items that are
    in `s` or `t`, but not both |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference(t)` | `s ^ t` | 返回一个集合，包含`s`或`t`中的所有项目，但不是两者都有的项目
    |'
- en: '| `s.union(t)` | `s &#124; t1 &#124; t2 &#124;...` | Returns a set of all items
    in `s` or `t` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `s.union(t)` | `s &#124; t1 &#124; t2 &#124;...` | 返回`s`或`t`中所有项目的集合 |'
- en: In the preceding table, the parameter `t` can be any Python object that supports
    iteration and all methods are available to both `set` and `frozenset` objects.
    It is important to be aware that the operator versions of these methods require
    their arguments to be sets, whereas the methods themselves can accept any iterable
    type. For example, `s - [1,2,3]`, for any set `s`, will generate an unsupported
    operand type. Using the equivalent `s.difference([1,2,3])` will return a result.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，参数`t`可以是任何支持迭代的Python对象，并且所有方法都对`set`和`frozenset`对象可用。重要的是要注意，这些方法的操作符版本要求它们的参数是集合，而方法本身可以接受任何可迭代类型。例如，对于任何集合`s`，`s
    - [1,2,3]`将生成一个不支持的运算符类型。使用等效的`s.difference([1,2,3])`将返回一个结果。
- en: 'Mutable set objects have additional methods, described in the following table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可变集合对象有额外的方法，如下表所述：
- en: '| **Method** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `s.add(item)` | Adds item to `s`. Has no effect if `item` is already present.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `s.add(item)` | 添加`item`到`s`。如果`item`已经存在，则没有效果。 |'
- en: '| `s.clear()` | Removes all items from `s`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | 从`s`中移除所有项目。 |'
- en: '| `s.difference_update(t)` | Removes all items in `s` that are also in `t`.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference_update(t)` | 从`s`中移除在`t`中的所有项目。 |'
- en: '| `s.discard(item)` | Removes `item` from `s`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `s.discard(item)` | 从`s`中移除`item`。 |'
- en: '| `s.intersection_update(t)` | Removes all items from `s` that are not in the
    intersection of `s` and `t`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection_update(t)` | 从`s`中移除不在`s`和`t`的交集中的所有项目。 |'
- en: '| `s.pop()` | Returns and removes an arbitrary item from `s`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | 返回并从`s`中移除一个任意项目。|'
- en: '| `s.remove(item)` | Removes item from `s`. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(item)` | 从`s`中移除项目。|'
- en: '| `s.symetric_difference_update(t)` | Removes all items from `s` that are not
    in the symmetric difference of `s` and `t`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference_update(t)` | 从`s`中移除不在`s`和`t`的对称差集中的所有项目。|'
- en: '| `s.update(t)` | Adds all the items in an iterable object `t` to `s`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `s.update(t)` | 将可迭代对象`t`中的所有项目添加到`s`中。|'
- en: 'The following example demonstrates some simple set operations and their results:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一些简单的集合操作及其结果：
- en: '![](img/image_02_018.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_018.png)'
- en: Notice that the set object does not care that its members are not all of the
    same type, as long as they are all immutable. If you try to use a mutable object
    such as a list or dictionaries in a set, you will receive an unhashable type error.
    Hashable types all have a hash value that does not change throughout the lifetime
    of the instance. All built-in immutable types are hashable. All built-in mutable
    types are not hashable, so they cannot be used as elements of sets or keys to
    dictionaries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，集合对象并不关心其成员是否都是同一类型，只要它们都是不可变的。如果你尝试在集合中使用可变对象，如列表或字典，你会收到一个不可哈希的类型错误。所有可哈希类型都具有在整个实例生命周期中不变的哈希值。所有内置不可变类型都是可哈希的。所有内置可变类型都不是可哈希的，因此不能用作集合的元素或字典的键。
- en: Notice also in the preceding code that when we print out the union of `s1` and
    `s2,` there is only one element with the value `'ab'`. This is a natural property
    of sets in that they do not include duplicates.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，当我们打印出`s1`和`s2`的并集时，只有一个值为`'ab'`的元素。这是集合的自然属性，即它们不包含重复项。
- en: 'In addition to these built-in methods there are a number of other operations
    that we can perform on sets. For example, to test for membership of a set, use
    the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些内置方法之外，我们还可以在集合上执行许多其他操作。例如，要测试集合的成员资格，可以使用以下方法：
- en: '![](img/image_02_019.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_019.png)'
- en: 'We can loop through elements in a set using the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式遍历集合中的元素：
- en: '![](img/image_02_020.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_020.png)'
- en: Immutable sets
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: 'Python has an immutable set type called `frozenset`. It works pretty much exactly
    like `set` apart from not allowing methods or operations that change values such
    as the `add()` or `clear()` methods. There are several ways that this immutability
    can be useful. For example, since normal sets are mutable and therefore not hashable,
    they cannot be used as members of other sets. The `frozenset`, on the other hand,
    is immutable and therefore able to be used as a member of a set:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个不可变的集合类型，称为`frozenset`。它几乎与`set`完全相同，除了不允许更改值的方法或操作，如`add()`或`clear()`方法。这种不可变性有几种有用的方式。例如，由于正常集合是可变的，因此不可哈希，它们不能用作其他集合的成员。另一方面，`frozenset`是不可变的，因此可以用作集合的成员：
- en: '![](img/image_02_021.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_021.png)'
- en: 'Also the immutable property of `frozenset` means we can use it for a `key`
    to a dictionary, for example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变属性意味着我们可以将`frozenset`用作字典的`key`，例如：
- en: '![](img/image_02_022.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_022.png)'
- en: Modules for data structures and algorithms
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法模块
- en: In addition to the built-in types, there are several Python modules that we
    can use to extend these built-in types and functions. In many cases, these Python
    modules may offer efficiency and programming advantages that allow us to simplify
    our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置类型外，还有几个Python模块可以用来扩展这些内置类型和函数。在许多情况下，这些Python模块可能提供效率和编程优势，使我们能够简化代码。
- en: So far, we have looked at the built-in datatypes of strings, lists, sets, and
    dictionaries as well as the `decimal` and `fractions` modules. They are often
    described by the term **abstract data types** (**ADTs**). ADTs can be considered
    as mathematical specifications for the set of operations that can be performed
    on data. They are defined by their behavior rather than their implementation.
    In addition to the ADTs that we have looked at, there are several Python libraries
    that provide extensions to the built-in datatypes. These will be discussed in
    the following section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了字符串、列表、集合和字典的内置数据类型以及`decimal`和`fractions`模块。它们通常被称为**抽象数据类型**（**ADTs**）。ADTs可以被视为对可以执行在数据上的操作集的数学规范。它们是由其行为而不是其实施来定义的。除了我们探讨的ADTs之外，还有几个Python库提供了对内置数据类型的扩展。这些将在下一节中讨论。
- en: Collections
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'The `collections` module provides more specialized, high, performance alternatives
    for the built-in data types as well as a utility function to create named tuples.
    The following table lists the datatypes and operations of the collections module
    and their descriptions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections` 模块提供了对内置数据类型的更多专业化和高性能替代方案，以及一个创建命名元组的实用函数。以下表格列出了 `collections`
    模块的数据类型和操作及其描述：'
- en: '| **Datatype or operation** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型或操作** | **描述** |'
- en: '| `namedtuple()` | Creates tuple subclasses with named fields. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `namedtuple()` | 创建具有命名字段的元组子类。 |'
- en: '| `deque` | Lists with fast appends and pops either end. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `deque` | 具有快速追加和弹出两端列表的功能。 |'
- en: '| `ChainMap` | Dictionary like class to create a single view of multiple mappings.
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `ChainMap` | 创建多个映射的单个视图的字典类。 |'
- en: '| `Counter` | Dictionary subclass for counting hashable objects. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | 用于计数可哈希对象的字典子类。 |'
- en: '| `OrderedDict` | Dictionary subclass that remembers the entry order. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedDict` | 记录条目顺序的字典子类。 |'
- en: '| `defaultdict` | Dictionary subclass that calls a function to supply missing
    values. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `defaultdict` | 调用一个函数来提供缺失值的字典子类。 |'
- en: '| `UserDict``UserList``UserString` | These three data types are simply wrappers
    for their underlying base classes. Their use has largely been supplanted by the
    ability to subclasas their respective base classes directly. Can be used to access
    the underlying object as an attribute. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `UserDict` `UserList` `UserString` | 这三个数据类型只是它们底层基类的包装器。它们的使用在很大程度上已被直接子类化各自基类的功能所取代。可以用来将底层对象作为属性访问。
    |'
- en: Deques
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双端队列
- en: Double-ended queues, or deques (usually pronounced *decks*), are list-like objects
    that support thread-safe, memory-efficient appends. Deques are mutable and support
    some of the operations of lists, such as indexing. Deques can be assigned by index,
    for example, `dq[1] = z`; however, we cannot directly slice deques. For example,
    `dq[1:2]` results in a `TypeError` (we will look at a way to return a slice from
    a `deque` as a list shortly).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列，或称为双端队列（通常发音为 *decks*），是类似列表的对象，支持线程安全的、内存高效的追加操作。双端队列是可变的，并支持列表的一些操作，如索引。可以通过索引赋值，例如，`dq[1]
    = z`；然而，我们无法直接对双端队列进行切片。例如，`dq[1:2]` 会导致一个 `TypeError`（我们将在稍后查看如何从 `deque` 返回一个列表作为示例）。
- en: The major advantage of deques over lists is that inserting items at the beginning
    of a deque is much faster than inserting items at the beginning of a list, although
    inserting items at the end of a `deque` is very slightly slower than the equivalent
    operation on a list. Deques are thread, safe and can be serialized using the `pickle`
    module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，双端队列的主要优势是在双端队列的开始处插入项目比在列表的开始处插入项目要快得多，尽管在 `deque` 的末尾插入项目比在列表上执行等效操作要稍微慢一些。双端队列是线程安全的，可以使用
    `pickle` 模块进行序列化。
- en: 'A useful way of thinking about deques is in terms of populating and consuming
    items. Items in deques are usually populated and consumed sequentially from either
    end:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于双端队列的一个有用思考方式是关于填充和消耗项目。双端队列中的项目通常从两端按顺序填充和消耗：
- en: '![](img/image_02_023.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_023.png)'
- en: 'We can use the `pop()` and `popleft()` methods for consuming items in the `deque`,
    for example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `pop()` 和 `popleft()` 方法在 `deque` 中消耗项目，例如：
- en: '![](img/image_02_024.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_024.png)'
- en: 'We can also use the `rotate(n)` method to move and rotate all items of *n*
    steps to the right for positive values of the integer *n*, or left for negative
    values of n the left, using positive integers as the argument, for example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `rotate(n)` 方法将所有项目向右移动并旋转 *n* 步，对于正整数的 *n*，或者对于负整数的 *n* 向左移动，使用正整数作为参数，例如：
- en: '![](img/image_02_025.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_025.png)'
- en: 'Note that we can use the `rotate` and `pop` methods to delete selected elements.
    Also worth knowing is a simple way to return a slice of a deque, as a list, which
    can be done as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用 `rotate` 和 `pop` 方法来删除选定的元素。还值得知道的一个简单方法是将双端队列的切片作为列表返回，可以按照以下方式完成：
- en: '![](img/image_02_026.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_026.png)'
- en: The `itertools.islice` method works in the same way that slice works on a list,
    except rather than taking a list for an argument, it takes an iterable and returns
    selected values, by start and stop indices, as a list.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.islice` 方法的工作方式与列表上的切片操作相同，不同之处在于它接受一个可迭代对象作为参数，而不是列表，并通过起始和结束索引返回选定的值，作为一个列表。'
- en: 'A useful feature of deques is that they support a `maxlen` optional parameter
    that restricts the size of the `deque`. This makes it ideally suited to a data
    structure known as a **circular buffer**. This is a fixed-size structure that
    is effectively connected end to end and they are typically used for buffering
    data streams. The following is a basic example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列（deque）的一个有用特性是它支持一个可选的 `maxlen` 参数，该参数限制了 `deque` 的大小。这使得它非常适合称为**循环缓冲区**的数据结构。这是一个固定大小的结构，它实际上是通过端到端连接的，并且通常用于缓冲数据流。以下是一个基本示例：
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This prints out the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下内容：
- en: '![](img/image_02_027.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_027.png)'
- en: In this example, we are populating from the right and consuming from the left.
    Notice that once the buffer is full, the oldest values are consumed first, and
    values are replaced from the right. We will look at circular buffers again in
    [Chapter 4](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml), *Lists and Pointer Structures*,
    by implementing circular lists.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从右侧填充，从左侧消费。请注意，一旦缓冲区满了，最旧的数据首先被消费，然后从右侧替换数据。我们将在 [第 4 章](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml)，*列表和指针结构*中再次讨论循环缓冲区，通过实现循环列表来做到这一点。
- en: ChainMaps
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChainMaps
- en: 'The `collections.chainmap` class was added in Python 3.2 and it provides a
    way to link a number of dictionaries, or other mappings, so that they can be treated
    as one object. In addition, there is a `maps` attribute, a `new_child()` method,
    and a `parents` property. The underlying mappings for `ChainMap` objects are stored
    in a list and are accessible using the `maps[*i*]` attribute to retrieve the `ith`
    dictionary. Note that even though dictionaries themselves are unordered, ChainMaps
    are an ordered list of dictionaries. `ChainMap` is useful in applications where
    we are using a number of dictionaries containing related data. The consuming application
    expects data in terms of a priority, where the same key in two dictionaries is
    given priority if it occurs at the beginning of the underlying list. `ChainMap` is
    typically used to simulate nested contexts such as when we have multiple overriding
    configuration settings. The following example demonstrates a possible use case
    for `ChainMap`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.2 中添加了 `collections.chainmap` 类，它提供了一种将多个字典或其他映射链接起来的方法，这样它们就可以被当作一个对象来处理。此外，还有一个
    `maps` 属性，一个 `new_child()` 方法，以及一个 `parents` 属性。`ChainMap` 对象的底层映射存储在一个列表中，可以通过
    `maps[*i*]` 属性来访问以检索第 `i` 个字典。请注意，尽管字典本身是无序的，但 ChainMaps 是字典的有序列表。`ChainMap` 在我们使用包含相关数据的多个字典的应用程序中非常有用。消费应用程序期望以优先级的方式提供数据，其中两个字典中相同的键如果在底层列表的开头出现，则具有优先级。`ChainMap`
    通常用于模拟嵌套上下文，例如当我们有多个覆盖配置设置时。以下是一个 `ChainMap` 的可能用例示例：
- en: '![](img/image_02_028.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_028.png)'
- en: The advantage of using ChainMaps, rather than just a dictionary, is that we
    retain previously set values. Adding a child context overrides values for the
    same key, but it does not remove it from the data structure. This can be useful
    for when we may need to keep a record of changes so that we can easily roll back
    to a previous setting.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ChainMaps 而不是仅仅使用字典的优势在于，我们保留了之前设置的值。添加子上下文会覆盖相同键的值，但不会从数据结构中删除它。这在我们可能需要记录更改以便我们可以轻松回滚到之前的设置时非常有用。
- en: 'We can retrieve and change any value in any of the dictionaries by providing
    the `map()` method with an appropriate index. This index represents a dictionary
    in the ChainMap. Also, we can retrieve the parent setting, that is, the default
    settings, by using the `parents()` method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 `map()` 方法提供一个适当的索引来检索和更改任何字典中的任何值。这个索引代表 ChainMap 中的一个字典。此外，我们可以通过使用
    `parents()` 方法来检索父设置，即默认设置：
- en: '![](img/image_02_029.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_029.png)'
- en: Counter objects
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器对象
- en: 'Counter is a subclass of a dictionary where each dictionary `key` is a hashable
    object and the associated value is an integer count of that object. There are
    three ways to initialize a counter. We can pass it any sequence object, a dictionary
    of `key:value` pairs, or a tuple of the format `(object = value, ...)`, for example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是字典的一个子类，其中每个字典 `key` 是一个可哈希的对象，与之关联的值是该对象的整数计数。初始化计数器有三种方式。我们可以传递任何序列对象，一个
    `key:value` 对的字典，或者一个格式为 `(object = value, ...)` 的元组，例如：
- en: '![](img/image_02_030.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_030.png)'
- en: 'We can also create an empty counter object and populate it by passing its `update`
    method an iterable or a dictionary, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个空的计数器对象，并通过传递其 `update` 方法的可迭代对象或字典来填充它，例如：
- en: '![](img/image_02_031.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_031.png)'
- en: 'Notice how the `update` method adds the counts rather than replacing them with
    new values. Once the counter is populated, we can access stored values in the
    same way we would for dictionaries, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`update`方法是如何添加计数而不是用新值替换它们的。一旦Counter被填充，我们可以像访问字典中的值一样访问存储的值，例如：
- en: '![](img/image_02_032.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_032.png)'
- en: 'The most notable difference between counter objects and dictionaries is that
    counter objects return a zero count for missing items rather than raising a `key`
    error, for example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Counter对象与字典之间最显著的区别是，Counter对象对于缺失的项返回零计数，而不是抛出`key`错误，例如：
- en: '![](img/image_02_033.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_033.png)'
- en: 'We can create an iterator out of a `Counter` object by using its `elements()`
    method. This returns an iterator where counts below one are not included and the
    order is not guaranteed. In the following code, we perform some updates, create
    an iterator from `Counter` elements, and use `sorted()` to sort the keys alphabetically:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Counter`对象的`elements()`方法来从`Counter`对象创建一个迭代器。这个迭代器不包括计数小于一的元素，并且顺序没有保证。在下面的代码中，我们执行了一些更新，从`Counter`元素创建了一个迭代器，并使用`sorted()`对键进行字母排序：
- en: '![](img/image_02_034.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_034.png)'
- en: 'Two other Counter methods worth mentioning are `most_common()` and `subtract()`.
    The most common method takes a positive integer argument that determines the number
    of most common elements to return. Elements are returned as a list of `(key ,value)`
    tuples. The `subtract` method works exactly like update except instead of adding
    values, it subtracts them, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的另外两种Counter方法有`most_common()`和`subtract()`。`most_common()`方法接受一个正整数参数，用于确定返回最常见元素的数量。元素以`(key,
    value)`元组的列表形式返回。`subtract`方法的工作方式与`update`方法类似，但不同的是它不是添加值，而是减去值，例如：
- en: '![](img/image_02_035.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_035.png)'
- en: Ordered dictionaries
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: 'The important thing about ordered dictionaries is that they remember the insertion
    order, so when we iterate over them, they return values in the order they were
    inserted. This is in contrast to a normal dictionary, where the order is arbitrary.
    When we test to see whether two dictionaries are equal, this equality is only
    based on their keys and values; however, with an `OrderedDict`, the insertion
    order is also considered An equality test between two OrderedDicts with the same
    keys and values but a different insertion order will return `False`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有序字典的重要之处在于它们会记住插入顺序，因此当我们迭代它们时，它们会按插入顺序返回值。这与正常字典不同，正常字典的顺序是任意的。当我们测试两个字典是否相等时，这种相等性仅基于它们的键和值；然而，对于`OrderedDict`，插入顺序也会被考虑。具有相同键和值但不同插入顺序的两个`OrderedDict`之间的相等性测试将返回`False`：
- en: '![](img/image_02_036.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_036.png)'
- en: 'Similarly, when we add values from a list using `update`, the `OrderedDict`
    will retain the same order as the list. This is the order that is returned when
    we iterate the values, for example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们使用`update`从列表中添加值时，`OrderedDict`将保留与列表相同的顺序。这是我们在迭代值时返回的顺序，例如：
- en: '![](img/image_02_037.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_037.png)'
- en: 'The `OrderedDict` is often used in conjunction with the sorted method to create
    a sorted dictionary. For example, in the following example we use a `lambda` function
    to sort on the values, here we use a numerical expression to sort the integer
    values:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`通常与`sorted`方法一起使用来创建排序字典。例如，在下面的示例中，我们使用`lambda`函数按值排序，这里我们使用数值表达式来排序整数值：'
- en: '![](img/image_02_038.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_038.png)'
- en: defaultdict
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'The `defaultdict` object is a subclass of `dict` and therefore they share methods
    and operations. It acts as a convenient way to initialize dictionaries. With a
    `dict`, Python will throw a `KeyError` when attempting to access a key that is
    not already in the dictionary. The `defaultdict` overrides one method, `__missing__(key)`,
    and creates a new instance variable, `default_factory`. With `defaultdict`, rather
    than throw an error, it will run the function, supplied as the `default_factory`
    argument, which will generate a value. A simple use of `defaultdict` is to set
    `default_factory` to `int` and use it to quickly tally the counts of items in
    the dictionary, for example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`对象是`dict`的子类，因此它们共享方法和操作。它是一种方便初始化字典的方式。使用`dict`时，Python会在尝试访问不在字典中的键时抛出`KeyError`。`defaultdict`覆盖了一个方法`__missing__(key)`，并创建了一个新的实例变量`default_factory`。使用`defaultdict`时，而不是抛出错误，它将运行作为`default_factory`参数提供的函数，该函数将生成一个值。`defaultdict`的一个简单用法是将`default_factory`设置为`int`，并快速统计字典中项的计数，例如：'
- en: '![](img/image_02_039.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_039.png)'
- en: 'You will notice that if we tried to do this with an ordinary dictionary, we
    would get a key error when we tried to add the first key. The `int` we supplied
    as an argument to default `dict` is really the function `int()` that simply returns
    a zero. We can, of course, create a function that will determine the dictionary''s
    values. For example, the following function returns `True` if the supplied argument
    is a primary color, that is red, green, or blue, or returns `False` otherwise:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果我们尝试用普通的字典来做这件事，当我们尝试添加第一个键时，我们会得到一个键错误。我们提供给默认 `dict` 的 `int` 参数实际上是返回零的函数
    `int()`。我们当然可以创建一个函数来确定字典的值。例如，以下函数如果提供的参数是主色（即红色、绿色或蓝色），则返回 `True`，否则返回 `False`：
- en: '[PRE11]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now create a new `defaultdict` object and use the `isprimary` function
    to populate it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个新的 `defaultdict` 对象，并使用 `isprimary` 函数来填充它：
- en: '![](img/image_02_040.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_040.png)'
- en: Named Tuples
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: The `namedtuple` method returns a tuple-like object that has fields accessible
    with named indexes as well as the integer indexes of normal tuples. This allows
    for code that is, to a certain extent, self-documenting and more readable. It
    can be especially useful in an application where there is a large number of tuples
    and we need to easily keep track of what each tuple represents. The `namedtuple`
    inherits methods from `tuple` and it is backward-compatible with `tuple`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple` 方法返回一个类似元组的对象，它具有字段，可以通过命名索引以及正常元组的整数索引访问。这允许代码在一定程度上自我文档化，并且更易于阅读。在存在大量元组且需要轻松跟踪每个元组代表的内容的应用程序中，这特别有用。`namedtuple`
    继承了 `tuple` 的方法，并且与 `tuple` 兼容。'
- en: 'The field names are passed to the `namedtuple` method as comma and/or whitespace
    separated values. They can also be passed as a sequence of strings. Field names
    are single strings and they can be any legal Python identifier that does not begin
    with a digit or an underscore. A typical example is shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称作为逗号和/或空格分隔的值传递给 `namedtuple` 方法。它们也可以作为字符串序列传递。字段名称是单个字符串，并且可以是任何合法的 Python
    标识符，但不能以数字或下划线开头。这里有一个典型的示例：
- en: '![](img/image_02_041.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_041.png)'
- en: 'The `namedtuple` method take two optional Boolean arguments, `verbose` and
    `rename`. When `verbose` is set to `True` then the class definition is printed
    when it is built. This argument is depreciated in favor of using the `__source`
    attribute. When the `rename` argument is set to `True` then any invalid field
    names will be automatically replaced with positional arguments. As an example,
    we attempt to use `def` as a field name. This would normally generate an error,
    but since we have assigned `rename` to `True`, the Python interpreter allows this.
    However, when we attempt to look up the `def` value, we get a syntax error, since
    `def` is a reserved keyword. The illegal field name has been replaced by a field
    name created by adding an underscore to the positional value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple` 方法接受两个可选的布尔参数，`verbose` 和 `rename`。当 `verbose` 设置为 `True` 时，在构建类定义时将打印出类定义。此参数已被
    `__source` 属性所取代。当 `rename` 参数设置为 `True` 时，任何无效的字段名称将被自动替换为位置参数。例如，我们尝试使用 `def`
    作为字段名称。这通常会产生错误，但由于我们将 `rename` 设置为 `True`，Python 解释器允许这样做。然而，当我们尝试查找 `def` 值时，由于
    `def` 是一个保留关键字，我们会得到一个语法错误。非法字段名称已被添加下划线的位置值创建的字段名称所替换：'
- en: '![](img/image_02_042.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_042.png)'
- en: 'In addition to the inherited tuple methods, the named tuple also defines three
    methods of its own, `_make()` , `asdict()`, and `_replace`. These methods begin
    with an underscore to prevent potential conflicts with field names. The `_make()`
    method takes an iterable as an argument and turns it into a named tuple object,
    for example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承的元组方法外，命名元组还定义了它自己的三个方法，`_make()`、`asdict()` 和 `_replace`。这些方法以前缀下划线开头，以防止与字段名称发生潜在冲突。`_make()`
    方法接受一个可迭代对象作为参数，并将其转换为命名元组对象，例如：
- en: '![](img/image_02_043.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_043.png)'
- en: 'The `_asdict` method returns an `OrderedDict` with the field names mapped to
    index keys and the values mapped to the dictionary values, for example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`_asdict` 方法返回一个 `OrderedDict`，字段名称映射到索引键，值映射到字典值，例如：'
- en: '![](img/image_02_044.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_044.png)'
- en: 'The `_replace` method returns a new instance of the tuple, replacing the specified
    values, for example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`_replace` 方法返回一个新的元组实例，替换指定的值，例如：'
- en: '![](img/image_02_045.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_045.png)'
- en: Arrays
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: The array module defines a datatype `array` that is similar to the `list` datatype
    except for the constraint that their contents must be of a single type of the
    underlying representation, as is determined by the machine architecture or underlying
    C implementation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 数组模块定义了一个类似于 `list` 数据类型的 `array` 数据类型，除了它们的约束是它们的必须包含底层表示的单一种类的数据，这由机器架构或底层
    C 实现确定。
- en: 'The type of an array is determined at creation time and it is indicated by
    one of the following type codes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型在创建时确定，并由以下类型代码之一指示：
- en: '| Code | C type | Python type | Minimum bytes |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 代码类型 | C 类型 | Python 类型 | 最小字节数 |'
- en: '| `''b''` | `signed char` | `int` | 1 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `''b''` | `signed char` | `int` | 1 |'
- en: '| `''B''` | `unsigned char` | `int` | 1 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `''B''` | `unsigned char` | `int` | 1 |'
- en: '| `''u''` | `Py_UNICODE` | `Unicode character` | 2 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `''u''` | `Py_UNICODE` | `Unicode 字符` | 2 |'
- en: '| `''h''` | `signed short` | `int` | 2 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `''h''` | `signed short` | `int` | 2 |'
- en: '| `''H''` | `unsigned short` | `int` | 2 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `''H''` | `unsigned short` | `int` | 2 |'
- en: '| `''i''` | `signed int` | `int` | 2 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `''i''` | `signed int` | `int` | 2 |'
- en: '| `''I''` | `unsigned int` | `int` | 2 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `''I''` | `unsigned int` | `int` | 2 |'
- en: '| `''l''` | `signed long` | `int` | 4 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `''l''` | `signed long` | `int` | 4 |'
- en: '| `''L''` | `unsigned long` | `int` | 8 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `''L''` | `unsigned long` | `int` | 8 |'
- en: '| `''q''` | `signed long long` | `int` | 8 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `''q''` | `signed long long` | `int` | 8 |'
- en: '| `''Q''` | `unsigned lon long` | `int` | 8 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `''Q''` | `unsigned long long` | `int` | 8 |'
- en: '| `''f''` | `float` | `float` | 4 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `''f''` | `float` | `float` | 4 |'
- en: '| `''d''` | `double` | `float` | 8 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `''d''` | `double` | `float` | 8 |'
- en: 'The array objects support the following attributes and methods:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象支持以下属性和方法：
- en: '| Attribute or method | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 属性或方法 | 描述 |'
- en: '| `a.typecode` | The typecode character used to create the array. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `a.typecode` | 创建数组时使用的类型代码字符。|'
- en: '| `a.itemsize` | Size, in bytes, of items stored in the array. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `a.itemsize` | 存储在数组中的项的大小，以字节为单位。|'
- en: '| `a.append(x)` | Appends item `x` to the end of the array. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `a.append(x)` | 将项 `x` 追加到数组的末尾。|'
- en: '| `a.buffer_info()` | Returns the memory location and length of the buffer
    used to store the array. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `a.buffer_info()` | 返回用于存储数组的内存位置和长度。|'
- en: '| `a.byteswap()` | Swaps the byte order of each item. Used for writing to a
    machine or file with a different byte order. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `a.byteswap()` | 交换每个项的字节顺序。用于写入具有不同字节顺序的机器或文件。|'
- en: '| `a.count(x)` | Returns the number of occurrences of `x` in `a`. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `a.count(x)` | 返回 `a` 中 `x` 的出现次数。|'
- en: '| `a.extend(b)` | Appends any iterable, `b`, to the end of array `a`. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `a.extend(b)` | 将任何可迭代对象 `b` 追加到数组 `a` 的末尾。|'
- en: '| `a.frombytes(s)` | Appends items from a string, `s`, as an array of machine
    values. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `a.frombytes(s)` | 从字符串 `s` 中追加项作为机器值数组。|'
- en: '| `a.fromfile(f, n)` | Reads `n` items, as machine values, from a file object,
    `f`, and appends them to `a`. Raises an `EOFError` if there are fewer than `n`
    items in `n`. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromfile(f, n)` | 从文件对象 `f` 中读取 `n` 项，作为机器值，并将它们追加到 `a` 中。如果 `n` 中的项少于
    `n`，则引发 `EOFError`。|'
- en: '| `a.fromlist(l)` | Appends items from list `l`. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromlist(l)` | 从列表 `l` 中追加项。|'
- en: '| `a.fromunicode(s)` | Extends `a` with unicode string `s`. Array `a` must
    be of type `u` or else `ValueError` is raised. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromunicode(s)` | 使用 Unicode 字符串 `s` 扩展 `a`。如果数组 `a` 的类型不是 `u`，则引发 `ValueError`。|'
- en: '| `index(x)` | Returns the first (smallest) index of item `x.` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `index(x)` | 返回项 `x` 的第一个（最小的）索引。|'
- en: '| `a.insert(i, x)` | Inserts item `x` before index `i.` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `a.insert(i, x)` | 在索引 `i` 之前插入项 `x`。|'
- en: '| `a.pop([i])` | Removes and returns items with index `i`. Defaults to the
    last item `(i = -1)` if not specified. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `a.pop([i])` | 移除并返回索引为 `i` 的项。如果未指定，则默认为最后一个项 `(i = -1)`。|'
- en: '| `a.remove(x)` | Removes the first occurrence of item `x`. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `a.remove(x)` | 移除项 `x` 的第一个出现。|'
- en: '| `a.reverse()` | Reverses the order of items. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `a.reverse()` | 反转项的顺序。|'
- en: '| `a.tobytes()` | Convert the array to machine values and returns the bytes
    representation. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `a.tobytes()` | 将数组转换为机器值并返回字节表示。|'
- en: '| `a.tofile(f)` | Writes all items, as machine values, to file object `f`.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `a.tofile(f)` | 将所有项，作为机器值，写入文件对象 `f`。|'
- en: '| `a.tolist()` | Converts the array to a list. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `a.tolist()` | 将数组转换为列表。|'
- en: '| `a.tounicode()` | Convert an array to `unicode` string. The array type must
    be `''u''` or else a `ValueError` is raised. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `a.tounicode()` | 将数组转换为 `unicode` 字符串。数组类型必须是 `''u''`，否则引发 `ValueError`。|'
- en: Array objects support all the normal sequence operations such as indexing, slicing,
    concatenation, and multiplication.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象支持所有正常的序列操作，如索引、切片、连接和乘法。
- en: 'Using arrays, as opposed to lists, is a much more efficient way of storing
    data that is all of the same type. In the following example, we have created an
    integer array of the digits from 0 to 1 million minus 1, and an identical list.
    Storing 1 million integers in an integer array requires around 45% of the memory
    of an equivalent list:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，使用数组存储所有相同类型的数据是一种更有效的方式。在下面的例子中，我们创建了一个包含从0到100万减1的数字的整数数组和一个相同的列表。在整数数组中存储100万个整数大约需要相当于列表的45%的内存：
- en: '![](img/image_02_046.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_046.png)'
- en: 'Because we are interested in saving space, that is, we are dealing with large
    datasets and limited memory size, we usually perform in-place operations on arrays,
    and only create copies when we need to. Typically, enumerate is used to perform
    an operation on each element. In the following snippet, we perform the simple
    operation of adding one to each item in the array:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注节省空间，也就是说，我们在处理大量数据集和有限的内存大小，我们通常在数组上执行原地操作，并且只有在需要时才创建副本。通常，枚举用于对每个元素执行操作。在下面的代码片段中，我们执行了将数组中每个元素加一的简单操作：
- en: '![](img/image_02_047.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_047.png)'
- en: 'It should be noted that when performing operations on arrays that create lists,
    such as list comprehensions, the memory efficiency gains of using an array in
    the first place will be negated. When we need to create a new data object, a solution
    is to use a generator expression to perform the operation, for example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，当对创建列表的数组执行操作时，例如列表推导式，使用数组带来的内存效率提升将会被抵消。当我们需要创建一个新的数据对象时，一个解决方案是使用生成器表达式来执行操作，例如：
- en: '![](img/image_02_048.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_048.png)'
- en: Arrays created with this module are unsuitable for work that requires a matrix
    of vector operations. In the next chapter, we will build our own abstract data
    type to deal with these operations. Also important for numerical work is the `NumPy`
    extension, available at [www.numpy.org](http://www.numpy.org) .
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模块创建的数组不适合需要矩阵或向量操作的工作。在下一章中，我们将构建自己的抽象数据类型来处理这些操作。对于数值工作也很重要的是`NumPy`扩展，可在[www.numpy.org](http://www.numpy.org)找到。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the last two chapters, we have examined the language features and data types
    of Python. We have looked at the built-in data types and some internal Python
    modules, most notably the collections module. There are also several other Python
    modules that are relevant to the topic of this book, but rather than examining
    them separately, their use and functionality should become self-evident as we
    begin using them. There are also a number of external libraries such as the SciPy
    stack, and, likewise, I will attempt to explain their basic functionality as we
    begin to apply them.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们已经探讨了Python的语言特性和数据类型。我们查看了一些内置数据类型和一些内部Python模块，最值得注意的是collections模块。还有其他几个与本书主题相关的Python模块，但与其单独检查它们，不如在我们开始使用它们时，它们的使用和功能应该变得显而易见。还有一些外部库，如SciPy堆栈，同样，我将在我们开始应用它们时尝试解释它们的基本功能。
- en: In the next chapter, we will introduce the basic theory and techniques of algorithm
    design.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍算法设计的基本理论和技巧。
