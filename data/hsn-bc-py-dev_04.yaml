- en: Implementing Smart Contracts Using Vyper
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vyper实现智能合约
- en: Many programmers who are learning how to write a smart contract will learn about
    the Solidity programming language. There are abundant sources of online tutorials
    and books that can teach you about Solidity. When combined with the Truffle framework,
    Solidity forms a killer combo for developing a smart contract. Almost all smart
    contracts that live on the Ethereum blockchain are written in the Solidity programming
    language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多学习如何编写智能合约的程序员会学习Solidity编程语言。有丰富的在线教程和书籍可以教你Solidity。与Truffle框架结合使用，Solidity形成了一个开发智能合约的绝佳组合。几乎所有存在于以太坊区块链上的智能合约都是用Solidity编程语言编写的。
- en: In this chapter, we will explore how to write a smart contract. However, we
    are not going to use the Solidity programming language for this. Instead, we will
    use the Vyper programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何编写智能合约。但我们不会使用Solidity编程语言。相反，我们将使用Vyper编程语言。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Motivations behind Vyper
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vyper背后的动机
- en: Installing Vyper
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Vyper
- en: Creating a smart contract using Vyper
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vyper创建智能合约
- en: Deploying a smart contract to Ganache
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能合约部署到Ganache
- en: Going deeper into Vyper
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Vyper
- en: Interacting with other smart contracts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他智能合约互动
- en: Compiling code programmatically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式编译代码
- en: Other tricks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他技巧
- en: Motivations behind Vyper
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vyper背后的动机
- en: Writing a smart contract is different than developing a normal web application.
    When developing a normal web application, the motto is *move fast and break things*.
    The speed of developing a web application is paramount. If there is a bug in the
    application, you can always upgrade the application later. Alternatively, if the
    bug is catastrophic, you can patch it online or take the application offline before
    introducing a fix. There is a very popular word to describe the ideal mindset
    in developing a normal web application—agile. You need to be flexible in order
    to change the software as the requirements change.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写智能合约与开发普通的Web应用程序是不同的。在开发普通的Web应用程序时，座右铭是“快速移动，打破事物”。开发Web应用程序的速度至关重要。如果应用程序中有错误，你可以随后升级应用程序。或者，如果错误是灾难性的，你可以在线修补它或在引入修复之前将应用程序下线。有一个非常流行的词来描述开发普通Web应用程序的理想思维方式——敏捷。你需要灵活，以便随着需求的变化改变软件。
- en: However, writing a smart contract requires a different mindset. The application
    of smart contracts can range from writing a financial application to launching
    a rocket into space. Fixing an error once a smart contract is deployed is very
    difficult. You cannot replace a smart contract because once it is deployed, it
    is deployed. You can destroy a smart contract if you write a function to do so,
    but the only way to fix a faulty smart contract is to deploy a new smart contract
    that has the fix to the error in a new address, and then communicate this situation
    to all concerned parties. But you cannot replace a smart contract.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写智能合约需要不同的思维方式。智能合约的应用范围可以从编写金融应用程序到将火箭发射到太空。一旦部署了智能合约，要修复错误就非常困难。你不能替换智能合约，因为一旦部署了，就无法更改。如果编写一个函数来销毁智能合约，你可以销毁智能合约，但修复有问题的智能合约的唯一方法是部署一个新的智能合约，在新的地址中修复错误，然后将这种情况通知所有相关方。但你不能替换智能合约。
- en: So, the ideal situation would be a smart contract deployed on the blockchain
    with no bugs, or at least without malignant bugs. However, bugs still appear in
    smart contracts that are released in the real world.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理想的情况是在区块链上部署一个没有错误的智能合约，或者至少没有恶性错误。然而，在现实世界中发布的智能合约仍然会出现错误。
- en: So, what kind of bugs can appear in smart contracts? The first kind is the one
    that will make your money disappear. Let’s say you are writing a smart contract
    for an **initial coin offering** (**ICO**). An ICO is the accumulation of capital
    by selling tokens that you have created on top of an Ethereum blockchain. So basically,
    people buy your token with ethers. You can set the price as you like—for example,
    *1 ETH = 100 YOURTOKEN*. This means that people would get 100 of your tokens if
    they pay you 1 ether.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，智能合约中可能出现什么样的错误？第一种是会让你的资金消失的错误。比如，你正在为一个**首次代币发行**（**ICO**）编写智能合约。ICO是通过在以太坊区块链上出售你创建的代币来积累资本。基本上，人们用以太币购买你的代币。你可以自行设置价格，例如*1
    ETH = 100 YOURTOKEN*。这意味着人们如果支付给你1个以太币，他们将获得100个你的代币。
- en: The first bug that you can introduce is that people can send money (ethers)
    to your smart contract, but you cannot withdraw it (either you forgot to implement
    the withdrawal method or the withdrawal method is faulty). This would mean that
    you could check your smart contract’s balance, and the ether balance could well
    be worth $1 million, but it would be stuck there forever and no one would be able
    to claim it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能引入的第一个错误是人们可以向你的智能合约发送资金（以太币），但你无法提取它（要么你忘记实现提取方法，要么提取方法有问题）。这意味着你可以检查你的智能合约余额，以太币余额可能值得100万美元，但它将永远被困在那里，没有人能够索取它。
- en: Another bug could be that you forgot to secure the method to destroy a smart
    contract. In Ethereum, you are incentivized to remove stuff from the blockchain
    because storage is expensive. So if you deploy a smart contract, you will pay
    a gas fee because your smart contract will be kept. You can experiment with it,
    and then if you get bored with your smart contract, you can destroy it. To do
    that, Ethereum will give some gas back to your account. This is to discourage
    spamming the Ethereum blockchain. So, going back to our case of the smart contract’s
    bug, imagine that you have accumulated $1 million worth of ether in your smart
    contract, and then someone destroys your smart contract account by accessing a
    function to destroy it. In this case, your ether balance will be destroyed as
    well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误可能是您忘记保护销毁智能合约的方法。在以太坊中，您有动机从区块链中删除东西，因为存储是昂贵的。因此，如果您部署了一个智能合约，您将支付燃气费，因为您的智能合约将被保留。您可以对其进行实验，然后如果您对您的智能合约感到厌倦，您可以销毁它。为此，以太坊将返还一些燃气到您的账户。这是为了阻止垃圾邮件攻击以太坊区块链。因此，回到我们智能合约错误的案例，想象一下您在智能合约中积累了价值100万美元的以太币，然后有人通过访问销毁它的功能销毁了您的智能合约账户。在这种情况下，您的以太币余额也将被销毁。
- en: The last type of bug is one that allows a hacker to steal your ether balance
    and move it to their account. This could occur under many different circumstances.
    For example, maybe you forgot to the set correct permissions in the withdrawal
    function, or maybe the permission in the withdrawal function is too open.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种错误是允许黑客窃取您的以太坊余额并将其转移到他们的账户。这可能发生在许多不同的情况下。例如，也许您忘记在提款功能中设置正确的权限，或者提款功能中的权限太开放。
- en: Of course, all of these bugs can be traced back to the fault of the programmers.
    To avoid these kinds of bugs, a new kind of job was born—a smart contract auditor,
    who audits your smart contract to make sure it does not have bugs. However, Vitalik
    Buterin (the inventor of Ethereum) then looked at the tool (the programming language,
    in this case) and wondered whether this situation could be mitigated by improving
    the tool itself. The culprit in this case is the Solidity programming language.
    Vitalik argued that Solidity has some features that are powerful, but have the
    potential to create bugs. Although the developers of Solidity had a plan to improve
    the safety of Solidity, Vitalik wanted some freedom to experiment with a fresh
    perspective. From this, Vyper was born.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些错误都可以追溯到程序员的错误。为了避免这些错误，一个新的工作岗位诞生了——智能合约审计员，他审计您的智能合约，以确保它没有错误。然而，以太坊的发明者Vitalik
    Buterin随后审视了工具（在这种情况下是编程语言），并想知道是否可以通过改进工具本身来缓解这种情况。这种情况的罪魁祸首是Solidity编程语言。Vitalik认为Solidity具有一些功能是强大的，但可能会产生错误。尽管Solidity的开发人员有改进Solidity安全性的计划，但Vitalik希望有一些自由来尝试新的视角。Vyper就是从这里诞生的。
- en: Say that you created a parent class that has an important function. In your
    current or child class, you use this function without checking its definition.
    Perhaps the parent class was written by someone else in your team. Programmers
    are sometimes too lazy to check function definitions in other files; they will
    scroll up and down in a source code file to read the code, but programmers often
    will not check code in other files enabled by the inheritance feature.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您创建了一个具有重要功能的父类。在当前或子类中，您使用此功能而不检查其定义。也许父类是由您团队中的其他人编写的。程序员有时懒得检查其他文件中的函数定义；他们会在源代码文件中上下滚动以阅读代码，但程序员通常不会检查继承功能启用的其他文件中的代码。
- en: 'Another Solidity feature that could really make a smart contract complicated
    and hard to read is a modifier, which is like a preliminary function. The following
    code shows how a modifier is used in Solidity:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能使智能合约复杂且难以阅读的Solidity功能是修饰符，它类似于一个预备函数。以下代码显示了修饰符在Solidity中的使用方式：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we want to use the `withdraw()` method, the smart contract will execute the `onlyBy()`
    modifier method first. The `require` phrase is used to ensure that `msg.sender`
    (which calls this method) is the same as the `account` variable that was sent
    as a parameter. This example is simple. You can read all of the code in the blink
    of an eye. However, consider the fact that these functions are separated by many
    lines, or even defined in another file. Programmers have a tendency to overlook
    the definition of the `onlyBy()` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用`withdraw()`方法，智能合约将首先执行`onlyBy()`修饰符方法。使用`require`短语是为了确保调用此方法的`msg.sender`与作为参数发送的`account`变量相同。这个例子很简单。您可以一眼看完所有的代码。然而，请考虑这些函数是由许多行分隔开的，甚至在另一个文件中定义。程序员往往会忽视`onlyBy()`方法的定义。
- en: 'Function overloading is one of the most powerful features in programming languages.
    This is a feature that enables you to send different parameters to get different
    functions, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是编程语言中最强大的功能之一。这是一个使您能够发送不同参数以获得不同函数的功能，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the function overloading feature can mislead programmers, causing them
    to execute a function with a different intention. A programmer might only remember
    that the `flexible_function` function does this, but could innocently execute
    a different kind of function than `flexible_function`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数重载功能可能会误导程序员，导致他们执行不同意图的函数。程序员可能只记得`flexible_function`函数是这样做的，但可能会无意中执行与`flexible_function`不同类型的函数。
- en: Consequently, some smart people decided that while all of these features make
    it possible to create a really complex program, these features should be limited
    to developing a smart contract. Perhaps they got this idea from those who write
    programs on spacecraft, where there are rules as to which features of C++ are
    forbidden to be used. Alternatively, they could have been inspired by the reason
    why Java was created to replace C++. In Java, direct manipulation of the memory
    feature was not possible. Bjarne Stroustoup (the creator of C++) said that C++
    is so powerful that with C++, people can shoot themselves in their foot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些聪明的人决定，虽然所有这些功能使得创建一个非常复杂的程序成为可能，但这些功能应该被限制在开发智能合约上。也许他们从太空飞船上编写程序的人那里得到了这个想法，在那里有规定禁止使用C++的某些功能。或者，他们可能受到了Java为何被创建来取代C++的启发。在Java中，不可能直接操纵内存。C++的创造者Bjarne
    Stroustoup说，C++是如此强大，以至于人们可以用C++自己打自己的脚。
- en: These smart people decided to create a new programming language that is simpler
    than Solidity. Python is their main inspiration because the syntax of this programming
    language is derived from Python. This programming language is called **Vyper**.
    In Vyper, features such as inheritance, function overloading, modifiers, and many
    others are removed. The creator of the Vyper programming language argued that
    the removal of these features can make the development of a smart contract easier.
    Importantly, it also makes the code easier to read. Code is read much more than
    it is written. With all of these factors, they hope that programmers could create
    fewer bugs when using the Vyper programming language to create a smart contract.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些聪明的人决定创建一种比Solidity更简单的新编程语言。Python是他们的主要灵感，因为这种编程语言的语法源自Python。这种编程语言被称为**Vyper**。在Vyper中，诸如继承、函数重载、修饰符等功能都被移除了。Vyper编程语言的创造者认为，移除这些功能可以使智能合约的开发更容易。重要的是，它还使代码更易于阅读。代码的阅读远远多于编写。考虑到所有这些因素，他们希望程序员在使用Vyper编程语言创建智能合约时能够减少错误。
- en: Installing Vyper
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vyper
- en: By default, Ubuntu Xenial has Python 3.5 installed. Vyper needs Python 3.6 software,
    and so you will need to install Python 3.6 first if you want to use Ubuntu Xenial.
    A newer version of Ubuntu, such as Bionic Beaver, will have Python 3.6 installed
    already.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ubuntu Xenial安装了Python 3.5。Vyper需要Python 3.6软件，因此如果您想使用Ubuntu Xenial，您需要首先安装Python
    3.6。较新版本的Ubuntu，如Bionic Beaver，将已经安装了Python 3.6。
- en: 'So, if you don''t have Python 3.6 software installed, you must install it first
    using the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您没有安装Python 3.6软件，您必须首先使用以下命令安装它：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It’s not just Python 3.6 that is required by Vyper; you need to install the
    development files `python3.6-dev` as well. Then you can create a virtual environment
    for Python 3.6 by going through the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper需要的不仅仅是Python 3.6；您还需要安装开发文件`python3.6-dev`。然后，您可以通过以下步骤为Python 3.6创建一个虚拟环境：
- en: 'First, you must install the `virtualenv` tool using the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须使用以下代码安装`virtualenv`工具：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, create a virtual environment for Python 3.6 using the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码为Python 3.6创建一个虚拟环境：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, execute the virtual environment script as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式执行虚拟环境脚本：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, install Vyper using `pip` as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令安装Vyper：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you don’t have any errors here, you are set to go. You can test the Vyper
    compiler as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这里没有任何错误，您就可以开始了。您可以按照以下方式测试Vyper编译器：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then you are ready to embark on the next step of your journey.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您就准备好迈向下一个步骤了。
- en: Creating a smart contract with Vyper
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vyper创建智能合约
- en: 'Now let''s create a smart contract with Vyper. First, we will create a file
    with the `.vy` extension and name it `hello.vy`, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Vyper创建一个智能合约。首先，我们将创建一个扩展名为`.vy`的文件，并将其命名为`hello.vy`，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you come from a Solidity or Python background, you will notice a peculiarity:
    there is no class (as in the Python programming language) and there is no contract
    (as in the Solidity programming language) in a smart contract written with the
    Vyper programming language. However, there is an `initializer` function. The name
    of the `initializer` function is the same as it is in the Python programming language,
    which is `__init__`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自Solidity或Python背景，您会注意到一个奇特之处：在使用Vyper编程语言编写的智能合约中，没有类（如Python编程语言中）和合约（如Solidity编程语言中）的概念。但是，有一个`initializer`函数。`initializer`函数的名称与Python编程语言中的`__init__`相同。
- en: While using Python, you can create as many classes as you want in one file.
    In Vyper, the rule is one smart contract per one file. There is also no class
    or contract here; the file itself is a class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以在一个文件中创建任意多的类。在Vyper中，规则是一个文件对应一个智能合约。这里也没有类或合约；文件本身就是一个类。
- en: 'This is how you compile this `vyper` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何编译这个`vyper`文件的：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From this, you will get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，您将得到以下输出：
- en: '![](assets/bf57bb9f-bfb3-4540-ae0f-eb6c6c117ecf.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf57bb9f-bfb3-4540-ae0f-eb6c6c117ecf.png)'
- en: 'This is the bytecode of the smart contract. Keep in mind that to deploy a smart
    contract, you need bytecode, but to access a smart contract, you need `abi`. So
    how do you get `abi`? You can do this by running the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是智能合约的字节码。请记住，要部署智能合约，您需要字节码，但要访问智能合约，您需要`abi`。那么如何获得`abi`？您可以通过运行以下命令来实现：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this, you will get the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，您将得到以下输出：
- en: '![](assets/e2405edb-5251-49b3-b660-5c864f862154.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e2405edb-5251-49b3-b660-5c864f862154.png)'
- en: 'If you want to get both `abi` and `bytecode` together in a single compilation
    process, you could combine both flags in the compilation process as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在单个编译过程中同时获得`abi`和`bytecode`，您可以在编译过程中结合这两个标志，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will give you the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你以下输出：
- en: '![](assets/3233f1d0-a9d1-4265-a371-be4e50b80301.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3233f1d0-a9d1-4265-a371-be4e50b80301.png)'
- en: Deploying a smart contract to Ganache
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将智能合约部署到Ganache
- en: 'So how do you deploy this smart contract to the Ethereum blockchain? There
    are few ways to do this, but let’s employ a familiar way using Truffle:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何将这个智能合约部署到以太坊区块链上呢？有几种方法可以做到这一点，但让我们使用Truffle的一种熟悉的方式：
- en: 'Create a directory and initialize it with `truffle` `init` as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，并使用`truffle init`进行初始化，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just as you did in the previous chapter, set `truffle-config.js` as the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像您在上一章中所做的那样，将`truffle-config.js`设置为以下内容：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `build` directory, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`build`目录，如下所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then create a `Hello.json` file there, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在那里创建一个`Hello.json`文件，如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then fill the `abi` field with `abi` or `json` output from the compilation
    process, and fill the `bytecode` field with the `bytecode` output from the compilation
    process. You need to quote the `bytecode` value with double quote marks . Don''t
    forget to put comma between the `abi` field and the `bytecode` field. This will
    give you something similar to the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`abi`字段填充为编译过程的`abi`或`json`输出，并将`bytecode`字段填充为编译过程的`bytecode`输出。您需要用双引号引用`bytecode`值。不要忘记在`abi`字段和`bytecode`字段之间放置逗号。这将给您类似于以下内容：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can then create a migration file to deploy this smart contract by creating
    a new file in `migrations/2_deploy_hello.js`, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个迁移文件来部署这个智能合约，方法是在`migrations/2_deploy_hello.js`中创建一个新文件，如下所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After everything is set up, fire up Ganache!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置好之后，启动Ganache！
- en: 'Then, inside the `hello_project` directory, you could just run the migration
    process, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`hello_project`目录中，您可以运行迁移过程，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will see something similar to the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似于以下内容：
- en: '![](assets/e9b659a2-abd6-4a70-b2b1-86f75a200cca.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9b659a2-abd6-4a70-b2b1-86f75a200cca.png)'
- en: 'Your smart contract written with Vyper has been deployed to Ganache. Your smart
    contract address is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用Vyper编写的智能合约已经部署到了Ganache。您的智能合约地址如下：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Interacting with smart contracts
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与智能合约交互
- en: 'Just as we did before, you can use the Truffle console to interact with your
    smart contract, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，您可以使用Truffle控制台与您的智能合约交互，如下所示：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your smart contract is always given the name `Contract`. We can access the
    smart contract using the following statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您的智能合约始终被赋予名称`Contract`。我们可以使用以下语句访问智能合约：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will get a long output in which you can see `abi`, `bytecode`, and so on,
    as shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到一个长输出，其中您可以看到`abi`、`bytecode`等，如下面的截图所示：
- en: '![](assets/b9bbe090-30ea-4f29-86ee-6ee4c07f593d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9bbe090-30ea-4f29-86ee-6ee4c07f593d.png)'
- en: 'Let’s look at the value of the `name` variable of the smart contract using
    the following statement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下语句查看智能合约的`name`变量的值：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You may notice that the cryptic output does not look like Satoshi Nakamoto.
    However, it actually is Satoshi Nakamoto, but written in hexadecimal. Let’s throw
    away `0x` from the cryptic output; this is just an indicator that this string
    is in hexadecimal form. You now have the `5361746f736869204e616b616d6f746f` string.
    Take the first two numbers, which are `53`, and convert them into a decimal number.
    In Python, you can do this as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，神秘的输出看起来并不像Satoshi Nakamoto。但实际上，这确实是Satoshi Nakamoto，只是用十六进制写的。让我们丢弃`0x`，这只是一个指示器，表明这个字符串是十六进制形式。现在您有了`5361746f736869204e616b616d6f746f`字符串。取前两个数字，即`53`，并将其转换为十进制数。在Python中，您可以这样做：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, the decimal number is `83`. Do you remember the ASCII table? This is a data
    table that holds the relations between decimal numbers and characters. So, the
    decimal number `65` represents the character A (capital A) and the decimal number
    `66` represents the character B (capital B).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制数为`83`。您还记得ASCII表吗？这是一个数据表，保存了十进制数和字符之间的关系。因此，十进制数`65`代表字符A（大写A），十进制数`66`代表字符B（大写B）。
- en: 'So what is the character of the decimal number `83`? You can use Python to
    find out as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么十进制数`83`的字符是什么？您可以使用Python来找出，如下所示：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you do this for all other hexadecimal characters on which each hexadecimal
    character takes two number characters, it would spell out Satoshi Nakamoto.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对每个十六进制字符都这样做，其中每个十六进制字符占两个数字字符，它将拼写出Satoshi Nakamoto。
- en: 'Let’s execute another method in this smart contract using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码在这个智能合约中执行另一个方法：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That cryptic output is just `Hello, Satoshi Nakamoto`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那个神秘的输出只是`Hello, Satoshi Nakamoto`。
- en: 'Let’s change the name as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式更改名称：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will get the following as the output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '![](assets/f7951de4-4b6d-4f2a-aa2f-fee83c0dda03.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7951de4-4b6d-4f2a-aa2f-fee83c0dda03.png)'
- en: The value in the `from` field is taken from one of the accounts in Ganache.
    You can just look at the Ganache window and choose any account you like.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`字段中的值来自Ganache中的一个账户。您可以查看Ganache窗口并选择任何您喜欢的账户。'
- en: We cannot send a string directly to the `change_name` method; we have to convert
    it to a hexadecimal string with the `web3.utils.fromAscii` method first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接将字符串发送到`change_name`方法；我们必须首先使用`web3.utils.fromAscii`方法将其转换为十六进制字符串。
- en: 'Now has the name been changed? Let’s find out. Run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在名称已经更改了吗？让我们找出来。运行以下命令：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Yup, the name has been changed. If you transform that hexadecimal string to
    an ASCII string, you will get Vitalik Buterin.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，名称已经更改了。如果您将该十六进制字符串转换为ASCII字符串，您将得到Vitalik Buterin。
- en: Going deeper into Vyper
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Vyper
- en: 'Let’s take a look at our smart contract:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的智能合约：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Take a look at the first line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下第一行：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The array of bytes is basically a string. The variable called `name` has a
    type of array of `bytes` or `string`. Its visibility is `public`. If you want
    to set it to `private`, then just omit the public keyword, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数组基本上就是一个字符串。名为`name`的变量具有`bytes`或`string`数组类型。它的可见性是`public`。如果要将其设置为`private`，只需省略public关键字，如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, take a look at the next lines:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下接下来的几行：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you are coming from a Python background, then you will recognize the Python
    decorator function. There are four of these in Vyper:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自Python背景，那么您将认识到Python装饰器函数。Vyper中有四个这样的函数：
- en: '`@public` means you can execute this method as a user (just as you did in the
    Truffle console in the previous chapter).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@public`表示您可以像用户一样执行此方法（就像在上一章中的Truffle控制台中一样）。'
- en: '`@private` means that only other methods inside the same smart contract can
    access this method. You cannot call the method as a user (in the Truffle console).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@private`表示只有相同智能合约内的其他方法才能访问此方法。您不能作为用户（在Truffle控制台中）调用该方法。'
- en: '`@payable` means that you can send some ethers to this method.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@payable`表示您可以向此方法发送一些以太币。'
- en: '`@const` is an indicator that this method should not modify the state of a
    smart contract. It means that it will not cost ether to execute this method. It’s
    like reading a public variable''s value.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@const`表示此方法不应更改智能合约的状态。这意味着执行此方法不会花费以太币。这就像读取公共变量的值。'
- en: 'Going back to the `__init__()` method, you could pass a parameter to this method
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`方法，您可以像这样向该方法传递参数：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Don''t forget to send the parameter when you deploy a smart contract. In our
    case, we use migration in Truffle software, so modify your migration file, `2_deploy_hello.js`,
    to be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署智能合约时不要忘记发送参数。在我们的情况下，我们在Truffle软件中使用迁移，因此修改您的迁移文件`2_deploy_hello.js`如下：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s move on to the following lines of the smart contract to understand the
    `public` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续阅读智能合约的以下行，以了解`public`方法：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method modifies the state of the smart contract, which is the `name` variable.
    This would incur gas.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法修改了智能合约的状态，即`name`变量。这将产生燃气。
- en: 'Let’s move on to the next lines of the smart contract to learn about returning
    a value inside the `public` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续阅读智能合约的下一行，以了解在`public`方法中返回值的情况：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A `concat` is a built-in function that combines the strings. Refer to [https://vyper.readthedocs.io/en/latest/built-in-functions.html](https://vyper.readthedocs.io/en/latest/built-in-functions.html)
    for a complete list of built-in functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat`是一个内置函数，用于组合字符串。请参考[https://vyper.readthedocs.io/en/latest/built-in-functions.html](https://vyper.readthedocs.io/en/latest/built-in-functions.html)获取完整的内置函数列表。'
- en: 'You must be careful with the return value of the method indicated by the right
    arrow (→). You might set this to an array of bytes that does not have enough length.
    For example, take a look at the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须小心方法的返回值，该值由右箭头（→）指示。例如，看一下以下代码：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, it would fail in compilation, although "Hello, Satoshi Nakamoto"
    is definitely less than 28 characters. The string has a length of 23 characters;
    however, you must remember that `self.name` is defined as `bytes[24]`, and `Hello,` 
     has a length of 7 characters. Because 24 + 7 is 31 characters, you must set this
    to a bigger array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，尽管“Hello，Satoshi Nakamoto”肯定少于28个字符，但它在编译时会失败。该字符串的长度为23个字符；但是，您必须记住`self.name`被定义为`bytes[24]`，而`Hello，`的长度为7个字符。因为24
    + 7是31个字符，所以您必须将其设置为更大的数组。
- en: 'Since this method does not change the state of this smart contract, you can
    add `@const` on top of this method, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法不会更改此智能合约的状态，因此您可以在此方法的顶部添加`@const`，如下所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Data types
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Let''s create a more complex smart contract and name it `donation.vy`, as follows.
    You can refer to the followng GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更复杂的智能合约，并将其命名为`donation.vy`，如下所示。您可以参考以下GitLab链接获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy)：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile and deploy the smart contract as before. Don’t forget to remove all
    of your files in the `build/contracts` directory and restart your Ganache if you
    reuse the project directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样编译和部署智能合约。不要忘记删除`build/contracts`目录中的所有文件，并且如果您重用项目目录，则重新启动您的Ganache。
- en: 'Take a look at the following lines:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下行：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s discuss the Vyper data types one by one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论Vyper数据类型：
- en: '**Struct**: The first one is called the struct. A struct in Vyper is just like
    a struct in another programming language; it is a container of different data
    types. You can access its members as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：第一个称为结构。Vyper中的结构就像另一种编程语言中的结构一样；它是不同数据类型的容器。您可以按以下方式访问其成员：'
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Wei**: The second data type that we are going to learn about is a `uint256(wei)`.
    This refers to a specific amount of ether that can be held. As you know, 1 ether
    is 1,000,000,000,000,000,000 wei (18 zeros). To hold that large an amount, a specific
    data type is required.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wei**：我们要了解的第二个数据类型是`uint256(wei)`。这指的是可以持有的特定以太币金额。正如您所知，1个以太币等于1,000,000,000,000,000,000
    wei（18个零）。为了持有如此大的金额，需要特定的数据类型。'
- en: '**Timestamp**: The third data type is the `timestamp` data type. This is designed
    to hold time values.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**：第三个数据类型是`timestamp`数据类型。这是设计用来保存时间值的。'
- en: '**Address**: The fourth one is the address data type. This is designed to hold
    the address value (such as `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`). This
    could be the address of an account or a smart contract. If you want to know what
    an address data type looks like, you can take a look at Ganache in the following
    screenshot. The address of the account is an example of the address data type.
    You could send ethers to the variable with this data type:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**：第四个是地址数据类型。这是设计用来保存地址值（例如`0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`）。这可以是帐户或智能合约的地址。如果您想知道地址数据类型是什么样子，可以查看下面的Ganache截图。帐户地址是地址数据类型的示例。您可以向具有此数据类型的变量发送以太币：'
- en: '![](assets/b4336a28-859d-43de-95e5-ce9814e2c196.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b4336a28-859d-43de-95e5-ce9814e2c196.png)'
- en: '**Map**: The fifth one is the `map` data type. This is like a dictionary. A
    simple map would be look as follows:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：第五个是`map`数据类型。这就像一个字典。一个简单的映射看起来是这样的：'
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, the key is `address` and the value is `uint256`. Here’s how you fill
    the value to this map:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，键是`address`，值是`uint256`。这是如何向这个映射填充值的：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There is a twist with this map data type if you are accustomed to the dictionary
    data type in Python: you cannot iterate this map. So, don''t expect to iterate
    a variable that has a mapping data type in Vyper, like you did with variables
    using the `dictionary` data type in Python. You can see how this works by looking
    at the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了Python中的字典数据类型，那么对于这种映射数据类型，有一个小技巧：你不能迭代这个映射。所以，不要期望像在Python中使用`dictionary`数据类型的变量那样在Vyper中迭代映射数据类型的变量。你可以通过查看以下代码来了解它是如何工作的：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The **Ethereum virtual machine** (**EVM**) doesn''t keep track of all the keys
    of a variable that has the mapping data type. In Python, you could get all keys
    from a variable that has the dictionary data type, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊虚拟机**（**EVM**）不会跟踪具有映射数据类型的变量的所有键。在Python中，你可以从具有字典数据类型的变量中获取所有键，如下面的代码所示：'
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But you cannot do this in Vyper.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在Vyper中你不能这样做。
- en: 'If you access a nonexistent key, it will return the default value of the value
    data type. In our case, if we do something like this, we would get `0`, as shown
    in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问一个不存在的键，它会返回值数据类型的默认值。在我们的例子中，如果我们做类似这样的操作，我们会得到`0`，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It makes no difference if you never set the value for the `0x1111111111111111111111111111111111111111`
    key or if you set it with a value of `0`. If you want to keep track of the keys,
    you need to keep them in a separate array. The mapping data type is like the default
    dictionary in Python, as shown in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从来没有为`0x1111111111111111111111111111111111111111`键设置值，或者设置为`0`，都没有关系。如果你想要跟踪这些键，你需要将它们保存在一个单独的数组中。映射数据类型就像Python中的默认字典，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'So, going back to our second defined variable, let''s look at the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回到我们第二个定义的变量，让我们看一下下面的代码：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code shows the map of an address to a struct that contains the `wei`, `string`,
    and `timestamp` data types. We want to record a donator's name, the amount of
    the donation, and the time of the donation with this data type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了一个地址到包含`wei`、`string`和`timestamp`数据类型的结构体的映射。我们想要用这种数据类型记录捐赠者的姓名、捐赠金额和捐赠时间。
- en: '**Array**: The fifth data type is the array data type, which does not have
    infinite size. The size of the array must be set in the beginning.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：第五种数据类型是数组数据类型，它没有无限大小。数组的大小必须在开始时设置。'
- en: 'Take a look at these lines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这些行：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is an array of addresses with size `10`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含10个地址的数组。
- en: 'Let''s take a look at the following lines to learn how to keep the owner''s
    account in the smart contract:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的行，学习如何在智能合约中保留所有者的账户：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Integer**: The sixth data type is integer. It''s something like `uint256`
    or `int128`. Please note that `uint256` and `uint256(wei)` are different. The
    difference between uint256 and int128 is that the int128 data type can hold zero,
    positive numbers, and negative. The uint256 data type can only hold zero and positive
    numbers, but its upper limit is higher than int128.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：第六种数据类型是整数。它类似于`uint256`或`int128`。请注意，`uint256`和`uint256(wei)`是不同的。`int128`和`uint256`之间的区别在于`int128`数据类型可以保存零、正数和负数。`uint256`数据类型只能保存零和正数，但它的上限比`int128`更高。'
- en: 'The following code will hold the address of someone who launched this smart
    contract:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将保存启动这个智能合约的人的地址：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is designed to keep track of how many donators have donated. Note that
    it does not have a public modifier. This means that you cannot access the variable
    from the Truffle console.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了跟踪有多少捐赠者捐赠了。请注意，它没有一个公共修饰符。这意味着你不能从Truffle控制台访问这个变量。
- en: 'Let''s take a look at the `__init__()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`__init__()`方法：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Inside every method, there are special objects. One of these is `msg`. You
    can access the account that accesses this method with `msg.sender`. You can also
    find the amount of ethers (in `wei`) with `msg.value`. In the following code,
    we want to save the address of the launcher of this smart contract:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法中，都有一些特殊的对象。其中之一是`msg`。你可以通过`msg.sender`访问访问该方法的账户。你还可以通过`msg.value`找到以`wei`为单位的以太币的数量。在下面的代码中，我们想要保存这个智能合约的启动者的地址：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, `@payable` indicates that this method accepts payment in ether. The `assert` phrase
    is like `assert` in the Python programming language. If the condition is `false`,
    then the execution of the method will be aborted. After the `assert` lines, we
    just set the `self.donatur_details` map with the `msg.sender` key to a `DonaturDetail`
    struct. Inside of the struct, you set the property of the time with `block.timestamp`,
    which indicates the current time. The `as_wei_value` phrase is a built-in function.
    Since we must deal with ether payment using the wei unit in this smart contract,
    it is a good idea to use this built-in function. If not, you have to use a lot
    of zeros, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@payable`表示这个方法接受以太币支付。`assert`短语类似于Python编程语言中的`assert`。如果条件为`false`，那么方法的执行将被中止。在`assert`行之后，我们只是将`self.donatur_details`映射设置为一个`DonaturDetail`结构体，键为`msg.sender`。在结构体内部，你可以使用`block.timestamp`设置时间属性，表示当前时间。`as_wei_value`短语是一个内置函数。由于在这个智能合约中我们必须使用wei单位处理以太支付，使用这个内置函数是一个好主意。否则，你必须使用很多零，如下所示：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Withdrawing ethers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取以太币
- en: 'The last lines of the smart contract will be a method to withdraw donation
    to the `donatee` account, as shown in the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的最后几行将是一个提取捐款到`donatee`账户的方法，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, `self.balance` represents all ethers that are accumulated in this smart
    contract. The `send` phrase is a built-in function to transfer money to the first
    parameter, in this case, the `donatee`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self.balance`代表了在这个智能合约中累积的所有以太币。`send`短语是一个内置函数，用于将钱转移到第一个参数，也就是`donatee`。
- en: 'So let''s test this smart contract in the Truffle console. Make sure you change
    the address in the method to the address of your smart contract. You can get it
    with the `truffle migrate` command, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在 Truffle 控制台中测试这个智能合约。确保你将方法中的地址更改为你的智能合约的地址。你可以使用 `truffle migrate` 命令获取它，如下所示：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is the first account in Ganache, as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Ganache 中的第一个账户，如下面的截图所示：
- en: '![](assets/0ead1b6c-d44f-48b2-95d7-b83b2e772073.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0ead1b6c-d44f-48b2-95d7-b83b2e772073.png)'
- en: 'Let’s donate 2 ether from the second account in Ganache, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Ganache 中的第二个账户捐赠 2 个以太币，如下所示：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now donate 3.5 ether from the third account in Ganache, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从 Ganache 中的第三个账户捐赠 3.5 个以太币，如下所示：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now take a look at the donator’s donation using the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用以下代码查看捐赠者的捐赠情况：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The way you access a property of a struct is by using two underscores after
    the `donatur_details` struct. You put the key of the map inside the `call` function.
    If you are wondering what `30927f74c9de0000` in `<BN: 30927f74c9de0000>` means,
    it''s not the memory''s location—it''s a number in hexadecimal format. Because
    the number is very big (BN is a short for big number), EVM has to display the
    number in hexadecimal format, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '你访问结构的属性的方式是在 `donatur_details` 结构后使用两个下划线。你将映射的键放在 `call` 函数中。如果你想知道 `<BN:
    30927f74c9de0000>` 中的 `30927f74c9de0000` 是什么意思，它不是内存的位置，而是一个十六进制格式的数字。因为这个数字非常大（BN
    是大数的缩写），EVM 必须以十六进制格式显示这个数字，如下所示：'
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you look at Ganache, the second and third accounts have lost some money,
    as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下 Ganache，第二和第三个账户已经失去了一些钱，如下面的截图所示：
- en: '![](assets/05dcbb08-d31f-4562-803a-ffe72ee17cfc.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/05dcbb08-d31f-4562-803a-ffe72ee17cfc.png)'
- en: 'So, let’s withdraw the donation using the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们使用以下代码撤回捐赠：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Take a look at your Ganache. The first account, in my case, has 105.48 ETH,
    as shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下你的 Ganache。在我的情况下，第一个账户有 105.48 ETH，如下面的截图所示：
- en: '![](assets/33f1d182-0bdb-42a3-96f0-d4ae5346126b.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/33f1d182-0bdb-42a3-96f0-d4ae5346126b.png)'
- en: Other data types
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数据类型
- en: 'Vyper has other data types that have not been used in the donation smart contract,
    as shown in the following list:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper 还有其他数据类型，这些数据类型在捐赠智能合约中没有使用，如下面的列表所示：
- en: '`bool`: This data type is like a normal Boolean. It holds true or false values,
    as shown in the following code:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：这种数据类型类似于普通的布尔值。它包含 true 或 false 值，如下面的代码所示：'
- en: '[PRE61]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`decimal`: This data type is like `float` or `double` in Python, as shown in
    the following code:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：这种数据类型类似于 Python 中的 `float` 或 `double`，如下面的代码所示：'
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`bytes32`: This data type is like `bytes32`, with a peculiarity. If the length
    of the value is less than 32 bytes, it will be padded with zero bytes. So, if
    you set the `messi` value (5 characters/bytes) to the `bytes32` data type variable
    (as shown in the following code), it will become `messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes32`：这种数据类型类似于 `bytes32`，但有一个特点。如果值的长度小于 32 字节，它将用零字节填充。所以，如果你将 `messi`
    值（5 个字符/字节）设置为 `bytes32` 数据类型变量（如下面的代码所示），它将变成 `messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`：'
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`Constant`: This data type cannot be changed after being declared:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Constant`：这种数据类型在声明后不能被改变：'
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Unlike the C++ programming language, where an uninitialized variable can have
    a garbage value, all uninitialized variables in the Vyper programming language
    have default values. The default integer data type value is `0`. The default Boolean
    data type value is `false`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 编程语言不同，未初始化的变量可以有垃圾值，Vyper 编程语言中所有未初始化的变量都有默认值。默认的整数数据类型值是 `0`。默认的布尔数据类型值是
    `false`。
- en: Useful built-in functions
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的内置函数
- en: 'You have used built-in functions, such as `send`, `assert`, `as_wei_value`,
    `concat`, and `convert`. However, there are other useful functions, such as the
    following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了内置函数，比如 `send`、`assert`、`as_wei_value`、`concat` 和 `convert`。然而，还有其他有用的函数，比如以下的函数：
- en: '`slice`: The `slice` phrase is the bytes data type. It''s used for tasks such
    as getting a substring from a string, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`：`slice` 短语是字节数据类型。它用于从字符串中获取子字符串等任务，如下面的代码所示：'
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`len`: This function is used to get the length of values, as shown in the following
    code:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`：此函数用于获取值的长度，如下面的代码所示：'
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`selfdestruct`: This function is used to destroy the smart contract, as shown
    in the following code. The argument is the address that this smart contract sends
    its ethers to:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selfdestruct`：此函数用于销毁智能合约，如下面的代码所示。参数是这个智能合约发送其以太币的地址：'
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`ceil`: This function is used to round the integer to the upper limit, as shown
    in the following code:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceil`：这个函数用于将整数四舍五入到上限，如下面的代码所示：'
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`floor`: This function is used to round the integer to the lower limit, as
    shown in the following code:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor`：这个函数用于将整数四舍五入到下限，如下面的代码所示：'
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`sha3`: This is a built-in hashing function, as shown in the following code:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha3`：这是一个内置的哈希函数，如下面的代码所示：'
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Events
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Vyper supports events. You can broadcast an event in your method to any subscriber
    of this event. For example, when people donate ethers with the smart contract,
    you can broadcast a donation event. To declare an event, you can use the following
    statement:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper 支持事件。你可以在你的方法中向任何订阅者广播事件。例如，当人们用智能合约捐赠以太币时，你可以广播一个捐赠事件。要声明一个事件，你可以使用以下语句：
- en: '[PRE71]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, in our `donate` method, you can broadcast the event after the donation
    transaction has occurred, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `donate` 方法中，你可以在捐赠交易发生后广播事件，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We'll talk more about events in later chapters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更多地讨论事件。
- en: Interacting with other smart contracts
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他智能合约交互
- en: Did you know that your smart contract doesn't have to be lonely out there? Your
    smart contract can interact with other smart contracts on the blockchain.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你的智能合约不必在那里孤独吗？你的智能合约可以与区块链上的其他智能合约进行交互。
- en: The address data type is not only used for normal accounts, but it can also
    be used for smart contract accounts. So, a smart contract can donate ethers to
    our donatee via the donation smart contract!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 地址数据类型不仅用于普通账户，还可以用于智能合约账户。因此，智能合约可以通过捐赠智能合约向我们的受赠人捐赠以太币！
- en: Restart your Ganache; we will start our blockchain anew. Remember your `hello.vy`
    Vyper file? We want to deploy our `Hello` smart contract with a custom name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的Ganache；我们将重新启动我们的区块链。还记得您的`hello.vy` Vyper文件吗？我们想要部署我们的`Hello`智能合约并自定义名称。
- en: 'Our migration file, `migrations/2_deploy_hello.js`, is still the same, as shown
    in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的迁移文件`migrations/2_deploy_hello.js`仍然是相同的，如下所示：
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Compile your `hello.vy` file again to get the interface and the bytecode. Open
    our contracts JSON file, the `build/contracts/Hello.json` file. Wipe out all the
    content''s and replace it with the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译您的`hello.vy`文件以获取接口和字节码。打开我们的合同JSON文件，`build/contracts/Hello.json`文件。清除所有内容并用以下代码替换它：
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You have to give a name to your smart contract because this time, you are going
    to deploy two smart contracts. If you don't give a name to your smart contract,
    it will have a default name, `Contract`. It's not a problem if you only want to
    deploy one smart contract.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须为您的智能合约命名，因为这次，您将部署两个智能合约。如果您不为您的智能合约命名，它将具有默认名称`Contract`。如果您只想部署一个智能合约，这不是问题。
- en: 'Then, for your `donation.vy`, edit it, and add the following lines of code
    (highlighted in bold) to the code file (refer to the code file in the following
    GitLab link for a complete code file of `donation.vy` at [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy)):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于您的`donation.vy`，编辑它，并将以下代码行（加粗显示）添加到代码文件中（请参考以下GitLab链接中`donation.vy`的完整代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy)）：
- en: '[PRE75]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note the changes in bold. These changes are how you declare the interface of
    the smart contract you want to interact with; you declare the contract object
    and the methods you want to interact with. You don't need to know the implementation
    of the `say_hello` method, only the interface (that is, the arguments it expects
    and the return value).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意加粗的更改。这些更改是您要与之交互的智能合约接口的声明方式；您声明合约对象和要与之交互的方法。您不需要知道`say_hello`方法的实现，只需要知道接口（即它期望的参数和返回值）。
- en: Then call the external smart contract's `donation_smart_contract_call_hello_smart_contract_method `method.
    Send the address as the argument for the contract object and call the method as
    usual. If you already know the address of the smart contract you want to interact
    with, you can hardcode it. But I use an arguments because I don't know the address
    of the `Hello` smart contract yet.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用外部智能合约的`donation_smart_contract_call_hello_smart_contract_method`方法。将地址作为参数发送给合约对象并像往常一样调用该方法。如果您已经知道要与之交互的智能合约的地址，可以硬编码它。但我使用参数是因为我还不知道`Hello`智能合约的地址。
- en: 'Using the following code, create another migration file for our upgraded `Donation`
    smart contract, `migrations/3_deploy_donation.js`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，为我们升级的`Donation`智能合约创建另一个迁移文件，`migrations/3_deploy_donation.js`：
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Compile your `donation.vy` and get the interface and the bytecode of the smart
    contract.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编译您的`donation.vy`并获取智能合约的接口和字节码。
- en: 'Then, using the following code, create another contract JSON file for our `Donation`
    smart contract, `build/contracts/Donation.json`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码，为我们的`Donation`智能合约创建另一个合同JSON文件，`build/contracts/Donation.json`：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Run the migration. You may have to use `--reset` flag, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行迁移。您可能需要使用`--reset`标志，如下所示：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will get the following output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '![](assets/95c24c65-26e2-42fb-8d8a-d18bd11372a8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95c24c65-26e2-42fb-8d8a-d18bd11372a8.png)'
- en: Note the address of the `Donation` smart contract and the address of the `Hello`
    smart contract. The address of the `Donation` smart contract is `0x98Db4235158831BF9133faC1c4e1829021ecEB67`
    and the address of the `Hello` smart contract is `0xBc932d934cfE859F9Dc903fdd5DE135F32EbC20E`.
    Yours could be different.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Donation`智能合约的地址和`Hello`智能合约的地址。`Donation`智能合约的地址是`0x98Db4235158831BF9133faC1c4e1829021ecEB67`，`Hello`智能合约的地址是`0xBc932d934cfE859F9Dc903fdd5DE135F32EbC20E`。您的地址可能不同。
- en: 'Run the Truffle console as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行Truffle控制台：
- en: '[PRE79]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now our smart contract is not lonely anymore, as shown in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的智能合约不再孤单，如下所示：
- en: '[PRE80]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: One of the use cases of the interaction between smart contracts is to create
    a decentralized exchange smart contract. Say that your grandma launched a token
    smart contract named power grid token and your uncle launched a token smart contract
    named Wi-Fi access token. You could create a smart contract that interacts with
    power grid token and Wi-Fi access token. In your smart contract, you could create
    a method to enable the trade between these two tokens; you just have to get their
    smart contract's addresses and interfaces. Of course, you also need to write the
    logic of the trade.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约之间交互的用例之一是创建一个去中心化交易智能合约。假设您的祖母启动了一个名为电网代币的代币智能合约，您的叔叔启动了一个名为Wi-Fi接入代币的代币智能合约。您可以创建一个智能合约，与电网代币和Wi-Fi接入代币进行交互。在您的智能合约中，您可以创建一个方法来启用这两个代币之间的交易；您只需获取它们的智能合约地址和接口。当然，您还需要编写交易的逻辑。
- en: Compiling code programmatically
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式编译代码
- en: 'You could create a script to compile Vyper code, instead of using a command-line
    utility. Make sure that you are in the same directory containing `hello.vy` and
    `donation.vy`. Create a script named `compiler.vy`, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个脚本来编译Vyper代码，而不是使用命令行实用程序。确保您在包含`hello.vy`和`donation.vy`的相同目录中。创建一个名为`compiler.vy`的脚本，如下所示：
- en: '[PRE81]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you execute this script using the following command, you will get a `Hello.json`
    file that you could use with Truffle, as shown in the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用以下命令执行这个脚本，你将得到一个`Hello.json`文件，你可以在Truffle中使用，如下代码所示：
- en: '[PRE82]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, let''s study the script bit by bit. First, import the `Vyper` library
    and some Python standard libraries so we can write a JSON file, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步学习这个脚本。首先，导入`Vyper`库和一些Python标准库，这样我们就可以写一个JSON文件，如下所示：
- en: '[PRE83]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You need a Vyper file, the name that you want to give to your smart contract,
    and the output JSON file. The following code will do this task:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个Vyper文件，你想要给你的智能合约的名称，以及输出的JSON文件。以下代码将完成这个任务：
- en: '[PRE84]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use the following lines of code to get the content of the Vyper file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码行获取Vyper文件的内容：
- en: '[PRE85]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then you create a dictionary object where the key is a path to your Vyper file
    and the value is the content of the Vyper file, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个字典对象，其中键是指向你的Vyper文件的路径，值是Vyper文件的内容，如下所示：
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To compile the Vyper code, all you need to do is use the `compile_codes` method
    from the `vyper` module, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译Vyper代码，你只需要使用`vyper`模块的`compile_codes`方法，如下所示：
- en: '[PRE87]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The first argument of the `compile_codes` method is a dictionary with the key
    points to the path and the value representing the Vyper code in a string. The
    second argument is `format`, which consists of the interface and the bytecode.
    The third argument is optional. If you use `''dict''`, then you will get a dictionary.
    If you don''t give a third argument, then you will get an array. Let''s look at
    the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile_codes`方法的第一个参数是一个字典，其中键指向路径，值表示字符串中的Vyper代码。第二个参数是`format`，包括接口和字节码。第三个参数是可选的。如果你使用`''dict''`，那么你将得到一个字典。如果你不给出第三个参数，那么你将得到一个数组。让我们看一下以下代码：'
- en: '[PRE88]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Because we used `'dict'` as our third argument, we get the result of a dictionary
    object. The key of the result is our path to the Vyper files. Technically speaking,
    you can set it to any string you like. Some developers use the file path to differentiate
    their Vyper files, which are scattered inside a project directory.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`'dict'`作为我们的第三个参数，我们得到了一个字典对象的结果。结果的键是我们的Vyper文件的路径。从技术上讲，你可以将它设置为任何你喜欢的字符串。一些开发人员使用文件路径来区分他们在项目目录中散布的Vyper文件。
- en: 'The last code is used to write the result to an output JSON file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码用于将结果写入输出的JSON文件：
- en: '[PRE89]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: By compiling Vyper code programmatically, you can build a framework on top of
    Vyper. In the later chapters of this book, you will use a framework called Populus
    to compile and deploy Vyper files. But you may want to build a better framework,
    or you could build a Vyper **integrated development environment** (**IDE**), such
    as the JetBrains IDE, but for the Vyper programming language.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以编程方式编译Vyper代码，你可以在Vyper之上构建一个框架。在本书的后面章节中，你将使用一个名为Populus的框架来编译和部署Vyper文件。但你可能想要构建一个更好的框架，或者你可以构建一个Vyper集成开发环境（IDE），比如JetBrains
    IDE，但用于Vyper编程语言。
- en: Other tricks
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技巧
- en: Vyper is not as liberal as Python; there are some limitations that you must
    live with. To overcome these limitations, you need to make peace with them or
    you need to unlock your creativity. Here are some hints as to how to do this.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper不像Python那样自由；有一些限制是你必须接受的。要克服这些限制，你需要与它们和解，或者你需要释放你的创造力。以下是一些关于如何做到这一点的提示。
- en: 'The first limitation is that the array must have a fixed size. In Python, you
    might be very accustomed to having a list that you can extend on your whim, as
    shown in the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个限制是数组必须有固定的大小。在Python中，你可能非常习惯于拥有一个可以根据需要扩展的列表，如下代码所示：
- en: '[PRE90]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: There is no such thing in Vyper. You have to declare how big your array is.
    Then you must use an integer variable to track how many items you have inserted
    into this fixed-size array. You used this strategy in the `Donation` smart contract.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vyper中没有这样的东西。你必须声明你的数组有多大。然后你必须使用一个整数变量来跟踪你已经插入到这个固定大小数组中的项目数量。你在`Donation`智能合约中使用了这种策略。
- en: 'If you are itching to have an infinite-sized array, there is a way that you
    can achieve this. You can use the mapping data type with an integer as the key.
    You still use an integer variable to track how many items you have inserted into
    this mapping data type variable, as shown in the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渴望拥有一个无限大小的数组，有一种方法可以实现这一点。你可以使用整数作为键的映射数据类型。你仍然使用一个整数变量来跟踪你已经插入到这个映射数据类型变量中的项目数量，如下代码所示：
- en: '[PRE91]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: But since `infinite_array_of_strings` is a mapping data type, it's your responsibility
    to guard this variable from the noninteger keys.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于`infinite_array_of_strings`是一个映射数据类型，你有责任保护这个变量免受非整数键的影响。
- en: 'The second limitation is that the mapping data type cannot accept the composite
    data type as the key. So you cannot put a mapping data type or struct data type
    as the key. But it can accept a mapping data type or struct data type as the value,
    as shown in the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个限制是映射数据类型不能接受复合数据类型作为键。因此，你不能将映射数据类型或结构数据类型作为键。但它可以接受映射数据类型或结构数据类型作为值，如下代码所示：
- en: '[PRE92]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you want to use the struct as the key of the mapping data type variable,
    you could serialize them first. For example, if you want to use two strings as
    the key of the mapping data type variable, you can concatenate the strings to
    make the key for your mapping data type variable, as shown in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将结构体作为映射数据类型变量的键，你可以先对它们进行序列化。例如，如果你想将两个字符串作为映射数据类型变量的键，你可以将这些字符串连接起来，作为你的映射数据类型变量的键，如下代码所示：
- en: '[PRE93]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Or you could use a nested array, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用嵌套数组，如下所示：
- en: '[PRE94]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Which approach is better depends on the situation and your preference.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好取决于情况和你的偏好。
- en: 'The third limitation is that the Vyper programming language cannot access the
    real world. So, don''t imagine something like the following in your smart contract:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个限制是Vyper编程语言无法访问现实世界。因此，在你的智能合约中不要想象以下内容：
- en: '[PRE95]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write a smart contract using the Vyper programming
    language. First, we installed the Vyper compiler. Then we developed a smart contract.
    By doing this, we learned about most of the features of the Vyper programming
    language, including the function decorator, initialization function, and function
    permission modifier. There are also some data types such as address, integer,
    timestamp, map, array, and array of bytes (string). We learned how to compile
    a Vyper source to a smart contract and then deploy it to Ganache with the Truffle
    tool. We also interacted with that smart contract through the Truffle console.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Vyper编程语言编写智能合约。首先，我们安装了Vyper编译器。然后我们开发了一个智能合约。通过这样做，我们了解了Vyper编程语言的大部分特性，包括函数修饰符、初始化函数和函数权限修改器。还有一些数据类型，如地址、整数、时间戳、映射、数组和字节数组（字符串）。我们学会了如何将Vyper源代码编译成智能合约，然后使用Truffle工具将其部署到Ganache上。我们还通过Truffle控制台与该智能合约进行了交互。
- en: In the next chapter, we are going to learn about `web3.py`. This is the first
    step towards building a decentralized application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于`web3.py`。这是构建去中心化应用的第一步。
