- en: Chapter 9. Building a Waiter Caller App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。建立服务员呼叫应用程序
- en: After going through the headlines project, in which you learned the basics of
    Flask, and the Crimemap project, in which you learned about some more useful Flask
    features, such as how to use a database and how to write some basic JavaScript
    code, we're now ready for our most sophisticated project yet! We will build a
    waiter caller web application that allows restaurant patrons to easily call a
    waiter to their table. The restaurant manager will easily be able to register
    for and start using our application without the need to invest in expensive hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了头条项目之后，你学习了Flask的基础知识，以及Crimemap项目，其中你学习了一些更有用的Flask功能，比如如何使用数据库和如何编写一些基本的JavaScript代码，我们现在准备进行我们迄今为止最复杂的项目！我们将建立一个服务员呼叫网络应用程序，允许餐厅顾客轻松地呼叫服务员到他们的桌子上。餐厅经理将能够轻松注册并开始使用我们的应用程序，而无需投资昂贵的硬件。
- en: We will dive even deeper into the Flask world, taking a look at some Flask extensions
    to help us with user account control and web forms, and we'll look at how to use
    template inheritance in Jinja, too. We'll also use the Bootstrap frontend framework
    so that we don't have to do so much of the HTML and CSS code from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究Flask世界，看看一些Flask扩展，帮助我们进行用户账户控制和网络表单，并且我们还将看看如何在Jinja中使用模板继承。我们还将使用Bootstrap前端框架，这样我们就不必从头开始编写太多HTML和CSS代码。
- en: 'In contrast with the MySQL database we used for our previous application, we''ll
    take a look at a controversial alternative: MongoDB. MongoDB is a NoSQL database,
    which means that we don''t deal with tables, rows, and columns in it. We''ll also
    discuss exactly what this means.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前应用程序使用的MySQL数据库相比，我们将看看一个有争议的替代方案：MongoDB。MongoDB是一个NoSQL数据库，这意味着我们在其中不处理表、行和列。我们还将讨论这究竟意味着什么。
- en: One of the most difficult tasks for a waiter is to know when a patron needs
    something. Either the patron complains that they waited for far too long before
    the waiter came and asked about dessert options, or they complain that the waiter
    was constantly interrupting conversation in order to ask whether everything was
    all right. In order to solve this problem, some restaurants install dedicated
    buttons at each table which, when pressed, notify the waiter that his attention
    is wanted. However, the cost of specialized hardware and installation is prohibitive
    for smaller establishments and often just too much hassle for larger ones.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务员来说，最困难的任务之一就是知道顾客需要什么。要么顾客抱怨等待服务员来询问甜点选择的时间太长，要么他们抱怨服务员不断打断对话来询问一切是否顺利。为了解决这个问题，一些餐厅在每张桌子上安装了专用按钮，当按下时，通知服务员需要他的注意。然而，对于规模较小的餐厅来说，专门硬件和安装的成本是不可承受的，对于规模较大的餐厅来说，这往往只是太麻烦了。
- en: In our modern day and age, nearly all restaurant-goers have smartphones, and
    we can leverage this fact to provide restaurants with a much more cost-effective
    solution. When patrons want attention, they will simply visit a short URL on their
    phone, and the waiters will receive a notification on a centralized screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现代的时代，几乎所有的餐厅顾客都有智能手机，我们可以利用这一事实为餐厅提供一个成本更低的解决方案。当顾客需要服务时，他们只需在手机上访问一个简短的URL，服务员就会在一个集中的屏幕上收到通知。
- en: We want the application to allow for multiple, unrelated restaurants to use
    the same web application, so each should have a private login account for our
    system. We want it to be easy for the restaurant manager to set up; that is, we
    as developers should not need to be involved at all when a new restaurant joins
    the system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望该应用程序允许多个不相关的餐厅使用同一个网络应用程序，因此每个餐厅都应该有我们系统的私人登录账户。我们希望餐厅经理能够轻松设置；也就是说，当一个新餐厅加入系统时，我们作为开发人员不需要参与其中。
- en: 'The setup required for our application is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序所需的设置如下：
- en: The restaurant manager signs up a new account on our web application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅经理在我们的网络应用程序上注册一个新账户
- en: The restaurant manager provides basic information about how many tables the
    restaurant has
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅经理提供了关于餐厅有多少张桌子的基本信息
- en: The web application provides a unique URL for each table
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序为每张桌子提供一个独特的URL
- en: The restaurant manager prints out these URLs and ensures that the relevant URL
    is easily accessible from each table
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅经理打印出这些URL，并确保相关的URL可以轻松从每张桌子上访问
- en: 'The usage of our application should have the following features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用应该具有以下功能：
- en: The restaurant staff should be able to log into the web application from a centralized
    screen and see a simple notification page.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅员工应该能够从一个集中的屏幕登录到网络应用程序并看到一个简单的通知页面。
- en: Some patrons would want service and visit the URL relevant to their table on
    a smartphone, so this should be possible.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些顾客希望通过智能手机获得服务，并访问与他们的桌子相关的URL，因此这应该是可能的。
- en: In real time, the waiters should see a notification appear on a centralized
    screen. The waiter will then acknowledge the notification on the screen and attend
    to the patrons.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务员应该实时看到通知出现在一个集中的屏幕上。然后服务员会在屏幕上确认通知并为顾客提供服务。
- en: If more notifications arrive before the first one is acknowledged, the later
    ones should appear beneath the earlier ones.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在第一个通知被确认之前出现更多通知，后来的通知应该出现在先前的通知下方。
- en: Over the next three chapters, we'll implement a Flask application that has all
    of the preceding features. We'll have a database to store the account information
    of all the individual restaurants that register to use our application so that
    we can process patron requests for each of them individually. Patrons will be
    able to make requests, which will be registered in the database, while the restaurant
    staff will be able to view current attention requests for their establishment.
    We'll build a user account control system so that restaurants can have their own
    password-protected accounts for our application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将实现一个具有所有前述功能的Flask应用程序。我们将拥有一个数据库，用于存储注册使用我们的应用程序的所有个别餐厅的帐户信息，以便我们可以为每个餐厅单独处理顾客的请求。顾客将能够发出请求，这些请求将在数据库中注册，而餐厅工作人员将能够查看他们餐厅的当前关注请求。我们将构建一个用户帐户控制系统，以便餐厅可以为我们的应用程序拥有自己的受密码保护的帐户。
- en: To start with, we'll set up a new Flask application, Git repository, and Apache
    configuration to serve our new project. We'll introduce Twitter's Bootstrap framework
    as the one we'll use on the frontend. We'll download a basic Bootstrap template
    as a start for the frontend of our application and make some changes to integrate
    it into a basic Flask application. Then, we'll set up a user account control system
    that allows users to register, log in, and log out of our application by supplying
    an e-mail address and password.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个新的Flask应用程序、Git存储库和Apache配置来提供我们的新项目。我们将引入Twitter的Bootstrap框架作为我们在前端使用的框架。我们将下载一个基本的Bootstrap模板作为我们应用程序前端的起点，并对其进行一些更改以将其整合到一个基本的Flask应用程序中。然后，我们将设置一个用户帐户控制系统，允许用户通过提供电子邮件地址和密码在我们的应用程序中注册、登录和注销。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a new `git` repository
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新的`git`存储库
- en: Using Bootstrap to kick-start our application
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap启动我们的应用程序
- en: Adding User Account Control to our application
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户帐户控制添加到我们的应用程序
- en: Setting up a new Git repository
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的Git存储库
- en: As before, we need to create a new `git` repository to host our new project.
    The first step is to go to log into the web interface of BitBucket or whichever
    code repository host you are using, select the **Create a new Repository** option,
    and select the **Git** radio option, taking note of the URL with which it provides
    you. As the next steps are identical to the previous projects, we will give you
    only a summary. If you need more fine-grained guidance, refer to the *Installing
    and using git* section of [Chapter 1](ch01.html "Chapter 1. Hello, World!"), *Hello,
    World!*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们需要创建一个新的`git`存储库来托管我们的新项目。第一步是登录BitBucket或您正在使用的任何代码存储库主机的Web界面，选择**创建新存储库**选项，并选择**Git**单选按钮，注意它提供给您的URL。由于接下来的步骤与以前的项目相同，我们只会给您一个摘要。如果您需要更详细的指导，请参考[第1章](ch01.html
    "第1章。你好，世界！") *安装和使用git*部分，*你好，世界！*。
- en: Setting up the new project locally
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地设置新项目
- en: 'To set up the local project structure, run the following commands locally:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置本地项目结构，请在本地运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We want to get the minimal running app for this project so that we can iron
    out any configuration issues before we get started with development. Add the following
    to your `waitercaller.py` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为这个项目获得最小的运行应用程序，以便在开始开发之前解决任何配置问题。将以下内容添加到您的`waitercaller.py`文件中：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, `push` the project outline to the repository with the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令将项目概述推送到存储库：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting up the project on our VPS
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的VPS上设置项目
- en: 'On your VPS, run the following commands to clone the repository, and set up
    Apache2 to serve our new project as the default website:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的VPS上，运行以下命令来克隆存储库，并设置Apache2以将我们的新项目作为默认网站提供服务：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code to the `.wsgi` file we created with the most recent
    command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们最近创建的`.wsgi`文件中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, hit *Ctrl* + *X* and select *Y* when prompted to quit Nano.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按下*Ctrl* + *X*，并在提示时选择*Y*退出Nano。
- en: 'Lastly, create the Apache configuration file by running the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过运行以下命令创建Apache配置文件：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following configuration data to the `waitercaller.conf` file we just
    created:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下配置数据添加到我们刚创建的`waitercaller.conf`文件中：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Quit Nano, saving the new file as before. Now, to disable our `crimemap` project
    as the default site and enable our new project instead, run the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 退出Nano，保存新文件。现在，为了禁用我们的`crimemap`项目作为默认站点，并启用我们的新项目，运行以下命令：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Verify that everything worked by visiting the IP address of your VPS in your
    web browser. You should see the **Under construction** string. Have another look
    at your configuration and log files if things don't work out as expected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Web浏览器中访问您的VPS的IP地址来验证一切是否正常。您应该看到**正在建设中**字符串。如果事情不如预期那样工作，请再次查看您的配置和日志文件。
- en: Using Bootstrap to kick-start our application
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bootstrap启动我们的应用程序
- en: In our previous projects, we spent quite a bit of time on frontend work, fiddling
    around with CSS and HTML, and we didn't even touch on some of the frontend problems
    that web application developers need to be aware of, such as making sure our content
    looks good and functions correctly on all devices of all screen sizes running
    any browser on any operating system. This diversity of browsers and devices as
    well as the inconsistent way in which each of them implements certain JavaScript,
    HTML, and CSS functionality is one of the biggest challenges of web development,
    and there is no silver bullet to solve the problem. However, frontend frameworks
    such as Bootstrap can take away some of the pain, providing shortcuts for developers
    to improve their user experience.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们以前的项目中，我们花了相当多的时间在前端工作上，摆弄CSS和HTML，并且甚至没有触及到Web应用程序开发人员需要注意的一些前端问题，比如确保我们的内容在任何操作系统上的任何浏览器上的所有屏幕尺寸的所有设备上看起来好看并且功能正常。浏览器和设备的多样性以及它们各自实现某些JavaScript、HTML和CSS功能的不一致方式是Web开发的最大挑战之一，没有解决问题的银弹。然而，像Bootstrap这样的前端框架可以减轻一些痛苦，为开发人员提供改进用户体验的捷径。
- en: Introducing Bootstrap
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Bootstrap
- en: Bootstrap was developed by Twitter and is released under an open license. It
    can greatly speed up CSS development as it provides many styles for different
    HTML layouts and form inputs. It can also provide *responsiveness*; that is, it
    can allow your website to automatically change the layout of certain elements
    based on the screen size of your user's device. We'll discuss exactly what this
    means for us and for this project later in the chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap由Twitter开发，并在开放许可下发布。它可以极大地加快CSS开发，因为它为不同的HTML布局和表单输入提供了许多样式。它还可以提供*响应性*；也就是说，它可以根据用户设备的屏幕大小自动更改某些元素的布局。我们将在本章后面讨论这对我们和这个项目的确切意义。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bootstrap has faced some criticism, but it still holds its popularity. There
    are many alternatives with different strengths and weaknesses. As modern web development
    is a fast-evolving field, there are also many new frameworks that appear regularly.
    Existing frameworks often get major updates and don't provide backward compatibility
    to old versions. For important production web applications, current research into
    what best fits the specific needs of this project is always crucial.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap受到了一些批评，但它仍然保持着它的流行度。有许多具有不同优势和劣势的替代品。随着现代网页开发的快速发展，也会定期出现许多新的框架。现有的框架经常会进行重大更新，并且不提供向旧版本的向后兼容性。对于重要的生产网页应用程序，当前研究什么最适合这个项目的特定需求总是至关重要的。
- en: Bootstrap's main offerings are reusable in CSS and JavaScript modules. We'll
    mainly use it for its CSS components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的主要提供的是可重复使用的CSS和JavaScript模块。我们主要会用它的CSS组件。
- en: Take a look at Bootstrap's homepage at [http://getbootstrap.com/](http://getbootstrap.com/)
    as well as the subpages at [http://getbootstrap.com/getting-started/#examples](http://getbootstrap.com/getting-started/#examples)
    and [http://getbootstrap.com/components/](http://getbootstrap.com/components/)
    to get an idea of what Bootstrap provides.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Bootstrap的主页[http://getbootstrap.com/](http://getbootstrap.com/)，以及子页面[http://getbootstrap.com/getting-started/#examples](http://getbootstrap.com/getting-started/#examples)和[http://getbootstrap.com/components/](http://getbootstrap.com/components/)，以了解Bootstrap提供了什么。
- en: Instead of writing CSS from scratch, Bootstrap allows us to use various inputs,
    icons, navigation bars, and other often-needed components of a website that look
    good by default.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与从头开始编写CSS不同，Bootstrap允许我们使用各种输入、图标、导航栏和其他经常需要的网站组件，默认情况下看起来很好。
- en: Downloading Bootstrap
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载Bootstrap
- en: 'There are a few ways to install Bootstrap, but keeping in mind that Bootstrap
    can be thought of as a collection of some JavaScript, CSS, and icon files, we
    will not do anything too fancy. We can simply download a `.zip` file of the compiled
    code files and use these files in our local project. We''ll include bootstrap
    in our `git` repository, so there is no need to install it on our VPS as well.
    Perform the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种安装Bootstrap的方法，但要记住Bootstrap可以被视为一组JavaScript、CSS和图标文件的集合，我们不会做太复杂的事情。我们可以简单地下载编译后的代码文件的`.zip`文件，并在我们的本地项目中使用这些文件。我们将在我们的`git`存储库中包含bootstrap，因此无需在我们的VPS上安装它。执行以下步骤：
- en: Head over to [http://getbootstrap.com/getting-started/#download](http://getbootstrap.com/getting-started/#download)
    and select the **Download Bootstrap** option, which should be the compiled and
    minified version without documentation.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[http://getbootstrap.com/getting-started/#download](http://getbootstrap.com/getting-started/#download)，选择**下载Bootstrap**选项，这应该是已编译和压缩的版本，没有文档。
- en: Unzip the file you downloaded, and you'll find a single directory called `bootstrap-3.x.x`
    (here, the repeated letter x represents numbers that indicate which version of
    Bootstrap is contained). Inside the directory, there will be some subdirectories,
    probably `js`, `css`, and `fonts`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压您下载的文件，您会发现一个名为`bootstrap-3.x.x`的单个目录（这里，重复的字母x代表包含的Bootstrap版本的数字）。在目录内，可能会有一些子目录，可能是`js`、`css`和`fonts`。
- en: 'Copy the `js`, `css`, and `fonts` directories to the `static` directory of
    the `waitercaller` project. Your project should now have the following structure:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`js`、`css`和`fonts`目录复制到`waitercaller`项目的`static`目录中。您的项目现在应该具有以下结构：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because of the regular Bootstrap updates, we included a complete copy of the
    code for Bootstrap 3.3.5 in the accompanying code bundle (the latest version during
    the writing of this book). While the latest version is probably better, it might
    not be compatible with the examples we give. You can choose to test the waters
    with the version we provide, knowing that the examples should work as expected,
    or jump in at the deep end and, if necessary, try to work out how to adapt the
    examples to the newer Bootstrap code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定期的Bootstrap更新，我们在附带的代码包中包含了Bootstrap 3.3.5的完整代码副本（在撰写本书时的最新版本）。虽然最新版本可能更好，但它可能与我们提供的示例不兼容。您可以选择使用我们提供的版本来测试，知道示例应该按预期工作，或者直接尝试适应更新的Bootstrap代码，必要时尝试适应示例。
- en: Bootstrap templates
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bootstrap模板
- en: Bootstrap strongly encourages users to build customized frontend pages instead
    of simply using existing templates. You've probably noticed a lot of modern web
    pages look very similar; this is because frontend designing is difficult, and
    people like taking shortcuts. As this book focuses on Flask development, we'll
    also take a bit of a frontend shortcut and start with one of the example template
    files that Bootstrap provides. The template file we'll work with can be seen at
    [http://getbootstrap.com/examples/jumbotron/](http://getbootstrap.com/examples/jumbotron/),
    and the adaptation for our project can be found in the accompanying code bundle
    for this chapter at `tempates/home.html`. You can note from the similarity of
    the two files that we didn't have to do too much work to get a basic web page
    that also looks good.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap强烈鼓励用户构建定制的前端页面，而不是简单地使用现有的模板。你可能已经注意到很多现代网页看起来非常相似；这是因为前端设计很困难，人们喜欢走捷径。由于本书侧重于Flask开发，我们也会采取一些前端的捷径，并从Bootstrap提供的示例模板文件开始。我们将使用的模板文件可以在[http://getbootstrap.com/examples/jumbotron/](http://getbootstrap.com/examples/jumbotron/)中找到，我们项目的适配可以在本章的附带代码包中的`tempates/home.html`中找到。你可以注意到这两个文件的相似之处，我们并没有做太多的工作来获得一个基本的网页，看起来也很好。
- en: 'Copy the code from the `templates/home.html` file in the code bundle to the
    same place in your own project directory that we created earlier. If you included
    all the Bootstrap files properly in your `static` folder, opening this new file
    directly in your web browser will result in a page that looks similar to the following
    screenshot. (Note that at this stage, we still use pure HTML and none of the Jinja
    functionality, so you can just open the file locally in your web browser instead
    of serving it from a Flask application.):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码包中的`templates/home.html`文件中复制代码到您之前创建的项目目录中的相同位置。如果您在`static`文件夹中正确地包含了所有的Bootstrap文件，直接在Web浏览器中打开这个新文件将会得到一个类似于以下屏幕截图的页面。（请注意，在这个阶段，我们仍然使用纯HTML，没有使用Jinja功能，所以您可以直接在Web浏览器中打开文件，而不是从Flask应用程序中提供服务。）
- en: '![Bootstrap templates](img/B04312_09_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap templates](img/B04312_09_01.jpg)'
- en: 'We can note the advantages of the styling of inputs, headers, the navigation
    bar, and Jumbotron (the gray bar near the top with the oversized **Waiter Caller**
    text in it) that we can achieve with very little code. However, perhaps the most
    significant time-saving element of using Bootstrap is the *responsiveness* that
    our site has. Bootstrap is based on a grid layout, which means that different
    elements of the grid can rearrange themselves to better fit on any device. Note
    this part of HTML from the template:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，我们可以用很少的代码实现输入、标题、导航栏和Jumbotron（靠近顶部的灰色条，上面有超大的**服务员呼叫**文本）的样式的优势。然而，使用Bootstrap最显著的节省时间的元素可能是我们网站的*响应性*。Bootstrap基于网格布局，这意味着网格的不同元素可以重新排列以更好地适应任何设备。注意模板中的HTML的这一部分：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `"row"` has space for 12 columns. Our three main content elements below the
    Jumbotron each take up four columns, thus filling the row (*4 x 3 = 12*). We specified
    this using the `class="col-md-4"` attribute. Think of this as a medium (`md`)
    column of size four. You can read more about how the grid system works and take
    a look at some examples at [http://getbootstrap.com/css/](http://getbootstrap.com/css/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`"row"`有12列的空间。我们的Jumbotron下面的三个主要内容元素每个占据四列，因此填满了整行（*4 x 3 = 12*）。我们使用`class="col-md-4"`属性来指定这一点。可以将其视为大小为四的中等（`md`）列。您可以在[http://getbootstrap.com/css/](http://getbootstrap.com/css/)上阅读有关网格系统如何工作的更多信息，并查看一些示例。
- en: 'There''s also some code that doesn''t look used in the preceding screenshot,
    similar to this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中还有一些看起来没有使用的代码，类似于这样：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The two preceding excerpts are perhaps the most important components in making
    our web application responsive. To understand what this means, resize your browser
    window while the page is open. This simulates how our page will be seen on smaller
    devices, such as phones and tablets. It should look similar to the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个摘录可能是使我们的网络应用程序响应的最重要的组成部分。要理解这意味着什么，可以在页面打开时调整浏览器窗口大小。这模拟了我们的页面在较小设备上（如手机和平板电脑）上的显示方式。它应该看起来类似于以下的屏幕截图：
- en: '![Bootstrap templates](img/B04312_09_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap templates](img/B04312_09_02.jpg)'
- en: We can note that our three main content elements that used the Bootstrap grid
    functionality are now arranged beneath each other instead of side by side. This
    is ideal for smaller devices in which users are more used to scrolling down than
    to looking for more content on the side. Our navigation bar has also become more
    concise with the login inputs now hidden.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，我们使用Bootstrap网格功能的三个主要内容元素现在排列在彼此下方，而不是并排。这对于较小的设备来说是理想的，用户更习惯于向下滚动，而不是在侧边寻找更多的内容。我们的导航栏也变得更加简洁，登录输入现在被隐藏了。
- en: These can be revealed by selecting the *hamburger* icon in the upper right-hand
    corner; this is a controversial, but highly prevalent, element in web development.
    Most users instinctively know that they can touch the icon to get some form of
    menu or expansion, but there are many criticisms of using this technique. For
    now, we'll just accept this as normal practice and not go into the problems behind
    it. It's definitely better than trying to display exactly the same content no
    matter the screen size and having our users zoom into the page section by section,
    depending on which part they need to see.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过选择右上角的*汉堡包*图标来显示；这是一个有争议但非常普遍的网页开发元素。大多数用户本能地知道他们可以触摸图标以获得某种形式的菜单或扩展，但是有许多批评使用这种技术。目前，我们只接受这种正常的做法，不去深究它背后的问题。这绝对比尝试在任何屏幕大小上显示完全相同的内容，并且让我们的用户根据需要逐个部分地放大页面要好得多。
- en: Adding user account control to our application
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加用户帐户控制
- en: For user account control, a user is expected to log in and authenticate using
    a password. For example, when you log in to your Webmail account, you enter your
    password upon visiting the page. Thereafter, all your actions are taken as authenticated;
    that is, you do not have to enter your password again when you send an e-mail.
    The Webmail client *remembers* that you are logged in, and you are therefore allowed
    to complete certain actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户帐户控制，预期用户将使用密码登录和进行身份验证。例如，当您登录到您的网络邮件帐户时，您在访问页面时输入密码。此后，所有您的操作都将被视为经过身份验证；也就是说，当您发送电子邮件时，您不必再次输入密码。网络邮件客户端*记住*您已登录，因此允许您完成某些操作。
- en: However, HTTP is a stateless protocol, which means that we have no direct way
    of knowing that the user who logged in is the same user who made the request to
    send an e-mail. As a workaround for this problem, we will give the user a cookie
    when he or she logs in initially, and the user's browser will then send this cookie
    to us with *every* subsequent request. We'll use our database to keep track of
    which users are currently logged in. This allows us to authenticate the user for
    every request without requesting the user's password multiple times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTTP是一种无状态协议，这意味着我们无法直接知道登录的用户是否是发送电子邮件请求的同一用户。为了解决这个问题，我们将在用户最初登录时给用户一个cookie，然后用户的浏览器将在*每个*后续请求中将此cookie发送给我们。我们将使用我们的数据库来跟踪当前已登录的用户。这使我们能够在每个请求中对用户进行身份验证，而无需多次请求用户的密码。
- en: We could implement this from scratch using Flask cookies in a similar way to
    what we saw in our Headlines project. However, there are numerous steps that we
    would need to implement, such as selecting which pages in our application require
    authentication and ensuring that the cookie is secure, and be involved in deciding
    what information to store in the cookie.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Flask cookie从头开始实现这一点，方式类似于我们在Headlines项目中看到的方式。但是，我们需要实现许多步骤，例如选择应用程序中哪些页面需要身份验证，并确保cookie是安全的，并参与决定在cookie中存储什么信息。
- en: Instead, we'll go up one level of abstraction and use the `Flask-Login` extension.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将提高一级抽象，并使用`Flask-Login`扩展。
- en: Introducing Flask-Login
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Flask-Login
- en: '`Flask-Login` is a Flask extension that implements the groundwork required
    for all user account control systems. To use this, we need to install it through
    `pip` and then create a user class that follows a specific pattern. You can find
    a summary of `Flask-Login` as well as comprehensive documentation at [https://flask-login.readthedocs.org/en/latest/](https://flask-login.readthedocs.org/en/latest/).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Login`是一个Flask扩展，实现了所有用户帐户控制系统所需的基础工作。要使用此功能，我们需要通过`pip`安装它，然后创建一个遵循特定模式的用户类。您可以在[https://flask-login.readthedocs.org/en/latest/](https://flask-login.readthedocs.org/en/latest/)找到`Flask-Login`的摘要以及全面的文档。'
- en: Installing and importing Flask-Login
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和导入Flask-Login
- en: 'To install `Flask-Login`, run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`Flask-Login`，运行以下命令：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with all the Python modules we install, remember to do this both locally
    and on your VPS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们安装的所有Python模块一样，请记住在本地和VPS上都要这样做。
- en: To begin with, we'll add the most basic login functionality possible. Our application
    will display **You are logged in** for users who have authenticated, but users
    who do not enter a correct password will not be able to see the message.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加可能的最基本的登录功能。我们的应用程序将为经过身份验证的用户显示**您已登录**，但未输入正确密码的用户将无法看到消息。
- en: Using Flask extensions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flask扩展
- en: 'When we install Flask extensions, we can automatically access them through
    the `flask.ext` path. The first class we''ll use from the `Flask-Login` extension
    is the so-called `LoginManager` class. We''ll also use the `@login_required` decorator
    to specify which routes are restricted to users who are logged in. Add the following
    imports to your `waitercaller.py` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装Flask扩展时，我们可以通过`flask.ext`路径自动访问它们。我们将从`Flask-Login`扩展中使用的第一个类是所谓的`LoginManager`类。我们还将使用`@login_required`装饰器指定哪些路由受限于已登录用户。将以下导入添加到您的`waitercaller.py`文件中：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we need to connect the extension to our Flask app. In a pattern that will
    become familiar as we use more Flask extensions, add the following line to `waitercaller.py`
    directly below the place where you create the `app` variable:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将扩展连接到我们的Flask应用程序。在我们使用更多Flask扩展时将变得熟悉的模式中，将以下行直接添加到`waitercaller.py`中创建`app`变量的位置下面：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `LoginManager` class we instantiated now has a reference to our application.
    We'll use this new `LoginManager` class to—you guessed it—manage logins for our
    application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化的`LoginManager`类现在引用了我们的应用程序。我们将使用这个新的`LoginManager`类来管理我们应用程序的登录。
- en: Adding a restricted route
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加受限路由
- en: Now, let's add a route to our application at `/account` and make sure that only
    authenticated users can view this page. The easy part of this step is to make
    sure that *non* authenticated users *can't* see the page, so we'll start with
    this.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`/account`上为我们的应用程序添加一个路由，并确保只有经过身份验证的用户才能查看此页面。这一步的简单部分是确保*非*经过身份验证的用户*不能*看到页面，因此我们将从这里开始。
- en: 'First, we want our application to render our Bootstrap template by default.
    Add the following route to the `waitercaller.py` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望我们的应用程序默认呈现我们的Bootstrap模板。将以下路由添加到`waitercaller.py`文件中：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we''ll add a restricted route that users who aren''t logged in can''t
    see. Add the following function to `waitercaller.py`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个受限路由，未登录的用户无法看到。将以下函数添加到`waitercaller.py`：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we're using the `@login_required` decorator. Similarly to the `@app.route`
    decorator, this is a function that takes the function below it as input and returns
    a modified function. In this case, instead of the routing magic, it'll verify
    that the user is logged in, and if not, it'll redirect the user to an **Unauthorized**
    page instead of returning the content we specified in the `return` statement.
    It's important that the `@app.route` decorator is first and the `@login_required`
    one is below it, as in the preceding example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用`@login_required`装饰器。类似于`@app.route`装饰器，这是一个接受下面的函数作为输入并返回修改后的函数的函数。在这种情况下，它不是路由魔法，而是验证用户是否已登录，如果没有，它将重定向用户到一个**未经授权**页面，而不是返回我们在`return`语句中指定的内容。重要的是`@app.route`装饰器首先出现，`@login_required`装饰器在其下面，就像前面的例子一样。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You've probably seen **404 page not found** errors sometimes while browsing
    the Web. While **404** is especially infamous, there are many error codes that
    are part of the HTTP specification. Different browsers may show different default
    error messages when these are received, and it's also possible to define custom
    error pages to be shown when the specified errors are hit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览网页时，你可能会有时看到**404页面未找到**错误。虽然**404**尤为臭名昭著，但有许多错误代码是HTTP规范的一部分。不同的浏览器在接收到这些错误时可能会显示不同的默认错误消息，也可以定义自定义错误页面在指定错误发生时显示。
- en: 'As we haven''t set up any of the login logic yet, no user should be able to
    authenticate and view the new route we created. Start your Flask application locally
    and try to visit the account route at `localhost:5000/account`. If all went well,
    you should see an unauthorized error message similar to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有设置任何登录逻辑，没有用户应该能够验证并查看我们创建的新路由。在本地启动你的Flask应用程序，尝试访问`localhost:5000/account`的账户路由。如果一切顺利，你应该会看到类似以下截图的未经授权的错误消息：
- en: '![Adding a restricted route](img/B04312_09_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![添加受限路由](img/B04312_09_03.jpg)'
- en: Authenticating a user
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户
- en: The Internet can be a dark and scary place. This is why you need to put passwords
    into many web applications; the password proves that you are who you claim to
    be. By telling us something that only you know, the web application knows you
    are "you" and not an imposter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网可能是一个黑暗和可怕的地方。这就是为什么你需要在许多网络应用程序中输入密码；密码证明你是你所声称的人。通过告诉我们只有你知道的东西，网络应用程序知道你是“你”，而不是冒名顶替者。
- en: The simplest way to implement a password checking system would be to store passwords
    associated with usernames in a database. When the user logs in, you need to first
    verify that the username exists, and if it does, you need to verify that the password
    the user just gave matches the one that he or she used when registering.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现密码检查系统的最简单方法是在数据库中存储与用户名关联的密码。当用户登录时，你需要首先验证用户名是否存在，如果存在，你需要验证用户刚刚给出的密码是否与注册时使用的密码匹配。
- en: In practice, this is a terrible idea. Databases may be accessed by any number
    of people, including employees of the company that runs the web application and,
    potentially, hackers. Instead, we'll eventually store a cryptographic hash of
    the user's password; however for now, to make sure our login system works, we'll
    work with plaintext passwords.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个糟糕的主意。数据库可能被任意数量的人访问，包括运行网络应用程序的公司的员工，可能还有黑客。相反，我们最终将存储用户密码的加密哈希；但是现在，为了确保我们的登录系统正常工作，我们将使用明文密码。
- en: We'll set up a mock database that is very similar to the one we used in our
    Crime Map project and check whether we can allow a mock user to view our `account`
    page if, and only if, the correct password is entered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建立一个模拟数据库，这个数据库与我们在犯罪地图项目中使用的数据库非常相似，并检查是否允许模拟用户查看我们的“账户”页面，只有在输入正确的密码时才允许。
- en: Creating a user class
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个用户类
- en: As we are using the `Flask-Login` module, we need to create a `User` class that
    conforms to a strict format. `Flask-Login` is flexible enough to allow some more
    advanced login functionality, such as distinguishing between *active* and *nonactive*
    accounts as well as anonymous users. We won't use these features, but we need
    to create a `User` class that can work with `Flask-Login`, so we'll have some
    methods that look redundant.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`Flask-Login`模块，我们需要创建一个符合严格格式的`User`类。`Flask-Login`足够灵活，可以允许一些更高级的登录功能，比如区分*活跃*和*非活跃*账户以及匿名用户。我们不会使用这些功能，但我们需要创建一个能够与`Flask-Login`一起工作的`User`类，因此我们将有一些看起来多余的方法。
- en: 'Create a new file called `user.py` in your `waitercaller` directory. Add the
    following code to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`waitercaller`目录中创建一个名为`user.py`的新文件。将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Flask-Login` requires that we implement a `get_id()` method in our `User`
    class that returns a unique identifier for the user. We''ll be using the user''s
    e-mail address for this, so in the `get_id()` function we can simply return that.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Login`要求我们在我们的`User`类中实现一个`get_id()`方法，返回用户的唯一标识符。我们将使用用户的电子邮件地址，因此在`get_id()`函数中，我们可以简单地返回它。'
- en: We'll regard all our users as having active accounts; so, in this method, which
    is also required, we'll simply return `True`. The opposite goes for the `is_anonymous()`
    function; while this is also required, we won't deal with the concept of anonymous
    logins in our application, so we'll always return `False`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有用户视为活跃账户；因此，在这个方法中，我们将简单地返回`True`。对于`is_anonymous()`函数也是如此；虽然这也是必需的，但我们不会在我们的应用程序中处理匿名登录的概念，所以我们将始终返回`False`。
- en: The last function may look a bit odd; we'll always return `True` for `is_authenticated()`.
    This is because we only create the user object when the correct username and password
    combination is entered, so if the user object exists, it'll be authenticated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数可能看起来有点奇怪；我们将始终为`is_authenticated()`返回`True`。这是因为只有在输入正确的用户名和密码组合时才会创建用户对象，所以如果用户对象存在，它将被验证。
- en: Mocking our database for users
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟我们的用户数据库
- en: We'll create a `MockDBHelper` class again and also create a configuration file
    to indicate that this should be used locally when we test our application and
    don't have access to the database. It needs to have a function that takes a username
    and password and checks whether these exist in the database and are associated
    with each other.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次创建一个`MockDBHelper`类，并创建一个配置文件，指示在测试应用程序时应在本地使用它，而不需要访问数据库。它需要有一个函数，接受用户名和密码，并检查它们是否存在于数据库中，并且彼此关联。
- en: 'First, create a file called `mockdbhelper.py` in your `waitercaller` directory
    and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的`waitercaller`目录中创建一个名为`mockdbhelper.py`的文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At the top, we have a dictionary that acts as the database storage. We have
    a single `get_user()` method that checks whether a user exists in our database
    and returns the password if it does.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有一个充当数据库存储的字典。我们有一个单独的`get_user()`方法，检查用户是否存在于我们的数据库中，并在存在时返回密码。
- en: 'Now, create a `config.py` file in the `waitercaller` directory and add the
    single line as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`waitercaller`目录中创建一个`config.py`文件，并添加以下单行：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As in our last project, this file will let our application know whether it
    is running in our test (local) environment or in our production (VPS) one. Unlike
    our previous project, we''ll add other information into this file later that doesn''t
    involve the database, which is why we''ll call it `config.py` instead of `dbconfig.py`.
    We don''t want to check this file into our `git` repository as it''ll be different
    on our VPS and will also contain sensitive database credentials that we don''t
    want to store; so, create a `.gitignore` file in your `waitercaller` directory
    with the following lines:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个项目一样，此文件将让我们的应用程序知道它是在我们的测试（本地）环境中运行还是在我们的生产（VPS）环境中运行。与以前的项目不同，我们将稍后向此文件添加其他不涉及数据库的信息，这就是为什么我们将其称为`config.py`而不是`dbconfig.py`。我们不希望将此文件检入我们的`git`存储库，因为它在我们的VPS上会有所不同，并且还将包含我们不希望存储的敏感数据库凭据；因此，在您的`waitercaller`目录中创建一个`.gitignore`文件，并添加以下行：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Logging in a user
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录用户
- en: Our template already has a login form set up that allows a user to enter an
    e-mail and a password. We'll now set up functionality that allows us to enter
    and check the input into this form against our mock database. If we enter an e-mail
    and password that exist in our mock database, we'll log the user in and allow
    access to our `/account` route. If not, we'll just redirect back to the home page
    (we'll look at displaying feedback to a user who inputs invalid information in
    the next chapter in the *Adding user feedback using WTForms* section).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板已经设置了一个登录表单，允许用户输入电子邮件和密码。现在，我们将设置功能，允许我们输入并检查此表单中的输入是否与我们的模拟数据库匹配。如果我们输入的电子邮件和密码存在于我们的模拟数据库中，我们将登录用户并允许访问我们的`/account`路由。如果不是，我们将重定向回主页（我们将在下一章节的*使用WTForms添加用户反馈*部分中查看向输入无效信息的用户显示反馈）。
- en: Adding imports and configuration
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加导入和配置
- en: 'We need to import the `login_user` function that is part of the `Flask-Login`
    extension as well as our new `User` class code and database helper. Add the following
    lines to your imports in `waitercaller.py`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入`Flask-Login`扩展的`login_user`函数，以及我们的新`User`类代码和数据库助手。在`waitercaller.py`的导入中添加以下行：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we don't have a database helper except for our mock one at the moment, we'll
    always import the mock one. Later, we'll use the value in `config.py` to decide
    which database helper to `import`—the real or mock one—as we did in our previous
    project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前除了我们的模拟数据库助手外，我们没有其他数据库助手，所以我们将始终导入模拟数据库助手。稍后，我们将使用`config.py`中的值来决定要`import`哪个数据库助手-真实的还是模拟的，就像我们在以前的项目中所做的那样。
- en: 'We also need to create a `DBHelper` global class so that our application code
    can easily talk to our database. Add the following line beneath the import section
    of `waitercaller.py`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个`DBHelper`全局类，以便我们的应用程序代码可以轻松地与我们的数据库交流。在`waitercaller.py`的导入部分下面添加以下行：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we also need to configure a secret key for our application. This is
    used to cryptographically sign the session information cookies that `Flask-Login`
    hands out to our users when they log in. Signing the cookies prevents our users
    from editing them manually, which helps prevent fraudulent logins. For this step,
    you should create a long and secure secret key; you will never have to remember
    it, so don''t think about it as you would about a password or passphrase. Although
    randomly mashing your keyboard should be sufficient, humans are generally terrible
    at creating unbiased randomness, so you could also use the following command to
    create a random string using `/dev/urandom` (changing `100` to the number of characters
    you want) via the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要为我们的应用程序配置一个秘密密钥。这用于对`Flask-Login`在用户登录时分发的会话信息cookie进行加密签名。签署cookie可以防止用户手动编辑它们，有助于防止欺诈登录。对于这一步，您应该创建一个长而安全的秘密密钥；您永远不必记住它，所以不要把它当作密码或口令来考虑。尽管随机按键盘应该足够，但人类通常很难创建无偏见的随机性，因此您也可以使用以下命令使用`/dev/urandom`创建一个随机字符串（将`100`更改为您想要的字符数）：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have a long random string of characters, add the following line to
    your `waitercaller.py` file under the place where you declared the `app` variable,
    substituting the random characters for your own:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了一长串随机字符，将以下行添加到您的`waitercaller.py`文件中，在您声明`app`变量的位置下，用您自己的随机字符替换它：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding the login functionality
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加登录功能
- en: There are two main parts of logging a user in to consider. The first is when
    the user enters an e-mail address and password to authenticate, and the second
    is when the user does so by sending the required cookie—that is, he or she is
    still in the same browser *session* as when a successful login was completed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用户有两个主要部分需要考虑。第一部分是用户输入电子邮件地址和密码进行身份验证，第二部分是用户通过发送所需的cookie进行身份验证，即他或她仍然处于与成功登录完成时相同的浏览器*会话*中。
- en: Writing the login function
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写登录功能
- en: We already created the stub of our login route for the first case, so now, we
    will flesh that out a bit to check the input information against our database
    and use `Flask-Login` to log the user in if the e-mail and password match.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为第一个案例创建了登录路由的存根，现在，我们将稍微完善一下，检查输入信息与我们的数据库匹配，并使用`Flask-Login`来登录用户，如果电子邮件和密码匹配的话。
- en: 'We''ll also introduce a cleaner way of calling one Flask route from a separate
    one. Add the following lines to the imports section of `waitercaller.py`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一种更清晰的方式，从一个单独的Flask路由调用另一个。将以下行添加到`waitercaller.py`的导入部分：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first takes a URL and creates a response for a route that simply redirects
    the user to the URL specified. The second builds a URL from a function name. In
    Flask applications, you'll often see these two functions used together, as in
    the following example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数接受一个URL，并为一个简单重定向用户到指定URL的路由创建一个响应。第二个函数从一个函数名构建一个URL。在Flask应用程序中，你经常会看到这两个函数一起使用，就像下面的例子一样。
- en: 'Write the login function in `waitercaller.py` to match what follows through
    this code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`中编写登录函数，以匹配以下代码：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need to add `import` for the `request` library. Add the following line
    to the `import` section of `waitercaller.py`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`request`库添加`import`。将以下行添加到`waitercaller.py`的`import`部分：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We'll load the user's input into `email` and `password` variables and then load
    the stored password into a `user_password` variable. The `if` statement is verbose
    as we explicitly verified that a password was returned (that is, we verified that
    the user exists) and that the password was correct, even though the second condition
    implies the first. Later on, we'll talk about the trade-off of differentiating
    between the two conditions when giving feedback to our user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户的输入加载到`email`和`password`变量中，然后将存储的密码加载到`user_password`变量中。`if`语句很冗长，因为我们明确验证了是否返回了密码（也就是说，我们验证了用户是否存在），以及密码是否正确，尽管第二个条件暗示了第一个条件。稍后，我们将讨论在向用户提供反馈时区分这两个条件的权衡。
- en: If everything is valid, we will create a `User` object from the e-mail address,
    now using the e-mail address as the unique identifier required by Flask login.
    We will then pass our `User` object to the `Flask-Login` module's `login_user()`
    function so that it can handle the authentication magic. If the login is successful,
    we will redirect the user to the account page. As the user is now logged in, this
    will return the `"You are logged in"` string instead of the `"Unauthorized"` error
    we got before.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切有效，我们将从电子邮件地址创建一个`User`对象，现在使用电子邮件地址作为Flask登录所需的唯一标识符。然后，我们将把我们的`User`对象传递给`Flask-Login`模块的`login_user()`函数，以便它可以处理认证操作。如果登录成功，我们将重定向用户到账户页面。由于用户现在已经登录，这将返回`"You
    are logged in"`字符串，而不是之前得到的`"Unauthorized"`错误。
- en: 'Note that we will create a URL for our account page using the `url_for()` function.
    We will pass the result of this into the `redirect()` function so that the user
    is taken from the `/login` route to the `/account` one. This is preferable to
    simply using the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将使用`url_for()`函数为我们的账户页面创建一个URL。我们将把这个结果传递给`redirect()`函数，以便用户从`/login`路由被带到`/account`路由。这比简单地使用以下方式更可取：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our intention is more explicit, and the user will see the correct URL in the
    browser (that is, both will take the user to the `/account` page), but if we don't
    use the `redirect()` function, `/login` will still be displayed in the browser
    even on the `/account` page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图更加明确，用户将在浏览器中看到正确的URL（也就是说，两者都会把用户带到`/account`页面），但如果我们不使用`redirect()`函数，即使在`/account`页面上，浏览器中仍然会显示`/login`。
- en: Creating the load_user function
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建`load_user`函数
- en: If the user has already logged in, their browser will send us information through
    the cookie that `Flask-Login` gave them when we called the `login_user` function.
    This cookie contains a reference to the unique identifier we specified when we
    created our `User` object—in our case, the e-mail address.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经登录，他们的浏览器将通过`Flask-Login`在我们调用`login_user`函数时给他们的cookie发送信息。这个cookie包含了我们在创建`User`对象时指定的唯一标识符的引用，即在我们的情况下是电子邮件地址。
- en: '`Flask-Login` has an existing function that we called `user_loader`, which
    will handle this for us; we just need to use it as a decorator for our own function
    that checks the database to make sure the user exists and creates a `User` object
    from the identifier we are given.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Login`有一个现有的函数，我们称之为`user_loader`，它将为我们处理这个问题；我们只需要将它作为我们自己的函数的装饰器，检查数据库以确保用户存在，并从我们得到的标识符创建一个`User`对象。'
- en: 'Add the following function to your `waitercaller.py` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到你的`waitercaller.py`文件中：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The decorator indicates to `Flask-Login` that this is the function we want to
    use to handle users who already have a cookie assigned, and it'll pass the `user_id`
    variable from the cookie to this function whenever a user visits our site, which
    already has one. Similarly to what we did before, we will check whether the user
    is in our database (`user_password` will be blank if `user_id` is invalid), and
    if it is, we will recreate the `User` object. We'll never explicitly call this
    function or use the result as it'll only be used by the `Flask-Login` code, but
    our application will throw an error if a user who is given a cookie by our `login()`
    function visits the site and `Flask-Login` can't find an implementation for this
    `user_loader()` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器指示`Flask-Login`这是我们要用来处理已经分配了cookie的用户的函数，每当一个用户访问我们的网站时，它都会把cookie中的`user_id`变量传递给这个函数，这个用户已经有了一个。类似于之前的操作，我们将检查用户是否在我们的数据库中（如果`user_id`无效，`user_password`将为空），如果是，我们将重新创建`User`对象。我们永远不会显式调用这个函数或使用结果，因为它只会被`Flask-Login`代码使用，但是如果我们的应用程序通过我们的`login()`函数给用户分配了一个cookie，当用户访问网站时`Flask-Login`找不到这个`user_loader()`函数的实现，我们的应用程序将抛出一个错误。
- en: It might seem unnecessary to check the database in this step considering we
    gave the user a supposedly tamper-proof token that proves that he or she is a
    valid user, but it is in fact necessary as the database may have been updated
    since the user last logged in. If we make the user's session token valid for a
    long time (recall that in our Headlines project, we made the cookies last for
    a year), there is the possibility that the user's account will have been modified
    or deleted since the cookie was assigned.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中检查数据库似乎是不必要的，因为我们给用户一个据称是防篡改的令牌，证明他或她是一个有效的用户，但实际上是必要的，因为自用户上次登录以来数据库可能已经更新。如果我们使用户的会话令牌有效时间很长（回想一下，在我们的Headlines项目中，我们让cookies持续了一年），那么用户的帐户在分配cookie后可能已经被修改或删除。
- en: Checking the login functionality
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查登录功能
- en: It's time to give our new login functionality a try! Fire up the `waitercaller.py`
    file locally and visit `localhost:5000` in your web browser. Type in the e-mail
    ID `test@example.com` and password `123456` from our mock database and hit the
    login button. You should be redirected to `http://localhost:5000/account` and
    view the **You are logged in** message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试我们的新登录功能了！在本地启动`waitercaller.py`文件，并在Web浏览器中访问`localhost:5000`。在我们的模拟数据库中输入电子邮件ID`test@example.com`和密码`123456`，然后点击登录按钮。您应该会被重定向到`http://localhost:5000/account`，并看到**您已登录**的消息。
- en: Close your browser and reopen it, this time visiting `localhost:5000/account`
    directly. As we didn't tell `Flask-Login` to remember users, you should now see
    the **Unauthorized** error again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭浏览器，然后重新打开，这次直接访问`localhost:5000/account`。由于我们没有告诉`Flask-Login`记住用户，您现在应该再次看到**未经授权**的错误。
- en: 'Because of the nature of our application, we would expect most users to want
    to stay logged in so that the restaurant staff can simply open the page in the
    morning and use the functionality straightaway. `Flask-Login` makes this change
    very straightforward. Simply change the line of your `login()` function that reads
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用程序的性质，我们预计大多数用户都希望保持登录状态，以便餐厅员工可以在早上简单地打开页面并立即使用功能。`Flask-Login`使这个改变非常简单。只需更改`login()`函数中的以下行：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Your new `login()` function should now read:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新`login()`函数现在应该是这样的：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if you repeat the preceding steps, you should view the **You are logged
    in** message as shown in the following screenshot, even after restarting your
    browser:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您重复前面的步骤，即使重新启动浏览器，您也应该看到**您已登录**的消息，如下面的屏幕截图所示：
- en: '![Checking the login functionality](img/B04312_09_04.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![检查登录功能](img/B04312_09_04.jpg)'
- en: Now that we can log a user in, let's take a look at how we can allow the user
    to log out as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以登录用户，让我们看看如何让用户注销。
- en: Logging out a user
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注销用户
- en: '`Flask-Login` provides a logout function that works straight out of the box.
    All we have to do is link it up to a route. Add the following route to your `waitercaller.py`
    file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Login`提供了一个直接可用的注销功能。我们所要做的就是将其链接到一个路由上。在您的`waitercaller.py`文件中添加以下路由：'
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, add the `import` for the `logout_user()` function to the imports section
    of `waitercaller.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`waitercaller.py`的导入部分添加`logout_user()`函数的`import`：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note here that there's no need to pass the `User` object to `Flask-Login` for
    this call; the `logout()` function simply removes the session cookie from the
    user's browser. Once the user is logged out, we can redirect them back to the
    home page.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此调用中不需要将`User`对象传递给`Flask-Login`；`logout()`函数只是从用户的浏览器中删除会话cookie。一旦用户注销，我们就可以将他们重定向回主页。
- en: Visit `localhost:5000/logout` in your browser and then attempt to visit `localhost:5000/account`
    again. You should see the **Unauthorized** error again as the `test@example.com`
    user got logged out.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中访问`localhost:5000/logout`，然后尝试再次访问`localhost:5000/account`。您应该会再次看到**未经授权**的错误，因为`test@example.com`用户已注销。
- en: Registering a user
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册用户
- en: It's great that we can log users in, but at the moment we can only do so with
    the mock user that we hardcoded into our database. We need to be able to add new
    users to our database when the registration form is filled out. We'll still do
    all of this through our mock database, so every time our application is restarted,
    all the users will be lost (they will only be saved in the local Python dictionary
    variable, which is lost when the application is terminated).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以登录用户是很好的，但目前我们只能使用硬编码到我们数据库中的模拟用户来这样做。当注册表格被填写时，我们需要能够将新用户添加到我们的数据库中。我们仍然会通过我们的模拟数据库来完成所有这些工作，因此每次应用程序重新启动时，所有用户都将丢失（它们只会保存在本地Python字典变量中，在应用程序终止时丢失）。
- en: We mentioned that storing the users' passwords was a very bad idea; so first,
    we'll take a brief look at how cryptographic hashing works and how we can manage
    passwords more securely.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到存储用户密码是一个非常糟糕的主意；因此，首先，我们将简要介绍密码哈希的工作原理以及如何更安全地管理密码。
- en: Managing passwords with cryptographic hashes
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用密码进行密码管理的密码哈希
- en: Instead of storing the password, we want to store something that is *derived
    from* the password. When the user registers and gives us a password, we'll run
    some modification on it and store the result of the modification instead. Then,
    the next time the user visits our site and uses the password to log in, we can
    run the same modification on the input password and verify that the result matches
    what we stored.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想存储密码，而是想存储*从*密码派生出的东西。当用户注册并给我们一个密码时，我们将对其进行一些修改，并存储修改的结果。然后，用户下次访问我们的网站并使用密码登录时，我们可以对输入密码进行相同的修改，并验证结果是否与我们存储的匹配。
- en: The catch is that we want our modification to be nonreversible; that is, someone
    who has access to the modified password should not be able to deduce the original.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们希望我们的修改是不可逆的；也就是说，有权访问修改后的密码的人不应该能够推断出原始密码。
- en: Enter hash functions. These little pieces of mathematical wizardry take a string
    as input and return a (big) number as output. The same string input will always
    result in the same output, but it is almost impossible for two different inputs
    to produce the same output. Hash functions are so-called *one-way* functions as
    it is provably impossible to deduce the input if you only have the output.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输入哈希函数。这些小片段的数学魔法将字符串作为输入并返回（大）数字作为输出。相同的字符串输入将始终产生相同的输出，但几乎不可能使两个不同的输入产生相同的输出。哈希函数被称为*单向*函数，因为如果您只有输出，则无法推断输入是可以证明的。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Password storage and management is a big topic that we can only touch on in
    this project. For more information on most things regarding information security,
    [www.owasp.org](http://www.owasp.org) is a good resource. Their comprehensive
    guide to storing passwords securely can be found at [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 密码存储和管理是一个大课题，我们在这个项目中只能触及一点。有关信息安全的大多数事项的更多信息，请访问[www.owasp.org](http://www.owasp.org)。他们关于安全存储密码的全面指南可以在[https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet)找到。
- en: Python hashlib
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python hashlib
- en: 'Let''s take a look at how to use hash functions in Python. Run the following
    in a Python shell:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中使用哈希函数。在Python shell中运行以下命令：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As output, you should see the hash **ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**,
    as shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，您应该看到哈希**ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**，如下面的屏幕截图所示：
- en: '![Python hashlib](img/B04312_09_05.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Python hashlib](img/B04312_09_05.jpg)'
- en: The random-looking string of hexadecimal characters is the `sha512` hash of
    the `'123456'` string, and this is what we will store in our database. Every time
    the user enters the plaintext password, we'll run it through the hash function
    and verify that the two hashes meet up. If an attacker or employee sees the hash
    in the database, they cannot masquerade as the user because they cannot deduce
    `'123456'` from the hash.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字符的随机字符串是`sha512`哈希值的`'123456'`字符串，这是我们将存储在数据库中的内容。每当用户输入明文密码时，我们将通过哈希函数运行它，并验证这两个哈希是否匹配。如果攻击者或员工在数据库中看到哈希值，他们无法冒充用户，因为他们无法从哈希中推断出`'123456'`。
- en: Reversing hashes
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反向哈希
- en: Actually, the heading of this section isn't entirely true. While there is no
    way to *reverse* a hash and write a function that takes the preceding hexadecimal
    string as input and produces `'123456'` as output, people can be pretty determined.
    The hacker may still try every possible likely input and run it through the same
    hash function and keep doing this until the hashes match up. When the hacker comes
    across an input that produces **ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**
    as an output, he has effectively cracked the password.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这一部分的标题并不完全正确。虽然没有办法*反向*哈希并编写一个函数，该函数以前面的十六进制字符串作为输入并产生`'123456'`作为输出，但人们可能会非常坚决。黑客可能仍然尝试每种可能的输入，并通过相同的哈希函数运行它，并继续这样做，直到哈希匹配。当黑客遇到一个输入，产生的输出为**ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**时，他已成功破解了密码。
- en: However, hashing functions tend to need a lot of processing power, so it is
    not practical to run through large amounts of input (known as *brute forcing*).
    People have also created so-called rainbow tables with all common inputs precomputed
    and stored in a database so that the results can be found instantly. This is a
    classic *space-time* trade-off that is so often seen in computer science. If we
    compute hashes for all possible inputs, it will take a long time; if we want to
    compute every possible combination in advance so that we can look up the results
    instantly, we need a lot of storage space.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，哈希函数往往需要大量的处理能力，因此通过大量输入（称为*暴力破解*）并不实际。人们还创建了所谓的彩虹表，其中包含所有常见输入的预先计算和存储在数据库中，以便可以立即找到结果。这是计算机科学中经常看到的经典*空间-时间*权衡。如果我们计算所有可能的输入的哈希值，将需要很长时间；如果我们想要预先计算每种可能的组合，以便我们可以立即查找结果，我们需要大量的存储空间。
- en: If you go to a hash reversal website, such as [http://md5decrypt.net/en/Sha512/](http://md5decrypt.net/en/Sha512/),
    and input the exact hex string you noted here, it'll tell you that the decrypted
    version is **123456**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您转到哈希反转网站，例如[http://md5decrypt.net/en/Sha512/](http://md5decrypt.net/en/Sha512/)，并输入您在此处注意到的确切十六进制字符串，它会告诉您解密版本为**123456**。
- en: '![Reversing hashes](img/B04312_09_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![反向哈希](img/B04312_09_06.jpg)'
- en: It didn't actually try every possible combination of inputs in the claimed **0.143**
    seconds, but it stored the answer from a previous time when the hash was computed.
    Such sites have a large database containing mappings and plaintext strings along
    with their hashed equivalents.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在所声称的0.143秒内，它实际上并没有尝试每种可能的输入组合，但它存储了以前计算哈希时的答案。这样的网站有一个包含映射和明文字符串以及它们的哈希等效项的大型数据库。
- en: 'If you hash a string such as `b^78asdflkjwe@#xx...&AFs[--l` and paste the resulting
    hash into the md5decrypt website, you''ll note that the string is not common enough
    for this particular site to have precomputed, and instead of getting the plain
    text back again, you''ll get a screen that looks similar to the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对字符串进行哈希处理，例如`b^78asdflkjwe@#xx...&AFs[--l`，并将生成的哈希粘贴到md5decrypt网站上，您会注意到该字符串对于该特定网站来说并不常见，而不是再次获得纯文本，您将看到一个类似于以下屏幕截图的屏幕：
- en: '![Reversing hashes](img/B04312_09_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![反向哈希](img/B04312_09_07.jpg)'
- en: We want all of the passwords we store to be complicated enough to not exist
    in precomputed hash tables. However, our users are more likely to choose passwords
    that are common enough that they *have* been precomputed. The solution is to add
    what is known as *salt* to our passwords before we store them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们存储的所有密码都足够复杂，以至于在预先计算的哈希表中不存在。然而，我们的用户更有可能选择常见到已经被预先计算的密码。解决方案是在存储密码之前添加所谓的*盐*。
- en: Salting passwords
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 给密码加盐
- en: As users tend to use weak passwords, such as `123456`, that quite likely exist
    in precomputed hash tables, we want to do our users a favor and add some random
    value to their passwords when we store them. This makes it even more difficult
    for a malicious attacker who has access to the stored hash to gain the user's
    private password, even though we will store the random value we used with the
    password. This is known as *salting* the password; similarly to salting food,
    it is easy for us to add some salt to the password, but removing the salt is hopefully
    impossible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户往往使用弱密码，比如 `123456`，这些密码很可能存在于预先计算的哈希表中，我们希望为我们的用户做一些好事，并在存储密码时为其添加一些随机值。这样，即使恶意攻击者能够访问存储的哈希值，也更难以获取用户的私人密码，尽管我们将存储与密码一起使用的随机值。这就是所谓的*给密码加盐*；类似于给食物加盐，我们很容易给密码加一些盐，但希望去除盐是不可能的。
- en: 'In summary, we want to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们想要：
- en: Accept a plaintext password from the user at registration time
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册时接受用户的明文密码
- en: Add some random value (salt) to this password to strengthen it
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这个密码添加一些随机值（盐）以加强它
- en: Hash the concatenation of the password and salt
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对密码和盐的连接进行哈希处理
- en: Store the hash and salt
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储哈希和盐
- en: 'When the user logs in, we need to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，我们需要：
- en: Take the plaintext password from the user
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户那里获取明文密码
- en: Find the stored salt in our database and add it to the user's input
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找我们数据库中存储的盐，并将其添加到用户的输入中
- en: Hash the concatenation of the password and salt
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对密码和盐的连接进行哈希处理
- en: Verify that the result matches what we previously stored
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证结果是否与我们之前存储的相匹配
- en: Implementing secure password storage in Python
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中实现安全的密码存储
- en: To implement the preceding, we'll create a very small `PasswordHelper` class
    that will take care of the hashing and generation of random salts. Although this
    is very little code, when we use the standard `hashlib`, `os`, and `base64` Python
    libraries, it is good practice to abstract all the cryptography logic to its own
    class. That way, if we change how we implement password management, we can make
    most of our changes to this new class and not have to touch the main application
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述内容，我们将创建一个非常小的 `PasswordHelper` 类，它将负责哈希处理和生成随机盐。尽管这是非常少量的代码，但当我们使用标准的
    `hashlib`、`os` 和 `base64` Python 库时，将所有加密逻辑抽象到自己的类中是一个良好的实践。这样，如果我们改变了密码管理的实现方式，我们可以将大部分更改都应用到这个新类中，而不必触及主应用程序代码。
- en: We also need to make some changes to our `login()` function, flesh out our `registration()`
    function, and create a new method for our database helper code that will add a
    new user to our mock database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对我们的 `login()` 函数进行一些更改，完善我们的 `registration()` 函数，并为我们的数据库辅助代码创建一个新的方法，用于向我们的模拟数据库中添加新用户。
- en: Creating the PasswordHelper class
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 PasswordHelper 类
- en: 'Let''s start with `PasswordHelper`. Create a file called `passwordhelper.py`
    in your `waitercaller` directory and add the following code to it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `PasswordHelper` 开始。在您的 `waitercaller` 目录中创建一个名为 `passwordhelper.py` 的文件，并将以下代码添加到其中：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first two methods are used when a user registers for the first time and
    can be explained as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法用于用户首次注册时，并可以解释如下：
- en: The `get_hash()` method is just a wrapper of the `sha512` hash function that
    we looked at earlier. We'll use this to create the final hash that we will store
    in our database.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_hash()` 方法只是我们之前看过的 `sha512` 哈希函数的包装器。我们将使用它来创建最终存储在我们数据库中的哈希值。'
- en: The `get_salt()` method uses `os.urandom()` to generate a cryptographically
    secure random string. We will encode this as a `base64` string as the random string
    may contain any bytes, some of which we may have issues with storing in our database.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_salt()` 方法使用 `os.urandom()` 生成一个密码学上安全的随机字符串。我们将把它编码为 `base64` 字符串，因为随机字符串可能包含任何字节，其中一些可能会在我们的数据库中存储时出现问题。'
- en: The `validate_password()` method is used when the user logs in and gives us
    the original plaintext password again. We'll pass in what the user gave us (the
    `plain` parameter), the salt that we stored when they registered, and verify that
    hashing the two produces the same hash that we stored (the `expected` parameter).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_password()` 方法在用户登录时使用，并再次给出原始明文密码。我们将传入用户给我们的内容（`plain` 参数），他们注册时存储的盐，并验证对这两者进行哈希处理是否产生了我们存储的相同哈希值（`expected`
    参数）。'
- en: Updating our database code
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新我们的数据库代码
- en: We now need to store a password and salt associated with each user; we can't
    use the simple e-mail and password dictionary that we had before. Instead, for
    our mock database, we'll use a list of dictionaries, with every piece of information
    we need to store having a key and value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为每个用户存储一个密码和盐；我们不能再使用之前的简单电子邮件和密码字典。相反，对于我们的模拟数据库，我们将使用一个字典列表，其中我们需要存储的每个信息都有一个键和值。
- en: 'We''ll also update the code in `mockdbhelper.py` to read as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新 `mockdbhelper.py` 中的代码如下：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our mock user still has the password `123456`, but a potential attacker can
    no longer work this out by looking up the hash in a rainbow table. We also created
    the `add_user()` function, which takes the `email`, `salt`, and `hashed` password
    for a new user and stores a record of this. Our `get_user()` method now needs
    to loop through all the mock users to find out whether any match the input e-mail
    address. This is inefficient but will be handled more efficiently by our database,
    and as we will never have hundreds of mock users, we don't need to worry about
    this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟用户仍然使用密码`123456`，但潜在的攻击者不再能够通过查找彩虹表中的哈希值来破解密码。我们还创建了`add_user()`函数，该函数接受新用户的`email`、`salt`和`hashed`密码，并存储这些记录。我们的`get_user()`方法现在需要循环遍历所有模拟用户，以找出是否有任何匹配输入电子邮件地址的用户。这是低效的，但将由我们的数据库更有效地处理，并且由于我们永远不会有数百个模拟用户，所以我们不需要担心这一点。
- en: Updating our application code
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新我们的应用程序代码
- en: In our main `waitercaller.py` file, we need to add another `import` for our
    password helper and instantiate a global instance of our password helper class
    so that we can use it in our `register()` and `login()` functions. We also need
    to modify our `login()` function to account for the new database model and flesh
    out our `register()` function to perform some validation and call the database
    code to add a new user.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主要`waitercaller.py`文件中，我们需要为密码助手添加另一个`import`，并实例化密码助手类的全局实例，以便我们可以在`register()`和`login()`函数中使用它。我们还需要修改我们的`login()`函数以适应新的数据库模型，并完善我们的`register()`函数以执行一些验证，并调用数据库代码来添加新用户。
- en: 'Add the following line to the imports section of `waitercaller.py`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`的导入部分添加以下行：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, add the following near the place where you created the `DBHelper()` object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在创建`DBHelper()`对象的地方附近添加以下内容：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, modify the `login()` function to read as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改`login()`函数如下：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The only real change is in the `if` statement, in which we will now use the
    password helper to validate the password using the salt and user-provided password.
    We will also change the variable name of the user to `stored_user` as this is
    now a dictionary instead of just the password value it used to be.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的真正变化在`if`语句中，我们现在将使用密码助手使用盐和用户提供的密码来验证密码。我们还将用户的变量名称更改为`stored_user`，因为现在这是一个字典，而不仅仅是以前的密码值。
- en: Finally, we need to build the `register()` function. This will use the password
    and database helper to create a new salted and hashed password and store this
    along with the user's e-mail address in our database.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要构建`register()`函数。这将使用密码和数据库助手来创建一个新的加盐和哈希密码，并将其与用户的电子邮件地址一起存储在我们的数据库中。
- en: 'Add a `/register` route and associated function to the `waitercaller.py` file
    with the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`文件中添加`/register`路由和相关函数，代码如下：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We asked the user to input their password twice on our registration form as
    it's easy for users to make a typo when they register and then not be able to
    access their account (as they registered with a different password from the one
    they meant to). Therefore, in this step, we can confirm that the two passwords
    entered by the user are the same.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求用户在注册表单上两次输入他们的密码，因为用户在注册时很容易出现输入错误，然后无法访问他们的帐户（因为他们使用了与他们打算使用的密码不同的密码）。因此，在这一步中，我们可以确认用户输入的两个密码是相同的。
- en: We also verified that the user doesn't already exist as each user needs to use
    a unique e-mail address.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还验证了用户是否已经存在，因为每个用户都需要使用唯一的电子邮件地址。
- en: Finally, we generated a salt, created a hash from the password and salt, and
    stored this in our database. Then, we redirected the user back to homepage, testing
    our registration functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们生成了一个盐，从密码和盐创建了一个哈希，并将其存储在我们的数据库中。然后，我们将用户重定向回主页，测试我们的注册功能。
- en: It's time to give the application a test run again. Close your browser and restart
    the application locally. Visit the homepage and register an account by choosing
    an e-mail and password. When you get redirected to the homepage after registration,
    log in using the same username and password you just registered with. If all went
    well, you'll see the **You are logged in** message. Again, visit `http://localhost:5000/logout`
    in order to log out.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次对应用程序进行测试了。关闭浏览器并在本地重新启动应用程序。访问主页并通过选择电子邮件和密码注册一个帐户。注册后，使用刚刚注册的相同用户名和密码登录。如果一切顺利，您将看到**您已登录**消息。然后再次访问`http://localhost:5000/logout`以注销。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to use Bootstrap to make our application look
    good out of the box and to be responsive based on our user's screen size. We got
    a basic User Account Control system up and running, and we can register users,
    log users in, and log them out again.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Bootstrap使我们的应用程序在开箱即用时看起来很好，并根据用户的屏幕大小进行响应。我们建立了一个基本的用户帐户控制系统，我们可以注册用户，登录用户，然后再次注销用户。
- en: We also spent some time looking at how to securely store passwords using cryptographic
    hash functions and salts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间研究如何使用加密哈希函数和盐来安全存储密码。
- en: In the next chapter, we'll build out the functionality of our application, which
    we discussed in the project outline at the start of this chapter. We'll also look
    at an easier way to create the forms that our visitors will use to interact with
    our application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建应用程序的功能，这些功能在本章开头的项目概述中讨论过。我们还将看一种更简单的方法来创建访问者将用来与我们的应用程序交互的表单。
