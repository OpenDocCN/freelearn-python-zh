- en: Chapter 3. Unit Testing with doctest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用 doctest 进行单元测试
- en: In the last chapter, we talked about what `doctest` does, how it works, and
    what you can expect out of it. Why are we devoting another chapter to it?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 `doctest` 做什么，它是如何工作的，以及你可以期望从它那里得到什么。为什么我们还要再写一章关于它？
- en: We're not. This chapter isn't really about `doctest`. It's about the testing
    discipline called **unit testing**. Since unit testing is an idea, not a piece
    of software, we'll be using `doctest` to practice with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是。这一章并不是真的关于 `doctest`。它是关于称为**单元测试**的测试纪律。由于单元测试是一个想法，而不是一个软件片段，我们将使用 `doctest`
    来实践它。
- en: 'In this chapter, we''re going to see:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看到：
- en: What unit testing actually is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试实际上是什么
- en: How unit testing helps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试如何帮助
- en: How `doctest` relates to unit testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest` 如何与单元测试相关'
- en: What is unit testing?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试是什么？
- en: First of all, why do we care what unit testing is? One answer is that unit testing
    is a best practice that has been evolving toward its current form over most of
    the time that programming has existed. Another answer is that the core principles
    of unit testing are just good sense. It might actually be a little embarrassing
    to our community as a whole that it took us so long to recognize this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为什么关心单元测试是什么？一个答案是单元测试是一种最佳实践，在编程存在的大部分时间里，它一直在向当前形式演变。另一个答案是单元测试的核心原则只是常识。实际上，对我们整个社区来说，我们花了这么长时间才认识到这一点可能有点尴尬。
- en: So what is it? Unit testing means testing the smallest meaningful pieces of
    code (such pieces are called units), in such a way that guarantees that the success
    or failure of each test depends only on the unit and nothing else.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它到底是什么？单元测试意味着以这样的方式测试代码的最小有意义的部分（这样的部分被称为单元），确保每个测试的成功或失败只依赖于单元，而不依赖于其他任何东西。
- en: 'There''s a reason for each part of this definition:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定义中的每一部分都有原因：
- en: We test the smallest meaningful pieces of code so that failed tests tell us
    where the problem is. The larger the tested chunk of code, the larger the area
    where a problem might originate.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试代码的最小有意义的部分，以便失败的测试告诉我们问题在哪里。测试的代码块越大，问题可能起源的区域就越大。
- en: We make sure that each test depends only on the tested unit for success or failure
    because, if it invokes any code outside the unit, we can't guarantee that the
    test's success or failure is actually due to that unit. When tests aren't independent,
    you can't trust them to tell you what the problem is and where to find it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保每个测试只依赖于被测试的单元来成功或失败，因为如果它调用了单元外的任何代码，我们无法保证测试的成功或失败实际上是由于该单元。当测试不是独立的，你就不能信任它们告诉你问题的性质和位置。
- en: We made some efforts to write our tests in [Chapter 2](ch02.html "Chapter 2. Working
    with doctest"), *Working with doctest*, according to this discipline, although
    we allowed ourselves some wiggle room because we were focusing on writing a testable
    specification. In this chapter, we're going to be more rigorous.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据这种纪律在[第2章](ch02.html "第2章. 与 doctest 一起工作") *与 doctest 一起工作* 中努力编写我们的测试，尽管我们给自己留了一些余地，因为我们专注于编写可测试的规范。在这一章中，我们将更加严格。
- en: Automated testing is often associated with unit testing. Automated testing makes
    it fast and easy to run unit tests, and unit tests tend to be amenable to automation.
    We're certainly going to make heavy use of automated testing, both with `doctest`
    now, and later with tools such as unittest and Nose as well. However, strictly
    speaking, unit testing is not tied to automated testing. You can do unit testing
    with nothing but your own code and some discipline.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试通常与单元测试相关联。自动测试使得运行单元测试变得快速且容易，而且单元测试通常易于自动化。我们当然会大量使用自动测试，现在使用 `doctest`，以后还会使用像
    unittest 和 Nose 这样的工具。然而，严格来说，单元测试并不局限于自动测试。你可以仅用你自己的代码和一些纪律来进行单元测试。
- en: The limitations of unit testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的限制
- en: Any test that involves more than one unit is automatically not a unit test.
    That matters because the results of unit tests tend to be particularly clear about
    what a problem is and where to find it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何涉及多个单元的测试自动就不是单元测试。这很重要，因为单元测试的结果往往特别清晰地表明了问题的性质和位置。
- en: When you test multiple units at once, the results of the various units get mixed
    together. In the end, you have to wonder about both what the problem is (is the
    mistake in this piece of code, or is it correctly handling bad input from some
    other piece of code?), and where the problem is (this output is wrong, but how
    do the involved units work together to create the error?).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你同时测试多个单元时，各个单元的结果会混合在一起。最终，你不得不思考问题是什么（错误是否在这段代码中，或者是否正确处理了其他代码段传来的错误输入？），以及问题在哪里（这个输出是错误的，但涉及到的单元是如何一起工作以产生错误的？）。
- en: Empirical scientists must perform experiments that check only one hypothesis
    at a time, whether the subject at hand is Chemistry, Physics, or the behavior
    of a body of program code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 经验科学家必须进行实验，每次只检查一个假设，无论研究对象是化学、物理还是程序代码的行为。
- en: Example – identifying units
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 确定单元
- en: 'Imagine for a moment that one of your coworkers has written the following code,
    and it''s your responsibility to test it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的一个同事编写了以下代码，而你的任务是测试它：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some things to think about: Which sections of this code are the units?
    Is there only one unit consisting of the entire class? Is each method a separate
    unit? What about each statement, or maybe each expression?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的事情：这段代码的哪些部分是单元？是否只有一个包含整个类的单元？每个方法是否是一个单独的单元？关于每个语句，或者可能是每个表达式呢？
- en: In some sense, the answer is subjective because part of the definition of a
    unit is that it is meaningful. You can say that the whole class is a single unit,
    and in some circumstances that might be the best answer. However, it is easy to
    subdivide most classes into methods, and normally methods make better units because
    they have well-defined interfaces and partially isolated behaviors, and because
    their intent and meaning should be well understood.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，答案具有主观性，因为单元定义的一部分是它是有意义的。你可以认为整个类是一个单元，在某些情况下这可能是最合适的答案。然而，大多数类都很容易细分为方法，通常方法比类更适合作为单元，因为它们有定义良好的接口和部分隔离的行为，以及它们的意图和意义应该被充分理解。
- en: 'Statements and expressions don''t make good units because they are almost never
    particularly meaningful in isolation. Furthermore, statements and expressions
    are difficult to target: unlike classes and methods, they don''t have names or
    easy ways to focus a test on them.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和表达式并不构成好的单元，因为它们几乎从未在孤立状态下具有特别的意义。此外，语句和表达式很难定位：与类和方法不同，它们没有名称或容易聚焦测试的方法。
- en: 'Here are some things to think about: What will be the consequences of choosing
    a different definition of unit for this code? If you have decided that methods
    are the best units, what would be different if you had picked classes? Likewise,
    if you picked classes, what would be different if you''d picked methods?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的事情：选择不同的单元定义对这段代码会有什么后果？如果你已经决定方法是最好的单元，那么如果你选择了类，会有什么不同？同样，如果你选择了类，那么如果你选择了方法，会有什么不同？
- en: 'Here are some things to think about: Take a look at `method4`. The result of
    this method depends on all of the other methods working correctly; worse, it depends
    on the unique ID of the self object. Can `method4` be treated as a unit? If we
    could change anything except `method4`, what is that we have to change to allow
    it to be tested as a unit and produce a predictable result?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的事情：看看`method4`。这个方法的结果依赖于所有其他方法正确工作；更糟糕的是，它依赖于self对象的唯一ID。`method4`能否被视为一个单元？如果我们可以改变除`method4`之外的所有东西，我们还需要改变什么才能允许它作为一个单元进行测试并产生可预测的结果？
- en: Choosing units
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择单元
- en: You can't organize a suite of unit tests until you decide what constitutes a
    unit. The capabilities of your chosen programming language affect this choice.
    For example, C++ and Java make it difficult or impossible to treat methods as
    units (because you can't access a method without first instantiating the class
    it's part of); thus, in these languages each class is usually treated as a single
    unit, or metaprogramming tricks are used to force the methods into isolation so
    that they can be tested as units. C, on the other hand, doesn't support classes
    as language features at all, so the obvious choice of unit is the function. Python
    is flexible enough that either classes or methods can be considered as units and,
    of course, it has standalone functions as well; it is also natural to think of
    them as units.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定什么是单元之前，你不能组织单元测试套件。你选择的编程语言的能力会影响这个选择。例如，C++和Java使得将方法视为单元变得困难或不可能（因为你不能在没有首先实例化它所属的类的情况下访问方法）；因此，在这些语言中，每个类通常被视为一个单独的单元，或者使用元编程技巧来强制方法隔离，以便它们可以作为单元进行测试。另一方面，C语言根本不支持类作为语言特性，所以明显的单元选择是函数。Python足够灵活，既可以考虑类或方法作为单元，当然，它也有独立的函数；将它们视为单元也是自然的。
- en: The smaller the units are, the more useful the tests tend to be because they
    narrow down the location and nature of bugs more quickly. For example, if you
    choose to treat the `Testable` class as a unit, tests of the class will fail if
    there is a mistake in any of the methods. This tells you that there's a mistake
    in `Testable`, but not that it's in `method2`, or wherever it actually is. On
    the other hand, there is a certain amount of rigamarole involved in treating `method4`
    and its like as units, to such an extent that the next chapter of the book is
    dedicated to dealing with such situations. Even so, I recommend using methods
    and functions as units most of the time because it pays off in the long run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元越小，测试通常越有用，因为它们可以更快地缩小错误的位置和性质。例如，如果你选择将`Testable`类视为一个单元，如果任何方法中存在错误，类的测试将失败。这告诉你`Testable`中存在错误，但不是在`method2`中，或者实际上在哪个位置。另一方面，将`method4`及其类似方法视为单元涉及一定程度的繁琐，以至于本书的下一章专门讨论这种情况。即便如此，我建议大多数时候使用方法和函数作为单元，因为从长远来看这样做是值得的。
- en: When you were thinking about `method4`, you probably realized that the function
    calls to `id` and `self.method3` were the problem, and that the method can be
    tested as a unit if they didn't invoke other units. In Python, replacing the functions
    with stand-ins at runtime is fairly easy to do, and we'll be discussing a structured
    approach to this in the next chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在思考`method4`时，你可能意识到对`id`和`self.method3`的函数调用是问题所在，如果它们没有调用其他单元，那么这个方法可以作为单元进行测试。在Python中，在运行时用替身替换函数相对容易，我们将在下一章讨论这种方法的结构化方法。
- en: Check your understanding
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查你的理解
- en: 'Take a look at the code for this simple class, and use it to figure out the
    answers to the questions. It''s okay to check back through the book. This is just
    a way for you to make sure you''re ready to move on:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个简单类的代码，并使用它来找出问题的答案。查看本书是完全可以的。这只是确保你准备好继续前进的一种方式：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are the questions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题：
- en: Assuming that we're using methods as units, how many units exist in the preceding
    code?
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们使用方法作为单元，前面代码中存在多少个单元？
- en: 'Answer: There are three units that exist in the preceding code and that are
    as follows: `__init__`, `method1`, and `method2`. `__init__` is a method, just
    as `method1` and `method2`. The fact that it''s a constructor means that it''s
    all tangled up with the other units, but it''s still a method containing code
    and a possible location for bugs, and so we cannot afford to treat this as anything
    other than a unit.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：在前面代码中存在三个单元，如下所示：`__init__`、`method1`和`method2`。`__init__`是一个方法，就像`method1`和`method2`一样。它是构造函数的事实意味着它与其他单元纠缠在一起，但它仍然是一个包含代码和可能存在错误的位置的方法，所以我们不能将其视为任何其他东西，而只能视为一个单元。
- en: Which units make assumptions about the correct operation of other units? In
    other words, which units are not independent?
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些单元假设其他单元的正确运行？换句话说，哪些单元不是独立的？
- en: 'Answer: Both `method1` and `method2` assume that `__init__` works right, and
    `method2` makes the same assumption as that of `method1`.'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：`method1`和`method2`都假设`__init__`运行正确，`method2`与`method1`有相同的假设。
- en: How can you write a test for `method2` that does not assume that other units
    work correctly?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写一个测试`method2`的测试，而不假设其他单元正确工作？
- en: 'Answer: The tests for `method2` will need to use a fake `method1` that is a
    part of the test code, and not a part of the code being tested.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：`method2`的测试将需要使用一个作为测试代码一部分的假`method1`，而不是被测试代码的一部分。
- en: Unit testing during the development process
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发过程中的单元测试
- en: We're going to walk through the development of one class, treating it as a complete
    programming project and integrating unit testing at each step of the process.
    For something as small as a single standalone class, this may seem silly, but
    it illustrates the practices that keep larger projects from getting bogged down
    in a tangle of bugs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步开发一个类，将其视为一个完整的编程项目，并在每个步骤中集成单元测试。对于一个如此小的独立类来说，这可能看起来很愚蠢，但它说明了如何防止大型项目陷入bug的混乱。
- en: We're going to create a PID controller class. A PID controller is a tool from
    control theory, a way of controlling machines so that they move smoothly and efficiently.
    The robot arms that assemble cars in factories are controlled by PID controllers.
    We'll be using a PID controller for this demonstration because it's a very useful,
    and a very real-world idea. Many programmers have been asked to implement PID
    controllers at some point in their careers. This example is meant to be read as
    if we are contractors and are being paid to produce results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个PID控制器类。PID控制器是控制理论中的一个工具，是一种控制机器使其平滑高效运动的方法。在工厂中组装汽车的机器人手臂是由PID控制器控制的。我们将使用PID控制器进行这个演示，因为它非常实用，并且非常贴近现实世界。许多程序员在他们的职业生涯中某个时刻都被要求实现PID控制器。这个例子意味着我们作为承包商，正在被支付以产生结果。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you find that the PID controllers are more interesting than simply an example
    in a programming book, wikipedia''s article is a good place to begin learning
    about this: [http://en.wikipedia.org/wiki/PID_controller](http://en.wikipedia.org/wiki/PID_controller).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现PID控制器比编程书中的简单例子更有趣，维基百科的文章是一个开始学习这个主题的好地方：[http://en.wikipedia.org/wiki/PID_controller](http://en.wikipedia.org/wiki/PID_controller)。
- en: Design
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'Our imaginary client gives us the following specification:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假设客户给出了以下规范：
- en: We want a class that implements a PID controller for a single variable. The
    measurement, setpoint and output should all be real numbers.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们希望有一个类来实现单个变量的PID控制器。测量值、设定点和输出都应该是实数。
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need to be able to adjust the setpoint at runtime, but we want it to have
    a memory, so we can easily return to the previous setpoint.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们需要在运行时调整设定点，但我们希望它具有记忆功能，这样我们就可以轻松地返回到先前的设定点。
- en: We'll take this and make it more formal, not to mention complete, by writing
    a set of acceptance tests as unit tests that describe the behavior. This way we'll
    at least have it set down precisely as what we believe the client intended.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一组验收测试作为单元测试，以描述行为。这样我们至少可以精确地记录我们认为客户意图的内容。
- en: 'We need to write a set of tests that describe the constructor. After looking
    up what a PID controller actually is, we have learned that they are defined by
    three gains and a setpoint. The controller has three components: proportional,
    integral, and derivative (this is where the name PID comes from). Each gain is
    a number that determines how much effect one of the three parts of the controller
    has on the final result. The setpoint determines what the goal of the controller
    is; in other words, to where it''s trying to move the controlled variable. Looking
    at all this, we decide that the constructor should just store the gains and the
    setpoint along with initializing some internal state that we know we''ll need
    because we read about PID controllers. With this, we know enough to write some
    constructor tests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一组测试来描述构造函数。在查阅了PID控制器实际上是什么之后，我们了解到它们由三个增益和一个设定点定义。控制器有三个组成部分：比例、积分和微分（这就是PID名称的由来）。每个增益都是一个数字，它决定了控制器三个部分中的哪一个对最终结果的影响程度。设定点决定了控制器的目标；换句话说，它试图将控制变量移动到哪个位置。考虑到所有这些，我们决定构造函数应该只存储增益和设定点，以及初始化一些我们知道我们将来会需要的内部状态，因为我们阅读了关于PID控制器的资料。有了这个，我们就知道足够多的东西来编写一些构造函数测试：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also need tests that describe measurement processing. This means testing
    the actual use of the controller, taking a measured value as its input, and producing
    a control signal that should smoothly move the measured variable toward the setpoint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写描述测量处理的测试。这意味着测试控制器的实际使用，以测量值作为其输入，并产生一个控制信号，该信号应平滑地将测量变量移动到设定点。
- en: The behavior of a PID controller is based on time; we know that, so we're going
    to need to be able to feed the controller time values that we choose if we expect
    the tests to produce predictable results. We do this by replacing `time.time`
    with a different function of the same signature, which produces predictable results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器的行为基于时间；我们知道这一点，所以如果我们希望测试产生可预测的结果，我们需要能够向控制器提供我们选择的时间值。我们通过用具有相同签名的不同函数替换`time.time`来实现这一点，该函数产生可预测的结果。
- en: 'Once we have that taken care of, we plug our test input values into the math
    that defines a PID controller along with the gains to figure out what the correct
    outputs will be, and use these numbers to write the tests:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完这个问题，我们就将我们的测试输入值插入到定义PID控制器的数学公式中，包括增益，以确定正确的输出值，并使用这些数字来编写测试：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to write tests that describe setpoint handling. Our client asked for
    a "memory" for setpoints, which we''ll interpret as a stack, so we write tests
    that ensure that the setpoint stack works. Writing code that uses this stack behavior
    brings to our attention the fact that a PID controller with no setpoint is not
    a meaningful entity, so we add a test that checks that the PID class rejects this
    situation by raising an exception:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写描述设定点处理的测试。我们的客户要求一个“记忆”设定点，我们将将其解释为栈，因此我们编写测试以确保设定点栈正常工作。编写使用此栈行为的代码使我们注意到，没有设定点的PID控制器不是一个有意义的实体，因此我们添加了一个测试来检查PID类通过引发异常来拒绝这种情况：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: PID controllers are well-defined elsewhere, so the sparse specification that
    our client gave us works pretty well over all. Still, we had to codify several
    assumptions when we wrote our acceptance tests; it would probably be wise to check
    with the client and make sure that we didn't go astray, which means that, before
    we even ran the tests, they already helped us by pointing out questions we needed
    to ask them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器在其他地方有明确的定义，所以我们的客户给出的稀疏规范在整个过程中工作得相当好。尽管如此，当我们编写验收测试时，我们不得不明确几个假设；在测试运行之前，与客户核对并确保我们没有走偏可能是个明智之举，这意味着，在我们甚至运行测试之前，它们已经通过指出我们需要向他们提出的问题来帮助我们。
- en: We took extra steps in the tests to help isolate them from each other, by forcing
    the `pid` module to reimport before each group of test statements. This has the
    effect of resetting anything that might have changed in the module, and causes
    it to reimport any modules that it depends on. This is particularly important,
    since we replaced `time.time` with a dummy function. We want to be sure that the
    `pid` module uses the dummy time function, so we reload the `pid` module. If the
    real-time function is used instead of the dummy, the test won't be useful because
    it will succeed only once. Tests need to be repeatable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们采取了额外措施来帮助它们彼此隔离，通过在每组测试语句之前强制`pid`模块重新导入。这会重置模块中可能发生变化的任何内容，并使其重新导入它所依赖的任何模块。这尤其重要，因为我们用模拟函数替换了`time.time`。我们想确保`pid`模块使用模拟时间函数，所以我们重新加载了`pid`模块。如果使用真实时间函数而不是模拟函数，测试将不会有用，因为它只会成功一次。测试需要可重复。
- en: The stand-in time function was created by making an iterator that counts through
    the integers from 1 to 999 (as floating point values), and binding `time.time`
    to that iterator's `__next__` method. Once we were done with the time-dependent
    tests, we replaced the original `time.time`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个从1到999（作为浮点值）的整数计数迭代器，并将`time.time`绑定到该迭代器的`__next__`方法来创建替代时间函数。一旦我们完成了时间相关的测试，我们就替换了原始的`time.time`。
- en: We did get a little bit lazy, though, because we didn't bother to isolate the
    assorted tests from the PID constructor. If there's a bug in the constructor,
    it might cause a false error report in any of the tests that are dependent on
    it. We could have been more rigorous by using a mock object instead of an actual
    PID object, and thus even skipped invoking the constructor during the tests of
    other units but, as we aren't talking about mock objects until the next chapter,
    we'll allow ourselves a bit of laziness here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们确实有点偷懒，因为我们没有费心将各种测试与PID构造函数隔离开来。如果构造函数中有一个错误，它可能会在任何依赖于它的测试中引起错误的报告。我们本可以使用模拟对象而不是实际的PID对象来更加严谨，甚至可以在测试其他单元时跳过调用构造函数，但因为我们直到下一章才讨论模拟对象，所以我们在这里允许自己有点偷懒。
- en: Right now, we have tests for a module that doesn't exist. That's good! Writing
    the tests was easier than writing the module, and this gives us a stepping stone
    towards getting the module right, quickly and easily. As a general rule, you always
    want to have tests ready before the code that the test is written for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个不存在模块的测试。这很好！编写测试比编写模块要容易，这为我们快速、轻松地构建模块提供了一个基石。一般来说，你总是希望在编写测试的代码之前就准备好测试。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that I said "you want to have tests ready," not "you want to have all of
    the tests ready." You don't want, or need, to have every test in place before
    you start writing code. What you want is to have the tests in place that define
    the things you already know at the start of the process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我说的是“你想要准备好测试”，而不是“你想要准备好所有的测试”。在你开始编写代码之前，你不需要或不需要所有测试都到位。你想要的是在过程开始时就确定好定义你已知的事情的测试。
- en: Development
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发
- en: Now that we have some tests, we can begin writing code to satisfy the tests,
    and thus also the specification.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些测试了，我们可以开始编写代码以满足测试，从而也满足规范。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What if the code is already written? We can still write tests for its units.
    This isn't as productive as writing the tests in parallel with the code, but this
    at least gives us a way to check our assumptions and make sure that we don't introduce
    regressions. A test suite written late is better than no test suite at all.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码已经编写好了呢？我们仍然可以为它的单元编写测试。这并不像与代码并行编写测试那样高效，但至少这给了我们一种检查假设并确保我们没有引入回归的方法。比没有测试套件要好。
- en: The first step is to run the tests because this is always the first thing you
    do when you need to decide what to do next. If all the tests pass, either you're
    done with the program or you need to write more tests. If one or more tests fail,
    you pick one and make it pass.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是运行测试，因为这是你需要决定下一步做什么时做的第一件事。如果所有测试都通过，要么你已经完成了程序，要么你需要编写更多的测试。如果一个或多个测试失败，你选择一个并让它通过。
- en: 'So, we run the tests as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们按照以下方式运行测试：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first time they tell us that we don''t have a `pid` module. Let''s create
    one and fill it with a first attempt at a `PID` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次他们告诉我们我们没有`pid`模块。让我们创建一个并填充一个`PID`类的第一次尝试：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we''ll run the tests again, and see how we did as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次运行测试，看看我们做得如何：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This immediately tells us that there''s a bug in the `calculate_response` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即告诉我们`calculate_response`方法中有一个错误：
- en: '![Development](img/3211OS_03_01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![开发](img/3211OS_03_01.jpg)'
- en: There are more error reports in the same vein. There should be five in total.
    It seems that the `calculate_response` method is working backwards, producing
    negatives when it should give us positives, and vice-versa.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多类似的错误报告。总共有五个。似乎`calculate_response`方法在反向工作，当它应该给出正值时产生了负值，反之亦然。
- en: 'We know that we need to look for a sign error in `calculate_response`, and
    we find it on the fourth line, where the input value should be subtracted from
    the setpoint and not the other way around. Things should work better if we change
    this line to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要在`calculate_response`中查找符号错误，我们发现在第四行，输入值应该从设定点减去，而不是相反。如果我们把这一行改为以下内容，事情应该会更好：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As expected, that change fixes things. The tests all pass, now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个更改修复了问题。现在所有的测试都通过了。
- en: We used our tests to tell us what was needed to be done, and to tell us when
    our code was complete. Our first run of the tests gave us a list of things that
    needed to be written; a to-do list of sorts. After we wrote some code, we ran
    the tests again to see if it was doing what we expected, which gave us a new to-do
    list. We kept on alternately running the tests and writing code to make one of
    the tests pass until they all did. When all the tests pass, either we're done,
    or we need to write more tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用测试来告诉我们需要做什么，以及告诉我们代码何时完成。我们第一次运行测试给我们一个需要编写的事项列表；类似于待办事项列表。在编写了一些代码之后，我们再次运行测试以查看它是否按预期工作，这给了我们一个新的待办事项列表。我们继续交替运行测试和编写代码，直到通过一个测试，然后继续直到所有测试都通过。当所有测试都通过时，要么我们已经完成了，要么我们需要编写更多的测试。
- en: Whenever we find a bug that isn't already caught by a test, the right thing
    to do is to add a test that catches it, and then we need to fix the bug. This
    gives a fixed bug, but also a test that covers some part of the program that wasn't
    tested before. Your new test might well catch more bugs that you weren't even
    aware of, and it will help you avoid recreating the fixed bug.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们发现一个测试尚未捕获的bug，正确的做法是添加一个测试来捕获它，然后我们需要修复这个bug。这会给我们一个固定的bug，但也会有一个覆盖之前未测试过的程序部分的测试。你的新测试可能会捕获你甚至没有意识到的更多bug，并且它将帮助你避免重新创建已修复的bug。
- en: This "test a little, code a little" style of programming is called **Test-driven
    Development**, and you'll find that it's very productive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“测试一点，编码一点”的编程风格被称为**测试驱动开发**，你会发现它非常高效。
- en: Notice that the pattern in the way the tests failed was immediately apparent.
    There's no guarantee that will be the case, of course, but it often is. Combined
    with the ability to narrow your attention to the specific units that are having
    problems, debugging is usually a snap.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试失败的模式立即显而易见。当然，没有保证这种情况会发生，但通常是这样的。结合能够将注意力缩小到有问题的特定单元，调试通常变得非常简单。
- en: Feedback
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈
- en: So, we have a PID controller, it passes our tests... are we done? Maybe. Let's
    ask the client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个PID控制器，它通过了我们的测试...我们完成了吗？也许吧。让我们去询问客户。
- en: The good news is that they mostly like it. They have a few things they'd like
    to be changed, though. They want us to be able to optionally specify the current
    time as a parameter to `calculate_response`, so that the specified time is used
    instead of the current system time. They also want us to change the signature
    of the constructor so that it accepts an initial measurement and optionally a
    measurement time as parameters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，他们大多数都喜欢。尽管如此，他们还有一些想要改变的地方。他们希望我们能够可选地指定当前时间作为`calculate_response`的参数，以便使用指定的时间而不是当前系统时间。他们还希望我们更改构造函数的签名，使其接受初始测量值和可选的测量时间作为参数。
- en: So, the program passes all of our tests, but the tests don't correctly describe
    the requirements anymore. What to do?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序通过了我们所有的测试，但测试不再正确描述需求了。怎么办？
- en: 'First, we''ll add the initial value parameter to the constructor tests, and
    update the expected results as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将初始值参数添加到构造函数测试中，并更新预期结果如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we''ll add another test of the constructor, a test that checks the correct
    behavior when the optional initial time parameter is provided:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为构造函数添加另一个测试，这是一个检查当提供可选的初始时间参数时的正确行为的测试：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we change the `calculate_response` tests to use the new signature for
    the constructor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`calculate_response`测试更改为使用构造函数的新签名：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to add a second `calculate_response` test that checks whether the function
    behaves properly when the optional time parameter is passed to it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加第二个`calculate_response`测试，以检查当将可选的时间参数传递给它时，函数是否表现正常：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, we adjust the constructor call in the setpoint method tests. This change
    looks the same as the constructor call changes in the other tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在设定点方法测试中调整构造函数调用。这个更改看起来与其他测试中的构造函数调用更改相同。
- en: When we're adjusting the tests, we discover that the behavior of the `calculate_response`
    method has changed due to the addition of the initial value and initial time parameters
    to the constructor. The tests will report this as an error but it's not clear
    that if it really is wrong, so we check this with the client. After talking it
    over, the client decides that this is actually correct behavior, so we change
    our tests to reflect that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调整测试时，我们发现由于将初始值和初始时间参数添加到构造函数中，`calculate_response`方法的行为发生了变化。测试将报告这是一个错误，但并不清楚这实际上是否错误，所以我们与客户进行了确认。经过讨论，客户决定这实际上是正确的行为，因此我们更改了我们的测试以反映这一点。
- en: 'Our complete specification and test document now looks like this (new or changed
    lines are highlighted):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完整的规范和测试文档现在看起来是这样的（新或更改的行已突出显示）：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our tests didn't match the requirements and so we needed to change them. That's
    fine, but we don't want to change them too much because the tests we have already
    help us to avoid some problems that we've previously spotted or had to fix. The
    last thing we want for the computer is to stop checking for known problems. Because
    of this, we very much prefer adding new tests, instead of changing old ones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试没有符合要求，因此我们需要更改它们。这很好，但我们不想更改太多，因为我们已有的测试帮助我们避免了我们之前发现或必须解决的问题。我们最不想看到的是计算机停止检查已知问题。因此，我们非常倾向于添加新的测试，而不是更改旧的测试。
- en: This is one reason why we added new tests to check the behavior when the optional
    time parameters were supplied. The other reason is that, if we added these parameters
    to the existing tests, we wouldn't have any tests of what happens when you don't
    use these parameters. We always want to check every code path through each unit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们添加新测试以检查在提供可选时间参数时的行为的一个原因。另一个原因是，如果我们将这些参数添加到现有的测试中，我们就不会有测试来检查当你不使用这些参数时会发生什么。我们总是想检查每个单元中的每个代码路径。
- en: 'The addition of the initial parameter to the constructor is a big deal. It
    not only changes the way the constructor should behave, it also changes the way
    the `calculate_response` method should behave in a rather dramatic way. Since
    there is a change in the correct behavior (a fact that we didn''t realize until
    the tests pointed it out to us, which in turn allowed us to get a confirmation
    of what the correct behavior should be from our clients before we started writing
    the code), we have no choice but to go through and change the tests, recalculating
    the expected outputs and all. Doing all that work has a benefit, though, over
    and above the future ability to check whether the function is working correctly:
    this makes it much easier to comprehend how the function should work when we actually
    write it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将初始参数添加到构造函数中是一件大事。这不仅改变了构造函数应该如何表现，还以相当戏剧性的方式改变了`calculate_response`方法应该如何表现。由于正确行为发生了变化（这是我们直到测试指出这一点之前都没有意识到的事实，这也反过来允许我们在开始编写代码之前从客户那里获得对正确行为的确认），我们别无选择，只能遍历并更改测试，重新计算预期的输出等。尽管如此，所有这些工作都有好处，除了未来能够检查函数是否正确工作之外：这使得我们在实际编写函数时更容易理解函数应该如何工作。
- en: When we change a test to reflect new correct behavior, we still try to change
    it as little as possible. After all, we don't want the test to stop checking for
    old behavior that's still correct, and we don't want to introduce a bug in the
    test itself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改测试以反映新的正确行为时，我们仍然尽量少做更改。毕竟，我们不想让测试停止检查仍然正确的旧行为，我们也不想在自己的测试中引入错误。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To a certain extent, the code being tested acts as a test of the test, so even
    bugs in your tests don't survive very long when you use good testing discipline.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，正在测试的代码充当了测试的测试，因此即使你的测试中存在错误，当使用良好的测试纪律时，这些错误也不会持续很长时间。
- en: Development, again
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次进行开发
- en: Time to do some more coding. In real life, we might cycle between development
    and feedback any number of times, depending on how well we're able to communicate
    with our clients. In fact, it might be a good thing to increase the number of
    times we go back and forth, even if this means that each cycle is short. Keeping
    the clients in the loop and up-to-date is a good thing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行更多编码了。在现实生活中，我们可能会根据我们与客户沟通的好坏在开发和反馈之间循环多次。事实上，增加我们来回次数的数量可能是一件好事，即使这意味着每个周期都很短。让客户保持同步并了解最新情况是件好事。
- en: 'The first step, as always, is to run the tests and get an updated list of the
    things that need to be done:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，一如既往，是运行测试并获取需要完成的更新列表：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Development, again](img/3211OS_03_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![再次开发](img/3211OS_03_02.jpg)'
- en: There are actually a lot more errors that are reported, but the very first one
    gives us a good hint about what we need to fix right off. The constructor needs
    to change to match the tests' expectations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上报告的错误还有很多，但第一个错误就给我们提供了很好的提示，关于我们需要立即修复的问题。构造函数需要改变以匹配测试的期望。
- en: Using the `doctest` error report to guide us, and rerunning the tests frequently,
    we can quickly get our PID class into shape. In practice, this works best using
    short development cycles where you make only a few changes to the code, and then
    run the tests again. Fix one thing, and then test again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`doctest`错误报告来引导我们，并频繁地重新运行测试，我们可以快速将我们的PID类调整到合适的状态。在实践中，这在使用短的开发周期时效果最好，你只对代码进行少量更改，然后再次运行测试。修复一个问题，然后再次测试。
- en: 'Once we''ve gone back and forth between coding and testing enough times, we''ll
    end up with something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在编码和测试之间来回多次，我们最终会得到类似这样的结果：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once again, all of the tests pass including all of the revised tests from the
    client, and it's remarkable how rewarding that lack of an error report can be.
    We're ready to see whether the client is willing to accept delivery of the code
    yet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有测试都通过了，包括来自客户的修订测试，而且没有错误报告是多么令人欣慰。我们准备看看客户是否愿意接受代码的交付。
- en: Later stages of the process
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程的后期阶段
- en: There are later phases of development when it's your job to maintain the code,
    or to integrate it into another product. Functionally, they work in the same way
    as the development phase. If you're handling pre-existing code and are asked to
    maintain or integrate it, you'll be much happier if it comes to you with a test
    suite already written because, until you've mastered the intricacies of the code,
    the test suite is the only way in which you'll be able to modify the code with
    confidence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的后期阶段，你的任务是维护代码，或者将其集成到另一个产品中。功能上，它们与开发阶段相同。如果你正在处理现有的代码并被要求维护或集成它，如果它已经附带了一个测试套件，你会感到更加高兴，因为，直到你掌握了代码的复杂性，测试套件是你唯一能够有信心修改代码的方式。
- en: If you're unfortunate enough to be handed a pile of code with no tests, writing
    tests is a good first step. Each test you write is one more unit of the code that
    you can honestly say you understand, and know what to expect from. And, of course,
    each test you write is one more unit that you can count on to tell you if you
    introduce a bug.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不幸得到了一堆没有测试的代码，编写测试是一个好的第一步。你写的每个测试都是代码的一个单元，你可以诚实地说你理解它，并知道可以期待什么。当然，你写的每个测试都是另一个单元，你可以依赖它告诉你是否引入了错误。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've walked through the process of developing a project using unit testing
    and test-driven development, paying attention to the ways that we can identify
    units, and covering some of the ways in which we can isolate `doctest` tests for
    individual units.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用单元测试和测试驱动开发来开发项目的过程，注意我们如何识别单元，并介绍了一些我们可以隔离`doctest`测试以针对单个单元的方法。
- en: We've also talked about the philosophy and discipline of unit testing, what
    it is in detail, and why it is valuable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了单元测试的哲学和纪律，详细说明了它是什么，以及为什么它有价值。
- en: In the next chapter, we'll discuss mock objects, a powerful tool for isolating
    units.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论模拟对象，这是隔离单元的强大工具。
