- en: Chapter 7. Testing, Profiling, and Dealing with Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 测试、性能分析和处理异常
- en: '|   | *"Code without tests is broken by design."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"没有测试的代码是有意设计成有缺陷的。" |   |'
- en: '|   | --*Jacob Kaplan-Moss* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*雅各布·卡普兰-莫斯* |'
- en: Jacob Kaplan-Moss is one of the core developers of the Django web framework.
    We're going to explore it in the next chapters. I strongly agree with this quote
    of his. I believe code without tests shouldn't be deployed to production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 雅各布·卡普兰-莫斯是Django Web框架的核心开发者之一。我们将在下一章中探讨它。我非常同意他的这句话。我相信没有测试的代码不应该部署到生产环境中。
- en: Why are tests so important? Well, for one, they give you predictability. Or,
    at least, they help you achieve high predictability. Unfortunately, there is always
    some bug that sneaks into our code. But we definitely want our code to be as predictable
    as possible. What we don't want is to have a surprise, our code behaving in an
    unpredictable way. Would you be happy to know that the software that checks on
    the sensors of the plane that is taking you on holidays sometimes goes crazy?
    No, probably not.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么测试如此重要？好吧，首先，它们为你提供了可预测性。或者至少，它们帮助你实现高可预测性。不幸的是，总有一些漏洞会悄悄地进入我们的代码。但我们肯定希望我们的代码尽可能可预测。我们不希望的是惊喜，我们的代码以一种不可预测的方式运行。你会高兴地知道，检查你度假时乘坐的飞机传感器的软件有时会发疯吗？不，可能不会。
- en: Therefore we need to test our code, we need to check that its behavior is correct,
    that it works as expected when it deals with edge cases, that it doesn't hang
    when the components it's talking to are down, that the performances are well within
    the acceptable range, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们需要测试我们的代码，我们需要检查其行为是否正确，当它处理边缘情况时是否按预期工作，当与之通信的组件出现问题时它不会挂起，性能是否在可接受的范围内，等等。
- en: This chapter is all about this topic, making sure that your code is prepared
    to face the scary outside world, that is fast enough and that it can deal with
    unexpected or exceptional conditions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于这个主题，确保你的代码准备好面对可怕的外部世界，即足够快，并且能够处理意外或异常情况。
- en: We're going to explore testing, including a brief introduction to **test-driven
    development** (**TDD**), which is one of my favorite working methodologies. Then,
    we're going to explore the world of exceptions, and finally we're going to talk
    a little bit about performances and profiling. Deep breath, and here we go...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨测试，包括对**测试驱动开发**（**TDD**）的简要介绍，这是我最喜欢的作业方法之一。然后，我们将探索异常的世界，最后我们将简要谈谈性能和性能分析。深呼吸，我们开始吧...
- en: Testing your application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的应用程序
- en: There are many different kinds of tests, so many in fact that companies often
    have a dedicated department, called **quality assurance** (**QA**), made up of
    individuals that spend their day testing the software the company developers produce.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同种类的测试，实际上如此之多，以至于公司通常有一个专门的部门，称为**质量保证**（**QA**），由那些整天测试公司开发人员生产的软件的个人组成。
- en: 'To start making an initial classification, we can divide tests into two broad
    categories: white-box and black-box tests.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始进行初步分类，我们可以将测试分为两大类：白盒测试和黑盒测试。
- en: '**White-box tests** are those which exercise the internals of the code, they
    inspect it down to a very fine level of granularity. On the other hand, **black-box
    tests** are those which consider the software under testing as if being within
    a box, the internals of which are ignored. Even the technology, or the language
    used inside the box is not important for black-box tests. What they do is to plug
    input to one end of the box and verify the output at the other end, and that''s
    it.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**白盒测试**是那些锻炼代码内部结构的测试，它们检查到非常细粒度的程度。另一方面，**黑盒测试**是那些将正在测试的软件视为一个盒子内的，忽略其内部结构的测试。甚至盒子内使用的科技或语言对黑盒测试来说也不重要。它们所做的是将输入连接到盒子的一端，并验证另一端的输出，这就是全部。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is also an in-between category, called **gray-box** testing, that involves
    testing a system in the same way we do with the black-box approach, but having
    some knowledge about the algorithms and data structures used to write the software
    and only partial access to its source code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个介于两者之间的类别，称为**灰盒测试**，它以与黑盒方法相同的方式测试系统，但对我们使用的算法和数据结构有一些了解，并且只有部分访问源代码的权限。
- en: 'There are many different kinds of tests in these categories, each of which
    serves a different purpose. Just to give you an idea, here''s a few:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类别中有很多不同种类的测试，每种测试都服务于不同的目的。仅为了给你一个概念，这里有一些例子：
- en: '**Front-end tests** make sure that the client side of your application is exposing
    the information that it should, all the links, the buttons, the advertising, everything
    that needs to be shown to the client. It may also verify that it is possible to
    walk a certain path through the user interface.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端测试**确保应用程序的客户端暴露了应该暴露的信息，所有链接、按钮、广告等需要展示给客户的内容。它还可能验证是否可以通过用户界面走一条特定的路径。'
- en: '**Scenario tests** make use of stories (or scenarios) that help the tester
    work through a complex problem or test a part of the system.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景测试**利用故事（或场景）帮助测试人员解决复杂问题或测试系统的一部分。'
- en: '**Integration tests** verify the behavior of the various components of your
    application when they are working together sending messages through interfaces.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**验证应用程序的各个组件在通过接口发送消息时一起工作的行为。'
- en: '**Smoke tests** are particularly useful when you deploy a new update on your
    application. They check whether the most essential, vital parts of your application
    are still working as they should and that they are not *on fire*. This term comes
    from when engineers tested circuits by making sure nothing was smoking.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**在您部署应用程序的新更新时特别有用。它们检查应用程序最基本、最重要的部分是否仍然按预期工作，并且它们没有**着火**。这个术语来自工程师通过确保没有冒烟来测试电路的时候。'
- en: '**Acceptance tests**, or **user acceptance testing** (**UAT**) is what a developer
    does with a product owner (for example, in a SCRUM environment) to determine if
    the work that was commissioned was carried out correctly.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**，或**用户验收测试**（**UAT**），是开发者与产品负责人（例如，在敏捷开发环境中）一起进行的工作，以确定委托的工作是否正确完成。'
- en: '**Functional tests** verify the features or functionalities of your software.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**验证软件的功能或功能。'
- en: '**Destructive tests** take down parts of your system, simulating a failure,
    in order to establish how well the remaining parts of the system perform. These
    kinds of tests are performed extensively by companies that need to provide an
    extremely reliable service, such as Amazon, for example.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性测试**通过模拟系统故障来摧毁系统的一部分，以确定系统剩余部分的表现如何。这类测试通常由需要提供极其可靠服务的公司广泛进行，例如亚马逊等。'
- en: '**Performance tests** aim to verify how well the system performs under a specific
    load of data or traffic so that, for example, engineers can get a better understanding
    of which are the bottlenecks in the system that could bring it down to its knees
    in a heavy load situation, or those which prevent scalability.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**旨在验证系统在特定数据负载或流量下的表现如何，以便工程师可以更好地了解系统中的瓶颈，这些瓶颈可能在重负载情况下使系统崩溃，或者那些阻止可扩展性的瓶颈。'
- en: '**Usability tests**, and the closely related **user experience** (**UX**) tests,
    aim to check if the user interface is simple and easy to understand and use. They
    aim to provide input to the designers so that the user experience is improved.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**和与之密切相关的**用户体验**（**UX**）测试旨在检查用户界面是否简单、易于理解和使用。它们旨在为设计师提供反馈，以改善用户体验。'
- en: '**Security and penetration tests** aim to verify how well the system is protected
    against attacks and intrusions.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性和渗透测试**旨在验证系统抵御攻击和入侵的能力。'
- en: '**Unit tests** help the developer to write the code in a robust and consistent
    way, providing the first line of feedback and defense against coding mistakes,
    refactoring mistakes, and so on.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**帮助开发者以稳健和一致的方式编写代码，提供对编码错误、重构错误等的初步反馈和防御。'
- en: '**Regression tests** provide the developer with useful information about a
    feature being compromised in the system after an update. Some of the causes for
    a system being said to have a regression are an old bug coming back to life, an
    existing feature being compromised, or a new issue being introduced.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**在更新后向开发者提供有关系统中被损害的功能的有用信息。系统被认为有回归的原因包括旧错误重新出现、现有功能受损或引入了新问题。'
- en: Many books and articles have been written about testing, and I have to point
    you to those resources if you're interested in finding out more about all the
    different kinds of tests. In this chapter, we will concentrate on unit tests,
    since they are the backbone of software crafting and form the vast majority of
    tests that are written by a developer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试已经写了许多书籍和文章，如果你对了解所有不同类型的测试感兴趣，我必须向你指出这些资源。在本章中，我们将专注于单元测试，因为它们是软件构建的基石，构成了开发者编写的绝大多数测试。
- en: Testing is an *art*, an art that you don't learn from books, I'm afraid. You
    can learn all the definitions (and you should), and try and collect as much knowledge
    about testing as you can but I promise you, you will be able to test your software
    properly only when you have done it for long enough in the field.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一种*艺术*，恐怕你无法从书中学习到这种艺术。你可以学习所有的定义（你应该这样做），并尽可能多地收集有关测试的知识，但我向你保证，只有在你在这个领域工作足够长的时间后，你才能正确地测试你的软件。
- en: When you are having trouble refactoring a bit of code, because every little
    thing you touch makes a test blow up, you learn how to write less rigid and limiting
    tests, which still verify the correctness of your code but, at the same time,
    allow you the freedom and joy to play with it, to shape it as you want.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在重构一小段代码时遇到困难，因为每次你触摸到的东西都会使测试失败，你会学会编写不那么僵化和限制性的测试，这些测试仍然可以验证你的代码的正确性，同时，也让你有自由和乐趣去玩弄它，按照你的意愿塑造它。
- en: When you are being called too often to fix unexpected bugs in your code, you
    learn how to write tests more thoroughly, how to come up with a more comprehensive
    list of edge cases, and strategies to cope with them before they turn into bugs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你频繁被要求修复代码中的意外错误时，你会学会如何更彻底地编写测试，如何提出一个更全面的边缘情况列表，以及应对这些情况的策略，以防它们变成错误。
- en: When you are spending too much time reading tests and trying to refactor them
    in order to change a small feature in the code, you learn to write simpler, shorter,
    and better focused tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花费太多时间阅读测试并尝试重构它们以更改代码中的一个小功能时，你会学会编写更简单、更短、更专注的测试。
- en: I could go on with this *when you... you learn...*, but I guess you get the
    picture. You need to get your hands dirty and build experience. My suggestion?
    Study the theory as much as you can, and then experiment using different approaches.
    Also, try to learn from experienced coders; it's very effective.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续说“当你……你学习……”，但我想你明白我的意思。你需要亲自动手，积累经验。我的建议？尽可能多地学习理论，然后尝试使用不同的方法进行实验。此外，尝试向经验丰富的程序员学习；这非常有效。
- en: The anatomy of a test
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的结构
- en: Before we concentrate on unit tests, let's see what a test is, and what its
    purpose is.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们专注于单元测试之前，让我们看看什么是测试，以及它的目的是什么。
- en: A **test** is a piece of code whose purpose is to verify something in our system.
    It may be that we're calling a function passing two integers, that an object has
    a property called `donald_duck`, or that when you place an order on some API,
    after a minute you can see it dissected into its basic elements, in the database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**是一段代码，其目的是验证我们系统中的某个东西。这可能意味着我们正在调用一个函数，传递两个整数，或者一个对象有一个名为`donald_duck`的属性，或者当你在一个API上下单后，一分钟内你可以在数据库中看到它被分解成基本元素。'
- en: 'A test is typically comprised of three sections:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试通常由三个部分组成：
- en: '**Preparation**: This is where you set up the scene. You prepare all the data,
    the objects, the services you need in the places you need them so that they are
    ready to be used.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：这是你设置场景的地方。你准备所有需要的数据、对象、服务，确保它们在需要的地方准备好使用。'
- en: '**Execution**: This is where you execute the bit of logic that you''re checking
    against. You perform an action using the data and the interfaces you have set
    up in the preparation phase.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：这是你执行检查逻辑的地方。你使用在准备阶段设置的数据和接口执行操作。'
- en: '**Verification**: This is where you verify the results and make sure they are
    according to your expectations. You check the returned value of a function, or
    that some data is in the database, some is not, some has changed, a request has
    been made, something has happened, a method has been called, and so on.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：这是你验证结果并确保它们符合你的预期的地方。你检查函数的返回值，或者某些数据是否在数据库中，某些数据不在，某些数据已更改，已发起请求，发生了某些事情，调用了某个方法，等等。'
- en: Testing guidelines
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试指南
- en: 'Like software, tests can be good or bad, with the whole range of shades in
    the middle. In order to write good tests, here are some guidelines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件一样，测试可以是好的或坏的，中间有各种不同的程度。为了编写好的测试，以下是一些指导原则：
- en: '**Keep them as simple as possible**: It''s okay to violate some good coding
    rules, such as hardcoding values or duplicating code. Tests need first and foremost
    to be as readable as possible and easy to understand. When tests are hard to read
    or understand, you can never be sure if they are actually making sure your code
    is performing correctly.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能保持简单**：违反一些良好的编码规则，如硬编码值或重复代码，是可以接受的。测试首先需要尽可能的可读和易于理解。当测试难以阅读或理解时，你永远无法确定它们是否确实确保了你的代码正在正确执行。'
- en: '**Tests should verify one thing and one thing only**: It''s very important
    that you keep them short and contained. It''s perfectly fine to write multiple
    tests to exercise a single object or function. Just make sure that each test has
    one and only one purpose.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应验证一件事，且仅一件事**：保持测试简短并集中非常重要。编写多个测试来测试单个对象或函数是完全可行的。只需确保每个测试只有一个且仅有一个目的。'
- en: '**Tests should not make any unnecessary assumption when verifying data**: This
    is tricky to understand at first, but say you are testing the return value of
    a function and it is an unordered list of numbers (like `[2, 3, 1]`). If the order
    in that list is random, in the test you may be tempted to sort it and compare
    it with `[1, 2, 3]`. If you do, you will introduce an extra assumption on the
    ordering of the result of your function call, and *this is bad practice*. You
    should always find a way to verify things without introducing any assumptions
    or any feature that doesn''t belong in the use case you''re describing with your
    test.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试在验证数据时不应做任何不必要的假设**：一开始这可能难以理解，但假设你在测试一个函数的返回值，它是一个无序的数字列表（如 `[2, 3, 1]`）。如果列表中的顺序是随机的，在测试中你可能想对其进行排序并与
    `[1, 2, 3]` 进行比较。如果你这样做，你将在函数调用结果的顺序上引入额外的假设，这是不好的做法。你应该总是找到一种方法来验证事物，而不会引入任何假设或任何不属于你用测试描述的使用案例中的特性。'
- en: '**Tests should exercise the what, rather than the how**: Tests should focus
    on checking *what* a function is supposed to do, rather than *how* it is doing
    it. For example, focus on the fact that it''s calculating the square root of a
    number (the *what*), instead of on the fact that it is calling `math.sqrt` to
    do it (the *how*). Unless you''re writing performance tests or you have a particular
    need to verify how a certain action is performed, try to avoid this type of testing
    and focus on the *what*. Testing the *how* leads to restrictive tests and makes
    refactoring hard. Moreover, the type of test you have to write when you concentrate
    on the *how* is more likely to degrade the quality of your testing code base when
    you amend your software frequently (more on this later).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应测试“是什么”，而不是“如何”**：测试应专注于检查函数应该做什么，而不是它是如何做的。例如，关注它正在计算一个数字的平方根（“是什么”），而不是关注它是如何调用
    `math.sqrt` 来实现的（“如何”）。除非你正在编写性能测试或你有特定的需求来验证某些动作是如何执行的，否则尽量避免这种类型的测试，专注于“是什么”。测试“如何”会导致测试过于严格，并使得重构变得困难。此外，当你专注于“如何”时，你必须编写的测试类型更有可能在频繁修改软件时降低你的测试代码库的质量（关于这一点稍后还会讨论）。'
- en: '**Tests should assume the least possible in the preparation phase**: Say you
    have 10 tests that are checking how a data structure is manipulated by a function.
    And let''s say this data structure is a dict with five key/value pairs. If you
    put the complete dict in each test, the moment you have to change something in
    that dict, you also have to amend all ten tests. On the other hand, if you strip
    down the test data as much as you can, you will find that, most of the time, it''s
    possible to have the majority of tests checking only a partial version of the
    data, and only a few running with a full version of it. This means that when you
    need to change your data, you will have to amend only those tests that are actually
    exercising it.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试在准备阶段应假设尽可能少的内容**：假设你有10个测试，它们正在检查一个函数如何操作数据结构。假设这个数据结构是一个包含五个键/值对的字典。如果你在每个测试中都放入完整的字典，那么当你需要更改该字典中的任何内容时，你也必须修改所有十个测试。另一方面，如果你尽可能减少测试数据，你会发现，大多数情况下，大多数测试只检查数据的部分版本，而只有少数测试使用完整的版本。这意味着当你需要更改数据时，你只需要修改那些实际在测试它的测试。'
- en: '**Test should run as fast as possible**: A good test codebase could end up
    being much longer than the code being tested itself. It varies according to the
    situation and the developer but whatever the length, you''ll end up having hundreds,
    if not thousands, of tests to run, which means the faster they run, the faster
    you can get back to writing code. When using TDD, for example, you run tests very
    often, so speed is essential.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应该尽可能快地运行**：一个良好的测试代码库可能会比被测试的代码本身更长。这取决于具体情况和开发者，但无论长度如何，你最终会有数百甚至数千个测试要运行，这意味着它们运行得越快，你就能越快回到编写代码。例如，在使用
    TDD 时，你会非常频繁地运行测试，所以速度是至关重要的。'
- en: '**Tests should use up the least possible amount of resources**: The reason
    for this is that every developer who checks out your code should be able to run
    your tests, no matter how powerful their box is. It could be a skinny virtual
    machine or a neglected Jenkins box, your tests should run without chewing up too
    many resources.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应该使用尽可能少的资源**：这样做的原因是，任何检查你代码的开发者都应该能够运行你的测试，无论他们的机器有多强大。这可能是一个瘦虚拟机，或者是一个被忽视的
    Jenkins 服务器，但你的测试应该在不消耗太多资源的情况下运行。'
- en: Note
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **Jenkins** box is a machine that runs Jenkins, software that is capable of,
    amongst many other things, running your tests automatically. Jenkins is frequently
    used in companies where developers use practices like continuous integration,
    extreme programming, and so on.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Jenkins** 服务器是一个运行 Jenkins 的机器，Jenkins 是一种能够执行各种任务（包括自动运行测试）的软件。Jenkins 在那些采用持续集成、极限编程等实践的公司中经常被使用。'
- en: Unit testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that you have an idea about what testing is and why we need it, let''s
    finally introduce the developer''s best friend: the **unit test**.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了测试是什么以及为什么我们需要它，让我们最终介绍开发者的最佳拍档：**单元测试**。
- en: 'Before we proceed with the examples, allow me to spend some words of caution:
    I''ll try to give you the fundamentals about unit testing, but I don''t follow
    any particular school of thought or methodology to the letter. Over the years,
    I have tried many different testing approaches, eventually coming up with my own
    way of doing things, which is constantly evolving. To put it as Bruce Lee would
    have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续举例之前，让我提醒你一些注意事项：我会尽量给你讲解单元测试的基础知识，但我不会严格遵循任何特定的思想或方法论。多年来，我尝试了许多不同的测试方法，最终形成了自己的做事方式，这种方式一直在不断进化。用布鲁斯·李的话来说：
- en: '*"Absorb what is useful, discard what is useless and add what is specifically
    your own".*'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"吸收有用的，摒弃无用的，添加你自己的特色"。*'
- en: Writing a unit test
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'In order to explain how to write a unit test, let''s help ourselves with a
    simple snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何编写单元测试，让我们用一个简单的代码片段来帮助自己：
- en: '`data.py`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.py`'
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function `get_clean_data` is responsible for getting data from `source`,
    cleaning it, and returning it to the caller. How do we test this function?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `get_clean_data` 负责从 `source` 获取数据，对其进行清理，并将其返回给调用者。我们如何测试这个函数？
- en: One way of doing this is to call it and then make sure that `load_data` was
    called once with `source` as its only argument. Then we have to verify that `clean_data`
    was called once, with the return value of `load_data`. And, finally, we would
    need to make sure that the return value of `clean_data` is what is returned by
    the `get_clean_data` function as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是在调用它之后，确保 `load_data` 只被调用了一次，并且它的唯一参数是 `source`。然后我们必须验证 `clean_data`
    也只被调用了一次，并且它的参数是 `load_data` 的返回值。最后，我们还需要确保 `clean_data` 的返回值与 `get_clean_data`
    函数返回的值相同。
- en: In order to do this, we need to set up the source and run this code, and this
    may be a problem. One of the golden rules of unit testing is that *anything that
    crosses the boundaries of your application needs to be simulated*. We don't want
    to talk to a real data source, and we don't want to actually run real functions
    if they are communicating with anything that is not contained in our application.
    A few examples would be a database, a search service, an external API, a file
    in the filesystem, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要设置源代码并运行这段代码，这可能会成为一个问题。单元测试的黄金法则之一是*任何跨越你应用程序边界的元素都需要被模拟*。我们不希望与真实的数据源进行交互，也不希望实际运行与不在我们应用程序中包含的任何东西通信的真实函数。一些例子包括数据库、搜索服务、外部
    API、文件系统中的文件等等。
- en: We need these restrictions to act as a shield, so that we can always run our
    tests safely without the fear of destroying something in a real data source.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些限制来作为盾牌，这样我们就可以始终安全地运行测试，而不必担心在真实数据源中破坏某些东西。
- en: Another reason is that it may be quite difficult for a single developer to reproduce
    the whole architecture on their box. It may require the setting up of databases,
    APIs, services, files and folders, and so on and so forth, and this can be difficult,
    time consuming, or sometimes not even possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，单个开发者可能很难在自己的机器上重现整个架构。这可能需要设置数据库、API、服务、文件和文件夹等，这可能很困难，耗时，有时甚至不可能。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Very simply put, an **application programming interface** (**API**) is a set
    of tools for building software applications. An API expresses a software component
    in terms of its operations, inputs and outputs, and underlying types. For example,
    if you create a software that needs to interface with a data provider service,
    it's very likely that you will have to go through their API in order to gain access
    to the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，**应用程序编程接口**（**API**）是一套用于构建软件应用的工具。API通过其操作、输入和输出以及底层类型来表示软件组件。例如，如果你创建的软件需要与数据提供者服务进行接口，那么你很可能需要通过他们的API来获取数据。
- en: Therefore, in our unit tests, we need to simulate all those things in some way.
    Unit tests need to be run by any developer without the need for the whole system
    to be set up on their box.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事物。单元测试需要由任何开发者运行，而无需在他们的机器上设置整个系统。
- en: A different approach, which I always favor when it's possible to do so, is to
    simulate entities without using fake objects, but using special purpose test objects
    instead. For example, if your code talks to a database, instead of faking all
    the functions and methods that talk to the database and programming the fake objects
    so that they return what the real ones would, I'd much rather prefer to spawn
    a test database, set up the tables and data I need, and then patch the connection
    settings so that my tests are running real code, against the test database, thereby
    doing no harm at all. In-memory databases are excellent options for these cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不同的方法，当可能这样做时，我总是更喜欢使用，那就是在不使用假对象的情况下模拟实体，而是使用专门的测试对象。例如，如果你的代码与数据库进行交互，而不是伪造所有与数据库交互的函数和方法，并编程假对象使其返回真实对象的结果，我更愿意创建一个测试数据库，设置我需要的表和数据，然后修补连接设置，以便我的测试运行的是真实代码，针对测试数据库，从而不会造成任何损害。内存数据库是这些情况下的绝佳选择。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of the applications that allow you to spawn a database for testing, is Django.
    Within the `django.test` package you can find several tools that help you write
    your tests so that you won't have to simulate the dialog with a database. By writing
    tests this way, you will also be able to check on transactions, encodings, and
    all other database related aspects of programming. Another advantage of this approach
    consists in the ability of checking against things that can change from one database
    to another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你为测试创建数据库的应用之一是Django。在`django.test`包中，你可以找到一些工具，这些工具可以帮助你编写测试，这样你就不必模拟与数据库的对话。通过这种方式编写测试，你还可以检查事务、编码以及所有其他与数据库相关的编程方面。这种方法的另一个优点在于，你可以检查那些可能从一个数据库到另一个数据库发生变化的事物。
- en: Sometimes, though, it's still not possible, and we need to use fakes, therefore
    let's talk about them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时仍然不可能，我们需要使用假对象，因此让我们来谈谈它们。
- en: Mock objects and patching
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟对象和修补
- en: First of all, in Python, these fake objects are called **mocks**. Up to version
    3.3, the `mock` library was a third-party library that basically every project
    would install via `pip` but, from version 3.3, it has been included in the standard
    library under the `unittest` module, and rightfully so, given its importance and
    how widespread it is.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Python中，这些假对象被称为**mocks**。在版本3.3之前，`mock`库是一个第三方库，基本上每个项目都会通过`pip`安装，但从版本3.3开始，它已经被包含在标准库的`unittest`模块中，这是理所当然的，鉴于其重要性和普及程度。
- en: The act of replacing a real object or function (or in general, any piece of
    data structure) with a mock, is called **patching**. The `mock` library provides
    the `patch` tool, which can act as a function or class decorator, and even as
    a context manager (more on this in [Chapter 8](ch08.html "Chapter 8. The Edges
    – GUIs and Scripts"), *The Edges – GUIs and Scripts*), that you can use to mock
    things out. Once you have replaced everything you need not to run, with suitable
    mocks, you can pass to the second phase of the test and run the code you are exercising.
    After the execution, you will be able to check those mocks to verify that your
    code has worked correctly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用模拟对象或函数（或一般地，任何数据结构）替换真实对象或函数的行为被称为**修补**。`mock` 库提供了 `patch` 工具，它可以作为一个函数或类装饰器，甚至作为一个上下文管理器（更多内容请参阅[第8章](ch08.html
    "第8章。边缘 – GUI和脚本")，*边缘 – GUI和脚本*），你可以用它来模拟事物。一旦你用合适的模拟替换了你不需要运行的所有东西，你就可以将它们传递到测试的第二阶段，并运行你正在执行的代码。执行后，你将能够检查这些模拟以验证你的代码是否正确工作。
- en: Assertions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: The verification phase is done through the use of assertions. An **assertion**
    is a function (or method) that you can use to verify equality between objects,
    as well as other conditions. When a condition is not met, the assertion will raise
    an exception that will make your test fail. You can find a list of assertions
    in the `unittest` module documentation, and their corresponding Pythonic version
    in the nose third-party library, which provides a few advantages over the sheer
    `unittest` module, starting from an improved test discovery strategy (which is
    the way a test runner detects and discovers the tests in your application).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 验证阶段是通过使用断言来完成的。**断言**是一个函数（或方法），你可以用它来验证对象之间的相等性，以及其他条件。当条件不满足时，断言将引发一个异常，这将使你的测试失败。你可以在
    `unittest` 模块文档中找到一个断言列表，以及它们在 nose 第三方库中的对应Python版本，该库提供了一些相对于纯 `unittest` 模块的优势，从改进的测试发现策略开始（这是测试运行器检测和发现你应用程序中的测试的方式）。
- en: A classic unit test example
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个经典的单元测试示例
- en: Mocks, patches, and assertions are the basic tools we'll be using to write tests.
    So, finally, let's see an example. I'm going to write a function that takes a
    list of integers and filters out all those which aren't positive.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟、修补和断言是我们编写测试时将使用的基本工具。所以，最后，让我们看看一个例子。我将编写一个函数，该函数接受一个整数列表，并过滤掉所有非正数。
- en: '`filter_funcs.py`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_funcs.py`'
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we define the `filter_ints` function, which basically
    uses a list comprehension to retain all the numbers in `v` that are positive,
    discarding zeros and negative ones. I hope, by now, any further explanation of
    the code would be insulting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了 `filter_ints` 函数，它基本上使用列表推导来保留 `v` 中所有正数，丢弃零和负数。我希望，到现在为止，任何进一步的代码解释都是侮辱性的。
- en: What is interesting, though, is to start thinking about how we can test it.
    Well, how about we call `filter_ints` with a list of numbers and we make sure
    that `is_positive` is called for each of them? Of course, we would have to test
    `is_positive` as well, but I will show you later on how to do that. Let's write
    a simple test for `filter_ints` now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的是开始思考我们如何测试它。好吧，我们为什么不调用 `filter_ints` 并传递一个数字列表，并确保对每个数字调用 `is_positive`
    呢？当然，我们还需要测试 `is_positive`，但我稍后会向你展示如何做。现在，让我们为 `filter_ints` 编写一个简单的测试。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just to be sure we're on the same page, I am putting the code for this chapter
    in a folder called `ch7`, which lies within the root of our project. At the same
    level of `ch7`, I have created a folder called `tests`, in which I have placed
    a folder called `test_ch7`. In this folder I have one test file, called `test_filter_func.py`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们处于同一页面上，我将本章的代码放入一个名为 `ch7` 的文件夹中，该文件夹位于我们项目的根目录下。在 `ch7` 的同一级别，我创建了一个名为
    `tests` 的文件夹，其中我放置了一个名为 `test_ch7` 的文件夹。在这个文件夹中，我有一个测试文件，名为 `test_filter_func.py`。
- en: Basically, within the `tests` folder, I will recreate the tree structure of
    the code I'm testing, prepending everything with `test_`. This way, finding tests
    is really easy, as well as is keeping them tidy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在 `tests` 文件夹中，我将重新创建我正在测试的代码的树结构，将所有内容前缀为 `test_`。这样，查找测试就非常容易，同时也能保持它们的整洁。
- en: '`tests/test_ch7/test_filter_funcs.py`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs.py`'
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'My, oh my, so little code, and yet so much to say. First of all: `#1`. The
    `TestCase` class is the base class that we use to have a contained entity in which
    to run our tests. It''s not just a bare container; it provides you with methods
    to write tests more easily.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这么少的代码，却说了这么多。首先：`#1`。`TestCase`类是我们用来运行测试的封装实体的基类。它不仅仅是一个裸容器；它为您提供了编写测试的更简单的方法。
- en: On `#2`, we import `patch` and `call` from the `unittest.mock` module. `patch`
    is responsible for substituting an object with a `Mock` instance, thereby giving
    us the ability to check on it after the execution phase has been completed. `call`
    provides us with a nice way of expressing a (for example, function) call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#2`中，我们从`unittest.mock`模块中导入`patch`和`call`。`patch`负责用`Mock`实例替换对象，从而在执行阶段完成后，让我们能够检查它。`call`为我们提供了一个很好的方式来表达一个（例如，函数）调用。
- en: On `#3`, you can see that I prefer to use assertions from `nose`, rather than
    the ones that come with the `unittest` module. To give you an example, `assert_equal(...)`
    would become `self.assertEqual(...)` if I didn't use `nose`. I don't enjoy typing
    `self.` for any assertion, if there is a way to avoid it, and I don't particularly
    enjoy **camel case**, therefore I always prefer to use `nose` to make my assertions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#3`中，您可以看到我更倾向于使用`nose`提供的断言，而不是`unittest`模块自带的断言。举个例子，如果我没有使用`nose`，`assert_equal(...)`将变为`self.assertEqual(...)`。我不喜欢为任何断言输入`self.`，如果有可能避免，我也不特别喜欢驼峰命名法，因此我总是更喜欢使用`nose`来进行断言。
- en: '`assert_equal` is a function that takes two parameters (and an optional third
    one that acts as a message) and verifies that they are the same. If they are equal,
    nothing happens, but if they differ, then an `AssertionError` exception is raised,
    telling us something is wrong. When I write my tests, I always put the expected
    value as the first argument, and the real one as the second. This convention saves
    me time when I''m reading tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_equal`是一个接受两个参数（以及一个可选的第三个参数，用作消息）并验证它们是否相同的函数。如果它们相等，则不会发生任何事情，但如果它们不同，则会引发`AssertionError`异常，告诉我们有问题。当我编写测试时，我总是将预期值作为第一个参数，将实际值作为第二个参数。这个约定在阅读测试时节省了我很多时间。'
- en: 'On `#4`, we import the function we want to test, and then (`#5`) we proceed
    to create the class where our tests will live. Each method of this class starting
    with `test_`, will be interpreted as a test. As you can see, we need to decorate
    `test_filter_ints` with `patch` (`#6`). Understanding this part is crucial, we
    need to patch the object where it is actually used. In this case, the path is
    very simple: `ch7.filter_func.is_positive`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#4`中，我们导入我们想要测试的函数，然后（`#5`）我们继续创建一个类，我们的测试将在这个类中运行。这个类的每个以`test_`开头的方法都将被解释为一个测试。如您所见，我们需要用`patch`装饰`test_filter_ints`（`#6`）。理解这部分内容至关重要，我们需要在对象实际使用的地方进行补丁。在这种情况下，路径非常简单：`ch7.filter_func.is_positive`。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Patching can be very tricky, so I urge you to read the *Where to patch* section
    in the mock documentation: [https://docs.python.org/3/library/unittest.mock.html#where-to-patch](https://docs.python.org/3/library/unittest.mock.html#where-to-patch).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁操作可能非常复杂，所以我强烈建议您阅读模拟文档中的“在哪里打补丁”部分：[https://docs.python.org/3/library/unittest.mock.html#where-to-patch](https://docs.python.org/3/library/unittest.mock.html#where-to-patch)。
- en: When we decorate a function using `patch`, like in our example, we get an extra
    argument in the test signature (`#7`), which I like to call as the patched function
    name, plus a `_mock` suffix, just to make it clear that the object has been patched
    (or mocked out).).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`patch`装饰一个函数时，就像在我们的例子中那样，测试签名中会多出一个参数（`#7`），我喜欢将其称为补丁函数名称，加上一个`_mock`后缀，以便清楚地表明该对象已被补丁（或模拟）。）
- en: Finally, we get to the body of the test, and we have a very simple preparation
    phase in which we set up a list with at least one representative of all the integer
    number categories (negative, zero, and positive).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达测试的主体，我们有一个非常简单的准备阶段，在这个阶段中，我们设置一个列表，其中至少包含所有整数类别（负数、零和正数）的代表。
- en: Then, in `#8`, we perform the execution phase, which runs the `filter_ints`
    function, without collecting its results. If all has gone as expected, the fake
    `is_positive` function must have been called with each of the integers in `v`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`#8`中，我们执行执行阶段，运行`filter_ints`函数，但不收集其结果。如果一切如预期进行，伪造的`is_positive`函数必须已经对`v`中的每个整数进行了调用。
- en: We can verify this by comparing a list of call objects to the `call_args_list`
    attribute on the mock (`#9`). This attribute is the list of all the calls performed
    on the object since its creation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较调用对象列表与模拟的`call_args_list`属性（`#9`）来验证这一点。这个属性是自对象创建以来在对象上执行的所有调用的列表。
- en: 'Let''s run this test. First of all, make sure that you install `nose` (`$ pip
    freeze` will tell you if you have it already):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个测试。首先，确保你已经安装了`nose`（`$ pip freeze`会告诉你你是否已经安装了它）：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, change into the root of the project (mine is called `learning.python`),
    and run the tests like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，切换到项目的根目录（我的项目名为`learning.python`），并按如下方式运行测试：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output shows one dot (each dot is a test), a separation line, and the time
    taken to run the whole test suite. It also says `OK` at the end, which means that
    our tests were all successful.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了单个点（每个点代表一个测试），一条分隔线，以及运行整个测试套件所需的时间。最后还显示`OK`，这意味着我们的测试都是成功的。
- en: Making a test fail
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使测试失败
- en: 'Good, so just for fun let''s make one fail. In the test file, change the last
    call from `call(8)` to `call(9)`, and run the tests again:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，为了好玩，让我们让其中一个失败。在测试文件中，将最后的调用从`call(8)`改为`call(9)`，然后再次运行测试：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wow, we made the beast angry! So much wonderful information, though. This tells
    you that the test `test_filter_ints` (with the path to it), was run and that it
    failed (the big `F` at the top, where the dot was before). It gives you a `Traceback`,
    that tells you that in the `test_filter_funcs.py` module, at line 21, when asserting
    on `is_positive_mock.call_args_list`, we have a discrepancy. The test expects
    the list of calls to end with a `call(9)` instance, but the real list ends with
    a `call(8)`. This is nothing less than wonderful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们激怒了这个怪物！尽管如此，信息量仍然很大。这告诉你，测试`test_filter_ints`（包括它的路径）已经运行并且失败了（顶部的大`F`，之前是点所在的位置）。它提供了一个`Traceback`，告诉你，在`test_filter_funcs.py`模块的第21行，当我们断言`is_positive_mock.call_args_list`时，存在差异。测试期望调用列表以`call(9)`实例结束，但实际列表以`call(8)`结束。这简直太棒了。
- en: If you have a test like this, can you imagine what would happen if you refactored
    and introduced a bug into your function by mistake? Well, your tests will break!
    They will tell you that *you have screwed something up, and here's the details*.
    So, you go and check out what you broke.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个这样的测试，你能想象如果你不小心重构并引入了错误会发生什么吗？好吧，你的测试会崩溃！它们会告诉你*你搞砸了某些东西，这里是详细信息*。所以，你去检查你破坏了什么。
- en: Interface testing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口测试
- en: 'Let''s add another test that checks on the returned value. It''s another method
    in the class, so I won''t reproduce the whole code again:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试来检查返回值。这是类中的另一个方法，所以我不需要再次复制整个代码：
- en: '`tests/test_ch7/test_filter_funcs.py`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs.py`'
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test is a bit different from the previous one. Firstly, we cannot mock
    the `is_positive` function, otherwise we wouldn't be able to check on the result.
    Secondly, we don't check on calls, but only on the result of the function when
    input is given.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与之前的测试略有不同。首先，我们不能模拟`is_positive`函数，否则我们就无法检查结果。其次，我们不是检查调用，而是检查输入数据时函数的结果。
- en: I like this test much more than the previous one. This type of test is called
    an **interface test** because it checks on the interface (the set of inputs and
    outputs) of the function we're testing. It doesn't use any mocks, which is why
    I use this technique much more than the previous one. Let's run the new test suite
    and then let's see why I like interface testing more than those with mocks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢这个测试，而不是之前的那个。这种类型的测试被称为**接口测试**，因为它检查我们正在测试的函数的接口（输入和输出的集合）。它不使用任何模拟，这就是为什么我比之前更常用这种技术。让我们运行新的测试套件，然后看看为什么我比那些带模拟的测试更喜欢接口测试。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Two tests ran, all good (I changed that `9` back to an `8` in the first test,
    of course).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试都运行良好（我在第一个测试中将那个`9`改回了`8`，当然）。
- en: Comparing tests with and without mocks
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较带和不带模拟的测试
- en: 'Now, let''s see why I don''t really like mocks and use them only when I have
    no choice. Let''s refactor the code in this way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看为什么我真的不喜欢模拟，只有在没有选择的情况下才使用它们。让我们以这种方式重构代码：
- en: '`filter_funcs_refactored.py`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_funcs_refactored.py`'
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code for `is_positive` is the same as before. But the logic in `filter_ints`
    has now changed in a way that `is_positive` will never be called with a `0`, since
    they are all filtered out in `#1`. This leads to an interesting result, so let''s
    run the tests again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_positive`的代码与之前相同。但`filter_ints`中的逻辑现在已改变，这样`is_positive`就不会用`0`调用，因为它们都在`#1`中被过滤掉了。这导致了一个有趣的结果，所以让我们再次运行测试：'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One test succeeded but the other one, the one with the mocked `is_positive`
    function, failed. The `AssertionError` message shows us that we now need to amend
    the list of expected calls, removing `call(0)`, because it is no longer performed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试通过了，但另一个测试，即使用模拟的`is_positive`函数的测试失败了。`AssertionError`消息显示我们现在需要修改预期调用列表，移除`call(0)`，因为它不再执行了。
- en: This is not good. We have changed neither the interface of the function nor
    its behavior. The function is still keeping to its *original contract*. What we've
    done by testing it with a mocked object is limit ourselves. In fact, we now have
    to amend the test in order to use the new logic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好。我们既没有改变函数的接口，也没有改变其行为。函数仍然遵守其*原始契约*。通过用模拟对象测试它，我们所做的是限制了自己。实际上，我们现在必须修改测试以使用新的逻辑。
- en: This is just a simple example but it shows one important flaw in the whole mock
    mechanism. *You must keep your mocks up-to-date and in sync with the code they
    are replacing*, otherwise you risk having issues like the preceding one, or even
    worse. Your tests may not fail because they are using mocked objects that perform
    fine, but because the real ones, now not in sync any more, are actually failing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，但它展示了整个模拟机制中的一个重要缺陷。*你必须确保你的模拟与被替换的代码保持最新和同步*，否则你可能会遇到前面提到的问题，甚至更糟。你的测试可能不会失败，因为它们使用的是模拟对象，它们的表现良好，但真正的问题在于，现在不再同步的它们实际上失败了。
- en: So *use mocks only when necessary*, only when there is no other way of testing
    your functions. When you cross the boundaries of your application in a test, try
    to use a replacement, like a test database, or a fake API, and only when it's
    not possible, resort to mocks. They are very powerful, but also very dangerous
    when not handled properly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以*只有在必要时才使用模拟*，只有在没有其他测试方法时才使用。当你跨越测试中的应用边界时，尝试使用替代品，比如测试数据库或模拟API，只有在不可能的情况下才求助于模拟。它们非常强大，但如果不正确处理，也非常危险。
- en: 'So, let''s remove that first test and keep only the second one, so that I can
    show you another issue you could run into when writing tests. The whole test module
    now looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们移除第一个测试，只保留第二个，这样我就可以向你展示你在编写测试时可能会遇到的其他问题。整个测试模块现在看起来是这样的：
- en: '`tests/test_ch7/test_filter_funcs_final.py`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs_final.py`'
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we run it, it will pass.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，它将通过。
- en: 'A brief chat about triangulation. Now let me ask you: what happens if I change
    my `filter_ints` function to this?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 简单聊聊三角剖分。现在让我问你：如果我将我的`filter_ints`函数改为这样，会发生什么？
- en: '`filter_funcs_triangulation.py`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_funcs_triangulation.py`'
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run the test suite, the test we have will still pass! You may think I'm
    crazy but I'm showing you this because I want to talk about a concept called **triangulation**,
    which is very important when doing interface testing with TDD.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试套件，我们现有的测试仍然会通过！你可能觉得我疯了，但我展示这个是因为我想讨论一个叫做**三角剖分**的概念，这在进行TDD接口测试时非常重要。
- en: 'The whole idea is to remove cheating code, or badly performing code, by pinpointing
    it from different angles (like going to one vertex of a triangle from the other
    two) in a way that makes it impossible for our code to cheat, and the bug is exposed.
    We can simply modify the test like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个想法是通过从不同的角度（比如从一个三角形的三个顶点之一到其他两个顶点）定位，以使我们的代码无法作弊，并暴露出错误。我们可以简单地修改测试如下：
- en: '`tests/test_ch7/test_filter_funcs_final_triangulation.py`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs_final_triangulation.py`'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I have moved the execution section in the assertions directly, and you can see
    that we're now pinpointing our function from two different angles, thereby requiring
    that the real code be in it. It's no longer possible for our function to cheat.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将执行部分直接移动到断言中，你可以看到我们现在从两个不同的角度定位我们的函数，从而要求真实代码必须包含在其中。我们的函数再也不能作弊了。
- en: Triangulation is a very powerful technique that teaches us to always try to
    exercise our code from many different angles, to cover all possible edge cases
    to expose any problems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 三角剖分是一种非常强大的技术，它教会我们始终尝试从许多不同的角度来测试我们的代码，以覆盖所有可能的边缘情况，从而暴露任何问题。
- en: Boundaries and granularity
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界和粒度
- en: 'Let''s now add a test for the `is_positive` function. I know it''s a one-liner,
    but it presents us with opportunity to discuss two very important concepts: **boundaries**
    and **granularity**.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`is_positive`函数添加一个测试。我知道它只有一行，但它为我们提供了讨论两个非常重要的概念的机会：**边界**和**粒度**。
- en: 'That `0` in the body of the function is a **boundary**, the `>` in the inequality
    is how we behave with regards to this boundary. Typically, when you set a boundary,
    you divide the space into three areas: what lies before the boundary, after the
    boundary, and on the boundary itself. In the example, before the boundary we find
    the negative numbers, the boundary is the element `0` and, after the boundary,
    we find the positive numbers. We need to test each of these areas to be sure we''re
    testing the function correctly. So, let''s see one possible solution (I will add
    the test to the class, but I won''t show the repeated code):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数主体中的那个`0`是一个**边界**，不等式中的`>`是我们对这个边界的行为。通常，当你设置一个边界时，你会将空间分成三个区域：边界之前的部分，边界之后的部分，以及边界本身。在例子中，边界之前我们找到负数，边界是元素`0`，边界之后我们找到正数。我们需要测试这些区域中的每一个，以确保我们正确地测试了函数。那么，让我们看看一个可能的解决方案（我将把这个测试添加到类中，但不会展示重复的代码）：
- en: '`tests/test_ch7/test_filter_funcs_is_positive_loose.py`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs_is_positive_loose.py`'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see that we are exercising one number for each different area around
    the boundary. Do you think this test is good? Think about it for a minute before
    reading on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们正在为边界周围的每个不同区域练习一个数字。你认为这个测试好吗？在你继续阅读之前，先思考一下。
- en: 'The answer is no, this test is not good. Not good enough, anyway. If I change
    the body of the `is_positive` function to read `return n > 1`, I would expect
    my test to fail, but it won''t. `-2` is still `False`, as well as `0`, and `2`
    is still `True`. Why does that happen? It is because we haven''t taken granularity
    properly into account. We''re dealing with integers, so what is the minimum granularity
    when we move from one integer to the next one? It''s 1\. Therefore, when we surround
    the boundary, taking all three areas into account is not enough. We need to do
    it with the minimum possible granularity. Let''s change the test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，这个测试并不好。至少不够好。如果我改变`is_positive`函数的主体，使其读取`return n > 1`，我预期我的测试会失败，但它不会。`-2`仍然是`False`，`0`也是，而`2`仍然是`True`。为什么会这样呢？这是因为我们没有正确考虑粒度。我们处理的是整数，那么从一个整数移动到下一个整数时的最小粒度是多少？是1。因此，当我们考虑边界时，只考虑这三个区域是不够的。我们需要以可能的最小粒度来做这件事。让我们改变一下测试：
- en: '`tests/test_ch7/test_filter_funcs_is_positive_correct.py`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs_is_positive_correct.py`'
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ah, now it's better. Now if we change the body of `is_positive` to read `return
    n > 1`, the third assertion will fail, which is what we want. Can you think of
    a better test?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在好多了。现在如果我们改变`is_positive`的主体，使其读取`return n > 1`，第三个断言将会失败，这正是我们想要的。你能想到一个更好的测试吗？
- en: '`tests/test_ch7/test_filter_funcs_is_positive_better.py`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_filter_funcs_is_positive_better.py`'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This test is even better. We test the first ten thousand integers (both positive
    and negative) and 0\. It basically provides us with a better coverage than just
    the one across the boundary. So, keep this in mind. Zoom closely around each boundary
    with minimal granularity, but try to expand as well, finding a good compromise
    between optimal coverage and execution speed. We would love to check the first
    billion integers, but we can't wait days for our tests to run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试甚至更好。我们测试了前十个整数（正数和负数）以及`0`。这基本上为我们提供了比仅仅跨越边界更好的覆盖率。所以，请记住这一点。在边界周围以最小的粒度进行近距离观察，但也要尝试扩展，在最佳覆盖率和执行速度之间找到一个良好的折衷方案。我们很想检查前十亿个整数，但我们不能等待几天来运行我们的测试。
- en: A more interesting example
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更有趣的例子
- en: 'Okay, this was as gentle an introduction as I could give you, so let''s move
    on to something more interesting. Let''s write and test a function that flattens
    a nested dictionary structure. For a couple of years, I have worked very closely
    with Twitter and Facebook APIs. Handling such humongous data structures is not
    easy, especially since they''re often deeply nested. It turns out that it''s much
    easier to flatten them in a way that you can work on them without losing the original
    structural information, and then recreate the nested structure from the flat one.
    To give you an example, we want something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我能够给你的最温和的介绍了，所以让我们继续到更有趣的部分。让我们编写并测试一个函数，它可以扁平化嵌套字典结构。在过去的几年里，我非常紧密地与Twitter和Facebook
    API合作。处理这样庞大的数据结构并不容易，尤其是它们通常非常嵌套。结果发现，以一种你可以工作而不丢失原始结构信息的方式扁平化它们要容易得多，然后可以从扁平结构重新创建嵌套结构。为了给你一个例子，我们想要的是这样的：
- en: '`data_flatten.py`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_flatten.py`'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A structure like `flat` is much simpler to manipulate. Before writing the flattener,
    let''s make some assumptions: the keys are strings, we leave every data structure
    as it is unless it''s a dictionary, in which case we flatten it, we use the dot
    as separator, but we want to be able to pass a different one to our function.
    Here''s the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `flat` 的结构更容易操作。在编写扁平化函数之前，让我们做一些假设：键是字符串，除非是字典，否则我们保留每个数据结构不变，如果是字典，则进行扁平化处理，我们使用点作为分隔符，但希望能够将不同的分隔符传递给我们的函数。以下是代码：
- en: '`data_flatten.py`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_flatten.py`'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding example is not difficult, but also not trivial so let''s go through
    it. At first, we check if `data` is a dictionary. If it''s not a dictionary, then
    it''s data that doesn''t need to be flattened; therefore, we simply return either
    `data` or, if `prefix` is not an empty string, a dictionary with one key/value
    pair: `prefix`/`data`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例并不困难，但也不是显而易见的，所以让我们来分析一下。首先，我们检查 `data` 是否是字典。如果不是字典，那么它就是不需要扁平化的数据；因此，我们简单地返回
    `data`，或者如果 `prefix` 不是空字符串，则返回一个包含一个键/值对的字典：`prefix`/`data`。
- en: If instead `data` is a dict, we prepare an empty `result` dict to return, then
    we parse the list of `data`'s items, which, at I'm sure you will remember, are
    2-tuples *(key, value)*. For each *(key, value)* pair, we recursively call `flatten`
    on them, and we update the `result` dict with what's returned by that call. Recursion
    is excellent when running through nested structures.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `data` 是一个字典，我们准备一个空的 `result` 字典来返回，然后解析 `data` 的项目列表，我相信你会记得，它们是 2-元组 *(键，值)*。对于每一对
    *(键，值)*，我们递归地调用 `flatten`，并用那个调用返回的内容更新 `result` 字典。递归在遍历嵌套结构时非常出色。
- en: At a glance, can you understand what the `_get_new_prefix` function does? Let's
    use the inside-out technique once again. I see a ternary operator that returns
    the stringified `key` when `prefix` is an empty string. On the other hand, when
    `prefix` is a non-empty string, we use the `separator` to `join` the `prefix`
    with the stringified version of `key`. Notice that the braces inside the call
    to `join` aren't redundant, we need them. Can you figure out why?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你能理解 `_get_new_prefix` 函数的作用吗？让我们再次使用内外部技术。我看到一个三元运算符，当 `prefix` 是空字符串时返回
    `key` 的字符串表示。另一方面，当 `prefix` 是非空字符串时，我们使用 `separator` 将 `prefix` 与 `key` 的字符串表示形式
    `join`。请注意，在 `join` 调用内部的括号不是多余的，我们需要它们。你能想出为什么吗？
- en: 'Let''s write a couple of tests for this function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个函数写几个测试用例：
- en: '`tests/test_ch7/test_data_flatten.py`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_ch7/test_data_flatten.py`'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's start from `test_flatten`. I defined a list of 2-tuples `(nested, flat)`,
    each of which represents a test case (I highlighted `nested` to ease reading).
    I have one big dict with three levels of nesting, and then some smaller data structures
    that won't change when passed to the `flatten` function. These test cases are
    probably not enough to cover all edge cases, but they should give you a good idea
    of how you could structure a test like this. With a simple `for` loop, I cycle
    through each test case and assert that the result of `flatten(nested)` is equal
    to `flat`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `test_flatten` 开始。我定义了一个包含 2-元组 `(nested, flat)` 的列表，每个都代表一个测试用例（我突出显示了
    `nested` 以便于阅读）。我有一个包含三个嵌套级别的字典，然后是一些较小的数据结构，当传递给 `flatten` 函数时它们不会改变。这些测试用例可能不足以覆盖所有边缘情况，但它们应该能给你一个关于如何构建此类测试的好主意。通过简单的
    `for` 循环，我遍历每个测试用例，并断言 `flatten(nested)` 的结果等于 `flat`。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One thing to say about this example is that, when you run it, it will show you
    that two tests have been run. This is actually not correct because even if technically
    there were only two tests running, in one of them we have multiple test cases.
    It would be nicer to have them run in a way that they were recognized as separate.
    This is possible through the use of libraries such as `nose-parameterized`, which
    I encourage you to check out. It's on [https://pypi.python.org/pypi/nose-parameterized](https://pypi.python.org/pypi/nose-parameterized).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例，有一点要说的是，当你运行它时，它会显示已经运行了两个测试。这实际上是不正确的，因为即使技术上只有一个测试在运行，其中一个测试中我们有多个测试用例。最好以它们被识别为单独的方式运行。这可以通过使用像
    `nose-parameterized` 这样的库来实现，我鼓励你查看。它位于 [https://pypi.python.org/pypi/nose-parameterized](https://pypi.python.org/pypi/nose-parameterized)。
- en: I also provided a second test to make sure the custom separator feature worked.
    As you can see, I used only one data structure, which is much smaller. We don't
    need to go big again, nor to test other edge cases. Remember, tests should make
    sure of one thing and one thing only, and `test_flatten_custom_separator` just
    takes care of verifying whether or not we can feed the `flatten` function a different
    `separator`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提供了一个额外的测试用例，以确保自定义分隔符功能正常工作。正如你所看到的，我只使用了一个数据结构，它要小得多。我们不需要再次做大，也不需要测试其他边缘情况。记住，测试应该确保一件事，而且只有一件事，`test_flatten_custom_separator`只是负责验证我们是否可以向`flatten`函数提供不同的`separator`。
- en: I could keep blathering on about tests for about another book if only I had
    the space, but unfortunately, we need to stop here. I haven't told you about **doctests**
    (tests written in the documentation using a Python interactive shell style), and
    about another half a million things that could be said about this subject. You'll
    have to discover that for yourself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有足够的空间，我可以继续谈论测试，大概还能写一本书，但不幸的是，我们得在这里停下来。我没有告诉你关于**doctests**（使用Python交互式shell风格编写的文档中的测试）以及关于这个主题可能说的另外五十万件事情。你必须自己发现这些。
- en: Take a look at the documentation for the `unittest` module, the `nose` and `nose-parameterized`
    libraries, and `pytest` ([http://pytest.org/](http://pytest.org/)), and you will
    be fine. In my experience, mocking and patching seem to be quite hard to get a
    good grasp of for developers who are new to them, so allow yourself a little time
    to digest these techniques. Try and learn them gradually.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`unittest`模块、`nose`和`nose-parameterized`库以及`pytest`（[http://pytest.org/](http://pytest.org/)）的文档，这样你就能顺利了。根据我的经验，对于新手来说，模拟和补丁似乎很难掌握，所以请给自己一点时间来消化这些技术。尝试并逐渐学习它们。
- en: Test-driven development
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Let's talk briefly about **test-driven development** or **TDD**. It is a methodology
    that was rediscovered by Kent Beck, who wrote *Test Driven Development by Example*,
    *Addison Wesley – 2002*, which I encourage you to check out if you want to learn
    about the fundamentals of this subject, which I'm quite obsessed with.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈**测试驱动开发**或**TDD**。这是一种由Kent Beck重新发现的方法论，他写了《通过示例进行测试驱动开发》，*Addison
    Wesley – 2002*，如果你想了解这个主题的基础知识，我强烈建议你阅读这本书，我对这个主题非常着迷。
- en: '*TDD is a software development methodology that is based on the continuous
    repetition of a very short development cycle.*'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*TDD是一种基于持续重复非常短的开发周期的软件开发方法*。'
- en: At first, the developer writes a test, and makes it run. The test is supposed
    to check a feature that is not yet part of the code. Maybe is a new feature to
    be added, or something to be removed or amended. Running the test will make it
    fail and, because of this, this phase is called **Red**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，开发者编写一个测试用例，并运行它。测试用例旨在检查代码中尚未包含的功能。可能是要添加的新功能，或者是要删除或修改的内容。运行测试用例会使它失败，因此这个阶段被称为**红色**。
- en: When the test has failed, the developer writes the minimal amount of code to
    make it pass. When running the test succeeds, we have the so-called **Green**
    phase. In this phase, it is okay to write code that cheats, just to make the test
    pass (that's why you would then use triangulation). This technique is called,
    *fake it 'til you make it*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，开发者编写最少的代码来使其通过。当运行测试成功时，我们就进入了所谓的**绿色**阶段。在这个阶段，可以编写一些欺骗性的代码，只是为了使测试通过（这就是为什么你会使用三角测量法）。这种技术被称为，*假装直到你做到*。
- en: The last piece of this cycle is where the developer takes care of both the code
    and the tests (in separate times) and refactors them until they are in the desired
    state. This last phase is called **Refactor**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环的最后一部分是开发者负责代码和测试（分别在不同的时间）并进行重构，直到它们达到期望的状态。这个最后阶段被称为**重构**。
- en: The **TDD mantra** therefore recites, **Red-Green-Refactor**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**TDD的咒语**是，**红色-绿色-重构**。
- en: At first, it feels really weird to write tests before the code, and I must confess
    it took me a while to get used to it. If you stick to it, though, and force yourself
    to learn this slightly counter-intuitive way of working, at some point something
    almost magical happens, and you will see the quality of your code increase in
    a way that wouldn't be possible otherwise.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，在编写代码之前编写测试用例感觉真的很奇怪，我必须承认我花了一些时间才习惯这种方式。但是，如果你坚持下去，并强迫自己学习这种稍微有些反直觉的工作方式，在某个时刻，几乎神奇的事情就会发生，你将看到你的代码质量以一种在其他情况下不可能的方式提高。
- en: When you write your code before the tests, you have to take care of *what* the
    code has to do and *how* it has to do it, both at the same time. On the other
    hand, when you write tests before the code, you can concentrate on the *what*
    part alone, while you write them. When you write the code afterwards, you will
    mostly have to take care of *how* the code has to implement *what* is required
    by the tests. This shift in focus allows your mind to concentrate on the *what*
    and *how* parts in separate moments, yielding a brain power boost that will surprise
    you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编写测试之前编写代码时，你必须同时注意代码需要做什么以及如何做。另一方面，当你先编写测试再编写代码时，你可以专注于“做什么”的部分，在编写测试时集中精力。当你编写代码之后，你主要需要关注的是如何实现测试所要求的内容。这种关注点的转变允许你的大脑在单独的时刻集中精力在“做什么”和“如何做”的部分，从而产生一个让你惊讶的大脑能力提升。
- en: 'There are several other benefits that come from the adoption of this technique:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从采用这种技术中还可以获得其他一些好处：
- en: '**You will refactor with much more confidence**: Because when you touch your
    code you know that if you screw things up, you will break at least one test. Moreover,
    you will be able to take care of the architectural design in the refactor phase,
    where having tests that act as guardians will allow you to enjoy massaging the
    code until it reaches a state that satisfies you.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你将更有信心地进行重构**：因为当你接触代码时，你知道如果你搞砸了，至少会破坏一个测试。此外，你将在重构阶段处理架构设计，此时有测试作为守护者将允许你享受对代码进行按摩，直到它达到让你满意的状态。'
- en: '**The code will be more readable**: This is crucial in our time, when coding
    is a social activity and every professional developer spends much more time reading
    code than writing it.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码将更加易于阅读**：在我们这个时代，编码已经成为一种社会活动，每个专业开发者花费在阅读代码上的时间远多于编写代码。'
- en: '**The code will be more loose-coupled and easier to test and maintain**: This
    is simply because writing the tests first forces you to think more deeply about
    its structure.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码将更加松散耦合，更容易测试和维护**：这仅仅是因为先编写测试迫使你更深入地思考其结构。'
- en: '**Writing tests first requires you to have a better understanding of the business
    requirements**: This is fundamental in delivering what was actually asked for.
    If your understanding of the requirements is lacking information, you''ll find
    writing a test extremely challenging and this situation acts as a sentinel for
    you.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先编写测试需要你对业务需求有更好的理解**：这是交付实际所需内容的基本要求。如果你的需求理解缺乏信息，你会发现编写测试极具挑战性，这种情况就像一个哨兵一样提醒你。'
- en: '**Having everything unit tested means the code will be easier to debug**: Moreover,
    small tests are perfect for providing alternative documentation. English can be
    misleading, but five lines of Python in a simple test are very hard to be misunderstood.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有内容都经过单元测试意味着代码将更容易调试**：此外，小测试是提供替代文档的完美选择。英语可能会误导，但五行简单的Python代码在一个简单的测试中很难被误解。'
- en: '**Higher speed**: It''s faster to write tests and code than it is to write
    the code first and then lose time debugging it. If you don''t write tests, you
    will probably deliver the code sooner, but then you will have to track the bugs
    down and solve them (and, rest assured, there will be bugs). The combined time
    taken to write the code and then debug it is usually longer than the time taken
    to develop the code with TDD, where having tests running before the code is written,
    ensuring that the amount of bugs in it will be much lower than in the other case.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的速度**：编写测试和代码比先编写代码然后花费时间调试要快。如果你不编写测试，你可能会更快地交付代码，但随后你必须追踪并解决错误（而且，请放心，肯定会有错误）。编写代码然后调试所花费的总时间通常比使用TDD（测试驱动开发）开发代码的时间要长，在编写代码之前就有测试运行，确保其中的错误数量将远低于其他情况。'
- en: 'On the other hand, the main shortcomings of this technique are:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种技术的缺点主要是：
- en: '**The whole company needs to believe in it**: Otherwise you will have to constantly
    argue with your boss, who will not understand why it takes you so long to deliver.
    The truth is, it may take you a bit longer to deliver in the short term, but in
    the long term you gain a lot with TDD. However, it is quite hard to see the long
    term because it''s not under our noses like the short term is. I have fought battles
    with stubborn bosses in my career, to be able to code using TDD. Sometimes it
    has been painful, but always well worth it, and I have never regretted it because,
    in the end, the quality of the result has always been appreciated.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整个公司都需要相信它**：否则你将不得不不断地与你的老板争论，而你的老板可能不会理解为什么你交付的时间如此之长。事实是，短期内你交付的时间可能会更长，但长期来看，TDD会给你带来很多好处。然而，由于它不像短期那样触手可及，因此很难看到长远的影响。在我的职业生涯中，我与固执的老板进行了斗争，以便能够使用TDD进行编码。有时这很痛苦，但总是值得的，我从未后悔过，因为最终，结果的质量总是受到赞赏。'
- en: '**If you fail to understand the business requirements, this will reflect in
    the tests you write, and therefore it will reflect in the code too**: This kind
    of problem is quite hard to spot until you do UAT, but one thing that you can
    do to reduce the likelihood of it happening is to pair with another developer.
    Pairing will inevitably require discussions about the business requirements, and
    this will help having a better idea about them before the tests are written.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果你没有理解业务需求，这将在你编写的测试中反映出来，因此也会反映在代码中**：这种问题直到你进行用户验收测试（UAT）之前很难被发现，但你可以做的一件事是与另一位开发者结对编程。结对编程不可避免地需要讨论业务需求，这有助于在编写测试之前更好地了解它们。'
- en: '**Badly written tests are hard to maintain**: This is a fact. Tests with too
    many mocks or with extra assumptions or badly structured data will soon become
    a burden. Don''t let this discourage you; just keep experimenting and change the
    way you write them until you find a way that doesn''t require you a huge amount
    of work every time you touch your code.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写糟糕的测试很难维护**：这是一个事实。带有太多模拟或额外假设或结构不良数据的测试很快就会成为一种负担。不要让这让你气馁；只需继续实验，改变你编写测试的方式，直到你找到一种不需要你在每次触摸代码时做大量工作的方法。'
- en: I'm so passionate about TDD that when I interview for a job, I always ask if
    the company I'm about to join adopts it. If the answer is no, it's kind of a deal-breaker
    for me. I encourage you to check it out and use it. Use it until you feel something
    clicking in your mind. You won't regret it, I promise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我对TDD（测试驱动开发）的热情如此之高，以至于当我去面试工作时，我总是询问我即将加入的公司是否采用TDD。如果答案是“不”，对我来说这可能是一个决定性的因素。我鼓励你尝试并使用它。一直用到你在脑海中有所领悟。我保证你不会后悔。
- en: Exceptions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Even though I haven't formally introduced them to you, by now I expect you to
    at least have a vague idea of what an **exception** is. In the previous chapters,
    we've seen that when an iterator is exhausted, calling `next` on it raises a `StopIteration`
    exception. We've met `IndexError` when we tried accessing a list at a position
    that was outside the valid range. We've also met `AttributeError` when we tried
    accessing an attribute on an object that didn't have it, and `KeyError` when we
    did the same with a key and a dictionary. We've also just met `AssertionError`
    when running tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我还没有正式向你介绍它们，但到现在为止，我期望你至少对什么是**异常**有一个模糊的概念。在前几章中，我们看到了当迭代器耗尽时，对其调用`next`会引发`StopIteration`异常。当我们尝试访问一个不在有效范围内的列表位置时，我们遇到了`IndexError`。当我们尝试访问一个没有该属性的对象的属性时，我们遇到了`AttributeError`，当我们用键和字典做同样的事情时，我们遇到了`KeyError`。我们还在运行测试时遇到了`AssertionError`。
- en: Now, the time has come for us to talk about exceptions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们讨论异常的时候了。
- en: Sometimes, even though an operation or a piece of code is correct, there are
    conditions in which something may go wrong. For example, if we're converting user
    input from `string` to `int`, the user could accidentally type a letter in place
    of a digit, making it impossible for us to convert that value into a number. When
    dividing numbers, we may not know in advance if we're attempting a division by
    zero. When opening a file, it could be missing or corrupted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，即使一个操作或一段代码是正确的，也可能存在某些可能导致错误的情况。例如，如果我们正在将用户输入从`string`转换为`int`，用户可能会不小心输入一个字母代替数字，这使得我们无法将该值转换为数字。在除法操作中，我们可能事先不知道是否尝试除以零。在打开文件时，它可能不存在或已损坏。
- en: 'When an error is detected during execution, it is called an **exception**.
    Exceptions are not necessarily lethal; in fact, we''ve seen that `StopIteration`
    is deeply integrated in Python generator and iterator mechanisms. Normally, though,
    if you don''t take the necessary precautions, an exception will cause your application
    to break. Sometimes, this is the desired behavior but in other cases, we want
    to prevent and control problems such as these. For example, we may alert the user
    that the file they''re trying to open is corrupted or that it is missing so that
    they can either fix it or provide another file, without the need for the application
    to die because of this issue. Let''s see an example of a few exceptions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当在执行过程中检测到错误时，它被称为 **异常**。异常并不一定是致命的；事实上，我们已经看到 `StopIteration` 在 Python 生成器和迭代器机制中是深度集成的。通常情况下，如果你不采取必要的预防措施，异常会导致你的应用程序崩溃。有时，这是期望的行为，但在其他情况下，我们希望防止和控制这些问题。例如，我们可能提醒用户他们正在尝试打开的文件已损坏或丢失，这样他们可以修复它或提供另一个文件，而无需应用程序因这个问题而死亡。让我们看看几个异常的例子：
- en: '`exceptions/first.example.py`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions/first.example.py`'
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the Python shell is quite forgiving. We can see the `Traceback`,
    so that we have information about the error, but the program doesn't die. This
    is a special behavior, a regular program or a script would normally die if nothing
    were done to handle exceptions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 的外壳相当宽容。我们可以看到 `Traceback`，这样我们就有关于错误的信息，但程序并没有死亡。这是一种特殊的行为，一个常规程序或脚本如果没有处理异常，通常会死亡。
- en: 'To handle an exception, Python gives you the `try` statement. What happens
    when you enter the `try` clause is that Python will watch out for one or more
    different types of exceptions (according to how you instruct it), and if they
    are raised, it will allow you to react. The `try` statement is comprised of the
    `try` clause, which opens the statement; one or more `except` clauses (all optional)
    that define what to do when an exception is caught; an `else` clause (optional),
    which is executed when the `try` clause is exited without any exception raised;
    and a `finally` clause (optional), whose code is executed regardless of whatever
    happened in the other clauses. The `finally` clause is typically used to clean
    up resources. Mind the order, it''s important. Also, `try` must be followed by
    at least one `except` clause or a `finally` clause. Let''s see an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理异常，Python 提供了 `try` 语句。当你进入 `try` 子句时，Python 会监视一个或多个不同类型的异常（根据你的指令），如果发生异常，它会允许你做出反应。`try`
    语句由 `try` 子句组成，它开启了语句；一个或多个 `except` 子句（都是可选的），用于定义捕获异常时应该做什么；一个 `else` 子句（可选的），当
    `try` 子句在没有抛出任何异常的情况下退出时执行；以及一个 `finally` 子句（可选的），其代码无论在其他子句中发生什么都会执行。`finally`
    子句通常用于清理资源。注意顺序，这很重要。此外，`try` 后面必须至少跟一个 `except` 子句或一个 `finally` 子句。让我们看一个例子：
- en: '`exceptions/try.syntax.py`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions/try.syntax.py`'
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example defines a simple `try_syntax` function. We perform the
    division of two numbers. We are prepared to catch a `ZeroDivisionError` exception
    if we call the function with `denominator = 0`. Initially, the code enters the
    `try` block. If `denominator` is not `0`, `result` is calculated and the execution,
    after leaving the `try` block, resumes in the `else` block. We print `result`
    and return it. Take a look at the output and you'll notice that just before returning
    `result`, which is the exit point of the function, Python executes the `finally`
    clause.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例定义了一个简单的 `try_syntax` 函数。我们执行两个数字的除法。如果我们用 `denominator = 0` 调用函数，我们准备捕获
    `ZeroDivisionError` 异常。最初，代码进入 `try` 块。如果 `denominator` 不是 `0`，则计算 `result`，执行在离开
    `try` 块后，在 `else` 块中继续。我们打印 `result` 并返回它。看看输出，你会在返回 `result` 之前注意到，这是函数的退出点，Python
    执行了 `finally` 子句。
- en: 'When `denominator` is `0`, things change. We enter the `except` block and print
    `zde`. The `else` block isn''t executed because an exception was raised in the
    `try` block. Before (implicitly) returning `None`, we still execute the `finally`
    block. Take a look at the output and see if it makes sense to you:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `denominator` 为 `0` 时，情况会发生变化。我们进入 `except` 块并打印 `zde`。`else` 块没有执行，因为在 `try`
    块中抛出了异常。在（隐式地）返回 `None` 之前，我们仍然执行 `finally` 块。看看输出，看看它对你是否有意义：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you execute a `try` block, you may want to catch more than one exception.
    For example, when trying to decode a JSON object, you may incur into `ValueError`
    for malformed JSON, or `TypeError` if the type of the data you''re feeding to
    `json.loads()` is not a string. In this case, you may structure your code like
    this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行一个 `try` 块时，您可能想要捕获多个异常。例如，当尝试解码一个 JSON 对象时，您可能会遇到 `ValueError`（不规则的 JSON），或者如果您提供给
    `json.loads()` 的数据类型不是字符串，则可能发生 `TypeError`。在这种情况下，您可以像这样结构化您的代码：
- en: '`exceptions/json.example.py`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions/json.example.py`'
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code will catch both `ValueError` and `TypeError`. Try changing `json_data
    = '{}'` to `json_data = 2` or `json_data = '{{'`, and you'll see the different
    output.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将捕获 `ValueError` 和 `TypeError`。尝试将 `json_data = '{}'` 改为 `json_data = 2`
    或 `json_data = '{{'`，您将看到不同的输出。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**JSON** stands for **JavaScript Object Notation** and it''s an open standard
    format that uses human-readable text to transmit data objects consisting of key/value
    pairs. It''s an exchange format widely used when moving data across applications,
    especially when data needs to be treated in a language or platform-agnostic way.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 代表 **JavaScript Object Notation**，它是一种开放标准格式，使用人类可读的文本来传输由键/值对组成的数据对象。它是当在应用程序之间移动数据时广泛使用的交换格式，尤其是在数据需要以语言或平台无关的方式处理时。'
- en: 'If you want to handle multiple exceptions differently, you can just add more
    `except` clauses, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以不同的方式处理多个异常，只需添加更多的 `except` 子句，如下所示：
- en: '`exceptions/multiple.except.py`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions/multiple.except.py`'
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Keep in mind that an exception is handled in the first block that defines that
    exception class or any of its bases. Therefore, when you stack multiple `except`
    clauses like we've just done, make sure that you put specific exceptions at the
    top and generic ones at the bottom. In OOP terms, children on top, grandparents
    at the bottom. Moreover, remember that only one `except` handler is executed when
    an exception is raised.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，异常是在定义该异常类或其基类的第一个块中处理的。因此，当您堆叠多个 `except` 子句时，请确保将特定的异常放在顶部，将通用的异常放在底部。在面向对象术语中，子类在顶部，基类在底部。此外，请记住，当抛出异常时，只有一个
    `except` 处理器被执行。
- en: You can also write **custom exceptions**. In order to do that, you just have
    to inherit from any other exception class. Python built-in exceptions are too
    many to be listed here, so I have to point you towards the official documentation.
    One important thing to know is that every Python exception derives from `BaseException`,
    but your custom exceptions should never inherit directly from that one. The reason
    for it is that handling such an exception will trap also **system-exiting exceptions**
    such as `SystemExit` and `KeyboardInterrupt`, which derive from `BaseException`,
    and this could lead to severe issues. In case of disaster, you want to be able
    to *Ctrl* + *C* your way out of an application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写 **自定义异常**。为了做到这一点，您只需从任何其他异常类继承即可。Python 内置的异常太多，无法在此列出，因此我必须将您指向官方文档。需要知道的一个重要事项是，每个
    Python 异常都源自 `BaseException`，但您的自定义异常不应直接从该类继承。这样做的原因是，处理此类异常也会捕获来自 `BaseException`
    的 **系统退出异常**，如 `SystemExit` 和 `KeyboardInterrupt`，这可能导致严重问题。在灾难发生时，您希望能够通过 *Ctrl*
    + *C* 从应用程序中退出。
- en: You can easily solve the problem by inheriting from `Exception`, which inherits
    from `BaseException`, but doesn't include any system-exiting exception in its
    children because they are siblings in the built-in exceptions hierarchy (see [https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从 `Exception` 继承来轻松解决问题，`Exception` 继承自 `BaseException`，但它的子类不包括任何退出系统的异常，因为它们在内置异常层次结构中是兄弟关系（参见
    [https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)）。
- en: 'Programming with exceptions can be very tricky. You could inadvertently silence
    out errors, or trap exceptions that aren''t meant to be handled. Play it safe
    by keeping in mind a few guidelines: always put in the `try` clause only the code
    that may cause the exception(s) that you want to handle. When you write `except`
    clauses, be as specific as you can, don''t just resort to `except Exception` because
    it''s easy. Use tests to make sure your code handles edge cases in a way that
    requires the least possible amount of exception handling. Writing an `except`
    statement without specifying any exception would catch any exception, therefore
    exposing your code to the same risks you incur when you derive your custom exceptions
    from `BaseException`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常进行编程可能会非常棘手。你可能会无意中静音错误，或者捕获那些本不应该处理的异常。为了安全起见，请记住以下几点指南：只将可能引发你想要处理的异常（s）的代码放入`try`子句中。当你编写`except`子句时，尽可能具体，不要仅仅求助于`except
    Exception`，因为这很容易。使用测试来确保你的代码以尽可能少的异常处理方式处理边缘情况。不指定任何异常的`except`语句会捕获任何异常，因此使你的代码面临与从`BaseException`派生自定义异常时相同的风险。
- en: You will find information about exceptions almost everywhere on the web. Some
    coders use them abundantly, others sparingly (I belong to the latter category).
    Find your own way of dealing with them by taking examples from other people's
    source code. There's plenty of interesting projects whose sources are open, and
    you can find them on either GitHub ([https://github.com](https://github.com))
    or Bitbucket ([https://bitbucket.org/](https://bitbucket.org/)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在网上找到有关异常的几乎所有信息。一些程序员大量使用它们，而另一些则很少使用（我属于后者）。通过参考他人的源代码来找到自己处理它们的方式。有许多有趣的项目开源了，你可以在GitHub
    ([https://github.com](https://github.com)) 或 Bitbucket ([https://bitbucket.org/](https://bitbucket.org/))
    上找到它们。
- en: Before we talk about **profiling**, let me show you an unconventional use of
    exceptions, just to give you something to help you expand your views on them.
    They are not just simply errors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论**分析**之前，让我向你展示一个异常的非传统用法，只是为了给你一些东西来帮助你扩展对这些异常的看法。它们不仅仅是简单的错误。
- en: '`exceptions/for.loop.py`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions/for.loop.py`'
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code is quite a common idiom if you deal with numbers. You have
    to iterate over a few nested ranges and look for a particular combination of `a`,
    `b`, and `c` that satisfies a condition. In the example, condition is a trivial
    linear equation, but imagine something much cooler than that. What bugs me is
    having to check if the solution has been found at the beginning of each loop,
    in order to break out of them as fast as we can when it is. The break out logic
    interferes with the rest of the code and I don't like it, so I came up with a
    different solution for this. Take a look at it, and see if you can adapt it to
    other cases too.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理数字，前面的代码是一个非常常见的习语。你必须遍历几个嵌套的范围，并寻找满足条件的特定组合`a`、`b`和`c`。在示例中，条件是一个简单的线性方程，但想象一下比这更酷的东西。让我烦恼的是，我不得不在每个循环的开始检查是否找到了解决方案，以便在找到时尽可能快地跳出循环。跳出逻辑干扰了其他代码，我不喜欢它，所以我为这个问题想出了一个不同的解决方案。看看它，看看你是否可以将其适应到其他情况。
- en: '`e` `xceptions/for.loop.py`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`e` `xceptions/for.loop.py`'
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Can you see how much more elegant it is? Now the breakout logic is entirely
    handled with a simple exception whose name even hints at its purpose. As soon
    as the result is found, we raise it, and immediately the control is given to the
    except clause which handles it. This is food for thought. This example indirectly
    shows you how to raise your own exceptions. Read up on the official documentation
    to dive into the beautiful details of this subject.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出这有多优雅吗？现在，突破逻辑完全由一个简单的异常来处理，其名称甚至暗示了其目的。一旦找到结果，我们就抛出它，然后立即控制权交给处理它的`except`子句。这是值得深思的。这个例子间接地展示了如何抛出自己的异常。查阅官方文档，深入了解这个主题的美丽细节。
- en: Profiling Python
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Python
- en: There are a few different ways to profile a Python application. Profiling means
    having the application run while keeping track of several different parameters,
    like the number of times a function is called, the amount of time spent inside
    it, and so on. Profiling can help us find the bottlenecks in our application,
    so that we can improve only what is really slowing us down.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以分析Python应用程序。分析意味着在跟踪几个不同参数的同时运行应用程序，如函数被调用的次数、在其中花费的时间量等。分析可以帮助我们找到应用程序中的瓶颈，这样我们就可以只改进真正减慢我们速度的部分。
- en: 'If you take a look at the profiling section in the standard library official
    documentation, you will see that there are a couple of different implementations
    of the same profiling interface: `profile` and `cProfile`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看标准库官方文档中的性能分析部分，你会看到有几个不同的性能分析接口实现：`profile` 和 `cProfile`。
- en: '`cProfile` is recommended for most users, it''s a C extension with reasonable
    overhead that makes it suitable for profiling long-running programs'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cProfile` 被推荐给大多数用户，它是一个具有合理开销的 C 扩展，使其适合分析长时间运行的程序。'
- en: '`profile` is a pure Python module whose interface is imitated by `cProfile`,
    but which adds significant overhead to profiled programs'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profile` 是一个纯 Python 模块，其接口被 `cProfile` 模拟，但会给被分析程序增加显著的开销。'
- en: This interface does **determinist profiling**, which means that all function
    calls, function returns and exception events are monitored, and precise timings
    are made for the intervals between these events. Another approach, called **statistical
    profiling**, randomly samples the effective instruction pointer, and deduces where
    time is being spent.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口执行 **确定性性能分析**，这意味着所有函数调用、函数返回和异常事件都会被监控，并在这些事件之间进行精确的时间测量。另一种方法，称为 **统计性能分析**，随机采样有效指令指针，并推断时间花费在哪里。
- en: The latter usually involves less overhead, but provides only approximate results.
    Moreover, because of the way the Python interpreter runs the code, deterministic
    profiling doesn't add that as much overhead as one would think, so I'll show you
    a simple example using `cProfile` from the command line.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 后者通常涉及更少的开销，但只提供近似结果。此外，由于 Python 解释器运行代码的方式，确定性性能分析并不会增加人们想象中的那么多开销，所以我会给你一个使用命令行中的
    `cProfile` 的简单示例。
- en: 'We''re going to calculate Pythagorean triples (I know, you''ve missed them...)
    using the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码计算毕达哥拉斯三元组（我知道，你可能错过了它们...）。
- en: '`profiling/triples.py`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiling/triples.py`'
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The script is extremely simple; we iterate over the interval [1, *mx*] with
    `a` and `b` (avoiding repetition of pairs by setting `b >= a`) and we check if
    they belong to a right triangle. We use `calc_hypotenuse` to get `hypotenuse`
    for `a` and `b`, and then, with `is_int`, we check if it is an integer, which
    means (*a*, *b*, *c*) is a Pythagorean triple. When we profile this script, we
    get information in tabular form. The columns are `ncalls`, `tottime`, `percall`,
    `cumtime`, `percall`, and `filename:lineno(function)`. They represent the amount
    of calls we made to a function, how much time we spent in it, and so on. I'll
    trim a couple of columns to save space, so if you run the profiling yourself,
    don't worry if you get a different result.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本非常简单；我们用 `a` 和 `b` 迭代区间 [1, *mx*]（通过设置 `b >= a` 来避免重复的配对）并检查它们是否属于直角三角形。我们使用
    `calc_hypotenuse` 来获取 `a` 和 `b` 的斜边，然后，使用 `is_int` 检查它是否为整数，这意味着 (*a*, *b*, *c*)
    是一个毕达哥拉斯三元组。当我们对这个脚本进行性能分析时，我们得到表格形式的信息。列包括 `ncalls`、`tottime`、`percall`、`cumtime`、`percall`
    和 `filename:lineno(function)`。它们代表我们对函数的调用次数、在其中花费的时间等等。我会裁剪一些列以节省空间，所以如果你自己运行性能分析，不要担心如果你得到不同的结果。
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even with this limited amount of data, we can still infer some useful information
    about this code. Firstly, we can see that the time complexity of the algorithm
    we have chosen grows with the square of the input size. The amount of times we
    get inside the inner loop body is exactly *mx (mx + 1) / 2*. We run the script
    with `mx = 1000`, which means we get `500500` times inside the inner `for` loop.
    Three main things happen inside that loop, we call `calc_hypotenuse`, we call
    `is_int` and, if the condition is met, we append to the `triples` list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有这么有限的数据，我们仍然可以从中推断出一些关于此代码的有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入大小的平方增长。我们进入内循环体的次数正好是
    *mx (mx + 1) / 2*。我们用 `mx = 1000` 运行脚本，这意味着我们在内层 `for` 循环中进入了 `500500` 次。在这个循环中发生三件事，我们调用
    `calc_hypotenuse`，调用 `is_int`，如果条件满足，我们将元素添加到 `triples` 列表中。
- en: Taking a look at the profiling report, we notice that the algorithm has spent
    `0.469` seconds inside `calc_hypotenuse`, which is way more than the `0.087` seconds
    spent inside `is_int`, given that they were called the same number of times, so
    let's see if we can boost `calc_hypotenuse` a little.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 查看性能分析报告，我们发现算法在 `calc_hypotenuse` 函数中花费了 `0.469` 秒，这比在 `is_int` 函数中花费的 `0.087`
    秒多得多，尽管它们被调用的次数相同，所以让我们看看是否可以稍微提升 `calc_hypotenuse` 的性能。
- en: 'As it turns out, we can. As I mentioned earlier on in the book, the power operator
    `**` is quite expensive, and in `calc_hypotenuse,` we''re using it three times.
    Fortunately, we can easily transform two of those into simple multiplications,
    like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以。正如我之前在书中提到的，幂运算符`**`相当昂贵，在`calc_hypotenuse`中我们使用了它三次。幸运的是，我们可以轻松地将其中两个转换为简单的乘法，如下所示：
- en: '`profiling/triples.py`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiling/triples.py`'
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simple change should improve things. If we run the profiling again, we
    see that now the `0.469` is now down to `0.177`. Not bad! This means now we're
    spending only about 37% of the time inside `calc_hypotenuse` as we were before.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改应该会改善情况。如果我们再次运行性能分析，我们会看到现在`0.469`已经下降到`0.177`。不错！这意味着现在我们花费在`calc_hypotenuse`函数内部的时间大约只有之前的37%。
- en: 'Let''s see if we can improve `is_int` as well, by changing it like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以通过这样改变来改进`is_int`：
- en: '`profiling/triples.py`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiling/triples.py`'
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This implementation is different and the advantage is that it also works when
    `n` is an integer. Alas, when we run the profiling against it, we see that the
    time taken inside the `is_int` function has gone up to `0.141` seconds. This means
    that it has roughly doubled, compared to what it was before. In this case, we
    need to revert to the previous implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现是不同的，其优势在于它也适用于`n`是整数的情况。然而，当我们对它进行性能分析时，我们发现`is_int`函数内部的时间已经上升到`0.141`秒。这意味着它大约翻了一番，与之前相比。在这种情况下，我们需要恢复到之前的实现。
- en: This example was trivial, of course, but enough to show you how one could profile
    an application. Having the amount of calls that are performed against a function
    helps us understand better the time complexity of our algorithms. For example,
    you wouldn't believe how many coders fail to see that those two `for` loops run
    proportionally to the square of the input size.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子很简单，但足以展示如何对应用程序进行性能分析。了解针对函数执行的调用次数可以帮助我们更好地理解算法的时间复杂度。例如，你不会相信有多少程序员没有意识到那两个`for`循环是与输入大小的平方成比例运行的。
- en: 'One thing to mention: depending on what system you''re using, results may be
    different. Therefore, it''s quite important to be able to profile software on
    a system that is as close as possible to the one the software is deployed on,
    if not actually on that one.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要提及：根据你使用的系统，结果可能会有所不同。因此，能够在一个尽可能接近软件部署系统的系统上对软件进行性能分析，如果不是实际上在那个系统上，这非常重要。
- en: When to profile?
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时进行性能分析？
- en: Profiling is super cool, but we need to know when it is appropriate to do it,
    and in what measure we need to address the results we get from it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析非常酷，但我们需要知道何时进行性能分析，以及我们需要以何种程度来处理从性能分析中获得的结果。
- en: Donald Knuth once said that *premature optimization is the root of all evil*
    and, although I wouldn't have put it down so drastically, I do agree with him.
    After all, who am I to disagree with the man that gave us *The Art of Computer
    Programming*, *TeX*, and some of the coolest algorithms I have ever studied when
    I was a university student?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Donald Knuth 曾经说过，“过早优化是万恶之源”，虽然我不会如此极端地表达，但我同意他的观点。毕竟，我怎能不同意这位给我们带来了《计算机程序设计艺术》、《TeX》以及我在大学时研究过的最酷算法的人呢？
- en: 'So, first and foremost: *correctness*. You want you code to deliver the result
    correctly, therefore write tests, find edge cases, and stress your code in every
    way you think makes sense. Don''t be protective, don''t put things in the back
    of your brain for later because you think they''re not likely to happen. Be thorough.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先也是最重要的：*正确性*。你希望你的代码能够正确地交付结果，因此编写测试，寻找边缘情况，并以你认为合理的方式对你的代码进行压力测试。不要过于保护，不要把事情放在脑后，因为你认为它们不太可能发生。要彻底。
- en: 'Secondly, take care of coding *best practices*. Remember readability, extensibility,
    loose coupling, modularity, and design. Apply OOP principles: encapsulation, abstraction,
    single responsibility, open/closed, and so on. Read up on these concepts. They
    will open horizons for you, and they will expand the way you think about code.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，注意编码的最佳实践。记住可读性、可扩展性、松散耦合、模块化和设计。应用面向对象编程（OOP）原则：封装、抽象、单一职责、开闭原则等。深入了解这些概念。它们将为你打开新的视野，并扩展你对代码的思考方式。
- en: Thirdly, *refactor like a beast!* The Boy Scouts Rule says to *Always leave
    the campground cleaner than you found it*. Apply this rule to your code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，像野兽一样重构代码！童子军规则说：“总是要使你离开的地方比找到的时候更干净。”将这个规则应用到你的代码上。
- en: And, finally, when all of the above has been taken care of, then and only then,
    you take care of profiling.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有上述事项都得到妥善处理之后，然后且仅在此之后，你才开始关注性能分析。
- en: Run your profiler and identify bottlenecks. When you have an idea of the bottlenecks
    you need to address, start with the worst one first. Sometimes, fixing a bottleneck
    causes a ripple effect that will expand and change the way the rest of the code
    works. Sometimes this is only a little, sometimes a bit more, according to how
    your code was designed and implemented. Therefore, start with the biggest issue
    first.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的性能分析器并识别瓶颈。当你对需要解决的瓶颈有了概念后，先从最严重的一个开始。有时，修复一个瓶颈会引起连锁反应，从而改变代码其余部分的工作方式。这取决于你的代码是如何设计和实现的，有时这种影响很小，有时则更多。因此，先从最大的问题开始。
- en: One of the reasons Python is so popular is that it is possible to implement
    it in many different ways. So, if you find yourself having troubles boosting up
    some part of your code using sheer Python, nothing prevents you from rolling up
    your sleeves, buying a couple of hundred liters of coffee, and rewriting the slow
    piece of code in C. Guaranteed to be fun!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Python之所以如此受欢迎，其中一个原因是它可以以许多不同的方式实现。所以，如果你发现自己在使用纯Python时遇到困难，没有什么能阻止你卷起袖子，买上几百升咖啡，然后用C语言重写那些慢速的代码。保证会很有趣！
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of testing, exceptions, and profiling.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试、异常和性能分析的世界。
- en: I tried to give you a fairly comprehensive overview of testing, especially unit
    testing, which is the kind of testing that a developer mostly does. I hope I have
    succeeded in channeling the message that testing is not something that is perfectly
    defined and that you can learn from a book. You need to experiment with it a lot
    before you get comfortable. Of all the efforts a coder must make in terms of study
    and experimentation, I'd say testing is one of those that are most worth it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图给你一个相当全面的测试概述，特别是单元测试，这是开发者主要进行的测试类型。我希望我已经成功地传达了测试不是完美定义的东西，你可以从书中学习。在感到舒适之前，你需要大量地实验。在程序员必须做出的学习和实验努力中，我认为测试是最值得的之一。
- en: We've briefly seen how we can prevent our program from dying because of errors,
    called exceptions, that happen at runtime. And, to steer away from the usual ground,
    I have given you an example of a somewhat unconventional use of exceptions to
    break out of nested `for` loops. That's not the only case, and I'm sure you'll
    discover others as you grow as a coder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地看到了如何防止我们的程序因为运行时发生的错误，称为异常，而死亡。而且，为了避开常规内容，我给你提供了一个使用异常跳出嵌套`for`循环的不太常规的例子。这并非唯一的情况，我相信随着你作为程序员成长，你还会发现其他情况。
- en: In the end, we very briefly touched base on profiling, with a simple example
    and a few guidelines. I wanted to talk about profiling for the sake of completeness,
    so at least you can play around with it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们非常简要地提到了性能分析，通过一个简单的例子和一些指导方针。我想为了完整性而讨论性能分析，这样你至少可以尝试一下。
- en: We're now about to enter [Chapter 8](ch08.html "Chapter 8. The Edges – GUIs
    and Scripts"), *The Edges – GUIs and Scripts*, where we're going to get our hands
    dirty with scripts and GUIs and, hopefully, come up with something interesting.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在即将进入[第8章](ch08.html "第8章。边缘 – GUI和脚本")，*边缘 – GUI和脚本*，我们将在这里动手处理脚本和GUI，并希望有所发现。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I am aware that I gave you a lot of pointers in this chapter, with no links
    or directions. I'm afraid this is by choice. As a coder, there won't be a single
    day at work when you won't have to look something up in a documentation page,
    in a manual, on a website, and so on. I think it's vital for a coder to be able
    to search effectively for the information they need, so I hope you'll forgive
    me for this extra training. After all, it's all for your benefit.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我在本章中给了你很多提示，但没有提供链接或方向。我恐怕这是出于选择。作为一个程序员，在工作中不会有哪一天不需要在文档页面、手册、网站等地方查找东西。我认为对于程序员来说，能够有效地搜索所需信息是至关重要的，所以我希望你能原谅我这种额外的训练。毕竟，这一切都是为了你的利益。
