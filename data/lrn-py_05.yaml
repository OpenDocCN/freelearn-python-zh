- en: Chapter 5. Saving Time and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：节省时间和内存
- en: '|   | *"It''s not the daily increase but daily decrease. Hack away at the unessential."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"不是每天的增量，而是每天的减量。砍掉不必要的东西。" |   |'
- en: '|   | --*Bruce Lee* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*李小龙* |'
- en: I love this quote from Bruce Lee, he was such a wise man! Especially, the second
    part, *hack away at the unessential*, is to me what makes a computer program elegant.
    After all, if there is a better way of doing things so that we don't waste time
    or memory, why not?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢李小龙的这句话，他是一位非常明智的人！特别是，第二部分“砍掉不必要的东西”，对我来说正是使计算机程序优雅的原因。毕竟，如果我们有更好的做事方式，这样我们就不浪费时间和内存，为什么不呢？
- en: 'Sometimes, there are valid reasons for not pushing our code up to the maximum
    limit: for example, sometimes to achieve a negligible improvement, we have to
    sacrifice on readability or maintainability. Does it make any sense to have a
    web page served in 1 second with unreadable, complicated code, when we can serve
    it in 1.05 seconds with readable, clean code? No, it makes no sense.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，有一些合理的理由不把我们的代码推到最大极限：例如，有时候为了实现微小的改进，我们必须牺牲可读性或可维护性。当我们可以用可读的、干净的代码在1.05秒内提供服务时，为什么还要用1秒内无法阅读的、复杂的代码来提供服务呢？没有，这没有意义。
- en: On the other hand, sometimes it's perfectly licit to try and shave off a millisecond
    from a function, especially when the function is meant to be called thousands
    of times. Every millisecond you save there means one second saved per thousand
    of calls, and this could be meaningful for your application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时尝试从函数中节省一个毫秒是完全合法的，尤其是当这个函数预期会被调用数千次时。你节省的每一个毫秒都意味着在每次调用中节省一秒钟，这对于你的应用程序来说可能是有意义的。
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    "no matter what", but rather, to give you the tools to write efficient, elegant
    code that reads well, runs fast, and doesn't waste resources in an obvious way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，本章的重点不是给你工具来让你的代码无论什么情况下都能达到性能和优化的绝对极限，而是给你工具来编写高效、优雅的代码，这些代码易于阅读，运行速度快，并且不会以明显的方式浪费资源。
- en: 'In this chapter, I will perform several measurements and comparisons, and cautiously
    draw some conclusions. Please do keep in mind that on a different box with a different
    setup or a different operating system, results may vary. Take a look at this code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将进行几次测量和比较，并谨慎地得出一些结论。请务必记住，在不同的机器、不同的设置或不同的操作系统上，结果可能会有所不同。看看这段代码：
- en: '`squares.py`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares.py`'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions return the square of *n*, but which is faster? From a simple
    benchmark I ran on them, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication
    and therefore, whatever algorithm you may use to perform the power operation,
    it''s not likely to beat a simple multiplication like the one in `square2`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都返回*n*的平方，但哪个更快？从我对他们进行的一个简单基准测试来看，第二个似乎稍微快一点。如果你这么想，这是有道理的：计算一个数的幂涉及乘法，因此，无论你使用什么算法来执行幂运算，它都不太可能比`square2`中的简单乘法更快。
- en: Do we care about this result? In most cases no. If you're coding an e-commerce
    website, chances are you won't ever even need to raise a number to the second
    power, and if you do, you probably will have to do it a few times per page. You
    don't need to concern yourself on saving a few microseconds on a function you
    call a few times.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否关心这个结果？在大多数情况下不关心。如果你正在编写一个电子商务网站，你很可能永远不需要将一个数字提高到平方，即使你需要这样做，你可能也只是在每一页上做几次。你不需要担心在一个只调用几次的函数上节省几微秒。
- en: So, when does optimization become important? One very common case is when you
    have to deal with huge collections of data. If you're applying the same function
    on a million `customer` objects, then you want your function to be tuned up to
    its best. Gaining 1/10 of a second on a function called one million times saves
    you 100,000 seconds, which are about 27.7 hours. That's not the same, right? So,
    let's focus on collections, and let's see which tools Python gives you to handle
    them with efficiency and grace.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时优化变得重要呢？一个非常常见的例子是当你必须处理大量数据时。如果你要对一百万个`customer`对象应用相同的函数，那么你希望你的函数调优到最佳状态。在一个被调用一百万次的函数上节省1/10秒可以为你节省100,000秒，这大约是27.7小时。这难道不是一样的吗？所以，让我们专注于集合，看看Python提供了哪些工具来高效且优雅地处理它们。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the concepts we will see in this chapter are based on those of **iterator**
    and **iterable**. Simply put, the ability for an object to return its next element
    when asked, and to raise a `StopIteration` exception when exhausted. We'll see
    how to code a custom iterator and iterable objects in the next chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的大部分概念都基于 **迭代器** 和 **可迭代对象** 的概念。简单来说，就是对象在被询问时返回其下一个元素的能力，以及在耗尽时引发
    `StopIteration` 异常的能力。我们将在下一章中看到如何编写自定义的迭代器和可迭代对象。
- en: map, zip, and filter
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map, zip, 和 filter
- en: 'We''ll start by reviewing `map`, `filter`, and `zip`, which are the main built-in
    functions one can employ when handling collections, and then we''ll learn how
    to achieve the same results using two very important constructs: **comprehensions**
    and **generators**. Fasten your seat belt!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾 `map`、`filter` 和 `zip`，这些是在处理集合时可以使用的内置函数的主要函数，然后我们将学习如何使用两个非常重要的结构来实现相同的结果：**列表推导式**
    和 **生成器**。系好安全带！
- en: map
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map
- en: 'According to the official Python documentation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方 Python 文档：
- en: '*`map(function, iterable, ...)` returns an iterator that applies function to
    every item of iterable, yielding the results. If additional iterable arguments
    are passed, function must take that many arguments and is applied to the items
    from all iterables in parallel. With multiple iterables, the iterator stops when
    the shortest iterable is exhausted.*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`map(function, iterable, ...)` 返回一个迭代器，它将函数应用到可迭代对象的每个元素上，并产生结果。如果传递了额外的可迭代参数，函数必须接受那么多参数，并且将并行应用于所有可迭代对象的元素。如果有多个可迭代对象，迭代器会在最短的迭代对象耗尽时停止。*'
- en: 'We will explain the concept of yielding later on in the chapter. For now, let''s
    translate this into code: we''ll use a *lambda* function that takes a variable
    number of positional arguments, and just returns them as a tuple. Also, as `map`
    returns an iterator, we''ll need to wrap each call to it within a `list` constructor
    so that we exhaust the iterable by putting all of its elements into a list (you''ll
    see an example of this in the code):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释 `yielding` 的概念。现在，让我们将其转换为代码：我们将使用一个接受可变数量位置参数的 *lambda* 函数，并仅将它们作为元组返回。此外，由于
    `map` 返回一个迭代器，我们需要在 `list` 构造函数中包装对它的每个调用，以便通过将所有元素放入列表来耗尽可迭代对象（你将在代码中看到一个例子）：
- en: '`map.example.py`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`map.example.py`'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code you can see why, in order to present you with the results,
    I have to wrap the calls to `map` within a `list` constructor, otherwise I get
    the string representation of a `map` object, which is not really useful in this
    context, is it?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到为什么，为了向你展示结果，我必须将 `map` 的调用包装在 `list` 构造函数中，否则我会得到一个 `map` 对象的字符串表示，这在当前上下文中并不是很有用，对吧？
- en: 'You can also notice how the elements of each iterable are applied to the function:
    at first, the first element of each iterable, then the second one of each iterable,
    and so on. Notice also that map stops when the shortest of the iterables we called
    it with is exhausted. This is actually a very nice behavior: it doesn''t force
    us to level off all the iterables to a common length, and it doesn''t break if
    they aren''t all the same length.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以注意到每个可迭代对象的元素是如何应用到函数上的：首先，每个可迭代对象的第一元素，然后是每个可迭代对象的第二个元素，依此类推。还要注意，当使用 `map`
    的可迭代对象中最短的一个耗尽时，`map` 会停止。这实际上是一个非常棒的行为：它不会强迫我们将所有可迭代对象都调整到相同的长度，而且如果它们的长度不相同，它也不会出错。
- en: '`map` is very useful when you have to apply the same function to one or more
    collections of objects. As a more interesting example, let''s see the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform**). It''s a technique that was extremely
    popular when Python sorting wasn''t providing *key-functions*, and therefore today
    is less used, but it''s a cool trick that still comes at hand once in a while.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将相同的函数应用到一组或多个对象集合上时，`map` 非常有用。作为一个更有趣的例子，让我们看看 **decorate-sort-undecorate**
    习语（也称为 **Schwartzian 转换**）。这是一种在 Python 排序不提供 *key-functions* 时非常流行的技术，因此今天使用较少，但它是一个偶尔仍然有用的巧妙技巧。
- en: 'Let''s see a variation of it in the next example: we want to sort in descending
    order by the sum of credits accumulated by students, so to have the best student
    at position 0\. We write a function to produce a decorated object, we sort, and
    then we undecorate. Each student has credits in three (possibly different) subjects.
    To decorate an object means to transform it, either adding extra data to it, or
    putting it into another object, in a way that allows us to be able to sort the
    original objects the way we want. After the sorting, we revert the decorated objects
    to get the original ones from them. This is called to undecorate.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个例子中看看它的一个变体：我们想要根据学生累积的学分总和进行降序排序，以便将最佳学生放在位置 0。我们编写一个函数来生成装饰对象，然后排序，然后取消装饰。每个学生有三个（可能不同的）科目学分。装饰一个对象意味着对其进行转换，要么向其添加额外数据，要么将其放入另一个对象中，以便我们能够以我们想要的方式对原始对象进行排序。排序后，我们将装饰对象恢复以获取原始对象。这被称为取消装饰。
- en: '`decorate.sort.undecorate.py`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorate.sort.undecorate.py`'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, I highlighted the tricky and important parts. Let''s
    start by understanding what each student object is. In fact, let''s print the
    first one:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我突出了棘手和重要的部分。让我们首先了解每个学生对象是什么。事实上，让我们打印第一个：
- en: '`{''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'': 0}`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`{''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'': 0}`'
- en: 'You can see that it''s a dictionary with two keys: `id` and `credit`. The value
    of `credit` is also a dictionary in which there are three subject/grade key/value
    pairs. As I''m sure you recall from our visit in the data structures world, calling
    `dict.values()` returns an object similar to an `iterable`, with only the values.
    Therefore, `sum(student[''credits''].values())`, for the first student is equivalent
    to `sum(9, 6, 7)` (or any permutation of those numbers because dictionaries don''t
    retain order, but luckily for us, addition is commutative).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这是一个包含两个键的字典：`id` 和 `credit`。`credit` 的值也是一个字典，其中包含三个科目/成绩的键/值对。我相信你从我们在数据结构世界中的访问中还记得，调用
    `dict.values()` 返回一个类似于 `iterable` 的对象，只包含值。因此，对于第一个学生，`sum(student['credits'].values())`
    等同于 `sum(9, 6, 7)`（或者这些数字的任何排列，因为字典不保留顺序，但幸运的是，加法是交换的）。
- en: 'With that out of the way, it''s easy to see what is the result of calling decorate
    with any of the students. Let''s print the result of `decorate(students[0])`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个问题之后，很容易看出调用装饰函数后会发生什么。让我们打印 `decorate(students[0])` 的结果：
- en: '`(22, {''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'':
    0})`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`(22, {''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'':
    0})`'
- en: That's nice! If we decorate all the students like this, we can sort them on
    their total amount of credits but just sorting the list of tuples. In order to
    apply the decoration to each item in students, we call `map(decorate, students)`.
    Then we sort the result, and then we undecorate in a similar fashion. If you have
    gone through the previous chapters correctly, understanding this code shouldn't
    be too hard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！如果我们这样装饰所有学生，我们就可以根据他们的总学分对他们进行排序，但只需对元组列表进行排序。为了将装饰应用于学生中的每个项目，我们调用 `map(decorate,
    students)`。然后我们排序结果，然后以类似的方式取消装饰。如果你正确地完成了前面的章节，理解这段代码不应该太难。
- en: 'Printing students after running the whole code yields:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行整个代码后打印学生信息：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And you can see, by the order of the student objects, that they have indeed
    been sorted by the sum of their credits.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，按照学生对象的顺序，它们确实是根据它们的学分总和进行了排序。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more on the *decorate-sort-undecorate* idiom, there's a very nice introduction
    in the sorting how-to section of the official Python documentation ([https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `decorate-sort-undecorate` 习语的更多信息，可以在官方 Python 文档的排序如何做部分中找到一个非常好的介绍（[https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)）。
- en: 'One thing to notice about the sorting part: what if two or more students share
    the same total sum? The sorting algorithm would then proceed sorting the tuples
    by comparing the `student` objects with each other. This doesn''t make any sense,
    and in more complex cases could lead to unpredictable results, or even errors.
    If you want to be sure to avoid this issue, one simple solution is to create a
    3-tuple instead of a 2-tuple, having the sum of credits in the first position,
    the position of the `student` object in the `students` list in the second one,
    and the `student` object itself in the third one. This way, if the sum of credits
    is the same, the tuples will be sorted against the position, which will always
    be different and therefore enough to resolve the sorting between any pair of tuples.
    For more considerations on this topic, please check out the sorting how-to section
    on the official Python documentation.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排序部分有一点需要注意：如果有两个或更多学生的总分相同，排序算法将按比较 `student` 对象进行排序。这没有任何意义，在更复杂的情况下可能会导致不可预测的结果，甚至错误。如果你想要确保避免这个问题，一个简单的解决方案是创建一个
    3-元组而不是 2-元组，第一个位置是学分的总和，第二个位置是 `students` 列表中 `student` 对象的位置，第三个位置是 `student`
    对象本身。这样，如果学分的总和相同，元组将按位置排序，这总是不同的，因此足以解决任何一对元组之间的排序。关于这个主题的更多考虑，请查看官方Python文档中的排序如何操作部分。
- en: zip
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zip
- en: We've already covered `zip` in the previous chapters, so let's just define it
    properly and then I want to show you how you could combine it with `map`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中介绍了 `zip`，所以让我们正确地定义它，然后我想向你展示如何将它与 `map` 结合使用。
- en: 'According to the Python documentation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: '*`zip(*iterables)` returns an iterator of tuples, where the i-th tuple contains
    the i-th element from each of the argument sequences or iterables. The iterator
    stops when the shortest input iterable is exhausted. With a single iterable argument,
    it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`zip(*iterables)` 返回一个元组的迭代器，其中第 i 个元组包含每个参数序列或可迭代对象的第 i 个元素。当最短的输入可迭代对象耗尽时，迭代器停止。如果只有一个可迭代对象参数，它返回一个
    1-元组迭代器。如果没有参数，它返回一个空迭代器。*'
- en: 'Let''s see an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '`zip.grades.py`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip.grades.py`'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we're zipping together the average and the grade for
    the last exam, per each student. Notice how the code inside the two list calls
    produces exactly the same result, showing how easy it is to reproduce `zip` using
    `map`. Notice also that, as we do for `map`, we have to feed the result of the
    `zip` call to a `list` constructor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将平均分和最后考试的分数按每个学生进行组合。注意代码在两个列表调用中产生的结果完全相同，展示了如何轻松地通过 `map` 重新生成
    `zip`。注意，正如我们对 `map` 所做的那样，我们必须将 `zip` 调用的结果传递给列表构造函数。
- en: 'A simple example on the combined use of `map` and `zip` could be a way of calculating
    the element-wise maximum amongst sequences, that is, the maximum of the first
    element of each sequence, then the maximum of the second one, and so on:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `zip` 结合使用的一个简单例子可以是计算序列中元素的最大值，即每个序列的第一个元素的最大值，然后是第二个元素的最大值，依此类推：'
- en: '`maxims.py`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxims.py`'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how easy it is to calculate the max values of three sequences. `zip`
    is not strictly needed of course, we could just use `map`, but this would require
    us to write a much more complicated function to feed `map` with. Sometimes we
    may be in a situation where changing the function we feed to `map` is not even
    possible. In cases like these, being able to massage the data (like we're doing
    in this example with `zip`) is very helpful.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意计算三个序列的最大值是多么容易。当然，`zip` 不是必需的，我们也可以只使用 `map`，但这将需要我们编写一个更复杂的函数来提供给 `map`。有时我们可能处于无法更改提供给
    `map` 的函数的情况。在这种情况下，能够处理数据（就像我们在本例中使用 `zip` 所做的那样）非常有帮助。
- en: filter
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter
- en: 'According to the Python documentation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: '*`filter(function, iterable)` construct an iterator from those elements of
    iterable for which function returns True. iterable may be either a sequence, a
    container which supports iteration, or an iterator. If function is `None`, the
    identity function is assumed, that is, all elements of iterable that are false
    are removed.*'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`filter(function, iterable)` 从那些函数返回 True 的可迭代对象元素中构建一个迭代器。可迭代对象可以是序列，支持迭代的容器，或迭代器。如果函数是
    `None`，则假定身份函数，即移除可迭代对象中所有为假的元素。*'
- en: 'Let''s see a very quick example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常快速的例子：
- en: '`filter.py`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter.py`'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, notice how the second call to filter is equivalent to
    the first one. If we pass a function that takes one argument and returns the argument
    itself, only those arguments that are `True` will make the function return `True`,
    therefore this behavior is exactly the same as passing `None`. It's often a very
    good exercise to mimic some of the built-in Python behaviors. When you succeed
    you can say you fully understand how Python behaves in a specific situation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意第二个`filter`调用与第一个是等价的。如果我们传递一个只接受一个参数并返回该参数本身的函数，只有那些返回`True`的参数才会使函数返回`True`，因此这种行为与传递`None`完全相同。模仿一些内置的Python行为通常是一个非常有益的练习。当你成功时，你可以说你完全理解了Python在特定情况下的行为。
- en: 'Armed with `map`, `zip`, and `filter` (and several other functions from the
    Python standard library) we can massage sequences very effectively. But those
    functions are not the only way to do it. So let''s see one of the nicest features
    of Python: comprehensions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`map`、`zip`和`filter`（以及Python标准库中的几个其他函数），我们可以非常有效地处理序列。但这些都是做这件事的方法之一。所以让我们看看Python最漂亮的功能之一：推导式。
- en: Comprehensions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导式
- en: 'Python offers you different types of comprehensions: `list`, `dict`, and `set`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python为你提供了不同类型的推导式：`list`、`dict`和`set`。
- en: We'll concentrate on the first one for now, and then it will be easy to explain
    the other two.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在先关注第一个，然后解释其他两个就会容易得多。
- en: A `list` comprehension is a quick way of making a list. Usually the list is
    the result of some operation that may involve applying a function, filtering,
    or building a different data structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是快速创建列表的一种方法。通常列表是某些操作的结果，这些操作可能涉及应用函数、过滤或构建不同的数据结构。
- en: 'Let''s start with a very simple example I want to calculate a list with the
    squares of the first 10 natural numbers. How would you do it? There are a couple
    of equivalent ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始，我想计算前10个自然数的平方列表。你会怎么做？有几个等效的方法：
- en: '`squares.map.py`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares.map.py`'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding example should be nothing new for you. Let''s see how to achieve
    the same result using a list comprehension:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例对你来说应该不是什么新鲜事。让我们看看如何使用列表推导式达到相同的结果：
- en: '`squares.comprehension.py`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares.comprehension.py`'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As simple as that. Isn't it elegant? Basically we have put a `for` loop within
    square brackets. Let's now filter out the odd squares. I'll show you how to do
    it with `map` and `filter`, and then using a `list` comprehension again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。难道这不优雅吗？基本上我们是在方括号内放置了一个`for`循环。现在让我们过滤掉奇数平方。我会用`map`和`filter`来展示如何做，然后再用列表推导式来做。
- en: '`even.squares.py`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`even.squares.py`'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I think that now the difference in readability is evident. The list comprehension
    reads much better. It''s almost English: give me all squares (*n ** 2*) for *n*
    between 0 and 9 if n is even.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在可读性的差异应该是显而易见的。列表推导式读起来要好得多。它几乎就像是英语：给我所有0到9之间偶数的平方（*n ** 2*）。
- en: 'According to the Python documentation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: '*A list comprehension consists of brackets containing an expression followed
    by a `for` clause, then zero or more `for` or `if` clauses. The result will be
    a new list resulting from evaluating the expression in the context of the `for`
    and `if` clauses which follow it".*'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*列表推导式由包含一个表达式和随后的`for`子句的括号组成，然后是零个或多个`for`或`if`子句。结果将是一个新列表，该列表是在`for`和`if`子句的上下文中评估表达式后得到的。*'
- en: Nested comprehensions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套推导式
- en: Let's see an example of nested loops. It's very common when dealing with algorithms
    to have to iterate on a sequence using two placeholders. The first one runs through
    the whole sequence, left to right. The second one as well, but it starts from
    the first one, instead of 0\. The concept is that of testing all pairs without
    duplication. Let's see the classical `for` loop equivalent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看嵌套循环的一个例子。在处理算法时，通常需要使用两个占位符来迭代一个序列。第一个占位符从左到右遍历整个序列。第二个占位符也是如此，但它从第一个占位符开始，而不是从0开始。这个概念是测试所有成对而不重复。让我们看看经典的`for`循环等效。
- en: '`pairs.for.loop.py`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs.for.loop.py`'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you print pairs at the end, you get:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你最后打印出成对的数据，你会得到：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All the tuples with the same letter are those for which `b` is at the same
    position as `a`. Now, let''s see how we can translate this in a list comprehension:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同字母的元组都是那些`b`在相同位置于`a`的元组。现在，让我们看看我们如何将这个翻译成列表推导式：
- en: '`pairs.list.comprehension.py`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs.list.comprehension.py`'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This version is just two lines long and achieves the same result. Notice that
    in this particular case, because the `for` loop over `b` has a dependency on `a`,
    it must follow the `for` loop over `a` in the comprehension. If you swap them
    around, you'll get a name error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只有两行长，但达到了相同的效果。注意，在这个特定的情况下，因为`for`循环对`b`的遍历依赖于`a`，所以在推导式中它必须跟在`for`循环对`a`的遍历之后。如果你交换它们的位置，你会得到一个命名错误。
- en: Filtering a comprehension
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤推导式
- en: We can apply filtering to a comprehension. Let's first do it with `filter`.
    Let's find all Pythagorean triples whose short sides are numbers smaller than
    10\. We obviously don't want to test a combination twice, and therefore we'll
    use a trick like the one we saw in the previous example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将过滤应用于推导式。让我们首先使用`filter`来做。让我们找到所有短边小于10的勾股数。显然，我们不希望测试两次相同的组合，因此我们将使用我们在上一个例子中看到的那种技巧。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **Pythagorean triple** is a triple (*a*, *b*, *c*) of integer numbers satisfying
    the equation ![Filtering a comprehension](img/4715_05_03.jpg).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**勾股数**是一个整数三元组(*a*, *b*, *c*)，满足方程![过滤推导式](img/4715_05_03.jpg)。'
- en: '`pythagorean.triple.py`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`pythagorean.triple.py`'
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we generated a list of *3-tuples*, legs. Each tuple contains
    two integer numbers (the legs) and the hypotenuse of the Pythagorean triangle
    whose legs are the first two numbers in the tuple. For example, when a = 3 and
    b = 4, the tuple will be (3, 4, 5.0), and when a = 5 and b = 7, the tuple will
    be (5, 7, 8.602325267042627).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了一组*三元组*，即边长。每个元组包含两个整数（边长）和勾股三角形的斜边，其边长是元组中的前两个数字。例如，当a = 3且b =
    4时，元组将是(3, 4, 5.0)，当a = 5且b = 7时，元组将是(5, 7, 8.602325267042627)。
- en: After having all the triples done, we need to filter out all those that don't
    have a hypotenuse that is an integer number. In order to do this, we filter based
    on `float_number.is_integer()` being `True`. This means that of the two example
    tuples I showed you before, the one with hypotenuse 5.0 will be retained, while
    the one with hypotenuse 8.602325267042627 will be discarded.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成所有三元组之后，我们需要过滤掉那些斜边不是整数的所有三元组。为了做到这一点，我们基于`float_number.is_integer()`为`True`进行过滤。这意味着在我之前给你展示的两个示例元组中，斜边为5.0的那个将被保留，而斜边为8.602325267042627的那个将被丢弃。
- en: 'This is good, but I don''t like that the triple has two integer numbers and
    a float. They are supposed to be all integers, so let''s use map to fix this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我不喜欢三元组中有两个整数和一个浮点数。它们应该都是整数，所以让我们使用`map`来修复这个问题：
- en: '`pythagorean.triple.int.py`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`pythagorean.triple.int.py`'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice the step we added. We take each element in legs and we slice it, taking
    only the first two elements in it. Then, we concatenate the slice with a 1-tuple,
    in which we put the integer version of that float number that we didn't like.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加的步骤。我们取`legs`中的每个元素，并从中切片，只取其中的前两个元素。然后，我们将这个切片与一个1元组连接起来，在这个1元组中，我们放那个我们不喜欢的浮点数的整数版本。
- en: 'Seems like a lot of work, right? Indeed it is. Let''s see how to do all this
    with a list comprehension:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来要做很多工作，对吧？确实如此。让我们看看如何使用列表推导式来完成所有这些：
- en: '`pythagorean.triple.comprehension.py`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pythagorean.triple.comprehension.py`'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I know. It's much better, isn't it? It's clean, readable, shorter. In other
    words, elegant.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道。它好多了，不是吗？它干净、易读、更短。换句话说，优雅。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I'm going quite fast here, as anticipated in the summary of the last chapter.
    Are you playing with this code? If not, I suggest you do. It's very important
    that you play around, break things, change things, see what happens. Make sure
    you have a clear understanding of what is going on. You want to become a ninja,
    right?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里走得很快，正如上一章总结中预期的那样。你在玩这个代码吗？如果不是，我建议你试试。重要的是你要玩一玩，破坏一些东西，改变一些东西，看看会发生什么。确保你对正在发生的事情有清晰的理解。你想要成为一个忍者，对吧？
- en: dict comprehensions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'Dictionary and set comprehensions work exactly like the list ones, only there
    is a little difference in the syntax. The following example will suffice to explain
    everything you need to know:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字典和集合推导式的工作方式与列表推导式完全一样，只是在语法上有一点不同。以下示例将足以解释你需要知道的一切：
- en: '`dictionary.comprehensions.py`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictionary.comprehensions.py`'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you print `lettermap`, you will see the following (I omitted the middle
    results, you get the gist):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印`lettermap`，你会看到以下内容（我省略了中间结果，你得到的是要点）：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What happens in the preceding code is that we''re feeding the `dict` constructor
    with a comprehension (technically, a generator expression, we''ll see it in a
    bit). We tell the `dict` constructor to make *key/value* pairs from each tuple
    in the comprehension. We enumerate the sequence of all lowercase ASCII letters,
    starting from *1*, using `enumerate`. Piece of cake. There is also another way
    to do the same thing, which is closer to the other dictionary syntax:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生的情况是，我们正在向 `dict` 构造函数提供了一个推导式（技术上，是一个生成器表达式，我们稍后会看到）。我们告诉 `dict` 构造函数从推导式中的每个元组中创建
    *键/值* 对。我们使用 `enumerate` 对所有小写ASCII字母的序列进行枚举，从 *1* 开始。小菜一碟。还有另一种做同样事情的方法，这更接近其他字典语法：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It does exactly the same thing, with a slightly different syntax that highlights
    a bit more of the *key: value* part.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '它做的是完全相同的事情，但语法略有不同，这更多地突出了 *键: 值* 部分。'
- en: 'Dictionaries do not allow duplication in the keys, as shown in the following
    example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不允许键的重复，如下面的例子所示：
- en: '`dictionary.comprehensions.duplicates.py`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictionary.comprehensions.duplicates.py`'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We create a dictionary with keys, the letters in the string `''Hello''`, and
    values of the same letters, but with the case swapped. Notice there is only one
    `''l'': ''L''` pair. The constructor doesn''t complain, simply reassigns duplicates
    to the latest value. Let''s make this clearer with another example; let''s assign
    to each key its position in the string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建了一个字典，键是字符串 `''Hello''` 中的字母，值是相同字母的大小写互换。注意只有一个 `''l'': ''L''` 对。构造函数不会抱怨，只是简单地重新分配重复项到最新的值。让我们用另一个例子来使这更清晰；让我们将每个键分配到其在字符串中的位置：'
- en: '`dictionary.comprehensions.positions.py`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictionary.comprehensions.positions.py`'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the value associated to the letter `''l'': 3`. The pair `''l'': 2` isn''t
    there, it has been overridden by `''l'': 3`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '注意与字母 `''l''` 关联的值是 `3`。对 `''l'': 2` 并不存在，它已被 `''l'': 3` 覆盖。'
- en: set comprehensions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'Set comprehensions are very similar to list and dictionary ones. Python allows
    both the `set()` constructor to be used, or the explicit `{}` syntax. Let''s see
    one quick example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式与列表和字典推导式非常相似。Python 允许使用 `set()` 构造函数或显式的 `{}` 语法。让我们看一个快速示例：
- en: '`set.comprehensions.py`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`set.comprehensions.py`'
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how for set comprehensions, as for dictionaries, duplication is not allowed
    and therefore the resulting set has only four letters. Also, notice that the expressions
    assigned to `letters1` and `letters2` produce equivalent sets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对于集合推导式，就像对于字典一样，不允许重复，因此生成的集合只有四个字母。此外，注意分配给 `letters1` 和 `letters2` 的表达式产生了等效的集合。
- en: The syntax used to create `letters2` is very similar to the one we can use to
    create a dictionary comprehension. You can spot the difference only by the fact
    that dictionaries require keys and values, separated by columns, while sets don't.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `letters2` 所使用的语法与我们用来创建字典推导式的语法非常相似。你只能通过以下事实来区分它们：字典需要通过列分隔的键和值，而集合不需要。
- en: Generators
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Generators** are one very powerful tool that Python gifts us with. They are
    based on the concepts of *iteration*, as we said before, and they allow for coding
    patterns that combine elegance with efficiency.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是Python赋予我们的一种非常强大的工具。它们基于我们之前提到的 *迭代* 概念，并允许结合优雅和效率的编码模式。'
- en: 'Generators are of two types:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有两种类型：
- en: '**Generator functions**: These are very similar to regular functions, but instead
    of returning results through return statements, they use yield, which allows them
    to suspend and resume their state between each call'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器函数**：这些与常规函数非常相似，但它们不是通过返回语句返回结果，而是使用 `yield`，这使得它们可以在每次调用之间暂停和恢复其状态'
- en: '**Generator expressions**: These are very similar to the list comprehensions
    we''ve seen in this chapter, but instead of returning a list they return an object
    that produces results one by one'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：这些与我们在本章中看到的列表推导式非常相似，但它们返回的是一个对象，该对象一次产生一个结果'
- en: Generator functions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: '**Generator functions** come under all aspects like regular functions, with
    one difference: instead of collecting results and returning them at once, they
    can start the computation, yield one value, suspend their state saving everything
    they need to be able to resume and, if called again, resume and perform another
    step. Generator functions are automatically turned into their own iterators by
    Python, so you can call `next` on them.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器函数**在所有方面都类似于常规函数，只有一个区别：它们不是一次性收集结果并返回，而是可以开始计算，产生一个值，暂停其状态，保存所有需要能够恢复的信息，如果再次被调用，则恢复并执行另一个步骤。Python会自动将生成器函数转换为它们自己的迭代器，因此你可以对它们调用`next`。'
- en: This is all very theoretical so, let's make it clear why such a mechanism is
    so powerful, and then let's see an example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是非常理论性的，所以，让我们明确一下这种机制为什么如此强大，然后让我们看看一个例子。
- en: Say I asked you to count out loud from 1 to a million. You start, and at some
    point I ask you to stop. After some time, I ask you to resume. At this point,
    what is the minimum information you need to be able to resume correctly? Well,
    you need to remember the last number you called. If I stopped you after 31415,
    you will just go on with 31416, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我让你大声从1数到一百万。你开始数，在某个时候我让你停下来。过了一段时间，我让你继续。在这个时候，你至少需要记住哪个数字才能正确地继续？好吧，你需要记住你最后叫的数字。如果我让你在31415之后停下来，你将直接从31416开始，以此类推。
- en: The point is, you don't need to remember all the numbers you said before 31415,
    nor do you need them to be written down somewhere. Well, you may not know it,
    but you're behaving like a generator already!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，你不需要记住你之前说的所有数字，也不需要将它们写下来。好吧，你可能不知道，但你已经在像生成器一样行事了！
- en: 'Take a good look at the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看下面的代码：
- en: '`first.n.squares.py`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`first.n.squares.py`'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result of the prints will be the same: `[0, 1, 4, 9, 16, 25, 36, 49, 64,
    81]`. But there is a huge difference between the two functions. `get_squares`
    is a classic function that collects all the squares of numbers in [0, *n*) in
    a list, and returns it. On the other hand, `get_squares_gen` is a generator, and
    behaves very differently. Each time the interpreter reaches the `yield` line,
    its execution is suspended. The only reason those prints return the same result
    is because we fed `get_squares_gen` to the `list` constructor, which when called
    like that exhausts the generator completely by asking the next element until a
    `StopIteration` is raised. Let''s see this in detail:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的结果将会相同：`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`。但是这两个函数之间有一个巨大的区别。`get_squares`是一个经典的函数，它将[0,
    *n*)区间内所有数的平方收集到一个列表中，并返回它。另一方面，`get_squares_gen`是一个生成器，其行为非常不同。每次解释器到达`yield`行时，其执行就会暂停。那些打印返回相同结果的原因仅仅是因为我们将`get_squares_gen`传递给了`list`构造函数，这样它会完全耗尽生成器，通过请求下一个元素直到抛出`StopIteration`异常。让我们详细看看：
- en: '`first.n.squares.manual.py`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`first.n.squares.manual.py`'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, each time we call `next` on the generator object, we
    either start it (first `next`) or make it resume from the last suspension point
    (any other `next`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次我们对生成器对象调用`next`时，我们要么启动它（第一次`next`），要么从最后一个暂停点恢复（任何其他的`next`）。
- en: The first time we call `next` on it, we get `0`, which is the square of `0`,
    then `1`, then `4`, then `9` and since the `for` loop stops after that (`n` is
    `4`), then the generator naturally ends. A classic function would at that point
    just return `None`, but in order to comply with the iteration protocol, a generator
    will instead raise a `StopIteration` exception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用它的`next`方法时，我们得到`0`，这是`0`的平方，然后是`1`，然后是`4`，然后是`9`。由于`for`循环在`n`为`4`之后停止，因此生成器自然结束。在这一点上，一个经典的函数会直接返回`None`，但为了遵守迭代协议，生成器会抛出一个`StopIteration`异常。
- en: This explains how a `for` loop works for example. When you call `for k in range(n)`,
    what happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了例如`for`循环是如何工作的。当你调用`for k in range(n)`时，在底层发生的事情是`for`循环从`range(n)`中获取一个迭代器，并开始对其调用`next`，直到抛出`StopIteration`异常，这告诉`for`循环迭代已经达到其结束。
- en: Having this behavior built-in in every iteration aspect of Python makes generators
    even more powerful because once we write them, we'll be able to plug them in whatever
    iteration mechanism we want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的每个迭代方面都内置这种行为使得生成器更加强大，因为一旦我们编写了它们，我们就能将它们插入到我们想要的任何迭代机制中。
- en: 'At this point, you''re probably asking yourself why would you want to use a
    generator instead of a regular function. Well, the title of this chapter should
    suggest the answer. I''ll talk about performances later, so for now let''s concentrate
    on another aspect: sometimes generators allow you to do something that wouldn''t
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has length *N*, then the number of its permutations
    is *N!*. This means that if the sequence is 10 elements long, the number of permutations
    is 3628800\. But a sequence of 20 elements would have 2432902008176640000 permutations.
    They grow factorially.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能自己在想，为什么你想使用生成器而不是普通函数。嗯，这一章的标题应该能暗示答案。我会在后面讨论性能，但现在让我们集中关注另一个方面：有时生成器允许你做一些用简单列表不可能做到的事情。例如，假设你想分析一个序列的所有排列。如果序列的长度是
    *N*，那么它的排列数是 *N!*。这意味着如果序列有10个元素，排列数是3628800。但是一个有20个元素的序列将有2432902008176640000个排列。它们以阶乘的方式增长。
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few tens of seconds, but for 20 elements there is simply no
    way that it can be done.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个经典函数，它试图计算所有排列，将它们放入一个列表中，然后返回给你。对于10个元素，可能需要几秒钟，但对于20个元素，根本无法完成。
- en: On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course
    you won't have the time to parse them all, they are too many, but at least you'll
    be able to work with some of them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，生成器函数将能够开始计算，并给你返回第一个排列，然后是第二个，依此类推。当然，你不会有时间去解析它们，因为它们太多了，但至少你将能够处理其中的一些。
- en: Remember when we were talking about the `break` statement in `for` loops? When
    we found a number dividing a *candidate prime* we were breaking the loop, no need
    to go on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前讨论`for`循环中的`break`语句吗？当我们找到一个可以整除**候选素数**的数时，我们会中断循环，没有必要继续下去。
- en: 'Sometimes it''s exactly the same, only the amount of data you have to iterate
    over is so huge that you cannot keep it all in memory in a list. In this case,
    generators are invaluable: they make possible what wouldn''t be possible otherwise.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候情况完全相同，只是你需要迭代的数量数据太大了，你无法将它们全部保存在列表中。在这种情况下，生成器是无价的：它们使得原本不可能的事情成为可能。
- en: So, in order to save memory (and time), use generator functions whenever possible.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了节省内存（和时间），尽可能使用生成器函数。
- en: 'It''s also worth noting that you can use the return statement in a generator
    function. It will produce a `StopIteration` exception to be raised, effectively
    ending the iteration. This is extremely important. If a `return` statement were
    actually to make the function return something, it would break the iteration protocol.
    Python consistency prevents this, and allows us great ease when coding. Let''s
    see a quick example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，你可以在生成器函数中使用`return`语句。它将产生一个`StopIteration`异常，从而有效地结束迭代。这非常重要。如果`return`语句实际上使函数返回某些内容，它将破坏迭代协议。Python的一致性防止了这种情况，并在编码时为我们提供了极大的便利。让我们看一个快速示例：
- en: '`gen.yield.return.py`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.yield.return.py`'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code yields all terms of the geometric progression *a*, *aq*,
    ![Generator functions](img/4715_05_01.jpg), ![Generator functions](img/4715_05_02.jpg),
    .... When the progression produces a term that is greater than 100,000, the generator
    stops (with a `return` statement). Running the code produces the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成了几何级数的所有项 *a*，*aq*，![生成器函数](img/4715_05_01.jpg)，![生成器函数](img/4715_05_02.jpg)，...
    当级数产生一个大于100,000的项时，生成器停止（使用`return`语句）。运行代码会产生以下结果：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The next term would have been 156250, which is too big.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项将是156250，这太大了。
- en: Going beyond next
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越下一个
- en: At the beginning of this chapter, I told you that generator objects are based
    on the iteration protocol. We'll see in the next chapter a complete example of
    how to write a custom iterator/iterable object. For now, I just want you to understand
    how `next()` works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我告诉过你，生成器对象基于迭代协议。我们将在下一章看到一个如何编写自定义迭代器/可迭代对象的完整示例。现在，我只是想让你理解`next()`是如何工作的。
- en: What happens when you call `next(generator)` is that you're calling the `generator.__next__()`
    method. Remember, a **method** is just a function that belongs to an object, and
    objects in Python can have special methods. Our friend `__next__()` is just one
    of these and its purpose is to return the next element of the iteration, or to
    raise `StopIteration` when the iteration is over and there are no more elements
    to return.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `next(generator)` 时，实际上是在调用 `generator.__next__()` 方法。记住，**方法**只是属于一个对象的功能，Python
    中的对象可以有特殊方法。我们的朋友 `__next__()` 就是其中之一，它的目的是返回迭代中的下一个元素，或者当迭代结束时没有更多元素返回时抛出 `StopIteration`
    异常。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python, an object's special methods are also called **magic methods**, or
    **dunder** (from "double underscore") **methods**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一个对象的特殊方法也被称为 **魔法方法**，或 **双下划线** **方法**。
- en: 'When we write a generator function, Python automatically transforms it into
    an object that is very similar to an iterator, and when we call `next(generator)`,
    that call is transformed in `generator.__next__()`. Let''s revisit the previous
    example about generating squares:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个生成器函数时，Python 会自动将其转换成一个与迭代器非常相似的对象，当我们调用 `next(generator)` 时，这个调用会被转换成
    `generator.__next__()`。让我们回顾一下之前关于生成平方数的示例：
- en: '`first.n.squares.manual.method.py`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`first.n.squares.manual.method.py`'
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The result is exactly as the previous example, only this time instead of using
    the proxy call `next(squares)`, we're directly calling `squares.__next__()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与上一个示例完全相同，只是这次我们没有使用代理调用 `next(squares)`，而是直接调用 `squares.__next__()`。
- en: 'Generator objects have also three other methods that allow controlling their
    behavior: `send`, `throw`, and `close`. `send` allows us to communicate a value
    back to the generator object, while `throw` and `close` respectively allow raising
    an exception within the generator and closing it. Their use is quite advanced
    and I won''t be covering them here in detail, but I want to spend a few words
    at least about `send`, with a simple example.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象还有三个其他方法可以用来控制其行为：`send`、`throw` 和 `close`。`send` 允许我们向生成器对象发送一个值，而 `throw`
    和 `close` 分别允许在生成器内部抛出异常和关闭它。它们的使用相当高级，这里不会详细讲解，但我想至少简单地说一下 `send`，以下是一个简单的例子。
- en: 'Take a look at the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '`gen.send.preparation.py`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.send.preparation.py`'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, it will never stop. Alternatively, you can put it in a `for`
    loop, for example, `for n in counter(): ...` and it will go on forever as well.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的迭代器创建了一个会无限运行的生成器对象。你可以一直调用它，它永远不会停止。或者，你可以将它放入一个 `for` 循环中，例如，`for n in
    counter(): ...`，它也会无限进行。'
- en: 'Now, what if you wanted to stop it at some point? One solution is to use a
    variable to control the `while` loop. Something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想在某个点停止它怎么办？一个解决方案是使用变量来控制 `while` 循环。就像这样：
- en: '`gen.send.preparation.stop.py`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.send.preparation.stop.py`'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will do it. We start with `stop = False`, and until we change it to `True`,
    the generator will just keep going, like before. The moment we change stop to
    `True` though, the `while` loop will exit, and the next call will raise a `StopIteration`
    exception. This trick works, but I don''t like it. We depend on an external variable,
    and this can lead to issues: what if another function changes that `stop`? Moreover,
    the code is scattered. In a nutshell, this isn''t good enough.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做就可以了。我们开始时 `stop = False`，直到我们将其更改为 `True`，生成器会继续运行，就像之前一样。然而，当我们把 `stop`
    改为 `True` 时，`while` 循环将退出，下一次调用将抛出 `StopIteration` 异常。这个技巧是有效的，但我不喜欢它。我们依赖于外部变量，这可能会导致问题：如果另一个函数改变了那个
    `stop` 呢？此外，代码是分散的。总之，这还不够好。
- en: 'We can make it better by using `generator.send()`. When we call `generator.send()`,
    the value that we feed to `send` will be passed in to the generator, execution
    is resumed, and we can fetch it via the `yield` expression. This is all very complicated
    when explained with words, so let''s see an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `generator.send()` 来改进它。当我们调用 `generator.send()` 时，我们提供给 `send` 的值将被传递给生成器，执行将继续，我们可以通过
    `yield` 表达式获取它。当用文字解释时，这一切都非常复杂，所以让我们看一个例子：
- en: '`gen.send.py`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.send.py`'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Execution of the preceding code produces the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下结果：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I think it's worth going through this code line by line, like if we were executing
    it, and see if we can understand what's going on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为逐行阅读这段代码是有价值的，就像我们正在执行它一样，看看我们是否能理解正在发生的事情。
- en: We start the generator execution with a call to `next` (`#C`). Within the generator,
    `n` is set to the same value of `start`. The `while` loop is entered, execution
    stops (`#A`) and `n` (0) is yielded back to the caller. 0 is printed on the console.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `next` (`#C`) 来启动生成器的执行。在生成器内部，`n` 被设置为 `start` 的相同值。进入 `while` 循环，执行停止（`#A`），并将
    `n`（0）返回给调用者。0 在控制台上打印。
- en: We then call `send` (`#D`), execution resumes and `result` is set to `'Wow!'`
    (still `#A`), then its type and value are printed on the console (`#B`). `result`
    is not `'Q'`, therefore `n` is incremented by 1 and execution goes back to the
    `while` condition, which, being `True`, evaluates to `True` (that wasn't hard
    to guess, right?). Another loop cycle begins, execution stops again (`#A`), and
    `n` (1) is yielded back to the caller. 1 is printed on the console.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用 `send` (`#D`)，执行恢复，`result` 被设置为 `'Wow!'`（仍然 `#A`），然后其类型和值在控制台上打印（`#B`）。`result`
    不是 `'Q'`，因此 `n` 增加 1，执行回到 `while` 条件，由于 `True`，它评估为 `True`（这不难猜到，对吧？）。另一个循环周期开始，执行再次停止（`#A`），并将
    `n`（1）返回给调用者。1 在控制台上打印。
- en: 'At this point, we call `next` (`#E`), execution is resumed again (`#A`), and
    because we are not sending anything to the generator explicitly, Python behaves
    exactly like functions that are not using the `return` statement: the `yield n`
    expression (`#A`) returns `None`. `result` therefore is set to `None`, and its
    type and value are yet again printed on the console (`#B`). Execution continues,
    `result` is not `''Q''` so `n` is incremented by 1, and we start another loop
    again. Execution stops again (`#A`) and `n` (2) is yielded back to the caller.
    2 is printed on the console.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个点上，我们调用 `next` (`#E`)，执行再次恢复（`#A`），因为我们没有明确地向生成器发送任何内容，Python 的行为与不使用 `return`
    语句的函数完全一样：`yield n` 表达式（`#A`）返回 `None`。因此，`result` 被设置为 `None`，其类型和值再次在控制台上打印（`#B`）。执行继续，`result`
    不是 `'Q'`，所以 `n` 增加 1，然后再次开始另一个循环。执行再次停止（`#A`），并将 `n`（2）返回给调用者。2 在控制台上打印。
- en: 'And now for the grand finale: we call `send` again (`#F`), but this time we
    pass in `''Q''`, therefore when execution is resumed, `result` is set to `''Q''`
    (`#A`). Its type and value are printed on the console (`#B`), and then finally
    the `if` clause evaluates to `True` and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates and this means a `StopIteration`
    exception is raised. You can see the print of its traceback on the last few lines
    printed on the console.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是压轴大戏：我们再次调用 `send` (`#F`)，但这次我们传递了 `'Q'`，因此当执行恢复时，`result` 被设置为 `'Q'` (`#A`)。其类型和值在控制台上打印（`#B`），然后最终
    `if` 子句评估为 `True`，`while` 循环通过 `break` 语句停止。生成器自然终止，这意味着会引发 `StopIteration` 异常。你可以在控制台打印的最后几行看到其跟踪信息。
- en: This is not at all simple to understand at first, so if it's not clear to you,
    don't be discouraged. You can keep reading on and then you can come back to this
    example after some time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点一开始并不容易理解，所以如果你觉得不清楚，不要气馁。你可以继续阅读，然后过一段时间再回到这个例子。
- en: Using `send` allows for interesting patterns, and it's worth noting that `send`
    can only be used to resume the execution, not to start it. Only `next` starts
    the execution of a generator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `send` 允许出现有趣的模式，值得注意的是，`send` 只能用于恢复执行，而不能用于启动执行。只有 `next` 才能启动生成器的执行。
- en: The yield from expression
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`yield from` 表达式'
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a subiterator. Its use allows for quite advanced
    patterns, so let''s just see a very quick example of it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的构造是 `yield from` 表达式。这个表达式允许你从子迭代器中产生值。它的使用允许出现相当高级的模式，所以让我们快速看看它的一个简单示例：
- en: '`gen.yield.for.py`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.yield.for.py`'
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code prints the numbers `4`, `9`, `16` on the console (on separate
    lines). By now, I expect you to be able to understand it by yourself, but let's
    quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n ** 2`, which returns the square of the current `n`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在控制台上打印了数字 `4`、`9`、`16`（分别在不同的行上）。到现在为止，我期望你自己能够理解它，但让我们快速回顾一下发生了什么。函数外部的
    `for` 循环从 `print_squares(2, 5)` 获取一个迭代器，并对它调用 `next`，直到迭代结束。每次调用生成器时，执行会在 `yield
    n ** 2` 上暂停（稍后恢复），它返回当前 `n` 的平方。
- en: 'Let''s see how we can transform this code benefiting from the `yield from`
    expression:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用 `yield from` 表达式来转换这段代码：
- en: '`gen.yield.from.py`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.yield.from.py`'
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code produces the same result, but as you can see the `yield from` is actually
    running a subiterator `(n ** 2 …)`. The `yield from` expression returns to the
    caller each value the subiterator is producing. It's shorter and it reads better.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生相同的结果，但正如你所见，`yield from` 实际上是在运行一个子迭代器 `(n ** 2 …)`。`yield from` 表达式返回子迭代器产生的每个值。它更短，读起来更好。
- en: Generator expressions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Let's now talk about the other techniques to generate values one at a time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈其他一次生成一个值的技术。
- en: The syntax is exactly the same as list comprehensions, only, instead of wrapping
    the comprehension with square brackets, you wrap it with round braces. That is
    called a **generator expression**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与列表推导式完全相同，只是，你用圆括号而不是方括号来包装推导式。这被称为 **生成器表达式**。
- en: 'In general, generator expressions behave like equivalent list comprehensions,
    but there is one very important thing to remember: generators allow for one iteration
    only, then they will be exhausted. Let''s see an example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成器表达式的行为类似于等效的列表推导式，但有一件非常重要的事情需要记住：生成器只允许进行一次迭代，然后它们就会耗尽。让我们看一个例子：
- en: '`generator.expressions.py`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`generator.expressions.py`'
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Look at the line in which the generator expression is created and assigned the
    name `cubes_gen`. You can see it's a generator object. In order to see its elements,
    we can use a `for` loop, a manual set of calls to `next`, or simply, feed it to
    a `list` constructor, which is what I did.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看看创建生成器表达式并将其赋值给名称 `cubes_gen` 的那行代码。你可以看到它是一个生成器对象。为了查看其元素，我们可以使用一个 `for` 循环，手动调用
    `next`，或者简单地将其传递给 `list` 构造函数，这就是我所做的。
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it, if we want to use it
    from scratch again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦生成器耗尽，就无法再次从中恢复相同的元素。如果我们想从头开始再次使用它，我们需要重新创建它。
- en: 'In the next few examples, let''s see how to reproduce `map` and `filter` using
    generator expressions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子中，让我们看看如何使用生成器表达式来重现 `map` 和 `filter`。
- en: '`gen.map.py`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.map.py`'
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the previous example, `s1` and `s2` are exactly the same: they are the sum
    of `adder(0, 1), adder(1, 2), adder(2, 3)`, and so on, which translates to `sum(1,
    3, 5, ...)`. The syntax is different though, I find the generator expression to
    be much more readable:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`s1` 和 `s2` 完全相同：它们是 `adder(0, 1), adder(1, 2), adder(2, 3)` 等等的和，这相当于
    `sum(1, 3, 5, ...)`。语法不同，我发现生成器表达式更容易阅读：
- en: '`gen.filter.py`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.filter.py`'
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the previous example, `odd_cubes1` and `odd_cubes2` are the same: they generate
    a sequence of odd cubes. Yet again, I prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`odd_cubes1` 和 `odd_cubes2` 是相同的：它们生成一个奇数立方序列。再次，我更喜欢生成器语法。当事情变得稍微复杂一些时，这一点应该很明显：
- en: '`gen.map.filter.py`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen.map.filter.py`'
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code creates to generators `cubes1` and `cubes2`. They are exactly
    the same, and return 2-tuples (*n*, ![Generator expressions](img/4715_05_04.jpg))
    when *n* is a multiple of 3 or 5.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了两个生成器 `cubes1` 和 `cubes2`。它们完全相同，当 *n* 是 3 或 5 的倍数时，返回 2-元组 (*n*, ![生成器表达式](img/4715_05_04.jpg))。
- en: 'If you print the list (`cubes1`), you get: `[(0, 0), (3, 27), (5, 125), (6,
    216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印列表 (`cubes1`)，你会得到：`[(0, 0), (3, 27), (5, 125), (6, 216), (9, 729), (10,
    1000), (12, 1728), (15, 3375), (18, 5832)]`。
- en: See how much better the generator expression reads? It may be debatable when
    things are very simple, but as soon as you start nesting functions a bit, like
    we did in this example, the superiority of the generator syntax is evident. Shorter,
    simpler, more elegant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看看生成器表达式读起来有多好？当事情非常简单时，这可能是有争议的，但一旦你开始稍微嵌套一些函数，就像我们在例子中所做的那样，生成器语法的优越性就显而易见了。更短，更简单，更优雅。
- en: 'Now, let me ask you a question: what is the difference between the following
    lines of code?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我问你一个问题：以下代码行有什么区别？
- en: '`sum.example.py`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum.example.py`'
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are exactly the same because the braces in `s2` are redundant. They are
    both generator expressions inside the `sum` function. The expression to get `s1`
    is different though. Inside `sum`, we find a list comprehension. This means that
    in order to calculate `s1`, the `sum` function has to call `next` on a list, a
    million times.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，它们都产生了相同的总和。获取`s2`和`s3`的表达式完全相同，因为`s2`中的大括号是多余的。它们都是`sum`函数内的生成器表达式。而获取`s1`的表达式则不同。在`sum`内部，我们找到一个列表推导式。这意味着为了计算`s1`，`sum`函数必须在一个列表上调用`next`，一百万次。
- en: Do you see where we're loosing time and memory? Before `sum` can start calling
    `next` on that list, the list needs to have been created, which is a waste of
    time and space. It's much better for `sum` to call `next` on a simple generator
    expression. There is no need to have all the numbers from `range(10**6)` stored
    in a list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我们在哪里丢失时间和内存了吗？在`sum`开始调用列表上的`next`之前，列表需要被创建，这是时间和空间的浪费。对于`sum`来说，调用一个简单的生成器表达式上的`next`会更好。没有必要将`range(10**6)`中的所有数字都存储在一个列表中。
- en: 'So, *watch out for extra parentheses when you write your expressions*: sometimes
    it''s easy to skip on these details, which makes our code much different. Don''t
    believe me?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*在编写表达式时要小心额外的括号*：有时候很容易忽略这些细节，这使得我们的代码大不相同。你不相信吗？
- en: '`sum.example.2.py`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum.example.2.py`'
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try running the preceding example. If I run the first line, this is what I
    get:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行前面的示例。如果我运行第一行，这就是我得到的结果：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the other hand, if I comment out the first line, and uncomment the second
    one, this is the result:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我注释掉第一行，取消注释第二行，这就是结果：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sweet generator expressions. The difference between the two lines is that in
    the first one, a list with the squares of the first hundred million numbers must
    be made before being able to sum them up. That list is huge, and we run out of
    memory (at least, my box did, if yours doesn't try a bigger number), therefore
    Python kills the process for us. Sad face.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 美味的生成器表达式。这两行之间的区别在于，在第一行中，必须先创建一个包含前一百个百万数的平方的列表，然后才能将它们相加。这个列表非常大，我们耗尽了内存（至少，我的机器是这样，如果你的没有，尝试一个更大的数字），因此Python为我们杀死了进程。悲伤的脸。
- en: But when we remove the square brackets, we don't make a list any more. The sum
    function receives 0, 1, 4, 9, and so on until the last one, and sums them up.
    No problems, happy face.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们移除方括号时，我们不再创建列表。求和函数接收0、1、4、9等等，直到最后一个数，并将它们相加。没问题，开心的脸。
- en: Some performance considerations
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些性能考虑
- en: 'So, we''ve seen that we have many different ways to achieve the same result.
    We can use any combination of `map`, `zip`, `filter`, or choose to go with a comprehension,
    or maybe choose to use a generator, either function or expression. We may even
    decide to go with `for` loops: when the logic to apply to each running parameter
    isn''t simple, they may be the best option.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到我们有很多不同的方法可以达到相同的结果。我们可以使用`map`、`zip`、`filter`的任何组合，或者选择使用列表推导式，或者也许选择使用生成器，无论是函数还是表达式。我们甚至可能决定使用`for`循环：当要应用于每个运行参数的逻辑不简单时，它们可能是最佳选择。
- en: 'Other than readability concerns though, let''s talk about performances. When
    it comes to performances, usually there are two factors which play a major role:
    **space** and **time**.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可读性考虑之外，让我们谈谈性能。当谈到性能时，通常有两个因素起着主要作用：**空间**和**时间**。
- en: 'Space means the size of the memory that a data structure is going to take up.
    The best way to choose is to ask yourself if you really need a list (or tuple)
    or if a simple generator function would work as well. If the answer is yes, go
    with the generator, it''ll save a lot of space. Same goes with functions: if you
    don''t actually need them to return a list or tuple, then you can transform them
    in generator functions as well.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 空间意味着数据结构将要占用的内存大小。最好的选择是问问自己你是否真的需要一个列表（或元组），或者一个简单的生成器函数是否也能工作。如果答案是肯定的，就使用生成器，它将节省大量的空间。同样也适用于函数：如果你实际上不需要它们返回列表或元组，你也可以将它们转换为生成器函数。
- en: Sometimes, you will have to use lists (or tuples), for example there are algorithms
    that scan sequences using multiple pointers or maybe they run over the sequence
    more than once. A generator function (or expression) can be iterated over only
    once and then it's exhausted, so in these situations, it wouldn't be the right
    choice.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你必须使用列表（或元组），例如，有一些算法使用多个指针扫描序列，或者可能多次遍历序列。生成器函数（或表达式）只能迭代一次，然后就会耗尽，所以在这种情况下，它不是最佳选择。
- en: Time is a bit harder than space because it depends on more variables and therefore
    it isn't possible to state that *X is faster than Y* with absolute certainty for
    all cases. However, based on tests run on Python today, we can say that `map`
    calls can be twice as fast as equivalent `for` loops, and list comprehensions
    can be (always generally speaking) even faster than equivalent `map` calls.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 时间比空间更难确定，因为它依赖于更多的变量，因此不可能在所有情况下绝对肯定地说“X比Y快”。然而，根据今天在Python上运行的测试，我们可以说`map`调用可以比等效的`for`循环快两倍，而列表推导（通常来说）甚至可以比等效的`map`调用更快。
- en: In order to fully appreciate the reason behind these statements, we need to
    understand how Python works, and this is a bit outside the scope of this book,
    for it's too technical in detail. Let's just say that `map` and `list` comprehensions
    run at C language speed within the interpreter, while a Python `for` loop is run
    as Python bytecode within the Python Virtual Machine, which is often much slower.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解这些陈述背后的原因，我们需要了解Python是如何工作的，但这超出了本书的范围，因为它的技术细节太复杂。我们只需说，在解释器中，`map`和列表推导以C语言的速度运行，而Python的`for`循环在Python虚拟机中以Python字节码的形式运行，这通常要慢得多。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several different implementations of Python. The original one, and
    still the most common one, is the one written in C. C is one of the most powerful
    and popular programming languages still used today.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几种不同的实现。最初的一个，也是最常见的一个，是用C语言编写的。C语言是今天仍在使用的最强大和最受欢迎的编程语言之一。
- en: These claims I made come from books and articles that you can find on the Web,
    but how about we do a small exercise and try to find out for ourselves? I will
    write a small piece of code that collects the results of `divmod(a, b)` for a
    certain set of integer pairs `(a, b)`. I will use the `time` function from the
    `time` module to calculate the elapsed time of the operations that I will perform.
    Let's go!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出的这些观点来自可以在网上找到的书籍和文章，但我们可以做一个小练习，自己尝试找出答案？我将编写一小段代码，收集一组整数对`(a, b)`的`divmod(a,
    b)`的结果。我将使用`time`模块中的`time`函数来计算我将执行的操作的耗时。让我们开始吧！
- en: '`performances.py`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`performances.py`'
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we''re creating three lists: `dmloop`, `dmlist`, `dmgen` (`divmod`-`for`
    loop, `divmod`-`list` comprehension, `divmod`-generator expression). We start
    with the slowest option, the `for` loops. Then we have a `list` comprehension,
    and finally a generator expression. Let''s see the output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了三个列表：`dmloop`、`dmlist`、`dmgen`（`divmod`-`for`循环、`divmod`-`list`推导、`divmod`-生成器表达式）。我们从最慢的选项开始，即`for`循环。然后是列表推导，最后是生成器表达式。让我们看看输出：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `list` comprehension runs in 63% of the time taken by the `for` loop. That's
    impressive. The generator expression came quite close to that, with a good 72%.
    The reason the generator expression is slower is that we need to feed it to the
    `list()` constructor and this has a little bit more overhead compared to a sheer
    list comprehension.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导运行的时间是`for`循环的63%。这很令人印象深刻。生成器表达式的速度也非常接近，达到了72%。生成器表达式之所以较慢，是因为我们需要将其传递给`list()`构造函数，这比纯粹的列表推导有更多的开销。
- en: I would never go with a generator expression in a similar case though, there
    is no point if at the end we want a list. I would just use a list comprehension,
    and the result of the previous example proves me right. On the other hand, if
    I just had to do those `divmod` calculations without retaining the results, then
    a generator expression would be the way to go because in such a situation a list
    comprehension would unnecessarily consume a lot of space.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我永远不会在类似的情况下使用生成器表达式，如果我们最终想要一个列表，那就没有意义。我会直接使用列表推导，前一个例子中的结果证明我是对的。另一方面，如果我只是需要做那些`divmod`计算而不保留结果，那么生成器表达式将是最佳选择，因为在那种情况下，列表推导会不必要地消耗大量的空间。
- en: 'So, to recap: generators are very fast and allow you to save on space. List
    comprehensions are in general even faster, but don''t save on space. Pure Python
    `for` loops are the slowest option. Let''s see a similar example that compares
    a `for` loop and a `map` call:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下：生成器非常快，并且可以节省空间。列表推导通常更快，但不会节省空间。纯Python的`for`循环是最慢的选择。让我们看看一个类似的例子，比较`for`循环和`map`调用：
- en: '`performances.map.py`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`performances.map.py`'
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code is conceptually very similar to the previous example. The only thing
    that has changed is that we''re applying the `abs` function instead of the `divmod`
    one, and we have only one loop instead of two nested ones. Execution gives the
    following result:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在概念上与上一个例子非常相似。唯一不同的是，我们使用的是`abs`函数而不是`divmod`函数，我们只有一个循环而不是两个嵌套循环。执行结果如下：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And `map` wins the race! As I told you before, giving a statement of *what is
    faster than what* is very tricky. In this case, the `map` call is faster than
    the list comprehension.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 而`map`函数赢得了比赛！正如我之前告诉你的，给出一个关于*什么比什么快*的声明是非常棘手的。在这种情况下，`map`调用比列表推导式更快。
- en: Apart from the case by case little differences though, it's quite clear that
    the `for` loop option is the slowest one, so let's see what are the reasons we
    still want to use it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在逐个案例中存在一些细微的差异，但很明显，`for`循环选项是最慢的，所以让我们看看我们为什么还想使用它。
- en: Don't overdo comprehensions and generators
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度使用推导式和生成器
- en: We've seen how powerful list comprehensions and generator expressions can be.
    And they are, don't get me wrong, but the feeling that I have when I deal with
    them is that their complexity grows exponentially. The more you try to do within
    a single comprehension or a generator expression, the harder it becomes to read,
    understand, and therefore to maintain or change.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了列表推导式和生成器表达式有多么强大。它们确实如此，不要误会我，但当我处理它们时，我有一种感觉，它们的复杂性呈指数增长。你在一个单一的推导式或生成器表达式中尝试做的事情越多，阅读、理解和维护或更改它们就越困难。
- en: 'Open a Python console and type in `import this`, let''s read the Zen of Python
    again, in particular, there are a few lines that I think are very important to
    keep in mind:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Python控制台并输入`import this`，让我们再次阅读Python之禅，特别是有几行我认为非常重要需要记住：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: I have put a comment sign on the right of the main focus points here. Comprehensions
    and generator expressions become hard to read, more implicit than explicit, complex,
    and they can be hard to explain. Sometimes you have to break them apart using
    the inside-out technique, to understand why they produce the result they produce.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里的主要关注点右侧添加了注释符号。列表推导式和生成器表达式变得难以阅读，比显式更隐晦，更复杂，并且它们可能难以解释。有时你必须使用从内到外的技术将它们拆分，以理解它们为什么产生这样的结果。
- en: To give you an example, let's talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers (*a*, *b*,
    *c*) such that ![Don't overdo comprehensions and generators](img/4715_05_05.jpg).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个例子，让我们再谈谈毕达哥拉斯三元组。只是为了提醒你，毕达哥拉斯三元组是一组正整数(*a*, *b*, *c*)的元组，满足 ![不要过度使用推导式和生成器](img/4715_05_05.jpg)。
- en: We saw earlier in this chapter how to calculate them, but we did it in a very
    inefficient way because we were scanning all pairs of numbers below a certain
    threshold, calculating the hypotenuse, and filtering out those that were not producing
    a triple.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经看到了如何计算它们，但我们以非常低效的方式做了这件事，因为我们扫描了低于某个阈值的所有数字对，计算斜边，并过滤掉那些没有产生三元组的数字对。
- en: 'A better way to get a list of Pythagorean triples is to directly generate them.
    There are many different formulas to do this and we''ll use one of them: the **Euclidean
    formula**.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 获取毕达哥拉斯三元组列表的更好方法是通过直接生成它们。为此有许多不同的公式，我们将使用其中之一：**欧几里得公式**。
- en: 'This formula says that any triple (*a*, *b*, *c*), where ![Don''t overdo comprehensions
    and generators](img/4715_05_06.jpg), *b = 2mn*, ![Don''t overdo comprehensions
    and generators](img/4715_05_07.jpg), with *m* and *n* positive integers such that
    *m > n*, is a Pythagorean triple. For example, when *m = 2* and *n = 1*, we find
    the smallest triple: (3, 4, 5).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式表明，任何满足以下条件的三元组(*a*, *b*, *c*)，其中 ![不要过度使用推导式和生成器](img/4715_05_06.jpg)，*b
    = 2mn*，![不要过度使用推导式和生成器](img/4715_05_07.jpg)，*m*和*n*是满足*m* > *n*的正整数，都是一个毕达哥拉斯三元组。例如，当*m*
    = 2且*n* = 1时，我们找到最小的三元组：(3, 4, 5)。
- en: 'There is one catch though: consider the triple (6, 8, 10), that is just like
    (3, 4, 5) with all the numbers multiplied by 2\. This triple is definitely Pythagorean,
    since ![Don''t overdo comprehensions and generators](img/4715_05_08.jpg), but
    we can derive it from (3, 4, 5) simply by multiplying each of its elements by
    *2*. Same goes for (9, 12, 15), (12, 16, 20), and in general for all the triples
    that we can write as (3k, 4k, 5k), with *k* being a positive integer greater than
    1.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题：考虑三元组 (6, 8, 10)，它就像 (3, 4, 5) 乘以 2 得到的那样。这个三元组无疑是毕达哥拉斯三元组，因为 ![不要过度使用列表推导和生成器](img/4715_05_08.jpg)，但我们可以通过简单地将其每个元素乘以
    *2* 从 (3, 4, 5) 推导出它。同样适用于 (9, 12, 15)，(12, 16, 20)，以及一般地，对于所有我们可以写成 (3k, 4k,
    5k) 的三元组，其中 *k* 是大于 1 的正整数。
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor *k*, is called **primitive**. Another way of stating this is: if
    the three elements of a triple are **coprime**, then the triple is primitive.
    Two numbers are coprime when they don''t share any prime factor amongst their
    divisors, that is, their **greatest common divisor** (**GCD**) is 1\. For example,
    3 and 5 are coprime, while 3 and 6 are not, because they are both divisible by
    3.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过将另一个三元组的元素乘以某个因子 *k* 得到的一个三元组被称为 **原始的**。另一种表述方式是：如果一个三元组的三个元素是 **互质的**，那么这个三元组是原始的。两个数互质是指它们在它们的除数中没有共享任何质因数，也就是说，它们的
    **最大公约数** （**GCD**）是 1。例如，3 和 5 是互质的，而 3 和 6 不是，因为它们都能被 3 整除。
- en: 'So, the Euclidean formula tells us that if *m* and *n* are coprime, and *m
    – n* is odd, the triple they generate is *primitive*. In the following example,
    we will write a generator expression to calculate all the primitive Pythagorean
    triples whose hypotenuse (*c*) is less than or equal to some integer *N*. This
    means we want all triples for which ![Don''t overdo comprehensions and generators](img/4715_05_09.jpg).
    When *n* is *1*, the formula looks like this: ![Don''t overdo comprehensions and
    generators](img/4715_05_10.jpg), which means we can approximate the calculation
    with an upper bound of ![Don''t overdo comprehensions and generators](img/4715_05_11.jpg).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，欧几里得公式告诉我们，如果 *m* 和 *n* 是互质的，并且 *m – n* 是奇数，那么它们生成的三元组是 *原始的*。在下面的例子中，我们将编写一个生成器表达式来计算所有斜边
    (*c*) 小于或等于某个整数 *N* 的原始毕达哥拉斯三元组。这意味着我们想要所有满足 ![不要过度使用列表推导和生成器](img/4715_05_09.jpg)
    的三元组。当 *n* 是 *1* 时，公式看起来像这样：![不要过度使用列表推导和生成器](img/4715_05_10.jpg)，这意味着我们可以用一个上限
    ![不要过度使用列表推导和生成器](img/4715_05_11.jpg) 来近似计算。
- en: 'So, to recap: *m* must be greater than *n*, they must also be coprime, and
    their difference *m - n* must be odd. Moreover, in order to avoid useless calculations
    we''ll put the upper bound for *m* at *floor(sqrt(N)) + 1*.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：*m* 必须大于 *n*，它们也必须是互质的，并且它们的差 *m - n* 必须是奇数。此外，为了避免无用的计算，我们将 *m* 的上限设置为
    *floor(sqrt(N)) + 1*。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The function `floor` for a real number *x* gives the maximum integer *n* such
    that *n < x*, for example, *floor(3.8) = 3*, *floor(13.1) = 13*. Taking the *floor(sqrt(N))
    + 1* means taking the integer part of the square root of *N* and adding a minimal
    margin just to make sure we don't miss out any number.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实数 *x* 的 `floor` 函数给出小于 *x* 的最大整数 *n*，例如，*floor(3.8) = 3*，*floor(13.1) = 13*。取
    *floor(sqrt(N)) + 1* 的意思是取 *N* 的平方根的整数部分并加上一个最小边距，以确保我们不会错过任何数字。
- en: 'Let''s put all of this into code, step by step. Let''s start by writing a simple
    `gcd` function that uses **Euclid''s algorithm**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放入代码中，一步一步来。让我们先写一个简单的 `gcd` 函数，它使用 **欧几里得算法**：
- en: '`functions.py`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions.py`'
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The explanation of Euclid''s algorithm is available on the Web, so I won''t
    spend any time here talking about it; we need to concentrate on the generator
    expression. The next step is to use the knowledge we gathered before to generate
    a list of primitive Pythagorean triples:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法的解释可以在网上找到，所以在这里我不会花时间谈论它；我们需要集中精力在生成器表达式上。下一步是使用我们之前收集的知识来生成一个原始毕达哥拉斯三元组的列表：
- en: '`pythagorean.triple.generation.py`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`pythagorean.triple.generation.py`'
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There you go. It's not easy to read, so let's go through it line by line. At
    `#3`, we start a generator expression that is creating triples. You can see from
    `#4` and `#5` that we're looping on `m` in *[1, M]* with *M* being the integer
    part of *sqrt(N)*, plus 1\. On the other hand, `n` loops within *[1, m)*, to respect
    the *m > n* rule. Worth noting how I calculated *sqrt(N)*, that is, `N**.5`, which
    is just another way to do it that I wanted to show you.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 看这里。它不容易阅读，所以让我们逐行分析。在`#3`处，我们开始一个生成器表达式，用于创建三元组。从`#4`和`#5`可以看出，我们在*[1, M]*上对*m*进行循环，其中*M*是*N*的整数部分加上1。另一方面，`n`在*[1,
    m)*范围内循环，以遵守*m > n*规则。值得注意的是我如何计算*sqrt(N)*，即`N**.5`，这只是我想向你展示的另一种方法。
- en: 'At `#6`, you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2`, and finishes at `#7`. We take the triples (*a*, *b*, *c*)
    in (...innermost generator...) such that `c <= N`. This is necessary because ![Don''t
    overdo comprehensions and generators](img/4715_05_11.jpg) is the lowest upper
    bound that we can apply, but it doesn''t guarantee that *c* will actually be less
    than or equal to *N*.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#6`处，你可以看到用于使三元组成为原型的过滤条件：当`(m - n)`为奇数时，`(m - n) % 2`评估为`True`，而`gcd(m, n)
    == 1`意味着`m`和`n`是互质的。有了这些条件，我们知道三元组将是原型的。这解决了最内层的生成器表达式。最外层的生成器表达式从`#2`开始，到`#7`结束。我们取三元组(*a*,
    *b*, *c*)，使得`c <= N`。这是必要的，因为![不要过度使用列表推导和生成器](img/4715_05_11.jpg)是我们能应用的最低上限，但它不能保证*c*实际上会小于或等于*N*。
- en: Finally, at `#1` we apply sorting, to present the list in order. At `#7`, after
    the outermost generator expression is closed, you can see that we specify the
    sorting key to be the sum *a + b + c*. This is just my personal preference, there
    is no mathematical reason behind it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`#1`处我们应用排序，以按顺序展示列表。在`#7`处，在外层生成器表达式关闭后，你可以看到我们指定排序键为*a + b + c*的和。这只是我个人的偏好，没有数学上的原因。
- en: So, what do you think? Was it straightforward to read? I don't think so. And
    believe me, this is still a simple example; I have seen expressions way more complicated
    than this one.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你怎么看？阅读起来是否直接？我认为不是。相信我，这仍然是一个简单的例子；我见过比这更复杂的表达式。
- en: Unfortunately some programmers think that writing code like this is cool, that
    it's some sort of demonstration of their superior intellectual powers, of their
    ability to quickly read and digest intricate code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些程序员认为编写这样的代码很酷，认为这是他们优越智力力量的某种展示，是他们快速阅读和理解复杂代码的能力的展示。
- en: Within a professional environment though, I find myself having much more respect
    for those who write efficient, clean code, and manage to keep ego out the door.
    Conversely, those who don't, will produce lines at which you will stare for a
    long time while swearing in three languages (at least this is what I do).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中，我发现我对那些编写高效、干净代码并设法将自我抛在门外的人更加尊重。相反，那些做不到的人会写出让你长时间凝视并咒骂三语（至少这是我做的）的代码行。
- en: 'Now, let''s see if we can rewrite this code into something easier to read:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看是否可以将这段代码重写为更容易阅读的形式：
- en: '`pythagorean.triple.generation.for.py`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`pythagorean.triple.generation.for.py`'
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I feel so much better already. Let's go through this code as well, line by line.
    You'll see how easier it is to understand.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经感觉好多了。让我们逐行分析这段代码。你会发现它更容易理解。
- en: 'We start looping at `#1` and `#2`, in exactly the same way we were looping
    in the previous example. On line `#3`, we have the filtering for primitive triples.
    On line `#4`, we deviate a bit from what we were doing before: we calculate `c`,
    and on line `#5`, we filter on `c` being less than or equal to `N`. Only when
    `c` satisfies that condition, we calculate `a` and `b`, and yield the resulting
    tuple. It''s always good to delay all calculations for as much as possible so
    that we don''t waste time, in case eventually we have to discard those results.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`#1`和`#2`开始循环，与上一个例子中的循环方式完全相同。在`#3`行，我们有原型的三元组过滤条件。在`#4`行，我们稍微偏离了我们之前所做的方法：我们计算*c*，在`#5`行，我们过滤*c*小于或等于`N`。只有当*c*满足这个条件时，我们才计算*a*和*b*，并产生结果元组。尽可能推迟所有计算总是好的，这样我们就不浪费时间去丢弃那些结果。
- en: On the last line, before printing the result, we apply sorting with the same
    key we were using in the generator expression example.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，在打印结果之前，我们使用与在生成器表达式示例中使用的相同键进行排序。
- en: I hope you agree, this example is easier to understand. And I promise you, if
    you have to modify the code one day, you'll find that modifying this one is easy,
    while to modify the other version will take much longer (and it will be more error
    prone).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会同意，这个例子更容易理解。我保证，如果你有一天必须修改代码，你会发现修改这个例子很容易，而修改其他版本将需要更长的时间（并且更容易出错）。
- en: 'Both examples, when run, print the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例运行时都会打印以下内容：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The moral of the story is, try and use comprehensions and generator expressions
    as much as you can, but if the code starts to be complicated to modify or to read,
    you may want to refactor into something more readable. There is nothing wrong
    with this.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义在于，尽量多使用列表推导和生成器表达式，但如果代码开始变得难以修改或阅读，你可能想要重构为更易读的形式。这样做并没有什么不妥。
- en: Name localization
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名本地化
- en: 'Now that we are familiar with all types of comprehensions and generator expression,
    let''s talk about name localization within them. Python 3.* localizes loop variables
    in all four forms of comprehensions: `list`, `dict`, `set`, and generator expressions.
    This behavior is therefore different from that of the `for` loop. Let''s see a
    simple example to show all the cases:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了所有类型的推导和生成器表达式，让我们来谈谈它们内部的命名本地化。Python 3.* 在所有四种推导形式中本地化循环变量：`list`、`dict`、`set`
    和生成器表达式。因此，这种行为与 `for` 循环不同。让我们通过一个简单的例子来展示所有情况：
- en: '`scopes.py`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes.py`'
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we declare a global name `A = 100`, and then we exercise
    the four comprehensions: list, generator expression, dictionary, and set. None
    of them alter the global name `A`. Conversely, you can see at the end that the
    `for` loop modifies it. The last print statement prints 4.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个全局名称 `A = 100`，然后我们练习了四种推导：列表、生成器表达式、字典和集合。它们都没有改变全局名称 `A`。相反，你可以在最后看到
    `for` 循环修改了它。最后的打印语句打印了 4。
- en: 'Let''s see what happens if `A` wasn''t there:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果 `A` 不存在会发生什么：
- en: '`scopes.noglobal.py`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes.noglobal.py`'
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code would work the same with any of the four types of comprehensions.
    After we run the first line, `A` is not defined in the global namespace.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与任何四种类型的推导都一样有效。运行第一行后，`A` 在全局命名空间中未定义。
- en: 'Once again, the `for` loop behaves differently:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`for` 循环的行为不同：
- en: '`scopes.for.py`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes.for.py`'
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code shows that after a `for` loop, if the loop variable wasn''t
    defined before it, we can find it in the global frame. To make sure of it, let''s
    take a peek at it by calling the `globals()` built-in function:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码表明，在 `for` 循环之后，如果循环变量在循环之前未定义，我们可以在全局帧中找到它。为了确保这一点，让我们通过调用内置的 `globals()`
    函数来查看它：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Together with a lot of other boilerplate stuff, we can spot `''A'': 4`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '与许多其他样板代码一起，我们可以找到 `''A'': 4`。'
- en: Generation behavior in built-ins
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的生成行为
- en: Amongst the built-in types, the generation behavior is now quite common. This
    is a major difference between Python 2 and Python 3\. A lot of functions such
    as `map`, `zip`, and `filter` have been transformed so that they return objects
    that behave like iterables. The idea behind this change is that if you need to
    make a list of those results you can always wrap the call in a `list()` class,
    and you're done. On the other hand, if you just need to iterate and want to keep
    the impact on memory as light as possible, you can use those functions safely.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在内置类型中，生成行为现在相当常见。这是 Python 2 和 Python 3 之间的一个主要区别。许多函数，如 `map`、`zip` 和 `filter`，已经被转换成返回类似可迭代对象的对象。这种变化的背后思想是，如果你需要创建一个包含这些结果的列表，你总是可以将其调用包裹在
    `list()` 类中，然后完成。另一方面，如果你只需要迭代并且希望尽可能减少对内存的影响，你可以安全地使用这些函数。
- en: Another notable example is the `range` function. In Python 2 it returns a list,
    and there is another function called `xrange` that returns an object that you
    can iterate on, which generates the numbers on the fly. In Python 3 this function
    has gone, and `range` now behaves like it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的例子是 `range` 函数。在 Python 2 中，它返回一个列表，还有一个名为 `xrange` 的函数，它返回一个你可以迭代的对象，它会即时生成数字。在
    Python 3 中，这个函数已经不存在了，`range` 现在的行为就像它一样。
- en: But this concept in general is now quite widespread. You can find it in the
    `open()` function, which is used to operate on file objects (we'll see it in one
    of the next chapters), but also in `enumerate`, in the dictionary `keys`, `values`,
    and `items` methods, and several other places.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个概念现在在一般情况下已经很普遍了。你可以在 `open()` 函数中找到它，该函数用于操作文件对象（我们将在下一章中看到它），也可以在 `enumerate`、字典的
    `keys`、`values` 和 `items` 方法以及几个其他地方找到它。
- en: 'It all makes sense: Python''s aim is to try and reduce the memory footprint
    by avoiding wasting space wherever is possible, especially in those functions
    and methods that are used extensively in most situations.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都有意义：Python 的目标是通过尽可能避免浪费空间来尝试减少内存占用，尤其是在那些在大多数情况下被广泛使用的函数和方法中。
- en: Do you remember at the beginning of this chapter? I said that it makes more
    sense to optimize the performances of code that has to deal with a lot of objects,
    rather than shaving off a few milliseconds from a function that we call twice
    a day.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得这一章的开头吗？我说过，优化需要处理大量对象的代码的性能比从每天只调用两次的函数中节省几毫秒更有意义。
- en: One last example
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个例子
- en: Before we part from this chapter, I'll show you a simple problem that I submitted
    to candidates for a Python developer role in a company I used to work for.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这一章之前，我会向你展示一个简单的问题，我把它提交给了应聘我在一家曾经工作过的公司的 Python 开发者职位的候选人。
- en: 'The problem is the following: given the sequence `0 1 1 2 3 5 8 13 21 ...`
    write a function that would return the terms of this sequence up to some limit
    `N`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 问题如下：给定序列 `0 1 1 2 3 5 8 13 21 ...`，编写一个函数，该函数将返回这个序列直到某个限制 `N` 的项。
- en: If you haven't recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0*, *F(1) = 1* and, for any *n > 1*, *F(n) = F(n-1) + F(n-2)*. This
    sequence is excellent to test knowledge about recursion, memoization techniques
    and other technical details, but in this case it was a good opportunity to check
    whether the candidate knew about generators (and too many so called Python coders
    didn't, when I was interviewing them).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有认出它，那就是斐波那契序列，它定义为 *F(0) = 0*，*F(1) = 1*，并且对于任何 *n > 1*，*F(n) = F(n-1)
    + F(n-2)*。这个序列非常适合测试关于递归、记忆化技术和其他技术细节的知识，但在这个情况下，这是一个很好的机会来检查候选人是否了解生成器（在我面试他们的时候，太多的所谓
    Python 程序员并不知道这一点）。
- en: 'Let''s start from a rudimentary version of a function, and then improve on
    it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从函数的一个基本版本开始，然后对其进行改进：
- en: '`fibonacci.first.py`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibonacci.first.py`'
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From the top: we set up the `result` list to a starting value of `[0]`. Then
    we start the iteration from the next element (`next_n`), which is `1`. While the
    next element is not greater than `N`, we keep appending it to the list and calculating
    the next. We calculate the next element by taking a slice of the last two elements
    in the `result` list and passing it to the `sum` function. Add some `print` statements
    here and there if this is not clear to you, but by now I would expect it not to
    be an issue.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始：我们将 `result` 列表初始化为起始值 `[0]`。然后我们从下一个元素 (`next_n`) 开始迭代，它是 `1`。当下一个元素不大于
    `N` 时，我们将其追加到列表中并计算下一个元素。我们通过从 `result` 列表中的最后两个元素中取一个切片并将其传递给 `sum` 函数来计算下一个元素。如果你觉得这里不清楚，可以添加一些
    `print` 语句，但现在我预计这不会是问题。
- en: When the condition of the `while` loop evaluates to `False`, we exit the loop
    and return `result`. You can see the result of those `print` statements in the
    comments next to each of them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `while` 循环的条件评估为 `False` 时，我们退出循环并返回 `result`。你可以在每个 `print` 语句旁边的注释中看到这些语句的结果。
- en: 'At this point, I would ask the candidate the following question: "What if I
    just wanted to iterate over those numbers?" A good candidate would then change
    the code like the next listing (an excellent candidate would have started with
    it!):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我会问候选人以下问题：“如果我只是想遍历这些数字呢？”一个优秀的候选人会像下面这样修改代码（一个更优秀的候选人可能会从一开始就这样做！）：
- en: '`fibonacci.second.py`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibonacci.second.py`'
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is actually one of the solutions I was given. I don''t know why I kept
    it, but I''m glad I did so I can show it to you. Now, the `fibonacci` function
    is a *generator function*. First we yield `0`, then if `N` is `0` we return (this
    will cause a `StopIteration` exception to be raised). If that''s not the case,
    we start iterating, yielding `b` at every loop cycle, and then updating `a` and
    `b`. All we need in order to be able to produce the next element of the sequence
    is the past two: `a` and `b`, respectively.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我得到的一个解决方案。我不知道为什么我保留了它，但我很高兴我这样做了，这样我就可以展示给你了。现在，`fibonacci`函数是一个*生成器函数*。首先我们产生`0`，然后如果`N`是`0`，我们返回（这将引发一个`StopIteration`异常）。如果不是这种情况，我们开始迭代，在每次循环周期产生`b`，然后更新`a`和`b`。为了能够产生序列的下一个元素，我们只需要前两个：`a`和`b`。
- en: This code is much better, has a lighter memory footprint and all we have to
    do to get a list of Fibonacci numbers is to wrap the call with `list()`, as usual.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更好，内存占用更轻，我们只需用`list()`包装调用，就像平常一样，就可以得到斐波那契数列的列表。
- en: 'But what about elegance? I cannot leave the code like that. It was decent for
    an interview, where the focus is more on functionality than elegance, but here
    I''d like to show you a nicer version:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于优雅性呢？我不能就这样离开代码。对于一个更注重功能而不是优雅性的面试来说，这已经足够好了，但在这里我想给你展示一个更优雅的版本：
- en: '`fibonacci.elegant.py`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`fibonacci.elegant.py`'
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Much better. The whole body of the function is four lines, five if you count
    the docstring. Notice how in this case using tuple assignment (`a, b = 0, 1` and
    `a, b = b, a + b`) helps in making the code shorter, and more readable. It's one
    of the features of Python I like a lot.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。整个函数的主体只有四行，如果你把文档字符串也算上，那就是五行。注意在这个例子中，使用元组赋值（`a, b = 0, 1` 和 `a, b = b,
    a + b`）如何帮助使代码更短、更易读。这是我喜欢Python的许多特性之一。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concept of iteration and generation a bit more
    deeply. We saw the `map`, `zip` and `filter` functions quite in detail, and how
    to use them as an alternative to a regular `for` loop approach.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了迭代和生成的概念。我们相当详细地看到了`map`、`zip`和`filter`函数，以及如何将它们用作常规`for`循环方法的替代方案。
- en: Then we saw the concept of comprehensions, for lists, dictionaries, and sets.
    We saw their syntax and how to use them as an alternative to both the classic
    `for` loop approach and also to the use of `map`, `zip`, and `filter` functions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了列表、字典和集合的推导式概念。我们看到了它们的语法以及如何将它们用作经典`for`循环方法的替代方案，以及`map`、`zip`和`filter`函数的使用。
- en: 'Finally, we talked about the concept of generation, in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques and saw how they can make possible what wouldn''t normally be if we
    used a conventional approach based on lists.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了生成概念，有两种形式：生成器函数和表达式。我们学习了如何通过使用生成技术节省时间和空间，并看到了它们如何使基于列表的传统方法不可能实现的事情成为可能。
- en: We talked about performances, and saw that `for` loops are last in terms of
    speed, but they provide the best readability and flexibility to change. On the
    other hand, functions such as `map` and `filter` can be much faster, and comprehensions
    may be even better.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了性能，并看到`for`循环在速度上排在最后，但它们提供了最佳的可读性和灵活性来改变。另一方面，`map`和`filter`这样的函数可能要快得多，而推导式可能更好。
- en: The complexity of the code written using these techniques grows exponentially
    so, in order to favor readability and ease of maintainability, we still need to
    use the classic `for` loop approach at times. Another difference is in the name
    localization, where the `for` loop behaves differently from all other types of
    comprehensions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技术编写的代码的复杂性呈指数增长，因此，为了优先考虑可读性和易于维护性，我们有时仍然需要使用经典的`for`循环方法。另一个区别在于名称本地化，其中`for`循环的行为与其他所有推导式类型不同。
- en: The next chapter will be all about objects and classes. Structurally similar
    to this one, in that we won't explore many different subjects, rather, just a
    few of them, but we'll try to dive a little bit more deeply.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全部关于对象和类。在结构上与这一章相似，因为我们不会探索很多不同的主题，而是只探索其中的一些，但我们会尝试更深入地研究。
- en: Make sure you understand well the concepts of this chapter before jumping to
    the next one. We're building a wall brick by brick, and if the foundation is not
    solid, we won't get very far.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳到下一章之前，请确保你很好地理解了本章的概念。我们是一块砖一块砖地建造墙壁，如果基础不牢固，我们就走不远。
