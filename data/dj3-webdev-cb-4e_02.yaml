- en: Models and Database Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和数据库结构
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using model mixins
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型mixin
- en: Creating a model mixin with URL-related methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有URL相关方法的模型mixin
- en: Creating a model mixin to handle creation and modification dates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模型mixin来处理创建和修改日期
- en: Creating a model mixin to take care of meta tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个处理元标签的模型mixin
- en: Creating a model mixin to handle generic relations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个处理通用关系的模型mixin
- en: Handling multilingual fields
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多语言字段
- en: Working with model translation tables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型翻译表
- en: Avoiding circular dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免循环依赖
- en: Adding database constraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数据库约束
- en: Using migrations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迁移
- en: Changing a foreign key to the many-to-many field
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外键更改为多对多字段
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When you start a new app, the first thing that you do is create the models that
    represent your database structure. We are assuming that you have already created
    Django apps, or, at the very least, have read and understood the official Django
    tutorial. In this chapter, you will see a few interesting techniques that will
    make your database structure consistent across the different apps in your project.
    Then, you will see how to handle the internationalization of the data in your
    database. After that, you will learn how to avoid circular dependencies in your
    models and how to set database constraints. At the end of the chapter, you will
    see how to use migrations to change your database structure during the process
    of development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始一个新的应用程序时，您要做的第一件事是创建代表您的数据库结构的模型。我们假设您已经创建了Django应用程序，或者至少已经阅读并理解了官方的Django教程。在本章中，您将看到一些有趣的技术，这些技术将使您的数据库结构在项目中的不同应用程序中保持一致。然后，您将学习如何处理数据库中数据的国际化。之后，您将学习如何避免模型中的循环依赖以及如何设置数据库约束。在本章的最后，您将学习如何使用迁移来在开发过程中更改数据库结构。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code in this book, you will need the latest stable version
    of Python, the MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本书中的代码，您需要最新稳定版本的Python、MySQL或PostgreSQL数据库以及一个带有虚拟环境的Django项目。
- en: You can find all the code for this chapter in the `ch02` directory in the GitHub
    repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`ch02`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)。
- en: Using model mixins
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型mixin
- en: In object-oriented languages, such as Python, a mixin class can be viewed as
    an interface with implemented features. When a model extends a mixin, it implements
    the interface and includes all of its fields, attributes, properties, and methods.
    The mixins in Django models can be used when you want to reuse the generic functionalities
    in different models multiple times. The model mixins in Django are abstract base
    model classes. We will explore them in the next few recipes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，比如Python，一个mixin类可以被视为一个带有实现特性的接口。当一个模型扩展一个mixin时，它实现了接口并包含了所有的字段、属性、属性和方法。Django模型中的mixin可以在您想要多次在不同模型中重用通用功能时使用。Django中的模型mixin是抽象基本模型类。我们将在接下来的几个示例中探讨它们。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, you will need to create reusable mixins. A good place to keep your model
    mixins is in a `myproject.apps.core` app. If you create a reusable app that you
    will share with others, keep the model mixins in the reusable app itself, possibly
    in a `base.py` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建可重用的mixin。将模型mixin保存在`myproject.apps.core`应用程序中是一个很好的地方。如果您创建了一个可重用的应用程序，将模型mixin保存在可重用的应用程序本身中，可能是在一个`base.py`文件中。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open the `models.py` file of any Django app that you want to use mixins with,
    and type the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开任何您想要在其中使用mixin的Django应用程序的`models.py`文件，并键入以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Django''s model inheritance supports three types of inheritance: abstract base
    classes, multi-table inheritance, and proxy models. Model mixins are abstract
    model classes, in that we define them by using an abstract `Meta` class, with
    specified fields, properties, and methods. When you create a model such as `Idea`,
    as shown in the preceding example, it inherits all of the features from `CreationModificationDateMixin`,
    `MetaTagsMixin`, and `UrlMixin`. All of the fields of these abstract classes are
    saved in the same database table as the fields of the extending model. In the
    following recipes, you will learn how to define your model mixins.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模型继承支持三种类型的继承：抽象基类、多表继承和代理模型。模型mixin是抽象模型类，我们通过使用一个指定字段、属性和方法的抽象`Meta`类来定义它们。当您创建一个模型，比如在前面的示例中所示的`Idea`，它继承了`CreationModificationDateMixin`、`MetaTagsMixin`和`UrlMixin`的所有特性。这些抽象类的所有字段都保存在与扩展模型的字段相同的数据库表中。在接下来的示例中，您将学习如何定义您自己的模型mixin。
- en: There's more...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In normal Python class inheritance, if there is more than one base class, and
    all of them implement a specific method, and you call that method on the instance
    of a child class, only the method from the first parent class will be called,
    as in the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的Python类继承中，如果有多个基类，并且它们都实现了一个特定的方法，并且您在子类的实例上调用该方法，只有第一个父类的方法会被调用，就像下面的例子一样：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the same for Django model base classes; however, there is one special
    exception.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Django模型基类相同；然而，有一个特殊的例外。
- en: The Django framework does some magic with metaclasses that calls the `save()`
    and `delete()` methods from each of the base classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Django框架对元类进行了一些魔术，调用了每个基类的`save()`和`delete()`方法。
- en: That means that you can confidently do pre-save, post-save, pre-delete, and
    post-delete manipulations for specific fields defined specifically in the mixin
    by overwriting the `save()` and `delete()` methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以自信地对特定字段进行预保存、后保存、预删除和后删除操作，这些字段是通过覆盖mixin中的`save()`和`delete()`方法来定义的。
- en: To learn more about the different types of model inheritance, refer to the official
    Django documentation, available at [https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance](https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于不同类型的模型继承，请参阅官方Django文档，网址为[https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance](https://docs.djangoproject.com/en/2.2/topics/db/models/#model-inheritance)。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a model mixin with URL-related methods* recipe
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个具有与URL相关方法的模型mixin*配方'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模型mixin来处理创建和修改日期*配方'
- en: The *Creating a model mixin to take care of meta tags* recipe
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模型mixin来处理meta标签*配方'
- en: Creating a model mixin with URL-related methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个具有与URL相关方法的模型mixin
- en: For every model that has its own distinct detail page, it is good practice to
    define the `get_absolute_url()` method. This method can be used in templates and
    also in the Django admin site to preview the saved object. However, `get_absolute_url()`
    is ambiguous, as it returns the URL path instead of the full URL.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个具有自己独特详细页面的模型，定义`get_absolute_url()`方法是一个良好的做法。这个方法可以在模板中使用，也可以在Django管理站点中用于预览保存的对象。但是，`get_absolute_url()`是模棱两可的，因为它返回URL路径而不是完整的URL。
- en: 'In this recipe, we will look at how to create a model mixin that provides simplified
    support for model-specific URLs. This mixin will enable you to do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何创建一个模型mixin，为模型特定的URL提供简化的支持。这个mixin将使您能够做到以下几点：
- en: Allow you to define either the URL path or the full URL in your model
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您在模型中定义URL路径或完整URL
- en: Generate the other URL automatically, based on the one that you defined
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您定义的路径自动生成其他URL
- en: Define the `get_absolute_url()` method behind the scenes
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在幕后定义`get_absolute_url()`方法
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't yet done so, create the `myproject.apps.core` app where you will
    store your model mixins. Then, create a `models.py` file in the core package.
    Alternatively, if you create a reusable app, put the mixins in a `base.py` file
    in that app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请创建`myproject.apps.core`应用程序，您将在其中存储您的模型mixin。然后，在core包中创建一个`models.py`文件。或者，如果您创建了一个可重用的应用程序，请将mixin放在该应用程序的`base.py`文件中。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following steps, one by one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步执行以下步骤：
- en: 'Add the following content to the `models.py` file of your `core` app:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`core`应用程序的`models.py`文件中：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `WEBSITE_URL` setting without a trailing slash to the `dev`, `test`,
    `staging`, and `production` settings. For example, for the development environment
    this will be as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WEBSITE_URL`设置添加到`dev`、`test`、`staging`和`production`设置中，不带斜杠。例如，对于开发环境，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use the mixin in your app, import the mixin from the `core` app, inherit
    the mixin in your model class, and define the `get_url_path()` method, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在您的应用程序中使用mixin，从`core`应用程序导入mixin，在您的模型类中继承mixin，并定义`get_url_path()`方法，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UrlBase` class is an abstract model that has three methods, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`UrlBase`类是一个抽象模型，具有三种方法，如下所示：'
- en: '`get_url()` retrieves the full URL of the object.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_url()`检索对象的完整URL。'
- en: '`get_url_path()` retrieves the absolute path of the object.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_url_path()`检索对象的绝对路径。'
- en: '`get_absolute_url()` mimics the `get_url_path()` method.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_absolute_url()`模仿`get_url_path()`方法。'
- en: The `get_url()` and `get_url_path()` methods are expected to be overwritten
    in the extended model class, for example, `Idea`. You can define `get_url()`,
    and `get_url_path()` will strip it to the path. Alternatively, you can define
    `get_url_path()`, and `get_url()` will prepend the website URL to the beginning
    of the path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_url()`和`get_url_path()`方法预计会在扩展模型类中被覆盖，例如`Idea`。您可以定义`get_url()`，`get_url_path()`将会将其剥离为路径。或者，您可以定义`get_url_path()`，`get_url()`将在路径的开头添加网站URL。'
- en: The rule of thumb is to always overwrite the `get_url_path()` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是始终覆盖`get_url_path()`方法。
- en: 'In the templates, use `get_url_path()` when you need a link to an object on
    the same website, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，当您需要链接到同一网站上的对象时，请使用`get_url_path()`，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use `get_url()` for links in external communication, such as in emails, RSS
    feeds, or APIs; an example is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部通信中使用`get_url()`进行链接，例如在电子邮件、RSS订阅或API中；例如如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The default `get_absolute_url()` method will be used in the Django model administration
    for the View on site functionality, and might also be used by some third-party
    Django apps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`get_absolute_url()`方法将在Django模型管理中用于“查看网站”功能，并且也可能被一些第三方Django应用程序使用。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In general, don''t use incremental primary keys in the URLs, because it is
    not safe to expose them to the end user: the total amount of items would be visible,
    and it would be too easy to navigate through different items by just changing
    the URL path.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不要在URL中使用递增的主键，因为将它们暴露给最终用户是不安全的：项目的总数将可见，并且只需更改URL路径就可以轻松浏览不同的项目。
- en: 'You can use the primary keys in the URLs for the detail pages only if they
    are **Universal Unique Identifiers** (**UUIDs**) or generated random strings.
    Otherwise, create and use a slug field, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当它们是**通用唯一标识符**（**UUIDs**）或生成的随机字符串时，您才可以在详细页面的URL中使用主键。否则，请创建并使用slug字段，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using model mixins* recipe
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型mixin*配方'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模型mixin来处理创建和修改日期*配方'
- en: The *Creating a model mixin to take care of meta tags* recipe
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模型mixin来处理meta标签*配方'
- en: The *Creating a model mixin to handle generic relations* recipe
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模型mixin来处理通用关系*配方'
- en: The *Configuring settings for development, testing, staging, and production
    environments* recipe, in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为开发、测试、暂存和生产环境配置设置*配方，在[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*，使用Django
    3.0入门*'
- en: Creating a model mixin to handle creation and modification dates
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模型mixin来处理创建和修改日期
- en: It is common to include timestamps in your models for the creation and modification
    of your model instances. In this recipe, you will learn how to create a simple
    model mixin that saves the creation and modification dates and times for your
    model. Using such a mixin will ensure that all of the models use the same field
    names for the timestamps, and have the same behaviors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的模型中包含创建和修改模型实例的时间戳是很常见的。在这个示例中，您将学习如何创建一个简单的模型mixin，为您的模型保存创建和修改的日期和时间。使用这样的mixin将确保所有模型使用相同的时间戳字段名称，并具有相同的行为。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't yet done so, create the `myproject.apps.core` package to save
    your mixins. Then, create the `models.py` file in the core package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有这样做，请创建`myproject.apps.core`包来保存您的mixin。然后，在核心包中创建`models.py`文件。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open the `models.py` file in your `myprojects.apps.core` package, and insert
    the following content there:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`myprojects.apps.core`包中的`models.py`文件，并在其中插入以下内容：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `CreationModificationDateMixin` class is an abstract model, which means
    that extending model classes will create all of the fields in the same database
    table—that is, there will be no one-to-one relationships that make the table more
    complex to handle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreationModificationDateMixin`类是一个抽象模型，这意味着扩展模型类将在同一个数据库表中创建所有字段，也就是说，不会有使表更复杂的一对一关系。'
- en: This mixin has two date-time fields, `created` and `modified`. With the `auto_now_add`
    and `auto_now` attributes, the timestamps will be saved automatically when saving
    a model instance. The fields will automatically get the `editable=False` attribute,
    and thus will be hidden in administration forms. If `USE_TZ` is set to `True`
    in the settings (which is the default and recommended), time-zone-aware timestamps
    will be used. Otherwise, time-zone-naive timestamps will be used. Timezone-aware
    timestamps are saved in the **Coordinated Universal Time** (**UTC**) time zone
    in the database and converted to the default time zone of the project when reading
    or writing them. Time-zone-naive timestamps are saved in the local time zone of
    the project in the database; they are not practical to use in general, because
    they make time management between time zones more complicated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mixin有两个日期时间字段，`created`和`modified`。使用`auto_now_add`和`auto_now`属性，时间戳将在保存模型实例时自动保存。字段将自动获得`editable=False`属性，因此在管理表单中将被隐藏。如果在设置中将`USE_TZ`设置为`True`（这是默认和推荐的），将使用时区感知的时间戳。否则，将使用时区无关的时间戳。时区感知的时间戳保存在数据库中的**协调世界时**（**UTC**）时区，并在读取或写入时将其转换为项目的默认时区。时区无关的时间戳保存在数据库中项目的本地时区；一般来说，它们不实用，因为它们使得时区之间的时间管理更加复杂。
- en: 'To make use of this mixin, we just have to import it and extend our model,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个mixin，我们只需要导入它并扩展我们的模型，如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using model mixins* recipe
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型mixin*示例'
- en: The *Creating a model mixin to take care of meta tags* recipe
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个处理meta标签的模型mixin*示例'
- en: The *Creating a model mixin to handle generic relations* recipe
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个处理通用关系的模型mixin*示例'
- en: Creating a model mixin to take care of meta tags
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个处理meta标签的模型mixin
- en: When you optimize your site for search engines, you not only have to use semantic
    markup for each page, but you also have to include appropriate meta tags. For
    maximum flexibility, it helps to have a way to define content for common meta
    tags, specific to objects that have their own detail pages on your website. In
    this recipe, we will look at how to create a model mixin for the fields and methods
    related to the keyword, description, author, and copyright meta tags.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为搜索引擎优化您的网站时，不仅需要为每个页面使用语义标记，还需要包含适当的meta标签。为了最大的灵活性，有必要定义特定于在您的网站上拥有自己详细页面的对象的常见meta标签的内容。在这个示例中，我们将看看如何为与关键字、描述、作者和版权meta标签相关的字段和方法创建模型mixin。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As detailed in the previous recipes, make sure that you have the `myproject.apps.core`
    package for your mixins. Also, create a directory structure, `templates/utils/includes/`,
    under the package, and inside of that, create a `meta.html` file to store the
    basic meta tag markup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例中所述，确保您的mixin中有`myproject.apps.core`包。另外，在该包下创建一个目录结构`templates/utils/includes/`，并在其中创建一个`meta.html`文件来存储基本的meta标签标记。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create our model mixin:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的模型mixin：
- en: Make sure to add `"myproject.apps.core"` to `INSTALLED_APPS` in the settings,
    because we want to take the `templates` directory into account for this module.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在设置中将`"myproject.apps.core"`添加到`INSTALLED_APPS`中，因为我们希望为此模块考虑`templates`目录。
- en: 'Add the following basic meta tag markup to `meta_field.html`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下基本的meta标签标记添加到`meta_field.html`中：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `models.py` file from the core package in your favorite editor, and
    add the following content:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的编辑器中的核心包中的`models.py`文件，并添加以下内容：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: 'This mixin adds four fields to the model that extends from it: `meta_keywords`,
    `meta_description`, `meta_author`, and `meta_copyright`. The corresponding `get_*()`
    methods, used to render the associated meta tags, are also added. Each of these
    passes the name and appropriate field content to the core `get_meta_field()` method,
    which uses this input to return rendered markup based on the `meta_field.html`
    template. Finally, a shortcut `get_meta_tags()` method is provided to generate
    the combined markup for all of the available metadata at once.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mixin为扩展自它的模型添加了四个字段：`meta_keywords`，`meta_description`，`meta_author`和`meta_copyright`。还添加了相应的`get_*()`方法，用于呈现相关的meta标签。其中每个方法都将名称和适当的字段内容传递给核心的`get_meta_field()`方法，该方法使用此输入返回基于`meta_field.html`模板的呈现标记。最后，提供了一个快捷的`get_meta_tags()`方法，用于一次生成所有可用元数据的组合标记。
- en: 'If you use this mixin in a model, such as `Idea`, which is shown in the *Using
    model mixins* recipe at the start of this chapter, you can put the following in
    the `HEAD` section of your `detail` page template to render all of the meta tags
    at once, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在模型中使用这个mixin，比如在本章开头的*使用模型mixin*配方中展示的`Idea`中，您可以将以下内容放在`detail`页面模板的`HEAD`部分，以一次性渲染所有的元标记：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, a `meta_tags` block has been defined in a parent template, and this snippet
    shows how the child template redefines the block, including the content from the
    parent first as `block.super`, and extending it with our additional tags from
    the `idea` object. You could also render only a specific meta tag by using something
    like the following: `{{ idea.get_meta_description }}`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个`meta_tags`块已经在父模板中定义，这个片段展示了子模板如何重新定义块，首先将父模板的内容作为`block.super`，然后用`idea`对象的附加标签扩展它。您也可以通过类似以下的方式只渲染特定的元标记：`{{
    idea.get_meta_description }}`。
- en: As you may have noticed from the `models.py` code, the rendered meta tags are
    marked as safe – that is, they are not escaped, and we don't need to use the `safe`
    template filter. Only the values that come from the database are escaped, in order
    to guarantee that the final HTML is well formed. The database data in `meta_keywords`
    and other fields will automatically be escaped when we call `render_to_string()`
    for the `meta_field.html` template, because that template does not specify `{%
    autoescape off %}` in its content.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从`models.py`代码中，您可能已经注意到，渲染的元标记被标记为安全-也就是说，它们没有被转义，我们不需要使用`safe`模板过滤器。只有来自数据库的值被转义，以确保最终的HTML格式正确。当我们为`meta_field.html`模板调用`render_to_string()`时，`meta_keywords`和其他字段中的数据库数据将自动转义，因为该模板在其内容中没有指定`{%
    autoescape off %}`。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using model mixins* recipe
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型mixin*配方'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个处理创建和修改日期的模型mixin*配方'
- en: The *Creating a model mixin to handle generic relations* recipe
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建处理通用关系的模型mixin*配方'
- en: The *Arranging the base.html template* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*，模板和JavaScript*中*安排base.html模板*配方
- en: Creating a model mixin to handle generic relations
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个处理通用关系的模型mixin
- en: Aside from normal database relationships, such as a foreign-key relationship
    or a many-to-many relationship, Django has a mechanism to relate a model to an
    instance of any other model. This concept is called generic relations. For each
    generic relation, we save the content type of the related model as well as the
    ID of the instance of that model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的数据库关系，比如外键关系或多对多关系，Django还有一种将模型与任何其他模型的实例相关联的机制。这个概念被称为通用关系。对于每个通用关系，我们保存相关模型的内容类型以及该模型实例的ID。
- en: In this recipe, we will look at how to abstract the creation of generic relations
    in the model mixins.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何在模型mixin中抽象通用关系的创建。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe to work, you will need to have the `contenttypes` app installed.
    It should be in the `INSTALLED_APPS` list in the settings, by default, as shown
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个配方工作，您需要安装`contenttypes`应用程序。它应该默认在设置中的`INSTALLED_APPS`列表中，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, make sure that you have already created the `myproject.apps.core` app
    for your model mixins.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次确保您已经为模型mixin创建了`myproject.apps.core`应用程序。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create and use a mixin for generic relations follow these steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用通用关系的mixin，请按照以下步骤进行：
- en: 'Open the `models.py` file in the core package in a text editor, and insert
    the following content there:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开核心包中的`models.py`文件，并在那里插入以下内容：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code snippet is an example of how to use two generic relationships
    in your app (put this code in `ideas/models.py`):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段是如何在您的应用中使用两个通用关系的示例（将此代码放在`ideas/models.py`中）：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, this snippet is more complex than the previous ones.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个片段比之前的更复杂。
- en: The `object_relation_base_factory` function, which we have aliased to `generic_relation`,
    for short, in our import, is not a mixin itself; it is a function that generates
    a model mixin – that is, an abstract model class to extend from. The dynamically
    created mixin adds the `content_type` and `object_id` fields and the `content_object`
    generic foreign key that points to the related instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`object_relation_base_factory`函数，我们已经给它起了别名`generic_relation`，在我们的导入中，它本身不是一个mixin；它是一个生成模型mixin的函数-也就是说，一个抽象模型类来扩展。动态创建的mixin添加了`content_type`和`object_id`字段以及指向相关实例的`content_object`通用外键。'
- en: Why can't we just define a simple model mixin with these three attributes? A
    dynamically generated abstract class allows us to have prefixes for each field
    name; therefore, we can have more than one generic relation in the same model.
    For example, the `Like` model, which was shown previously, will have the `content_type`,
    `object_id`, and `content_object` fields for the favorite object, and `owner_content_type`,
    `owner_object_id`, and `owner_content_object` for the one (user or group) that
    liked the object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能只定义一个具有这三个属性的简单模型mixin？动态生成的抽象类允许我们为每个字段名称添加前缀；因此，我们可以在同一个模型中拥有多个通用关系。例如，之前展示的`Like`模型将为喜欢的对象添加`content_type`、`object_id`和`content_object`字段，以及为喜欢对象的用户或组添加`owner_content_type`、`owner_object_id`和`owner_content_object`。
- en: The `object_relation_base_factory` function, which we have aliased
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`object_relation_base_factory`函数，我们已经给它起了别名'
- en: to `generic_relation` for short, adds the possibility to limit the content type
    choices by the `limit_content_type_choices_to` parameter. The preceding example
    limits the choices for `owner_content_type` to only the content types of the `User`
    and `Group` models.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`generic_relation`的简称，通过`limit_content_type_choices_to`参数添加了限制内容类型选择的可能性。前面的示例将`owner_content_type`的选择限制为`User`和`Group`模型的内容类型。
- en: See also
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a model mixin with URL-related methods* recipe
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个具有URL相关方法的模型mixin*配方'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理创建和修改日期的模型混合的配方
- en: The *Creating a model mixin to take care of meta tags* recipe
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理处理元标签的模型混合的配方
- en: The *Implementing the Like widget* recipe in [Ch](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)[apter](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)
    [4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)的*实现“喜欢”小部件*配方中，模板和JavaScript
- en: Handling multilingual fields
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多语言字段
- en: Django uses the internationalization mechanism to translate verbose strings
    in the code and templates. But it's up to the developer to decide how to implement
    the multilingual content in the models. We'll show you a couple of ways for how
    to implement multilingual models directly in your project. The first approach
    will be using language-specific fields in your model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用国际化机制来翻译代码和模板中的冗长字符串。但是开发人员可以决定如何在模型中实现多语言内容。我们将向您展示如何直接在项目中实现多语言模型的几种方法。第一种方法是在模型中使用特定语言字段。
- en: 'This approach has the following features:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法具有以下特点：
- en: It is straightforward to define multilingual fields in the model.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型中定义多语言字段很简单。
- en: It is simple to use the multilingual fields in database queries.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库查询中使用多语言字段很简单。
- en: You can use contributed administration to edit models with the multilingual
    fields, without additional modifications.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用贡献的管理来编辑具有多语言字段的模型，无需额外修改。
- en: If you need to, you can effortlessly show all of the translations of an object
    in the same template.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，您可以轻松地在同一模板中显示对象的所有翻译。
- en: After changing the amount of languages in the settings, you will need to create
    and run migrations for all multilingual models.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置中更改语言数量后，您需要为所有多语言模型创建和运行迁移。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have you created the `myproject.apps.core` package used in the preceding recipes
    of this chapter? You will now need a new `model_fields.py` file within the `core`
    app, for the custom model fields.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否已经创建了本章前面配方中使用的`myproject.apps.core`包？现在，您需要在`core`应用程序中创建一个新的`model_fields.py`文件，用于自定义模型字段。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following steps to define the multilingual character field and
    multilingual text field:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来定义多语言字符字段和多语言文本字段：
- en: 'Open the `model_fields.py` file, and create the base multilingual field, as
    follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`model_fields.py`文件，并创建基本多语言字段，如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the same file, subclass the base field for character and text field forms,
    as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，为字符和文本字段表单子类化基本字段，如下所示：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create an `admin.py` file in the core app, and add the following content:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在核心应用中创建一个`admin.py`文件，并添加以下内容：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we''ll consider an example of how to use the multilingual fields in your
    app, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将考虑如何在应用程序中使用多语言字段的示例，如下所示：
- en: 'First, set multiple languages in the settings for your project. Let''s say,
    our website will support all official languages of the European Union, with English
    being the default language:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目的设置中设置多种语言。假设我们的网站将支持欧盟所有官方语言，英语是默认语言：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, open the `models.py` file from the `myproject.apps.ideas` app, and create
    the multilingual fields for the `Idea` model, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`myproject.apps.ideas`应用的`models.py`文件，并为`Idea`模型创建多语言字段，如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create an `admin.py` file for the `ideas` app:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`ideas`应用创建一个`admin.py`文件：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The example of `Idea` will generate a model that is similar to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Idea`的示例将生成一个类似以下的模型：'
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If there were any language codes with a dash, like "de-ch" for Swiss German,
    the fields for those languages would be replaced with underscores, like `title_de_ch`
    and `content_de_ch`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有带有破折号的语言代码，比如瑞士德语的“de-ch”，那么这些语言的字段将被下划线替换，比如`title_de_ch`和`content_de_ch`。
- en: In addition to the generated language-specific fields, there will be two properties
    – `title` and `content` – that will return the corresponding field in the currently
    active language. These will fall back to the default language if no localized
    field content is available.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成的特定语言字段之外，还将有两个属性 - `title` 和 `content` - 它们将返回当前活动语言中对应的字段。如果没有可用的本地化字段内容，它们将回退到默认语言。
- en: The `MultilingualCharField` and `MultilingualTextField` fields will juggle the
    model fields dynamically, depending on your `LANGUAGES` setting. They will overwrite
    the `contribute_to_class()` method that is used when the Django framework creates
    the model classes. The multilingual fields dynamically add character or text fields
    for each language of the project. You'll need to create a database migration to
    add the appropriate fields in the database. Also, the properties are created to
    return the translated value of the currently active language or the main language,
    by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultilingualCharField`和`MultilingualTextField`字段将根据您的`LANGUAGES`设置动态地处理模型字段。它们将覆盖`contribute_to_class()`方法，该方法在Django框架创建模型类时使用。多语言字段动态地为项目的每种语言添加字符或文本字段。您需要创建数据库迁移以在数据库中添加适当的字段。此外，创建属性以返回当前活动语言的翻译值或默认情况下的主语言。'
- en: In the administration, `get_multilingual_field_names()` will return a list of
    language-specific field names, starting with one of the default languages and
    then proceeding with the other languages from the `LANGUAGES` setting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理中，`get_multilingual_field_names()` 将返回一个特定语言字段名称的列表，从`LANGUAGES`设置中的一个默认语言开始，然后继续使用其他语言。
- en: Here are a couple of examples of how you might use the multilingual fields in
    templates and views.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可能在模板和视图中使用多语言字段的几个示例。
- en: 'If you have the following code in the template, it will show the text in the
    currently active language, let''s say Lithuanian, and will fall back to English
    if the translation doesn''t exist:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在模板中有以下代码，它将显示当前活动语言的文本，比如立陶宛语，如果翻译不存在，将回退到英语：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to have your `QuerySet` ordered by the translated titles, you can
    define it as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将您的“QuerySet”按翻译后的标题排序，可以定义如下：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with model translation tables* recipe
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型翻译表*配方'
- en: The *Using migrations* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用迁移*配方'
- en: '[Chapter 6](8b8138c4-c364-4616-8a81-b2f369cf870b.xhtml)*, Model Administration*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6章，模型管理
- en: Working with model translation tables
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型翻译表
- en: The second approach to handling multilingual content in the database involves
    using model translation tables for each multilingual model.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据库中的多语言内容时，第二种方法涉及为每个多语言模型使用模型翻译表。
- en: 'The features of this approach are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的特点如下：
- en: You can use contributed administration to edit translations as inlines.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用贡献的管理来编辑翻译，就像内联一样。
- en: After changing the amount of languages in the settings, no migrations or other
    further actions are necessary.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改设置中的语言数量后，不需要进行迁移或其他进一步的操作。
- en: You can effortlessly show the translation of the current language in the template,
    but it would be more difficult to show several translations in specific languages
    on the same page.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松地在模板中显示当前语言的翻译，但在同一页上显示特定语言的多个翻译会更困难。
- en: You have to know and use a specific pattern described in this recipe for creating
    model translations.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须了解并使用本配方中描述的特定模式来创建模型翻译。
- en: It's not that simple to use this approach for database queries, but, as you
    will see, it's still possible.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法进行数据库查询并不那么简单，但是，正如您将看到的，这仍然是可能的。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we will start with the `myprojects.apps.core` app.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从“myprojects.apps.core”应用程序开始。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following steps to prepare for multilingual models:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来准备多语言模型：
- en: 'In the `core` app, create `model_fields.py` with the following content:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“core”应用程序中，创建带有以下内容的“model_fields.py”：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `admin.py` file to the `core` app with the following content:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到“core”应用程序的“admin.py”文件中：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s implement the multilingual models:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现多语言模型：
- en: 'First, set multiple languages in the settings for your project. Let''s say,
    our website will support all official languages of European Union with English
    being the default language:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目的设置中设置多种语言。假设我们的网站将支持欧盟所有官方语言，英语是默认语言：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, let''s create the `Idea` and `IdeaTranslations` models:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建“Idea”和“IdeaTranslations”模型：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Last, create the `admin.py` for the `ideas` app as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建“ideas”应用程序的“admin.py”如下：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We keep the language-specific fields of the default language in the `Idea` model
    itself. The translations for each language are in the `IdeaTranslations` model,
    which will be listed in the administration as an inline translation. `IdeaTranslations`
    don't have the language choices at the model for a reason – we don't want to create
    migrations every time a new language is added or some language is removed. Instead,
    the language choices are set in the administration form, also making sure that
    the default language is skipped or not available for selection in the list. The
    language choices are restricted using the `LanguageChoicesForm` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将默认语言的特定于语言的字段保留在“Idea”模型本身中。每种语言的翻译都在“IdeaTranslations”模型中，该模型将作为内联翻译列在管理中列出。“IdeaTranslations”模型没有模型的语言选择，这是有原因的——我们不希望每次添加新语言或删除某种语言时都创建迁移。相反，语言选择设置在管理表单中，还要确保默认语言被跳过或在列表中不可选择。语言选择使用“LanguageChoicesForm”类进行限制。
- en: 'To get a specific field in the current language, you would use the fields defined
    as `TranslatedField`. In the template, that would look like the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前语言中的特定字段，您将使用定义为“TranslatedField”的字段。在模板中，看起来像这样：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To order items by a translated title in a specific language, you would use
    the `annotate()` method as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要按特定语言的翻译标题对项目进行排序，您将使用“annotate()”方法如下：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we prompt for a language code in the Django shell. If the language
    is the default one, we store the `title` and `content` as the `title_translation` and
    the `content_translation` from the `Idea` model. If there is another language
    chosen, we read the `title` and `content` as `title_translation` and `content_translation` from
    the `IdeaTranslations` model  with the chosen language.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在Django shell中提示输入语言代码。如果语言是默认语言，我们将“title”和“content”存储为“Idea”模型的“title_translation”和“content_translation”。如果选择了其他语言，我们将从选择的语言中读取“title”和“content”作为“IdeaTranslations”模型的“title_translation”和“content_translation”。
- en: Afterward, we can filter or order `QuerySet` by `title_translation` or `content_translation`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过“title_translation”或“content_translation”筛选或排序“QuerySet”。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Handling multilingual fields* recipe
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理多语言字段*配方'
- en: '[Chapter 6](8b8138c4-c364-4616-8a81-b2f369cf870b.xhtml)*, Model Administration*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6章，模型管理
- en: Avoiding circular dependencies
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免循环依赖
- en: When developing Django models, it is very important to avoid circular dependencies
    especially in the `models.py` files. Circular dependencies are imports in different
    Python modules from each other. You should never cross-import from the different
    `models.py` files, because that causes serious stability issues. Instead, if you
    have interdependencies, you should use the actions described in this recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Django模型时，非常重要的是要避免循环依赖，特别是在“models.py”文件中。循环依赖是指不同Python模块之间的相互导入。您不应该从不同的“models.py”文件中交叉导入，因为这会导致严重的稳定性问题。相反，如果存在相互依赖，您应该使用本配方中描述的操作。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's work with `categories` and `ideas` apps to illustrate how to deal with
    cross dependencies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用“categories”和“ideas”应用程序来说明如何处理交叉依赖。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these practices when working with models that use models from other
    apps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理使用其他应用程序模型的模型时，请遵循以下实践：
- en: 'For foreign keys and many-to-many relationships with models from other apps,
    use the `"<app_label>.<model>"` declaration instead of importing the model. In
    Django this works with `ForeignKey`, `OneToOneField`, and `ManyToManyField`, for
    example:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于来自其他应用程序的模型的外键和多对多关系，请使用`"<app_label>.<model>"`声明，而不是导入模型。在Django中，这适用于`ForeignKey`，`OneToOneField`和`ManyToManyField`，例如：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, `settings.AUTH_USER_MODEL` is a setting with a value such as `"auth.User"`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`settings.AUTH_USER_MODEL`是一个具有值如`"auth.User"`的设置：
- en: 'If you need to access a model from another app in a method, import that model
    inside the method instead of at the module level, for example, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要在方法中访问另一个应用程序的模型，请在方法内部导入该模型，而不是在模块级别导入，例如：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you use model inheritance, for example, for model mixins, keep the base
    classes in a separate app and place them before other apps that would use them
    in `INSTALLED_APPS`, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用模型继承，例如用于模型混合，将基类保留在单独的应用程序中，并将它们放在`INSTALLED_APPS`中将使用它们的其他应用程序之前，如下所示：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here the `ideas` app will use the model mixins from the `core` app as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ideas`应用程序将如下使用`core`应用程序的模型混合：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See also
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Configuring settings for development, testing, staging, and production
    environments* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*中的*为开发、测试、暂存和生产环境配置设置*示例，Django
    3.0入门'
- en: The *Respecting the import order in Python files* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)**,
    Getting Started with Django 3.0**
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)**中的*尊重Python文件的导入顺序*示例，Django
    3.0入门**'
- en: The *Using model mixins* recipe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型混合*示例'
- en: The *Changing the foreign key to the many-to-many field* recipe
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将外键更改为多对多字段*示例'
- en: Adding database constraints
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据库约束
- en: For better database integrity, it's common to define database constraints, telling
    some fields to be bound to fields of other database tables, making some fields
    unique or not null. For advanced database constraints, such as making the fields
    unique with a condition or setting specific conditions for the values of some
    fields, Django has special classes: `UniqueConstraint` and `CheckConstraint`.
    In this recipe, you will see a practical example of how to use them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地保证数据库的完整性，通常会定义数据库约束，告诉某些字段绑定到其他数据库表的字段，使某些字段唯一或非空。对于高级数据库约束，例如使字段在满足条件时唯一或为某些字段的值设置特定条件，Django有特殊的类：`UniqueConstraint`和`CheckConstraint`。在这个示例中，您将看到如何使用它们的实际示例。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with the `ideas` app and the `Idea` model that will have at least `title`
    and `author` fields.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ideas`应用程序和将至少具有`title`和`author`字段的`Idea`模型开始。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Set the database constraints in the `Meta` class of the `Idea` model as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Idea`模型的`Meta`类中设置数据库约束如下：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define two constraints in the database.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据库中定义了两个约束。
- en: 'The first one, `UniqueConstraint`, tells the titles to be unique for each author.
    If the author is not set, the titles can be repeated. To check if the author is
    set we use the negated lookup: `~models.Q(author=None)`. Note that in Django,
    the `~` operator for lookups is equivalent to the `exclude()` method of a QuerySet,
    so these QuerySets are equivalent:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`UniqueConstraint`告诉标题对于每个作者是唯一的。如果作者未设置，则标题可以重复。要检查作者是否已设置，我们使用否定查找：`~models.Q(author=None)`。请注意，在Django中，查找的`~`运算符等同于QuerySet的`exclude()`方法，因此这些QuerySets是等价的：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second constraint, `CheckConstraint`, checks if the title doesn't start
    and end with a whitespace. For that, we use a regular expression lookup.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个约束条件`CheckConstraint`检查标题是否不以空格开头和结尾。为此，我们使用正则表达式查找。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Database constraints don't affect form validation. They will just raise `django.db.utils.IntegrityError`
    if any data doesn't pass its conditions when saving entries to the database.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库约束不会影响表单验证。如果保存条目到数据库时任何数据不符合其条件，它们只会引发`django.db.utils.IntegrityError`。
- en: 'If you want to have data validated at the forms, you have to implement the
    validation in addition yourself, for example, in the `clean()` method of the model.
    That would look like this for the `Idea` model:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在表单中验证数据，您必须自己实现验证，例如在模型的`clean()`方法中。对于`Idea`模型，这将如下所示：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*, Forms and Views*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*中的*表单和视图*'
- en: The *Using database query expressions* recipe in [Chapter 10](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*,
    Bells and Whistles*
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](dc084cae-d894-487f-8071-08c63c80f852.xhtml)*中的*使用数据库查询表达式*示例，花里胡哨'
- en: Using migrations
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迁移
- en: In Agile software development, requirements for the project evolve and get updated
    from time to time in the process of development. As development happens iteratively,
    you will have to perform database schema changes along the way. With Django migrations,
    you don't have to change the database tables and fields manually, as most of it
    is done automatically, using the command-line interface.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷软件开发中，项目的要求会随着时间的推移而不断更新和更新。随着开发的进行，您将不得不沿途执行数据库架构更改。使用Django迁移，您不必手动更改数据库表和字段，因为大部分工作都是自动完成的，使用命令行界面。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Activate your virtual environment in the command-line tool, and change the active
    directory to your project's directory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行工具中激活您的虚拟环境，并将活动目录更改为您的项目目录。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create the database migrations, take a look at the following steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库迁移，请查看以下步骤：
- en: 'When you create models in your new `categories` or `ideas` app, you have to
    create an initial migration that will create the database tables for your app.
    This can be done by using the following command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在新的`categories`或`ideas`应用程序中创建模型时，您必须创建一个初始迁移，该迁移将为您的应用程序创建数据库表。这可以通过使用以下命令来完成：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The first time that you want to create all of the tables for your project,
    run the following command:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次要为项目创建所有表时，请运行以下命令：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run this command when you want to execute the new migrations for all of your
    apps.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要执行所有应用程序的新迁移时，请运行此命令。
- en: 'If you want to execute the migrations for a specific app, run the following
    command:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要执行特定应用程序的迁移，请运行以下命令：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you make some changes in the database schema, you will have to create a
    migration for that schema. For example, if we add a new subtitle field to the
    idea model, we can create the migration by using the following command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对数据库模式进行了一些更改，则必须为该模式创建一个迁移。例如，如果我们向idea模型添加一个新的subtitle字段，可以使用以下命令创建迁移：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, the `--name=subtitle_added` field can be skipped because in most cases
    Django generates fairly self-explanatory default names.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`--name=subtitle_added`字段可以被跳过，因为在大多数情况下，Django会生成相当自解释的默认名称。
- en: 'Sometimes, you may have to add to or change data in the existing schema in
    bulk, which can be done with a data migration, instead of a schema migration.
    To create a data migration that modifies the data in the database table, we can
    use the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，您可能需要批量添加或更改现有模式中的数据，这可以通过数据迁移而不是模式迁移来完成。要创建修改数据库表中数据的数据迁移，可以使用以下命令：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `--empty` parameter tells Django to create a skeleton data migration, which
    you have to modify to perform the necessary data manipulation before applying
    it. For data migrations, setting the name is recommended.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`--empty`参数告诉Django创建一个骨架数据迁移，您必须在应用之前修改它以执行必要的数据操作。对于数据迁移，建议设置名称。'
- en: 'To list all of the available applied and unapplied migrations, run the following
    command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有可用的已应用和未应用的迁移，请运行以下命令：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The applied migrations will be listed with an [X] prefix. The unapplied ones
    will be listed with a [ ] prefix.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 已应用的迁移将以[X]前缀列出。未应用的迁移将以[ ]前缀列出。
- en: 'To list all of the available migrations for a specific app, run the same command,
    but pass the app name, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出特定应用程序的所有可用迁移，请运行相同的命令，但传递应用程序名称，如下所示：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Django migrations are instruction files for the database migration mechanism.
    The instruction files inform us about which database tables to create or remove,
    which fields to add or remove, and which data to insert, update, or delete. Also
    they define which migrations are dependent on which other migrations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Django迁移是数据库迁移机制的指令文件。这些指令文件告诉我们要创建或删除哪些数据库表，要添加或删除哪些字段，以及要插入、更新或删除哪些数据。它们还定义了哪些迁移依赖于其他迁移。
- en: There are two types of migrations in Django. One is schema migration, and the
    other is data migration. Schema migration should be created when you add new models,
    or add or remove fields. Data migration should be used when you want to fill the
    database with some values or massively delete values from the database. Data migrations
    should be created by using a command in the command-line tool, and then coded
    in the migration file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Django有两种类型的迁移。一种是模式迁移，另一种是数据迁移。当您添加新模型、添加或删除字段时，应创建模式迁移。当您想要向数据库填充一些值或大量删除数据库中的值时，应使用数据迁移。数据迁移应该通过命令行工具中的命令创建，然后在迁移文件中编码。
- en: The migrations for each app are saved in their `migrations` directories. The
    first migration will usually be called `0001_initial.py`, and the other migrations
    in our example app will be called `0002_subtitle_added.py` and `0003_populate_subtitle.py`.
    Each migration gets a number prefix that is automatically incremented. For each
    migration that is executed, there is an entry that is saved in the `django_migrations`
    database table.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序的迁移都保存在它们的`migrations`目录中。第一个迁移通常称为`0001_initial.py`，在我们的示例应用程序中，其他迁移将被称为`0002_subtitle_added.py`和`0003_populate_subtitle.py`。每个迁移都有一个自动递增的数字前缀。对于执行的每个迁移，都会在`django_migrations`数据库表中保存一个条目。
- en: 'It is possible to migrate back and forth by specifying the number of the migration
    to which we want to migrate, as shown in the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定要迁移的迁移编号来来回迁移，如下命令所示：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To unmigrate all migrations of the app including the initial migration, run
    the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消应用程序的所有迁移，包括初始迁移，请运行以下命令：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unmigrating requires each migration to have both a forward and a backward action.
    Ideally, the backward action would undo exactly the changes made by the forward
    action. However, in some cases such a change would be unrecoverable, such as when
    the forward action has removed a column from the schema, because it will have
    destroyed data. In such a case, the backward action might restore the schema,
    but the data would remain lost forever, or else there might not be a backward
    action at all.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 取消迁移需要每个迁移都有前向和后向操作。理想情况下，后向操作应该恢复前向操作所做的更改。然而，在某些情况下，这样的更改是无法恢复的，例如当前向操作从模式中删除了一个列时，因为它将破坏数据。在这种情况下，后向操作可能会恢复模式，但数据将永远丢失，或者根本没有后向操作。
- en: Do not commit your migrations to version control until you have tested the forward
    and backward migration process and you are sure that they will work well in other
    developments and public website environments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了前向和后向迁移过程并确保它们在其他开发和公共网站环境中能够正常工作之前，不要将您的迁移提交到版本控制中。
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Learn more about writing database migrations in the official *How To* guide,
    found at [https://docs.djangoproject.com/en/2.2/howto/writing-migrations/](https://docs.djangoproject.com/en/2.2/howto/writing-migrations/)​.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方的*How To*指南中了解更多关于编写数据库迁移的信息，网址为[https://docs.djangoproject.com/en/2.2/howto/writing-migrations/](https://docs.djangoproject.com/en/2.2/howto/writing-migrations/)​。
- en: See also
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with a virtual environment* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*中的*使用虚拟环境*配方'
- en: The *Working with Docker containers for Django, Gunicorn, Nginx, and PostgreSQL*
    recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*, Getting Started
    with Django 3.0*
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*中的*使用Django、Gunicorn、Nginx和PostgreSQL的Docker容器*食谱，使用Django
    3.0入门
- en: The *Handling project dependencies with pip* receipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*中的*使用pip处理项目依赖关系*食谱，使用Django
    3.0入门
- en: The *Including external dependencies in your project* recipe in [Chapter 1](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*,
    Getting Started with Django 3.0*
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](87d1a2a0-31bb-4c77-ab38-98b738f55fa1.xhtml)*中的*在您的项目中包含外部依赖项*食谱，使用Django
    3.0入门
- en: The *Changing a foreign key to the many-to-many field* recipe
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将外键更改为多对多字段*食谱'
- en: Changing a foreign key to the many-to-many field
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将外键更改为多对多字段
- en: This recipe is a practical example of how to change a many-to-one relation to
    a many-to-many relation, while preserving the already existing data. We will use
    both schema and data migrations in this situation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是如何将多对一关系更改为多对多关系的实际示例，同时保留已经存在的数据。在这种情况下，我们将同时使用模式迁移和数据迁移。
- en: Getting ready
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's suppose that you have the `Idea` model, with a foreign key pointing to
    the `Category` model.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有`Idea`模型，其中有一个指向`Category`模型的外键。
- en: 'Let''s define the `Category` model in the `categories` app, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`categories`应用程序中定义`Category`模型，如下所示：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s define the `Idea` model in the `ideas` app, as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ideas`应用程序中定义`Idea`模型，如下所示：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create and execute initial migrations by using the following commands:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下命令创建和执行初始迁移：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps will show you how to switch from a foreign key relation
    to a many-to-many relation, while preserving the already existing data:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何从外键关系切换到多对多关系，同时保留已经存在的数据：
- en: 'Add a new many-to-many field, called `categories`, as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`categories`的新多对多字段，如下所示：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create and run a schema migration, in order to add the new relationship to
    the database, as shown in the following code snippet:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并运行模式迁移，以向数据库添加新的关系，如下面的代码片段所示：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a data migration to copy the categories from the foreign key to the
    many-to-many field, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据迁移，将类别从外键复制到多对多字段，如下所示：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Open the newly created migration file (`0003_copy_categories.py`), and define
    the forward migration instructions, as shown in the following code snippet:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的迁移文件（`0003_copy_categories.py`），并定义前向迁移指令，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the new data migration, as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新的数据迁移，如下所示：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Delete the foreign key `category` field in the `models.py` file, leaving only
    the new `categories` many-to-many field, as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models.py`文件中删除外键`category`字段，只留下新的`categories`多对多字段，如下所示：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create and run a schema migration, in order to delete the `Categories` field
    from the database table, as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并运行模式迁移，以从数据库表中删除`Categories`字段，如下所示：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At first, we add a new many-to-many field to the `Idea` model, and a migration
    is generated to update the database accordingly. Then, we create a data migration
    that will copy the existing relations from the foreign key `category` to the new
    many-to-many `categories`. Lastly, we remove the foreign key field from the model,
    and update the database once more.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向`Idea`模型添加一个新的多对多字段，并生成一个迁移以相应地更新数据库。然后，我们创建一个数据迁移，将现有关系从外键`category`复制到新的多对多`categories`。最后，我们从模型中删除外键字段，并再次更新数据库。
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Our data migration currently includes only the forward action, copying the foreign
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据迁移目前只包括前向操作，将外键中的类别复制到多对多字段中
- en: key category as the first related item in the new categories relationship. Although
    we did not elaborate here, in a real-world scenario it would be best to include
    the reverse operation as well. This could be accomplished by copying the first
    related item back to the `category` foreign key. Unfortunately, any `Idea` object
    with multiple categories would lose extra data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将类别键作为新类别关系中的第一个相关项目。虽然我们在这里没有详细说明，在实际情况下最好也包括反向操作。这可以通过将第一个相关项目复制回`category`外键来实现。不幸的是，任何具有多个类别的`Idea`对象都将丢失额外数据。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using migrations* recipe
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用迁移*食谱'
- en: The *Handling multilingual fields* recipe
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理多语言字段*食谱'
- en: The *Working with model translation tables* recipe
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用模型翻译表*食谱'
- en: The *Avoiding circular dependencies* recipe
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*避免循环依赖*食谱'
