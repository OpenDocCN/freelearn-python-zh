- en: Deadlocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁
- en: Deadlocks, one of the most common concurrency problems, will be the first problem
    that we analyze in this book. In this chapter, we will discuss the theoretical
    causes of deadlocks in concurrent programming. We will cover a classical synchronization
    problem in concurrency, called the Dining Philosophers problem, as a real-life
    example of deadlock. We will also illustrate an actual implementation of deadlock
    in Python. We will discuss several methods to address the problem. This chapter
    will also cover the concept of livelock, which is relevant to deadlock and is
    a relatively common problem in concurrent programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是并发问题中最常见的问题之一。在本章中，我们将讨论并发编程中死锁的理论原因。我们将涵盖并发中的一个经典同步问题，称为哲学家就餐问题，作为死锁的现实例子。我们还将在Python中演示死锁的实际实现。我们将讨论解决该问题的几种方法。本章还将涵盖与死锁相关的活锁概念，这是并发编程中相对常见的问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The idea behind deadlock, and how to simulate it in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁的概念，以及如何在Python中模拟它
- en: Common solutions to deadlock, and how to implement them in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁的常见解决方案，以及如何在Python中实现它们
- en: The concept of livelock, and its connection to deadlock
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活锁的概念，以及它与死锁的关系
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上安装了Python 3
- en: Download the GitHub repository at** [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: In this chapter, we will be working with the subfolder titled **`Chapter12`**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为**`Chapter12`**的子文件夹进行工作
- en: Check out the following video to see the Code in Action: [http://bit.ly/2r2WKaU](http://bit.ly/2r2WKaU)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2r2WKaU](http://bit.ly/2r2WKaU)
- en: The concept of deadlock
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁的概念
- en: In the field of computer science, deadlock refers to a specific situation in
    concurrent programming, in which no progress can be made and the program becomes
    locked in its current state. In most cases, this phenomenon is caused by a lack
    of, or mishandled, coordination between different lock objects (for thread synchronization
    purposes). In this section, we will discuss a thought experiment commonly known
    as the Dining Philosophers problem, in order to illustrate the concept of deadlock
    and its causes; from there, you will learn how to simulate the problem in a Python
    concurrent program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，死锁指的是并发编程中的一种特定情况，即程序无法取得进展并且陷入当前状态。在大多数情况下，这种现象是由于不同锁对象之间的协调不足或处理不当（用于线程同步目的）。在本节中，我们将讨论一个被称为哲学家就餐问题的思想实验，以阐明死锁及其原因的概念；从那里，您将学习如何在Python并发程序中模拟该问题。
- en: The Dining Philosophers problem
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哲学家就餐问题
- en: The Dining Philosophers problem was first introduced by Edgar Dijkstra (who,
    as you learned in **[Chapter 1](0159c46a-c66b-4ba3-87b5-81dbeb3bcf02.xhtml)**, *Advanced
    Introduction to Concurrent and Parallel Programming* was a leading pioneer in
    concurrent programming) in 1965\. The problem was first demonstrated using different
    technical terms (resource contention in computer systems), and was later rephrased
    by Tony Hoare, a British computer scientist and the inventor of the quicksort
    sorting algorithm. The problem statement is as follows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学家就餐问题最初是由Edgar Dijkstra（正如您在**[第1章](0159c46a-c66b-4ba3-87b5-81dbeb3bcf02.xhtml)**中学到的那样，*并发和并行编程的高级介绍*是并发编程的领先先驱）在1965年首次提出的。该问题最初使用不同的技术术语（计算机系统中的资源争用）进行演示，并且后来由Tony
    Hoare重新表述，他是一位英国计算机科学家，也是快速排序算法的发明者。问题陈述如下。
- en: 'Five philosophers sit around a table, and each has a bowl of food in front
    of them. Placed between these five bowls of food are five forks, so each philosopher
    has a fork on their left side, and one on their right side. This setup is demonstrated
    by the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 五位哲学家围坐在一张桌子旁，每个人面前都有一碗食物。在这五碗食物之间放着五把叉子，所以每个哲学家左边和右边都有一把叉子。这个设置由以下图表演示：
- en: '![](assets/4d3213aa-ee0f-4d22-a967-af295e8e34b5.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d3213aa-ee0f-4d22-a967-af295e8e34b5.png)'
- en: An illustration of the Dining Philosophers problem
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学家就餐问题的插图
- en: Each silent philosopher is to alternate between thinking and eating. Each philosopher
    is required to have both of the forks around them to be able to pick up the food
    from their individual bowl, and no fork can be shared between two or more different
    philosophers. When a philosopher finishes eating a specific amount of food, they
    are to place both of the forks back in their respective, original locations. At
    this point, the philosophers around that philosopher will be able to use those
    forks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每位沉默的哲学家都要在思考和进餐之间交替。每位哲学家需要周围的两把叉子才能够拿起自己碗里的食物，而且一把叉子不能被两个或更多不同的哲学家共享。当一个哲学家吃完一定量的食物后，他们需要把两把叉子放回原来的位置。在这一点上，那位哲学家周围的哲学家将能够使用那些叉子。
- en: Since the philosophers are silent and cannot communicate with each other, they
    have no method to let each other know they need the forks to eat. In other words,
    the only way for a philosopher to eat is to have both of the forks already available
    to them. The question of this problem is to design a set of instructions for the
    philosophers to efficiently switch between eating and thinking, so that each philosopher
    is provided with enough food.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哲学家们是沉默的，无法相互交流，因此他们没有方法让彼此知道他们需要叉子来吃饭。换句话说，哲学家吃饭的唯一方法是已经有两把叉子可供他们使用。这个问题的问题是设计一组指令，使哲学家能够有效地在进餐和思考之间切换，以便每个哲学家都能得到足够的食物。
- en: 'Now, a potential approach to this problem would be the following set of instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解决这个问题的一个潜在方法可能是以下一组指令：
- en: A philosopher must think until the fork on their left side becomes available.
    When that happens, the philosopher is to pick it up.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哲学家必须思考，直到他们左边的叉子可用。当这种情况发生时，哲学家就要拿起它。
- en: A philosopher must think until the fork on their right side becomes available.
    When that happens, the philosopher is to pick it up.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哲学家必须思考，直到他们右边的叉子可用。当这种情况发生时，哲学家就要拿起它。
- en: 'If a philosopher is holding two forks, they will eat a specific amount of food
    from the bowl in front of them, and then the following will apply:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个哲学家手里拿着两个叉子，他们会从面前的碗里吃一定量的食物，然后以下情况将适用：
- en: Afterwards, the philosopher has to put the right fork down in its original place
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，哲学家必须把右边的叉子放回原来的位置
- en: Afterwards, the philosopher has to put the left fork down in its original place
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，哲学家必须把左边的叉子放回原来的位置。
- en: The process repeats from the first bullet point.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过程从第一个项目重复。
- en: It is quite clear how this set of instructions can lead to a situation where
    no progress can be made; namely, if at the beginning, all of the philosophers
    start to execute their instructions at the same time. Since all of the forks are
    on the table at the beginning, and are therefore available to be picked up by
    nearby philosophers, each philosopher will be able to execute the first instruction
    (picking up the fork on their left side).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这一系列指令如何导致无法取得进展的情况；也就是说，如果一开始所有哲学家都同时开始执行他们的指令。由于一开始所有叉子都在桌子上，因此附近的哲学家可以拿起叉子执行第一个指令（拿起左边的叉子）。
- en: Now, after this step, each philosopher will be holding a fork with their left
    hand, and no forks will be left on the table. Since no philosopher has both forks
    in their hands, they cannot proceed to eat their food. Furthermore, the set of
    instructions that they were given specifies that only after a philosopher has
    eaten a specific amount of food can they put their forks down on the table. This
    means that as long as a philosopher has not eaten, they will not release any fork
    that they are holding.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过这一步，每个哲学家都会用左手拿着一个叉子，桌子上不会剩下叉子。由于没有哲学家手里同时拿着两个叉子，他们无法开始吃饭。此外，他们得到的指令集规定，只有在哲学家吃了一定量的食物后，才能把叉子放在桌子上。这意味着只要哲学家没有吃饭，他们就不会放下手里的叉子。
- en: So, as each philosopher is holding only one fork with their left hand, they
    cannot proceed to eat or put down the fork they are holding. The only time a philosopher
    gets to eat their food is when their neighboring philosopher puts their fork down,
    which is only possible if they can eat their own food; this creates a never-ending
    circle of conditions that can never be satisfied. This situation is, in essence,
    the nature of a deadlock, in which all of the elements of a system are stuck in
    place, and no progress can be made.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个哲学家只用左手拿着一个叉子，无法开始吃饭或放下手里的叉子。哲学家能吃饭的唯一时机是邻座的哲学家放下叉子，而这只有在他们自己能吃饭的情况下才可能发生；这造成了一个永无止境的条件循环，无法满足。这种情况本质上就是死锁的特性，系统中的所有元素都被困在原地，无法取得进展。
- en: Deadlock in a concurrent system
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发系统中的死锁
- en: With the example of the Dining Philosophers problem in mind, let us consider
    the formal concept of deadlock, and the relevant theories around it. Given a concurrent
    program with multiple threads or processes, the execution flow enters a situation
    of deadlock if a process (or thread) is waiting on a resource that is being held
    and utilized by another process, which is, in turn, waiting for another resource
    that is held by a different process. In other words, processes cannot proceed
    with their execution instructions while waiting for resources that can only be
    released after the execution is completed; therefore, these processes are unable
    to change their execution states.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到餐桌哲学家问题的例子，让我们考虑死锁的正式概念以及相关的理论。给定一个具有多个线程或进程的并发程序，如果一个进程（或线程）正在等待另一个进程持有并使用的资源，而另一个进程又在等待另一个进程持有的资源，那么执行流程就会陷入死锁。换句话说，进程在等待只有在执行完成后才能释放的资源时，无法继续执行其指令；因此，这些进程无法改变其执行状态。
- en: 'Deadlock is also defined by the conditions that a concurrent program needs
    to have at the same time in order for deadlock to occur. These conditions were
    first proposed by the computer scientist Edward G. Coffman, Jr., and are therefore
    known as the Coffman conditions. These conditions are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁还由并发程序需要同时具备的条件来定义。这些条件最初由计算机科学家Edward G. Coffman, Jr.提出，因此被称为Coffman条件。这些条件如下：
- en: At least one resource has to be in a non-shareable state. This means that that
    resource is being held by an individual process (or thread), and cannot be accessed
    by others; the resource can only be accessed and held by a single process (or
    thread) at any given time. This condition is also known as mutual exclusion.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一个资源必须处于不可共享的状态。这意味着资源被一个单独的进程（或线程）持有，其他人无法访问；资源只能被单个进程（或线程）在任何给定时间内访问和持有。这种情况也被称为互斥。
- en: There exists one process (or thread) that is simultaneously accessing a resource
    and waiting for another held by other processes (or threads). In other words,
    this process (or thread) needs access to two resources in order to execute its
    instructions, one of which it is already holding, the other of which it is waiting
    for from other processes (or threads). This condition is called hold and wait.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个同时访问资源并等待其他进程（或线程）持有的进程（或线程）。换句话说，这个进程（或线程）需要访问两个资源才能执行其指令，其中一个已经持有，另一个则需要等待其他进程（或线程）释放。这种情况称为持有和等待。
- en: Resources can only be released by a process (or a thread) holding them if there
    are specific instructions for the process (or thread) to do so. This is to say
    that unless the process (or thread) voluntarily and actively releases the resource,
    that resource remains in a non-shareable state. This is the no preemption condition.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源只能由持有它们的进程（或线程）释放，如果有特定的指令要求进程（或线程）这样做。这就是说，除非进程（或线程）自愿主动释放资源，否则该资源将保持在不可共享的状态。这就是无抢占条件。
- en: The final condition is called circular wait. As suggested by the name, this
    condition specifies that there exists a set of processes (or threads) such that the
    first process (or thread) in the set is in a waiting state for a resource to be
    released by the second process (or thread), which, in turn, needs to be waiting
    for the third process (or thread); finally, the last process (or thread) in the
    set is waiting for the first one.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的条件称为循环等待。正如名称所示，该条件指定存在一组进程（或线程），使得该组中的第一个进程（或线程）处于等待状态，等待第二个进程（或线程）释放资源，而第二个进程（或线程）又需要等待第三个进程（或线程）；最后，该组中的最后一个进程（或线程）等待第一个进程。
- en: 'Let us quickly take a look at a basic example of deadlock. Consider a concurrent
    program in which there are two different processes (process **A** and process
    **B**), and two different resources (resource **R1** and resource **R2**), as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一个死锁的基本例子。考虑一个并发程序，其中有两个不同的进程（进程**A**和进程**B**），以及两个不同的资源（资源**R1**和资源**R2**），如下所示：
- en: '![](assets/e440b909-cfa2-4257-9c5c-6ab2a8eb71e2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e440b909-cfa2-4257-9c5c-6ab2a8eb71e2.png)'
- en: Sample deadlock diagram
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 样本死锁图
- en: Neither of the resources can be shared across separate processes, and each process
    needs to access both resources to execute its instructions. Take process **A**,
    for example. It is already holding resource **R1**, but its also needs **R2**
    to proceed with its execution. However, **R2** cannot be acquired by process **A**,
    as it is being held by process **B**. So, process **A** cannot proceed. The same
    goes for process **B**, which is holding **R2** and needs **R1** to proceed. **R1**
    is, in turn, held by process **A**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个资源都不能在不同的进程之间共享，并且每个进程都需要访问这两个资源来执行其指令。以进程**A**为例。它已经持有资源**R1**，但它还需要**R2**来继续执行。然而，**R2**无法被进程**A**获取，因为它被进程**B**持有。因此，进程**A**无法继续。进程**B**也是一样，它持有**R2**，并且需要**R1**来继续。而**R1**又被进程**A**持有。
- en: Python simulation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python模拟
- en: In this section, we will implement the preceding situation in an actual Python
    program. Specifically, we will have two locks (we will call them lock A and lock
    B), and two separate threads interacting with the locks (thread A and thread B).
    In our program, we will set up a situation in which thread A has acquired lock
    A and is waiting to acquire lock B, which has already been acquired by thread
    B, which is, in turn, waiting for lock A to be released.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在一个实际的Python程序中实现前面的情况。具体来说，我们将有两个锁（我们将它们称为锁A和锁B），以及两个分开的线程与锁交互（线程A和线程B）。在我们的程序中，我们将设置这样一种情况：线程A已经获取了锁A，并且正在等待获取锁B，而锁B已经被线程B获取，并且正在等待锁A被释放。
- en: 'If you have already downloaded the code for this book from the GitHub page,
    go ahead and navigate to the `Chapter12` folder. Let us consider the `Chapter12/example1.py`
    file, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经从GitHub页面下载了本书的代码，请转到`Chapter12`文件夹。让我们考虑`Chapter12/example1.py`文件，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this script, the `thread_a()` and `thread_b()` functions specify our thread
    A and thread B, respectively. In our main program, we also have two `threading.Lock`
    objects: lock A and lock B. The general structure of the thread instructions is
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`thread_a()`和`thread_b()`函数分别指定了我们的线程A和线程B。在我们的主程序中，我们还有两个`threading.Lock`对象：锁A和锁B。线程指令的一般结构如下：
- en: Start the thread
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程
- en: Try to acquire the lock with the same name as the thread (thread A will try
    to acquire lock A, and thread B will try to acquire lock B)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试获取与线程名称相同的锁（线程A将尝试获取锁A，线程B将尝试获取锁B）
- en: Perform some calculations
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些计算
- en: Try to acquire the other lock (thread A will try to acquire lock B, and thread
    B will try to acquire lock A)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试获取另一个锁（线程A将尝试获取锁B，线程B将尝试获取锁A）
- en: Perform some other calculations
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些其他计算
- en: Release both locks
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放两个锁
- en: End the thread
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束线程
- en: Note that we are using the `time.sleep()` function to simulate the action of
    some calculations being processed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`time.sleep()`函数来模拟一些计算正在进行的动作。
- en: First of all, we are starting both thread A and thread B almost simultaneously,
    within the main program. With the structure of the thread instruction set in mind,
    we can see that at this point, both threads will be initiated; thread A will try
    to acquire lock A, and will succeed in doing so, since lock A is still available
    at this point. The same goes for thread B and lock B. The two threads will then
    go on to perform some calculations on their own.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们几乎同时启动线程A和线程B，在主程序中。考虑到线程指令集的结构，我们可以看到此时两个线程将被启动；线程A将尝试获取锁A，并且会成功，因为此时锁A仍然可用。线程B和锁B也是一样。然后两个线程将继续进行一些计算。
- en: 'Let us consider the current state of our program: lock A has been acquired
    by thread A, and lock B has been acquired by thread B. After their respective
    calculation processes are complete, thread A will then try to acquire lock B,
    and thread B will try to acquire lock A. We can easily see that this is the beginning
    of our deadlock situation: since lock B is already being held by thread B, and
    cannot be acquired by thread A, thread B, for the same reason, cannot acquire
    lock A.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们程序的当前状态：锁A已被线程A获取，锁B已被线程B获取。在它们各自的计算过程完成后，线程A将尝试获取锁B，线程B将尝试获取锁A。我们很容易看出这是我们死锁情况的开始：由于锁B已经被线程B持有，并且无法被线程A获取，出于同样的原因，线程B也无法获取锁A。
- en: Both of the threads will now wait infinitely, in order to acquire their respective
    second lock. However, the only way a lock can be released is for a thread to continue
    its execution instructions and release all of the locks it has at the end. Our
    program will therefore be stuck in its execution at this point, and no further
    progress will be made.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个线程将无限等待，以获取它们各自的第二个锁。然而，锁能够被释放的唯一方式是线程继续执行指令并在最后释放它所持有的所有锁。因此，我们的程序将在这一点上被卡住，不会再有进展。
- en: 'The following diagram further illustrates the process of how the deadlock unfolds,
    in sequence:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进一步说明了死锁是如何按顺序展开的。
- en: '![](assets/bd657a2f-bc26-424b-a3ef-06c0bd441ffa.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd657a2f-bc26-424b-a3ef-06c0bd441ffa.png)'
- en: Deadlock sequence diagram
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁序列图
- en: 'Now, let''s see the deadlock that we have created in action. Run the script,
    and you should obtain the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们创建的死锁是如何发生的。运行脚本，你应该会得到以下输出：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we discussed, since each thread is trying to acquire a lock that is currently
    held by the other thread, and the only way for a lock to be released is for a
    thread to continue its execution. This is a deadlock, and your program will hang
    infinitely, never reaching the final print statement in the last line of the program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，由于每个线程都试图获取另一个线程当前持有的锁，而锁能够被释放的唯一方式是线程继续执行。这就是死锁，你的程序将无限挂起，永远无法到达程序最后一行的最终打印语句。
- en: Approaches to deadlock situations
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁情况的方法
- en: As we have seen, deadlock can lead our concurrent programs to an infinite hang,
    which is undesirable in every way. In this section, we will be discussing potential
    approaches to prevent deadlocks from occurring. Intuitively, each approach looks
    to eliminate one of the four Coffman conditions from our program, in order to
    prevent deadlocks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，死锁会导致我们的并发程序陷入无限挂起，这在任何情况下都是不可取的。在本节中，我们将讨论预防死锁发生的潜在方法。直觉上，每种方法都旨在消除程序中的四个Coffman条件之一，以防止死锁发生。
- en: Implementing ranking among resources
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现资源之间的排名
- en: From both the Dining Philosophers problem and our Python example, we can see
    that the last condition of the four Coffman conditions, circular wait, is at the
    heart of the problem of deadlock. It specifies that the different processes (or
    threads) in our concurrent program wait for resources held by other processes
    (or threads) in a circular manner. Giving this a closer look, we can see that
    the root cause for this condition is the order (or lack thereof) in which the
    processes (or threads) access the resources.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从哲学家就餐问题和我们的Python示例中，我们可以看到四个Coffman条件中的最后一个条件，循环等待，是死锁问题的核心。它指定了并发程序中不同进程（或线程）等待其他进程（或线程）持有的资源的循环方式。仔细观察后，我们可以看到这种条件的根本原因是进程（或线程）访问资源的顺序（或缺乏顺序）。
- en: In the Dining Philosophers problem, each philosopher is instructed to pick up
    the fork on their left side first, while in our Python example, the threads always
    try to acquire the locks with the same name before performing any calculations.
    As you have seen, when the philosophers want to start eating at the same time,
    they will pick up their respective left forks, and will be stuck in an infinite
    wait; similarly, when the two threads start their execution at the same time,
    they will acquire their individual locks, and, again, they will wait for the other
    locks infinitely.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在哲学家就餐问题中，每个哲学家都被指示首先拿起左边的叉子，而在我们的Python示例中，线程总是在执行任何计算之前尝试获取同名的锁。正如你所见，当哲学家们想同时开始就餐时，他们会拿起各自左边的叉子，并陷入无限等待；同样，当两个线程同时开始执行时，它们将获取各自的锁，然后再次无限等待另一个锁。
- en: The conclusion that we can infer from this is that if, instead of accessing
    the resources arbitrarily, the processes (or threads) were to access them in a
    predetermined, static order, the circular nature of the way that they acquire
    and wait for the resources will be eliminated. So, for our two-lock Python example,
    instead of having thread A try to acquire lock A and thread B try to acquire lock
    B in their respective execution instructions, we will require that both threads
    try to acquire the locks in the same order. For example, both threads will now
    try to acquire lock A first, perform some calculations, try to acquire lock B,
    perform further calculations, and finally, release both threads.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中得出的结论是，如果进程（或线程）不是任意地访问资源，而是按照预定的静态顺序访问它们，那么它们获取和等待资源的循环性质将被消除。因此，对于我们的两把锁Python示例，我们将要求两个线程以相同的顺序尝试获取锁。例如，现在两个线程将首先尝试获取锁A，进行一些计算，然后尝试获取锁B，进行进一步的计算，最后释放两个线程。
- en: 'This change is implemented in the `Chapter12/example2.py` file, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变是在`Chapter12/example2.py`文件中实现的，如下所示：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This version of the script is now able to finish its execution, and should
    produce the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的脚本现在能够完成执行，并应该产生以下输出：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This approach efficiently eliminates the problem of deadlock in our two-lock
    example, but how well does it hold up for the Dining Philosophers problem? To
    answer this question, let''s try to simulate the problem and the solution in Python
    by ourselves. The `Chapter12/example3.py` file contains the implementation of
    the Dining Philosophers problem in Python, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效地消除了我们两把锁示例中的死锁问题，但它对哲学家就餐问题的解决方案有多大的影响呢？为了回答这个问题，让我们尝试自己在Python中模拟问题和解决方案。`Chapter12/example3.py`文件包含了Python中哲学家就餐问题的实现，如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have the `philospher()` function as the underlying logic for our separate
    threads. It takes in two `Threading.Lock` objects and simulates the previously
    discussed eating procedure, with two context managers. In our main program, we
    create a list of five lock objects, named `forks`, and a list of five threads,
    named `phils`, with the specification that the first thread will take in the first
    and second locks, the second thread will take in the second and third locks, and
    so on; and the fifth thread will take in the fifth and first locks (in order).
    Finally, we start all five threads simultaneously.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`philospher()`函数作为我们单独线程的基本逻辑。它接受两个`Threading.Lock`对象，并模拟先前讨论的吃饭过程，使用两个上下文管理器。在我们的主程序中，我们创建了一个名为`forks`的五个锁对象的列表，以及一个名为`phils`的五个线程的列表，规定第一个线程将获取第一个和第二个锁，第二个线程将获取第二个和第三个锁，依此类推；第五个线程将按顺序获取第五个和第一个锁。最后，我们同时启动所有五个线程。
- en: 'Run the script, and it can easily be observed that deadlock occurs almost immediately.
    The following is my output, up until the program hangs infinitely:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，可以很容易地观察到死锁几乎立即发生。以下是我的输出，直到程序无限挂起：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The question that naturally follows is: how can we implement an order in which
    the locks are acquired in the `philosopher()` function? We will be using the built-in
    `id()` function in Python, which returns the unique, constant identity of the
    parameter, as the keys to sort the lock objects. We will also implement a custom
    context manager, in order to factor out this sorting logic in a separate class.
    Navigate to `Chapter12/example4.py` for this specific implementation, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来自然而然的问题是：我们如何在`philosopher()`函数中实现获取锁的顺序？我们将使用Python中内置的`id()`函数，该函数返回参数的唯一常量标识作为排序锁对象的键。我们还将实现一个自定义上下文管理器，以便将这个排序逻辑分离到一个单独的类中。请转到`Chapter12/example4.py`查看具体实现。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the main program remaining in the same, this script will produce an output
    showing that this solution of ranking can effectively address the Dining Philosophers
    problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序保持不变的情况下，这个脚本将产生一个输出，显示排序的解决方案可以有效解决哲学家就餐问题。
- en: However, there is a problem with this approach when it is applied to some particular
    cases. Keeping the high-level idea of concurrency in mind, we know that one of
    our main goals when applying concurrency to our programs is to improve the speed.
    Let us go back to our two-lock example and examine the execution time of our program
    with resource ranking implemented. Take a look at the `Chapter12/example5.py`
    file; it is simply the two-lock program with ranked (or ordered) locking implemented,
    combined with a timer that is added to keep track of how much time it takes for
    the two threads to finish executing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这种方法应用于某些特定情况时，会出现问题。牢记并发的高级思想，我们知道在将并发应用于程序时的主要目标之一是提高速度。让我们回到我们的两锁示例，检查实现资源排序后程序的执行时间。看一下`Chapter12/example5.py`文件；它只是实现了排序（或有序）锁定的两锁程序，结合了一个计时器，用于跟踪两个线程完成执行所需的时间。
- en: 'After running the script, your output should look similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你的输出应该类似于以下内容：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that the combined execution of both threads took around 14 seconds.
    However, if we take a closer look at the specific instructions in the two threads,
    we can see that aside from interacting with the locks, thread A would take around
    4 seconds to do its calculations (simulated by two `time.sleep(2)` commands),
    while thread B would take around 10 seconds (two `time.sleep(5)` commands).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到两个线程的组合执行大约需要14秒。然而，如果我们仔细看两个线程的具体指令，除了与锁交互外，线程A需要大约4秒来进行计算（通过两个`time.sleep(2)`命令模拟），而线程B需要大约10秒（两个`time.sleep(5)`命令）。
- en: 'Does this mean that our program is taking as long as it would if we were to
    execute the two threads sequentially? We will test this theory with our `Chapter12/example6.py`
    file, in which we specify that each thread should execute its instructions one
    at a time, in our main program:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们的程序花费的时间与我们按顺序执行两个线程时一样长？我们将用`Chapter12/example6.py`文件测试这个理论，在这个文件中，我们规定每个线程应该在主程序中依次执行它的指令：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run this script, and you will see that this sequential version of our two-lock
    program will take the same amount of time as its concurrent counterpart:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本，你会发现我们的两锁程序的顺序版本将花费与并发版本相同的时间。
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This interesting phenomenon is a direct result of the heavy requirements that
    we have placed on the locks in the program. In other words, since each thread
    has to acquire both locks to complete its execution, each lock cannot be acquired
    by more than one thread at any given time, and finally, the locks are required
    to be acquired in a specific order, and the execution of individual threads cannot
    happen simultaneously. If we were to go back and examine the output produced by
    the `Chapter12/example5.py` file, it would be apparent that thread B could not
    start its calculations after thread A released both locks at the end of its execution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的现象是我们在程序中对锁的严格要求的直接结果。换句话说，由于每个线程都必须获取两个锁才能完成执行，每个锁在任何给定时间内都不能被多个线程获取，最后，需要按特定顺序获取锁，并且单个线程的执行不能同时发生。如果我们回过头来检查`Chapter12/example5.py`文件产生的输出，很明显可以看到线程B在线程A在执行结束时释放两个锁后无法开始计算。
- en: It is quite intuitive, then, to arrive at the conclusion that if you placed
    enough locks on the resources of your concurrent program, it would become entirely
    sequential in its execution, and, combined with the overhead of concurrent programming
    functionalities, it would have an even worse speed than the purely sequential
    version of the program. However, we did not see in the Dining Philosophers problem
    (simulated in Python) this sequentiality created by locks. This is because in
    the two-thread problem, two locks were enough to sequentialize the program execution,
    while five were not enough to do the same for the Dining Philosophers problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很直观地得出结论，如果在并发程序的资源上放置了足够多的锁，它将在执行上变得完全顺序化，并且结合并发编程功能的开销，它的速度甚至会比程序的纯顺序版本更糟糕。然而，在餐桌哲学家问题中（在
    Python 中模拟），我们没有看到锁所创建的这种顺序性。这是因为在两线程问题中，两个锁足以使程序执行顺序化，而五个锁不足以使餐桌哲学家问题执行顺序化。
- en: We will explore another instance of this phenomenon in [Chapter 14](d87c597d-2130-4847-9ca9-e12021bc7a0c.xhtml),
    *Race Conditions*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第14章》*竞争条件*中探讨这种现象的另一个实例。
- en: Ignoring locks and sharing resources
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略锁并共享资源
- en: 'Locks are undoubtedly an important tool in synchronization tasks, and in concurrent
    programming in general. However, if the use of locks leads to an undesirable situation,
    such as a deadlock, then it is quite natural for us to explore the option of simply
    not using locks in our concurrent programs. By ignoring locks, our program''s
    resources effectively become shareable among different processes/threads in a
    concurrent program, thus eliminating the first of the four Coffman conditions:
    mutual exclusion.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 锁无疑是同步任务中的重要工具，在并发编程中也是如此。然而，如果锁的使用导致不良情况，比如死锁，那么我们很自然地会探索在并发程序中简单地不使用锁的选项。通过忽略锁，我们程序的资源有效地在并发程序中的不同进程/线程之间可以共享，从而消除了
    Coffman 条件中的第一个条件：互斥。
- en: 'This approach to the problem of deadlock can be straightforward to implement;
    let us try with the two preceding examples. In the two-lock example, we simply
    remove the code specifying any interaction with the lock objects both inside the
    thread functions and in the main program. In other words, we are not utilizing
    a locking mechanism anymore. The `Chapter12/example7.py` file contains the implementation
    of this approach, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决死锁问题的方法可能很容易实现；让我们尝试前面的两个例子。在两锁示例中，我们简单地删除了指定与线程函数和主程序中的锁对象的任何交互的代码。换句话说，我们不再使用锁定机制。`Chapter12/example7.py`
    文件包含了这种方法的实现，如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the script, and your output should look similar to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你的输出应该类似于以下内容：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is clear that since we are not using locks to restrict access to any calculation
    processes, the executions of the two threads have now become entirely independent
    of one another, and the threads were therefore run completely in parallel. For
    this reason, we also obtained a better speed: since the threads ran in parallel,
    the total time that the whole program took was the same as the time that the longer
    task of the two threads took (in other words, thread B, with 10 seconds).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，由于我们不使用锁来限制对任何计算过程的访问，两个线程的执行现在已经完全独立于彼此，因此线程完全并行运行。因此，我们也获得了更好的速度：由于线程并行运行，整个程序所花费的总时间与两个线程中较长任务所花费的时间相同（换句话说，线程
    B，10秒）。
- en: What about the Dining Philosophers problem? It seems that we can also conclude
    that without locks (the forks), the problem can be solved easily. Since the resources
    (food) are unique to each philosopher (in other words, no philosopher should eat
    another philosopher's food), it should be the case that each philosopher can proceed
    with their execution without worrying about the others. By ignoring the locks,
    each can be executed in parallel, similar to what we saw in our two-lock example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么餐桌哲学家问题呢？似乎我们也可以得出结论，没有锁（叉子）的情况下，问题可以很容易地解决。由于资源（食物）对于每个哲学家都是独特的（换句话说，没有哲学家应该吃另一个哲学家的食物），因此每个哲学家都可以在不担心其他人的情况下继续执行。通过忽略锁，每个哲学家可以并行执行，类似于我们在两锁示例中看到的情况。
- en: Doing this, however, means that we are completely misunderstanding the problem.
    We know that locks are utilized so that processes and threads can access the shared
    resources in a program in a systematic, coordinated way, to avoid mishandling
    the data. Therefore, removing any locking mechanisms in a concurrent program means
    that the likelihood of the shared resources, which are now free from access limitations,
    being manipulated in an uncoordinated way (and therefore, becoming corrupted)
    increases significantly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做意味着我们完全误解了问题。我们知道锁被利用来让进程和线程可以以系统化、协调的方式访问程序中的共享资源，以避免对数据的错误处理。因此，在并发程序中移除任何锁定机制意味着共享资源的可能性，这些资源现在不受访问限制，被以不协调的方式操纵（因此，变得损坏）的可能性显著增加。
- en: So, by ignoring locks, it is relatively likely that we will need to completely
    redesign and restructure our concurrent program. If the shared resources still
    need to be accessed and manipulated in an organized way, other synchronization
    methods will need to be implemented. The logic of our processes and threads might
    need to be altered to appropriately interact with this new synchronization method,
    the execution time might be negatively affected by this change in the structure
    of the program, and other potential synchronization problems might also arise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过忽略锁，我们很可能需要完全重新设计和重构我们的并发程序。如果共享资源仍然需要以有组织的方式访问和操作，就需要实现其他同步方法。我们的进程和线程的逻辑可能需要改变以适当地与这种新的同步方法进行交互，执行时间可能会受到程序结构变化的负面影响，还可能会出现其他潜在的同步问题。
- en: An additional note about locks
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于锁的额外说明
- en: 'While the approach of dismissing locking mechanisms in our program to eliminate
    deadlocks might raise some questions and concerns, it does effectively reveal
    a new point for us about lock objects in Python: it is possible for an element
    of a concurrent program to completely bypass the locks when accessing a given
    resource. In other words, lock objects only prevent different processes/threads
    from accessing and manipulating a shared resource if those processes or threads
    actually acquire the lock objects.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的程序中取消锁定机制以消除死锁的方法可能会引发一些问题和关注，但它确实为我们揭示了Python中锁对象的一个新点：在访问给定资源时，一个并发程序的元素完全可以绕过锁。换句话说，锁对象只有在进程/线程实际获取锁对象时，才能阻止不同的进程/线程访问和操作共享资源。
- en: Locks, then, do not actually lock anything. They are simply flags that help
    to indicate whether a resource should be accessed at a given time; if a poorly
    instructed, or even malicious, process/thread attempts to access that resource
    without checking the lock object exists, it will most likely be able to do that
    without difficulty. In other words, locks are not at all connected to the resources
    that they are supposed to lock, and they most certainly do not block processes/threads
    from accessing those resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，锁实际上并没有锁定任何东西。它们只是标志，帮助指示在给定时间是否应该访问资源；如果一个指令不清晰甚至恶意的进程/线程试图在没有检查锁对象存在的情况下访问该资源，它很可能可以轻松地做到这一点。换句话说，锁根本不与它们应该锁定的资源相关联，它们绝对不会阻止进程/线程访问这些资源。
- en: The simple use of locks is therefore inefficient to design and implement a secure,
    dynamic, concurrent data structure. To achieve that, we would need to either add
    more concrete links between the locks and their corresponding resources, or utilize
    a different synchronization tool altogether (for example, atomic message queues).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单地使用锁来设计和实现安全的、动态的并发数据结构是低效的。为了实现这一点，我们需要在锁和它们对应的资源之间添加更多具体的链接，或者完全利用不同的同步工具（例如原子消息队列）。
- en: Concluding note on deadlock solutions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于死锁解决方案的结论
- en: You have seen two of the most common approaches to the problem of deadlock.
    Each addresses one of the four Coffman conditions, and, while both (somewhat)
    successfully prevent deadlocks from occurring in our examples, each raises different,
    additional problems and concerns. It is therefore important to truly understand
    the nature of your concurrent programs, in order to know which of the two is applicable,
    if either of them are.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了解决死锁问题的两种最常见方法。每种方法都解决了四个Coffman条件中的一个，虽然两种方法在我们的示例中都（在某种程度上）成功地防止了死锁的发生，但每种方法都引发了不同的额外问题和关注。因此，真正理解您的并发程序的性质非常重要，以便知道这两种方法中的哪一种是适用的，如果有的话。
- en: It is also possible that some programs, through deadlock, are revealed to us
    as unsuitable to be made concurrent; some programs are better left sequential,
    and will be made worse with forced concurrency. As we have discussed, while concurrency
    provides significant improvements in many areas of our applications, some are
    inherently inappropriate for the application of concurrent programming. In situations
    of deadlock, developers should be ready to consider different approaches to designing
    a concurrent program, and should not be reluctant to implement another method
    when one concurrent approach does not work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能，一些程序通过死锁向我们展示出不适合并发的特性；有些程序最好是按顺序执行，如果强制并发可能会变得更糟。正如我们所讨论的，虽然并发在我们应用程序的许多领域中提供了显著的改进，但有些领域本质上不适合并发编程的应用。在死锁的情况下，开发人员应该准备考虑设计并发程序的不同方法，并且在一个并发方法不起作用时不要犹豫地实现另一种方法。
- en: The concept of livelock
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活锁的概念
- en: The concept of livelock is connected to deadlock; some even consider it an alternate
    version of deadlock. In a livelock situation, the processes (or threads) in the
    concurrent program are able to switch their states; in fact, they switch states
    constantly. Yet, they simply switch back and forth infinitely, and no progress
    is made. We will now consider an actual scenario of livelock.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 活锁的概念与死锁有关；有些人甚至认为它是死锁的另一种版本。在活锁的情况下，并发程序中的进程（或线程）能够切换它们的状态；事实上，它们不断地切换状态。然而，它们只是无限地来回切换，没有任何进展。现在我们将考虑一个实际的活锁场景。
- en: 'Suppose that a pair of spouses are eating dinner together at a table. They
    only have one fork to share with each other, so only one of them can eat at any
    given point. Additionally, the spouses are really polite to each other, so even
    if one spouse is hungry and wants to eat their food, they will leave the fork
    on the table if their partner is also hungry. This specification is at the heart
    of creating a livelock for this problem: when both spouses are hungry, each will
    wait for the other to eat first, creating a infinite loop in which each spouse
    switches between wanting to eat and waiting for the other spouse to eat.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一对夫妇在一起吃晚餐。他们只有一个叉子可以共用，所以在任何给定的时间只有一个人可以吃。此外，夫妇之间非常彬彬有礼，所以即使其中一位饥饿想吃饭，如果另一位也饥饿，他们会把叉子放在桌子上。这个规定是创建这个问题的活锁的核心：当夫妇两个都饥饿时，每个人都会等待另一个先吃饭，从而创建一个无限循环，每个人都在想要吃饭和等待另一位先吃饭之间切换。
- en: 'Let''s simulate this problem in Python. Navigate to `Chapter12/example8.py`,
    and take a look at the `Spouse` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中模拟这个问题。转到`Chapter12/example8.py`，看一下`Spouse`类：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This class inherits from the `threading.Thread` class and implements the logic
    that we discussed previously. It takes in a name for the `Spouse` instance and
    another `Spouse` object as its partner; when initialized, a `Spouse` object is
    also always hungry (the `hungry` attribute is always set to `True`). The `run()`
    function in the class specifies the logic when the thread is started: as long
    as the `Spouse` object''s `hungry` attribute is set to `True`, the object will
    attempt to use the fork, which is a lock object, to eat. However, it always checks
    to see whether its partner also has its `hungry` attribute set to `True`, in which
    case, it will not proceed to acquire the lock, and will instead wait for its partner
    to do it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自`threading.Thread`类，并实现了我们之前讨论的逻辑。它接受一个`Spouse`实例的名称和另一个`Spouse`对象作为其伴侣；初始化时，`Spouse`对象也总是饥饿的（`hungry`属性始终设置为`True`）。类中的`run()`函数指定了线程启动时的逻辑：只要`Spouse`对象的`hungry`属性设置为`True`，对象将尝试使用叉子（一个锁对象）进食。但是，它总是检查其伴侣的`hungry`属性是否也设置为`True`，在这种情况下，它将不会继续获取锁，而是等待其伴侣这样做。
- en: 'In our main program, we create the fork as a lock object first; then, we create
    two `Spouse` thread objects, which are each other''s `partner` attributes. Finally,
    we start both threads, and run the program until both threads finish executing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，首先将叉子创建为一个锁对象；然后，我们创建两个`Spouse`线程对象，它们分别是彼此的`partner`属性。最后，我们启动两个线程，并运行程序直到两个线程都执行完毕：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the script, and you will see that, as we discussed, each thread will go
    into an infinite loop, switching between wanting to eat and waiting for its partner
    to eat; the program will run forever, until Python is interrupted. The following
    code shows the first few lines of the output that I obtained:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，您会看到，正如我们讨论的那样，每个线程都会进入一个无限循环，不断地在想要吃饭和等待伴侣吃饭之间切换；程序将永远运行，直到Python被中断。以下代码显示了我得到的输出的前几行：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the field of computer science, deadlock refers to a specific situation in
    concurrent programming, in which no progress is made and the program is locked
    in its current state. In most cases, this phenomenon is caused by a lack of, or
    mishandled, coordination between different lock objects, and it can be illustrated
    with the Dining Philosophers problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，死锁是指并发编程中的一种特定情况，即没有任何进展并且程序被锁定在当前状态。在大多数情况下，这种现象是由于不同锁对象之间缺乏或处理不当的协调引起的，可以用餐厅哲学家问题来说明。
- en: Potential approaches to preventing deadlocks from occurring include imposing
    an order for the lock objects and sharing non-shareable resources by ignoring
    lock objects. Each solution addresses one of the four Coffman conditions, and,
    while both solutions can successfully prevent deadlocks, each raises different,
    additional problems and concerns.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 预防死锁发生的潜在方法包括对锁对象施加顺序和通过忽略锁对象共享不可共享的资源。每种解决方案都解决了四个Coffman条件中的一个，虽然这两种解决方案都可以成功地防止死锁，但每种解决方案都会引发不同的额外问题和关注点。
- en: 'Connected to the concept of deadlock is livelock. In a livelock situation,
    processes (or threads) in the concurrent program are able to switch their states,
    but they simply switch back and forth infinitely, and no progress is made. In
    the next chapter, we will discuss another common problem in concurrent programming:
    starvation.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与死锁概念相关的是活锁。在活锁情况下，并发程序中的进程（或线程）能够切换它们的状态，但它们只是无休止地来回切换，没有任何进展。在下一章中，我们将讨论并发编程中的另一个常见问题：饥饿。
- en: Questions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What can lead to a deadlock situation, and why is it undesirable?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么会导致死锁情况，为什么这是不可取的？
- en: How is the Dining Philosophers problem related to the problem of deadlock?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅哲学家问题与死锁问题有什么关系？
- en: What are the four Coffman conditions?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是四个Coffman条件？
- en: How can resource ranking solve the problem of deadlock? What other problems
    can occur when this is implemented?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源排序如何解决死锁问题？在实施这一方法时可能会出现哪些其他问题？
- en: How can ignoring locks solve the problem of deadlock? What other problems can
    occur when this is implemented?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略锁如何解决死锁问题？在实施这一方法时可能会出现哪些其他问题？
- en: How is livelock related to deadlock?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活锁与死锁有什么关系？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: '*Parallel Programming with Python*, by Jan. Palach, Packt Publishing Ltd, 2014'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python进行并行编程*，作者Jan. Palach，Packt Publishing Ltd，2014'
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，作者Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Python Thread Deadlock Avoidance* ([dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20](http://dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20.html))'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python线程死锁避免*（[dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20](http://dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20.html)）'
