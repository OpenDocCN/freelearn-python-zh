- en: Appendix B. Common Pitfalls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 常见陷阱
- en: Read the API documents
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读API文档
- en: It may sound pedantic but it is not an exaggeration to say that many Python-related
    questions asked on Blender forums can simply be answered by reading the API docs
    thoroughly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来有些繁琐，但说许多在 Blender 论坛上提出的与 Python 相关的问题可以通过仔细阅读 API 文档来简单地回答，这并不夸张。
- en: Of course, these are not the easiest documents to read as they cover many topics
    and often it might not be clear where to start, so it might be a good idea to
    read them at least once in their entirety from start to finish. Not only will
    it give you some idea about the vast scope of the Blender API but it will also
    help you find specific subjects later on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些文档不是最容易阅读的，因为它们涵盖了众多主题，而且往往不清楚从哪里开始阅读，所以至少从头到尾完整阅读一次可能是个好主意。这不仅会给你一些关于
    Blender API 广阔范围的想法，而且还会帮助你以后找到特定的主题。
- en: The trouble with import
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入的问题
- en: One of the questions that regularly pops up is why the `import` statement isn't
    working as expected. The problem here is that you have to know what to expect.
    Blender has augmented the standard import behavior of Python to make it possible
    to import from the text files residing within a `.blend` file. This is a great
    boon because it allows you to modularize your code without the need to distribute
    separate files. However, the behavior of the part that imports these internal
    files should be absolutely clear to spare you nasty surprises but it is, at the
    moment, not very well-documented.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的问题之一是为什么 `import` 语句没有按预期工作。这里的问题是，你必须知道预期的结果。Blender 扩展了 Python 的标准导入行为，使其能够从
    `.blend` 文件中驻留的文本文件中导入。这是一个巨大的便利，因为它允许你模块化你的代码，而无需分发单独的文件。然而，导入这些内部文件的部分的行为应该非常清晰，以避免让你遇到令人不快的惊喜，但目前这部分并不是非常详细地记录在文档中。
- en: 'This is what happens when an `import` statement such as `import` `foo` is executed:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行如 `import foo` 这样的 `import` 语句时，会发生以下情况：
- en: Check whether `foo.pyc` or `foo.py` exists in any of the directories in `sys.path`
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `foo.pyc` 或 `foo.py` 是否存在于 `sys.path` 中的任何目录中
- en: 'If one of them exists:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中之一存在：
- en: if `foo.py` is newer
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `foo.py` 更新了
- en: compile `foo.pyfoo.pyc`
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 `foo.pyfoo.pyc`
- en: use `foo.pyc`
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `foo.pyc`
- en: 'Else, if `foo.py` exists as an internal text file:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果 `foo.py` 作为内部文本文件存在：
- en: 'if it is not compiled already:'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它尚未编译：
- en: compile internal text file
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译内部文本文件
- en: use compiled version
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译版本
- en: Else
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则
- en: raise an exception
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'The first part is Python''s regular behavior (it is a bit simplified from what
    really happens as we don''t mention packages or `.pyo` files here) and the second
    part is what Blender adds to it if the required module does not exist as an external
    file. There are two important things to note here: if an external file exists
    with the same name as an internal file, the external file (or its compiled version)
    takes precedence. This can be annoying because many people save an external copy
    of an internal file with the same name. If these two are out of sync unexpected
    things may happen. Fortunately, Blender''s internal editor reminds you of this
    situation by showing an **Out** **of** **Sync** button next to the name of the
    internal file. Still, if you haven''t opened the text editor on that specific
    file, you may not notice it.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是 Python 的常规行为（这里简化了一些，因为我们没有在这里提及包或 `.pyo` 文件），第二部分是如果所需的模块不是外部文件时，Blender
    添加到其中的内容。这里有两个重要的事项需要注意：如果存在与内部文件同名的外部文件，外部文件（或其编译版本）将具有优先权。这可能会让人烦恼，因为许多人保存了与内部文件同名的外部副本。如果这两个文件不同步，可能会发生意外的事情。幸运的是，Blender
    的内部编辑器通过在内部文件名称旁边显示一个 **Out of Sync**（不同步）按钮来提醒你这种情况。尽管如此，如果你没有打开该特定文件的文本编辑器，你可能不会注意到它。
- en: Furthermore, if you take a close look at the previous outline you will notice
    that if Blender is looking for an internal file it checks if this internal file
    is already compiled but does not check if the source might be newer. This means
    that any changes in the source code of an internal file that are to be imported
    will not be seen by the main program. To remedy this situation, you may force
    Python to compile the module by using the built-in `reload()` function. This is
    less efficient when running a program, but it saves a lot of headaches when developing.
    Once your script is production-ready you might drop the `reload()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你仔细查看之前的概述，你会注意到如果 Blender 正在寻找一个内部文件，它会检查这个内部文件是否已经编译，但不会检查源文件是否可能更新。这意味着任何要导入的内部源代码更改都不会被主程序看到。为了解决这个问题，你可以通过使用内置的
    `reload()` 函数强制 Python 编译模块。这在运行程序时效率较低，但在开发过程中可以节省很多麻烦。一旦你的脚本准备就绪，你可能会放弃使用 `reload()`。
- en: 'So suppose you have two internal files, `main.py` and `mymodule.py`, and you
    want to make sure changes in `module.py`, will always be visible once `main.py`
    is executed, then each file might look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个内部文件，`main.py` 和 `mymodule.py`，并且你想要确保在 `main.py` 执行后，`module.py` 的更改始终可见，那么每个文件可能看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The highlighted line shows the all important `reload()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了至关重要的 `reload()` 函数。
- en: Installing a full Python distribution
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装完整的 Python 发行版
- en: 'Two specific issues come up frequently: either a standard Python module seems
    to be missing (an `import` statement raises an exception telling you it can''t
    find the requested module) or Blender warns that it cannot find the Python distribution
    with a version equal to the compiled version.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个具体问题经常出现：要么是一个标准的 Python 模块似乎丢失了（一个 `import` 语句会引发异常，告诉你它找不到请求的模块），要么 Blender
    警告说它找不到与编译版本相等的 Python 发行版。
- en: 'Both issues were addressed in [Chapter 1](ch01.html "Chapter 1. Extending Blender
    with Python"), *Extending Blender with Python* and for additional information
    refer to: [http://wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python](http://wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都在 [第 1 章](ch01.html "第 1 章。使用 Python 扩展 Blender") *使用 Python 扩展 Blender*
    中得到了解决，并且对于更多信息请参考：[http://wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python](http://wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python)。
