- en: Working with Threads in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中处理线程
- en: In [Chapter 1](0159c46a-c66b-4ba3-87b5-81dbeb3bcf02.xhtml), *Advanced Introduction
    to Concurrent and Parallel Programming*, you saw an example of threads being used
    in concurrent and parallel programming. In this chapter, you will be introduced
    to the formal definition of a thread, as well as the `threading` module in Python.
    We will cover a number of ways to work with threads in a Python program, including
    activities such as creating new threads, synchronizing threads, and working with
    multithreaded priority queues, via specific examples. We will also discuss the
    concept of a lock in thread synchronization, and we will implement a lock-based
    multithreaded application, in order to better understand the benefits of thread
    synchronization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](0159c46a-c66b-4ba3-87b5-81dbeb3bcf02.xhtml)中，*并发和并行编程的高级介绍*，您看到了线程在并发和并行编程中的使用示例。在本章中，您将了解线程的正式定义，以及Python中的`threading`模块。我们将涵盖在Python程序中处理线程的多种方法，包括创建新线程、同步线程以及通过具体示例处理多线程优先队列等活动。我们还将讨论线程同步中锁的概念，并实现基于锁的多线程应用程序，以更好地理解线程同步的好处。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of a thread in the context of concurrent programming in computer
    science
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学中并发编程上下文中的线程概念
- en: The basic API of the `threading` module in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中`threading`模块的基本API
- en: How to create a new thread via the `threading` module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过`threading`模块创建新线程
- en: The concept of a lock and how to use different locking mechanisms to synchronize
    threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁的概念以及如何使用不同的锁定机制来同步线程
- en: The concept of a queue in the context of concurrent programming, and how to
    use the `Queue` module to work with queue objects in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程上下文中队列的概念，以及如何使用`Queue`模块在Python中处理队列对象
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上已安装Python 3
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: During this chapter, we will be working with the subfolder titled `Chapter03`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter03`的子文件夹进行工作
- en: Check out the following video to see the Code in Action: [http://bit.ly/2SeD2oz](http://bit.ly/2SeD2oz)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[http://bit.ly/2SeD2oz](http://bit.ly/2SeD2oz)
- en: The concept of a thread
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的概念
- en: In the field of computer science, a **thread of execution** is the smallest
    unit of programming commands (code) that a scheduler (usually as part of an operating
    system) can process and manage. Depending on the operating system, the implementation
    of threads and processes (which we will cover in future chapters) varies, but
    a thread is typically an element (a component) of a process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，**执行线程**是调度程序（通常作为操作系统的一部分）可以处理和管理的编程命令（代码）的最小单位。根据操作系统的不同，线程和进程的实现（我们将在以后的章节中介绍）有所不同，但线程通常是进程的一个元素（组件）。
- en: Threads versus processes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程与进程的区别
- en: More than one thread can be implemented within the same process, most often
    executing concurrently and accessing/sharing the same resources, such as memory;
    separate processes do not do this. Threads in the same process share the latter's
    instructions (its code) and context (the values that its variables reference at
    any given moment).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一进程中可以实现多个线程，通常并发执行并访问/共享相同的资源，如内存；而单独的进程不会这样做。同一进程中的线程共享后者的指令（其代码）和上下文（其变量在任何给定时刻引用的值）。
- en: 'The key difference between the two concepts is that a thread is typically a
    component of a process. Therefore, one process can include multiple threads, which
    can be executing simultaneously. Threads also usually allow for shared resources,
    such as memory and data, while it is fairly rare for processes to do so. In short,
    a thread is an independent component of computation that is similar to a process,
    but the threads within a process can share the address space, and hence the data,
    of that process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念之间的关键区别在于，线程通常是进程的组成部分。因此，一个进程可以包括多个线程，这些线程可以同时执行。线程通常也允许共享资源，如内存和数据，而进程很少这样做。简而言之，线程是计算的独立组件，类似于进程，但进程中的线程可以共享该进程的地址空间，因此也可以共享该进程的数据：
- en: '![](assets/8ffb5a66-8985-4179-9c11-3abb0a3b0f28.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ffb5a66-8985-4179-9c11-3abb0a3b0f28.png)'
- en: A process with two threads of execution running on one processor
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个处理器上运行的两个执行线程的进程
- en: Threads were reportedly first used for a variable number of tasks in OS/360
    multiprogramming, which is a discontinued batch processing system that was developed
    by IBM in 1967\. At the time, threads were called tasks by the developers, while
    the term thread became popular later on and has been attributed to Victor A. Vyssotsky,
    a mathematician and computer scientist who was the founding director of Digital's
    Cambridge Research Lab.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 据报道，线程最早用于OS/360多道程序设计中的可变数量任务，这是IBM于1967年开发的一种已停用的批处理系统。当时，开发人员将线程称为任务，而后来线程这个术语变得流行，并且被归因于数学家和计算机科学家维克托·A·维索茨基，他是Digital的剑桥研究实验室的创始主任。
- en: Multithreading
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: In computer science, single-threading is similar to traditional sequential processing,
    executing a single command at any given time. On the other hand, **multithreading**
    implements more than one thread to exist and execute in a single process, simultaneously.
    By allowing multiple threads to access shared resources/contexts and be executed
    independently, this programming technique can help applications to gain speed
    in the execution of independent tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，单线程类似于传统的顺序处理，一次执行一个命令。另一方面，**多线程**实现了多个线程同时存在和执行单个进程。通过允许多个线程访问共享资源/上下文并独立执行，这种编程技术可以帮助应用程序在执行独立任务时提高速度。
- en: 'Multithreading can primarily be achieved in two ways. In single-processor systems,
    multithreading is typically implemented via **time slicing**, a technique that
    allows the CPU to switch between different software running on different threads.
    In time slicing, the CPU switches its execution so quickly and so often that users
    usually perceive that the software is running in parallel (for example, when you
    open two different software at the same time on a single-processor computer):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程主要可以通过两种方式实现。在单处理器系统中，多线程通常是通过时间片分配实现的，这是一种允许CPU在不同线程上切换的技术。在时间片分配中，CPU执行得非常快速和频繁，以至于用户通常会感知到软件在并行运行（例如，在单处理器计算机上同时打开两个不同的软件）。
- en: '![](assets/8bad6da1-678c-48dd-a2ba-c4fc6320dad0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8bad6da1-678c-48dd-a2ba-c4fc6320dad0.png)'
- en: An example of a time slicing technique called round-robin scheduling
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 时间片分配技术的一个例子称为轮转调度
- en: As opposed to single-processor systems, systems with multiple processors or
    cores can easily implement multithreading, by executing each thread in a separate
    process or core, simultaneously. Additionally, time slicing is an option, as these
    multiprocess or multicore systems can have only one processor/core to switch between
    tasks—although this is generally not a good practice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与单处理器系统相反，具有多个处理器或核心的系统可以通过在单独的进程或核心中执行每个线程来轻松实现多线程，同时进行。此外，时间片分配也是一种选择，因为这些多处理器或多核系统可以只有一个处理器/核心在任务之间切换，尽管这通常不是一个好的做法。
- en: 'Multithreaded applications have a number of advantages, as compared to traditional
    sequential applications; some of them are listed as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的顺序应用程序相比，多线程应用程序具有许多优点；以下是其中一些：
- en: '**Faster execution time**: One of the main advantages of concurrency through
    multithreading is the speedup that is achieved. Separate threads in the same program
    can be executed concurrently or in parallel, if they are sufficiently independent
    of one another.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的执行时间**：通过多线程并发的主要优势之一是实现的加速。同一程序中的单独线程可以并发或并行执行，如果它们彼此足够独立。'
- en: '**Responsiveness**: A single-threaded program can only process one piece of
    input at a time; therefore, if the main execution thread blocks on a long-running
    task (that is, a piece of input that requires heavy computation and processing),
    the whole program will not be able to continue with other input, and hence, it
    will appear to be frozen. By using separate threads to perform computation and
    remain running to take in different user input simultaneously, a multithreaded
    program can provide better responsiveness.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：单线程程序一次只能处理一个输入；因此，如果主执行线程在长时间运行的任务上阻塞（即需要大量计算和处理的输入），整个程序将无法继续处理其他输入，因此看起来会被冻结。通过使用单独的线程来执行计算并保持运行以同时接收不同的用户输入，多线程程序可以提供更好的响应性。'
- en: '**Efficiency in resource consumption**: As we mentioned previously, multiple
    threads within the same process can share and access the same resources. Consequently,
    multithreaded programs can serve and process many client requests for data concurrently,
    using significantly fewer resources than would be needed when using single-threaded
    or multiprocess programs. This also leads to quicker communication between threads.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源消耗效率**：正如我们之前提到的，同一进程中的多个线程可以共享和访问相同的资源。因此，多线程程序可以使用比使用单线程或多进程程序时少得多的资源，同时为数据处理和服务许多客户请求。这也导致了线程之间更快的通信。'
- en: 'That being said, multithreaded programs also have their disadvantages, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，多线程程序也有其缺点，如下所示：
- en: '**Crashes**: Even though a process can contain multiple threads, a single illegal
    operation within one thread can negatively affect the processing of all of the
    other threads in the process, and can crash the entire program as a result.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**崩溃**：即使一个进程可以包含多个线程，一个线程中的单个非法操作也可能对该进程中的所有其他线程的处理产生负面影响，并导致整个程序崩溃。'
- en: '**Synchronization**: Even though sharing the same resources can be an advantage
    over traditional sequential programming or multiprocessing programs, careful consideration
    is also needed for the shared resources. Usually, threads must be coordinated
    in a deliberate and systematic manner, so that shared data is computed and manipulated
    correctly. Unintuitive problems that can be caused by careless thread coordination
    include deadlocks, livelocks, and race conditions, all of which will be discussed
    in future chapters.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：尽管共享相同的资源可以优于传统的顺序编程或多处理程序，但对共享资源也需要仔细考虑。通常，线程必须以一种深思熟虑和系统化的方式协调，以便正确计算和操作共享数据。由于不慎的线程协调可能导致的难以理解的问题包括死锁、活锁和竞争条件，这些问题将在未来的章节中讨论。'
- en: An example in Python
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的一个例子
- en: 'To illustrate the concept of running multiple threads in the same process,
    let''s look at a quick example in Python. If you have already downloaded the code
    for this book from the GitHub page, go ahead and navigate to the `Chapter03` folder.
    Let''s take a look at the `Chapter03/my_thread.py` file, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在同一进程中运行多个线程的概念，让我们来看一个在Python中的快速示例。如果您已经从GitHub页面下载了本书的代码，请转到`Chapter03`文件夹。让我们看一下`Chapter03/my_thread.py`文件，如下所示：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this file, we are using the `threading` module from Python as the foundation
    of the `MyThread` class. Each object of this class has a `name` and `delay` parameter.
    The function `run()`, which is called as soon as a new thread is initialized and
    started, prints out a starting message, and, in turn, calls the `thread_count_down()`
    function. This function counts down from the number `5` to the number `0`, while
    sleeping between iterations for a number of seconds, specified by the delay parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们使用Python的`threading`模块作为`MyThread`类的基础。这个类的每个对象都有一个`name`和`delay`参数。`run()`函数在初始化和启动新线程时被调用，打印出一个开始消息，然后调用`thread_count_down()`函数。这个函数从数字`5`倒数到数字`0`，在每次迭代之间休眠指定秒数，由延迟参数指定。
- en: The point of this example is to show the concurrent nature of running more than
    one thread in the same program (or process) by starting more than one object of
    the `MyThread` class at the same time. We know that, as soon as each thread is
    started, a time-based countdown for that thread will also start. In a traditional
    sequential program, separate countdowns will be executed separately, in order
    (that is, a new countdown will not start until the current one finishes). As you
    will see, the separate countdowns for separate threads are executed concurrently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的重点是展示在同一个程序（或进程）中运行多个线程的并发性质，通过同时启动`MyThread`类的多个对象。我们知道，一旦启动每个线程，该线程的基于时间的倒计时也将开始。在传统的顺序程序中，单独的倒计时将按顺序分别执行（即，新的倒计时不会在当前倒计时完成之前开始）。正如您将看到的那样，单独的线程倒计时是同时执行的。
- en: 'Let''s look at the `Chapter3/example1.py` file, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Chapter3/example1.py`文件，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we are initializing and starting two threads together, each of which
    has `0.5` seconds as its `delay` parameter. Run the script using your Python interpreter.
    You should get the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们同时初始化和启动了两个线程，每个线程的`delay`参数都是`0.5`秒。使用您的Python解释器运行脚本。您应该会得到以下输出：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as we expected, the output tells us that the two countdowns for the threads
    were executed concurrently; instead of finishing the first thread's countdown
    and then starting the second thread's countdown, the program ran the two countdowns
    at almost the same time. Without including some overhead and miscellaneous declarations,
    this threading technique allows almost double improvement in speed for the preceding
    program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，输出告诉我们，线程的两个倒计时是同时执行的；程序不是先完成第一个线程的倒计时，然后再开始第二个线程的倒计时，而是几乎同时运行了两个倒计时。在不包括一些额外开销和其他声明的情况下，这种线程技术使得前面的程序速度几乎提高了一倍。
- en: There is one additional thing that should be taken note of in the preceding
    output. After the first countdown for number `5`, we can see that the countdown
    of thread B actually got ahead of thread A in execution, even though we know that
    thread A was initialized and started before thread B. This change actually allowed
    thread B to finish before thread A. This phenomenon is a direct result of concurrency
    via multithreading; since the two threads were initialized and started almost
    simultaneously, it was quite likely for one thread to get ahead of the other in
    execution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中还有一件事情需要注意。在数字`5`的第一个倒计时之后，我们可以看到线程B的倒计时实际上在执行中超过了线程A，尽管我们知道线程A在线程B之前初始化和启动。这种变化实际上允许线程B在线程A之前完成。这种现象是通过多线程并发产生的直接结果；由于两个线程几乎同时初始化和启动，很可能一个线程在执行中超过另一个线程。
- en: If you were to execute this script many times, it would be quite likely for
    you to get varying output, in terms of the order of execution and the completion
    of the countdowns. The following are two pieces of output that I obtained by executing
    the script again and again. The first output shows a uniform and unchanging order
    of execution and completion, in which the two countdowns were executed hand in
    hand. The second shows a case in which thread A was executed significantly faster
    than thread B; it even finished before thread B counted to number `1`. This variation
    of output further illustrates the fact that the threads were treated and executed
    by Python equally.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次执行此脚本，很可能会得到不同的输出，无论是执行顺序还是倒计时的完成。以下是我多次执行脚本后获得的两个输出。第一个输出显示了一致且不变的执行顺序和完成顺序，两个倒计时一起执行。第二个输出显示了一种情况，线程A的执行速度明显快于线程B；甚至在线程B计数到数字`1`之前就已经完成了。这种输出的变化进一步说明了这些线程是由Python平等对待和执行的事实。
- en: 'The following code shows one possible output of the program:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了程序的一个可能输出：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is another possible output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个可能的输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An overview of the threading module
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程模块概述
- en: There are a lot of choices when it comes to implementing multithreaded programs
    in Python. One of the most common ways to work with threads in Python is through
    the `threading` module. Before we dive into the module's usage and its syntax,
    first, let's explore the `thread` model, which was previously the main thread-based
    development module in Python.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现多线程程序时有很多选择。在Python中处理线程的最常见方式之一是通过`threading`模块。在深入探讨模块的用法和语法之前，让我们先探索一下`thread`模型，这在Python中曾经是主要的基于线程的开发模块。
- en: The thread module in Python 2
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 2中的线程模块
- en: Before the `threading` module became popular, the primary thread-based development
    module was `thread`. If you are using an older version of Python 2, it is possible
    to use the module as it is. However, according to the module documentation page,
    the `thread` module was, in fact, renamed `_thread` in Python 3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`threading`模块变得流行之前，主要基于线程的开发模块是`thread`。如果您使用的是较旧版本的Python 2，可以直接使用该模块。然而，根据模块文档页面，`thread`模块实际上在Python
    3中被重命名为`_thread`。
- en: For readers that have been working with the `thread` module to build multithreaded
    applications and are looking to port their code from Python 2 to Python 3, the
    2to3 tool might be a solution. The 2to3 tool handles most of the detectable incompatibilities
    between the different versions of Python, while parsing the source and traversing
    the source tree to convert Python 2.x code into Python 3.x code. Another trick
    to achieve the conversion is to change the import code from `import thread` to
    `import _thread as thread` in your Python programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些一直在使用`thread`模块构建多线程应用程序并希望将其代码从Python 2迁移到Python 3的读者来说，2to3工具可能是一个解决方案。2to3工具处理了大部分Python不同版本之间可检测到的不兼容性，同时解析源代码并遍历源树将Python
    2.x代码转换为Python 3.x代码。另一个实现转换的技巧是在Python程序中将导入代码从`import thread`改为`import _thread
    as thread`。
- en: 'The main feature of the `thread` module is its fast and sufficient method of
    creating new threads to execute functions: the `thread.start_new_thread()` function.
    Aside from this, the module only supports a number of low-level ways to work with
    multithreaded primitives and share their global data space. Additionally, simple
    lock objects (for example, mutexes and semaphores) are provided for synchronization
    purposes.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`模块的主要特点是快速有效地创建新线程以执行函数：`thread.start_new_thread()`函数。除此之外，该模块还支持一些低级的处理多线程原语和共享全局数据空间的方式。此外，还提供了简单的锁对象（例如互斥锁和信号量）用于同步目的。'
- en: The threading module in Python 3
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3中的线程模块
- en: The old `thread` module has been considered deprecated by Python developers
    for a long time, mainly because of its rather low-level functions and limited
    usage. The `threading` module, on the other hand, is built on top of the `thread`
    module, providing easier ways to work with threads through powerful, higher-level
    APIs. Python users have actually been encouraged to utilize the new `threading`
    module over the `thread` module in their programs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，旧的`thread`模块一直被Python开发人员认为是过时的，主要是因为它的功能相对较低级，使用范围有限。另一方面，`threading`模块是建立在`thread`模块之上的，通过强大的高级API提供了更容易处理线程的方式。Python用户实际上被鼓励在他们的程序中使用新的`threading`模块而不是`thread`模块。
- en: Additionally, the `thread` module considers each thread a function; when the `thread.start_new_thread()`
    is called, it actually takes in a separate function as its main argument, in order
    to spawn a new thread. However, the `threading` module is designed to be user-friendly
    for those that come from the object-oriented software development paradigm, treating
    each thread that is created as an object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`thread`模块将每个线程视为一个函数；当调用`thread.start_new_thread()`时，它实际上接受一个单独的函数作为其主要参数，以产生一个新的线程。然而，`threading`模块被设计为对面向对象软件开发范式的用户友好，将创建的每个线程视为一个对象。
- en: 'In addition to all of the functionality for working with threads that the `thread`
    module provides, the `threading` module supports a number of extra methods, as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`thread`模块提供的所有处理线程功能之外，`threading`模块还支持一些额外的方法，如下所示：
- en: '`threading.activeCount()`: This function returns the number of currently active
    thread objects in the program'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.activeCount()`: 此函数返回程序中当前活动线程对象的数量'
- en: '`threading.currentThread()`: This function returns the number of thread objects
    in the current thread control from the caller'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.currentThread()`: 此函数从调用者返回当前线程控制中的线程对象数'
- en: '`threading.enumerate()`: This function returns a list of all of the currently
    active thread objects in the program'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.enumerate()`: 此函数返回程序中当前活动线程对象的列表'
- en: 'Following the object-oriented software development paradigm, the `threading`
    module also provides a `Thread` class that supports the object-oriented implementation
    of threads. The following methods are supported in this class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循面向对象的软件开发范式，`threading`模块还提供了一个支持线程面向对象实现的`Thread`类。该类支持以下方法：
- en: '`run()`: This method is executed when a new thread is initialized and started'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()`: 当初始化并启动新线程时执行此方法'
- en: '`start()`: This method starts the initialized calling thread object by calling
    the `run()` method'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`: 这个方法通过调用`run()`方法来启动初始化的调用线程对象'
- en: '`join()`: This method waits for the calling thread object to terminate before
    continuing to execute the rest of the program'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 这个方法在继续执行程序的其余部分之前等待调用线程对象终止'
- en: '`isAlive()`: This method returns a Boolean value, indicating whether the calling
    thread object is currently executing'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAlive()`: 这个方法返回一个布尔值，指示调用线程对象当前是否正在执行'
- en: '`getName()`: This method returns the name of the calling thread object'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName()`: 这个方法返回调用线程对象的名称'
- en: '`setName()`: This method sets the name of the calling thread object'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setName()`: 这个方法设置调用线程对象的名称'
- en: Creating a new thread in Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中创建一个新线程
- en: Having provided an overview of the `threading` module and its differences from
    the old `thread` module, in this section, we will explore a number of examples
    of creating new threads by using these tools in Python. As mentioned previously,
    the `threading` module is most likely the most common way of working with threads
    in Python. Specific situations require use of the `thread` module and maybe other
    tools, as well, and it is important for us to be able to differentiate those situations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经提供了`threading`模块及其与旧的`thread`模块的区别的概述，现在我们将通过在Python中使用这些工具来创建新线程的一些示例来探讨。正如之前提到的，`threading`模块很可能是在Python中处理线程的最常见方式。特定情况下需要使用`thread`模块，也许还需要其他工具，因此我们有必要能够区分这些情况。
- en: Starting a thread with the thread module
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程模块启动线程
- en: 'In the `thread` module, new threads are created to execute functions concurrently.
    As we have mentioned, the way to do this is by using the `thread.start_new_thread()`
    function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`thread`模块中，新线程被创建以并发执行函数。正如我们所提到的，通过使用`thread.start_new_thread()`函数来实现这一点：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this function is called, a new thread is spawned to execute the function
    specified by the parameters, and the identifier of the thread is returned when
    the function finishes its execution. The `function` parameter is the name of the
    function to be executed, and the `args` parameter list (which has to be a list
    or a tuple) includes the arguments to be passed to the specified function. The
    optional `kwargs` argument, on the other hand, includes a separate dictionary
    of additional keyword arguments. When the `thread.start_new_thread()` function
    returns, the thread also terminates silently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此函数时，将生成一个新线程来执行参数指定的函数，并且当函数完成执行时，线程的标识符将被返回。`function`参数是要执行的函数的名称，`args`参数列表（必须是列表或元组）包括要传递给指定函数的参数。另一方面，可选的`kwargs`参数包括一个额外的关键字参数的字典。当`thread.start_new_thread()`函数返回时，线程也会悄悄地终止。
- en: 'Let''s look at an example of using the `thread` module in a Python program. If
    you have already downloaded the code for this book from the GitHub page, go ahead
    and navigate to the `Chapter03` folder and the `Chapter03/example2.py` file. In
    this example, we will look at the `is_prime()` function that we have also used
    in previous chapters:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Python程序中使用`thread`模块的例子。如果您已经从GitHub页面下载了本书的代码，请转到`Chapter03`文件夹和`Chapter03/example2.py`文件。在这个例子中，我们将看一下`is_prime()`函数，这个函数我们在之前的章节中也使用过：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may have noticed that there is quite a difference in the way this `is_prime(x)`
    function returns the result of its computation; instead of returning `true` or
    `false`, to indicate whether the `x` parameter is a prime number, this `is_prime()`
    function directly prints out that result. As you saw earlier, the `thread.start_new_thread()`
    function executes the parameter function through spawning a new thread, but it
    actually returns the thread's identifier. Printing out the result inside of the
    `is_prime()` function is a workaround for accessing the result of that function
    through the `thread` module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`is_prime(x)`函数返回其计算结果的方式有很大的不同；它不是返回`true`或`false`来指示`x`参数是否是一个质数，而是直接打印出该结果。正如您之前看到的，`thread.start_new_thread()`函数通过生成一个新线程来执行参数函数，但它实际上返回线程的标识符。在`is_prime()`函数内部打印结果是通过`thread`模块访问该函数的结果的一种解决方法。
- en: 'In the main part of our program, we will loop through a list of potential candidates
    for prime numbers, and we will call the `thread.start_new_thread()` function on
    the `is_prime()` function and each number in that list, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们程序的主要部分，我们将循环遍历潜在的质数候选列表，并对该列表中的每个数字调用`thread.start_new_thread()`函数和`is_prime()`函数，如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice that, in the `Chapter03/example2.py` file, there is a line
    of code to take in the user''s input at the end:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在`Chapter03/example2.py`文件中，有一行代码在最后接受用户的输入：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For now, let's comment out this last line. Then, when we execute the whole Python
    program, it will be observed that the program terminates without printing out
    any output; in other words, the program terminates before the threads can finish
    executing. This is due to the fact that, when a new thread is spawned through
    the `thread.start_new_thread()` function to process a number in our input list,
    the program continues to loop through the next input number while the newly created
    thread executes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们注释掉最后一行。然后，当我们执行整个Python程序时，可以观察到程序在没有打印任何输出的情况下终止；换句话说，程序在线程执行完毕之前终止。这是因为，当通过`thread.start_new_thread()`函数生成一个新线程来处理我们输入列表中的一个数字时，程序会继续循环遍历下一个输入数字，而新创建的线程在执行。
- en: So, by the time the Python interpreter reaches the end of the program, if any
    thread has not finished executing (in our case, it is all of the threads), that
    thread will be ignored and terminated, and no output will be printed out. However,
    once in a while, one of the output is `2 is a prime number.` which will be printed
    out before the program terminates, because the thread processing the number `2`
    is able to finish executing prior to that point.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当Python解释器到达程序末尾时，如果有任何线程尚未执行完毕（在我们的情况下，是所有线程），那么该线程将被忽略和终止，并且不会打印任何输出。然而，偶尔会有一个输出是`2是一个质数。`，它将在程序终止之前被打印出来，因为处理数字`2`的线程能够在那一点之前执行完毕。
- en: 'The last line of code is another workaround for the `thread` module—this time,
    to address the preceding problem. This line prevents the program from exiting
    until the user presses any key on their keyboard, at which time the program will
    quit. The strategy is to wait for the program to finish executing all of the threads
    (that is, to finish processing all of the numbers in our input list). Uncomment
    the last line and execute the file, and your output should be similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行是`thread`模块的另一个解决方法，这次是为了解决前面的问题。这行代码阻止程序退出，直到用户在键盘上按下任意键，此时程序将退出。策略是等待程序执行完所有线程（也就是处理我们输入列表中的所有数字）。取消最后一行的注释并执行文件，您的输出应该类似于以下内容：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the `Type something to quit:` line, which corresponds to the
    last line of code in our program, was printed out before the output from the `is_prime()`
    function; this is consistent with the fact that that line is executed before any
    of the other threads finish executing, most of the time. I say most of the time
    because, when the thread that is processing the first input (the number `2`) finishes
    executing before the Python interpreter reaches the last line, the output of the
    program would be something similar to the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，“键入一些内容以退出：”这一行对应于我们程序中的最后一行代码，在`is_prime()`函数的输出之前被打印出来；这与该行在其他线程完成执行之前被执行的事实一致，大多数情况下是这样。我之所以说大多数情况是因为，当处理第一个输入（数字`2`）的线程在Python解释器到达最后一行之前执行完毕时，程序的输出将类似于以下内容：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Starting a thread with the threading module
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程模块启动线程
- en: You now know how to start a thread with the `thread` module, and you know about
    its limited and low-level use of threading and the need for considerably unintuitive
    workarounds when working with it. In this subsection, we will explore the preferred
    `threading` module and its advantages over the `thread` module, with regard to
    the implementation of multithreaded programs in Python.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何使用`thread`模块启动线程，以及它在线程使用方面的有限和低级的使用，以及在处理它时需要相当不直观的解决方法。在本小节中，我们将探讨首选的`threading`模块及其相对于`thread`模块在Python中实现多线程程序方面的优势。
- en: 'To create and customize a new thread using the `threading` module, there are
    specific steps that need to be followed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`threading`模块创建和自定义一个新的线程，需要遵循特定的步骤：
- en: Define a subclass of the `threading.Thread` class in your program
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中定义`threading.Thread`类的子类
- en: Override the default `__init__(self [,args])` method inside of the subclass,
    in order to add custom arguments for the class
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类中覆盖默认的`__init__(self [,args])`方法，以添加类的自定义参数
- en: Override the default `run(self [,args])` method inside of the subclass, in order
    to customize the behavior of the thread class when a new thread is initialized
    and started
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类中覆盖默认的`run(self [,args])`方法，以自定义线程类在初始化和启动新线程时的行为
- en: 'You actually saw an example of this in the first example of this chapter. As
    a refresher, the following is what we have to use to customize a `threading.Thread`
    subclass, in order to perform a five-step countdown, with a customizable delay
    between each step:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在本章的第一个示例中，您已经看到了这个例子。作为一个复习，以下是我们必须使用的内容来自定义`threading.Thread`子类，以执行一个五步倒计时，每一步之间都有一个可定制的延迟：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our next example, we will look at the problem of determining whether a specific
    number is a prime number. This time, we will be implementing a multithreaded Python
    program through the `threading` module. Navigate to the `Chapter03` folder and
    the `example3.py` file. Let''s first focus on the `MyThread` class, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将看看如何确定一个特定的数字是否是素数。这一次，我们将通过`threading`模块实现一个多线程的Python程序。转到`Chapter03`文件夹和`example3.py`文件。让我们首先关注`MyThread`类，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each instance of the `MyThread` class will have a parameter called `x`, specifying
    the prime number candidate to be processed. As you can see, when an instance of
    the class is initialized and started (that is, in the `run(self)` function), the
    `is_prime()` function, which is the same prime-checking function that we used
    in the previous example, on the `x` parameter, before that a message is also printed
    out by the `run()` function to specify the beginning of the processing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyThread`类的每个实例都将有一个名为`x`的参数，指定要处理的素数候选数。正如您所看到的，当类的一个实例被初始化并启动（也就是在`run(self)`函数中），`is_prime()`函数，这是我们在前面的示例中使用的相同的素数检查函数，对`x`参数进行检查，然后`run()`函数也打印出一条消息来指定处理的开始。'
- en: 'In our main program, we still have the same list of input for prime-checking.
    We will be going through each number in that list, spawning and running a new
    instance of the `MyThread` class with that number, and appending that `MyThread`
    instance to a separate list. This list of created threads is necessary because,
    after that, we will have to call the `join()` method on all of those threads,
    which ensures that all of the threads have finished executing successfully:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，我们仍然有相同的素数检查输入列表。我们将遍历该列表中的每个数字，生成并运行一个新的`MyThread`类的实例，并将该`MyThread`实例附加到一个单独的列表中。这个创建的线程列表是必要的，因为在那之后，我们将不得不对所有这些线程调用`join()`方法，以确保所有线程都已成功执行：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that, unlike when we used the `thread` module, this time, we do not have
    to invent a workaround to make sure that all of the threads have finished executing
    successfully. Again, this is done by the `join()` method provided by the `threading`
    module. This is only one example of the many advantages of using the more powerful,
    higher-level API of the `threading` module, rather than using the `thread` module.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们使用`thread`模块时不同的是，这一次，我们不必发明一种解决方法来确保所有线程都已成功执行。同样，这是由`threading`模块提供的`join()`方法完成的。这只是使用`threading`模块更强大、更高级API的许多优势之一，而不是使用`thread`模块。
- en: Synchronizing threads
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步线程
- en: As you saw in the previous examples, the `threading` module has many advantages
    over its predecessor, the `thread` module, in terms of functionality and high-level
    API calls. Even though some recommend that experienced Python developers know
    how to implement multithreaded applications using both of these modules, you will
    most likely be using the `threading` module to work with threads in Python. In
    this section, we will look at using the `threading` module in thread synchronization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中看到的，`threading`模块在功能和高级API调用方面比其前身`thread`模块有许多优势。尽管一些人建议有经验的Python开发人员应该知道如何使用这两个模块来实现多线程应用程序，但您在Python中处理线程时很可能会使用`threading`模块。在本节中，我们将看看如何在线程同步中使用`threading`模块。
- en: The concept of thread synchronization
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步的概念
- en: Before we jump into an actual Python example, let's explore the concept of synchronization
    in computer science. As you saw in previous chapters, sometimes, it is undesirable
    to have all portions of a program execute in a parallel manner. In fact, in most
    contemporary concurrent programs, there are sequential portions and concurrent
    portions of the code; furthermore, even inside of a concurrent portion, some form
    of coordination between different threads/processes is also required.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入实际的Python示例之前，让我们探讨计算机科学中的同步概念。正如您在前几章中看到的，有时，让程序的所有部分并行执行是不可取的。事实上，在大多数当代并发程序中，代码有顺序部分和并发部分；此外，即使在并发部分内部，也需要一些形式的协调来处理不同的线程/进程。
- en: '**Thread/process synchronization** is a concept in computer science that specifies
    various mechanisms to ensure that no more than one concurrent thread/process can
    process and execute a particular program portion at a time; this portion is known
    as the **critical section**, and we will discuss it in further detail when we
    consider common problems in concurrent programming in [Chapter 12](e8b97a27-3966-4a32-aae6-b8d995f4c662.xhtml),
    *Starvation,* and [Chapter 13](d87c597d-2130-4847-9ca9-e12021bc7a0c.xhtml), *Race
    Conditions*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程/进程同步**是计算机科学中的一个概念，它指定了各种机制，以确保不超过一个并发线程/进程可以同时处理和执行特定程序部分；这部分被称为**临界区**，当我们考虑并发编程中的常见问题时，我们将在[第12章](e8b97a27-3966-4a32-aae6-b8d995f4c662.xhtml)
    *饥饿*和[第13章](d87c597d-2130-4847-9ca9-e12021bc7a0c.xhtml) *竞争条件*中进一步讨论它。'
- en: In a given program, when a thread is accessing/executing the critical section
    of the program, the other threads have to wait until that thread finishes executing.
    The typical goal of thread synchronization is to avoid any potential data discrepancies
    when multiple threads access their shared resources; allowing only one thread
    to execute the critical section of the program at a time guarantees that no data
    conflicts occur in multithreaded applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的程序中，当一个线程正在访问/执行程序的临界部分时，其他线程必须等待，直到该线程执行完毕。线程同步的典型目标是避免多个线程访问其共享资源时可能出现的数据不一致；只允许一个线程一次执行程序的临界部分，可以确保多线程应用中不会发生数据冲突。
- en: The threading.Lock class
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程锁类
- en: 'One of the most common ways to apply thread synchronization is through the
    implementation of a locking mechanism. In our `threading` module, the `threading.Lock`
    class provides a simple and intuitive approach to creating and working with locks.
    Its main usage includes the following methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用线程同步最常见的方法之一是通过实现锁定机制。在我们的`threading`模块中，`threading.Lock`类提供了一种简单直观的方法来创建和使用锁。它的主要用法包括以下方法：
- en: '`threading.Lock()`: This method initializes and returns a new lock object.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threading.Lock()`: 此方法初始化并返回一个新的锁对象。'
- en: '`acquire(blocking)`: When this method is called, all of the threads will run
    synchronously (that is, only one thread can execute the critical section at a
    time):'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquire(blocking)`: 调用此方法时，所有线程将同步运行（即，一次只有一个线程可以执行临界部分）：'
- en: The optional argument `blocking` allows us to specify whether the current thread
    should wait to acquire the lock
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数`blocking`允许我们指定当前线程是否应等待获取锁
- en: When `blocking = 0`, the current thread does not wait for the lock and simply
    returns `0` if the lock cannot be acquired by the thread, or `1` otherwise
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`blocking = 0`时，当前线程不会等待锁，如果线程无法获取锁，则返回`0`，否则返回`1`
- en: When `blocking = 1`, the current thread blocks and waits for the lock to be
    released and acquires it afterwards
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`blocking = 1`时，当前线程将阻塞并等待锁被释放，然后获取它
- en: '`release()`: When this method is called, the lock is released.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release()`: 调用此方法时，锁将被释放。'
- en: An example in Python
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的一个例子
- en: 'Let''s consider a specific example. In this example, we will be looking at
    the `Chapter03/example4.py` file. We will go back to the thread example of counting
    down from five to one, which we looked at at the beginning of this chapter; take
    a moment to look back if you do not remember the problem. In this example, we
    will be tweaking the `MyThread` class, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具体的例子。在这个例子中，我们将查看`Chapter03/example4.py`文件。我们将回到从五数到一的线程示例，这是我们在本章开头看到的；如果您不记得问题，请回顾一下。在这个例子中，我们将调整`MyThread`类，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As opposed to the first example of this chapter, in this example, the `MyThread`
    class utilizes a lock object (whose variable is named `thread_lock`) inside of
    its `run()` function. Specifically, the lock object is acquired right before the
    `thread_count_down()` function is called (that is, when the countdown begins),
    and the lock object is released right after its ends. Theoretically, this specification
    will alter the behavior of the threads that we saw in the first example; instead
    of executing the countdown simultaneously, the program will now execute the threads
    separately, and the countdowns will take place one after the other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章的第一个例子相反，在这个例子中，`MyThread`类在其`run()`函数内部使用了一个锁对象（变量名为`thread_lock`）。具体来说，在调用`thread_count_down()`函数之前（即倒计时开始时）获取锁对象，并在结束后释放锁对象。理论上，这个规定将改变我们在第一个例子中看到的线程行为；程序现在将分别执行线程，倒计时将依次进行。
- en: 'Finally, we will initialize the `thread_lock` variable as well as run two separate
    instances of the `MyThread` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将初始化`thread_lock`变量，并运行两个`MyThread`类的单独实例：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output will be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Multithreaded priority queue
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程优先级队列
- en: A computer science concept that is widely used in both non-concurrent and concurrent
    programming is queuing. A **queue** is an abstract data structure that is a collection
    of different elements maintained in a specific order; these elements can be the
    other objects in a program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在非并发和并发编程中广泛使用的计算机科学概念是排队。**队列**是一种抽象数据结构，它是按特定顺序维护的不同元素的集合；这些元素可以是程序中的其他对象。
- en: A connection between real-life and programmatic queues
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实生活和程序排队之间的联系
- en: 'Queues are an intuitive concept that can easily be related to our everyday
    life, such as when you stand in line to board a plane at the airport. In an actual
    line of people, you will see the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个直观的概念，可以很容易地与我们的日常生活联系起来，比如当您在机场排队登机时。在实际的人群中，您会看到以下情况：
- en: People typically enter at one end of the line and exit from the other end
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们通常从一端进入队列，从另一端离开
- en: If person A enters the line before person B, person A will also leave the line
    before person B (unless person B has more priority)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果A在B之前进入队列，A也将在B之前离开队列（除非B具有更高的优先级）
- en: Once everyone has boarded the plane, there will be no one left in the line.
    In other words, the line will be empty
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦每个人都登上飞机，排队就没有人了。换句话说，队列将为空
- en: 'In computer science, a queue works in a considerably similar way:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，队列的工作方式非常相似。
- en: Elements can be added to the end of the queue; this task is called **enqueue**.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素可以被添加到队列的末尾；这个任务被称为**入队**。
- en: Elements can also be removed from the beginning of the queue; this task is called
    **dequeue**.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素也可以从队列的开头移除；这个任务被称为**出队**。
- en: In a **First In First Out** (**FIFO**) queue, the elements that are added first
    will be removed first (hence, the name FIFO). This is contrary to another common
    data structure in computer science, called **stack**, in which the last element
    that is added will be removed first. This is known as **L****ast In First Out**
    (**LIFO**).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**先进先出**（**FIFO**）队列中，首先添加的元素将首先被移除（因此称为FIFO）。这与计算机科学中的另一个常见数据结构**栈**相反，后添加的元素将首先被移除。这被称为**后进先出**（**LIFO**）。
- en: 'If all of the elements inside of a queue have been removed, the queue will
    be empty and there will be no way to remove further elements from the queue. Similarly,
    if a queue is at the maximum capacity of the number of elements it can hold, there
    is no way to add any other elements to the queue:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果队列中的所有元素都被移除，队列将为空，将无法再从队列中移除更多元素。同样，如果队列达到了它可以容纳的元素的最大容量，就无法再向队列中添加任何其他元素：
- en: '![](assets/3b3674f3-7f65-4736-83b2-66d87b5ce324.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b3674f3-7f65-4736-83b2-66d87b5ce324.png)'
- en: A visualization of the queue data structure
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构的可视化
- en: The queue module
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列模块
- en: 'The `queue` module in Python provides a simple implementation of the queue
    data structure. Each queue in the `queue.Queue` class can hold a specific amount
    of element, and can have the following methods as its high-level API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`queue`模块提供了队列数据结构的简单实现。`queue.Queue`类中的每个队列可以容纳特定数量的元素，并且可以具有以下方法作为其高级API：
- en: '`get()`: This method returns the next element of the calling `queue` object
    and removes it from the `queue` object'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 这个方法返回调用`queue`对象的下一个元素并将其从`queue`对象中移除'
- en: '`put()`: This method adds a new element to the calling `queue` object'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 这个方法向调用`queue`对象添加一个新元素'
- en: '`qsize()`: This method returns the number of current elements in the calling
    `queue` object (that is, its size)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qsize()`: 这个方法返回调用`queue`对象中当前元素的数量（即其大小）'
- en: '`empty()`: This method returns a Boolean, indicating whether the calling `queue`
    object is empty'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`: 这个方法返回一个布尔值，指示调用`queue`对象是否为空'
- en: '`full()`: This method returns a Boolean, indicating whether the calling `queue`
    object is full'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full()`: 这个方法返回一个布尔值，指示调用`queue`对象是否已满'
- en: Queuing in concurrent programming
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发编程中的排队
- en: The concept of a queue is even more prevalent in the sub-field of concurrent
    programming, especially when we need to implement a fixed number of threads in
    our program to interact with a varying number of shared resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的概念在并发编程的子领域中更加普遍，特别是当我们需要在程序中实现固定数量的线程来与不同数量的共享资源交互时。
- en: In the previous examples, we have learned to assign a specific task to a new
    thread. This means that the number of tasks that need to be processed will dictate
    the number of threads our program should spawn. (For example, in our `Chapter03/example3.py`
    file, we had five numbers as our input and we therefore created five threads—each
    took one input number and processed it.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经学会了将特定任务分配给一个新线程。这意味着需要处理的任务数量将决定我们的程序应该产生的线程数量。（例如，在我们的`Chapter03/example3.py`文件中，我们有五个数字作为输入，因此我们创建了五个线程，每个线程都处理一个输入数字。）
- en: Sometimes it is undesirable to have as many threads as the tasks we have to
    process. Say we have a large number of tasks to be processed, then it will be
    quite inefficient to spawn the same large number of threads and have each thread
    execute only one task. It could be more beneficial to have a fixed number of threads
    (commonly known as a thread pool) that would work through the tasks in a cooperative
    manner.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不希望有和任务数量一样多的线程。比如我们有大量任务需要处理，那么产生同样数量的线程并且每个线程只执行一个任务将会非常低效。有一个固定数量的线程（通常称为线程池）以合作的方式处理任务可能更有益。
- en: Here is when the concept of a queue comes in. We can design a structure in which
    the pool of threads will not hold any information regarding the tasks they should
    each execute, instead the tasks are stored in a queue (in other words task queue),
    and the items in the queue will be fed to individual members of the thread pool.
    As a given task is completed by a member of the thread pool, if the task queue
    still contains elements to be processed, then the next element in the queue will
    be sent to the thread that just became available.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是队列概念的应用。我们可以设计一个结构，线程池不会保存任何关于它们应该执行的任务的信息，而是任务存储在队列中（也就是任务队列），队列中的项目将被提供给线程池的各个成员。当线程池的成员完成了给定的任务，如果任务队列仍然包含要处理的元素，那么队列中的下一个元素将被发送给刚刚变得可用的线程。
- en: 'This diagram further illustrates this setup:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表进一步说明了这个设置：
- en: '![](assets/ff384e15-a7ed-4bf2-9342-bcad86b687c3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff384e15-a7ed-4bf2-9342-bcad86b687c3.png)'
- en: Queuing in threading
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 线程排队
- en: 'Let''s consider a quick example in Python, in order to illustrate this point. Navigate
    to the `Chapter03/example5.py` file. In this example, we will be considering the
    problem of printing out all of the positive factors of an element in a given list
    of positive integers. We are still looking at the previous `MyThread` class, but
    with some adjustments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Python中的一个快速示例来说明这一点。转到`Chapter03/example5.py`文件。在这个例子中，我们将考虑打印给定正整数列表中元素的所有正因子的问题。我们仍然在看之前的`MyThread`类，但做了一些调整：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a lot going on, so let''s break the program down into smaller pieces.
    First, let''s look at our key function, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情要做，所以让我们把程序分解成更小的部分。首先，让我们看看我们的关键函数，如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function takes in an argument, `x` then iterates through all positive numbers
    between `1` and itself, to check whether a number is a factor of `x`. It finally
    prints out a formatted message that contains all of the information that it cumulates
    through the loop.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个参数`x`，然后迭代所有介于`1`和`x`之间的正数，以检查一个数字是否是`x`的因子。最后，它打印出一个格式化的消息，其中包含它通过循环累积的所有信息。
- en: In our new `MyThread` class, when a new instance is initialized and started,
    the `process_queue()` function will be called. This function will first attempt
    to obtain the next element of the queue object that the `my_queue` variable holds
    in a non-blocking manner by calling the `get(block=False)` method. If a `queue.Empty`
    exception occurs (which indicates that the queue currently holds no value), then
    we will end the execution of the function. Otherwise we simply pass that element
    we just obtained to the `print_factors()` function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新`MyThread`类中，当初始化并启动一个新实例时，`process_queue()`函数将被调用。此函数首先尝试以非阻塞方式通过调用`get(block=False)`方法获取`my_queue`变量中持有的队列对象的下一个元素。如果发生`queue.Empty`异常（表示队列当前没有值），则我们将结束执行该函数。否则，我们只需将刚刚获取的元素传递给`print_factors()`函数。
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `my_queue` variable is defined in our main function as a `Queue` object
    from the `queue` module that contains the elements in the `input_` list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_queue`变量在我们的主函数中被定义为`queue`模块中的`Queue`对象，其中包含`input_`列表中的元素：'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the rest of the main program, we simply initiate and run three separate
    threads until all of them finish their respective execution. Here we choose to
    create only three threads to simulate the design that we discussed earlier—a fixed
    number of threads processing a queue of input whose number of elements can change
    independently:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主程序的其余部分，我们只需启动并运行三个单独的线程，直到它们都完成各自的执行。在这里，我们选择创建三个线程来模拟我们之前讨论的设计——一个固定数量的线程处理一个输入队列，其元素数量可以独立变化。
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the program and you will see the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你会看到以下输出：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we have implemented the structure that we discussed earlier:
    a task queue that holds all the tasks to be executed and a thread pool (threads
    A, B, and C) that interacts with the queue to process its elements individually.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了之前讨论过的结构：一个任务队列，其中包含所有要执行的任务，以及一个线程池（线程A、B和C），它们与队列交互以逐个处理其元素。
- en: Multithreaded priority queue
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程优先队列
- en: The elements in a queue are processed in the order that they were added to the
    queue; in other words, the first element that is added leaves the queue first
    (FIFO). Even though this abstract data structure simulates real life in many situations,
    depending on the application and its purposes, sometimes, we need to redefine/change
    the order of the elements dynamically. This is where the concept of priority queuing
    comes in handy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的元素按照它们被添加到队列的顺序进行处理；换句话说，第一个被添加的元素最先离开队列（先进先出）。尽管这种抽象数据结构在许多情况下模拟现实生活，但根据应用程序及其目的，有时我们需要动态地重新定义/更改元素的顺序。这就是优先队列的概念派上用场的地方。
- en: 'The **priority queue** abstract data structure is similar to the queue (and
    even the aforementioned stack) data structure, but each of the elements in a priority
    queue, as the name suggests, has a priority associated with it; in other words,
    when an element is added to a priority queue, its priority needs to be specified.
    Unlike in regular queues, the dequeuing principle of a priority queue relies on
    the priority of the elements: the elements with higher priorities are processed
    before those with lower priorities.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**抽象数据结构类似于队列（甚至前面提到的栈）数据结构，但是优先队列中的每个元素都有与之关联的优先级；换句话说，当一个元素被添加到优先队列时，需要指定其优先级。与常规队列不同，优先队列的出队原则依赖于元素的优先级：具有较高优先级的元素在具有较低优先级的元素之前被处理。'
- en: The concept of a priority queue is used in a variety of different applications—namely,
    bandwidth management, Dijkstra's algorithm, best-first search algorithms, and
    so on. Each of these applications typically uses a definite scoring system/function
    to determine the priority of its elements. For example, in bandwidth management,
    prioritized traffic, such as real-time streaming, is processed with the least
    delay and the least likelihood of being rejected. In best-search algorithms that
    are used to find the shortest path between two given nodes of a graph, a priority
    queue is implemented to keep track of unexplored routes; the routes with shorter
    estimated path lengths are given higher priorities in the queue.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列的概念在各种不同的应用中被使用，包括带宽管理、Dijkstra算法、最佳优先搜索算法等。每个应用通常使用一个明确定义的评分系统/函数来确定其元素的优先级。例如，在带宽管理中，优先处理实时流等优先流量，以保证最小的延迟和最小的被拒绝的可能性。在用于在图中找到两个给定节点之间的最短路径的最佳搜索算法中，实现了一个优先队列来跟踪未探索的路径；估计路径长度较短的路径在队列中具有更高的优先级。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A thread of execution is the smallest unit of programming commands. In computer
    science, multithreaded applications allow for multiple threads to exist within
    the same process simultaneously, in order to implement concurrency and parallelism.
    Multithreading provides a variety of advantages, in execution time, responsiveness,
    and the efficiency of resource consumption.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行线程是编程命令的最小单位。在计算机科学中，多线程应用程序允许多个线程同时存在于同一进程中，以实现并发性和并行性。多线程提供了各种优势，包括执行时间、响应性和资源消耗的效率。
- en: The `threading` module in Python 3, which is commonly considered superior to
    the old `thread` module, provides an efficient, powerful, and high-level API to
    work with threads while implementing multithreaded applications in Python, including
    options to spawn new threads dynamically and synchronize threads through different
    locking mechanisms.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3中的`threading`模块通常被认为优于旧的`thread`模块，它提供了一个高效、强大和高级的API，用于在Python中实现多线程应用程序，包括动态生成新线程和通过不同的锁定机制同步线程的选项。
- en: Queuing and priority queuing are important data structures in the field of computer
    science, and they are essential concepts in concurrent and parallel programming.
    They allow for multithreaded applications to efficiently execute and complete
    their threads in an accurate manner, ensuring that the shared resources are processed
    in a specific and dynamic order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 排队和优先排队是计算机科学领域中重要的数据结构，在并发和并行编程中是必不可少的概念。它们允许多线程应用程序以有效的方式执行和完成其线程，确保共享资源以特定和动态的顺序进行处理。
- en: In the next chapter, we will discuss a more advanced function of Python, the
    `with` statement, and how it complements the use of multithreaded programming
    in Python.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Python的更高级功能`with`语句，以及它如何在Python中的多线程编程中起到补充作用。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a thread? What are the core differences between a thread and a process?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程？线程和进程之间的核心区别是什么？
- en: What are the API options provided by the `thread` module in Python?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的`thread`模块提供了哪些API选项？
- en: What are the API options provided by the `threading` module in Python?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的`threading`模块提供了哪些API选项？
- en: What are the processes of creating new threads via the `thread` and `threading`
    modules?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`thread`和`threading`模块创建新线程的过程是什么？
- en: What is the idea behind thread synchronization using locks?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步背后的思想是什么？
- en: What is the process of implementing thread synchronization using locks in Python?
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用锁实现线程同步的过程是什么？
- en: What is the idea behind the queue data structure?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列数据结构背后的思想是什么？
- en: What is the main application of queuing in concurrent programming?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发编程中排队的主要应用是什么？
- en: What are the core differences between a regular queue and a priority queue?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规队列和优先队列之间的核心区别是什么？
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information you can refer to the following links:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: '*Python Parallel Programming Cookbook*, Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '"Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications", Elliot Forbes (2017)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"学习Python并发：构建高效、稳健和并发的应用程序"，Elliot Forbes（2017）'
- en: '*Real-time concepts for embedded systems*, Qing Li and Caroline Yao, CRC Press,
    2003'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式系统的实时概念*，Qing Li和Caroline Yao，CRC出版社，2003'
