- en: '*Chapter 3*: Understanding Decorators and their Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：理解装饰器和它们的用途'
- en: From this chapter onwards, we will start looking at various concepts that are
    part of metaprogramming along with examples of how to apply them. We will first
    take a look at decorators and how decorators can be implemented in Python 3\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将开始查看元编程的各种概念，以及如何应用它们的示例。我们首先将查看装饰器以及如何在Python 3中实现装饰器。
- en: Decorators are one of the metaprogramming concepts that deal with decorating
    a function without modifying the actual function body. As the name suggests, a
    decorator adds additional value to a function, a method, or a class by allowing
    the function to become an argument of another function that *decorates* or gives
    more information on the function, method, or class being decorated. Decorators
    can be developed on an individual user-defined function or on a method that is
    defined inside a class, or they can be defined on a class itself too. Understanding
    decorators will help us to enhance the reusability of functions, methods, and
    classes by manipulating them externally without impacting the actual implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是元编程概念之一，它处理在不修改实际函数主体的同时装饰函数。正如其名所示，装饰器通过允许函数成为另一个函数的参数来为函数、方法或类添加额外的价值，该函数“装饰”或提供有关被装饰的函数、方法或类的更多信息。装饰器可以在单个用户定义的函数或定义在类内部的函数上开发，或者也可以在类本身上定义。理解装饰器将帮助我们通过外部操作来增强函数、方法和类的可重用性，而不会影响实际的实现。
- en: In the previous chapter, we reviewed the concept of object-oriented programming,
    which serves as the base for this chapter and the future chapters in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们回顾了面向对象编程的概念，它是本章以及本书未来章节的基础。
- en: 'In this chapter, we will be taking a look at the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将探讨以下主要主题：
- en: Looking into simple function decorators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看简单的函数装饰器
- en: Exchanging decorators from one function to another
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个函数和另一个函数之间交换装饰器
- en: Applying multiple decorators to one function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个装饰器应用于一个函数
- en: Exploring class decorators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索类装饰器
- en: Getting to know built-in decorators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解内置装饰器
- en: By the end of this chapter, you should be able to create your own decorators,
    implement user-defined decorators on functions/methods and classes, and reuse
    built-in decorators.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建自己的装饰器，在函数/方法或类上实现用户定义的装饰器，并重用内置装饰器。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中共享的代码示例可以在GitHub上找到，这里是本章代码的链接：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03)。
- en: Looking into simple function decorators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看简单的函数装饰器
- en: We will now look at different types of function decorators with an example.
    We will continue using the *ABC Megamart* example we looked at in the previous
    chapter. Each user-defined function in Python can perform a different operation.
    But what if we want different functions to show specific additional information,
    no matter what the functions perform? We can do this simply by defining another
    function that decorates any function that is provided as an input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过一个示例来查看不同类型的函数装饰器。我们将继续使用我们在上一章中查看的*ABC Megamart*示例。Python中的每个用户定义函数都可以执行不同的操作。但如果我们想让不同的函数显示特定的附加信息，无论这些函数执行什么操作呢？我们可以通过定义另一个函数来实现，该函数装饰任何作为输入提供的函数。
- en: 'Let’s take a look at the following steps to understand this better:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来更好地理解：
- en: 'A function decorator can be defined as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数装饰器可以这样定义：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code defines a simple function decorator that takes in any input function
    as an argument and adds a line above the function result that prints `---Decorate
    function with this line---` as the first output line for any input function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个简单的函数装饰器，它接受任何输入函数作为参数，并在函数结果上方添加一行，打印“---使用此行装饰函数---”作为任何输入函数的第一个输出行。
- en: 'This function decorator can be called by a new user-defined function with two
    different syntaxes. Let us define two simple functions:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数装饰器可以通过一个新定义的用户函数以两种不同的语法来调用。让我们定义两个简单的函数：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function returns the phrase `A picture is worth a thousand words`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回短语“一张图片胜过千言万语”。
- en: 'We will be adding one more function that returns a different phrase: `Actions
    speak louder than words`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个返回不同短语的功能：“行动胜于言语”：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following step, let us add a function decorator to both the preceding
    user-defined functions and look at the results:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下步骤中，让我们将函数装饰器添加到前面定义的两个用户定义函数中，并查看结果：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have reassigned the functions by adding a decorator
    function to them. Executing decorated function 1 results in the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过向它们添加装饰器函数来重新分配了函数。执行装饰函数1的结果如下：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we can also execute decorated function 2:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以执行装饰函数2：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both of the function results added an additional line, `---Decorate function
    with this line---`, that was not part of their function definition but was part
    of the decorator function. These examples show the reusable nature of function
    decorators.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数结果都添加了一条额外的行，`---使用此行装饰函数---`，这不是它们函数定义的一部分，而是装饰器函数的一部分。这些示例展示了函数装饰器的可重用性。
- en: 'Let us look further into syntax 2, which is the most widely used method of
    adding decorators to other functions, methods, or classes:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步探讨语法2，这是添加装饰器到其他函数、方法或类中最广泛使用的方法：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, while defining the user-defined functions, we added an
    additional line above the definition of `@functiondecorator`. This line signifies
    that we have added a decorator to the function in the definition stage itself.
    This decorator can be declared once and reused for any relevant function that
    is newly defined.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在定义用户定义函数时，我们在`@functiondecorator`定义上方添加了额外的行。这一行表示我们在定义阶段本身添加了装饰器。这个装饰器可以声明一次，并用于任何新定义的相关函数。
- en: 'Executing the preceding code provides the same results as in the code execution
    of examples with syntax 1:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的代码提供了与使用语法1的示例代码执行相同的输出：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that you understand simple function decorators, we can look into an example
    that demonstrates its applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了简单的函数装饰器，我们可以看看一个演示其应用的示例。
- en: Understanding function decorators with an application
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过应用理解函数装饰器
- en: We can further look into an example of function decorators using a scenario
    from *ABC Megamart*. In this example, we will create a function to add an email
    signature for a branch manager in a different format for each branch. We will
    define two functions, `manager_albany` and `manager_manhattan`, with different
    font colors and highlights.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步探讨一个使用*ABC Megamart*场景的函数装饰器示例。在这个例子中，我们将创建一个函数，为不同分支的分支经理添加不同格式的电子邮件签名。我们将定义两个函数，`manager_albany`和`manager_manhattan`，它们具有不同的字体颜色和高亮显示。
- en: 'Let’s look at this first piece of code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码的第一部分：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code prints the branch manager’s email signature with white,
    bold, and blue highlighted text:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码打印了分支经理的电子邮件签名，带有白色、粗体和蓝色高亮文本：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let’s take a quick look at this block of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下这段代码：
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This one prints the branch manager’s email signature with highlighted text:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将打印带有高亮文本的分支经理的电子邮件签名：
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let us add the name of *ABC Megamart* in both the signatures with a yellow
    highlight and modify the font color of the signature to yellow while keeping the
    signature highlight colors intact. To do this, we will create a function decorator
    that takes in the arguments of the preceding functions and add *ABC Megamart*
    with a black font and yellow highlight:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在两个签名中添加*ABC Megamart*的名称，并使用黄色高亮显示，同时保持签名高亮颜色不变。为此，我们将创建一个函数装饰器，该装饰器接受前面函数的参数，并将*ABC
    Megamart*添加为黑色字体和黄色高亮：
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The following figure is a representation of how an email signature decorator
    can be implemented on two different signatures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表示了如何在两个不同的签名上实现电子邮件签名装饰器。
- en: '![Figure 3.1 – Email signature decorator ](img/B13426_03_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 电子邮件签名装饰器](img/B13426_03_01.jpg)'
- en: Figure 3.1 – Email signature decorator
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 电子邮件签名装饰器
- en: The preceding signature decorator adds the name of *ABC Megamart* in both the
    signatures with a yellow highlight and modifies the font color of the signature
    to yellow while keeping the signature highlight colors intact.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的签名装饰器在两个签名中添加了*ABC Megamart*的名称，并使用黄色高亮显示，同时保持签名高亮颜色不变。
- en: 'First, let’s add `@signature` to `manager_manhattan`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将`@signature`添加到`manager_manhattan`：
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code returns the following email signature:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回以下电子邮件签名：
- en: '[PRE47]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let’s add `@signature` to `manager_albany`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将 `@signature` 添加到 `manager_albany`：
- en: '[PRE55]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Doing so returns the following email signature:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会返回以下电子邮件签名：
- en: '[PRE63]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Adding a function decorator to different functions in the preceding code snippets
    makes them have common functionality – in this case, the *ABC Megamart* title
    with a yellow highlight as a common functionality while keeping the individual
    branch manager signatures. It’s a simple example of how reusable decorators can
    be and the nature of adding metadata or additional information to a function while
    keeping the actual functionality of the function intact.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中添加一个函数装饰器到不同的函数中，使它们具有共同的功能——在这种情况下，*ABC Megamart* 的标题具有黄色高亮作为共同功能，同时保留各个分支经理的签名。这是一个简单示例，说明了可重用装饰器可以是什么，以及如何在保持函数实际功能完整的同时，向函数添加元数据或附加信息。
- en: Now that we understand what function decorators are and how we can use them,
    let’s look at utilizing decorators for different functions by exchanging them
    and making them more reusable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数装饰器是什么以及我们如何使用它们，让我们看看通过交换它们来利用装饰器为不同的函数，使它们更具可重用性。
- en: Exchanging decorators from one function to another
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数之间交换装饰器
- en: We now have an understanding of what a function decorator is and how a function
    decorator can be used for more than one function. We will look into further exploring
    the reusability concept of decorators by creating two different decorators to
    serve two different purposes and later utilizing them by interchanging the decorators
    between different functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了什么是函数装饰器以及函数装饰器可以用于多个函数。我们将通过创建两个不同的装饰器来进一步探索装饰器的可重用性概念，这两个装饰器将服务于不同的目的，并在不同函数之间交换装饰器。
- en: To demonstrate this concept, we will be creating Decorator 1 for function 1
    and Decorator 2 for function 2, and then we will be exchanging them from one function
    to another. Let us create two decorators to decorate two different functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，我们将为函数1创建装饰器1，为函数2创建装饰器2，然后我们将它们从一个函数交换到另一个函数。让我们创建两个装饰器来装饰两个不同的函数。
- en: '**Decorator 1** will be created to convert a date argument that is provided
    as a holiday date to the function that sets holidays for the Alabama branch of
    *ABC Megamart*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器1** 将被创建来转换提供的作为假日日期的日期参数，用于设置 *ABC Megamart* 阿拉巴马分支的假日。'
- en: The following figure is a representation of **Decorator 1** and its **Function
    1**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示是 **装饰器1** 和其 **函数1** 的表示。
- en: '![Figure 3.2 – Date converter as a decorator ](img/B13426_03_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 作为装饰器的日期转换器](img/B13426_03_02.jpg)'
- en: Figure 3.2 – Date converter as a decorator
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 作为装饰器的日期转换器
- en: 'Let’s take a look at the code we’d be using for our desired example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将使用以下代码来实现我们的示例：
- en: '[PRE70]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The preceding `dateconverter` is a decorator function that takes in another
    function as an argument. To perform this function, we have imported the `datetime`
    library that helps us to convert the input date argument into the format of weekday,
    day of the month, month of the year, and year. This decorator function internally
    takes in all the arguments passed to the internal function and checks whether
    any of the function arguments are of the `datetime` data type, and if it finds
    a `datetime` object, it will be converted to display weekday, day of the month,
    month of the year, and year.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `dateconverter` 是一个装饰器函数，它接受另一个函数作为参数。为了执行这个函数，我们导入了 `datetime` 库，这个库帮助我们把输入的日期参数转换成星期、月份中的天数、年份以及月份的格式。这个装饰器函数内部接受所有传递给内部函数的参数，并检查是否有任何函数参数是
    `datetime` 数据类型，如果找到 `datetime` 对象，它将被转换以显示星期、月份中的天数、年份和月份。
- en: This decorator also stores the converted format of the `datetime` object along
    with the rest of the function arguments in a list and passes the list as an argument
    to the function that is provided as input to this decorator. Let us now create
    a function to set a holiday calendar for the Alabama branch and decorate it using
    this decorator function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器还将转换后的 `datetime` 对象格式与函数的其他参数一起存储在一个列表中，并将该列表作为参数传递给作为此装饰器输入的函数。现在让我们创建一个函数来设置阿拉巴马分支的假日日历，并使用此装饰器函数对其进行装饰。
- en: '`*args` parameter. The first argument of this function will be set as `branch_id`,
    the second argument as `holiday_type`, the third argument as `holiday_name`, and
    the fourth argument as `holiday_date`. All of these input arguments are converted
    into a dictionary variable by the function and it returns the dictionary with
    its key-value pairs denoting each value.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args`参数。此函数的第一个参数将被设置为`branch_id`，第二个参数为`holiday_type`，第三个参数为`holiday_name`，第四个参数为`holiday_date`。所有这些输入参数也被函数转换为字典变量，并返回带有其键值对的字典，表示每个值。'
- en: 'Here is what the code looks like using the details we just discussed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用我们刚才讨论的细节的代码看起来像什么：
- en: '[PRE81]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the preceding code, we have started the function definition by adding the
    decorator `@dateconverter`, which takes care of converting the holiday date into
    the aforementioned format. Let us now call this function by providing the arguments
    required to create the holiday details dictionary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过添加装饰器`@dateconverter`开始函数定义，该装饰器负责将假日日期转换为上述格式。现在让我们通过提供创建假日详情字典所需的参数来调用此函数：
- en: '[PRE89]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the preceding code, we have created a `datatime` object and stored it in
    a holiday variable that will be passed as one of the inputs to the `set_holidays_alabama`
    function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`datatime`对象，并将其存储在名为holiday的变量中，该变量将被作为`set_holidays_alabama`函数的输入之一：
- en: '[PRE91]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The preceding code gives us the following decorated output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下装饰后的输出：
- en: '[PRE95]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We can now go ahead and create another decorator that performs a different manipulation
    on another function that is provided as input.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建另一个装饰器，它对提供的另一个函数执行不同的操作。
- en: Let’s now look at `id` is present in the input that denotes that the input value
    is an identifier of any kind and returns the numerical value of the identifier
    by removing its prefix. This decorator will be added to a function to set promotion
    details for any input product for the Malibu branch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看`id`是否存在于输入中，这表示输入值是任何类型的标识符，并通过移除其前缀来返回标识符的数值。这个装饰器将被添加到一个函数中，用于设置任何输入产品为Malibu分公司的促销详情。
- en: 'The following figure is a representation of **Decorator 2** and **Function
    2**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表示了**装饰器2**和**函数2**：
- en: '![Figure 3.3 – ID identifier as a decorator ](img/B13426_03_03.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – ID标识符作为装饰器](img/B13426_03_03.jpg)'
- en: Figure 3.3 – ID identifier as a decorator
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – ID标识符作为装饰器
- en: 'Here is the code we’ll be using for our decorator:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将用于装饰器的代码：
- en: '[PRE99]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The preceding identifier is a decorator function that takes in another function
    as an argument. This decorator function also internally takes in all the arguments
    passed to its internal function and navigates through each individual argument
    to check whether it is a string. If the argument is a string, the decorator converts
    the string into lowercase and checks whether it has a substring ID. If the substring
    ID is present in the variable, then all strings will be removed from the variable
    and only digits will be stored in it with the rest of the function arguments in
    a list, passing the list as an argument to the function that is provided as input
    to this decorator. Let us now create a function to set promotion details for the
    Malibu branch and decorate its ID using this decorator function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个标识符是一个装饰器函数，它接受另一个函数作为参数。这个装饰器函数还内部接受传递给其内部函数的所有参数，并遍历每个单独的参数以检查它是否是一个字符串。如果参数是一个字符串，装饰器将字符串转换为小写并检查它是否包含子串ID。如果子串ID存在于变量中，那么变量中的所有字符串都将被移除，并且只存储其中的数字，其余的函数参数以列表的形式传递给作为输入提供给此装饰器的函数。现在让我们创建一个函数来设置Malibu分公司的促销详情，并使用这个装饰器函数来装饰其ID。
- en: '`*args` similar to the `set_holidays_alabama` function. The first argument
    of this function will be set as `branch_id`, the second argument as `product_id`,
    the third argument as `promotion_date`, the fourth as `promotion_type`, and the
    fifth as `promotion_reason`. All of these input arguments are also converted into
    a dictionary variable by the function and it returns the dictionary with its key-value
    pairs denoting each value. There are two `id` arguments in this function that
    get decorated by the identifier.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`*args`类似于`set_holidays_alabama`函数。此函数的第一个参数将被设置为`branch_id`，第二个参数为`product_id`，第三个参数为`promotion_date`，第四个参数为`promotion_type`，第五个参数为`promotion_reason`。所有这些输入参数也被函数转换为字典变量，并返回带有其键值对的字典，表示每个值。此函数中有两个`id`参数，它们被标识符装饰。'
- en: 'Here is what the code looks like using the details we just discussed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用我们刚才讨论的细节所看到的代码样子：
- en: '[PRE111]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In the preceding code, we have started the function definition by adding the
    decorator `@identifier`, which takes care of removing the prefixes from the `id`
    variable. Let us now call this function by providing the arguments required to
    create the product promotion details dictionary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过添加装饰器 `@identifier` 开始了函数定义，该装饰器负责从 `id` 变量中移除前缀。现在让我们通过提供创建产品促销详细信息字典所需的参数来调用这个函数：
- en: '[PRE121]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here, we have created a `datatime` object and stored it in a promotion date,
    which will be passed as one of the inputs to the `set_promotion_malibu` function,
    but this date variable will stay in the same format as defined:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个 `datetime` 对象并将其存储在促销日期中，这个日期将作为 `set_promotion_malibu` 函数的一个输入参数传递，但这个日期变量将保持与定义相同的格式：
- en: '[PRE123]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The preceding code gives us the decorated output that follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下装饰后的输出：
- en: '[PRE124]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We now have two decorators and two different functions decorated by them. To
    check whether these decorators can be exchanged, let us now redefine these functions
    by swapping the decorators using the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个装饰器和两个由它们装饰的不同函数。为了检查这些装饰器是否可以交换，我们现在通过以下代码重新定义这些函数，使用交换装饰器：
- en: '[PRE130]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Let us input the required arguments and execute the preceding function, `set_holidays_alabama`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入所需的参数并执行前面的函数 `set_holidays_alabama`：
- en: '[PRE148]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'This code gives us the decorated output as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码给出了以下装饰后的输出：
- en: '[PRE154]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In the preceding output, the identifier is applied on the branch ID and there
    is no change to the holiday date. Similarly, let us execute the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，标识符应用于分支ID，而假日日期没有变化。同样，让我们执行以下代码：
- en: '[PRE158]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'This code gives us the decorated output that follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码给出了以下装饰后的输出：
- en: '[PRE160]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The following figure is a representation of how the two decorators will be
    exchanged or swapped between their functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了两个装饰器如何在它们的功能之间交换或替换：
- en: '![Figure 3.4 – Exchange decorators ](img/B13426_03_04.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 交换装饰器](img/B13426_03_04.jpg)'
- en: Figure 3.4 – Exchange decorators
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 交换装饰器
- en: Let us reuse the previous examples to look further into the concept of applying
    multiple decorators to one function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用之前的示例来进一步探讨将多个装饰器应用到单个函数的概念。
- en: Applying multiple decorators to one function
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个装饰器应用到单个函数
- en: So far, we have understood that decorators can be created and added to functions
    to perform metaprogramming on the functions. We also understand that decorators
    can be reused and exchanged for different functions. We have also understood that
    decorators add decoration or value to a function from outside of the function
    body and help in altering the function with additional information. What if we
    want the function to perform two different actions through decorators and at the
    same time do not want the decorators to become more specific? Can we create two
    or more different decorators and apply them to a single function? Yes, we can.
    We will now look at decorating a function with more than one decorator and understand
    how it works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到装饰器可以被创建并添加到函数中，以在函数上执行元编程。我们也了解到装饰器可以被重用并交换到不同的函数中。我们还了解到装饰器可以从函数外部添加装饰或值到函数中，并帮助通过附加信息来改变函数。如果我们想通过装饰器让函数执行两种不同的操作，同时又不想让装饰器变得更加具体，我们可以创建两个或更多不同的装饰器并将它们应用到单个函数上吗？是的，我们可以。现在我们将查看如何使用多个装饰器装饰一个函数以及它是如何工作的。
- en: For this example, let us reuse the decorators `dateconverter` and `identifier`.
    To understand this concept, we can reuse one of the previously declared functions,
    `set_promotion_malibu`, which has both a `datetime` object as an input argument
    – promotion date – and two ID values as input arguments – `branch_id` and `product_id`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，让我们重用装饰器 `dateconverter` 和 `identifier`。为了理解这个概念，我们可以重用之前声明的函数之一，`set_promotion_malibu`，它既有
    `datetime` 对象作为输入参数（促销日期）也有两个ID值作为输入参数（`branch_id` 和 `product_id`）。
- en: 'The following figure is a representation of adding two decorators to a function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了将两个装饰器添加到函数中：
- en: '![Figure 3.5 – Multiple decorators for one function ](img/B13426_03_05.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 一个函数的多个装饰器](img/B13426_03_05.jpg)'
- en: Figure 3.5 – Multiple decorators for one function
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 一个函数的多个装饰器
- en: 'The following code puts our example into action:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将我们的示例付诸实践：
- en: '[PRE166]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'In this code, we have added both decorators to the `set_promotion_malibu` function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将两个装饰器都添加到了`set_promotion_malibu`函数中：
- en: '[PRE177]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Executing the preceding code results in the application of both decorators
    on the input values:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致对输入值应用两个装饰器：
- en: '[PRE179]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: From the preceding output, we can see that `@identifier` is applied on `branch_id`
    and `product_id`. At the same time, `@dateconverter` is applied on the `promotion_date`.
    Let us now explore other variants of decorators.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`@identifier`应用于`branch_id`和`product_id`。同时，`@dateconverter`应用于`promotion_date`。现在让我们探索装饰器的其他变体。
- en: Exploring class decorators
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索类装饰器
- en: A `__init__` and `__call__`. Any variable initialized as part of the `__init__`
    function of a class while creating an object instance of the class becomes a variable
    of the class itself. Similarly, the `__call__` function of a class returns a function
    object. If we want to use a class as a decorator, we need to make use of the combination
    of these two built-in methods.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`和`__call__`。在创建类的对象实例时，作为`__init__`函数一部分初始化的任何变量都成为类的变量本身。同样，类的`__call__`函数返回一个函数对象。如果我们想将类用作装饰器，我们需要利用这两个内置方法的组合。'
- en: 'Let us look at what happens if we don’t use the `call` method. Look at the
    following piece of code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们不使用`call`方法会发生什么。看看以下代码片段：
- en: '[PRE185]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Here, we have created a class named `classdecorator` and have added the `init`
    method to take a function as input. We have also created a `decorator` method
    that stores the result of the initialized function variable and adds a decorator
    string decorated by a class decorator to the input function result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`classdecorator`的类，并添加了`init`方法来接收一个函数作为输入。我们还创建了一个`decorator`方法，它存储初始化的函数变量结果，并将由类装饰器装饰的装饰器字符串添加到输入函数结果中。
- en: 'Let us now create an input function to test the preceding `classdecorator`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个输入函数来测试前面的`classdecorator`：
- en: '[PRE192]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Adding this class decorator should decorate the input function. Let us check
    what happens when we call this input function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个类装饰器应该会装饰输入函数。让我们检查当我们调用这个输入函数时会发生什么：
- en: '[PRE195]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'We get the following type error, which states `classdecorator` is not callable:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下类型错误，指出`classdecorator`不可调用：
- en: '![Figure 3.6 – Error due to an incorrect definition of the class decorator
    ](img/B13426_03_06.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 由于类装饰器定义不正确导致的错误](img/B13426_03_06.jpg)'
- en: Figure 3.6 – Error due to an incorrect definition of the class decorator
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 由于类装饰器定义不正确导致的错误
- en: 'We are receiving this error since we did not use the right method to make the
    class behave as a decorator. The `decorator` method in the preceding code returns
    a variable but not a function. To make this class work as a decorator, we need
    to redefine the class as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到这个错误是因为我们没有使用正确的方法使类表现得像一个装饰器。前面代码中的`decorator`方法返回一个变量而不是一个函数。为了使这个类作为一个装饰器工作，我们需要按照以下方式重新定义类：
- en: '[PRE196]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Here, we have replaced the `decorator` method with the built-in method `__call__`.
    Let us now redefine the input function and see what happens:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`decorator`方法替换为内置方法`__call__`。现在让我们重新定义输入函数并看看会发生什么：
- en: '[PRE203]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'We can call the preceding function and check the behavior of this class decorator:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用前面的函数来检查这个类装饰器的行为：
- en: '[PRE206]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The following figure is a simple representation that shows an incorrect way
    of creating a class decorator:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图是一个简单的表示，展示了创建类装饰器的不正确方法：
- en: '![Figure 3.7 – Wrong method for creating a class decorator ](img/B13426_03_07.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 创建类装饰器的错误方法](img/B13426_03_07.jpg)'
- en: Figure 3.7 – Wrong method for creating a class decorator
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 创建类装饰器的错误方法
- en: 'Here is the correct way of creating it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建它的正确方式：
- en: '![Figure 3.8 – Correct method for creating a class decorator ](img/B13426_03_08.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 创建类装饰器的正确方法](img/B13426_03_08.jpg)'
- en: Figure 3.8 – Correct method for creating a class decorator
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 创建类装饰器的正确方法
- en: Now that you have a better understanding of class decorator, we can proceed
    to analyze the application of class decorator on *ABC Megamart*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对类装饰器有了更好的理解，我们可以继续分析类装饰器在*ABC Megamart*上的应用。
- en: Understanding class decorators with an application
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过应用来理解类装饰器
- en: We will look into a detailed example of the class decorator by applying it to
    a scenario on *ABC Megamart*. Let us consider a scenario where *ABC Megamart*
    has a separate class created for each branch. Let us also assume each class has
    its own method, `buy_product`, to calculate a product’s sales price by specifically
    applying the sales tax rate for the specific branch and product being purchased.
    When the mart wants to apply seasonal promotions that involve eight generic promotion
    types. Each branch class need not have a promotion calculation method to be applied
    to its calculated sales price. Instead, we can create a class decorator that can
    be applied to the `buy_product` method of each branch and the class decorator
    will, in turn, calculate the final sales price by applying promotion discounts
    on the actual sales price calculated by the branch.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将类装饰器应用于 *ABC Megamart* 的一个场景来详细了解类装饰器的应用。让我们考虑一个场景，其中 *ABC Megamart* 为每个分店创建了一个单独的类。让我们还假设每个类都有自己的方法
    `buy_product`，该方法通过具体应用购买的分店和产品的销售税率来计算产品的销售价格。当商场想要应用涉及八种通用促销类型的季节性促销时，每个分支类不需要有应用于其计算出的销售价格的促销计算方法。相反，我们可以创建一个类装饰器，可以应用于每个分支的
    `buy_product` 方法，并且类装饰器将反过来通过在分支计算的实际销售价格上应用促销折扣来计算最终销售价格。
- en: 'We will create two classes and add the `buy_product` method to each class to
    calculate the sales price without adding a class decorator. This is to understand
    the return values of the actual methods:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个类，并将 `buy_product` 方法添加到每个类中，以计算销售价格而不添加类装饰器。这是为了理解实际方法的返回值：
- en: '[PRE207]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Creating an object instance for the previous class and calling the method with
    its arguments returns the following result:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为前面的类创建一个对象实例，并使用其参数调用该方法，返回以下结果：
- en: '[PRE215]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Similarly, we can define the class `Arizona` and add the method `buy_product`
    and execute the following code to verify its return value without a decorator:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以定义一个名为 `Arizona` 的类，并添加 `buy_product` 方法，然后执行以下代码来验证其返回值，而不使用装饰器：
- en: '[PRE218]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The preceding `buy_product` method takes in product name, unit price, quantity,
    and promotion type as input and calculates the initial price by multiplying the
    unit price by the quantity of a product. It further calculates the sales price
    by adding the product of the initial price to the state tax rate along with the
    initial price calculated in the previous step. Finally, the method returns the
    sales price, product name, and promotion type. The sales tax rates are different
    for each state and the sales price calculation differs according to the sales
    tax rates.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `buy_product` 方法接受产品名称、单价、数量和促销类型作为输入，并通过将单价乘以产品的数量来计算初始价格。然后，它进一步通过将初始价格与上一步骤中计算的初始价格以及州税率相加来计算销售价格。最后，该方法返回销售价格、产品名称和促销类型。销售税率因州而异，销售价格的计算也根据销售税率的不同而不同。
- en: We can now create a class decorator to apply a promotional discount on the sales
    price and calculate the final sales price for a product by including the offer
    rate or discount rate.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个类装饰器来应用促销折扣到销售价格，并通过包括优惠率或折扣率来计算产品的最终销售价格。
- en: 'In the following code, let us define the class `applypromotion` and add two
    built-in methods required to make the class behave as a decorator:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，让我们定义一个名为 `applypromotion` 的类，并添加两个内置方法，使该类表现得像一个装饰器：
- en: 'The **__init__ method**: This is a function or method as an input variable
    in this scenario'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`__init__` 方法**：在这个场景中，这是一个作为输入变量的函数或方法'
- en: 'The **__call__ method**: This method accepts multiple input arguments, which
    are also the arguments of the function or method being decorated'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`__call__` 方法**：此方法接受多个输入参数，这些参数也是被装饰的函数或方法的参数'
- en: 'The input arguments are applied to the function or method being decorated and
    it further applies various discount rates to the sales price resulting from the
    input function by checking for eight different promotion types, recalculating
    the sales price, and storing it as the final sales price, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数应用于被装饰的函数或方法，并且它进一步通过检查八种不同的促销类型，重新计算销售价格，并将其存储为最终销售价格，如下所示：
- en: '[PRE229]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'The class decorator to `@applypromotion` is now ready to be further used by
    other functions or methods. We can now apply this decorator to the `buy_product`
    method from the class `Alabama`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器 `@applypromotion` 现在可以进一步由其他函数或方法使用。我们现在可以将这个装饰器应用到 `Alabama` 类的 `buy_product`
    方法上：
- en: '[PRE252]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Creating an object instance for the preceding code and calling its method works
    as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为前面的代码创建一个对象实例并调用其方法的工作方式如下：
- en: '[PRE259]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Similarly, we can also redefine the class `Arizona` and its method `buy_product`
    by adding the class decorator as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以通过添加类装饰器来重新定义名为 `Arizona` 的类及其 `buy_product` 方法，如下所示：
- en: '[PRE262]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Creating an object instance for the preceding code and calling its method works
    as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为前面的代码创建一个对象实例并调用其方法的工作方式如下：
- en: '[PRE271]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'Let us review the results of `buy_product` methods from Arizona before adding
    the decorator and after adding the decorator. The preceding code has the output
    after adding the decorator and the following code has the output before adding
    the decorator:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾在添加装饰器之前和之后 `buy_product` 方法的 `Arizona` 的结果。前面的代码是在添加装饰器后的输出，以下代码是在添加装饰器之前的输出：
- en: '[PRE274]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: After adding the `applypromotion` decorator, the sales price for 250 packs of
    cookies is at a discounted rate of $85.66 compared to the price of $128.50 before
    applying the promotion. The store need not always add a promotion on a product
    and the `buy_product` method can reuse the `applypromotion` decorator only when
    it needs to sell a product on promotion, thus making the decorator externally
    alter the behavior of the class while keeping the `buy_product` method’s actual
    functionality intact.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 `applypromotion` 装饰器后，250包巧克力的销售价格在促销前后的价格相差$128.50，折扣后的价格为$85.66。商店不必总是对产品进行促销，而
    `buy_product` 方法只有在需要促销销售产品时才能重用 `applypromotion` 装饰器，从而在保持 `buy_product` 方法实际功能完整的同时，使装饰器能够外部改变类的行为。
- en: 'The simple representation of this example is as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的简单表示如下：
- en: '![Figure 3.9 – Class decorator to apply promotional discounts on products ](img/B13426_03_09.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 应用促销折扣的产品类装饰器](img/B13426_03_09.jpg)'
- en: Figure 3.9 – Class decorator to apply promotional discounts on products
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 应用促销折扣的产品类装饰器
- en: Having learned how to apply class decorators to methods or functions from other
    classes, we will proceed further to look at some of the built-in decorators available
    in Python.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何将类装饰器应用于来自其他类的函数或方法之后，我们将进一步探讨 Python 中可用的内置装饰器。
- en: Getting to know built-in decorators
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解内置装饰器
- en: Now, the question is, do we have to always create user-defined or custom decorators
    to be applied to classes and methods, or do we have some pre-defined decorators
    that can be used for specific purposes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是，我们是否总是需要创建用户定义或自定义装饰器来应用于类和方法，或者我们是否有一些预定义的装饰器可以用于特定目的。
- en: In addition to the user-defined decorators that we’ve looked at throughout this
    chapter, Python has its own built-in decorators, such as `@staticmethod` and `@classmethod`,
    that can be directly applied to methods. These decorators add certain important
    functionalities to methods and classes during the process of the class definition
    itself. We will be looking at these two decorators in detail, as follows.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中我们查看的用户定义装饰器之外，Python 还有一些自己的内置装饰器，如 `@staticmethod` 和 `@classmethod`，可以直接应用于方法。这些装饰器在类定义的过程中为方法和类添加了某些重要的功能。我们将详细探讨这两个装饰器，如下所示。
- en: The static method
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: The `@staticmethod` – is a decorator that takes in a regular Python function
    as an input argument and converts it into a static method. Static methods can
    be created inside a class but will not use the implicit first argument of the
    class object instance usually denoted as an argument named `self` like the other
    instance-based methods.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`@staticmethod` – 是一个装饰器，它接受一个常规的 Python 函数作为输入参数，并将其转换为静态方法。静态方法可以在类内部创建，但不会使用类对象实例的隐式第一个参数，通常表示为名为
    `self` 的参数，就像其他基于实例的方法一样。'
- en: 'To understand this concept, let us first create the class `Alabama` and add
    a function to the class `buy_product` without `self` as an argument and without
    the static method decorator and check its behavior:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，让我们首先创建一个名为 `Alabama` 的类，并向该类添加一个名为 `buy_product` 的函数，该函数不带 `self`
    参数，也不带静态方法装饰器，并检查其行为：
- en: '[PRE276]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Here we have defined the class `Alabama` with the function `buy_product`. Let
    us now create an object instance and call the function inside the class to check
    its behavior:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `Alabama` 的类，其中包含一个名为 `buy_product` 的函数。现在，让我们创建一个对象实例，并在类内部调用该函数以检查其行为：
- en: '[PRE283]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'Executing this code leads to the following error:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码会导致以下错误：
- en: '![Figure 3.10 – Error on calling a function without static method and self
    ](img/B13426_03_10.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 调用不带静态方法和 self 的函数时的错误](img/B13426_03_10.jpg)'
- en: Figure 3.10 – Error on calling a function without static method and self
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 在调用没有静态方法和 self 的函数时出错
- en: 'Rerunning the preceding function without creating an object works as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行前面的函数而不创建对象的工作方式如下：
- en: '[PRE285]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'To avoid the preceding error and to call a function inside a class with or
    without creating an object, we can convert the function into a static method by
    adding the `@staticmethod` decorator to it. We can now look at how it works:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免前面的错误，并在创建或不创建对象的情况下调用类内的函数，我们可以通过向函数中添加 `@staticmethod` 装饰器将其转换为静态方法。现在我们可以看看它是如何工作的：
- en: '[PRE287]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'We have added an additional method named `another_method`, which can only be
    called using an object instance. Let us now create an object for the class and
    call both the preceding methods:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `another_method` 的额外方法，它只能通过对象实例来调用。现在让我们为该类创建一个对象并调用前面的两个方法：
- en: '[PRE298]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Both the methods, `static` and `instance`, can be called using the object of
    the class. At the same time, the static method can also be called using the class
    itself without creating an object:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法，`static` 和 `instance`，都可以使用类的对象来调用。同时，静态方法也可以使用类本身来调用，而无需创建对象：
- en: '[PRE303]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Executing this code leads to the following error:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码会导致以下错误：
- en: '![Figure 3.11 – Error on calling an instance method using its class ](img/B13426_03_11.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 使用其类调用实例方法时出错](img/B13426_03_11.jpg)'
- en: Figure 3.11 – Error on calling an instance method using its class
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 使用其类调用实例方法时出错
- en: The static method generated the expected output when called using its class,
    while the instance method did not run. This is the advantage of using a static
    method to convert a function into a method inside a class.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用其类调用时，静态方法生成了预期的输出，而实例方法没有运行。这是使用静态方法将函数转换为类内部方法的优点。
- en: The class method
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: 'The `@classmethod` – is also a built-in decorator similar to `@staticmethod,`
    and this decorator also converts a function into a static method inside a class.
    `@staticmethod` does not have an implicit argument of the object to a class whereas
    `@classmethod` has an implicit argument, `cls`, which gets added to the function,
    while the `@classmethod` decorator is added to it as seen in the following code
    block:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`@classmethod` – 也是一个类似于 `@staticmethod` 的内置装饰器，这个装饰器也将一个函数转换为类内部的静态方法。`@staticmethod`
    没有对类的对象的隐含参数，而 `@classmethod` 有一个隐含参数 `cls`，它被添加到函数中，而 `@classmethod` 装饰器则添加到它上面，如下面的代码块所示：'
- en: '[PRE306]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'This function can be called either with or without creating a class instance.
    We can look at both in the following code:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以带或不带创建类实例来调用。我们可以在下面的代码中查看这两种情况：
- en: '[PRE315]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: In the preceding code, we can see that a function converted by `@classmethod`
    into a class method can be called directly using the class or by creating an object
    of the class.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到通过 `@classmethod` 转换为类方法的函数可以直接使用类或通过创建类的对象来调用。
- en: These are a few of the built-in decorators and there are more such decorators
    available in Python 3 that can be explored and reused.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些内置的装饰器，Python 3 中还有更多这样的装饰器可供探索和重用。
- en: Summary
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create simple decorators and how to
    apply decorators with examples. We saw how to exchange decorators from one function
    to another along with how to add multiple decorators to one function.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建简单的装饰器，以及如何通过示例应用装饰器。我们看到了如何将装饰器从一个函数交换到另一个函数，以及如何将多个装饰器添加到同一个函数中。
- en: We now understand the concept of class decorators and have looked at an example
    of how to apply them. And finally, we learned how to use some built-in decorators
    such as `@staticmethod` and `@classmethod`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了类装饰器的概念，并查看了一个如何应用它们的示例。最后，我们学习了如何使用一些内置装饰器，如 `@staticmethod` 和 `@classmethod`。
- en: All of these concepts are part of Python metaprogramming and they are used to
    change the behavior of a function or a method externally and without impacting
    the internal functionalities of the function or method.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些概念都是 Python 元编程的一部分，并且它们被用来在外部更改函数或方法的行为，而不影响函数或方法的内部功能。
- en: In the next chapter, we will be looking at the concept of meta classes with
    different examples.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过不同的示例来探讨元类概念。
