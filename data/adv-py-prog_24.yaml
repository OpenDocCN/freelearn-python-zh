- en: '*Chapter 21*: The Bridge Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第21章*：桥接模式'
- en: In the previous two chapters, we covered our first structural pattern, **adapter**,
    which is used to make two incompatible interfaces compatible, and **decorator**,
    which allows us to add responsibilities to an object in a dynamic way. There are
    more similar patterns. Let's continue with the series!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们介绍了我们的第一个结构模式**适配器**，它用于使两个不兼容的接口兼容，以及**装饰器**，它允许我们以动态的方式向对象添加责任。还有更多类似的模式。让我们继续这个系列！
- en: A third structural pattern to look at is the **bridge** pattern. We can actually
    compare the *bridge* and the *adapter* patterns by looking at the way they work.
    While the adapter is used to make unrelated classes work together (as we saw in
    the implementation example discussed in [*Chapter 19*](B17499_19_Final_SS_ePub.xhtml#_idTextAnchor310),
    *The Adapter Pattern*), the bridge pattern is designed upfront to decouple an
    implementation from its abstraction, as we are going to see in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要观察的第三种结构模式是**桥接模式**。我们可以通过观察它们的工作方式来比较**桥接模式**和**适配器模式**。虽然适配器用于使不相关的类协同工作（正如我们在第[*第19章*](B17499_19_Final_SS_ePub.xhtml#_idTextAnchor310)，*适配器模式*）中讨论的实现示例中所见），但桥接模式在设计之初就是为了解耦实现与其抽象，正如我们将在本章中看到的那样。
- en: 'Specifically, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将讨论以下主题：
- en: Real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: Use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: By the end of this chapter, we will know how to implement this design pattern
    and understand better the aforementioned difference with the adapter pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解如何实现这种设计模式，并更好地理解与适配器模式上述的区别。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过此链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21)。
- en: Real-world examples
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: In our modern, everyday lives, one example of the bridge pattern that I can
    think of is **information products** from the *digital economy*. Nowadays, the
    information product, or **infoproduct** is part of the resources you can find
    online for training, self-improvement, or your ideas and business development.
    The purpose of an information product found on certain marketplaces, or the website
    of the provider, is to deliver information on a given topic in such a way that
    it is easy to access and consume. The material provided can be a PDF document
    or ebook, an ebook series, a video, a video series, an online course, a subscription-based
    newsletter, or a combination of all those formats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现代的日常生活中，我能想到的一个桥接模式的例子是来自*数字经济*的**信息产品**。如今，信息产品，或**信息产品**是你可以在线找到的资源的一部分，用于培训、自我提升或你的想法和商业发展。在某个市场或供应商网站上找到的信息产品的目的是以易于访问和消费的方式提供特定主题的信息。提供的材料可以是PDF文档或电子书、电子书系列、视频、视频系列、在线课程、基于订阅的通讯或所有这些格式的组合。
- en: In the software realm, **device drivers** are often cited as an example of the
    bridge pattern, when the developer of an **operating system** (**OS**) defines
    the interface for device vendors to implement it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，**设备驱动程序**经常被引用为桥接模式的一个例子，当操作系统（**OS**）的开发者为设备供应商定义接口以实现它时。
- en: Next, let's discuss when this design pattern should be employed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论何时应该使用这种设计模式。
- en: Use cases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: 'Using the bridge pattern is a good idea when you want to share an implementation
    among multiple objects. Basically, instead of implementing several specialized
    classes, defining all that is required within each class, you can define the following
    special components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在多个对象之间共享实现时，使用桥接模式是个好主意。基本上，而不是实现几个专门的类，在每一个类中定义所有需要的内容，你可以定义以下特殊组件：
- en: An abstraction that applies to all the classes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个适用于所有类的抽象
- en: A separate interface for the different objects involved
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为涉及的不同对象定义一个单独的接口
- en: Next, we will see an implementation example that illustrates this approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一个实现示例，以说明这种方法。
- en: Implementation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s assume we are building an application where the user is going to manage
    and deliver content after fetching it from diverse sources, which could be the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个应用程序，用户将管理并交付从不同来源获取的内容，这些来源可能是以下内容：
- en: A web page (based on its URL)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于其 URL 的网页
- en: A resource accessed on an FTP server
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在 FTP 服务器上访问的资源
- en: A file on the local filesystem
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统上的文件
- en: A database server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库服务器
- en: 'So, here is the idea: instead of implementing several content classes, each
    holding the methods responsible for getting the content pieces, assembling them,
    and showing them inside the application, we can define an abstraction for the
    `Resource Content`and a separate interface for the objects that are responsible
    for fetching the content. Let''s try it!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里的思想是：而不是实现几个内容类，每个类都包含负责获取内容片段、组装它们并在应用程序中显示的方法，我们可以定义 `Resource Content`
    的抽象以及一个单独的接口，用于负责获取内容的对象。让我们试试看！
- en: We begin with the class for our `Resource Content` abstraction, called `ResourceContent`.
    Then, we will need to define the interface for implementation classes that help
    fetch content, that is, the `ResourceContentFetcher` class. This concept is called
    the **Implementor**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义我们的 `Resource Content` 抽象类 `ResourceContent` 开始，然后我们需要定义帮助获取内容的实现类接口，即
    `ResourceContentFetcher` 类。这个概念被称为 **实现者**。
- en: 'The first trick we use here is to use the `_imp` attribute on the `ResourceContent`
    class to maintain a reference to the object, which represents the *Implementor*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的第一个技巧是在 `ResourceContent` 类上使用 `_imp` 属性来维护对对象的引用，该对象代表 *实现者*：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you may know by now, we define the equivalent of an interface in the Python
    language using two features: the `metaclass` feature (which helps define the *type
    of a type*), and **abstract base classes** (**ABC**), as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经知道的，我们使用 Python 语言的两个特性来定义接口的等价物：`metaclass` 特性（它有助于定义 *类型的类型*），以及 **抽象基类**（**ABC**），如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can add an implementation class called `URLFetcher` to fetch content
    from a web page or resource:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个名为 `URLFetcher` 的实现类，用于从网页或资源获取内容：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also add an implementation class called `LocalFileFecher` to fetch content
    from a file on the local filesystem:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个名为 `LocalFileFecher` 的实现类，用于从本地文件系统中的文件获取内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Based on that, our `main` function for showing content using both *content
    fetchers* could look like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们展示内容的 `main` 函数，使用两种 *内容获取器* 可能如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Overall, our process could be summarized in the following UML diagram, where
    `LocalFileFetcher` and `URLFetcher` both inherit from `ResrouceContentFetcher`,
    and `ResourceContent` stores a `Fetcher` object in its `_imp` field:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们的过程可以用以下 UML 图来概括，其中 `LocalFileFetcher` 和 `URLFetcher` 都继承自 `ResrouceContentFetcher`，而
    `ResourceContent` 在其 `_imp` 字段中存储一个 `Fetcher` 对象：
- en: '![Figure 21.1 — UML diagram of the content-fetching application ](img/Figure_21.1_B17499.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.1 — 内容获取应用程序的 UML 图](img/Figure_21.1_B17499.jpg)'
- en: Figure 21.1 — UML diagram of the content-fetching application
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1 — 内容获取应用程序的 UML 图
- en: 'Let''s see a summary for the complete code of our example (the `bridge.py`
    file):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们示例（`bridge.py` 文件）的完整代码的总结：
- en: We import the three modules we need for the program (`abc`, `urllib.parse`,
    and `urllib.request`).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入程序所需的三个模块（`abc`、`urllib.parse` 和 `urllib.request`）。
- en: We define the `ResourceContent` class for the interface of the abstraction.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了抽象的接口 `ResourceContent` 类。
- en: We define the `ResourceContentFetcher` class for the implementator.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为实现者定义了 `ResourceContentFetcher` 类。
- en: 'We define two `implementation` classes:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个 `implementation` 类：
- en: '`URLFetcher` for fetching content from a URL'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLFetcher` 用于从 URL 获取内容'
- en: '`LocalFileFetcher` for fetching content from the local filesystem'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalFileFetcher` 用于从本地文件系统获取内容'
- en: Finally, we add the `main()` function, as shown previously, and the usual trick
    to call it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了之前显示的 `main()` 函数，以及通常的调用它的技巧。
- en: 'Here is some sample output when executing the `python bridge.py` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行 `python bridge.py` 命令时的部分输出示例：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a basic illustration of how, using the bridge pattern in your design,
    you can extract content from different sources and integrate the results in the
    same data manipulation system or user interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用设计中的桥接模式从不同来源提取内容并将结果集成到相同的数据处理系统或用户界面中的基本说明。
- en: Summary
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the bridge pattern. Sharing similarities with
    the adapter pattern, the bridge pattern differs in the sense that it is used upfront
    to define an abstraction and its implementation in a decoupled way so that both
    can vary independently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了桥接模式。与适配器模式相似，桥接模式的不同之处在于它预先用来以解耦的方式定义抽象及其实现，这样两者都可以独立变化。
- en: The bridge pattern is useful when writing software for problem domains such
    as OSs, device drivers, GUIs, and website builders where we have multiple themes,
    and we need to change the theme of a website based on certain properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写用于操作系统、设备驱动程序、GUI和网站构建器等问题的软件时，桥接模式非常有用，在这些领域中我们有多套主题，并且需要根据某些属性更改网站的主题。
- en: To help you understand this pattern, we discussed an example in the domain of
    content extraction and management, where we defined an interface for the abstraction,
    an interface for the Implementor, and two implementations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解这个模式，我们在内容提取和管理领域讨论了一个示例，其中我们定义了一个抽象的接口、一个实现者的接口以及两个实现。
- en: In the next chapter, we are going to cover the façade pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍外观模式。
- en: Questions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main motivation for the bridge pattern?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桥接模式的主要动机是什么？
- en: How does the bridge pattern differ from the adapter pattern?
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桥接模式与适配器模式有何不同？
- en: How is the bridge pattern implemented in the Python example of content extraction
    we considered?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们考虑的内容提取的Python示例中，桥接模式是如何实现的？
