- en: Chapter 14. Useful Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。有用的设计模式
- en: 'A design pattern is a reusable, somewhat language-specific solution to a common
    problem in software design. The most popular book on this topic is *Design Patterns:
    Elements of Reusable Object-Oriented Software*, *Addison-Wesley Professional*,
    written by Gamma, Helm, Johnson, and Vlissides, also known as the *Gang of Four*
    or *GoF*. It is considered as a major writing in this area and provides a catalogue
    of 23 design patterns with examples in SmallTalk and C++.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件设计中常见问题的可重用的、有些特定于语言的解决方案。关于这个主题最流行的书是*设计模式：可复用面向对象软件的元素*，*Addison-Wesley
    Professional*，由Gamma、Helm、Johnson和Vlissides编写，也被称为*四人帮*或*GoF*。它被认为是这一领域的重要著作，并提供了23种设计模式的目录，其中包括SmallTalk和C++的示例。
- en: While designing an application code, these patterns help in solving common problems.
    They ring a bell to all developers since they describe proven development paradigms.
    But they should be studied with the used language in mind, since some of them
    do not make sense in some languages or are already built-in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序代码时，这些模式有助于解决常见问题。它们向所有开发人员发出警报，因为它们描述了经过验证的开发范例。但是应该根据使用的语言来学习它们，因为其中一些在某些语言中没有意义或者已经内置。
- en: 'This chapter describes the most useful patterns in Python or patterns that
    are interesting to discuss, with implementation examples. The following are the
    three sections that correspond to design pattern categories defined by the GoF:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Python中最有用的模式或者有趣讨论的模式，并提供了实现示例。以下是三个部分，对应于GoF定义的设计模式类别：
- en: '**Creational patterns**: These are patterns that are used to generate objects
    with specific behaviors'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模式**：这些模式用于生成具有特定行为的对象'
- en: '**Structural patterns**: These are patterns that help in structuring the code
    for specific use cases'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：这些模式有助于为特定用例构建代码结构'
- en: '**Behavioral patterns**: These are patterns that help in assigning responsibilities
    and encapsulating behaviors'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些模式有助于分配责任和封装行为'
- en: Creational patterns
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模式
- en: Creational patterns deal with object instantiation mechanism. Such a pattern
    might define a way as to how object instances are created or even how classes
    are constructed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式处理对象实例化机制。这样的模式可能定义了对象实例的创建方式，甚至类的构造方式。
- en: These are very important patterns in compiled languages such as C or C++, since
    it is harder to generate types on-demand at run time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式在编译语言（如C或C++）中非常重要，因为在运行时更难以按需生成类型。
- en: 'But creating new types at runtime is pretty straightforward in Python. The
    built-in `type` function lets you define a new type object by code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在Python中，运行时创建新类型非常简单。内置的`type`函数允许您通过代码定义一个新的类型对象：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Classes and types are built-in factories. We already dealt with the creation
    of new class objects and you can interact with class and object generation using
    metaclasses. These features are the basics for implementing the **factory** design
    pattern, but we won't further describe it in this section because we extensively
    covered the topic of class and object creation in [Chapter 3](ch03.html "Chapter 3. Syntax
    Best Practices – above the Class Level"), *Syntax Best Practices – above the Class
    Level*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类和类型是内置的工厂。我们已经处理了新类对象的创建，您可以使用元类与类和对象生成进行交互。这些功能是实现**工厂**设计模式的基础，但我们不会在本节进一步描述它，因为我们已经在[第3章](ch03.html
    "第3章。类级别以上的语法最佳实践")中广泛涵盖了类和对象创建的主题，*语法最佳实践 - 类级别以上*。
- en: Besides factory, the only other creational design pattern from the GoF that
    is interesting to describe in Python is singleton.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工厂，GoF中另一个有趣的创建设计模式是单例。
- en: Singleton
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: '**Singleton** restricts the instantiation of a class to only a single object
    instance.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例**将类的实例化限制为仅一个对象实例。'
- en: The singleton pattern makes sure that a given class has always only one living
    instance in the application. This can be used, for example, when you want to restrict
    a resource access to one and only one memory context in the process. For instance,
    a database connector class can be a singleton that deals with synchronization
    and manages its data in memory. It makes the assumption that no other instance
    is interacting with the database in the meantime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式确保给定的类在应用程序中始终只有一个活动实例。例如，当您希望将资源访问限制为进程中仅有一个内存上下文时，可以使用此模式。例如，数据库连接器类可以是一个单例，它处理同步并在内存中管理数据。它假设与数据库交互的同时没有其他实例。
- en: This pattern can simplify a lot the way concurrency is handled in an application.
    Utilities that provide application-wide functions are often declared as singletons.
    For instance, in web applications, a class that is in charge of reserving a unique
    document ID would benefit from the singleton pattern. There should be one and
    only one utility doing this job.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以简化应用程序中处理并发的方式。提供应用程序范围功能的实用程序通常被声明为单例。例如，在Web应用程序中，负责保留唯一文档ID的类将受益于单例模式。应该有一个且仅有一个执行此工作的实用程序。
- en: 'There is a popular semi-idiom to create singletons in Python by overriding
    the `__new__()` method of a class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一种流行的半成语是通过覆盖类的`__new__()`方法来创建单例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you try to create multiple instances of that class and compare their IDs,
    you will find that they all represent the same object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试创建该类的多个实例并比较它们的ID，您会发现它们都代表同一个对象：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I call this a semi-idiom because it is a really dangerous pattern. The problem
    starts when you try to subclass your base singleton class and create an instance
    of this new subclass if you already created an instance of the base class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其称为半成语，因为这是一个非常危险的模式。问题在于当您尝试对基本单例类进行子类化并创建此新子类的实例时，如果您已经创建了基类的实例，则问题就开始了。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This may become even more problematic when you notice that this behavior is
    affected by an instance creation order. Depending on your class usage order, you
    may or may not get the same result. Let''s see what the results are if you create
    the subclass instance first and after that, the instance of the base class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会变得更加棘手，当你注意到这种行为受到实例创建顺序的影响时。根据你的类使用顺序，你可能会得到相同的结果，也可能不会。让我们看看如果你首先创建子类实例，然后创建基类的实例，结果会是什么样的：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the behavior is completely different and very hard to predict.
    In large applications, it may lead to very dangerous and hard-to-debug problems.
    Depending on the run time context, you may or may not use the classes that you
    were meant to. Because such a behavior is really hard to predict and control,
    the application may break because of changed import order or even user input.
    If your singleton is not meant to be subclassed, it may be relatively safe to
    implement that way. Anyway, it's a ticking bomb. Everything may blow up if someone
    disregards the risk in future and decides to create a subclass from your singleton
    object. It is safer to avoid this particular implementation and use an alternative
    one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，行为完全不同，非常难以预测。在大型应用程序中，这可能导致非常危险且难以调试的问题。根据运行时上下文，您可能会或者不会使用您本来打算使用的类。由于这种行为真的很难预测和控制，应用程序可能会因为改变的导入顺序甚至用户输入而崩溃。如果您的单例不打算被子类化，那么以这种方式实现可能相对安全。无论如何，这是一个定时炸弹。如果将来有人忽视风险并决定从您的单例对象创建一个子类，一切都可能会爆炸。避免使用这种特定的实现，使用另一种替代方案会更安全。
- en: 'It is a lot safer to use a more advanced technique—metaclasses. By overriding
    the `__call__()` method of a metaclass, you can affect the creation of your custom
    classes. This allows creating a reusable singleton code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高级的技术——元类是更安全的。通过重写元类的`__call__()`方法，您可以影响自定义类的创建。这允许创建可重用的单例代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By using this `Singleton` as a metaclass for your custom classes, you are able
    to get singletons that are safe to subclass and independent of instance creation
    order:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Singleton`用作自定义类的元类，您可以获得安全的可子类化的单例，并且不受实例创建顺序的影响：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another way to overcome the problem of trivial singleton implementation is to
    use what Alex Martelli proposed. He came out with something similar in behavior
    to singleton but completely different in structure. This is not a classical design
    pattern coming from the GoF book, but it seems to be common among Python developers.
    It is called **Borg** or **Monostate**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 克服单例实现问题的另一种方法是使用Alex Martelli提出的方法。他提出了一种与单例类似但在结构上完全不同的方法。这不是来自GoF书籍的经典设计模式，但似乎在Python开发人员中很常见。它被称为**Borg**或**Monostate**。
- en: 'The idea is quite simple. What really matters in the singleton pattern is not
    the number of living instances a class has, but rather the fact that they all
    share the same state at all times. So, Alex Martelli came up with a class that
    makes all instances of the class share the same `__dict__`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常简单。单例模式中真正重要的不是一个类有多少个实例，而是它们始终共享相同的状态。因此，Alex Martelli提出了一个使类的所有实例共享相同`__dict__`的类：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This fixes the subclassing issue but is still dependent on how the subclass
    code works. For instance, if `__getattr__` is overridden, the pattern can be broken.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了子类化问题，但仍取决于子类代码的工作方式。例如，如果重写了`__getattr__`，则可能会破坏模式。
- en: Nevertheless, singletons should not have several levels of inheritance. A class
    that is marked as a singleton is already specific.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单例不应该有多层继承。标记为单例的类已经是特定的。
- en: That said, this pattern is considered by many developers as a heavy way to deal
    with uniqueness in an application. If a singleton is needed, why not use a module
    with functions instead, since a Python module is already singleton? The most common
    pattern is to define a module-level variable as an instance of a class that needs
    to be singleton. This way, you also don't constrain the developers to your initial
    design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，许多开发人员认为这种模式是处理应用程序中的唯一性的一种繁重方式。如果需要单例，为什么不使用具有函数的模块，因为Python模块已经是单例了呢？最常见的模式是将模块级变量定义为需要是单例的类的实例。这样，你也不会限制开发人员对你的初始设计。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The singleton factory is an *implicit* way of dealing with the uniqueness of
    your application. You can live without it. Unless you are working in a framework
    à la Java that requires such a pattern, use a module instead of a class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单例工厂是处理应用程序唯一性的*隐式*方式。你可以不用它。除非你在类似Java的框架中工作，这种模式是必需的，否则请使用模块而不是类。
- en: Structural patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: Structural patterns are really important in big applications. They decide how
    the code is organized and give developers recipes on how to interact with each
    part of the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式在大型应用程序中非常重要。它们决定了代码的组织方式，并为开发人员提供了如何与应用程序的每个部分进行交互的指南。
- en: For a long time, the most well-known implementation of many structural patterns
    in the Python world provided the Zope project with its **Zope Component Architecture**
    (**ZCA**). It implements most of the patterns described in this section and provides
    a rich set of tools to work with them. The ZCA is intended to run not only in
    the Zope framework, but also in other frameworks such as Twisted. It provides
    an implementation of interfaces and adapters among other things.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，Python世界中许多结构模式的最著名实现是Zope项目的**Zope组件架构**（**ZCA**）。它实现了本节中描述的大多数模式，并提供了一套丰富的工具来处理它们。ZCA旨在不仅在Zope框架中运行，还在其他框架中运行，如Twisted。它提供了接口和适配器的实现，以及其他功能。
- en: Unfortunately (or not), Zope lost almost all of its momentum and is not as popular
    as it used to be. But its ZCA may still be a good reference on implementing structural
    patterns in Python. Baiju Muthukadan created *A Comprehensive Guide to Zope Component
    Architecture*. It is available both in print and freely online (refer to [http://muthukadan.net/docs/zca.html](http://muthukadan.net/docs/zca.html)).
    It was written in 2009, so it does not cover the latest versions of Python but
    should still be a good read because it provides a lot of rationale for some of
    the mentioned patterns.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（或者不是），Zope几乎失去了所有的动力，不再像以前那样受欢迎。但是它的ZCA可能仍然是Python中实现结构模式的一个很好的参考。Baiju
    Muthukadan创建了*Zope组件架构综合指南*。它可以打印和免费在线获取（参考[http://muthukadan.net/docs/zca.html](http://muthukadan.net/docs/zca.html)）。它是在2009年写的，所以它没有涵盖Python的最新版本，但应该是一个很好的阅读，因为它为一些提到的模式提供了很多合理性。
- en: Python already provides some of the popular structural patterns through its
    syntax. For instance, the class and function decorators can be considered a flavor
    of the **decorator pattern**. Also, support for creating and importing modules
    is an emanation of **module pattern**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经通过其语法提供了一些流行的结构模式。例如，类和函数装饰器可以被认为是**装饰器模式**的一种变体。此外，创建和导入模块的支持是**模块模式**的一种表现。
- en: 'The list of common structural patterns is actually quite long. The original
    *Design Patterns* book featured as many as seven of them and the list was later
    extended by other literature. We won''t discuss all of them but will focus only
    on the three most popular and recognized ones, which are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 常见结构模式的列表实际上相当长。原始的*设计模式*书中有多达七种，后来的文献中还扩展了这个列表。我们不会讨论所有这些模式，而只会专注于最受欢迎和公认的三种模式，它们是：
- en: Adapter
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Proxy
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Facade
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Adapter
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: The **Adapter** pattern allows the interface of an existing class to be used
    from another interface. In other words, an adapter wraps a class or an object
    *A* so that it works in a context intended for a class or an object *B*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器**模式允许使用现有类的接口从另一个接口中使用。换句话说，适配器包装了一个类或对象*A*，使其在预期用于类或对象*B*的上下文中工作。'
- en: 'Creating adapters in Python is actually very straightforward due to how typing
    in this language works. The typing philosophy in Python is commonly referred to
    as duck-typing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建适配器实际上非常简单，因为这种语言的类型系统是如何工作的。Python中的类型哲学通常被称为鸭子类型：
- en: '*"If it walks like a duck and talks like a duck, then it''s a duck!"*'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“如果它走起来像鸭子，说起来像鸭子，那么它就是鸭子！”*'
- en: According to this rule, if a value for a function or method is accepted, the
    decision should not be based on its type but rather on its interface. So, as long
    as the object behaves as expected, that is, has proper method signatures and attributes,
    its type is considered compatible. This is completely different from many statically
    typed languages where such a thing is rarely available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个规则，如果一个函数或方法接受一个值，决定不应该基于它的类型，而应该基于它的接口。因此，只要对象的行为符合预期，即具有适当的方法签名和属性，它的类型就被认为是兼容的。这与许多静态类型的语言完全不同，在这些语言中很少有这样的事情。
- en: In practice, when some code is intended to work with a given class, it is fine
    to feed it with objects from another class as long as they provide the methods
    and attributes used by the code. Of course, this assumes that the code isn't calling
    an `instance` to verify that the instance is of a specific class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当一些代码打算与给定类一起工作时，只要它们提供了代码使用的方法和属性，就可以用另一个类的对象来提供它。当然，这假设代码不会调用`instance`来验证实例是否属于特定类。
- en: 'The adapter pattern is based on this philosophy and defines a wrapping mechanism
    where a class or an object is wrapped in order to make it work in a context that
    was not primarily intended for it. `StringIO` is a typical example, as it adapts
    the `str` type, so it can be used as a `file` type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式基于这种哲学，定义了一种包装机制，其中一个类或对象被包装以使其在最初不打算用于它的上下文中工作。`StringIO`就是一个典型的例子，因为它适应了`str`类型，所以它可以被用作`file`类型：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's take another example. A `DublinCoreInfos` class knows how to display the
    summary of some subset of Dublin Core information (see [http://dublincore.org/](http://dublincore.org/))
    for a given document provided as a `dict`. It reads a few fields, such as the
    author's name or the title, and prints them. To be able to display Dublin Core
    for a file, it has to be adapted in the same way `StringIO` does. The following
    figure shows a UML-like diagram for such a kind of adapter pattern implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举另一个例子。`DublinCoreInfos`类知道如何显示给定文档的一些Dublin Core信息子集的摘要（参见[http://dublincore.org/](http://dublincore.org/)），并提供为`dict`提供。它读取一些字段，比如作者的名字或标题，并打印它们。为了能够显示文件的Dublin
    Core，它必须以与`StringIO`相同的方式进行适配。下图显示了这种适配器模式实现的类似UML的图。
- en: '![Adapter](graphics/B05295_14_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](graphics/B05295_14_01.jpg)'
- en: Figure 2 UML diagram for simple adapter pattern example
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2 简单适配器模式示例的UML图
- en: '`DublinCoreAdapter` wraps a file instance and provides metadata access over
    it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DublinCoreAdapter`包装了一个文件实例，并提供了对其元数据的访问：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here is the example usage:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例用法：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Besides the fact that it allows substitution, the adapter pattern can also change
    the way developers work. Adapting an object to work in a specific context makes
    the assumption that the class of the object does not matter at all. What matters
    is that this class implements what `DublinCoreInfo` is waiting for and this behavior
    is fixed or completed by an adapter. So, the code can, somehow, simply tell whether
    it is compatible with objects that are implementing a specific behavior. This
    can be expressed by *interfaces*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许替换的事实之外，适配器模式还可以改变开发人员的工作方式。将对象适应特定上下文的假设是对象的类根本不重要。重要的是这个类实现了`DublinCoreInfo`等待的内容，并且这种行为由适配器固定或完成。因此，代码可以简单地告诉它是否与实现特定行为的对象兼容。这可以通过*接口*来表达。
- en: Interfaces
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口
- en: An **interface** is a definition of an API. It describes a list of methods and
    attributes a class should have to implement with the desired behavior. This description
    does not implement any code but just defines an explicit contract for any class
    that wishes to implement the interface. Any class can then implement one or several
    interfaces in whichever way it wants.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**是API的定义。它描述了一个类应该具有的方法和属性列表，以实现所需的行为。这个描述不实现任何代码，只是为希望实现接口的任何类定义了一个明确的合同。然后任何类都可以以任何方式实现一个或多个接口。'
- en: While Python prefers duck-typing over explicit interface definitions, it may
    be better to use them sometimes. For instance, explicit interface definition makes
    it easier for a framework to define functionalities over interfaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python更喜欢鸭子类型而不是明确的接口定义，但有时使用它们可能更好。例如，明确的接口定义使框架更容易定义接口上的功能。
- en: The benefit is that classes are loosely coupled, which is considered as a good
    practice. For example, to perform a given process, a class `A` does not depend
    on a class `B`, but rather on an interface `I`. Class `B` implements `I`, but
    it could be any other class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于类之间松散耦合，这被认为是一种良好的实践。例如，要执行给定的过程，类`A`不依赖于类`B`，而是依赖于接口`I`。类`B`实现了`I`，但它可以是任何其他类。
- en: 'The support for such a technique is built-in in many statically typed languages
    such as Java or Go. The interfaces allow the functions or methods to limit the
    range of acceptable parameter objects that implement a given interface, no matter
    what kind of class it comes from. This allows for more flexibility than restricting
    arguments to given types or their subclasses. It is like an explicit version of
    duck-typing behavior: Java uses interfaces to verify a type safety at compile
    time rather than use duck-typing to tie things together at run time.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态类型语言（如Java或Go）内置了对这种技术的支持。接口允许函数或方法限制实现给定接口的可接受参数对象的范围，无论它来自哪种类。这比将参数限制为给定类型或其子类更灵活。这就像鸭子类型行为的显式版本：Java使用接口在编译时验证类型安全，而不是在运行时使用鸭子类型将事物绑在一起。
- en: 'Python has a completely different typing philosophy to Java, so it does not
    have native support for interfaces. Anyway, if you would like to have more explicit
    control on application interfaces, there are generally two solutions to choose
    from:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python对接口的类型哲学与Java完全不同，因此它没有原生支持接口。无论如何，如果您想对应用程序接口有更明确的控制，通常有两种选择：
- en: Use some third-party framework that adds a notion of interfaces
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些第三方框架添加接口的概念
- en: Use some of the advanced language features to build your methodology for handling
    interfaces.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些高级语言特性来构建处理接口的方法论。
- en: Using zope.interface
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用zope.interface
- en: There are a few frameworks that allow you to build explicit interfaces in Python.
    The most notable one is a part of the Zope project. It is the `zope.interface`
    package. Although, nowadays, Zope is not as popular as it used to be, the `zope.interface`
    package is still one of the main components of the Twisted framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些框架允许您在Python中构建明确的接口。最值得注意的是Zope项目的一部分。它是`zope.interface`包。尽管如今Zope不像以前那样受欢迎，但`zope.interface`包仍然是Twisted框架的主要组件之一。
- en: 'The core class of the `zope.interface` package is the `Interface` class. It
    allows you to explicitly define a new interface by subclassing. Let''s assume
    that we want to define the obligatory interface for every implementation of a
    rectangle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`zope.interface`包的核心类是`Interface`类。它允许您通过子类化来明确定义一个新的接口。假设我们想为矩形的每个实现定义一个强制性接口：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some important things to remember when defining interfaces with `zope.interface`
    are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`zope.interface`定义接口时需要记住的一些重要事项如下：
- en: The common naming convention for interfaces is to use `I` as the name suffix.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的常见命名约定是使用`I`作为名称后缀。
- en: The methods of the interface must not take the `self` parameter.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的方法不得带有`self`参数。
- en: As the interface does not provide concrete implementation, it should consist
    only of empty methods. You can use the `pass` statement, raise `NotImplementedError`,
    or provide a docstring (preferred).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于接口不提供具体实现，因此它应该只包含空方法。您可以使用`pass`语句，引发`NotImplementedError`，或提供文档字符串（首选）。
- en: An interface can also specify the required attributes using the `Attribute`
    class.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口还可以使用`Attribute`类指定所需的属性。
- en: 'When you have such a contract defined, you can then define new concrete classes
    that provide implementation for our `IRectangle` interface. In order to do that,
    you need to use the `implementer()` class decorator and implement all of the defined
    methods and attributes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义了这样的合同后，您可以定义提供`IRectangle`接口实现的新具体类。为此，您需要使用`implementer()`类装饰器并实现所有定义的方法和属性：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is common to say that the interface defines a contract that a concrete implementation
    needs to fulfill. The main benefit of this design pattern is being able to verify
    consistency between contract and implementation before the object is being used.
    With the ordinary duck-typing approach, you only find inconsistencies when there
    is a missing attribute or method at runtime. With `zope.interface`, you can introspect
    the actual implementation using two methods from the `zope.interface.verify` module
    to find inconsistencies early on:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常说接口定义了具体实现需要满足的合同。这种设计模式的主要好处是能够在对象被使用之前验证合同和实现之间的一致性。使用普通的鸭子类型方法，只有在运行时缺少属性或方法时才会发现不一致性。使用`zope.interface`，您可以使用`zope.interface.verify`模块的两种方法来提前检查实际实现中的不一致性：
- en: '`verifyClass(interface, class_object)`: This verifies the class object for
    existence of methods and correctness of their signatures without looking for attributes'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verifyClass(interface, class_object)`: 这会验证类对象是否存在方法，并检查其签名的正确性，而不会查找属性'
- en: '`verifyObject(interface, instance)`: This verifies the methods, their signatures,
    and also attributes of the actual object instance'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verifyObject(interface, instance)`: 这验证实际对象实例的方法、它们的签名和属性'
- en: 'Since we have defined our interface and two concrete implementations, let''s
    verify their contracts in an interactive session:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了我们的接口和两个具体的实现，让我们在交互式会话中验证它们的契约：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nothing impressive. The `Rectangle` and `Square` classes carefully follow the
    defined contract so there is nothing more to see than a successful verification.
    But what happens when we make a mistake? Let''s see an example of two classes
    that fail to provide full `IRectangle` interface implementation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人印象深刻的。`Rectangle`和`Square`类仔细遵循了定义的契约，因此除了成功的验证外，没有更多的东西可见。但是当我们犯错时会发生什么？让我们看一个未能提供完整`IRectangle`接口实现的两个类的示例：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Point` class does not provide any method or attribute of the `IRectangle`
    interface, so its verification will show inconsistencies already on the class
    level:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`类没有提供`IRectangle`接口的任何方法或属性，因此它的验证将在类级别上显示不一致性：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Circle` class is a bit more problematic. It has all the interface methods
    defined but breaks the contract on the instance attribute level. This is the reason
    why, in most cases, you need to use the `verifyObject()` function to completely
    verify the interface implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类有点棘手。它定义了所有接口方法，但在实例属性级别上违反了契约。这就是为什么在大多数情况下，您需要使用`verifyObject()`函数来完全验证接口实现的原因：'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using `zope.inteface` is an interesting way to decouple your application. It
    allows you to enforce proper object interfaces without the need for the overblown
    complexity of multiple inheritance, and it also allows to catch inconsistencies
    early. However, the biggest downside of this approach is the requirement that
    you explicitly define that the given class follows some interface in order to
    be verified. This is especially troublesome if you need to verify instances coming
    from external classes of built-in libraries. `zope.interface` provides some solutions
    for that problem, and you can of course handle such issues on your own by using
    the adapter pattern, or even monkey-patching. Anyway, the simplicity of such solutions
    is at least arguable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`zope.inteface`是一种有趣的解耦应用程序的方式。它允许您强制执行正确的对象接口，而无需多重继承的过度复杂性，并且还可以及早捕获不一致性。然而，这种方法最大的缺点是要求您明确定义给定类遵循某个接口才能进行验证。如果您需要验证来自内置库的外部类的实例，这将特别麻烦。`zope.interface`为该问题提供了一些解决方案，当然您也可以使用适配器模式或甚至猴子补丁来处理这些问题。无论如何，这些解决方案的简单性至少是值得商榷的。
- en: Using function annotations and abstract base classes
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用函数注释和抽象基类
- en: Design patterns are meant to make problem solving easier and not to provide
    you with more layers of complexity. The `zope.interface` is a great concept and
    may greatly fit some projects, but it is not a silver bullet. By using it, you
    may soon find yourself spending more time on fixing issues with incompatible interfaces
    for third-party classes and providing never-ending layers of adapters instead
    of writing the actual implementation. If you feel that way, then this is a sign
    that something went wrong. Fortunately, Python supports for building lightweight
    alternative to the interfaces. It's not a full-fledged solution like `zope.interface`
    or its alternatives but it generally provides more flexible applications. You
    may need to write a bit more code, but in the end you will have something that
    is more extensible, better handles external types, and may be more *future proof*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的目的是使问题解决变得更容易，而不是为您提供更多的复杂层次。`zope.interface`是一个很好的概念，可能非常适合某些项目，但它并不是万能解决方案。使用它，您可能很快就会发现自己花费更多时间修复与第三方类的不兼容接口的问题，并提供无休止的适配器层，而不是编写实际的实现。如果您有这种感觉，那么这是某种问题出现的迹象。幸运的是，Python支持构建轻量级的接口替代方案。它不像`zope.interface`或其替代方案那样是一个成熟的解决方案，但通常提供更灵活的应用程序。您可能需要编写更多的代码，但最终您将拥有更具可扩展性，更好地处理外部类型，并且可能更具*未来性*的东西。
- en: 'Note that Python in its core does not have explicit notions of interfaces,
    and probably will never have, but has some of the features that allow you to build
    something that resembles the functionality of interfaces. The features are:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python在其核心中没有接口的明确概念，可能永远不会有，但具有一些功能，允许您构建类似接口功能的东西。这些功能包括：
- en: '**Abstract base classes** (**ABCs**)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象基类**（**ABCs**）'
- en: Function annotations
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数注释
- en: Type annotations
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型注释
- en: The core of our solution is abstract base classes, so we will feature them first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的核心是抽象基类，所以我们将首先介绍它们。
- en: 'As you probably know, the direct type comparison is considered harmful and
    not *pythonic*. You should always avoid comparisons as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能知道的那样，直接的类型比较被认为是有害的，而且不是*pythonic*。您应该始终避免以下比较：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Comparing types in functions or methods that way completely breaks the ability
    to pass a class subtype as an argument to the function. The slightly better approach
    is to use the `isinstance()` function that will take the inheritance into account:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数或方法中比较类型的方式完全破坏了将类子类型作为参数传递给函数的能力。稍微更好的方法是使用`isinstance()`函数，它会考虑继承关系：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The additional advantage of `isinstance()` is that you can use a larger range
    of types to check the type compatibility. For instance, if your function expects
    to receive some sort of sequence as the argument, you can compare against the
    list of basic types:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()`的额外优势是您可以使用更广泛的类型来检查类型兼容性。例如，如果您的函数期望接收某种序列作为参数，您可以与基本类型的列表进行比较：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Such a way of type compatibility checking is OK in some situations but it is
    still not perfect. It will work with any subclass of `list`, `tuple`, or `range`,
    but will fail if the user passes something that behaves exactly the same as one
    of these sequence types but does not inherit from any of them. For instance, let's
    relax our requirements and say that you want to accept any kind of iterable as
    an argument. What would you do? The list of basic types that are iterable is actually
    pretty long. You need to cover list, tuple, range, str, bytes, dict, set, generators,
    and a lot more. The list of applicable built-in types is long, and even if you
    cover all of them it will still not allow you to check against the custom class
    that defines the `__iter__()` method, but will instead inherit directly from `object`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型兼容性检查的方式在某些情况下是可以的，但仍然不完美。它将适用于`list`、`tuple`或`range`的任何子类，但如果用户传递的是与这些序列类型完全相同但不继承自任何一个的东西，它将失败。例如，让我们放宽要求，说你想接受任何类型的可迭代对象作为参数。你会怎么做？可迭代的基本类型列表实际上相当长。你需要涵盖list、tuple、range、str、bytes、dict、set、生成器等等。适用的内置类型列表很长，即使你覆盖了所有这些类型，它仍然不允许你检查是否与定义了`__iter__()`方法的自定义类兼容，而是直接继承自`object`。
- en: And this is the kind of situation where abstract base classes (ABC) are the
    proper solution. ABC is a class that does not need to provide a concrete implementation
    but instead defines a blueprint of a class that may be used to check against type
    compatibility. This concept is very similar to the concept of abstract classes
    and virtual methods known in the C++ language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是抽象基类（ABC）是适当解决方案的情况。ABC是一个类，不需要提供具体的实现，而是定义了一个类的蓝图，可以用来检查类型的兼容性。这个概念与C++语言中的抽象类和虚方法的概念非常相似。
- en: 'Abstract base classes are used for two purposes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类用于两个目的：
- en: Checking for implementation completeness
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查实现的完整性
- en: Checking for implicit interface compatibility
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查隐式接口兼容性
- en: 'So, let''s assume we want to define an interface which ensures that a class
    has a `push()` method. We need to create a new abstract base class using a special
    `ABCMeta` metaclass and an `abstractmethod()` decorator from the standard `abc`
    module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设我们想定义一个接口，确保一个类具有`push()`方法。我们需要使用特殊的`ABCMeta`元类和标准`abc`模块中的`abstractmethod()`装饰器创建一个新的抽象基类：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `abc` module also provides an ABC base class that can be used instead of
    the metaclass syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc`模块还提供了一个可以用来代替元类语法的ABC基类：'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once it is done, we can use that `Pushable` class as a base class for concrete
    implementation and it will guard us from the instantiation of objects that would
    have incomplete implementation. Let''s define `DummyPushable`, which implements
    all interface methods and the `IncompletePushable` that breaks the expected contract:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以将`Pushable`类用作具体实现的基类，并且它将阻止我们实例化具有不完整实现的对象。让我们定义`DummyPushable`，它实现了所有接口方法和`IncompletePushable`，它违反了预期的合同：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to obtain the `DummyPushable` instance, there is no problem because
    it implements the only required `push()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获得`DummyPushable`实例，那就没有问题，因为它实现了唯一需要的`push()`方法：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But if you try to instantiate `IncompletePushable`, you will get `TypeError`
    because of missing implementation of the `interface()` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你尝试实例化`IncompletePushable`，你会得到`TypeError`，因为缺少`interface()`方法的实现：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding approach is a great way to ensure implementation completeness
    of base classes but is as explicit as the `zope.interface` alternative. The `DummyPushable`
    instances are of course also instances of `Pushable` because Dummy is a subclass
    of `Pushable`. But how about other classes with the same methods but not descendants
    of `Pushable`? Let''s create one and see:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法是确保基类实现完整性的好方法，但与`zope.interface`替代方案一样明确。`DummyPushable`实例当然也是`Pushable`的实例，因为Dummy是`Pushable`的子类。但是其他具有相同方法但不是`Pushable`的后代的类呢？让我们创建一个并看看：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Something is still missing. The `SomethingWithPush` class definitely has a compatible
    interface but is not considered as an instance of `Pushable` yet. So, what is
    missing? The answer is the `__subclasshook__(subclass)` method that allows you
    to inject your own logic into the procedure that determines whether the object
    is an instance of a given class. Unfortunately, you need to provide it by yourself,
    as `abc` creators did not want to constrain the developers in overriding the whole
    `isinstance()` mechanism. We got full power over it, but we are forced to write
    some boilerplate code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些东西缺失。`SomethingWithPush`类明确具有兼容的接口，但尚未被视为`Pushable`的实例。那么，缺少什么？答案是`__subclasshook__(subclass)`方法，它允许你将自己的逻辑注入到确定对象是否是给定类的实例的过程中。不幸的是，你需要自己提供它，因为`abc`的创建者不希望限制开发人员覆盖整个`isinstance()`机制。我们对它有完全的控制权，但我们被迫写一些样板代码。
- en: 'Although you can do whatever you want to, usually the only reasonable thing
    to do in the `__subclasshook__()` method is to follow the common pattern. The
    standard procedure is to check whether the set of defined methods are available
    somewhere in the MRO of the given class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以做任何你想做的事情，但通常在`__subclasshook__()`方法中唯一合理的事情是遵循常见的模式。标准程序是检查定义的方法集是否在给定类的MRO中的某个地方可用：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the `__subclasshook__()` method defined that way, you can now confirm
    that the instances that implement the interface implicitly are also considered
    instances of the interface:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式定义`__subclasshook__()`方法，现在可以确认隐式实现接口的实例也被视为接口的实例：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unfortunately, this approach to the verification of type compatibility and implementation
    completeness does not take into account the signatures of class methods. So, if
    the number of expected arguments is different in implementation, it will still
    be considered compatible. In most cases, this is not an issue, but if you need
    such fine-grained control over interfaces, the `zope.interface` package allows
    for that. As already said, the `__subclasshook__()` method does not constrain
    you in adding more complexity to the `isinstance()` function's logic to achieve
    a similar level of control.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种验证类型兼容性和实现完整性的方法并未考虑类方法的签名。因此，如果实现中预期的参数数量不同，它仍将被视为兼容。在大多数情况下，这不是问题，但如果您需要对接口进行如此精细的控制，`zope.interface`包允许这样做。正如前面所说，`__subclasshook__()`方法不会限制您在`isinstance()`函数的逻辑中添加更多复杂性，以实现类似的控制水平。
- en: 'The two other features that complement abstract base classes are function annotations
    and type hints. Function annotation is the syntax element described briefly in
    [Chapter 2](ch02.html "Chapter 2. Syntax Best Practices – below the Class Level"),
    *Syntax Best Practices – below the Class Level*. It allows you to annotate functions
    and their arguments with arbitrary expressions. As explained in [Chapter 2](ch02.html
    "Chapter 2. Syntax Best Practices – below the Class Level"), *Syntax Best Practices
    – below the Class Level*, this is only a feature stub that does not provide any
    syntactic meaning. There is no utility in the standard library that uses this
    feature to enforce any behavior. Anyway, you can use it as a convenient and lightweight
    way to inform the developer of the expected argument interface. For instance,
    consider this `IRectangle` interface rewritten from `zope.interface` to abstract
    the base class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 补充抽象基类的另外两个特性是函数注释和类型提示。函数注释是在[第2章](ch02.html "第2章。类级别以下的语法最佳实践")中简要描述的语法元素，*语法最佳实践-类级别以下*。它允许您使用任意表达式对函数及其参数进行注释。正如[第2章](ch02.html
    "第2章。类级别以下的语法最佳实践")中所解释的，*语法最佳实践-类级别以下*，这只是一个不提供任何语法意义的功能存根。标准库中没有使用此功能来强制执行任何行为。无论如何，您可以将其用作通知开发人员预期参数接口的便捷且轻量级的方式。例如，考虑从`zope.interface`重写的`IRectangle`接口以抽象基类的形式：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you have a function that works only on rectangles, let''s say `draw_rectangle()`,
    you could annotate the interface of the expected argument as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个仅适用于矩形的函数，比如`draw_rectangle()`，您可以将预期参数的接口注释如下：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This adds nothing more than information for the developer about expected information.
    And even this is done through an informal contract because, as we know, bare annotations
    contain no syntactic meaning. However, they are accessible at runtime, so we can
    do something more. Here is an example implementation of a generic decorator that
    is able to verify interface from function annotation if it is provided using abstract
    base classes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为开发人员提供有关预期信息的信息。即使这是通过非正式合同完成的，因为正如我们所知，裸注释不包含任何语法意义。但是，它们在运行时是可访问的，因此我们可以做更多的事情。以下是一个通用装饰器的示例实现，它能够验证函数注释中提供的接口是否使用抽象基类：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once it is done, we can create some concrete class that implicitly implements
    the `IRectangle` interface (without inheriting from `IRectangle`) and update the
    implementation of the `draw_rectangle()` function to see how the whole solution
    works:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以创建一些具体的类，它们隐式地实现了`IRectangle`接口（而不是继承自`IRectangle`），并更新`draw_rectangle()`函数的实现，以查看整个解决方案的工作原理：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we feed the `draw_rectangle()` function with an incompatible object, it
    will now raise `TypeError` with a meaningful explanation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用不兼容的对象来调用`draw_rectangle()`函数，它现在将引发`TypeError`并提供有意义的解释：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But if we use `ImplicitRectangle` or anything else that resembles the `IRectangle`
    interface, the function executes as it should:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用`ImplicitRectangle`或任何其他类似`IRectangle`接口的对象，该函数将按预期执行：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our example implementation of `ensure_interface()` is based on the `typechecked()`
    decorator from the `typeannotations` project that tries to provide run-time checking
    capabilities (refer to [https://github.com/ceronman/typeannotations](https://github.com/ceronman/typeannotations)).
    Its source code might give you some interesting ideas about how to process type
    annotations to ensure run-time interface checking.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ensure_interface()`的示例实现是基于`typeannotations`项目中的`typechecked()`装饰器，该项目试图提供运行时检查功能（请参阅[https://github.com/ceronman/typeannotations](https://github.com/ceronman/typeannotations)）。它的源代码可能会给您一些有趣的想法，关于如何处理类型注释以确保运行时接口检查。
- en: The last feature that can be used to complement this interface pattern landscape
    are type hints. Type hints are described in detail by PEP 484 and were added to
    the language quite recently. They are exposed in the new `typing` module and are
    available from Python 3.5\. Type hints are built on top of function annotations
    and reuse this slightly forgotten syntax feature of Python 3\. They are intended
    to guide type hinting and check for various *yet-to-come* Python type checkers.
    The `typing` module and PEP 484 document aim to provide a standard hierarchy of
    types and classes that should be used for describing type annotations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来补充这种接口模式的最后一个特性是类型提示。类型提示在PEP 484中有详细描述，并且是最近添加到语言中的。它们在新的`typing`模块中公开，并且从Python
    3.5开始可用。类型提示建立在函数注释的基础上，并重用了Python 3中略微被遗忘的语法特性。它们旨在指导类型提示并检查各种*尚未出现*的Python类型检查器。`typing`模块和PEP
    484文档旨在提供一种用于描述类型注释的标准类型和类的层次结构。
- en: Still, type hints do not seem to be something revolutionary because this feature
    does not come with any type checker built-in into the standard library. If you
    want to use type checking or enforce strict interface compatibility in your code,
    you need to create your own tool because there is none worth recommendation yet.
    This is why we won't dig into details of PEP 484\. Anyway, type hints and the
    documents describing them are worth mentioning because if some extraordinary solution
    emerges in the field of type checking in Python, it is highly probable that it
    will be based on PEP 484.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型提示似乎并不是什么革命性的东西，因为这个特性并没有内置任何类型检查器到标准库中。如果你想在你的代码中使用类型检查或者强制严格的接口兼容性，你需要创建自己的工具，因为目前还没有值得推荐的工具。这就是为什么我们不会深入研究PEP
    484的细节。无论如何，类型提示和描述它们的文档是值得一提的，因为如果在Python的类型检查领域出现了一些非凡的解决方案，它很可能是基于PEP 484的。
- en: Using collections.abc
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用collections.abc
- en: Abstract base classes are like small building blocks for creating a higher level
    of abstraction. They allow you to implement really usable interfaces but are very
    generic and designed to handle lot more than this single design pattern. You can
    unleash your creativity and do magical things but building something generic and
    really usable may require a lot of work. Work that may never pay off.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类就像创建更高级抽象的小积木。它们允许你实现真正可用的接口，但非常通用，设计用于处理远远超出这个单一设计模式的东西。你可以释放你的创造力，做出神奇的事情，但构建一些通用的、真正可用的东西可能需要大量的工作。这可能永远得不到回报。
- en: This is why custom abstract base classes are not used so often. Despite that,
    the `collections.abc` module provides a lot of predefined ABCs that allow to verify
    interface compatibility of many basic Python types. With base classes provided
    in this module, you can check, for example, whether a given object is callable,
    mapping, or if it supports iteration. Using them with the `isinstance()` function
    is way better than comparing them against the base python types. You should definitely
    know how to use these base classes even if you don't want to define your own custom
    interfaces with `ABCMeta`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么自定义抽象基类并不经常使用。尽管如此，`collections.abc`模块提供了许多预定义的ABCs，允许验证许多基本Python类型的接口兼容性。使用这个模块提供的基类，你可以检查一个给定的对象是否可调用、映射，或者是否支持迭代。使用它们与`isinstance()`函数比较要比与基本的Python类型比较要好得多。即使你不想使用`ABCMeta`定义自己的自定义接口，你也应该知道如何使用这些基类。
- en: 'The most common abstract base classes from `collections.abc` that you will
    use from time to time are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你会时不时地使用`collections.abc`中最常见的抽象基类：
- en: '`Container`: This interface means that the object supports the `in` operator
    and implements the `__contains__()` method'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container`：这个接口意味着对象支持`in`操作符，并实现了`__contains__()`方法'
- en: '`Iterable`: This interface means that the object supports the iteration and
    implements the `__iter__()` method'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable`：这个接口意味着对象支持迭代，并实现了`__iter__()`方法'
- en: '`Callable`: This interface means that it can be called like a function and
    implements the `__call__()` method'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`：这个接口意味着它可以像函数一样被调用，并实现了`__call__()`方法'
- en: '`Hashable`: This interface means that the object is hashable (can be included
    in sets and as key in dictionaries) and implements the `__hash__` method'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hashable`：这个接口意味着对象是可散列的（可以包含在集合中并作为字典中的键），并实现了`__hash__`方法'
- en: '`Sized`: This interface means that the object has size (can be a subject of
    the `len()` function) and implements the `__len__()` method'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sized`：这个接口意味着对象有大小（可以使用`len()`函数）并实现了`__len__()`方法'
- en: A full list of the available abstract base classes from the `collections.abc`
    module is available in the official Python documentation (refer to [https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc`模块中可用的抽象基类的完整列表可以在官方Python文档中找到（参见[https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)）。'
- en: Proxy
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: '**Proxy** provides indirect access to an expensive or a distant resource. A
    **Proxy** is between a **Client** and a **Subject**, as shown in the following
    figure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**提供了对昂贵或远程资源的间接访问。**代理**位于**客户端**和**主体**之间，如下图所示：'
- en: '![Proxy](graphics/B05295_14_02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![代理](graphics/B05295_14_02.jpg)'
- en: It is intended to optimize Subject accesses if they are expensive. For instance,
    the `memoize()` and `lru_cache()` decorators described in [Chapter 12](ch12.html
    "Chapter 12. Optimization – Some Powerful Techniques"), *Optimization – Some Powerful
    Techniques*, can be considered as proxies.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Subject的访问是昂贵的，这是为了优化Subject的访问。例如，在[第12章](ch12.html "第12章。优化-一些强大的技术")中描述的`memoize()`和`lru_cache()`装饰器，*优化-一些强大的技术*，可以被视为代理。
- en: A proxy can also be used to provide smart access to a subject. For instance,
    big video files can be wrapped into proxies to avoid loading them into memory
    when the user just asks for their titles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也可以用来提供对主体的智能访问。例如，大型视频文件可以被包装成代理，以避免在用户只要求它们的标题时将它们加载到内存中。
- en: 'An example is given by the `urllib.request` module. `urlopen` is a proxy for
    the content located at a remote URL. When it is created, headers can be retrieved
    independently from the content itself without the need to read the rest of the
    response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.request`模块提供了一个例子。`urlopen`是一个代理，用于访问远程URL上的内容。当它被创建时，可以独立于内容本身检索头部，而无需读取响应的其余部分：'
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This can be used to decide whether the page has been changed before getting
    its body to update a local copy, by looking at the `last-modified` header. Let''s
    take an example with a big file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来决定在获取页面主体之前是否已经更改了页面，通过查看`last-modified`头部。让我们用一个大文件举个例子：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Another use case of proxies is **data uniqueness**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的另一个用例是**数据唯一性**。
- en: For example, let's consider a website that presents the same document in several
    locations. Extra fields specific to each location are appended to the document,
    such as a hit counter and a few permission settings. A proxy can be used in that
    case to deal with location-specific matters and also to point to the original
    document instead of copying it. So, a given document can have many proxies, and
    if its content changes, all locations will benefit from it without having to deal
    with version synchronization.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个网站，在几个位置上呈现相同的文档。特定于每个位置的额外字段被附加到文档中，例如点击计数器和一些权限设置。在这种情况下，可以使用代理来处理特定于位置的问题，并指向原始文档，而不是复制它。因此，给定的文档可以有许多代理，如果其内容发生变化，所有位置都将受益，而无需处理版本同步。
- en: 'Generally speaking, proxy pattern is useful for implementing a local handle
    of something that may live somewhere else to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，代理模式对于实现可能存在于其他地方的某些东西的本地处理很有用：
- en: Make the process faster
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快流程
- en: Avoid external resource access
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免外部资源访问
- en: Reduce memory load
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少内存负载
- en: Ensure data uniqueness
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据的唯一性
- en: Facade
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facade
- en: '**Facade** provides high-level, simpler access to a subsystem.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Facade**提供了对子系统的高级、简单的访问。'
- en: A facade is nothing but a shortcut to use a functionality of the application,
    without having to deal with the underlying complexity of a subsystem. This can
    be done, for instance, by providing high-level functions at the package level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Facade只是一个快捷方式，用于使用应用程序的功能，而不必处理子系统的底层复杂性。例如，可以通过在包级别提供高级功能来实现这一点。
- en: Facade is usually done on existing systems, where a package's frequent usage
    is synthesized in high-level functions. Usually, no classes are needed to provide
    such a pattern and simple functions in the `__init__.py` module are sufficient.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Facade通常是在现有系统上完成的，其中包的频繁使用被合成为高级功能。通常，不需要类来提供这样的模式，`__init__.py`模块中的简单函数就足够了。
- en: A good example of project that provides a big facade over complicated and complex
    interfaces is the `requests` package (refer to [http://docs.python-requests.org/](http://docs.python-requests.org/)).
    It really simplifies the madness of dealing with HTTP requests and responses in
    Python by providing a clean API that is easily readable to developers. It is actually
    even advertised as *HTTP for humans*. Such ease of use always comes at some price
    but eventual tradeoffs and additional overhead does not scare most people from
    using the Requests project as their HTTP tool of choice. In the end, it allows
    us to finish projects faster and a developer's time is usually more expensive
    than hardware.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个提供了一个大的外观覆盖复杂和复杂接口的项目的很好的例子是`requests`包（参考[http://docs.python-requests.org/](http://docs.python-requests.org/)）。它通过提供一个清晰的API，使得在Python中处理HTTP请求和响应的疯狂变得简单，这对开发人员来说非常容易阅读。它实际上甚至被宣传为“人类的HTTP”。这种易用性总是以一定的代价为代价，但最终的权衡和额外的开销并不会吓倒大多数人使用Requests项目作为他们选择的HTTP工具。最终，它使我们能够更快地完成项目，而开发人员的时间通常比硬件更昂贵。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Facade simplifies the usage of your packages. Facades are usually added after
    a few iterations with usage feedback.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Facade简化了您的包的使用。在几次迭代后，通常会添加Facade以获得使用反馈。
- en: Behavioral patterns
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns are intended to simplify the interactions between classes
    by structuring the processes of their interaction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式旨在通过结构化它们的交互过程来简化类之间的交互。
- en: 'This section provides three examples of popular behavioral patterns that you
    may want to consider when writing Python code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了三个流行的行为模式的示例，您在编写Python代码时可能需要考虑：
- en: Observer
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Visitor
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Template
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Observer
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者
- en: The **observer** pattern is used to notify a list of objects about a state change
    of the observed component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者**模式用于通知一系列对象观察组件的状态变化。'
- en: Observer allows adding features in an application in a pluggable way by de-coupling
    the new functionality from the existing code base. An event framework is a typical
    implementation of the observer pattern and is described in the figure that follows.
    Every time an event occurs, all observers for this event are notified with the
    subject that has triggered this event.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者允许以可插拔的方式向应用程序添加功能，通过将新功能与现有代码库解耦。事件框架是观察者模式的典型实现，并在接下来的图中描述。每当发生事件时，所有观察者都会收到触发此事件的主题的通知。
- en: An event is created when something happens. In graphical user interface applications,
    event-driven programming (see [http://en.wikipedia.org/wiki/Event-driven_programming](http://en.wikipedia.org/wiki/Event-driven_programming))
    is often used to link the code to user actions. For instance, a function can be
    linked to the `MouseMove` event so it is called every time the mouse moves over
    the window.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是发生某事时创建的。在图形用户界面应用程序中，事件驱动编程（参见[http://en.wikipedia.org/wiki/Event-driven_programming](http://en.wikipedia.org/wiki/Event-driven_programming)）通常用于将代码与用户操作链接起来。例如，可以将函数链接到`MouseMove`事件，以便在鼠标在窗口上移动时调用它。
- en: In case of GUI application, de-coupling the code from the window management
    internals simplifies the work a lot. Functions are written separately and then
    registered as event observers. This approach exists from the earliest versions
    of Microsoft's MFC framework (see [http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library](http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library))
    and in all GUI development tools such as Qt or GTK. Many frameworks use the notion
    of *signals*, but they are simply another manifestation of the observer pattern.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI应用程序的情况下，将代码与窗口管理内部解耦会大大简化工作。函数是分开编写的，然后注册为事件观察者。这种方法存在于微软的MFC框架的最早版本中（参见[http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library](http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library)），以及Qt或GTK等所有GUI开发工具中。许多框架使用*信号*的概念，但它们只是观察者模式的另一种表现。
- en: The code can also generate events. For instance, in an application that stores
    documents in a database, `DocumentCreated`, `DocumentModified`, and `DocumentDeleted`
    can be three events provided by the code. A new feature that works on documents
    can register itself as an observer to get notified every time a document is created,
    modified, or deleted and do the appropriate work. A document indexer could be
    added that way in an application. Of course, this requires that all the code in
    charge of creating, modifying, or deleting documents is triggering events. But
    this is rather easier than adding indexing hooks all over the application code
    base! A popular web framework that follows this pattern is Django with its mechanism
    of signals.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码也可以生成事件。例如，在一个将文档存储在数据库中的应用程序中，`DocumentCreated`、`DocumentModified`和`DocumentDeleted`可以是代码提供的三个事件。一个在文档上工作的新功能可以注册自己作为观察者，每当文档被创建、修改或删除时得到通知，并进行适当的工作。这样就可以在应用程序中添加一个文档索引器。当然，这要求负责创建、修改或删除文档的所有代码都触发事件。但这比在整个应用程序代码库中添加索引挂钩要容易得多！一个遵循这种模式的流行Web框架是Django，它具有信号机制。
- en: 'An `Event` class can be implemented for the registration of observers in Python
    by working at the class level:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在类级别上工作来实现Python中观察者的注册的`Event`类：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The idea is that observers register themselves using the `Event` class method
    and get notified with `Event` instances that carry the subject that triggered
    them. Here is an example of the concrete `Event` subclass with some observers
    subscribed to its notifications:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者使用`Event`类方法注册自己，并通过携带触发它们的主题的`Event`实例得到通知。以下是一个具体的`Event`子类的示例，其中一些观察者订阅了它的通知：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is an example result of firing the event with the `WriteEvent.notify()`
    method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`WriteEvent.notify()`方法触发事件的示例结果：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This implementation is simple and serves only as illustrational purposes. To
    make it fully functional, it could be enhanced by:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现很简单，只是作为说明目的。要使其完全功能，可以通过以下方式加以增强：
- en: Allowing the developer to change the order or events
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发人员更改事件的顺序
- en: Making the event object hold more information than just the subject
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使事件对象携带的信息不仅仅是主题
- en: De-coupling your code is fun and the observer is the right pattern to do it.
    It componentizes your application and makes it more extensible. If you want to
    use an existing tool, try **Blinker** (refer to [https://pythonhosted.org/blinker/](https://pythonhosted.org/blinker/)).
    It provides fast and simple object-to-object and broadcast signaling for Python
    objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦你的代码是有趣的，观察者是正确的模式。它将你的应用程序组件化，并使其更具可扩展性。如果你想使用现有的工具，可以尝试**Blinker**（参见[https://pythonhosted.org/blinker/](https://pythonhosted.org/blinker/)）。它为Python对象提供快速简单的对象到对象和广播信号。
- en: Visitor
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者
- en: '**Visitor** helps in separating algorithms from data structures and has a similar
    goal to that of the observer pattern. It allows extending the functionalities
    of a given class without changing its code. But the visitor goes a bit further
    by defining a class that is responsible for holding data and pushes the algorithms
    to other classes called `Visitors`. Each visitor is specialized in one algorithm
    and can apply it on the data.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问者**有助于将算法与数据结构分离，其目标与观察者模式类似。它允许扩展给定类的功能，而不改变其代码。但是访问者通过定义一个负责保存数据并将算法推送到其他类（称为`Visitors`）的类，更进一步。每个访问者专门负责一个算法，并可以在数据上应用它。'
- en: This behavior is quite similar to the MVC paradigm (refer to [http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)),
    where documents are passive containers pushed to views through controllers, or
    where models contain data that is altered by a controller.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与MVC范式非常相似（参见[http://en.wikipedia.org/wiki/Model-view-controller](http://en.wikipedia.org/wiki/Model-view-controller)），其中文档是被动容器，通过控制器推送到视图，或者模型包含被控制器改变的数据。
- en: 'Visitor pattern is implemented by providing an entry point in the data class
    that can be visited by all kinds of visitors. A generic description is a `Visitable`
    class that accepts `Visitor` instances and calls them, as shown in the following
    figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是通过在数据类中提供一个入口点来实现的，所有类型的访问者都可以访问。一个通用的描述是一个接受`Visitor`实例并调用它们的`Visitable`类，如下图所示：
- en: '![Visitor](graphics/B05295_14_03.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![访问者](graphics/B05295_14_03.jpg)'
- en: 'The `Visitable` class decides how it calls the `Visitor` class, for instance,
    by deciding which method is called. For example, a visitor in charge of printing
    built-in type content can implement the `visit_TYPENAME()` methods, and each of
    these types can call the given method in its `accept()` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visitable`类决定如何调用`Visitor`类，例如，决定调用哪个方法。例如，负责打印内置类型内容的访问者可以实现`visit_TYPENAME()`方法，每个这些类型可以在其`accept()`方法中调用给定的方法：'
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is done as shown in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在下面的例子中所做的：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But this pattern means that each visited class needs to have an `accept` method
    to be visited, which is quite painful.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种模式意味着每个被访问的类都需要有一个`accept`方法来被访问，这是相当痛苦的。
- en: 'Since Python allows code introspection, a better idea is to automatically link
    visitors and visited classes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python允许代码内省，一个更好的主意是自动链接访问者和被访问的类：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This pattern is used in this way in the `ast` module, for instance, by the `NodeVisitor`
    class that calls the visitor with each node of the compiled code tree. This is
    because Python doesn't have a match operator like Haskell.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在`ast`模块中以这种方式使用，例如，通过`NodeVisitor`类调用编译代码树的每个节点的访问者。这是因为Python没有像Haskell那样的匹配操作符。
- en: 'Another example is a directory walker that calls Visitor methods depending
    on the file extension:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个目录遍历器，根据文件扩展名调用访问者方法：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If your application has data structures that are visited by more than one algorithm,
    the Visitor pattern will help in separating concerns. It is better for a data
    container to focus only on providing access to data and holding them, and nothing
    else.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序具有多个算法访问的数据结构，则访问者模式将有助于分离关注点。数据容器最好只专注于提供对数据的访问和保存，而不做其他事情。
- en: Template
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: '**Template** helps in designing a generic algorithm by defining abstract steps
    which are implemented in subclasses. This pattern uses the **Liskov substitution
    principle**, which is defined by Wikipedia as:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**通过定义在子类中实现的抽象步骤来设计通用算法。这种模式使用**Liskov替换原则**，由维基百科定义为：'
- en: '*"If S is a subtype of T, then objects of type T in a program may be replaced
    with objects of type S without altering any of the desirable properties of that
    program."*'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果S是T的子类型，则程序中类型T的对象可以替换为类型S的对象，而不会改变该程序的任何理想属性。”
- en: In other words, an abstract class can define how an algorithm works through
    steps that are implemented in concrete classes. The abstract class can also give
    a basic or partial implementation of the algorithm and let developers override
    its parts. For instance, some methods of the `Queue` class in the `queue` module
    can be overridden to make its behavior vary.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，抽象类可以通过在具体类中实现的步骤来定义算法的工作方式。抽象类还可以为算法提供基本或部分实现，并让开发人员覆盖其部分。例如，“queue”模块中的“Queue”类的一些方法可以被覆盖以使其行为变化。
- en: Let's implement an example, as shown in the figure that follows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个示例，如下图所示。
- en: '![Template](graphics/B05295_14_04.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![模板](graphics/B05295_14_04.jpg)'
- en: '`Indexer` is an indexer class that processes a text in five steps, which are
    common steps no matter what indexing technique is used:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: “Indexer”是一个索引器类，它在五个步骤中处理文本，无论使用何种索引技术，这些步骤都是常见的：
- en: Text normalization
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本规范化
- en: Text split
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本拆分
- en: Stop words removal
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停用词去除
- en: Stem words
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词干词
- en: Frequency
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频率
- en: An `Indexer` provides partial implementation for the process algorithm but requires
    `_remove_stop_words` and `_stem_words` to be implemented in a subclass. `BasicIndexer`
    implements the strict minimum, while `LocalIndex` uses a stop word file and a
    stem words database. `FastIndexer` implements all steps and could be based on
    a fast indexer such as **Xapian** or **Lucene**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: “Indexer”为处理算法提供了部分实现，但需要在子类中实现“_remove_stop_words”和“_stem_words”。 “BasicIndexer”实现了严格的最小值，而“LocalIndex”使用了停用词文件和词干词数据库。
    “FastIndexer”实现了所有步骤，并可以基于快速索引器（如Xapian或Lucene）。
- en: 'A toy implementation can be:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个玩具实现可以是：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'From there, a `BasicIndexer` implementation can be:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，“BasicIndexer”实现可以是：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And, like always, here is an example usage for the preceding example code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，像往常一样，这是前面示例代码的一个使用示例：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Template should be considered for an algorithm that may vary and can be expressed
    into isolated substeps. This is probably the most used pattern in Python and does
    not always needs to be implemented via subclassing. For instance, a lot of built-in
    Python functions that deal with algorithmic problems accept arguments that allow
    you to delegate part of the implementation to external implementation. For instance,
    the `sorted()` function allows for an optional `key` keyword argument that is
    later used by a sorting algorithm. This is also the same for `min()` and `max()`
    functions that find minimum and maximum values in the given collection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 应该考虑模板，以便设计可能变化并可以表达为孤立子步骤的算法。这可能是Python中最常用的模式，并且不总是需要通过子类实现。例如，许多内置的Python函数处理算法问题，接受允许您将部分实现委托给外部实现的参数。例如，“sorted（）”函数允许使用后续由排序算法使用的可选“key”关键字参数。对于在给定集合中查找最小值和最大值的“min（）”和“max（）”函数也是如此。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Design patterns are reusable, somewhat language-specific solutions to common
    problems in software design. They are a part of the culture of all developers,
    no matter what language they use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是可重用的，与语言有关的解决方案，用于软件设计中的常见问题。无论使用何种语言，它们都是所有开发人员文化的一部分。
- en: So, using implementation examples for the most used patterns for a given language
    is a great way to document that. Both on the Web and in other books, you will
    easily find implementation for every design pattern mentioned in GoF books. This
    is why we concentrated only on patterns that are the most common and popular in
    the context of the Python language.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用给定语言中最常用模式的实现示例是记录的好方法。在网络和其他书籍中，您将很容易找到GoF书籍中提到的每个设计模式的实现。这就是为什么我们只集中在Python语言上下文中最常见和流行的模式上。
