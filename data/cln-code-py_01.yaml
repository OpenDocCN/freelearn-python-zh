- en: Introduction, Code Formatting, and Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍、代码格式化和工具
- en: In this chapter, we will explore the first concepts related to clean code, starting
    with what it is and what it means. The main point of the chapter is to understand
    that clean code is not just a nice thing to have or a luxury in software projects.
    It's a necessity. Without quality code, the project will face the perils of failing
    due to an accumulated technical debt.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与干净代码相关的第一个概念，从它是什么和意味着什么开始。本章的主要观点是要理解干净代码不仅仅是软件项目中的一件好事或奢侈品。这是必需的。没有质量的代码，项目将面临由于积累的技术债务而失败的危险。
- en: Along the same lines, but going into a bit more detail, are the concepts of
    formatting and documenting the code. This also might sound like a superfluous
    requirement or task, but again, we will discover that it plays a fundamental role
    in keeping the code base maintainable and workable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着同样的思路，但更详细地讨论的是格式化和文档化代码的概念。这也可能听起来像是一个多余的要求或任务，但我们将发现它在保持代码库的可维护性和可操作性方面起着基本作用。
- en: We will analyze the importance of adopting a good coding guideline for this
    project. Realizing that maintaining the code align to the reference is a continuous
    task, and we will see how we can get help from automated tools that will ease
    our work. For this reason, we quickly discuss how to configure the main tools
    so that they automatically run on the project as part of the build.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析采用良好的编码准则对该项目的重要性。意识到保持代码与参考一致是一项持续的任务，我们将看到如何从自动化工具中获得帮助，以简化我们的工作。因此，我们迅速讨论如何配置主要工具，以便它们作为构建的一部分自动运行在项目上。
- en: After reading this chapter, you will have an idea of what clean code is, why
    it is important, why formatting and documenting the code are crucial tasks, and
    how to automate this process. From this, you should acquire the mindset for quickly
    organizing the structure of a new project, aiming for good code quality.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解干净代码是什么，为什么它很重要，为什么格式化和文档化代码是关键任务，以及如何自动化这个过程。从中，您应该获得快速组织新项目结构的思维方式，以追求良好的代码质量。
- en: 'After reading this chapter, you will have learned the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将学到以下内容：
- en: That clean code really means something far more important than formatting in
    software construction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 干净代码在软件构建中的真正意义远远重要于格式化
- en: That even so, having a standard formatting is a key component to have in a software
    project, for the sake of its maintainability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使如此，拥有标准的格式化是软件项目中必须具备的关键组成部分，以确保其可维护性
- en: How to make the code self-documenting by using the features that Python provides
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用Python提供的功能使代码自我记录
- en: How to configure tools to help arrange the layout of the code in a consistent
    way so that team members can focus on the essence of the problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置工具以帮助以一致的方式安排代码布局，以便团队成员可以专注于问题的本质。
- en: The meaning of clean code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 干净代码的含义
- en: There is no sole or strict definition of clean code. Moreover, there is probably
    no way of formally measuring clean code, so you cannot run a tool on a repository
    that could tell you how good, bad, or maintainable or not that code is. Sure,
    you can run tools such as checkers, linters, static analyzers, and so on. And
    those tools are of much help. They are necessary, but not sufficient. Clean code
    is not something a machine or script could tell (so far), but rather something
    that us, as professionals, can decide.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 没有干净代码的唯一或严格定义。此外，可能没有正式衡量干净代码的方法，因此您无法在存储库上运行工具，告诉您代码的好坏、可维护性或不可维护性。当然，您可以运行检查器、linter、静态分析器等工具。这些工具非常有帮助。它们是必需的，但不够。干净的代码不是机器或脚本可以告诉的东西（到目前为止），而是我们作为专业人士可以决定的东西。
- en: For decades of using the terms programming languages, we thought that they were
    languages to communicate our ideas to the machine, so it can run our programs.
    We were wrong. That's not the truth, but part of the truth. The real language
    behind programming languages is to communicate our ideas to other developers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，我们一直在使用编程语言这个术语，我们认为它们是用来向机器传达我们的想法，以便它可以运行我们的程序。我们错了。这不是真相，而是真相的一部分。编程语言背后的真正语言是将我们的想法传达给其他开发人员。
- en: Here is where the true nature of clean code lies. It depends on other engineers
    to be able to read and maintain the code. Therefore, we, as professionals, are
    the only ones who can judge this. Think about it; as developers, we spend much
    more time reading code than actually writing it. Every time we want to make a
    change or add a new feature, we first have to read all the surroundings of the
    code we have to modify or extend. The language (Python), is what we use to communicate
    among ourselves.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是干净代码的真正本质所在。它取决于其他工程师能够阅读和维护代码。因此，我们作为专业人士是唯一能够判断这一点的人。想想看；作为开发人员，我们花在阅读代码上的时间要比实际编写代码的时间多得多。每当我们想要进行更改或添加新功能时，我们首先必须阅读我们需要修改或扩展的代码周围的所有内容。语言（Python）是我们用来相互交流的工具。
- en: So, instead of giving you a definition (or my definition) of clean code, I invite
    you to go through the book, read all about idiomatic Python, see the difference
    between good and bad code, identify traits of good code and good architecture,
    and then come up with your own definition. After reading this book, you will be
    able to judge and analyze code for yourself, and you will have a more clear understanding
    of clean code. You will know what it is and what it means, regardless of any definition
    given to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其给您一个干净代码的定义（或我的定义），我邀请您阅读全书，了解有关惯用Python的所有内容，看到好代码和坏代码之间的区别，识别好代码和良好架构的特征，然后提出您自己的定义。阅读本书后，您将能够自行判断和分析代码，并对干净代码有更清晰的理解。您将知道它是什么和意味着什么，而不受任何给定的定义的影响。
- en: The importance of having clean code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有干净代码的重要性
- en: There are a huge number of reasons why clean code is important. Most of them
    revolve around the ideas of maintainability, reducing technical debt, working
    effectively with agile development, and managing a successful project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码重要的原因有很多。其中大部分都围绕着可维护性、减少技术债务、有效地与敏捷开发合作以及管理成功的项目。
- en: The first idea I would like to explore is in regards to agile development and
    continuous delivery. If we want our project to be able to successfully deliver
    features constantly at a steady and predictable pace, then having a good and maintainable
    code base is a must.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我想探讨的第一个想法是关于敏捷开发和持续交付。如果我们希望我们的项目能够以稳定和可预测的速度不断成功地交付功能，那么拥有一个良好且可维护的代码库是必不可少的。
- en: Imagine you are driving a car on a road toward a destination you want to reach
    at a certain point in time. You have to estimate your arrival time so that you
    can tell the person who is waiting for you. If the car works fine, and the road
    is flat and perfect, then I do not see why you would miss your estimation by a
    large margin. Now, if the road is broken and you have to step out to move rocks
    out of the way, or avoid cracks, stop to check the engine every few kilometers,
    and so on, then it is very unlikely that you will know for sure when are you going
    to arrive (or if you are). I think the analogy is clear; the road is the code.
    If you want to move at a steady, constant, and predictable pace, the code needs
    to be maintainable and readable. If it is not, every time product management asks
    for a new feature, you will have to stop to refactor and fix the technical debt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在驾驶一辆汽车沿着一条通往你想在某个时间点到达的目的地的道路行驶。你必须估计到达时间，这样你就可以告诉等待你的人。如果汽车运行良好，道路平坦完美，那么我不明白为什么你会大大地错过你的估计。现在，如果道路破损，你不得不下车移动路上的石头，或者避开裂缝，每隔几公里就停下来检查引擎，等等，那么你很可能不会确定你何时到达（或者是否会到达）。我认为这个类比很清楚；道路就是代码。如果你想以稳定、持续和可预测的速度前进，代码就需要是可维护和可读的。如果不是，每当产品管理要求新功能时，你都必须停下来重构和修复技术债务。
- en: Technical debt refers to the concept of problems in the software as a result
    of a compromise, and a bad decision being made. In a way, it's possible to think
    about technical debt in two ways. From the present to the past. What if the problems
    we are currently facing are the result of previously written bad code? From the
    present to the future—if we decide to take the shortcut now, instead of investing
    time in a proper solution, what problems are we creating for ourselves in the
    future?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是指由于妥协和错误决策而导致软件中的问题的概念。在某种程度上，可以从现在到过去来思考技术债务。如果我们目前面临的问题是先前编写的糟糕代码的结果，那么怎么办？从现在到未来——如果我们决定现在走捷径，而不是投入时间进行适当的解决方案，那么我们将为自己创造什么问题？
- en: The word *debt* is a good choice. It's a debt because the code will be harder
    to change in the future than it would be to change it now. That incurred cost
    is the interests of the debt. Incurring in technical debt means that tomorrow,
    the code will be harder and more expensive (it would be possible to even measure
    this) than today, and even more expensive the day after, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “债务”这个词是一个很好的选择。这是一种债务，因为将来更改代码将比现在更改代码更困难。这种产生的成本就是债务的利息。技术债务意味着明天，代码将比今天更难、更昂贵（甚至可能测量）；后天更昂贵，以此类推。
- en: Every time the team cannot deliver something on time and has to stop to fix
    and refactor the code is paying the price of technical debt.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当团队无法按时交付某些东西并不得不停下来修复和重构代码时，就是在支付技术债务的代价。
- en: The worst thing about technical debt is that it represents a long-term and underlying
    problem. It is not something that raises a high alarm. Instead, it is a silent
    problem, scattered across all parts of the project, that one day, at one particular
    time, will wake up and become a show-stopper.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务最糟糕的地方在于它代表了一个长期和潜在的问题。这不是引起高度警报的事情。相反，它是一个潜在的问题，分散在项目的所有部分，某一天，在某个特定的时间，它将醒来并成为一个停工的原因。
- en: The role of code formatting in clean code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式在清洁代码中的作用
- en: Is clean code about formatting and structuring the code, according to some standards
    (for example, PEP-8, or a custom standard defined by the project guidelines)?
    The short answer is no.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的代码是关于根据一些标准（例如PEP-8，或项目指南定义的自定义标准）格式化和构造代码吗？简短的答案是否定的。
- en: Clean code is something else that goes way beyond coding standards, formatting,
    linting tools, and other checks regarding the layout of the code. Clean code is
    about achieving quality software and building a system that is robust, maintainable,
    and avoiding technical debt. A piece of code or an entire software component could
    be 100% with PEP-8 (or any other guideline), and still not satisfy these requirements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的代码是另一回事，远远超出了编码标准、格式化、linting工具和其他有关代码布局的检查。清洁的代码是关于实现高质量的软件，构建一个健壮、可维护的系统，避免技术债务。一段代码或整个软件组件可以符合PEP-8（或任何其他指南），但仍然不能满足这些要求。
- en: However, not paying attention to the structure of the code has some perils.
    For this reason, we will first analyze the problems with a bad code structure,
    how to address them, and then we will see how to configure and use tools for Python
    projects in order to automatically check and correct problems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不关注代码结构也有一些危险。因此，我们将首先分析糟糕的代码结构问题，如何解决这些问题，然后我们将看到如何配置和使用Python项目工具，以便自动检查和纠正问题。
- en: To sum this up, we can say that clean code has nothing to do with things like
    PEP-8 or coding styles. It goes way beyond that, and it means something more meaningful
    to the maintainability of the code and the quality of the software. However, as
    we will see, formatting the code correctly is important in order to work efficiently.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以说，清洁的代码与PEP-8或编码风格之类的东西无关。它远远超出了那些，对代码的可维护性和软件质量意味着更有意义的东西。然而，正如我们将看到的，正确格式化代码对于高效工作是重要的。
- en: Adhering to a coding style guide on your project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 遵循项目的编码风格指南'
- en: A coding guideline is a bare minimum a project should have to be considered
    being developed under quality standards. In this section, we will explore the
    reasons behind this, so in the following sections, we can start looking at ways
    to enforce this automatically by the means of tools.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编码指南是项目应该具备的最低标准，以便被认为是按照质量标准开发的项目。在本节中，我们将探讨其中的原因，以便在接下来的章节中，我们可以开始探讨通过工具自动强制执行这一点的方法。
- en: The first thing that comes to my mind when I try to find good traits in a code
    layout is consistency. I would expect the code to be consistently structured so
    that it is easier to read and follow. If the code is not correct or consistently
    structured, and everyone on the team is doing things in their own way, then we
    will end up with code that will require extra effort and concentration to be followed
    correctly. It will be error-prone, misleading, and bugs or subtleties might slip
    through easily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我试图在代码布局中找到好的特点时，我脑海中首先想到的是一致性。我希望代码能够一致地结构化，以便更容易阅读和理解。如果代码不正确或结构不一致，并且团队中的每个人都按照自己的方式做事，那么我们最终会得到需要额外努力和专注才能正确遵循的代码。它将容易出错，误导人，并且错误或微妙之处可能很容易被忽略。
- en: We want to avoid that. What we want is exactly the opposite of that—code that
    we can read and understand as quickly as possible at a single glance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要避免这种情况。我们想要的正是相反的情况——我们能够在一瞥之间尽快阅读和理解的代码。
- en: If all members of the development team agree on a standardized way of structuring
    the code, the resulting code would look much more familiar. As a result of that,
    you will quickly identify patterns (more about this in a second), and with these
    patterns in mind, it will be much easier to understand things and detect errors.
    For example, when something is amiss, you will notice that somehow, there is something
    odd in the patterns you are used to seeing, which will catch your attention. You
    will take a closer look, and you will more than likely spot the mistake!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发团队的所有成员都同意以标准化的方式结构化代码，那么最终的代码看起来会更加熟悉。因此，你将很快识别出模式（稍后会详细介绍），并且有了这些模式，理解事物和发现错误将变得更加容易。例如，当出现问题时，你会注意到你习惯看到的模式中有些地方不对劲，这会引起你的注意。你会仔细看一看，很可能会发现错误！
- en: As it was stated in the classical book, *Code Complete*, an interesting analysis
    of this was done on the paper titled *Perceptions in Chess* (1973), where an experiment
    was conducted in order to identify how different people can understand or memorize
    different chess positions. The experiment was conducted on players of all levels
    (novices, intermediate, and chess masters), and with different chess positions
    on the board. They found out that when the position was random, the novices did
    as well as the chess masters; it was just a memorization exercise that anyone
    could do at reasonably the same level. When the positions followed a logical sequence
    that might occur in a real game (again, consistency, adhering to a pattern), then
    the chess masters performed exceedingly better than the rest.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如经典著作《代码大全》中所述，对此进行了有趣的分析，即在题为《国际象棋中的感知》（1973）的论文中进行了一项实验，以确定不同人如何理解或记忆不同的国际象棋局面。实验涉及各个水平的玩家（初学者、中级和国际象棋大师），以及棋盘上的不同国际象棋局面。他们发现，当局面是随机的时，初学者和国际象棋大师的表现一样好；这只是一个任何人都可以在相当同等水平上完成的记忆练习。当局面遵循可能在真实比赛中出现的逻辑顺序时（再次强调，一致性，遵循模式），国际象棋大师的表现要远远好于其他人。
- en: Now imagine this same situation applied to software. We, as the software engineers
    experts in Python, are like the chess masters in the previous example. When the
    code is structured randomly, without following any logic, or adhering to any standard,
    then it would be as difficult for us to spot mistakes as a novice developer. On
    the other hand, if we are used to reading code in a structured fashion, and we
    have learned to quickly get the ideas from the code by following patterns, then
    we are at a considerable advantage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，将这种情况应用到软件中。作为Python软件工程师专家，我们就像前面例子中的国际象棋大师。当代码结构随意，没有遵循任何逻辑或标准时，我们很难像初学者开发人员那样发现错误。另一方面，如果我们习惯以结构化的方式阅读代码，并且已经学会通过遵循模式快速理解代码的思想，那么我们就处于相当大的优势。
- en: In particular, for Python, the sort of coding style you should follow is PEP-8\.
    You can extend it or adopt some of its parts to the particularities of the project
    you are working on (for example, the length of the line, the notes about strings,
    and so on). However, I do suggest that regardless of whether you are using just
    plain PEP-8 or extending it, you should really stick to it instead of trying to
    come up with another different standard from scratch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于Python，你应该遵循的编码风格是PEP-8。你可以扩展它或采用它的一些部分来适应你正在工作的项目的特殊情况（例如，行的长度，关于字符串的注释等）。然而，我建议无论你是只使用PEP-8还是扩展它，你都应该坚持使用它，而不是试图从头开始制定另一个不同的标准。
- en: The reason for this is that this document already takes into consideration many
    of the particularities of the syntax of Python (that would not normally apply
    for other languages), and it was created by core Python developers who actually
    contributed to the syntax of Python. For this reason, it is hard to think that
    the accuracy of PEP-8 can be otherwise matched, not to mention, improved.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是这个文档已经考虑了Python语法的许多特殊情况（这些特殊情况通常不适用于其他语言），而且它是由实际为Python语法做出贡献的核心Python开发人员创建的。因此，很难想象PEP-8的准确性可以被否定，更不用说改进了。
- en: 'In particular, PEP-8 has some characteristics that carry other nice improvements
    when dealing with code, such as following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，PEP-8在处理代码时具有一些特点，可以带来其他良好的改进，例如：
- en: '**Grepability**: This is the ability to grep tokens inside the code; that is,
    to search in certain files (and in which part of those files) for the particular
    string we are looking for. One of the items introduced by this standard is something
    that differentiates the way of writing the assignment of values to variables,
    from the keyword arguments being passed to functions.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可搜索性**：这是在代码中搜索标记的能力；也就是说，在特定文件中（以及这些文件的哪个部分）搜索我们正在寻找的特定字符串。这个标准引入的其中一项内容是区分变量赋值的方式和传递给函数的关键字参数的方式。'
- en: 'To see this better, let''s use an example. Let''s say we are debugging, and
    we need to find where the value to a parameter named `location` is being passed.
    We can run the following `grep` command, and the result will tell us the file
    and the line we are looking for:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们举个例子。假设我们正在调试，我们需要找到将值传递给名为`location`的参数的地方。我们可以运行以下`grep`命令，结果将告诉我们我们正在寻找的文件和行：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we want to know where this variable is being assigned this value, and
    the following command will also give us the information we are looking for:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想知道这个变量是在哪里被赋予这个值，下面的命令也会给我们提供我们正在寻找的信息：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PEP-8 establishes the convention that, when passing arguments by keyword to
    a function, we don't use spaces, but we do when we assign variables. For that
    reason, we can adapt our search criteria (no spaces around the `=` on the first
    search, and one space on the second) and be more efficient in our search. That
    is one of the advantages of following a convention.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-8规定，当通过关键字将参数传递给函数时，我们不使用空格，但在赋值变量时使用。因此，我们可以调整我们的搜索标准（在第一次搜索时不使用`=`周围的空格，在第二次搜索时使用一个空格），并且在我们的搜索中更加高效。这是遵循约定的优势之一。
- en: '**Consistency**: If the code looks like a uniform format, the reading of it
    will be much easier. This is particularly important for onboarding, if you want
    to welcome new developers to your project, or even hire new (and probably less
    experienced) programmers on your team, and they need to become familiar with the
    code (which might even consist of several repositories). It will make their lives
    much easier if the code layout, documentation, naming convention, and such is
    identical across all files they open, in all repositories.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：如果代码看起来像一个统一的格式，那么阅读它将更容易。这对于入职非常重要，如果你想欢迎新的开发人员加入你的项目，或者雇佣新的（可能经验不足）程序员加入你的团队，并且他们需要熟悉代码（甚至可能由多个存储库组成）。如果他们打开的所有文件中的代码布局、文档、命名约定等都是相同的，那么他们的生活将变得更加轻松。'
- en: '**Code quality:** By looking at the code in a structured fashion, you will
    become more proficient at understanding it at a glance (again, like in *Perception
    in Chess*), and you will spot bugs and mistakes more easily. In addition to that,
    tools that check for the quality of the code will also hint at potential bugs.
    Static analysis of the code might help to reduce the ratio of bugs per line of
    code.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**：通过以结构化的方式查看代码，你将更加熟练地一览无余地理解它（再次，就像*国际象棋中的感知*），并且更容易地发现错误和错误。除此之外，检查代码质量的工具也会提示潜在的错误。对代码进行静态分析可能有助于减少每行代码的错误比率。'
- en: Docstrings and annotations
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档字符串和注释
- en: This section is about documenting the code in Python, from within the code.
    Good code is self-explanatory but is also well-documented. It is a good idea to
    explain what it is supposed to do (not how).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是关于在Python中从代码内部对代码进行文档化。良好的代码是自解释的，但也要有良好的文档。解释它应该做什么（而不是如何）是一个好主意。
- en: One important distinction; documenting the code is not the same as adding comments
    on it. Comments are bad, and they should be avoided. By documentation, we refer
    to the fact of explaining the data types, providing examples of them, and annotating
    the variables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的区别；对代码进行文档化并不等同于在代码上添加注释。注释是不好的，应该避免。通过文档化，我们指的是解释数据类型，提供它们的示例，并对变量进行注释。
- en: This is relevant in Python, because being dynamically typed, it might be easy
    to get lost on the values of variables or objects across functions and methods.
    For this reason, stating this information will make it easier for future readers
    of the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Python中很重要，因为它是动态类型的，可能很容易在函数和方法之间的变量或对象的值上迷失。因此，陈述这些信息将使未来的代码读者更容易理解。
- en: There is another reason that specifically relates to annotations. They can also
    help in running some automatic checks, such as type hinting, through tools such
    as Mypy. We will find that, in the end, adding annotations pays off.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个特别与注释相关的原因。它们还可以帮助运行一些自动检查，比如通过Mypy这样的工具进行类型提示。最终，我们会发现，添加注释是值得的。
- en: Docstrings
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档字符串
- en: In simple terms, we can say that docstrings are basically documentation embedded
    in the source code. A **docstring** is basically a literal string, placed somewhere
    in the code, with the intention of documenting that part of the logic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以说文档字符串基本上是嵌入在源代码中的文档。**文档字符串**基本上是一个字面字符串，放在代码的某个地方，目的是对该逻辑部分进行文档化。
- en: Notice the emphasis on the word **documentation**. This subtlety is important
    because it's meant to represent explanation, not justification. Docstrings are
    not comments; they are documentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对**文档**一词的强调。这种微妙之处很重要，因为它的意图是代表解释，而不是证明。文档字符串不是注释；它们是文档。
- en: Having comments in the code is a bad practice for multiple reasons. First, comments
    represent our failure to express our ideas in the code. If we actually have to
    explain why or how we are doing something, then that code is probably not good
    enough. For starters, it fails to be self-explanatory. Second, it can be misleading.
    Worst than having to spend some time reading a complicated section is to read
    a comment on how it is supposed to work, and figuring out that the code actually
    does something different. People tend to forget to update comments when they change
    the code, so the comment next to the line that was just changed will be outdated,
    resulting in a dangerous misdirection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中添加注释是一个不好的做法，原因有多个。首先，注释代表了我们未能用代码表达我们的想法。如果我们实际上必须解释为什么或如何做某事，那么该代码可能还不够好。首先，它没有足够的自解释性。其次，它可能会误导。在阅读复杂部分时，最糟糕的情况是阅读一个注释，说明它应该如何工作，然后发现代码实际上做了不同的事情。人们往往会忘记在更改代码时更新注释，因此刚刚更改的行旁边的注释将过时，导致危险的错误方向。
- en: Sometimes, on rare occasions, we cannot avoid having comments. Maybe there is
    an error on a third-party library that we have to circumvent. In those cases,
    placing a small but descriptive comment might be acceptable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在极少数情况下，我们无法避免添加注释。也许第三方库上有一个错误，我们必须规避。在这些情况下，放置一个小但描述性的注释可能是可以接受的。
- en: With docstrings, however, the story is different. Again, they do not represent
    comments, but the documentation of a particular component (a module, class, method,
    or function) in the code. Their use is not only accepted but also encouraged.
    It is a good practice to add docstrings whenever possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文档字符串的情况不同。再次强调，它们不代表注释，而是代码中特定组件（模块、类、方法或函数）的文档。它们的使用不仅被接受，而且被鼓励。尽可能添加文档字符串是一个好习惯。
- en: The reason why they are a good thing to have in the code (or maybe even required,
    depending on the standards of your project) is that Python is dynamically typed.
    This means that, for example, a function can take anything as the value for any
    of its parameters. Python will not enforce, nor check, anything like this. So,
    imagine that you find a function in the code that you know you will have to modify.
    You are even lucky enough that the function has a descriptive name, and that its
    parameters do as well. It might still not be quite clear what types you should
    pass to it. Even if this is the case, how are they expected to be used?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在代码中是一个好东西的原因（或者甚至可能是必需的，这取决于项目的标准）是因为Python是动态类型的。这意味着，例如，函数可以将任何东西作为其参数的值。Python不会强制执行或检查任何这样的事情。因此，想象一下，在代码中找到一个您知道必须修改的函数。您甚至很幸运，该函数有一个描述性的名称，它的参数也是如此。它可能仍然不太清楚应该传递什么类型。即使是这种情况，它们应该如何使用？
- en: Here is where a good docstring might be of help. Documenting the expected input
    and output of a function is a good practice that will help the readers of that
    function understand how it is supposed to work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个好的文档字符串可能有所帮助的地方。记录函数的预期输入和输出是一个好习惯，将帮助该函数的读者理解它应该如何工作。
- en: 'Consider this good example from the standard library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下标准库中的这个很好的例子：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the docstring for the `update` method on dictionaries gives us useful
    information, and it is telling us that we can use it in different ways:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字典上`update`方法的文档字符串为我们提供了有用的信息，并告诉我们可以以不同的方式使用它：
- en: 'We can pass something with a `.keys()` method (for example, another dictionary),
    and it will update the original dictionary with the keys from the object passed
    per parameter:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以传递一个具有`.keys()`方法的对象（例如，另一个字典），它将使用传递的对象的键更新原始字典：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can pass an iterable of pairs of keys and values, and we will unpack them
    to `update`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以传递一个键和值的对的可迭代对象，并将它们解包到`update`中：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In any case, the dictionary will be updated with the rest of the keyword arguments
    passed to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，字典将使用传递给它的其余关键字参数进行更新。
- en: This information is crucial for someone that has to learn and understand how
    a new function works, and how they can take advantage of it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于必须学习和理解新函数如何工作以及如何利用它的人来说是至关重要的信息。
- en: Notice that in the first example, we obtained the docstring of the function
    by using the double question mark on it (`dict.update??`). This is a feature of
    the IPython interactive interpreter. When this is called, it will print the docstring
    of the object you are expecting. Now, imagine that in the same way, we obtained
    help from this function of the standard library; how much easier could you make
    the lives of your readers (the users of your code), if you place docstrings on
    the functions you write so that others can understand their workings in the same
    way?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个示例中，我们通过在其上使用双问号（`dict.update??`）获得了函数的文档字符串。这是IPython交互式解释器的一个特性。调用它时，它将打印您期望的对象的文档字符串。现在，想象一下，以同样的方式，我们从标准库的这个函数中获得帮助；如果您在编写的函数上放置文档字符串，以便其他人可以以同样的方式理解它们的工作原理，那么您可以使您的读者（代码的用户）的生活变得更加轻松多少？
- en: 'The docstring is not something separated or isolated from the code. It becomes
    part of the code, and you can access it. When an object has a docstring defined,
    this becomes part of it via its `__doc__` attribute:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串不是与代码分离或孤立的东西。它成为代码的一部分，您可以访问它。当对象有定义的文档字符串时，这通过其`__doc__`属性成为其一部分：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that it is even possible to access it at runtime and even generate
    or compile documentation from the source code. In fact, there are tools for that.
    If you run Sphinx, it will create the basic scaffold for the documentation of
    your project. With the `autodoc` extension (`sphinx.ext.autodoc`) in particular,
    the tool will take the docstrings from the code and place them in the pages that
    document the function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着甚至可以在运行时访问它，甚至可以从源代码生成或编译文档。实际上，有工具可以做到这一点。如果运行Sphinx，它将为项目的文档创建基本的框架。特别是使用`autodoc`扩展（`sphinx.ext.autodoc`），该工具将从代码中获取文档字符串，并将其放置在记录函数的页面中。
- en: Once you have the tools in place to build the documentation, make it public
    so that it becomes part of the project itself. For open source projects, you can
    use read the docs, which will generate the documentation automatically per branch
    or version (configurable). For companies or projects, you can have the same tools
    or configure these services on-premise, but regardless of this decision, the important
    part is that the documentation should be ready and available to all members of
    the team.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了构建文档的工具，就将其公开，使其成为项目本身的一部分。对于开源项目，你可以使用read the docs，它将根据分支或版本（可配置）自动生成文档。对于公司或项目，你可以使用相同的工具或在本地配置这些服务，但无论做出何种决定，重要的是文档应该准备好并对团队的所有成员可用。
- en: There is, unfortunately, one downside to docstrings, and it is that, as it happens
    with all documentation, it requires manual and constant maintenance. As the code
    changes, it will have to be updated. Another problem is that for docstrings to
    be really useful, they have to be detailed, which requires multiple lines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，文档字符串也有一个缺点，就是和所有文档一样，它需要手动和持续的维护。随着代码的变化，文档也需要更新。另一个问题是，为了使文档字符串真正有用，它们必须详细，这就需要多行。
- en: Maintaining proper documentation is a software engineering challenge that we
    cannot escape from. It also makes sense to be like this. If you think about it,
    the reason for documentation to be manually written is because it is intended to
    be read by other humans. If it were automated, it would probably not be of much
    use. For the documentation to be of any value, everyone on the team must agree
    that it is something that requires manual intervention, hence the effort required.
    The key is to understand that software is not just about code. The documentation
    that comes with it is also part of the deliverable. Therefore, when someone is
    making a change on a function, it is equally important to also update the corresponding
    part of the documentation to the code that was just changed, regardless of whether
    its a wiki, a user manual, a `README` file, or several docstrings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 维护适当的文档是我们无法逃避的软件工程挑战。这也是有道理的。如果你仔细想想，文档需要手动编写的原因是因为它是打算让其他人阅读的。如果它是自动化的，可能就没有太大的用处。为了使文档有价值，团队中的每个人都必须同意它是需要手动干预的东西，因此需要付出努力。关键是要理解软件不仅仅是代码。随之而来的文档也是交付内容的一部分。因此，当有人对一个函数进行更改时，同样重要的是更新文档的相应部分，无论是维基、用户手册、README文件还是多个文档字符串。
- en: Annotations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: PEP-3107 introduced the concept of annotations. The basic idea of them is to
    hint to the readers of the code about what to expect as values of arguments in
    functions. The use of the word **hint** is not casual; annotations enable type
    hinting, which we will discuss later on in this chapter, after the first introduction
    to annotations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-3107引入了注解的概念。它们的基本想法是向代码的读者提示函数参数的预期值。使用“提示”这个词并非偶然；注解使类型提示成为可能，我们将在本章后面讨论这个问题，首先介绍注解。
- en: Annotations let you specify the expected type of some variables that have been
    defined. It is actually not only about the types, but any kind of metadata that
    can help you get a better idea of what that variable actually represents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注解允许您指定已定义的某些变量的预期类型。实际上，这不仅仅是关于类型，还有任何可以帮助您更好地了解该变量实际代表的元数据。
- en: 'Consider the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we use `float` to indicate the expected types of `latitude` and `longitude`.
    This is merely informative for the reader of the function so that they can get
    an idea of these expected types. Python will not check these types nor enforce
    them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`float`来指示`latitude`和`longitude`的预期类型。这仅仅是为了让函数的读者了解这些预期类型。Python不会检查这些类型，也不会强制执行它们。
- en: We can also specify the expected type of the returned value of the function.
    In this case, `Point` is a user-defined class, so it will mean that whatever is
    returned will be an instance of `Point`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定函数返回值的预期类型。在这种情况下，`Point`是一个用户定义的类，这意味着无论返回什么都将是`Point`的一个实例。
- en: However, types or built-ins are not the only kind of thing we can use as annotations.
    Basically, everything that is valid in the scope of the current Python interpreter
    could be placed there. For example, a string explaining the intention of the variable,
    a callable to be used as a callback or validation function, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型或内置类型并不是我们可以用作注解的唯一类型。基本上，任何在当前Python解释器范围内有效的东西都可以放在那里。例如，解释变量意图的字符串，可用作回调或验证函数的可调用对象等。
- en: 'With the introduction of annotations, a new special attribute is also included,
    and it is `__annotations__`. This will give us access to a dictionary that maps
    the name of the annotations (as keys in the dictionary) with their corresponding
    values, which are those we have defined for them. In our example, this will look
    like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着注解的引入，还包括了一个新的特殊属性，即`__annotations__`。这将使我们能够访问一个字典，将注解的名称（作为字典中的键）与它们的对应值进行映射，这些值是我们为它们定义的。在我们的示例中，这将如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We could use this to generate documentation, run validations, or enforce checks
    in our code if we think we have to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为有必要，我们可以使用这些来生成文档，运行验证，或者在我们的代码中强制检查。
- en: 'Speaking of checking the code through annotations, this is when PEP-484 comes
    into play. This PEP specifies the basics of type hinting; the idea of checking
    the types of our functions via annotations. Just to be clear again, and quoting
    PEP-484 itself:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 说到通过注解检查代码，这就是PEP-484发挥作用的时候。这个PEP指定了类型提示的基础，即通过注解检查我们函数的类型。再次明确一下，引用PEP-484本身：
- en: '"Python will remain a dynamically typed language, and the authors have no desire
    to ever make type hints mandatory, even by convention."'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python将保持为一种动态类型的语言，作者们也不希望通过约定来强制类型提示成为必须。
- en: The idea of type hinting is to have extra tools (independent from the interpreter)
    to check and assess the correct use of types throughout the code and to hint to
    the user in case any incompatibilities are detected. The tool that runs these
    checks, Mypy, is explained in more detail in a later section, where we will talk
    about using and configuring the tools for the project. For now, you can think
    of it as a sort of linter that will check the semantics of the types used on the
    code. This sometimes helps in finding bugs early on, when the tests and checks
    are run. For this reason, it is a good idea to configure Mypy on the project and
    use it at the same level as the rest of the tools for static analysis.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的想法是提供额外的工具（与解释器无关），以检查和评估代码中类型的正确使用，并在检测到任何不兼容性时提示用户。运行这些检查的工具Mypy将在后面的章节中详细解释，我们将讨论如何为项目使用和配置这些工具。现在，您可以将其视为一种检查代码中使用的类型语义的linter。这有时有助于在运行测试和检查时尽早发现错误。因此，将Mypy配置到项目中并将其与其他静态分析工具放在同一级别是一个好主意。
- en: However, type hinting means more than just a tool for checking the types on
    the code. Starting with Python 3.5, the new typing module was introduced, and
    this significantly improved how we define the types and the annotations in our
    Python code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型提示意味着不仅仅是代码中类型检查的工具。从Python 3.5开始，引入了新的typing模块，这显著改进了我们在Python代码中定义类型和注释的方式。
- en: The basic idea behind this is that now the semantics extend to more meaningful
    concepts, making it even easier for us (humans) to understand what the code means,
    or what is expected at a given point. For example, you could have a function that
    worked with lists or tuples in one of its parameters, and you would have put one
    of these two types as the annotation, or even a string explaining it. But with
    this module, it is possible to tell Python that it expects an iterable or a sequence.
    You can even identify the type or the values on it; for example, that it takes
    a sequence of integers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其基本思想是，现在语义扩展到更有意义的概念，使我们（人类）更容易理解代码的含义，或者在给定点处期望的内容。例如，您可以有一个函数，它的一个参数是列表或元组，并且您可以将这两种类型之一作为注释，甚至是一个解释字符串。但是使用这个模块，可以告诉Python它期望一个可迭代对象或序列。甚至可以识别类型或其中的值；例如，它需要一个整数序列。
- en: 'There is one extra improvement made in regards to annotations at the time of
    writing this book, and that is that starting from Python 3.6, it is possible to
    annotate variables directly, not just function parameters and return types. This
    was introduced in PEP-526, and the idea is that you can declare the types of some
    variables defined without necessarily assigning a value to them, as shown in the
    following listing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，关于注释方面进行了一项额外的改进，那就是从Python 3.6开始，可以直接注释变量，而不仅仅是函数参数和返回类型。这是在PEP-526中引入的，其想法是可以声明一些变量的类型，而不一定给它们赋值，如下面的清单所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do annotations replace docstrings?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释是否取代了docstrings？
- en: This is a valid question, since on older versions of Python, long before annotations
    were introduced, the way of documenting the types of the parameters of functions
    or attributes was done by putting docstrings on them. There are even some conventions
    on formats on how to structure docstrings to include the basic information for
    a function, including types and meaning of each parameter, type, and meaning of
    the result, and possible exceptions that the function might raise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的问题，因为在Python的旧版本中，在引入注释之前很久，函数或属性的参数类型的文档方式是通过在它们上面放置docstrings来完成的。甚至有一些关于如何构造docstrings的格式的约定，以包括函数的基本信息，包括每个参数的类型和含义，结果的类型和含义，以及函数可能引发的异常。
- en: Most of this has been addressed already in a more compact way by means of annotations,
    so one might wonder if it is really worth having docstrings as well. The answer
    is yes, and this is because they complement each other.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容已经通过注释以更紧凑的方式进行了处理，因此人们可能会想知道是否真的值得使用docstrings。答案是肯定的，因为它们互补。
- en: It is true that a part of the information previously contained on the docstring
    can now be moved to the annotations. But this should only leave more room for
    a better documentation on the docstring. In particular, for dynamic and nested
    data types, it is always a good idea to provide examples of the expected data
    so that we can get a better idea of what we are dealing with.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，以前包含在docstring中的一部分信息现在可以移动到注释中。但这只应该为docstring提供更好的文档空间。特别是对于动态和嵌套数据类型，提供预期数据的示例总是一个好主意，这样我们就可以更好地了解我们正在处理的内容。
- en: 'Consider the following example. Let''s say we have a function that expects
    a dictionary to validate some data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。假设我们有一个函数，它期望一个字典来验证一些数据：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see a function that takes a dictionary and returns another dictionary.
    Potentially, it can raise an exception if the value under the key `"status"` is
    not the expected one. However, we do not have much more information about it.
    For example, what does a correct instance of a `response` object look like? What
    would an instance of `result` look like? To answer both of these questions, it
    would be a good idea to document examples of the data that is expected to be passed
    in by a parameter and returned by this function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个接受字典并返回另一个字典的函数。可能会在键“status”下的值不是预期值时引发异常。但是，我们对此了解不多。例如，`response`对象的正确实例是什么样的？`result`的实例会是什么样的？为了回答这两个问题，最好是记录预期由参数传入并由此函数返回的数据的示例。
- en: 'Let''s see if we can explain this better with the help of a docstring:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以通过docstring更好地解释这一点：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have a better idea of what is expected to be received and returned by
    this function. The documentation serves as valuable input, not only for understanding
    and getting an idea of what is being passed around, but also as a valuable source
    for unit tests. We can derive data like this to use as input, and we know what
    would be the correct and incorrect values to use on the tests. Actually, the tests
    also work as actionable documentation for our code, but this will be explained
    in more detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对这个函数预期接收和返回的内容有了更好的了解。文档不仅作为理解和了解传递内容的宝贵输入，还是单元测试的宝贵来源。我们可以从中获取数据作为输入，并知道测试时应该使用的正确和不正确的值。实际上，测试也可以作为我们代码的可执行文档，但这将在更详细地解释。
- en: The benefit is that now we know what the possible values of the keys are, as
    well as their types, and we have a more concrete interpretation of what the data
    looks like. The cost is that, as we mentioned earlier, it takes up a lot of lines,
    and it needs to be verbose and detailed to be effective.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是现在我们知道键的可能值以及它们的类型，我们对数据的外观有了更具体的解释。成本是，正如我们之前提到的，它占用了很多行，并且需要冗长和详细才能有效。
- en: Configuring the tools for enforcing basic quality gates
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置工具以强制执行基本质量门
- en: In this section, we will explore how to configure some basic tools and automatically
    run checks on the code, with the goal of leveraging part of the repetitive verification
    checks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨如何配置一些基本工具，并自动运行代码检查，目的是利用重复性验证检查的一部分。
- en: 'This is an important point: remember that code is for us, people, to understand,
    so only we can determine what is good or bad code. We should invest time in code
    reviews, thinking about what good code is, and how readable and understandable
    it is. When looking at the code written by a peer, you should ask such questions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的观点：记住，代码是为了我们人类理解的，所以只有我们才能确定什么是好的或坏的代码。我们应该在代码审查上投入时间，思考什么是好的代码，以及它的可读性和可理解性。当查看同事编写的代码时，你应该问这样的问题：
- en: Is this code easy to understand and follow for a fellow programmer?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码对其他程序员来说易于理解和遵循吗？
- en: Does it speak in terms of the domain of the problem?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否以问题域的术语来表达？
- en: Would a new person joining the team be able to understand it and work with it
    effectively?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新加入团队的人能够理解并有效地使用它吗？
- en: As we saw previously, code formatting, consistent layout, and proper indentation
    are required but not sufficient traits to have in a code base. Moreover, this
    is something that we, as engineers with a high sense of quality, would take for
    granted, so we would read and write code far beyond the basic concepts of its
    layout. Therefore, we are not willing to waste time reviewing these kinds of items,
    so we can invest our time more effectively by looking at actual patterns in the
    code in order to understand its true meaning and provide valuable results.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，代码格式化、一致的布局和适当的缩进是必需的，但不足以成为代码库中具有的特征。此外，作为具有高质量意识的工程师，我们会认为这是理所当然的，因此我们会读写代码，远远超出其布局的基本概念。因此，我们不愿意浪费时间审查这些种类的项目，因此我们可以通过查看代码中的实际模式来更有效地投入时间，以理解其真正含义并提供有价值的结果。
- en: All of these checks should be automated. They should be part of the tests or
    checklist, and this, in turn, should be part of the continuous integration build.
    If these checks do not pass, make the build fail. This is the only way to actually
    ensure the continuity of the structure of the code at all times. It also serves
    as an objective parameter for the team to have as a reference. Instead of having
    some engineers or the leader of the team always having to tell the same comments
    about PEP-8 on code reviews, the build will automatically fail, making it something
    objective.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些检查都应该是自动化的。它们应该是测试或清单的一部分，反过来又应该是持续集成构建的一部分。如果这些检查未通过，构建将失败。这是确保代码结构始终连续的唯一方法。它也作为团队的客观参数参考。与其让一些工程师或团队领导在代码审查中总是说相同的关于PEP-8的评论，构建将自动失败，使其成为客观的事实。
- en: Type hinting with Mypy
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mypy的类型提示
- en: Mypy ([http://mypy-lang.org/](http://mypy-lang.org/)) is the main tool for optional
    static type checking in Python. The idea is that, once you install it, it will
    analyze all of the files on your project, checking for inconsistencies on the
    use of the types. This is useful since, most of the time, it will detect actual
    bugs early, but sometimes it can give false positives.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy ([http://mypy-lang.org/](http://mypy-lang.org/)) 是 Python 中可选的静态类型检查的主要工具。其想法是，一旦安装，它将分析项目中的所有文件，检查类型的使用是否一致。这是有用的，因为大多数时候，它会及早检测到实际的错误，但有时它可能会产生误报。
- en: 'You can install it with `pip`, and it is recommended to include it as a dependency
    for the project on the setup file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pip` 安装它，并建议将其包含在项目的设置文件中作为依赖项：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once it is installed in the virtual environment, you just have to run the preceding
    command and it will report all of the findings on the type checks. Try to adhere
    to its report as much as possible, because most of the time, the insights provided
    by it help to avoid errors that might otherwise slip into production. However,
    the tool is not perfect, so if you think it is reporting a false positive, you
    can ignore that line with the following marker as a comment:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它安装在虚拟环境中，你只需运行上述命令，它将报告类型检查的所有发现。尽量遵循它的报告，因为大多数时候，它提供的见解有助于避免可能会滑入生产中的错误。然而，该工具并不完美，所以如果你认为它报告了一个误报，你可以用以下标记忽略该行作为注释：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Checking the code with Pylint
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pylint检查代码
- en: There are many tools for checking the structure of the code (basically, this
    is compliance with PEP-8) in Python, such as pycodestyle (formerly known as PEP-8),
    Flake8, and many more. They all are configurable and are as easy to use as running
    the command they provide. Among all of them, I have found Pylint to be the most
    complete (and strict). It is also configurable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有许多用于检查代码结构的工具（基本上是符合PEP-8的），例如pycodestyle（以前称为PEP-8）、Flake8等。它们都是可配置的，并且像运行它们提供的命令一样容易使用。在所有这些工具中，我发现Pylint是最完整（也是最严格）的。它也是可配置的。
- en: 'Again, you just have to install it in the virtual environment with `pip`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您只需在虚拟环境中使用`pip`安装它：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, just running the `pylint` command would be enough to check it in the code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需运行`pylint`命令就足以检查代码。
- en: It is possible to configure Pylint via a configuration file named `pylintrc`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过名为`pylintrc`的配置文件来配置Pylint。
- en: In this file, you can decide the rules you would like to enable or disable,
    and parametrize others (for example, to change the maximum length of the column).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，您可以决定要启用或禁用的规则，并对其他规则进行参数化（例如，更改列的最大长度）。
- en: Setup for automatic checks
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检查设置
- en: On Unix development environments, the most common way of working is through
    makefiles. **Makefiles** are powerful tools that let us configure commands to
    be run in the project, mostly for compiling, running, and so on. Besides this,
    we can use a makefile in the root of our project, with some commands configured
    to run checks of the formatting and conventions on the code, automatically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix开发环境中，最常见的工作方式是通过makefile。**Makefile**是强大的工具，让我们可以配置在项目中运行的命令，主要用于编译、运行等。除此之外，我们还可以在项目的根目录中使用一个makefile，其中配置了一些命令来自动运行代码的格式和约定检查。
- en: 'A good approach for this would be to have targets for the tests, and each particular
    test, and then have another one that will run altogether. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的方法是为测试设置目标，每个特定的测试，然后再设置一个将所有测试一起运行的目标。例如：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, the command we should run (both in our development machines and in the
    continuous integration environment builds) is the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该运行的命令（无论是在我们的开发机器上还是在持续集成环境构建中）是以下命令：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will run everything in the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按以下步骤运行所有内容：
- en: It will first check the compliance with the coding guideline (PEP-8, for instance)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将首先检查是否符合编码指南（例如PEP-8）
- en: Then it will check for the use of types on the code
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它将检查代码中类型的使用
- en: Finally, it will run the tests
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将运行测试
- en: If any of these steps fail, consider the entire process a failure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤中的任何一个失败，都要将整个过程视为失败。
- en: Besides configuring these checks automatically in the build, it is also a good
    idea if the team adopts a convention and an automatic approach for structuring
    the code. Tools such as Black ([https://github.com/ambv/black](https://github.com/ambv/black))
    automatically format the code. There are many tools that will edit the code automatically,
    but the interesting thing about Black is that it does so in a unique form. It's
    opinionated and deterministic, so the code will always end up arranged in the
    same way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在构建中自动配置这些检查之外，如果团队采用了一种约定和自动化的代码结构方法，那也是一个好主意。诸如Black（[https://github.com/ambv/black](https://github.com/ambv/black)）之类的工具会自动格式化代码。有许多工具可以自动编辑代码，但Black的有趣之处在于它以独特的方式进行。它是一种主观和确定性的工具，因此代码最终总是以相同的方式排列。
- en: For example, Black strings will always be double-quotes, and the order of the
    parameters will always follow the same structure. This might sound rigid, but
    it's the only way to ensure the differences in the code are minimal. If the code
    always respects the same structure, changes in the code will only show up in pull
    requests with the actual changes that were made, and no extra cosmetic modifications.
    It's more restrictive than PEP-8, but it's also convenient because, by formatting
    the code directly through a tool, we don't have to actually worry about that,
    and we can focus on the crux of the problem at hand.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Black字符串总是双引号，参数的顺序总是遵循相同的结构。这可能听起来很严格，但这是确保代码差异最小的唯一方法。如果代码始终遵守相同的结构，代码中的更改将只显示在实际进行更改的拉取请求中，而不会有额外的美观修改。它比PEP-8更严格，但也更方便，因为通过工具直接格式化代码，我们不必真正担心这个问题，可以专注于手头问题的关键。
- en: At the time of writing this book, the only thing that can be configured is the
    length of the lines. Everything else is corrected by the criteria of the project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，唯一可以配置的是行的长度。其他一切都由项目的标准来纠正。
- en: 'The following code is PEP-8 correct, but it doesn''t follow the conventions
    of `black`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码符合PEP-8规范，但不符合`black`的约定：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can run the following command to format the file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下命令来格式化文件：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can see what the tool has written:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到工具写了什么：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On more complex code, a lot more would have changed (trailing commas, and more),
    but the idea can be seen clearly. Again, it's opinionated, but it's also a good
    idea to have a tool that takes care of details for us. It's also something that
    the Golang community learned a long time ago, to the point that there is a standard
    tool library, `got fmt`, that automatically formats the code according to the
    conventions of the language. It's good that Python has something like this now.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的代码中，会有更多的变化（尾随逗号等），但这个想法可以清楚地看到。再次强调，这是一种主观看法，但对于我们来说，拥有一个处理细节的工具也是一个好主意。这也是Golang社区很久以前就学会的东西，以至于有一个标准的工具库`got
    fmt`，可以根据语言的约定自动格式化代码。Python现在也有这样的东西，这是件好事。
- en: These tools (Black, Pylint, Mypy, and many more) can be integrated with the
    editor or IDE of your choice to make things even easier. It's a good investment
    to configure your editor to make these kinds of modifications either when saving
    the file or through a shortcut.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具（Black、Pylint、Mypy等）可以与您选择的编辑器或IDE集成，使事情变得更加容易。将编辑器配置为在保存文件时或通过快捷键进行这些修改是一个不错的投资。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a first idea of what clean code is, and a workable interpretation
    of it, which will serve us as a reference point for the rest of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对清晰的代码有了第一个概念，以及一个可行的解释，这将成为本书其余部分的参考点。
- en: More importantly, we understood that clean code is something much more important
    than the structure and layout of the code. We have to focus on how the ideas are
    represented on the code to see if they are correct. Clean code is about readability,
    maintainability of the code, keeping technical debt to the minimum, and effectively
    communicating our ideas into the code so that others can understand the same thing
    we intended to write in the first place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们明白了清晰的代码比代码的结构和布局更重要得多。我们必须关注代码中的思想是如何表示的，以确定它们是否正确。清晰的代码是关于代码的可读性、可维护性，将技术债务降到最低，并有效地将我们的想法传达到代码中，以便他人能够理解我们最初打算写的东西。
- en: However, we discussed that the adherence to coding styles or guidelines is important
    for multiple reasons. We have agreed that this is a condition that is necessary,
    but not sufficient, and since it is a minimal requirement every solid project
    should comply with, it is clear that is something we better leave to the tools.
    Therefore, automating all of these checks becomes critical, and in this regard,
    we have to keep in mind how to configure tools such as Mypy, Pylint, and more.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们讨论了遵循编码风格或指南的重要性，有多种原因。我们一致认为这是一个必要的条件，但并不充分，因为它是每个扎实项目都应该遵守的最低要求，很明显，这是我们最好留给工具的事情。因此，自动化所有这些检查变得至关重要，在这方面，我们必须记住如何配置诸如Mypy、Pylint等工具。
- en: The next chapter is going to be more focused on the Python-specific code, and
    how to express our ideas in idiomatic Python. We will explore the idioms in Python
    that make for more compact and efficient code. In this analysis, we will see that,
    in general, Python has different ideas or different ways to accomplish things
    compared to other languages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将更加专注于特定于Python的代码，以及如何用Python的习惯用法表达我们的想法。我们将探讨Python中使代码更简洁高效的习惯用法。在这个分析中，我们将看到，总的来说，Python有不同的想法或不同的方法来完成任务，与其他语言相比。
