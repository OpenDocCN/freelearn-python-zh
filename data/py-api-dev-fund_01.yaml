- en: 1\. Your First Step
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 您的第一步
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Replicate the concepts of RESTful API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制RESTful API的概念
- en: Describe the meaning of different HTTP methods and statuses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不同HTTP方法和状态的意义
- en: Get hands-on experience on PyCharm IDE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm IDE中获得实际操作经验
- en: Build a RESTful API and execute CRUD using Flask
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask构建RESTful API并执行CRUD操作
- en: Use JSON messages to communicate with the APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON消息与API进行通信
- en: Test API endpoints using Postman and httpie/curl command-line tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman和httpie/curl命令行工具测试API端点
- en: This chapter introduces API and explains the concepts of web services, API and
    REST.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了API，并解释了网络服务、API和REST的概念。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: We are in the internet era, a world where everything is connected. Data flows
    seamlessly from one place to another. We can get all the information in the world
    with a few clicks on a website. Take Skyscanner as an example, we just need to
    put in the date and location of our trips, and it can find us the cheapest flight
    in a split second; the hero behind the scenes that provides this data is API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处于互联网时代，一个万物互联的世界。数据无缝地从一地流向另一地。我们只需在网站上点击几下，就能获取世界上所有的信息。以Skyscanner为例，我们只需输入旅行的日期和地点，它就能在瞬间找到最便宜的航班；背后提供这些数据的英雄就是API。
- en: In this chapter, you will learn what a web service, an API, and REST are. We
    will start by teaching the fundamental concepts of APIs. Then we will look at
    real-life examples of how different web services (Google, Facebook, and so on)
    use the REST API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习什么是网络服务、API和REST。我们将从教授API的基本概念开始。然后，我们将探讨不同网络服务（如Google、Facebook等）如何使用REST
    API的实际例子。
- en: Finally, we will develop our first simple Python RESTful API using Python. Python
    is a popular and powerful programming language. Apart from its extensive use in
    the realm of artificial intelligence, it is also widely used in web application
    development, big data analysis, web scraping, and process automation. What makes
    Python excel in so many areas is the extensive number of frameworks available.
    The frameworks do all the heavy lifting jobs and that allows the developers to
    focus on the actual application design and development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Python开发我们的第一个简单的Python RESTful API。Python是一种流行且功能强大的编程语言。除了在人工智能领域广泛使用外，它还在Web应用程序开发、大数据分析、网络爬虫和流程自动化等方面得到广泛应用。Python在众多领域表现出色的原因是它拥有大量的框架。这些框架承担了所有繁重的工作，这使得开发者能够专注于实际的应用程序设计和开发。
- en: In this chapter, you will see how data is encoded and communicated between the
    frontend and the backend. You will learn technical details about the JSON format,
    the HTTP protocol, HTTP status codes, and so on. All the development work will
    be verified and tested using Postman and httpie/curl. We will take you through
    the whole process of web application development. Not only will you learn the
    essential aspects of developing a RESTful API, but you will also learn about the
    thinking process, design, development, testing, and even deployment. This is a
    journey of learning the complete software development life cycle. Let's embark
    on our exciting journey now!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解数据是如何在前端和后端之间编码和通信的。您将学习有关JSON格式、HTTP协议、HTTP状态码等的技术细节。所有开发工作都将使用Postman和httpie/curl进行验证和测试。我们将带您了解整个Web应用程序开发过程。您不仅将学习开发RESTful
    API的必要方面，还将学习思考过程、设计、开发、测试，甚至部署。这是一次学习完整软件开发生命周期的旅程。现在就让我们踏上这段激动人心的旅程吧！
- en: Understanding API
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解API
- en: API stands for application programming interface; it is an interface for the
    website (or mobile application) to communicate with the backend logic. Simply
    put, it is like a messenger that takes a request from the users and sends the
    request to the backend system. Once the backend system responds, it will then
    pass that response to the users. A metaphor for this is a waiter/waitress, who
    can understand different customers' orders. They will then act as a middleman
    between the customers and the chefs in the kitchen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: API代表应用程序编程接口；它是网站（或移动应用程序）与后端逻辑通信的接口。简单来说，它就像一个信使，从用户那里接收请求并将其发送到后端系统。一旦后端系统响应，它将把响应传递给用户。这个比喻就像服务员，能够理解不同顾客的订单。然后，他们将在顾客和厨房里的厨师之间充当中间人。
- en: If you were the boss of the restaurant, the key benefit of having a waiter/waitress
    here between your customer and the kitchen is that the customers will be shielded
    from seeing your business secrets. They don't need to know how the meal is prepared.
    They just need to send an order through the waiter/waitress, and they will get
    the meal they ordered. In this scenario, the waiter acts like the API. The following
    figure helps illustrate the analogy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一家餐厅的老板，在客户和厨房之间有服务员/女服务员在这里的好处是，客户将不会看到你的商业机密。他们不需要知道餐点是如何准备的。他们只需要通过服务员/女服务员下单，他们就会得到他们订购的餐点。在这种情况下，服务员就像API一样。以下图示有助于说明这个类比。
- en: '![Figure 1.1: The waiter acting as the API for the customer'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：服务员作为客户API的体现'
- en: '](img/C15309_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：服务员作为客户API的体现](img/C15309_01_01.jpg)'
- en: 'Figure 1.1: The waiter acting as the API for the customer'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：服务员作为客户API的体现
- en: Similarly, in computer science, one of the key benefits of having API is encapsulation.
    We encapsulate the logic so that people outside won't be able to see it. With
    this arrangement, big companies with sensitive information are willing to provide
    services to the world through APIs, confident that their internal information
    won't be revealed. Take Skyscanner again as an example. The company is comfortable
    with using an API to allow customers to book their flights, but at the same time,
    personal data from other customers that are stored in their internal database
    won't leak.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在计算机科学中，拥有API的一个关键好处是封装。我们封装逻辑，这样外面的人就无法看到它。在这种安排下，拥有敏感信息的大公司愿意通过API向世界提供服务，自信他们的内部信息不会被泄露。以Skyscanner为例，该公司对使用API让客户预订航班感到满意，但与此同时，存储在他们内部数据库中的其他客户的个人信息不会泄露。
- en: An API is also a standard interface that can communicate with different types
    of frontend Terminals, they can be mobile applications or websites. As long as
    the frontend is sending the same request to the API, it will get the same result
    back. If we go back to our metaphor, the waiter/waitress will serve all kinds
    of customers, regardless of their gender, age, language, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: API也是一个标准接口，可以与不同类型的终端进行通信，它们可以是移动应用程序或网站。只要前端向API发送相同的请求，它就会得到相同的结果。如果我们回到我们的比喻，服务员/女服务员将为所有类型的客户提供服务，无论他们的性别、年龄、语言等等。
- en: Now, imagine you are a software engineer at Skyscanner who is responsible for
    developing an API. What will your job be? Let me tell you. Your job will be to
    write a program that can take booking requests (date and location) from customers
    through the website, and then look up matching flights in the Skyscanner database
    and return the flight details to the customers. Throughout this book, you will
    be our API engineering intern. We will guide you, step by step, through the process
    of developing a RESTful API project that can serve the users of your system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你是Skyscanner的一名软件工程师，负责开发API。你的工作会是什么？让我告诉你。你的工作将是编写一个程序，可以从客户通过网站接收预订请求（日期和位置），然后在Skyscanner数据库中查找匹配的航班，并将航班详情返回给客户。在这本书的整个过程中，你将是我们的API工程实习生。我们将一步一步地引导你通过开发一个可以服务于你系统用户的RESTful
    API项目的流程。
- en: RESTful API
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful API
- en: REST stands for Representational State Transfer. It was first defined in Dr.
    Roy Fielding's dissertation (Architectural Styles and the Design of Network-Based
    Software Architectures) back in 2000\. This dissertation is considered to be the
    bible in the web domain. REST is not a standard or protocol; it is more like a
    software architectural style. Many engineers follow this architectural style to
    build their applications, such as eBay, Facebook, and Google Maps. These web applications
    serve huge amounts of traffic every second, so you can see that REST really is
    a scalable architecture style. And when we say RESTful API, we are referring to
    an API that conforms to the REST constraints/principles.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表表示状态传输。它最初在2000年Roy Fielding博士的论文（网络软件架构的设计和架构风格）中被定义。这篇论文被认为是网络领域的圣经。REST不是一个标准或协议；它更像是一种软件架构风格。许多工程师遵循这种架构风格来构建他们的应用程序，例如eBay、Facebook和Google
    Maps。这些网络应用程序每秒处理巨大的流量，所以你可以看到REST确实是一种可扩展的架构风格。当我们说RESTful API时，我们指的是符合REST约束/原则的API。
- en: REST Constraints/Principles
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST约束/原则
- en: 'There are five important constraints/principles for the REST architecture style:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST架构风格，有五个重要的约束/原则：
- en: 'Client-server: There is an interface between the client and the server. The
    client and server communicate through this interface and are independent of each
    other. Either side can be replaced as long as the interface stays the same. Requests
    always come from the client-side.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器：客户端和服务器之间存在一个接口。客户端和服务器通过这个接口进行通信，彼此独立。只要接口保持不变，任何一方都可以被替换。请求总是来自客户端。
- en: 'Stateless: There is no concept of state for a request. Every request is considered
    to be independent and complete. There is no dependence on the previous request
    nor dependence on a session to maintain the connection status.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态：对于请求没有状态的概念。每个请求都被视为独立且完整的。它不依赖于前一个请求，也不依赖于会话来维持连接状态。
- en: 'Cacheable: Things are cacheable on the server or client-side to improve performance.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存：为了提高性能，服务器或客户端上的事物可以缓存。
- en: 'Layered system: There can be multiple layers in the system, and the goal here
    is to hide the actual logic/resources. These layers can perform different functions,
    such as caching and encryption.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统：系统中可以有多个层次，这里的目的是隐藏实际的逻辑/资源。这些层可以执行不同的功能，例如缓存和加密。
- en: 'Uniform interface: The interface stays the same. This helps to decouple the
    client and server logic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口：接口保持不变。这有助于解耦客户端和服务器逻辑。
- en: HTTP Protocol
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP协议
- en: To better understand what REST is and make sure we are implementing the REST
    style, we can simply talk about the HTTP protocol. HTTP is an implementation of
    the REST architecture style. It is short for HyperText Transfer Protocol and is
    the standard protocol used on the worldwide web. We use it every day to browse
    different websites. That's why all the websites we visit are prefixed with http.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解REST是什么，并确保我们正在实现REST风格，我们可以简单地谈谈HTTP协议。HTTP是REST架构风格的实现。它代表超文本传输协议，是互联网上使用的标准协议。我们每天都在使用它来浏览不同的网站。这就是为什么我们访问的所有网站都以http开头。
- en: In the HTTP protocol, there are different types of service request methods.
    Each service request method has a special definition that is specific to it. When
    the frontend interface interacts with the backend API through a URL, they need
    to, at the same time, define the HTTP method for this request. Different HTTP
    methods are like different service counters. For example, reading and creating
    data are completely different services, so they should be handled by different
    service counters, meaning different HTTP methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP协议中，有不同的服务请求方法类型。每种服务请求方法都有其特定的定义。当前端界面通过URL与后端API交互时，它们需要同时定义此请求的HTTP方法。不同的HTTP方法就像不同的服务窗口。例如，读取和创建数据是完全不同的服务，因此应该由不同的服务窗口处理，即不同的HTTP方法。
- en: '`GET`: For reading data'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 用于读取数据'
- en: '`POST`: For creating data'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 用于创建数据'
- en: '`PUT`: For updating data by completely replacing data with new content'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 通过用新内容完全替换数据来更新数据'
- en: '`PATCH`: For updating data, but by partially modifying a few attributes'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 通过部分修改一些属性来更新数据'
- en: '`DELETE`: For deleting data'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 用于删除数据'
- en: Simply put, different HTTP methods are like the verbs for REST API. They are
    used for performing different actions on the same set of data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，不同的HTTP方法就像REST API的动词。它们用于对同一组数据执行不同的操作。
- en: HTTP Methods and CRUD
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法和CRUD
- en: We can easily build a RESTful API by leveraging what has already been provided
    by the HTTP protocol. Let's take a look at the HTTP methods that we can use to
    communicate with the server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用HTTP协议已经提供的内容轻松构建RESTful API。让我们看看我们可以用来与服务器通信的HTTP方法。
- en: In this book, we will build a recipe sharing platform with a RESTful API as
    the backend. This platform will allow users to create and share their own recipes.
    At the same time, users will also be able to read recipes shared by other users.
    Using this recipe sharing platform as an example, to achieve these functionalities,
    we will need our API to be able to perform different actions on the recipes. We
    can leverage different HTTP methods here. For example, we can use the `GET` method
    to request `http://localhost:5000/recipes` for all the recipes. We can use the
    `POST` method to request `http://localhost:5000/recipes` to create a new recipe.
    We can also use the `DELETE` method to request `http://localhost:5000/recipes/20`
    to delete a recipe with `ID = 20`. Please refer to the following table for details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将构建一个以RESTful API作为后端的食谱分享平台。这个平台将允许用户创建和分享他们自己的食谱。同时，用户还可以阅读其他用户分享的食谱。以这个食谱分享平台为例，为了实现这些功能，我们需要我们的API能够对食谱执行不同的操作。我们可以利用不同的HTTP方法。例如，我们可以使用`GET`方法请求`http://localhost:5000/recipes`以获取所有食谱。我们可以使用`POST`方法请求`http://localhost:5000/recipes`来创建一个新的食谱。我们还可以使用`DELETE`方法请求`http://localhost:5000/recipes/20`来删除ID为20的食谱。请参考以下表格以获取详细信息。
- en: '![Figure 1.2: HTTP methods'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：HTTP方法'
- en: '](img/C15309_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C15309_01_02.jpg]'
- en: 'Figure 1.2: HTTP methods'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：HTTP方法
- en: We can see that asking the backend API to work for us is simple. We can simply
    use the HTTP protocol to communicate our request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，让后端API为我们工作很简单。我们可以简单地使用HTTP协议来传达我们的请求。
- en: In fact, with this recipe sharing platform, you can see the majority of the
    actions we require will revolve around CREATE, READ, UPDATE, and DELETE. This
    is generally true for all other web applications as well. In the developer community,
    we call this CRUD in short. In a nutshell, CRUD models the life cycle of database
    record management.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用这个食谱分享平台，你可以看到我们需要的绝大多数操作都将围绕创建（CREATE）、读取（READ）、更新（UPDATE）和删除（DELETE）展开。这在所有其他Web应用程序中也是普遍适用的。在开发者社区中，我们简称为CRUD。简而言之，CRUD模型了数据库记录管理的生活周期。
- en: Modeling our web applications this way can help us easily construct a functioning
    web system, as these actions are related to the HTTP methods. Constructing our
    application with this architecture is simple, powerful, and highly readable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建我们的Web应用程序可以帮助我们轻松构建一个功能性的Web系统，因为这些操作与HTTP方法相关。使用这种架构构建我们的应用程序简单、强大且易于阅读。
- en: As you can probably imagine, we will need to send information to the backend
    server. For example, you may want to store a recipe in the backend database. You
    send the recipe over HTTP with a pre-agreed format with the backend. A pre-agreed
    format can be understood as a language used to communicate with the waiter/waitress
    in our previous metaphor. In real life, we have different languages, such as English,
    German, Chinese, and so on. We need to speak the right language for the other
    side to understand. In the web API domain, there are two prevalent standards,
    JSON and XML. We will mainly talk about JSON here because it is more readable
    and widely adopted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能想象，我们需要将信息发送到后端服务器。例如，你可能想在后端数据库中存储一个食谱。你通过HTTP以与后端预先约定的格式发送食谱。预先约定的格式可以理解为我们在之前的比喻中与服务员沟通时所使用的语言。在现实生活中，我们有不同的语言，如英语、德语、中文等。我们需要说对方能理解的语言。在Web
    API领域，有两种流行的标准，JSON和XML。我们将主要讨论JSON，因为它更易于阅读且被广泛采用。
- en: The JSON Format
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON格式
- en: '**JavaScript Object Notation** (**JSON**) is a simple plaintext format that
    is capable of representing complex data structures. We can use this format to
    represent strings, numbers, arrays, and even objects. Once we have the information
    "JSONified," we can use this widely adopted format to communicate with the API.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种能够表示复杂数据结构的简单纯文本格式。我们可以使用这种格式来表示字符串、数字、数组，甚至对象。一旦我们将信息“JSON化”，我们就可以使用这种广泛采用的格式与API进行通信。'
- en: We are going to show you what a JSON format file looks like. In the following
    example, you will see that we are representing two recipes in JSON format. A JSON
    document is a plaintext document; there is no encryption here. It is so readable
    that I am sure you can already tell (without further explanation) that there are
    two recipes here, each with an ID, name, and description.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示JSON格式文件的样子。在以下示例中，您将看到我们正在用JSON格式表示两个食谱。JSON文档是一个纯文本文档；这里没有加密。它如此易于阅读，以至于我相信您已经可以判断出来（无需进一步解释）这里有两个食谱，每个食谱都有一个ID、名称和描述。
- en: 'Here are a few notes on JSON syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于JSON语法的注意事项：
- en: Arrays are enclosed by `[]`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组被`[]`包围
- en: Objects can be represented by `{}`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以用`{}`表示
- en: Names/values always exist in pairs, and are delimited by "`:`"
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称/值总是成对存在，并由"`:`"分隔
- en: Strings are enclosed by ""
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串被""包围
- en: 'Following is a sample code file with JSON syntax:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有JSON语法的示例代码文件：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: HTTP Status Codes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: An HTTP status code is a code that is returned in the HTTP protocol. It is usually
    hidden from users, so you probably didn't realize it exists. In fact, every HTTP
    response from the server contains a status code. And as we construct our RESTful
    API, we need to comply with the HTTP protocol. The status code helps the frontend
    client understand the status of their request, that is, whether it is a success
    or failure. For example, there could be a client request about creating a record
    in the backend database. In that case, once the database record has been successfully
    created, the server should return an HTTP status code 201 (Created). If there
    is an error (such as a syntax error in the JSON document), the server should return
    an HTTP status code 400 (Bad Request) instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码是在HTTP协议中返回的代码。它通常对用户隐藏，所以你可能没有意识到它的存在。事实上，来自服务器的每个HTTP响应都包含一个状态码。在我们构建RESTful
    API时，我们需要遵守HTTP协议。状态码帮助前端客户端了解请求的状态，即成功或失败。例如，可能有一个关于在后端数据库中创建记录的客户端请求。在这种情况下，一旦数据库记录成功创建，服务器应返回HTTP状态码201（已创建）。如果有错误（例如JSON文档中的语法错误），服务器应返回HTTP状态码400（错误请求）。
- en: Commonly used HTTP Status Codes
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用HTTP状态码
- en: 'Let''s discuss some commonly used status codes. They are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些常用的状态码。它们如下：
- en: 200 OK means the request has been successful. The request could be a GET, PUT,
    or PATCH.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 200 OK表示请求已成功。请求可以是GET、PUT或PATCH。
- en: 201 Created means the POST request has been successful and a record has been
    created.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 201 已创建表示POST请求已成功，并已创建记录。
- en: 204 No Content means the DELETE request has been successful.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 204 无内容表示DELETE请求已成功。
- en: 400 Bad Request means there is something wrong with the client request. For
    example, there is a syntax error in the JSON format.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 错误请求表示客户端请求有误。例如，JSON格式中有语法错误。
- en: 401 Unauthorized means the client request is missing authentication details.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 401 未授权表示客户端请求缺少认证信息。
- en: 403 Forbidden means the requested resource is forbidden.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 403 禁止访问表示请求的资源被禁止访问。
- en: 404 Not Found means the requested resource doesn't exist.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 未找到表示请求的资源不存在。
- en: Open API
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放API
- en: Open API is a third-party API that is open to use. There are plenty of them
    available out there. Companies are eager to open their APIs to expand their user
    base but at the same time keep their source code proprietary. These APIs can be
    accessible by us as well. Let's take a look at some of the APIs from Facebook.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 开放API是一个对第三方开放的API。市面上有很多这样的API。公司渴望开放他们的API以扩大用户基础，同时保持他们的源代码为私有。这些API我们也可以访问。让我们看看一些来自Facebook的API。
- en: For example, we can use the HTTP GET method to access `https://graph.facebook.com/{page_id}/feed`,
    which will give us the feeds on the Facebook page with `ID = {page_id}`. We can
    send an HTTP request using the `POST` method to `https://graph.facebook.com/{page_id}/feed`,
    and then we can create a post on the Facebook page with `ID = {page_id}`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用HTTP GET方法访问`https://graph.facebook.com/{page_id}/feed`，这将给我们提供`ID
    = {page_id}`的Facebook页面的动态。我们可以通过使用`POST`方法向`https://graph.facebook.com/{page_id}/feed`发送HTTP请求，然后在`ID
    = {page_id}`的Facebook页面上创建一个帖子。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The Facebook fans page API details can be found at [https://developers.facebook.com/docs/pages/publishing](https://developers.facebook.com/docs/pages/publishing).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook粉丝页面API详情可在[https://developers.facebook.com/docs/pages/publishing](https://developers.facebook.com/docs/pages/publishing)找到。
- en: 'Now, let''s look at another internet giant, Google. Google also provides some
    Gmail APIs that we can use to manage the email labels in our mailbox. Here is
    a screenshot from the Gmail API documentation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个互联网巨头，谷歌。谷歌也提供了一些我们可以用来管理邮箱中电子邮件标签的Gmail API。以下是Gmail API文档的截图：
- en: '![Figure 1.3: Gmail API documentation'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：Gmail API文档'
- en: '](img/C15309_01_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_01_03.jpg)'
- en: 'Figure 1.3: Gmail API documentation'
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：Gmail API文档
- en: Note
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The Gmail Label API is available at [https://developers.google.com/gmail/api/v1/reference/](https://developers.google.com/gmail/api/v1/reference/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Gmail标签API可在[https://developers.google.com/gmail/api/v1/reference/](https://developers.google.com/gmail/api/v1/reference/)找到。
- en: The Flask Web Framework
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask Web 框架
- en: Flask is a web framework that we can use to easily build a web application.
    Web applications usually need some core functionalities, such as interacting with
    client requests, routing URLs to resources, rendering web pages, and interacting
    with backend databases. A web application framework such as Flask provides the
    necessary packages, modules that do the heavy lifting. So, as a developer, we
    only need to focus on the actual application logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 是一个我们可以用来轻松构建网络应用程序的网络框架。网络应用程序通常需要一些核心功能，例如与客户端请求交互、将 URL 路由到资源、渲染网页以及与后端数据库交互。像
    Flask 这样的网络应用程序框架提供了必要的包、模块，它们负责繁重的工作。因此，作为开发者，我们只需要关注实际的应用逻辑。
- en: There are, of course, other available web frameworks available on the market.
    One strong competitor of Flask is Django. It is also a Python web framework. The
    reason why we choose Flask in this book is that Flask is minimalistic. It is regarded
    as a micro-web-framework that only provides the absolutely essential packages
    for developers to start with. Because of that, it is easy to learn and is great
    for beginners.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，市场上还有其他可用的网络框架。Flask 的一个强大竞争对手是 Django。它也是一个 Python 网络框架。我们选择在本书中使用 Flask
    的原因是因为 Flask 是简约的。它被视为一个仅提供开发者起步所需的绝对必要包的微网络框架。正因为如此，它易于学习，非常适合初学者。
- en: And later, if we want to build further functions, there is a vast number of
    Flask extensions. You will see the power of Flask as we progress in this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果我们想构建更多的功能，有大量的 Flask 扩展可供选择。随着我们在本书中的学习深入，您将看到 Flask 的强大之处。
- en: Building a Simple Recipe Management Application
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建简单的菜谱管理应用程序
- en: 'Let''s do some simple exercises to test your knowledge. We are going to build
    a recipe-sharing platform throughout this book, and the API is the interface we
    expose to the public. We will first define what functions we want to provide and
    the corresponding URLs. These are the basic functions that we will probably need:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些简单的练习来测试你的知识。我们将在这本书中构建一个菜谱分享平台，API 是我们向公众公开的接口。我们首先定义我们想要提供的函数和相应的 URL。这些是我们可能需要的最基本的功能：
- en: '![Figure 1.4: HTTP methods and functions'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4：HTTP 方法与函数'
- en: '](img/C15309_01_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_01_04.jpg)'
- en: 'Figure 1.4: HTTP methods and functions'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.4：HTTP 方法与函数
- en: A typical recipe should have the following attributes
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的菜谱应该具有以下属性
- en: '`ID`: The unique identifier for the recipe'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`：菜谱的唯一标识符'
- en: '`Name`: The name of the recipe'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：菜谱的名称'
- en: '`Description`: The description of the recipe'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`：菜谱的描述'
- en: We are going to build an API that lists all the recipes stored in our system.
    The API will be designed to return different results with different URLs. For
    example, `http://localhost:5000/recipes` is going to give us all the recipes stored
    in our system, while `http://localhost:5000/recipes/20` will give us the recipe
    with `ID = 20`. Upon successful recipe retrieval, we will also see the HTTP status
    is set to 200 (OK). This indicates that our request has been successful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个 API，列出存储在我们系统中的所有菜谱。该 API 将设计为根据不同的 URL 返回不同的结果。例如，`http://localhost:5000/recipes`
    将给我们系统中存储的所有菜谱，而 `http://localhost:5000/recipes/20` 将给我们 `ID = 20` 的菜谱。在成功检索菜谱后，我们还将看到
    HTTP 状态设置为 200（OK）。这表明我们的请求已成功。
- en: When we create a new recipe, we use the HTTP POST method to query `http://localhost:5000/recipes`
    with all the necessary parameters to describe our recipe in JSON format. The JSON
    format is simply a key/value pair. If our request is successful, the recipe will
    be created in the backend and will return HTTP status 201 (Created). Together
    with the HTTP status, it will also send the recipe that has just been created
    in JSON format.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的菜谱时，我们使用 HTTP POST 方法，将所有必要的参数以 JSON 格式查询 `http://localhost:5000/recipes`
    来描述我们的菜谱。JSON 格式简单来说就是键/值对。如果我们的请求成功，菜谱将在后端创建，并将返回 HTTP 状态 201（已创建）。与 HTTP 状态一起，它还将以
    JSON 格式发送刚刚创建的菜谱。
- en: When we update a recipe, we use the HTTP PUT method to send the data to `http://localhost:5000/recipes/20`
    with all the necessary parameters for the updated recipe in JSON format. If our
    request is successful, the recipe will be updated in the backend and it will return
    HTTP status 200 (OK). Together with the HTTP status, it will also send the updated
    recipe in JSON format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新一个菜谱时，我们使用 HTTP PUT 方法，将更新菜谱的所有必要参数以 JSON 格式发送到 `http://localhost:5000/recipes/20`。如果我们的请求成功，菜谱将在后端更新，并将返回
    HTTP 状态 200（OK）。与 HTTP 状态一起，它还将以 JSON 格式发送更新的菜谱。
- en: When we delete a recipe, we can use the HTTP Delete method to send the data
    to `http://localhost:5000/recipes/20`. This will remove the recipe with `ID =
    20`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们删除一个菜谱时，我们可以使用 HTTP Delete 方法将数据发送到 `http://localhost:5000/recipes/20`。这将删除
    `ID = 20` 的菜谱。
- en: Now you know where we are heading to, let's roll up our sleeves and get our
    hands dirty!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道我们将要走向何方，让我们挽起袖子，大干一场吧！
- en: Virtual Environment
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: It is always recommended for developers to develop their application inside
    a virtual environment instead of directly on their local environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者始终建议在虚拟环境中开发他们的应用程序，而不是直接在本地环境中开发。
- en: The reason is that virtual environments are independent application development
    environments. We can create multiple virtual environments on a local machine,
    and these virtual environments can have their own version of Python, their own
    packages, their own environment variables, and so on. These virtual environments
    won't interfere with each other even though they are built on the same local machine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是虚拟环境是独立的应用程序开发环境。我们可以在本地机器上创建多个虚拟环境，这些虚拟环境可以有自己的 Python 版本、自己的包、自己的环境变量等等。尽管它们建立在同一台本地机器上，但这些虚拟环境之间不会相互干扰。
- en: In the following exercise, we will create a development project in the PyCharm
    IDE. We will show you how to set up a virtual environment for this project in
    PyCharm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将在 PyCharm IDE 中创建一个开发项目。我们将向您展示如何在 PyCharm 中为该项目设置虚拟环境。
- en: 'Exercise 1: Building Our First Flask Application'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1：构建我们的第一个 Flask 应用程序
- en: 'We are going to build our first Flask application in this exercise. You will
    realize how simple it is to build an application along the way. PyCharm is a great
    **integrated development environment** (**IDE**) with a nice GUI that will make
    our development process easier. We will learn about the workflow of application
    development, including the creation of the application project and installing
    the necessary Python packages:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建我们的第一个 Flask 应用程序。您将意识到构建应用程序是多么简单。PyCharm 是一个优秀的 **集成开发环境**（**IDE**），拥有友好的
    GUI，这将使我们的开发过程更加容易。我们将学习应用程序开发的流程，包括创建应用程序项目和安装必要的 Python 包：
- en: 'Create a new project in PyCharm with `basic-api`. PyCharm will automatically
    help us to create a virtual environment for this new project.![Figure 1.5: Creating
    a new project'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `basic-api` 在 PyCharm 中创建一个新项目。PyCharm 将自动帮助我们为这个新项目创建一个虚拟环境。![图 1.5：创建新项目
- en: '](img/C15309_01_05.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.5](img/C15309_01_05.jpg)'
- en: 'Figure 1.5: Creating a new project'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.5：创建新项目
- en: It's a good practice for projects to run on their own assigned independent virtual
    environments, so these projects can run on different packages and they won't affect
    each other.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于项目在自己的分配的独立虚拟环境中运行来说，这是一个好的做法，这样这些项目就可以在不同的包上运行，而不会相互影响。
- en: Install the necessary packages in our virtual environment. To do that, we can
    create a file named `requirements.txt` in our project and type in the following
    text. We want to install `Flask` (version `1.0.3`) and `httpie` (version `1.0.2):`
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的虚拟环境中安装必要的包。为此，我们可以在项目中创建一个名为 `requirements.txt` 的文件，并输入以下文本。我们想要安装 `Flask`（版本
    `1.0.3`）和 `httpie`（版本 `1.0.2`）：
- en: '[PRE1]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Following screenshot shows the installation of Flask and httpie in `requirements.txt`:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了在 `requirements.txt` 中安装 Flask 和 httpie：
- en: '![Figure 1.6: Installing Flask and httpie in requirements.txt'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.6：在 requirements.txt 中安装 Flask 和 httpie'
- en: '](img/C15309_01_06.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.6](img/C15309_01_06.jpg)'
- en: 'Figure 1.6: Installing Flask and httpie in requirements.txt'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.6：在 requirements.txt 中安装 Flask 和 httpie
- en: PyCharm is going to prompt us on the missing package, as shown in the screenshot.
    Clicking on `app.py`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PyCharm 将会提示我们缺少的包，如图所示。点击 `app.py`。
- en: Note
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To install the Python packages, we can also run the `pip install -r requirements.txt`
    command in Terminal. It will yield the same result.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要安装 Python 包，我们也可以在终端中运行 `pip install -r requirements.txt` 命令。它会产生相同的结果。
- en: The Flask package that we are installing is a web micro-framework. It is extremely
    lightweight and allows us to build a web service with just a few lines of code.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在安装的 Flask 包是一个网络微框架。它非常轻量级，只需几行代码就可以构建一个网络服务。
- en: 'Let''s type in the following code in `app.py`, then *right-click* on the filename
    of `app.py` in the left panel, and select `app` to execute our first web service
    in Flask:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `app.py` 中输入以下代码，然后在左侧面板中右键点击 `app.py` 的文件名，选择 `app` 来执行我们第一个 Flask 网络服务：
- en: '[PRE2]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What this does is it first imports the Flask package in `app.py`, then it instantiates
    a `Flask` object, and finally, it assigns it to the `app` variable. We have created
    the main function as the entry point for our startup script. This subsequently
    brings up the Flask web server. After that, we have defined our first API function,
    `hello`, which returns a "`Hello World`" response. Using the Flask decorator,
    we can route the GET request URL to this function.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码首先在 `app.py` 中导入 Flask 包，然后实例化一个 `Flask` 对象，最后将其分配给 `app` 变量。我们已创建主函数作为启动脚本的人口点。这随后启动了
    Flask web 服务器。之后，我们定义了我们的第一个 API 函数 `hello`，它返回一个 "`Hello World`" 响应。使用 Flask
    装饰器，我们可以将 GET 请求 URL 路由到这个函数。
- en: 'Now open the browser and type `http://localhost:5000`, You will see the string
    **Hello World!**. No special format, just plaintext. This means your first web
    service passed the test, it works!![Figure 1.7: Browser showing Hello World in
    plaintext'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开浏览器并输入 `http://localhost:5000`，你会看到字符串 **Hello World**！没有特殊格式，只是纯文本。这意味着你的第一个
    web 服务通过了测试，它工作！！[图 1.7：浏览器以纯文本形式显示 Hello World
- en: '](img/C15309_01_07.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_01_07.jpg)'
- en: 'Figure 1.7: Browser showing Hello World in plaintext'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.7：浏览器以纯文本形式显示 Hello World
- en: This is a very good start! Though this web service merely returns the plain
    text string, we can build a lot of stuff on top of that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的开始！尽管这个 web 服务仅仅返回纯文本字符串，但我们可以在此基础上构建很多东西。
- en: I hope you can see how simple it is to build a web service using Flask; it is
    literally just a few lines of code. In fact, there are more Flask extensions out
    there that can help us build fancy functions. And be patient, we will talk about
    that in the subsequent chapters. For now, let's stay simple and get ourselves
    familiar with Flask first.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能看到使用 Flask 构建一个 web 服务是多么简单；实际上，这只需要几行代码。实际上，还有更多的 Flask 扩展可以帮助我们构建复杂的函数。要有耐心，我们将在后续章节中讨论这一点。现在，让我们保持简单，首先熟悉一下
    Flask。
- en: For production-grade applications, data is usually stored in a database. We
    haven't looked at how to interact with the database yet, so for now, we are going
    to simply store them in memory. Since we are building a recipe sharing platform,
    we will be creating two recipes in our next exercise, and we'll let them live
    in the memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产级应用，数据通常存储在数据库中。我们还没有查看如何与数据库交互，所以现在我们将简单地存储在内存中。由于我们正在构建一个食谱分享平台，我们将在下一个练习中创建两个食谱，并将它们存储在内存中。
- en: 'Exercise 2: Managing Recipes with Flask'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：使用 Flask 管理食谱
- en: 'In this exercise, we are going to work on our recipe management application
    with Flask. We will implement functionality to get recipes, to create recipes,
    and to update recipes. Without further ado, let''s get started:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Flask 来构建我们的食谱管理应用。我们将实现获取食谱、创建食谱和更新食谱的功能。无需多言，让我们开始吧：
- en: Note
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the complete code, please refer to [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的代码，请参阅 [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02)。
- en: 'First, clean up `app.py` and start everything all over again, import the packages
    that we need for this web service from the preceding code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，清理 `app.py` 并从头开始，从前面的代码中导入我们需要的这个 web 服务包：
- en: '[PRE3]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The jsonify package here is to convert our Python objects (such as a list) to
    JSON format. It will also change the content type in our HTTP response to application/json.
    Simply put, it takes care of the heavy lifting of converting to JSON format for
    us.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的 jsonify 包是用来将我们的 Python 对象（如列表）转换为 JSON 格式的。它还会将我们的 HTTP 响应的内容类型更改为 application/json。简单来说，它为我们处理了转换为
    JSON 格式的繁重工作。
- en: 'Then we import the `HTTPStatus` enum, which includes different HTTP statuses:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们导入 `HTTPStatus` 枚举，它包括不同的 HTTP 状态：
- en: '[PRE4]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For instance, we will have `HTTPStatus.CREATED (201)` and `HTTPStatus.NOT_FOUND
    (404)`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们将有 `HTTPStatus.CREATED (201)` 和 `HTTPStatus.NOT_FOUND (404)`。
- en: Create an instance of the `Flask` class
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Flask` 类的实例
- en: '[PRE5]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Define the recipes list. We store two recipes in the list. They are stored in
    the memory
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义食谱列表。我们在列表中存储两个食谱。它们存储在内存中
- en: '[PRE6]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the route decorator to tell Flask that the `/recipes` route will route
    to the `get_recipes` function, and the `methods = [''GET'']` argument to specify
    that the route decorator will only respond to GET requests:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用路由装饰器告诉 Flask `/recipes` 路由将路由到 `get_recipes` 函数，并使用 `methods = ['GET']` 参数指定路由装饰器将只响应
    GET 请求：
- en: '[PRE7]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that if we don't specify methods argument, the default will still
    be only responding to GET requests.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，如果我们没有指定方法参数，默认情况下仍然只会响应 GET 请求。
- en: 'After that, use the `jsonify` function to convert the list of recipes to JSON
    format and respond to the client:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用 `jsonify` 函数将菜谱列表转换为 JSON 格式，并响应客户端：
- en: '[PRE8]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After getting a specific recipe, if you only want to retrieve one specific recipe,
    then use the `/recipes/<int:recipe_id>` route to trigger the `get_recipe(recipe_id)`
    function.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取特定菜谱后，如果您只想检索一个特定的菜谱，请使用 `/recipes/<int:recipe_id>` 路由来触发 `get_recipe(recipe_id)`
    函数。
- en: '[PRE9]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The syntax `<int:recipe_id>` syntax means the value in the route will be assigned
    to the integer variable id integer variable and can be used in the function. Our
    function `get_recipe(recipe_id)` function will then loop through the whole "`recipes`"
    list and locate the recipe that has the id that we are looking for. If that recipe
    exists, then we will return it.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<int:recipe_id>` 语法表示路由中的值将被分配给整数变量 `id`，并可以在函数中使用。我们的 `get_recipe(recipe_id)`
    函数将遍历整个 "`recipes`" 列表，找到具有我们正在寻找的 ID 的菜谱。如果该菜谱存在，则返回它。'
- en: 'Take a closer look at our `get_recipe` function. Get the next recipe in the
    loop by using `recipe = next((recipe for recipe in recipes if recipe[''id''] ==
    recipe_id), None)`. Here, the line `for recipe in recipes` iterates through all
    the recipes in our recipe collection and finds out the recipe with `id = recipe_id`.
    Once we have found it, we store it in the iterator and retrieve it using the next
    function. If there is no such recipe with that ID, `None` will be returned:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细查看我们的 `get_recipe` 函数。通过使用 `recipe = next((recipe for recipe in recipes if
    recipe['id'] == recipe_id), None)` 来获取循环中的下一个菜谱。在这里，`for recipe in recipes` 这行代码遍历了我们菜谱集合中的所有菜谱，并找出具有
    `id = recipe_id` 的菜谱。一旦找到，我们就将其存储在迭代器中，并使用 `next` 函数检索它。如果没有找到具有该 ID 的菜谱，则返回 `None`：
- en: '[PRE10]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will work on the `create_recipe` function, which creates a recipe
    in memory. Use the `/recipes` route to the `create_recipe` function and the "`methods
    = [POST]`" argument to specify that the route decorator will only respond to POST
    requests:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理 `create_recipe` 函数，该函数在内存中创建菜谱。使用 `/recipes` 路由到 `create_recipe` 函数，并使用
    "`methods = [POST]`" 参数指定路由装饰器将只响应 POST 请求：
- en: '[PRE11]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, use the `request.get_json` method to get the name and description
    from the client POST request. These two values together with a self-incremented
    id that we generate will be stored in the recipe (dictionary object) and then
    appended to our recipes list. At this point in time, the recipe is created and
    stored:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用 `request.get_json` 方法从客户端 POST 请求中获取名称和描述。这两个值以及我们生成的自增 ID 将存储在菜谱（字典对象）中，然后追加到我们的菜谱列表中。此时，菜谱已创建并存储：
- en: '[PRE12]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, return the recipe that has just been created in JSON format, together
    with an **HTTP 201 (CREATED)** status. The following code highlights this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以 JSON 格式返回刚刚创建的菜谱，并带有 **HTTP 201 (已创建)** 状态。以下代码突出了这一点：
- en: '[PRE13]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next part of code is about updating recipes. Again, use the same line of
    code here, `recipe = next((recipe for recipe in recipes if recipe[''id''] == recipe_id),
    None)` to get the recipe with a specific ID:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一部分代码是关于更新菜谱的。同样，在这里使用相同的代码行，`recipe = next((recipe for recipe in recipes if
    recipe['id'] == recipe_id), None)` 来获取具有特定 ID 的菜谱：
- en: '[PRE14]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next few lines of code say that if we can''t find the recipe, we will return
    a `recipe not found` message in JSON format, together with a `HTTP NOT_FOUND`
    status:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码表示如果我们找不到菜谱，我们将以 JSON 格式返回 `recipe not found` 消息，并带有 `HTTP NOT_FOUND` 状态：
- en: '[PRE15]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we found the recipe, then perform the `recipe.update` function, and put
    in the new name and description you get from the client request:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到了菜谱，那么执行 `recipe.update` 函数，并输入从客户端请求中获取的新名称和描述：
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we convert the updated recipe to JSON format using the `jsonify` function
    and return together with a default HTTP status **200 (OK)**. The following code
    highlights this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `jsonify` 函数将更新的菜谱转换为 JSON 格式，并与其一起返回，带有默认的 HTTP 状态 **200 (OK)**。以下代码突出了这一点：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last few lines of code in our program is for starting up the Flask server:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们程序中最后几行代码是用于启动 Flask 服务器：
- en: '[PRE18]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the code is done, *right-click* on the `app.py` file and click **run**
    to start the application. The Flask server will be started up and our application
    is ready to be tested. The full code looks like this:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码完成后，*右键单击* `app.py` 文件并点击**运行**以启动应用程序。Flask服务器将启动，我们的应用程序准备进行测试。完整的代码如下所示：
- en: '[PRE19]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 1.8: The final Flask server'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8：最终的Flask服务器'
- en: '](img/C15309_01_08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_01_08.jpg)'
- en: 'Figure 1.8: The final Flask server'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.8：最终的Flask服务器
- en: In the following sections, we will show you how to test your web service using
    curl/httpie or Postman.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将向您展示如何使用curl/httpie或Postman测试您的网络服务。
- en: Using curl or httpie to Test All the Endpoints
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用curl或httpie测试所有端点
- en: In this section, we will go through ways to test the API service endpoints in
    our recipe management application using Command Prompt. Testing is a very important
    step in application development. This is to ensure the functions we developed
    are working as expected. We can use curl or httpie, depending on your personal
    preference. In the subsequent exercise, we will show you both tools.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用命令提示符测试我们的食谱管理应用程序中的API服务端点。测试是应用程序开发中的一个非常重要的步骤。这是为了确保我们开发的功能按预期工作。我们可以使用curl或httpie，具体取决于您的个人偏好。在随后的练习中，我们将向您展示这两个工具。
- en: Curl (or cURL) is a command-line tool that can transfer data using URLs. We
    can use this tool to send requests to our API endpoints and examine the response.
    If you are running on macOS, you don't need to install curl. It is pre-installed
    in the system and you can find it in Terminal. You can also run it in the Terminal
    in PyCharm. However, if you are running on Windows, you need to download and install
    it for free from [http://curl.haxx.se/download.html](http://curl.haxx.se/download.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Curl（或cURL）是一个可以使用URL传输数据的命令行工具。我们可以使用这个工具向我们的API端点发送请求并检查响应。如果您正在macOS上运行，您不需要安装curl。它已预安装在系统中，您可以在终端中找到它。您也可以在PyCharm的终端中运行它。但是，如果您正在Windows上运行，您需要免费下载并安装它，请访问[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)。
- en: Httpie (aych-tee-tee-pie) is another command-line client that does a similar
    thing. It was built with the goal to improve the communication between the CLI
    (command-line interface) and the web. It is pretty user-friendly. For more details
    about httpie, please refer to [https://httpie.org/](https://httpie.org/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Httpie（aych-tee-tee-pie）是另一个执行类似功能的命令行客户端。它旨在改善CLI（命令行界面）与网络之间的通信。它非常用户友好。有关httpie的更多详细信息，请参阅[https://httpie.org/](https://httpie.org/)。
- en: We added `httpie==1.0.2` in our requirements.txt previously, so PyCharm should
    have already installed it for us. The main benefit of having httpie is it will
    beautifully format the JSON document, making it more readable. And believe me,
    that will save us a lot of time when we move on to verifying the HTTP response
    from the server.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在`requirements.txt`中添加了`httpie==1.0.2`，所以PyCharm应该已经为我们安装了它。拥有httpie的主要好处是它将美观地格式化JSON文档，使其更易于阅读。并且请相信我，当我们继续验证来自服务器的HTTP响应时，这将为我们节省大量时间。
- en: 'Exercise 3: Testing Our API Endpoints with httpie and curl'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：使用httpie和curl测试我们的API端点
- en: 'In this exercise, we are going to use httpie and curl to test our API endpoints.
    We will test the functions of getting all the recipes back from the server, and
    also creating/updating the recipes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用httpie和curl来测试我们的API端点。我们将测试从服务器获取所有菜谱的功能，以及创建/更新菜谱：
- en: 'We will first open the Terminal in PyCharm. It is located at the bottom of
    the application. It will look as shown in the following screenshot:![Figure 1.9:
    PyCharm Terminal'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将在PyCharm中打开终端。它位于应用程序的底部。它看起来如下所示：![图1.9：PyCharm终端
- en: '](img/C15309_01_09.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_01_09.jpg)'
- en: 'Figure 1.9: PyCharm Terminal'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：PyCharm终端
- en: 'Type in the following httpie command to get the recipes from our API endpoint,
    [`http://localhost:5000/recipes`](http://localhost:5000/recipes); we will be using
    the HTTP GET method here:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下httpie命令以从我们的API端点获取菜谱，[`http://localhost:5000/recipes`](http://localhost:5000/recipes)；在这里我们将使用HTTP
    GET方法：
- en: '[PRE20]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you prefer to do it the curl way, use the following command instead. Note
    that we have different parameters here: `-i` is for showing the header in the
    response and `-X` is for specifying the HTTP method. We will be using `GET` here:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用curl的方式，请使用以下命令代替。请注意，这里我们有不同的参数：`-i`用于显示响应中的头部信息，`-X`用于指定HTTP方法。在这里我们将使用`GET`：
- en: '[PRE21]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE22]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, let''s create a recipe. This time, use the HTTP `POST` method,
    as we have lots of information that cannot be encoded in the URL. Please take
    a look at the following httpie command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个食谱。这次，使用HTTP `POST`方法，因为我们有大量信息无法编码在URL中。请查看以下httpie命令：
- en: '[PRE23]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And then following is the curl command. The -H here is to specify the header
    in the request. Put in `Content-Type: application/json`, as we are going to send
    over the details of the new recipe in JSON format. The `-d` here is to specify
    the HTTP `POST` data, which is our new recipe:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后下面是curl命令。这里的`-H`是用来指定请求中的头部的。输入`Content-Type: application/json`，因为我们将要发送新的食谱详情，格式为JSON。这里的`-d`是用来指定HTTP
    `POST`数据，即我们的新食谱：'
- en: '[PRE24]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `@app.route(''/recipes'', methods=[''POST''])` in the backend to catch
    this client request and invoke the `create_recipe` function. It will get the recipe
    details from the client request and save it to a list in the application memory.
    Once the recipe is successfully stored in the memory, it will return an HTTP status
    of `201 CREATED`, and the new recipe will also be returned in the HTTP response
    for us to verify:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后端中的`@app.route('/recipes', methods=['POST'])`用于捕获这个客户端请求并调用`create_recipe`函数。它将从客户端请求中获取食谱详情并将其保存到应用程序内存中的列表中。一旦食谱成功存储在内存中，它将返回HTTP状态`201
    CREATED`，并且新的食谱也将作为HTTP响应返回，以便我们进行验证：
- en: '[PRE25]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, get all the recipes again to verify if our previous recipe was really
    created successfully. We expect to receive three recipes in the response now:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次获取所有食谱以验证我们之前的食谱是否真的成功创建。我们现在期望在响应中接收到三个食谱：
- en: '[PRE26]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Use either one of the preceding commands. They do the same thing, which is to
    trigger the `get_recipes` function and get us all the recipes currently stored
    in the application memory in JSON format.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述命令中的任何一个。它们做的是同一件事，即触发`get_recipes`函数，并获取当前存储在应用程序内存中的所有食谱的JSON格式。
- en: 'In the following response, we can see that the HTTP header is saying OK, and
    the Content-Length is now slightly longer than our previous response, that is,
    `252` bytes. This makes sense because we are expecting to see one more recipe
    in the response. The Content-Type is again `application/json`, with the body storing
    the recipes in JSON format. Now we can see our new recipe with ID `3`:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下响应中，我们可以看到HTTP头部表示OK，并且Content-Length现在略长于我们之前的响应，即`252`字节。这是有道理的，因为我们期望在响应中看到另一个食谱。Content-Type仍然是`application/json`，其中正文以JSON格式存储食谱。现在我们可以看到我们的新食谱，ID为`3`：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Cool! So far, we are in pretty good shape. Now, test our application by trying
    to modify the recipe with ID 3\. Use the HTTP `PUT` method and send over the modified
    name and description of the recipe to `localhost:5000/recipes/3`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太酷了！到目前为止，我们的状态相当不错。现在，通过尝试修改ID为3的食谱来测试我们的应用程序。使用HTTP `PUT`方法，将修改后的食谱名称和描述发送到`localhost:5000/recipes/3`：
- en: '[PRE28]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the curl command. Again, `-H` is to specify the header in
    the HTTP request, and we are setting that to `"Content-Type: application/json"`;
    `-d` is to specify that our data should be in JSON format:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '下面的curl命令。同样，`-H`是用来指定HTTP请求中的头部的，我们将它设置为`"Content-Type: application/json"`；`-d`是用来指定我们的数据应该以JSON格式：'
- en: '[PRE29]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If things are working properly, then the client request will be caught by the
    `@app.route(''/recipes/<int:recipe_id>'', methods=[''PUT''])` route. It will then
    invoke the `update_recipe(recipe_id)` function to look for the recipe with the
    passed-in `recipe_id`, update it, and return it. Together with the updated recipe
    in JSON format, we will also receive the HTTP status of `OK` (`200`):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，那么客户端请求将被`@app.route('/recipes/<int:recipe_id>', methods=['PUT'])`路由捕获。然后它将调用`update_recipe(recipe_id)`函数来查找传递的`recipe_id`对应的食谱，更新它，并返回。我们将收到更新后的食谱的JSON格式，以及HTTP状态`OK`（`200`）：
- en: '[PRE30]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alright, all good so far. Now, go on and see if we can get a particular recipe.
    To do this, send a request to `localhost:5000/recipes/3` to get the recipe with
    ID `3`, and confirm whether our previous update was successful:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利。现在，继续看看我们是否可以获取特定的食谱。为此，向`localhost:5000/recipes/3`发送请求以获取ID为`3`的食谱，并确认我们之前的更新是否成功：
- en: '[PRE31]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also use a `curl` command:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用`curl`命令：
- en: '[PRE32]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The application will look for the recipe with the `recipe_id` and return it
    in JSON format, together with an HTTP status of `200 OK`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将寻找具有`recipe_id`的食谱，并以JSON格式返回它，同时返回HTTP状态`200 OK`：
- en: '[PRE33]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, what if we try a recipe ID that we know doesn''t exist? How will the application
    behave? Test it out with the httpie command as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试一个我们知道不存在的食谱ID，应用程序会如何表现？使用以下httpie命令进行测试：
- en: '[PRE34]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Alternatively, use the following `curl` command, which will do the same thing
    as in the preceding code:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下 `curl` 命令，它将执行与前面代码相同的功能：
- en: '[PRE35]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly, `@app.route(''/recipes/<int:recipe_id>'', methods=[''GET''])` in
    the application will catch this client request and try to look for the recipe
    with ID = 101\. The application will return with an HTTP status of `message: "recipe
    not found"` in JSON format:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '类似地，应用程序中的 `@app.route(''/recipes/<int:recipe_id>'', methods=[''GET''])` 将捕获这个客户端请求并尝试查找
    ID 为 101 的食谱。应用程序将以 JSON 格式返回 HTTP 状态 `message: "recipe not found"`：'
- en: '[PRE36]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If your application passed the test, congratulations! It is a pretty solid implementation.
    You can choose to perform more tests by yourself if you want to.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序通过了测试，恭喜您！这是一个相当稳固的实现。如果您想的话，可以选择自行进行更多测试。
- en: Postman
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman
- en: A Postman is a handy tool for API testing. It has a user-friendly GUI that we
    can send HTTP requests through. It allows us to send requests with different HTTP
    methods (that is, GET, POST, PUT, and DELETE) and we can check the response from
    the server. With this tool, we can easily test our API by sending a client request
    and checking the HTTP response. We can also save our test cases and group them
    into different collections.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个方便的 API 测试工具。它有一个用户友好的图形用户界面，我们可以通过它发送 HTTP 请求。它允许我们使用不同的 HTTP 方法（即
    GET、POST、PUT 和 DELETE）发送请求，并且我们可以检查来自服务器的响应。使用这个工具，我们可以通过发送客户端请求并检查 HTTP 响应来轻松测试我们的
    API。我们还可以保存我们的测试用例并将它们分组到不同的集合中。
- en: The Postman GUI
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman 图形用户界面
- en: We assume you should have already installed Postman by following the steps in
    the preface. When you open Postman, you should see the screen shown in the following
    screenshot. The left-hand side is a navigation panel for you to navigate through
    your historical or saved requests. In Postman, your requests are going to be organized
    into collections, which is like a folder in the filesystem. You can put relevant
    saved requests in the same collection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经按照前言中的步骤安装了 Postman。当您打开 Postman 时，您应该看到以下截图所示的屏幕。左侧是一个导航面板，用于您浏览历史或保存的请求。在
    Postman 中，您的请求将被组织到集合中，就像文件系统中的文件夹一样。您可以将相关的保存请求放在同一个集合中。
- en: The top panel is for you to compose your request. As you have learned from the
    command-line testing tool, we can have different HTTP verbs (such as GET and PUT).
    We also need to put in an API endpoint to send the request to. For some requests,
    you may also need to pass in additional parameters. These can all be done in Postman.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部面板用于您编写请求。如您从命令行测试工具中学到的，我们可以有不同的 HTTP 动词（如 GET 和 PUT）。我们还需要输入 API 端点以发送请求。对于某些请求，您可能还需要传递额外的参数。所有这些都可以在
    Postman 中完成。
- en: 'The bottom panel shows the server response:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 底部面板显示了服务器响应：
- en: '![Figure 1.10: Postman interface'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10：Postman 界面'
- en: '](img/C15309_01_10.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_01_10.jpg)'
- en: 'Figure 1.10: Postman interface'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.10：Postman 界面
- en: Sending a GET Request
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送 GET 请求
- en: 'Sending a GET request is simple; we just need to fill in the target URL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 GET 请求很简单；我们只需要填写目标 URL：
- en: Select `GET` as our HTTP method in the drop-down list.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中选择我们的 HTTP 方法为 **GET**。
- en: Enter the request URL (such as `http://localhost:5000/API1`).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入请求 URL（例如 `http://localhost:5000/API1`）。
- en: Click the **Send** button.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 按钮。
- en: Sending a POST Request
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送 POST 请求
- en: 'Sending a POST request, however, will take a bit more work, because very often,
    we will put extra data in the request. For example, if you want to send some JSON
    data to an API endpoint, you can do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 POST 请求需要做更多的工作，因为通常我们会在请求中放入额外的数据。例如，如果您想向 API 端点发送一些 JSON 数据，可以执行以下操作：
- en: Select **POST** as our HTTP method in the drop-down list.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉列表中选择我们的 HTTP 方法为 **POST**。
- en: Enter the request URL (such as `http://localhost:5000/API2`).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入请求 URL（例如 `http://localhost:5000/API2`）。
- en: Select the **Body** Tab. Also, select the "**raw**" radio button.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **正文** 选项卡。同时，选择“**raw**”单选按钮。
- en: 'Choose "**JSON (application/json)**" from the right drop-down menu. Put in
    the JSON data to the Body content area:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧下拉菜单中选择“**JSON (application/json)**”。将 JSON 数据放入正文内容区域：
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Click the **Send** button.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 按钮。
- en: Saving a Request
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存请求
- en: Very often, you will want to save your request for later use. This saving feature
    in Postman is particularly useful during regression testing. To save your request,
    you just need to click the save button, follow the on-screen instructions, and
    save it in a collection. Then you will see your saved request in the left navigation
    panel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，您可能希望保存请求以供以后使用。Postman 中的此保存功能在回归测试期间特别有用。要保存请求，您只需点击保存按钮，遵循屏幕上的说明，并将其保存到集合中。然后您将在左侧导航面板中看到您保存的请求。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to open an account in Postman before you can save the request.
    Please follow the on-screen instructions accordingly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够保存请求之前，可能需要在 Postman 中创建一个账户。请按照屏幕上的说明操作。
- en: If you want to learn more about Postman, click on the "Bootcamp" button at the
    bottom of Postman. You will see interactive tutorials showing you how to use Postman
    step-by-step on the screen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 Postman 的信息，请点击 Postman 底部的“训练营”按钮。您将在屏幕上看到交互式教程，逐步向您展示如何使用 Postman。
- en: 'Activity 1: Sending Requests to Our APIs Using Postman'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 1：使用 Postman 向我们的 API 发送请求
- en: 'Now that we have learned how to use Postman, we are going to test our application
    using Postman instead of the curl/httpie command-line testing tools. In this activity,
    we will be using this tool to test the CRUD functions in our web service:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用 Postman，我们将使用 Postman 而不是 curl/httpie 命令行测试工具来测试我们的应用程序。在这个活动中，我们将使用此工具来测试我们网络服务的
    CRUD 功能：
- en: Create a request in Postman and get all the recipes.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Postman 中创建一个请求并获取所有菜谱。
- en: Use a `POST` request to create a recipe.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `POST` 请求创建菜谱。
- en: Create a request to get all the recipes.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取所有菜谱的请求。
- en: Send an update request to modify the recipe that we have just created.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送更新请求以修改我们刚刚创建的菜谱。
- en: Send a request to get a specific recipe.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求以获取特定的菜谱。
- en: Send a request to search for a recipe that doesn't exist.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求以搜索一个不存在的菜谱。
- en: Note
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 286.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 286 页找到。
- en: If your application passed the test, congratulations! It is a pretty solid implementation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序通过了测试，恭喜您！这是一个相当稳健的实现。
- en: 'Exercise 4: Automated Testing Using Postman'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：使用 Postman 进行自动化测试
- en: 'In this exercise, we would like to show you how we can use Postman as a powerful
    automatic testing tool. An automatic testing tool allows us to repeatedly send
    requests to the APIs, thus achieve testing automation. Postman allows us to do
    this. We can save historical requests in a collection so that you can reuse the
    same test cases next time:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们想向您展示如何使用 Postman 作为一款强大的自动测试工具。自动测试工具允许我们反复向 API 发送请求，从而实现测试自动化。Postman
    允许我们这样做。我们可以将历史请求保存到集合中，以便您下次可以重用相同的测试用例：
- en: 'Hover the cursor over the request; the **Save Request** button will appear:![Figure
    1.11: Saving the request'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在请求上；将出现**保存请求**按钮：![图 1.11：保存请求
- en: '](img/C15309_01_11.jpg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_01_11.jpg)'
- en: 'Figure 1.11: Saving the request'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.11：保存请求
- en: 'Click on the Save Request button, and you will see a dialog box popping up,
    asking for more information. Type in **Get all recipes** for the request name
    and click on **Create Collection** at the bottom. Then, type in **Basic API**
    as the collection name and tick to confirm. Click **Save to Basic API**:![Figure
    1.12: Putting in information for saving the request'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“保存请求”按钮，您将看到一个对话框弹出，要求输入更多信息。将请求名称输入为**获取所有菜谱**，然后在底部点击**创建集合**。然后，将集合名称输入为**基本
    API**并勾选以确认。点击**保存到基本 API**：![图 1.12：输入保存请求的信息
- en: '](img/C15309_01_12.jpg)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_01_12.jpg)'
- en: 'Figure 1.12: Putting in information for saving the request'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.12：输入保存请求的信息
- en: 'The collection will then be created. Now, save our request to this collection
    for future use. We can also click on the **Collections** tab to see all the requests
    in that collection:![Figure 1.13: Creating the new collection'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合将随后创建。现在，将我们的请求保存到此集合以供将来使用。我们还可以点击**集合**选项卡来查看该集合中的所有请求：![图 1.13：创建新集合
- en: '](img/C15309_01_13.jpg)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_01_13.jpg)'
- en: 'Figure 1.13: Creating the new collection'
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.13：创建新集合
- en: Now we have a bunch of saved requests in our collection. Next time, if we make
    any changes in our application, we can rerun these tests to make sure the previously
    developed APIs are still working fine. This is called regression testing in the
    developer community. And Postman is a simple yet powerful tool for us to perform
    such testing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们收集中有许多已保存的请求。下次，如果我们对我们的应用程序进行任何更改，我们可以重新运行这些测试以确保之前开发的 API 仍然运行良好。这在开发者社区中被称为回归测试。Postman
    是我们执行此类测试的一个简单而强大的工具。
- en: 'Activity 2: Implement and Test the delete_recipe Function'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：实现并测试 delete_recipe 函数
- en: Now we have a basic understanding of how to implement the API. We have coded
    the create and update recipe functions. In this activity, you will implement the
    `delete_recipe` function yourself.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何实现 API 有了一个基本了解。我们已经编写了创建和更新食谱的函数。在本活动中，你将亲自实现 `delete_recipe` 函数。
- en: 'You have learned about both the command-line and GUI testing tools. You will
    test the application using these tools after the implementation. This is what
    you need to do:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了命令行和 GUI 测试工具。在实现之后，你将使用这些工具测试应用程序。你需要做的是：
- en: Implement a `delete_recipe` function in `app.py` that can delete a specific
    recipe. Create the API endpoint accordingly.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中实现一个 `delete_recipe` 函数，可以删除特定的食谱。相应地创建 API 端点。
- en: Start the application, make it ready for testing.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，使其准备就绪以进行测试。
- en: Use httpie or curl to delete the recipe with `ID = 1`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 httpie 或 curl 删除 `ID = 1` 的食谱。
- en: Use Postman to delete the recipe with `ID = 2`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Postman 删除 `ID = 2` 的食谱。
- en: Note
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 291.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 291 页找到。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built a basic RESTful API using Flask. We did CRUD
    (Create, Read, Update, Delete) operations on our recipes, and through this, you
    should have grasped the concepts and fundamentals of APIs. We have also talked
    about relevant concepts, such as HTTP methods, HTTP status codes, JSON, and routing.
    We wrapped up the chapter by showing you different ways (command prompt, GUI)
    to test the web services that we have built.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Flask 构建了一个基本的 RESTful API。我们在我们的食谱上执行了 CRUD（创建、读取、更新、删除）操作，通过这个过程，你应该已经掌握了
    API 的概念和基础。我们还讨论了相关概念，例如 HTTP 方法、HTTP 状态码、JSON 和路由。我们通过向您展示测试我们构建的 Web 服务不同方式（命令提示符、GUI）来结束本章。
- en: After laying a good foundation, in the next chapter, we will continue to develop
    our recipe sharing platform step by step. You will learn the whole process of
    RESTful API development. Just stay with us, the best is yet to come!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在打下良好基础之后，在下一章中，我们将逐步开发我们的食谱分享平台。你将学习 RESTful API 开发的整个过程。只需继续跟随我们，最好的还在后面！
