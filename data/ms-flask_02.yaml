- en: Chapter 2. Creating Models with SQLAlchemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用SQLAlchemy创建模型
- en: As previously stated, **models** are a means of abstracting and giving a common
    interface to data. In most web applications, data is stored and retrieved from
    a **Relational Database Management System** (**RDBMS**), which is a database that
    holds data in a tabular format with rows and columns and is able to compare data
    across tables. Some examples include MySQL, Postgres, Oracle, and MSSQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**模型**是一种抽象和给数据提供一个通用接口的方式。在大多数Web应用程序中，数据存储和检索是通过**关系数据库管理系统**（**RDBMS**）进行的，这是一个以行和列的表格格式存储数据并能够在表格之间比较数据的数据库。一些例子包括MySQL，Postgres，Oracle和MSSQL。
- en: In order to create models on top of our database, we will use a Python package
    named **SQLAlchemy**. SQLAlchemy is a database API at its lowest level and performs
    **Object Relational Mapping** (**ORM**) at its highest level. An ORM is a technique
    to pass and convert data between two sources with different types of systems and
    data structures. In this case, it converts data between the large amount of types
    in databases versus the mix of types and objects in Python. Also, a programming
    language such as Python allows you to have different objects that hold references
    to each other, and get and set their attributes. An ORM, such as SQLAlchemy, helps
    translate that into a traditional database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的数据库上创建模型，我们将使用一个名为**SQLAlchemy**的Python包。SQLAlchemy在其最低级别是一个数据库API，并在其最高级别执行**对象关系映射**（**ORM**）。ORM是一种在不同类型的系统和数据结构之间传递和转换数据的技术。在这种情况下，它将数据库中大量类型的数据转换为Python中类型和对象的混合。此外，像Python这样的编程语言允许您拥有不同的对象，这些对象相互引用，并获取和设置它们的属性。ORM，如SQLAlchemy，有助于将其转换为传统数据库。
- en: In order to tie SQLAlchemy into our application context, we will use Flask SQLAlchemy.
    Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that provides useful
    defaults and Flask-specific functions. If you are already familiar with SQLAlchemy,
    then you are free to use it without Flask SQLAlchemy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将SQLAlchemy与我们的应用程序上下文联系起来，我们将使用Flask SQLAlchemy。Flask SQLAlchemy是SQLAlchemy的一个便利层，提供了有用的默认值和特定于Flask的函数。如果您已经熟悉SQLAlchemy，那么您可以在没有Flask
    SQLAlchemy的情况下自由使用它。
- en: By the end of this chapter, we will have a full database schema of our blogging
    application as well as models interacting with that schema.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个完整的博客应用程序的数据库架构，以及与该架构交互的模型。
- en: Setting up SQLAlchemy
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SQLAlchemy
- en: In order to follow along in this chapter, you will need a running database if
    you do not already have one. If you have never installed a database or you do
    not have a preference, SQLite is the best option for beginners.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中跟进，如果您还没有运行的数据库，您将需要一个。如果您从未安装过数据库，或者您没有偏好，SQLite是初学者的最佳选择。
- en: '**SQLite** is a SQL that is fast, works without a server, and is entirely contained
    in one file. Also, SQLite is natively supported in python. If you choose to go
    with SQLite, a SQLite database will be created for you in the *Our first model*
    section.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLite**是一种快速的SQL，无需服务器即可工作，并且完全包含在一个文件中。此外，SQLite在Python中有原生支持。如果您选择使用SQLite，将在*我们的第一个模型*部分为您创建一个SQLite数据库。'
- en: Python packages
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python包
- en: 'To install Flask SQLAlchemy with `pip`, run the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pip`安装Flask SQLAlchemy，请运行以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also need to install specific packages for the database you chose to
    use that will act as the connector for SQLAlchemy. SQLite users can skip this
    step:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装特定的数据库包，用于作为SQLAlchemy的连接器。SQLite用户可以跳过此步骤：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Flask SQLAlchemy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask SQLAlchemy
- en: 'Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy
    creates its database connection through a special database URI. This is a string
    that looks like a URL that contains all the information that SQLAlchemy needs
    to connect. It takes the general form of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以抽象化我们的数据之前，我们需要设置Flask SQLAlchemy。SQLAlchemy通过特殊的数据库URI创建其数据库连接。这是一个看起来像URL的字符串，包含SQLAlchemy连接所需的所有信息。它的一般形式如下：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For each driver you installed previously, the URI would be:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您之前安装的每个驱动程序，URI将是：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our `config.py` file, add the URI to the `DevConfig` file with:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`config.py`文件中，使用以下方式将URI添加到`DevConfig`文件中：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our first model
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个模型
- en: You may have noted that we did not actually create any tables in our database
    to abstract off of. This is because SQLAlchemy allows us to create either models
    from tables or tables from our models. This will be covered after we create the
    first model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们实际上没有在我们的数据库中创建任何表来进行抽象。这是因为SQLAlchemy允许我们从表中创建模型，也可以从我们的模型中创建表。这将在我们创建第一个模型后进行介绍。
- en: 'In our `main.py` file, SQLAlchemy must first be initialized with our app as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.py`文件中，必须首先使用以下方式初始化SQLAlchemy：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'SQLAlchemy will read our app''s configuration and automatically connect to
    our database. Let''s create a `User` model to interact with a user table in the
    `main.py` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy将读取我们应用程序的配置，并自动连接到我们的数据库。让我们在`main.py`文件中创建一个`User`模型，以与用户表进行交互：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What have we accomplished? We now have a model that is based on a user table
    with three columns. When we inherit from `db.Model`, the entire connection and
    communication with the database will be already handled for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了什么成就？我们现在有一个基于用户表的模型，有三列。当我们从`db.Model`继承时，与数据库的整个连接和通信将已经为我们处理。
- en: 'Each class variable that is the `db.Column` instance represents a column in
    the database. There is an optional first argument in a `db.Column` instance that
    allows us to specify the name of the column in the database. Without it, SQLAlchemy
    assumes that the name of the variable is the same as the name of the column. Using
    this, optional variable would look like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`db.Column`实例的类变量代表数据库中的一列。`db.Column`实例中有一个可选的第一个参数，允许我们指定数据库中列的名称。如果没有，SQLAlchemy会假定变量的名称与列的名称相同。使用这个可选变量会看起来像这样：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second argument to `db.Column` tells SQLAlchemy what type the column should
    be treated as. The main types that we will work with in this book are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Column`的第二个参数告诉SQLAlchemy应将该列视为什么类型。本书中我们将使用的主要类型是：'
- en: '`db.String`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.String`'
- en: '`db.Text`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Text`'
- en: '`db.Integer`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Integer`'
- en: '`db.Float`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Float`'
- en: '`db.Boolean`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Boolean`'
- en: '`db.Date`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Date`'
- en: '`db.DateTime`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.DateTime`'
- en: '`db.Time`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.Time`'
- en: What each type represents is rather simple. The `String` and `Text` types take
    Python strings and translate them to the `varchar` and `text` type columns, respectively.
    The `Integer` and `Float` types take any Python number and translate them into
    the correct type before inserting them into the database. Boolean takes Python
    `True` or `False` statements and if the database has a `boolean` type, inserts
    a Boolean into the database. If there is no `boolean` type in the database, SQLAlchemy
    automatically translates between Python Booleans and a 0 or a 1 in the database.
    The `Date`, `DateTime`, and `Time` types use the Python types of the same name
    from the `datetime` native library and translate them into the database. The `String`,
    `Integer`, and `Float` types take an extra argument that tells SQLAlchemy the
    length limit on our column.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型代表的含义都相当简单。`String`和`Text`类型接受Python字符串并将它们分别转换为`varchar`和`text`类型的列。`Integer`和`Float`类型接受任何Python数字并在将它们插入数据库之前将它们转换为正确的类型。布尔类型接受Python的`True`或`False`语句，并且如果数据库有`boolean`类型，则将布尔值插入数据库。如果数据库中没有`boolean`类型，SQLAlchemy会自动在Python布尔值和数据库中的0或1之间进行转换。`Date`、`DateTime`和`Time`类型使用`datetime`本地库中同名的Python类型，并将它们转换为数据库中的类型。`String`、`Integer`和`Float`类型接受一个额外的参数，告诉SQLAlchemy我们列的长度限制。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you wish to truly understand how SQLAlchemy translates your code into SQL
    queries, add the following to the `DevConfig` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望真正了解SQLAlchemy如何将您的代码转换为SQL查询，请将以下内容添加到`DevConfig`文件中：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will print out the created queries to the terminal. You may wish to turn
    this feature off as you get further along in the book, as dozens of queries could
    be printed to the terminal every page load.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端上打印出创建的查询。随着您在本书中的进展，您可能希望关闭此功能，因为每次加载页面时可能会打印出数十个查询。
- en: The argument `primary_key` tells SQLAlchemy that this column has the **primary
    key index** on it. Each SQLAlchemy model *requires* a primary key to function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`primary_key`告诉SQLAlchemy该列具有**主键索引**。每个SQLAlchemy模型*都需要*一个主键才能正常工作。
- en: SQLAlchemy will assume that the name of your table is the lowercase version
    of your model class name. However, what if we want our table to be called something
    other than *users*? To tell SQLAlchemy what name to use, add the `__tablename__`
    class variable. This is also how you connect to tables that already exist in your
    database. Just place the name of the table in the string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy将假定您的表名是模型类名的小写版本。但是，如果我们希望我们的表被称为除了*users*之外的其他名称呢？要告诉SQLAlchemy使用什么名称，请添加`__tablename__`类变量。这也是连接到已经存在于数据库中的表的方法。只需将表的名称放在字符串中。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don't have to include the `__init__` or `__repr__` functions. If we don't,
    then SQLAlchemy will automatically create an `__init__` function that accepts
    the names and values of your columns as keyword arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必包含`__init__`或`__repr__`函数。如果不包含，那么SQLAlchemy将自动创建一个接受列的名称和值作为关键字参数的`__init__`函数。
- en: Creating the user table
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户表
- en: 'Using SQLAlchemy to do the heavy lifting, we will now create the user table
    in our database. Update `manage.py` to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy来完成繁重的工作，我们现在将在数据库中创建用户表。更新`manage.py`为：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: From now on, whenever we create a new model, import it and add it to the returned
    `dict`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当我们创建一个新模型时，导入它并将其添加到返回的`dict`中。
- en: 'This will allow us to work with our models in the shell. Run the shell now
    and use `db.create_all()` to create all of the tables:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在shell中使用我们的模型。现在运行shell并使用`db.create_all()`来创建所有表：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should now see in your database a table called `users` with the columns
    specified. Also, if you are using SQLite, you should now see a file named `database.db`
    in your file structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在数据库中看到一个名为`users`的表以及指定的列。此外，如果您使用SQLite，您现在应该在文件结构中看到一个名为`database.db`的文件。
- en: CRUD
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD
- en: 'In every storage mechanism for data, there are four basic types of functions:
    **Create, Read, Update, and Delete** (**CRUD**). These allow all the basic ways
    of manipulating and viewing data needed for our web apps. To use these functions,
    we will use an object on the database named the **session**. Sessions will be
    explained later in the chapter, but for now, think of them as a storage location
    for all of our changes to the database.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据的每种存储机制，都有四种基本类型的函数：**创建、读取、更新和删除**（**CRUD**）。这些允许我们使用的所有基本方式来操作和查看我们的Web应用程序所需的数据。要使用这些函数，我们将在数据库上使用一个名为**session**的对象。会话将在本章后面进行解释，但现在，将其视为我们对数据库的所有更改的存储位置。
- en: Creating models
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'To create a new row in your database using our models, add the model to the
    `session` and `commit` objects. Adding an object to the session marks its changes
    for saving, and committing is when the session is saved to the database as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的模型在数据库中创建新行，请将模型添加到`session`和`commit`对象中。将对象添加到会话中标记其更改以进行保存，并且提交是将会话保存到数据库中的时候：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is simple to add a new row to our table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的表中添加新行非常简单。
- en: Reading models
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取模型
- en: After we have added data to our database, data can be queried using `Model.query`.
    For those who use SQLAlchemy, this is shorthand for `db.session.query(Model)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在向数据库添加数据后，可以使用`Model.query`来查询数据。对于使用SQLAlchemy的人来说，这是`db.session.query(Model)`的简写。
- en: For our first example, use `all()` to get all rows in the database as a list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个示例，使用`all()`来获取数据库中的所有行作为列表。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the number of items in the database increases, this query process becomes
    slower. In SQLAlchmey, as in SQL, we have the limit function to specify the total
    number of rows we wish to work with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库中的项目数量增加时，此查询过程变得更慢。在SQLAlchmey中，与SQL一样，我们有限制功能来指定我们希望处理的总行数。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, SQLAlchemy returns the records ordered by their primary keys. To
    control this, we have the `order_by` function, which is given as:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLAlchemy 返回按其主键排序的记录。要控制这一点，我们有 `order_by` 函数，它的用法是：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To return just one model, we use `first()` instead of `all()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回一个模型，我们使用 `first()` 而不是 `all()`：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To return one model by its primary key, use `query.get()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过其主键返回一个模型，使用 `query.get()`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All these functions are chainable, which means that they can be appending on
    to each other to modify the return result. Those of you who are fluent in JavaScript
    will find this syntax familiar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是可链式调用的，这意味着它们可以附加到彼此以修改返回结果。精通 JavaScript 的人会发现这种语法很熟悉。
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `first()` and `all()` methods return a value and therefore end the chain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`first()` 和 `all()` 方法返回一个值，因此结束了链式调用。'
- en: There is also a Flask SQLAlchemy-specific method that is called **pagination**,
    which can be used rather than `first()` or `all()`. This is a convenience method
    designed to enable the pagination feature that most websites use while displaying
    a long list of items. The first parameter defines which page the query should
    return to and the second parameter is the number of items per page. So, if we
    passed 1 and 10 as the parameters, the first 10 objects would be returned. If
    we instead passed 2 and 10, objects 11-20 would be returned, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个特定于 Flask SQLAlchemy 的方法叫做 **pagination**，可以用来代替 `first()` 或 `all()`。这是一个方便的方法，旨在启用大多数网站在显示长列表项目时使用的分页功能。第一个参数定义了查询应该返回到哪一页，第二个参数是每页的项目数。因此，如果我们传递
    1 和 10 作为参数，将返回前10个对象。如果我们传递 2 和 10，将返回对象11-20，依此类推。
- en: 'The pagination method is different from the `first()` and `all()` methods because
    it returns a pagination object rather than a list of models. For example, if we
    wanted to get the first 10 items of a fictional `Post` object for the first page
    in our blog:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 分页方法与 `first()` 和 `all()` 方法不同，因为它返回一个分页对象而不是模型列表。例如，如果我们想要获取博客中虚构的 `Post` 对象的第一页的前10个项目：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This object has several useful properties:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有几个有用的属性：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Filtering queries
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤查询
- en: 'Now we get to the actual power of SQL, that is, filtering results by a set
    of rules. To get a list of models that satisfy a set of equalities, we use the
    `query.filter_by` filter. The `query.filter_by` filter takes named arguments that
    represent the values we are looking for in each column in the database. To get
    a list of all users with a username of `fake_name`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了 SQL 的真正威力，即通过一组规则过滤结果。要获取满足一组相等条件的模型列表，我们使用 `query.filter_by` 过滤器。`query.filter_by`
    过滤器接受命名参数，这些参数代表我们在数据库中每一列中寻找的值。要获取所有用户名为 `fake_name` 的用户列表：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This example is filtering on one value, but multiple values can be passed to
    the `filter_by` filter. Just like our previous functions, `filter_by` is chainable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是在一个值上进行过滤，但多个值可以传递给 `filter_by` 过滤器。就像我们之前的函数一样，`filter_by` 是可链式调用的：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`query.filter_by` only works if you know the exact values that you are looking
    for. This is avoided by passing Python comparison statements to the query with
    `query.filter`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.filter_by` 只有在你知道你要查找的确切值时才有效。这可以通过将Python比较语句传递给 `query.filter` 来避免：'
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a simple example, but `query.filter` accepts any Python comparison.
    With common Python types, such as `integers`, `strings`, and `dates`, the `==`
    operator can be used for equality comparisons. If you had an `integer`, `float`,
    or `date` column, an inequality statement could also be passed with the `>`, `<`,
    `<=`, and `>=` operators.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但 `query.filter` 接受任何Python比较。对于常见的Python类型，比如 `整数`、`字符串` 和 `日期`，可以使用
    `==` 运算符进行相等比较。如果有一个 `整数`、`浮点数` 或 `日期` 列，也可以使用 `>`、`<`、`<=` 和 `>=` 运算符传递不等式语句。
- en: 'We can also translate complex SQL queries with SQLAlchemy functions. For example,
    to use `IN`, `OR`, or `NOT` SQL comparisons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用SQLAlchemy函数来转换复杂的SQL查询。例如，使用 `IN`、`OR` 或 `NOT` SQL 比较：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In SQLAlchemy, comparisons to `None` are translated to comparisons to `NULL`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，与 `None` 的比较会被转换为与 `NULL` 的比较。
- en: Updating models
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新模型
- en: 'To update the values of models that already exist, apply the `update` method
    to a query object, that is, before you return the models with a method such as
    `first()` or `all()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新已经存在的模型的值，将 `update` 方法应用到查询对象上，也就是说，在你使用 `first()` 或 `all()` 等方法返回模型之前：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deleting models
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除模型
- en: 'If we wish to remove a model from the database:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望从数据库中删除一个模型：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Relationships between models
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型之间的关系
- en: Relationships between models in SQLAlchemy are links between two or more models
    that allow models to reference each other automatically. This allows naturally
    related data, such as *comments to posts*, to be easily retrieved from the database
    with its related data. This is where the *R* in RDBMS comes from, and it gives
    this type of database a large amount of power.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 中模型之间的关系是两个或多个模型之间的链接，允许模型自动引用彼此。这允许自然相关的数据，比如 *评论到帖子*，可以轻松地从数据库中检索其相关数据。这就是关系型数据库管理系统中的
    *R*，它赋予了这种类型的数据库大量的能力。
- en: Let's create our first relation. Our blogging website is going to need some
    blog posts. Each blog post is going to be written by one user, so it makes sense
    to link posts back to the user that wrote them to easily get all posts by a user.
    This is an example of a **one-to-many** relationship.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个关系。我们的博客网站将需要一些博客文章。每篇博客文章将由一个用户撰写，因此将博客文章链接回撰写它们的用户是很有意义的，可以轻松地获取某个用户的所有博客文章。这是一个
    **一对多** 关系的例子。
- en: One-to-many
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多
- en: 'Let''s add a model to represent blog posts on our website:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个模型来代表我们网站上的博客文章：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the column `user_id`. Those who are familiar with RDBMSes will know that
    this represents a **Foreign Key Constraint**. Foreign Key Constraint is a rule
    in the database that forces the value of `user_id` to exist in the `id` column
    in the user table. This is a check in the database to make sure that `Post` will
    always refer to an existing user. The parameter to `db.ForeignKey` is a string
    representation of the `user_id` field. If you have decided to call your user table
    with `__table_name__`, you must change this string. This string is used rather
    than a direct reference with `User.id` because during initialization of SQLAlchemy,
    the `User` object might not exist yet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`user_id`列。熟悉RDBMS的人会知道这代表**外键约束**。外键约束是数据库中的一条规则，强制`user_id`的值存在于用户表中的`id`列中。这是数据库中的一个检查，以确保`Post`始终引用现有用户。`db.ForeignKey`的参数是`user_id`字段的字符串表示。如果决定用`__table_name__`来命名用户表，必须更改此字符串。在初始化SQLAlchemy时，使用此字符串而不是直接引用`User.id`，因为`User`对象可能尚不存在。
- en: 'The `user_id` column itself is not enough to tell SQLAlchemy that we have a
    relationship. We must modify our `User` model as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_id`列本身不足以告诉SQLAlchemy我们有一个关系。我们必须修改我们的`User`模型如下：'
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `db.relationship` function creates a virtual column in SQLAlchemy that connects
    with `db.ForeignKey` in our `Post` model. The first parameter is the name of the
    class that we are referencing. We will cover what `backref` does soon, but what
    is the `lazy` parameter? The `lazy` parameter controls how SQLAlchemy will load
    our related objects. `subquery` would load our relations as soon as our `Post`
    object is loaded. This cuts down the number of queries, but will slow down when
    the number of returned items grows larger. In contrast, with the `dynamic` option,
    the related objects will be loaded on access and can be filtered down before returning.
    This is best if the number of returned objects is or will become large.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.relationship`函数在SQLAlchemy中创建一个虚拟列，与我们的`Post`模型中的`db.ForeignKey`相连接。第一个参数是我们引用的类的名称。我们很快就会介绍`backref`的作用，但`lazy`参数是什么？`lazy`参数控制SQLAlchemy如何加载我们的相关对象。`subquery`会在加载我们的`Post`对象时立即加载我们的关系。这减少了查询的数量，但当返回的项目数量增加时，速度会变慢。相比之下，使用`dynamic`选项，相关对象将在访问时加载，并且可以在返回之前进行筛选。如果返回的对象数量很大或将变得很大，这是最好的选择。'
- en: 'We may now access the `User.posts` variable that will return a list of all
    the posts whose `user_id` field equals our `User.id`. Let''s try this now in our
    shell as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问`User.posts`变量，它将返回所有`user_id`字段等于我们的`User.id`的帖子的列表。让我们在shell中尝试一下：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we were not able to access our post from our relationship without
    committing our changes to the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有将更改提交到数据库，我们将无法访问我们的关系中的帖子。
- en: 'The parameter `backref` gives us the ability to access and set our `User` class
    via `Post.user`. This is given by:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`backref`参数使我们能够通过`Post.user`访问和设置我们的`User`类。这是由以下给出的：'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because `user.posts` is a list, we could have also added our `Post` model to
    the list to save it automatically:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`user.posts`是一个列表，我们也可以将我们的`Post`模型添加到列表中以自动保存它：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `backref` option as dynamic, we can treat our relation column as a
    query as well as a list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`backref`选项作为dynamic，我们可以将我们的关系列视为查询以及列表：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before we move on to our next relationship type, let''s add another model for
    user comments with a one-to-many relationship, which will be used in the book
    later on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个关系类型之前，让我们为用户评论添加另一个模型，它具有一对多的关系，稍后将在书中使用：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Many-to-many
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: 'What if we have two models that can reference each other, but each model needs
    to reference more than one of each type? For example, our blog posts will need
    tags in order for our users to easily group similar posts. Each tag can refer
    to many posts, but each post can have multiple tags. This type of relation is
    called a **many-to-many** relationship. Consider the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个可以相互引用的模型，但每个模型都需要引用每种类型的多个模型，该怎么办？例如，我们的博客帖子将需要标签，以便我们的用户可以轻松地将相似的帖子分组。每个标签可以指向多个帖子，但每个帖子可以有多个标签。这种类型的关系称为**多对多**关系。考虑以下示例：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `db.Table` object is a lower level access to the database than the abstraction
    of `db.Model`. The `db.Model` object rests on top of `db.Table` and provides a
    representation of specific rows in the table. The `db.Table` object is used because
    there is no need to access individual rows of the table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Table`对象是对数据库的低级访问，比`db.Model`的抽象更低。`db.Model`对象建立在`db.Table`之上，并提供了表中特定行的表示。使用`db.Table`对象是因为不需要访问表的单个行。'
- en: 'The `tags` variable is used to represent the `post_tags` table, which contains
    two rows: one that represents the id of a post, and another that represents the
    id of a tag. To illustrate how this works, if the table had the following data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`变量用于表示`post_tags`表，其中包含两行：一行表示帖子的id，另一行表示标签的id。为了说明这是如何工作的，如果表中有以下数据：'
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'SQLAlchemy would translate this to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy会将其转换为：
- en: A post with an id of `1` has the tags with ids of `1` and `3`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id为`1`的帖子具有id为`1`和`3`的标签
- en: A post with an id of `2` has the tags with ids of `3`, `4`, and `5`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id为`2`的帖子具有id为`3`、`4`和`5`的标签
- en: A post with an id of `3` has the tags with ids of `1` and `2`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id为`3`的帖子具有id为`1`和`2`的标签
- en: You may describe this data as easily as tags being related to posts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些数据描述为与帖子相关的标签。
- en: 'Before the `db.relationship` function sets up our relationship, but this time
    it has the secondary parameter. The secondary parameter tells SQLAlchemy that
    this relationship is stored in the tags table. Let''s see this in the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`db.relationship`函数设置我们的关系之前，但这次它有secondary参数。secondary参数告诉SQLAlchemy这个关系存储在tags表中。让我们看看下面的代码：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As given in the one-to-many relationship, the main relationship column is just
    a list. The main difference being that the `backref` option is now also a list.
    Because it''s a list, we may add posts to tags from the `tag` object as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一对多关系中，主关系列只是一个列表。主要区别在于`backref`选项现在也是一个列表。因为它是一个列表，我们可以从`tag`对象中向标签添加帖子，如下所示：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The convenience of SQLAlchemy sessions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy会话的便利性
- en: Now that you understand the power of SQLAlchemy, you can also understand what
    the SQLAlchemy session object is and why web apps should never be made without
    them. As stated before, the session can be simply described as an object that
    tracks the changes in our models and commits them to the database when we tell
    it to. However, there is a bit more to it than this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了SQLAlchemy的强大之处，也可以理解SQLAlchemy会话对象是什么，以及为什么Web应用程序不应该没有它们。正如之前所述，会话可以简单地描述为一个跟踪我们模型更改并在我们告诉它时将它们提交到数据库的对象。但是，它比这更复杂一些。
- en: First, the session is the handler for **transactions**. Transactions are sets
    of changes that are flushed to the database on commit. Transactions provide a
    lot of hidden functionality. For example, transactions automatically determine
    which objects will be saved first when objects have relations. You might have
    noted this when we were saving tags in the previous section. When we added tags
    to the posts, the session automatically knew to save the tags first despite the
    fact that we did not add it to be committed. If we are working with raw SQL queries
    and a database connection, we would have to keep track of which rows are related
    to which other rows to avoid saving a foreign key reference to an object that
    does not exist.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，会话是**事务**的处理程序。事务是在提交时刷新到数据库的一组更改。事务提供了许多隐藏的功能。例如，当对象具有关系时，事务会自动确定哪些对象将首先保存。您可能已经注意到了，在上一节中保存标签时。当我们将标签添加到帖子中时，会话自动知道首先保存标签，尽管我们没有将其添加到提交。如果我们使用原始SQL查询和数据库连接，我们将不得不跟踪哪些行与其他行相关，以避免保存对不存在的对象的外键引用。
- en: Transactions also automatically mark data as stale when changes to an object
    are saved to the database. When we access the object next, a query is made to
    the database to update the data, but all happens behind the scenes. If we were
    not using SQLAlchemy, we would also need to manually track which rows need to
    updated. If we want to be resource efficient, we only need to query and update
    those rows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事务还会在将对象的更改保存到数据库时自动将数据标记为陈旧。当我们下次访问对象时，将向数据库发出查询以更新数据，但所有这些都是在后台进行的。如果我们不使用SQLAlchemy，我们还需要手动跟踪需要更新的行。如果我们想要资源高效，我们只需要查询和更新那些行。
- en: Second, the session makes it impossible for there to be two different references
    to the same row in the database. This is accomplished by all queries going through
    the session (`Model.query` is actually `db.session.query(Model)`), and if the
    row has already been queried in this transaction, then the pointer to that object
    will be returned and not a new object. If this check did not exist, two objects
    that represent the same row could be saved to the database with different changes.
    This creates subtle bugs that might not be caught instantly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，会话使得不可能存在对数据库中同一行的两个不同引用。这是通过所有查询都经过会话来实现的（`Model.query`实际上是`db.session.query(Model)`），如果在此事务中已经查询了该行，则将返回指向该对象的指针，而不是一个新对象。如果没有这个检查，表示同一行的两个对象可能会以不同的更改保存到数据库中。这会产生微妙的错误，可能不会立即被发现。
- en: Keep in mind that Flask SQLAlchemy creates a new session for every request and
    discards any changes that were not committed at the end of the request, so always
    remember to save your work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Flask SQLAlchemy为每个请求创建一个新会话，并在请求结束时丢弃未提交的任何更改，因此请记住保存您的工作。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave
    a talk at PyCon Canada 2012\. Refer to *The SQLAlchemy Session - In Depth*, here—[https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解会话，SQLAlchemy的创建者Mike Bayer在2012年加拿大PyCon上发表了一次演讲。请参阅*SQLAlchemy会话-深入*，链接在这里-[https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo)。
- en: Database migrations with Alembic
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Alembic进行数据库迁移
- en: The functionality of web apps change all the time, and with new functionality,
    we need to change the structure of our database. Whether it's adding or dropping
    new columns, or creation of new tables, our models will change throughout the
    life cycle of our app. However, problems quickly arise when the database changes
    often. When moving our changes from development to production, how can you be
    sure that you carried over every change without manually comparing each model
    and its corresponding table? Let's say that you wish to go back in your Git history
    to see if some earlier version of your app had the same bug that you are now encountering
    in production. How will you change your database back to the correct schema without
    a lot of extra work?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的功能性不断变化，随着新功能的增加，我们需要改变数据库的结构。无论是添加或删除新列，还是创建新表，我们的模型都会在应用程序的生命周期中发生变化。然而，当数据库经常发生变化时，问题很快就会出现。在将我们的更改从开发环境移动到生产环境时，如何确保您在没有手动比较每个模型及其相应表的情况下携带了每个更改？假设您希望回到Git历史记录中查看您的应用程序的早期版本是否存在与您现在在生产环境中遇到的相同错误。在没有大量额外工作的情况下，您将如何将数据库更改回正确的模式？
- en: As programmers, we hate extra work. Thankfully, there is a tool called **Alembic**,
    which automatically creates and tracks database migrations from the changes in
    our SQLAlchemy models. **Database migrations** are records of all the changes
    of our schema. Alembic allows us to upgrade or downgrade our database to a specific
    saved version. Upgrading or downgrading by several versions will execute all the
    files between the two selected versions. The best part of Alembic is that its
    history files are only Python files. When we create our first migration, we can
    see how simple the Alembic syntax is.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们讨厌额外的工作。幸运的是，有一个名为**Alembic**的工具，它可以根据我们的SQLAlchemy模型的更改自动创建和跟踪数据库迁移。**数据库迁移**是我们模式的所有更改的记录。Alembic允许我们将数据库升级或降级到特定的保存版本。通过几个版本的升级或降级将执行两个选定版本之间的所有文件。Alembic最好的部分是它的历史文件只是Python文件。当我们创建我们的第一个迁移时，我们可以看到Alembic语法是多么简单。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alembic does not capture every possible change. For example, it does not record
    changes on the SQL indexes. After every migration, the reader is encouraged to
    review the migration file and make any necessary corrections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic并不捕获每一个可能的变化。例如，它不记录SQL索引的更改。在每次迁移之后，建议读者查看迁移文件并进行任何必要的更正。
- en: 'We won''t work directly with Alembic; instead, we will use **Flask-Migrate**,
    which is an extension created specifically for SQLAlchemy and works with Flask
    Script. To install it with `pip`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用Alembic；相反，我们将使用**Flask-Migrate**，这是专门为SQLAlchemy创建的扩展，并与Flask Script一起使用。要使用`pip`安装它：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To get started, we need to add the command to our `manage.py` file as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要将命令添加到我们的`manage.py`文件中，如下所示：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We initialized the `Migrate` object with our app and our SQLAlchemy instance,
    and we made the migrate command callable through `manage.py db`. To see a list
    of possible commands, run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的应用程序和我们的SQLAlchemy实例初始化了`Migrate`对象，并且通过`manage.py db`使迁移命令可调用。要查看可能的命令列表，请运行此命令：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To start tracking our changes, we use the `init` command as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始跟踪我们的更改，我们使用`init`命令如下：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will create a new folder in our directory named `migrations` that will
    hold all of our history. Now we start with our first migration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的目录中创建一个名为`migrations`的新文件夹，其中将保存我们的所有历史记录。现在我们开始进行我们的第一个迁移：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This command will cause Alembic to scan our SQLAlchemy object and find all the
    tables and columns that did not exist before this commit. As this is our first
    commit, the migration file will be rather long. Be sure to specify the migration
    message with `-m`, as it's the easiest way to identify what each migration is
    doing. Each migration file is stored in the `migrations/versions/` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将导致Alembic扫描我们的SQLAlchemy对象，并找到所有在此提交之前不存在的表和列。由于这是我们的第一个提交，迁移文件会相当长。一定要使用`-m`指定迁移消息，因为这是识别每个迁移在做什么的最简单方法。每个迁移文件都存储在`migrations/versions/`文件夹中。
- en: 'To apply the migration to your database and change your schema, run the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将迁移应用到您的数据库并更改模式，请运行以下命令：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To return to the previous version, find the version number with the `history`
    command and pass it to the `downgrade` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到以前的版本，使用`history`命令找到版本号，并将其传递给`downgrade`命令：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Like Git, a hash marks each migration. This is the main functionality of Alembic,
    but it is only surface level. Try to align your migrations with your Git commits
    in order to make it easier to downgrade or upgrade when reverting commits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Git一样，每个迁移都有一个哈希标记。这是Alembic的主要功能，但这只是表面层次。尝试将您的迁移与Git提交对齐，以便在还原提交时更容易降级或升级。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have data control mastered, we can now move on to displaying our
    data in our application. The next chapter, [Chapter 3](ch03.html "Chapter 3. Creating
    Views with Templates"), *Creating Views with Templates*, will dynamically cover
    creating HTML based on our models and adding models from our web interface.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了数据控制，我们现在可以继续在我们的应用程序中显示我们的数据。下一章，[第3章](ch03.html "第3章。使用模板创建视图") *使用模板创建视图*，将动态地涵盖根据我们的模型创建基于HTML的视图，并从我们的Web界面添加模型。
