- en: Chapter 11. Python Design Patterns II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。Python设计模式II
- en: 'In this chapter we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几种设计模式。我们将再次介绍经典的示例以及Python中的任何常见替代实现。我们将讨论：
- en: The adapter pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Lazy initialization and the flyweight pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化和享元模式
- en: The command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The abstract factory pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The composition pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: The adapter pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Unlike most of the patterns we reviewed in [Chapter 8](ch08.html "Chapter 8. Strings
    and Serialization"), *Strings and Serialization*, the adapter pattern is designed
    to interact with existing code. We would not design a brand new set of objects
    that implement the adapter pattern. Adapters are used to allow two pre-existing
    objects to work together, even if their interfaces are not compatible. Like the
    display adapters that allow VGA projectors to be plugged into HDMI ports, an adapter
    object sits between two different interfaces, translating between them on the
    fly. The adapter object's sole purpose is to perform this translation job. Adapting
    may entail a variety of tasks, such as converting arguments to a different format,
    rearranging the order of arguments, calling a differently named method, or supplying
    default arguments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第8章](ch08.html "第8章。字符串和序列化")中审查的大多数模式不同，*字符串和序列化*，适配器模式旨在与现有代码交互。我们不会设计一个全新的实现适配器模式的对象集。适配器用于允许两个现有对象一起工作，即使它们的接口不兼容。就像显示适配器允许VGA投影仪插入HDMI端口一样，适配器对象位于两个不同接口之间，实时进行翻译。适配器对象的唯一目的是执行这项翻译工作。适应可能涉及各种任务，例如将参数转换为不同的格式，重新排列参数的顺序，调用不同命名的方法或提供默认参数。
- en: 'In structure, the adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. Here it is in UML form:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构上，适配器模式类似于简化的装饰器模式。装饰器通常提供与它们替代的相同接口，而适配器在两个不同的接口之间进行映射。这是它的UML形式：
- en: '![The adapter pattern](images/8781OS_11_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![适配器模式](images/8781OS_11_01.jpg)'
- en: Here, **Interface1** is expecting to call a method called **make_action(some,
    arguments)**. We already have this perfect **Interface2** class that does everything
    we want (and to avoid duplication, we don't want to rewrite it!), but it provides
    a method called **different_action(other, arguments)** instead. The **Adapter**
    class implements the **make_action** interface and maps the arguments to the existing
    interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**Interface1**期望调用名为**make_action(some, arguments)**的方法。我们已经有了完美的**Interface2**类，它做了我们想要的一切（为了避免重复，我们不想重写它！），但它提供了一个名为**different_action(other,
    arguments)**的方法。**Adapter**类实现了**make_action**接口，并将参数映射到现有接口。
- en: The advantage here is that the code that maps from one interface to another
    is all in one place. The alternative would be really ugly; we'd have to perform
    the translation in multiple places whenever we need to access this code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，从一个接口到另一个接口的映射代码都在一个地方。另一种方法将非常丑陋；每当我们需要访问这段代码时，我们都必须在多个地方执行翻译。
- en: 'For example, imagine we have the following preexisting class, which takes a
    string date in the format "YYYY-MM-DD" and calculates a person''s age on that
    day:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们有以下现有类，它接受格式为“YYYY-MM-DD”的字符串日期并计算当天的人的年龄：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a pretty simple class that does what it's supposed to do. But we have
    to wonder what the programmer was thinking, using a specifically formatted string
    instead of using Python's incredibly useful built-in `datetime` library. As conscientious
    programmers who reuse code whenever possible, most of the programs we write will
    interact with `datetime` objects, not strings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类，它做了它应该做的事情。但是我们不得不想一下程序员在想什么，使用一个特定格式的字符串，而不是使用Python非常有用的内置`datetime`库。作为一名负责任的程序员，我们尽可能地重用代码，我们编写的大多数程序将与`datetime`对象交互，而不是字符串。
- en: We have several options to address this scenario; we could rewrite the class
    to accept `datetime` objects, which would probably be more accurate anyway. But
    if this class had been provided by a third party and we don't know or can't change
    its internal structure, we need to try something else. We could use the class
    as it is, and whenever we want to calculate the age on a `datetime.date` object,
    we could call `datetime.date.strftime('%Y-%m-%d')` to convert it to the proper
    format. But that conversion would be happening in a lot of places, and worse,
    if we mistyped the `%m` as `%M`, it would give us the current minute instead of
    the entered month! Imagine if you wrote that in a dozen different places only
    to have to go back and change it when you realized your mistake. It's not maintainable
    code, and it breaks the DRY principle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种选择来解决这种情况；我们可以重写类以接受`datetime`对象，这可能更准确。但是，如果这个类是由第三方提供的，我们不知道或无法更改其内部结构，我们需要尝试其他方法。我们可以使用现有的类，每当我们想要计算`datetime.date`对象上的年龄时，我们可以调用`datetime.date.strftime('%Y-%m-%d')`将其转换为正确的格式。但是这种转换会发生在很多地方，更糟糕的是，如果我们将`%m`误写为`%M`，它将给出当前分钟而不是输入的月份！想象一下，如果你在十几个不同的地方写了这个，只有在意识到错误时才能回去更改它。这不是可维护的代码，它违反了DRY原则。
- en: 'Instead, we can write an adapter that allows a normal date to be plugged into
    a normal `AgeCalculator` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以编写一个适配器，允许将普通日期插入普通的`AgeCalculator`类中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This adapter converts `datetime.date` and `datetime.time` (they have the same
    interface to `strftime`) into a string that our original `AgeCalculator` can use.
    Now we can use the original code with our new interface. I changed the method
    signature to `get_age` to demonstrate that the calling interface may also be looking
    for a different method name, not just a different type of argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适配器将`datetime.date`和`datetime.time`（它们对`strftime`有相同的接口）转换为我们原始的`AgeCalculator`可以使用的字符串。现在我们可以使用原始代码来使用我们的新接口。我将方法签名更改为`get_age`，以演示调用接口可能也在寻找不同的方法名，而不仅仅是不同类型的参数。
- en: 'Creating a class as an adapter is the usual way to implement this pattern,
    but, as usual, there are other ways to do it in Python. Inheritance and multiple
    inheritance can be used to add functionality to a class. For example, we could
    add an adapter on the `date` class so that it works with the original `AgeCalculator`
    class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类作为适配器是实现这种模式的常见方式，但通常情况下，在Python中还有其他方法可以实现。继承和多重继承可以用于向类添加功能。例如，我们可以在`date`类上添加一个适配器，以便它与原始的`AgeCalculator`类一起使用：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s code like this that makes one wonder if Python should even be legal.
    We have added a `split` method to our subclass that takes a single argument (which
    we ignore) and returns a tuple of year, month, and day. This works flawlessly
    with the original `AgeCalculator` class because the code calls `strip` on a specially
    formatted string, and `strip`, in that case, returns a tuple of year, month, and
    day. The `AgeCalculator` code only cares if `strip` exists and returns acceptable
    values; it doesn''t care if we really passed in a string. It really works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这样的代码让人怀疑Python是否应该合法。我们已经为我们的子类添加了一个`split`方法，它接受一个参数（我们忽略）并返回一个年、月和日的元组。这与原始的`AgeCalculator`类完美配合，因为代码在特殊格式的字符串上调用`strip`，而在这种情况下，`strip`返回一个年、月和日的元组。`AgeCalculator`代码只关心`strip`是否存在并返回可接受的值；它并不关心我们是否真的传入了一个字符串。它真的能工作：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It works but it's a stupid idea. In this particular instance, such an adapter
    would be hard to maintain. We'd soon forget why we needed to add a `strip` method
    to a `date` class. The method name is ambiguous. That can be the nature of adapters,
    but creating an adapter explicitly instead of using inheritance usually clarifies
    its purpose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它能工作，但这是一个愚蠢的想法。在这种特定情况下，这样的适配器很难维护。我们很快会忘记为什么需要向`date`类添加`strip`方法。方法名是模棱两可的。这可能是适配器的性质，但显式创建适配器而不是使用继承通常可以澄清其目的。
- en: Instead of inheritance, we can sometimes also use monkey-patching to add a method
    to an existing class. It won't work with the `datetime` object, as it doesn't
    allow attributes to be added at runtime, but in normal classes, we can just add
    a new method that provides the adapted interface that is required by calling code.
    Alternatively, we could extend or monkey-patch the `AgeCalculator` itself to replace
    the `calculate_age` method with something more amenable to our needs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可以使用猴子补丁来给现有的类添加方法，而不是继承。它不适用于`datetime`对象，因为它不允许在运行时添加属性，但在普通类中，我们可以添加一个新方法，以提供调用代码所需的适应接口。或者，我们可以扩展或猴子补丁`AgeCalculator`本身，以用更适合我们需求的方法替换`calculate_age`方法。
- en: Finally, it is often possible to use a function as an adapter; this doesn't
    obviously fit the actual design of the adapter pattern, but if we recall that
    functions are essentially objects with a `__call__` method, it becomes an obvious
    adapter adaptation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常可以将函数用作适配器；这显然不符合适配器模式的实际设计，但如果我们记得函数本质上是带有`__call__`方法的对象，它就成为一个明显的适配器适应。
- en: The facade pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'The facade pattern is designed to provide a simple interface to a complex system
    of components. For complex tasks, we may need to interact with these objects directly,
    but there is often a "typical" usage for the system for which these complicated
    interactions aren''t necessary. The facade pattern allows us to define a new object
    that encapsulates this typical usage of the system. Any time we want access to
    common functionality, we can use the single object''s simplified interface. If
    another part of the project needs access to more complicated functionality, it
    is still able to interact with the system directly. The UML diagram for the facade
    pattern is really dependent on the subsystem, but in a cloudy way, it looks like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在为复杂的组件系统提供一个简单的接口。对于复杂的任务，我们可能需要直接与这些对象交互，但通常系统有一个“典型”的用法，这些复杂的交互并不是必要的。外观模式允许我们定义一个新对象，封装了系统的典型用法。每当我们想要访问常见功能时，我们可以使用单个对象的简化接口。如果项目的另一部分需要访问更复杂的功能，它仍然可以直接与系统交互。外观模式的UML图表实际上取决于子系统，但在模糊的方式下，它看起来像这样：
- en: '![The facade pattern](images/8781OS_11_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![外观模式](images/8781OS_11_02.jpg)'
- en: A facade is, in many ways, like an adapter. The primary difference is that the
    facade is trying to abstract a simpler interface out of a complex one, while the
    adapter is only trying to map one existing interface to another.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 外观在许多方面类似于适配器。主要区别在于，外观试图从复杂的接口中抽象出一个简单的接口，而适配器只是试图将一个现有的接口映射到另一个接口。
- en: Let's write a simple facade for an e-mail application. The low-level library
    for sending e-mail in Python, as we saw in [Chapter 7](ch07.html "Chapter 7. Python
    Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*, is quite complicated.
    The two libraries for receiving messages are even worse.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一个电子邮件应用程序编写一个简单的外观。Python中用于发送电子邮件的低级库，正如我们在[第7章](ch07.html "第7章。Python面向对象的快捷方式")中看到的那样，*Python面向对象的快捷方式*，非常复杂。用于接收消息的两个库甚至更糟。
- en: 'It would be nice to have a simple class that allows us to send a single e-mail,
    and list the e-mails currently in the inbox on an IMAP or POP3 connection. To
    keep our example short, we''ll stick with IMAP and SMTP: two totally different
    subsystems that happen to deal with e-mail. Our facade performs only two tasks:
    sending an e-mail to a specific address, and checking the inbox on an IMAP connection.
    It makes some common assumptions about the connection, such as the host for both
    SMTP and IMAP is at the same address, that the username and password for both
    is the same, and that they use standard ports. This covers the case for many e-mail
    servers, but if a programmer needs more flexibility, they can always bypass the
    facade and access the two subsystems directly.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的类可以让我们发送单个电子邮件，并列出当前在IMAP或POP3连接中的收件箱中的电子邮件将是很好的。为了保持我们的示例简短，我们将坚持使用IMAP和SMTP：两个完全不同的子系统，碰巧处理电子邮件。我们的外观只执行两项任务：向特定地址发送电子邮件，并在IMAP连接上检查收件箱。它对连接做了一些常见的假设，比如SMTP和IMAP的主机位于同一地址，它们的用户名和密码相同，并且它们使用标准端口。这涵盖了许多电子邮件服务器的情况，但如果程序员需要更多的灵活性，他们可以绕过外观直接访问这两个子系统。
- en: 'The class is initialized with the hostname of the e-mail server, a username,
    and a password to log in:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用电子邮件服务器的主机名、用户名和密码进行初始化：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `send_email` method formats the e-mail address and message, and sends it
    using `smtplib`. This isn''t a complicated task, but it requires quite a bit of
    fiddling to massage the "natural" input parameters that are passed into the facade
    to the correct format to enable `smtplib` to send the message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_email`方法格式化电子邮件地址和消息，并使用`smtplib`发送它。这不是一个复杂的任务，但需要相当多的调整来将传递到外观中的“自然”输入参数转换为正确的格式，以使`smtplib`能够发送消息：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `if` statement at the beginning of the method is catching whether or not
    the `username` is the entire "from" e-mail address or just the part on the left
    side of the `@` symbol; different hosts treat the login details differently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法开头的`if`语句捕获了`username`是否是整个“from”电子邮件地址，还是`@`符号左侧的部分；不同的主机以不同的方式处理登录详细信息。
- en: 'Finally, the code to get the messages currently in the inbox is a ruddy mess;
    the IMAP protocol is painfully over-engineered, and the `imaplib` standard library
    is only a thin layer over the protocol:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取当前收件箱中的消息的代码是一团糟；IMAP协议过度设计，而`imaplib`标准库只是协议的薄层封装：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if we add all this together, we have a simple facade class that can send
    and receive messages in a fairly straightforward manner, much simpler than if
    we had to interact with these complex libraries directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把所有这些加在一起，我们就有了一个简单的外观类，可以以相当简单的方式发送和接收消息，比直接与这些复杂的库进行交互要简单得多。
- en: Although it is rarely named in the Python community, the facade pattern is an
    integral part of the Python ecosystem. Because Python emphasizes language readability,
    both the language and its libraries tend to provide easy-to-comprehend interfaces
    to complicated tasks. For example, `for` loops, `list` comprehensions, and generators
    are all facades into a more complicated iterator protocol. The `defaultdict` implementation
    is a facade that abstracts away annoying corner cases when a key doesn't exist
    in a dictionary. The third-party requests library is a powerful facade over less
    readable libraries for HTTP requests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Python社区中很少被命名，但外观模式是Python生态系统的一个组成部分。因为Python强调语言的可读性，语言及其库倾向于为复杂的任务提供易于理解的接口。例如，`for`循环，`list`推导和生成器都是对更复杂的迭代器协议的外观。`defaultdict`实现是一个外观，它在字典中键不存在时抽象掉烦人的边缘情况。第三方的requests库是一个强大的外观，可以覆盖不太可读的HTTP请求库。
- en: The flyweight pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少内存占用的设计模式
- en: The flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of them. This is often perfectly acceptable, but when developing larger
    applications with many related objects, paying attention to memory concerns can
    have a huge payoff.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 减少内存占用的设计模式是一种内存优化模式。初学者Python程序员往往忽视内存优化，认为内置的垃圾收集器会处理它们。这通常是可以接受的，但是在开发具有许多相关对象的较大应用程序时，关注内存问题可能会有巨大的回报。
- en: The flyweight pattern basically ensures that objects that share a state can
    use the same memory for that shared state. It is often implemented only after
    a program has demonstrated memory problems. It may make sense to design an optimal
    configuration from the beginning in some situations, but bear in mind that premature
    optimization is the most effective way to create a program that is too complicated
    to maintain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 减少内存占用的设计模式基本上确保共享状态的对象可以使用相同的内存来存储该共享状态。通常只有在程序表现出内存问题后才会实施它。在某些情况下，从一开始设计最佳配置可能是有意义的，但请记住，过早优化是创建一个过于复杂以至于无法维护的程序的最有效方式。
- en: 'Let''s have a look at the UML diagram for the flyweight pattern:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看减少内存占用的设计模式的UML图：
- en: '![The flyweight pattern](images/8781OS_11_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![减少内存占用的设计模式](images/8781OS_11_03.jpg)'
- en: Each **Flyweight** has no specific state; any time it needs to perform an operation
    on **SpecificState**, that state needs to be passed into the **Flyweight** by
    the calling code. Traditionally, the factory that returns a flyweight is a separate
    object; its purpose is to return a flyweight for a given key identifying that
    flyweight. It works like the singleton pattern we discussed in [Chapter 10](ch10.html
    "Chapter 10. Python Design Patterns I"), *Python Design Patterns I*; if the flyweight
    exists, we return it; otherwise, we create a new one. In many languages, the factory
    is implemented, not as a separate object, but as a static method on the `Flyweight`
    class itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**享元**都没有特定的状态；每当它需要对**特定状态**执行操作时，该状态需要被调用代码传递给**享元**。传统上，返回享元的工厂是一个单独的对象；它的目的是为了根据标识该享元的键返回一个享元。它的工作方式类似于我们在[第10章](ch10.html
    "第10章。Python设计模式I")中讨论的单例模式，*Python设计模式I*；如果享元存在，我们返回它；否则，我们创建一个新的。在许多语言中，工厂被实现为`Flyweight`类本身上的静态方法，而不是作为一个单独的对象。
- en: Think of an inventory system for car sales. Each individual car has a specific
    serial number and is a specific color. But most of the details about that car
    are the same for all cars of a particular model. For example, the Honda Fit DX
    model is a bare-bones car with few features. The LX model has A/C, tilt, cruise,
    and power windows and locks. The Sport model has fancy wheels, a USB charger,
    and a spoiler. Without the flyweight pattern, each individual car object would
    have to store a long list of which features it did and did not have. Considering
    the number of cars Honda sells in a year, this would add up to a huge amount of
    wasted memory. Using the flyweight pattern, we can instead have shared objects
    for the list of features associated with a model, and then simply reference that
    model, along with a serial number and color, for individual vehicles. In Python,
    the flyweight factory is often implemented using that funky `__new__` constructor,
    similar to what we did with the singleton pattern. Unlike singleton, which only
    needs to return one instance of the class, we need to be able to return different
    instances depending on the keys. We could store the items in a dictionary and
    look them up based on the key. This solution is problematic, however, because
    the item will remain in memory as long as it is in the dictionary. If we sold
    out of LX model Fits, the Fit flyweight is no longer necessary, yet it will still
    be in the dictionary. We could, of course, clean this up whenever we sell a car,
    but isn't that what a garbage collector is for?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下汽车销售的库存系统。每辆汽车都有一个特定的序列号和特定的颜色。但是关于那辆车的大部分细节对于特定车型的所有车辆来说都是相同的。例如，本田Fit
    DX车型是一辆几乎没有特色的车。LX车型有空调、倾斜、巡航和电动窗户和锁。Sport车型有时尚的轮毂、USB充电器和扰流板。如果没有享元模式，每个单独的汽车对象都必须存储一个长长的列表，其中包含它拥有或不拥有的功能。考虑到本田一年销售的汽车数量，这将导致大量的内存浪费。使用享元模式，我们可以为与车型相关的功能列表拥有共享对象，然后简单地引用该车型，以及序列号和颜色，用于单独的车辆。在Python中，享元工厂通常使用那个奇怪的`__new__`构造函数来实现，类似于我们在单例模式中所做的。与单例模式不同，单例模式只需要返回类的一个实例，我们需要能够根据键返回不同的实例。我们可以将项目存储在字典中，并根据键查找它们。然而，这种解决方案存在问题，因为只要项目在字典中，它就会一直保留在内存中。如果我们卖完了LX车型的Fit，那么Fit享元就不再需要了，但它仍然会留在字典中。当然，我们可以在卖车时清理它，但这不是垃圾收集器的作用吗？
- en: We can solve this by taking advantage of Python's `weakref` module. This module
    provides a `WeakValueDictionary` object, which basically allows us to store items
    in a dictionary without the garbage collector caring about them. If a value is
    in a weak referenced dictionary and there are no other references to that object
    stored anywhere in the application (that is, we sold out of LX models), the garbage
    collector will eventually clean up for us.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Python的`weakref`模块来解决这个问题。这个模块提供了一个`WeakValueDictionary`对象，基本上允许我们在字典中存储项目，而垃圾收集器不会关心它们。如果一个值在一个弱引用字典中，并且在应用程序的任何其他地方都没有对该对象的其他引用（也就是说，我们卖完了LX车型），垃圾收集器最终会为我们清理它。
- en: 'Let''s build the factory for our car flyweights first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为我们的汽车享元构建工厂：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Basically, whenever we construct a new flyweight with a given name, we first
    look up that name in the weak referenced dictionary; if it exists, we return that
    model; if not, we create a new one. Either way, we know the `__init__` method
    on the flyweight will be called every time, regardless of whether it is a new
    or existing object. Our `__init__` method can therefore look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每当我们用给定的名称构造一个新的享元时，我们首先在弱引用字典中查找该名称；如果存在，我们返回该模型；如果不存在，我们创建一个新的。无论哪种方式，我们都知道`__init__`方法在每次调用时都会被调用，无论它是一个新的还是现有的对象。因此，我们的`__init__`方法可以看起来像这样：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `if` statement ensures that we only initialize the object the first time
    `__init__` is called. This means we can call the factory later with just the model
    name and get the same flyweight object back. However, because the flyweight will
    be garbage-collected if no external references to it exist, we have to be careful
    not to accidentally create a new flyweight with null values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保我们只在第一次调用`__init__`时初始化对象。这意味着我们以后可以只用车型名称调用工厂，并得到相同的享元对象。然而，如果享元没有外部引用存在，它将被垃圾收集，我们必须小心不要意外地创建一个具有空值的新享元。'
- en: 'Let''s add a method to our flyweight that hypothetically looks up a serial
    number on a specific model of vehicle, and determines if it has been involved
    in any accidents. This method needs access to the car''s serial number, which
    varies from car to car; it cannot be stored with the flyweight. Therefore, this
    data must be passed into the method by the calling code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的享元添加一个方法，假设它查找特定车型的序列号，并确定它是否曾经参与过任何事故。这个方法需要访问汽车的序列号，这个序列号因汽车而异；它不能与享元一起存储。因此，这些数据必须由调用代码传递给方法：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can define a class that stores the additional information, as well as a
    reference to the flyweight:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个存储额外信息的类，以及对享元的引用：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also keep track of the available models as well as the individual cars
    on the lot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以跟踪可用模型以及停车场上的个别汽车：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s demonstrate the weak referencing at work:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示弱引用的工作方式：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `id` function tells us the unique identifier for an object. When we call
    it a second time, after deleting all references to the LX model and forcing garbage
    collection, we see that the ID has changed. The value in the `CarModel __new__`
    factory dictionary was deleted and a fresh one created. If we then try to construct
    a second `CarModel` instance, however, it returns the same object (the IDs are
    the same), and, even though we did not supply any arguments in the second call,
    the `air` variable is still set to `True`. This means the object was not initialized
    the second time, just as we designed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`函数告诉我们对象的唯一标识符。当我们在删除对LX模型的所有引用并强制进行垃圾回收后第二次调用它时，我们看到ID已经改变了。`CarModel
    __new__`工厂字典中的值已被删除，并创建了一个新的值。然而，如果我们尝试构造第二个`CarModel`实例，它将返回相同的对象（ID相同），即使我们在第二次调用中没有提供任何参数，`air`变量仍然设置为`True`。这意味着对象第二次没有被初始化，就像我们设计的那样。'
- en: Obviously, using the flyweight pattern can be more complicated than just storing
    features on a single car class. When should we choose to use it? The flyweight
    pattern is designed for conserving memory; if we have hundreds of thousands of
    similar objects, combining similar properties into a flyweight can have an enormous
    impact on memory consumption. It is common for programming solutions that optimize
    CPU, memory, or disk space result in more complicated code than their unoptimized
    brethren. It is therefore important to weigh up the tradeoffs when deciding between
    code maintainability and optimization. When choosing optimization, try to use
    patterns such as flyweight to ensure that the complexity introduced by optimization
    is confined to a single (well documented) section of the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用享元模式可能比只在单个汽车类上存储特性更复杂。我们何时应该选择使用它呢？享元模式旨在节省内存；如果我们有数十万个相似的对象，将相似的属性合并到享元中对内存消耗会产生巨大影响。通常，用于优化CPU、内存或磁盘空间的编程解决方案会导致比未经优化的代码更复杂。因此，在决定代码可维护性和优化之间进行权衡时，重要的是要权衡权衡。在选择优化时，尽量使用享元等模式，以确保优化引入的复杂性局限于代码的单个（有良好文档记录的）部分。
- en: The command pattern
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command pattern adds a level of abstraction between actions that must be
    done, and the object that invokes those actions, normally at a later time. In
    the command pattern, client code creates a `Command` object that can be executed
    at a later date. This object knows about a receiver object that manages its own
    internal state when the command is executed on it. The `Command` object implements
    a specific interface (typically it has an `execute` or `do_action` method, and
    also keeps track of any arguments required to perform the action. Finally, one
    or more `Invoker` objects execute the command at the correct time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在必须执行的操作和在以后通常由对象调用这些操作之间增加了一层抽象。在命令模式中，客户端代码创建一个`Command`对象，可以在以后执行。这个对象知道一个接收者对象，在命令在其上执行时管理自己的内部状态。`Command`对象实现了一个特定的接口（通常有一个`execute`或`do_action`方法，并且还跟踪执行操作所需的任何参数。最后，一个或多个`Invoker`对象在正确的时间执行命令。
- en: 'Here''s the UML diagram:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UML图：
- en: '![The command pattern](images/8781OS_11_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![命令模式](images/8781OS_11_04.jpg)'
- en: A common example of the command pattern is actions on a graphical window. Often,
    an action can be invoked by a menu item on the menu bar, a keyboard shortcut,
    a toolbar icon, or a context menu. These are all examples of `Invoker` objects.
    The actions that actually occur, such as `Exit`, `Save`, or `Copy`, are implementations
    of `CommandInterface`. A GUI window to receive exit, a document to receive save,
    and `ClipboardManager` to receive copy commands, are all examples of possible
    `Receivers`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的一个常见示例是在图形窗口上的操作。通常，一个操作可以通过菜单栏上的菜单项、键盘快捷键、工具栏图标或上下文菜单来调用。这些都是`Invoker`对象的示例。实际发生的操作，例如`Exit`、`Save`或`Copy`，是`CommandInterface`的实现。用于接收退出的GUI窗口，用于接收保存的文档，以及用于接收复制命令的`ClipboardManager`，都是可能的`Receivers`的示例。
- en: 'Let''s implement a simple command pattern that provides commands for `Save`
    and `Exit` actions. We''ll start with some modest receiver classes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的命令模式，为`Save`和`Exit`操作提供命令。我们将从一些适度的接收者类开始：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These mock classes model objects that would likely be doing a lot more in a
    working environment. The window would need to handle mouse movement and keyboard
    events, and the document would need to handle character insertion, deletion, and
    selection. But for our example these two classes will do what we need.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟类模拟了在工作环境中可能会做更多事情的对象。窗口需要处理鼠标移动和键盘事件，文档需要处理字符插入、删除和选择。但是在我们的示例中，这两个类将做我们需要的事情。
- en: 'Now let''s define some invoker classes. These will model toolbar, menu, and
    keyboard events that can happen; again, they aren''t actually hooked up to anything,
    but we can see how they are decoupled from the command, receiver, and client code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些调用者类。这些将模拟可能发生的工具栏、菜单和键盘事件；再次强调，它们实际上并没有连接到任何东西，但我们可以看到它们与命令、接收者和客户端代码是解耦的：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the various action methods each call the `execute` method on their
    respective commands? This code doesn't show the `command` attribute being set
    on each object. They could be passed into the `__init__` function, but because
    they may be changed (for example, with a customizable keybinding editor), it makes
    more sense to set the attributes on the objects afterwards.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意各种动作方法如何在各自的命令上调用`execute`方法？这段代码没有显示在每个对象上设置`command`属性。它们可以被传递到`__init__`函数中，但是因为它们可能会被更改（例如，使用可定制的按键绑定编辑器），所以在对象之后设置属性更有意义。
- en: 'Now, let''s hook up the commands themselves:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接命令本身：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands are straightforward; they demonstrate the basic pattern, but
    it is important to note that we can store state and other information with the
    command if necessary. For example, if we had a command to insert a character,
    we could maintain state for the character currently being inserted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令很简单；它们展示了基本的模式，但重要的是要注意，如果需要的话，我们可以存储状态和其他信息与命令。例如，如果我们有一个插入字符的命令，我们可以维护当前正在插入的字符的状态。
- en: 'Now all we have to do is hook up some client and test code to make the commands
    work. For basic testing, we can just include this at the end of the script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是连接一些客户端和测试代码，使命令起作用。对于基本测试，我们可以在脚本的末尾包含以下内容：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we create two receivers and two commands. Then we create several of the
    available invokers and set the correct command on each of them. To test, we can
    use `python3 -i filename.py` and run code like `exit_menu.click()`, which will
    end the program, or `save_keystroke.keystroke()`, which will save the fake file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们创建两个接收者和两个命令。然后我们创建几个可用的调用者，并在每个调用者上设置正确的命令。为了测试，我们可以使用`python3 -i filename.py`，并运行像`exit_menu.click()`这样的代码，这将结束程序，或者`save_keystroke.keystroke()`，这将保存虚假文件。
- en: Unfortunately, the preceding examples do not feel terribly Pythonic. They have
    a lot of "boilerplate code" (code that does not accomplish anything, but only
    provides structure to the pattern), and the `Command` classes are all eerily similar
    to each other. Perhaps we could create a generic command object that takes a function
    as a callback?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的例子并不像Python。它们有很多“样板代码”（不完成任何任务，只提供模式结构），而且`Command`类彼此之间都非常相似。也许我们可以创建一个通用的命令对象，以函数作为回调？
- en: 'In fact, why bother? Can we just use a function or method object for each command?
    Instead of an object with an `execute()` method, we can write a function and use
    that as the command directly. This is a common paradigm for the command pattern
    in Python:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为什么要麻烦呢？我们可以为每个命令使用函数或方法对象吗？我们可以编写一个函数，直接将其用作命令，而不是具有`execute()`方法的对象。这是Python中命令模式的常见范例：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that looks a lot more like Python. At first glance, it looks like we've
    removed the command pattern altogether, and we've tightly connected the `menu_item`
    and `Window` classes. But if we look closer, we find there is no tight coupling
    at all. Any callable can be set up as the command on the `MenuItem`, just as before.
    And the `Window.exit` method can be attached to any invoker. Most of the flexibility
    of the command pattern has been maintained. We have sacrificed complete decoupling
    for readability, but this code is, in my opinion, and that of many Python programmers,
    more maintainable than the fully abstracted version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来更像Python。乍一看，它看起来像我们完全删除了命令模式，并且紧密连接了`menu_item`和`Window`类。但是如果我们仔细看，我们会发现根本没有紧密耦合。任何可调用对象都可以设置为`MenuItem`上的命令，就像以前一样。`Window.exit`方法可以附加到任何调用者上。命令模式的大部分灵活性都得到了保留。我们为可读性牺牲了完全解耦，但在我看来，以及许多Python程序员看来，这段代码比完全抽象的版本更易于维护。
- en: 'Of course, since we can add a `__call__` method to any object, we aren''t restricted
    to functions. The previous example is a useful shortcut when the method being
    called doesn''t have to maintain state, but in more advanced usage, we can use
    this code as well:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们可以向任何对象添加`__call__`方法，我们并不局限于函数。前面的例子是一种有用的快捷方式，当被调用的方法不必维护状态时，但在更高级的用法中，我们也可以使用这段代码：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we have something that looks like the first command pattern, but a bit
    more idiomatic. As you can see, making the invoker call a callable instead of
    a command object with an execute method has not restricted us in any way. In fact,
    it's given us more flexibility. We can link to functions directly when that works,
    yet we can build a complete callable command object when the situation calls for
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些看起来像第一个命令模式的东西，但更符合习惯。正如你所看到的，让调用者调用可调用对象而不是具有执行方法的命令对象并没有限制我们的任何方式。事实上，这给了我们更多的灵活性。当适用时，我们可以直接链接到函数，但是当情况需要时，我们也可以构建一个完整的可调用命令对象。
- en: The command pattern is often extended to support undoable commands. For example,
    a text program may wrap each insertion in a separate command with not only an
    `execute` method, but also an `undo` method that will delete that insertion. A
    graphics program may wrap each drawing action (rectangle, line, freehand pixels,
    and so on) in a command that has an `undo` method that resets the pixels to their
    original state. In such cases, the decoupling of the command pattern is much more
    obviously useful, because each action has to maintain enough of its state to undo
    that action at a later date.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常被扩展以支持可撤销的命令。例如，文本程序可能会将每个插入操作包装在一个单独的命令中，该命令不仅具有`execute`方法，还具有`undo`方法，用于删除该插入。图形程序可能会将每个绘图操作（矩形、线条、自由像素等）包装在一个命令中，该命令具有`undo`方法，将像素重置为其原始状态。在这种情况下，命令模式的解耦显然更有用，因为每个操作都必须维护足够的状态以便在以后的某个日期撤消该操作。
- en: The abstract factory pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The abstract factory pattern is normally used when we have multiple possible
    implementations of a system that depend on some configuration or platform issue.
    The calling code requests an object from the abstract factory, not knowing exactly
    what class of object will be returned. The underlying implementation returned
    may depend on a variety of factors, such as current locale, operating system,
    or local configuration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式通常用于当我们有多种可能的系统实现取决于一些配置或平台问题时。调用代码从抽象工厂请求对象，不知道将返回什么类的对象。返回的底层实现可能取决于各种因素，如当前区域设置、操作系统或本地配置。
- en: Common examples of the abstract factory pattern include code for operating-system
    independent toolkits, database backends, and country-specific formatters or calculators.
    An operating-system-independent GUI toolkit might use an abstract factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an abstract factory
    can return a particular tax calculation object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的常见例子包括操作系统独立工具包的代码、数据库后端和特定国家的格式化程序或计算器。一个操作系统独立的GUI工具包可能使用一个抽象工厂模式，在Windows下返回一组WinForm小部件，在Mac下返回一组Cocoa小部件，在Gnome下返回一组GTK小部件，在KDE下返回一组QT小部件。Django提供了一个抽象工厂，根据当前站点的配置设置返回一组与特定数据库后端交互的对象关系类（MySQL、PostgreSQL、SQLite等）。如果应用程序需要在多个地方部署，每个地方可以通过仅更改一个配置变量来使用不同的数据库后端。不同的国家有不同的系统来计算零售商品的税额、小计和总额；抽象工厂可以返回特定的税收计算对象。
- en: 'The UML class diagram for an abstract factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. We''ll create a set of formatters that depend on a specific locale
    and help us format dates and currencies. There will be an abstract factory class
    that picks the specific factory, as well as a couple example concrete factories,
    one for France and one for the USA. Each of these will create formatter objects
    for dates and times, which can be queried to format a specific value. Here''s
    the diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的UML类图很难理解，没有具体的例子，所以让我们先创建一个具体的例子。我们将创建一组依赖于特定区域设置的格式化程序，帮助我们格式化日期和货币。将有一个选择特定工厂的抽象工厂类，以及一对示例具体工厂，一个用于法国，一个用于美国。每个工厂将创建日期和时间的格式化程序对象，可以查询以格式化特定值。这是图表：
- en: '![The abstract factory pattern](images/8781OS_11_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂模式](images/8781OS_11_05.jpg)'
- en: Comparing that image to the earlier simpler text shows that a picture is not
    always worth a thousand words, especially considering we haven't even allowed
    for factory selection code here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将该图像与之前更简单的文本进行比较，可以看出图片并不总是价值千言万语，尤其是考虑到我们甚至没有在这里允许工厂选择代码。
- en: 'Of course, in Python, we don''t have to implement any interface classes, so
    we can discard `DateFormatter`, `CurrencyFormatter`, and `FormatterFactory`. The
    formatting classes themselves are pretty straightforward, if verbose:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们不必实现任何接口类，所以我们可以丢弃`DateFormatter`、`CurrencyFormatter`和`FormatterFactory`。格式化类本身非常简单，但冗长：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These classes use some basic string manipulation to try to turn a variety of
    possible inputs (integers, strings of different lengths, and others) into the
    following formats:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类使用一些基本的字符串操作来尝试将各种可能的输入（整数、不同长度的字符串等）转换为以下格式：
- en: '|   | USA | France |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   | 美国 | 法国 |'
- en: '| --- | --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Date** | mm-dd-yyyy | dd/mm/yyyy |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | mm-dd-yyyy | dd/mm/yyyy |'
- en: '| **Currency** | $14,500.50 | 14 500€50 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **货币** | $14,500.50 | 14 500€50 |'
- en: There could obviously be more validation on the input in this code, but let's
    keep it simple and dumb for this example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，输入显然可以进行更多的验证，但是让我们保持简单和愚蠢，以便进行这个例子。
- en: 'Now that we have the formatters set up, we just need to create the formatter
    factories:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了格式化程序，我们只需要创建格式化程序工厂：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we set up the code that picks the appropriate formatter. Since this is
    the kind of thing that only needs to be set up once, we could make it a singleton—except
    singletons aren''t very useful in Python. Let''s just make the current formatter
    a module-level variable instead:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置选择适当格式化程序的代码。由于这种事情只需要设置一次，我们可以将其设置为单例——但是单例在Python中并不是很有用。让我们将当前格式化程序作为模块级变量：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we hardcode the current country code; in practice, it would
    likely introspect the locale, the operating system, or a configuration file to
    choose the code. This example uses a dictionary to associate the country codes
    with factory classes. Then we grab the correct class from the dictionary and instantiate
    it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们硬编码了当前的国家代码；在实践中，它可能会检查区域设置、操作系统或配置文件来选择代码。这个例子使用字典将国家代码与工厂类关联起来。然后我们从字典中获取正确的类并实例化它。
- en: 'It is easy to see what needs to be done when we want to add support for more
    countries: create the new formatter classes and the abstract factory itself. Bear
    in mind that `Formatter` classes might be reused; for example, Canada formats
    its currency the same way as the USA, but its date format is more sensible than
    its Southern neighbor.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为更多的国家添加支持时，很容易看出需要做什么：创建新的格式化程序类和抽象工厂本身。请记住，`Formatter`类可能会被重用；例如，加拿大的货币格式与美国相同，但其日期格式比其南邻更合理。
- en: Abstract factories often return a singleton object, but this is not required;
    in our code, it's returning a new instance of each formatter every time it's called.
    There's no reason the formatters couldn't be stored as instance variables and
    the same instance returned for each factory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂通常返回一个单例对象，但这并不是必需的；在我们的代码中，它每次调用时都返回每个格式化程序的新实例。没有理由不能将格式化程序存储为实例变量，并为每个工厂返回相同的实例。
- en: 'Looking back at these examples, we see that, once again, there appears to be
    a lot of boilerplate code for factories that just doesn''t feel necessary in Python.
    Often, the requirements that might call for an abstract factory can be more easily
    fulfilled by using a separate module for each factory type (for example: the USA
    and France), and then ensuring that the correct module is being accessed in a
    factory module. The package structure for such modules might look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾这些例子，我们再次看到，对于工厂来说，似乎有很多样板代码在Python中并不感觉必要。通常，可能需要抽象工厂的要求可以更容易地通过为每种工厂类型（例如：美国和法国）使用单独的模块来实现，并确保在工厂模块中访问正确的模块。这些模块的包结构可能如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The trick is that `__init__.py` in the `localize` package can contain logic
    that redirects all requests to the correct backend. There is a variety of ways
    this could be done.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧在`localize`包的`__init__.py`中可以包含将所有请求重定向到正确后端的逻辑。有多种方法可以实现这一点。
- en: 'If we know that the backend is never going to change dynamically (that is,
    without a restart), we can just put some `if` statements in `__init__.py` that
    check the current country code, and use the usually unacceptable `from .backends.USA
    import *` syntax to import all variables from the appropriate backend. Or, we
    could import each of the backends and set a `current_backend` variable to point
    at a specific module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道后端永远不会动态更改（即在没有重新启动的情况下），我们可以在`__init__.py`中放一些`if`语句来检查当前的国家代码，并使用通常不可接受的`from
    .backends.USA import *`语法从适当的后端导入所有变量。或者，我们可以导入每个后端并设置一个`current_backend`变量指向特定的模块：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Depending on which solution we choose, our client code would have to call either
    `localize.format_date` or `localize.current_backend.format_date` to get a date
    formatted in the current country's locale. The end result is much more Pythonic
    than the original abstract factory pattern, and, in typical usage, just as flexible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们选择的解决方案，我们的客户端代码将不得不调用`localize.format_date`或`localize.current_backend.format_date`来获取以当前国家区域设置格式化的日期。最终结果比原始的抽象工厂模式更符合Python的风格，并且在典型的使用情况下同样灵活。
- en: The composite pattern
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The composite pattern allows complex tree-like structures to be built from simple
    components. These components, called composite objects, are able to behave sort
    of like a container and sort of like a variable depending on whether they have
    child components. Composite objects are container objects, where the content may
    actually be another composite object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许从简单组件构建复杂的类似树状结构的结构。这些组件，称为组合对象，能够表现得像容器和变量，具体取决于它们是否有子组件。组合对象是容器对象，其中内容实际上可能是另一个组合对象。
- en: 'Traditionally, each component in a composite object must be either a leaf node
    (that cannot contain other objects) or a composite node. The key is that both
    composite and leaf nodes can have the same interface. The UML diagram is very
    simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，组合对象中的每个组件必须是叶节点（不能包含其他对象）或复合节点。关键是复合和叶节点都可以具有相同的接口。UML图非常简单：
- en: '![The composite pattern](images/8781OS_11_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![组合模式](images/8781OS_11_06.jpg)'
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. Here is a concrete
    instance of such a complicated arrangement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的模式允许我们创建复杂的元素排列，所有这些元素都满足组件对象的接口。以下是这样一个复杂排列的具体实例：
- en: '![The composite pattern](images/8781OS_11_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![组合模式](images/8781OS_11_07.jpg)'
- en: The composite pattern is commonly useful in file/folder-like trees. Regardless
    of whether a node in the tree is a normal file or a folder, it is still subject
    to operations such as moving, copying, or deleting the node. We can create a component
    interface that supports these operations, and then use a composite object to represent
    folders, and leaf nodes to represent normal files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式通常在文件/文件夹样式的树中非常有用。无论树中的节点是普通文件还是文件夹，它仍然受到移动、复制或删除节点等操作的影响。我们可以创建一个支持这些操作的组件接口，然后使用组合对象来表示文件夹，使用叶节点来表示普通文件。
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们可以再次利用鸭子类型来隐式提供接口，因此我们只需要编写两个类。让我们首先定义这些接口：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each folder (composite) object, we maintain a dictionary of children. Often,
    a list is sufficient, but in this case, a dictionary will be useful for looking
    up children by name. Our paths will be specified as node names separated by the
    `/` character, similar to paths in a Unix shell.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件夹（复合）对象，我们维护一个子对象的字典。通常，列表就足够了，但在这种情况下，使用字典来按名称查找子对象将很有用。我们的路径将被指定为由`/`字符分隔的节点名称，类似于Unix
    shell中的路径。
- en: Thinking about the methods involved, we can see that moving or deleting a node
    behaves in a similar way, regardless of whether or not it is a file or folder
    node. Copying, however, has to do a recursive copy for folder nodes, while copying
    a file node is a trivial operation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑涉及的方法，我们可以看到移动或删除节点的行为方式是相似的，无论它是文件节点还是文件夹节点。然而，复制对于文件夹节点必须进行递归复制，而复制文件节点是一个微不足道的操作。
- en: 'To take advantage of the similar operations, we can extract some of the common
    methods into a parent class. Let''s take that discarded `Component` interface
    and change it to a base class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用相似的操作，我们可以将一些常见的方法提取到一个父类中。让我们将被丢弃的`Component`接口更改为基类：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've created the `move` and `delete` methods on the `Component` class. Both
    of them access a mysterious `parent` variable that we haven't set yet. The `move`
    method uses a module-level `get_path` function that finds a node from a predefined
    root node, given a path. All files will be added to this root node or a child
    of that node. For the `move` method, the target should be a currently existing
    folder, or we'll get an error. As with many of the examples in technical books,
    error handling is woefully absent, to help focus on the principles under consideration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`Component`类上创建了`move`和`delete`方法。它们都访问一个我们尚未设置的神秘的`parent`变量。`move`方法使用一个模块级的`get_path`函数，根据路径从预定义的根节点找到一个节点。所有文件都将被添加到这个根节点或该节点的子节点。对于`move`方法，目标应该是一个当前存在的文件夹，否则我们会得到一个错误。就像技术书籍中的许多示例一样，错误处理是非常缺乏的，以帮助专注于正在考虑的原则。
- en: 'Let''s set up that mysterious `parent` variable first; this happens, in the
    folder''s `add_child` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置那个神秘的`parent`变量；这发生在文件夹的`add_child`方法中：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working
    properly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就够简单的了。让我们看看我们的复合文件层次结构是否正常工作：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Yes, we can create folders, add folders to other folders, add files to folders,
    and move them around! What more could we ask for in a file hierarchy?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以创建文件夹，将文件夹添加到其他文件夹中，将文件添加到文件夹中，并对它们进行移动！在文件层次结构中，我们还能要求什么呢？
- en: Well, we could ask for copying to be implemented, but to conserve trees, let's
    leave that as an exercise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们可以要求实现复制，但为了节约树木，让我们把它作为一个练习留下。
- en: The composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. It can be a useful pattern in Python when implemented according to the traditional
    implementation, as the example earlier demonstrated. Sometimes, if only a shallow
    tree is being created, we can get away with a list of lists or a dictionary of
    dictionaries, and do not need to implement custom component, leaf, and composite
    classes. Other times, we can get away with implementing only one composite class,
    and treating leaf and composite objects as a single class. Alternatively, Python's
    duck typing can make it easy to add other objects to a composite hierarchy, as
    long as they have the correct interface.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 复合模式对各种类似树状结构非常有用，包括GUI小部件层次结构、文件层次结构、树集、图形和HTML DOM。按照传统的实现方式，在Python中实现时，它可以是一个有用的模式，就像之前的示例所演示的那样。有时，如果只创建了一个浅树，我们可以使用列表的列表或字典的字典，并且不需要实现自定义组件、叶子和复合类。其他时候，我们可以只实现一个复合类，并将叶子和复合对象视为一个类。另外，Python的鸭子类型可以很容易地将其他对象添加到复合层次结构中，只要它们具有正确的接口。
- en: Exercises
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Before diving into exercises for each design pattern, take a moment to implement
    the `copy` method for the `File` and `Folder` objects in the previous section.
    The `File` method should be quite trivial; just create a new node with the same
    name and contents, and add it to the new parent folder. The `copy` method on `Folder`
    is quite a bit more complicated, as you first have to duplicate the folder, and
    then recursively copy each of its children to the new location. You can call the
    `copy()` method on the children indiscriminately, regardless of whether each is
    a file or a folder object. This will drive home just how powerful the composite
    pattern can be.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究每个设计模式的练习之前，先花点时间为上一节中的`File`和`Folder`对象实现`copy`方法。`File`方法应该非常简单；只需创建一个具有相同名称和内容的新节点，并将其添加到新的父文件夹中。`Folder`上的`copy`方法要复杂得多，因为你首先必须复制文件夹，然后递归地将它的每个子项复制到新位置。你可以不加选择地在子项上调用`copy()`方法，无论每个子项是文件还是文件夹对象。这将彰显出复合模式有多么强大。
- en: Now, as with the previous chapter, look at the patterns we've discussed, and
    consider ideal places where you might implement them. You may want to apply the
    adapter pattern to existing code, as it is usually applicable when interfacing
    with existing libraries, rather than new code. How can you use an adapter to force
    two interfaces to interact with each other correctly?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，和上一章一样，看看我们讨论过的模式，并考虑你可能实现它们的理想位置。您可能希望将适配器模式应用于现有代码，因为当与现有库进行接口时通常适用，而不是新代码。您如何使用适配器来强制两个接口正确地相互交互？
- en: Can you think of a system complex enough to justify using the facade pattern?
    Consider how facades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the facade interface are other programmers, rather than people
    trained to use them. Are there complex systems in your latest project that could
    benefit from the facade pattern?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个足够复杂的系统来证明使用外观模式是合理的吗？考虑外观在现实生活中的使用情况，比如汽车的驾驶员界面，或者工厂中的控制面板。在软件中也是类似的，只不过外观接口的用户是其他程序员，而不是受过培训的人。在你最新的项目中，是否有复杂的系统可以从外观模式中受益？
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does the flyweight pattern make sense? When
    is it overkill?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有任何巨大的、占用内存的代码，可以从享元模式中受益，但你能想到它可能有用的情况吗？任何需要处理大量重叠数据的地方，都可以使用享元。在银行业中会有用吗？在Web应用程序中呢？享元模式在什么时候是有意义的？什么时候又是多余的？
- en: What about the command pattern? Can you think of any common (or better yet,
    uncommon) examples of places where the decoupling of action from invocation would
    be useful? Look at the programs you use on a daily basis, and imagine how they
    are implemented internally. It's likely that many of them use the command pattern
    for one purpose or another.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式呢？你能想到任何常见（或更好的是，不常见的）例子，表明从调用中分离出动作会很有用吗？看看你每天使用的程序，想象它们内部是如何实现的。很可能它们中的许多都在某种情况下使用了命令模式。
- en: The abstract factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式，或者我们讨论过的更具Python风格的派生模式，对于创建一键配置的系统非常有用。你能想到这样的系统在哪些地方会有用吗？
- en: Finally, consider the composite pattern. There are tree-like structures all
    around us in programming; some of them, like our file hierarchy example, are blatant;
    others are fairly subtle. What situations might arise where the composite pattern
    would be useful? Can you think of places where you can use it in your own code?
    What if you adapted the pattern slightly; for example, to contain different types
    of leaf or composite nodes for different types of objects?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一下组合模式。在编程中，我们周围都有类似树的结构；其中一些，比如我们的文件层次结构示例，是显而易见的；其他一些则相当微妙。可能会出现哪些情况，组合模式会很有用呢？你能想到在自己的代码中可以使用它的地方吗？如果你稍微调整一下模式；例如，包含不同类型的叶子或组合节点，用于不同类型的对象？
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The adapter pattern is useful for matching interfaces, while the facade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. In Python, the command pattern
    is often more aptly implemented using first class functions as callbacks. Abstract
    factories allow run-time separation of implementations depending on configuration
    or system information. The composite pattern is used universally for tree-like
    structures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了几种设计模式，包括它们的经典描述以及在Python中实现它们的替代方法，Python通常比传统的面向对象语言更灵活和多才多艺。适配器模式用于匹配接口，而外观模式适用于简化接口。享元模式是一个复杂的模式，只有在需要内存优化时才有用。在Python中，命令模式通常更适合使用一等函数作为回调来实现。抽象工厂允许根据配置或系统信息在运行时分离实现。组合模式通常用于类似树的结构。
- en: In the next chapter, we'll discuss how important it is to test Python programs,
    and how to do it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论测试Python程序的重要性，以及如何进行测试。
