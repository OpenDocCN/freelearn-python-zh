- en: Chapter 8. Application Presentation and Page Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。应用程序展示和页面布局
- en: Up to this point, we have developed a fairly simple, but a complete application.
    There are some rough edges that need to be polished, obviously. For example, the
    templates that we use, all have a different layout, and although they use more
    or less the same styles and colors, they lack uniformity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了一个相当简单但完整的应用程序。显然，还有一些粗糙的边缘需要抛光。例如，我们使用的模板都有不同的布局，尽管它们使用或多或少相同的样式和颜色，但缺乏统一性。
- en: 'In this chapter, we are going to learn how to lay out an application. Some
    important points that we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何布局应用程序。我们将涵盖的一些重要点包括：
- en: Viewlet managers and viewlets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图小部件管理器和视图小部件
- en: Layout definition using viewlets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图小部件进行布局定义
- en: Inserting forms into viewlets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表单插入视图小部件
- en: Layers and skins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层和皮肤
- en: Defining an alternative skin for the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序的替代皮肤
- en: Viewlets and viewlet managers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图小部件和视图小部件管理器
- en: In a typical web application, there are many parts of its layout that need to
    be repeated on almost every page. Sometimes these pieces need to be present in
    different combinations. For example, a login prompt should not appear if the user
    is already logged in, but a search box should be visible at all times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Web应用程序中，其布局的许多部分几乎需要在每个页面上重复。有时这些部分需要以不同的组合出现。例如，如果用户已经登录，则不应显示登录提示，但搜索框应始终可见。
- en: Grok solves this problem by allowing the developer to break up web pages into
    small pieces of HTML called **viewlets**, which can then be assembled as required
    inside a given view.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Grok通过允许开发者将网页拆分成称为**视图小部件**的小块HTML，然后将它们按要求组装在给定的视图中来解决此问题。
- en: Viewlets
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图小部件
- en: Viewlets provide a mechanism for separating the different components of a page
    into independent pieces, such as header, footer, and navigation. It's possible
    to further decompose these into HTML snippets, which can be shown on the page
    or not, depending on contextual information. This concept allows us to have great
    flexibility in assembling pages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 视图小部件提供了一种将页面不同组件分离成独立部分（如页眉、页脚和导航）的机制。可以将这些部分进一步分解成HTML片段，这些片段可以根据上下文信息显示在页面上或不显示。这个概念使我们能够在组装页面时具有很大的灵活性。
- en: Unlike a view, which is meant to show a complete page, a viewlet is the representation
    of an HTML snippet that usually has one clear function. When using viewlets, we
    can think of a page as a collection of these snippets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与旨在显示完整页面的视图不同，视图小部件是HTML片段的表示，通常具有一个清晰的功能。当使用视图小部件时，我们可以将页面视为这些片段的集合。
- en: Viewlet managers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图小部件管理器
- en: To avoid making a view, keep track of all possible viewlet combinations. Viewlets
    are assigned to specific viewlet managers. A **viewlet manager** can represent
    a section of the page layout, such as the header, for instance. Viewlets register
    with this manager, so that it takes care of their order and rendering. In our
    header viewlet manager, we could have for example title, login, search box, and
    main navigation viewlets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建视图，跟踪所有可能的视图小部件组合。视图小部件分配给特定的视图小部件管理器。**视图小部件管理器**可以表示页面布局的一部分，例如，例如标题。视图小部件向此管理器注册，以便它负责它们的顺序和渲染。在我们的标题视图小部件管理器中，例如，我们可以有标题、登录、搜索框和主要导航视图小部件。
- en: 'This means that the viewlets are never called directly from a template. Instead,
    their viewlet manager is called and this, in turn, calls each of its registered
    viewlets in the desired order and renders them on the page. Viewlet managers have
    a few other responsibilities:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着视图小部件永远不会直接从模板中调用。相反，它们的视图小部件管理器被调用，然后它依次调用其注册的每个视图小部件，并按所需顺序在页面上渲染它们。视图小部件管理器还有其他一些职责：
- en: Aggregation of all viewlets registered to the manager.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合注册到管理器的所有视图小部件。
- en: Applying a set of filters to determine the availability of the viewlets.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用一组过滤器以确定视图小部件的可用性。
- en: Sorting the viewlets based on an implemented policy. The default is to show
    them in the order in which they were declared, and Grok can also numerically sort
    them according to the `grok.order([number])` directive for the viewlets.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据实施的政策对视图小部件进行排序。默认情况下，按它们声明的顺序显示它们，Grok还可以根据视图的`grok.order([number])`指令对它们进行数字排序。
- en: Providing an environment in which the viewlets are rendered.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供视图小部件渲染的环境。
- en: Rendering itself, containing the HTML content of the viewlets.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染本身，包含视图小部件的HTML内容。
- en: Viewlets can also be tied to specific views, contexts, or permissions, so the
    overall system is very flexible, and is easier to manage than a collection of
    macros with conditional tags.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 视图小部件也可以与特定的视图、上下文或权限相关联，因此整个系统非常灵活，并且比带有条件标签的宏集合更容易管理。
- en: Understanding how the pieces fit together
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各个部分如何组合
- en: 'We now have all of the pieces of how Grok constructs the page layout. When
    a Grok application serves a page, here''s what''s going on behind the scenes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了 Grok 构建页面布局的所有组成部分。当一个 Grok 应用程序服务一个页面时，幕后发生的事情如下：
- en: The browser makes a request, which contains the desired URL as well as any form
    input, together with the usual `HTTP` headers, to Grok.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器发出请求，其中包含所需的 URL 以及任何表单输入，以及通常的 `HTTP` 头信息，发送给 Grok。
- en: Based on the URL parts, Grok traverses (walks) the site, starting at the root
    and continuing on to the next part of the URL until it gets to the last model
    object. This model object is called the **context.**
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 URL 的部分，Grok 从根开始遍历（遍历）网站，继续到 URL 的下一部分，直到它到达最后一个模型对象。这个模型对象被称为**上下文**。
- en: When the model object is found, Grok takes the remainder of the URL and uses
    it as the name of a view. If there is no URL remainder, the name "index" is used.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当找到模型对象时，Grok 会使用 URL 的剩余部分并将其用作视图的名称。如果没有 URL 剩余，则使用名称 "index"。
- en: Once it has the name of the view, Grok finds it and initializes the view, passing
    to it the context and the request used to find the view.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦有了视图的名称，Grok 就会找到它并初始化视图，将上下文和用于找到视图的请求传递给它。
- en: The view usually has a template assigned to it, which is used to render the
    response to the browser.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图通常分配了一个模板，该模板用于将响应渲染到浏览器。
- en: The template may include calls to a number of viewlet managers, which in turn
    call their contained viewlets to assemble the HTML that will be returned in the
    response.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板可能包含对多个视图管理器的调用，这些视图管理器反过来调用它们包含的视图小部件来组装将返回的响应中的 HTML。
- en: The template is the final result of calling the Grok application, and it represents
    the rendering of the view. The view, in turn, is associated with a context, which
    is the model object that has been assigned to that view.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是调用 Grok 应用程序后的最终结果，它代表了视图的渲染。视图反过来与一个上下文相关联，这是分配给该视图的模型对象。
- en: 'Grok passes a lot of information to the template, in order to let the developer
    use all of the pieces. This information is in the form of variables that point
    to the following objects that can be used by the developer to build the template:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 向模板传递大量信息，以便让开发者使用所有这些部分。这些信息是以变量形式存在的，这些变量指向以下对象，开发者可以使用这些对象来构建模板：
- en: '`request:` The `HTTP` request that was sent by the browser, including all of
    the headers.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request:` 浏览器发送的 `HTTP` 请求，包括所有头信息。'
- en: '`context:` The model object pointed to by the requested URL. In our application,
    this could be a project or a to-do list item.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context:` 由请求的 URL 指向的模型对象。在我们的应用程序中，这可能是一个项目或待办事项列表项。'
- en: '`view:` The view that is configured to be used for the context, according to
    its name. This is the code that is associated with the current template.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view:` 根据其名称配置用于上下文的视图。这是与当前模板相关联的代码。'
- en: '`viewlet:` Inside a viewlet template, this variable represents the viewlet
    object.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewlet:` 在视图小部件模板内部，这个变量代表视图小部件对象。'
- en: '`viewletmanager:` Inside a viewlet template, this variable points to the viewlet
    manager responsible for the current viewlet.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewletmanager:` 在视图小部件模板内部，这个变量指向负责当前视图小部件的视图管理器。'
- en: View methods and attributes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图方法和属性
- en: These methods and attributes are a part of the `view` variable, and can be used
    by the developer, inside the template.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法和属性是`view`变量的一个部分，并且可以在模板内部被开发者使用。
- en: '| View methods and attributes | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 视图方法和属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `context` | The object that the view is presenting. This is often an instance
    of a `grok.Model` class, but can be a `grok.Application`, a `grok.Container` object,
    or any type of Python object. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `context` | 视图所呈现的对象。这通常是一个`grok.Model`类的实例，但也可以是一个`grok.Application`、一个`grok.Container`对象或任何类型的
    Python 对象。 |'
- en: '| `request` | The `HTTP Request` object. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `request` | `HTTP 请求`对象。 |'
- en: '| `response` | The `HTTP Response` object that is associated with the request.
    This is also available as `self.request.response`, but the `response` attribute
    is provided as a convenience. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `response` | 与请求相关联的`HTTP 响应`对象。这也可以作为`self.request.response`提供，但`response`属性提供是为了方便。
    |'
- en: '| `static` | Directory resource containing the static files of the view''s
    package. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `static` | 包含视图包静态文件的目录资源。 |'
- en: '| `redirect(url)` | Redirects to a given URL. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `redirect(url)` | 重定向到指定的URL。 |'
- en: '| `url(obj=None, name=None, data=None)` | Constructs URL.If no arguments are
    given, constructs the URL to the view itself.If only the `obj` argument is given,
    constructs the URL to `obj`.If only `name` is given as the first argument, constructs
    the URL to context/name.If both of the object and name arguments are supplied,
    constructs the URL to `obj/name`.Optionally, you can pass a `data` keyword argument
    that is added to the URL as a `cgi` query string. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `url(obj=None, name=None, data=None)` | 构建URL。如果没有提供任何参数，则构建到视图本身的URL。如果只提供了`obj`参数，则构建到`obj`的URL。如果只提供了第一个参数`name`，则构建到上下文/名称的URL。如果同时提供了对象和名称参数，则构建到`obj/name`的URL。可选地，您可以传递一个作为`cgi`查询字符串添加到URL中的`data`关键字参数。
    |'
- en: '| `default_namespace()` | Returns a dictionary of namespaces that the template
    implementation expects to be available always. This method is *not* intended to
    be overridden by application developers. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `default_namespace()` | 返回模板实现期望始终可用的命名空间字典。此方法不打算被应用程序开发者重写。 |'
- en: '| `namespace()` | Returns a dictionary that is injected into the template namespace
    in addition to the default namespace. This method is intended to be overridden
    by the application developer. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `namespace()` | 返回一个字典，该字典将注入到模板命名空间中，除了默认命名空间之外。此方法打算由应用程序开发者重写。 |'
- en: '| View methods and attributes | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 视图方法和属性 | 描述 |'
- en: '| `update(**kw)` | This method is meant to be implemented by `grok.View` subclasses.
    It will be called before the view''s associated template is rendered, and can
    be used to precompute values for the template.`update()` can take arbitrary keyword
    parameters that will be filled in from the request (in which case they *must*
    be present in the request). |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `update(**kw)` | 此方法旨在由`grok.View`子类实现。它将在渲染视图的关联模板之前被调用，并可用于为模板预计算值。`update()`可以接受任意关键字参数，这些参数将从请求中填充（在这种情况下，它们*必须*存在于请求中）。
    |'
- en: '| `render(**kw)` | A view can either be rendered by an associated template,
    or it can implement this method to render itself from Python. This is useful if
    the view''s output isn''t XML/HTML but something computed in Python (such as plain
    text, PDF, and so on).`render()` can take arbitrary keyword parameters that will
    be filled in from the request (in which case they *must* be present in the request).
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `render(**kw)` | 视图可以通过关联的模板进行渲染，或者它可以实现此方法以从Python本身进行渲染。如果视图的输出不是XML/HTML，而是在Python中计算（例如纯文本、PDF等），则这很有用。`render()`可以接受任意关键字参数，这些参数将从请求中填充（在这种情况下，它们*必须*存在于请求中）。
    |'
- en: '| `application_url(name=None)` | Returns the URL of the closest application
    object in the hierarchy, or the URL of a named object (name parameter) relative
    to the closest application object. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `application_url(name=None)` | 返回层次结构中最接近的应用程序对象的URL，或相对于最接近的应用程序对象的命名对象（name参数）的URL。
    |'
- en: '| `flash(message, type=''message'')` | Sends a short message to the user. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `flash(message, type=''message'')` | 向用户发送简短的消息。 |'
- en: Viewlet methods and attributes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图小部件方法和属性
- en: 'From inside a viewlet template, the following methods and attributes are available
    to the developer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图小部件模板内部，以下方法和属性可供开发者使用：
- en: '| Viewlet methods and attributes | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 视图小部件方法和属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `context` | Typically, this is the model object for which this viewlet is
    being rendered in the context of. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `context` | 通常，这是在此视图小部件的上下文中渲染的模型对象。 |'
- en: '| `request` | The `Request` object. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `request` | `Request`对象。 |'
- en: '| `view` | A reference to the view that the viewlet is being provided in. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `view` | 对视图的引用，视图小部件在其中提供。 |'
- en: '| `viewletmanager` | A reference to the `ViewletManager` that is rendering
    this viewlet. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `viewletmanager` | 对渲染此视图小部件的`ViewletManager`的引用。 |'
- en: '| `update()` | This method is called before the viewlet is rendered, and can
    be used to perform precomputation. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 在渲染视图小部件之前调用此方法，可用于执行预计算。 |'
- en: '| `render(*args, **kw)` | This method renders the content provided by this
    viewlet. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `render(*args, **kw)` | 此方法渲染由该视图小部件提供的内容。 |'
- en: Viewlet manager methods and attributes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图小部件管理器方法和属性
- en: 'The `viewletmanager` variable is available to developers from inside a viewlet.
    These are the methods and attributes that it contains:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewletmanager`变量在视图小部件内部对开发者可用。这些是它包含的方法和属性：'
- en: '| Viewlet manager methods and attributes | Description |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 视图管理器方法和属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `context` | This is typically the model object for which this `ViewletManager`
    is being rendered in the context of. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `context` | 这通常是 `ViewletManager` 在上下文中渲染的模型对象。|'
- en: '| `request` | The `Request` object. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `request` | `Request` 对象。|'
- en: '| `view` | A reference to the view in which the `ViewletManager` is being provided.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `view` | 对 `ViewletManager` 提供的视图的引用。|'
- en: '| `update()` | This method is called before the `ViewletManager` is rendered,
    and can be used to perform precomputation. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 在 `ViewletManager` 渲染之前调用此方法，可以用来执行预计算。|'
- en: '| `render(*args, **kw)` | This method renders the content provided by this
    `ViewletManager`. Typically this will mean rendering and concatenating all of
    the viewlets managed by this `ViewletManager`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `render(*args, **kw)` | 此方法渲染由该 `ViewletManager` 提供的内容。通常这意味着渲染和连接由该 `ViewletManager`
    管理的所有视图。|'
- en: In addition to these methods, the viewlets contained inside the viewlet manager
    can be accessed using standard Python dictionary syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法外，视图管理器内部包含的视图可以使用标准的 Python 字典语法访问。
- en: To-do list manager layout
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项管理器布局
- en: 'For our application then, we will use viewlets to generate the layout. First,
    let''s define our layout structure, which will be more or less what we have now.
    Take a look at the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用视图来生成布局。首先，让我们定义我们的布局结构，它将大致是我们现在的样子。看看下面的截图：
- en: '![To-do list manager layout](img/7481_08_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项管理器布局](img/7481_08_01.jpg)'
- en: 'It''s a very simple layout. Each of the three sections (Header, **Main**, and
    **Footer)** represents a viewlet manager and the list of things inside these sections
    refers to the viewlets that will be needed. To do this in a page template, we
    need to use a special kind of template expression called a **provider**. This
    is how our master template will look:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的布局。三个部分（标题、**主要**和**页脚**）分别代表一个视图管理器以及这些部分内的事物列表，它们指的是所需视图。要在页面模板中实现这一点，我们需要使用一种特殊的模板表达式，称为**提供者**。我们的主模板将如下所示：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we are thinking about our application's final presentation, the first thing
    to note is that we inserted a correct`<DOCTYPE>` declaration. We also removed
    the`<title>` and`<style>` tags from the header, as they will go inside a viewlet
    now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑我们应用程序的最终展示时，首先要注意的是我们插入了一个正确的 `<DOCTYPE>` 声明。我们还从标题中移除了 `<title>` 和 `<style>`
    标签，因为它们现在将放入视图内。
- en: 'We define four layout areas: headslot, header, main, and footer. The content
    for each one of those will be provided by a separate viewlet manager. The `provider:name`
    expression tells Grok to find a viewlet manager with this name, render all of
    its registered viewlets, and return them in their configured order. As you may
    recall, the `structure` prefix means to interpret whatever comes from the function
    call as HTML to be rendered.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了四个布局区域：headslot、header、main 和 footer。每个区域的内容将由一个单独的视图管理器提供。`provider:name`
    表达式告诉 Grok 查找一个具有此名称的视图管理器，渲染其所有已注册的视图，并按配置的顺序返回它们。如您所回忆的，`structure` 前缀意味着将函数调用返回的内容解释为要渲染的
    HTML。
- en: Defining viewlet managers in application code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序代码中定义视图管理器
- en: 'We looked at the template first, to see how it relates to the desired layout,
    but we actually need to define some viewlet managers and viewlets to make this
    work. Fortunately, Grok has `Viewlet` and `ViewletManager` classes that we can
    use for this. First, let''s define our viewlet managers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看模板，以了解它如何与所需的布局相关联，但实际上我们需要定义一些视图管理器和视图来使这成为可能。幸运的是，Grok 有 `Viewlet` 和
    `ViewletManager` 类，我们可以使用这些类。首先，让我们定义我们的视图管理器：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it. We just subclass from `grok.ViewletManager` and Grok will pretty
    much do it all for us. The key part is the `grok.name` class declaration, as the
    name we use here is the one that goes inside the provider expressions in the templates.
    The `grok.context` directive uses `Interface` because it is the most general declaration
    possible, so doing this will enable the managers in all of our application's views
    and models.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们只需从 `grok.ViewletManager` 继承，Grok 就会为我们做大部分工作。关键部分是 `grok.name` 类声明，因为我们在这里使用的名称将用于模板中的提供者表达式。`grok.context`
    指令使用 `Interface`，因为它是最通用的声明，所以这样做将使所有应用程序视图和模型中的管理器生效。
- en: Registering viewlets
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册视图
- en: To get the viewlets going, we need to modify our application a bit. Up to now,
    we have been using separate views to define what goes on on each page and who
    can see it. As may be apparent from the master template that we just defined,
    this will now be the responsibility of the viewlets themselves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使视图小部件运行，我们需要对我们的应用程序进行一些修改。到目前为止，我们一直在使用单独的视图来定义每个页面上发生的事情以及谁可以看到它。从我们刚刚定义的主模板中可能很明显，这现在将是视图小部件本身的职责。
- en: 'To convert our application to use viewlets, the first step is to take the parts
    that we want to turn into viewlets from the `dashboard.pt` template and put them
    in their own templates. We''ll do the title first, as an example. In the project,
    create a file named `apptitle.pt` and enter the following code into it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的应用程序转换为使用视图小部件，第一步是从`dashboard.pt`模板中提取我们想要转换为视图小部件的部分，并将它们放入它们自己的模板中。我们将首先以标题为例。在项目中创建一个名为`apptitle.pt`的文件，并将以下代码输入其中：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Right now, this contains only the title, but we could eventually include a logo
    and other similar elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这仅包含标题，但我们可以最终包括标志和其他类似元素。
- en: 'To register this viewlet with a viewlet manager, the `Viewlet` class is used
    as a base, and the `grok.viewletmanager` class is invoked:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此视图小部件注册到视图小部件管理器中，使用`Viewlet`类作为基类，并调用`grok.viewletmanager`类：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's it. This viewlet will be registered with the `Header` viewlet manager
    defined earlier. Viewlets also require a context, to let the viewlet managers
    know if they are to be displayed in the current context or not. As is the case
    for viewlet managers, we use `Interface` as the context, so that the viewlet is
    enabled everywhere in the application. Also note the `grok.order` directive, which
    is useful for specifying the order that the viewlet manager should use when rendering
    the viewlets. If `grok.order` is not used, the viewlets will be rendered in the
    order that they are defined.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。此视图小部件将与之前定义的`Header`视图小部件管理器注册。视图小部件还需要一个上下文，以便视图小部件管理器知道它们是否要在当前上下文中显示。与视图小部件管理器的情况一样，我们使用`Interface`作为上下文，这样视图小部件就可以在应用程序的任何地方启用。还要注意`grok.order`指令，它在指定视图小部件管理器在渲染视图小部件时应使用的顺序时很有用。如果不使用`grok.order`，视图小部件将按照它们定义的顺序渲染。
- en: A `Viewlet` class is very similar to a view. It has an `update` method to prepare
    it for rendering, and a `render` method to do the actual rendering. If these methods
    are omitted, Grok simply renders the corresponding template, which in this case
    is `apptitle.pt`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewlet`类与视图非常相似。它有一个`update`方法来准备它进行渲染，以及一个`render`方法来进行实际的渲染。如果省略了这些方法，Grok将简单地渲染相应的模板，在这种情况下是`apptitle.pt`。'
- en: 'Now let''s go for the other simple viewlets. The template for the head section,
    `head.pt`, looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理其他简单的视图小部件。头部部分的模板`head.pt`看起来是这样的：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The template for the search box, `searchbox.pt:`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索框的模板`searchbox.pt:`：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The logged in information and logout link, `loggedin.pt`, is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 登录信息和注销链接`loggedin.pt`如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And a simple navigational aid, `navigation.pt`, is defined as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个简单的导航辅助工具`navigation.pt`，定义为：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the footer, we will use a simple **Powered by Grok** message, along with
    Grok's logo, which will be defined in `grokpowered.pt:`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于页脚，我们将使用一个简单的**由Grok提供支持**的消息，以及Grok的标志，该标志将在`grokpowered.pt:`中定义：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we''ll register these viewlets with their managers. We just need to add
    the appropriate class declarations in `app.py`, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把这些视图小部件与它们的管理器注册。我们只需在`app.py`中添加适当的类声明，如下所示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, the `Header` viewlet manager has four viewlets registered in a specific
    order. The `Footer` has just one viewlet at the moment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Header`视图小部件管理器已按特定顺序注册了四个视图小部件。目前`Footer`只有一个视图小部件。
- en: Modifying existing views to use the master template
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有视图以使用主模板
- en: 'We already have several working views in our application. To get them to use
    the new layout defined in the master template, we need to do two things:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中已经有了几个工作的视图。为了使它们使用在主模板中定义的新布局，我们需要做两件事：
- en: Make them use the master template
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让它们使用主模板
- en: Create viewlets that show the main parts of the old template
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建显示旧模板主要部分的视图小部件
- en: 'The first part is easy; we just need to use the `grok.template` directive to
    force each view to use the master template, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分很简单；我们只需使用`grok.template`指令强制每个视图使用主模板，如下所示：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The viewlet itself is very similar to the other ones that we have defined,
    with the addition of a couple of lines:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 视图小部件本身与我们定义的其他视图非常相似，增加了几行：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the `grok.template` directive to force the viewlet to use the `dashboard_viewlet`
    template. The `grok.view` directive is used next, to make this viewlet show up
    only in the `DashBoard` view. We have to do this to prevent multiple viewlets
    that are registered with the `Main` viewlet manager from showing up all at once
    in every view. In other words, this means that the `DashBoardViewlet` will only
    be rendered inside the `Main` viewlet manager when the user is browsing the default
    view of the application, which happens to be the `DashBoard` view.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`grok.template`指令来强制视图组件使用`dashboard_viewlet`模板。接下来使用`grok.view`指令，以使此视图组件仅在`DashBoard`视图中显示。我们必须这样做，以防止注册到`Main`视图组件管理器的多个视图组件同时出现在每个视图中。换句话说，这意味着当用户浏览应用程序的默认视图时，`DashBoardViewlet`将仅在`Main`视图组件管理器中渲染，而这个默认视图恰好是`DashBoard`视图。
- en: To make this work, we need an additional step. Currently, we have the template
    `dashboard.pt` in the `app_templates` directory. We can't keep this name because
    then the `DashBoard` view would have two possible templates to use and Grok will
    refuse to guess which one to use. Therefore, we'll change the name to `dashboard_viewlet.pt`,
    which is what we put in the `grok.template` directive.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，我们需要额外的步骤。目前，我们在`app_templates`目录中有模板`dashboard.pt`。我们不能保留这个名称，因为这样`DashBoard`视图将有两个可能的模板可以使用，Grok将拒绝猜测使用哪一个。因此，我们将名称更改为`dashboard_viewlet.pt`，这是我们放在`grok.template`指令中的名称。
- en: 'The final step is to change the template itself, and remove all of the structure
    from it. This structure is now included in the `master.pt` template. This is the
    result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更改模板本身，并从中删除所有结构。这些结构现在包含在`master.pt`模板中。这是结果：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have to perform the same steps to make the `TodoSearch` and `UserList` views
    work. We'll end up with `TodoSearchViewlet` and `UserListViewlet` declarations,
    along with `todosearch_viewlet.pt` and `userlist_viewlet.pt` templates. The `ProjectIndex`
    view requires extra work, because of its use of JavaScript. We'll see how to fix
    that later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须执行相同的步骤来使`TodoSearch`和`UserList`视图工作。我们将得到`TodoSearchViewlet`和`UserListViewlet`声明，以及`todosearch_viewlet.pt`和`userlist_viewlet.pt`模板。`ProjectIndex`视图需要额外的工作，因为它使用了JavaScript。我们将在本章后面看到如何解决这个问题。
- en: 'For now, you can take a look at the next screenshot and see how the layout
    works:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您可以查看下一张截图，看看布局是如何工作的：
- en: '![Modifying existing views to use the master template](img/7481_08_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![修改现有视图以使用主模板](img/7481_08_02.jpg)'
- en: Inserting forms into viewlets
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表单插入到视图组件中
- en: As the "add user" and "add project" forms are generated automatically, they
    are still not using our new layout. We have to put these forms inside a viewlet
    so that we can take advantage of the layout. This requires a bit more work because
    the viewlet needs to render the form.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“添加用户”和“添加项目”表单是自动生成的，它们仍然没有使用我们新的布局。我们必须将这些表单放入视图组件中，以便我们可以利用布局。这需要更多的工作，因为视图组件需要渲染表单。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We previously defined the `AddProjectForm` and gave it the name "add". This
    code uses that form directly to render the viewlet. First, we define a view that
    will use the master template. We keep the same context that the real form uses,
    which is `Todo` in this case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义了`AddProjectForm`并给它命名为“add”。此代码直接使用该表单来渲染视图组件。首先，我们定义一个将使用主模板的视图。我们保持与实际表单相同的上下文，在这个例子中是`Todo`。
- en: Next, we create a viewlet that we register with the `Main` viewlet manager in
    the same context. We assign this viewlet to the view that was just defined. The
    trick here is to get hold of the form, which we do by using the `getMultiAdapter`
    method imported from `zope.component`. We'll have more to say about adapters in
    Chapter 11, but for now, take it on faith that this call will get us the form
    named "add" in the current context. Once we have the form, we store it in the
    viewlet and use it in the viewlet's `render` method in order to pull the rendering
    from the real form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个视图组件，并在相同上下文中将其注册到`Main`视图组件管理器中。我们将此视图组件分配给刚刚定义的视图。这里的技巧是获取表单，我们通过使用从`zope.component`导入的`getMultiAdapter`方法来实现。我们将在第11章中更多地讨论适配器，但就目前而言，请相信这个调用将使我们得到当前上下文中的名为“add”的表单。一旦我们有了表单，我们就将其存储在视图组件中，并在视图组件的`render`方法中使用它，以便从实际表单中提取渲染。
- en: 'That''s all there is to it, we just need to change the link in `dashboard_viewlet.pt`
    to point to "addproject" instead of just "add", and we''ll get the result that
    we want, as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了，我们只需要将`dashboard_viewlet.pt`中的链接更改为指向“addproject”而不是“add”，我们就会得到我们想要的结果，如下面的截图所示：
- en: '![Inserting forms into viewlets](img/7481_08_03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![将表单插入视图组件](img/7481_08_03.jpg)'
- en: Using viewlets to insert different static resources
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图组件插入不同的静态资源
- en: We have almost converted the whole application to use our new layout. The only
    thing missing is the project view. The problem with this view is that it uses
    some JavaScript code that is not used elsewhere, so we need to include it in the
    header, somehow.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经将整个应用程序转换为使用我们新的布局。唯一缺少的是项目视图。这个视图的问题在于它使用了一些在其他地方没有使用的JavaScript代码，因此我们需要以某种方式将其包含在标题中。
- en: 'As we already have a `headslot` viewlet manager, the easiest way to accomplish
    this is by registering a viewlet with this manager that will only be applied to
    the project view. We have done this before. The trick is to use the `grok.view`
    directive to make the viewlet show only for the selected view:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个`headslot`视图组件管理器，完成这个任务的最简单方法是通过这个管理器注册一个视图组件，该视图组件只应用于项目视图。我们之前已经这样做过了。技巧是使用`grok.view`指令使视图组件只对选定的视图显示：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now add a new template named `projectjavascript.pt` that will include
    our JavaScript calls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个名为`projectjavascript.pt`的新模板，该模板将包括我们的JavaScript调用：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the JavaScript code will work properly in this view and the project viewlet
    can be seen without problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个视图中的JavaScript代码将正常工作，并且项目视图组件可以无问题地显示。
- en: Layers and skins
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层和皮肤
- en: We have shown how building a flexible layout is possible by using viewlets.
    Grok allows us to have even more flexibility, by using layers and skins.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何通过使用视图组件来构建一个灵活的布局。Grok通过使用层和皮肤，为我们提供了更多的灵活性。
- en: The look and feel of our application was created by combining some viewlets
    and using appropriate CSS styles. The final combination can be thought of as the
    'theme' of the application. In Grok, the name we use for this is 'skin'.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的外观和感觉是通过结合一些视图组件并使用适当的CSS样式创建的。最终的组合可以被认为是应用程序的“主题”。在Grok中，我们为这个主题使用的名字是“皮肤”。
- en: A **skin** represents the look and feel of our application. It should be possible
    to rearrange all of the viewlets and edit the styles to create a totally different
    look and feel without changing the way that the application works. Thus, having
    a mechanism to handle skins allows us to easily create themes for our applications
    or create special skins for other uses, such as mobile browser presentation, views
    that respond to specific HTTP verbs (known as REST views, which are actually built
    like this inside Grok), or special power-user skins, depending on who is logged
    in.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**皮肤**代表我们应用程序的外观和感觉。应该能够重新排列所有的视图组件并编辑样式，以创建一个完全不同的外观和感觉，而无需改变应用程序的工作方式。因此，有一个处理皮肤的机制，使我们能够轻松地为我们的应用程序创建主题或为其他用途创建特殊的皮肤，例如移动浏览器展示、响应特定HTTP动词的视图（称为REST视图，实际上在Grok内部就是这样构建的），或者根据登录用户的不同而创建的特殊高级用户皮肤。'
- en: To simplify the creation and use of skins, they are composed of a number of
    layers, each of which will include only the parts of the look and feel that are
    different for them. This makes it easy to reuse most of the application UI and
    focus only on what's particular to the skin in question.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化皮肤的制作和使用，它们由多个层组成，每个层将只包含它们特有的外观和感觉部分。这使得重用应用程序的大部分UI变得容易，只需关注特定皮肤的特定部分。
- en: Skins in Grok
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grok中的皮肤
- en: In Grok, all views and viewlets have to be assigned to a layer. Up to now, this
    has been happening in the background because by default there is a layer that
    all of them use. This is called the **default browser layer**. All applications
    in Grok have a default skin, which has no name and is composed of only one layer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中，所有视图和视图组件都必须分配给一个层。到目前为止，这已经在后台发生了，因为默认情况下有一个所有视图都使用的层。这被称为**默认浏览器层**。Grok中的所有应用程序都有一个默认皮肤，它没有名字，只由一个层组成。
- en: However, the difference between a skin and a layer is subtle. In reality they
    are very similar, but a skin has a name that will be known to the user, whereas
    a layer is anonymous. The intention is to have skins consisting of a number of
    layers, and to use the name to refer to the result.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，皮肤和层之间的区别是微妙的。实际上它们非常相似，但皮肤有一个用户将知道的名字，而层则是匿名的。目的是让皮肤由多个层组成，并使用名字来引用结果。
- en: Adding themes to our application
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将主题添加到我们的应用程序中
- en: Let's add different themes to our application by using skins. We'll make it
    very simple for now. We already have a viewlet that includes the`<link>` tag for
    our stylesheet. To design a theme, we'll simply create a layer that overrides
    this viewlet and uses a different stylesheet. In this way, we can create a new
    theme just by adding seven lines of code, a template, and a stylesheet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用皮肤为我们的应用程序添加不同的主题。现在我们将使其非常简单。我们已经有了一个包含我们的样式表 `<link>` 标签的视图组件。为了设计一个主题，我们将简单地创建一个覆盖此视图组件并使用不同样式表的层。这样，我们只需添加七行代码、一个模板和一个样式表，就可以创建一个新的主题。
- en: 'We are using blue for the masthead of our application. We''ll add a second
    theme, which uses red, and another one that uses green. As the names will be known
    to the users, we''ll use fancy names: the red theme will be called "martian" and
    the green theme will be known as "forest".'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用蓝色为我们应用程序的页眉。我们将添加第二个主题，它使用红色，还有一个使用绿色。由于这些名称将为人所知，我们将使用花哨的名称：红色主题将被称为“martian”，绿色主题将被称为“forest”。
- en: 'A layer in Grok needs to inherit from the `IDefaultBrowserLayer` defined in
    `zope.publisher`. So the first thing we need to do is to import that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grok 中，一个层需要从 `zope.publisher` 中定义的 `IDefaultBrowserLayer` 继承。因此，我们首先需要做的是导入它：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now define the skins in `app.py`, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `app.py` 中定义皮肤，如下所示：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For each skin, we just define a class based on `IDefaultBrowserLayer`, and then
    use the `grok.skin` directive to name it. This name will be used to browse to
    the skin.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一层皮肤，我们只需基于 `IDefaultBrowserLayer` 定义一个类，然后使用 `grok.skin` 指令为其命名。这个名称将被用来浏览皮肤。
- en: Overriding a viewlet
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖视图组件
- en: 'Now that we have the skins, we can override the `Head` viewlet, where the stylesheet
    link is defined. This viewlet is managed by the `HeadSlot` viewlet manager. To
    override a viewlet, we just have to create another one, with the same name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了皮肤，我们可以覆盖定义样式表的 `Head` 视图组件。这个视图组件由 `HeadSlot` 视图组件管理器管理。要覆盖一个视图组件，我们只需创建另一个具有相同名称的组件：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the `HeadMartian` and `HeadForest` viewlets have exactly the same
    viewlet manager, context, and name as those used by the `Head` viewlet that they
    override. The difference is that they will use another template. To make the `HeadMartian`
    viewlet work only on the `MartianLayer` skin, we add the `grok.layer` directive
    and pass it to the skin. Keep in mind that `grok.layer` can be used in any viewlet
    or view that we define, so we could override anything from the application, or
    create new views or viewlets that appear only when using a specific skin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `HeadMartian` 和 `HeadForest` 视图组件与它们覆盖的 `Head` 视图组件具有完全相同的视图组件管理器、上下文和名称。区别在于它们将使用另一个模板。为了使
    `HeadMartian` 视图组件仅在 `MartianLayer` 皮肤上工作，我们添加了 `grok.layer` 指令并将其传递给皮肤。请记住，`grok.layer`
    可以用于我们定义的任何视图组件或视图，因此我们可以覆盖应用程序中的任何内容，或者创建仅在特定皮肤上使用的新视图或视图组件。
- en: 'In this case, this is all the code that needs to be added to these two themes
    for our application. We just need to add the templates and styles and we are done.
    For the martian theme, we directed the viewlet to use the `head_martian` template,
    so we create a file named `head_martian.pt` and add the following code to it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这就是我们需要添加到这两个主题中的所有代码。我们只需添加模板和样式，然后我们就完成了。对于 martian 主题，我们指导视图组件使用 `head_martian`
    模板，因此我们创建一个名为 `head_martian.pt` 的文件，并向其中添加以下代码：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only change is the name of the stylesheet in the`<link>` tag.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是 `<link>` 标签中样式表的名称。
- en: For the forest theme, we'll create the `head_forest.pt` file and add the same
    text, except that we have to change the name of the CSS file to `styles_forest.css`
    in order to use the correct stylesheet.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 forest 主题，我们将创建 `head_forest.pt` 文件，并添加相同的文本，但我们必须将 CSS 文件名更改为 `styles_forest.css`
    以使用正确的样式表。
- en: All that's left now is to add the new stylesheets. To keep things simple, we'll
    just copy the `styles.css` file to `styles_martian.css` and `styles_forest.css`,
    and then make some color substitutions. Using your favorite text editor, change
    all occurrences of `#223388` to `#883322` in martian and to `#338822` in forest.
    Other than that, the themes will be exactly the same, but we'll easily be able
    to see the difference. Feel free to make more style changes if you like.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是添加新的样式表。为了使事情简单，我们只需将 `styles.css` 文件复制到 `styles_martian.css` 和 `styles_forest.css`，然后进行一些颜色替换。使用您喜欢的文本编辑器，将
    `martian` 中的所有 `#223388` 替换为 `#883322`，在 `forest` 中替换为 `#338822`。除此之外，主题将完全相同，但我们将能够轻松地看到差异。如果您喜欢，可以自由地进行更多样式更改。
- en: Using the new skins
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的皮肤
- en: To actually see the new skins, we need to tell Grok that a different skin than
    the default has to be used. The simplest way to do this is to use the special
    `++skin++` name in the URL, along with the skin name. Grok will see this, and
    use the correct skin.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正看到新皮肤，我们需要告诉Grok使用默认皮肤以外的其他皮肤。最简单的方法是在URL中使用特殊的`++skin++`名称，并附带皮肤名称。Grok会看到这个，并使用正确的皮肤。
- en: 'For example, we''ll see the martian skin if we point the browser to the following
    URL: [http://localhost:8080/++skin++martian/todo](http://localhost:8080/++skin++martian/todo).
    Notice how the `++skin++` name goes immediately after the hostname. Grok will
    signal an error if we put it anywhere else in the URL. To see the forest skin,
    just change the word `martian` to `forest` in the preceding URL. See the next
    screenshot to take a look at the martian skin:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们把浏览器指向以下URL：[http://localhost:8080/++skin++martian/todo](http://localhost:8080/++skin++martian/todo)，我们就能看到火星皮肤。注意`++skin++`名称紧接在主机名之后。如果我们把`++skin++`放在URL的其他位置，Grok将会发出错误信号。要查看森林皮肤，只需在上面的URL中将单词`martian`改为`forest`。查看下一张截图，看看火星皮肤的样子：
- en: '![Using the new skins](img/7481_08_04.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用新皮肤](img/7481_08_04.jpg)'
- en: We are done. If we browse through the application, we'll see that all of the
    pages now show the header with the corresponding background color.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了。如果我们浏览应用程序，我们会看到现在所有页面都显示了带有相应背景色的标题。
- en: Of course, asking the user to type the name of the skin in the URL will not
    do for production use. In Chapter 11, we'll see how to let the user choose a skin
    via a preferences menu, and get Grok to apply the correct skin itself.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要求用户在URL中输入皮肤名称并不适合生产使用。在第11章中，我们将看到如何通过偏好设置菜单让用户选择皮肤，并让Grok自动应用正确的皮肤。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Grok's layout and presentation facilities,
    including viewlets, layers, and skins. We modified our application to have a consistent
    look and feel, by using these tools. We will now go on to learn about the ZODB
    and how Grok uses it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Grok的布局和展示功能，包括视图组件、层和皮肤。我们通过使用这些工具修改了我们的应用程序，使其外观和感觉保持一致。接下来，我们将学习ZODB以及Grok如何使用它。
