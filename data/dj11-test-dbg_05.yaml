- en: 'Chapter 5. Filling in the Blanks: Integrating Django and Other Test Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。填补空白：集成Django和其他测试工具
- en: Previous chapters have discussed the built-in application test support that
    comes with Django 1.1\. We first learned how to use doctests to test the building
    blocks of our application, and then covered the basics of unit tests. In addition,
    we saw how functions provided by `django.test.TestCase` and `django.test.Client`
    aid in testing Django applications. Through examples, we learned how to use these
    functions to test more complete pieces of our application, such as the contents
    of pages it serves and its form handling behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节已经讨论了Django 1.1提供的内置应用程序测试支持。我们首先学习了如何使用doctests来测试应用程序的构建模块，然后介绍了单元测试的基础知识。此外，我们还看到了`django.test.TestCase`和`django.test.Client`提供的函数如何帮助测试Django应用程序。通过示例，我们学习了如何使用这些函数来测试应用程序的更完整的部分，例如它提供的页面内容和表单处理行为。
- en: Django alone, however, does not provide everything one might want for test support.
    Django is, after all, a web application framework, not a test framework. It doesn't,
    for example, provide any test coverage information, which is essential for developing
    comprehensive test suites, nor does it provide any support for testing client-side
    behavior, since Django is purely a server-side framework. Other tools exist that
    fill in these gaps, but often it is desirable to integrate these other tools with
    Django rather than using several entirely different tool sets to build a full
    application test suite.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Django本身并没有提供测试支持所需的一切。毕竟，Django是一个Web应用程序框架，而不是一个测试框架。例如，它不提供任何测试覆盖信息，这对于开发全面的测试套件至关重要，也不提供任何支持测试客户端行为的支持，因为Django纯粹是一个服务器端框架。存在其他工具来填补这些空白，但通常希望将这些其他工具与Django集成，而不是使用完全不同的工具集来构建完整的应用程序测试套件。
- en: In some cases even when Django does support a function, some other tool may
    be preferred. For example, if you already have experience with a Python test framework
    such as `nose`, which provides a very flexible test discovery mechanism and a
    powerful test plugin architecture, you may find Django's test runner rather limiting.
    Similarly, if you are familiar with the `twill` web testing tool, you may find
    using Django's test `Client` cumbersome for testing form behavior in comparison
    with `twill`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，即使Django支持某个功能，也可能更喜欢使用其他工具。例如，如果您已经有了使用Python测试框架（如`nose`）的经验，它提供了非常灵活的测试发现机制和强大的测试插件架构，您可能会发现Django的测试运行器相当受限制。同样，如果您熟悉`twill`
    Web测试工具，您可能会发现与`twill`相比，使用Django的测试`Client`来测试表单行为相当麻烦。
- en: 'In this chapter, we will investigate integration of Django with other testing
    tools. Integration can sometimes be accomplished through the use of standard Python
    unit test extension mechanisms, but sometimes more is required. Both situations
    will be covered in this chapter. Specifically, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调查Django与其他测试工具的集成。集成有时可以通过使用标准的Python单元测试扩展机制来实现，但有时需要更多。本章将涵盖这两种情况。具体来说，我们将：
- en: Discuss the issues involved in integration, and learn about the hooks Django
    provides for integrating other tools into its test structure.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论集成涉及的问题，并了解Django提供的用于将其他工具集成到其测试结构中的钩子。
- en: 'Look into answering the question: How much of our code is being executed by
    our tests? We will see how we can answer this question both without making any
    changes to our Django test setup and by utilizing the hooks discussed earlier.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨一个问题：我们的代码有多少被我们的测试执行了？我们将看到如何在不对Django测试设置进行任何更改的情况下回答这个问题，并利用之前讨论过的钩子。
- en: Explore the `twill` tool, and see how to use it instead of the Django test `Client`
    in our Django application tests. For this integration, we do not need to use any
    Django hooks for integration, we simply need to use Python's unit test hooks for
    test set up and tear down.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`twill`工具，并了解如何在我们的Django应用程序测试中使用它，而不是Django测试`Client`。对于这种集成，我们不需要使用任何Django钩子进行集成，我们只需要使用Python的单元测试钩子进行测试设置和拆卸。
- en: Problems of integration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成的问题
- en: 'Why is integration of Django testing with other tools even an issue? Consider
    the case of wanting to use the `nose` test framework. It provides its own command,
    `nosetests`, to find and run tests in a project tree. However, attempting to run
    `nosetests`, instead of `manage.py test`, in a Django project tree quickly reveals
    a problem:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Django测试与其他工具的集成甚至是一个问题？考虑想要使用`nose`测试框架的情况。它提供了自己的命令`nosetests`，用于在项目树中查找并运行测试。然而，在Django项目树中尝试运行`nosetests`而不是`manage.py
    test`，很快就会发现一个问题：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The problem here is that some environmental setup done by `manage.py test` is
    missing. Specifically, setting up the environment so that the appropriate settings
    are found when Django code is called, hasn't been done. This particular error
    could be fixed by setting the `DJANGO_SETTINGS_MODULE` environment variable before
    running `nosetests`, but `nosetests` would not get much farther, since there is
    more that is missing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`manage.py test`所做的一些环境设置缺失。具体来说，没有设置环境，以便在调用Django代码时找到适当的设置。可以通过在运行`nosetests`之前设置`DJANGO_SETTINGS_MODULE`环境变量来解决这个特定的错误，但`nosetests`不会走得更远，因为还有更多的东西缺失。
- en: The next problem that would be encountered would result from tests that need
    to use the database. Creating the test database is done by support code called
    by `manage.py test` before any of the tests are run. The `nosetests` command knows
    nothing about the need for a test database, so when run under `nosetests`, Django
    test cases that require a database will fail since the database won't exist. This
    problem cannot be solved by simply setting an environment variable before running
    `nosetests`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个遇到的问题将是需要使用数据库的测试。在运行任何测试之前，`manage.py test`调用的支持代码会创建测试数据库。`nosetests`命令对测试数据库的需求一无所知，因此在`nosetests`下运行需要数据库的Django测试用例将失败，因为数据库不存在。简单地在运行`nosetests`之前设置环境变量无法解决这个问题。
- en: There are two approaches that can be taken to address integration issues like
    these. First, if the other tool provides hooks for adding functionality, they
    can be used to do things such as setting up the environment and creating the test
    database before the tests are run. This approach integrates Django tests into
    the other tool. Alternatively, hooks provided by Django can be used to integrate
    the other tool into Django testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采取两种方法来解决这些集成问题。首先，如果其他工具提供了添加功能的钩子，可以使用它们来执行诸如在运行测试之前设置环境和创建测试数据库等操作。这种方法将Django测试集成到其他工具中。或者，可以使用Django提供的钩子将其他工具集成到Django测试中。
- en: The first option is outside the scope of this book, so it won't be discussed
    in any detail. However, for the particular case of `nose`, its plugin architecture
    certainly supports adding the necessary function to get Django tests running under
    `nose`. There are existing nose plugins that can be used to allow Django application
    tests to run successfully when called from `nosetests`. If this is an approach
    you want to take for your own testing, you probably want to search the web for
    existing solutions before building your own `nose` plugin to accomplish this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选项超出了本书的范围，因此不会详细讨论。但是，对于`nose`的特定情况，其插件架构当然支持添加必要的功能以使Django测试在`nose`下运行。存在可以用于允许Django应用程序测试在从`nosetests`调用时成功运行的现有nose插件。如果这是您想要采用的方法进行自己的测试，您可能希望在构建自己的`nose`插件之前搜索现有解决方案。
- en: 'The second option is what we will focus on in this section: the hooks that
    Django provides to allow for pulling other functions in to the normal path of
    Django testing. There are two hooks that may be used here. First, Django allows
    specification of an alternative test runner. Details of specifying this, the responsibilities
    of the test runner, and the interface it must support will be described first.
    Second, Django allows applications to provide entirely new management commands.
    Thus, it is possible to augment `manage.py test` with another command, which might
    support different options, and does whatever is necessary to integrate another
    tool into the testing path. Details on doing this will also be discussed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是我们将在本节中关注的：Django提供的允许将其他函数引入到Django测试的正常路径中的钩子。这里可以使用两个钩子。首先，Django允许指定替代测试运行程序。首先将描述指定这一点，测试运行程序的责任以及它必须支持的接口。其次，Django允许应用程序提供全新的管理命令。因此，可以通过另一个命令来增强`manage.py
    test`，该命令可能支持不同的选项，并且可以执行将另一个工具集成到测试路径中所需的任何操作。也将讨论如何执行此操作的详细信息。
- en: Specifying an alternative test runner
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定替代测试运行程序
- en: 'Django uses the `TEST_RUNNER` setting to decide what code to call in order
    to run tests. By default, the value of `TEST_RUNNER` is `''django.test.simple.run_tests''`.
    We can look at the declaration and docstring for that routine to see what interface
    it must support:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用`TEST_RUNNER`设置来决定调用哪些代码来运行测试。默认情况下，`TEST_RUNNER`的值是`'django.test.simple.run_tests'`。我们可以查看该例程的声明和文档字符串，以了解它必须支持的接口：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `test_labels`, `verbosity`, and `interactive` arguments are clearly going
    to come straight from the `manage.py test` command line. The `extra_tests` argument
    is a bit mysterious, as there is no supported `manage.py test` argument that might
    correspond to that. In fact, when called from `manage.py test`, `extra_tests`
    will never be specified. This argument is used by the `runtests.py` program that
    Django uses to run its own test suite. Unless you are going to write a test runner
    that will be used to run Django's own tests, you probably don't need to worry
    about `extra_tests`. However, a custom runner should implement the defined behavior
    of including `extra_tests` among those run.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_labels`，`verbosity`和`interactive`参数显然将直接来自`manage.py test`命令行。`extra_tests`参数有点神秘，因为没有受支持的`manage.py
    test`参数与之对应。实际上，当从`manage.py test`调用时，`extra_tests`将永远不会被指定。这个参数是由Django用来运行自己的测试套件的`runtests.py`程序使用的。除非您打算编写一个用于运行Django自己的测试的测试运行程序，否则您可能不需要担心`extra_tests`。但是，自定义运行程序应该实现包括`extra_tests`在内的定义行为。'
- en: 'What exactly does a test runner need to do? This question is most easily answered
    by looking at the existing `django.test.simple.run_tests` code and seeing what
    it does. Briefly, without going through the routine line by line, it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行程序需要做什么？这个问题最容易通过查看现有的`django.test.simple.run_tests`代码并看看它做了什么来回答。简而言之，不逐行进行例程，它：
- en: Sets up the test environment by calling `django.test.utils.setup_test_environment`.
    This is a documented method that a custom test runner should call as well. It
    does things to ensure, for example, that the responses generated by the test client
    have the `context` and `templates` attributes mentioned in the previous chapter.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`django.test.utils.setup_test_environment`设置测试环境。这也是自定义测试运行程序应该调用的一个记录方法。它会执行一些操作，以确保例如测试客户端生成的响应具有上一章中提到的`context`和`templates`属性。
- en: Sets `DEBUG` to `False`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`DEBUG`设置为`False`。
- en: Builds a `unittest.TestSuite` containing all of the tests discovered under the
    specified `test_labels`. Django's simple test runner searches only in the `models`
    and `tests` modules for tests.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包含在指定的`test_labels`下发现的所有测试的`unittest.TestSuite`。Django的简单测试运行程序仅在`models`和`tests`模块中搜索测试。
- en: Creates the test database by calling `connection.creation.create_test_db`. This
    is another routine that is documented in the Django test documentation for use
    by alternative test runners.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`connection.creation.create_test_db`创建测试数据库。这是另一个在Django测试文档中记录的例程，供替代测试运行程序使用。
- en: Runs the tests.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Destroys the test database by calling `connection.creation.destroy_test_db`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`connection.creation.destroy_test_db`销毁测试数据库。
- en: Cleans up the test environment by calling `django.test.utils.teardown_test_environment`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`django.test.utils.teardown_test_environment`清理测试环境。
- en: Returns the sum of the test failures and errors.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回测试失败和错误的总和。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Django 1.2 adds support for a class-based approach to specifying an
    alternative test runner. While Django 1.2 continues to support the function-based
    approach used earlier and described here, using function-based alternative test
    runners will be deprecated in the future. The class-based approach simplifies
    the task of making a small change to the test running behavior. Instead of needing
    to re-implement (and often largely duplicate) the existing `django.tests.simple.run_tests`
    function, you can implement an alternative test runner class that inherits from
    the default class and simply overrides whatever specific methods are necessary
    to accomplish the desired alternative behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Django 1.2添加了对指定替代测试运行器的基于类的方法的支持。虽然Django 1.2继续支持先前使用的基于函数的方法，并在此处描述，但将来将弃用使用基于函数的替代测试运行器。基于类的方法简化了对测试运行行为进行小改动的任务。您可以实现一个替代测试运行器类，该类继承自默认类，并简单地覆盖实现所需的任何特定方法以实现所需的替代行为。
- en: It is reasonably straightforward, then, to write a test runner. However, in
    replacing just the test runner, we are limited by the arguments and options supported
    by the `manage.py test` command. If our runner supports some option that isn't
    supported by `manage.py test`, there is no obvious way to get that option passed
    through from the command line to our test runner. Instead, `manage.py` test will
    reject any option it doesn't know about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写一个测试运行器是相当简单的。但是，仅仅替换测试运行器，我们受到`manage.py test`命令支持的参数和选项的限制。如果我们的运行器支持一些`manage.py
    test`不支持的选项，那么没有明显的方法可以将该选项从命令行传递给我们的测试运行器。相反，`manage.py` test将拒绝它不知道的任何选项。
- en: There is a way to get around this. Django uses the Python `optparse` module
    to parse options from command lines. Placing a bare `–` or `–-` on the command
    line causes `optparse` to halt processing the command line, so options specified
    after a bare `–` or `–-`won't be seen by the regular Django code doing the parsing.
    They will still be accessible to our test runner in `sys.argv`, though, so they
    could be retrieved and passed on to whatever tool we are integrating with.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以绕过这个问题。Django使用Python的`optparse`模块来解析命令行中的选项。在命令行上放置一个裸的`-`或`--`会导致`optparse`停止处理命令行，因此在裸的`-`或`--`之后指定的选项不会被正在解析的常规Django代码看到。但它们仍然可以在`sys.argv`中被我们的测试运行器访问，因此它们可以被检索并传递给我们正在集成的任何工具。
- en: This method works, but the existence of such options will be well-hidden from
    users, since the standard Django help for the `test` command knows nothing of
    them. By using this technique, we extend the interface supported by `manage.py
    test` without having any way to obviously publish the extensions we have made,
    as part of the built-in help for the `test` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效，但这些选项的存在将对用户隐藏得很好，因为`test`命令的标准Django帮助对它们一无所知。通过使用这种技术，我们扩展了`manage.py
    test`支持的接口，而没有任何明显的方式来发布我们所做的扩展，作为`test`命令的内置帮助的一部分。
- en: Thus, a better alternative to specifying a custom test runner may be to supply
    an entirely new management command. When creating a new command, we can define
    it to take whatever options we like, and supply the help text that should be displayed
    for each new option when the user requests help for the command. This approach
    is discussed next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指定自定义测试运行器的一个更好的选择可能是提供一个全新的管理命令。创建一个新命令时，我们可以定义它以接受我们喜欢的任何选项，并在用户请求命令的帮助时提供应该显示的每个新选项的帮助文本。下面将讨论这种方法。
- en: Creating a new management command
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的管理命令
- en: Providing a new management command is simple. Django looks for management commands
    in a `management.commands` package in each installed application's directory.
    Any Python module found in an installed application's `management.commands` package
    is automatically available to specify as a command to `manage.py`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个新的管理命令很简单。Django在每个已安装应用程序的目录中的`management.commands`包中查找管理命令。在已安装应用程序的`management.commands`包中找到的任何Python模块都可以自动用作`manage.py`的命令指定。
- en: So, to create a custom test command, say `survey_test`, for our survey application,
    we create a `management` subdirectory under survey, and a `commands` directory
    under `management`. We put `__init__.py` files in both of those directories so
    that Python will recognize them as modules. Then, we put the implementation for
    the `survey_test` command in a file named `survey_test.py`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要为我们的调查应用程序创建一个自定义测试命令，比如`survey_test`，我们在调查目录下创建一个`management`子目录，并在`management`下创建一个`commands`目录。我们在这两个目录中都放置`__init__.py`文件，以便Python将它们识别为模块。然后，我们将`survey_test`命令的实现放在一个名为`survey_test.py`的文件中。
- en: What would need to go in `survey_test.py`? Documentation on implementing management
    commands is scant as of Django 1.1\. All it states is that the file must define
    a class named `Command` that extends `django.core.management.base.BaseCommand`.
    Beyond that, it recommends consulting some of the existing management commands
    to see what to do. Since we are looking to provide an enhanced test command, the
    easiest thing to do is probably copy the implementation of the `test` command
    (found in `django/core/management/commands/test.py`) to our `survey_test.py` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`survey_test.py`需要包含什么？截至Django 1.1，有关实现管理命令的文档很少。它只说明文件必须定义一个名为`Command`的类，该类扩展自`django.core.management.base.BaseCommand`。除此之外，它建议查阅一些现有的管理命令，以了解应该做什么。由于我们希望提供一个增强的测试命令，最简单的方法可能是复制`test`命令的实现（在`django/core/management/commands/test.py`中找到）到我们的`survey_test.py`文件中。'
- en: 'Looking at that file, we see that a management command implementation contains
    two main parts. First, after the necessary imports and class declaration, some
    attributes are defined for the class. These control things such as what options
    it supports and what help should be displayed for the command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看该文件，我们看到管理命令实现包含两个主要部分。首先，在必要的导入和类声明之后，为类定义了一些属性。这些属性控制诸如它支持什么选项以及用户请求命令时应显示什么帮助之类的事情：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that while `BaseCommand` is not documented in the official Django 1.1
    documentation, it does have an extensive docstring, so the exact purpose of each
    of these attributes (`option_list`, `help`, `args`, `requires_model_validation`)
    can be found by consulting the source or using the Python shell''s help function.
    Even without checking the docstring, we can see that Python''s standard `optparse`
    module is used to build the option string, so extending `option_list` to include
    additional arguments is straightforward. For example, if we wanted to add a `–-cover`
    option to turn on generation of test coverage data, we could change the `option_list`
    specification to be:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`BaseCommand`在官方Django 1.1文档中没有记录，但它有一个详尽的文档字符串，因此可以通过查阅源代码或使用Python shell的帮助函数来找到这些属性（`option_list`、`help`、`args`、`requires_model_validation`）的确切目的。即使不查看文档字符串，我们也可以看到Python的标准`optparse`模块用于构建选项字符串，因此扩展`option_list`以包括其他参数是很简单的。例如，如果我们想要添加一个`--cover`选项来打开测试覆盖数据的生成，我们可以将`option_list`的规范更改为：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have added support for specifying `–-cover` on the command line. If
    specified, it will cause the value of the `coverage` option to be `True`. If not
    specified, this new option will default to `False`. Along with adding support
    for the option, we have the ability to add help text for it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了对在命令行上指定`--cover`的支持。如果指定了，它将导致`coverage`选项的值为`True`。如果没有指定，这个新选项将默认为`False`。除了添加对该选项的支持，我们还可以为它添加帮助文本。
- en: 'The declaration section of the `Command` implementation is followed by a `handle`
    function definition. This is the code that will be called to implement our `survey_test`
    command. The existing code from the `test` command is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`实现的声明部分后面是`handle`函数的定义。这是将被调用来实现我们的`survey_test`命令的代码。来自`test`命令的现有代码是：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this performs a very straightforward retrieval of passed options,
    uses a utility function to find the correct test runner to call, and simply calls
    the runner with the passed options. When the runner returns, if there were any
    failures, the program exits with a system exit code set to the number of failures.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这执行了一个非常简单的选项检索，使用一个实用函数来找到正确的测试运行器来调用，并简单地使用传递的选项调用运行器。当运行器返回时，如果有任何失败，程序将以设置为失败数量的系统退出代码退出。
- en: 'We can replace the last four lines with code that retrieves our new option
    and prints out whether it has been specified:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用检索新选项的代码替换最后四行，并打印出它是否已被指定：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can try running our `survey_test` command to verify that it is found
    and can accept our new option:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试运行我们的`survey_test`命令，以验证它是否被找到并且能够接受我们的新选项：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also verify that if we do not pass `--cover` on the command line, it
    defaults to `False`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证，如果我们在命令行上没有传递`--cover`，它默认为`False`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can see that help for our option is included in the help response
    for the new command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到我们的选项的帮助包含在新命令的帮助响应中：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that all of the other options displayed in the help message that were not
    specified in our `option_list` are inherited from `BaseCommand`. In some cases,
    (for example, the `settings` and `pythonpath` arguments) appropriate handling
    of the argument is done for us before they are called; in others (`verbosity`,
    for example) we are expected to honor the documented behavior of the option in
    our implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，帮助消息中显示的所有其他选项，如果在我们的`option_list`中没有指定，都是从`BaseCommand`继承的。在某些情况下（例如，`settings`和`pythonpath`参数），在调用它们之前，会为我们适当地处理这些参数；在其他情况下（例如`verbosity`），我们期望在我们的实现中遵守选项的文档行为。
- en: Adding a new management command was easy! Of course, we didn't actually implement
    running tests and generating coverage data, since we do not know any way to do
    that yet. There are existing packages that provide this support, and we will see
    in the next section how they can be used to do exactly this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的管理命令很容易！当然，我们实际上并没有实现运行测试和生成覆盖数据，因为我们还不知道如何做到这一点。有现有的软件包提供了这种支持，我们将在下一节中看到它们如何被用来做到这一点。
- en: For now, we might as well delete the `survey/management` tree created here.
    It was a useful exercise to experiment with seeing how to add management commands.
    However in reality, if we were to provide a customized test command to add function
    such as recording coverage data, it would be a bad approach to tie that function
    directly to our survey application. A test command that records coverage data
    would be better implemented in an independent application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能会删除这里创建的`survey/management`树。尝试添加管理命令是一个有用的练习。但实际上，如果我们要提供一个自定义的测试命令来添加诸如记录覆盖数据之类的功能，将这个功能直接绑定到我们的调查应用程序是一个不好的方法。记录覆盖数据的测试命令最好是在一个独立的应用程序中实现。
- en: How much of the code are we testing?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们测试了多少代码？
- en: When writing tests, the goal is to test everything. Although we can try to be
    vigilant and manually ensure that we have a test for every line of our code, that's
    a very hard goal to meet without some automated analysis to verify what lines
    of code are executed by our tests. For Python code, Ned Batchelder's `coverage`
    module is an excellent tool for determining what lines of code are being executed.
    In this section, we see how to use `coverage`, first as a standalone utility and
    then integrated into our Django project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，目标是测试一切。虽然我们可以尝试保持警惕并手动确保我们的代码的每一行都有一个测试，但这是一个非常难以实现的目标，除非有一些自动化分析来验证我们的测试执行了哪些代码行。对于Python代码，Ned
    Batchelder的`coverage`模块是一个优秀的工具，用于确定哪些代码行正在执行。在本节中，我们将看到如何使用`coverage`，首先作为一个独立的实用程序，然后集成到我们的Django项目中。
- en: Using coverage standalone
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用独立的覆盖
- en: Before using `coverage`, it must first be installed, since it's neither included
    with Python nor Django 1.1\. If you are using Linux, your distribution package
    manager may have `coverage` available to be installed on your system. Alternatively,
    the latest version of `coverage` can always be found at its web page on the Python
    Package Index (PyPI), [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage).
    The version of `coverage` used here is 3.2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`coverage`之前，必须先安装它，因为它既不包含在Python中，也不包含在Django 1.1中。如果你使用Linux，你的发行版包管理器可能有`coverage`可供安装在你的系统上。另外，最新版本的`coverage`始终可以在Python软件包索引（PyPI）的网页上找到，[http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage)。这里使用的`coverage`版本是3.2。
- en: 'Once installed, we can use the `coverage` command with the `run` subcommand
    to run our tests and record coverage data:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以使用`coverage`命令的`run`子命令来运行测试并记录覆盖数据：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you see, the output from the test runner looks completely normal. The coverage
    module does not affect the program's output; it simply stores the coverage data
    in a file named `.coverage`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试运行器的输出看起来完全正常。覆盖模块不会影响程序的输出；它只是将覆盖数据存储在名为`.coverage`的文件中。
- en: 'The data stored in `.coverage` can be formatted as a report using the `report`
    subcommand of `coverage`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`.coverage`中存储的数据可以使用`coverage`的`report`子命令格式化为报告：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s a bit more than we actually want. We only care about coverage of our
    own code, so for a start, everything reported for modules located under `/usr`
    is not interesting. The `--omit` option to `coverage report` can be used to omit
    modules that start with particular paths. Additionally, the `-m` option can be
    used to get `coverage` to report on the lines that were not executed (missing)
    during the run:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们实际想要的要多一点。我们只关心我们自己代码的覆盖率，所以首先，对于位于`/usr`目录下的模块报告的内容并不感兴趣。`coverage report`的`--omit`选项可用于省略以特定路径开头的模块。此外，`-m`选项可用于让`coverage`报告未执行（缺失）的行：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's much more manageable. Not surprisingly, since we have been developing
    tests for each bit of code discussed, just about everything is showing as covered.
    What's missing? If you look at lines 5 to 8 of `manage.py`, they handle the case
    where the `import` of `settings.py` raises an `ImportError`. Since that leg of
    code is not taken for a successful run, they were not executed and come up missing
    in the coverage report.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就好多了。毫不奇怪，因为我们已经为讨论的每一部分代码开发了测试，几乎所有内容都显示为已覆盖。还有什么缺失的吗？如果你看一下`manage.py`的5到8行，它们处理了`settings.py`的`import`引发`ImportError`的情况。由于这部分代码在成功运行时没有被执行，它们在覆盖报告中显示为缺失。
- en: 'Similarly, the lines mentioned in `model_tests` (35 to 42, 47 to 51) are from
    alternative execution paths of the `testClosesReset` method, which contains this
    code starting at line 34:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`model_tests`中提到的行（35到42，47到51）来自于`testClosesReset`方法的替代执行路径，该方法包含从第34行开始的代码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lines 35 to 42 were not executed because the database used for this run was
    SQLite, not MySQL. Then, in any single test run, only one leg of the `if strict/elif
    debug/else` block will execute, so the other legs will show up as not covered.
    (In this particular case, the `if strict` leg was the one taken.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 35到42行没有被执行，因为此次运行使用的数据库是SQLite，而不是MySQL。然后，在任何单个测试运行中，`if strict/elif debug/else`块中的一个分支将执行，因此其他分支将显示为未覆盖的。在这种情况下，`if
    strict`分支是被执行的。
- en: The remaining line noted as missing is line 66 in `survey/models.py`. This is
    the `__unicode__` method implementation for the `Question` model, which we neglected
    to write a test for. We can put doing that on our to-do list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个被标记为缺失的行是`survey/models.py`中的第66行。这是`Question`模型的`__unicode__`方法实现，我们忽略了为其编写测试。我们可以把这件事放在待办事项清单上。
- en: Although this last one is a valid indication of a missing test, neither the
    missing lines in `manage.py` nor the missing lines in our test code are really
    things we care about, as they are not reporting missing coverage for our application
    code. (Actually, if we are thorough, we would probably want to ensure that several
    runs of our test code with different settings did result in full test code execution,
    but let's assume we are only interested in coverage of our application code for
    now.) The `coverage` module supports a couple of different ways of excluding code
    from reports. One possibility is to annotate source lines with a `# pgrama no
    cover` directive to tell `coverage` to exclude them from `coverage` consideration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最后一个是缺失测试的有效指示，但`manage.py`中的缺失行和我们的测试代码中的缺失行并不是我们真正关心的事情，因为它们并没有报告我们应用代码的缺失覆盖。实际上，如果我们很仔细，我们可能会希望确保我们的测试代码在不同的设置下运行了几次，但让我们暂时假设我们只对我们应用代码的覆盖率感兴趣。`coverage`模块支持几种不同的方法来排除报告中的代码。一种可能性是在源代码行上注释`#
    pgrama no cover`指令，告诉`coverage`将其排除在覆盖率考虑之外。
- en: Alternatively, `coverage` provides a Python API that supports specifying regular
    expressions for code constructs that should be automatically excluded, and also
    for limiting the modules included in reports. This Python API is more powerful
    than what is available through the command line, and more convenient than manually
    annotating source with `# pragma` directives. We might, then, start looking into
    how to write some `coverage` utility scripts to easily generate coverage reports
    for the tests of our application code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`coverage`提供了一个Python API，支持指定应自动排除的代码结构的正则表达式，还支持限制报告中包含的模块。这个Python API比命令行提供的功能更强大，比手动使用`#
    pragma`指令注释源代码更方便。因此，我们可以开始研究如何编写一些`coverage`实用程序脚本，以便轻松生成我们应用代码的测试覆盖率报告。
- en: Before embarking on that task, though, we might wonder if anyone has already
    done the same and provided a ready-to-use utility that integrates `coverage` with
    the Django test support. Some searching on the Web shows that the answer is yes—there
    are several blog postings discussing the subject, and at least one project packaged
    as a Django application. Use of this package is discussed next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始这项任务之前，我们可能会想知道是否有人已经做过同样的事情，并提供了一个集成`coverage`与Django测试支持的即插即用的工具。在网上搜索后发现答案是肯定的——有几篇博客文章讨论了这个主题，至少有一个项目打包为Django应用程序。接下来将讨论使用这个包。
- en: Integrating coverage into a Django project
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将覆盖率集成到Django项目中
- en: 'George Song and Mikhail Korobov provide a Django application named `django_coverage`
    that supports integrating `coverage` into testing for a Django project. Like the
    base `coverage` package, `django_coverage` can be found on PyPI: [http://pypi.python.org/pypi/django-coverage](http://pypi.python.org/pypi/django-coverage).
    The version used here is 1.0.1.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: George Song和Mikhail Korobov提供了一个名为`django_coverage`的Django应用程序，支持将`coverage`集成到Django项目的测试中。与基本的`coverage`包一样，`django_coverage`可以在PyPI上找到：[http://pypi.python.org/pypi/django-coverage](http://pypi.python.org/pypi/django-coverage)。这里使用的版本是1.0.1。
- en: 'The `django_coverage` package offers integration of `coverage` with Django
    using both of the methods previously discussed. First, it provides a test runner
    that can be specified in `settings.py`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`django_coverage`包提供了将`coverage`与Django集成的方法，使用了之前讨论过的两种方法。首先，它提供了一个可以在`settings.py`中指定的测试运行程序：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this option, every time you run `manage.py test`, coverage information
    will be generated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个选项，每次运行`manage.py test`时都会生成覆盖信息。
- en: Alternatively, `django_coverage` can be included in `INSTALLED_APPS`. When this
    approach is used, the `django_coverage` application provides a new management
    command, named `test_coverage`. The `test_coverage` command can be used instead
    of `test` to run tests and generate coverage information. Since generating coverage
    information does make the tests run a bit more slowly, the second option is what
    we will use here. That way, we can choose to run tests without coverage data when
    we are interested in fast execution and not concerned with checking on coverage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`django_coverage`也可以包含在`INSTALLED_APPS`中。当使用这种方法时，`django_coverage`应用程序提供了一个名为`test_coverage`的新管理命令。`test_coverage`命令可以用来代替`test`来运行测试并生成覆盖信息。由于生成覆盖信息会使测试运行得更慢，我们将使用第二个选项。这样，我们可以选择在对速度要求较高且不关心覆盖率时运行测试。
- en: Beyond listing `django_coverage` in `INSTALLED_APPS`, nothing needs to be done
    to set up `django_coverage` to run with our project. It comes with a sample `settings.py`
    file that shows the settings it supports, all with default options and comments
    describing what they do. We can override any of the default settings provided
    in `django_coverage/settings.py` by specifying our preferred value in our own
    settings file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将`django_coverage`列在`INSTALLED_APPS`中之外，无需进行任何设置即可使`django_coverage`与我们的项目一起运行。它带有一个示例`settings.py`文件，显示了它支持的设置，所有设置都有默认选项和注释描述其作用。我们可以通过在我们自己的设置文件中指定我们喜欢的值来覆盖`django_coverage/settings.py`中提供的任何默认设置。
- en: 'We will start, though, by using all the default settings values provided. When
    we run `python manage.py test_coverage survey`, we will get coverage information
    displayed at the end of the test output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们将首先使用提供的所有默认设置值。当我们运行`python manage.py test_coverage survey`时，我们将在测试输出的末尾看到覆盖信息：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That is a bit curious. Recall that the `coverage` package reported in the previous
    section that one line of code in `survey.models` was not exercised by tests—the
    `__unicode__` method of the `Question` model. This report, though, shows 100%
    coverage for `survey.models`. Looking closely at the two reports, we can see that
    the statements that count for the listed modules are all lower in the `django_coverage`
    report than they were in the `coverage` report.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点奇怪。回想一下，在上一节中，`coverage`包报告说`survey.models`中的一行代码没有被测试覆盖——`Question`模型的`__unicode__`方法。然而，这个报告显示`survey.models`的覆盖率为100%。仔细观察这两份报告，我们可以看到列出的模块的语句在`django_coverage`报告中都比在`coverage`报告中低。
- en: This difference is due to the default value of the `COVERAGE_CODE_EXCLUDES`
    setting used by `django_coverage`. The default value of this setting causes all
    `import` lines, all `__unicode__` method definitions, and all `get_absolute_url`
    method definitions to be excluded from consideration. These default exclusions
    account for the differences seen here between the two reports. If we don't like
    this default behavior, we can supply our own alternate setting, but for now, we
    will leave it as it is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异是由`django_coverage`使用的`COVERAGE_CODE_EXCLUDES`设置的默认值造成的。此设置的默认值导致所有`import`行、所有`__unicode__`方法定义和所有`get_absolute_url`方法定义都被排除在考虑范围之外。这些默认排除导致了这两份报告之间的差异。如果我们不喜欢这种默认行为，我们可以提供自己的替代设置，但现在我们将保持原样。
- en: Furthermore, some modules listed by `coverage` are completely missing from the
    `django_coverage` report. These too are the result of a default setting value
    (in this case, `COVERAGE_MODULE_EXCLUDES`) and there is a message in the output
    noting which modules have been excluded due to this setting. As you can see, the
    `__init__`, `tests`, and `urls` modules inside `survey` were all automatically
    excluded from coverage consideration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`coverage`列出的一些模块在`django_coverage`报告中完全缺失。这也是默认设置值的结果（在这种情况下是`COVERAGE_MODULE_EXCLUDES`），输出中有一条消息指出由于此设置而被排除的模块。正如你所看到的，`survey`中的`__init__`、`tests`和`urls`模块都被自动排除在覆盖范围之外。
- en: 'However, `templates` and `fixtures` are not excluded by default, and that caused
    a problem as they are not actually Python modules, so they cannot be imported.
    To get rid of the message about problems loading these, we can specify a value
    for `COVERAGE_MODULE_EXCLUDES` in our own `settings.py` file and include these
    two. Adding them to the default list, we have:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认情况下不排除`templates`和`fixtures`，这导致了一个问题，因为它们实际上不是Python模块，所以不能被导入。为了摆脱关于加载这些问题的消息，我们可以在自己的`settings.py`文件中为`COVERAGE_MODULE_EXCLUDES`指定一个值，并包括这两个。将它们添加到默认列表中，我们有：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we run the `test_coverage` command again after making this change, we will
    see that the message about problems loading some modules is gone.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在进行此更改后再次运行`test_coverage`命令，我们将看到关于加载某些模块存在问题的消息已经消失了。
- en: 'The summary information displayed with the test output is useful, but even
    better are the HTML reports `django_coverage` can generate. To get these, we must
    specify a value for the `COVERAGE_REPORT_HTML_OUTPUT_DIR` setting, which is `None`
    by default. So, we can create a `coverage_html` directory in `/dj_projects/marketr`
    and specify it in `settings.py`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在测试输出中的摘要信息很有用，但更好的是`django_coverage`可以生成的HTML报告。要获得这些报告，我们必须为`COVERAGE_REPORT_HTML_OUTPUT_DIR`设置指定一个值，默认值为`None`。因此，我们可以在`/dj_projects/marketr`中创建一个`coverage_html`目录，并在`settings.py`中指定它：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The HTML reports are not particularly interesting when code coverage comes
    in at 100 percent. Hence, to see the full usefulness of the reports, let''s run
    just a single test, say the admin test for trying to add a `Survey` with a `closes`
    date that is earlier than its `opens` date:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码覆盖率达到100％时，HTML报告并不特别有趣。因此，为了看到报告的完整用处，让我们只运行单个测试，比如尝试使用`closes`日期早于其`opens`日期的`Survey`的管理员测试：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, since we have specified a directory for HTML coverage reports, instead
    of getting the summary coverage information at the end of the test run, we see:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，由于我们为HTML覆盖率报告指定了一个目录，所以在测试运行结束时，我们看到的不是摘要覆盖率信息，而是：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can use a web browser to load the `index.html` file that has been
    placed in the `coverage_html` directory. It will look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Web浏览器加载放置在`coverage_html`目录中的`index.html`文件。它会看起来像这样：
- en: '![Integrating coverage into a Django project](img/7566_05_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![将覆盖率整合到Django项目中](img/7566_05_01.jpg)'
- en: 'Since we ran just a single test, we only got partial coverage of our code.
    The **% covered** values in the HTML report are color-coded to reflect how well
    covered each module is. Green is good, yellow is fair, and red is poor. In this
    case, since we ran one of the admin tests, only **survey.admin** is colored green,
    and it is not 100 percent. To see what was missed in that module, we can click
    on the **survey.admin** link:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只运行了单个测试，我们只对我们的代码进行了部分覆盖。HTML报告中的**％ covered**值以颜色编码方式反映了每个模块的覆盖情况。绿色是好的，黄色是一般，红色是差的。在这种情况下，由于我们运行了其中一个管理员测试，只有**survey.admin**被标记为绿色，而且它并不是100％。要查看该模块中遗漏的内容，我们可以点击**survey.admin**链接：
- en: '![Integrating coverage into a Django project](img/7566_05_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![将覆盖率整合到Django项目中](img/7566_05_02.jpg)'
- en: Reports like this provide a very convenient way to determine the parts of our
    application code that are covered by testing and the parts that are not. Lines
    not executed are highlighted in red. Here, we only ran the test that exercises
    the error path through the `SurveyFrom clean` method, so the successful code path
    through that method comes up in red. In addition, the color coding of the `import`
    lines indicates that they were excluded. This is due to the default `COVERAGE_CODE_EXCLUDES`
    setting. Finally, the six empty lines in the file were ignored (lines with comments
    would also be ignored).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的报告提供了一种非常方便的方式来确定我们的应用程序代码中哪些部分被测试覆盖，哪些部分没有被测试覆盖。未执行的行会以红色高亮显示。在这里，我们只运行了通过`SurveyFrom
    clean`方法的错误路径的测试，所以该方法的成功代码路径以红色显示。此外，`import`行的颜色编码表明它们被排除了。这是由于默认的`COVERAGE_CODE_EXCLUDES`设置。最后，文件中的六行空行被忽略了（带有注释的行也会被忽略）。
- en: Using a tool like `coverage` is essential for ensuring that a test suite is
    doing its job. It is likely that in the future, Django will provide some integrated
    code coverage support. But in the meantime, as we have seen, it is not difficult
    to integrate `coverage` as an add-on to our projects. In the case of `django_coverage`,
    it provides options for using either of the ways of extending Django discussed
    earlier. The next integration task we will discuss requires neither, but rather
    needs only the standard Python hooks into unit test set up and tear down.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`coverage`这样的工具对于确保测试套件正常运行至关重要。未来，Django可能会提供一些集成的代码覆盖支持。但与此同时，正如我们所看到的，将`coverage`作为项目的附加组件集成并不困难。在`django_coverage`的情况下，它提供了使用之前讨论过的Django扩展方式的选项。我们将讨论的下一个集成任务既不需要这两种方式，也只需要标准的Python钩子来设置和拆卸单元测试。
- en: The twill web browsing and testing tool
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: twill网络浏览和测试工具
- en: '`twill` is a Python package that supports command-line interaction with web
    sites, primarily for testing purposes. Like the `coverage` and `django_coverage`
    packages, twill can be found on PyPI: [http://pypi.python.org/pypi/twill](http://pypi.python.org/pypi/twill).
    While `twill` offers a command-line tool for interactive use, the commands it
    provides are also available from a Python API, meaning it is possible to use `twill`
    from within a Django `TestCase`. When we do this, we essentially replace use of
    the Django test `Client` with an alternative `twill` implementation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`twill`是一个支持与网站进行命令行交互的Python包，主要用于测试目的。与`coverage`和`django_coverage`包一样，twill可以在PyPI上找到：[http://pypi.python.org/pypi/twill](http://pypi.python.org/pypi/twill)。虽然`twill`提供了一个用于交互使用的命令行工具，但它提供的命令也可以通过Python
    API使用，这意味着可以在Django `TestCase`中使用`twill`。当我们这样做时，我们实质上是用替代的`twill`实现替换了Django测试`Client`的使用。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the latest official release of `twill` available on PyPI (0.9 at the
    time of this writing) is quite old. The latest development release is available
    at [http://darcs.idyll.org/~t/projects/twill-latest.tar.gz](http://darcs.idyll.org/~t/projects/twill-latest.tar.gz).
    Output from the latest development release as of January 2010 is what is shown
    in this section. The code included here was also tested with the official 0.9
    release. Everything works using the older `twill` code, but the error output from
    `twill` is slightly less helpful and there is some `twill` output that cannot
    be suppressed when running as part of a Django `TestCase`. Thus, I'd recommend
    the latest development release over the 0.9 release.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前在PyPI上可用的`twill`的最新官方版本（在撰写本文时为0.9）非常古老。最新的开发版本可在[http://darcs.idyll.org/~t/projects/twill-latest.tar.gz](http://darcs.idyll.org/~t/projects/twill-latest.tar.gz)上找到。截至2010年1月的最新开发版本的输出如本节所示。此处包含的代码也经过了官方的0.9版本测试。使用旧的`twill`代码一切正常，但`twill`的错误输出略显不足，而且在作为Django
    `TestCase`的一部分运行时，有些`twill`输出无法被抑制。因此，我建议使用最新的开发版本而不是0.9版本。
- en: 'Why would we want to use `twill` instead of the Django test `Client`? To understand
    the motivation for using `twill` instead of the Django test `Client`, let''s revisit
    the admin customization test from the last chapter. Recall that we provided a
    custom form for adding and editing `Survey` objects. This form has a `clean` method
    that raises a `ValidationError` on any attempt to save a `Survey` with an `opens`
    date later than its `closes` date. The test to ensure that `ValidationError` is
    raised when it should be looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要使用`twill`而不是Django测试`Client`？为了理解使用`twill`而不是Django测试`Client`的动机，让我们重新审视上一章的管理员定制测试。回想一下，我们为添加和编辑`Survey`对象提供了一个自定义表单。这个表单有一个`clean`方法，对于任何试图保存`opens`日期晚于其`closes`日期的`Survey`都会引发`ValidationError`。确保在应该引发`ValidationError`时引发它的测试如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that this test sends a POST to the server containing a dictionary of
    POST data without ever having issued a GET for the page. This caused a problem
    at first: recall that we did not initially include the `question_set-TOTAL_FORMS`
    and `question_set-INITIAL_FORMS` values in the POST dictionary. We were focused
    on testing the `Survey` part of the form on the page and did not realize the formset
    used by admin to display `Questions` in line with `Surveys` required these other
    values. When we found they were needed, we somewhat cavalierly set their values
    to `0` and hoped that would be acceptable for what we wanted to test.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个测试向服务器发送了一个包含POST数据字典的POST，而没有发出GET请求来获取页面。这最初引起了问题：回想一下，我们最初没有在POST字典中包含`question_set-TOTAL_FORMS`和`question_set-INITIAL_FORMS`的值。我们当时专注于测试页面上表单的`Survey`部分，并没有意识到管理员用于显示`Surveys`中的`Questions`的表单集需要这些其他值。当我们发现它们是必需的时，我们有点鲁莽地将它们的值设置为`0`，并希望这对我们想要测试的内容是可以接受的。
- en: A better approach would have been to first `get` the survey add page. The response
    would include a form with a set of initial values that could be used as the basis
    for the dictionary to `post` back. Before issuing the `post` request, we would
    change only the values necessary for our test (`title`, `opens`, and `closes`).
    Thus, when we did issue the `post` call, any other form values that the server
    had provided initially in the form would be sent back unchanged. We would not
    have to make up additional values for parts of the form that our test did not
    intend to change.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是首先`get`调查添加页面。响应将包括一个带有一组初始值的表单，可以用作`post`回去的字典的基础。在发出`post`请求之前，我们只需更改我们测试所需的值（`title`，`opens`和`closes`）。因此，当我们发出`post`调用时，服务器最初在表单中提供的任何其他表单值都将不变地发送回去。我们不必为测试不打算更改的表单部分编制额外的值。
- en: Besides being a more realistic server interaction scenario, this approach also
    ensures that the server is responding correctly to the GET request. Testing the
    GET path isn't necessary in this particular case since the additional validation
    we added to admin doesn't affect how it responds to a GET of the page. However,
    for one of our own views that provides a form in the response, we would want to
    test the response to `get` as well as `post`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更真实地模拟服务器交互场景之外，这种方法还确保服务器正确响应GET请求。在这种特殊情况下，测试GET路径并不是必要的，因为我们在管理员中添加的额外验证不会影响其对页面的GET响应。但是，对于我们自己的视图中提供响应的表单，我们希望测试对`get`和`post`的响应。
- en: So why didn't we write the test that way? The test `Client` supports `get` as
    well as `post`; we certainly could start off by retrieving the page containing
    the form. The problem is that the returned response is HTML, and the Django test
    `Client` doesn't provide any utility functions to parse the HTML form and turn
    it into something we can easily manipulate. There is no straightforward way for
    Django to just take the response, change a few values in the form, and `post`
    it back to the server. The `twill` package, on the other hand, makes this easy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们不以这种方式编写测试呢？测试`Client`支持`get`和`post`；我们当然可以通过检索包含表单的页面来开始。问题在于返回的响应是HTML，而Django测试`Client`没有提供任何实用函数来解析HTML表单并将其转换为我们可以轻松操作的内容。Django没有直接的方法来获取响应，更改表单中的一些值，然后将其`post`回服务器。另一方面，`twill`包可以轻松实现这一点。
- en: In the following sections, we will re-implement the `AdminSurveyTest` using
    `twill`. First, we'll see how to use its command line tool and then transfer what
    we learn into a Django `TestCase`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用`twill`重新实现`AdminSurveyTest`。首先，我们将看到如何使用其命令行工具，然后将我们学到的内容转移到Django
    `TestCase`中。
- en: Using the twill command line program
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用twill命令行程序
- en: 'The `twill` package includes a shell script, named `twill-sh`, to allow command-line
    testing. This is a convenient way to do some initial testing and figure out what
    the test case code will need to do. From the shell program, we can use the `go`
    command to visit a page. Once we''ve visited a page, we can use the `showforms`
    command to see what forms are on the page, and what fields and initial values
    the forms contain. Since we are going to use `twill` to re-implement the `AdminSurveyTest`,
    let''s see what visiting the `Survey` add page for our test server produces:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: “twill”包括一个名为“twill-sh”的shell脚本，允许进行命令行测试。这是一种方便的方法，可以进行一些初始测试，并找出测试用例代码需要做什么。从shell程序中，我们可以使用“go”命令访问页面。一旦我们访问了一个页面，我们可以使用“showforms”命令查看页面上有哪些表单，表单包含哪些字段和初始值。由于我们将使用“twill”重新实现“AdminSurveyTest”，让我们看看为我们的测试服务器访问“Survey”添加页面会产生什么：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Clearly, we didn''t actually get to the survey add page. Since we aren''t logged
    in, the server responded with a login page. We can fill the login form using the
    `formvalue` command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们实际上没有到达调查添加页面。由于我们没有登录，服务器响应了一个登录页面。我们可以使用“formvalue”命令填写登录表单：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The arguments to `formvalue` are first the form number, then the field name,
    and then the value we want to set for that field. Once we have filled the username
    and password in the form, we can `submit` the form:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “formvalue”的参数首先是表单编号，然后是字段名称，然后是我们要为该字段设置的值。一旦我们在表单中填写了用户名和密码，我们就可以“submit”表单了。
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the `submit` command optionally also accepts the name of the submit button
    to use. In the case where there is only one (as here), or if using the first submit
    button on the form is acceptable, we can simply use `submit` with no argument.
    Now that we have logged in, we can use `showforms` again to see if we have now
    really retrieved a `Survey` add page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“submit”命令还可以选择接受要使用的提交按钮的名称。在只有一个（就像这里）或者如果使用表单上的第一个提交按钮是可以接受的情况下，我们可以简单地使用没有参数的“submit”。现在我们已经登录，我们可以再次使用“showforms”来查看我们是否真的检索到了“Survey”添加页面：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That looks more like a `Survey` add page. And indeed, our setting of `question_set-TOTAL_FORMS`
    to `0` in our first test case is unrealistic, since the server actually serves
    up a form with that set to `4`. But it worked. This means that we did not have
    to manufacture values for the four inline questions, so it is not a fatal flaw.
    However, with `twill` we can take the more realistic path of leaving all those
    values as-is and just changing the fields we are interested in, again using the
    `formvalue` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个“Survey”添加页面。确实，我们在第一个测试用例中将“question_set-TOTAL_FORMS”设置为“0”是不现实的，因为服务器实际上提供了一个将其设置为“4”的表单。但它起作用了。这意味着我们不必为这四个内联问题制造值，因此这不是一个致命的缺陷。然而，使用“twill”，我们可以采取更现实的路径，将所有这些值保持不变，只改变我们感兴趣的字段，再次使用“formvalue”命令：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we submit that form, we expect the server to respond with the same form
    re-displayed and the `ValidationError` message text from our custom `clean` method.
    We can verify that the text is on the returned page using the `find` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交该表单时，我们期望服务器会用相同的表单重新显示，并显示来自我们自定义“clean”方法的“ValidationError”消息文本。我们可以使用“find”命令验证返回页面上是否有该文本：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That response to `find` may not make it immediately obvious whether it worked
    or not. Let''s see what it does with something that is most likely not on the
    page:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“find”的响应可能不会立即明显它是否起作用。让我们看看它对于页面上最有可能不存在的内容会做什么：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'OK, since `twill` clearly complains when the text is not found, the first `find`
    must have succeeded in locating the expected validation error text on the page.
    Now, we can use `showforms` again to see that indeed the server has sent back
    the form we submitted. Note that the initial values are what we submitted, not
    empty as they were when we first retrieved the page:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，由于“twill”明显在找不到文本时会抱怨，第一个“find”必须已经成功地在页面上找到了预期的验证错误文本。现在，我们可以再次使用“showforms”来查看服务器是否确实发送回我们提交的表单。请注意，初始值是我们提交的值，而不是我们第一次检索页面时的空值。
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, we can simply adjust one of the dates in order to make the form
    valid and try submitting it again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以简单地调整一个日期以使表单有效，并尝试再次提交它：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice the **current page** has changed to be the survey changelist page (there
    is no longer an `add` at the end of the URL path). This is a clue that the `Survey`
    add worked this time, as the server redirects to the changelist page on a successful
    save. There is a `twill` command to display the HTML contents of a page, named
    `show`. It can be useful to see which page has been returned when you've got a
    display window you can scroll back through. However, HTML pages aren't very useful
    when reproduced on paper, so it's not shown here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当前页面已更改为调查变更列表页面（URL路径末尾不再有“add”）。这是一个线索，表明“Survey”添加这次起作用了，因为服务器在成功保存后会重定向到变更列表页面。有一个名为“show”的twill命令用于显示页面的HTML内容。当你有一个可以滚动回去的显示窗口时，这可能很有用。然而，HTML页面在纸上复制时并不是很有用，所以这里不显示。
- en: There are also many more useful commands that `twill` provides that are beyond
    the scope of what we are covering now. The discussion here is intended to simply
    give a taste of what `twill` provides and show how to use it in a Django test
    case. This second task will be covered next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “twill”提供了许多更有用的命令，超出了我们现在所涵盖的范围。这里的讨论旨在简单地展示“twill”提供了什么，并展示如何在Django测试用例中使用它。下面将介绍第二个任务。
- en: Using twill in a TestCase
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在TestCase中使用twill
- en: What do we need to do to take what we've done in the `twill-sh` program and
    turn it into a `TestCase`? First, we will need to use `twill`'s Python API in
    the test code. The `twill` commands we used from within `twill-sh` are available
    in the `twill.commands` module. Additionally, `twill` provides a browser object
    (accessible via `twill.get_browser()`) that may be more appropriate to call from
    Python. The browser object version of a command may return a value, for example,
    instead of printing something on the screen. However, the browser object does
    not support all of the commands in `twill.commands` directly, thus it is common
    to use a mixture of `twill.commands` methods and browser methods. Mixing the usage
    is fine since the code in `twill.commands` internally operates on the same browser
    instance returned from `twill.get_browser()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做什么来将我们在`twill-sh`程序中所做的工作转换为`TestCase`？首先，我们需要在测试代码中使用`twill`的Python API。我们在`twill-sh`中使用的`twill`命令在`twill.commands`模块中可用。此外，`twill`提供了一个浏览器对象（通过`twill.get_browser()`访问），可能更适合从Python调用。命令的浏览器对象版本可能返回一个值，例如，而不是在屏幕上打印一些东西。然而，浏览器对象不直接支持`twill.commands`中的所有命令，因此通常使用混合`twill.commands`方法和浏览器方法是常见的。混合使用是可以的，因为`twill.commands`中的代码在从`twill.get_browser()`返回的同一个浏览器实例上运行。
- en: Second, for test code purposes, we'd like to instruct `twill` to interact with
    our Django server application code directly, instead of sending requests to an
    actual server. It's fine when using the `twill-sh` code to test against our running
    development server, but we don't want to have a server running in order for our
    tests to pass. The Django test `Client` does this automatically since it was written
    specifically to be used from test code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，出于测试代码的目的，我们希望指示`twill`直接与我们的Django服务器应用程序代码交互，而不是将请求发送到实际服务器。在使用`twill-sh`代码针对我们正在运行的开发服务器进行测试时，这是可以的，但我们不希望服务器在运行以使我们的测试通过。Django测试`Client`会自动执行这一点，因为它是专门编写用于从测试代码中使用的。
- en: 'With `twill`, we must call its `add_wsgi_intercept` method to tell it to route
    requests for a particular host and port directly to a WSGI application instead
    of sending the requests out on the network. Django provides a class that supports
    the WSGI application interface (named `WSGIHandler`) in `django.core.handlers.wsgi`.
    Thus, in our setup code for using `twill` in tests, we can include code like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`twill`，我们必须调用它的`add_wsgi_intercept`方法，告诉它将特定主机和端口的请求直接路由到WSGI应用程序，而不是将请求发送到网络上。Django提供了一个支持WSGI应用程序接口（名为`WSGIHandler`）的类，在`django.core.handlers.wsgi`中。因此，在我们的测试中使用`twill`的设置代码中，我们可以包含类似这样的代码：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This tells `twill` that a `WSGIHandler` instance should be used for the handling
    of any requests that are bound for the host named `twilltest` on the regular HTTP
    port, 80\. The actual hostname and port used here are not important; they must
    simply match the host name and port that our test code tries to access.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`twill`，一个`WSGIHandler`实例应该用于处理任何发送到名为`twilltest`的主机的端口80的请求。这里使用的实际主机名和端口不重要；它们只是必须与我们的测试代码尝试访问的主机名和端口匹配。
- en: 'This brings us to the third thing we must consider in our test code. The URLs
    we use with the Django test `Client` have no hostname or port components as the
    test `Client` does not perform any routing based on that information, but it rather
    just sends the request directly to our application code. The `twill` interface,
    on the other hand, does expect host (and optionally port) components in the URLs
    passed to it. Thus, we need to build URLs that are correct for `twill` and will
    be routed appropriately by it. Since we are generally using Django''s `reverse`
    to create our URLs during testing, a utility function that takes a named URL and
    returns the result of reversing it into a form that will be handled properly by
    `twill` will come in handy:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到我们的测试代码中必须考虑的第三件事。我们在Django测试`Client`中使用的URL没有主机名或端口组件，因为测试`Client`不基于该信息执行任何路由，而是直接将请求发送到我们的应用程序代码。另一方面，`twill`接口确实期望在传递给它的URL中包含主机（和可选端口）组件。因此，我们需要构建对于`twill`正确并且将被适当路由的URL。由于我们通常在测试期间使用Django的`reverse`来创建我们的URL，因此一个实用函数，它接受一个命名的URL并返回将其反转为`twill`可以正确处理的形式的结果将会很方便。
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that since we used the default HTTP port in the `add_wsgi_intercept` call,
    we do not need to include the port number in the URLs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们在`add_wsgi_intercept`调用中使用了默认的HTTP端口，因此我们不需要在URL中包含端口号。
- en: One thing to note about using the `WSGIHandler` application interface for testing
    is that this interface, by default, suppresses any exceptions raised during processing
    of a request. This is the same interface that is used, for example, by the `mod_wsgi`
    module when running under Apache. It would be unacceptable in such an environment
    for `WSGIHandler` to expose exceptions to its caller, thus it catches all exceptions
    and turns them into server error (HTTP 500) responses.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`WSGIHandler`应用程序接口进行测试的一件事是，默认情况下，该接口会抑制在处理请求时引发的任何异常。这是在生产环境中使用的相同接口，例如在Apache下运行时使用的`mod_wsgi`模块。在这样的环境中，`WSGIHandler`暴露异常给其调用者是不可接受的，因此它捕获所有异常并将它们转换为服务器错误（HTTP
    500）响应。
- en: Although suppressing exceptions is the correct behavior in a production environment,
    it is not very useful for testing. The server error response generated instead
    of the exception is completely unhelpful in determining where the problem originated.
    Thus, this behavior is likely to make it very hard to diagnose test failures in
    cases where the code under test raises an exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在生产环境中抑制异常是正确的行为，但在测试中并不是很有用。生成的服务器错误响应而不是异常完全无助于确定问题的根源。因此，这种行为可能会使诊断测试失败变得非常困难，特别是在被测试的代码引发异常的情况下。
- en: To fix this problem, Django has a setting, `DEBUG_PROPAGATE_EXCEPTIONS`, which
    can be set to `True` to tell the `WSGIHandler` interface to allow exceptions to
    propagate up. This setting is `False` by default and should never be set to `True`
    in a production environment. Our `twill` test setup code, however, should set
    it to `True` so that if an exception is raised during request processing, it will
    be seen when the test is run instead of being replaced by a generic server error
    response.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Django有一个设置`DEBUG_PROPAGATE_EXCEPTIONS`，可以设置为`True`，告诉`WSGIHandler`接口允许异常传播。这个设置默认为`False`，在生产环境中永远不应该设置为`True`。然而，我们的`twill`测试设置代码应该将其设置为`True`，这样如果在请求处理过程中引发异常，它将在测试运行时被看到，而不是被通用的服务器错误响应替换。
- en: One final wrinkle involved with using Django's `WSGIHandler` interface for testing
    concerns maintaining a single database connection for multiple web page requests
    made by a single test. Ordinarily, each request (GET or POST of a page) uses its
    own newly-established database connection. At the end of the processing for a
    successful request, any open transaction on the database connection is committed
    and the database connection is closed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django的`WSGIHandler`接口进行测试时的最后一个问题是保持单个数据库连接用于单个测试发出的多个网页请求。通常，每个请求（获取或提交页面）都使用自己新建立的数据库连接。对于成功请求的处理结束时，数据库连接上的任何打开事务都将被提交，并关闭数据库连接。
- en: 'However, as noted at the end of [Chapter 4](ch04.html "Chapter 4. Getting Fancier:
    Django Unit Test Extensions"), *Getting Fancier: Django Unit Test Extensions*,
    the `TestCase` code prevents any database commits issued by the code under test
    from actually reaching the database. Thus, when testing the database will not
    see the commit normally present at the end of a request, but instead will just
    see the connection closed. Some databases, such as PostgreSQL and MySQL with the
    InnoDB storage engine, will automatically rollback the open transaction in this
    situation. This will cause problems for tests that need to issue multiple requests
    and have database updates made by earlier requests be accessible to later requests.
    For example, any test that requires a login will run into trouble since the login
    information is stored in the `django_session` database table.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如在[第4章](ch04.html "第4章。变得更加复杂：Django单元测试扩展")的结尾所指出的，`TestCase`代码会阻止由测试代码发出的任何数据库提交实际到达数据库。因此，在测试数据库中将不会看到通常在请求结束时出现的提交，而是只会看到连接关闭。一些数据库，如具有InnoDB存储引擎的PostgreSQL和MySQL，将在这种情况下自动回滚打开的事务。这将对需要发出多个请求并且需要让先前请求所做的数据库更新对后续请求可访问的测试造成问题。例如，任何需要登录的测试都会遇到麻烦，因为登录信息存储在`django_session`数据库表中。
- en: One way to fix this would be to use a `TransactionTestCase` instead of a `TestCase`
    as the base class for all of our tests that use `twill`. With a `TransactionTestCase`,
    the commit that normally happens at the end of request processing will be sent
    to the database as usual. However, the process of resetting the database to a
    clean state between each test is much slower for a `TransactionTestCase` than
    `TestCase`, so this approach could considerably slow down our tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是将`TransactionTestCase`用作所有使用`twill`的测试的基类，而不是`TestCase`。使用`TransactionTestCase`，通常在请求处理结束时发生的提交将像往常一样发送到数据库。然而，在每个测试之间将数据库重置为干净状态的过程对于`TransactionTestCase`来说要比`TestCase`慢得多，因此这种方法可能会显著减慢我们的测试速度。
- en: An alternative solution is to prevent the closing of the database connection
    at the end of request processing. That way there is nothing to trigger the database
    to rollback any updates in the middle of a test. We can accomplish this by disconnecting
    the `close_connection` signal handler from the `request_finished` signal as part
    of the test `setUp` method. This is not a very clean solution, but it is worth
    the performance gain (and it is also what the test `Client` does to overcome the
    same problem).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是阻止在请求处理结束时关闭数据库连接。这样，在测试过程中就不会触发数据库在测试中间回滚任何更新。我们可以在测试的`setUp`方法中将`close_connection`信号处理程序与`request_finished`信号断开连接来实现这一点。这不是一个非常干净的解决方案，但这样做是值得的（这也是测试`Client`用来克服相同问题的方法）。
- en: 'Let''s start, then, by writing a `twill` version of the `setUp` method for
    the `AdminSurveyTest`. The test `Client` version from the previous chapter is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从为`AdminSurveyTest`编写一个`twill`版本的`setUp`方法开始。前一章中的测试`Client`版本如下：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `twill` version will need to do the same user creation steps, but something
    different for login. Instead of duplicating the user creation code, we will factor
    that out into a common base class (called `AdminTest`) for the `AdminSurveyTest`
    and the `twill` version `AdminSurveyTwillTest`. For logging into the `twill` version,
    we can fill in and submit the login form that will be returned if we attempt to
    go to any admin page before logging in. Thus, the `twill` version of `setUp` might
    look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`twill`版本将需要执行相同的用户创建步骤，但登录步骤会有所不同。我们将用户创建代码提取到一个公共基类（称为`AdminTest`）中，供`AdminSurveyTest`和`twill`版本的`AdminSurveyTwillTest`使用。对于`twill`版本的登录，我们可以填写并提交登录表单，如果在登录之前尝试访问任何管理员页面，将返回该表单。因此，`twill`版本的`setUp`可能如下所示：'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This `setUp` first calls the superclass `setUp` to create the admin user, and
    then saves the existing `DEBUG_PROPAGATE_EXCEPTIONS` setting before setting that
    to `True`. It then disconnects the `close_connection` signal handler from the
    `request_finished` signal. Next, it calls `twill.add_wsgi_intercept` to set up
    `twill` to route requests for the `twilltest` host to Django's `WSGIHandler`.
    For convenient access, it stashes the `twill` browser object in `self.browser`.
    It then uses the previously mentioned `reverse_for_twill` utility function to
    create the appropriate URL for the admin index page, and calls the browser `go`
    method to retrieve that page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`setUp`首先调用超类`setUp`来创建管理员用户，然后保存现有的`DEBUG_PROPAGATE_EXCEPTIONS`设置，然后将其设置为`True`。然后，它断开`close_connection`信号处理程序与`request_finished`信号的连接。接下来，它调用`twill.add_wsgi_intercept`来设置`twill`以将对`twilltest`主机的请求路由到Django的`WSGIHandler`。为了方便访问，它将`twill`浏览器对象存储在`self.browser`中。然后，它使用先前提到的`reverse_for_twill`实用函数来创建管理员索引页面的适当URL，并调用浏览器`go`方法来检索该页面。
- en: The returned page should have a single form containing `username` and `password`
    fields. These are set to the values for the user created by the superclass `setUp`
    using the `formvalue` command, and the form is submitted using the browser `submit`
    method. The result should be the admin index page, if the login works. That page
    will have the string `Welcome` on it, so the last thing this `setUp` routine does
    is verify that text is found on the page, so that if the login failed an error
    is raised at the point the problem was encountered rather than later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的页面应该有一个包含`用户名`和`密码`字段的表单。这些字段设置为由超类`setUp`创建的用户的值，使用`formvalue`命令，并使用浏览器`submit`方法提交表单。如果登录成功，结果应该是管理员索引页面。该页面上将有字符串`Welcome`，因此这个`setUp`例程的最后一件事是验证页面上是否找到了文本，这样如果登录失败，错误就会在遇到问题的地方而不是后来引发。
- en: 'When we write `setUp`, we should also write the companion `tearDown` method
    to undo the effects of `setUp`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`setUp`时，我们还应该编写相应的`tearDown`方法来撤消`setUp`的影响：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we `go` to the admin logout page to log out from the admin site, call
    `remove_wsgi_intercept` to remove the special routing for the host named `twilltest`,
    reconnect the normal `close_connection` signal handler to the `request_finished`
    signal, and lastly restore the old value of `DEBUG_PROPAGATE_EXCEPTIONS`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们`go`到管理员注销页面以从管理员站点注销，调用`remove_wsgi_intercept`以删除名为`twilltest`的主机的特殊路由，重新连接正常的`close_connection`信号处理程序到`request_finished`信号，最后恢复`DEBUG_PROPAGATE_EXCEPTIONS`的旧值。
- en: 'A `twill` version of the test case routine that checks for the error case of
    `closes` being earlier than `opens` would then be:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个检查`closes`早于`opens`的错误情况的`twill`版本的测试例程将是：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unlike the test `Client` version, here we start by visiting the admin `Survey`
    add page. We expect the response to contain a single form, and set the values
    in it for `title`, `opens`, and `closes`. We don't care about anything else that
    may be in the form and leave it unchanged. We then `submit` the form.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试`Client`版本不同，这里我们首先访问管理员`Survey`添加页面。我们期望响应包含一个单独的表单，并为其中的`title`、`opens`和`closes`设置值。我们不关心表单中可能还有什么，所以保持不变。然后我们`submit`表单。
- en: We expect that in the error case (which this should be, given that we made `closes`
    one day before `opens`) the admin will redisplay the same page with an error message.
    We test for this by first using the `twill url` command to test that the current
    URL is still the `Survey` add page URL. We then also use the `twill find` command
    to verify that the expected error message is found on the page. (It's probably
    only necessary to perform one of those checks, but it doesn't hurt to do both.
    Hence, both are included here for illustration purposes.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在错误情况下（鉴于我们将`closes`设置为比`opens`早一天，这应该是错误情况），管理员将重新显示相同的页面，并显示错误消息。我们通过首先使用`twill
    url`命令来测试当前URL是否仍然是`Survey`添加页面的URL来测试这一点。然后，我们还使用`twill find`命令来验证页面上是否找到了预期的错误消息。（可能只需要执行其中一个检查，但同时执行两个不会有害。因此，这里包括了两个以示例目的。）
- en: 'If we now run this test with `python manage.py test survey.AdminSurveyTwillTest`,
    we will see that it works, but `twill` is a bit chatty, even when using the Python
    API. At the end of the test output, we will see:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用`python manage.py test survey.AdminSurveyTwillTest`运行这个测试，我们会看到它可以工作，但即使使用Python
    API，`twill`也有点啰嗦。在测试输出的末尾，我们会看到：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''d rather not have output from `twill` cluttering up our test output, so
    we''d like to redirect this output elsewhere. Luckily, `twill` provides a routine
    for this, `set_output`. So, we can add the following to our `setUp` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望`twill`的输出混乱了我们的测试输出，所以我们希望将这些输出重定向到其他地方。幸运的是，`twill`提供了一个用于此目的的例程，`set_output`。因此，我们可以将以下内容添加到我们的`setUp`方法中：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Place this prior to any `twill` commands that print output, and remember to
    include `from StringIO import StringIO` among the imports before referencing `StringIO`.
    We should also undo this in our `tearDown` routine by calling `twill.commands.reset_output()`
    there. That will restore the `twill` default behavior of sending output to the
    screen. After making those changes, if we run the test again, we will see that
    it passes, and the `twill` output is no longer present.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印输出的任何`twill`命令之前放置这个，并记得在引用`StringIO`之前在导入中包括`from StringIO import StringIO`。我们还应该在我们的`tearDown`例程中通过调用`twill.commands.reset_output()`来撤消这一点。这将恢复`twill`将输出发送到屏幕的默认行为。做出这些更改后，如果我们再次运行测试，我们会看到它通过了，并且`twill`的输出不再存在。
- en: 'The last piece to write, then, is the test case for adding a `Survey` with
    dates that do not trigger the validation error. It might look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后要编写的是添加一个`Survey`的测试用例，其中日期不会触发验证错误。它可能看起来像这样：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is much like the previous test except we attempt to verify that we are
    redirected to the admin changelist page on the expected successful submit. If
    we run this test, it will pass, but it is actually not correct. That is, it will
    not fail if in fact the admin re-displays the add page instead of redirecting
    to the changelist page. Thus, if we have broken something and caused submits that
    should be successful to fail, this test won't catch that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的测试非常相似，只是我们尝试验证在预期的成功提交时是否重定向到管理员changelist页面。如果我们运行这个测试，它会通过，但实际上是不正确的。也就是说，如果管理员重新显示添加页面而不是重定向到changelist页面，它将不会失败。因此，如果我们破坏了某些东西并导致应该成功的提交失败，这个测试将无法捕捉到。
- en: To see this, change the `closes` date in this test case to be one day before
    `opens`. This will trigger an error as it does in the `testAddSurveyError` method.
    However, if we run the test with that change, it will still pass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这一点，将这个测试用例中的`closes`日期更改为`opens`之前一天。这将触发一个错误，就像`testAddSurveyError`方法中的情况一样。然而，如果我们进行了这个更改运行测试，它仍然会通过。
- en: 'The reason for this is that the `twill url` command takes a regular expression
    as its argument. It isn''t checking for an exact match of the passed argument
    with the actual URL, but rather that the actual URL matches the regular expression
    passed to the `url` command. The changelist URL that we are passing into the `url`
    method is:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`twill url`命令以正则表达式作为其参数。它不是检查传递的参数与实际URL的精确匹配，而是实际URL是否与传递给`url`命令的正则表达式匹配。我们传递给`url`方法的changelist
    URL是：
- en: '`http://twilltest/admin/survey/survey/`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://twilltest/admin/survey/survey/`'
- en: 'The URL for the add page that will be re-displayed in case of an error on submit
    will be:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交时出现错误时，将重新显示添加页面的URL将是：
- en: '`http://twilltest/admin/survey/survey/add/`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://twilltest/admin/survey/survey/add/`'
- en: 'An attempt to match the add page URL with the changelist page URL will be successful,
    since the changelist URL is contained within the add page URL. Thus, the `twill
    url` command will not raise an error as we want it to. To fix this, we must indicate
    in the regular expression we pass into `url` that we require the actual URL to
    end as the value we are passing in ends, by including an end of string marker
    on the value we pass:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将添加页面URL与changelist页面URL进行匹配将成功，因为changelist URL包含在添加页面URL中。因此，`twill url`命令不会像我们希望的那样引发错误。为了解决这个问题，我们必须在传递给`url`的正则表达式中指示，我们要求实际URL以我们传递的值结束，通过在我们传递的值上包含一个字符串结束标记：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We could also include a string marker at the beginning, but that isn''t actually
    required to fix this particular problem. If we make that change and leave in the
    incorrect `closes` date setting, we will see that this test case now does fail
    as it should when the server re-displays the add page, instead of successfully
    processing the submit:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在开头包括一个字符串标记，但实际上并不需要修复这个特定问题。如果我们进行这个更改，保留不正确的`closes`日期设置，我们会看到这个测试用例现在确实失败了，当服务器重新显示添加页面时，而不是成功处理提交：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once we verify the test does fail in the case where the server does not respond
    as we expect, we can restore the `closes` date setting to be acceptable for saving
    and again the tests will pass. One lesson here is to be careful when using the
    `url` command that `twill` provides. A second lesson is to always attempt to verify
    that a test will report failure when appropriate. When focusing on writing tests
    that pass, we can often forget to verify that tests will properly fail when they
    should.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证测试在服务器不按预期响应的情况下失败，我们可以将`closes`日期设置恢复为可接受的保存，并且测试将再次通过。这里的一个教训是在使用`twill`提供的`url`命令时要小心。第二个教训是始终尝试验证测试在适当时报告失败。当专注于编写通过的测试时，我们经常忘记验证测试在应该失败时是否能够正确失败。
- en: We've now got working `twill`-based versions of our admin customization tests.
    Achieving that was not exactly easy—the need for some of the `setUp` code, for
    example, is not necessarily immediately obvious. However, once in place it can
    be easily reused by tests that require more sophisticated form manipulation than
    we needed here. Form manipulation is a weak point of Django's test framework,
    and it is unlikely that it will be addressed in Django by the addition of functions
    that would duplicate functions already available in external tools. It is more
    likely that in the future, Django will offer more easy integration with `twill`
    or another tool like it. Therefore, investing in learning how to use a tool like
    `twill` is likely a good use of time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了基于`twill`的工作版本的管理员定制测试。实现这一点并不容易——例如，一些`setUp`代码的需求并不一定立即显而易见。然而，一旦放置，它可以很容易地被需要比我们在这里需要的更复杂的表单操作的测试所重用。表单操作是Django测试框架的一个薄弱点，而且不太可能通过在Django中添加重复外部工具中已有的函数的函数来解决这个问题。更有可能的是，在将来，Django将提供更容易与`twill`或类似工具集成。因此，投资学习如何使用类似`twill`的工具可能是一个很好的时间利用。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This brings us to the end of discussing the testing of Django applications.
    In this chapter, we focused on how to fill in any gaps of testing functions within
    Django by integrating with other test tools. It is impossible to cover the specifics
    of integrating with every tool out there, but we learned the general mechanisms
    available and discussed a couple of examples in detail. This provides a solid
    foundation for understanding how to accomplish the task in general.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们结束了讨论Django应用程序的测试。在本章中，我们重点介绍了如何通过与其他测试工具集成来填补Django中测试函数的任何空白。不可能涵盖与每个工具集成的具体细节，但我们学习了可用的一般机制，并详细讨论了一些例子。这为理解如何一般完成任务提供了坚实的基础。
- en: 'As Django continues to develop, such gaps may become fewer, but it is unlikely
    that Django will ever be able to provide everything that everyone wants in terms
    of testing support. In some cases, Python''s class inheritance structure and unit
    test extension mechanisms allow for straightforward integration of other test
    tools into Django test cases. In other cases, this is not sufficient. Thus, it
    is helpful that Django also provides hooks for adding additional functionality.
    In this chapter, we:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Django的不断发展，这样的空白可能会变得更少，但是Django不太可能能够在测试支持方面提供每个人都想要的一切。在某些情况下，Python的类继承结构和单元测试扩展机制允许将其他测试工具直接集成到Django测试用例中。在其他情况下，这是不够的。因此，Django提供了用于添加额外功能的钩子是有帮助的。在本章中，我们：
- en: Learned what hooks Django provides for adding test functions
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了Django为添加测试功能提供的钩子
- en: Saw an example of how these hooks can be used, specifically in the case of adding
    code coverage reporting
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到了这些钩子如何被使用的例子，特别是在添加代码覆盖报告的情况下
- en: Also explored an example where using these hooks was not necessary—when integrating
    the use of the `twill` test tool into our Django test cases
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还探讨了一个例子，在这个例子中，使用这些钩子是不必要的——当将“twill”测试工具集成到我们的Django测试用例中时
- en: In the next chapter, we will move from testing to debugging, and begin to learn
    what facilities Django provides to aid in debugging our Django applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从测试转向调试，并开始学习Django提供的哪些设施来帮助调试我们的Django应用程序。
