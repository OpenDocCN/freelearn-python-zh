- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Simulators for Other Architectures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他架构的模拟器
- en: In this chapter, you will learn how to create simulators for different instruction
    set architectures, for example, the stack-based computer and the classic CISC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建不同指令集架构的模拟器，例如基于栈的计算机和经典的CISC。
- en: After describing a simple stack-based calculator, TC0, we will introduce a simulator
    for a one-address format. Most operations take place between an accumulator (i.e.,
    register) and the contents of a memory location; for example, `ADD Y` means *add
    the contents of memory location Y to the accumulator*. The term *accumulator*
    indicates the location where the result of an addition is *accumulated*. Early
    microprocessors lacked room on the silicon chip for multiple registers, and all
    data had to pass through one or two accumulators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了一个简单的基于栈的计算器TC0之后，我们将介绍一个单地址格式的模拟器。大多数操作发生在累加器（即寄存器）和内存位置的内容之间；例如，`ADD Y`意味着*将内存位置Y的内容加到累加器中*。术语*累加器*表示加法结果*累积*的位置。早期的微处理器在硅芯片上缺乏多个寄存器的空间，所有数据都必须通过一个或两个累加器。
- en: After that, we will simulate a CISC architecture, which is an extension of the
    accumulator-based machine, where you can perform an operation on the contents
    of memory and on-chip registers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将模拟一个CISC架构，它是基于累加器的机器的扩展，其中可以在内存内容和片上寄存器的存储内容上执行操作。
- en: Finally, we will present the code of TC4\. This is a simulator for a non-von
    Neumann machine with separate address and data memories and where the address
    and data word lengths differ.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示TC4的代码。这是一个非冯·诺依曼机器的模拟器，具有独立的地址和数据存储器，并且地址和数据字长度不同。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: 'TC0: A Stack-Based Calculator'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC0：基于栈的计算器
- en: 'TC2: A One-Address Accumulator Machine'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC2：单地址累加器机器
- en: 'TC3: A CISC Machine with a Register-to-Memory Architecture'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC3：具有寄存器到内存架构的CISC机器
- en: The Complete TC3 Code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的TC3代码
- en: Arithmetic and Logic Unit (ALU)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术逻辑单元（ALU）
- en: 'A Final Example: TC4'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个示例：TC4
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的程序，网址为[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08)。
- en: 'TC0: A stack-based calculator'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC0：基于栈的计算器
- en: We’ll begin with a very simple s*tack-based calculator*. Here, we’ll introduce
    a zero-address machine that avoids explicit operand addresses by storing data
    on a stack. We have included the notion of a stack-based computer for two reasons.
    First, it forms the basis of many classic calculators, a programming language
    (FORTH) and the design of a classic computer (Burroughs B5000). Second, constructing
    a stack-based computer is very easy and you can experiment with this class of
    computer. Indeed, elements of a stack-based processor can easily be incorporated
    into any computer. In a conventional computer, two elements are added with an
    operation such as `ADD A,B,C`. In a stack-based computer, two elements are added
    with `ADD`. There is no need for operand addresses because the elements to be
    added are the top two in a stack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常简单的*基于栈的计算器*开始。在这里，我们将介绍一种零地址机器，它通过在栈上存储数据来避免显式操作数地址。我们包含基于栈的计算机的概念有两个原因。首先，它是许多经典计算器、编程语言（FORTH）和经典计算机（Burroughs
    B5000）设计的基础。其次，构建基于栈的计算机非常简单，您可以实验这类计算机。实际上，基于栈处理器的元素可以轻松地集成到任何计算机中。在传统计算机中，两个元素通过如`ADD
    A,B,C`这样的操作相加。在基于栈的计算机中，两个元素通过`ADD`相加。不需要操作数地址，因为要相加的元素是栈顶的两个元素。
- en: The computer we describe here is called TC0 to indicate that it is a proto-simulator,
    rather than a full simulator (it cannot execute conditional operations).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的计算机被称为TC0，以表明它是一个原型模拟器，而不是完整的模拟器（它无法执行条件操作）。
- en: The stack is a data structure in the form of a queue. Items enter the queue
    at the top and leave the queue in the reverse order to that in which they entered.
    It’s called a *stack* because it behaves exactly like a stack of papers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种以队列形式存在的数据结构。项目从顶部进入队列，并以相反的顺序离开队列，即它们进入的顺序。它被称为*栈*，因为它表现得就像一叠纸张。
- en: 'A stack provides two operations: *push*, in which an item is added to the stack,
    and *pull* (or *pop*), in which an item is removed from the stack.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 栈提供了两种操作：*push*，即将项目添加到栈中，和 *pull*（或 *pop*），即将项目从栈中移除。
- en: An operation on a single element (e.g., negate) is applied to the *top* element
    of the stack. An operation with two operands is applied to the two elements at
    the **Top of the Stack (TOS)**; for example, an addition is performed by pulling
    two operands off the stack, performing the addition, and then pushing the result
    back on the stack. *Figure 8**.1* demonstrates the behavior of the stack as we
    evaluate P = (A + B)×(C – B – D).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对单个元素的操作（例如，取反）应用于栈的 *顶部* 元素。对两个操作数进行操作的操作应用于栈的 **顶部元素（TOS**）；例如，通过从栈中拉出两个操作数，执行加法，然后将结果推回栈中来实现加法。*图
    8**.1* 展示了在评估 P = (A + B)×(C – B – D) 时栈的行为。
- en: '![Figure 8.1 – The sequence of actions taking place during the evaluation of
    (A + B)×(C – B – D)](img/Figure_8.1_B19624.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 评估 (A + B)×(C – B – D) 时发生的操作序列](img/Figure_8.1_B19624.jpg)'
- en: Figure 8.1 – The sequence of actions taking place during the evaluation of (A
    + B)×(C – B – D)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 评估 (A + B)×(C – B – D) 时发生的操作序列
- en: '*Table 8.1* shows how we perform the P = (A + B)×(C – B – D) calculation using
    the `PUSH`, `PULL`, `ADD`, `SUB`, and `MUL` stack operations. As well as arithmetic
    operations, two other common stack operations are `DUP` (duplicate) and `SWAP`.
    The `DUP` operation makes a copy of the item at the TOS and pushes it on the stack
    (i.e., the top of the stack is duplicated). The `SWAP` operation exchanges the
    TOS and **Next on Stack (****NOS)** values.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 8.1* 展示了如何使用 `PUSH`、`PULL`、`ADD`、`SUB` 和 `MUL` 栈操作来执行 P = (A + B)×(C – B
    – D) 的计算。除了算术操作外，还有两种常见的栈操作 `DUP`（复制）和 `SWAP`。`DUP` 操作会复制 TOS 上的项目并将其推入栈中（即，栈顶被复制）。`SWAP`
    操作交换 TOS 和 **Next on Stack (NOS**) 的值。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Table 8.1 – The code to evaluate (A + B)×(C – B – D)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – 评估 (A + B)×(C – B – D) 的代码
- en: To simplify the simulator, each instruction is stored in a Python list consisting
    of the operation and memory address (for `PUSH` and `PULL`). This is not intended
    to be a practical simulator; it’s a demonstration of the use of the stack to handle
    arithmetic operations and an introduction to the stack for later chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化模拟器，每个指令都存储在一个包含操作和内存地址（对于 `PUSH` 和 `PULL`）的 Python 列表中。这不是一个实用的模拟器；它是一个使用栈来处理算术操作的演示，也是对后续章节中栈的介绍。
- en: A register called a `1231,` pushing an element on the stack stores it at address
    `1230`, since the stack grows toward low addresses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `1231` 的寄存器，将一个元素压入栈中会将其存储在地址 `1230`，因为栈是向低地址增长的。
- en: 'In some implementations, the stack pointer points at the *next free location*
    above the top of the stack. We will represent the stack in Python by the list
    `stack[]`. The stack pointer is sp and the operation to push item A on the stack
    is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些实现中，栈指针指向栈顶之上的 *下一个空闲位置*。我们将使用 Python 中的列表 `stack[]` 来表示栈。栈指针是 sp，将项目 A 压入栈的操作如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember that the stack pointer is decremented because the stack grows toward
    lower addresses. If an item is popped off the stack, the inverse operation is
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，栈指针是递减的，因为栈是向低地址增长的。如果从栈中弹出一个项目，则逆操作如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are complementary operations. A pull operation cancels a push. Consider
    evaluating an expression. *Figure 8**.2* shows the state of the stack during the
    evaluation of `X = (A + B)×(C –` `D)`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是互补操作。一个 pull 操作取消一个 push。考虑评估一个表达式。*图 8**.2* 展示了在评估 `X = (A + B)×(C –` `D)`
    时栈的状态。
- en: '![Figure 8.2 – The sequence of actions taking place during the evaluation of
    X = (A + B)×(C – D)](img/Figure_8.2_B19624.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 评估 X = (A + B)×(C – D) 时发生的操作序列](img/Figure_8.2_B19624.jpg)'
- en: Figure 8.2 – The sequence of actions taking place during the evaluation of X
    = (A + B)×(C – D)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 评估 X = (A + B)×(C – D) 时发生的操作序列
- en: The next step is to demonstrate how we can implement a simple calculator, TC0,
    based on a stack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是演示如何实现一个简单的计算器，TC0，它基于栈。
- en: 'TC0: A python stack machine'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TC0：Python 栈机器
- en: 'We can represent the addition `y3 = y1 + y2` on a stack machine in Python as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Python 的栈机器上表示加法 `y3 = y1 + y2` 如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve taken a shortcut. We could have pulled two elements off the stack, added
    them, and pushed the result. Instead, we put the result back where the second
    operand was and saved two stack pointer movements. The following Python code illustrates
    a very simple stack machine interpreter. It does not implement branch operations,
    so it is not a realistic computation machine. Because a stack machine often operates
    on the top of the stack and the element below it, the second element is frequently
    called NOS. Note that the program is stored as a list of lists, with each instruction
    consisting of either a two-element list (e.g., `[''push'', ''2''])` or a single-element
    list (e.g., `[''``mul'']`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取了一个捷径。我们本可以从栈中取出两个元素，将它们相加，然后将结果压入栈中。相反，我们将结果放回到第二个操作数的位置，并节省了两个栈指针的移动。以下Python代码演示了一个非常简单的栈机解释器。它不实现分支操作，因此它不是一个现实的计算机器。由于栈机通常在栈顶及其下面的元素上操作，第二个元素通常被称为NOS。请注意，程序存储为列表的列表，每个指令由一个包含两个元素的列表（例如，`['push',
    '2'])`）或一个包含单个元素的列表（例如，`['``mul']`）组成：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the output from this program, which shows the program counter,
    the top of the stack, NOS, the stack itself, the data, and the opcode being executed.
    Values that change between cycles are in bold:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从该程序输出的结果，显示了程序计数器、栈顶、NOS、栈本身、数据和正在执行的指令码。在周期之间发生变化的值以粗体显示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next section, we will look at a more realistic machine that implements
    a simple accumulator machine of the early 8-bit microprocessor era.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个更现实的机器，该机器实现了早期8位微处理器时代的简单累加器机器。
- en: 'TC2: A one-address accumulator machine'
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC2：一个单地址累加器机器
- en: In this section, you will learn about a computer that implements a memory-to-register
    architecture. This is a very simple machine that implements a one-address instruction
    format (like an 8-bit CISC microprocessor from the 1970s).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解一种实现内存到寄存器架构的计算机。这是一台非常简单的机器，实现了单地址指令格式（类似于20世纪70年代的8位CISC微处理器）。
- en: The TC2 model can be used to simulate classic 8-bit microprocessors that are
    found in low-cost computer systems (e.g., controllers in mechanical devices).
    It also teaches you about the trade-off between simplicity (of the computer) and
    complexity (of the software that is constrained by the primitive architecture).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TC2模型可以用来模拟在低成本计算机系统中发现的经典8位微处理器（例如，机械设备的控制器）。它还教会你关于计算机的简单性（计算机的）和由原始架构限制的软件的复杂性之间的权衡。
- en: 'Unlike modern RISC architectures with data-processing operations between two
    registers, this computer implements a dyadic operation between one operand in
    the accumulator and the other operand, which is either a literal or the contents
    of memory; for example, `ADD M` adds the contents of memory location `M` to the
    accumulator, and `ADD #5` adds a literal to the contents of the accumulator. This
    computer does not have a large set of general-purpose registers.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '与现代RISC架构不同，这种计算机在累加器中的一个操作数和另一个操作数（可以是文字或内存内容）之间实现二元操作；例如，`ADD M`将内存位置`M`的内容加到累加器中，而`ADD
    #5`将一个文字加到累加器的内容中。这台计算机没有大量的一般用途寄存器。'
- en: 'The one-address machine permits operations between data in the accumulator
    and in memory. This contrasts with RISC architectures that permit data-processing
    operations only between registers. Load and store are the only memory operations
    permitted by a RISC architecture. This computer, TC2, implements a minimal instruction
    set that demonstrates its operation. Table 8.2 describes the instruction set:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单地址机器允许在累加器中的数据和内存中的数据之间进行操作。这与只允许在寄存器之间进行数据处理操作的RISC架构形成对比。加载和存储是RISC架构允许的唯一内存操作。这台计算机TC2实现了一个最小的指令集，以展示其操作。表8.2描述了指令集：
- en: '| Mnemonic | Action | Memory form | Literal form | Opcode |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 操作 | 内存形式 | 文字形式 | 指令码 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `LDA` | Load accumulator | `[A]` ← `[``M]` | `[A]` ← `L` | `0` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `LDA` | 加载累加器 | `[A]` ← `[``M]` | `[A]` ← `L` | `0` |'
- en: '| `STA` | Store accumulator | `[M]` ← `[``A]` | `[M]` ← `L` | `0` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `STA` | 存储累加器 | `[M]` ← `[``A]` | `[M]` ← `L` | `0` |'
- en: '| `ADD` | Add to accumulator | `[A]` ← `[A] + [``M]` | `[A]` ← `[A] + L` |
    `1` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` | 向累加器中加 | `[A]` ← `[A] + [``M]` | `[A]` ← `[A] + L` | `1` |'
- en: '| `SUB` | Subtract from accumulator | `[A]` ← `[A] - [``M]` | `[A]` ← `[A]
    – L` | `2` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `SUB` | 从累加器中减去 | `[A]` ← `[A] - [``M]` | `[A]` ← `[A] – L` | `2` |'
- en: '| `CLR` | Load accumulator/memory with zero | `[A]` ← `0` | `[M]` ← `0` | `3`
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `CLR` | 将累加器/内存加载为零 | `[A]` ← `0` | `[M]` ← `0` | `3` |'
- en: '| `BRA` | Branch unconditionally to L | `[PC]` ← `L` |  | `4` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `BRA` | 无条件分支到L | `[PC]` ← `L` |  | `4` |'
- en: '| `BEQ` | Branch on zero to L | `if Z = 1 then[PC]` ← `L` |  | `5` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `BEQ` | 零分支到L | `如果Z = 1，则[PC]` ← `L` |  | `5` |'
- en: '| `BNE` | Branch on not zero to L | `if Z = 0 then[PC]` ← `L` |  | `6` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `BNE` | 非零分支到L | `如果Z = 0，则[PC]` ← `L` |  | `6` |'
- en: '| `STOP` | Stop |  |  | `7` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `STOP` | 停止 |  |  | `7` |'
- en: Table 8.2 – Typical operations of a register-to-memory computer
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 寄存器到内存计算机的典型操作
- en: Here, `[A]` is the contents of the accumulator, `[M]` is the contents of memory
    location *M*, *L* is a literal, and the Z-bit is set if the result of a subtraction
    is zero. *M* and *L* represent the literal field of an instruction and are mutually
    exclusive. You can’t have an instruction with both an *M* and *L* operand.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`[A]`是累加器的内容，`[M]`是内存位置*M*的内容，*L*是一个立即数，如果减法的结果为零，则设置Z位。*M*和*L*代表指令的立即数字段，它们是互斥的。你不能有一个同时包含*M*和*L*操作数的指令。
- en: Simulating a computer teaches us a lot about partitioning an instruction into
    various fields and how to implement instructions. In this example, we use a 3-bit
    opcode, a 1-bit *direction* flag (for `LDA` and `STA`) that defines the direction
    of data movement (to or from memory), and a 1-bit *mode* flag that selects either
    a literal or a direct memory access. A 5-bit numeric field provides an integer
    in the range 0 to 31, or a memory address. The instruction size is 10 bits with
    the format `CCC D M LLLLL`, where *CCC* is the opcode field, *D* is the direction
    bit, *M* is the mode bit, and *LLLLL* is the literal or memory address (*Figure
    8**.3*). The extreme simplicity of this makes it easy to write a tiny simulator
    and leaves the user with a lot of opportunities to expand the code into a more
    realistic machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟计算机教给我们很多关于将指令分割成各种字段以及如何实现指令的知识。在这个例子中，我们使用一个3位操作码，一个1位*方向*标志（用于`LDA`和`STA`），它定义了数据移动的方向（向或从内存），以及一个1位*模式*标志，它选择是直接内存访问还是立即数。一个5位数字字段提供一个0到31范围内的整数，或一个内存地址。指令大小为10位，格式为`CCC
    D M LLLLL`，其中*CCC*是操作码字段，*D*是方向位，*M*是模式位，*LLLLL*是立即数或内存地址（*图8**.3*）。这种极端的简单性使得编写一个微型的模拟器变得容易，同时也给用户留下了很多将代码扩展成更真实机器的机会。
- en: '![Figure 8.3 – TC2 instruction format](img/Figure_8.3_B19624.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – TC2指令格式](img/Figure_8.3_B19624.jpg)'
- en: Figure 8.3 – TC2 instruction format
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – TC2指令格式
- en: TC2 simulates a stored program computer with a single memory that holds both
    the program and data. The 32-bit location memory is initialized by memory = `[``0]*32`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TC2模拟了一个存储程序计算机，它有一个单一内存，既可以存储程序也可以存储数据。32位位置内存通过`memory = [``0]*32`初始化。
- en: 'The TC2 code has a setup section and a `while` loop that includes a fetch instruction
    and an execute instruction part. The structure of the `while` loop part of the
    code (instruction fetch/execute cycle) consists of the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TC2代码有一个设置部分和一个包含取指令和执行指令部分的`while`循环。代码中`while`循环部分的（指令取/执行周期）结构如下：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within the while loop, we have a `fetch` phase followed by an execution phase.
    The `fetch` phase is identical to the CPUs we have already described. Instruction
    decoding is included in this phase. Instruction decoding separates OpCode, Dir
    (i.e., direction to or from memory), Mode, and Literal by using shifting and bit-masking
    operations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们有一个`fetch`阶段，随后是执行阶段。`fetch`阶段与我们已经描述的CPU相同。指令解码包含在这个阶段。指令解码通过移位和位掩码操作将OpCode、Dir（即向或从内存的方向）、Mode和Immediate分开：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Right shifts and ANDs extract fields from the instruction; for example, the
    3-bit opcode is extracted from the 10-bit `CCCDMLLLLL` instruction by shifting
    seven places left to get `0000000CCC`. The direction bit, Dir, is extracted by
    performing six left shifts to get `000000CCCD` and then ANDing the result with
    1 to get `000000000D`. These two operations can be combined and written as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 右移和AND操作从指令中提取字段；例如，从10位的`CCCDMLLLLL`指令中提取3位操作码，通过左移七位得到`0000000CCC`。方向位，Dir，通过执行六次左移得到`000000CCCD`，然后与1进行AND操作得到`000000000D`。这两个操作可以合并并写成如下：
- en: '`(IR >> 6) & 1`      # 6-bit shift right with >> and AND with 1 using the AND
    operator, &'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`(IR >> 6) & 1`      # 使用>>进行6位右移，并使用AND操作符&与1进行AND操作'
- en: Similarly, we extract the mode bit by performing `Mode = (IR >> 5) & 1`. Finally,
    the literal is in place, so all we have to do is to clear the other bits by ANDing
    it with `0b0000011111`, that is, `IR &` `0x1F`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过执行`Mode = (IR >> 5) & 1`来提取模式位。最后，立即数已经就位，所以我们只需通过AND操作与`0b0000011111`（即`IR
    & 0x1F`）进行AND操作来清除其他位。
- en: 'In the `execute` phase, the three op-code bits, `OpCode`, select one of the
    eight possible instructions. Of course, the use of `if … elif` would have been
    more appropriate:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`阶段，三个操作码位`OpCode`选择八种可能指令之一。当然，使用`if … elif`会更合适：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each op-code is guarded by an `if` statement. Here’s the code for the load
    and store accumulator instruction. We treat this as one operation and use the
    direction flag, `Dir`, to select between `LDA` (direction memory to accumulator)
    and `STA` (direction accumulator to memory):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作码都由一个`if`语句保护。以下是加载和存储累加器指令的代码。我们将这视为一个操作，并使用方向标志`Dir`来选择`LDA`（从内存到累加器的方向）和`STA`（从累加器到内存的方向）：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To make it easier to read the code, we’ve divided it into two blocks (one shaded
    in dark gray and one in light gray) guarded by the if `Dir == 0` statement. When
    the direction flag is 0, the instruction is *load accumulator* and the address
    is copied to the `MAR`, a read is performed, and the data is copied to the `MBR`
    and then the accumulator. If the direction flag is 1, the instruction is a *store
    accumulator* and the accumulator is copied to the `MBR` and a write operation
    is carried out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更容易阅读，我们将其分为两个块（一个深灰色阴影，一个浅灰色阴影），由`if `Dir == 0`语句保护。当方向标志为0时，指令是*加载累加器*，地址被复制到`MAR`，执行读取操作，然后将数据复制到`MBR`和累加器。如果方向标志为1，指令是*存储累加器*，累加器被复制到`MBR`并执行写入操作。
- en: Note the use of the `Mode` flag. When loading the accumulator from memory, `LDA`,
    the mode flag is used to load the accumulator with either a literal or the contents
    of memory. When executing a `STA`, which refers to the store accumulator, the
    mode flag is ignored because only a memory store is possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Mode`标志的使用。当从内存加载累加器`LDA`时，模式标志用于将累加器加载为字面量或内存内容。当执行`STA`（存储累加器）时，模式标志被忽略，因为只能进行内存存储。
- en: We don’t need to describe the `ADD` and `SUB` operations because they are simply
    extensions of the load and store operations. We’ve included a clear operation,
    `CLR`, which sets either the accumulator to 0 or the contents of memory to 0 depending
    only on the `Mode` flag.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要描述`ADD`和`SUB`操作，因为它们仅仅是加载和存储操作的扩展。我们包含了一个清晰的操作`CLR`，它根据`Mode`标志将累加器设置为0或将内存内容设置为0。
- en: We’ll now present the full simulator code. The `Memory[MAR]` notation means
    the contents of memory whose address is in the `MAR` and is conveniently identical
    to the RTL we’ve been using. In the execute instruction block, alternate opcodes
    are shaded gray and blue to facilitate reading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示完整的模拟器代码。`Memory[MAR]`表示法意味着地址在`MAR`中的内存内容，并且方便地与我们所使用的RTL相同。在执行指令块中，交替的操作码以灰色和蓝色阴影显示，以方便阅读。
- en: We’ve included a small program in memory, complete with data that tests several
    of the instructions, including load and store, add, subtract, and branch.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内存中包含了一个小程序，包括测试几个指令的数据，包括加载和存储、加法、减法和分支。
- en: TC2 has a clear operation, `CLR`, that sets either the accumulator or the contents
    of memory to 0 depending on the Mode flag. This simplified computer has only a
    Z-bit (no N and C bits).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TC2有一个清除操作`CLR`，根据模式标志将累加器或内存内容设置为0。这个简化的计算机只有一个Z位（没有N和C位）。
- en: The branch group of instructions (`BRA`, `BEQ`, and `BNE`) load the program
    counter with a literal to force a jump. `BRA` performs an unconditional branch,
    and `BEQ`/`BNE` depending on the state of the Z-bit, which is set/cleared by add
    and subtract operations. The branch target address is an absolute address provided
    by the literal field.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 指令组（`BRA`、`BEQ`和`BNE`）将一个字面量加载到程序计数器中，以强制跳转。`BRA`执行无条件分支，而`BEQ`/`BNE`则根据Z位的状态（由加法和减法操作设置/清除）执行。分支目标地址是由字面量字段提供的绝对地址。
- en: 'We have reserved the last instruction opcode, `111`, as a stop (halt) instruction
    that breaks out of the `while` loop and terminates execution. In general, a real
    CPU does not need a halt instruction, although a halt instruction can be used
    to force it into a power-down mode until it is awakened by an external event,
    such as a keyboard/mouse input or a screen touch:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经预留了最后一个指令操作码`111`作为停止（暂停）指令，它会跳出`while`循环并终止执行。一般来说，实际的CPU不需要暂停指令，尽管暂停指令可以用来强制将其置于待机模式，直到被外部事件（如键盘/鼠标输入或屏幕触摸）唤醒：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we’ve loaded memory with the program and set up some variables, we
    can enter the `fetch` `execute` loop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将程序加载到内存中并设置了一些变量，我们可以进入`fetch` `execute`循环：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following block (dark shading) implements a clear operation. This instruction
    is not strictly necessary, because you can always load a zero or subtract x from
    X. For this reason, some computers do not incorporate a clear instruction. Some
    computers allow you to write `CLR` and then substitute an operation such as `SUB
    X,X`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块（深色阴影）实现了清除操作。这个指令不是严格必要的，因为你可以始终加载零或从X中减去x。因此，一些计算机不包含清除指令。一些计算机允许你写入`CLR`然后替换为操作，如`SUB
    X,X`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could argue that we should have inserted a break or exit here because if
    we haven’t encountered a valid op-code by the end of the `execute` loop, the source
    code must be invalid:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以争论说我们应该在这里插入一个中断或退出，因为如果我们没有在`execute`循环结束时遇到有效的操作码，源代码必须是无效的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now run this program. The output when running this program is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在运行这个程序。运行此程序时的输出如下：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enhancing the TC2 Simulator
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强TC2模拟器
- en: The simple example of an accumulator-based machine illustrates several aspects
    of the implementation of instructions, the design of the instruction set, and
    the allocation of bits. The TC2 has a 3-bit opcode giving us eight operations.
    Or does it?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器基础机器的简单示例说明了指令实现、指令集设计和位分配的几个方面。TC2有一个3位操作码，给我们提供了八个操作。或者不是吗？
- en: 'The direction bit, Dir, is employed only by the `LDA`/`STA` instruction. If
    we removed this bit from the opcode field, we would have a 4-bit opcode giving
    16 instructions. Since `LDA` and `STA` would now be separate instructions, our
    eight-instruction computer would have nine instructions, leaving 16 – 9 = 7 new
    (i.e., unallocated) opcodes. We could have also used the direction flag with `ADD`
    and `SUB` instructions allowing the destination to be either the accumulator or
    memory. Consider the following example. The current TC2 simulator can increment
    variables *x* and *y* using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 方向位，Dir，仅由`LDA`/`STA`指令使用。如果我们从操作码字段中移除此位，我们将有一个4位操作码，提供16条指令。由于`LDA`和`STA`现在将是独立的指令，我们的8条指令计算机将拥有9条指令，留下16
    - 9 = 7个新的（即未分配的）操作码。我们还可以使用方向标志与`ADD`和`SUB`指令一起使用，允许目标为累加器或内存。考虑以下示例。当前的TC2模拟器可以使用以下代码增加变量*x*和*y*：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By extending the addition operation (`ADDA` to add to the accumulator and `ADDM`
    to add to memory), we can now write the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展加法操作（`ADDA`用于累加器加和`ADDM`用于内存加和），我们现在可以编写以下代码：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This enhancement halves the number of instructions, because we load the accumulator
    with the literal once and then add it to two different memory locations. The new
    code for the `ADD` operation is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增强将指令数量减半，因为我们只将累加器加载为文字一次，然后将其添加到两个不同的内存位置。`ADD`操作的新代码如下：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What else can we do to extend the instruction set? We allocated *three* opcodes
    to the branch group. That was very wasteful. Since each of these branch instructions
    has a direction and a mode bit that is unused, we can press these bits into service
    (i.e., redefine their meaning). Consider the arrangement of *Table 8.3*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做什么来扩展指令集？我们为分支组分配了*三个*操作码。这非常浪费。由于这些分支指令的方向位和模式位都是未使用的，我们可以将这些位投入使用（即重新定义它们的含义）。考虑*表8.3*的排列：
- en: '| Operation | Direction | Mode |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方向 | 模式 |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `BRA` | 0 | 0 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `BRA` | 0 | 0 |'
- en: '| Undefined | 0 | 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 未定义 | 0 | 1 |'
- en: '| `BEQ` | 1 | 0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `BEQ` | 1 | 0 |'
- en: '| `BNE` | 1 | 1 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `BNE` | 1 | 1 |'
- en: Table 8.3 – Re-purposing the direction and mode bits
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3 – 重新利用方向和模式位
- en: 'We have used the `Dir` and `Mode` instruction bits to select the branch type.
    As a bonus, we have a spare operation that is marked *undefined*. The code for
    the branch group is as follows. We’ve used shading to help identify the blocks.
    Note that in this example, we demonstrate how branches can be made program counter
    relative:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`Dir`和`Mode`指令位来选择分支类型。作为额外的好处，我们有一个标记为*未定义*的备用操作。分支组的代码如下。我们使用了阴影来帮助识别块。注意，在这个例子中，我们展示了如何使分支程序计数器相关：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code looks a little more complex than it is, because we have `if` statements
    nested four deep when we test for op-code, direction, mode, and then Z-bit. However,
    this example demonstrates how instruction bits can be reused to increase the number
    of instructions at the cost of decoding complexity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来比实际要复杂，因为我们测试操作码、方向、模式和Z位时嵌套了四个`if`语句。然而，这个例子展示了如何通过重用指令位来增加指令数量，但代价是解码复杂度增加。
- en: 'There’s still room to maneuver and squeeze more functionality out of the instruction
    set. Look at the `CLR` instruction. We use the mode bit to clear memory or the
    accumulator. How about being a little creative and using the *direction* bit to
    provide another operation? Incrementing a register or memory is a common operation,
    so let’s provide that. We can use `Dir == 0` for `CLR` and `Dir == 1` for `INC`
    Memory/accumulator. The block shaded in gray is the original clear and the block
    shaded in blue is the new increment operation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令集中仍有空间进行操作和提取更多功能。看看`CLR`指令。我们使用模式位来清除内存或累加器。为什么不稍微发挥一下创意，使用*方向*位来提供另一种操作呢？增加寄存器或内存是一个常见的操作，所以让我们提供这个功能。我们可以使用`Dir
    == 0`来表示`CLR`，`Dir == 1`来表示内存/累加器的`INC`操作。灰色阴影的部分是原始的清除操作，蓝色阴影的部分是新的增加操作：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, consider the `STOP` (halt) instruction with the `111DMLLLLL` opcode.
    Here, we have 7 bits doing nothing. That is 27 = 128 combinations. If we were
    to reserve one code for halt, say, `1110000000`, we could allocate codes 1110000001
    to `1111111111` to new instructions. The next section extends this architecture
    to create a more realistic simulator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑带有`111DMLLLLL`操作码的`STOP`（停止）指令。在这里，我们有7位没有做任何事情。这是\(2^7 = 128\)种组合。如果我们为停止操作保留一个代码，比如`1110000000`，那么我们可以将代码`1110000001`到`1111111111`分配给新的指令。下一节将扩展这个架构以创建一个更逼真的模拟器。
- en: 'TC3: A CISC machine with a register-to-memory architecture'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC3：具有寄存器到内存架构的CISC机器
- en: In this section, you will learn about the design of a simulator that implements
    a CISC-style instruction set architecture, providing both register-to-register
    and register-to-memory operations. TC3 is a more sophisticated version of TC2
    with a more practical architecture.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解一个模拟器的结构设计，该模拟器实现了CISC风格的指令集架构，提供寄存器到寄存器和寄存器到内存的操作。TC3是TC2的一个更复杂的版本，具有更实用的架构。
- en: 'TC3 supports register direct, register indirect, memory direct, and literal
    addressing modes. For example, `AND [R2], #129` performs a logical `AND` between
    the contents of the memory location pointed at by register `R2` and the binary
    value `10000001`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'TC3支持寄存器直接、寄存器间接、内存直接和立即数寻址模式。例如，`AND [R2], #129`执行的是寄存器`R2`指向的内存位置的值与二进制值`10000001`的逻辑`AND`操作。'
- en: We have included memory direct operations. These are intended to illustrate
    the features of a computer, rather than being practical. Early 8-bit microprocessors
    like the Motorola 6800 let you operate on memory directly. Most modern processors
    don’t. TC3 can access, say, memory at location 12 with `MOV` R2,`M:12`. This instruction
    loads register 2 with the contents of memory location 12\. Note the syntax. A
    TC3 instruction provides a single literal field that can serve as a literal or
    a memory address, but not both at the same time. I’ve used `#` to indicate a literal
    and `M:` to indicate a memory address; consider `MOV` R2,`M:12` and `MOV` R2,`#12`.
    The former loads register `R2` with the contents of memory location `12`, and
    the latter loads `R2` with the integer `12`. With a single literal field in the
    instruction, TC3 can’t support an instruction like `MOV M:12,#127.`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了内存直接操作。这些操作旨在展示计算机的特性，而不是实用性。早期的8位微处理器，如摩托罗拉6800，允许你直接操作内存。大多数现代处理器都不支持这一点。TC3可以通过`MOV
    R2,`M:12`来访问，例如，内存位置12的内容。注意语法。TC3指令提供了一个单一的立即数字段，它可以作为立即数或内存地址，但不能同时作为两者。我使用`#`来表示立即数，`M:`来表示内存地址；考虑`MOV
    R2,`M:12`和`MOV R2,`#12`。前者将内存位置`12`的内容加载到寄存器`R2`中，后者将整数`12`加载到`R2`中。由于指令中只有一个立即数字段，TC3不能支持像`MOV
    M:12,#127`这样的指令。
- en: The TC3 instruction set architecture
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TC3指令集架构
- en: The TC3 simulator is a one-and-a-half address CISC processor with a 24-bit instruction
    and an 8-bit data word length. This makes it a Harvard machine, because it has
    separate data and program memory. We have taken this approach for two reasons.
    First, an 8-bit data word is easy to work with from an educational point of view.
    Second, a 24-bit instruction provides functionality, without either using a large
    32-bit word or employing variable-length instructions like some CISC processors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: TC3模拟器是一个具有24位指令和8位数据字长的一个半地址CISC处理器。这使得它成为一个哈佛机器，因为它有独立的数据和程序内存。我们采取这种方法的两个原因是：首先，从教育角度来看，8位数据字容易处理；其次，24位指令提供了功能，既没有使用大的32位字，也没有采用像某些CISC处理器那样的可变长度指令。
- en: '*Figure 8**.4* describes the TC3’s instruction format, which has an instruction
    class and an op-code field, an addressing mode field, two register fields, and
    a literal field. The format is the same for all instructions.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.4*描述了TC3的指令格式，它包含一个指令类别字段和一个操作码字段、一个寻址模式字段、两个寄存器字段和一个立即数字段。所有指令的格式都是相同的。'
- en: '![Figure 8.4 – Instruction format of the TC3](img/Figure_8.4_B19624.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – TC3指令格式](img/Figure_8.4_B19624.jpg)'
- en: Figure 8.4 – Instruction format of the TC3
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – TC3指令格式
- en: We use 8-bit registers, an 8-bit address, and an 8-bit literal to simplify the
    design. The data space is restricted to 28 = 256 locations, since the literal
    can access only 256 locations. Changing the instruction width to 32 bits and expanding
    the literal to 16 bits would provide a data space of 65,536 locations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用8位寄存器、8位地址和8位立即数来简化设计。数据空间限制在2^8 = 256个位置，因为立即数只能访问256个位置。将指令宽度改为32位并将立即数扩展到16位将提供65,536个位置的数据空间。
- en: The TC3 has eight general-purpose registers, `R0` to `R7`. It requires 6 bits
    to provide source and destination register fields The instruction field is 6 bits
    wide and is divided into a 2-bit instruction-class field and a 4-bit op-code field.
    This allows up to 64 instructions with a maximum of 16 in each class. We took
    this approach (instruction class and op-code) to simplify the design. This is
    a rather inefficient approach in terms of instruction-space usage, because most
    instructions fall within one class and other classes are nearly empty.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TC3拥有八个通用寄存器，`R0`到`R7`。它需要6位来提供源寄存器和目标寄存器字段。指令字段宽度为6位，分为一个2位的指令类别字段和一个4位的操作码字段。这允许最多有64条指令，每个类别最多16条。我们采用这种（指令类别和操作码）方法来简化设计。从指令空间使用效率的角度来看，这是一个相当低效的方法，因为大多数指令都位于一个类别中，而其他类别几乎是空的。
- en: 'The 4-bit mode field defines an instruction’s attributes (e.g., addressing
    modes). The TC3 supports the addressing modes defined by *Table 8.4*, that is,
    no-operand instructions, one-register instructions, instructions with a literal,
    and two-operand instructions. Although the TC3 supports only two operands (register
    + register and register + literal), there are three fields in the instruction.
    Consequently, the computer could be easily modified to provide three-operand instructions.
    We chose this approach to simplify instruction encoding and decoding. An alternative
    approach would be to provide two operand fields – a register field and a register
    or literal field:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 4位模式字段定义了指令的属性（例如，寻址模式）。TC3支持*表8.4*中定义的寻址模式，即无操作数指令、单寄存器指令、带立即数的指令和双操作数指令。尽管TC3只支持两个操作数（寄存器+寄存器和寄存器+立即数），但指令中有三个字段。因此，计算机可以很容易地修改以提供三操作数指令。我们选择这种方法来简化指令编码和解码。另一种方法是为两个操作数字段提供两个字段——一个寄存器字段和一个寄存器或立即数字段：
- en: '| **Mode** | **Address** | **Example** | **RTL** | **Class** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **地址** | **示例** | **RTL** | **类别** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | No operand | `STOP` |  | `0` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 无操作数 | `STOP` |  | `0` |'
- en: '| 1 | Single register | `INC R1` | `[R1]` ← `[R1] + 1` | `1` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 单个寄存器 | `INC R1` | `[R1]` ← `[R1] + 1` | `1` |'
- en: '| 2 | Literal offset | `BEQ 123` | `[pc]` ← `123` | `2` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 立即数偏移量 | `BEQ 123` | `[pc]` ← `123` | `2` |'
- en: '| 3 | Reserved |  |  |  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 保留 |  |  |  |'
- en: '| 4 | Literal to register | `MOV R1,#M` | `[R1]` ← `M` | `3` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 立即数到寄存器 | `MOV R1,#M` | `[R1]` ← `M` | `3` |'
- en: '| 5 | Register to register | `MOV R1,R2` | `[R1]` ← `[``R2]` | `3` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 寄存器到寄存器 | `MOV R1,R2` | `[R1]` ← `[``R2]` | `3` |'
- en: '| 6 | Register indirect to register | `MOV R1,[R2]` | `[R1]` ← `[[``R2]]` |
    `3` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 寄存器间接到寄存器 | `MOV R1,[R2]` | `[R1]` ← `[[``R2]]` | `3` |'
- en: '| 7 | Register to register indirect | `MOV [R1],R2` | `[[R1]]` ← `[``R2]` |
    `3` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 寄存器到寄存器间接寻址 | `MOV [R1],R2` | `[[R1]]` ← `[``R2]` | `3` |'
- en: '| 8 | Register indirect to register indirect | `MOV [R1],[R2]` | `[[R1]]` ←
    `[[``R2]]` | `3` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 寄存器间接到寄存器间接 | `MOV [R1],[R2]` | `[[R1]]` ← `[[``R2]]` | `3` |'
- en: '| 9 | Register to memory | `MOV M:123,R2` | `M[123] ← [``R2]` | `3` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 寄存器到内存 | `MOV M:123,R2` | `M[123] ← [``R2]` | `3` |'
- en: '| 10 | Register indirect to memory | `MOV M:123,[R2]` | `M[123]` ← `[[``R2]]`
    | `3` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 寄存器间接到内存 | `MOV M:123,[R2]` | `M[123]` ← `[[``R2]]` | `3` |'
- en: '| 11 | Memory to register | `MOV R1,M:123` | `[R1]` ← `M[123]` | `3` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 内存到寄存器 | `MOV R1,M:123` | `[R1]` ← `M[123]` | `3` |'
- en: '| 12 | Memory to register indirect | `MOV [R1],M:123` | `[[R1]]` ← `M[123]`
    | `3` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 内存到寄存器间接 | `MOV [R1],M:123` | `[[R1]]` ← `M[123]` | `3` |'
- en: '| 13-15 | Reserved |  |  |  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 13-15 | 保留 |  |  |  |'
- en: Table 8.4 – TC3 processor addressing modes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4 – TC3处理器寻址模式
- en: 'Consider the following assembly language program that runs on this computer.
    We wish to add together two vectors plus an integer, that is, *z*i = xi + yi +
    5 for *i* = 0 to 3\. The following code should be largely self-explanatory. Literals
    are prefixed with #, and a label in an instruction is terminated with a colon.
    The first part of the code uses the `RND R5` instruction to fill vectors `X` and
    `Y` with random numbers to aid testing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在此计算机上运行的汇编语言程序。我们希望将两个向量加上一个整数相加，即*z*i = xi + yi + 5，其中*i* = 0到3。以下代码应该大部分是自解释的。立即数前面加有#，指令中的标签以冒号结束。代码的前一部分使用`RND
    R5`指令用随机数填充向量`X`和`Y`，以帮助测试。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example uses literal, register direct, and register indirect (pointer-based)
    addressing. We have provided the binary code of each instruction with the class,
    op-code, addressing mode, registers, and literal fields.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用了直接寻址、寄存器直接寻址和寄存器间接寻址（基于指针）的寻址方式。我们为每个指令提供了二进制代码，包括类别、操作码、寻址模式、寄存器和立即数字段。
- en: Initially, we didn’t construct an assembler for this simulator. However, it
    was such a pain to hand-code the instructions that an assembler was incorporated.
    The key to both the assembler and simulator is the `mode` field of the instruction,
    which indicates the addressing mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们没有为这个模拟器构建汇编器。然而，手动编写指令非常痛苦，因此加入了汇编器。汇编器和模拟器的关键是指令的`mode`字段，它指示寻址模式。
- en: When an instruction in mnemonic form is read, it is examined, and its addressing
    modes and operands are used to determine the four mode bits required by the instruction.
    The reverse action is carried out when the instruction is executed, and the mode
    bits are used to implement the appropriate addressing modes. For example, if the
    instruction is `LDR` `R6,#5`, the mode is `4` and the assembler stores `6` in
    the first register field and `5` in the literal field. When the instruction is
    executed, the simulator uses the mode bits, `0100`, to determine that the destination
    register is `110` and the literal is `00000101`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当以助记符形式读取指令时，会对其进行检查，并使用其寻址模式和操作数来确定指令所需的四个模式位。当执行指令时，执行相反的操作，并使用模式位来实现适当的寻址模式。例如，如果指令是`LDR
    R6,#5`，则模式为`4`，汇编器将`6`存储在第一个寄存器字段中，将`5`存储在立即数字段中。当执行指令时，模拟器使用模式位`0100`来确定目标寄存器为`110`，立即数为`00000101`。
- en: 'The first part of the TC3 simulator is given as follows. We create two lists:
    one for the program memory and one for the data memory (pMem and dMem). The instructions
    in program memory are imported from a file. The data memory is set up as 16 locations
    that are initialized to 0\. The text file containing the source program is src
    and is processed to reformat instructions and remove assembler directives.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: TC3模拟器的第一部分如下。我们创建两个列表：一个用于程序存储器，一个用于数据存储器（pMem和dMem）。程序存储器中的指令是从文件导入的。数据存储器设置为16个位置，初始化为0。包含源程序的文本文件是src，处理以重新格式化指令和删除汇编指令。
- en: The shaded section of the code was added to detect the `'END'` directive in
    the source code, which terminates the assembly processing and acts as a `STOP`
    when the code is executed. I added it for convenience. I sometimes want to test
    one or two instructions but don’t want to write a new source code program. I can
    put the code under test at the top of an existing program, followed by `END`.
    All code after `END` is ignored. Later, I can delete the new code and `END`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的阴影部分是为了检测源代码中的`'END'`指令，它终止汇编处理，并在代码执行时作为`STOP`指令。我添加它是为了方便。有时我想测试一两个指令，但不想编写新的源代码程序。我可以将测试的代码放在现有程序的最上面，然后跟随着`END`。`END`之后的所有代码都将被忽略。稍后，我可以删除新的代码和`END`。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The following code takes an instruction in assembly language form, tokenizes
    it, and converts it into the bit pattern of an instruction. In the following code,
    we use ic as the instruction counter, which steps through the source program line
    by line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将汇编语言形式的指令进行标记化，并将其转换为指令的位模式。在以下代码中，我们使用ic作为指令计数器，它逐行遍历源程序。
- en: 'One issue we must deal with is the label. Some instructions have one and some
    don’t. That means that the mnemonic is token `0` for an instruction without a
    label, and token `1` if there is a label. The Python code checks for a label (which
    ends in a colon). If a label is found, `j` is set to `1`, and, if not found, `j`
    is set to `0`. We then use `j` to calculate the location of tokens in the instruction.
    The tLen variable is the number of tokens in an instruction:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的一个问题是标签。一些指令有一个标签，而另一些则没有。这意味着，对于没有标签的指令，助记符是令牌 `0`，如果有标签，则是令牌 `1`。Python
    代码检查标签（以冒号结尾）。如果找到标签，`j` 被设置为 `1`，如果没有找到，`j` 被设置为 `0`。然后我们使用 `j` 来计算指令中令牌的位置。tLen
    变量是一个指令中令牌的数量：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next section of the assembler does all the work. Here, we generate the
    binary code. Unlike other simulators we’ve developed, we use directories and lists
    to detect registers, as the following (partial) code shows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器的下一部分做所有的工作。在这里，我们生成二进制代码。与我们所开发的其它模拟器不同，我们使用目录和列表来检测寄存器，如下（部分）代码所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can take a token and ask whether it’s in `rName` to detect `R0` to
    `R7`, or whether it’s in `rNamInd` to detect whether it’s `[R0]` to `[R7]`. Moreover,
    we can use the mnemonic from an instruction and ask whether it’s in each class
    in turn in order to determine the two class bits of the instruction; for example,
    if `t0` is the first token (corresponding to the mnemonic), we can write the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以取一个令牌并询问它是否在 `rName` 中以检测 `R0` 到 `R7`，或者是否在 `rNamInd` 中以检测它是否是 `[R0]`
    到 `[R7]`。此外，我们可以使用指令中的助记符并依次询问它是否在每个类别中，以确定指令的两个类别位；例如，如果 `t0` 是第一个令牌（对应于助记符），我们可以写出以下内容：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similarly, we can use if t1 in `rNamInd` to determine whether the second token
    is a register used as a pointer (e.g., `[R4]`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `if t1 in `rNamInd`` 来判断第二个标记是否是一个用作指针的寄存器（例如，`[R4]`）。
- en: 'The most complex class of instructions is `iClass3`, which deals with two-operand
    instructions, such as `ADD [R3],R4`. In this case, token `t0` would be `''ADD''`,
    token `t1` would be `''``[r3]''`, and token `t2` would be `''R4''`. To identify
    the class of this instruction, we look for a first operand, which is an indirect
    register, and a second operand, which is a register, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 指令中最复杂的类别是 `iClass3`，它处理双操作数指令，例如 `ADD [R3],R4`。在这种情况下，令牌 `t0` 将是 `'ADD'`，令牌
    `t1` 将是 `'``[r3]'`，而令牌 `t2` 将是 `'R4'`。为了识别这个指令的类别，我们寻找第一个操作数，它是一个间接寄存器，以及第二个操作数，它是一个寄存器，如下所示：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code that determines the mode of an instruction is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 决定指令模式的代码如下：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After extracting the instruction class, op-code, and mode, the final step is
    to get the actual register numbers and any literals. In the following fragment
    of code, we define the two register fields and the literal field, respectively.
    These are `rField1`, `rField2`, and `lField` and are all initialized to `0`, because
    instructions without three fields have the corresponding bits set to `0`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取指令类别、操作码和模式之后，最后一步是获取实际的寄存器编号和任何字面量。在以下代码片段中，我们分别定义了两个寄存器字段和字面量字段。这些是 `rField1`、`rField2`
    和 `lField`，并且它们都被初始化为 `0`，因为不带三个字段的指令对应的位被设置为 `0`。
- en: 'Here, we use the list as a very convenient method for extracting fields rather
    than combined if and or operators. For example, register field `1` is used by
    modes `4`, `5`, `6`, and `11`. We could write the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用列表作为提取字段的一个非常方便的方法，而不是使用组合的 if 和 or 操作符。例如，寄存器字段 `1` 被模式 `4`、`5`、`6`
    和 `11` 使用。我们可以写出以下内容：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, we can write instead, which is far easier to read:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以用以下更易读的方式来写：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code shows how the three register/literal fields are evaluated:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何评估三个寄存器/字面量字段：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following two lines of the code-generation logic insert the register/literal
    fields by shifting and executing OR on bits and append the current binary instruction,
    binC, to the program memory, pMem:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行代码生成逻辑通过移位和执行位或操作来插入寄存器/字面量字段，并将当前二进制指令 binC 添加到程序内存 pMem 中：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Features of the simulator
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器的特点
- en: The simulator part of TC3 is relatively straightforward. Here, I’ll simply provide
    a few comments on some of its features to aid in understanding the code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: TC3 的模拟器部分相对简单。在这里，我将简单地提供一些关于其特性的注释，以帮助理解代码。
- en: '**1.** **Printing data**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.** 打印数据'
- en: 'The number of items to be displayed increased during the simulator’s development.
    So, we created a list of strings, one for each item to be printed, and then concatenated
    the items. For example, this is the print mechanism I used to display data during
    assembly:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器开发过程中，要显示的项目数量增加了。因此，我们创建了一个字符串列表，每个要打印的项目一个，然后将这些项目连接起来。例如，这是我在汇编过程中显示数据的打印机制：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `displayLevel` parameter is included to determine what information was
    printed during the assembly process. For example, we could write the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayLevel`参数包括确定在汇编过程中打印了什么信息。例如，我们可以编写以下内容：'
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This would print binary code only when debugging is required by setting the
    variable to `5` or greater.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在需要调试时（将变量设置为`5`或更大）仅打印二进制代码。
- en: '**2. Implementing add** **with carry**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 实现带进位的加法**'
- en: 'When I implemented the ALU with its numbered functions, I initially forgot
    to include `ADC`, add with carry. Rather than renumbering the functions, I converted
    the `ADD` into a dual `ADD`/`ADC` operation by first performing an addition. Then,
    if the op-code was an `ADC`, add the carry bit:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我实现带有编号功能的ALU时，我最初忘记了包括`ADC`，带进位的加法。而不是重新编号函数，我通过首先执行加法将`ADD`转换为双重`ADD`/`ADC`操作。然后，如果操作码是`ADC`，则添加进位位：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**3. Dealing with simple** **instruction classes**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 处理简单的指令类**'
- en: Here is the code used to deal with class 1 instructions. We do not have to worry
    about decoding the mode as there is only one mode for this class. Of course, the
    class could be extended (in the future) by the addition of other modes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是处理第1类指令的代码。我们不必担心解码模式，因为此类只有一个模式。当然，该类可以通过添加其他模式（在未来）进行扩展。
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Class 1 instructions have an op-code and literal and are generally used to implement
    branch operations. Notice that we compare the current instruction with a name
    (e.g., `'BRA'`) rather than an op-code, as we did in other simulators. The use
    of a table of reverse op-code-to-mnemonic translations makes life much easier.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第1类指令包含操作码和字面量，通常用于实现分支操作。请注意，我们比较当前指令与一个名称（例如，`'BRA'`）而不是操作码，就像我们在其他模拟器中所做的那样。使用反向操作码到助记符翻译表使得生活变得更加容易。
- en: 'We have added a `CZN` (carry zero negative) instruction, which allows us to
    preset condition codes; for example, `CZN #%101` sets `c` and `n` to `1`, and
    `z` to `0`. Computers often have an operation that allows you to test condition
    codes, clear them, set them, and toggle (flip) them.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了一个`CZN`（进位零负）指令，允许我们预设条件码；例如，`CZN #%101`将`c`和`n`设置为`1`，将`z`设置为`0`。计算机通常有一个操作，允许你测试条件码、清除它们、设置它们，以及切换（翻转）它们。'
- en: '**4.** **Handling literals**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. 处理字面量**'
- en: 'TC3’s numeric values can be expressed in several formats, for example, binary,
    where we represent `8` by `%1000`. Literal processing in TC3 must also deal with
    special formats, such as M:12, which indicates a memory address. The following
    function performs all the literal processing and handles several formats. It can
    also deal with literals that are symbolic names that must be looked up in the
    symbol table:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: TC3的数值可以用几种格式表示，例如二进制，其中我们用`%1000`表示`8`。TC3中的字面量处理还必须处理特殊格式，例如M:12，它表示一个内存地址。以下函数执行所有字面量处理并处理几种格式。它还可以处理必须是符号名称的字面量，这些名称必须在符号表中查找：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**5.** **Result Writeback**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**5. 结果写回**'
- en: 'After performing an ALU operation or a data movement, the resulting operand
    must be written back into the computer. However, because we have specified a two-operand
    CISC-style format, the result of a calculation can be written to a register (like
    any RISC operation), it can be written to a memory location pointed at by a register,
    or it can be written to a memory operation specified by its address. The following
    fragment of code demonstrates TC3’s writeback:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行ALU操作或数据移动后，必须将结果操作数写回计算机。然而，因为我们指定了双操作数CISC风格格式，计算结果可以写入寄存器（就像任何RISC操作一样），可以写入由寄存器指向的内存位置，或者可以写入由其地址指定的内存操作。以下代码片段演示了TC3的写回操作：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Sample output
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本输出
- en: 'The following is a sample of the output from the simulator that demonstrates
    integer handling. We have written a program with six different ways of inputting
    a literal. In each case, we load the literal into register `r0`. The source program
    is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从模拟器输出的示例，展示了整数处理。我们编写了一个程序，有六种不同的输入字面量的方式。在每种情况下，我们将字面量加载到寄存器`r0`中。源程序如下：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the following code block, we have the output of TC3\. This output has been
    designed for the purpose of developing and testing the simulator (for example,
    following the assembly process):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有TC3的输出。这个输出是为了开发和测试模拟器（例如，在汇编过程之后）而设计的：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is the output during the assembly and analysis phase:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在汇编和分析阶段的输出：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following code block, we have the single-step execution output. It’s
    been edited to help fit it on the page. We printed only two memory locations for
    each line. The literal in the instruction and its value in `r0` are printed in
    bold:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有单步执行输出。为了帮助适应页面，我们已编辑它。我们只为每一行打印了两个内存位置。指令中的文字和其在`r0`中的值以粗体显示：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The complete TC3 code
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的TC3代码
- en: 'We have discussed the design of TC3\. Here, we present the code of a complete
    simulator. There are some slight differences between the descriptive fragments
    of code we described in the previous section and this more complete simulator.
    This is followed by a sample run of the simulator. The first part of the code
    defines the instruction modes and provides a simple source program that will be
    executed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了TC3的设计。在这里，我们展示了完整模拟器的代码。与我们之前章节中描述的代码描述片段相比，这个更完整的模拟器有一些细微的差异。随后是一个模拟器样本运行的示例。代码的第一部分定义了指令模式，并提供了将执行的简单源程序：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following block contains the dictionaries for instruction decoding and register
    lookup. We’ve provided reverse lookup so that you can look up a mnemonic to get
    its code or look up the code to get the mnemonic. Similarly, we’ve provided lookup
    for registers, such as `R0` and `R2`, and indirect registers, such as `[R0]` and
    `[R1]:`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块包含指令解码和寄存器查找的字典。我们提供了反向查找，以便你可以通过查找助记符来获取其代码，或者通过查找代码来获取助记符。同样，我们提供了对寄存器（如`R0`和`R2`）和间接寄存器（如`[R0]`和`[R1]`）的查找：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following two functions provide the ability to read integer operands in
    various formats, and an ALU that performs arithmetic and logic operations. Both
    of these functions can be expanded to provide additional capabilities:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数提供了以各种格式读取整数操作数的能力，以及执行算术和逻辑运算的ALU。这两个函数都可以扩展以提供额外的功能：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `trace()` function prints the state of the processor as a program is executed.
    This can be modified to change the amount, layout, and format of the data:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace()`函数在程序执行时打印处理器的状态。这可以修改以改变数据量、布局和格式：'
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the instruction execution part of the program. Note that instructions
    are executed in the order of their class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序中的指令执行部分。请注意，指令按其类别顺序执行：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A sample run of TC3
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TC3的样本运行
- en: 'Here is the output from a sample run of TC3\. We have provided the source code
    that is executed, the equate and branch table, the assembled code, and then the
    output of a run:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是TC3样本运行的输出。我们提供了执行的源代码、等式和分支表、汇编代码，以及运行输出：
- en: Source code
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Equate and branch table
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等式和分支表
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Assembly loop
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编循环
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: EXECUTE
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行
- en: We have provided only a few lines of the traced output and reformatted them
    to fit on the page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只提供了追踪输出的几行，并将它们重新格式化以适应页面。
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Output not displayed to save space
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，未显示输出
- en: In the next section, we’ll look at one component of simulators in greater detail,
    the ALU.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地研究模拟器的一个组件，即ALU。
- en: Arithmetic and Logic Unit (ALU)
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术逻辑单元 (ALU)
- en: And now for something different. We have used an ALU in all the simulators.
    Here, you will learn about the ALU in greater detail and about its testing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来点不同的。我们已经在所有模拟器中使用了ALU。在这里，你将更详细地了解ALU及其测试。
- en: The following Python code demonstrates the implementation of an 8-bit, 16-function
    ALU. We have added several *contemporary operations* that some computers provide,
    such as modulus, minimum, and maximum. The alu function is called with the `op`,
    `a`, `b`, `cIn`, and `display` parameters. The `op` parameter is in the range
    0 to 15 and defines the function. The `a` and `b` parameters are two 8-bit integers
    in the range 0 to 255, `cin` is a carry in, and `display` is a flag. When display
    is `0`, no data is printed. When `display` is `1`, the inputs and results are
    printed by the function. This feature is for debugging.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Python代码演示了一个8位、16功能的ALU的实现。我们添加了一些计算机提供的**当代操作**，例如取模、最小值和最大值。`alu`函数通过`op`、`a`、`b`、`cIn`和`display`参数调用。`op`参数的范围是0到15，定义了函数。`a`和`b`参数是范围在0到255之间的两个8位整数，`cin`是进位输入，`display`是一个标志。当`display`为`0`时，不打印任何数据。当`display`为`1`时，函数会打印输入和结果。这个特性用于调试。
- en: 'This code demonstrates the use of Python’s if...elif construct to decode the
    arithmetic operation. We have also included a *dictionary structure* that enables
    us to print out the operation code by name. In this case, the dictionary is `allOps`
    and is written as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码演示了使用Python的if...elif结构来解码算术操作。我们还包含了一个**字典结构**，使我们能够通过名称打印出操作码。在这种情况下，字典是`allOps`，如下所示：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Another feature is that we can easily print data in binary form. The `print(bin(c))`
    operation prints `c` in binary form. However, because we are using 8-bit arithmetic
    and wish to see leading zeros, we can force an 8-bit output by using the zfill;
    that is `print(bin(c).zfill(8))` method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特点是，我们可以轻松地以二进制形式打印数据。`print(bin(c))`操作以二进制形式打印`c`。然而，因为我们使用8位算术并且希望看到前导零，我们可以通过使用`zfill`强制8位输出；即`print(bin(c).zfill(8))`方法。
- en: Alternatively, we can use `print('Result', format(c,'08b'))` to print the `c`
    variable as an 8-bit binary string.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`print('Result', format(c,'08b'))`来以8位二进制字符串的形式打印`c`变量。
- en: 'A Python function can return multiple values as a *tuple*. A tuple is a Python
    list of immutable values that cannot be changed; for example, if you write return
    (`c`, `z`, `n`, `v` `cOut`), you are returning a tuple that consists of the function
    we calculated and the `z`, `n`, `v`, and `cOut` flags. These can’t be changed,
    but they can be assigned to variables in the calling program; take the following
    example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数可以返回多个值作为**元组**。元组是Python不可变值的列表，不能更改；例如，如果你写`return (c, z, n, v, cOut)`，你正在返回一个由我们计算出的函数和`z`、`n`、`v`和`cOut`标志组成的元组。这些不能更改，但可以在调用程序中分配给变量；以下是一个示例：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note the calculation of overflow. The `v-bit` is set if the sign bits of the
    two operands are the same and the sign bit of the result is different. Overflow
    is valid only for addition and subtraction. The modulus function returns a positive
    value if the input parameter is negative in two’s complement terms. We do this
    by inverting the bits and adding 1.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意溢出的计算。如果两个操作数的符号位相同且结果的符号位不同，则设置`v-bit`。溢出仅对加法和减法有效。如果输入参数在二进制补码中为负值，则取模函数返回正值。我们通过翻转位并加1来实现这一点。
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Testing the ALU
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试ALU
- en: We will now demonstrate testing the ALU. A `while` loop is created and two integers
    are inputted using Python’s keyboard input function and the `.split()` method
    to divide the input string into substrings. For example, you can enter add 3 5
    to perform the addition of 3 and 5\. A null input (i.e., a return) ends the sequence.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将演示测试ALU的过程。创建了一个`while`循环，并使用Python的键盘输入函数和`.split()`方法将输入字符串分割成子字符串，输入两个整数。例如，你可以输入`add
    3 5`来执行3和5的加法操作。空输入（即回车）将结束序列。
- en: I have arranged the code so that you can see only the parameters entered as
    needed for the operation, for example, add 3,7, mod 5, or sbc 3 4 1\. To make
    it easier to test logic functions, you can enter parameters in binary `(%10110`)
    or hexadecimal `($``3B`) format.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经安排了代码，以便你只能看到操作所需输入的参数，例如，`add 3,7`、`mod 5`或`sbc 3 4 1`。为了更容易测试逻辑函数，你可以以二进制`(%10110)`或十六进制`($3B)`格式输入参数。
- en: A feature of the test code is that I use a reverse dictionary. This allows you
    to enter a function by its name, rather than number.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的一个特点是，我使用了一个反向字典。这允许你通过名称而不是数字来输入一个函数。
- en: 'The following is the code I used to test the ALU:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我用来测试ALU的代码：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s some sample output from a test run:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些测试运行中的示例输出：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A final example: TC4'
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个示例：TC4
- en: In this example, we provide a new simulator that introduces you to some new
    elements of Python, such as the ability to include the date and time. This final
    example of a computer simulator brings some of the things we have discussed together
    and creates a simulator with a 32-bit instruction memory and a 16-bit data memory.
    Consequently, this is not a von Neumann machine because it has different program
    and data memories. TC4 incorporates several modifications to demonstrate both
    simplifications and additions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了一个新的模拟器，它介绍了Python的一些新元素，例如包含日期和时间的能力。这个计算机模拟器的最终例子将我们讨论的一些内容结合起来，创建了一个具有32位指令内存和16位数据内存的模拟器。因此，这不是冯·诺依曼机器，因为它有不同的程序和数据内存。TC4包含了一些修改，以展示简化和添加。
- en: 'We’ll present the code first and then add some comments via the labels that
    indicate points of interest. Shaded parts of the code have comments following
    the code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示代码，然后通过标签添加一些注释，这些标签指示感兴趣的点。代码的阴影部分后面跟着代码的注释：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `memProc()` function deals with the data memory and allows you to store
    data in memory and even ASCII code. This function processes assembler directives:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`memProc()`函数处理数据内存，并允许你在内存中存储数据，甚至ASCII代码。这个函数处理汇编指令：'
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `get_reg()` function determines the number of a register. It first looks
    in the symbol table to determine whether the name is symbolic. Otherwise, it extracts
    the register number from the predicate:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_reg()`函数确定寄存器的编号。它首先在符号表中查找以确定名称是否为符号。如果不是，它从谓词中提取寄存器编号：'
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `get_lit()` function extracts a literal from the predicate. As in the case
    of register names, it is able to deal with symbolic values by first looking for
    the name in the symbol table. If there is no symbolic name, the text is converted
    into the appropriate integer by observing and dealing with any prefixes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_lit()`函数从谓词中提取一个字面量。与寄存器名称的情况一样，它能够通过首先在符号表中查找名称来处理符号值。如果没有符号名称，文本将被转换为适当的整数，通过观察和处理任何前缀来完成：'
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `display()` function takes care of displaying data after each instruction
    has been executed. In this case, the data values are converted into hexadecimal
    format and turned into strings:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`display()`函数负责在每条指令执行后显示数据。在这种情况下，数据值被转换为十六进制格式并转换为字符串：'
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `alu()` function performs arithmetic operations. This example is very rudimentary
    and provides only basic operations. Since we have covered ALU elsewhere, it’s
    not necessary to be comprehensive. You can easily add new functions yourself:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`alu()`函数执行算术运算。这个例子非常基础，只提供了基本操作。因为我们已经在其他地方介绍了ALU，所以没有必要全面介绍。你可以轻松地添加新功能：'
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here, we carry out the usual cleaning up of the source text in the assembly
    language file and prepare the text for later parsing and analysis. Note that we
    use a regular expression to remove multiple spaces. This is a feature we do not
    use in this book, but it is worthwhile investigating if you are doing extensive
    text processing:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行汇编语言文件中源文本的常规清理工作，并为后续的解析和分析准备文本。请注意，我们使用正则表达式来删除多个空格。这是一个我们在这本书中不使用的功能，但如果你在进行大量的文本处理，那么调查它是值得的：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, we execute the code. The program counter is first initialized to 0\. Of
    course, we could have started at any arbitrary point or even provided assembly
    language directives to preset the pc. After setting the pc, we read an instruction
    and parse it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们执行代码。程序计数器首先初始化为0。当然，我们可以在任何任意点开始，甚至提供汇编语言指令来预置pc。在设置pc之后，我们读取一条指令并解析它。
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can use `opFormat` to extract the required parameters from the predicate:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`opFormat`从谓词中提取所需的参数：
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this example of a simulator, we create the binary code to be executed. The
    various parameters extracted from the predicate have to be moved into the appropriate
    place to create the final binary code, `binCode`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模拟器的例子中，我们创建要执行的二进制代码。从谓词中提取的各种参数必须移动到适当的位置以创建最终的二进制代码`binCode`：
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This block initializes variables, registers, memory, and the stack pointer
    before we enter the code execution loop. Note that we create a stack with 16 entries.
    The stack pointer is set to `16`, which is one below the bottom of the stack.
    When the first item is pushed, the stack pointer is pre-decremented to `15`, the
    bottom of the available stack area:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码执行循环之前，这个块初始化变量、寄存器、内存和栈指针。注意我们创建了一个包含 16 个条目的栈。栈指针被设置为 `16`，这是栈底以下的一个位置。当第一个项目被推入时，栈指针预先递减到
    `15`，这是可用栈区域的底部：
- en: '[PRE72]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, the instructions are executed. Note we used an `if` statement for each
    instruction. This was used during the initial development phase. In practice,
    an if...elif structure would be more suitable:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，执行指令。注意我们为每个指令使用了一个 `if` 语句。这在初始开发阶段被使用过。在实践中，一个 if...elif 结构会更合适：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the following code we’ve included stack-based operations for the sake of
    demonstrating stack usage and for versatility:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们包括基于栈的操作是为了演示栈的使用和多功能性：
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Comments on TC4
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 TC4 的注释
- en: 'We have not provided a detailed discussion of this program because it follows
    the same pattern as earlier simulators. However, we have highlighted some of its
    principal features. The following numbers correspond to the numbers (at the end
    of the comment field) in the shaded lines of the code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有对这个程序提供详细的讨论，因为它遵循了早期模拟器相同的模式。然而，我们已经突出了一些其主要特性。以下数字对应于代码中阴影行的注释字段末尾的数字：
- en: Call regular expressions library. This is a library that handles regular expressions
    that offer a very powerful means of processing text. In this example, we use only
    one simple example of regular text processing.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用正则表达式库。这是一个处理正则表达式的库，提供了非常强大的文本处理手段。在这个例子中，我们只使用了一个简单的正则文本处理示例。
- en: The `src = [re.sub(' +', ' ',i) for i in src ]` Python expression uses a regular
    expression to remove multiple spaces from a text string. We have included this
    to point you in the direction of regular expressions for more sophisticated text
    manipulation.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`src = [re.sub('' +'', '' '',i) for i in src ]` 这个 Python 表达式使用正则表达式从一个文本字符串中移除多个空格。我们包括这个例子是为了指导你了解正则表达式在更复杂的文本操作中的应用。'
- en: The `from datetime import date` operation imports a method date from datetime
    that can be used to display the date and time. This is useful for labeling your
    output during a run.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`from datetime import date` 操作导入了一个来自 datetime 的 date 方法，可以用来显示日期和时间。这在运行过程中标记输出时非常有用。'
- en: TC4 has an optional debugging facility. We can select three options. Entering
    ‘D’ provides a debugging facility by printing the source program as it is processed.
    We can see the original source code, the source code without comments and assembly
    directives, and the processed version, which includes the binary output after
    assembly. The ‘T’ option provides a line-by-line trace function that executes
    a line of code each time the *Enter* key is pressed. The ‘B’ option supports breakpoints
    where the output is printed only at a breakpoint. The breakpoint may be a label,
    a mnemonic, or the PC value. Note that in breakpoint mode, only breakpoint lines
    are displayed.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TC4 有一个可选的调试功能。我们可以选择三个选项。输入‘D’通过打印正在处理的源程序来提供调试功能。我们可以看到原始源代码、不带注释和汇编指令的源代码，以及经过处理的版本，包括汇编后的二进制输出。‘T’选项提供了一个按行跟踪功能，每次按下
    *Enter* 键时执行一行代码。‘B’选项支持断点，只有当输出在断点处时才会打印。断点可能是一个标签、助记符或 PC 值。注意，在断点模式下，只显示断点行。
- en: Entering `T` or `B` at the prompt can be used to set up a trace mode or enter
    instructions or PC values into the breakpoint table. Unusually, this is performed
    once at the beginning of the program and not during the execution phase.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符处输入 `T` 或 `B` 可以用来设置跟踪模式或输入指令或 PC 值到断点表中。不寻常的是，这仅在程序开始时执行，而不是在执行阶段。
- en: The function processes the source code and deals with assembly directives related
    to setting up the data memory, for example, loading data values with the `.WORD`
    directive. It also supports storing an ASCII character in memory and reserving
    a named memory location for data.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数处理源代码并处理与设置数据内存相关的汇编指令，例如，使用 `.WORD` 指令加载数据值。它还支持在内存中存储 ASCII 字符并为数据保留一个命名的内存位置。
- en: The most important directive is `.WORD`, which stores a numeric value in memory
    and gives that address a symbolic value. For example, if the next free data memory
    location were `20`, then the`.WORD TIME 100` expression would store the number
    `100` at memory location `20` and bind the name `time` to `100`. The`.DSW` (define
    storage word) directive simply reserves memory locations for future data access
    and names the address of the first location; for example, if the current memory
    location is `10`, then `.DSW XYZ 5` frees five memory locations (`10`, `11`, `12`,
    `13`, and `14`) and binds the names `XYZ` to `10`. The memory pointer is moved
    to `15`, the next free location. The `memPoint` variable is the memory pointer
    that keeps track of where data is to be stored in data memory during the assembly
    phase. The `.ASCII` directive is there for demonstration purposes. The `.ASCII
    PQR` directive would store the ASCII code for the character `'T'` in memory.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的指令是`.WORD`，它在内存中存储一个数值，并给该地址一个符号值。例如，如果下一个空闲的数据内存位置是`20`，那么`.WORD TIME 100`表达式会将数字`100`存储在内存位置`20`，并将名称`time`绑定到`100`。`.DSW`（定义存储字）指令简单地为未来的数据访问预留内存位置，并命名第一个位置的地址；例如，如果当前内存位置是`10`，那么`.DSW
    XYZ 5`会释放五个内存位置（`10`、`11`、`12`、`13`和`14`），并将名称`XYZ`绑定到`10`。内存指针移动到`15`，下一个空闲位置。`memPoint`变量是内存指针，在汇编阶段跟踪数据在数据内存中的存储位置。`.ASCII`指令是为了演示目的而存在的。`.ASCII
    PQR`指令会在内存中存储字符`'T'`的ASCII代码。
- en: These directives are removed from the source code after they have done their
    job.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些指令在其任务完成后从源代码中移除。
- en: We have created a very simple ALU that implements only add and subtract. This
    was done to keep the program small and concentrate on more interesting instructions
    in this final example. Simple logic operations are directly implemented in the
    code execution of the program, in the style
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的ALU，仅实现加法和减法。这样做是为了保持程序小巧，并专注于在这个最终示例中更有趣的指令。简单的逻辑操作直接在程序的代码执行中实现，风格如下
- en: '`if thisOpcode == ''AND'': result = a & b`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`if thisOpcode == ''AND'': result = a & b`。'
- en: TC4 provides several stack operations (push and pull). We initially create a
    separate stack. TC4’s stack does not use the data memory. This feature is for
    demonstration and can be expanded.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TC4提供了几种栈操作（压栈和出栈）。我们最初创建了一个单独的栈。TC4的栈不使用数据内存。这个特性是为了演示，可以扩展。
- en: Real computers normally contain a far wider range of conditional branches than
    we have in this book. Here, we demonstrate one such branch operation, `BHS`, which
    means branch if higher or same. This operation forces a branch if two values are
    compared and `x` > `y` or `x` = `y`. Note that this applies to unsigned numbers
    (i.e., not two’s complement). This condition is met if the carry bit, `c`, is
    `0` after a comparison. `BHS` and `BCC` (branch on carry 0) are synonyms. For
    example, if `x = 1000` and `y = 0100`, `x` > `y` if the numbers are unsigned (4
    > -8) and y > `x` (8 > 4) if the numbers are signed.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的计算机通常包含比我们在这本书中展示的更广泛的条件分支。在这里，我们演示了一种这样的分支操作，`BHS`，表示如果更高或相同则分支。这个操作在比较两个值时强制分支，如果`x`
    > `y`或`x` = `y`。请注意，这适用于无符号数（即，不是二进制补码）。如果比较后的进位位`c`为`0`，则满足此条件。`BHS`和`BCC`（在进位为0时分支）是同义词。例如，如果`x
    = 1000`和`y = 0100`，则无符号数时`x` > `y`（4 > -8），如果是有符号数则`y` > `x`（8 > 4）。
- en: The `LDRI+` operation performs a pointer-based load register operation and then
    increments the pointer register.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LDRI+`操作执行基于指针的加载寄存器操作，然后增加指针寄存器。'
- en: We have provided an interesting branch and return operation like that of the
    ARM’s branch with link. The `BL` operation jumps to a target address and saves
    the return address in a special register called the link register, `rl`. At the
    end of the subroutine, the `RL` (return from link) instruction returns to the
    instruction after the call. This mechanism allows only one call, because a second
    call would overwrite the return address in the link register.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供了一个类似于ARM的带链接的分支和返回操作。`BL`操作跳转到目标地址，并将返回地址保存在一个称为链接寄存器`rl`的特殊寄存器中。在子例程结束时，`RL`（从链接返回）指令返回到调用之后的指令。这种机制只允许一个调用，因为第二个调用会覆盖链接寄存器中的返回地址。
- en: To demonstrate direct printing, the `PRT` operation displays the character corresponding
    to the ASCII code in the register; for example, if R1 contains 0x42, the `PRT
    R2` operation would display `B` on the console.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示直接打印，`PRT`操作显示寄存器中ASCII代码对应的字符；例如，如果R1包含0x42，则`PRT R2`操作会在控制台上显示`B`。
- en: When the program has been executed, the `sys.exit()` library function exits
    the program.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序执行完毕后，`sys.exit()`库函数将退出程序。
- en: 'Here’s an example of code that can be executed by TC4\. It’s been badly set
    out in order to test TC4’s ability to process text:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个可以被TC4执行的代码示例。它被错误地设置，以便测试TC4处理文本的能力：
- en: '[PRE75]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This example ends the section of this book on designing simulators in Python.
    In the next part, we’ll look at a real computer.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子结束了本书关于在Python中设计模拟器这一部分。在下一部分，我们将研究一台真正的计算机。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have extended our overview of simulator design. We started
    with one of the simplest simulators of them all, the *zero-address machine*; that
    is, the *stack computer*, TC0\. This simulator is not a true computer, because
    it does not include conditional and branch operations. However, it demonstrates
    the use of the stack as a means of performing chained calculations.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们关于模拟器设计的概述。我们从所有中最简单的模拟器之一开始，即*零地址机*；也就是说，*堆栈计算机*，TC0。这个模拟器不是一个真正的计算机，因为它不包括条件和分支操作。然而，它展示了使用堆栈作为执行链式计算的手段。
- en: We then looked at the instruction set architecture (IAS) of a classic 8-bit
    computer, with its simple one-address instruction format, where all operations
    are applied to a single accumulator (i.e., register) and the contents of a memory
    location or a literal.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着研究了经典8位计算机的指令集架构（IAS），它具有简单的单地址指令格式，其中所有操作都应用于单个累加器（即寄存器）和内存位置的内容或一个字面量。
- en: The one-address machine is followed by the simulation of a multi-register CISC
    ISA that allows operations between two registers or between a register and the
    contents of a memory location. The simulator we developed had a 22-bit address
    just to demonstrate that you can have instructions of any width.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 单地址机之后是模拟一个多寄存器CISC指令集架构（ISA），它允许在两个寄存器之间或寄存器与内存位置的内容之间进行操作。我们开发的模拟器有一个22位的地址，只是为了演示你可以有任意宽度的指令。
- en: We also looked at the simulator of an ALU to further demonstrate the way in
    which arithmetic operations can be simulated.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了ALU的模拟，以进一步展示算术操作是如何被模拟的。
- en: Finally, we presented a register-to-register machine with separate data and
    instruction memories.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了一个具有独立的数据和指令存储器的寄存器到寄存器机。
- en: In the next chapter, we’ll change course and introduce the ARM-based Raspberry
    Pi microprocessor, which can be used to write programs in Python, and learn how
    to program a real 32-bit ARM microprocessor in assembly language.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改变方向，介绍基于ARM的Raspberry Pi微处理器，它可以用来编写Python程序，并学习如何用汇编语言编程一个真正的32位ARM微处理器。
