- en: Chapter 3. Containers and Collections – Storing Data the Right Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。容器和集合-正确存储数据
- en: Python comes bundled with several very useful collections, a few of which are
    basic Python collection data types. The rest are advanced combinations of these
    types. In this chapter, we will explain some of these collections, how to use
    them, and the pros and cons of each of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python捆绑了几个非常有用的集合，其中一些是基本的Python集合数据类型。其余的是这些类型的高级组合。在本章中，我们将解释其中一些集合的使用方法，以及它们各自的优缺点。
- en: Before we can properly discuss data structures and the related performance,
    a basic understanding of time complexity (and specifically the big O notation)
    is required. No need to worry! The concept is really simple, but without it, we
    cannot easily explain the performance characteristics of operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式讨论数据结构和相关性能之前，需要对时间复杂度（特别是大O符号）有基本的了解。不用担心！这个概念非常简单，但没有它，我们无法轻松地解释操作的性能特征。
- en: 'Once the big O notation is clear, we will discuss the basic data structures:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦大O符号清晰，我们将讨论基本数据结构：
- en: '`list`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`dict`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`'
- en: '`set`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`tuple`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple`'
- en: 'Building on the basic data structures, we will continue with more advanced
    collections, such as the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本数据结构的基础上，我们将继续介绍更高级的集合，例如以下内容：
- en: 'Dictionary-like types:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似字典的类型：
- en: '`ChainMap`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`'
- en: '`Counter`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`'
- en: '`Defaultdict`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Defaultdict`'
- en: '`OrderedDict`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`'
- en: 'List types:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表类型：
- en: '`Deque`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deque`'
- en: '`Heapq`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Heapq`'
- en: 'Tuple types:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型：
- en: '`NamedTuple`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedTuple`'
- en: 'Other types:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型：
- en: '`Enum`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enum`'
- en: Time complexity – the big O notation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间复杂度-大O符号
- en: Before we can begin with this chapter, there is a simple notation that you need
    to understand. This chapter heavily uses the big O notation to indicate the time
    complexity for an operation. Feel free to skip this paragraph if you are already
    familiar with this notation. While this notation sounds really complicated, the
    concept is actually quite simple.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，您需要了解一个简单的符号。本章大量使用大O符号来指示操作的时间复杂度。如果您已经熟悉这个符号，可以跳过这一段。虽然这个符号听起来很复杂，但实际概念非常简单。
- en: When we say that a function takes `O(1)` time, it means that it generally only
    takes `1` step to execute. Similarly, a function with `O(n)` would take `n` steps
    to execute, where `n` is generally the size of the object. This time complexity
    is just a basic indication of what to expect when executing the code, as it is
    generally what matters most.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个函数需要`O(1)`的时间时，这意味着通常只需要`1`步来执行。同样，一个具有`O(n)`的函数将需要`n`步来执行，其中`n`通常是对象的大小。这种时间复杂度只是对执行代码时可以预期的基本指示，因为这通常是最重要的。
- en: The purpose of this system is to indicate the approximate performance of an
    operation; this is separate from code speed but it is still relevant. A piece
    of code that executes a single step `1000` times faster but needs `O(2**n)` steps
    to execute will still be slower than another version of it that takes only `O(n)`
    steps for a value of n equal to `10` or more. This is because `2**n` for `n=10`
    is `2**10=1024`, that is, 1,024 steps to execute the same code. This makes choosing
    the right algorithm very important. Even though `C` code is generally faster than
    Python, if it uses the wrong algorithm, it won't help at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的目的是指示操作的大致性能；这与代码速度无关，但仍然相关。执行单个步骤的代码`1000`次更快，但需要执行`O(2**n)`步骤的代码仍然比另一个版本慢，因为对于n等于`10`或更高的值，它只需要`O(n)`步骤。这是因为`n=10`时`2**n`为`2**10=1024`，也就是说，执行相同代码需要1,024步。这使得选择正确的算法非常重要。即使`C`代码通常比Python快，如果使用错误的算法，也毫无帮助。
- en: 'For example, suppose you have a list of `1000` items and you walk through them.
    This will take `O(n)` time because there are `n=1000` items. Checking whether
    or not an item exists in the list takes `O(n)`, so that''s 1,000 steps. Doing
    this 100 times will take you `100*O(n) = 100 * 1000 = 100,000` steps. When you
    compare this to a `dict`, where checking whether the item exists or not takes
    `only O(1)` time the difference is huge. With a `dict`, it would be `100*O(1)
    = 100 * 1 = 100` steps. So, using a `dict` instead of a `list` will be roughly
    1,000 times faster for an object with 1,000 items:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个包含`1000`个项目的列表，并且您遍历它们。这将花费`O(n)`的时间，因为有`n=1000`个项目。检查项目是否存在于列表中需要`O(n)`的时间，因此需要1,000步。这样做100次将花费`100*O(n)
    = 100 * 1000 = 100,000`步。当您将其与`dict`进行比较时，检查项目是否存在只需要`O(1)`的时间，差异是巨大的。使用`dict`，将是`100*O(1)
    = 100 * 1 = 100`步。因此，对于包含1000个项目的对象，使用`dict`而不是`list`将大约快1,000倍：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To illustrate `O(1)`, `O(n)`, and `O(n**2)` functions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`O(1)`，`O(n)`和`O(n**2)`函数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It should be noted that the big O in this chapter is about the average case
    and not the worst case. In some cases, they can be much worse, but those are rare
    enough to be ignored for the general case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，本章中的大O是关于平均情况，而不是最坏情况。在某些情况下，它们可能更糟，但这些情况很少，可以忽略不计。
- en: Core collections
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心集合
- en: Before we can look at the more advanced combined collections later in this chapter,
    you need to understand the workings of the core Python collections. This is not
    just about the usage, however; it is also about the time complexities involved,
    which can strongly affect how your application will behave as it grows. If you
    are well versed with the time complexities of these objects and know the possibilities
    of Python 3's tuple packing and unpacking by heart, then feel free to jump to
    the *Advanced collections* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后讨论更高级的组合集合之前，您需要了解核心Python集合的工作原理。这不仅仅是关于使用，还涉及到时间复杂度，这会对应用程序随着增长而产生强烈影响。如果您熟悉这些对象的时间复杂度，并且熟记Python
    3的元组打包和解包的可能性，那么可以直接跳到*高级集合*部分。
- en: list – a mutable list of items
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list - 一个可变的项目列表
- en: The `list` is most likely the container structure that you've used most in Python.
    It is simple in its usage, and for most cases, it exhibits great performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`很可能是您在Python中最常用的容器结构。它的使用简单，对于大多数情况，性能很好。'
- en: 'While you may already be well versed with the usage of list, you might not
    be aware of the time complexities of the `list` object. Luckily, many of the time
    complexities of `list` are very low; `append`, `get`, `set`, and `len` all take
    `O(1)` time—the best possible. However, you might not be aware of the fact that
    `remove` and `insert` have `O(n)` time complexity. So, to delete a single item
    out of 1,000 items, Python will have to walk-through 1,000 items. Internally,
    the `remove` and `insert` operations execute something along these lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能已经熟悉了列表的使用，但你可能不知道`list`对象的时间复杂度。幸运的是，`list`的许多时间复杂度非常低；`append`，`get`，`set`和`len`都需要`O(1)`的时间-这是最好的可能性。但是，你可能不知道`remove`和`insert`的时间复杂度是`O(n)`。因此，要从1000个项目中删除一个项目，Python将不得不遍历1000个项目。在内部，`remove`和`insert`操作执行类似于这样的操作：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To remove or insert a single item from/into the list, Python needs to copy
    the entire list, which is especially heavy with larger lists. When executing this
    only once, it is of course not all that bad. But when executing a large number
    of deletions, a `filter` or `list` comprehension is a much faster solution because,
    if properly structured, it needs to copy the list only once. For example, suppose
    we wish to remove a specific set of numbers from the list. We have quite a few
    options for this. The first is a solution using `remove`, followed by a list comprehension,
    and then comes a `filter` statement. [Chapter 4](ch04.html "Chapter 4. Functional
    Programming – Readability Versus Brevity"), *Functional Programming – Readability
    Versus Brevity*, will explain `list` comprehensions and the `filter` statement
    in more detail. But first, let''s check out the example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中删除或插入单个项目，Python需要复制整个列表，这在列表较大时特别耗费资源。当执行一次时，当然不是那么糟糕。但是当执行大量删除时，`filter`或`list`推导是一个更快的解决方案，因为如果结构良好，它只需要复制列表一次。例如，假设我们希望从列表中删除一组特定的数字。我们有很多选项。第一个是使用`remove`，然后是列表推导，然后是`filter`语句。[第4章](ch04.html
    "第4章。功能编程-可读性与简洁性"), *功能编程-可读性与简洁性*，将更详细地解释`list`推导和`filter`语句。但首先，让我们看看这个例子：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The latter two are much faster for large lists of items. This is because the
    operations are much faster. To compare using `n=len(items)` and `m=len(primes)`,
    the first takes `O(m*n)=5*10=50` operations, whereas the latter two take `O(n*1)=10*1=10`
    operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 后两种对于大量项目的列表要快得多。这是因为操作要快得多。比较使用`n=len(items)`和`m=len(primes)`，第一个需要`O(m*n)=5*10=50`次操作，而后两个需要`O(n*1)=10*1=10`次操作。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first method is actually slightly better than that since `n` decreases during
    the loop. So, it's effectively `10+9+8+7+6=40`, but this is an effect that is
    negligible enough to ignore. In the case of `n=1000`, that would be the difference
    between `1000+999+998+997+996=4990` and `5*1000=5000`, which is negligible in
    most cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法实际上比这更好一些，因为`n`在循环过程中减少。所以，实际上是`10+9+8+7+6=40`，但这是一个可以忽略的效果。在`n=1000`的情况下，这将是`1000+999+998+997+996=4990`和`5*1000=5000`之间的差异，在大多数情况下是可以忽略的。
- en: Of course, `min`, `max`, and `in` all take `O(n)` as well, but that is expected
    for a structure that is not optimized for these types of lookups.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`min`，`max`和`in`都需要`O(n)`，但这对于一个不是为这些类型的查找进行优化的结构来说是可以预料的。
- en: 'They can be implemented like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以这样实现：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these examples, it's obvious as well that the `in` operator could work
    `O(1)` if you're lucky, but we count it as `O(n)` because it might not exist,
    in which case all values need to be checked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些例子，很明显`in`运算符如果你幸运的话可以工作`O(1)`，但我们将其视为`O(n)`，因为它可能不存在，如果不存在，那么所有的值都需要被检查。
- en: dict – unsorted but a fast map of items
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dict-无序但快速的项目映射
- en: The `dict` has to be at least among the top three container structures you use
    in Python. It's fast, simple to use, and very effective. The average time complexity
    is exactly as you would expect—`O(1)` for `get`, `set`, and `del`—but there are
    cases where this is not true. The way a `dict` works is by converting the key
    to a hash using the `hash` function (calls the `__hash__` function of an object)
    and storing it in a hash table. There are two problems with hash tables, however.
    The first and the most obvious is that the items will be sorted by hash, which
    appears at random in most cases. The second problem with hash tables is that they
    can have hash collisions, and the result of a hash collision is that in the worst
    case, all the former operations can take `O(n)` instead. Hash collisions are not
    all that likely to occur, but they can occur, and if a large `dict` performs subpar,
    that's the place to look.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`必须至少是你在Python中使用的前三种容器结构之一。它快速，易于使用，非常有效。平均时间复杂度正如你所期望的那样-`O(1)`对于`get`，`set`和`del`-但也有一些例外。`dict`的工作方式是通过使用`hash`函数（调用对象的`__hash__`函数）将键转换为哈希并将其存储在哈希表中。然而，哈希表有两个问题。第一个和最明显的问题是，项目将按哈希排序，这在大多数情况下是随机的。哈希表的第二个问题是它们可能会发生哈希冲突，哈希冲突的结果是在最坏的情况下，所有先前的操作可能需要`O(n)`。哈希冲突并不太可能发生，但它们可能发生，如果一个大的`dict`表现不佳，那就是需要查看的地方。'
- en: 'Let''s see how this actually works in practice. For the sake of this example,
    I will use the simplest hashing algorithm I can think of, which is the most significant
    digit of a number. So, for the case of `12345`, it will return `1`, and for `56789`,
    it will return `5`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是如何工作的。为了举例说明，我将使用我能想到的最简单的哈希算法，即数字的最高位。所以，对于`12345`，它将返回`1`，对于`56789`，它将返回`5`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we will emulate a `dict` using a `list` of lists with this hashing method.
    We know that our hashing method can only return numbers from `0` to `9`, so we
    need only 10 buckets in our list. Now we will add a few values and show how the
    spam in eggs might work:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用这种哈希方法使用一个列表的列表来模拟一个`dict`。我们知道我们的哈希方法只能返回`0`到`9`之间的数字，所以我们在列表中只需要10个桶。现在我们将添加一些值，并展示spam
    in eggs可能如何工作：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is obviously not identical to the `dict` implementation, but it is
    actually quite similar internally. Because we can just get item `1` for a value
    of `123` by simple indexing, we have only `O(1)` lookup costs in the general case.
    However, since both keys, `123` and `101`, are within the `1` bucket, the runtime
    can actually increase to `O(n)` in the worst case where all keys have the same
    hash. That is what we call a hash collision.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然与`dict`的实现不同，但在内部实际上非常相似。因为我们可以通过简单的索引获取值为`123`的项`1`，所以在一般情况下，我们只有`O(1)`的查找成本。然而，由于`123`和`101`两个键都在`1`桶中，运行时实际上可能增加到`O(n)`，在最坏的情况下，所有键都具有相同的散列。这就是我们所说的散列冲突。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To debug hash collisions, you can use the `hash()` function paired with the
    counter collection, discussed in the *counter – keeping track of the most occurring
    elements* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试散列冲突，可以使用`hash()`函数与计数集合配对，这在*counter – keeping track of the most occurring
    elements*部分有讨论。
- en: In addition to the hash collision performance problem, there is another behavior
    that might surprise you. When deleting items from a dictionary, it won't actually
    resize the dictionary in memory yet. The result is that both copying and iterating
    the entire dictionary take `O(m)` time (where m is the maximum size of the dictionary);
    `n`, the current number of items is not used. So, if you add 1,000 items to a
    `dict` and remove 999, iterating and copying will still take 1,000 steps. The
    only way to work around this issue is by recreating the dictionary, which is something
    that both the `copy` and `insert` operations will perform internally. Note that
    recreation during an `insert` operation is not guaranteed and depends on the number
    of free slots available internally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了散列冲突性能问题，还有另一种可能让你感到惊讶的行为。当从字典中删除项时，它实际上不会立即调整内存中的字典大小。结果是复制和迭代整个字典都需要`O(m)`时间（其中m是字典的最大大小）；当前项数n不会被使用。因此，如果向`dict`中添加1000个项并删除999个项，迭代和复制仍将需要1000步。解决此问题的唯一方法是重新创建字典，这是`copy`和`insert`操作都会在内部执行的操作。请注意，`insert`操作期间的重新创建不是保证的，而是取决于内部可用的空闲插槽数量。
- en: set – like a dict without values
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: set - 没有值的字典
- en: 'A `set` is a structure that uses the hash method to get a unique collection
    of values. Internally, it is very similar to a `dict`, with the same hash collision
    problem, but there are a few handy features of set that need to be shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`是一种使用散列方法获取唯一值集合的结构。在内部，它与`dict`非常相似，具有相同的散列冲突问题，但`set`有一些方便的功能需要展示：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first few are pretty much as expected. At the operators, it gets interesting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个基本上都是预期的。在操作符处，它变得有趣起来。
- en: '| Expression | Output | Explanation |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 输出 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spam` | `amps` | All unique items. A `set` doesn''t allow for duplicates.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `spam` | `amps` | 所有唯一的项。`set` 不允许重复。 |'
- en: '| `eggs` | `egs` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `eggs` | `egs` |'
- en: '| `spam & eggs` | `s` | Every item in both. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `spam & eggs` | `s` | 两者中的每一项。 |'
- en: '| `spam &#124; eggs` | `aegmps` | Every item in either or both. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `spam &#124; eggs` | `aegmps` | 两者中的任一项或两者都有的。 |'
- en: '| `spam ^ eggs` | `aegmp` | Every item in either but not in both. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `spam ^ eggs` | `aegmp` | 两者中的任一项，但不是两者都有的。 |'
- en: '| `spam - eggs` | `amp` | Every item in the first but not the latter. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `spam - eggs` | `amp` | 第一个中的每一项，但不是后者中的。 |'
- en: '| `eggs - spam` | `eg` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `eggs - spam` | `eg` |'
- en: '| `spam > eggs` | `False` | True if every item in the latter is in the first.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `spam > eggs` | `False` | 如果后者中的每一项都在前者中，则为真。 |'
- en: '| `eggs > spam` | `False` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `eggs > spam` | `False` |'
- en: '| `spam > sp` | `True` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `spam > sp` | `True` |'
- en: '| `spam < sp` | `False` | True if every item in the first is contained in the
    latter. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `spam < sp` | `False` | 如果第一个中的每一项都包含在后者中，则为真。 |'
- en: 'One useful example for `set` operations is calculating the differences between
    two objects. For example, let''s assume we have two lists:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`操作的一个有用示例是计算两个对象之间的差异。例如，假设我们有两个列表：'
- en: '`current_users`: The current users in a group'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_users`: 组中的当前用户'
- en: '`new_users`: The new list of users in a group'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_users`: 组中的新用户列表'
- en: 'In permission systems, this is a very common scenario—mass adding and/or removing
    users from a group. Within many permission databases, it''s not easily possible
    to set the entire list at once, so you need a list to insert and a list to delete.
    This is where `set` comes in really handy:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在权限系统中，这是一个非常常见的场景——从组中批量添加和/或删除用户。在许多权限数据库中，不容易一次设置整个列表，因此你需要一个要插入的列表和一个要删除的列表。这就是`set`真正方便的地方：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have lists of all users who were added, removed, and unchanged. Note
    that `sorted` is only needed for consistent output, since a `set`, similar to
    a `dict`, has no predefined sort order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有被添加、删除和未更改的用户列表。请注意，`sorted`仅用于一致的输出，因为`set`与`dict`类似，没有预定义的排序顺序。
- en: tuple – the immutable list
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组 - 不可变列表
- en: A `tuple` is an object that you use very often without even noticing it. When
    you look at it initially, it seems like a useless data structure. It's like a
    list that you can't modify, so why not just use a `list`? There are a few cases
    where a `tuple` offers some really useful functionalities that a `list` does not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`是一个你经常使用而甚至都没有注意到的对象。当你最初看到它时，它似乎是一个无用的数据结构。它就像一个你无法修改的列表，那么为什么不只使用`list`呢？有一些情况下，`tuple`提供了一些`list`没有的非常有用的功能。'
- en: 'Firstly, they are hashaable. This means that you can use a `tuple` as a key
    in a `dict`, which is something a `list` can''t do:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们是可散列的。这意味着你可以将`tuple`用作`dict`中的键，这是`list`无法做到的：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, it can actually be more than simple numbers. As long as all elements
    of a `tuple` are hashable, it will work. This means that you can use nested tuples,
    strings, numbers, and anything else for which the `hash()` function returns a
    consistent result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它实际上可以比简单的数字更复杂。只要`tuple`的所有元素都是可散列的，它就可以工作。这意味着你可以使用嵌套的元组、字符串、数字和任何其他`hash()`函数返回一致结果的东西：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can make these as complex as you need. As long as all the parts are hashable,
    it will function as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使它们变得如你所需的那样复杂。只要所有部分都是可散列的，它就会按预期运行。
- en: 'Perhaps, even more useful is the fact that tuples also support tuple packing
    and unpacking:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更有用的是元组也支持元组打包和解包：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In addition to regular packing and unpacking, from Python 3 onwards, we can
    actually pack and unpack objects with a variable number of items:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的打包和解包外，从Python 3开始，我们实际上可以使用可变数量的项目打包和解包对象：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This very method can be applied in many cases, even for function arguments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在许多情况下都可以应用，甚至用于函数参数：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And its equally useful to return multiple arguments from a function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从函数返回多个参数也很有用：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Advanced collections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级集合
- en: The following collections are mostly just extensions of base collections, some
    of them fairly simple and others a bit more advanced. For all of them though,
    it is important to know the characteristics of the underlying structures. Without
    understanding them, it will be difficult to comprehend the characteristics of
    these collections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下集合大多只是基本集合的扩展，其中一些非常简单，另一些则稍微复杂一些。不过，对于所有这些集合，了解底层结构的特性是很重要的。如果不了解它们，将很难理解这些集合的特性。
- en: There are a few collections that are implemented in native C code for performance
    reasons, but all of them can easily be implemented in pure Python as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，有一些集合是用本机C代码实现的，但所有这些集合也可以很容易地在纯Python中实现。
- en: ChainMap – the list of dictionaries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChainMap - 字典列表
- en: Introduced in Python 3.3, `ChainMap` allows you to combine multiple mappings
    (dictionaries for example) into one. This is especially useful when combining
    multiple contexts. For example, when looking for a variable in your current scope,
    by default, Python will search in `locals()`, `globals()`, and lastly `builtins`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.3中引入的`ChainMap`允许您将多个映射（例如字典）合并为一个。这在合并多个上下文时特别有用。例如，在查找当前作用域中的变量时，默认情况下，Python会在`locals()`，`globals()`，最后是`builtins`中搜索。
- en: 'Normally, you would do something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会这样做：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This works, but it''s ugly to say the least. We can make it prettier, of course:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但至少可以说很丑陋。当然，我们可以让它更漂亮：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A lot better! Moreover, this can actually be considered a nice solution. But
    since Python 3.3, it''s even easier. Now we can simply use the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！而且，这实际上可以被认为是一个不错的解决方案。但自从Python 3.3以来，它变得更容易了。现在我们可以简单地使用以下代码：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `ChainMap` collection is very useful for command-line applications. The
    most important configuration happens through command-line arguments, followed
    by directory local config files, followed by global config files, followed by
    defaults:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`集合对于命令行应用程序非常有用。最重要的配置是通过命令行参数进行的，然后是目录本地配置文件，然后是全局配置文件，最后是默认配置：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that accessing specific mappings is still possible:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍然可以访问特定的映射：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: counter – keeping track of the most occurring elements
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: counter - 跟踪最常出现的元素
- en: 'The `counter` is a class for keeping track of the number of occurrences of
    an element. Its basic usage is as you would expect:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter`是一个用于跟踪元素出现次数的类。它的基本用法如您所期望的那样：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, `counter` can do more than simply return the count. It also has a
    few very useful and fast (it uses `heapq`) methods for getting the most common
    elements. Even with a million elements added to the counter, it still executes
    within a second:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`counter`不仅仅可以返回计数。它还有一些非常有用且快速（它使用`heapq`）的方法来获取最常见的元素。即使向计数器添加了一百万个元素，它仍然在一秒内执行：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But wait, there''s more! In addition to getting the most frequent elements,
    it''s also possible to add, subtract, intersect, and "union" counters very similarly
    to the `set` operations that we saw earlier. So what is the difference between
    adding two counters and making a union of them? As you would expect, they are
    similar, but there is a small difference. Let''s look at its workings:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！除了获取最频繁的元素之外，还可以像我们之前看到的`set`操作一样添加、减去、交集和"联合"计数器。那么添加两个计数器和对它们进行联合有什么区别呢？正如您所期望的那样，它们是相似的，但有一点不同。让我们看看它的工作原理：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two are obvious. The `eggs` string is just a sequence of characters
    with two "`g`"s, one "`s`", and one "`e`", and spam is almost the same but with
    different letters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是显而易见的。`eggs`字符串只是一个包含两个"`g`"，一个"`s`"和一个"`e`"的字符序列，spam几乎相同，但字母不同。
- en: The result of `spam & eggs` (and the reverse) is also quite predictable. The
    only letter that's shared between spam and eggs is `s`, so that's the result.
    When it comes to counts, it simply does a `min(element_a, element_b)` per shared
    element from both and gets the lowest.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam & eggs`的结果（以及反向）也是非常可预测的。spam和eggs之间唯一共享的字母是`s`，因此这就是结果。在计数方面，它只是对来自两者的共享元素执行`min(element_a,
    element_b)`，并得到最低值。'
- en: When subtracting the letters `s`, `p`, `a`, and `m` from eggs, you are left
    with `e` and `g`. Similarly, when removing `e`, `g`, and `s` from spam, you are
    left with `p`, `a`, and `m`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从eggs中减去字母`s`，`p`，`a`和`m`，剩下`e`和`g`。同样，从spam中删除`e`，`g`和`s`，剩下`p`，`a`和`m`。
- en: Now, adding is as you would expect—just an element-by-element addition of both
    counters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加就像您所期望的那样 - 只是对两个计数器的每个元素进行逐个相加。
- en: So how is the union (OR) any different? It gets the `max(element_a, element_b)`
    per element in either of the counters instead of adding them; regardless as is
    the case with the addition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么联合（OR）有什么不同呢？它获取每个计数器中元素的`max(element_a, element_b)`，而不是将它们相加；与添加的情况一样。
- en: Lastly, as is demonstrated in the preceding code, the elements method returns
    an expanded list of all elements repeated by the count.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如前面的代码所示，elements方法返回一个由计数重复的所有元素扩展列表。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Counter` object will automatically remove elements that are zero or less
    during the execution of mathematical operations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`对象将在执行数学运算期间自动删除零或更少的元素。'
- en: deque – the double ended queue
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: deque - 双端队列
- en: The `deque` (short for Double Ended Queue) object is one of the oldest collections.
    It was introduced in Python 2.4, so it has been available for over 10 years by
    now. Generally, this object will be too low-level for most purposes these days,
    as many operations that would otherwise use it have well-supported libraries available,
    but that doesn't make it less useful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`（双端队列）对象是最古老的集合之一。它是在Python 2.4中引入的，所以到目前为止已经有10多年的历史了。一般来说，这个对象对于大多数目的来说现在都太低级了，因为许多操作本来会使用它，现在有很好的支持库可用，但这并不使它变得不那么有用。'
- en: Internally, `deque` is created as a doubly linked list, which means that every
    item points to the next and the previous item. Since `deque` is double-ended,
    the list itself points to both the first and the last element. This makes both
    adding and removing items from either the beginning or the end a very light `O(1)`
    operation, since only the pointer to the beginning/end of the list needs to change
    and a pointer needs to be added to the first/last item, depending on whether an
    item is added at the beginning or the end.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`deque`被创建为一个双向链表，这意味着每个项目都指向下一个和上一个项目。由于`deque`是双端的，列表本身指向第一个和最后一个元素。这使得从列表的开头/结尾添加和删除项目都是非常轻松的`O(1)`操作，因为只需要改变指向列表开头/结尾的指针，并且需要添加指针到第一个/最后一个项目，具体取决于是在开头还是结尾添加项目。
- en: For simple stack/queue purposes, it seems wasteful to use a double-ended queue,
    but the performance is good enough for us not to care about the overhead incurred.
    The `deque` class is fully implemented in C (with CPython).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的堆栈/队列目的，使用双端队列似乎是浪费的，但性能足够好，我们不必担心产生的开销。`deque`类是完全在C中实现的（使用CPython）。
- en: 'Its usage as a queue is very straightforward:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为队列的使用非常简单：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, the items are followed by an `IndexError` since there are only
    two items and we are trying to get three.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于只有两个项目，我们尝试获取三个项目，所以会出现`IndexError`。
- en: 'The usage as a stack is almost identical, but we have to use `pop` instead
    of `popleft` (or `appendleft` instead of `append`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为堆栈的使用几乎相同，但我们必须使用`pop`而不是`popleft`（或者使用`appendleft`而不是`append`）：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another very useful feature is that `deque` can be used as a circular queue
    with the `maxlen` parameter. By using this, it can be used to keep the last `n`
    status messages or something similar:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是`deque`可以使用`maxlen`参数作为循环队列。通过使用这个参数，它可以用来保留最后的`n`个状态消息或类似的东西：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever you require a queue or stack class within a single-threaded application,
    `deque` is a very convenient option. If you require the object to be synchronized
    for multithreading operations, then the `queue.Queue` class would be better suited.
    Internally, it wraps `deque`, but it's a thread-safe alternative. In the same
    category, there is also an `asyncio.Queue` for asynchronous operations and `multiprocessing.Queue`
    for multiprocessing operations. Examples of `asyncio` and multiprocessing can
    be found in [Chapter 7](ch07.html "Chapter 7. Async IO – Multithreading without
    Threads"), *Async IO – Multithreading without Threads* and [Chapter 13](ch13.html
    "Chapter 13. Multiprocessing – When a Single CPU Core Is Not Enough"), *Multiprocessing
    – When a Single CPU Core Is Not Enough* respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您需要单线程应用程序中的队列或堆栈类时，`deque`是一个非常方便的选择。如果您需要将对象同步到多线程操作，则`queue.Queue`类更适合。在内部，它包装了`deque`，但它是一个线程安全的替代方案。在同一类别中，还有一个用于异步操作的`asyncio.Queue`和一个用于多进程操作的`multiprocessing.Queue`。`asyncio`和多进程的示例分别可以在[第7章](ch07.html
    "第7章。无线程的异步IO - 无线程的多线程")和[第13章](ch13.html "第13章。多进程 - 当单个CPU核心不够用时")中找到。
- en: defaultdict – dictionary with a default value
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defaultdict - 具有默认值的字典
- en: The `defaultdict` is by far my favorite object in the collections package. I
    still remember writing my own versions of it before it was added to the core.
    While it's a fairly simple object, it is extremely useful for all sorts of design
    patterns. Instead of having to check for the existence of a key and adding a value
    every time, you can just declare the default from the beginning, and there is
    no need to worry about the rest.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`绝对是我在collections包中最喜欢的对象。我仍然记得在它被添加到核心之前写过自己的版本。虽然它是一个相当简单的对象，但它对各种设计模式非常有用。您只需从一开始声明默认值，而不必每次都检查键的存在并添加值，这使得它非常有用。'
- en: For example, let's say we are building a very basic graph structure from a list
    of connected nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在从连接的节点列表构建一个非常基本的图结构。
- en: 'This is our list of connected nodes (one way):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的连接节点列表（单向）：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s put this graph into a normal dictionary:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这个图放入一个普通的字典中：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some variations are possible, of course, using `setdefault` for example. But
    they remain more complex than they need to be.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些变化，例如使用`setdefault`。但它们比必要的复杂。
- en: 'The truly Pythonic version uses `defaultdict` instead:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的Python版本使用`defaultdict`代替：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Isn''t that a beautiful bit of code? The `defaultdict` can actually be seen
    as the precursor of the `counter` object. It''s not as fancy and doesn''t have
    all the bells and whistles that `counter` has, but it does the job in many cases:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段美妙的代码吗？`defaultdict`实际上可以被看作是`counter`对象的前身。它没有`counter`那么花哨，也没有所有`counter`的功能，但在许多情况下它可以胜任：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The default value for `defaultdict` needs to be a callable object. In the previous
    cases, these were `int` and `list`, but you can easily define your own functions
    to use as a default value. That's what the following example uses, although I
    won't recommend production usage since it lacks a bit of readability. I do believe,
    however, that it is a beautiful example of the power of Python.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`的默认值需要是一个可调用对象。在前面的例子中，这些是`int`和`list`，但您可以轻松地定义自己的函数来用作默认值。下面的例子就是这样做的，尽管我不建议在生产中使用，因为它缺乏一些可读性。然而，我相信这是Python强大之处的一个美好例子。'
- en: 'This is how we create a `tree` in a single line of Python:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在一行Python中创建一个`tree`：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Brilliant, isn''t it? Here''s how we can actually use it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？这是我们实际上如何使用它的方式：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The nice thing is that you can make it go as deep as you'd like. Because of
    the `defaultdict` base, it generates itself recursively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个好处是你可以让它变得更深。由于`defaultdict`的基础，它会递归生成自己。
- en: namedtuple – tuples with field names
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: namedtuple - 带有字段名称的元组
- en: 'The `namedtuple` object is exactly what the name implies—a tuple with a name.
    It has a few useful use cases, though I must admit that I haven''t found too many
    in the wild, except for some Python modules such as inspect and `urllib.parse`.
    Points in 2D or 3D space are a nice example of where it is definitely useful:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`对象确实就像名字暗示的那样 - 一个带有名称的元组。它有一些有用的用例，尽管我必须承认我在实际中并没有找到太多用例，除了一些Python模块，比如inspect和`urllib.parse`。2D或3D空间中的点是它明显有用的一个很好的例子：'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Not too much can be said about `namedtuple`; it does what you would expect,
    and the greatest advantage is that the properties can be executed both by name
    and by index, which makes tuple unpacking quite easy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`namedtuple`，并没有太多可以说的；它做你期望的事情，最大的优势是属性可以通过名称和索引执行，这使得元组解包非常容易：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: enum – a group of constants
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: enum - 一组常量
- en: 'The `enum` package is quite similar to `namedtuple` but has a completely different
    goal and interface. The basic `enum` object makes it really easy to have constants
    in your modules while still avoiding magic numbers. This is a basic example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`包与`namedtuple`非常相似，但目标和接口完全不同。基本的`enum`对象使得在模块中拥有常量变得非常容易，同时避免了魔术数字。这是一个基本的例子：'
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A few of the handy features of the `enum` package are that the objects are iterable,
    accessible through both numeric and textual representation of the values, and,
    with proper inheritance, even comparable to other classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`包的一些方便功能是，对象是可迭代的，可以通过值的数字和文本表示进行访问，并且，通过适当的继承，甚至可以与其他类进行比较。'
- en: 'The following code shows the usage of a basic API:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了基本API的使用：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is more though. One of the lesser known possibilities from the `enum`
    package is that you can make value comparisons work through inheritance of specific
    types, and this works for every type—not just integers but (your own) custom types
    as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。`enum`包中较少为人知的可能性之一是，你可以通过特定类型的继承使值比较起作用，这对于任何类型都有效，不仅仅是整数，还包括（你自己的）自定义类型。
- en: 'This is the regular `enum`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是常规的`enum`：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is `enum` with `str` inheritance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有`str`继承的`enum`：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: OrderedDict – a dictionary where the insertion order matters
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrderedDict - 插入顺序很重要的字典
- en: '`OrderdDict` is a `dict` that keeps track of the order in which the items were
    inserted. Whereas a normal `dict` will return your keys in the order of hash,
    `OrderedDict` will return your keys by the order of insertion. So, it''s not ordered
    by key or value, but that is easily possible too:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderdDict`是一个跟踪插入顺序的`dict`。而普通的`dict`会按照哈希的顺序返回键，`OrderedDict`会按照插入的顺序返回键。所以，它不是按键或值排序的，但这也很容易实现：'
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While you can probably guess how this works, the internals might surprise you
    a little. I know I was expecting a different implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能猜到了它是如何工作的，但内部可能会让你有点惊讶。我知道我原本期望的实现方式是不同的。
- en: Internally, `OrderedDict` uses a normal `dict` for key/value storage, and in
    addition to that, it uses a doubly linked list to keep track of the next/previous
    items. To keep track of the reverse relation (from the doubly linked list back
    to the keys), there is an extra `dict` stored internally.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`OrderedDict`使用普通的`dict`来存储键/值，并且除此之外，它还使用一个双向链表来跟踪下一个/上一个项目。为了跟踪反向关系（从双向链表返回到键），还有一个额外的`dict`存储在内部。
- en: Put simply, `OrderedDict` can be a very handy tool for keeping your `dict` sorted,
    but it does come at a cost. The system is structured in such a way that `set`
    and `get` are really fast `O(1)`, but the object is still a lot heavier (double
    or more memory usage) when compared to a regular `dict`. In many cases, the memory
    usage of the objects inside will outweigh the memory usage of the `dict` itself,
    of course, but this is something to keep in mind.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`OrderedDict`可以是一个非常方便的工具，用来保持你的`dict`排序，但它是有代价的。这个系统的结构使得`set`和`get`非常快速（O(1)），但是与普通的`dict`相比，这个对象仍然更加沉重（内存使用量增加一倍或更多）。当然，在许多情况下，内部对象的内存使用量将超过`dict`本身的内存使用量，但这是需要记住的一点。
- en: heapq – the ordered list
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: heapq - 有序列表
- en: The `heapq` module is a great little module that makes it very easy to create
    a priority queue in Python. A structure that will always make the smallest (or
    largest, depending on the implementation) item available with minimum effort.
    The API is quite simple, and one of the best examples of its usage can be seen
    in the `OrderedDict` object. You probably don't want to use `heapq` directly,
    but understanding the inner workings is important in order to analyze how classes
    such as `OrderedDict` work.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq`模块是一个非常好的小模块，它可以非常容易地在Python中创建一个优先队列。这种结构总是可以在最小的（或最大的，取决于实现）项目上进行最小的努力。API非常简单，它的使用最好的例子之一可以在`OrderedDict`对象中看到。你可能不想直接使用`heapq`，但了解内部工作原理对于分析诸如`OrderedDict`之类的类是很重要的。'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are looking for a structure to keep your list always sorted, try the
    `bisect` module instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个结构来保持你的列表始终排序，可以尝试使用`bisect`模块。
- en: 'The basic usage is quite simple though:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用法非常简单：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One important thing to note here—something that you have probably already understood
    from the preceding example—is that the `heapq` module does not create a special
    object. It is simply a bunch of methods for treating a regular list as a `heap`.
    That doesn''t make it less useful, but it is something to take into consideration.
    You may also wonder why the `heap` isn''t sorted. Actually, it is sorted but not
    the way you expect it to be. If you view the `heap` as a tree, it becomes much
    more obvious:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件重要的事情需要注意 - 你可能已经从前面的例子中理解了 - `heapq`模块并不创建一个特殊的对象。它只是一堆方法，用于将常规列表视为`heap`。这并不使它变得不那么有用，但这是需要考虑的一点。你可能也会想为什么`heap`没有排序。实际上，它是排序的，但不是你期望的方式。如果你将`heap`视为一棵树，它就会变得更加明显：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The smallest number is always at the top and the biggest numbers are always
    at the bottom of the tree. Because of that, it's really easy to find the smallest
    number, but finding the largest is not so easy. To get the sorted version of the
    heap, we simply need to keep removing the top of the tree until all items are
    gone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的数字总是在顶部，最大的数字总是在树的底部。因此，找到最小的数字非常容易，但找到最大的数字就不那么容易了。要获得堆的排序版本，我们只需要不断地删除树的顶部，直到所有项目都消失。
- en: bisect – the sorted list
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bisect - 排序列表
- en: We have seen the `heapq` module in the previous paragraph, which makes it really
    simple to always get the smallest number from a list, and therefore makes it easy
    to sort a list of objects. While the `heapq` module appends items to form a tree-like
    structure, the `bisect` module inserts items in such a way that they stay sorted.
    A big difference is that adding/removing items with the `heapq` module is very
    light whereas finding items is really light with the `bisect` module. If your
    primary purpose is searching, then `bisect` should be your choice.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一段中看到了`heapq`模块，它使得从列表中始终获取最小的数字变得非常简单，因此也很容易对对象列表进行排序。`heapq`模块将项目附加到形成类似树的结构，而`bisect`模块以使它们保持排序的方式插入项目。一个很大的区别是，使用`heapq`模块添加/删除项目非常轻便，而使用`bisect`模块查找项目非常轻便。如果您的主要目的是搜索，那么`bisect`应该是您的选择。
- en: As is the case with `heapq`, `bisect` does not really create a special data
    structure. It just works on a standard `list` and expects that `list` to always
    be sorted. It is important to understand the performance implications of this;
    simply adding items to the list using the `bisect` algorithm can be very slow
    because an insert on a list takes `O(n)`. Effectively, creating a sorted list
    using bisect takes `O(n*n)`, which is quite slow, especially because creating
    the same sorted list using `heapq` or sorted takes `O(n * log(n))` instead.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与`heapq`一样，`bisect`并不真正创建一个特殊的数据结构。它只是在一个标准的`list`上操作，并期望该`list`始终保持排序。重要的是要理解这一点的性能影响；仅仅使用`bisect`算法向列表添加项目可能会非常慢，因为在列表上插入需要`O(n)`的时间。实际上，使用bisect创建一个排序列表需要`O(n*n)`的时间，这相当慢，特别是因为使用`heapq`或sorted创建相同的排序列表只需要`O(n
    * log(n))`的时间。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `log(n)` refers to the base 2 logarithm function. To calculate this value,
    the `math.log2()` function can be used. This results in an increase of 1 every
    time the number doubles in size. For `n=2`, the value of `log(n)` is `1`, and
    consequently for `n=4` and `n=8`, the log values are `2` and `3`, respectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`log(n)`是指以2为底的对数函数。要计算这个值，可以使用`math.log2()`函数。这意味着每当数字的大小加倍时，值就会增加1。对于`n=2`，`log(n)`的值为`1`，因此对于`n=4`和`n=8`，对数值分别为`2`和`3`。'
- en: This means that a 32-bit number, which is `2**32 = 4294967296`, has a log of
    `32`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着32位数字，即`2**32 = 4294967296`，具有`32`的对数。
- en: If you have a sorted structure and you only need to add a single item, then
    the `bisect` algorithm can be used for insertion. Otherwise, it's generally faster
    to simply append the items and call a `.sort()` afterwards.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个排序的结构，并且只需要添加一个单个项目，那么可以使用`bisect`算法进行插入。否则，通常更快的方法是简单地附加项目，然后调用`.sort()`。
- en: 'To illustrate, we have these lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们有这些行：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For a small number of items, the difference is negligible, but it quickly grows
    to a point where the difference will be large. For `n=4`, the difference is just
    between `4 * 1 + 8 = 12` and `1 + 2 + 3 + 4 = 10` making the bisect solution faster.
    But if we were to insert 1,000 items, it would be `1000 + 1000 * log(1000) = 10966`
    versus `1 + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500`. So, be very careful
    while inserting many items.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少量项目，差异是可以忽略的，但它很快就会增长到一个差异很大的程度。对于`n=4`，差异只是`4 * 1 + 8 = 12`和`1 + 2 + 3 +
    4 = 10`之间，使得bisect解决方案更快。但是，如果我们要插入1,000个项目，那么结果将是`1000 + 1000 * log(1000) = 10966`与`1
    + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500`。因此，在插入许多项目时要非常小心。
- en: Searching within the list is very fast though; because it is sorted, we can
    use a very simple binary search algorithm. For example, what if we want to check
    whether a few numbers exist within the list?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在列表中进行搜索非常快；因为它是排序的，我们可以使用一个非常简单的二分搜索算法。例如，如果我们想要检查列表中是否存在一些数字呢？
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the `bisect_left` function finds the position at which the number
    is supposed to be. This is actually what the `insort` function does as well; it
    inserts the number at the correct position by searching for the location of the
    number.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`bisect_left`函数找到了数字应该在的位置。这实际上也是`insort`函数所做的；它通过搜索数字的位置来将数字插入到正确的位置。
- en: 'So how is this different from a regular value in `sorted_list`? The biggest
    difference is that `bisect` does a binary search internally, which means that
    it starts in the middle and jumps left or right depending on whether the value
    is bigger or smaller than the value. To illustrate, we will search for `4` in
    a list of numbers from `0` to `14`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这与`sorted_list`中的常规值有什么不同呢？最大的区别在于`bisect`在内部执行二分搜索，这意味着它从中间开始，根据值是大还是小而向左或向右跳转。为了说明，我们将在从`0`到`14`的数字列表中搜索`4`：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, after only four steps (actually three; the fourth is just for
    illustration), we have found the number we searched for. Depending on the number
    (`7`, for example), it may go faster, but it will never take more than `O(log(n))`
    steps to find a number.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，经过仅四步（实际上是三步；第四步只是为了说明），我们已经找到了我们搜索的数字。根据数字（例如`7`），可能会更快，但是找到一个数字永远不会超过`O(log(n))`步。
- en: With a regular list, a search would simply walk through all items until it finds
    the desired item. If you're lucky, it could be the first number you encounter,
    but if you're unlucky, it could be the last item. In the case of 1,000 items,
    that would be the difference between 1,000 steps and `log(1000) = 10` steps.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规列表，搜索将简单地遍历所有项目，直到找到所需的项目。如果你幸运的话，它可能是你遇到的第一个数字，但如果你不幸的话，它可能是最后一个项目。对于1,000个项目来说，这将是1000步和`log(1000)
    = 10`步之间的差异。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Python has quite a few very useful collections built in. Since more and more
    collections are added regularly, the best thing to do is simply keep track of
    the collections manual. And do you ever wonder how or why any of the structures
    works? Just look at the source here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置了一些非常有用的集合。由于越来越多的集合定期添加，最好的做法就是简单地跟踪集合手册。你是否曾经想过任何结构是如何工作的，或者为什么会这样？只需在这里查看源代码：
- en: '[https://hg.python.org/cpython/file/default/Lib/collections/__init__.py](https://hg.python.org/cpython/file/default/Lib/collections/__init__.py)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hg.python.org/cpython/file/default/Lib/collections/__init__.py](https://hg.python.org/cpython/file/default/Lib/collections/__init__.py)'
- en: After finishing this chapter, you should be aware of both the core collections
    and the most important collections from the collections module, but more importantly
    the performance characteristics of these collections in several scenarios. Selecting
    the correct data structure within your applications is by far the most important
    performance factor that your code will ever experience, making this essential
    knowledge for any programmer.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该了解核心集合和集合模块中最重要的集合，更重要的是这些集合在几种情景下的性能特征。在应用程序中选择正确的数据结构是你的代码将经历的最重要的性能因素，这对于任何程序员来说都是必不可少的知识。
- en: Next, we will continue with functional programming which covers `lambda` functions,
    `list` comprehensions, `dict` comprehensions, `set` comprehensions and an array
    of related topics. This includes some background information on the mathematics
    involved which could be interesting but can safely be skipped.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论函数式编程，其中包括`lambda`函数、`list`推导、`dict`推导、`set`推导以及一系列相关主题。这包括一些涉及的数学背景信息，可能会很有趣，但可以安全地跳过。
