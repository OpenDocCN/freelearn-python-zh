- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Low-Level Network Device Interactions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级网络设备交互
- en: In *Ch**apter 1*, *Review of TCP/IP Protocol Suite and Python*, we looked at
    the theories and specifications behind network communication protocols. We also
    took a quick tour of the Python language. In this chapter, we will start to dive
    deeper into the management of network devices using Python. In particular, we
    will examine the different ways in which we can use Python to programmatically
    communicate with legacy network routers and switches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们回顾了TCP/IP协议套件和Python，我们探讨了网络通信协议背后的理论和规范。我们还快速浏览了Python语言。在本章中，我们将开始深入探讨使用Python管理网络设备。特别是，我们将检查我们可以使用Python以编程方式与传统的网络路由器和交换机通信的不同方式。
- en: What do I mean by legacy network routers and switches? While it’s hard to imagine
    any networking device coming out today without an **application programming interface**
    (**API**) for programmatic communication, it is a known fact that many of the
    network devices deployed in previous years did not contain API interfaces. The
    intended method of management for those devices was through **command-line interfaces**
    (**CLIs**) using terminal programs, which were originally developed with a human
    engineer in mind. The management relied on the engineer’s interpretation of the
    data returned from the device for appropriate action. As one can imagine, as the
    number of network devices and the complexity of the network grew, it became increasingly
    difficult to manually manage them one by one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的传统网络路由器和交换机是什么意思？虽然现在很难想象一个没有用于程序化通信的**应用程序编程接口**（**API**）的网络设备，但众所周知，许多在几年前部署的网络设备并没有包含API接口。这些设备的预期管理方式是通过使用终端程序（这些程序最初是为人类工程师开发的）的**命令行界面**（**CLIs**）。管理依赖于工程师对设备返回数据的解释来采取适当的行动。正如可以想象的那样，随着网络设备和网络复杂性的增加，手动逐个管理它们变得越来越困难。
- en: Python has several great libraries and frameworks that can help with these tasks,
    such as Pexpect, Paramiko, Netmiko, NAPALM, and Nornir, amongst others. It is
    worth noting that there are several overlaps between these libraries in terms
    of code, dependencies, and the maintainers of the projects. For example, the Netmiko
    library was created by Kirk Byers in 2014 based on the Paramiko SSH library. Carl
    Montanari created the Scrapli library to take advantage of the latest Python 3
    asyncio concurrency features. In recent years, Kirk, Carl, David Barroso from
    the NAPALM project, and others teamed up to create the awesome Nornir framework
    to provide a pure Python network automation framework.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个非常棒的库和框架可以帮助完成这些任务，例如Pexpect、Paramiko、Netmiko、NAPALM和Nornir等。值得注意的是，这些库在代码、依赖项和项目维护者方面存在一些重叠。例如，Netmiko库是由Kirk
    Byers在2014年基于Paramiko SSH库创建的。Carl Montanari创建了Scrapli库，以利用最新的Python 3 asyncio并发功能。近年来，Kirk、Carl、NAPALM项目的David
    Barroso以及其他一些人合作创建了令人惊叹的Nornir框架，以提供一个纯Python网络自动化框架。
- en: For the most part, the libraries are flexible enough to be used together or
    separately. For example, Ansible (covered in *Chapter 4*, *The Python Automation
    Framework – Ansible*) uses both Paramiko and Ansible-NAPALM as the underlying
    libraries for its network modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些库足够灵活，可以一起使用或单独使用。例如，Ansible（在第4章中介绍，*Python自动化框架 – Ansible*）使用Paramiko和Ansible-NAPALM作为其网络模块的底层库。
- en: 'With so many libraries in existence today, it’s not possible to cover all of
    them in a reasonable number of pages. In this chapter, we will cover Pexpect first,
    then move on with examples from Paramiko. Once we understand the basics and operations
    of Paramiko, it is easy to branch out to other libraries, such as Netmiko and
    NAPALM. In this chapter, we will take a look at the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在存在如此多的库，不可能在合理的页数内涵盖所有这些库。在本章中，我们将首先介绍Pexpect，然后通过Paramiko的示例继续。一旦我们了解了Paramiko的基本和操作，就很容易扩展到其他库，如Netmiko和NAPALM。在本章中，我们将探讨以下主题：
- en: The challenges of the CLI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面的挑战
- en: Constructing a virtual lab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建虚拟实验室
- en: The Python Pexpect library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Pexpect库
- en: The Python Paramiko library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Paramiko库
- en: Examples from other libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他库的示例
- en: The downsides of Pexpect and Paramiko
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pexpect和Paramiko的缺点
- en: We have briefly discussed the shortfalls of managing network devices via the
    command-line interface. It has proven to be ineffective in network management
    with even moderate-sized networks. This chapter will introduce Python libraries
    that can work with that limitation. First, let us discuss some of the challenges
    with the CLI in more detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了通过命令行界面管理网络设备的不足。这在管理中等规模的网络中已被证明是无效的。本章将介绍可以与这种限制一起工作的Python库。首先，让我们更详细地讨论一些CLI的挑战。
- en: The challenges of the CLI
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行的挑战
- en: I started my IT career at an ISP help desk back in the early 2000s. I remember
    watching the network engineers typing in what seemed like cryptic commands into
    a text terminal. Like magic, the network devices would then bend to their will
    and behave in the way they intended. In time, I got to learn and embrace these
    magic commands that I could type into the terminal. As network engineers, these
    CLI-based commands are like secret codes we share with each other in this world
    we call network engineering. Manually typing in the command was just something
    we all had to do to get the job done, no harm, no foul.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2000年代初在ISP帮助台开始了我的IT职业生涯。我记得看着网络工程师在文本终端中输入看似神秘的命令。就像魔法一样，网络设备就会按照他们的意愿弯曲，并以他们期望的方式表现。随着时间的推移，我学会了接受并拥抱这些我可以输入到终端中的魔法命令。作为网络工程师，这些基于CLI的命令就像我们在我们称之为网络工程的世界中相互分享的秘密代码。手动输入命令只是我们为了完成任务而必须做的事情，无伤大雅。
- en: However, it was right around the year 2014 when we started to see the industry
    coming to a consensus about the clear need to move away from manual, human-driven
    CLIs toward an automatic, computer-centric automation API. Make no mistake, we
    still need to directly communicate with the device when making network designs,
    bringing up an initial proof of concept, and deploying the topology for the first
    time. However, once the network is deployed, the network management requirement
    is now to consistently make the same changes reliably across all network devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正是在2014年左右，我们开始看到业界就明确需要从手动、以人为驱动的CLIs转向自动、以计算机为中心的自动化API达成共识。不要误解，我们在进行网络设计、提出初步的概念验证和首次部署拓扑结构时，仍然需要直接与设备进行通信。然而，一旦网络部署完成，网络管理的需求现在是一致地、可靠地在所有网络设备上做出相同的更改。
- en: These changes need to be error-free, and the engineers need to repeat the steps
    without being distracted or feeling tired. This requirement sounds like an ideal
    job for computers and our favorite programming language, Python.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改需要无错误，工程师需要重复步骤而不会被分心或感到疲倦。这种需求听起来像是计算机和我们所喜爱的编程语言Python的理想工作。
- en: Of course, if the network devices can only be managed with the command line,
    the main challenge becomes how we can replicate the previous manual interactions
    between the router and the administrator automatically with a computer program.
    In the command line, the router will output a series of information and will expect
    the administrator to enter a series of manual commands based on the engineer’s
    interpretation of the output. For example, in a Cisco **Internetwork Operating
    System** (**IOS**) device, you have to type in *enable* to get into a privileged
    mode, and upon receiving the returned prompt with the `#` sign, you then type
    in `configure terminal` in order to go into the configuration mode. The same process
    can further be expanded into the interface configuration mode and routing protocol
    configuration mode. This is in sharp contrast to a computer-driven, programmatic
    mindset. When the computer wants to accomplish a single task, say, put an IP address
    on an interface, it wants to structurally give all the information to the router
    at once, and it would expect a single *yes* or *no* answer from the router to
    indicate the success or failure of the task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果网络设备只能通过命令行进行管理，那么主要挑战就变成了我们如何能够通过计算机程序自动复制路由器和管理员之间的先前手动交互。在命令行中，路由器会输出一系列信息，并期望管理员根据工程师对输出的解释输入一系列手动命令。例如，在Cisco
    **Internetwork Operating System** (**IOS**) 设备中，你必须输入 *enable* 进入特权模式，在接收到带有 `#`
    符号的返回提示后，然后输入 `configure terminal` 以进入配置模式。同样的过程可以进一步扩展到接口配置模式和路由协议配置模式。这与计算机驱动的、程序化的思维方式形成鲜明对比。当计算机想要完成单个任务时，比如，在接口上放置IP地址，它希望一次性结构化地给出所有信息给路由器，并期望从路由器那里得到一个单一的
    *yes* 或 *no* 答案来指示任务的成败。
- en: The solution, as implemented by both Pexpect and Paramiko, is to treat the interactive
    process as a child process and watch over the interaction between the child process
    and the destination device. Based on the returned value, the parent process will
    decide the subsequent action, if any.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案，如Pexpect和Paramiko所实施的，是将交互过程视为子进程，并监控子进程与目标设备之间的交互。根据返回值，父进程将决定后续操作，如果有必要的话。
- en: I am sure we are all anxious to get started on using the Python libraries, but
    first, we will need to construct our network lab in order to have a network to
    test our code against. We will begin by looking at different ways we can build
    our network labs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们所有人都迫不及待地想要开始使用Python库，但首先，我们需要构建我们的网络实验室，以便有一个网络来测试我们的代码。我们将从探讨我们可以构建网络实验室的不同方式开始。
- en: Constructing a Virtual lab
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建虚拟实验室
- en: Before we dive into the Python libraries and frameworks, let’s examine the options
    of putting together a lab for the benefit of learning. As the old saying goes,
    “practice makes perfect” – we need an isolated sandbox to safely make mistakes,
    try out new ways of doing things, and repeat some of the steps to reinforce concepts
    that were not clear on the first try.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究Python库和框架之前，让我们先探讨一下构建实验室以供学习之用的选项。正如古老的谚语所说，“熟能生巧”——我们需要一个隔离的沙盒来安全地犯错，尝试新的做事方式，并重复一些步骤以强化第一次尝试中不清楚的概念。
- en: 'To put together a network lab, we basically have two options: physical devices
    or virtual devices. Let’s look at the advantages and disadvantages of the respective
    options.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个网络实验室，我们基本上有两种选择：物理设备或虚拟设备。让我们看看各自选项的优缺点。
- en: Physical devices
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理设备
- en: 'This option consists of putting together a lab with physical network devices
    that you can see and touch. If you are lucky enough, you might even be able to
    construct a lab that is an exact replication of your production environment. The
    advantages and disadvantages of a physical lab are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项包括使用您可以看到和触摸的物理网络设备来构建实验室。如果您足够幸运，甚至可能构建一个与您的生产环境完全相同的实验室。物理实验室的优缺点如下：
- en: '**Advantages**: It is an easy transition from lab to production. The topology
    is easier to understand for managers and fellow engineers who can look at and
    work on the devices if need be. The comfort level with physical devices is extremely
    high because of familiarity.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：从实验室到生产的过渡很容易。拓扑结构对于经理和需要查看和操作设备的工程师来说更容易理解。由于熟悉，对物理设备的舒适度极高。'
- en: '**Disadvantages**: It is relatively expensive to pay for devices that will
    only be used in a lab. Also, physical devices require engineering hours to rack
    and stack and are not very flexible once constructed.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：为仅用于实验室的设备付费相对较贵。此外，物理设备需要工程时间进行安装和堆叠，一旦构建完成，其灵活性就不高了。'
- en: Virtual devices
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟设备
- en: 'Virtual devices are emulations or simulations of actual network devices. They
    are either provided by the vendors or by the open source community. The advantages
    and disadvantages of virtual devices are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟设备是实际网络设备的仿真或模拟。它们可能由供应商或开源社区提供。虚拟设备的优缺点如下：
- en: '**Advantages**: Virtual devices are easier to set up, relatively cheap, and
    can make changes to the topology quickly.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：虚拟设备更容易设置，相对便宜，并且可以快速更改拓扑结构。'
- en: '**Disadvantages**: They are usually scaled-down versions of their physical
    counterparts. Sometimes there are feature gaps between the virtual and the physical
    device.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：它们通常是物理设备的缩小版。有时虚拟设备和物理设备之间存在功能差距。'
- en: Of course, deciding on a virtual or physical lab is a personal decision derived
    from a trade-off between the cost, ease of implementation, and the risk of having
    a gap between lab and production environments. In some of the places I have worked,
    the virtual lab was used when doing an initial proof-of-concept, while the physical
    lab was used when we moved closer to the final design.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，决定使用虚拟实验室还是物理实验室是一个个人决定，这是在成本、实施难度和实验室与生产环境之间差距的风险之间权衡的结果。在我工作的一些地方，虚拟实验室用于进行初步的概念验证，而物理实验室则用于我们接近最终设计时使用。
- en: In my opinion, as more and more vendors decide to produce virtual appliances,
    the virtual lab is the way to proceed in a learning environment. The feature gap
    of the virtual appliance is relatively small and specifically documented, especially
    when the virtual instance is provided by the vendor. The cost of the virtual appliance
    is relatively small compared to buying physical devices. The time to build using
    virtual devices is much shorter because they are just software programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，随着越来越多的厂商决定生产虚拟设备，虚拟实验室是在学习环境中前进的正确方式。虚拟设备的功能差距相对较小，并且有具体的文档记录，尤其是当虚拟实例由厂商提供时。与购买物理设备相比，虚拟设备的花费相对较小。使用虚拟设备构建所需的时间要短得多，因为它们只是软件程序。
- en: For this book, I will use a combination of physical and virtual devices for
    concept demonstration, with a preference for virtual devices. For the examples
    we will see, the differences should be transparent. If there are any known differences
    between the virtual and physical devices pertaining to our objectives, I will
    make sure to list them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我将使用物理设备和虚拟设备的组合来展示概念，更倾向于使用虚拟设备。对于我们将看到的示例，差异应该是透明的。如果虚拟设备和物理设备之间存在任何与我们的目标相关的已知差异，我将确保列出它们。
- en: For the code examples in the book, I will try to make the network topology as
    simple as possible while still being able to demonstrate the concept at hand.
    Each virtual network usually consists of not more than a few nodes, and we will
    reuse the same virtual network for multiple labs if possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于书中的代码示例，我将尝试使网络拓扑尽可能简单，同时仍然能够展示手头的概念。每个虚拟网络通常由不超过几个节点组成，如果可能的话，我们将重复使用相同的虚拟网络进行多个实验室。
- en: For the examples in this book, I will utilize Cisco Modeling Labs, [https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html](https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html),
    as well as other virtual platforms, such as Arista vEOS. As we will see in the
    next section, Cisco provides CML in both a paid version and a free, hosted version
    on Cisco DevNet ([https://developer.cisco.com/site/devnet/](https://developer.cisco.com/site/devnet/))
    based on availability. The use of CML is optional. You can use any lab devices
    you have, but it might make it easier to follow along with the book examples.
    Also worth noting is that Cisco has strict software license requirements for device
    images, so by purchasing or using the free hosted CML, you will be less likely
    to violate their software license requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的示例，我将使用思科建模实验室，[https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html](https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html)，以及其他虚拟平台，例如Arista
    vEOS。正如我们将在下一节中看到的，思科根据可用性提供付费版本的CML和免费托管版本的CML在Cisco DevNet ([https://developer.cisco.com/site/devnet/](https://developer.cisco.com/site/devnet/))。使用CML是可选的。您可以使用您拥有的任何实验室设备，但这可能有助于您更好地跟随书中的示例。还值得注意的是，思科对设备镜像有严格的软件许可要求，因此通过购买或使用免费托管的CML，您不太可能违反他们的软件许可要求。
- en: Cisco modeling labs
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思科建模实验室
- en: I remember when I first started to study for my **Cisco Certified Internetwork
    Expert** (**CCIE**) lab exam, I purchased some used Cisco equipment from eBay
    to study with. Even with a used equipment discount, each router and switch still
    cost hundreds of US dollars. To save money, I purchased some really outdated Cisco
    routers from the 1980s (search for Cisco AGS routers in your favorite search engine
    for a good chuckle), which significantly lacked features and horsepower, even
    for lab standards. As much as it made for an interesting conversation with family
    members when I turned them on (they were really loud), putting the physical devices
    together was not fun. They were heavy and clunky, and it was a pain to connect
    all the cables, and to introduce link failure, I would literally have to unplug
    a cable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得当我第一次开始为我的**思科认证网络专家**（**CCIE**）实验室考试做准备时，我从eBay上购买了一些二手的思科设备来学习。即使有二手设备的折扣，每个路由器和交换机仍然要花费数百美元。为了省钱，我购买了一些20世纪80年代的过时思科路由器（在您最喜欢的搜索引擎中搜索Cisco
    AGS路由器，会有很多好笑的内容），它们在实验室标准下功能严重不足。尽管当我打开它们时与家人聊天很有趣（它们真的很响），但组装物理设备并不好玩。它们又重又笨拙，连接所有电缆都很痛苦，为了引入链路故障，我实际上必须拔掉一根电缆。
- en: Fast-forward a few years. Dynamips was created, and I fell in love with how
    easy it was to create different network scenarios. This was especially important
    when trying to learn a new concept. All I needed was the IOS images from Cisco
    and a few carefully constructed topology files, and I could easily build a virtual
    network to test my knowledge on. I had a whole folder of network topologies, pre-saved
    configurations, and different versions of images, as called for by different scenarios.
    The addition of a GNS3 frontend gave the whole setup a beautiful GUI facelift.
    With GNS3, you can just click and drop your links and devices; you can even print
    out the network topology for your manager or client right out of the GNS3 design
    panel. The only disadvantage of GNS3 was the tool not being officially blessed
    by Cisco, and the perceived lack of credibility because of it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 快进几年。Dynamips被创建出来，我爱上了创建不同网络场景的简便性。这在尝试学习新概念时尤为重要。我所需要的只是思科的IOS镜像和一些精心构建的拓扑文件，我就能轻松构建一个虚拟网络来测试我的知识。我有一个包含网络拓扑、预先保存的配置和不同场景所需的不同版本镜像的整个文件夹。添加GNS3前端为整个设置提供了一个漂亮的GUI界面升级。使用GNS3，你可以直接点击并拖动你的链接和设备；你甚至可以直接从GNS3设计面板打印出网络拓扑图给你的经理或客户。GNS3的唯一缺点是工具没有得到思科的官方认可，因此它被认为缺乏可信度。
- en: In 2015, the Cisco community decided to fulfill this need by releasing the Cisco
    **Virtual Internet Routing Lab** (**VIRL**), [https://learningnetwork.cisco.com/s/virl](https://learningnetwork.cisco.com/s/virl).
    This quickly became my go-to tool as the network lab when developing, learning,
    and practicing network automation code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，思科社区决定通过发布思科的**虚拟互联网路由实验室**（**VIRL**），[https://learningnetwork.cisco.com/s/virl](https://learningnetwork.cisco.com/s/virl)来满足这一需求。这很快成为我在开发、学习和实践网络自动化代码时的首选工具。
- en: A few years after the introduction of VIRL, Cisco released **Cisco Modeling
    Labs** (**CML**), [https://developer.cisco.com/modeling-labs/](https://developer.cisco.com/modeling-labs/).
    It is a great network simulation platform with an easy-to-use HTML UI and a comprehensive
    API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在VIRL推出几年后，思科发布了**Cisco Modeling Labs**（**CML**），[https://developer.cisco.com/modeling-labs/](https://developer.cisco.com/modeling-labs/)。这是一个功能强大的网络仿真平台，拥有易于使用的HTML用户界面和全面的API。
- en: 'At the time of writing, the single-user license for CML is 199 USD (keep in
    mind that there is a free, hosted version on Cisco DevNet). In my opinion, the
    CML platform offers a few advantages over other alternatives and the cost is a
    bargain:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，CML的单用户许可证价格为199美元（请注意，在思科DevNet上有一个免费的托管版本）。在我看来，CML平台与其他替代方案相比提供了一些优势，而且价格非常划算：
- en: '**Ease of use**: As mentioned, all the images for IOSv, IOS-XRv, NX-OSv, ASAv,
    and other images are included in a single download.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：如前所述，所有IOSv、IOS-XRv、NX-OSv、ASAv和其他镜像的图像都包含在一个单独的下载中。'
- en: '**Official**: CML is a widely used tool internally at Cisco and within the
    network engineering community. In fact, CML is used extensively for the new Cisco
    DevNet Expert Lab exam. Because of its popularity, bugs get fixed quickly, new
    features are carefully documented, and useful knowledge is widely shared among
    its users.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方**：CML是思科内部和网络工程社区广泛使用的工具。事实上，CML被广泛用于新的思科DevNet专家实验室考试。由于其受欢迎程度，错误得到快速修复，新功能得到仔细记录，有用知识在用户之间广泛共享。'
- en: '**Third-party KVM images integration**: CML permits users to upload third-party
    VM images, such as Windows VM, that are not bundled by default.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方KVM镜像集成**：CML允许用户上传默认未捆绑的第三方虚拟机镜像，例如Windows虚拟机。'
- en: '**Others**: The CML tool offers many other features, such as dashboard list
    view, multiuser grouping, Ansible integration, and pyATS integration.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他功能**：CML工具还提供了许多其他功能，例如仪表板列表视图、多用户分组、Ansible集成和pyATS集成。'
- en: We will not use all of the CML features in this book, but it is nice to know
    the tool is so feature-rich and is constantly being updated. Again, I want to
    stress the importance of having a lab to follow along for the book examples but
    it does not need to be Cisco CML. The code examples provided in this book should
    work across any lab device, as long as it runs the same software type and version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中不会使用所有CML功能，但知道这个工具功能丰富且不断更新是很令人高兴的。再次强调，对于本书中的示例，拥有一个实验室来跟随是很重要的，但它不需要是思科CML。本书中提供的代码示例应该适用于任何实验室设备，只要它运行相同的软件类型和版本。
- en: CML tips
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CML技巧
- en: 'The CML website ([https://developer.cisco.com/modeling-labs/](https://developer.cisco.com/modeling-labs/))
    and documentation ([https://developer.cisco.com/docs/modeling-labs/](https://developer.cisco.com/docs/modeling-labs/))
    offer lots of guidance and information, from installation to usage. The lab topology
    will be included in the respective chapters in the book’s GitHub repository ([https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition](https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition)).
    The lab images can be directly imported to the lab via the **Import** button:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CML网站（[https://developer.cisco.com/modeling-labs/](https://developer.cisco.com/modeling-labs/））和文档（[https://developer.cisco.com/docs/modeling-labs/](https://developer.cisco.com/docs/modeling-labs/））提供了从安装到使用的许多指导和信息。实验室拓扑将包含在书籍GitHub仓库的相关章节中（[https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition](https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition)）。实验室镜像可以直接通过**导入**按钮导入到实验室中：
- en: '![](img/B18403_02_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述自动生成](img/B18403_02_01.png)'
- en: 'Figure 2.1: CML Console Image Lab Image'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：CML控制台镜像实验室镜像
- en: 'For the labs, each of the devices will have its management interface connected
    to an unmanaged switch, which in turn connects to an external connection for access:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实验室，每个设备的管理接口都将连接到一个无管理交换机，该交换机再连接到外部连接以供访问：
- en: '![](img/B18403_02_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述自动生成](img/B18403_02_02.png)'
- en: 'Figure 2.2: Unmanaged Switch for Management Interface Access'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：用于管理接口访问的无管理交换机
- en: You will need to change the IP address of the management interface to fit your
    own lab’s schema. For example, in the `2_DC_Topology.yaml` file in *Chapter 2*,
    the IP address of `lax-edg-r1 GigabitEthernet0/0 0` is `192.168.2.51`. You will
    need to change this IP address according to your own lab.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更改管理接口的IP地址以适应你自己的实验室架构。例如，在*第2章*的`2_DC_Topology.yaml`文件中，`lax-edg-r1 GigabitEthernet0/0
    0`的IP地址是`192.168.2.51`。你需要根据你自己的实验室更改这个IP地址。
- en: 'If you are using virtual lab software other than CML, you can open the topology
    file with any text editor (such as Sublime Text, shown below) and see each of
    the devices’ configurations. You can then copy and paste the configuration into
    your own lab devices:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是除CML之外的虚拟实验室软件，你可以用任何文本编辑器（例如下面的Sublime Text）打开拓扑文件，并查看每个设备的配置。然后你可以将配置复制并粘贴到自己的实验室设备中：
- en: '![Text  Description automatically generated](img/B18403_02_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18403_02_03.png)'
- en: 'Figure 2.3: Topology File Viewed with Text Editor'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：使用文本编辑器查看的拓扑文件
- en: We talked about Cisco DevNet briefly earlier in this section. Let us explore
    more about DevNet in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节前面简要介绍了思科DevNet。让我们在下一节中更深入地探讨DevNet。
- en: Cisco DevNet
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思科DevNet
- en: Cisco DevNet ([https://developer.cisco.com/site/devnet/](https://developer.cisco.com/site/devnet/))
    is the premier, all-in-one website when it comes to network automation resources
    at Cisco. It is free to sign up and provides free remote labs, free video courses,
    guided learning tracks, documentation, and much more.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 思科DevNet（[https://developer.cisco.com/site/devnet/](https://developer.cisco.com/site/devnet/））是思科网络自动化资源的首选一站式网站。注册免费，并提供免费远程实验室、免费视频课程、指导学习路径、文档等。
- en: The Cisco DevNet Sandbox ([https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/))
    is a great alternative if you do not already have a lab at your own disposal or
    want to try out new technologies. Some of the labs are always on, while others
    you need to reserve. The lab availability will depend on usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有自己的实验室或者想要尝试新技术，思科DevNet沙盒（[https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/））是一个很好的替代方案。一些实验室总是可用，而其他则需要预订。实验室的可用性将取决于使用情况。
- en: '![Graphical user interface, website  Description automatically generated](img/B18403_02_04.png)Figure
    2.4: Cisco DevNet Sandbox'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，网站描述自动生成](img/B18403_02_04.png)图2.4：思科DevNet沙盒'
- en: Since its inception, Cisco DevNet has become the de facto destination for all
    things related to network programmability and automation at Cisco. If you are
    interested in pursuing Cisco certifications in automation, DevNet offers different
    tracks from associate to expert level of validation; more information can be found
    at [https://developer.cisco.com/certification/](https://developer.cisco.com/certification/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 自从成立以来，思科DevNet已经成为思科网络可编程性和自动化相关事宜的事实上目的地。如果你对追求思科自动化认证感兴趣，DevNet提供了从助理到专家级别的不同验证路径；更多信息可以在[https://developer.cisco.com/certification/](https://developer.cisco.com/certification/)找到。
- en: GNS3 and others
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNS3和其他
- en: 'There are a few other virtual labs that I have used and would recommend. GNS3
    is one of them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我还使用过一些其他的虚拟实验室，并且会推荐它们。GNS3就是其中之一：
- en: '![Graphical user interface, website  Description automatically generated](img/B18403_02_05.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站描述自动生成](img/B18403_02_05.png)'
- en: 'Figure 2.5: GNS3 Website'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：GNS3网站
- en: As mentioned previously, GNS3 is what a lot of us use to study for certification
    tests and to practice for labs. The tool has really grown up from the early days
    of being the simple frontend for Dynamips into a viable commercial product. GNS3
    is vendor-neutral, which can be helpful if we want to build a multi-vendor lab.
    This is typically done either by making a clone of the image (such as Arista vEOS)
    or by directly launching the network device image via other hypervisors (such
    as KVM).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GNS3是我们许多人用来准备认证考试和练习实验室的工具。这个工具已经从最初作为Dynamips的简单前端发展到成为一个可行的商业产品。GNS3是供应商中立的，如果我们想建立一个多厂商实验室，这会很有帮助。这通常是通过克隆镜像（例如Arista
    vEOS）或通过其他虚拟机管理程序（例如KVM）直接启动网络设备镜像来完成。
- en: 'Another multi-vendor network emulation environment that has gotten a lot of
    great reviews is the **Emulated Virtual Environment Next Generation** (**Eve-NG**):
    [http://www.eve-ng.net/](http://www.eve-ng.net/). I personally do not have enough
    experience with the tool, but many of my colleagues and friends in the industry
    use it for their network labs. If you are familiar with containers, containerlab
    ([https://containerlab.dev/](https://containerlab.dev/)) can also be an alternative
    for you.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个获得许多好评的多厂商网络仿真环境是**仿真虚拟环境下一代**（**Eve-NG**）：[http://www.eve-ng.net/](http://www.eve-ng.net/)。我个人对这个工具的经验不足，但我的许多同行和行业内的朋友都使用它来建立他们的网络实验室。如果你熟悉容器，containerlab
    ([https://containerlab.dev/](https://containerlab.dev/))也可以作为你的一个替代选择。
- en: There are also other standalone virtualized platforms, such as Arista vEOS ([https://www.arista.com/en/cg-veos-router/veos-router-overview](https://www.arista.com/en/cg-veos-router/veos-router-overview)),
    Juniper vMX ([https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html](https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html)),
    and Nokia SR-Linux ([https://www.nokia.com/networks/data-center/service-router-linux-NOS/](https://www.nokia.com/networks/data-center/service-router-linux-NOS/)),
    which you can use as standalone virtual appliances during testing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些独立的虚拟化平台，例如Arista vEOS ([https://www.arista.com/en/cg-veos-router/veos-router-overview](https://www.arista.com/en/cg-veos-router/veos-router-overview))、Juniper
    vMX ([https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html](https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html))和Nokia
    SR-Linux ([https://www.nokia.com/networks/data-center/service-router-linux-NOS/](https://www.nokia.com/networks/data-center/service-router-linux-NOS/))，你可以在测试期间将它们用作独立的虚拟设备。
- en: They are great complementary tools for testing platform-specific features. Many
    of them are offered as paid products on public cloud provider marketplaces for
    easier access.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是测试特定平台功能的优秀补充工具。其中许多在公共云提供商市场上作为付费产品提供，以便更容易访问。
- en: Now that we have built our network lab, we can start to experiment with Python
    libraries that can help with management and automation. We will begin with enabling
    the Python virtual environment. Then we will install and use the Pexpect library
    for some examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了我们的网络实验室，我们可以开始尝试使用可以帮助管理和自动化的Python库。我们将从启用Python虚拟环境开始。然后我们将安装并使用Pexpect库进行一些示例。
- en: Python virtual environment
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python虚拟环境
- en: 'Let us start by using the Python virtual environment. The Python virtual environment
    allows us to manage separate package installations for different projects by creating
    a “virtual” isolated Python installation and installing packages into that virtual
    installation. By using a virtual environment, we do not need to worry about breaking
    the packages installed globally or from other virtual environments. We will start
    by installing the `python3.10-venv` package, then create the virtual environment
    itself:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Python虚拟环境。Python虚拟环境允许我们通过创建一个“虚拟”隔离的Python安装并在其中安装包来管理不同项目的独立包安装。通过使用虚拟环境，我们不需要担心破坏全局或来自其他虚拟环境的已安装包。我们将首先安装`python3.10-venv`包，然后创建虚拟环境本身：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the output, we saw that we use the `venv` module from our installation,
    create a virtual environment called “venv” and then activate it. While the virtual
    environment is activated, you will see the (`venv`) label in front of your hostname,
    indicating that you are in that virtual environment. When finished, you can use
    the `deactivate` command to exit the virtual environment. If interested, you can
    learn more about Python virtual environments here: [https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们看到我们使用了安装中的 `venv` 模块，创建了一个名为“venv”的虚拟环境，然后激活了它。当虚拟环境激活时，你将在主机名前看到（`venv`）标签，这表明你处于该虚拟环境中。完成工作后，你可以使用
    `deactivate` 命令退出虚拟环境。如果你感兴趣，可以在这里了解更多关于 Python 虚拟环境的信息：[https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv)。
- en: Always activate the virtual environment before you work on the code to isolate
    environments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写代码之前，始终要激活虚拟环境以隔离环境。
- en: Once we have activated the virtual environment, we can move on to install the
    Pexpect library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们激活了虚拟环境，我们就可以继续安装 Pexpect 库。
- en: Python pexpect library
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python pexpect 库
- en: 'Pexpect is a pure Python module for spawning child applications, controlling
    them, and responding to expected patterns in their output. Pexpect works like
    Don Libes’ `Expect`. Pexpect allows our script to spawn a child application and
    control it as if a human were typing commands; more information can be found on
    Pexpect’s documentation page: [https://pexpect.readthedocs.io/en/stable/index.html](https://pexpect.readthedocs.io/en/stable/index.html).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect 是一个用于派生子应用程序、控制它们并对它们输出中的预期模式做出响应的纯 Python 模块。Pexpect 的工作方式类似于 Don Libes
    的 `Expect`。Pexpect 允许我们的脚本派生一个子应用程序，并像人类输入命令一样控制它；更多详细信息可以在 Pexpect 的文档页面上找到：[https://pexpect.readthedocs.io/en/stable/index.html](https://pexpect.readthedocs.io/en/stable/index.html)。
- en: Nowadays, we typically use libraries, such as Nornir, that abstract this line-by-line,
    low-level interaction. However, it is still useful to understand the interaction
    at least at a high level. If you are the impatient kind, just skim through the
    following Pexpect and Paramiko sections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通常使用像 Nornir 这样的库来抽象逐行、低级别的交互。然而，至少在高级别上理解这种交互仍然是有用的。如果你是那种不耐烦的人，只需快速浏览以下
    Pexpect 和 Paramiko 部分。
- en: Similar to the original **Tool Command Language** (**TCL**) `Expect` module
    by Don Libes, Pexpect launches, or spawns, another process and watches over it
    in order to control the interaction. The Expect tool was originally developed
    to automate interactive processes such as FTP, Telnet, and rlogin, and was later
    expanded to include network automation. Unlike the original Expect, Pexpect is
    entirely written in Python, which does not require TCL or C extensions to be compiled.
    This allows us to use the familiar Python syntax and its rich standard library
    in our code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '与 Don Libes 的原始 **工具命令语言**（**TCL**）`Expect` 模块类似，Pexpect 启动或派生另一个进程，并监视它以控制交互。Expect
    工具最初是为了自动化交互式过程，如 FTP、Telnet 和 rlogin 而开发的，后来扩展到包括网络自动化。与原始 Expect 不同，Pexpect
    完全用 Python 编写，不需要编译 TCL 或 C 扩展。这使我们能够在代码中使用熟悉的 Python 语法及其丰富的标准库。 '
- en: Pexpect installation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pexpect 安装
- en: 'The Pexpect installation process is straightforward:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect 的安装过程很简单：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s do a quick test to make sure the package is usable; make sure we start
    the Python interactive shell from the virtual environment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速测试一下以确保包可用；确保我们从虚拟环境启动 Python 交互式外壳：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pexpect overview
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pexpect 概述
- en: 'For this chapter, we will use the `2_DC_Topology` and work on the two IOSv
    devices, **lax-edg-r1** and **lax-edg-r2**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用 `2_DC_Topology` 并在两个 IOSv 设备 **lax-edg-r1** 和 **lax-edg-r2** 上进行工作：
- en: '![Diagram  Description automatically generated](img/B18403_02_06.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B18403_02_06.png)'
- en: 'Figure 2.6: lax-edg-r1 and lax-edg-r2'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：lax-edg-r1 和 lax-edg-r2
- en: 'The devices will each have a management address in the `192.16.2.x/24` range.
    In the example, `lax-edg-r1` will have `192.168.2.51` and `lax-edg-r2` will have
    `192.168.2.52` as the management IP. If this is the first time the device is powered
    up, it will need to generate an RSA key for SSH:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都将有一个位于 `192.16.2.x/24` 范围内的管理地址。在示例中，`lax-edg-r1` 将有 `192.168.2.51`，而 `lax-edg-r2`
    将有 `192.168.2.52` 作为管理 IP。如果这是设备第一次开机，它将需要生成一个 RSA 密钥用于 SSH：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For older IOSv software images, we might also need to add the following lines
    to the `ssh` configuration `(~/.ssh/config)` depending on your platform:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的IOSv软件镜像，我们可能还需要根据您的平台在`ssh`配置（`~/.ssh/config`）中添加以下行：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the devices ready, let’s take a look at how you would interact with the
    router if you were to telnet into the device:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设备准备就绪后，让我们看看如果你通过telnet连接到设备，你会如何与之交互：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The device configuration uses the username of `cisco`, and the password is
    also `cisco`. Notice that the user is already in the privileged mode because of
    the privilege assigned in the configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设备配置使用用户名`cisco`，密码也是`cisco`。请注意，由于配置中分配的权限，用户已经处于特权模式：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The auto-config also generated `vty` access for both telnet and SSH:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自动配置还生成了telnet和SSH的`vty`访问权限：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s see a Pexpect example using the Python interactive shell:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用Python交互式外壳的Pexpect示例：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Starting from Pexpect version 4.0, you can run Pexpect on the Windows platform.
    But, as noted in the Pexpect documentation, running Pexpect on Windows should
    be considered experimental for now.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Pexpect版本4.0开始，你可以在Windows平台上运行Pexpect。但是，正如Pexpect文档中提到的，目前将Pexpect运行在Windows上应被视为实验性的。
- en: In the previous interactive example, Pexpect spawns off a child process and
    watches over it in an interactive fashion. There are two important methods shown
    in the example, `expect()` and `sendline()`. The `expect()` line indicates the
    string in the Pexpect process looks for when the returned string is considered
    done. This is the expected pattern. In our example, we knew the router had sent
    us all the information when the hostname prompt (`lax-edg-r1#)` was returned.
    The `sendline()` method indicates which words should be sent to the remote device
    as the command. There is also a method called `send()`, but `sendline()` includes
    a linefeed, which is similar to pressing the *Enter* key at the end of the words
    you sent in the previous telnet session. From the router’s perspective, it is
    just as if someone typed in the text from a Terminal. In other words, we are tricking
    the routers into thinking they are interfacing with a human being when they are
    actually communicating with a computer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的交互示例中，Pexpect启动了一个子进程，并以交互方式监视它。示例中展示了两个重要的方法，`expect()`和`sendline()`。`expect()`行表示Pexpect进程在返回字符串被认为是完成时寻找的字符串。这是预期模式。在我们的例子中，我们知道当返回主机名提示符（`lax-edg-r1#`）时，路由器已经向我们发送了所有信息。`sendline()`方法表示应该将哪些单词作为命令发送到远程设备。还有一个名为`send()`的方法，但`sendline()`包括一个换行符，这类似于在之前的telnet会话中发送的单词末尾按下*Enter*键。从路由器的角度来看，这就像有人从终端输入文本一样。换句话说，我们正在欺骗路由器，让它们认为它们在与人类交互，而实际上它们正在与计算机通信。
- en: 'The `before` and `after` properties will be set to the text printed by the
    child application. The `before` properties will be set to the text printed by
    the child application up to the expected pattern. The `after` string will contain
    the text that was matched by the expected pattern. In our case, the `before` text
    will be set to the output between the two expected matches (`lax-edg-r1#`), including
    the `show version` command. The `after` text is the router hostname prompt:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`和`after`属性将被设置为子应用程序打印的文本。`before`属性将被设置为子应用程序打印的文本，直到预期的模式。`after`字符串将包含由预期模式匹配的文本。在我们的例子中，`before`文本将被设置为两个预期匹配（`lax-edg-r1#`）之间的输出，包括`显示版本`命令。`after`文本是路由器的主机名提示符：'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are wondering about the `b'` in front of the return, it is a Python byte
    string ([https://docs.python.org/3.10/library/stdtypes.html](https://docs.python.org/3.10/library/stdtypes.html)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对返回值前面的`b'`感到好奇，它是一个Python字节字符串([https://docs.python.org/3.10/library/stdtypes.html](https://docs.python.org/3.10/library/stdtypes.html))。
- en: What would happen if you expected the wrong term? For example, if we typed in
    `username` with the lowercase “u” instead of `Username` after spawning the child
    application, the Pexpect process would look for a string of `username` from the
    child process. In that case, the Pexpect process would just hang because the word
    `username` would never be returned by the router. The session would eventually
    time out, or we could manually exit out via *Ctrl* + *C*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望错误的术语会发生什么？例如，如果我们输入了`username`而不是`Username`（在启动子应用程序后），Pexpect进程会在子进程中寻找`username`字符串。在这种情况下，Pexpect进程会直接挂起，因为路由器永远不会返回`username`这个词。会话最终会超时，或者我们可以通过*Ctrl*
    + *C*手动退出。
- en: 'The `expect()` method waits for the child application to return a given string,
    so in the previous example, if you wanted to accommodate both lowercase and uppercase
    `u`, you could use the following term:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect()`方法等待子应用返回一个给定的字符串，所以在前面的例子中，如果你想要适应小写和大写的`u`，你可以使用以下术语：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The square bracket serves as an `or` operation that tells the child application
    to expect a lowercase or uppercase “u” followed by `sername` as the string. What
    we are telling the process is that we will accept either `Username` or `username`
    as the expected string. For more information on these different types of matching
    using a regular expression, go to: [https://docs.python.org/3.10/library/re.html](https://docs.python.org/3.10/library/re.html).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号充当`or`操作符，告诉子应用期望一个小写或大写的“u”后跟`sername`作为字符串。我们告诉进程的是，我们将接受`Username`或`username`作为期望的字符串。有关使用正则表达式进行这些不同类型匹配的更多信息，请参阅：[https://docs.python.org/3.10/library/re.html](https://docs.python.org/3.10/library/re.html)。
- en: 'The `expect()` method can also contain a list of options instead of just a
    single string; these options can also be regular expressions themselves. Going
    back to the previous example, we can use the following list of options to accommodate
    the two different possible strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect()`方法也可以包含一个选项列表，而不仅仅是单个字符串；这些选项本身也可以是正则表达式。回到之前的例子，我们可以使用以下选项列表来适应两种可能的字符串：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Generally speaking, use the regular expression for a single `expect` string
    when we can fit the different letters in a regular expression, whereas use the
    possible options if we need to catch completely different responses from the device,
    such as a password rejection. For example, if we use several different passwords
    for our login, we want to catch `% Login invalid` as well as the device prompt.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，当我们能够将不同的字母组合成一个正则表达式时，使用单个`expect`字符串的正则表达式；而当我们需要捕获来自设备的完全不同的响应，例如密码拒绝时，则使用可能的选择。例如，如果我们为登录使用几个不同的密码，我们希望捕获`%
    Login invalid`以及设备的提示信息。
- en: One important difference between Pexpect regular expressions and Python regular
    expressions is that Pexpect matching is non-greedy, which means they will match
    as little as possible when using special characters. Because Pexpect performs
    regular expressions on a stream, it cannot look ahead, as the child process generating
    the stream may not be finished. This means the special dollar sign character `$`
    typically matching the end of the line is useless because `.+` will always return
    no characters, and the `.*` pattern will match as little as possible. In general,
    just keep this in mind and be as specific as you can be on the `expect` match
    strings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect正则表达式与Python正则表达式之间的重要区别在于，Pexpect匹配是非贪婪的，这意味着在使用特殊字符时，它们会尽可能少地匹配。因为Pexpect在流上执行正则表达式，它不能向前查看，因为生成流的子进程可能尚未完成。这意味着通常匹配行尾的特殊美元符号`$`是无用的，因为`.+`总是会返回没有字符，而`.*`模式会尽可能少地匹配。一般来说，只需记住这一点，并在`expect`匹配字符串上尽可能具体即可。
- en: 'Let’s consider the following scenario:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Hmm... Something is not quite right here. Compare it to the Terminal output
    before; the output you expect would be `hostname lax-edg-r1`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...这里似乎有点不对劲。与之前的终端输出比较；你期望的输出应该是`hostname lax-edg-r1`：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Taking a closer look at the expected string will reveal the mistake. In this
    case, we were missing the hash (`#`) sign behind the `lax-edg-r1` hostname. Therefore,
    the child application treated the second part of the return string as the expected
    string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看期望的字符串将揭示错误。在这种情况下，我们在`lax-edg-r1`主机名后面遗漏了井号`#`。因此，子应用将返回字符串的第二部分作为期望的字符串：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see a pattern emerging from the usage of Pexpect after a few examples.
    The user maps out the sequence of interactions between the Pexpect process and
    the child application. With some Python variables and loops, we can start to construct
    a useful program that will help us gather information and make changes to network
    devices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个示例之后，你可以从Pexpect的使用中看到一个模式的出现。用户绘制了Pexpect进程和子应用之间交互的序列。通过一些Python变量和循环，我们可以开始构建一个有用的程序，这将帮助我们收集信息并对网络设备进行更改。
- en: Our first Pexpect program
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个Pexpect程序
- en: 'Our first program, `chapter2_1.py`, extends what we did in the last section
    with some additional code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序`chapter2_1.py`，在上一节的基础上添加了一些额外的代码：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We used a nested dictionary in line 5:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第5行使用了一个嵌套字典：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The nested dictionary allows us to refer to the same device (such as `lax-edg-r1`)
    with the appropriate IP address and prompt symbol. We can then use those values
    for the `expect()` method later on in the loop.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字典允许我们使用适当的IP地址和提示符号来引用相同的设备（例如`lax-edg-r1`）。然后我们可以在循环的后续部分使用这些值进行`expect()`方法。
- en: 'The output prints out the `show version | i V` output on the screen for each
    of the devices:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会在屏幕上打印出每个设备的`show version | i V`输出：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have seen a basic example of Pexpect, let us go deeper into more
    features of the library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Pexpect的基本示例，让我们更深入地了解库的更多功能。
- en: More Pexpect Features
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多Pexpect功能
- en: In this section, we will look at more Pexpect features that might come in handy
    when certain situations arise.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨更多Pexpect功能，这些功能在某些情况下可能会很有用。
- en: 'If you have a slow or fast link to your remote device, the default `expect()`
    method timeout is 30 seconds, which can be increased or decreased via the `timeout`
    argument:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与远程设备之间的连接速度较慢或较快，默认的`expect()`方法超时时间为30秒，可以通过`timeout`参数增加或减少：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can choose to pass the command back to the user using the `interact()`
    method. This is useful when you just want to automate certain parts of the initial
    task:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用`interact()`方法将命令返回给用户。这在只想自动化初始任务的一部分时很有用：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can get a lot of information about the `child.spawn` object by printing
    it out in string format:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以字符串格式打印`child.spawn`对象来获取有关它的很多信息：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The most useful debug tool for Pexpect is to log the output in a file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Pexpect来说，最有用的调试工具是将输出记录到文件中：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For more information on Pexpect features, check out: [https://pexpect.readthedocs.io/en/stable/api/index.html](https://pexpect.readthedocs.io/en/stable/api/index.html)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Pexpect功能的信息，请查看：[https://pexpect.readthedocs.io/en/stable/api/index.html](https://pexpect.readthedocs.io/en/stable/api/index.html)
- en: We have been working with Telnet so far in our examples, which leaves our communication
    in clear text during the session. In modern networks, we typically use **secure
    shell** (**SSH**) for management. In the next section, we will take a look at
    Pexpect with SSH.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例中我们一直在使用Telnet，这使得在会话期间我们的通信是明文的。在现代网络中，我们通常使用**安全外壳**（**SSH**）进行管理。在下一节中，我们将探讨带有SSH的Pexpect。
- en: Pexpect and SSH
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pexpect和SSH
- en: 'Pexpect has a subclass called `pxssh`, which specializes in setting up SSH
    connections. The class adds methods for login, logout, and various tricky things
    to handle the different situations in the `ssh` login process. The procedures
    are mostly the same, with the exception of `login()` and `logout()`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect有一个名为`pxssh`的子类，它专门用于设置SSH连接。该类为登录、登出以及处理`ssh`登录过程中的不同情况添加了各种方法。程序流程基本上是相同的，除了`login()`和`logout()`：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the `auto_prompt_reset=False` argument in the `login()` method. By default,
    `pxssh` uses the shell prompt to synchronize the output. But since it uses the
    PS1 option for most of bash-shell or c-shell, they will error out on Cisco or
    other network devices.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`login()`方法中的`auto_prompt_reset=False`参数。默认情况下，`pxssh`使用shell提示来同步输出。但由于它主要用于bash-shell或c-shell的PS1选项，它们在Cisco或其他网络设备上将会出错。
- en: Pexpect complete example
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pexpect完整示例
- en: 'As the final step, let’s put everything you have learned so far about Pexpect
    into a script. Putting code into a script makes it easier to use in a production
    environment, as well as easier to share with your colleagues. We will write our
    second script, `chapter2_2.py`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们将到目前为止所学的所有关于Pexpect的知识放入一个脚本中。将代码放入脚本中使得在生产环境中使用它更加容易，同时也更容易与同事分享。我们将编写第二个脚本，`chapter2_2.py`：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The script further expands from our first Pexpect program with the following
    additional features:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本进一步扩展了我们的第一个Pexpect程序，并添加了以下附加功能：
- en: It uses SSH instead of Telnet.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用SSH而不是Telnet。
- en: It supports multiple commands instead of just one by making the commands into
    a list (line 8) and loops through the commands (starting at line 20).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将命令变成列表（第8行）并循环遍历命令（从第20行开始）来支持多个命令而不是一个。
- en: It prompts the user for their username and password instead of hardcoding them
    in the script for better security posture.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提示用户输入用户名和密码，而不是在脚本中硬编码它们，以提高安全性。
- en: It writes the output in two files, `lax-edg-r1_output.txt` and `lax-edg-r2_output.txt`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将输出写入两个文件，`lax-edg-r1_output.txt`和`lax-edg-r2_output.txt`。
- en: After the code is executed, we should see the two output files in the same directory.
    Besides Pexpect, Paramiko is another popular Python library used to handle interactive
    sessions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行后，我们应该在同一目录下看到两个输出文件。除了 Pexpect，Paramiko 还是一个流行的 Python 库，用于处理交互式会话。
- en: The Python Paramiko library
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Paramiko 库
- en: Paramiko is a Python implementation of the SSHv2 protocol. Just like the `pxssh`
    subclass of Pexpect, Paramiko simplifies the SSHv2 interaction between the host
    and the remote device. Unlike `pxssh`, Paramiko focuses only on SSHv2 with no
    Telnet support. It also provides both client and server operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko 是 SSHv2 协议的 Python 实现。就像 Pexpect 的 `pxssh` 子类一样，Paramiko 简化了主机和远程设备之间的
    SSHv2 交互。与 `pxssh` 不同，Paramiko 仅关注 SSHv2，没有 Telnet 支持。它还提供客户端和服务器操作。
- en: Paramiko is the low-level SSH client behind the high-level automation framework
    Ansible for its network modules. We will cover Ansible in *Chapter 4*, *The Python
    Automation Framework – Ansible*. Let’s take a look at the Paramiko library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko 是 Ansible 高级自动化框架网络模块背后的低级 SSH 客户端。我们将在 *第 4 章*，*Python 自动化框架 – Ansible*
    中介绍 Ansible。让我们看看 Paramiko 库。
- en: Installation of Paramiko
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Paramiko 安装
- en: Installing Paramiko is pretty straightforward with Python `pip`. However, there
    is a hard dependency on the cryptography library. The library provides low-level,
    C-based encryption algorithms for the SSH protocol.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Paramiko 非常简单，使用 Python `pip`。然而，它对加密库有硬依赖。该库为 SSH 协议提供基于 C 的低级加密算法。
- en: 'The installation instruction for Windows, macOS, and other flavors of Linux
    can be found at: [https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、macOS 和其他 Linux 版本的安装说明可以在：[https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/)
    找到。
- en: 'We will show the Paramiko installation steps for our Ubuntu 22.04 virtual machine:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示为我们的 Ubuntu 22.04 虚拟机安装 Paramiko 的步骤：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us test the library’s usage by importing it with the Python interpreter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 Python 解释器导入它来测试库的使用：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we are ready to take a look at Paramiko in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在下一节中查看 Paramiko。
- en: Paramiko overview
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Paramiko 概述
- en: 'Let’s look at a quick Paramiko example using the Python 3 interactive shell:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 Python 3 交互式 shell 的快速 Paramiko 示例：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `time.sleep()` function inserts a time delay to ensure all the outputs were
    captured. This is particularly useful on a slower network connection or a busy
    device. This command is not required but is recommended depending on your situation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.sleep()` 函数插入时间延迟以确保所有输出都被捕获。这在较慢的网络连接或繁忙的设备上特别有用。这个命令不是必需的，但根据你的情况推荐使用。'
- en: 'Even if we are seeing the Paramiko operation for the first time, the beauty
    of Python and its clear syntax means that we can make a pretty good educated guess
    at what the program is trying to do:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们是第一次看到 Paramiko 的操作，Python 的美感和其清晰的语法意味着我们可以对程序试图做什么有一个相当好的推测：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first four lines create an instance of the `SSHClient` class from Paramiko.
    The next line sets the policy that the client should use regarding keys; in this
    case, `lax-edg-r1` might not be in either the system host keys or the application’s
    keys. In our scenario, we will automatically add the key to the application’s
    `HostKeys` object. At this point, if you log on to the router, you will see all
    the login sessions from Paramiko.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行创建了一个 `SSHClient` 类的实例。下一行设置了客户端应使用的策略，关于密钥；在这种情况下，`lax-edg-r1` 可能既不在系统主机密钥中，也不在应用程序的密钥中。在我们的场景中，我们将自动将密钥添加到应用程序的
    `HostKeys` 对象中。此时，如果你登录到路由器，你会看到所有来自 Paramiko 的登录会话。
- en: The next few lines invoke a new interactive shell from the connection and a
    repeatable pattern of sending a command and retrieving the output. Finally, we
    close the connection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行从连接中调用一个新的交互式 shell，并重复发送命令和检索输出的模式。最后，我们关闭连接。
- en: 'Some readers who have used Paramiko before might be familiar with the `exec_command()`
    method instead of invoking a shell. Why do we need to invoke an interactive shell
    instead of using `exec_command()` directly? Unfortunately, `exec_command()` on
    Cisco IOS only allows a single command. Consider the following example with `exec_command()`
    for the connection:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一些之前使用过 Paramiko 的读者可能熟悉 `exec_command()` 方法而不是调用 shell。为什么我们需要调用交互式 shell 而不是直接使用
    `exec_command()`？不幸的是，Cisco IOS 上的 `exec_command()` 只允许执行单个命令。考虑以下使用 `exec_command()`
    的连接示例：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Everything works great; however, if you look at the number of sessions on the
    Cisco device, you will notice that the connection is dropped by the Cisco device
    without you closing the connection. Because the SSH session is no longer active,
    `exec_command()` will return an error if you want to send more commands to the
    remote device:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一切工作得很好；然而，如果你查看Cisco设备上的会话数量，你会注意到连接在没有你关闭连接的情况下被Cisco设备断开。因为SSH会话不再活跃，如果你想要向远程设备发送更多命令，`exec_command()`将返回错误：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous example, the `new_connection.recv()` command displayed what
    was in the buffer and implicitly cleared it out for us. What would happen if you
    did not clear out the received buffer? The output would just keep on filling up
    the buffer and would overwrite it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`new_connection.recv()`命令显示了缓冲区中的内容，并隐式地为我们清除了它。如果你没有清除接收到的缓冲区会发生什么？输出将不断填充缓冲区并覆盖它：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For consistency of the deterministic output, we will retrieve the output from
    the buffer each time we execute a command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保确定性输出的连贯性，我们将在每次执行命令时从缓冲区中检索输出。
- en: First Paramiko program
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个Paramiko程序
- en: Our first program will use the same general structure as the Pexpect program
    we have put together. We will loop over a list of devices and commands while using
    Paramiko instead of Pexpect. This will give us a good compare and contrast of
    the differences between Paramiko and Pexpect.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一程序将使用与我们在Pexpect程序中使用的相同的一般结构。我们将遍历设备列表和命令，同时使用Paramiko而不是Pexpect。这将让我们很好地比较和对比Paramiko和Pexpect之间的差异。
- en: 'If you have not done so already, you can download the code, `chapter2_3.py`,
    from the book’s GitHub repository at [https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition](https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition).
    I will list the notable differences here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，你可以从书的GitHub仓库[https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition](https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition)下载代码，`chapter2_3.py`。我将在下面列出显著的不同点：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We no longer need to match the device prompt using Paramiko; therefore, the
    device dictionary can be simplified:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要使用Paramiko匹配设备提示符；因此，设备字典可以简化：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is no sendline equivalent in Paramiko; instead, we manually include the
    newline break in each of the commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko中没有sendline的等效命令；相反，我们手动在每个命令中包含换行符：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We include a new method to clear the buffer for sending commands, such as `terminal
    length 0` or `enable`, because we do not need the output for those commands. We
    simply want to clear the buffer and get to the execution prompt. This function
    will later be used in the loop, such as in line 25 of the script:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了一种新的方法来清除发送命令的缓冲区，例如`terminal length 0`或`enable`，因为我们不需要那些命令的输出。我们只想清除缓冲区并到达执行提示符。这个功能将在后续的循环中使用，例如在脚本的第25行：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The rest of the program should be pretty self-explanatory, similar to what
    we have seen in this chapter. The last thing I would like to point out is that
    since this is an interactive program, we place a buffer and wait for the command
    to be finished on the remote device before retrieving the output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分应该相当直观，类似于我们在本章中看到的。我想指出的是，由于这是一个交互式程序，我们在检索输出之前会在远程设备上放置一个缓冲区并等待命令完成：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After we clear the buffer, we will wait five seconds between the execution of
    commands. This will give the device adequate time to respond if it is busy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们清除缓冲区后，我们将在命令执行之间等待五秒钟。这将给设备足够的时间来响应，如果它正忙的话。
- en: More Paramiko features
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多Paramiko功能
- en: We will look at Paramiko a bit later in *Chapter 4*, *The Python Automation
    Framework – Ansible**,* when we discuss Ansible, as Paramiko is the underlying
    transport for many of the network modules. In this section, we will take a look
    at some of the other features of Paramiko.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的*第4章*，*Python自动化框架 – Ansible*中简要介绍Paramiko，当我们讨论Ansible时，因为Paramiko是许多网络模块的底层传输。在本节中，我们将探讨Paramiko的一些其他功能。
- en: Paramiko for servers
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Paramiko用于服务器
- en: Paramiko can be used to manage servers through SSHv2 as well. Let’s look at
    an example of how we can use Paramiko to manage servers. We will use key-based
    authentication for the SSHv2 session.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko也可以用来通过SSHv2管理服务器。让我们看看如何使用Paramiko管理服务器的例子。我们将使用基于密钥的认证来建立SSHv2会话。
- en: In this example, I used another Ubuntu virtual machine on the same hypervisor
    as the destination server. You can also use a server on the CML simulator or an
    instance in one of the public cloud providers, such as Amazon AWS EC2.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了与目标服务器相同的虚拟机管理程序上的另一个 Ubuntu 虚拟机。您也可以使用 CML 模拟器上的服务器或公共云提供商（如 Amazon
    AWS EC2）中的一个实例。
- en: 'We will generate a public-private key pair for our Paramiko host:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的 Paramiko 主机生成一个公私钥对：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command, by default, will generate a public key named `id_rsa.pub`, as
    the public key under the user home directory `~/.ssh` along with a private key
    named `id_rsa`. Treat the private key with the same attention as you would for
    private passwords that you do not want to share with anybody else.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此命令将生成一个名为 `id_rsa.pub` 的公钥，作为用户家目录下 `~/.ssh` 中的公钥，以及一个名为 `id_rsa` 的私钥。对待私钥的重视程度应与您对待不希望与他人共享的私人密码相同。
- en: You can think of the public key as a business card that identifies who you are.
    Using the private and public keys, the message will be encrypted by your private
    key locally and decrypted by the remote host using the public key. We should copy
    the public key to the remote host. In production, we can do this via out-of-band
    using a USB drive; in our lab, we can simply copy the public key to the remote
    host’s `~/.ssh/authorized_keys` file. Open up a Terminal window for the remote
    server so you can paste in the public key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将公钥视为一张名片，用于识别您的身份。使用私钥和公钥，消息将在本地由您的私钥加密，并由远程主机使用公钥解密。我们应该将公钥复制到远程主机上。在生产环境中，我们可以通过非带外方式使用
    USB 驱动器来完成；在我们的实验室中，我们可以简单地将其复制到远程主机的 `~/.ssh/authorized_keys` 文件中。为远程服务器打开一个终端窗口，以便您可以粘贴公钥。
- en: 'Copy the content of `~/.ssh/id_rsa.pub` on your management host with Paramiko:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Paramiko 将您的管理主机上的 `~/.ssh/id_rsa.pub` 内容复制：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, paste it to the remote host under the `user` directory; in this case,
    I am using `echou` for both sides:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其粘贴到远程主机下的 `user` 目录中；在这种情况下，我正在使用 `echou` 作为双方：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You are now ready to use Paramiko to manage the remote host. Notice in this
    example that we will use the private key for authentication as well as the `exec_command()`
    method for sending commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用 Paramiko 来管理远程主机。注意在这个例子中，我们将使用私钥进行认证，以及使用 `exec_command()` 方法发送命令：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that in the server example, we do not need to create an interactive session
    to execute multiple commands. You can now turn off password-based authentication
    in your remote host’s SSHv2 configuration for more secure key-based authentication
    with automation enabled.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在服务器示例中，我们不需要创建交互式会话来执行多个命令。您现在可以关闭远程主机的 SSHv2 配置中的基于密码的认证，以启用更安全的基于密钥的认证并启用自动化。
- en: Why do we want to know about using private keys as authentication methods? More
    and more network devices, such as Cumulus and Vyatta switches, are moving toward
    using Linux shell and public-private key authentication as a security mechanism.
    For some operations, we will use a combination of SSH session and key-based authentication
    for authentication.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要了解使用私钥作为认证方法？越来越多的网络设备，如 Cumulus 和 Vyatta 交换机，正转向使用 Linux shell 和公私钥认证作为安全机制。对于某些操作，我们将使用
    SSH 会话和基于密钥的认证的组合进行认证。
- en: More Paramiko examples
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多 Paramiko 示例
- en: 'In this section, let’s make the Paramiko program more reusable. There is one
    downside of our existing script: we need to open up the script every time we want
    to add or delete a host, or whenever we need to change the commands we want to
    execute on the remote host.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们使 Paramiko 程序更具可重用性。我们现有脚本的一个缺点是：每次我们想要添加或删除主机，或者需要更改在远程主机上要执行的命令时，都需要打开脚本。
- en: This is due to the fact that both the host and command information are statically
    entered inside the script. Hardcoding the host and command has a higher chance
    of making mistakes when making a change. By making both the host and command files
    read in as parameters for the script, we can make the script more flexible. Users
    (and future us) can simply modify these text files when you need to make host
    or command changes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为主机和命令信息都是静态地输入到脚本内部的。在更改时，硬编码主机和命令更容易出错。通过将主机和命令文件作为脚本的参数读取，我们可以使脚本更加灵活。用户（以及未来的我们）只需在需要更改主机或命令时修改这些文本文件。
- en: We have incorporated the change in the script named `chapter2_4.py`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在名为 `chapter2_4.py` 的脚本中实现了这一更改。
- en: 'Instead of hardcoding the commands, we broke the commands into a separate `commands.txt`
    file. Up to this point, we have been using `show` commands; in this example, we
    will make configuration changes. In particular, we will change the logging buffer
    size to `30000` bytes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有硬编码命令，而是将命令拆分到一个单独的`commands.txt`文件中。到目前为止，我们一直在使用`show`命令；在这个例子中，我们将进行配置更改。特别是，我们将日志缓冲区大小更改为`30000`字节：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The device’s information is written into a `devices.json` file. We chose JSON
    format for the device’s information because JSON data types can be easily translated
    into Python dictionary data types:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 设备信息被写入到`devices.json`文件中。我们选择JSON格式来存储设备信息，因为JSON数据类型可以轻松转换为Python字典数据类型：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the script, we made the following changes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们做了以下更改：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is an abbreviated output from the script execution:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是脚本执行的一个简略输出：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Do a quick check to make sure the change has taken place in both `running-config`
    and `startup-config`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查以确保更改已应用于`running-config`和`startup-config`：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The Paramiko library is a general-purpose library intended for working with
    interactive command-line programs. For network management, there is another library,
    Netmiko, a fork from Paramiko, that is purpose-built for network device management.
    We will take a look at it in the upcoming section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko库是一个通用库，旨在与交互式命令行程序一起使用。对于网络管理，还有一个名为Netmiko的库，它是从Paramiko分叉出来的，专门用于网络设备管理。我们将在下一节中查看它。
- en: The Netmiko library
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netmiko库
- en: Paramiko is a great library to do low-level interactions with Cisco IOS and
    other vendor devices. But as you have noticed from previous examples, we are repeating
    many of the same steps between `lax-edg-r1` and `lax-edg-r2` for device login
    and execution. Once we start to develop more automation commands, we also start
    to repeat ourselves in capturing terminal outputs and formatting them into a usable
    format. Wouldn’t it be great if somebody could write a Python library that simplifies
    these low-level steps and share it with other network engineers?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko是一个用于与Cisco IOS和其他厂商设备进行低级交互的出色库。但正如您从前面的示例中注意到的，我们在`lax-edg-r1`和`lax-edg-r2`设备登录和执行之间重复了许多相同的步骤。一旦我们开始开发更多的自动化命令，我们也开始在捕获终端输出并将它们格式化为可用格式时重复自己。如果有人能编写一个简化这些低级步骤并与其他网络工程师共享的Python库，那岂不是很好？
- en: Ever since 2014, Kirk Byers ([https://github.com/ktbyers](https://github.com/ktbyers))
    has been working on open-source initiatives to simplify the management of network
    devices. In this section, we will take a look at an example of the Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    library that he created.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 自2014年以来，Kirk Byers ([https://github.com/ktbyers](https://github.com/ktbyers))
    一直在从事开源项目，以简化网络设备的管理工作。在本节中，我们将查看他创建的Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    库的一个示例。
- en: 'First, we will install the `netmiko` library using `pip`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`pip`安装`netmiko`库：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use the example published on Kirk’s website, [https://pynet.twb-tech.com/blog/automation/netmiko.html](https://pynet.twb-tech.com/blog/automation/netmiko.html),
    and apply it to our labs. We will start by importing the library and its `ConnectHandler`
    class. Then we will define our `device` parameter as a Python dictionary and pass
    it to the `ConnectHandler`. Notice that we are defining a `device_type` of `cisco_ios`
    in the `device` parameter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Kirk网站上发布的示例，[https://pynet.twb-tech.com/blog/automation/netmiko.html](https://pynet.twb-tech.com/blog/automation/netmiko.html)，并将其应用于我们的实验室。我们将首先导入库及其`ConnectHandler`类。然后我们将定义我们的`device`参数为一个Python字典，并将其传递给`ConnectHandler`。请注意，我们在`device`参数中定义了一个`device_type`为`cisco_ios`：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is where the simplification begins. Notice that the library automatically
    determines the device prompt as well as formatting the returned output from the
    `show` command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是简化的开始。请注意，库会自动确定设备提示，并格式化`show`命令返回的输出：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s see another example for the second Cisco IOS device in our lab and send
    a `configuration` command instead of a `show` command. Note that the `command`
    attribute is a list that can contain multiple commands:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实验室中第二个Cisco IOS设备的另一个示例，并发送一个`configuration`命令而不是`show`命令。请注意，`command`属性是一个列表，可以包含多个命令：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How cool is that? Netmiko automatically took care of the nitty-gritty stuff
    for us, allowing us to focus on the commands themselves. The `netmiko` library
    is a great time saver and is used by many network engineers. In the next section,
    we will take a look at the Nornir ([https://github.com/nornir-automation/nornir](https://github.com/nornir-automation/nornir))
    framework, which also aims to simplify low-level interactions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？Netmiko自动为我们处理了琐碎的事情，让我们可以专注于命令本身。`netmiko`库是一个节省时间的库，被许多网络工程师使用。在下一节中，我们将探讨Nornir（[https://github.com/nornir-automation/nornir](https://github.com/nornir-automation/nornir)）框架，该框架也旨在简化低级交互。
- en: The Nornir framework
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nornir框架
- en: 'Nornir ([https://nornir.readthedocs.io/en/latest/](https://nornir.readthedocs.io/en/latest/))
    is a pure Python automation framework intended to be used directly from Python.
    We will start with installing `nornir` in our environment:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Nornir（[https://nornir.readthedocs.io/en/latest/](https://nornir.readthedocs.io/en/latest/)）是一个纯Python自动化框架，旨在直接从Python使用。我们将从在我们的环境中安装`nornir`开始：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Nornir expects us to define an inventory file, `hosts.yaml`, consisting of
    the device information in a YAML format. The information specified in this file
    is no different than what we have previously defined using the Python dictionary
    in the Netmiko example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Nornir期望我们定义一个名为`hosts.yaml`的清单文件，其中包含设备的YAML格式信息。该文件中指定的信息与我们之前在Netmiko示例中使用的Python字典定义的信息没有区别：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use the `netmiko` plugin from the `nornir` library to interact with
    our device, as illustrated in the `chapter2_5.py` file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自`nornir`库的`netmiko`插件来与我们的设备交互，如`chapter2_5.py`文件所示：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The execution output is shown as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 执行输出如下所示：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There are other plugins in Nornir besides Netmiko, such as the popular NAPALM
    library ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)).
    Please feel free to check out Nornir’s project page for the latest plugins: [https://nornir.readthedocs.io/en/latest/plugins/index.html](https://nornir.readthedocs.io/en/latest/plugins/index.html).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Nornir除了Netmiko之外，还有其他插件，例如流行的NAPALM库（[https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)）。请随时查看Nornir的项目页面以获取最新的插件：[https://nornir.readthedocs.io/en/latest/plugins/index.html](https://nornir.readthedocs.io/en/latest/plugins/index.html)。
- en: We have taken a pretty huge leap forward in this chapter in automating our network
    using Python. However, some of the methods we have used feel like workarounds
    for automation. We attempted to trick the remote devices into thinking they were
    interacting with a human on the other end. Even if we use libraries such as Netmiko
    or the Nornir framework, the underlying approach remains the same. Just because
    somebody else has done the work to help abstract the grunt work of the low-level
    interaction, we are still susceptible to the downsides of dealing with CLI-only
    devices.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Python自动化网络方面取得了很大的进步。然而，我们使用的一些方法感觉像是自动化的一种权宜之计。我们试图欺骗远程设备，让它们认为它们正在与另一端的人类交互。即使我们使用Netmiko或Nornir框架等库，其底层方法仍然相同。尽管有人已经做了工作来帮助我们抽象低级交互的繁琐工作，但我们仍然容易受到仅处理CLI设备所带来的缺点的影响。
- en: Looking ahead, let us discuss some of the downsides of Pexpect and Paramiko
    compared to other tools in preparation for our discussion on API-driven methods
    in the next chapters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，让我们讨论一下与Pexpect和Paramiko相比，其他工具的一些缺点，为下一章讨论基于API的方法做准备。
- en: Downsides of Pexpect and Paramiko compared to other tools
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他工具相比，Pexpect和Paramiko的缺点
- en: The biggest downside of our current method for automating CLI-only devices is
    that the remote devices do not return structured data. They return data that is
    ideal for fitting on a terminal to be interpreted by a human, not by a computer
    program. The human eye can easily interpret a space, while a computer only sees
    a return character.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前用于自动化仅CLI设备的当前方法的最大缺点是远程设备不返回结构化数据。它们返回的数据非常适合在终端上显示，以便由人类解释，而不是由计算机程序解释。人眼可以轻松地解释空格，而计算机只能看到回车符。
- en: We will take a look at a better way in the upcoming chapter. As a prelude to
    *Chapter 3*, *APIs and Intent-Driven Networking**,* let’s discuss the idea of
    idempotency.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中探讨一种更好的方法。作为对*第三章*，*APIs和Intent-Driven Networking*的序言，让我们讨论一下幂等性的概念。
- en: Idempotent network device interaction
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幂等网络设备交互
- en: The term *idempotency* has different meanings, depending on its context. But
    in this book’s context, the term means that when a client makes the same call
    to a remote device, the result should always be the same. I believe we can all
    agree that this is necessary. Imagine a scenario where each time you execute the
    same script, you get a different result back. I find that scenario very scary.
    How can you trust your script if that is the case? It would render our automation
    effort useless because we need to be prepared to handle different returns.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“幂等性”在不同的上下文中有不同的含义。但在本书的上下文中，这个术语意味着当客户端对远程设备进行相同的调用时，结果应该始终相同。我相信我们都可以同意这是必要的。想象一下，每次你执行相同的脚本时，你都会得到不同的结果。我发现这种情况非常可怕。如果那样的话，你怎么能信任你的脚本呢？这将使我们的自动化工作变得毫无意义，因为我们需要准备好处理不同的返回结果。
- en: Since Pexpect and Paramiko are blasting out a series of commands interactively,
    the chance of having a non-idempotent interaction is higher. Going back to the
    fact that the return results needed to be screen scraped for useful elements,
    the risk of difference is much higher. Something on the remote end might have
    changed between the time we wrote the script and the time when the script is executed
    for the 100th time. For example, if the vendor makes a screen output change between
    releases without us updating the script, the script might break our network.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pexpect和Paramiko正在交互式地发出一系列命令，出现非幂等交互的可能性更高。回到需要从屏幕抓取有用元素的事实，差异的风险要高得多。在编写脚本和脚本执行第100次之间，远程端可能发生了变化。例如，如果供应商在发布之间更改了屏幕输出，而我们没有更新脚本，脚本可能会破坏我们的网络。
- en: If we need to rely on the script for production, we need the script to be idempotent
    as much as possible.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在生产中依赖脚本，我们需要尽可能使脚本具有幂等性。
- en: Bad automation speeds up bad things
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 糟糕的自动化会加速糟糕的事情
- en: Bad automation allows you to poke yourself in the eye a lot faster, it is as
    simple as that. Computers are much faster at executing tasks than human engineers.
    If we had the same set of operating procedures executed by a human versus a script,
    the script would finish faster than humans, sometimes without the benefit of having
    a solid feedback loop between steps. The internet is full of horror stories of
    when someone pressed the *Enter* key and immediately regretted it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的自动化会让你更快地戳到自己的眼睛，就是这样简单。计算机在执行任务方面比人类工程师要快得多。如果我们让一套操作程序由人类和脚本执行，脚本会比人类更快地完成，有时甚至没有在步骤之间建立稳固的反馈循环的好处。互联网上充满了当有人按下*Enter*键后立即后悔的故事。
- en: We need to minimize the chances of bad automation scripts screwing things up.
    We all make mistakes; carefully testing your script before any production work
    and having a small blast radius are two keys to making sure you can catch your
    mistake before it comes back and bites you. No tool or human can eliminate mistakes
    completely, but we can strive to minimize the mistakes. As we have seen, as great
    as some of the libraries we have used in this chapter are, the underlying CLI-based
    method is inherently faulty and error-prone. We will introduce the API-driven
    method in the next chapter, which addresses some of the CLI-driven management
    deficiencies.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最小化糟糕的自动化脚本搞砸事情的可能性。我们都会犯错误；在生产工作之前仔细测试你的脚本，并保持一个小的破坏半径是确保你能在错误回来并咬你之前捕捉到错误的关键。没有工具或人类可以完全消除错误，但我们可以努力最小化错误。正如我们所看到的，尽管我们在这章中使用的一些库很棒，但基于CLI的方法本质上是有缺陷和容易出错的。我们将在下一章介绍API驱动的方法，该方法解决了CLI驱动管理的一些不足。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered low-level ways to communicate directly with network
    devices. Without a way to programmatically communicate and make changes to network
    devices, there is no automation. We looked at several libraries in Python that
    allow us to manage devices that were meant to be managed by the CLI. Although
    useful, it is easy to see how the process can be somewhat fragile. This is mostly
    due to the fact that the network gear in question was meant to be managed by human
    beings and not computers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了直接与网络设备通信的低级方法。如果没有一种方法可以程序化地与网络设备通信并对其进行更改，就没有自动化。我们查看了一些Python库，这些库允许我们管理那些旨在通过CLI进行管理的设备。尽管很有用，但很容易看出这个过程可能会有些脆弱。这主要是因为相关的网络设备原本是打算由人类而不是计算机管理的。
- en: In *Chapter 3*, *APIs and Intent-Driven Networking*, we will look at network
    devices supporting API and intent-driven networking.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*APIs和意图驱动的网络*中，我们将探讨支持API和意图驱动的网络的网络设备。
- en: Join our book community
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
