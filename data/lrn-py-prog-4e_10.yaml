- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: ”Just as the wise accepts gold after testing it by heating, cutting, and rubbing
    it, so are my words to be accepted after examining them, but not out of respect
    for me.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “正如智者经过加热、切割和摩擦来检验黄金后才会接受它一样，我的话也应该在经过检验后接受，而不是出于对我的尊重。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Buddha
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 佛陀
- en: We love this quote by the Buddha. Within the software world, it translates perfectly
    into the healthy habit of never trusting code just because someone smart wrote
    it or because it has been working fine for a long time. If it has not been tested,
    the code is not to be trusted.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢佛陀的这句话。在软件世界中，它完美地转化为一个健康的习惯：永远不要仅仅因为某人聪明就信任代码，或者因为它长时间运行良好就信任它。如果它没有被测试，代码就不应该被信任。
- en: Why are tests so important? Well, for one, they give you predictability. Or,
    at least, they help you achieve high predictability. Unfortunately, there is always
    some bug that sneaks into the code. But we want our code to be as predictable
    as possible. What we do not want is to have a surprise; in other words, our code
    behaving in an unpredictable way. Unpredictability in software that checks the
    sensors of a plane, a train, or a nuclear power plant can lead to disastrous situations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么测试如此重要？好吧，首先，它们为你提供了可预测性。或者至少，它们帮助你实现高可预测性。不幸的是，代码中总是会有一些漏洞悄悄溜进来。但我们希望我们的代码尽可能可预测。我们不希望有惊喜；换句话说，我们不希望代码以不可预测的方式运行。在检查飞机、火车或核电站传感器的软件中存在不可预测性可能导致灾难性的情况。
- en: We need to test our code; we need to check that its behavior is correct, that
    it works as expected when it deals with edge cases, that it does not hang when
    the components it is talking to are broken or unreachable, that the performance
    is well within the acceptable range, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试我们的代码；我们需要检查其行为是否正确，当它处理边缘情况时是否按预期工作，当它与之通信的组件损坏或无法访问时，它不会挂起，性能是否在可接受的范围内，等等。
- en: This chapter is all about that—making sure that your code is prepared to face
    the scary outside world, that it is fast enough, and that it can deal with unexpected
    or exceptional conditions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于这一点——确保你的代码准备好面对可怕的外部世界，它足够快，并且能够处理意外或异常条件。
- en: 'In this chapter, we are going to explore the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: General testing guidelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用测试指南
- en: Unit testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: A brief mention of **test-driven development** ( **TDD** )
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要介绍**测试驱动开发**（**TDD**）
- en: Let us start by understanding what testing is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从理解什么是测试开始。
- en: Testing your application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的应用程序
- en: There are many kinds of tests; so many, in fact, that companies often have a
    dedicated department, called **quality assurance** ( **QA** ), made up of individuals
    whose job is to test the software the company developers produce.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有很多种类；实际上，公司通常有一个专门的部门，称为**质量保证**（**QA**），由那些负责测试公司开发软件的个人组成。
- en: 'To start making an initial classification, we can divide tests into two broad
    categories: **white-box** and **black-box** tests.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行初步分类，我们可以将测试分为两大类：**白盒**和**黑盒**测试。
- en: White-box tests are those that exercise the internals of the code; they inspect
    it down to a fine level of detail. On the other hand, black-box tests are those
    that consider the software under test as if within a box, the internals of which
    are ignored. Even the technology, or the language used inside the box, is not
    important for black-box tests. What they do is plug some input into one end of
    the box and verify the output at the other end—that’s it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试是那些锻炼代码内部结构的测试；它们检查到非常详细的程度。另一方面，黑盒测试是那些将待测试的软件视为一个盒子，忽略其内部结构的测试。即使是盒子内部使用的科技或语言，对黑盒测试来说也不重要。它们所做的是将一些输入插入盒子的一个端点，并验证另一个端点的输出——仅此而已。
- en: There is also an in-between category called **gray-box** testing, which involves
    testing a system in the same way we do with the black-box approach, but having
    some knowledge about the algorithms and data structures used to write the software
    and only partial access to its source code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个介于两者之间的类别，称为**灰盒**测试，它涉及以与黑盒方法相同的方式测试系统，但对我们使用的算法和数据结构有一些了解，并且只有部分访问源代码的权限。
- en: 'There are many kinds of tests in these categories, each of which serves a different
    purpose. To give you an idea, here are a few:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别中有许多种测试，每种都服务于不同的目的。为了给你一个概念，这里有一些例子：
- en: '**Frontend tests** : They make sure that the client side of your application
    is exposing the information that it should, all the links, the buttons, the advertising,
    and everything that needs to be shown to the client. They may also verify that
    it is possible to walk a certain path through the **user interface** ( **UI**
    ).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端测试**：它们确保你的应用程序客户端暴露了应该暴露的信息，所有链接、按钮、广告以及需要展示给客户端的一切。它们还可能验证是否可以通过**用户界面**（**UI**）走一条特定的路径。'
- en: '**Scenario tests** : They make use of stories (or scenarios) that help the
    tester work through a complex problem or test a part of the system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景测试**：它们利用故事（或场景）帮助测试人员解决复杂问题或测试系统的一部分。'
- en: '**Integration tests** : They verify the behavior of the various components
    of your application when they are working together and sending messages through
    interfaces.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：它们验证当应用程序的不同组件协同工作并通过接口发送消息时的行为。'
- en: '**Smoke tests** : Particularly useful when you deploy a new update on your
    application, they check whether the most essential, vital parts of your application
    are still working as they should and that they are not *on fire* . This term comes
    from when engineers tested circuits by making sure nothing was smoking.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**：在你对应用程序部署新的更新时特别有用，它们检查应用程序最基本、最重要的部分是否仍然按预期工作，并且它们没有处于**燃烧**状态。这个术语来源于工程师通过确保没有冒烟来测试电路的时候。'
- en: '**Acceptance tests** , or **user acceptance testing** ( **UAT** ): What a developer
    does with a product owner (for example, in a SCRUM environment) to determine whether
    the work that was commissioned was carried out correctly.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**，或**用户验收测试**（**UAT**）：开发者与产品负责人（例如，在敏捷开发环境中）一起进行的工作，以确定委托的工作是否正确完成。'
- en: '**Functional tests** : They verify the features or functionalities of your
    software.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：它们验证你的软件的功能或功能。'
- en: '**Destructive tests** : They take down parts of your system, simulating a failure,
    to establish how well the remaining parts of the system perform. This kind of
    test is performed extensively by companies that need to provide a highly reliable
    service.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性测试**：它们破坏系统的某些部分，模拟故障，以确定系统剩余部分的表现如何。这种测试由需要提供高度可靠服务的公司广泛进行。'
- en: '**Performance tests** : They aim to verify how well the system performs under
    a specific load of data or traffic so that, for example, engineers can get a better
    understanding of the bottlenecks in the system that could bring it to its knees
    in a heavy-load situation, or those that prevent scalability.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：它们旨在验证系统在特定数据负载或流量下的表现如何，以便工程师可以更好地了解可能导致系统在重负载情况下崩溃的瓶颈，或者那些阻止可扩展性的瓶颈。'
- en: '**Usability tests** , and the closely related **user experience** ( **UX**
    ) **tests** : They aim to check whether the UI is simple and easy to understand
    and use. They also aim to provide input to the designers so that the UX is improved.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**，以及与之密切相关的**用户体验**（**UX**）**测试**：它们旨在检查UI是否简单、易于理解和使用。它们还旨在为设计师提供反馈，以改善UX。'
- en: '**Security and penetration tests** : They aim to verify how well the system
    is protected against attacks and intrusions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和渗透测试**：它们旨在验证系统抵御攻击和入侵的能力。'
- en: '**Unit tests** : They help the developer write the code in a robust and consistent
    way, providing the first line of feedback and defense against coding mistakes,
    refactoring mistakes, and so on.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：它们帮助开发者以稳健和一致的方式编写代码，提供第一线的反馈和防御，以防止编码错误、重构错误等。'
- en: '**Regression tests** : They provide the developer with useful information about
    a feature being compromised in the system after an update. Some of the causes
    for a system being said to have a regression are an old bug resurfacing, an existing
    feature being compromised, or a new issue being introduced.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：它们为开发者提供有关更新后系统中的某个功能被破坏的有用信息。系统被认为有回归的一些原因是旧错误再次出现、现有功能被破坏，或者引入了新的问题。'
- en: Many books and articles have been written about testing, and we have to point
    you to those resources if you are interested in finding out more about all the
    different kinds of tests. In this chapter, we will concentrate on unit tests,
    since they are the backbone of software crafting and form the vast majority of
    tests that are written by a developer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试的书籍和文章已经有很多了，如果你对了解所有不同类型的测试感兴趣，我们必须向你推荐那些资源。在本章中，我们将专注于单元测试，因为它们是软件构建的基石，构成了开发者编写的测试中的绝大多数。
- en: Testing is an *art* , an art that you do not learn from books, unfortunately.
    You can learn all the definitions (and you should) and try to collect as much
    knowledge about testing as you can, but you will likely be able to test your software
    properly only when you have accumulated enough experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一种**艺术**，不幸的是，这种艺术你无法从书中学习。你可以学习所有的定义（你应该这样做），并尽可能多地收集有关测试的知识，但只有当你积累了足够多的经验时，你才可能正确地测试你的软件。
- en: When you are having trouble refactoring a bit of code because every little thing
    you touch makes a test blow up, you learn how to write less rigid and limiting
    tests that still verify the correctness of your code but, at the same time, allow
    you the freedom and joy to play with it, to shape it as you want.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在重构一小段代码时遇到困难，因为每次你触摸到的东西都会使测试失败，你会学会编写不那么严格和限制性的测试，这些测试仍然可以验证代码的正确性，同时，也让你有自由和乐趣去玩弄它，按照你的意愿去塑造它。
- en: When you are being called too often to fix unexpected bugs in your code, you
    learn how to write tests more thoroughly, how to come up with a more comprehensive
    list of edge cases, and strategies to cope with them before they turn into bugs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你频繁被要求修复代码中的意外错误时，你会学会如何更彻底地编写测试，如何提出一个更全面的边缘情况列表，以及应对这些情况的策略，以防它们变成错误。
- en: When you are spending too much time reading tests and trying to refactor them
    to change a small feature in the code, you learn to write simpler, shorter, and
    better-focused tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花费太多时间阅读测试并尝试重构它们以更改代码中的一个小功能时，你会学会编写更简单、更短、更专注的测试。
- en: We could go on with this *when you... you learn...* , but we guess you get the
    picture. You need to apply yourself and build experience. Our suggestion? Study
    the theory as much as you can, and then experiment using different approaches.
    Also, try to learn from experienced coders; it is very effective.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续用这种“当你……你学……”的方式来讨论，但我们猜测你已经明白了。你需要付出努力并积累经验。我们的建议？尽可能多地学习理论，然后尝试使用不同的方法进行实验。此外，尝试向经验丰富的程序员学习；这非常有效。
- en: Ideally, the more experienced you become, the more you should feel that source
    code and unit tests are not two separate things. Tests are not optional. They
    are intimately connected to the code. Source code and unit tests mutually influence
    each other.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你越有经验，你就越应该感觉到源代码和单元测试不是两件独立的事情。测试不是可选的。它们与代码紧密相连。源代码和单元测试相互影响。
- en: The anatomy of a test
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的结构
- en: Before we concentrate on unit tests, let us see what a test is, and what its
    purpose is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们专注于单元测试之前，让我们先看看什么是测试，以及它的目的是什么。
- en: A **test** is a piece of code whose purpose is to verify something in our system.
    It may be that we are calling a function passing two integers, that an object
    has a property called `donald_duck` , or that when you place an order on some
    **application programming interface** ( **API** ), after a minute you can see
    it dissected into its basic elements in the database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**是一段代码，其目的是验证我们系统中的某个东西。这可能意味着我们正在调用一个函数，传递两个整数，或者一个对象有一个名为`donald_duck`的属性，或者当你在一个**应用程序编程接口**（**API**）上放置一个订单后，一分钟内你可以在数据库中看到它被分解成基本元素。'
- en: 'A test is typically composed of three sections:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试通常由三个部分组成：
- en: '**Preparation** : This is where we set up the scene. We prepare all the data,
    the objects, and the services we need in the places we need them so that they
    are ready to be used.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备**：这是我们设置场景的地方。我们在需要的地方准备所有需要的数据、对象和服务，以便它们可以随时使用。'
- en: '**Execution** : This is where we execute the bit of logic that is under testing.
    We perform an action using the data and the interfaces we set up in the preparation
    phase.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**：这是我们在测试阶段执行逻辑的地方。我们使用在准备阶段设置的数据和接口执行一个动作。'
- en: '**Verification** : This is where we verify the results and make sure they are
    according to our expectations. We check the returned value of a function, or that
    some data is in the database, some is not, some has changed, an HTTP request has
    been made, something has happened, a method has been called, and so on.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证**：这是验证结果并确保它们符合我们预期的地方。我们检查函数的返回值，或者某些数据是否在数据库中，某些不是，某些已更改，已发起HTTP请求，发生了某些事情，调用了某个方法，等等。'
- en: 'While tests usually follow this structure, in a test suite, you will typically
    find some other constructs that take part in the testing process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试通常遵循这种结构，但在测试套件中，你通常会找到一些参与测试过程的其它构造：
- en: '**Setup** : This is something quite commonly found in several tests. It is
    logic that can be customized to run for every test, class, module, or even for
    a whole session. In this phase, developers usually set up connections to databases,
    populate them with data that will be needed there for the test to make sense,
    and so on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：这是在多个测试中相当常见的东西。这是一种可以定制以运行每个测试、类、模块或整个会话的逻辑。在这个阶段，开发者通常会设置与数据库的连接，用测试所需的数据填充它们，等等。'
- en: '**Teardown** : This is the opposite of the setup; the teardown phase takes
    place after the tests have run. Like the setup, it can be customized to run for
    every test, class, module, or session. Typically, in this phase, we destroy any
    artifacts that were created for the test suite and clean up after ourselves. This
    is important because we do not want to have any lingering objects around and because
    it helps to make sure that each test starts from a clean slate.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拆卸**：这是设置的反面；拆卸阶段在测试运行之后发生。像设置一样，它可以定制以运行每个测试、类、模块或会话。通常，在这个阶段，我们会销毁为测试套件创建的任何工件，并清理我们的痕迹。这很重要，因为我们不希望有任何残留的对象，这也有助于确保每个测试都是从一张干净的纸开始。'
- en: '**Fixtures** : These are pieces of data used in the tests. By using a specific
    set of fixtures, outcomes are predictable and therefore tests can perform verifications
    against them.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定装置**：这些是在测试中使用的数据片段。通过使用特定的固定装置集，结果是可以预测的，因此测试可以针对它们进行验证。'
- en: In this chapter, we will use the `pytest` Python library. It is a powerful tool
    that makes testing easier than it would be if we only used standard library tools.
    `pytest` provides plenty of helpers so that the test logic can focus more on the
    actual testing than the wiring and boilerplate around it. You will see, when we
    get to the code, that one of the characteristics of `pytest` is that fixtures,
    setup, and teardown often blend into one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`pytest` Python库。这是一个强大的工具，它使得测试比仅使用标准库工具要容易得多。`pytest`提供了大量的辅助工具，以便测试逻辑可以更多地关注实际的测试，而不是围绕它的布线和模板。当你看到代码时，你会发现`pytest`的一个特点是，固定装置、设置和拆卸通常融合在一起。
- en: Testing guidelines
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试指南
- en: 'Like software, tests can be good or bad, with a whole range of shades in the
    middle. To write good tests, here are some guidelines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件一样，测试可以是好的或坏的，中间还有一系列的灰色地带。要编写好的测试，以下是一些指导原则：
- en: '**Keep them as simple as possible** : It is okay to violate some good coding
    rules, such as hardcoding values or duplicating code. Tests need, first and foremost,
    to be as readable as possible and easy to understand. When tests are hard to read
    or understand, we can never be confident they are actually making sure our code
    is performing correctly.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能简单**：违反一些良好的编码规则，如硬编码值或重复代码，是可以接受的。测试首先需要尽可能的可读和易于理解。当测试难以阅读或理解时，我们永远无法确信它们实际上是在确保我们的代码正确执行。'
- en: '**Tests should verify one thing and one thing only** : It is important that
    we keep them short and contained. It is perfectly fine to write multiple tests
    to exercise a single object or function. We just need to make sure that each test
    has one and only one purpose.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应验证一件事，且仅一件事**：保持它们简短并包含在一个范围内非常重要。写多个测试来测试单个对象或函数是完全正常的。我们只需要确保每个测试只有一个且只有一个目的。'
- en: '**Tests should not make any unnecessary assumptions** : This may be tricky
    to understand at first, but it is important. Verifying that the result of a function
    call is `[1, 2, 3]` is not the same as saying the output is a list that contains
    the numbers 1, 2, and 3. In the former, we are also assuming the ordering; in
    the latter, we are only assuming which items are in the list. The differences
    sometimes are quite subtle, but they are still important.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试不应做出任何不必要的假设**：起初这可能难以理解，但这是很重要的。验证函数调用的结果是`[1, 2, 3]`并不等同于说输出是一个包含数字1、2和3的列表。在前者中，我们还在假设顺序；在后者中，我们只假设列表中包含哪些项目。这些差异有时可能非常微妙，但它们仍然很重要。'
- en: '**Tests should exercise the “what,” rather than the “how”** : Tests should
    focus on checking *what* a function is supposed to do, rather than *how* it is
    doing it. For example, focus on the fact that a function is calculating the square
    root of a number (the *what* ), instead of the fact that it is calling `math.sqrt()`
    to do it (the *how* ). Unless we are writing performance tests or we have a particular
    need to verify how a certain action is performed, we ought to try to avoid this
    type of testing and focus on the *what* . Testing the *how* leads to restrictive
    tests and makes refactoring hard. Moreover, the type of test we have to write
    when we concentrate on the *how* is more likely to degrade the quality of our
    testing codebase when we amend the software frequently.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应关注“是什么”，而不是“如何”**：测试应专注于检查函数应该做什么，而不是它是如何做到的。例如，关注函数是计算一个数字的平方根（即“是什么”），而不是它调用`math.sqrt()`来做到这一点（即“如何”）。除非我们正在编写性能测试或我们有特定的需求来验证某些动作是如何执行的，否则我们应该尽量避免这种类型的测试，并专注于“是什么”。测试“如何”会导致测试过于严格，并使得重构变得困难。此外，当我们专注于“如何”时，我们必须编写的测试类型更有可能在频繁修改软件时降低我们的测试代码库的质量。'
- en: '**Tests should use the minimal set of fixtures needed to do the job** : This
    is another crucial point. Fixtures tend to grow over time. They also tend to change
    every now and then. If we use many fixtures and ignore redundancies in the tests,
    refactoring will take longer. Spotting bugs will be harder. We ought to try to
    use a set of fixtures that is big enough for the test to perform correctly, but
    not any bigger.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应使用完成工作所需的最小固定数据集**：这是另一个关键点。固定数据集往往会随着时间的推移而增长。它们也往往会时不时地发生变化。如果我们使用许多固定数据集并且忽略测试中的冗余，重构将需要更长的时间。发现错误将更加困难。我们应该尽量使用一组足够大的固定数据集，以便测试能够正确执行，但不要过大。'
- en: '**Tests should use as few resources as possible** : The reason for this is
    that every developer who checks out our code should be able to run the tests,
    no matter how powerful their machine is. It could be a skinny virtual machine
    or a CircleCI setup; tests should run without chewing up too many resources.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应尽可能少地使用资源**：这样做的原因是，任何检出我们代码的开发者都应该能够运行测试，无论他们的机器有多强大。这可能是一个瘦虚拟机或CircleCI设置；测试应在不消耗太多资源的情况下运行。'
- en: '**Tests should run as fast as possible** : A good test codebase could end up
    being much longer than the code being tested itself. It varies according to the
    situation and the developer, but, whatever the length, we will end up having hundreds,
    if not thousands, of tests to run, which means the faster they run, the faster
    we can get back to writing code. When using **TDD** , for example, we run tests
    very often, so speed is essential.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应尽可能快地运行**：一个好的测试代码库最终可能会比被测试的代码本身更长。这取决于具体情况和开发者，但无论长度如何，我们最终都会拥有数百甚至数千个测试要运行，这意味着它们运行得越快，我们就能越快回到编写代码。例如，在使用**TDD**时，我们会非常频繁地运行测试，因此速度至关重要。'
- en: '**CircleCI** is one of the largest **continuous integration/continuous delivery**
    ( **CI/CD)** platforms available today. It is easy to integrate with services
    like GitHub, for example. You just need to add some configuration (typically in
    the form of a file) in the source code, and CircleCI will run tests when the new
    code is prepared to be merged into the current codebase.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**CircleCI**是今天可用的最大的**持续集成/持续交付**（**CI/CD**）平台之一。例如，它与GitHub等服务的集成非常容易。你只需要在源代码中添加一些配置（通常是文件的形式），当新代码准备合并到当前代码库时，CircleCI就会运行测试。'
- en: Unit testing
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that we have an idea about what testing is and why we need it, let us introduce
    the developer’s best friend: the **unit test** .'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了测试是什么以及为什么我们需要它，让我们来介绍开发者的最佳拍档：**单元测试**。
- en: 'Before we proceed with the examples, allow us to share some words of caution:
    we will try to give you the fundamentals about unit testing, but we do not follow
    any particular school of thought or methodology to the letter. Over the years,
    we have tried many different testing approaches, eventually coming up with our
    own way of doing things, which is constantly evolving. To put it as Bruce Lee
    would have:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续举例之前，让我们分享一些注意事项：我们将尝试向您介绍单元测试的基础知识，但我们并不严格遵循任何特定的思想或方法论。多年来，我们尝试了许多不同的测试方法，最终形成了我们自己的做事方式，这种方式一直在不断演变。用布鲁斯·李的话来说：
- en: Absorb what is useful, discard what is useless, and add what is specifically
    your own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收有用的，摒弃无用的，增加你自己的独特之处。
- en: Writing a unit test
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'Unit tests take their name from the fact that they are used to test small units
    of code. To explain how to write a unit test, let us look at a simple snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的名字来源于它们用于测试代码的小单元。为了解释如何编写单元测试，让我们看看一个简单的代码片段：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `get_clean_data()` function is responsible for getting data from `source`
    , cleaning it, and returning it to the caller. How do we test this function?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_clean_data()` 函数负责从 `source` 获取数据，清理它，并将其返回给调用者。我们如何测试这个函数？'
- en: One way of doing this is to call it and then make sure that `load_data()` was
    called once with `source` as its only argument. Then, we need to verify that `clean_data()`
    was called once, with the return value of `load_data()` . Finally, we would need
    to make sure that the return value of `clean_data()` is what is returned by the
    `get_clean_data()` function as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是在调用它并确保 `load_data()` 仅以 `source` 作为其唯一参数被调用一次。然后，我们需要验证 `clean_data()`
    仅被调用一次，并且其参数是 `load_data()` 的返回值。最后，我们需要确保 `clean_data()` 的返回值与 `get_clean_data()`
    函数返回的值相同。
- en: To do this, we need to set up the source and run this code, and this may be
    a problem. One of the golden rules of unit testing is that *anything that crosses
    the boundaries of your application needs to be simulated* . We do not want to
    talk to a real data source, and we do not want to actually run real functions
    if they are communicating with anything that is not contained in our application.
    A few examples would be a database, a search service, an external API, or the
    filesystem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要设置源并运行此代码，这可能会成为一个问题。单元测试的黄金法则之一是*任何跨越你应用程序边界的东西都需要被模拟*。我们不想与真实的数据源交谈，我们也不想实际运行与我们的应用程序之外的任何东西通信的真实函数。一些例子包括数据库、搜索服务、外部API或文件系统。
- en: We need these restrictions to act as a shield so that we can always run our
    tests safely without the fear of destroying something in a real data source.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些限制来充当盾牌，这样我们就可以始终安全地运行测试，而不必担心在真实数据源中破坏某些东西。
- en: Another reason is that it may be quite difficult for a developer to reproduce
    the whole architecture on their machine. It may require the setting up of databases,
    APIs, services, files and folders, and so on, and this can be difficult, time-consuming,
    or sometimes not even possible.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，对于开发者来说，在他们的机器上重现整个架构可能相当困难。这可能需要设置数据库、API、服务、文件和文件夹等，这可能很困难，耗时，有时甚至不可能。
- en: Very simply put, an **API** is a set of tools for building software applications.
    An API expresses a software component in terms of its operations, input and output,
    and underlying types. For example, if you create software that needs to interface
    with a data provider service, it is likely that you will have to go through their
    API in order to gain access to the data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，**API** 是构建软件应用程序的工具集。API 以其操作、输入和输出以及底层类型来表示软件组件。例如，如果你创建的软件需要与数据提供者服务接口，那么你很可能需要通过他们的API来获取数据。
- en: Therefore, in our unit tests, we need to simulate all those things in some way.
    Unit tests need to be run by any developer without the need for the entire system
    to be set up on their machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事情。单元测试需要由任何开发者运行，而无需在他们的机器上设置整个系统。
- en: A different approach, which we favor when it is possible to do so, is to simulate
    entities not by using fake objects but by using special-purpose test objects instead.
    For example, if our code talks to a database, instead of faking all the functions
    and methods that talk to the database and programming the fake objects so that
    they return what the real ones would, we would rather spawn a test database, set
    up the tables and data we need, and then patch the connection settings so that
    our tests are running real code against the test database. This is advantageous
    because if the underlying libraries change in a way that introduces an issue in
    our code, this setup will catch this issue. A test will break. A test with mocks,
    on the other hand, will blissfully continue to run successfully, because the mocked
    interface would have no idea about the change in the underlying library. In-memory
    databases are excellent options for these cases.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不同的方法，当可能这样做时，我们更喜欢使用它，是通过使用特殊用途的测试对象而不是使用模拟对象来模拟实体。例如，如果我们的代码与数据库进行通信，而不是模拟所有与数据库通信的函数和方法，并编程模拟对象使其返回真实对象的结果，我们宁愿创建一个测试数据库，设置我们需要的表和数据，然后修补连接设置，以便我们的测试在测试数据库上运行真实代码。这样做的好处是，如果底层库发生变化，引入了我们的代码中的问题，这种设置将捕获这个问题。一个测试将失败。另一方面，使用模拟的测试将无忧无虑地继续成功运行，因为模拟的接口将不会了解底层库的变化。内存数据库是这些情况下的绝佳选择。
- en: One of the applications that allows you to spawn a database for testing is Django.
    Within the `django.test` package, you can find several tools that help you write
    tests so that you won’t have to simulate the dialog with a database. By writing
    tests this way, you will also be able to check on transactions, encodings, and
    all other database-related aspects of programming. Another advantage of this approach
    consists of the ability to check against details that can change from one database
    to another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您为测试创建数据库的应用之一是Django。在`django.test`包中，您可以找到几个工具，这些工具可以帮助您编写测试，这样您就无需模拟与数据库的对话。通过这种方式编写测试，您还可以检查事务、编码以及编程的所有其他数据库相关方面。这种方法的另一个优点是能够检查可能从一个数据库到另一个数据库发生变化的细节。
- en: Sometimes, though, it is still not possible. For example, when the software
    interfaces with an API, and there is no test version of that API, we would need
    to simulate that API using fakes. In reality, most of the time we end up having
    to use a hybrid approach, where we use a test version of those technologies that
    allow this approach, and we use fakes for everything else. Let us now talk about
    fakes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，尽管如此，仍然无法实现。例如，当软件与API接口交互，而该API没有测试版本时，我们需要使用模拟来模拟该API。实际上，大多数情况下，我们最终不得不采用混合方法，即使用允许这种方法的技术的测试版本，而对于其他所有内容则使用模拟。现在让我们来谈谈模拟。
- en: Mock objects and patching
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟对象和修补
- en: First of all, in Python, these fake objects are called **mocks** . Up to version
    3.3, the `mock` library was a third-party library that basically every project
    would install via pip but, from version 3.3, it has been included in the standard
    library under the `unittest` module, and rightfully so, given its importance and
    how widespread it is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Python中，这些模拟对象被称为**模拟**。直到版本3.3，`mock`库是一个第三方库，基本上每个项目都会通过pip安装，但从版本3.3开始，它已被包含在标准库的`unittest`模块中，这是合理的，考虑到其重要性和普及程度。
- en: The act of replacing a real object or function (or in general, any piece of
    data structure) with a `mock` is called **patching** . The `mock` library provides
    the `patch` tool, which can act as a function or class decorator, and even as
    a context manager that you can use to `mock` things out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用`mock`替换真实对象或函数（或一般而言，任何数据结构）的行为被称为**修补**。`mock`库提供了`patch`工具，它可以作为函数或类装饰器，甚至可以作为上下文管理器，您可以使用它来模拟事物。
- en: Assertions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: The verification phase is done through the use of assertions. In most cases,
    an **assertion** is a function or method that you can use to verify equality between
    objects, as well as other conditions. When a condition is not met, the assertion
    will raise an exception that will cause the test to fail. You can find a list
    of assertions in the `unittest` module documentation; however, when using `pytest`
    , you will typically use the generic `assert` statement, which makes things even
    simpler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 验证阶段是通过使用断言来完成的。在大多数情况下，断言是一个可以用来验证对象之间相等性以及其他条件的函数或方法。当条件不满足时，断言将引发一个异常，这将导致测试失败。你可以在`unittest`模块的文档中找到一个断言列表；然而，当使用`pytest`时，你通常会使用通用的`assert`语句，这使得事情变得更加简单。
- en: Testing a CSV generator
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试CSV生成器
- en: Let us now adopt a practical approach. We will show you how to test a small
    piece of code, and we will touch on the rest of the important concepts around
    unit testing within the context of this example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在采取一种实际的方法。我们将向您展示如何测试一小段代码，并且我们将在这个示例的背景下涉及单元测试的其他重要概念。
- en: 'We want to write an `export()` function that does the following: it takes a
    list of dictionaries, each of which represents a user. It creates a **comma-separated
    values** ( **CSV** ) file, puts a header in it, and then proceeds to add all the
    users who are deemed valid according to some rules. The function will take three
    parameters: the list of user dictionaries, the name of the CSV file to create,
    and an indication of whether an existing file with the same name should be overwritten.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个`export()`函数，它执行以下操作：接收一个字典列表，每个字典代表一个用户。它创建一个**逗号分隔值**（**CSV**）文件，在其中放置一个标题，然后继续添加根据某些规则被认为是有效的所有用户。该函数将接受三个参数：用户字典列表、要创建的CSV文件名以及一个指示是否应该覆盖具有相同名称的现有文件的标志。
- en: 'To be considered valid, and added to the output file, a user dictionary must
    satisfy the following requirements: each user must have at least an email, a name,
    and an age. There can also be a fourth field representing the role, but it is
    optional. The user’s email address needs to be valid, the name needs to be non-empty,
    and the age must be an integer between 18 and 65.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要被认为是有效的并添加到输出文件中，用户字典必须满足以下要求：每个用户必须至少有一个电子邮件、一个姓名和一个年龄。还可以有一个表示角色的第四个字段，但这不是必需的。用户的电子邮件地址必须是有效的，姓名不能为空，年龄必须在18到65岁之间。
- en: 'This is our task; so, now we are going to show you the code, and then we are
    going to analyze the tests we wrote for it. But, first things first, in the following
    code snippets, we will be using two third-party libraries: `marshmallow` and `pytest`
    . They are both in the requirements of the chapter’s source code, so please make
    sure you have installed them with pip.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的任务；因此，现在我们将向您展示代码，然后我们将分析为其编写的测试。但是，首先，在以下代码片段中，我们将使用两个第三方库：`marshmallow`和`pytest`。它们都包含在该章节源代码的要求中，所以请确保您已经使用pip安装了它们。
- en: '`marshmallow` ( [https://marshmallow.readthedocs.io/](https://marshmallow.readthedocs.io/)
    ) is a library that provides us with the ability to serialize (or *dump* , in
    `marshmallow` terminology) and deserialize (or *load* , in `marshmallow` terminology)
    objects and, most importantly, gives us the ability to define a schema that we
    can use to validate a user dictionary. We will see another library that is used
    to create schemas, `pydantic` , in *Chapter 14* , *Introduction to API Development*
    .'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`marshmallow`（[https://marshmallow.readthedocs.io/](https://marshmallow.readthedocs.io/)）是一个库，它为我们提供了序列化（或`marshmallow`术语中的*dump*）和反序列化（或`marshmallow`术语中的*load*）对象的能力，最重要的是，它为我们提供了定义模式的能力，我们可以使用该模式来验证用户字典。我们将在*第14章*，*API开发简介*中看到另一个用于创建模式的库，`pydantic`。'
- en: '`pytest` ( [https://docs.pytest.org/](https://docs.pytest.org/) ) is one of
    the best pieces of software we have ever seen. It is used almost everywhere and
    has replaced other libraries, such as *nose* . It provides us with useful tools
    to write tests quite efficiently.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`（[https://docs.pytest.org/](https://docs.pytest.org/)）是我们所见过的最好的软件之一。它几乎被用于所有地方，并取代了其他库，如*nose*。它为我们提供了编写测试的有用工具，效率很高。'
- en: 'Let us get to the code. We called it `api.py` just because it exposes a function
    that we can use to export the CSV. We will show it to you in chunks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看代码。我们将其命名为`api.py`仅仅是因为它暴露了一个我们可以用来导出CSV的函数。我们将分块向您展示：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first part is where we import all that we need ( `Path` , `csv` , `deepcopy`
    , and some tools from `marshmallow)` , and then we define the schema for the users.
    As you can see, we inherit from `marshmallow.Schema` , and then we set four fields.
    Notice we are using two string fields ( `Str` ), an `Email` , and an integer (
    `Int` ). These will already provide us with some validation from `marshmallow`
    . Notice there is no `required=True` in the `role` field.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是我们导入所有需要的模块（`Path`、`csv`、`deepcopy` 以及来自 `marshmallow` 的一些工具），然后我们定义用户的模式。正如你所见，我们继承自
    `marshmallow.Schema`，然后设置四个字段。注意我们使用了两个字符串字段（`Str`），一个 `Email` 字段和一个整数（`Int`）。这些将已经为我们提供了一些来自
    `marshmallow` 的验证。注意在 `role` 字段中没有 `required=True`。
- en: We need to add a couple of custom bits of code, though. We need to add validation
    on `age` to make sure the value is within the range we want. `marshmallow` will
    raise `ValidationError` if it is not. It will also take care of raising an error
    should we pass anything but an integer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还需要添加一些自定义的代码。我们需要在 `age` 上添加验证以确保值在我们想要的范围内。如果它不是，`marshmallow` 将抛出
    `ValidationError`。它还会处理如果我们传递的不是整数时抛出错误。
- en: We also add validation on `name` , because the fact that there is a `name` key
    in a dictionary does not guarantee that the value of that name is non-empty. We
    validate that the length of the field’s value is at least one. Notice we do not
    need to add anything for the `email` field. This is because `marshmallow` will
    validate it for us.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对 `name` 字段添加了验证，因为字典中存在 `name` 键并不保证该名称的值不为空。我们验证字段值的长度至少为一位。注意我们不需要为 `email`
    字段添加任何内容。这是因为 `marshmallow` 会为我们验证它。
- en: After the field declarations, we write another method, `strip_name()` , which
    is decorated with the `pre_load()` `marshmallow` helper. This method will run
    before `marshmallow` deserializes (loads) the data. As you can see, we make a
    copy of `data` first, as in this context it is not a good idea to work directly
    on a mutable object, and then make sure we strip leading and trailing spaces away
    from `data['name']` . That key represents the name field we just declared above.
    We make sure we do this within a `try` / `except` block, so deserialization can
    run smoothly even in case of errors. The method returns the modified copy of `data`
    , and `marshmallow` does the rest.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段声明之后，我们编写了另一个方法，`strip_name()`，该方法被 `pre_load()` `marshmallow` 辅助器装饰。这个方法将在
    `marshmallow` 反序列化（加载）数据之前运行。正如你所见，我们首先复制 `data`，因为在当前上下文中直接在可变对象上工作不是一个好主意，然后确保从
    `data['name']` 中移除前导和尾随空格。这个键代表我们刚才声明的名称字段。我们确保在 `try` / `except` 块中这样做，这样即使在出现错误的情况下，反序列化也可以顺利运行。该方法返回修改后的数据副本，而
    `marshmallow` 执行剩余的操作。
- en: 'We then instantiate `schema` , so that we can use it to validate data. So,
    let us write the `export` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后实例化 `schema`，以便我们可以用它来验证数据。因此，让我们编写 `export` 函数：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you see, its logic is straightforward. If `overwrite` is `False` and the
    file already exists, we raise `IOError` with a message saying the file already
    exists. Otherwise, if we can proceed, we simply get the list of valid users and
    feed it to `write_csv()` , which is responsible for actually doing the job. Let
    us see how all these functions are defined:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，其逻辑非常直接。如果 `overwrite` 为 `False` 且文件已存在，我们将抛出带有文件已存在信息的 `IOError`。否则，如果我们可以继续进行，我们只需获取有效用户的列表并将其传递给
    `write_csv()`，该函数负责实际执行工作。让我们看看所有这些函数是如何定义的：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We coded `get_valid_users()` as a generator, as there is no need to make a potentially
    big list before writing to a file. We can validate and save them one by one. The
    `is_valid()` function simply delegates to `marshmallow` 's `schema.validate()`
    to validate the user. This method returns a dictionary, which is empty if the
    data is valid according to the schema or else it will contain error information.
    We do not need to collect the error information for this task, so we simply ignore
    it, and the `is_valid()` function simply returns `True` if the return value from
    `schema.validate()` is empty, or `False` otherwise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `get_valid_users()` 编码为一个生成器，因为在写入文件之前没有必要创建一个可能很大的列表。我们可以逐个验证和保存它们。`is_valid()`
    函数简单地委托给 `marshmallow` 的 `schema.validate()` 来验证用户。此方法返回一个字典，如果数据根据模式有效则为空，否则将包含错误信息。我们不需要收集错误信息来完成这项任务，所以我们简单地忽略它，而
    `is_valid()` 函数如果 `schema.validate()` 的返回值为空，则简单地返回 `True`，否则返回 `False`。
- en: 'The final piece of code in this module is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块中的最后一部分代码是：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, the logic is straightforward. We define the header in `fieldnames` ,
    then we open `filename` for writing, and we specify `newline=""` , which is recommended
    in the documentation for CSV files. When the file has been created, we get a `writer`
    object by using the `csv.DictWriter` class. This tool maps the user dictionaries
    to the field names, so we do not need to take care of the ordering.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，逻辑非常直接。我们在`fieldnames`中定义了表头，然后打开`filename`进行写入，并指定`newline=""`，这在CSV文件的文档中被推荐使用。当文件创建完成后，我们通过使用`csv.DictWriter`类来获取一个`writer`对象。这个工具将用户字典映射到字段名，因此我们不需要关心顺序。
- en: We write the header first, and then we loop over the users and add them one
    by one. Notice that this function assumes it is fed a list of valid users, and
    it may break if that assumption is false (with the default values, it would break
    if any user dictionary had extra fields).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先写入表头，然后遍历用户并逐个添加。请注意，这个函数假设传入的是一个有效的用户列表，如果这个假设不成立（使用默认值时，如果任何用户字典有额外的字段，它可能会中断）。
- en: That’s the code you should try and keep in mind. We suggest you spend a moment
    going through it again. There is no need to memorize it, and the fact that we
    have used small helper functions with meaningful names will enable you to follow
    the testing more easily.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该尝试记住的代码。我们建议你花点时间再次过一遍。没有必要去记忆它，而且我们使用了具有有意义名称的小辅助函数，这将使你更容易地跟踪测试。
- en: 'Let us now get to the interesting part: testing the `export()` function. Once
    again, we will show you the code in chunks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨有趣的部分：测试`export()`函数。我们再次将代码分块展示：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let us start with the imports: first, we import the `re` module from the standard
    library, as it’s needed in one of the tests. Then, we bring in some tools from
    `unittest.mock` , then `pytest` , and, finally, we fetch the three functions that
    we want to actually test: `is_valid()` , `export()` , and `write_csv()` .'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始：首先，我们从标准库中导入`re`模块，因为其中一个测试需要它。然后，我们引入`unittest.mock`中的某些工具，接着是`pytest`，最后，我们获取我们想要实际测试的三个函数：`is_valid()`、`export()`和`write_csv()`。
- en: 'Before we can write tests, though, we need to make a few fixtures. As you will
    see, a **fixture** in `pytest` is a function decorated with the `pytest.fixture`
    decorator. Fixtures are run before each test to which they are applied. In most
    cases, we expect a fixture to return something so that we can use it in a test.
    We have some requirements for a user dictionary, so let us write a couple of users:
    one with minimal requirements, and one with full requirements. Both need to be
    valid. Here is the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以编写测试之前，我们需要做一些固定装置。正如你将看到的，`pytest`中的**固定装置**是一个用`pytest.fixture`装饰器装饰的函数。固定装置在应用它们的每个测试之前运行。在大多数情况下，我们期望固定装置返回一些内容，这样我们就可以在测试中使用它。我们对用户字典有一些要求，所以让我们写几个用户：一个具有最小要求，另一个具有完整要求。两者都需要是有效的。以下是代码：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the only difference between the users is the presence of the
    `role` key, but it should be enough to show you the point.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户之间的唯一区别是`role`键的存在，但这应该足以说明问题。
- en: Notice that instead of simply declaring dictionaries at a module level, we have
    actually written two functions that return a dictionary, and we have decorated
    them with the `@pytest.fixture` decorator. This is because when you declare a
    dictionary that is supposed to be used in your tests at the module level, you
    need to make sure you copy it at the beginning of every test. If you do not, and
    any of the tests (or the code being tested) modify it, all the following tests
    might be compromised, as the dictionary would not be in its original form. By
    using these fixtures, `pytest` will give us a new dictionary for every test, so
    we do not need to go through that copy procedure. This helps to respect the principle
    of independence, which says that each test should be self-contained and independent.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有在模块级别简单地声明字典，而是实际上编写了两个返回字典的函数，并用`@pytest.fixture`装饰器进行了装饰。这是因为当你需要在模块级别声明用于测试的字典时，你需要确保在每个测试的开始处复制它。如果你不这样做，并且任何测试（或被测试的代码）修改了它，那么所有后续的测试可能会受到影响，因为字典将不会保持其原始形式。通过使用这些固定装置，`pytest`将为每个测试提供一个新字典，因此我们不需要进行复制过程。这有助于遵守独立性原则，即每个测试应该是自包含和独立的。
- en: 'Fixtures are also *composable* , which means they can be used in one another,
    which is a useful feature of `pytest` . To show you this, let us write a fixture
    for a list of users, in which we put the two we already have, plus one that would
    fail validation because it has no age. Let us take a look at the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 固定值也是*可组合的*，这意味着它们可以相互使用，这是 `pytest` 的一个有用特性。为了展示这一点，让我们为用户列表编写一个固定值，我们将放入我们已有的两个，再加上一个没有年龄将无法通过验证的用户。让我们看一下以下代码：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have two users that we can use individually, and we also have a list
    of three users.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个用户可以使用，我们还有一个包含三个用户的列表。
- en: The first few tests will test how we validate a user. We will group all the
    tests for this task within a class. This helps to give related tests a namespace,
    a place to be. As we will see later, it also allows us to declare class-level
    fixtures, which are defined just for the tests belonging to the class. One of
    the benefits of declaring a fixture at a class level is that you can easily override
    one with the same name that lives outside the scope of the class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个测试将测试我们如何验证用户。我们将为此任务将所有测试分组在一个类中。这有助于为相关测试提供一个命名空间，一个存放的地方。正如我们稍后将会看到的，这也允许我们声明类级别的固定值，这些固定值仅针对属于该类的测试定义。声明类级别固定值的一个好处是，你可以轻松地覆盖一个与类作用域外同名的内容。
- en: Although, in this case, we found it convenient to organize our tests in classes,
    you can also just have tests defined at the module level. `pytest` allows for
    great flexibility in the way tests are structured.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这种情况下，我们发现按类组织测试很方便，但你也可以只在模块级别定义测试。`pytest` 允许在测试结构方面具有很大的灵活性。
- en: Moreover, you will notice, as we walk you through the examples, that the name
    of each test function starts with `test_` and that of each test class starts with
    `Test` . This is to allow `pytest` to discover these functions and classes and
    consider them as tests. Please refer to the pytest documentation to learn the
    full specifications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将注意到，当我们引导你通过示例时，每个测试函数的名称都以 `test_` 开头，每个测试类的名称都以 `Test` 开头。这是为了让 `pytest`
    发现这些函数和类，并将它们视为测试。请参阅 `pytest` 文档以了解完整的规范。
- en: 'Let us come back to our code now. Take a look at the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码。看一下以下内容：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We start very simply by making sure our fixtures actually pass validation. This
    helps ensure that our code will correctly validate users that we know to be valid,
    with minimal as well as full data. Notice that we gave each test function a parameter
    matching the name of a fixture. This has the effect of activating the fixture
    for that test. When `pytest` runs the tests, it will inspect the parameters of
    each test and pass the return values of the corresponding fixture functions as
    arguments to the test.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从确保我们的固定值确实通过验证开始，这有助于确保我们的代码能够正确验证已知有效的用户，无论是最小数据还是完整数据。请注意，我们给每个测试函数提供了一个与固定值名称匹配的参数。这会激活该测试的固定值。当
    `pytest` 运行测试时，它将检查每个测试的参数，并将相应固定值函数的返回值作为参数传递给测试。
- en: 'Before we proceed, it would be good to run these two tests, just to make sure
    everything is wired up correctly. To run the tests, we invoke the `pytest` command
    in the shell, from the `ch10` folder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，运行这两个测试以确保一切连接正确会是个好主意。要运行测试，我们在 `ch10` 文件夹的壳中调用 `pytest` 命令：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have instructed the command to search for tests in the `tests` folder. Moreover,
    to show you the full details, we have invoked it with the verbose flag ( `-vv`
    ).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示命令在 `tests` 文件夹中搜索测试。此外，为了展示详细信息，我们使用详细标志（ `-vv` ）调用了它。
- en: After a bit of boilerplate, we find two lines that we highlighted. They represent
    the full path to each of the tests that ran. First, the name of the module where
    the tests live, then in this case, the name of the class in which they are defined,
    and finally their names.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些样板代码之后，我们发现了两行被高亮的代码。它们代表了运行的所有测试的完整路径。首先，是包含测试的模块名称，然后在这个例子中，是定义它们的类名称，最后是它们的名称。
- en: On the right, you can see the progression, indicated as a percentage. In this
    case, we only have two tests for now, so after running the first one, we have
    completed 50% of the test suite, and 100% after the second one. They both passed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，你可以看到进度，以百分比表示。在这种情况下，我们现在只有两个测试，所以在运行第一个测试后，我们已经完成了测试套件的50%，在运行第二个测试后完成100%。它们都通过了。
- en: 'Should any of the tests fail, `pytest` would print an error and some debug
    information, so we can inspect what is wrong and fix it. Let us simulate a failure
    by removing the `name` key from the `min_user` fixture and running the tests again:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何测试失败，`pytest` 会打印错误和一些调试信息，这样我们就可以检查哪里出了问题并修复它。让我们通过从 `min_user` 固定值中移除
    `name` 键并再次运行测试来模拟一个失败：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the highlighted sections, `pytest` reports which tests failed,
    and a snippet of the code where the failure happened, so we can inspect it and
    discover what the problem is. On the left-hand side of the snippet, there is a
    `>` sign, which indicates the line that threw the error, and underneath, two lines
    representing the error itself, which in this case is that `{''age'': 18, ''email'':
    ''minimal@example.com''}` is not a valid user.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '如您在突出显示的部分所见，`pytest` 会报告哪些测试失败了，以及发生失败的地方的代码片段，这样我们就可以检查它并发现问题所在。在代码片段的左侧有一个
    `>` 符号，它表示抛出错误的行，下面是两行代表错误本身，在这个例子中是 `{''age'': 18, ''email'': ''minimal@example.com''}`
    不是一个有效的用户。'
- en: Now that we know how to run tests, please feel free to run them any time you
    want. A good practice when we run tests is to make sure that they would fail if
    something was wrong, so feel free to play around with the fixtures and the assertions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何运行测试，请随时运行它们。当我们运行测试时，一个好的做法是确保如果有什么问题，它们会失败，所以请随意玩弄固定值和断言。
- en: Let us go back to the test suite now. The next task is to test the age. To do
    that, we are going to use parametrization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到测试套件。下一个任务是测试年龄。为了做到这一点，我们将使用参数化。
- en: '**Parametrization** is a technique that enables us to run the same test multiple
    times but feed different data to it. It is quite useful as it allows us to write
    the test only once with no repetition, and the result will be intelligently handled
    by `pytest` , which will run all those tests as if they were actually separate,
    thus providing us with clear error messages when they fail. Another solution would
    be to write one test with a `for` loop inside that runs through all the pieces
    of data we want to test against. The latter solution is of much lower quality
    though, as the framework won’t be able to give you specific information as if
    you were running separate tests. Moreover, should any of the `for` loop iterations
    fail, there would be no information about what would have happened after that,
    as subsequent iterations will not happen. Finally, the body of the test would
    get more difficult to understand, due to the `for` loop extra logic. Therefore,
    parametrization is a far superior choice for this use case.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数化**是一种技术，使我们能够多次运行相同的测试，但向它提供不同的数据。它非常有用，因为它允许我们只写一次测试，没有重复，并且结果将由 `pytest`
    智能处理，它将像实际单独运行那样运行所有这些测试，当它们失败时，会提供清晰的错误信息。另一个解决方案是在一个包含 `for` 循环的测试中运行我们想要测试的所有数据，但后者质量要低得多，因为框架无法提供像单独运行测试那样的具体信息。此外，如果
    `for` 循环的任何迭代失败，将没有关于之后会发生什么的信息，因为后续迭代将不会发生。最后，由于 `for` 循环的额外逻辑，测试的主体将更难以理解。因此，参数化对于这个用例来说是一个更好的选择。'
- en: 'It also spares us from having to write a bunch of almost identical tests to
    exhaust all possible scenarios. Let us see how we test the age (we are repeating
    the class signature for you, but omitting the tests that have already been presented):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使我们免于编写大量几乎相同的测试来穷尽所有可能的场景。让我们看看我们如何测试年龄（我们正在为您重复类签名，但省略了已经展示过的测试）：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start by writing a test to check that validation fails when the user is too
    young. According to our rule, a user is too young when they are younger than 18.
    We check for every age between 0 and 17 by using `range()` .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个测试来检查当用户年龄太小时验证失败。根据我们的规则，当用户年龄小于18岁时，他们年龄太小。我们通过使用 `range()` 来检查0到17岁之间的每个年龄。
- en: If you look at how the parametrization works, you see that we declare the name
    of an object and `age` and then we specify which values this object will take.
    The test will be run once for each of the specified values. In the case of this
    first test, the values are all those returned by `range(18)` , which means all
    integer numbers from 0 to 17 are included. Note that we also add an `age` parameter
    to the test. The values specified in the parameterization will be passed as arguments
    to the test through this parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看参数化是如何工作的，你会看到我们声明了一个对象的名字和 `age`，然后我们指定这个对象将取哪些值。测试将针对每个指定的值运行一次。在这个第一个测试中，值是
    `range(18)` 返回的所有值，这意味着包括从0到17的所有整数。注意，我们还向测试添加了一个 `age` 参数。参数化中指定的值将通过这个参数传递给测试。
- en: We also use the `min_user()` fixture in this test. In this case, we change the
    `age` within the `min_user()` dictionary, and then we verify that the result of
    `is_valid(min_user)` is `False` . We do this by asserting the fact that `not False`
    is `True` . In `pytest` , this is how you check for something. You simply assert
    that something is truthy. If that is the case, the test has succeeded. Should
    it instead be the opposite, the test will fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在这个测试中使用了 `min_user()` 固定值。在这种情况下，我们在 `min_user()` 字典中更改 `age`，然后验证 `is_valid(min_user)`
    的结果是 `False`。我们通过断言 `not False` 是 `True` 来做到这一点。在 `pytest` 中，这就是检查某个条件的方法。你只需断言某个条件是真实的。如果是这样，测试就成功了。如果相反，测试将失败。
- en: Note that `pytest` will re-evaluate the fixture function for each test run that
    uses it, so we are free to modify the fixture data within the test without affecting
    any other tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`pytest` 将为使用它的每个测试运行重新评估固定值函数，因此我们可以在测试中修改固定值数据，而不会影响其他任何测试。
- en: 'Let us proceed and add all the tests needed to make validation fail on the
    age:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加所有必要的测试，以便在年龄上使验证失败：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another two tests. One takes care of the other end of the spectrum, from 66
    years of age to 99. The second one instead makes sure that age is invalid when
    it is not an integer number, so we pass some values, such as a string, a float,
    and `None` , just to make sure. Notice how the structure of these tests is all
    the same, but, thanks to the parametrization, we feed different input arguments
    to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个测试。一个处理从66岁到99岁的另一端，第二个确保当年龄不是整数时，年龄无效。因此，我们传递一些值，例如字符串、浮点数和 `None`，以确保这一点。注意，这些测试的结构都是相同的，但多亏了参数化，我们向它提供了不同的输入参数。
- en: 'Now that we have the age-failing logic sorted out, let us add a test that checks
    when age is within the valid range:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了年龄失败的逻辑，让我们添加一个测试来检查年龄是否在有效范围内：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is as easy as that. We pass the correct range, from 18 to 65, and remove
    the `not` in the assertion.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。我们传递正确的范围，从18到65岁，并在断言中移除 `not`。
- en: 'We can consider the age as being taken care of. Let us move on to write tests
    on mandatory fields:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将年龄视为已处理。让我们继续编写关于必填字段的测试：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These three tests still belong to the same class. The first one tests whether
    a user is invalid when one of the mandatory fields is missing. Remember that at
    every test run, the `min_user` fixture is restored, so we only have one missing
    field per test run, which is the appropriate way to check for mandatory fields.
    We simply remove that one key from the dictionary. This time, the parametrization
    object takes the name `field` , and, by looking at the first test, you see all
    the mandatory fields in the parametrization decorator: `email` , `name` , and
    `age` .'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个测试仍然属于同一个类。第一个测试检查当必填字段之一缺失时，用户是否无效。记住，在每次测试运行时，`min_user` 固定值都会被恢复，所以我们每次测试运行只有一个缺失的字段，这是检查必填字段的正确方式。我们只需从字典中移除那个键。这次，参数化对象取名为
    `field`，通过查看第一个测试，你可以在参数化装饰器中看到所有必填字段：`email`、`name` 和 `age`。
- en: In the second one, things are a little different. Instead of removing keys,
    we simply set them (one at a time) to the empty string. Finally, in the third
    one, we check for the name to be made of whitespace only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，事情略有不同。我们不是移除键，而是简单地（逐个）将它们设置为空字符串。最后，在第三个测试中，我们检查名称是否只由空白字符组成。
- en: 'The previous tests take care of mandatory fields being there and being non-empty,
    and of the formatting around the `name` key of a user. Let us now write the last
    two tests for this class. We want to check that email is valid, and in the second
    one, the type for email, name, and role:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试确保了必填字段存在且非空，以及用户`name`键周围的格式。现在让我们为这个类编写最后两个测试。我们想要检查电子邮件是否有效，在第二个测试中，检查电子邮件、姓名和角色的类型：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time, the parametrization is slightly more complex. We define two objects
    ( `email` and `outcome` ) and then we pass a list of tuples, instead of a simple
    list, to the decorator. Each time the test is run, one of those tuples will be
    unpacked to fill the values of `email` and `outcome` , respectively. This allows
    us to write one test for both valid and invalid email addresses, instead of two
    separate ones. We define an email address, and we specify the outcome we expect
    from validation. The first four are invalid email addresses, and the last three
    are valid. We have used a couple of examples with non-ASCII characters, just to
    make sure we are not forgetting to include our friends from all over the world
    in the validation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，参数化稍微复杂一些。我们定义了两个对象（`email`和`outcome`），然后我们向装饰器传递一个元组列表，而不是一个简单的列表。每次运行测试时，这些元组中的一个将被解包以填充`email`和`outcome`的值。这允许我们为有效的和无效的电子邮件地址编写一个测试，而不是两个单独的测试。我们定义了一个电子邮件地址，并指定了验证预期的结果。前四个是无效的电子邮件地址，最后三个是有效的。我们使用了一些非ASCII字符的例子，只是为了确保我们没有忘记在验证中包括来自世界各地的朋友们。
- en: Notice how the validation is done, asserting that the result of the call needs
    to match the outcome we have set.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意验证是如何进行的，断言调用结果需要与我们设定的结果相匹配。
- en: 'Let us now write a simple test to make sure validation fails when we feed the
    wrong type to the fields (again, the age has been taken care of separately before):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们写一个简单的测试来确保当我们向字段提供错误类型时验证会失败（再次强调，年龄在之前已经单独处理过了）：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we did before, we pass three different values, none of which is actually
    a string. This test could be expanded to include more values, but, honestly, we
    shouldn’t need to write tests such as this one. We have included it here just
    to show you what’s possible, but normally you would focus on making sure the code
    considers valid types, those that have to be considered valid, and that should
    be enough.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们传递了三个不同的值，其中没有一个实际上是字符串。这个测试可以扩展以包含更多的值，但老实说，我们不应该需要编写这样的测试。我们在这里包含它只是为了展示什么是可能的，但通常你只会关注确保代码考虑了有效的类型，那些必须被认为是有效的类型，这应该就足够了。
- en: Before we move to the next test class, let us take a moment to talk a bit more
    about something we briefly touched on when testing the age.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移动到下一个测试类之前，让我们花点时间谈谈我们在测试年龄时简要提到的事情。
- en: Boundaries and granularity
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界和粒度
- en: 'While checking for the age, we wrote three tests to cover the three ranges:
    0-17 (fail), 18-65 (success), and 66-99 (fail). Why did we do this? The answer
    lies in the fact that we are dealing with two boundaries: 18 and 65. So, our testing
    needs to focus on the three regions those two boundaries define: before 18, within
    18 and 65, and after 65. How you do it is not important, as long as you make sure
    you test the boundaries correctly. This means if someone changes the validation
    in the schema from `18 <= value <= 65` to `18 <= value < 65` (notice the second
    `<=` is now `<` ), there must be a test that fails on 65.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查年龄时，我们编写了三个测试来覆盖三个范围：0-17（失败）、18-65（成功）和66-99（失败）。我们为什么这样做？答案在于我们正在处理两个边界：18和65。因此，我们的测试需要集中在这两个边界定义的三个区域：18之前、18和65之间以及65之后。你如何做不重要，只要确保你正确地测试了边界。这意味着如果有人将模式中的验证从`18
    <= value <= 65`更改为`18 <= value < 65`（注意第二个`<=`现在变成了`<`），那么在65上必须有一个失败的测试。
- en: This concept is known as a **boundary** , and it is crucial that you recognize
    them in your code so that you can test against them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念被称为**边界**，你必须在代码中识别它们，以便可以针对它们进行测试。
- en: Another important thing is to understand how close to the boundaries to get.
    In other words, which unit should I use to approach them?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是要理解我们离边界有多近。换句话说，我应该使用哪个单位来接近它们？
- en: In the case of age, we are dealing with integers, so a unit of 1 will be the
    perfect choice (which is why we used 16, 17, 18, 19, 20, ...). But what if you
    were testing for a timestamp? Well, in that case, the correct granularity will
    likely be different. If the code has to act differently according to your timestamp
    and that timestamp represents seconds, then the granularity of your tests should
    zoom down to seconds. If the timestamp represents years, then years should be
    the unit you use. We hope you get the picture. This concept is known as **granularity**
    and needs to be combined with that of boundaries so that by going around the boundaries
    with the correct granularity, you can make sure your tests are not leaving anything
    to chance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在年龄的情况下，我们处理整数，因此单位为 1 将是完美的选择（这就是为什么我们使用了 16、17、18、19、20 等）。但是，如果你正在测试时间戳呢？在这种情况下，正确的粒度可能不同。如果代码必须根据你的时间戳以不同的方式执行，并且该时间戳代表秒，那么你的测试的粒度应该缩小到秒。如果时间戳代表年，那么你应该使用年作为单位。我们希望你能理解这一点。这个概念被称为
    **粒度**，需要与边界概念相结合，这样通过以正确的粒度绕过边界，你可以确保你的测试没有留下任何偶然性。
- en: Let us now continue with our example and test the `export` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的例子，并测试 `export` 函数。
- en: Testing the export function
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试导出函数
- en: 'In the same test module, we defined another class that represents a test suite
    for the `export()` function. Here it is:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个测试模块中，我们定义了另一个类，它代表 `export()` 函数的测试套件。下面是它：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let us start by analyzing the fixtures. We have defined them at the class level
    this time, which means they will be available for the tests in the same class.
    We do not need these fixtures outside of this class, so it does not make sense
    to declare them at a module level as we did with the user ones.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分析设置函数。这次我们在类级别定义了它们，这意味着它们将可用于同一类中的测试。我们不需要在这个类之外使用这些设置函数，所以没有必要像用户设置函数那样在模块级别声明它们。
- en: We need two files. If you recall what we wrote at the beginning of this chapter,
    when it comes to interaction with databases, disks, networks, and so on, we should
    `mock` everything out. However, when possible, we prefer to use a different technique.
    In this case, we will employ temporary folders, which will be created and deleted
    within the fixture. We are much happier if we can avoid mocking. To create temporary
    folders, we employ the `tmp_path` fixture, from `pytest` , which is a `pathlib.Path`
    object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个文件。如果你还记得本章开头我们写的内容，当涉及到与数据库、磁盘、网络等交互时，我们应该模拟一切。然而，当可能时，我们更喜欢使用不同的技术。在这种情况下，我们将使用临时文件夹，这些文件夹将在设置函数中创建和删除。如果我们能够避免模拟，我们会更加高兴。为了创建临时文件夹，我们使用来自
    `pytest` 的 `tmp_path` 设置函数，它是一个 `pathlib.Path` 对象。
- en: The first fixture, `csv_file()` , provides a reference to a temporary folder.
    We can consider the logic up to and including the `yield` as the setup phase.
    The fixture itself, in terms of data, is represented by the temporary filename.
    The file itself does not exist yet. When a test runs, the fixture is created,
    and at the end of the test, the rest of the fixture code (the part after `yield`
    , if any) is executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个设置函数 `csv_file()` 提供了对一个临时文件夹的引用。我们可以将直到并包括 `yield` 的逻辑视为设置阶段。就数据而言，设置函数本身由临时文件名表示。该文件本身尚不存在。当测试运行时，设置函数被创建，并在测试结束时，执行设置函数的其余代码（如果有
    `yield` 之后的部分）。
- en: That part can be considered the teardown phase. In the case of the `csv_file()`
    fixture, it consists of calling `csv_path.unlink()` to delete the `.csv` file
    (if it exists). You can put much more in each phase of any fixture, and with experience,
    you will master the art of doing setup and teardown this way. It comes naturally
    quite quickly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分可以被视为拆卸阶段。在 `csv_file()` 设置函数的情况下，它包括调用 `csv_path.unlink()` 来删除 `.csv` 文件（如果存在）。你可以在任何设置函数的每个阶段放入更多内容，并且随着经验的积累，你将掌握以这种方式进行设置和拆卸的艺术。这会很快变得自然而然。
- en: It is not strictly necessary to delete the `.csv` file after each test. The
    `tmp_path` fixture will create a new temporary directory for each test, so there
    is no risk of files created within this directory interfering with other tests.
    We chose to delete the file in this fixture only to demonstrate the use of `yield`
    in fixtures.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试后严格来说没有必要删除 `.csv` 文件。`tmp_path` 设置函数将为每个测试创建一个新的临时目录，因此不存在在此目录中创建的文件干扰其他测试的风险。我们选择在这个设置函数中删除文件只是为了演示在设置函数中使用
    `yield` 的用法。
- en: The second fixture, `existing_file()` , is quite similar to the first one, but
    we will use it to test that we can prevent overwriting when we call `export()`
    with `overwrite=False` . So, we create a file in the temporary folder, and we
    put some content into it, just to have the means to verify it hasn’t been touched.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个固定值`existing_file()`与第一个类似，但我们将使用它来测试当我们用`overwrite=False`调用`export()`时，我们能否防止覆盖。因此，我们在临时文件夹中创建了一个文件，并放入了一些内容，只是为了有验证它没有被修改的手段。
- en: 'Let us now see the tests (as we did before, we include the class declaration
    but omit tests which we already presented):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看测试（就像我们之前做的那样，我们包括类声明但省略了已经展示过的测试）：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test employs the `users()` and `csv_file()` fixtures, and immediately calls
    `export()` with them. We expect that a file has been created, and populated with
    the two valid users we have (remember the list contains three users, but one is
    invalid).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用了`users()`和`csv_file()`固定值，并立即用它们调用`export()`。我们期望创建了一个文件，并填充了我们拥有的两个有效用户（记住列表中有三个用户，但有一个是无效的）。
- en: To verify that, we open the temporary file and collect all its text into a string.
    We then compare the content of the file with what we expect to be in it. Notice
    we only put the header, and the two valid users, in the correct order.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们打开临时文件，将其所有文本收集到一个字符串中。然后我们比较文件的内容与我们期望的内容。注意我们只放上了标题和两个有效的用户，并且顺序正确。
- en: 'Now we need another test to make sure that if there is a comma in one of the
    values, our CSV is still generated correctly. Being a **CSV** file, we need to
    make sure that a comma in the data does not break things up:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要另一个测试来确保如果其中一个值中有逗号，我们的CSV仍然可以正确生成。作为一个**CSV**文件，我们需要确保数据中的逗号不会破坏结构：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, we do not need the whole users list; we just need one, as we are
    testing a specific thing and we have the previous test to make sure we are generating
    the file correctly with all the users. Remember, always try to minimize the work
    you do within a test.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不需要整个用户列表；我们只需要一个，因为我们正在测试一个特定的事情，我们已经有之前的测试来确保我们能够正确地生成包含所有用户的文件。记住，总是尽量在测试中减少你的工作量。
- en: So, we use `min_user()` and put a comma in its name. We then repeat the procedure,
    which is similar to that of the previous test, and finally, we make sure that
    the name is put in the CSV file surrounded by double quotes. This is enough for
    any good CSV parser to understand that they should not break the comma inside
    the double quotes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`min_user()`并在其名称中加逗号。然后我们重复之前的程序，这和之前的测试类似，最后，我们确保名称被放在CSV文件的双引号内。这对任何好的CSV解析器来说都足够理解，它们不应该在双引号内断开逗号。
- en: 'Now, we want one more test, to check that when the file already exists and
    we do not want to override it, our code won’t do that:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还想进行另一个测试，以确保当文件已经存在而我们不想覆盖它时，我们的代码不会这样做：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an interesting test because it allows us to show you how you can tell
    `pytest` that you expect a function call to raise an exception. We do it in the
    context manager given to us by `pytest.raises()` , to which we feed the exception
    we expect from the call we make inside the body of that context manager. If the
    exception is not raised, the test will fail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的测试，因为它允许我们向您展示如何告诉`pytest`您期望一个函数调用抛出异常。我们在`pytest.raises()`提供的上下文中这样做，我们将我们期望从上下文管理器体内进行的调用中获得的异常提供给它。如果异常没有被引发，测试将失败。
- en: We like to be thorough in our tests, so we do not want to stop there. We also
    assert on the message, by using the convenient `err.match()` helper. Notice that
    we do not need to use an `assert` statement when calling `err.match()` . If the
    argument does not match, the call will raise an `AssertionError` , causing the
    test to fail. We also need to escape the string version of `existing_file` because
    on Windows, paths have backslashes, which would confuse the regular expression
    we feed to `err.match()` .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢在测试中做到彻底，所以不想就此停止。我们还通过使用方便的`err.match()`辅助函数对消息进行断言。注意，在调用`err.match()`时，我们不需要使用`assert`语句。如果参数不匹配，调用将引发`AssertionError`，导致测试失败。我们还需要转义`existing_file`的字符串版本，因为在Windows上，路径有反斜杠，这会混淆我们提供给`err.match()`的正则表达式。
- en: Finally, we make sure that the file still contains its original content (which
    is why we created the `existing_file()` fixture) by reading it and comparing its
    content to the string we originally wrote to the file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过读取文件并比较其内容与最初写入文件中的字符串来确保文件仍然包含其原始内容（这就是为什么我们创建了`existing_file()`固定值）。
- en: Final considerations
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终考虑
- en: Before we move on to the next topic, let us wrap up with some considerations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，让我们总结一些考虑因素。
- en: First, we hope you have noticed that we haven’t tested all the functions we
    wrote. Specifically, we didn’t test `get_valid_users()` , `validate()` , and `write_csv()`
    . The reason is that these functions are already implicitly tested by our test
    suite. We have tested `is_valid()` and `export()` , which is more than enough
    to make sure the schema is validating users correctly, and that the `export()`
    function is filtering out invalid users, respecting existing files when needed,
    and writing a proper CSV. The functions we haven’t tested are the internals; they
    provide logic that participates in doing something that we have thoroughly tested
    anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望你已经注意到我们没有测试我们编写的所有函数。具体来说，我们没有测试`get_valid_users()`、`validate()`和`write_csv()`。原因是这些函数已经被我们的测试套件隐式测试了。我们已经测试了`is_valid()`和`export()`，这已经足够确保模式正确验证用户，并且`export()`函数在需要时过滤掉无效用户，尊重现有文件，并正确写入CSV。我们没有测试的函数是内部函数；它们提供参与执行我们已经彻底测试过的某些操作的逻辑。
- en: Would adding extra tests for those functions be good or bad? The answer is actually
    difficult.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为那些函数添加额外的测试是好事还是坏事？答案实际上很难。
- en: The more we test, the less easily we can refactor that code. As it is now, we
    could easily decide to rename `validate()` , and we wouldn’t have to change any
    of the tests we wrote. If you think about it, it makes sense, because as long
    as `validate()` provides correct validation to the `get_valid_users()` function,
    we do not really need to know about it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试得越多，就越难重构那段代码。就目前而言，我们可以很容易地决定重命名`validate()`，而且我们不需要更改我们编写的任何测试。如果你这么想，这是有道理的，因为只要`validate()`为`get_valid_users()`函数提供正确的验证，我们就真的不需要了解它。
- en: If, instead, we had written tests for the `validate()` function, then we would
    have to change them, had we decided to rename it (or to change its signature,
    for example).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`validate()`函数编写了测试，那么如果我们决定重命名它（或更改其签名，例如），我们就必须更改这些测试。
- en: So, what is the right thing to do? Tests or no tests? It will be up to you.
    You have to find the right balance. Our personal take on this matter is that everything
    needs to be thoroughly tested, either directly or indirectly. We try to write
    the smallest possible test suite that guarantees that. This way, we will have
    a complete test suite in terms of coverage, but not any bigger than necessary.
    We need to maintain those tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，正确的事情是什么？测试还是不测试？这取决于你。你必须找到正确的平衡。我们个人对这个问题的看法是，一切都需要彻底测试，无论是直接还是间接。我们试图编写尽可能小的测试套件，以确保这一点。这样，我们将拥有一个在覆盖率方面的完整测试套件，但不会比必要的更大。我们需要维护这些测试。
- en: We hope this example made sense to you; we think it has allowed us to touch
    on the important topics.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个例子对你来说是有意义的；我们认为它使我们能够触及重要的主题。
- en: If you check out the source code for the book, in the `test_api.py` module,
    you will find a couple of extra test classes that will show you how different
    testing would have been had we decided to go all the way with the mocks. Make
    sure you read that code and understand it well. It is quite straightforward and
    will offer you a good comparison with the approach we have shown you here.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这本书的源代码，在`test_api.py`模块中，你会找到几个额外的测试类，它们会向你展示如果我们决定完全使用模拟进行测试，测试会有何不同。确保你阅读并充分理解那段代码。它相当直接，并且会为你提供一个与我们在这里展示的方法的良好比较。
- en: 'Let us now run the full test suite:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行完整的测试套件：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned before, make sure you run `$ pytest test` from within the `ch10`
    folder (add the `-vv` flag for a verbose output that will show you how parametrization
    modifies the names of your tests). `pytest` scans your files and folders, searching
    for modules that start or end with `test_` , like `test_*.py` or `*_test.py` .
    Within those modules, it grabs `test` -prefixed functions or `test` -prefixed
    methods inside `Test` -prefixed classes (you can read the full specification in
    the `pytest` documentation). As you can see, 132 tests were run in 140 milliseconds,
    and they all succeeded. We strongly suggest you check out this code and experiment
    with it. Change something in the code and see whether any test fails. Understand
    why it fails (or does not).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，请确保您在`ch10`文件夹内运行`$ pytest test`（添加`-vv`标志以获得详细输出，这将显示参数化如何修改测试名称）。`pytest`会扫描您的文件和文件夹，寻找以`test_`开头或结尾的模块，如`test_*.py`或`*_test.py`。在这些模块中，它会获取以`test`为前缀的函数或`Test`为前缀的类中的`test`为前缀的方法（您可以在`pytest`文档中阅读完整的规范）。如您所见，132个测试在140毫秒内完成，并且全部成功。我们强烈建议您检查此代码并对其进行实验。在代码中更改一些内容，看看是否有测试失败。理解为什么它失败了（或没有）。
- en: Did the tests pass even though the code is no longer correct? Are the tests
    too rigid and failing even when you make a change that does not affect the correctness
    of the output? Thinking about these questions will help you gain a deeper insight
    into the art of testing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码不再正确，测试是否仍然通过？测试是否过于严格，即使你做出不影响输出正确性的更改，测试也会失败？思考这些问题将帮助您更深入地了解测试的艺术。
- en: We also suggest you study the `unittest` module, and the `pytest` library too.
    These are tools you will use all the time, so you need to be familiar with them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议您学习`unittest`模块，以及`pytest`库。这些是您将经常使用的工具，因此您需要熟悉它们。
- en: Let us now discuss TDD.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论TDD。
- en: Test-driven development
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Let us talk briefly about **TDD** . It is a methodology that was rediscovered
    by Kent Beck, who wrote *Test-Driven Development by Example, Addison Wesley, 2002*
    , which we encourage you to read if you want to learn about the fundamentals of
    this subject.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈**TDD**。这是一种由Kent Beck重新发现的方法论，他写了《通过示例进行测试驱动开发，Addison Wesley，2002》，我们鼓励您阅读这本书，如果您想了解这个主题的基础知识。
- en: TDD is a software development methodology that is based on the continuous repetition
    of a very short development cycle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种基于非常短的开发周期持续重复的软件开发方法。
- en: First, the developer writes a test and makes it run. The test is supposed to
    check a feature that is not yet part of the code. Maybe it is a new feature to
    be added or something to be removed or amended. Running the test will make it
    fail and, because of this, this phase is called **Red** .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，开发者编写一个测试并运行它。这个测试应该检查尚未成为代码一部分的功能。可能是一个要添加的新功能，或者是要删除或修改的内容。运行测试将使其失败，因此这个阶段被称为**红色**。
- en: The developer then writes the minimal amount of code to make the test pass.
    When the test run succeeds, we have the so-called **Green** phase. In this phase,
    it is okay to write code that cheats, just to make the test pass. This technique
    is called *fake it ‘til you make it* . In a second iteration of the TDD cycle,
    tests are enriched with different edge cases, and if there is any cheating code,
    it will not be able to satisfy all the tests simultaneously, therefore the developer
    will have to write the actual logic that satisfies the tests. Adding other test
    cases is sometimes called **triangulation** .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开发者编写最少的代码以使测试通过。当测试运行成功时，我们就有了所谓的**绿色**阶段。在这个阶段，可以编写一些欺骗性的代码，只是为了使测试通过。这种技术被称为*fake
    it ‘til you make it*。在TDD周期的第二次迭代中，测试会添加不同的边缘情况，如果有任何欺骗性代码，它将无法同时满足所有测试，因此开发者必须编写满足测试的实际逻辑。添加其他测试案例有时被称为**三角测量**。
- en: The last piece of the cycle is where the developer takes care of refactoring
    code and tests until they are in the desired state. This last phase is called
    **Refactor** .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的最后一部分是开发者负责重构代码和测试，直到它们达到期望的状态。这个最后阶段被称为**重构**。
- en: The TDD mantra therefore is **Red-Green-Refactor** .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TDD的咒语是**红色-绿色-重构**。
- en: At first, it might feel weird to write tests before the code, and we must confess
    it took us a while to get used to it. If you stick to it, though, and force yourself
    to learn this slightly counterintuitive method, at some point, something almost
    magical happens, and you will see the quality of your code increase in a way that
    would not have been possible otherwise.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，在编写代码之前编写测试可能会感觉有些奇怪，我们必须承认我们花了很长时间才习惯这种方式。但是，如果你坚持下去，并强迫自己学习这种稍微有些反直觉的方法，在某个时刻，几乎会发生某种神奇的事情，你将看到代码质量以其他方式不可能实现的方式提高。
- en: When we write our code before the tests, we must take care of *what* the code
    has to do and *how* it has to do it, both at the same time. On the other hand,
    when we write tests before the code, we can concentrate on the *what* part almost
    exclusively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在测试之前编写代码时，我们必须同时关注代码需要做什么以及如何做。另一方面，当我们先编写测试再编写代码时，我们可以几乎完全专注于“是什么”的部分。
- en: Afterward, when we write the code, we will mostly have to take care of *how*
    the code has to implement *what* is required by the tests. This shift in focus
    allows our minds to concentrate on the *what* and *how* parts separately, yielding
    a brainpower boost that can feel quite surprising.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们编写代码时，我们主要需要关注代码如何实现测试所要求的内容。这种关注点的转变使得我们的思维可以分别专注于“是什么”和“如何做”的部分，从而产生一种令人惊讶的脑力提升。
- en: 'There are several other benefits that come from the adoption of this technique:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种技术还有其他一些好处：
- en: '**Improved code quality** : Writing tests first ensures that the codebase is
    thoroughly tested and can lead to fewer bugs and errors in the production code.
    It encourages developers to write only the code necessary to pass tests, which
    can result in cleaner, simpler code.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：首先编写测试确保代码库得到彻底测试，可以导致生产代码中更少的错误和错误。它鼓励开发者只编写通过测试所必需的代码，这可能导致更干净、更简单的代码。'
- en: '**Better design decisions** : TDD encourages developers to think about the
    design and structure of the code from the beginning. This early consideration
    can lead to better software design and architecture.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的设计决策**：TDD鼓励开发者从一开始就考虑代码的设计和结构。这种早期的考虑可以导致更好的软件设计和架构。'
- en: '**Facilitates refactoring** : With a comprehensive suite of tests in place,
    developers can confidently refactor and improve the code, knowing that the tests
    will catch any regressions or issues introduced by changes.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进重构**：有了全面的测试套件，开发者可以自信地进行重构和改进代码，因为他们知道测试将捕捉到任何由更改引入的回归或问题。'
- en: '**Documentation** : The tests themselves serve as documentation for the codebase.
    They describe what the code is supposed to do, which can be helpful for new team
    members or when revisiting old code.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：测试本身就是代码库的文档。它们描述了代码应该做什么，这有助于新团队成员或回顾旧代码时。'
- en: '**Reduces time spent on debugging** : By catching errors early in the development
    process, TDD can reduce the amount of time developers spend debugging code.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少调试时间**：通过在开发过程中早期捕捉错误，TDD可以减少开发者调试代码所花费的时间。'
- en: '**Better understanding of business requirements** : Having a suite of tests
    that pass gives developers confidence that their code meets the required specifications
    and behaves as expected.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的业务需求理解**：有一套通过测试的测试套件可以让开发者有信心，他们的代码符合所需的规范，并且按预期行为。'
- en: 'On the other hand, there are some shortcomings of this technique:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种技术也有一些缺点：
- en: '**Initial slowdown** : Writing tests before writing functional code can slow
    down the initial development process. This can be particularly challenging in
    fast-paced development environments or for tight deadlines.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始减速**：在编写功能代码之前编写测试可能会减缓初始的开发过程。这在快速发展的开发环境或紧迫的截止日期下尤其具有挑战性。'
- en: '**Learning curve** : TDD requires a different mindset and approach to coding
    than what many developers are accustomed to. There can be a significant learning
    curve, and developers may initially find it difficult to write effective tests.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：TDD（测试驱动开发）需要与许多开发者习惯的编程思维和方式有所不同。学习曲线可能会很陡峭，开发者最初可能会发现编写有效的测试比较困难。'
- en: '**Overhead for simple changes** : For very simple changes or fixes, the overhead
    of writing a test first can seem unnecessary and time-consuming.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单更改的额外开销**：对于非常简单的更改或修复，编写测试的第一步可能会显得不必要且耗时。'
- en: '**Difficulty with complex UI or external systems** : Testing can become challenging
    when dealing with complex UIs or interactions with external systems, databases,
    or APIs. Mocking and stubbing can help, but they also add complexity and maintenance
    overhead.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂 UI 或外部系统困难**：当处理复杂的 UI 或与外部系统、数据库或 API 的交互时，测试可能会变得具有挑战性。模拟和存根可能会有所帮助，但它们也增加了复杂性和维护开销。'
- en: We are quite passionate about TDD. However, through years of application, we
    have encountered scenarios where TDD proves to be less feasible. A prime example
    is when faced with test suites comprising hundreds or even thousands of tests.
    In such instances, predetermining the specific tests to alter for a desired change
    in the source code becomes an almost insurmountable task. It may, at times, be
    more pragmatic to directly modify the code and observe which tests fail as a result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 TDD 非常热情。然而，经过多年的应用，我们遇到了一些情况，TDD 证明不太可行。一个典型的例子是面对包含数百甚至数千个测试用例的测试套件。在这种情况下，预先确定要更改以实现源代码中所需更改的具体测试几乎是一项无法克服的任务。有时，直接修改代码并观察哪些测试失败可能更为实际。
- en: Nonetheless, we maintain a firm belief in the value of mastering TDD. While
    the most significant advantages of TDD may lie in its educational merits rather
    than its practical application, the knowledge and mindset it instills are invaluable.
    Mastering TDD to the extent that it can be applied efficiently leaves an indelible
    mark on our coding practices, influencing our approach even in projects where
    TDD is not utilized.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然坚信掌握 TDD 的价值。虽然 TDD 的最大优势可能在于其教育意义而不是其实际应用，但它所传授的知识和心态是无价的。将 TDD 掌握到可以高效应用的程度，在我们的编码实践中留下了不可磨灭的印记，即使在那些不使用
    TDD 的项目中，它也影响着我们的方法。
- en: 'It is essential, therefore, to bear in mind the following principle: always
    rigorously test your code. This practice is fundamental to ensuring the reliability
    and integrity of software, regardless of the development methodology employed.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，牢记以下原则至关重要：始终严格测试您的代码。这种做法对于确保软件的可靠性和完整性至关重要，无论采用何种开发方法。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of testing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试的世界。
- en: We tried to give you a fairly comprehensive overview of testing, especially
    unit testing, which is the most common type of testing a developer does. We hope
    we have succeeded in conveying the message that testing is not something that
    is perfectly defined and that you can learn from a book. You need to experiment
    with it for a significant amount of time before you get comfortable. Of all the
    efforts a coder must make in terms of study and experimentation, we would say
    testing is amongst the most important.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图为您提供关于测试的相当全面的概述，特别是单元测试，这是开发者最常进行的测试类型。我们希望我们已经成功地传达了这样一个信息：测试并不是一个完美定义的东西，你可以从书中学习。在感到舒适之前，你需要花相当长的时间去实验。在所有关于学习和实验的努力中，我们认为测试是最重要的之一。
- en: In the next chapter, we are going to explore debugging and profiling, which
    are techniques that go hand in hand with testing. You should make sure you learn
    them well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨调试和性能分析，这些技术与测试密切相关。您应该确保您能很好地掌握它们。
- en: Join our community on Discord
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_10.xhtml)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_10.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
