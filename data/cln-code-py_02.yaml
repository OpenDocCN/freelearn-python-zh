- en: Pythonic Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonic代码
- en: In this chapter, we will explore the way ideas are expressed in Python, with
    its own particularities. If you are familiar with the standard ways of accomplishing
    some tasks in programming (such as getting the last element of a list, iterating,
    searching, and so on), or if you come from more traditional programming languages
    (like C, C++, and Java), then you will find that, in general, Python provides
    its own mechanism for most common tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索在Python中表达观念的方式，以及它自己的特点。如果您熟悉编程中一些任务的标准完成方式（例如获取列表的最后一个元素，迭代，搜索等），或者如果您来自更传统的编程语言（如C、C++和Java），那么您将发现，总的来说，Python为大多数常见任务提供了自己的机制。
- en: In programming, an idiom is a particular way of writing code in order to perform
    a specific task. It is something common that repeats and follows the same structure
    every time. Some could even argue and call them a pattern, but be careful because
    they are not designed patterns (which we will explore later on). The main difference
    is that design patterns are high-level ideas, independent from the language (sort
    of), but they do not translate into code immediately. On the other hand, idioms
    are actually coded. It is the way things should be written when we want to perform
    a particular task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，成语是为了执行特定任务而编写代码的一种特定方式。它是一种常见的重复出现并且每次都遵循相同结构的东西。有些人甚至可能争论并称它们为一种模式，但要小心，因为它们不是设计模式（我们稍后将探讨）。主要区别在于设计模式是高级别的想法，独立于语言（在某种程度上），但它们不能立即转化为代码。另一方面，成语实际上是编码的。这是我们想要执行特定任务时应该编写的方式。
- en: As idioms are code, they are language dependent. Every language will have its
    own idioms, which means the way things are done in that particular language (for
    example, how you would open and write a file in C, C++, and so on). When the code
    follows these idioms, it is known as being idiomatic, which in Python is often
    referred to as **Pythonic**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成语是代码，因此它们是与语言相关的。每种语言都有自己的习语，这意味着在该特定语言中完成任务的方式（例如，在C、C++等语言中如何打开和写入文件）。当代码遵循这些习语时，它被称为成语化，而在Python中通常被称为**Pythonic**。
- en: There are multiple reasons to follow these recommendations and write Pythonic
    code first (as we will see and analyze), writing code in an idiomatic way usually
    performs better. It is also more compact and easier to understand. These are traits
    that we always want in our code so that it works effectively. Secondly, as introduced
    in the previous chapter, it is important that the entire development team can
    get used to the same patterns and structure of the code because this will help
    them focus on the true essence of the problem, and will help them avoid making
    mistakes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因要遵循这些建议并首先编写Pythonic代码（我们将看到并分析），以成语化的方式编写代码通常性能更好。它也更紧凑，更容易理解。这些都是我们希望在代码中始终具备的特征，以使其有效运行。其次，正如在上一章中介绍的，整个开发团队能够习惯相同的代码模式和结构非常重要，因为这将帮助他们专注于问题的真正本质，并帮助他们避免犯错。
- en: 'The goals of this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand indices and slices, and correctly implement objects that can be
    indexed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解索引和切片，并正确实现可以进行索引的对象
- en: To implement sequences and other iterables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现序列和其他可迭代对象
- en: To learn good use cases for context managers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习上下文管理器的良好使用案例
- en: To implement more idiomatic code through magic methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过魔术方法实现更成语化的代码
- en: To avoid common mistakes in Python that lead to undesired side-effects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免导致不良副作用的Python常见错误
- en: Indexes and slices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片
- en: In Python, as in other languages, some data structures or types support accessing
    its elements by index. Another thing it has in common with most programming languages
    is that the first element is placed in the index number zero. However, unlike
    those languages, when we want to access the elements in a different order than
    usual, Python provides extra features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，在Python中，一些数据结构或类型支持通过索引访问其元素。它与大多数编程语言共有的另一点是，第一个元素位于索引号零。然而，与那些语言不同的是，当我们想以与通常不同的顺序访问元素时，Python提供了额外的功能。
- en: 'For example, how would you access the last element of an array in C? This is
    something I did the first time I tried Python. Thinking the same way as in C,
    I would get the element in the position of the length of the array minus one.
    This could work, but we could also use a negative index number, which will start
    counting from the last, as shown in the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在C语言中，如何访问数组的最后一个元素？这是我第一次尝试Python时做的事情。以与C语言相同的方式思考，我会得到数组长度减一的位置的元素。这可能有效，但我们也可以使用负索引号，它将从最后开始计数，如下面的命令所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to getting just one element, we can obtain many by using `slice`,
    as shown in the following commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取单个元素外，我们还可以使用`slice`获取多个元素，如下面的命令所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the syntax on the square brackets means that we get all of the
    elements on the tuple, starting from the index of the first number (inclusive),
    up to the index on the second one (not including it). Slices work this way in
    Python by excluding the end of the selected interval.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，方括号中的语法意味着我们获取元组中的所有元素，从第一个数字的索引开始（包括该索引），直到第二个数字的索引（不包括该索引）。在Python中，切片的工作方式是通过排除所选区间的末尾来实现的。
- en: 'You can exclude either one of the intervals, start or stop, and in that case,
    it will act from the beginning or end of the sequence, respectively, as shown
    in the following commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以排除间隔的任一端点，开始或停止，这种情况下，它将分别从序列的开头或结尾起作用，如下面的命令所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first example, it will get everything up to the index in the position
    number `3`. In the second example, it will get all the numbers from the position
    `3` (inclusive), up to the end. In the second to last example, where both ends
    are excluded, it is actually creating a copy of the original tuple.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，它将获取到索引位置号为`3`的所有内容。在第二个示例中，它将获取从位置`3`（包括）开始到末尾的所有数字。在倒数第二个示例中，两端都被排除，实际上是创建了原始元组的副本。
- en: The last example includes a third parameter, which is the step. This indicates
    how many elements to jump when iterating over the interval. In this case, it would
    mean to get the elements between the positions one and seven, jumping by two.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子包括第三个参数，即步长。这表示在迭代间隔时要跳过多少个元素。在这种情况下，它意味着获取位置为一和七之间的元素，每两个跳一次。
- en: 'In all of these cases, when we pass intervals to a sequence, what is actually
    happening is that we are passing `slice`. Note that `slice` is a built-in object
    in Python that you can build yourself and pass directly:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，当我们将间隔传递给一个序列时，实际上发生的是我们传递了`slice`。注意，`slice`是Python中的一个内置对象，你可以自己构建并直接传递：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that when one of the elements is missing (start, stop, or step), it is
    considered to be none.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当元素中的一个缺失（开始、停止或步长），它被认为是无。
- en: You should always prefer to use this built-in syntax for slices, as opposed
    to manually trying to iterate the tuple, string, or list inside a `for` loop,
    excluding the elements by hand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终优先使用这种内置的切片语法，而不是手动尝试在`for`循环中迭代元组、字符串或列表，手动排除元素。
- en: Creating your own sequences
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的序列
- en: The functionality we just discussed works thanks to a magic method called `__getitem__`.
    This is the method that is called, when something like `myobject[key]` is called,
    passing the key (value inside the square brackets) as a parameter. A sequence,
    in particular, is an object that implements both `__getitem__` and `__len__`,
    and for this reason, it can be iterated over. Lists, tuples, and strings are examples
    of sequence objects in the standard library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的功能得益于一个叫做`__getitem__`的魔术方法。当像`myobject[key]`这样的东西被调用时，传递键（方括号内的值）作为参数调用这个方法。特别是，序列是一个实现了`__getitem__`和`__len__`的对象，因此它可以被迭代。列表、元组和字符串是标准库中序列对象的例子。
- en: In this section, we care more about getting particular elements from an object
    by a key than building sequences or iterable objects, which is a topic explored
    in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using Generators*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们更关心通过关键字从对象中获取特定元素，而不是构建序列或可迭代对象，这是[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中探讨的主题，*使用生成器*。
- en: If you are going to implement `__getitem__` in a custom class in your domain,
    you will have to take into account some considerations in order to follow a Pythonic
    approach.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要在你的领域的自定义类中实现`__getitem__`，你将不得不考虑一些问题，以便遵循Pythonic的方法。
- en: 'In the case that your class is a wrapper around a standard library object,
    you might as well delegate the behavior as much as possible to the underlying
    object. This means that if your class is actually a wrapper on the list, call
    all of the same methods on that list to make sure that it remains compatible.
    In the following listing, we can see an example of how an object wraps a list,
    and for the methods we are interested in, we just delegate to its corresponding
    version on the `list` object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类是标准库对象的包装器，你可能会尽可能地将行为委托给底层对象。这意味着如果你的类实际上是列表的包装器，调用列表上的所有相同方法，以确保它保持兼容。在下面的列表中，我们可以看到一个对象如何包装一个列表的例子，对于我们感兴趣的方法，我们只是委托给`list`对象上对应的版本：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example uses encapsulation. Another way of doing it is through inheritance,
    in which case we will have to extend the `collections.UserList` base class, with
    the considerations and caveats mentioned in the last part of this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了封装。另一种方法是通过继承，这种情况下，我们将不得不扩展`collections.UserList`基类，考虑到本章的最后部分提到的注意事项和警告。
- en: 'If, however, you are implementing your own sequence, that is not a wrapper
    or does not rely on any built-in object underneath, then keep in mind the following
    points:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在实现自己的序列，而不是一个包装器或不依赖于任何内置对象，那么请记住以下几点：
- en: When indexing by a range, the result should be an instance of the same type
    of the class
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过范围进行索引时，结果应该是与类的相同类型的实例
- en: In the range provided by the `slice`, respect the semantics that Python uses,
    excluding the element at the end
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`slice`提供的范围内，遵守Python使用的语义，排除末尾的元素
- en: 'The first point is a subtle error. Think about it—when you get `slice` of a
    list, the result is a list; when you ask for a range in a tuple, the result is
    a tuple; and when you ask for a substring, the result is a string. It makes sense
    in each case that the result is of the same type of the original object. If you
    are creating, let''s say, an object that represents an interval of dates, and
    you ask for a range on that interval, it would be a mistake to return a list or
    tuple, and many more. Instead, it should return a new instance of the same class
    with the new interval set. The best example of this is in the standard library,
    with the range function. Previously, in Python 2, the `range` function used to
    build a list. Now, if you call `range` with an interval, it will construct an
    iterable object that knows how to produce the values in the selected range. When
    you specify an interval for range, you get a new range (which makes sense), not
    a list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是一个微妙的错误。想想看——当你得到一个列表的`slice`时，结果是一个列表；当你在元组中请求一个范围时，结果是一个元组；当你请求一个子字符串时，结果是一个字符串。在每种情况下，结果与原始对象的类型相同是有道理的。如果你正在创建一个表示日期间隔的对象，并且你在该间隔上请求一个范围，返回一个列表或元组等都是错误的。相反，它应该返回一个设置了新间隔的相同类的新实例。最好的例子是在标准库中的`range`函数。在Python
    2中，`range`函数用于构建一个列表。现在，如果你用一个间隔调用`range`，它将构造一个可迭代的对象，知道如何产生所选范围内的值。当你为range指定一个间隔时，你得到一个新的range（这是有道理的），而不是一个列表：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second rule is also about consistency—users of your code will find it more
    familiar and easier to use if it is consistent with Python itself. As Python developers,
    we are already used to the idea of how the slices work, how the `range` function
    works, and so on. Making an exception on a custom class will create confusion,
    which means that it will be harder to remember and it might lead to bugs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则也是关于一致性 - 代码的用户会发现如果与Python本身保持一致，那么使用起来更加熟悉和容易。作为Python开发人员，我们已经习惯了切片的工作方式，`range`函数的工作方式等。对自定义类做出异常会造成混乱，这意味着更难记住，可能导致错误。
- en: Context managers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Context managers are a distinctively useful feature that Python provides. The
    reason why they are so useful is that they correctly respond to a pattern. The
    pattern is actually every situation where we want to run some code, and has preconditions
    and postconditions, meaning that we want to run things before and after a certain
    main action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是Python提供的一个非常有用的特性。它们之所以如此有用的原因是它们正确地响应了一种模式。这种模式实际上是我们想要运行一些代码的每种情况，并且具有前置条件和后置条件，这意味着我们想在某个主要操作之前和之后运行一些东西。
- en: Most of the time, we see context managers around resource management. For example,
    on situations when we open files, we want to make sure that they are closed after
    processing (so we do not leak file descriptors), or if we open a connection to
    a service (or even a socket), we also want to be sure to close it accordingly,
    or when removing temporary files, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在资源管理周围看到上下文管理器。例如，在打开文件时，我们希望在处理后确保它们被关闭（这样我们就不会泄漏文件描述符），或者如果我们打开到服务（甚至是套接字）的连接，我们也希望相应地关闭它，或者在删除临时文件时等等。
- en: 'In all of these cases, you would normally have to remember to free all of the
    resources that were allocated and that is just thinking about the best case—but
    what about exceptions and error handling? Given the fact that handling all possible
    combinations and execution paths of our program makes it harder to debug, the
    most common way of addressing this issue is to put the cleanup code on a `finally`
    block so that we are sure we do not miss it. For example, a very simple case would
    look like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，通常需要记住释放分配的所有资源，这只是考虑最佳情况，但是异常和错误处理呢？考虑到处理程序的所有可能组合和执行路径会使调试变得更加困难，解决这个问题的最常见方法是将清理代码放在`finally`块中，以确保不会遗漏它。例如，一个非常简单的情况看起来像下面这样：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Nonetheless, there is a much elegant and Pythonic way of achieving the same
    thing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一种更加优雅和Pythonic的方法来实现相同的功能：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `with` statement (PEP-343) enters the context manager. In this case, the
    `open` function implements the context manager protocol, which means that the
    file will be automatically closed when the block is finished, even if an exception
    occurred.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句（PEP-343）进入上下文管理器。在这种情况下，`open`函数实现了上下文管理器协议，这意味着文件将在块完成时自动关闭，即使发生异常也是如此。'
- en: 'Context managers consist of two magic methods: `__enter__` and `__exit__`.
    On the first line of the context manager, the `with` statement will call the first
    method, `__enter__`, and whatever this method returns will be assigned to the
    variable labeled after `as`. This is optional—we don''t really need to return
    anything specific on the `__enter__` method, and even if we do, there is still
    no strict reason to assign it to a variable if it is not required.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器由两个魔术方法组成：`__enter__`和`__exit__`。在上下文管理器的第一行，`with`语句将调用第一个方法`__enter__`，并且无论这个方法返回什么都将被分配给`as`后面标记的变量。这是可选的
    - 我们不真的需要在`__enter__`方法上返回任何特定的东西，即使我们这样做了，如果不需要，也没有严格的理由将其分配给一个变量。
- en: After this line is executed, the code enters a new context, where any other
    Python code can be run. After the last statement on that block is finished, the
    context will be exited, meaning that Python will call the `__exit__` method of
    the original context manager object we first invoked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这行之后，代码进入一个新的上下文，可以运行任何其他Python代码。在该块上的最后一条语句完成后，上下文将被退出，这意味着Python将调用我们首先调用的原始上下文管理器对象的`__exit__`方法。
- en: If there is an exception or error inside the context manager block, the `__exit__`
    method will still be called, which makes it convenient for safely managing cleaning
    up conditions. In fact, this method receives the exception that was triggered
    on the block in case we want to handle it in a custom fashion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上下文管理器块内部发生异常或错误，`__exit__`方法仍然会被调用，这使得安全地管理清理条件变得方便。实际上，如果我们想以自定义方式处理，这个方法会接收在块上触发的异常。
- en: Despite the fact that context managers are very often found when dealing with
    resources (like the example we mentioned with files, connections, and so on),
    this is not the sole application they have. We can implement our own context managers
    in order to handle the particular logic we need.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上下文管理器在处理资源时经常出现（比如我们提到的文件、连接等示例），但这并不是它们唯一的应用。我们可以实现自己的上下文管理器来处理我们需要的特定逻辑。
- en: Context managers are a good way of separating concerns and isolating parts of
    the code that should be kept independent, because if we mix them, then the logic
    will become harder to maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是分离关注点和隔离应该保持独立的代码部分的好方法，因为如果我们混合它们，那么逻辑将变得更难以维护。
- en: 'As an example, consider a situation where we want to run a backup of our database
    with a script. The caveat is that the backup is offline, which means that we can
    only do it while the database is not running, and for this we have to stop it.
    After running the backup, we want to make sure that we start the process again,
    regardless of how the process of the backup itself went. Now, the first approach
    would be to create a huge monolithic function that tries to do everything in the
    same place, stop the service, perform the backup task, handle exceptions and all
    possible edge cases, and then try to restart the service again. You can imagine
    such a function, and for that reason, I will spare you the details, and instead
    come up directly with a possible way of tackling this issue with context managers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑这样一种情况：我们想要用一个脚本对数据库进行备份。问题在于备份是离线的，这意味着只有在数据库不运行时才能进行备份，为此我们必须停止它。备份完成后，我们希望确保无论备份过程本身如何进行，我们都要重新启动该进程。现在，第一种方法是创建一个巨大的单片函数，试图在同一个地方做所有事情，停止服务，执行备份任务，处理异常和所有可能的边缘情况，然后尝试重新启动服务。你可以想象这样一个函数，因此我将省略细节，而直接提出一种可能的解决这个问题的方式，即使用上下文管理器：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we don't need the result of the context manager inside the
    block, and that's why we can consider that, at least for this particular case,
    the return value of `__enter__` is irrelevant. This is something to take into
    consideration when designing context managers—what do we need once the block is
    started? As a general rule, it should be good practice (although not mandatory),
    to always return something on the `__enter__`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要上下文管理器在块内的结果，这就是为什么我们可以认为，至少对于这种特殊情况，`__enter__`的返回值是无关紧要的。在设计上下文管理器时，这是需要考虑的事情——一旦块开始，我们需要什么？作为一个一般规则，总是在`__enter__`上返回一些东西应该是一个好的做法（尽管不是强制性的）。
- en: In this block, we only run the task for the backup, independently from the maintenance
    tasks, as we saw previously. We also mentioned that even if the backup task has
    an error, the `__exit__` will still be called.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们只运行备份任务，独立于维护任务，就像我们之前看到的那样。我们还提到，即使备份任务出现错误，`__exit__`仍然会被调用。
- en: Notice the signature of the `__exit__` method. It receives the values for the
    exception that was raised on the block. If there was no exception on the block,
    they are all none.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`__exit__`方法的签名。它接收了在块上引发的异常的值。如果块上没有异常，它们都是`None`。
- en: 'The return value of `__exit__` is something to consider. Normally, we would
    want to leave the method as it is, without returning anything in particular. If
    this method returns `True`, it means that the exception that was potentially raised;
    it will not propagate to the caller and will stop there. Sometimes, this is the
    desired effect, maybe even depending on the type of exception that was raised,
    but in general it is not a good idea to swallow the exception. Remember: errors
    should never pass silently.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__`的返回值是需要考虑的。通常，我们希望保持该方法不变，不返回任何特定的内容。如果该方法返回`True`，这意味着潜在引发的异常不会传播到调用者那里，而是在此处停止。有时，这是期望的效果，甚至可能取决于引发的异常类型，但一般来说，吞没异常并不是一个好主意。记住：错误不应该悄悄地传递。'
- en: Keep in mind not to accidentally return `True` on the `__exit__`. If you do,
    make sure that this is exactly what you want, and that there is a good reason
    for it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住不要在`__exit__`上意外返回`True`。如果你这样做了，请确保这确实是你想要的，并且有一个很好的理由。
- en: Implementing context managers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现上下文管理器
- en: In general, we can implement context managers like the one in the previous example.
    All we need is just a class that implements the `__enter__` and `__exit__` magic
    methods, and then that object will be able to support the context manager protocol.
    While this is the most common way for context managers to be implemented, it is
    not the only one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以像前面的例子一样实现上下文管理器。我们只需要一个实现`__enter__`和`__exit__`魔术方法的类，然后该对象就能支持上下文管理器协议。虽然这是实现上下文管理器最常见的方式，但并不是唯一的方式。
- en: In this section, we will see not only different (sometimes more compact) ways
    of implementing context managers but also how to take full advantage of them by
    using the standard library, in particular with the `contextlib` module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到不仅实现上下文管理器的不同（有时更紧凑）的方法，还将看到如何通过使用标准库，特别是`contextlib`模块，充分利用它们。
- en: The `contextlib` module contains a lot of helper functions and objects to either
    implement context managers or use some already provided ones that can help us
    write more compact code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextlib`模块包含了许多辅助函数和对象，可以实现上下文管理器，或者使用一些已经提供的可以帮助我们编写更紧凑代码的上下文管理器。'
- en: Let's start by looking at the `contextmanager` decorator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从看`contextmanager`装饰器开始。
- en: When the `contextlib.contextmanager` decorator is applied to a function, it
    converts the code on that function into a context manager. The function in question
    has to be a particular kind of function called a **generator** function, which
    will separate the statements into what is going to be on the `__enter__` and `__exit__` magic
    methods, respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当`contextlib.contextmanager`装饰器应用于一个函数时，它将该函数中的代码转换为上下文管理器。所涉及的函数必须是一种特殊类型的函数，称为**生成器**函数，它将语句分开成分别位于`__enter__`和`__exit__`魔术方法中的内容。
- en: If at this point you are not familiar with decorators and generators, this is
    not a problem because the examples we will be looking at will be self-contained,
    and the recipe or idiom can be applied and understood regardless. These topics
    are discussed in detail in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml),
    *Using Generators*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在对装饰器和生成器不熟悉，这并不是问题，因为我们将要看的例子是独立的，而且这个方法或习惯可以被应用和理解。这些主题在[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中有详细讨论，*使用生成器*。
- en: 'The equivalent code of the previous example can be rewritten with the `contextmanager`
    decorator like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的等价代码可以用`contextmanager`装饰器重写如下：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we define the generator function and apply the `@contextlib.contextmanager`
    decorator to it. The function contains a `yield` statement, which makes it a generator
    function. Again, details on generators are not relevant in this case. All we need
    to know is that when this decorator is applied, everything before the `yield`
    statement will be run as if it were part of the `__enter__` method. Then, the
    yielded value is going to be the result of the context manager evaluation (what
    `__enter__` would return), and what would be assigned to the variable if we chose
    to assign it like `as x:`—in this case, nothing is yielded (which means the yielded
    value will be none, implicitly), but if we wanted to, we could yield a statement
    which will become something we might want to use inside the context manager block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了生成器函数，并将`@contextlib.contextmanager`装饰器应用到它上面。该函数包含一个`yield`语句，这使它成为一个生成器函数。在这种情况下，生成器的细节并不相关。我们只需要知道，当应用这个装饰器时，`yield`语句之前的所有内容将被视为`__enter__`方法的一部分运行。然后，yield的值将成为上下文管理器评估的结果（`__enter__`将返回的内容），如果我们选择像`as
    x:`这样分配它的话，将被分配给变量——在这种情况下，没有任何yield（这意味着yield的值将是隐式的none），但如果我们想要的话，我们可以yield一个语句，这将成为我们可能想要在上下文管理器块中使用的东西。
- en: At that point, the generator function is suspended, and the context manager
    is entered, where, again, we run the backup code for our database. After this
    completes, the execution resumes, so we can consider that every line that comes
    after the `yield` statement will be part of the `__exit__` logic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一点上，生成器函数被挂起，进入上下文管理器，在那里，我们再次运行数据库的备份代码。完成后，执行恢复，因此我们可以认为`yield`语句之后的每一行都将成为`__exit__`逻辑的一部分。
- en: Writing context managers like this has the advantage that it is easier to refactor
    existing functions, reuse code, and in general is a good idea when we need a context
    manager that doesn't belong to any particular object. Adding the extra magic methods
    would make another object of our domain more coupled, with more responsibilities,
    and supporting something that it probably shouldn't. When we just need a context
    manager function, without preserving many states, and completely isolated and
    independent from the rest of our classes, this is probably a good way to go.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样编写上下文管理器的优势在于，更容易重构现有函数，重用代码，总的来说，当我们需要一个不属于任何特定对象的上下文管理器时，这是一个好主意。添加额外的魔术方法会使我们领域中的另一个对象更加耦合，责任更多，并支持一些它可能不应该支持的东西。当我们只需要一个上下文管理器函数，而不需要保留许多状态，并且完全独立于我们的其他类时，这可能是一个不错的选择。
- en: There are, however, more ways in which we can implement context manager, and
    once again, the answer is in the `contextlib` package from the standard library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以以更多的方式实现上下文管理器，再一次，答案在标准库的`contextlib`包中。
- en: Another helper we could use is `contextlib.ContextDecorator`. This is a mixin
    base class that provides the logic for applying a decorator to a function that
    will make it run inside the context manager, while the logic for the context manager
    itself has to be provided by implementing the aforementioned magic methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`contextlib.ContextDecorator`这个辅助工具。这是一个混合基类，提供了将装饰器应用到函数的逻辑，使其在上下文管理器中运行，而上下文管理器本身的逻辑必须通过实现前面提到的魔术方法来提供。
- en: 'In order to use it, we have to extend this class and implement the logic on
    the required methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们必须扩展这个类，并在所需的方法上实现逻辑：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do you notice something different from the previous examples? There is no `with`
    statement. We just have to call the function, and `offline_backup()` will automatically
    run inside a context manager. This is the logic that the base class provides to
    use it as a decorator that wraps the original function so that it runs inside
    a context manager.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到和之前的例子有什么不同了吗？这里没有`with`语句。我们只需要调用这个函数，`offline_backup()`就会自动在上下文管理器中运行。这是基类提供的逻辑，用作装饰器包装原始函数，使其在上下文管理器中运行。
- en: The only downside of this approach is that by the way the objects work, they
    are completely independent (which is a good trait)—the decorator doesn't know
    anything about the function that is decorating, and vice versa. This, however
    good, means that you cannot get an object that you would like to use inside the
    context manager (for example, assigning `with offline_backup() as bp:`), so if
    you really need to use the object returned by the `__exit__` method, one of the
    previous approaches will have to be the one of choice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是，对象完全独立运作（这是一个好特点）——装饰器对装饰的函数一无所知，反之亦然。然而，这意味着你无法获得一个你想要在上下文管理器中使用的对象（例如，分配`with
    offline_backup() as bp:`），所以如果你真的需要使用`__exit__`方法返回的对象，之前的方法将成为首选。
- en: Being a decorator, this also poses the advantage that the logic is defined only
    once, and we can reuse it as many times as we want by simply applying the decorators
    to other functions that require the same invariant logic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个装饰器，这也带来了一个优势，即逻辑只定义一次，我们可以通过简单地将装饰器应用到其他需要相同不变逻辑的函数上，来重复使用它。
- en: Let's explore one last feature of `contextlib`, to see what we can expect from
    context managers and get an idea of the sort of thing we could use them for.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`contextlib`的最后一个特性，看看我们可以从上下文管理器中期望什么，并了解我们可以用它们做什么样的事情。
- en: Note that `contextlib.suppress` is a `util` package that enters a context manager,
    which, if one of the provided exceptions is raised, doesn't fail. It's similar
    to running that same code on a `try`/`except` block and passing an exception or
    logging it, but the difference is that calling the `suppress` method makes it
    more explicit that those exceptions that are controlled as part of our logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`contextlib.suppress`是一个`util`包，它进入一个上下文管理器，如果其中一个提供的异常被触发，它不会失败。这类似于在`try`/`except`块上运行相同的代码并传递异常或记录它，但不同之处在于调用`suppress`方法更明确地表明那些作为我们逻辑一部分受控的异常。
- en: 'For example, consider the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the presence of the exception means that the input data is already in
    the expected format, so there is no need for conversion, hence making it safe
    to ignore it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，异常的存在意味着输入数据已经是预期格式，因此不需要转换，因此可以安全地忽略它。
- en: Properties, attributes, and different types of methods for objects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性、属性和对象的不同类型的方法
- en: All of the properties and functions of an object are public in Python, which
    is different from other languages where properties can be public, private, or
    protected. That is, there is no point in preventing caller objects from invoking
    any attributes an object has. This is another difference with respect to other
    programming languages in which you can mark some attributes as private or protected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对象的所有属性和函数都是公开的，这与其他语言不同，其他语言中属性可以是公共的、私有的或受保护的。也就是说，没有必要阻止调用对象调用对象具有的任何属性。这是与其他编程语言的另一个不同之处，其他编程语言可以将一些属性标记为私有或受保护。
- en: There is no strict enforcement, but there are some conventions. An attribute
    that starts with an underscore is meant to be private to that object, and we expect
    that no external agent calls it (but again, there is nothing preventing this).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 没有严格的强制，但有一些约定。以下划线开头的属性意味着它是对象的私有属性，我们期望没有外部代理调用它（但同样，没有阻止这种情况）。
- en: Before jumping into the details of properties, it's worth mentioning some traits
    of underscores in Python, understanding the convention, and the scope of attributes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解属性的细节之前，值得提到Python中下划线的一些特点，理解约定和属性的范围。
- en: Underscores in Python
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的下划线
- en: There are some conventions and implementation details that make use of underscores
    in Python, which is an interesting topic that's worthy of analysis.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有一些约定和实现细节，使用下划线是一个有趣的话题，值得分析。
- en: 'Like we mentioned previously, by default all attributes of an object are public.
    Consider the following example to illustrate this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，默认情况下，对象的所有属性都是公开的。考虑以下示例来说明这一点：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, a `Connector` object is created with `source`, and it starts with two
    attributes—the aforementioned `source` and `timeout`. The former is public, and
    the latter private. However, as we can see from the following lines when we create
    an object like this, we can actually access both of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个`Connector`对象与`source`，并且它开始有两个属性——前面提到的`source`和`timeout`。前者是公开的，后者是私有的。然而，正如我们从以下行中看到的，当我们创建这样一个对象时，我们实际上可以访问它们两个。
- en: The interpretation of this code is that `_timeout` should be accessed only within
    `connector` itself and never from a caller. This means that you should organize
    the code in a way so that you can safely refactor the timeout at all of the times
    it's needed, relying on the fact that it's not being called from outside the object
    (only internally), hence preserving the same interface as before. Complying with
    these rules makes the code easier to maintain and more robust because we don't
    have to worry about ripple effects when refactoring the code if we maintain the
    interface of the object. The same principle applies to methods as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的解释是，`_timeout`应该只在`connector`内部访问，而不是从调用者访问。这意味着你应该以一种安全的方式组织代码，以便在所有需要的时间安全地重构超时，依赖于它不是从对象外部调用（只在内部调用），因此保持与以前相同的接口。遵守这些规则使代码更容易维护，更健壮，因为我们在重构代码时不必担心连锁反应，如果我们保持对象的接口不变。同样的原则也适用于方法。
- en: Objects should only expose those attributes and methods that are relevant to
    an external caller object, namely, entailing its interface. Everything that is
    not strictly part of an object's interface should be kept prefixed with a single
    underscore.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象应该只公开对外部调用对象相关的属性和方法，即其接口。一切不严格属于对象接口的东西都应该以单下划线为前缀。
- en: 'This is the Pythonic way of clearly delimiting the interface of an object.
    There is, however, a common misconception that some attributes and methods can
    be actually made private. This is, again, a misconception. Let''s imagine that
    now the `timeout` attribute is defined with a double underscore instead:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清晰地界定对象接口的Python方式。然而，有一个常见的误解，即一些属性和方法实际上可以被私有化。这又是一个误解。让我们想象一下，现在`timeout`属性定义为双下划线：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some developers use this method to hide some attributes, thinking, like in this
    example, that `timeout` is now `private` and that no other object can modify it.
    Now, take a look at the exception that is raised when trying to access `__timeout`.
    It's `AttributeError`, saying that it doesn't exist. It doesn't say something
    like `"this is private"` or `"this can't be accessed"` and so on. It says it does
    not exist. This should give us a clue that, in fact, something different is happening
    and that this behavior is instead just a side effect, but not the real effect
    we want.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员使用这种方法来隐藏一些属性，像在这个例子中一样，认为`timeout`现在是`私有的`，没有其他对象可以修改它。现在，看一下尝试访问`__timeout`时引发的异常。它是`AttributeError`，表示它不存在。它没有说像“这是私有的”或“这不能被访问”等等。它说它不存在。这应该给我们一个线索，实际上发生了不同的事情，这种行为只是一个副作用，而不是我们想要的真正效果。
- en: 'What''s actually happening is that with the double underscores, Python creates
    a different name for the attribute (this is called **name mangling**). What it
    does is create the attribute with the following name instead: `"_<class-name>__<attribute-name>"`.
    In this case, an attribute named `''_Connector__timeout''`, will be created, and
    such an attribute can be accessed (and modified) as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的是，使用双下划线，Python为属性创建了一个不同的名称（这称为**名称混淆**）。它创建的属性的名称如下：`"_<class-name>__<attribute-name>"`。在这种情况下，将创建一个名为`'_Connector__timeout'`的属性，可以通过以下方式访问（和修改）这样的属性：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice the side effect that we mentioned earlier—the attribute only exists with
    a different name, and for that reason the `AttributeError` was raised on our first
    attempt to access it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们之前提到的副作用——属性只存在不同的名称，因此在我们第一次尝试访问它时引发了`AttributeError`。
- en: The idea of the double underscore in Python is completely different. It was
    created as a means to override different methods of a class that is going to be
    extended several times, without the risk of having collisions with the method
    names. Even that is a too far-fetched use case as to justify the use of this mechanism.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python中双下划线的概念完全不同。它被创建为一种方式，用于覆盖将被多次扩展的类的不同方法，而不会出现与方法名称的冲突的风险。即使这是一个牵强的用例，也不能证明使用这种机制的必要性。
- en: Double underscores are a non-Pythonic approach. If you need to define attributes
    as private, use a single underscore, and respect the Pythonic convention that
    it is a private attribute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 双下划线是一种非Pythonic的方法。如果需要将属性定义为私有的，请使用单下划线，并遵守Pythonic的约定，即它是一个私有属性。
- en: Do not use double underscores.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用双下划线。
- en: Properties
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: When the object needs to just hold values, we can use regular attributes. Sometimes,
    we might want to do some computations based on the state of the object and the
    values of other attributes. Most of the time, properties are a good choice for
    this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象只需要保存值时，我们可以使用常规属性。有时，我们可能希望根据对象的状态和其他属性的值进行一些计算。大多数情况下，属性是一个不错的选择。
- en: Properties are to be used when we need to define access control to some attributes
    in an object, which is another point where Python has its own way of doing things.
    In other programming languages (like Java), you would create access methods (getters
    and setters), but idiomatic Python would use properties instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要定义对象中某些属性的访问控制时，属性就应该被使用，这是Python在另一个方面有自己的做事方式的地方。在其他编程语言（如Java）中，你会创建访问方法（getter和setter），但惯用的Python会使用属性。
- en: 'Imagine that we have an application where users can register and we want to
    protect certain information about the user from being incorrect, such as their
    email, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个用户可以注册的应用程序，我们希望保护用户的某些信息不被错误地修改，比如他们的电子邮件，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By putting email under a property, we obtain some advantages for free. In this
    example, the first `@property` method will return the value held by the private
    attribute `email`. As mentioned earlier, the leading underscore determines that
    this attribute is intended to be used as private, and therefore should not be
    accessed from outside this class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将电子邮件放在属性下，我们可以免费获得一些优势。在这个例子中，第一个`@property`方法将返回私有属性`email`保存的值。如前所述，前导下划线确定了这个属性是私有的，因此不应该从这个类的外部访问。
- en: 'Then, the second method uses `@email.setter`, with the already defined property
    of the previous method. This is the one that is going to be called when `<user>.email
    = <new_email>` runs from the caller code, and `<new_email>` will become the parameter
    of this method. Here, we explicitly defined a validation that will fail if the
    value that is trying to be set is not an actual email address. If it is, it will
    then update the attribute with the new value as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第二个方法使用了`@email.setter`，使用了前一个方法已经定义的属性。当调用者代码中运行`<user>.email = <new_email>`时，将调用这个方法，`<new_email>`将成为这个方法的参数。在这里，我们明确定义了一个验证，如果试图设置的值不是实际的电子邮件地址，将失败。如果是，它将使用新值更新属性，如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach is much more compact than having custom methods prefixed with
    `get_` or `set_`. It's clear what is expected because it's just `email`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比使用以`get_`或`set_`为前缀的自定义方法要紧凑得多。因为它只是`email`，所以期望是清晰的。
- en: Don't write custom `get_*` and `set_*` methods for all attributes on your objects.
    Most of the time, leaving them as regular attributes is just enough. If you need
    to modify the logic for when an attribute is retrieved or modified, then use properties.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为对象的所有属性编写自定义的`get_*`和`set_*`方法。大多数情况下，将它们作为常规属性留下就足够了。如果需要修改检索或修改属性时的逻辑，那么使用属性。
- en: You might find that properties are a good way to achieve command and query separation
    (CC08). Command and query separation state that a method of an object should either
    answer to something or do something, but not both. If a method of an object is
    doing something and at the same time it returns a status answering a question
    of how that operation went, then it's doing more than one thing, clearly violating
    the principle that functions should do one thing, and one thing only.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现属性是实现命令和查询分离（CC08）的一种好方法。命令和查询分离表明对象的方法应该要么回答问题，要么执行操作，但不能两者兼而有之。如果对象的方法既在做某事，又同时返回一个回答该操作进行得如何的状态，那么它做了超过一件事，显然违反了函数应该只做一件事的原则。
- en: 'Depending on the name of the method, this can create even more confusion, making
    it harder for readers to understand what the actual intention of the code is.
    For example, if a method is called `set_email`, and we use it as `if self.set_email("a@j.com"):
    ...`, what is that code doing? Is it setting the email to `a@j.com`? Is it checking
    if the email is already set to that value? Both (setting and then checking if
    the status is correct)?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '根据方法的名称，这可能会导致更多的混淆，使读者更难理解代码的实际意图。例如，如果一个方法被称为`set_email`，我们使用它作为`if self.set_email("a@j.com"):
    ...`，那么这段代码在做什么？它是将电子邮件设置为`a@j.com`吗？它是在检查电子邮件是否已经设置为该值吗？两者（设置然后检查状态是否正确）？'
- en: With properties, we can avoid this kind of confusion. The `@property` decorator
    is the query that will answer to something, and the `@<property_name>.setter`
    is the command that will dosomething.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过属性，我们可以避免这种混淆。`@property`装饰器是回答问题的查询，`@<property_name>.setter`是执行命令的命令。
- en: Another piece of good advice derived from this example is as follows—don't do
    more than one thing on a method. If you want to assign something and then check
    the value, break that down into two or more sentences.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中得出的另一个好建议是——不要在一个方法上做超过一件事。如果你想分配一些东西然后检查值，把它分解成两个或更多个句子。
- en: Methods should do one thing only. If you have to run an action and then check
    for the status, so that in separate methods that are called by different statements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该只做一件事。如果你必须运行一个动作，然后检查状态，那么应该在不同的语句中调用不同的方法。
- en: Iterable objects
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: In Python, we have objects that can be iterated by default. For example, lists,
    tuples, sets, and dictionaries can not only hold data in the structure we want
    but also be iterated over a `for` loop to get those values repeatedly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有默认可迭代的对象。例如，列表、元组、集合和字典不仅可以以我们想要的结构保存数据，还可以在`for`循环中重复获取这些值。
- en: However, the built-in iterable objects are not the only kind that we can have
    in a `for` loop. We could also create our own iterable, with the logic we define
    for iteration.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内置的可迭代对象并不是我们在`for`循环中唯一可以拥有的类型。我们还可以创建自己的可迭代对象，并定义迭代的逻辑。
- en: In order to achieve this, we rely on, once again, magic methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们再次依赖于魔术方法。
- en: 'Iteration works in Python by its own protocol (namely the iteration protocol).
    When you try to iterate an object in the form `for e in myobject:...`, what Python
    checks at a very high level are the following two things, in order:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是通过Python自己的协议（即迭代协议）工作的。当你尝试以`for e in myobject:...`的形式迭代一个对象时，Python在非常高的层次上检查以下两件事，按顺序：
- en: If the object contains one of the iterator methods—`__next__` or `__iter__`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象包含迭代器方法之一——`__next__`或`__iter__`
- en: If the object is a sequence and has `__len__` and `__getitem__`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象是一个序列，并且具有`__len__`和`__getitem__`
- en: Therefore, as a fallback mechanism, sequences can be iterated, and so there
    are two ways of customizing our objects to be able to work on `for` loops.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为后备机制，序列可以被迭代，因此有两种方法可以自定义我们的对象以在`for`循环中工作。
- en: Creating iterable objects
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可迭代对象
- en: When we try to iterate an object, Python will call the `iter()` function over
    it. One of the first things this function checks for is the presence of the `__iter__`
    method on that object, which, if present, will be executed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试迭代一个对象时，Python将在其上调用`iter()`函数。这个函数首先检查的是该对象是否存在`__iter__`方法，如果存在，将执行该方法。
- en: 'The following code creates an object that allows iterating over a range of
    dates, producing one day at a time on every round of the loop:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个对象，允许在一系列日期上进行迭代，每次循环产生一天：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This object is designed to be created with a pair of dates, and when iterated,
    it will produce each day in the interval of specified dates, which is shown in
    the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象旨在使用一对日期创建，并在迭代时，将产生指定日期间隔内的每一天，如下代码所示：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `for` loop is starting a new iteration over our object. At this point,
    Python will call the `iter()` function on it, which in turn will call the `__iter__`
    magic method. On this method, it is defined to return self, indicating that the
    object is an iterable itself, so at that point every step of the loop will call
    the `next()` function on that object, which delegates to the `__next__` method.
    In this method, we decide how to produce the elements and return one at a time.
    When there is nothing else to produce, we have to signal this to Python by raising
    the `StopIteration` exception.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`for`循环开始对我们的对象进行新的迭代。此时，Python将在其上调用`iter()`函数，然后`iter()`函数将调用`__iter__`魔术方法。在这个方法中，它被定义为返回self，表示对象本身是可迭代的，因此在每一步循环中都将在该对象上调用`next()`函数，该函数委托给`__next__`方法。在这个方法中，我们决定如何产生元素并一次返回一个。当没有其他东西可以产生时，我们必须通过引发`StopIteration`异常向Python发出信号。
- en: 'This means that what is actually happening is similar to Python calling `next()`
    every time on our object until there is a `StopIteration` exception, on which
    it knows it has to stop the `for` loop:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着实际上发生的情况类似于Python每次在我们的对象上调用`next()`，直到出现`StopIteration`异常，然后它知道必须停止`for`循环：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This example works, but it has a small problem—once exhausted, the iterable
    will continue to be empty, hence raising `StopIteration`. This means that if we
    use this on two or more consecutive `for` loops, only the first one will work,
    while the second one will be empty:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是有效的，但存在一个小问题——一旦耗尽，可迭代对象将继续为空，因此引发`StopIteration`。这意味着如果我们在两个或更多连续的`for`循环中使用它，只有第一个会起作用，而第二个会为空：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is because of the way the iteration protocol works— an iterable constructs
    an iterator, and this one is the one being iterated over. In our example, `__iter__`
    just returned `self`, but we can make it create a new iterator every time it is
    called. One way of fixing this would be to create new instances of `DateRangeIterable`,
    which is not a terrible issue, but we can make `__iter__` use a generator (which
    are iterator objects), which is being created every time:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为迭代协议的工作方式——一个可迭代对象构造一个迭代器，这个迭代器被迭代。在我们的例子中，`__iter__`只是返回了`self`，但我们可以让它每次调用时创建一个新的迭代器。修复这个问题的一种方法是创建`DateRangeIterable`的新实例，这不是一个可怕的问题，但我们可以让`__iter__`使用生成器（它是迭代器对象），每次创建一个：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And this time, it works:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，它起作用了：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The difference is that each `for` loop is calling `__iter__` again, and each
    one of those is creating the generator again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于每个`for`循环都会再次调用`__iter__`，并且每个`for`循环都会再次创建生成器。
- en: This is called a **container** iterable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**容器**可迭代对象。
- en: In general, it is a good idea to work with container iterables when dealing
    with generators.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，处理生成器时最好使用容器可迭代对象。
- en: Details on generators will be explained in more detail in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml),
    *Using Generators*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关生成器的详细信息将在[第7章](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml)中详细解释，*使用生成器*。
- en: Creating sequences
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建序列
- en: Maybe our object does not define the `__iter__()` method, but we still want
    to be able to iterate over it. If `__iter__` is not defined on the object, the
    `iter()` function will look for the presence of `__getitem__`, and if this is
    not found, it will raise `TypeError`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们的对象没有定义`__iter__()`方法，但我们仍然希望能够对其进行迭代。如果对象上没有定义`__iter__`，`iter()`函数将查找`__getitem__`的存在，如果找不到，将引发`TypeError`。
- en: A sequence is an object that implements `__len__` and `__getitem__` and expects
    to be able to get the elements it contains, one at a time, in order, starting
    at zero as the first index. This means that you should be careful in the logic
    so that you correctly implement `__getitem__` to expect this type of index, or
    the iteration will not work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是一个实现`__len__`和`__getitem__`的对象，并期望能够按顺序一次获取它包含的元素，从零开始作为第一个索引。这意味着你应该在逻辑上小心，以便正确实现`__getitem__`以期望这种类型的索引，否则迭代将无法工作。
- en: The example from the previous section had the advantage that it uses less memory.
    This means that is only holding one date at a time, and knows how to produce the
    days one by one. However, it has the drawback that if we want to get the n^(th)
    element, we have no way to do so but iterate n-times until we reach it. This is
    a typical trade-off in computer science between memory and CPU usage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的示例有一个优点，它使用的内存更少。这意味着它一次只保存一个日期，并且知道如何逐个生成日期。然而，它的缺点是，如果我们想要获取第n个元素，我们除了迭代n次直到达到它之外别无选择。这是计算机科学中内存和CPU使用之间的典型权衡。
- en: The implementation with an iterable will use less memory, but it takes up to
    *O(n)* to get an element, whereas implementing a sequence will use more memory
    (because we have to hold everything at once), but supports indexing in constant
    time, *O(1)*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可迭代的实现会占用更少的内存，但获取一个元素最多需要*O(n)*的时间，而实现一个序列会占用更多的内存（因为我们必须一次性保存所有东西），但支持常数时间的索引，*O(1)*。
- en: 'This is what the new implementation might look like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是新实现可能看起来的样子：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is how the object behaves:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对象的行为：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we can see that negative indices also work. This is because
    the `DateRangeSequence` object delegates all of the operations to its wrapped
    object (a `list`), which is the best way to maintain compatibility and a consistent
    behavior.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到负索引也是有效的。这是因为`DateRangeSequence`对象将所有操作委托给其包装对象（一个`list`），这是保持兼容性和一致行为的最佳方式。
- en: Evaluate the trade-off between memory and CPU usage when deciding which one
    of the two possible implementations to use. In general, the iteration is preferable
    (and generators even more), but keep in mind the requirements of every case.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用哪种可能的实现时，要评估内存和CPU使用之间的权衡。一般来说，迭代是可取的（甚至是生成器），但要记住每种情况的要求。
- en: Container objects
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器对象
- en: Containers are objects that implement a `__contains__` method (that usually
    returns a Boolean value). This method is called in the presence of the `in` keyword
    of Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是实现`__contains__`方法的对象（通常返回一个布尔值）。在Python中的`in`关键字的存在下会调用这个方法。
- en: 'Something like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类似下面这样的：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When used in Python becomes this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用时变成这样：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can imagine how much more readable (and Pythonic!) the code can be when
    this method is properly implemented.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种方法被正确实现时，你可以想象代码会变得更可读（并且更Pythonic！）。
- en: 'Let''s say we have to mark some points on a map of a game that has two-dimensional
    coordinates. We might expect to find a function like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须在一个具有二维坐标的游戏地图上标记一些点。我们可能期望找到以下函数：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the part that checks the condition of the first `if` statement seems convoluted;
    it doesn't reveal the intention of the code, it's not expressive, and worst of
    all it calls for code duplication (every part of the code where we need to check
    the boundaries before proceeding will have to repeat that `if` statement).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查第一个`if`语句条件的部分似乎很复杂；它没有显示代码的意图，不够表达，最糟糕的是它要求代码重复（在代码的每个部分在继续之前都需要重复那个`if`语句）。
- en: 'What if the map itself (called `grid` on the code) could answer this question?
    Even better, what if the map could delegate this action to an even smaller (and
    hence more cohesive) object? Therefore, we can ask the map if it contains a coordinate,
    and the map itself can have information about its limit, and ask this object the
    following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地图本身（在代码中称为`grid`）能够回答这个问题怎么办？更好的是，如果地图能够将这个动作委托给一个更小（因此更内聚）的对象呢？因此，我们可以问地图是否包含一个坐标，地图本身可以有关于其限制的信息，并询问这个对象以下内容：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code alone is a much better implementation. First, it is doing a simple
    composition and it's using delegation to solve the problem. Both objects are really
    cohesive, having the minimal possible logic; the methods are short, and the logic
    speaks for itself—`coord in self.limits` is pretty much a declaration of the problem
    to solve, expressing the intention of the code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身就是一个更好的实现。首先，它进行了简单的组合，并使用委托来解决问题。两个对象都非常内聚，具有尽可能少的逻辑；方法很短，逻辑清晰明了——`coord
    in self.limits`基本上就是对要解决的问题的声明，表达了代码的意图。
- en: 'From the outside, we can also see the benefits. It''s almost as if Python is
    solving the problem for us:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部来看，我们也能看到好处。几乎就像Python在为我们解决问题：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dynamic attributes for objects
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的动态属性
- en: It is possible to control the way attributes are obtained from objects by means
    of the `__getattr__` magic method. When we call something like `<myobject>.<myattribute>`,
    Python will look for `<myattribute>` in the dictionary of the object, calling
    `__getattribute__` on it. If this is not found (namely, the object does not have
    the attribute we are looking for), then the extra method, `__getattr__`, is called,
    passing the name of the attribute (`myattribute`) as a parameter. By receiving
    this value, we can control the way things should be returned to our objects. We
    can even create new attributes, and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`__getattr__`魔术方法来控制从对象中获取属性的方式。当我们调用类似`<myobject>.<myattribute>`的东西时，Python会在对象的字典中查找`<myattribute>`，并调用`__getattribute__`。如果没有找到（即对象没有我们要找的属性），那么会调用额外的方法`__getattr__`，并将属性的名称（`myattribute`）作为参数传递。通过接收这个值，我们可以控制返回给我们对象的方式。我们甚至可以创建新的属性等等。
- en: 'In the following listing, the `__getattr__`method is demonstrated:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的清单中，演示了`__getattr__`方法：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here are some calls to an object of this class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对该类对象的一些调用：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first call is straightforward—we just request an attribute that the object
    has and get its value as a result. The second is where this method takes action
    because the object does not have anything called `fallback_test`, so the `__getattr__`
    will run with that value. Inside that method, we placed the code that returns
    a string, and what we get is the result of that transformation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用很简单——我们只是请求对象具有的属性，并将其值作为结果。第二个是这个方法发挥作用的地方，因为对象没有任何叫做`fallback_test`的东西，所以`__getattr__`将以该值运行。在该方法内部，我们放置了返回一个字符串的代码，我们得到的是该转换的结果。
- en: The third example is interesting because there a new attribute named `fallback_new`
    is created (actually, this call would be the same as running `dyn.fallback_new
    = "new value"`)*,* so when we request that attribute, notice that the logic we
    put in `__getattr__`does not apply, simply because that code is never called.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子很有趣，因为这里创建了一个名为`fallback_new`的新属性（实际上，这个调用与运行`dyn.fallback_new = "new value"`是一样的），所以当我们请求该属性时，注意到我们放在`__getattr__`中的逻辑不适用，因为那段代码根本没有被调用。
- en: Now, the last example is the most interesting one. There is a subtle detail
    here that makes a huge difference. Take another look at the code in the `__getattr__` method.
    Notice the exception it raises when the value is not retrievable `AttributeError`*. *This
    is not only for consistency (as well as the message in the exception) but also
    required by the built-in `getattr()` function. Had this exception been any other,
    it would raise, and the default value would not be returned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一个例子是最有趣的。这里有一个微妙的细节，这会产生很大的差异。再看一下`__getattr__`方法中的代码。注意当值不可检索时它引发的异常`AttributeError`。这不仅是为了一致性（以及异常中的消息），而且也是内置的`getattr()`函数所要求的。如果这个异常是其他任何异常，它都会引发，而默认值将不会被返回。
- en: Be careful when implementing a method so dynamic as `__getattr__`, and use it
    with caution. When implementing `__getattr__`, raise `AttributeError`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`__getattr__`这样动态的方法时要小心，并谨慎使用。在实现`__getattr__`时，要引发`AttributeError`。
- en: Callable objects
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用对象
- en: It is possible (and often convenient) to define objects that can act as functions.
    One of the most common applications for this is to create better decorators, but
    it's not limited to that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可以作为函数的对象是可能的（而且通常很方便）。其中最常见的应用之一是创建更好的装饰器，但不仅限于此。
- en: The magic method `__call__` will be called when we try to execute our object
    as if it were a regular function. Every argument passed to it will be passed along
    to the `__call__` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试执行我们的对象，就好像它是一个常规函数一样时，魔术方法`__call__`将被调用。传递给它的每个参数都将传递给`__call__`方法。
- en: The main advantage of implementing functions this way, through objects, is that
    objects have states, so we can save and maintain information across calls.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式实现函数的主要优势是，对象具有状态，因此我们可以在调用之间保存和维护信息。
- en: When we have an object, a statement like this `object(*args, **kwargs)` is translated
    in Python to `object.__call__(*args, **kwargs)`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个对象时，类似这样的语句`object(*args, **kwargs)`在Python中被翻译为`object.__call__(*args,
    **kwargs)`。
- en: This method is useful when we want to create callable objects that will work
    as parametrized functions, or in some cases functions with memory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建可作为带参数函数的可调用对象时，这种方法非常有用，或者在某些情况下是具有记忆功能的函数。
- en: 'The following listing uses this method to construct an object that when called
    with a parameter returns the number of times it has been called with the very
    same value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单使用此方法构建一个对象，当使用参数调用时，返回它已经使用相同值调用的次数：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Some examples of this class in action are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的一些示例操作如下：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Later in this book, we will find out that this method comes in handy when creating
    decorators.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将发现这种方法在创建装饰器时非常方便。
- en: Summary of magic methods
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 魔术方法总结
- en: 'We can summarize the concepts we described in the previous sections in the
    form of a cheat sheet like the one presented as follows. For each action in Python,
    the magic method involved is presented, along with the concept that it represents:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结前面描述的概念，形成一个类似下面所示的速查表。对于Python中的每个操作，都会呈现涉及的魔术方法，以及它所代表的概念：
- en: '| **Statement** | **Magic method** | **Python concept** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **语句** | **魔术方法** | **Python概念** |'
- en: '| `obj[key]``obj[i:j]``obj[i:j:k]` | `__getitem__(key)` | Subscriptable object
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `obj[key]``obj[i:j]``obj[i:j:k]` | `__getitem__(key)` | 可以进行下标操作的对象 |'
- en: '| `with obj: ...` | `__enter__` / `__exit__` | Context manager |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `with obj: ...` | `__enter__` / `__exit__` | 上下文管理器 |'
- en: '| `for i in obj: ...` | `__iter__` / `__next__``__len__` / `__getitem__` |
    Iterable objectSequence |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `for i in obj: ...` | `__iter__` / `__next__``__len__` / `__getitem__` |
    可迭代对象序列 |'
- en: '| `obj.<attribute>` | `__getattr__` | Dynamic attribute retrieval |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `obj.<attribute>` | `__getattr__` | 动态属性检索 |'
- en: '| `obj(*args, **kwargs)` | `__call__(*args, **kwargs)` | Callable object |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `obj(*args, **kwargs)` | `__call__(*args, **kwargs)` | 可调用对象 |'
- en: Caveats in Python
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的注意事项
- en: Besides understanding the main features of the language, being able to write
    idiomatic code is also about being aware of the potential problems of some idioms,
    and how to avoid them. In this section, we will explore common issues that might
    cause you long debugging sessions if they catch you off guard.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解语言的主要特性之外，能够编写惯用代码也意味着要意识到一些习语的潜在问题，以及如何避免它们。在本节中，我们将探讨一些常见问题，如果让你措手不及，可能会导致长时间的调试会话。
- en: Most of the points discussed in this section are things to avoid entirely, and
    I will dare to say that there is almost no possible scenario that justifies the
    presence of the anti-pattern (or idiom, in this case). Therefore, if you find
    this on the code base you are working on, feel free to refactor it in the way
    that is suggested. If you find these traits while doing a code review, this is
    a clear indication that something needs to change.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的大部分观点都是要完全避免的，我敢说几乎没有可能的情况能够证明反模式（或者在这种情况下是习语）的存在是合理的。因此，如果你在你正在工作的代码库中发现了这种情况，可以随意按照建议进行重构。如果你在进行代码审查时发现了这些特征，这清楚地表明需要做出一些改变。
- en: Mutable default arguments
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变默认参数
- en: Simply put, don't use mutable objects as the default arguments of functions.
    If you use mutable objects as default arguments, you will get results that are
    not the expected ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，不要将可变对象用作函数的默认参数。如果您将可变对象用作默认参数，您将得到意料之外的结果。
- en: 'Consider the following erroneous function definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下错误的函数定义：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This has two problems, actually. Besides the default mutable argument, the body
    of the function is mutating a mutable object, hence creating a side effect. But
    the main problem is the default argument for `user_medatada`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这有两个问题。除了默认的可变参数外，函数体正在改变一个可变对象，因此产生了副作用。但主要问题是`user_medatada`的默认参数。
- en: 'This will actually only work the first time it is called without arguments.
    For the second time, we call it without explicitly passing something to `user_metadata`.
    It will fail with a `KeyError`, like so:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这只会在第一次不带参数调用时起作用。第二次，我们在不明确传递任何内容给`user_metadata`的情况下调用它。它将失败并显示`KeyError`，如下所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The explanation is simple—by assigning the dictionary with the default data
    to `user_metadata` on the definition of the function, this dictionary is actually
    created once and the variable `user_metadata` points to it. The body of the function
    modifies this object, which remains alive in memory so long as the program is
    running. When we pass a value to it, this will take the place of the default argument
    we just created. When we don't want this object it is called again, and it has
    been modified since the previous run; the next time we run it, will not contain
    the keys since they were removed on the previous call.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很简单 - 在函数定义中将带有默认数据的字典分配给`user_metadata`，实际上是创建了一个字典，并且变量`user_metadata`指向它。函数体修改了这个对象，在程序运行时它会一直存在于内存中。当我们给它传递一个值时，这将取代我们刚刚创建的默认参数。当我们不想要这个对象时再次调用它，并且自上次运行以来它已经被修改；下一次运行它时，将不包含键，因为它们在上一次调用时被移除了。
- en: 'The fix is also simple—we need to use `None` as a default sentinel value and
    assign the default on the body of the function. Because each function has its
    own scope and life cycle, `user_metadata` will be assigned to the dictionary every
    time `None` appears:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 修复也很简单 - 我们需要使用`None`作为默认的标记值，并在函数体中分配默认值。因为每个函数都有自己的作用域和生命周期，`user_metadata`将在每次出现`None`时被分配给字典：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Extending built-in types
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置类型
- en: The correct way of extending built-in types such as lists, strings, and dictionaries
    is by means of the `collections` module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的扩展内置类型（如列表、字符串和字典）的方法是使用`collections`模块。
- en: If you create a class that directly extends dict, for example, you will obtain
    results that are probably not what you are expecting. The reason for this is that
    in CPython the methods of the class don't call each other (as they should), so
    if you override one of them, this will not be reflected by the rest, resulting
    in unexpected outcomes. For example, you might want to override `__getitem__`,
    and then when you iterate the object with a `for` loop, you will notice that the
    logic you have put on that method is not applied.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您直接扩展dict等类，您将得到可能不是您期望的结果。这是因为在CPython中，类的方法不会相互调用（应该调用），因此如果您覆盖其中一个方法，这不会被其他方法反映出来，导致意外的结果。例如，您可能想要覆盖`__getitem__`，然后当您使用`for`循环迭代对象时，您会注意到您在该方法中放置的逻辑没有被应用。
- en: This is all solved by using `collections.UserDict`, for example, which provides
    a transparent interface to actual dictionaries, and is more robust.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都可以通过使用`collections.UserDict`来解决，它提供了对实际字典的透明接口，并且更加健壮。
- en: 'Let''s say we want a list that was originally created from numbers to convert
    the values to strings, adding a prefix. The first approach might look like it
    solves the problem, but it is erroneous:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个最初由数字创建的列表将值转换为字符串，并添加前缀。第一种方法可能看起来解决了问题，但是是错误的：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At first sight, it looks like the object behaves as we want it to. But then,
    if we try to iterate it (after all, it is a list), we find that we don''t get
    what we wanted:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像我们想要的对象行为。但是，如果我们尝试迭代它（毕竟，它是一个列表），我们会发现我们得不到我们想要的东西：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `join` function will try to iterate (run a `for` loop over) the list, but
    expects values of type string. This should work because it is exactly the type
    of change we made to the list, but apparently when the list is being iterated,
    our changed version of the `__getitem__`is not being called.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`函数将尝试迭代（在列表上运行`for`循环），但期望的是字符串类型的值。这应该可以工作，因为这正是我们对列表所做的更改，但显然在迭代列表时，我们修改的`__getitem__`版本没有被调用。'
- en: This issue is actually an implementation detail of CPython (a C optimization),
    and in other platforms such as PyPy it doesn't happen (see the differences between
    PyPy and CPython in the references at the end of this chapter).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是CPython的一个实现细节（一种C优化），在其他平台（如PyPy）中不会发生（请参阅本章末尾的PyPy和CPython之间的差异）。
- en: 'Regardless of this, we should write code that is portable and compatible in
    all implementations, so we will fix it by extending not from `list` but from `UserList`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们应该编写可移植且兼容所有实现的代码，因此我们将通过不是从`list`而是从`UserList`扩展来修复它：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And now things look much better:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情看起来好多了：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't extend directly from dict, use `collections.UserDict` instead. For lists,
    use `collections.UserList`, and for strings, use `collections.UserString`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接从dict扩展，而是使用`collections.UserDict`。对于列表，使用`collections.UserList`，对于字符串，使用`collections.UserString`。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored the main features of Python, with the goal
    of understanding its most distinctive features, those that make Python a peculiar
    language compared to the rest. On this path, we have explored different methods
    of Python, protocols, and their internal mechanics.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经探讨了Python的主要特性，目标是理解其最独特的特性，这些特性使Python成为与其他语言相比独特的语言。在这条道路上，我们探索了Python的不同方法、协议和它们的内部机制。
- en: As opposed to the previous chapter, this one is more Python-focused. A key takeaway
    of the topics of this book is that clean code goes beyond following the formatting
    rules (which, of course, are essential to a good code base). They are a necessary
    condition, but not sufficient. Over the next few chapters, we will see ideas and
    principles that relate more to the code, with the goal of achieving a better design
    and implementation of our software solution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章相反，这一章更加关注Python。本书主题的一个关键要点是，清晰的代码不仅仅是遵循格式规则（当然，这对于良好的代码库是必不可少的）。这是一个必要条件，但不是充分条件。在接下来的几章中，我们将看到更多与代码相关的想法和原则，旨在实现更好的软件解决方案设计和实现。
- en: 'With the concepts and the ideas of this chapter, we explored the core of Python:
    its protocols and magic methods. It should be clear by now that the best way of
    having Pythonic, idiomatic code is not only by following the formatting conventions
    but also by taking full advantage of all the features Python has to offer. This
    means that you should sometimes use a particular magic method, implement a context
    manager, and more.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的概念和想法，我们探索了Python的核心：其协议和魔术方法。现在应该清楚了，编写Pythonic、惯用的代码的最佳方式不仅仅是遵循格式约定，还要充分利用Python提供的所有功能。这意味着有时您应该使用特定的魔术方法，实现上下文管理器等。
- en: In the next chapter, we will put these concepts into action, relating general
    concepts of software engineering with the way they can be written in Python.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些概念付诸实践，将软件工程的一般概念与它们在Python中的书写方式联系起来。
- en: References
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'The reader will find more information about some of the topics that we have
    covered in this chapter in the following references. The decision of how indices
    work in Python is based on (EWD831), which analyzes several alternatives for ranges
    in math and programming languages:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 读者将在以下参考资料中找到更多关于本章涵盖的一些主题的信息。 Python中索引如何工作的决定是基于（EWD831），该文分析了数学和编程语言中范围的几种替代方案：
- en: '*EWD831*: Why numbering should start at zero ([https://www.cs.utexas.edu/users/EWD/transcriptions//EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html))'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EWD831*：为什么编号应该从零开始（[https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)）'
- en: '*PEP-343*: The "with" Statement ([https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/))'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-343*： "with"语句（[https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)）'
- en: '*CC08*: The book written by Robert C. Martin named *Clean Code: A Handbook
    of Agile Software Craftsmanship*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CC08*：由Robert C. Martin撰写的书籍*Clean Code: A Handbook of Agile Software Craftsmanship*'
- en: Python documentation, the `iter()` function ([https://docs.python.org/3/library/functions.html#iter](https://docs.python.org/3/library/functions.html#iter))
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文档，`iter()`函数（[https://docs.python.org/3/library/functions.html#iter](https://docs.python.org/3/library/functions.html#iter)）
- en: Differences between PyPy and CPython ([https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types](https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPy和CPython之间的区别（[https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types](https://pypy.readthedocs.io/en/latest/cpython_differences.html#subclasses-of-built-in-types)）
