- en: Chapter 5. Where Do You Store Your Stuff?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。你把东西放在哪里？
- en: I'm like a squirrel. Once in a while, I leave money in secret stashes around
    the house in case I get mugged or just spend too much in a month. I truly forget
    where all my stashes are, and that is kind of funny and sad (for me).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我就像一只松鼠。我偶尔会在家里的秘密藏匿处留下一些钱，以防我被抢劫，或者在一个月里花费太多。我真的忘记了我所有的藏匿处在哪里，这有点有趣也有点悲哀（对我来说）。
- en: Now, imagine you're storing something equally important or even more important
    than money, for instance, client data or even your company data. Could you allow
    yourself to store it in places that could later be lost or accessible to someone
    who could meddle with your "stash"? We are in the information era; information
    is power!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，你正在存储一些同样重要甚至更重要的东西，比如客户数据或者甚至你公司的数据。你能允许自己将它存储在以后可能会丢失或者可以被某人干扰的地方吗？我们正处于信息时代；信息就是力量！
- en: 'In the web application world, we have two big players for data storage: **relational
    databases** and **NoSQL databases**. The first is the traditional way where your
    data is stored inside tables and columns and where transactions matter, ACID is
    expected and normalization is the key (pun intended)! It uses **SQL** to store
    and retrieve data. In the second way, things get a little wild. Your data may
    be stored in different structures such as documents, graphs, key value mappings,
    and others. Writing and consulting languages are vendor-specific, and you may
    have to give up on ACID too in a tradeoff for speed, lots of speed!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序世界中，我们有两个大的数据存储玩家：**关系数据库**和**NoSQL数据库**。第一种是传统的方式，其中您的数据存储在表和列中，事务很重要，期望有ACID，规范化是关键（双关语）！它使用**SQL**来存储和检索数据。在第二种方式中，情况变得有点疯狂。您的数据可能存储在不同的结构中，如文档、图形、键值映射等。写入和查询语言是特定于供应商的，您可能不得不放弃ACID以换取速度，大量的速度！
- en: You have probably guessed it already! This chapter is all about the **M** layer
    of **MVC**, that is, how to store and access your data in a transparent way with
    Flask! We'll look at the examples of how to use query and write to both the database
    types, and when to choose which one to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了！这一章是关于**MVC**中的**M**层，也就是如何以透明的方式存储和访问数据的章节！我们将看一下如何使用查询和写入两种数据库类型的示例，以及何时选择使用哪种。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: ACID is the acronym for atomicity, consistency, isolation, and durability. Refer
    to [http://en.wikipedia.org/wiki/ACID](http://en.wikipedia.org/wiki/ACID) for
    a cozy definition and overview.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ACID是原子性、一致性、隔离性和持久性的缩写。请参考[http://en.wikipedia.org/wiki/ACID](http://en.wikipedia.org/wiki/ACID)了解一个舒适的定义和概述。
- en: SQLAlchemy
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy
- en: SQLAlchemy is an amazing library for working with relational databases. It was
    made by the Pocoo Team, the same folks that brought you Flask, and is considered
    "The Facto" Python SQL library. It works with SQLite, Postgres, MySQL, Oracle,
    and all SQL databases, which comes with compatible drivers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个与关系数据库一起工作的惊人库。它是由Pocoo团队制作的，他们也是Flask的创始人，被认为是“事实上”的Python SQL库。它可以与SQLite、Postgres、MySQL、Oracle和所有SQL数据库一起使用，这些数据库都有兼容的驱动程序。
- en: SQLite describes itself as a self-contained, serverless, zero-configuration,
    and transactional SQL database engine ([https://sqlite.org/about.html](https://sqlite.org/about.html)).
    One of its main goals is to be a great embeddable database solution for applications
    and small devices, which it is! It is also very easy to use and that makes it
    perfect for our learning purposes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite自称为一个自包含、无服务器、零配置和事务性SQL数据库引擎（[https://sqlite.org/about.html](https://sqlite.org/about.html)）。其主要目标之一是成为应用程序和小型设备的嵌入式数据库解决方案，它已经做到了！它也非常容易使用，这使得它非常适合我们的学习目的。
- en: Though all the examples will be given and tested with SQLite in mind, they should
    work in the other databases with little to no changes. Database-specific tips
    will be given from time to time whenever appropriate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有的例子都将以SQLite为主要考虑对象进行给出和测试，但它们应该在其他数据库中也能够以很少或没有改动的方式工作。在适当的时候，将会不时地给出特定于数据库的提示。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to [http://www.w3schools.com/sql/default.asp](http://www.w3schools.com/sql/default.asp)
    for an extensive SQL reference.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[http://www.w3schools.com/sql/default.asp](http://www.w3schools.com/sql/default.asp)了解广泛的SQL参考。
- en: Before our first example, should we review a few relational database concepts?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子之前，我们是否应该复习一下几个关系数据库的概念？
- en: Concepts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念
- en: '**Tables** are low-level abstraction structures where your data is stored.
    It is made up of **columns** and **rows**, where each column represents a part
    of your data and each row represents a full record. Usually, each table represents
    a low-level abstraction of a class model.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表**是低级抽象结构，用于存储数据。它由**列**和**行**组成，其中每一列代表数据的一部分，每一行代表一个完整的记录。通常，每个表代表一个类模型的低级抽象。'
- en: '**Rows** are individual records of a given class model. You may need to scatter
    multiple row records across different tables to record a full piece of information.
    A good example is an **MxN relationship**.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**行**是给定类模型的单个记录。您可能需要将多个行记录分散到不同的表中，以记录完整的信息。一个很好的例子是**MxN关系**。'
- en: '**Columns** represent the stored data itself. Each column has a specific type,
    and accepts only that type as input data. You may think of it as an abstraction
    of a class model attribute.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**列**代表存储的数据本身。每一列都有一个特定的类型，并且只接受该类型的输入数据。您可以将其视为类模型属性的抽象。'
- en: '**Transactions** are how you group the operations you want to be executed together.
    It is used mainly to achieve atomicity. This way, no operations are done halfway.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务**是用来将要执行的操作分组的方式。它主要用于实现原子性。这样，没有操作是半途而废的。'
- en: '**Primary key** is a database concept where part of a record''s data is used
    to identify the given record across the database table. It is usually implemented
    by the database through constraints.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**主键**是一个数据库概念，记录的一部分数据用于标识数据库表中的给定记录。通常由数据库通过约束来实现。'
- en: '**Foreign key** is a database concept where a set of data is used to identify
    a given record across tables. Its main use is to construct relationships between
    rows in different tables. It is usually implemented by the database through constraints.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**外键**是一个数据库概念，用于在不同表之间标识给定记录的一组数据。它的主要用途是在不同表的行之间构建关系。通常由数据库通过约束来实现。'
- en: One main concern when working with relational databases is data normalization.
    In relational databases, related data is stored across different tables. You may
    have a table to hold a person's data, a table for the person's address, another
    for his/her cars, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关系数据库时的一个主要关注点是数据规范化。在关系数据库中，相关数据存储在不同的表中。您可能有一个表来保存一个人的数据，一个表来保存这个人的地址，另一个表来保存他/她的汽车，等等。
- en: Each table is isolated from one another and the related data may be retrievable,
    thanks to the relations established by the foreign keys! The data normalization
    techniques are a set of rules used to allow proper scattering of the data across
    the tables so that the related tables are easily fetched and redundancy is kept
    to a minimum.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表都与其他表隔离，通过外键建立的关系可以检索相关数据！数据规范化技术是一组规则，用于允许数据在表之间适当分散，以便轻松获取相关表，并将冗余保持最小。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please, refer to [http://en.wikipedia.org/wiki/Database_normalization](http://en.wikipedia.org/wiki/Database_normalization)
    for an overview of database normalization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[http://en.wikipedia.org/wiki/Database_normalization](http://en.wikipedia.org/wiki/Database_normalization)了解数据库规范化的概述。
- en: 'For an overview of the normal forms, please refer to the following links:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关规范形式的概述，请参阅以下链接：
- en: '[http://en.wikipedia.org/wiki/First_normal_form](http://en.wikipedia.org/wiki/First_normal_form)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/First_normal_form](http://en.wikipedia.org/wiki/First_normal_form)'
- en: '[http://en.wikipedia.org/wiki/Second_normal_form](http://en.wikipedia.org/wiki/Second_normal_form)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Second_normal_form](http://en.wikipedia.org/wiki/Second_normal_form)'
- en: '[http://en.wikipedia.org/wiki/Third_normal_form](http://en.wikipedia.org/wiki/Third_normal_form)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Third_normal_form](http://en.wikipedia.org/wiki/Third_normal_form)'
- en: We may now proceed!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续了！
- en: Hands on
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际操作
- en: 'Let''s begin by installing the library into our environment and trying out
    a few examples:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将库安装到我们的环境中，并尝试一些示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On to our first example! Let''s create a simple employee database for a company
    (maybe yours?):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例！让我们为一家公司（也许是你的公司？）创建一个简单的员工数据库：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding example is pretty simple. We create a SQLAlchemy engine, grab
    a connection from the **connection pool** (engine handles that for you) and then
    we execute the SQL command to create a table, insert a few rows and query to see
    whether everything occurred as expected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子非常简单。我们创建了一个SQLAlchemy引擎，从**连接池**中获取连接（引擎会为您处理），然后执行SQL命令来创建表，插入几行数据并查询是否一切都如预期发生。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Visit [http://en.wikipedia.org/wiki/Connection_pool](http://en.wikipedia.org/wiki/Connection_pool)
    for the connection pool pattern overview. (This is important, really!)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://en.wikipedia.org/wiki/Connection_pool](http://en.wikipedia.org/wiki/Connection_pool)了解连接池模式概述。（这很重要！）
- en: In our insertion, we provided the value `NULL` to the primary key `id`. Be aware
    that SQLite will not populate the primary key with `NULL`; instead, it will ignore
    the `NULL` value and set the column with a new, unique, across the table integer.
    That's SQLite- specific behavior. **Oracle**, for example, would require you to
    insert a sequence's next value explicitly in order to set a new unique column
    value for the primary key.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的插入中，我们为主键`id`提供了值`NULL`。请注意，SQLite不会使用`NULL`填充主键；相反，它会忽略`NULL`值，并将列设置为新的、唯一的整数。这是SQLite特有的行为。例如，**Oracle**将要求您显式插入序列的下一个值，以便为主键设置一个新的唯一列值。
- en: Our preceding example uses a feature called **autocommit**. It means each execute
    method call commits to the database immediately. In this way, you could not execute
    multiple statements at once, a common scenario in real world applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例使用了一个名为**autocommit**的功能。这意味着每次执行方法调用都会立即提交到数据库。这样，您无法一次执行多个语句，这在现实世界的应用程序中是常见的情况。
- en: 'To execute multiple statements at once, we should use **transactions**. We
    could rewrite our previous example with transactions in order to make sure all
    three insertions are either committed together or not at all (grim look...):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次执行多个语句，我们应该使用**事务**。我们可以通过事务重写我们之前的示例，以确保所有三个插入要么一起提交，要么根本不提交（严肃的表情...）。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nothing fancy so far. In our example, we create a transaction from the connection,
    execute a few statements and then commit it to finish the transaction. If an error
    occurs between the beginning and end of a transaction, the `except` block will
    be reached and all the statements executed within the transaction will rollback
    or "undone".
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止还没有什么花哨的。在我们的例子中，我们从连接创建了一个事务，执行了一些语句，然后提交以完成事务。如果在事务开始和结束之间发生错误，`except`块将被执行，并且在事务中执行的所有语句将被回滚或“撤消”。
- en: We can make our example complete by creating a relation among the tables. Imagine
    our employee has one or more addresses registered with his/her company profile.
    We will create a 1xN relation, where an employee may have one, or more addresses.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在表之间创建关系来完善我们的示例。想象一下，我们的员工在公司档案中注册了一个或多个地址。我们将创建一个1xN关系，其中一个员工可以拥有一个或多个地址。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our new and updated, awesome example, we record some addresses of our employees,
    making sure to use the correct value for the foreign keys (`id_employee`) and
    then we look out for the addresses of an employee called `'marcos mango'` using
    `LEFT JOIN`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新的和更新的示例中，我们记录了一些员工的地址，确保使用正确的外键值（`id_employee`），然后我们使用`LEFT JOIN`查找名为`'marcos
    mango'`的员工的地址。
- en: We have seen how to create tables and relations, run statements to consult and
    insert data, and use transactions with SQLAlchemy; we're yet to explore much of
    the library power within SQLAlchemy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建表和关系，运行语句来查询和插入数据，并使用SQLAlchemy进行事务处理；我们还没有完全探索SQLAlchemy库的强大功能。
- en: SQLAlchemy has a built-in ORM, which allows you to work with database tables
    as if they were native object instances. Imagine reading a column value as if
    it was an instance attribute or consulting a complex table relation through a
    method, that's SQLAlchemy's ORM.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy具有内置的ORM，允许您像使用本机对象实例一样使用数据库表。想象一下，读取列值就像读取实例属性一样，或者通过方法查询复杂的表关系，这就是SQLAlchemy的ORM。
- en: 'Let''s see how our example will look using the built-in ORM:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用内置ORM的示例会是什么样子：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example has quite a few concepts to be introduced. First, we create
    our engine, the SQLAlchemy engine used in the first example, then we create our
    base model class. While `Employee` will be mapped into a table called `employee`
    by `create_all`, each defined `Column` attribute will be mapped into a column
    of the given table in the database with the proper constraints. For the `id` field,
    for example, it is defined as a primary key, so it will have the primary key constraint
    created for it. The `id_employee` is a foreign key, which is a reference to the
    primary key of another table, so it will have a foreign key constraint, and so
    on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例介绍了相当多的概念。首先，我们创建了我们的引擎，即第一个示例中使用的SQLAlchemy引擎，然后我们创建了我们的基本模型类。虽然`Employee`将被`create_all`映射到一个名为`employee`的表中，但每个定义的`Column`属性都将被映射到数据库中给定表的列中，并具有适当的约束。例如，对于`id`字段，它被定义为主键，因此将为其创建主键约束。`id_employee`是一个外键，它是对另一个表的主键的引用，因此它将具有外键约束，依此类推。
- en: All of our class models should inherit from it. Then we create a `session`.
    A session is how you work with the SQLAlchemy ORM models.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的类模型都应该从中继承。然后我们创建一个`session`。会话是您使用SQLAlchemy ORM模型的方式。
- en: Sessions have an internal ongoing transaction, so it's very simple for it to
    have a *transaction-like* behavior. It also maps your models to the correct engine
    in case you're using more than one; but wait, there's more! It also keeps track
    of all the model instances loaded in/from it. For example, if you add a model
    instance to it and then modify that very instance, the session is smart enough
    to acknowledge the change of one of its objects. It will, thus, mark itself as
    dirty (stuff was changed) until a commit or rollback is called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 会话具有内部正在进行的事务，因此它非常容易具有类似事务的行为。它还将您的模型映射到正确的引擎，以防您使用多个引擎；但等等，还有更多！它还跟踪从中加载的所有模型实例。例如，如果您将模型实例添加到其中，然后修改该实例，会话足够聪明，能够意识到其对象的更改。因此，它会将自身标记为脏（内容已更改），直到调用提交或回滚。
- en: 'In the example, after finding marcos, we could change "Marcos Mango''s" name
    to something else, such as `"marcos tangerine"`, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，在找到marcos之后，我们可以将"Marcos Mango's"的名字更改为其他内容，比如`"marcos tangerine"`，就像这样：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, comment the whole code after `Base.metadata` and add the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Base.metadata`之后注释掉整个代码，并添加以下内容：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, re-execute the example. Marcos new last name now is "tangerine". Magical!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新执行示例。Marcos的新姓氏现在是"tangerine"。神奇！
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For an amazing, super duper, mega power reference on querying with SQLAlchemy
    ORM, please visit [http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying](http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用SQLAlchemy ORM进行查询的惊人、超级、强大的参考，请访问[http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying](http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying)。
- en: After so much talk about SQLAlchemy, could you please wake up as we'll talk
    about Flask-SQLAlchemy, the extension that integrates the library with Flask.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论了这么多关于SQLAlchemy之后，您能否请醒来，因为我们将谈论Flask-SQLAlchemy，这个扩展将库与Flask集成在一起。
- en: Flask-SQLAlchemy
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy
- en: 'Flask-SQLAlchemy is a thin extension that wraps SQLAlchemy around Flask. It
    allows you to configure the SQLAlchemy engine through your configuration file
    and binds a session to each request, giving you a transparent way to handle transactions.
    Let''s see how to do all that. First, let''s make sure we have all the necessary
    packages installed. With the virtual environment loaded, run:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy是一个轻量级的扩展，它将SQLAlchemy封装在Flask周围。它允许您通过配置文件配置SQLAlchemy引擎，并为每个请求绑定一个会话，为您提供了一种透明的处理事务的方式。让我们看看如何做到这一点。首先，确保我们已经安装了所有必要的软件包。加载虚拟环境后，运行：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our code should look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码应该是这样的：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example is pretty complete. It has a form validation, CSRF protection,
    auto-generated form from model, and database integration. Let's focus only on
    what we have not mentioned so far.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例非常完整。它具有表单验证、CSRF保护、从模型自动生成的表单以及数据库集成。让我们只关注到目前为止我们还没有提到的内容。
- en: The auto form generation is pretty handy. Using `model_form`, you're able to
    introspect the defined model class and generate a form class fit for that model.
    You may also provide arguments to the fields through the `model_form` parameter
    `field_args`, which is pretty useful for adding element classes or extra validators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成表单非常方便。使用`model_form`，您可以自省定义的模型类并生成适合该模型的表单类。您还可以通过`model_form`参数`field_args`为字段提供参数，这对于添加元素类或额外验证器非常有用。
- en: You may have also noticed that `Employee` extends `db.Model` which is your ORM
    model base class. All your models should extend it in order to be known by `db`,
    which encapsulates our engine and holds our request aware session.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到`Employee`扩展了`db.Model`，这是您的ORM模型基类。所有您的模型都应该扩展它，以便被`db`所知，它封装了我们的引擎并保存我们的请求感知会话。
- en: 'Inside the index function, we instantiate the form, then check whether it was
    submitted through POST and is valid. Inside the `if` block, we instantiate our
    employee model and use `populate_obj` to put the values of the form inside the
    model instance. We could also do it field by field, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在index函数内部，我们实例化表单，然后检查它是否通过POST提交并且有效。在`if`块内部，我们实例化我们的员工模型，并使用`populate_obj`将表单的值放入模型实例中。我们也可以逐个字段地进行操作，就像这样：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `populate_obj` is just more convenient. After populating the model, we add
    it to the session to keep track of it and commit the session. In case of any exception
    in this block, we have it inside a try/except block with a rollback prepared.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`populate_obj`只是更方便。在填充模型后，我们将其添加到会话中以跟踪它，并提交会话。在此块中发生任何异常时，我们将其放在一个带有准备回滚的try/except块中。'
- en: 'Note that we use `Employee.query` to consult which employees are stored in
    our database. Each model class comes with a `query` attribute that allows you
    to fetch and filter results from the database. Each filter call to `query` will
    return a `BaseQuery` instance, which allows you to stack your filters, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`Employee.query`来查询存储在我们数据库中的员工。每个模型类都带有一个`query`属性，允许您从数据库中获取和过滤结果。对`query`的每个过滤调用将返回一个`BaseQuery`实例，允许您堆叠过滤器，就像这样：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The possibilities here are many. Why don't you try a few examples on your own
    now?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多可能性。为什么不现在就尝试一些例子呢？
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most common security problem related to web applications and databases is
    the **SQL Injection Attack**, where an attacker injects SQL instructions into
    your queries to the database, gaining privileges he/she should not have. The SQLAlchemy's
    engine object "auto-magically" escapes special characters in your consults; so,
    unless you explicitly bypass its quoting mechanism, you should be safe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web应用程序和数据库相关的最常见的安全问题是**SQL注入攻击**，攻击者将SQL指令注入到您的数据库查询中，获取他/她不应该拥有的权限。SQLAlchemy的引擎对象“自动”转义您的查询中的特殊字符；因此，除非您明确绕过其引用机制，否则您应该是安全的。
- en: MongoDB
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB is a widely used, powerful NoSQL database. It allows you to store your
    data inside documents; a mutable, dictionary-like, object-like structure where
    your data may be stored without you worrying about things such as "is my data
    normalized to the third normal form?" or "do I have to create another table to
    store my relation?", and others.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个广泛使用的强大的NoSQL数据库。它允许您将数据存储在文档中；一个可变的、类似字典的、类似对象的结构，您可以在其中存储数据，而无需担心诸如“我的数据是否规范化到第三范式？”或“我是否必须创建另一个表来存储我的关系？”等问题。
- en: MongoDB documents are actually BSON documents, a superset of JSON with extended
    data type support. If you know how to handle JSON documents, you should have no
    problem.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB文档实际上是BSON文档，是JSON的超集，支持扩展的数据类型。如果您知道如何处理JSON文档，您应该不会有问题。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If JSON means nothing to you, just take a look at [http://www.w3schools.com/json/](http://www.w3schools.com/json/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JSON对您毫无意义，只需查看[http://www.w3schools.com/json/](http://www.w3schools.com/json/)。
- en: 'Let''s install MongoDB locally in order to try out some examples:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地安装MongoDB，以便尝试一些例子：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, from console, type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从控制台输入：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You''ll enter the MongoDB interactive console. From it, you may execute commands,
    add documents to your database, query, update, or remove. Anything you can achieve
    grammatically, you may also achieve through the console. Now, let''s understand
    the two important MongoDB concepts: databases and collections.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将进入MongoDB交互式控制台。从中，您可以执行命令，向数据库添加文档，查询、更新或删除。您可以通过控制台实现的任何语法，也可以通过控制台实现。现在，让我们了解两个重要的MongoDB概念：数据库和集合。
- en: 'Inside MongoDB, your documents are grouped inside collections, while collections
    are grouped inside databases. So, after connecting to MongoDB, the first thing
    you should do is to choose which database you plan to use. You do not need to
    create the database, connecting to it is enough to create the database. The same
    case is applicable for the collections. You also do not need to define your document
    structure prior to using it, nor are you required to implement complex altering
    commands if you decide your documents structure should change. Here''s an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，您的文档被分组在集合内，而集合被分组在数据库内。因此，在连接到MongoDB后，您应该做的第一件事是选择要使用的数据库。您不需要创建数据库，连接到它就足以创建数据库。对于集合也是一样。您也不需要在使用文档之前定义其结构，也不需要实现复杂的更改命令，如果您决定文档结构应该更改。这里有一个例子：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we switch to the example database, then we insert a new
    document into the employees collection (we do not need to create it before use)
    and eventually, we search for it using a regular expression. The MongoDB console
    is actually a JavaScript console, so new `Date` is actually the JavaScript class
    `Date` being instantiated. It's very simple.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们切换到示例数据库，然后将一个新文档插入到员工集合中（我们不需要在使用之前创建它），最后，我们使用正则表达式搜索它。MongoDB控制台实际上是一个JavaScript控制台，因此新的`Date`实际上是JavaScript类`Date`的实例化。非常简单。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're not familiar with JavaScript, visit [http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp)
    for a nice overview.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉JavaScript，请访问[http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp)了解一个很好的概述。
- en: We can store inside any JSON-type documents, also a few others. Visit [http://docs.mongodb.org/manual/reference/bson-types/](http://docs.mongodb.org/manual/reference/bson-types/)
    for the full list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以存储任何JSON类型的文档，还有其他一些类型。访问[http://docs.mongodb.org/manual/reference/bson-types/](http://docs.mongodb.org/manual/reference/bson-types/)获取完整列表。
- en: 'Regarding proper usage of MongoDB, just keep a few golden rules in mind:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正确使用MongoDB，只需记住几个黄金规则：
- en: Avoid keeping data from one collection to another as MongoDB does not *like*
    joins
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将数据从一个集合保留到另一个集合，因为MongoDB不喜欢*连接*
- en: Having document values as lists is OK in MongoDB, even expected
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中，将文档值作为列表是可以的，甚至是预期的
- en: Proper document indexes (not covered in this book) are key to good performance
    in MongoDB
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中，适当的文档索引（本书未涉及）对性能至关重要
- en: Writes are much slower than reads and may affect overall performance
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入比读取慢得多，可能会影响整体性能
- en: MongoEngine
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoEngine
- en: MongoEngine is a terrific Python library to access and manipulate MongoDB documents
    and uses **PyMongo**, the MongoDB recommended Python library underneath.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine是一个非常棒的Python库，用于访问和操作MongoDB文档，并使用**PyMongo**，MongoDB推荐的Python库。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As PyMongo does not have a **Document-object Mapper** (**DOM**), we are not
    using it directly. Nonetheless, there will be cases where the MongoEngine API
    will not be enough and you'll need to use PyMongo to achieve your goal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PyMongo没有**文档对象映射器**（**DOM**），我们不直接使用它。尽管如此，有些情况下MongoEngine API将不够用，您需要使用PyMongo来实现您的目标。
- en: It has its own consulting API and document to class mapper that allows you to
    work with the documents in a similar way you would work with SQLAlchemy ORM. That's
    a good thing because MongoDB is schema-less. It does not enforce the schema as
    a relational database would do. That way you don't have to declare how your document
    should look like before using it. MongoDB just doesn't care!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它有自己的咨询API和文档到类映射器，允许您以与使用SQLAlchemy ORM类似的方式处理文档。这是一个好事，因为MongoDB是无模式的。它不像关系数据库那样强制执行模式。这样，您在使用之前不必声明文档应该是什么样子。MongoDB根本不在乎！
- en: In actual daily development, knowing exactly what kind of information you're
    supposed to store in a document is a great anti-madness feature and MongoEngine
    gives it to you out of the box.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的日常开发中，确切地知道您应该在文档中存储什么样的信息是一个很好的反疯狂功能，MongoEngine可以直接为您提供。
- en: 'As you already have MongoDB on your machine, just install the MongoEngine library
    to start coding with it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的机器上已经安装了MongoDB，只需安装MongoEngine库即可开始使用它编码：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s add "Rosie Rinn" to the database using our new library:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的新库将“Rosie Rinn”添加到数据库中：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Understanding our example: first, we create a MongoDB connection with the `example`
    database, then define our employee document just like we did with SQLAlchemy,
    and eventually, we insert our employee "Rosie" and query to see whether everything
    is OK.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们的示例：首先，我们使用`example`数据库创建了一个MongoDB连接，然后像使用SQLAlchemy一样定义了我们的员工文档，最后，我们插入了我们的员工“Rosie”并查询是否一切正常。
- en: When declaring our `Employee` class, you may have noticed we had to define each
    field with its proper field type. If MongoDB is schema-less, why is that? MongoEngine
    enforces the type of each model field. If you had `IntField` defined for your
    model and provided it a string value, MongoEngine would raise a validation error
    as that is not a proper field value. Also, we defined a `__unicode__` method for
    `Employee` in order to have it print the employee's name in our loop. The `__repr__`
    will not work here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明我们的`Employee`类时，您可能已经注意到我们必须使用适当的字段类型定义每个字段。如果MongoDB是无模式的，为什么会这样？MongoEngine强制执行每个模型字段的类型。如果您为模型定义了`IntField`并为其提供了字符串值，MongoEngine将引发验证错误，因为那不是适当的字段值。此外，我们为`Employee`定义了一个`__unicode__`方法，以便在循环中打印员工的姓名。`__repr__`在这里不起作用。
- en: As MongoDB does not support transactions (MongoDB is not ACID, remember?), neither
    does MongoEngine, every operation we do is atomic. As we create our "Rosie" and
    call the `save` method, "Rosie" is inserted in the database at once; there is
    no need to commit the changes or anything like that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB不支持事务（MongoDB不是ACID，记住？），MongoEngine也不支持，我们进行的每个操作都是原子的。当我们创建我们的“Rosie”并调用`save`方法时，“Rosie”立即插入数据库；不需要提交更改或其他任何操作。
- en: At last, we have the database consult where we search for "Rosie". To query
    a chosen collection, you should use the `objects` handler available in every MongoEngine
    document. It exposes a Django-like interface for querying with support to operations
    such as `contains`, `icontains`, `ne`, `lte`, and others. For a full list of query
    operators, visit [https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators](https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有数据库查询，我们搜索“Rosie”。要查询所选集合，应使用每个MongoEngine文档中可用的`objects`处理程序。它提供了类似Django的界面，支持操作，如`contains`，`icontains`，`ne`，`lte`等。有关查询运算符的完整列表，请访问[https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators](https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators)。
- en: Flask-MongoEngine
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-MongoEngine
- en: 'MongoEngine is pretty easy by itself, but someone thought things could go better,
    and there we have Flask-MongoEngine. It gives you three main features:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine本身非常容易，但有人认为事情可以变得更好，于是我们有了Flask-MongoEngine。它为您提供了三个主要功能：
- en: Flask-DebugToolbar Integration (weeee!)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-DebugToolbar集成（嘿嘿！）
- en: Django-like querysets (`get_or_404`, `first_or_404`, `paginate`, `paginate_field`)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似Django的查询集（`get_or_404`，`first_or_404`，`paginate`，`paginate_field`）
- en: Connection management
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接管理
- en: Flask-DebugToolbar is a neat Flask extension inspired by the Django-DebugToolbar
    extension that keeps track of what is happening inside your application behind
    the hood, such as HTTP headers used in a request, CPU time, number of active MongoDB
    connections, and others.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-DebugToolbar是一个漂亮的Flask扩展，受到Django-DebugToolbar扩展的启发，它跟踪应用程序在幕后发生的事情，例如请求中使用的HTTP标头，CPU时间，活动MongoDB连接的数量等。
- en: The Django-like queries are a helpful feature as they allow you to avoid some
    boring coding here and there. The `get_or_404(*args, **kwargs)` query method will
    raise a 404 HTTP page if the document being looking for is not found (it uses
    a `get`, internally). In case you're building a blog, you might like to use this
    little fellow while loading a specific post entry. The `first_or_404()` query
    method is similar, but works with the collection. If the collection is empty,
    it raises a 404 HTTP page. The `paginate(page, per_page)` query is actually a
    very helpful query method. It provides you with a pagination interface out of
    the box. It will not work well with huge collections because MongoDB requires
    a different strategy in these cases, but most of the time, it will be all you
    need. The `paginate_field(field_name, doc_id, page, per_page)` is a more specific
    version of paginate as you'll be paginating through a single document field and
    not a collection. It is very useful when you have a document where one of the
    fields is a huge list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类似Django的查询是一个很有用的功能，因为它们可以帮助你避免一些无聊的编码。`get_or_404(*args, **kwargs)`查询方法会在未找到要查找的文档时引发404
    HTTP页面（它在内部使用`get`）。如果你正在构建一个博客，你可能会喜欢在加载特定的文章条目时使用这个小家伙。`first_or_404()`查询方法类似，但适用于集合。如果集合为空，它会引发404
    HTTP页面。`paginate(page, per_page)`查询实际上是一个非常有用的查询方法。它为你提供了一个开箱即用的分页界面。它在处理大型集合时效果不佳，因为在这些情况下MongoDB需要不同的策略，但大多数情况下，它就是你所需要的。`paginate_field(field_name,
    doc_id, page, per_page)`是paginate的更具体版本，因为你将对单个文档字段进行分页，而不是对集合进行分页。当你有一个文档，其中一个字段是一个巨大的列表时，它非常有用。
- en: 'Now, let''s look at a full example with `flask-mongoengine`. First, let''s
    install the library in our virtual environment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个完整的`flask-mongoengine`示例。首先，在我们的虚拟环境中安装这个库：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now on to coding:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始编码：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our Flask-MongoEngine example is pretty similar to our Flask-SQLAlchemy example.
    Besides differences in the imports, there is the MongoDB configuration, as MongoDB
    requires different parameters; we have the `birthday` field type as MongoEngine
    does not support `DateField`; there is birthday format overwrite as the default
    string format for `datetimefield` is different than what we want; and we have
    the changes in the `index` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flask-MongoEngine示例与Flask-SQLAlchemy示例非常相似。除了导入的差异之外，还有MongoDB的配置，因为MongoDB需要不同的参数；我们有`birthday`字段类型，因为MongoEngine不支持`DateField`；有生日格式的覆盖，因为`datetimefield`的默认字符串格式与我们想要的不同；还有`index`方法的更改。
- en: As we do not have to handle sessions with Flask-MongoEngine, we just remove
    all references to it. We also change how `employee_list` is built.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要使用Flask-MongoEngine处理会话，我们只需删除所有与它相关的引用。我们还改变了`employee_list`的构建方式。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As MongoDB does not parse the data you send to it in an attempt to figure out
    what the query is about, you do not have SQL injection-like problems with it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB不会解析你发送给它的数据以尝试弄清楚查询的内容，所以你不会遇到SQL注入的问题。
- en: Relational versus NoSQL
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型与NoSQL
- en: You might be wondering when to use relational and when to use NoSQL. Well, given
    the techniques and technologies in existence today, I would recommend you work
    with the type you feel better working with. NoSQL brags about being schema-less,
    scalable, fast, and so on, but relational databases are also quite fast for most
    of your needs. A few relational databases, such as Postgres, even support documents.
    What about scaling? Well, most projects do not need to scale as they will never
    be big enough. Others, just scale with their relational database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道何时使用关系型数据库，何时使用NoSQL。嗯，鉴于今天存在的技术和技术，我建议你选择你感觉更适合的类型来工作。NoSQL吹嘘自己是无模式、可扩展、快速等，但关系型数据库对于大多数需求也是相当快速的。一些关系型数据库，比如Postgres，甚至支持文档。那么扩展呢？嗯，大多数项目不需要扩展，因为它们永远不会变得足够大。其他一些项目，只需与它们的关系型数据库一起扩展。
- en: If there is no *important* reason to pick one or the other for native schema-less
    support or full ACID support, either of them will be good enough. Even security-wise,
    there are no big differences worth mentioning. MongoDB has its own authorization
    scheme as most relational databases do, and, if properly configured, both are
    just as secure. Usually, the application layer is more troublesome in this matter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有*重要*的原因来选择原生无模式支持或完整的ACID支持，它们中的任何一个都足够好。甚至在安全方面，也没有值得一提的大差异。MongoDB有自己的授权方案，就像大多数关系型数据库一样，如果配置正确，它们都是一样安全的。通常，应用层在这方面更加麻烦。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was pretty intense! We had an overview of relational and NoSQL
    databases, we learned about MongoDB and MongoEngine, SQLite and SQLAlchemy, and
    how to use extensions to integrate Flask with each. Knowledge is stacking up fast!
    You're now capable of creating more complex web applications with database support,
    custom validation, CSRF protection, and user communication.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章非常紧凑！我们对关系型和NoSQL数据库进行了概述，学习了MongoDB和MongoEngine，SQLite和SQLAlchemy，以及如何使用扩展来将Flask与它们集成。知识积累得很快！现在你能够创建更复杂的带有数据库支持、自定义验证、CSRF保护和用户通信的网络应用程序了。
- en: In the next chapter, we'll learn about REST, its advantages, and how to create
    services to be consumed by your app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于REST的知识，它的优势，以及如何创建服务供应用程序消费。
