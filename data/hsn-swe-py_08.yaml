- en: Creating Business Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建业务对象
- en: 'While examining the logical architecture of `hms_sys` in [Chapter 7](cabfde73-7c51-4741-8832-ca8427793869.xhtml), *Setting
    up Projects and Processes,* a handful of common business object types surfaced
    across the entire scope of the system:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](cabfde73-7c51-4741-8832-ca8427793869.xhtml)中检查`hms_sys`的逻辑架构，*设置项目和流程*，整个系统范围内出现了一些常见的业务对象类型：
- en: '![](assets/253f3c63-fe1e-4bb4-80cc-0b2ae4bba3fd.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/253f3c63-fe1e-4bb4-80cc-0b2ae4bba3fd.png)'
- en: 'The objects, as displayed in the preceding diagram, are explained as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示的对象，解释如下：
- en: An **Artisan** object represents a single **Artisan**—an end user who creates
    product items to be sold, and who makes those products available to the HMS Central
    Office through the system. **Artisans** are collected in the Central Office's
    data structure, and can be managed to a certain extent by Central Office staff,
    but the majority of their actual data needs to be owned and managed by the individual
    artisans themselves; that way, they have as much control over their information
    as possible, and Central Office staff aren't put in the position of managing data
    changes for artisans if, for example, they change their address, or want to add
    or change a company name.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**Artisan**对象代表一个**Artisan**——一个最终用户，他创建要出售的产品项目，并通过系统将这些产品提供给HMS中央办公室。**Artisans**被收集在中央办公室的数据结构中，并且在一定程度上可以由中央办公室工作人员管理，但是他们的实际数据大部分需要由个体工匠自己拥有和管理；这样，他们可以尽可能地控制自己的信息，中央办公室工作人员不必管理工匠的数据更改，例如，如果他们更改地址，或者想要添加或更改公司名称。
- en: A **Product** is a representation of a physical object, something that an Artisan
    has created that is for sale.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品**是一个物理对象的表示，是工匠创造并出售的物品。'
- en: An **Order** is the result of a customer placing an order for a Product through
    the HMS web store.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单是顾客通过HMS网店订购产品的结果。
- en: 'These three object types also infer two others that were not called out earlier:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种对象类型还暗示了另外两种之前没有提到的对象类型：
- en: A **Customer**, representing an actual customer that placed an **Order**, and
    that can be attached to one or more orders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表实际下订单的顾客，并且可以附加到一个或多个订单
- en: An **Address**, representing a physical location that something could be shipped
    to or from, which can also be attached to one or more orders, may be a property
    of a **Customer**, and almost certainly will be a property of an **Artisan**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址**，代表可以发货或收货的物理位置，也可以附加到一个或多个订单，可能是**顾客**的属性，几乎肯定是**工匠**的属性'
- en: This chapter will cover the implementation of those objects as a common class
    library that can be leveraged by the application and service projects' code, including
    the design, implementation, automated testing, and build process that turns it
    into a deployable package.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍将这些对象实现为通用类库的实现，该类库可以被应用程序和服务项目的代码利用，包括设计、实现、自动化测试和构建过程，将其转化为可部署的包。
- en: 'This chapter covers the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Iteration goals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代目标
- en: Assembly of stories and tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事和任务的组装
- en: A quick review of classes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的快速审查
- en: Implementing the basic business objects in `hms_sys`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_sys`中实现基本业务对象
- en: Testing the business objects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试业务对象
- en: Distribution and installation considerations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发和安装考虑
- en: Quality assurance and acceptance
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证和验收
- en: Operation/use, maintenance, and decommissioning considerations
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作/使用、维护和停用考虑
- en: Iteration goals
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代目标
- en: 'The deliverable for this iteration, then, is a class library that can be installed
    alongside or incorporated with the packages and code of the real projects—the
    user applications and the service—to provide the common representational structure
    of these business objects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次迭代的交付成果是一个类库，可以与真实项目的包和代码一起安装或合并，用户应用程序和服务可以提供这些业务对象的通用表示结构：
- en: The `hms_core` package/library
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_core`包/库'
- en: Unit tested
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Capable of being built as a free standing package
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够作为独立包构建
- en: 'Includes base classes that provide baseline representations of the following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括提供以下基本表示的基类：
- en: Artisans
  id: totrans-26
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠
- en: Customers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾客
- en: Orders
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Products
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Assembly of stories and tasks
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事和任务的组装
- en: 'Since the components of the business objects package are intended to be consumed
    or used by other packages in the system, most of the relevant stories are still
    focused on providing something that a developer needs:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于业务对象包的组件旨在被系统中的其他包消耗或使用，因此大部分相关故事仍然专注于提供开发人员需要的东西：
- en: 'As a developer, I need a common definition and functional structure to represent
    addresses in the system, so that I can incorporate them into the parts of the
    system that need them:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的定义和功能结构来表示系统中的地址，以便我可以将它们合并到需要它们的系统部分中：
- en: Define a `BaseAddress` **Abstract Base Class **(**ABC**)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`BaseAddress`抽象基类（ABC）
- en: Implement the `BaseAddress` ABC
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`BaseAddress` ABC
- en: Unit test the `BaseAddress` ABC
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BaseAddress` ABC进行单元测试
- en: 'As a developer, I need a common definition and functional structure to represent
    artisans in the system, so that I can incorporate them into the parts of the system
    that need them:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的定义和功能结构来表示系统中的工匠，以便我可以将它们合并到需要它们的系统部分中：
- en: Define a `BaseArtisan` ABC
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`BaseArtisan` ABC
- en: Implement the `BaseArtisan` ABC
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`BaseArtisan` ABC
- en: Unit test the `BaseArtisan` ABC
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BaseArtisan` ABC进行单元测试
- en: 'As a developer, I need a common definition and functional structure to represent
    customers in the system, so that I can incorporate them into the parts of the
    system that need them:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的定义和功能结构来表示系统中的顾客，以便我可以将它们合并到需要它们的系统部分中：
- en: Define a `BaseCustomer` ABC
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`BaseCustomer` ABC
- en: Implement the `BaseCustomer` ABC
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`BaseCustomer` ABC
- en: Unit test the `BaseCustomer` ABC
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BaseCustomer` ABC进行单元测试
- en: 'As a developer, I need a common definition and functional structure to represent
    orders in the system, so that I can incorporate them into the parts of the system
    that need them:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的定义和功能结构来表示系统中的订单，以便我可以将它们合并到需要它们的系统部分中：
- en: Define a `BaseOrder` ABC
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`BaseOrder` ABC
- en: Implement the `BaseOrder` ABC
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`BaseOrder` ABC
- en: Unit test the `BaseOrder`  ABC
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BaseOrder` ABC进行单元测试
- en: 'As a developer, I need a common definition and functional structure to represent
    products in the system, so that I can incorporate them into the parts of the system
    that need them:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个通用的定义和功能结构来表示系统中的产品，以便我可以将它们合并到需要它们的系统部分中：
- en: Define a `BaseProduct` ABC
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`BaseProduct` ABC
- en: Implement the `BaseProduct` ABC
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`BaseProduct` ABC
- en: Unit test the `BaseProduct` ABC
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BaseProduct` ABC进行单元测试
- en: 'As an **Artisan**, I need the business objects library to be installed with
    my application so that the application will work as needed without me having to
    install dependent components for it:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为**Artisan**，我需要将业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装它的依赖组件：
- en: Determine whether `setup.py` based packaging can include packages from outside
    the local project structure, and implement it if it can
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定`setup.py`是否可以基于包含来自本地项目结构之外的包，并在可以的情况下实现它
- en: Otherwise, implement `Makefile` based processes for including `hms_core` in
    the other projects' packaging processes
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，实现基于`Makefile`的过程，将`hms_core`包含在其他项目的打包过程中
- en: 'As a Central Office user, I need the business objects library to be installed
    with my application so that the application will work as needed without me having
    to install dependent components of it:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要将业务对象库与我的应用程序一起安装，以便应用程序能够按需工作，而无需我安装它的依赖组件：
- en: Verify that the **Artisan** packaging/installation process will also work for
    Central Office installations
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证**Artisan**打包/安装过程是否也适用于中央办公室的安装
- en: 'As a system administrator, I need the business objects library to be installed
    with the **Artisan** gateway service so that it will work as needed without me
    having to install dependent components of it:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为系统管理员，我需要安装业务对象库与**Artisan**网关服务，以便它能够按需工作，而无需我安装它的依赖组件：
- en: Verify that the **Artisan** packaging/installation process will also work for
    **Artisan** gateway installations
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证**Artisan**打包/安装过程是否也适用于**Artisan**网关安装
- en: It's worth noting that while this design starts by defining a lot of abstract
    classes, that is not the only way it could have gone. Another viable option would
    have been to start with simple Concrete Classes in each of the other libraries,
    then extract the common requirements across those, and create ABCs to enforce
    those requirements. That approach would yield concrete functionality sooner, while
    relegating structural and data standards to later, and requiring the movement
    of a fair chunk of code from the Concrete Classes back down to the ABCs, but it's
    still a viable option.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然这种设计从定义了许多抽象类开始，但这并不是唯一的方式。另一个可行的选择是从每个其他库中的简单Concrete Classes开始，然后提取这些类的共同要求，并创建ABC来强制执行这些要求。这种方法会更快地产生具体的功能，同时将结构和数据标准推迟到后面，并要求将相当多的代码从Concrete
    Classes移回到ABC，但这仍然是一个可行的选择。
- en: A quick review of classes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速审查类
- en: A class, in any object-oriented language, can be thought of as a blueprint for
    creating objects—defining what those objects, as instances of the class, are,
    have, and can do. Classes frequently represent real world objects, be they people,
    places, or things, but even when they don't, they provide a concise set of data
    and capabilities/functionality that fits into a logical conceptual unit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何面向对象的语言中，类都可以被视为创建对象的蓝图，定义了这些对象作为类的实例的特征、拥有的东西以及可以做的事情。类经常代表现实世界的对象，无论是人、地方还是物品，但即使它们不是，它们也提供了一套简洁的数据和功能/功能，适合逻辑概念单元。
- en: 'As `hms_sys` development progresses, there will be several classes, both concrete
    and abstract, that will be designed and implemented. In most cases, the design
    will start with a class diagram—a drawing of one-to-many classes that shows the
    structure of each and any relationship between them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`hms_sys`的开发进展，将设计和实现几个类，包括具体类和抽象类。在大多数情况下，设计将从类图开始，即一对多类的绘图，显示每个类的结构以及它们之间的任何关系：
- en: '![](assets/8a4d1e52-b870-4add-bea0-2cba58b74892.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8a4d1e52-b870-4add-bea0-2cba58b74892.png)'
- en: A **Concrete Class** is intended to be instantiated, to have object instances
    created from the blueprint it provides. An **Abstract Class** provides baseline
    functionality, interface requirements, and type identity for objects that have
    specific **Class Members** (concrete or abstract) that will be inherited by, or
    that require implementation in, classes that derive from them. The scope of those
    members, both **Properties** and **Methods**, are indicated by **+** for public
    members, **-** for private members, and **#** for protected members by convention,
    though as already noted, Python doesn't have truly protected or private members.
    Still, those at least provide some indication of what the intended scope of a
    member is.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Concrete Class**旨在被实例化，从提供的蓝图创建对象实例。**Abstract Class**为具有特定**Class Members**（具体或抽象）的对象提供基线功能、接口要求和类型标识，这些成员将被继承或需要在从它们派生的类中实现。这些成员的范围，包括**Properties**和**Methods**，按照约定，公共成员用**+**表示，私有成员用**-**表示，受保护的成员用**#**表示，尽管如前所述，Python并没有真正的受保护或私有成员。不过，这些至少提供了成员的预期范围的一些指示。'
- en: Implementing the basic business objects in hms_sys
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在hms_sys中实现基本的业务对象
- en: At this point in the development process, we simply don't know whether the exact
    same functionality for all of the business object classes will be in play in the
    two applications and the service that are going to be built. The data ownership
    rules—determination of what users can create, update, or delete what data inside
    an object—haven't been detailed enough to make those decisions yet. We do, however,
    have enough information, based solely on the purposes of those objects, to start
    defining what data they represent, and what constraints should exist around those
    data points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程的这一阶段，我们只是不知道所有业务对象类的确切功能是否将在即将构建的两个应用程序和服务中发挥作用。数据所有权规则——确定用户可以在对象内创建、更新或删除哪些数据——尚未详细说明，因此还不能做出这些决定。然而，仅基于这些对象的目的，我们已经有足够的信息来开始定义它们代表的数据以及这些数据点周围应该存在的约束。
- en: We may have enough information here and now to know that certain functionalities
    need to exist for some of these object types as well—that **Artisan** objects
    need the ability to add and remove related **Product** objects, for example—even
    if we don't know yet how that's going to work, or whether there are data ownership
    rules around those. We can also make some educated guesses around which classes
    will need to be abstract (because their actual implementations will vary between
    the applications and the service).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经有足够的信息来知道某些对象类型需要存在某些功能，例如，**Artisan**对象需要能够添加和删除相关的**Product**对象，即使我们还不知道这将如何运作，或者是否有关于这些对象的数据所有权规则。我们还可以对哪些类需要是抽象的做出一些合理的猜测（因为它们的实际实现将在应用程序和服务之间变化）。
- en: Address
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Address
- en: The `Address` class represents a physical location—a place that something could
    be mailed or shipped to, or that could be found on a map. The properties of an
    address are going to be consistent no matter what context the objects are encountered
    in—that is, an address is an address whether it's associated with an **Artisan**,
    a **Customer**, or an **Order**—and it feels safe to assume at this point that
    the whole of any address can be altered by an object that it is a member of, or
    none of it can be. At this point, barring information to the contrary, it doesn't
    feel like storing addresses as separate items in the backend data structure will
    be necessary; although it's possible that they'll have a meaningful independent
    existence of their own, there's no reason to assume that they will.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类表示一个物理位置——可以将某物邮寄或运送到的地方，或者可以在地图上找到的地方。无论对象在什么上下文中遇到，地址的属性都将是一致的——也就是说，地址是地址，无论它是与**Artisan**、**Customer**还是**Order**相关联的——并且在这一点上，可以放心地假设任何地址的整体都可以被其所属的对象更改，或者都不可以。在这一点上，除非有相反的信息，否则似乎不需要将地址作为后端数据结构中的单独项存储；尽管它们可能会有自己的有意义的独立存在，但没有理由假设它们会有。'
- en: 'With that in mind, making addresses an abstract class doesn''t feel like it''s
    necessary, at least not yet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，至少目前为止，将地址作为抽象类并不感觉是必要的：
- en: '![](assets/7887406d-de5a-4e06-9e15-6d0b50c80f46.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7887406d-de5a-4e06-9e15-6d0b50c80f46.png)'
- en: 'An **Address** is a dumb data object, at least so far; it consists of a data
    structure, but has no methods or functionality. The properties of the class themselves
    are fairly simple, and have a few rules around them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是一个愚蠢的数据对象，至少目前为止；它由一个数据结构组成，但没有方法或功能。类本身的属性相当简单，并且围绕它们有一些规则：
- en: '`street_address` is the street address of the location. It should be a single
    line string value, is required (cannot be empty), and should probably not allow
    any whitespace characters other than spaces. An example value of `street_address`
    would be `1234 Main Street`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`street_address`是位置的街道地址。它应该是一个单行字符串值，是必需的（不能是空的），并且可能不允许除空格之外的任何空白字符。`street_address`的一个示例值可能是`1234
    Main Street`。'
- en: '`building_address` is an optional second line of the address, used to indicate
    more detail about where at the street address the actual location is. Examples
    might include an apartment number, a suite or office location or number, and so
    on. If it''s present in any given address, it should be a string value with the
    same constraints as `street_address`, but, again, it''s an optional value.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`building_address`是地址的可选第二行，用于指示关于实际位置的街道地址的更多细节。示例可能包括公寓号、套房或办公室位置或编号等。如果在任何给定的地址中存在，它应该是一个具有与`street_address`相同约束的字符串值，但同样，它是一个可选值。'
- en: '`city` is a required string value, also restricted to a single line, and the
    same whitespace rules as `street_address`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`city`是一个必需的字符串值，同样限制为单行，并且与`street_address`具有相同的空白规则。'
- en: '`region` is an optional string value, with the same constraints, as are `postal_code`
    and `country`, at least for the time being.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`region`是一个可选的字符串值，具有与`postal_code`和`country`相同的约束，至少目前是这样。'
- en: These last three properties are difficult to generate rules around without some
    sort of country specific context. It's possible, though it seems unlikely, for
    addresses in some countries to not have regions or postal codes, while in other
    countries, they have completely different names and data requirements. By way
    of example, consider that in the United States, region and `postal_code` represent
    the **State** and **ZIP** **Code** (five numbers, with an optional dash and four
    more numbers), while in Canada they would represent a territory or province and
    a postal code that is alphanumeric. There may be a solution for some aspects of
    the requirements on a country by country basis, and that will be examined after
    the initial property definitions are taken care of.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后三个属性很难在没有某种特定国家上下文的情况下制定规则。在某些国家，地址可能没有地区或邮政编码，而在其他国家，它们可能有完全不同的名称和数据要求，尽管这似乎不太可能。例如，考虑到在美国，地区和`postal_code`代表**州**和**邮政编码**（五个数字，带有一个可选的破折号和另外四个数字），而在加拿大，它们代表一个领土或省份和一个字母数字混合的邮政编码。对于一些要求，可能会有一个按国家划分的解决方案，在初步处理完属性定义之后将对此进行检查。
- en: 'The initial implementation of `Address` is pretty straightforward; we start
    by defining a class with the properties that will be available:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`的初始实现非常简单；我们首先定义一个具有可用属性的类：'
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each of those `property` calls specify a getter, setter, and deleter method
    that then have to be implemented. The getter methods are all very simple, each
    returning the associated property value that stores the instance''s data for that
    property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`property`调用都指定了必须实施的getter、setter和deleter方法。getter方法都非常简单，每个方法都返回存储该属性实例数据的相关属性值：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The setter methods are also relatively simple, though there''s logic that has
    to be implemented in order to enforce the type and value rules noted earlier.
    The properties of Address, so far, fall into two categories:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管必须实施一些逻辑以强制执行前面提到的类型和值规则，但设置方法也相对简单。到目前为止，地址的属性分为两类：
- en: Required, non-empty, single line strings (such as `street_address`)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必填，非空，单行字符串（例如`street_address`）
- en: Optional (`None`) or non-empty, single line string values (`building_address`)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选（`None`）或非空，单行字符串值（`building_address`）
- en: 'The implementation for the required values will all follow the same pattern,
    using `street_address` as an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所需值的实现将都遵循相同的模式，以`street_address`为例：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The setter method process, then, from start to finish, is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方法的过程，从头到尾，如下所示：
- en: Make sure that the `value` submitted is a `str` type, and raises a `TypeError`
    if that's not the case
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保提交的`value`是`str`类型，并且如果不是这种情况则引发`TypeError`
- en: Create a list of forbidden characters—newline, carriage return, and tab, (`'\n'`,
    `'\r'`, `'\t'`)—that shouldn't be allowed in the value
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个禁止字符列表——换行符、回车符和制表符（`'\n'`、`'\r'`、`'\t'`）——不应该允许在值中出现
- en: Assume that the value is valid until otherwise determined (`is_valid = True`)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设该值有效，直到另有确定（`is_valid = True`）
- en: Check for the existence of each of those bad characters in the value, and if
    they are present, flags the value as invalid
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查值中是否存在这些非法字符，并且如果存在，则标记该值为无效
- en: Check to see if the value is only whitespace (`value.strip()`) or if any invalid
    characters were found, and if so, raises a `ValueError`
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查值是否只是空格（`value.strip()`）或是否找到了任何无效字符，如果是，则引发`ValueError`
- en: If no errors were raised, set the internal storage attribute for the property
    to the now verified value (`self._street_address = value`)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有引发错误，则将属性的内部存储属性设置为现在经过验证的值（`self._street_address = value`）
- en: This same code, with `street_address` changed to `city`, takes care of the city
    property's setter implementation. This property setter process/flow is going to
    come up repeatedly, in this iteration and iterations that follow. When it's in
    use from this point on, it'll be referred to as a standard required text line
    property setter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的代码，将`street_address`更改为`city`，处理了城市属性的setter实现。这个属性setter的过程/流程将反复出现，在这个迭代和后续的迭代中。从现在开始使用时，它将被称为标准必需文本行属性setter。
- en: 'The optional properties use a very similar structure, but check for (and allow)
    a `None` value first, since setting their values to `None` is technically valid/allowed.
    The `building_address` property setter serves as an example of this process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性使用非常相似的结构，但首先检查（并允许）`None`值，因为将它们的值设置为`None`在技术上是有效的/允许的。`building_address`属性setter就是这一过程的一个例子：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This setter method process, like the standard required text line property before
    it, will appear with some frequency, and will be referred to as a standard optional
    text line property setter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个setter方法的过程，就像前面的标准必需文本行属性一样，将会经常出现，并且将被称为标准可选文本行属性setter。
- en: 'The deleter methods are also going to be quite simple—all of these properties,
    if deleted, can be set to a value of `None` so that they still have a value (thus
    avoiding instances of  `AttributeError` if they are referenced elsewhere), but
    one that can be used to indicate that there isn''t a value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 删除方法也将非常简单——如果删除了这些属性中的任何一个，都可以将其设置为`None`，以便它们仍然具有值（从而避免在其他地方引用时出现`AttributeError`的实例），但可以用于指示没有值的值：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the property definitions and their underlying methods defined, all that
    remains to make the class usable is the definition of its `__init__` method, so
    that creation of an `Address` instance can actually accept and store the relevant
    properties.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义属性及其基础方法，使类可用的唯一剩下的就是定义其`__init__`方法，以便实际接受和存储相关属性的`Address`实例的创建。
- en: 'It''s tempting to just stick to a simple structure, with the various address
    elements accepted and required in the order that they''d be normally be used in,
    something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很诱人只坚持简单的结构，接受并要求各种地址元素的顺序与它们通常使用的顺序相同，类似于这样：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another approach, equally valid, would be to allow default values for the arguments
    that would translate to the optional properties of the instance created:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有效的另一种方法是允许参数的默认值，这些默认值将转换为实例创建的可选属性：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both approaches are perfectly valid from a functional standpoint—it would be
    possible to create an `Address` instance using either—but the first is probably
    going to be more easily understood, while the second would allow the creation
    of a minimal instance without having to worry about specifying every argument
    value every time. Making a decision about which argument structure to use should
    probably involve some serious thought about a variety of factors, including these:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能的角度来看，这两种方法都是完全有效的——可以使用任一种方法创建`Address`实例——但第一种方法可能更容易理解，而第二种方法则允许创建一个最小的实例，而无需每次都担心指定每个参数值。关于使用哪种参数结构应该涉及一些严肃的思考，包括以下因素：
- en: Who will be creating new `Address` instances?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁将创建新的`Address`实例？
- en: What do those `Address` creation processes look like?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些`Address`创建过程是什么样的？
- en: When and where will new `Address` instances be needed?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时何地需要新的`Address`实例？
- en: How will they be created? That is, will there be some sort of UI around the
    process with any consistency?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将如何被创建？也就是说，这个过程周围是否会有某种UI，并且是否会有任何一致性？
- en: The who question has a very simple answer, and one that mostly answers the other
    questions as well: pretty much any user may need to be able to create a new address.
    Central Office staff probably will in the process of setting up new **Artisan**
    accounts. **Artisans** may occasionally need to if they need to change their address.
    **Customers**, though only indirectly, will need to when they place their first
    order, and may well need to create addresses for shipping separate from their
    own default/billing addresses. Even the **Artisan** gateway service will probably
    need to create `Address` instances as part of the processes for handling movement
    of data back and forth.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “谁”这个问题有一个非常简单的答案，而且大多数情况下也能回答其他问题：几乎任何用户都可能需要能够创建新地址。中央办公室工作人员在设置新的**Artisan**账户时可能会需要。**Artisans**偶尔可能需要，如果他们需要更改他们的地址。**顾客**虽然只是间接地，在他们下第一个订单时会需要，而且可能需要为运输单独创建地址，而不是使用他们自己的默认/账单地址。甚至**Artisan**网关服务可能需要创建`Address`实例，作为处理数据来回移动的过程的一部分。
- en: 'In most of those cases, though, there will be some sort of UI involved: a web
    store form for the **Customer** and **Order **related items, and whatever GUI
    is in place in the **Artisan** and Central Office applications. With a UI sitting
    on top of the address creation process, the onus for passing arguments from that
    UI to `__init__` would only be of importance or concern to the developer. So those
    questions, though they shed some light on what the functional needs are, really
    don''t help much in making a choice between the two argument form possibilities.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，会涉及某种UI：**顾客**和**订单**相关项目的网店表单，以及**Artisan**和中央办公室应用程序中的任何GUI。在地址创建过程中有一个UI，将参数从UI传递给`__init__`的责任只对开发人员来说才重要或关注。因此，这些问题虽然能够揭示功能需求是什么，但在选择两种参数形式之间并没有太大帮助。
- en: 'That said, there''s no reason that the `__init__` can''t be defined one way,
    and another method created for Address to allow the other structure, a `standard_address`,
    perhaps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`__init__`可以以一种方式定义，而为`Address`创建另一种结构的方法，例如`standard_address`：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That then allows `__init__` to use the structure that leverages the various
    default argument values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就允许`__init__`使用结构，利用各种默认参数值：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That makes `Address` functionally complete, at least for the purposes of the
    story concerning it in this iteration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`Address`在功能上是完整的，至少对于本次迭代中关于它的故事来说是这样。
- en: 'As any class is undergoing development, it''s quite possible that questions
    will arise around use cases that the developer envisions, or that simply occur
    while considering some aspect of how the class works. Some examples that surfaced
    while `Address` was being fleshed out are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类正在开发过程中，开发人员可能会出现关于他们设想的用例的问题，或者在考虑类的某些方面时会出现问题。在`Address`被完善时出现的一些例子如下：
- en: What can/should happen if a non-default property value is deleted in an instance?
    If a required value is deleted, the instance is no longer well formed and is technically
    invalid as a result—should it even be possible to perform such a deletion?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在实例中删除了非默认属性值，会发生什么？如果删除了必需的值，那么实例将不再是完整的，从技术上讲是无效的结果——甚至可能会发生这样的删除吗？
- en: There is a Python module, `pycountry`, that gathers up ISO derived country and
    region information. Would it be desirable to try to leverage that data in order
    to ensure that country/region combinations are realistic?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个Python模块，`pycountry`，它收集ISO衍生的国家和地区信息。是否希望尝试利用这些数据，以确保国家/地区的组合是现实的？
- en: Will `Address` eventually need any sort of output capabilities? Label text,
    for example? Or maybe the ability to generate a row in a CSV file?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Address`最终是否需要任何输出能力？例如标签文本？或者可能需要生成CSV文件中的一行？'
- en: 'Such questions are probably worth saving somewhere, even if they never become
    relevant. If there isn''t some sort of project system repository for such things,
    or some process in place in the development team for preserving them so they don''t
    get lost, they can always be added to the code itself as some kind of comment,
    perhaps like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能值得保存在某个地方，即使它们从未变得相关。如果没有某种项目系统存储库来保存这些问题，或者开发团队中没有一些流程来保存它们，以免它们丢失，它们总是可以被添加到代码本身中，作为某种注释，也许像这样：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: BaseArtisan
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseArtisan
- en: The `Artisan` class represents an artisan who participates in the Hand Made
    Stuff marketplace—a person who creates products that are available to be sold
    through the Central Office's web store. Knowing that there will almost certainly
    be different functional rules for each different user's interaction with a final
    `Artisan` class, it makes sense to make an abstract class in the `hms_core` code
    base that defines the common functionality and requirements for any concrete `Artisan`
    in the other packages. We'll name that class `BaseArtisan`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Artisan`类代表参与手工制品市场的工匠——一个通过中央办公室的网店销售产品的人。知道几乎每个用户与最终`Artisan`类的交互都几乎肯定会有不同的功能规则，因此在`hms_core`代码库中创建一个抽象类来定义其他包中任何具体`Artisan`的共同功能和要求是有意义的。我们将把这个类命名为`BaseArtisan`。'
- en: 'Like the `Address` class we just completed, the design and implementation of
    `BaseArtisan` starts with a class diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们刚刚完成的`Address`类一样，`BaseArtisan`的设计和实现始于一个类图：
- en: '![](assets/0a445950-577b-44bb-9176-75d7383ad17d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a445950-577b-44bb-9176-75d7383ad17d.png)'
- en: It's not unusual for abstract classes to have a naming convention that indicates
    that they are abstract. In this case, the prefix of Base is that indicator, and
    will be used for other abstract classes as development progresses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类通常具有指示它们是抽象的命名约定。在这种情况下，Base的前缀就是这个指示符，并且将在开发过程中用于其他抽象类。
- en: '`BaseArtisan` is intended to provide a common set of state data rules and functionality
    for all of the properties associated with any **Artisan** in any part of the system.
    The properties themselves, then, will be concrete implementations. `BaseArtisan`
    is also intended to provide some (minimal) functional requirements, in the form
    of the `add_product` and `remove_product` methods. It''s a given, since artisans
    and products relate to each other, that a concrete `Artisan` object will need
    to be able to add and remove `Product` objects, but the specifics about how those
    processes work may well vary between the two applications and the services that
    are making use of that functionality, so they will be abstract—required to be
    overridden/implemented in any class that derives from `BaseArtisan`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: “BaseArtisan”旨在为系统中任何部分的任何“Artisan”关联的所有属性提供一组通用的状态数据规则和功能。属性本身将是具体的实现。此外，“BaseArtisan”还旨在以“add_product”和“remove_product”方法的形式提供一些（最小的）功能要求。由于工匠和产品彼此相关，因此一个具体的“Artisan”对象需要能够添加和删除“Product”对象，但是关于这些过程的具体细节可能会在两个应用程序和使用该功能的服务之间有所不同，因此它们将是抽象的——需要在从“BaseArtisan”派生的任何类中被覆盖/实现。
- en: This class diagram also includes the `Address` class that was created earlier,
    with a diamond ended connector between the two classes. That connection indicates
    that the `Address` class is used as an aggregated property of `BaseArtisan`—that
    is, that the address property of `BaseArtisan` is an instance of `Address`. That
    is also indicated in the address property itself, with an `<Address>` specified
    as the type of the address property. In simple terms, a `BaseArtisan` has an `Address`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该类图还包括了之前创建的“Address”类，两个类之间有一个菱形结束的连接器。该连接表示“Address”类被用作“BaseArtisan”的聚合属性——也就是说，“BaseArtisan”的地址属性是“Address”的一个实例。在地址属性本身中也有这种表示，地址属性的类型指定为“<Address>”。简单来说，一个“BaseArtisan”有一个“Address”。
- en: 'It would also be possible to define `BaseArtisan` as inheriting from `Address`.
    The class diagram for that relationship would be almost identical, except for
    the connector, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将“BaseArtisan”定义为从“Address”继承。该关系的类图几乎与上面相同，除了连接器，如下所示：
- en: '![](assets/74358f19-2088-48eb-8097-1f0d77f8e0b8.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74358f19-2088-48eb-8097-1f0d77f8e0b8.png)'
- en: In this relationship, a `BaseArtisan` is an `Address`—it would have all of the
    properties of an `Address`, as well as any method members that might be added
    down the line. Both of these relationships are perfectly legal, but there are
    advantages to using the aggregation (or composition) approach over relying on
    inheritance that are worth noting before moving on to the implementation of `BaseArtisan`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种关系中，“BaseArtisan”是一个“Address”——它将拥有“Address”的所有属性，以及可能在后续添加的任何方法成员。这两种关系都是完全合法的，但在继承上使用聚合（或组合）方法而不是依赖继承有一些值得注意的优势，这些优势值得在移动到“BaseArtisan”的实现之前注意。
- en: OO principles – composition over inheritance
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OO原则-组合优于继承
- en: It's probable that the most obvious of those advantages is that the structure
    is easily understood. An `Artisan` instance will have an address property that
    is another object, and that object has its own relevant properties. At the `Artisan`
    level, where there is only one address of any importance, that might not seem
    significant. Other objects, however, such as `Customer` and `Order`, might have
    more than one associated address (billing and shipping addresses, for example),
    or even several: `Customer` might have several shipping addresses that need to
    be held on to and available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能最明显的优势之一是结构容易理解。一个“工匠”实例将有一个地址属性，该属性是另一个对象，该对象有其自己的相关属性。在“工匠”级别上，只有一个重要的地址，这可能看起来并不重要。然而，其他对象，比如“顾客”和“订单”，可能有多个关联的地址（例如，账单地址和送货地址），甚至可能有几个：“顾客”可能有几个需要保留和可用的送货地址。
- en: As a system's object library becomes larger and more complex, using a purely
    inheritance based design approach will inevitably result in large trees of classes,
    many of which may do nothing more than provide functionality solely for the purpose
    of being inherited. A composition based design will reduce that complexity, probably
    significantly more so in larger and more complex libraries, since the functionality
    will be encapsulated in single classes, instances of which become properties themselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的对象库变得越来越庞大和复杂，使用纯继承的设计方法将不可避免地导致大量的类树，其中许多类可能只是提供功能，目的仅仅是为了被继承。基于组合的设计将减少这种复杂性，在更大更复杂的库中可能会显著减少，因为功能将封装在单个类中，这些类的实例本身就成为属性。
- en: 'This sort of composition does have some potential drawbacks too, though: deeply
    nested objects, properties of properties of properties *ad nauseam*, can result
    in long chains of data structure. For example, if an `order` in the context of
    `hms_sys` has a `customer` that in turn has a `shipping_address`, finding the
    `postal_code` of that address from the **Order** would look something like `order.customer.shipping_address.postal_code`.
    That''s not a terribly deep or complex path to get the data involved, and because
    the property names are easily understood it''s not difficult to understand the
    entire path. At the same time, it''s not hard to imagine this sort of nesting
    getting out of control, or relying on names that aren''t as easily understood.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种组合也有一些潜在的缺点：深度嵌套的对象，属性的属性的属性*无休止地*，可能会导致长链的数据结构。例如，在“hms_sys”的上下文中，如果一个“订单”有一个“顾客”，顾客又有一个“送货地址”，那么从“订单”中找到该地址的“邮政编码”看起来会像是“order.customer.shipping_address.postal_code”。这并不是一个非常深或复杂的路径来获取涉及的数据，因为属性名称很容易理解，所以理解整个路径并不困难。与此同时，很容易想象这种嵌套会失控，或者依赖于不那么容易理解的名称。
- en: It's also possible (perhaps likely) that a need will arise for a class to provide
    a local implementation of some composed property class methods, which adds to
    the complexity of the parent object's class. By way of example, assume that the
    address class of the `shipping_address` just mentioned has a method that checks
    various shipping APIs and returns a list of them sorted from lowest to highest
    cost—call it `find_best_shipping`. If there is a requirement that the `order`
    objects be able to use that functionality, that will probably end up with a `find_best_shipping`
    method being defined at the order class level that calls the address-level method
    and returns the relevant data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能（也许很可能）需要一个类来提供一些组合属性类方法的本地实现，这增加了父对象类的复杂性。举个例子，假设刚才提到的`shipping_address`的地址类有一个方法，检查各种运输API并返回一个从最低到最高成本排序的列表—称之为`find_best_shipping`。如果有一个要求`order`对象能够使用该功能，那可能最终会在订单类级别定义一个`find_best_shipping`方法，调用地址级别的方法并返回相关数据。
- en: Neither of those are significant drawbacks, however. Provided that there is
    some discipline exercised in making sure that the design is logical and easily
    understood, with meaningful member names, they will probably be no worse than
    tedious.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些都不是重大的缺点。只要在确保设计逻辑和易于理解，成员名称有意义的情况下进行一些纪律性的练习，它们可能不会比单调更糟。
- en: 'From a more pure, object oriented standpoint, a more significant concern is
    the diamond problem. Consider the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从更纯粹的面向对象的角度来看，一个更重要的问题是菱形问题。考虑以下代码：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Diagrammed, these classes form a diamond shape, hence the diamond problem''s
    name:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类形成了一个菱形，因此有了菱形问题的名称：
- en: '![](assets/5d7e7c53-3fd0-4fde-a5d8-0ba31e420401.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d7e7c53-3fd0-4fde-a5d8-0ba31e420401.png)'
- en: 'What happens upon the execution of the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行时会发生什么：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which method will be called? Unless the language itself defines how to resolve
    the ambiguity, the only thing that is probably safe to assume is that the method
    of `Root` will not be called, since both the `Left` and `Right` classes override
    it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个方法会被调用？除非语言本身定义了如何解决歧义，否则唯一可以肯定的是`Root`的方法不会被调用，因为`Left`和`Right`类都对其进行了重写。
- en: 'Python resolves ambiguities of this nature by using the order of inheritance
    specified in the class'' definition as a **Method Resolution Order** (**MRO**).
    In this case, because `Bottom` is defined as inheriting from `Left` and `Right`—`class
    Bottom(Left, Right)`—that is the order that will be used to determine which `method`
    of the several available will actually be executed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过使用类定义中指定的继承顺序作为**方法解析顺序**（**MRO**）来解决这种性质的歧义。在这种情况下，因为`Bottom`被定义为从`Left`和`Right`继承—`class
    Bottom(Left, Right)`—这个顺序将被用来确定实际执行哪个可用的`method`：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although it seems unlikely that any of the installable `hms_sys` components
    will ever reach a level of complexity where inheritance issues would be a significant
    concern, there is no guarantee that it will never happen. Given that, and that
    a refactoring effort to move from an inheritance based to a composition based
    structure would probably be both painful and prone to introducing breaking changes,
    a composition based approach, even with some of the drawbacks inherent to it,
    feels like a better design even at this point.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管似乎不太可能任何可安装的`hms_sys`组件会达到继承问题成为重大关注的程度，但并不能保证永远不会发生。鉴于这一点，以及从基于继承到基于组合的重构工作可能会非常痛苦并且容易引入破坏性变化，即使在这一点上，基于组合的方法，即使具有一些固有的缺点，也感觉像是更好的设计。
- en: Implementing BaseArtisan's properties
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现BaseArtisan的属性
- en: 'In order to represent an **Artisan** as a person (who may also have a company
    name), with a location and products, `BaseArtisan` provides six property members:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将**工匠**表示为一个人（可能还有公司名称），具有位置和产品，`BaseArtisan`提供了六个属性成员：
- en: '`contact_name` is the name of the contact person for an **Artisan**. It should
    be a standard required text line property, as defined earlier.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact_name`是**工匠**的联系人姓名。它应该是一个标准的必需文本行属性，如前所定义。'
- en: '`contact_email` is the email address of the person named in `contact_name`.
    It should be a well formed email address, and will be required.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact_email`是`contact_name`中提到的人的电子邮件地址。它应该是一个格式良好的电子邮件地址，并且是必需的。'
- en: '`company_name` is a standard optional text line property (optional because
    not all **artisans** will have a company name).'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`company_name`是一个标准的可选文本行属性（可选，因为并非所有**工匠**都有公司名称）。'
- en: '`address` will be required, and will be an instance of `Address`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`将是必需的，并且将是`Address`的一个实例。'
- en: '`website` is an optional web site address for the **Artisan**. If it''s present,
    it will need to be a well formed URL.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`website`是**工匠**的可选网站地址。如果存在，它将需要是一个格式良好的URL。'
- en: '`products` will be a collection of `BaseProduct` objects, in much the same
    way that `address` is a single `Address` instance. Some implementation details
    around product will be deferred until `BaseProduct` is fully defined.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products`将是`BaseProduct`对象的集合，方式与`address`是一个`Address`实例的方式相似。一些关于产品的实现细节将被推迟，直到`BaseProduct`被完全定义。'
- en: 'As before, the process starts with creating the class, and defining the properties
    whose implementations will be fleshed out next:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，流程从创建类开始，并定义其实现的属性：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The inclusion of `metaclass=abc.ABCMeta` defines `BaseArtisan` as an Abstract
    Base Class, using the `abc` module''s `ABCMeta` functionality:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将`metaclass=abc.ABCMeta`包含在内定义了`BaseArtisan`作为抽象基类，使用`abc`模块的`ABCMeta`功能：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since `company_name` and `contact_name` are standard optional and required text
    line implementations, as were described in creating the `Address` class, their
    implementations will follow the pattern established there, and will not be examined
    in any detail. The processes for both are identical to those for `Address.building_address`
    and `Address.street_address`, respectively—the only things that will change are
    the names of the getter, setter, and deleter methods and the state data attributes
    that store the properties' values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`company_name`和`contact_name`是标准的可选和必需的文本行实现，就像在创建`Address`类时描述的那样，它们的实现将遵循在那里建立的模式，并且不会被详细检查。它们的过程与`Address.building_address`和`Address.street_address`的过程相同，唯一变化的是getter、setter和deleter方法的名称以及存储属性的状态数据属性。
- en: 'Similarly, the `_get_` and `_del_` methods that are associated with all of
    the properties except for products will follow the same basic patterns that''ve
    been established already:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与除产品之外的所有属性相关的`_get_`和`_del_`方法将遵循已经建立的相同基本模式：
- en: Getter methods will simply return the value stored in the corresponding state
    storage attribute
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Getter方法将简单地返回存储在相应状态存储属性中的值
- en: Deleter methods will set the value of the corresponding state storage attribute
    to `None`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除方法将将相应状态存储属性的值设置为`None`
- en: 'The getter and deleter method implementations for `address`, `company_name`,
    and `contact_email`, for example, can be the exact same process as previously
    shown, even though `address` is not a simple value property and `contact_email`
    hasn''t been implemented yet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`address`、`company_name`和`contact_email`的getter和deleter方法的实现可以与先前显示的完全相同的过程，即使`address`不是一个简单的值属性，`contact_email`还没有被实现：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This probably feels like a lot of boilerplate, copy and paste code, but that's
    the cost of being able to perform the type and value checking that's handled by
    the setter methods. The setter methods themselves are where the magic happens
    that keeps the high degree of data type and integrity that's desired.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像大量样板文件，复制和粘贴的代码，但这是能够执行由setter方法处理的类型和值检查的成本。setter方法本身是保持所需的高度数据类型和完整性的魔法发生的地方。
- en: 'The setter for the `address` property is perhaps surprisingly simple, since
    all that really needs to be enforced is that any value passed to it must be an
    instance of the `Address` class. There is no value checking, since any `Address`
    instance that was successfully created will have performed its own type and value
    checks as part of the initialization process:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`address`属性的setter可能会出乎意料地简单，因为实际上只需要强制执行传递给它的任何值必须是`Address`类的实例。没有值检查，因为任何成功创建的`Address`实例都将在初始化过程中执行自己的类型和值检查：'
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `contact_email` setter could work much like the standard required text line
    setter process defined in `Address._set_street_address`. It has some of the same
    data rules associated, after all—it's a required value, cannot be empty, and since
    it's an email address, it can't be multi-line or have tabs. Since it's an email
    address, though, it also cannot have spaces in it, and there are other character
    restrictions that are common to all email addresses that aren't accounted for
    in that original structure. Since the requirements for the property include it
    being a well formed email address, there may be other, better ways to validate
    a value passed to the setter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`contact_email`的setter可以工作得像在`Address._set_street_address`中定义的标准必需文本行setter过程一样。毕竟，它有一些相同的数据规则——它是一个必需值，不能是空的，而且由于它是一个电子邮件地址，它不能是多行或包含制表符。然而，由于它是一个电子邮件地址，它也不能包含空格，并且有其他字符限制是所有电子邮件地址共有的，这些限制在原始结构中没有考虑到。由于该属性的要求包括它是一个格式良好的电子邮件地址，可能有其他更好的方法来验证传递给setter的值。'
- en: 'Ideally, an application will want to assure that an email address is both well
    formed and valid. There''s really only one way to do either, though, and it''s
    out of scope for `hms_sys`, even if it makes sense to try and implement it: send
    a confirmation email, and don''t store the value until/unless a confirmation response
    is received.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，应用程序将希望确保电子邮件地址既格式良好又有效。然而，确实只有一种方法可以实现其中任何一种，而且这超出了`hms_sys`的范围，即使尝试实现也是有意义的：发送确认电子邮件，并且在收到确认响应之前/除非不存储该值。
- en: There are a number of approaches that will get us most of the way to the validation
    of a well formed email address. The one that is probably the best place to start
    is to use a regular expression to match against the value, or to remove everything
    that is a well formed email address and not allow the value to be set unless there's
    nothing left after that replacement executes. Using a regular expression probably
    won't guarantee that the value is well formed, though it will catch a lot of invalid
    values. Combining that with some standard Python functionality found in the `email.utils`
    module should at least get the code to a point where testing can be built to look
    for well formed addresses that fail, and allow modification of the check process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以让我们完成大部分验证格式良好的电子邮件地址的工作。可能最好的起点是使用正则表达式与该值匹配，或者删除所有格式良好的电子邮件地址，并且在执行替换后不允许设置该值，除非剩下的内容为空。使用正则表达式可能不会保证该值格式良好，但它将捕获许多无效值。将其与`email.utils`模块中找到的一些标准Python功能结合起来，至少可以使代码达到一个测试点，以查找失败的格式良好的地址，并允许修改检查过程。
- en: 'First, we need to import some items, namely the `parseaddr` function from `email.utils`
    and the `re` module, in order to create the regular expression object we''ll use
    to test with. Those imports should happen at the top of the module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`email.utils`中导入`parseaddr`函数和`re`模块中的一些项目，以便创建我们将用于测试的正则表达式对象。这些导入应该发生在模块的顶部：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we''ll create a module level constant regular expression object that
    will be used to check email address values:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个模块级常量正则表达式对象，用于检查电子邮件地址值：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will match whole strings that start with one or more characters *A* through
    *Z* (upper or lower case), any digit 0-9, or an underscore, period, plus, or dash,
    followed by `@`, then most domain names. This structure was found on the internet
    with a quick search, and may not be complete, but it looks like it should work
    for most email addresses as it is. All the setter method implementation needs
    to do now is check that the value is a string, parse a recognizable address out
    of the string, check the parsed value, and if everything checks out, set the value
    of the data storage attribute:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配以一个或多个字符*A*到*Z*（大写或小写）、任何数字0-9或下划线、句点、加号或破折号开头的整个字符串，然后是`@`，然后是大多数域名。这种结构是在互联网上进行快速搜索时找到的，可能不完整，但看起来应该适用于大多数电子邮件地址。现在，setter方法的所有实现需要做的就是检查该值是否为字符串，从字符串中解析出可识别的地址，检查解析后的值，如果一切正常，设置数据存储属性的值：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A similar approach should be a good starting point for the website setter method,
    using the following as the regular expression to test with:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法应该是网站setter方法的一个很好的起点，使用以下作为正则表达式进行测试：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It starts with the same optional value check that was established in `Address._set_building_address`,
    but uses the `URL_CHECK` regular expression object to check the value passed in
    much the same way that `_set_contact_email` does:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它以与`Address._set_building_address`中建立的相同可选值检查开始，但使用`URL_CHECK`正则表达式对象来检查传入的值，方式与`_set_contact_email`相同：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That leaves just one property to implement: `products`. The products property
    has aspects to it that may not be apparent at first, but that have potentially
    significant implications on how it should be implemented. First and foremost,
    it''s a collection of other objects—whether that''s a list, a dictionary, or something
    else hasn''t yet been decided—but in any event it''s not a single object the way
    that `address` is. Additionally, it was defined as being a read-only property:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下一个属性要实现：`products`。`products`属性具有一些方面，一开始可能不明显，但对应该如何实现它可能有潜在的重要影响。首先，它是其他对象的集合——无论是列表、字典还是其他什么——但无论如何，它都不是像`address`那样的单个对象。此外，它被定义为只读属性：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Only the getter method is provided in the `property` definition. This is intentional,
    but requires some explanation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`定义中只提供了getter方法。这是有意为之，但需要一些解释。'
- en: 'Since products is intended to deal with a collection of product objects, it''s
    pretty important that the `products` property itself cannot be changed to something
    else. For example, if products were settable, it would be possible to execute
    something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品旨在处理产品对象的集合，因此`products`属性本身不能更改为其他内容非常重要。例如，如果产品是可设置的，就有可能执行以下操作：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, it's certainly possible to put type and value checking code in place to
    prevent that sort of assignment—and although there isn't a setter method associated
    with the property itself, we'll almost certainly want to have one available later
    on, and it should implement that type and value checking anyway. However, its
    use will probably be limited to populating an instance's products during the creation
    of the artisan instance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以实施类型和值检查代码来防止这种赋值方式，尽管属性本身没有与之关联的setter方法，但我们几乎肯定会在以后需要一个，而且它应该实施该类型和值检查。然而，它的使用可能仅限于在创建工匠实例期间填充实例的产品。
- en: 'The other potential concern is that it would be possible to alter the collection''s
    membership in ways that are both bug prone and difficult to regulate. For example,
    using the same `artisan` instance, and assuming that the underlying data storage
    for products is a list, there is nothing to stop code from doing any of the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的问题是，可能会以容易出错和难以调节的方式更改集合的成员资格。例如，使用相同的`artisan`实例，并假设产品的底层数据存储是列表，没有任何阻止代码执行以下任何操作：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similarly, allowing arbitrary deletion of an artisan's products (`del artisan.products`)
    is probably not a great idea.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，允许任意删除工匠的产品（`del artisan.products`）可能不是一个好主意。
- en: 'At a minimum, then, we want to assure the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，至少，我们希望确保以下内容：
- en: Manipulation of the membership of `products` is either not allowed or cannot
    affect the real, underlying data
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许或不能影响真实的底层数据的`products`成员资格
- en: Access to (and perhaps manipulation of) individual `products` members' members
    is still allowed, that is, given a list of product instances, reading data from
    and writing data to them is not constrained by the collection they live in
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然允许访问（也许是操作）单个`products`成员的成员，也就是说，给定产品实例的列表，从中读取数据并向其写入数据不受其所在集合的限制
- en: 'There are a couple of options, even without developing some sort of custom
    collection type. Since the `products` property uses a getter method to fetch and
    return the values, it would be possible to alter the data being returned in order
    to either:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有开发某种自定义集合类型，也有几种选择。由于`products`属性使用getter方法来获取和返回值，因此可以更改返回的数据，以便：
- en: Return a direct copy of the actual data, in which case altering the membership
    of the returned collection wouldn't touch the original collection
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接返回实际数据的副本，这样更改返回集合的成员资格不会影响原始集合
- en: Return a copy of the data in a different collection type; if the real data is
    stored in a list, for example, returning a tuple of that list would provide all
    of the same iterable sequence capabilities as the original list, but would not
    allow alteration of the membership of that copy itself
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据以不同的集合类型返回副本；例如，如果真实数据存储在列表中，返回该列表的元组将提供与原始列表相同的可迭代序列功能，但不允许更改副本本身的成员资格
- en: 'Python keeps track of objects by object reference—that is, it pays attention
    to where in memory an object actually lives, by association with the name assigned
    to the object—so when a list or tuple of objects is created from an already existing
    list of objects, the members of the new collection are the same objects as were
    present in the original list, for example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过对象引用跟踪对象——也就是说，它通过与分配给对象的名称相关联的内存中的位置来关注对象实际存在的位置——因此，当从已经存在的对象列表创建对象的列表或元组时，新集合的成员与原始列表中存在的对象相同，例如：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Creating a copy of the original list will create a new and distinct collection
    that will still have the same members in it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原始列表的副本将创建一个新的独立集合，其中仍然包含相同的成员：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, too will creating a tuple in a similar fashion:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组也需要类似的方式：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Returning either a new list or a tuple created from the original state data
    value would, then, take care of preventing changes made against the property value
    from affecting the real underlying data. For now the tuple returning option feels
    like the better choice, since it''s more restrictive, in which case `_get_products`
    will be implemented as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，返回从原始状态数据值创建的新列表或元组将处理防止对属性值进行的更改影响真正的基础数据。目前，元组返回选项似乎是更好的选择，因为它更加严格，这种情况下`_get_products`将被实现如下：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The deleter method `_del_products` cannot use `None` as a default with the
    getter that''s now in place. It will have to be changed to something else since
    trying to return a `tuple` of a `None` default value would raise an error. For
    now, the deleted value will be changed to an empty list:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 删除方法`_del_products`不能使用`None`作为默认值，因为现在已经有了getter。它将必须更改为其他内容，因为尝试返回一个`None`默认值的`tuple`会引发错误。目前，删除的值将更改为一个空列表：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, here is the setter method, `_set_products`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是设置方法，`_set_products`：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Taken together, these variations restrict changes to the products property
    pretty significantly:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来，这些变化相当大地限制了对产品属性的更改：
- en: The property itself is read-only, not allowing the value to be set or deleted
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性本身是只读的，不允许设置或删除值
- en: The value returned from the getter method is identical to, but distinct from,
    the one that's actually stored in the state data of the object it's being gotten
    from, and while it still allows access to the members of the original collection,
    it does not allow the original collection's membership to be altered
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从getter方法返回的值与实际存储在其状态数据中的值相同，但不同，并且虽然它仍然允许访问原始集合的成员，但不允许更改原始集合的成员资格
- en: The setter method enforces type checking for the entire collection, assuring
    that the membership of the collection is composed only of the appropriate object
    types
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方法强制对整个集合进行类型检查，确保集合的成员只由适当的对象类型组成
- en: What isn't accounted for yet are actual processes for making changes to the
    collection's members—that capability is in the method members.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未考虑的是对集合成员进行实际更改的过程——这种能力在方法成员中。
- en: Implementing BaseArtisan's methods
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现BaseArtisan的方法
- en: '`BaseArtisan`, as it''s currently designed, is expected to provide two abstract
    methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseArtisan`，按照当前的设计，应该提供两个抽象方法：'
- en: '`add_product`, which requires a mechanism for adding `products` to the products
    collection of an instance to be implemented on derived Concrete Classes'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_product`，需要一个机制来添加`products`到实例的产品集合中，需要在派生的具体类中实现'
- en: '`remove_product`, which similarly requires a mechanism for removing an item
    from the `products` collection of a derived instance'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_product`，同样需要一个机制来从派生实例的`products`集合中删除项目'
- en: These are specified as abstract methods because, while there will almost certainly
    be some common functionality involved with each of them across the application
    and service installables of `hms_sys`, there will also almost certainly be significant
    implementation differences across those same components—artisans, for example,
    may well be the only users who can truly remove items from their `products` collections.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被指定为抽象方法，因为虽然在`hms_sys`的应用和服务可安装组件中，每个方法几乎肯定会涉及一些共同的功能，但在这些相同的组件中也几乎肯定会有显著的实现差异——例如，artisans可能是唯一可以真正从他们的`products`集合中删除项目的用户。
- en: 'Typically, in most programming languages that support defining abstract methods,
    those methods are not expected to provide any actual implementation. It''s quite
    possible, in fact, that the act of defining a method as abstract actually prohibits
    any implementation. Python does not enforce that restriction on abstract methods,
    but still doesn''t expect any implementation either. As a result, our abstract
    methods do not need to be any more complicated than this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在大多数支持定义抽象方法的编程语言中，这些方法不需要提供任何实际的实现。事实上，定义方法为抽象方法可能会禁止任何实现。Python并不强制这种限制在抽象方法上，但也不期望有任何实现。因此，我们的抽象方法不需要比这更复杂：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we''re allowed to put concrete implementation into an abstract method,
    though, it''s possible to leverage that to provide baseline functionality in cases
    where there is some that''s useful to keep in one place. These two methods, `add_product`
    and `remove_product`, fall into that category:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们允许在抽象方法中放入具体实现，但是在某些情况下，可以利用这一点，在一个地方提供基线功能。这两种方法，`add_product`和`remove_product`，属于这种情况：
- en: Adding a product will always need to perform type checking, raise errors when
    invalid types are presented, and append the new item to the instance's collection
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加产品总是需要进行类型检查，当出现无效类型时引发错误，并将新项目附加到实例的集合中
- en: Removing a product will always involve removing the specified product from the
    instance's product collection
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从实例的产品集合中删除指定产品总是涉及到删除产品
- en: 'With those factors in mind, it can actually be beneficial to put those common
    processes into the abstract method as if they were concrete implementations. Those
    processes can then be called from derived class instances, with or without additional
    logic before or after the execution of the baselines themselves. Consider a basic
    implementation of `add_product` in `BaseArtisan` that looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，将这些常见流程放入抽象方法中实际上是有益的，就好像它们是具体实现一样。这些流程可以从派生类实例中调用，无论在执行基线本身之前还是之后，都可以加入或不加入额外的逻辑。考虑在`BaseArtisan`中实现`add_product`的基本方法如下：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A derived class—an `Artisan` class that lives in the Central Office''s application,
    for example—would be required to implement `add_product`, but could implement
    it as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个派生类——例如，位于总部应用程序中的`Artisan`类——将需要实现`add_product`，但可以按照以下方式实现：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a trade off to this approach, though: it would be possible for a derived
    class to implement a completely new `add_product` process, skipping the ready-made
    validation/business rules. An alternative approach would be to define an abstract
    validation method (`_check_products`, maybe) that handles the validation process
    and is called directly by a concrete implementation of `add_product`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这种方法存在一个权衡：派生类可以实现一个全新的`add_product`流程，跳过现成的验证/业务规则。另一种方法是定义一个抽象验证方法（也许是`_check_products`），它处理验证过程，并由`add_product`的具体实现直接调用。
- en: 'The `remove_product` method can be similarly defined, and could be implemented
    in a similar fashion in derived class instances:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove_product`方法可以类似地定义，并且可以在派生类实例中以类似的方式实现：'
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There may be other methods that would make sense to add to `BaseArtisan`, but
    if there are, they will probably surface as the implementations of concrete `Artisan`
    classes are developed. For now, we can call `BaseArtisan` done, after defining
    its `__init__` method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他方法适合添加到`BaseArtisan`中，但如果有的话，它们可能会在具体`Artisan`类的实现中出现。现在，我们可以在定义了`__init__`方法之后称`BaseArtisan`为完成：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: BaseCustomer
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础客户
- en: 'The class that defines what a customer''s data structure looks like is very
    simple, and uses code structures that have already been established in `Address`
    and `BaseArtisan` for all of its properties. Like the relationship of `BaseArtisan` with
    concrete `Artisan` instances, `Customer` objects are expected to vary significantly
    in what they can do, and perhaps what data access is allowed across the different
    components of the system. Once again, we''ll start by defining an ABC—`BaseCustomer`—rather
    than a concrete `Customer` class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定义客户数据结构的类非常简单，并且使用了已经在`Address`和`BaseArtisan`中建立的代码结构来定义其所有属性。就像`BaseArtisan`与具体`Artisan`实例的关系一样，预期`Customer`对象在其所能做的事情上会有很大的变化，也许在系统的不同组件之间允许的数据访问上也会有所不同。再次，我们将首先定义一个ABC——`BaseCustomer`——而不是一个具体的`Customer`类：
- en: '![](assets/4d1ea61e-9206-4487-bb53-828c74428616.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d1ea61e-9206-4487-bb53-828c74428616.png)'
- en: 'The properties of `BaseCustomer` are:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCustomer`的属性包括：'
- en: '`name`, a standard required text line.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`，一个标准的必填文本行。'
- en: '`billing_address` and `shipping_address`, which are, apart from their names,
    identical to the address property defined in `BaseArtisan`. The `shipping_address`
    will be made optional, since it''s quite possible for a customer to have only
    one address that''s used for both.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`billing_address`和`shipping_address`，除了它们的名称之外，与`BaseArtisan`中定义的地址属性相同。`shipping_address`将是可选的，因为客户可能只有一个地址用于两者。'
- en: 'The only new aspect of `BaseCustomer` that feels worth mentioning is how the
    `shipping_address` is annotated during initialization. `BaseCustomer.__init__`
    is mostly going to follow the same structure/approach that''s been shown in previous
    class definitions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseCustomer`的唯一值得一提的新方面是在初始化期间对`shipping_address`进行注释。`BaseCustomer.__init__`基本上会遵循之前类定义中展示的相同结构/方法：'
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `shipping_address` argument''s annotation, `(Address,None)`, is new, after
    a fashion. We''ve used built in types as annotation types before, as well as having
    a built in, non-`None` type and `None` for optional argument specifications before.
    `Address.__init__` uses this notation several times. This code, even though it
    uses a class that we have defined, works the same way: the `Address` class is
    also a type, just like `str` is in previous examples. It''s just a type that has
    been defined here in this project.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`shipping_address`参数的注释`(Address,None)`是新的，有点新意。我们以前使用过内置类型作为注释类型，以及在可选参数规范中使用过内置的非`None`类型和`None`。`Address.__init__`在几个地方使用了这种表示法。尽管这段代码使用了我们定义的一个类，但它的工作方式是一样的：`Address`类也是一种类型，就像以前的例子中的`str`一样。它只是在这个项目中定义的一种类型。'
- en: BaseOrder
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础订单
- en: The process of creating pretty much any dumb data object class, or even mostly
    dumb ones, is very similar no matter what those classes represent, at least so
    long as whatever data structure rules are in play hold true across the entire
    scope of those efforts. As more such data oriented classes are created, fewer
    new approaches to specific needs will be needed until eventually there will be
    a concise set of approaches for implementing various properties of all the various
    types and value constraints needed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建几乎任何愚蠢的数据对象类，甚至是大多数愚蠢的数据对象类，其过程非常相似，无论这些类代表什么，至少只要这些努力的整个范围内的数据结构规则保持不变。随着创建更多这样的面向数据的类，将需要更少的新方法来满足特定需求，直到最终将有一套简洁的方法来实现所需的各种类型和值约束的各种属性。
- en: 'The `BaseOrder` class, shown here with `BaseProduct`, is a good example of
    that effect, at least at first glance:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseOrder`类，与`BaseProduct`一起显示，是这种效果的一个很好的例子，至少乍一看是这样的：'
- en: '![](assets/4f92b29d-afdd-4bcd-9188-fcd993c7ae6c.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f92b29d-afdd-4bcd-9188-fcd993c7ae6c.png)'
- en: 'The list of `BaseOrder` properties is very short, since all an order really
    represents is a customer relationship with a collection of products:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseOrder`属性列表非常简短，因为订单实际上代表的只是与一组产品的客户关系：'
- en: '`customer` is an instance of `BaseCustomer`, which in turn has the `billing_address`
    and `shipping_address` properties of that **customer**;apart from the fact that
    the type of the property''s value is going to be a `BaseCustomer` instance, it''s
    reasonable to assume that it''ll behave in the same way that the `Address` type
    properties of `BaseCustomer` do'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer` 是`BaseCustomer`的一个实例，而`BaseCustomer`又有该**顾客**的`billing_address`和`shipping_address`属性；除了属性值的类型将是`BaseCustomer`实例之外，可以合理地假设它将以与`BaseCustomer`的`Address`类型属性相同的方式运行'
- en: '`products` is a collection of `BaseProduct` instances that can probably behave
    exactly like the `products` property of `BaseArtisan`—it''ll be doing the same
    sort of thing, after all, storing product instances and preventing mutation of
    those instances—so the initial implementation of it will be copied directly from
    `BaseArtisan`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products` 是`BaseProduct`实例的集合，可能可以完全像`BaseArtisan`的`products`属性一样运行——毕竟，它将做同样的事情，存储产品实例并防止对这些实例的改变——因此，它的初始实现将直接从`BaseArtisan`复制过来'
- en: In short, both properties, barring some changing of names in the case of the
    **customer** property, already have established implementation patterns, so there's
    nothing substantially new to show in `BaseOrder`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，除了在**顾客**属性的情况下更改名称外，这两个属性已经有了已建立的实现模式，因此在`BaseOrder`中没有实质性的新内容可展示。
- en: Copying code directly from one class to another is a contentious topic at times;
    even if everything works perfectly, it is, by definition, duplicating code, which
    means that there are now multiple copies of that code to be maintained if something
    goes awry later on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时直接从一个类复制代码到另一个类是一个有争议的话题；即使一切都完美运行，根据定义，这是复制代码，这意味着如果以后出现问题，就需要维护多个副本的代码。
- en: BaseProduct
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseProduct
- en: 'The `BaseProduct` ABC also has a lot of near boilerplate property code, though
    only three of its properties fall into implementation patterns that''ve been established
    so far:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct` ABC也有大量接近样板的属性代码，尽管其中只有三个属性符合到目前为止已经建立的实现模式：'
- en: '`name` is a standard required text line property.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是一个标准的必需文本行属性。'
- en: '`summary` is a standard required text line property.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summary` 是一个标准的必需文本行属性。'
- en: '`description` is an optional string value.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` 是一个可选的字符串值。'
- en: '`dimensions` is a standard optional text line property.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dimensions` 是一个标准的可选文本行属性。'
- en: '`shipping_weight` is a required number value, which may only be used for determining
    shipping costs, but could also appear in product displays in the web store.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shipping_weight` 是一个必需的数字值，可能仅用于确定运输成本，但也可能出现在网店的产品展示中。'
- en: '`metadata` is a dictionary of metadata keys (strings) and values (strings also,
    probably). This is a new data structure, so we''ll examine it in detail shortly.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata` 是元数据键（字符串）和值（也是字符串）的字典。这是一个新的数据结构，所以我们很快就会详细研究它。'
- en: '`available` is a required Boolean value that allows the artisan to indicate
    that the product is available to be sold on the HMS web store, though it may be
    visible to central office staff.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available` 是一个必需的布尔值，允许工匠指示产品在HMS网店上可供销售，尽管可能对中央办公室工作人员可见。'
- en: '`store_available` is also a required Boolean value, indicating that the HMS
    web store should consider the **product** available. It is intended to be controlled
    by the Central Office staff, though it may be visible to an artisan.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_available` 也是一个必需的布尔值，表示HMS网店是否应该考虑**产品**可用。它打算由中央办公室工作人员控制，尽管可能对工匠可见。'
- en: '`BaseProduct` has only two methods associated so far, both for use in managing
    the metadata values associated with a product instance:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseProduct`目前只有两个关联的方法，用于管理与产品实例相关的元数据值：'
- en: '`set_metadata` will set a metadata key/value on the instance'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_metadata` 将在实例上设置元数据键/值'
- en: '`remove_metadata` will remove a metadata key and value from the instance'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_metadata` 将从实例中删除元数据键和值'
- en: 'The `name`, `summary`, and `dimensions` properties, as standard required and
    optional text lines, will follow those patterns. The `description` is almost an
    optional text line implementation; all that needs to be changed there is removing
    the whitespace character checks, and it''s good to go:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`、`summary`和`dimensions`属性作为标准的必需和可选文本行，将遵循这些模式。`description`几乎是一个可选文本行的实现；唯一需要改变的是删除空格字符检查，然后就可以使用了：'
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the `shipping_weight` property varies most significantly
    in the setter method `_set_shipping_weight`, but is (hopefully) about what would
    be expected given the normal getter/setter/deleter method structure that is the
    typical approach for properties in the project:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`shipping_weight`属性的实现在setter方法`_set_shipping_weight`中最为显著，但（希望）与项目中属性的典型方法结构相符，这是可以预期的：'
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The same can be said for the implementation of both of the `available` properties,
    though it makes sense to allow both formal Boolean (`True` and `False`) values
    and integer value equivalents (`1` and `0`) as valid setter value arguments. This
    gives a bit of wiggle room in cases where the object''s state data may not be
    able to be stored as true Booleans—though that is an unlikely circumstance, it''s
    not out of the realm of possibility, either:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`available`属性的实现也可以这样说，尽管允许使用正式的布尔值（`True`和`False`）和整数值等价物（`1`和`0`）作为有效的setter值参数是有道理的。这在对象状态数据可能无法存储为真布尔值的情况下留有余地，尽管这是一个不太可能的情况，但也不是不可能的：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That leaves only the `metadata` property implementation. Metadata is probably
    best thought of as data about other data—in this case, data about the products
    that the class is fundamental to representing. In this particular case, the `metadata`
    property is intended to provide highly flexible data that may vary wildly from
    one product (or product type) to another, while still being available in a relatively
    simple manner within a more rigidly defined class/object structure. This will
    be important in the context of Hand Made Stuff's needs because the products that
    artisans create and sell through their web store can be virtually anything: beads,
    wood, or metal furniture, clothing, jewelry, whatever. Though there are a few
    descriptions that could potentially be applied to any product—what it's made out
    of, for example, and perhaps some basic items such as color—there are others that
    make it nearly impossible to categorize products across the entire spectrum available
    without either requiring a lot more data structures in the current product class
    structure, or a lot of product types that live in what would almost certainly
    be a prohibitively complex relationship with each other.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就只剩下了`metadata`属性的实现。元数据可能最好被视为关于其他数据的数据——在这种情况下，是关于类基本上代表的产品的数据。在这种特殊情况下，`metadata`属性旨在提供高度灵活的数据，这些数据可能在一个产品（或产品类型）到另一个产品之间变化很大，同时仍然以相对简单的方式在更严格定义的类/对象结构中提供。这在Hand
    Made Stuff的需求背景下是很重要的，因为工匠通过他们的网店销售的产品几乎可以是任何东西：珠宝、木制品、金属家具、服装、珠宝等。虽然有一些描述可能适用于任何产品——例如它是由什么制成的，也许一些基本项目，比如颜色——但有一些描述使得几乎不可能在当前产品类结构中对整个可用范围的产品进行分类，而不是要求在当前产品类结构中有更多的数据结构，或者有很多产品类型，这些产品类型几乎肯定会在彼此之间有一个难以想象的复杂关系。
- en: The initial implementation and design will center, then, around maintaining
    a `dict` based metadata structure with each object. If more stringent requirements
    arise later (such as requiring that items made of wood must specify the type of
    wood, for example), a refactoring effort to adjust accordingly may be necessary,
    but for now a simple `dict` feels reasonable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，初始实现和设计将围绕着维护每个对象的基于`dict`的元数据结构。如果以后出现更严格的要求（例如，要求木制品必须指定木材的类型），则可能需要进行相应的重构工作，但目前一个简单的`dict`看起来是合理的。
- en: Like the products property of `BaseArtisan` and `BaseOrder`, the `metadata` 
    of a `BaseProduct` needs to be difficult to casually or accidentally change—it
    should require something of a conscious decision to make changes. Given that the
    `metadata` structure is expected to provide data with which to categorize products,
    the keys, at the very least, will have some restrictions around what can be used.
    Metadata names should be meaningful and reasonably short. So, too should `metadata`
    values, though they will probably be less constrained than their corresponding
    keys.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与`BaseArtisan`和`BaseOrder`的`products`属性一样，`BaseProduct`的`metadata`需要难以轻易或意外更改——它应该需要一些有意识的决定来进行更改。鉴于`metadata`结构预期提供用于对产品进行分类的数据，至少键将受到一定限制。元数据名称应该有意义并且相当简短。`metadata`值也应该是如此，尽管它们可能比相应的键受到的限制要少。
- en: 'Taking all of these items together, the getter and deleter methods are not
    significantly different from their equivalents for the other properties—the usual
    name changes and a different deleted default value are about all there is to them:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑所有这些项目，获取器和删除器方法与其他属性的等效方法并没有显着不同——通常只是名称更改和不同的删除默认值：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The setter method is, as is most often the case, where the significant differences
    are; in this case, when it's called, the expectation is that the intention is
    to clear out any existing metadata and replace it with a new, validated set of
    keys and values. This changes the entire collection in the property, not just
    some or all of its members. Since the class will also be providing a dedicated
    method to allow the addition of new `metadata`, or changes to existing items in
    the `metadata`, and that method will need to perform whatever validation is desired
    against both keys and values, the `_set_metadata` property setter method will
    use the similarly named `set_metadata` method to assure that all metadata meets
    the same standards.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方法通常是最常见的地方，其中存在显着的差异；在这种情况下，当调用时，期望是清除任何现有的元数据并用新的经过验证的键和值集合替换它。这将更改属性中的整个集合，而不仅仅是它的一些或全部成员。由于该类还将提供专用方法来允许添加新的`metadata`，或更改`metadata`中的现有项目，并且该方法将需要对键和值进行所需的任何验证，`_set_metadata`属性设置方法将使用同名的`set_metadata`方法来确保所有元数据都符合相同的标准。
- en: 'The first step is to make sure that the incoming value is a dictionary:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保传入的值是一个字典：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll set up a variable to keep track of any invalid values encountered, and
    clear the current metadata out with the same mechanism that''s used to clear it
    out during initialization, `_del_metadata`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个变量来跟踪遇到的任何无效值，并使用与在初始化期间清除当前元数据的相同机制`_del_metadata`。
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With those accomplished, we can iterate across the value''s keys and values,
    calling `set_metadata` for each pair until they''ve all been accounted for, and
    trapping any errors raised in order to provide more useful error messaging when
    needed:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以遍历值的键和值，对每一对调用`set_metadata`，直到它们都被记录，并捕获任何错误以提供更有用的错误消息时需要：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If any bad values were detected, then we''ll want to raise an error and note
    them. If no errors occur, then the property''s been repopulated:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到任何错误的值，那么我们将希望引发错误并记录它们。如果没有错误发生，那么属性已被重新填充：
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `set_metadata` method looks a lot like our varied property setter methods—keys
    and (for now) values in metadata both act like standard required text line properties—so
    the type and value checking being performed for each will look very familiar:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_metadata`方法看起来很像我们各种属性setter方法——元数据中的键和（目前）值都像标准的必需文本行属性一样操作——因此对每个属性执行的类型和数值检查看起来会非常熟悉：'
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s the type and value checking for the `key` argument''s value:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对`key`参数值的类型和数值检查：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And here''s the type and value checking for the `value` argument''s value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对`value`参数值的类型和数值检查：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The removal of `metadata` requires considerably shorter and simpler code, though
    it also assumes that if an attempt is made to remove metadata that doesn''t exist,
    no error need be raised. There might be a need to allow such an error to occur,
    but for now the assumption is that it won''t be needed:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`metadata`需要的代码要短得多，也更简单，尽管它也假设如果试图删除不存在的元数据，则不需要引发错误。可能需要允许出现这样的错误，但目前的假设是不需要：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With `BaseProduct` complete, the required scope of the `hms_core` class library
    is fulfilled. Unit testing still needs to be written, and any issues that surface
    as a result.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`BaseProduct`完成，`hms_core`类库的必需范围得到满足。单元测试仍需编写，并解决由此产生的任何问题。
- en: Dealing with duplicated code – HasProducts
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理重复的代码 - HasProducts
- en: '`BaseArtisan` and `BaseOrder` have `products` properties that behave the same
    way, to the extent that the original implementation of those properties involved
    essentially copying and pasting the code from one into the other. While that''s
    probably not such a big deal in this particular case (since the `hms_core` class
    library is small, with few members, and there are only two places where that duplicate
    code would have to be maintained), in larger libraries, or if there was a lot
    of duplication of that code, it could become very problematic very quickly. Since
    Python allows classes to inherit from multiple parent classes, we can leverage
    that capability to define a new ABC—`HasProducts`—that will keep all of the product
    property related code in one place:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseArtisan`和`BaseOrder`都有`products`属性，其行为方式相同，以至于这些属性的原始实现基本上涉及将代码从一个属性复制并粘贴到另一个属性中。在这种特定情况下可能并不是什么大问题（因为`hms_core`类库很小，成员很少，只有两个地方需要维护重复的代码），但在更大的库中，或者如果有很多重复的代码，问题可能会很快变得非常棘手。由于Python允许类从多个父类继承，我们可以利用这种能力来定义一个新的ABC——`HasProducts`，将所有与产品属性相关的代码放在一个地方：'
- en: '![](assets/e29b2099-a83d-4ea8-aaea-ea553f4752fc.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e29b2099-a83d-4ea8-aaea-ea553f4752fc.png)'
- en: This approach is a variation of an object oriented principle that's usually
    referred to as a mixin—a class that contains concrete implementations of functionality
    for use in other classes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是面向对象原则的一种变体，通常被称为混入——一个包含功能具体实现以供其他类使用的类。
- en: 'The implementation of `HasProducts` is, essentially, just a collection or repackaging
    of the product properties code of `BaseArtisan` and `BaseOrder`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasProducts`的实现本质上只是`BaseArtisan`和`BaseOrder`的产品属性代码的集合或重新打包：'
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The getter, setter, and deleter methods:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: getter、setter和deleter方法：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `products` property definition:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`products`属性定义：'
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Object initialization:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The abstract methods for adding and removing products:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 用于添加和删除产品的抽象方法：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using `HasProducts` in `BaseArtisan` and `BaseOrder` is not difficult, though
    it involves refactoring them to remove code that is already in place that will
    override the common code in `HasProducts`. It starts with making sure that the
    class using `HasProducts` inherits from it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BaseArtisan`和`BaseOrder`中使用`HasProducts`并不困难，尽管它涉及重构以删除已经存在的代码，这些代码将覆盖`HasProducts`中的公共代码。首先要确保使用`HasProducts`的类继承自它：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `__init__` method of the derived class has to be altered to call the `__init__`
    of `HasProducts` as well, in order to assure that it performs all the relevant
    initialization tasks:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类的`__init__`方法必须被修改为调用`HasProducts`的`__init__`，以确保它执行所有相关的初始化任务：
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The processes of setting default values and instance values for the new class
    no longer have to worry about handling the `products` property setup, since that''s
    handled by `HasProducts.__init__`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 新类的默认值和实例值设置过程不再需要担心处理`products`属性的设置，因为这由`HasProducts.__init__`处理：
- en: '[PRE56]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, the `products` property in each, along with their associated getter,
    setter, and deleter methods, can just be removed from the derived classes:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个派生类中的`products`属性以及它们关联的getter、setter和deleter方法都可以被移除：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With `HasProducts` implemented, the full structure and functionality of the
    `hms_core` package is tentatively complete—tentatively because it hasn''t been
    unit tested yet. The class diagram for the entire package shows all of the moving
    parts, and the relationships between them:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HasProducts`在`BaseArtisan`和`BaseOrder`中实现后，`hms_core`包的完整结构和功能暂时完成——暂时是因为尚未进行单元测试。整个包的类图显示了所有的组成部分以及它们之间的关系：
- en: '![](assets/de3e0c91-0f1b-4f4c-8c47-d3dbf41517c3.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de3e0c91-0f1b-4f4c-8c47-d3dbf41517c3.png)'
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Overall, these classes provide definitions that could be described as dumb data
    objects. They provide little or no functionality that isn't directly related in
    some fashion to the definition and regulation of a specific data structure. Even
    `HasProducts`, and the classes that derive from it, fall into this category since
    the functionality provided there is strictly concerned with providing a data structure
    and controlling how that structure can be manipulated. As other classes are created
    that derive from these classes, those classes will start to become smarter, starting
    with persistence of the data for individual objects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些类提供的定义可以被描述为“愚蠢的数据对象”。它们提供的功能与特定数据结构的定义和规范直接相关，几乎没有其他功能。即使是“HasProducts”及其派生类也属于这一类，因为那里提供的功能严格关注于提供数据结构和控制如何操作该结构。随着从这些类派生出的其他类的创建，这些类将开始变得更智能，首先是对个体对象数据的持久化。
- en: First, though, unit tests for these classes need to be written, to assure that
    they have been tested, and that they can be retested on demand. Since that represents
    a significant shift in coding goals, and will involve some in depth examination
    of testing goals and how to accomplish them, this first unit testing pass warrants
    its own chapter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要编写这些类的单元测试，以确保它们已经经过测试，并且可以按需重新测试。由于这代表了编码目标的重大转变，并且将涉及对测试目标及其实现方式进行深入研究，因此这个第一次单元测试需要有自己的章节。
