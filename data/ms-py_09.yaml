- en: Chapter 9. Documentation – How to Use Sphinx and reStructuredText
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。文档 - 如何使用Sphinx和reStructuredText
- en: Documenting code can be both fun and useful! I will admit that many programmers
    have a strong dislike for documenting code and understandably so. Writing documentation
    can be a boring job and traditionally only others reap the benefits of that effort.
    The tools available for Python, however, make it almost trivial to generate useful
    and up-to-date documentation with little to no effort at all. Generating documentation
    has actually become so easy that I create and generate documentation before using
    a Python package. Assuming it wasn't available already, that is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码既有趣又有用！我承认许多程序员对记录代码有强烈的厌恶，这是可以理解的。撰写文档可能是一项枯燥的工作，传统上只有其他人才能从这一努力中获益。然而，Python提供的工具使得生成有用且最新的文档几乎是轻而易举的。生成文档实际上变得如此容易，以至于在使用Python包之前，我会先创建和生成文档。假设它之前并不存在的话。
- en: In addition to simple text documentation explaining what a function does, it
    is also possible to add metadata, such as type hints. These type hints can be
    used to make the arguments and return types of a function or class clickable in
    the documentation. But more importantly, many modern IDEs and editors, such as
    VIM, have plugins available that parse the type hints and use them for intelligent
    auto-completion. So if you type `Spam.eggs`, your editor will automatically complete
    the specific attributes and methods of the eggs object; something that is traditionally
    only viable with statically typed languages such as Java, C, and C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的文本文档解释函数的作用，还可以添加元数据，例如类型提示。这些类型提示可以用于使函数或类的参数和返回类型在文档中可点击。但更重要的是，许多现代IDE和编辑器，如VIM，都有可用的插件，可以解析类型提示并用于智能自动补全。因此，如果您键入`Spam.eggs`，您的编辑器将自动完成eggs对象的特定属性和方法；这在传统上只适用于静态类型语言，如Java、C和C++。
- en: This chapter will explain the types of documentation available in Python and
    how easily a full set of documentation can be created. With the amazing tools
    that Python provides, you can have fully functioning documentation within minutes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释Python中可用的文档类型以及如何轻松创建一套完整的文档。借助Python提供的惊人工具，您可以在几分钟内拥有完全运行的文档。
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: The reStructuredText syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reStructuredText语法
- en: Setting up documentation using Sphinx
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sphinx设置文档
- en: Sphinx style docstrings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sphinx风格的文档字符串
- en: Google style docstrings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google风格的文档字符串
- en: NumPy style docstrings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy风格的文档字符串
- en: The reStructuredText syntax
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reStructuredText语法
- en: The **reStructuredText** format (also known as **RST**, **ReST**, or **reST**)
    was developed in 2002 as a simple language that implements enough markup to be
    usable, but is simple enough to be readable as plain text. These two features
    make it readable enough to use in code, yet still versatile enough to generate
    pretty and useful documentation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**reStructuredText**格式（也称为**RST**、**ReST**或**reST**）于2002年开发，是一种简单的语言，实现了足够的标记以便使用，但又足够简单以便作为纯文本可读。这两个特点使得它足够可读以用于代码，但又足够灵活以生成漂亮且有用的文档。'
- en: The greatest thing about reStructuredText is that it is very intuitive. Even
    without knowing anything about the standard, you can easily write documentation
    in this style without ever knowing that it would be recognized as a language.
    However, more advanced techniques, such as images and links, do require some explanation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText最棒的地方在于它非常直观。即使不了解标准的任何内容，您也可以轻松以这种风格编写文档，而不必知道它会被识别为一种语言。然而，更高级的技术，如图片和链接，确实需要一些解释。
- en: Next to reStructuredText, there are also languages such as **Markdown** which
    are quite similar in usage. Within the Python community, reStructuredText has
    been the standard documentation language for over 10 years, making it the recommended
    solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了reStructuredText之外，还有诸如**Markdown**之类的语言，它们在使用上相当相似。在Python社区中，reStructuredText已经成为标准文档语言超过10年，因此成为了推荐的解决方案。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To easily convert between formats such as reStructuredText and Markdown, use
    the Pandoc tool, available at [http://pandoc.org/](http://pandoc.org/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要轻松在reStructuredText和Markdown等格式之间转换，请使用Pandoc工具，网址为[http://pandoc.org/](http://pandoc.org/)。
- en: The basic syntax reads just like text and the next few paragraphs will show
    some of the more advanced features. However, let us start with a simple example
    demonstrating how simple a reStructuredText file can be.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法读起来就像文本，接下来的几段将展示一些更高级的功能。然而，让我们从一个简单的例子开始，演示reStructuredText文件可以有多简单。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s how easy it is to convert the text of this chapter so far to reStructuredText.
    The following paragraphs will cover the following features:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将本章文本转换为reStructuredText的简单方法。接下来的段落将涵盖以下功能：
- en: Inline markup (italic, bold, code, and links)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内联标记（斜体、粗体、代码和链接）
- en: Lists
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表
- en: Headers
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题
- en: Advanced links
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级链接
- en: Images
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片
- en: Substitutions
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换
- en: Blocks containing code, math, and others
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含代码、数学和其他内容的块
- en: Getting started with reStructuredText
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用reStructuredText快速入门
- en: 'To quickly convert a reStructuredText file to HTML, we can use the `docutils`
    library. The `sphinx` library discussed later in this chapter actually uses the
    `docutils` library internally, but has some extra features that we won''t need
    initially. To get started, we just need to install `docutils`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速将reStructuredText文件转换为HTML，我们可以使用`docutils`库。本章后面讨论的`sphinx`库实际上在内部使用了`docutils`库，但具有一些我们最初不需要的额外功能。要开始，我们只需要安装`docutils`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that we can easily convert reStructuredText into PDF, LaTeX, HTML, and
    other formats. For the examples in this paragraph, we''ll use the HTML format
    which is easily generated using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以轻松地将reStructuredText转换为PDF、LaTeX、HTML和其他格式。在本段中的示例中，我们将使用HTML格式，可以使用以下命令轻松生成：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The basic components of reStructuredText are roles, which are used for inline
    modifications of the output and directives to generate markup blocks. Within pure
    reStructuredText, the directives are the most important, but we will see many
    uses for the roles in the section about Sphinx.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText的基本组件是角色，用于对输出进行内联修改，以及指令来生成标记块。在纯reStructuredText中，指令是最重要的，但在关于Sphinx的部分中，我们将看到角色的许多用途。
- en: Inline markup
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联标记
- en: '**Inline markup** is the markup that is used within a regular line of text.
    Examples of these are emphasis, in-line code examples, links, images, and bullet
    lists.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联标记**是在正常文本行内使用的标记。这些示例包括强调、内联代码示例、链接、图像和项目列表。'
- en: Emphasis, for example, can be added by encapsulating the words between one or
    two asterisk signs. This sentence for example could add a little bit of `*emphasis*`
    by adding a single asterisk on both sides or a lot of `**emphasis**` by adding
    two asterisks at both sides. There are many different inline markup directives
    so we will list only the most common ones. A full list can always be found through
    the reStructuredText homepage at `docutils.sourceforge.net`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过在一个或两个星号之间封装单词来添加强调。例如，通过在两侧添加一个星号或在两侧添加两个星号，可以为这个句子添加一点`*强调*`或很多`**强调**`。有许多不同的内联标记指令，因此我们只列出最常见的。完整列表始终可以在reStructuredText主页`docutils.sourceforge.net`上找到。
- en: 'Following are some examples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: 'Emphasis (italic) text: `*emphasis for this phrase*`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调（斜体）文本：`*对这个短语进行强调*`。
- en: 'Extra emphasis (bold) text: `**extra emphasis for this phrase**`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外强调（粗体）文本：`**对这个短语进行额外强调**`。
- en: 'For lists without numbers, a simple dash with spaces after it:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有数字的列表，一个简单的破折号后面跟着空格：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The space after the dash is required for reStructuredText to recognize the list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 破折号后面的空格是reStructuredText识别列表所必需的。
- en: 'For lists with numbers, the number followed by a period and a space:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于带有数字的列表，数字后面跟着一个句点和一个空格：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For numbered lists, the period after the number is required.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编号列表，数字后面的句点是必需的。
- en: 'Interpreted text: These are domain specific. Within Python documentation, the
    default role is code which means that surround text with back ticks will convert
    your code to use code tags. For example, ``if spam and eggs:``.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释文本：这些是特定于域的。在Python文档中，默认角色是代码，这意味着用反引号括起来的文本将转换为使用代码标记的代码。例如，``if spam and
    eggs:``。
- en: Different roles can be set through either a role prefix or suffix depending
    on your preference. For example, `:math:`E=mc^2`` to show mathematical equations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的喜好，可以通过角色前缀或后缀来设置不同的角色。例如，`:math:`E=mc^2``可以显示数学方程式。
- en: 'Inline literals: This is formatted with a mono-space font, which makes it ideal
    for inline code. Just add two back ticks to [PRE5].'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联文字：这是用等宽字体格式化的，非常适合内联代码。只需在[PRE5]后面加两个反引号。
- en: 'References: These can be created through a trailing underscore. They can point
    to headers, links, labels, and more. The next section will cover more about these,
    but the basic syntax is simply `reference_` or enclosed in back ticks when the
    reference contains spaces, ``some reference link`_`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用：可以通过下划线创建引用。它们可以指向标题、链接、标签等。下一节将更多地介绍这些内容，但基本语法就是简单的`reference_`或者在引用包含空格时用反引号括起来，``some
    reference link`_`。
- en: To escape the preceding characters, the backslash can be used. So if you wish
    to have an asterisk with emphasis, it's possible to use `*\**`, quite similar
    to escaping in Python strings.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要转义前面的字符，可以使用反斜杠。因此，如果您希望使用强调符号，可以使用`*\**`，这与Python字符串中的转义非常相似。
- en: There are many more available, but these are the ones you will use the most
    when writing reStructuredText.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他可用的，但这些是您在编写reStructuredText时最常使用的。
- en: Headers
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题
- en: 'The headers are used to indicate the start of a document, section, chapter,
    or paragraph. It is therefore the first structure you need in a document. While
    not strictly needed, its usage is highly recommended as it serves several purposes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标题用于指示文档、章节、章节或段落的开始。因此，它是文档中您需要的第一个结构。虽然不是严格必需的，但强烈建议使用，因为它有几个目的：
- en: The headers are consistently formatted according to their level.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题的格式一致地按照其级别进行格式化。
- en: Sphinx can generate a Table Of Contents (TOC) tree from the headers.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sphinx可以从标题生成目录树。
- en: All headers automatically function as labels, which means you can create links
    towards them.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有标题都自动作为标签，这意味着您可以创建指向它们的链接。
- en: When creating headers, consistency is one of the few constraints; the character
    used is fairly arbitrary as is the amount of levels.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建标题时，一致性是为数不多的约束之一；所使用的字符是相当任意的，级别的数量也是任意的。
- en: 'Personally, I default to a simple system with a fixed-size header, but I recommend
    at least following the default of the Python documentation in terms of the parts,
    chapters, sections, subsections, subsubsections, and paragraphs. Something along
    the lines of the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我默认使用一个简单的系统，带有固定大小的标题，但我建议至少在部分、章节、节、子节、子子节和段落方面遵循Python文档的默认设置。大致如下：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![Headers](images/4711_09_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![标题](images/4711_09_01.jpg)'
- en: 'That is just the common usage of the headers, but the main idea of reStructuredText
    is that you can use just about anything that feels natural to you, which means
    that you can use any of the following characters: `= - ` : '' " ~ ^ _ * + # <>`.
    It also supports both underlines and overlines, so if you prefer that, they are
    options as well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是标题的常见用法，但reStructuredText的主要思想是您可以使用几乎任何对您来说自然的东西，这意味着您可以使用以下任何字符：`= - `
    : '' " ~ ^ _ * + # <>`。它还支持下划线和上划线，因此如果您喜欢，也可以选择它们：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While I try to keep the number of characters fixed to 78 characters as `PEP8`
    ([Chapter 2](ch02.html "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style
    Guide"), *Pythonic Syntax, Common Pitfalls, and Style Guide*) recommends for Python,
    the number of characters used is mostly arbitrary, but it does have to be at least
    as long as the text of the header. This allows it to get the following result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我尽量保持字符数固定为78个字符，就像`PEP8`（[第2章](ch02.html "第2章。Pythonic Syntax, Common Pitfalls,
    and Style Guide")，*Pythonic Syntax, Common Pitfalls, and Style Guide*）为Python推荐的那样，但使用的字符数大多是任意的，但必须至少与标题文本一样长。这使得它可以得到以下结果：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But not this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是这样：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lists
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'The reStructuredText format has several styles of lists:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText格式有几种列表样式：
- en: Enumerated
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举
- en: Bulleted
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目符号
- en: Options
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选项
- en: Definitions
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义
- en: The simplest forms of lists were already displayed in the introduction section,
    but it's actually possible to use many different characters, such as letters,
    Roman numerals, and others, for enumeration. After demonstrating the basic list
    types, we will continue with the nesting of lists and structures which makes them
    even more powerful. Care must be taken with the amount of whitespace, as a space
    too many can cause a structure to be recognized as regular text instead of a structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的列表形式已经在介绍部分显示了，但实际上可以使用许多不同的字符，如字母、罗马数字和其他字符进行枚举。在演示了基本列表类型之后，我们将继续讨论列表和结构的嵌套，使它们变得更加强大。必须注意空格的数量，因为太多的空格会导致结构被识别为普通文本而不是结构。
- en: Enumerated list
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举列表
- en: 'Enumerated lists are convenient for all sorts of enumerations. The basic premise
    for enumerated lists is an alphanumeric character followed by a period, a right
    parenthesis, or parentheses on both sides. Additionally, the `#` character functions
    as an automatic enumeration. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举列表对各种枚举很方便。枚举列表的基本前提是字母数字字符后跟一个句点、右括号或两侧括号。另外，`#`字符作为自动枚举。例如：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is perhaps a bit simpler than you would expect. The reason is that
    it depends on the output format. These were generated with the HTML output format
    which has no support for parentheses. If you output LaTeX for example, the difference
    can be made visible. Following is the rendered HTML output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能比你期望的简单一些。原因是它取决于输出格式。这些是使用HTML输出格式生成的，该格式不支持括号。例如，如果输出LaTeX，差异就会变得明显。以下是渲染的HTML输出：
- en: '![Enumerated list](images/4711_09_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![枚举列表](images/4711_09_02.jpg)'
- en: Bulleted list
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目符号列表
- en: 'If the order of the list is not relevant and you simply need a list of items
    without enumeration, then the bulleted list is what you need. To create a simple
    list using bullets only, the bulleted items need to start with a `*`, `+`, `-`,
    `•`, `‣`, or `⁃`. This list is mostly arbitrary and can be modified by extending
    Sphinx or Docutils. For example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的顺序不重要，只需要一个项目列表而不需要枚举，那么项目符号列表就是你需要的。要创建一个只使用项目符号的简单列表，项目符号需要以`*`、`+`、`-`、`•`、`‣`或`⁃`开头。这个列表大多是任意的，可以通过扩展Sphinx或Docutils进行修改。例如：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, with the HTML output again all bullets look identical. When
    generating documentation as LaTeX (and consecutively, PDF or Postscript), these
    can differ. Since web-based documentation is by far the most common output format
    for Sphinx, we default to that output instead. The rendered HTML output is as
    follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用HTML输出时，所有项目符号看起来都是相同的。当生成LaTeX文档（以及随后的PDF或Postscript）时，它们可能会有所不同。由于基于Web的文档是Sphinx最常见的输出格式，因此我们默认使用该输出。渲染的HTML输出如下：
- en: '![Bulleted list](images/4711_09_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![项目符号列表](images/4711_09_03.jpg)'
- en: Option list
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项列表
- en: The `option` list is one meant specifically for documenting the command line
    arguments of a program. The only special thing about the syntax is that the comma-space
    is recognized as a separator for options.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`option`列表是专门用于记录程序命令行参数的。语法的特殊之处在于逗号空格被识别为选项的分隔符。'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Following is the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Option list](images/4711_09_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![选项列表](images/4711_09_04.jpg)'
- en: Definition list
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义列表
- en: The definition list is a bit more obscure than the other types of lists, since
    the actual structure consists of whitespace only. It's therefore pretty straightforward
    to use, but not always as easy to identify in a file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表比其他类型的列表更加隐晦，因为实际结构只包含空格。因此，使用起来非常简单，但在文件中并不总是容易识别。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Following is the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Definition list](images/4711_09_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![定义列表](images/4711_09_05.jpg)'
- en: Nested lists
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套列表
- en: Nesting items is actually not limited to lists and can be done with multiple
    types of blocks, but the idea is the same. Just be careful to keep the indenting
    at the correct level. If you don't, it either won't be recognized as a separate
    level or you will get an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套项目实际上不仅限于列表，还可以使用多种类型的块，但思想是相同的。只需小心保持正确级别的缩进。如果不这样做，它要么不会被识别为单独的级别，要么会出错。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Following is the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Nested lists](images/4711_09_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套列表](images/4711_09_06.jpg)'
- en: Links, references, and labels
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接、引用和标签
- en: 'There are many types of links supported in reStructuredText, the simplest of
    which is just a link with the protocol such as [http://python.org](http://python.org),
    which will automatically be recognized by most parsers. However, custom labels
    are also an option by using the interpreted text syntax we saw earlier: ``Python
    <http://python.org>`_`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText支持许多类型的链接，其中最简单的是带有协议的链接，例如[http://python.org](http://python.org)，大多数解析器会自动识别。但是，也可以使用前面看到的解释文本语法来自定义标签：``Python
    <http://python.org>`_`。
- en: Both of these are nice for simple links, which won't be repeated too often,
    but generally it's more convenient to attach labels to links so they can be reused
    and don't clog up the text too much.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种都适用于不太频繁重复的简单链接，但通常更方便的是给链接附加标签，这样它们可以被重复使用，而不会过多地占据文本。
- en: 'For example, refer to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请参考以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now compare it with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在与以下内容进行比较：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Links, references, and labels](images/4711_09_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![链接，引用和标签](images/4711_09_07.jpg)'
- en: 'Using labels, you can easily have a list of references at a designated location
    without making the actual text harder to read. These labels can be used for more
    than external links however; similar to the `GOTO` statements found in older programming
    languages, you can create labels and refer to them from other parts of the documentation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签，您可以在指定位置轻松创建引用列表，而不会使实际文本变得更难阅读。这些标签不仅可以用于外部链接；类似于在旧的编程语言中找到的`GOTO`语句，您可以创建标签并从文档的其他部分引用它们：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Within HTML or PDF output, this can be used to create a clickable link from
    anywhere in the text using the underscore links. Creating a clickable link to
    the label is as simple as having `label_` in the text. Note that reStructuredText
    ignores case differences so both uppercase and lowercase links work just fine.
    Even though it's not likely to make this mistake, having the same label in a single
    document with only case differences results in an error to make sure duplicates
    never occur.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML或PDF输出中，可以使用下划线链接从文本的任何位置创建可点击的链接。创建到标签的可点击链接就像在文本中有`label_`那样简单。请注意，reStructuredText忽略大小写差异，因此大写和小写链接都可以正常工作。即使不太可能犯这个错误，在单个文档中具有相同标签但只有大小写差异的情况会导致错误，以确保不会出现重复。
- en: 'The usage of references in conjunction with the headers works in a very natural
    way; you can just refer to them as you normally would and add an underscore to
    make it a link:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与标题一起使用引用的方式非常自然；您可以像通常一样引用它们，并添加下划线使其成为链接：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Links, references, and labels](images/4711_09_08.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![链接，引用和标签](images/4711_09_08.jpg)'
- en: Images
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像
- en: 'The image directive looks very similar to the label syntax. They''re actually
    a bit different but the pattern is quite similar. The image directive is just
    one of the many directives that is supported by reStructuredText. We will see
    more about that later on when we cover Sphinx and reStructuredText extensions.
    For the time being, it is enough to know that the directives start with two periods
    followed by a space, the name of the directive, and two colons:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图像指令看起来与标签语法非常相似。它们实际上有些不同，但模式非常相似。图像指令只是reStructuredText支持的许多指令中的一个。我们将在稍后介绍Sphinx和reStructuredText扩展时详细了解更多。目前，知道指令以两个句点开头，后跟一个空格，指令的名称和两个冒号就足够了：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the case of the image, the directive is called `image` of course:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像的情况下，指令当然被称为`image`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Scaled output as the actual image is much larger:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际图像要大得多，因此输出为缩放后的图像：
- en: '![Images](images/4711_09_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图像](images/4711_09_09.jpg)'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the double colon after the directives.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意指令后面有两个冒号。
- en: 'But how about specifying the size and other properties? The image directive
    has many other options (as do most other directives) which can be used: [http://docutils.sourceforge.net/docs/ref/rst/directives.html#images](http://docutils.sourceforge.net/docs/ref/rst/directives.html#images),
    they are mostly fairly obvious however. To specify the width and height or the
    scale (in percent) of the image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何指定大小和其他属性呢？图像指令有许多其他选项（大多数其他指令也是如此）可以使用：[http://docutils.sourceforge.net/docs/ref/rst/directives.html#images](http://docutils.sourceforge.net/docs/ref/rst/directives.html#images)，它们大多数都是相当明显的。要指定图像的宽度和高度或比例（以百分比表示）：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Following is the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Images](images/4711_09_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图像](images/4711_09_10.jpg)'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `scale` option uses the `width` and `height` options if available and falls
    back to the PIL (Python Imaging Library) or Pillow library to detect the image.
    If both width/height and PIL/Pillow are not available, the `scale` option will
    be ignored silently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`选项如果可用则使用`width`和`height`选项，并回退到PIL（Python Imaging Library）或Pillow库来检测图像。如果宽度/高度和PIL/Pillow都不可用，则`scale`选项将被静默忽略。'
- en: 'In addition to the `image` directive, there is also the `figure` directive.
    The difference is that `figure` adds a caption to the image. Beyond that, the
    usage is the same as `image`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`image`指令之外，还有`figure`指令。不同之处在于`figure`为图像添加了标题。除此之外，使用方式与`image`相同：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Images](images/4711_09_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图像](images/4711_09_11.jpg)'
- en: Substitutions
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换
- en: When writing documentation, it often happens that constructs are being repeated,
    the links have their own labelling system but there are more ways within reStructuredText.
    The substitution definitions make it possible to shorten directives so they can
    easily be re-used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档时，经常会发生重复使用构造的情况，链接有自己的标签系统，但在reStructuredText中还有更多的方法。替换定义使得缩短指令成为可能，因此它们可以轻松地被重复使用。
- en: 'Let''s assume we have a logo that we use quite often within a bit of text.
    Instead of typing the entire `.. image:: <url>` it would be very handy to have
    a shorthand to make it easier. That''s where the substitutions are very useful:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们有一个徽标，在文本中经常使用。与其输入整个`.. image:: <url>`，使用简写会更方便。这就是替换非常有用的地方：'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Substitutions](images/4711_09_12.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![替换](images/4711_09_12.jpg)'
- en: 'These substitutions can be used with many directives, though they are particularly
    useful for outputting a variable in many places of a document. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替换可以与许多指令一起使用，尽管它们特别适用于在文档的许多地方输出变量。例如：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Following is the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Substitutions](images/4711_09_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![替换](images/4711_09_13.jpg)'
- en: Blocks, code, math, comments, and quotes
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块，代码，数学，注释和引用
- en: 'When writing documentation, a common scenario is the need for blocks that contain
    different type of content, explanations with mathematical formulas, code examples,
    and more. The usage of these directives is similar to the image directive. Following
    is an example of a code block:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档时，常见的情况是需要包含不同类型内容的块，包括数学公式的解释，代码示例等。这些指令的使用方式类似于图像指令。以下是一个代码块的示例：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![块，代码，数学，注释和引用](images/4711_09_14.jpg)'
- en: 'Or math using LaTeX syntax, the fundamental theorem of calculus:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用LaTeX语法的数学，微积分基本定理：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Following is the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](images/4711_09_15.jpg)'
- en: 'Commenting a bunch of text/commands is easily achieved by using the "empty"
    directive followed by an indent:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用“空”指令后跟缩进轻松地对一堆文本/命令进行注释：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_16.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](images/4711_09_16.jpg)'
- en: The simplest ones are the block quotes. A block quote requires nothing but just
    a simple bit of indentation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的是块引用。块引用只需要简单的缩进。
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Blocks, code, math, comments, and quotes](images/4711_09_17.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](images/4711_09_17.jpg)'
- en: Conclusion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: reStructuredText is both a very simple and a very extensive language; a large
    portion of the syntax comes naturally when writing plain-text notes. A full guide
    to all the intricacies, however, could fill a separate book. The previous demonstrations
    should have given enough of an introduction to do at least 90 percent of the work
    you will need when documenting your projects. Beyond that, Sphinx will help a
    lot as we will see in the next sections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText既是一个非常简单又是一个非常广泛的语言；当写纯文本注释时，大部分语法都是自然而然的。然而，所有细节的完整指南可能需要一本单独的书来填满。之前的演示应该已经足够介绍至少90％的工作，您在记录项目时将需要。此外，Sphinx将在接下来的部分中帮助很多。
- en: The Sphinx documentation generator
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sphinx文档生成器
- en: 'The Sphinx documentation generator was created in 2008 for the Python 2.6 release
    to replace the old LaTeX documentation for Python. It''s a generator that makes
    it almost trivial to generate documentation for programming projects, but even
    outside of the programming world it can be easily used. Within programming projects,
    there is specific support for the following domains (programming languages):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx文档生成器是在2008年为Python 2.6版本创建的，以取代Python的旧LaTeX文档。它是一个几乎可以轻松生成编程项目文档的生成器，但即使在编程世界之外，它也可以轻松使用。在编程项目中，有特定支持以下领域（编程语言）：
- en: Python
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: C
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: Javascript
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Javascript
- en: reStructuredText
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reStructuredText
- en: Outside of these languages, there are extensions available for many other languages
    such as CoffeeScript, MATLAB, PHP, Ruby Lisp, Go, and Scala. And if you're simply
    looking for snippet code highlighting, the Pygments highlighter which is used
    internally supports over 120 languages and is easily extendible for new languages
    if needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些语言之外，还有许多其他语言的扩展可用，例如CoffeeScript、MATLAB、PHP、Ruby Lisp、Go和Scala。如果您只是寻找片段代码高亮显示，内部使用的Pygments高亮显示器支持超过120种语言，并且如果需要，可以轻松扩展为新语言。
- en: The most important advantage of Sphinx is that almost everything can be automatically
    generated from your source code. So the documentation is always up to date.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx的最重要优势是几乎可以从您的源代码自动生成几乎所有内容。因此，文档始终是最新的。
- en: Getting started with Sphinx
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Sphinx
- en: 'First of all, we have to make sure we install Sphinx. Even though the Python
    core documentation is written using Sphinx, it is still a separately maintained
    project and must be installed separately. Luckily, that''s easy enough using pip:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确保安装了Sphinx。尽管Python核心文档是使用Sphinx编写的，但它仍然是一个单独维护的项目，必须单独安装。幸运的是，使用pip很容易：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After installing Sphinx, there are two ways of getting started with a project,
    the `sphinx-quickstart` script and the `sphinx-apidoc` script. If you want to
    create and customize an entire Sphinx project then `sphinx-quickstart` may be
    best as it assists you in configuring a fully featured Sphinx project. If you
    simply want API documentation for an existing project then `sphinx-apidoc` might
    be better suited since it takes a single command and no further input to create
    a project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Sphinx后，有两种启动项目的方法，`sphinx-quickstart`脚本和`sphinx-apidoc`脚本。如果要创建和自定义整个Sphinx项目，那么`sphinx-quickstart`可能是最好的选择，因为它可以帮助您配置一个功能齐全的Sphinx项目。如果您只是想要现有项目的API文档，那么`sphinx-apidoc`可能更适合，因为它只需要一个命令和没有进一步的输入来创建项目。
- en: In the end, both are valid options for creating Sphinx projects and personally
    I usually end up generating the initial configuration using `sphinx-quickstart`
    and call the `sphinx-apidoc` command every time I add a Python module to add the
    new module. Since `sphinx-apidoc` does not overwrite any files by default, it
    is a safe operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两者都是创建Sphinx项目的有效选项，我个人通常最终使用`sphinx-quickstart`生成初始配置，并在每次添加Python模块时调用`sphinx-apidoc`命令以添加新模块。由于`sphinx-apidoc`默认不覆盖任何文件，因此这是一个安全的操作。
- en: Using sphinx-quickstart
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sphinx-quickstart
- en: The `sphinx-quickstart` script interactively asks you about the most important
    decisions in your Sphinx project. No need to worry if you've accidently made a
    typo however. Most of the configuration is stored in the `conf.py` directory so
    it's easy enough to edit the configuration later in case you still want to enable
    a certain module.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-quickstart`脚本会与您互动地询问有关Sphinx项目中最重要的决定。但是，如果您不小心打错了字，也不用担心。大部分配置存储在`conf.py`目录中，因此稍后编辑配置仍然很容易，以防您仍然想要启用某个模块。'
- en: 'Usage is easy enough, as a default I would recommend using the following settings.
    The output uses the following conventions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用起来很容易，作为默认值，我建议使用以下设置。输出使用以下约定：
- en: Inline comments start with `#`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联注释以`#`开头
- en: User input lines start with `>`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入行以`>`开头
- en: Cropped output is indicated with `...` and all questions skipped in between
    use the default settings
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪输出用`...`表示，所有问题之间跳过的默认设置
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should now populate your master file `docs/index.rst` and create other
    documentation source files. Use the Makefile to build the docs, like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该填充您的主文件`docs/index.rst`并创建其他文档源文件。使用Makefile构建文档，就像这样：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After running this, we should have a `docs` directory containing the Sphinx
    project. Let''s see what the command actually created for us:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，我们应该有一个包含Sphinx项目的`docs`目录。让我们看看这个命令实际为我们创建了什么：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `_build`, `_static`, and `_templates` directories are initially empty and
    can be ignored for now. The `_build` directory is used to output the generated
    documentation whereas the `_static` directory can be used to easily include custom
    CSS files and such. The `_templates` directory makes it possible to style the
    HTML output to your liking as well. Examples of these can be found in the Sphinx
    Git repository at [https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes](https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`_build`、`_static`和`_templates`目录最初是空的，现在可以忽略。`_build`目录用于输出生成的文档，而`_static`目录可用于轻松包含自定义CSS文件等。`_templates`目录还可以让您根据自己的喜好样式化HTML输出。这些示例可以在Sphinx
    Git存储库中找到：[https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes](https://github.com/sphinx-doc/sphinx/tree/master/sphinx/themes)。'
- en: '`Makefile` and `make.bat` can be used to generate the documentation output.
    `Makefile` can be used for any operating system that supports the make utility
    and `make.bat` is there to support Windows systems out of the box. Now let''s
    look at the `index.rst` source:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`和`make.bat`可用于生成文档输出。`Makefile`可用于支持make实用程序的任何操作系统，而`make.bat`则可用于直接支持Windows系统。现在让我们看一下`index.rst`源文件：'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We see the document title as expected, followed by `toctree` (table of contents
    tree; more about that later in this chapter), and the links to the indices and
    search. `toctree` automatically generates a tree out of the headers of all available
    documentation pages. The indices and tables are automatically generated Sphinx
    pages, which are very useful but nothing we need to worry about in terms of settings.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了预期的文档标题，接着是`toctree`（目录树；本章后面会详细介绍），以及索引和搜索的链接。`toctree`会自动生成所有可用文档页面的标题树。索引和表格是自动生成的Sphinx页面，非常有用，但在设置方面我们不需要担心。
- en: 'Now it''s time to generate the `HTML` output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候生成`HTML`输出了：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `make` html command generates the documentation for you and the result
    is placed in `_build/html/`. Just open `index.html` in your browser to see the
    results. You should have something looking similar to the following now:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`make html`命令会为您生成文档，并将结果放在`_build/html/`中。只需在浏览器中打开`index.html`即可查看结果。您现在应该看到类似以下的内容：'
- en: '![Using sphinx-quickstart](images/4711_09_18.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用sphinx-quickstart](images/4711_09_18.jpg)'
- en: With just that single command and by answering a few questions, we now have
    a documentation project with an index, search, and table of contents on all the
    pages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 只需这一个命令，回答几个问题，我们现在有了一个包含索引、搜索和所有页面的目录的文档项目。
- en: 'In addition to the HTML output, there are quite a few other formats supported
    by default, although some require external libraries to actually work:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了HTML输出之外，默认支持许多其他格式，尽管有些需要外部库才能真正工作：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using sphinx-apidoc
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sphinx-apidoc
- en: The `sphinx-apidoc` command is generally used together with `sphinx-quickstart`.
    It is possible to generate an entire project with the `--full` parameter but it's
    generally a better idea to generate the entire project using `sphinx-quickstart`
    and simply add the API documentation using `sphinx-apidoc`. To properly demonstrate
    the `sphinx-apidoc` command, we need some Python files, so we'll create two files
    within a project called `h09`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-apidoc`命令通常与`sphinx-quickstart`一起使用。可以使用`--full`参数生成整个项目，但通常最好使用`sphinx-quickstart`生成整个项目，然后使用`sphinx-apidoc`添加API文档。为了正确演示`sphinx-apidoc`命令，我们需要一些Python文件，因此我们将在名为`h09`的项目中创建两个文件。'
- en: 'The first one is `h09/spam.py` containing a class called `Spam` with some methods:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`h09/spam.py`，其中包含一个名为`Spam`的类和一些方法：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next we have `h09/eggs.py` containing a `Eggs` class that inherits `Spam`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`h09/eggs.py`，其中包含一个继承`Spam`的`Eggs`类：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have our source files, it''s time to generate the actual API documentation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了源文件，是时候生成实际的API文档了：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This alone is not enough to include the API in the documentation. It needs
    to be added to `toctree`. Luckily, that''s as simple as adding modules to `toctree`
    in the `index.rst` file to look something like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不足以将API包含在文档中。它需要添加到`toctree`中。幸运的是，只需在`index.rst`文件中的`toctree`中添加模块即可，看起来像这样：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `toctree` directive is discussed in further detail later in this chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`toctree`指令将在本章后面更详细地讨论。'
- en: 'We also have to make sure that the modules can be imported, otherwise Sphinx
    won''t be able to read the Python files. To do that, we simply add the `h09` directory
    to `sys.path`; this can be put anywhere in the `conf.py` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保可以导入模块，否则Sphinx将无法读取Python文件。为此，我们只需将`h09`目录添加到`sys.path`中；这可以放在`conf.py`文件的任何位置：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now it''s time to generate the documentation again:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次生成文档了：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open the `docs/_build/index.html` file again. For the sake of brevity, the
    repeated parts of the document will be omitted from the screenshots. The cropped
    output is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开`docs/_build/index.html`文件。为了简洁起见，文档的重复部分将从截图中省略。裁剪后的输出如下：
- en: '![Using sphinx-apidoc](images/4711_09_19.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![使用sphinx-apidoc](images/4711_09_19.jpg)'
- en: But it actually generated quite a bit more. When running the `sphinx-apidoc`
    command, it looks at all the Python modules in the specified directory recursively
    and generates a `rst` file for each of them. After generating all those separate
    files, it adds all those to a file called `modules.rst` which makes it easy to
    add them to your documentation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但它实际上生成了更多。运行`sphinx-apidoc`命令时，它会递归查看指定目录中的所有Python模块，并为每个生成一个`rst`文件。在生成所有这些单独的文件之后，它将所有这些添加到一个名为`modules.rst`的文件中，这样就可以轻松地将它们添加到您的文档中。
- en: 'The `modules.rst` file is really straight to the point; nothing more than a
    list of modules with the package name as the title really:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules.rst`文件非常简单明了；只是一个以包名称为标题的模块列表：'
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Using sphinx-apidoc](images/4711_09_20.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![使用sphinx-apidoc](images/4711_09_20.jpg)'
- en: '`spam.rst` and `eggs.rst` are equally simple, but more important in terms of
    customization. Within those files it adds the automodule directive which imports
    the Python module and lists the methods. The methods that are listed can be configured
    and by default we already get pretty useful output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam.rst`和`eggs.rst`同样简单，但在定制方面更为重要。在这些文件中，它添加了`automodule`指令，该指令导入Python模块并列出方法。列出的方法可以进行配置，默认情况下我们已经得到了非常有用的输出：'
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Following is the output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Using sphinx-apidoc](images/4711_09_21.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![使用sphinx-apidoc](images/4711_09_21.jpg)'
- en: Pretty, isn't it? And all that can be generated from most Python projects with
    virtually no effort whatsoever. The nice things about this is that the documentation
    we added to `Eggs.regular_method` is immediately added here, the inherited base
    (`spam.Spam`) is a clickable link to the `spam.Spam` documentation page, and the
    `:func:` role makes `spam.Spam.regular_method` immediately clickable as well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮，不是吗？所有这些几乎可以毫不费力地从大多数Python项目中生成。这里的好处是我们添加到`Eggs.regular_method`的文档立即添加到这里，继承的基类（`spam.Spam`）是指向`spam.Spam`文档页面的可点击链接，`：func：`角色也使`spam.Spam.regular_method`立即可点击。
- en: 'The output for the spam module is similar:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: spam模块的输出类似：
- en: '![Using sphinx-apidoc](images/4711_09_22.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![使用sphinx-apidoc](images/4711_09_22.jpg)'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: New files won't be added to your docs automatically. It is safe to rerun the
    `sphinx-apidoc` command to add the new files but it won't update your existing
    files. Even though the `--force` option can be used to force overwriting the files,
    within existing files I recommend manually editing them instead. As we will see
    in the next sections, there are quite a few reasons to manually modify the generated
    files after.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件不会自动添加到您的文档中。重新运行`sphinx-apidoc`命令以添加新文件是安全的，但它不会更新您现有的文件。即使`--force`选项可以用于强制覆盖文件，我建议手动编辑现有文件。正如我们将在接下来的部分中看到的，有很多理由在生成的文件之后手动修改它们。
- en: Sphinx directives
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sphinx指令
- en: Sphinx adds a few directives on top of the default ones in reStructuredText
    and an easy API to add new directives yourself. Most of them are generally not
    that relevant to modify but, as one would expect, Sphinx has pretty good documentation
    in case you need to know more about them. There are a few very commonly used ones
    which we will discus however.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx在reStructuredText的默认指令之上添加了一些指令，并提供了一个简单的API来添加新的指令。其中大多数通常不那么重要，但是正如人们所期望的那样，Sphinx在需要了解更多信息时有非常好的文档。有一些非常常用的指令，我们将在下面讨论。
- en: The table of contents tree directive (toctree)
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录树指令（toctree）
- en: 'This is one of the most important directives in Sphinx; it generates `toctree`
    (table of contents tree). The `toctree` directive has a couple of options but
    the most important one is probably `maxdepth` which specifies how deep the tree
    needs to go. The top level of `toctree` has to be specified manually by specifying
    the files to be read, but beyond that every level within a document (section,
    chapter, paragraph, and so on) can be another level in `toctree`, depending on
    the depth of course. Even though the `maxdepth` option is optional, without it
    all the available levels will be shown, which is usually more than required. In
    most cases a `maxdepth` of 2 is a good default value which makes the basic example
    look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Sphinx中最重要的指令之一；它生成`toctree`（目录树）。`toctree`指令有一些选项，但最重要的可能是`maxdepth`，它指定树需要多深。`toctree`的顶层必须通过手动指定要读取的文件来指定，但在此之外，文档中的每个级别（部分、章节、段落等）都可以是`toctree`中的另一级，取决于深度。即使`maxdepth`选项是可选的，但如果没有它，将显示所有可用级别，这通常超出了所需范围。在大多数情况下，`maxdepth`为2是一个很好的默认值，使基本示例看起来像这样：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The items in `toctree` are the `.rst` files in the same directory without the
    extension. This can include subdirectories, in which case the directories are
    separated with a `.` (period):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`toctree`中的项目是同一目录中的`.rst`文件，不包括扩展名。这可以包括子目录，此时目录用`.`（句号）分隔：'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another very useful option is the `glob` option. It tells `toctree` to use
    the `glob` module in Python to automatically add all the documents matching a
    pattern. By simply adding a directory with a `glob` pattern, you can add all the
    files in that directory. This makes the `toctree` we had before as simple as:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的选项是`glob`选项。它告诉`toctree`使用Python中的`glob`模块自动添加所有匹配模式的文档。通过简单地添加一个带有`glob`模式的目录，您可以添加该目录中的所有文件。这使得我们之前的`toctree`变得非常简单：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If for some reason the document title is not as you would have liked, you can
    easily change the title to something customized:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因文档标题不如您所希望的那样，您可以轻松地将标题更改为自定义内容：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Autodoc, documenting Python modules, classes, and functions
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autodoc，记录Python模块、类和函数
- en: The most powerful feature of Sphinx is the possibility of automatically documenting
    your modules, classes, and functions. The `sphinx-apidoc` command has already
    generated some of these for us, so let's use those files for the `Spam` and `Eggs`
    classes to extend the documentation a bit.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx最强大的功能是自动记录模块、类和函数的可能性。 `sphinx-apidoc`命令已经为我们生成了一些文件，所以让我们使用这些文件来为`Spam`和`Eggs`类扩展文档。
- en: 'The original result from `sphinx-apidoc` was:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-apidoc`的原始结果是：'
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This renders as:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现为：
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_23.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Autodoc，记录Python模块、类和函数](images/4711_09_23.jpg)'
- en: 'The `Eggs` class has only a single function right now. We can of course click
    towards the parent class with ease, but in many cases it''s useful to see all
    available functions in the class. So let''s add all the functions that are inherited
    from `Spam` as well:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eggs`类目前只有一个函数。当然，我们可以轻松地点击到父类，但在许多情况下，查看类中所有可用的函数是很有用的。因此，让我们也添加从`Spam`继承的所有函数：'
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_24.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Autodoc，记录Python模块、类和函数](images/4711_09_24.jpg)'
- en: 'Much more useful already, but we are still missing the hidden method. Let''s
    add the private members as well:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 已经更有用了，但我们仍然缺少隐藏的方法。让我们也添加私有成员：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Following is the output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_25.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Autodoc，记录Python模块、类和函数](images/4711_09_25.jpg)'
- en: Now all the methods are shown, but what about the `members` option? Without
    the `members` option or the `*-members` options, no functions will be visible
    anymore.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的方法都显示出来了，但`members`选项呢？如果没有`members`选项或`*-members`选项，将不再显示任何函数。
- en: '`show-inheritance` is useful if you want to have the `Bases: ...` section so
    it is possible to click to the parent class.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想要有`Bases: ...`部分，以便可以单击到父类，`show-inheritance`是有用的。'
- en: Naturally, it is also possible to create classes manually. While this has little
    practical use, it does show the internal structure of Python classes within Sphinx.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以手动创建类。虽然这几乎没有实际用途，但它确实展示了Sphinx中Python类的内部结构。
- en: 'There is a practical case however, if you are dynamically creating classes
    then `autodoc` will not always be able to document correctly and some additional
    help is required. There is more however, while it''s generally not that useful
    as you''re doing double work. In some cases, the `autodoc` extension won''t be
    able to correctly identify the members of your class. This is true in case of
    dynamic class/function generation, for example. For such cases, it can be useful
    to add some manual documentation to the module/class/function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个实际的情况，如果您正在动态创建类，那么`autodoc`将无法始终正确地记录文档，并且需要一些额外的帮助。然而，还有更多，虽然通常情况下并不那么有用，因为这样做相当于重复工作。在某些情况下，`autodoc`扩展无法正确识别类的成员。例如，在动态类/函数生成的情况下就是如此。对于这种情况，向模块/类/函数添加一些手动文档可能会有用：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Following is the output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Autodoc, documenting Python modules, classes, and functions](images/4711_09_26.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Autodoc，记录Python模块、类和函数](images/4711_09_26.jpg)'
- en: If at all possible, I would avoid this usage though. The biggest benefit of
    Sphinx is that it can automatically generate a large portion of your docs for
    you. By manually documenting, you may produce the one thing that's worse than
    no documentation, that is incorrect documentation. These statements are mainly
    useful for meta-documentation; documenting how a class might look instead of an
    actual example.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我会尽量避免这种用法。Sphinx最大的好处是它可以自动生成大部分文档。通过手动记录，您可能会产生比没有文档更糟糕的东西，即不正确的文档。这些陈述主要用于元文档；记录类可能看起来如何，而不是实际示例。
- en: Sphinx roles
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sphinx角色
- en: 'We have seen Sphinx directives, which are separate blocks. Now we will discuss
    Sphinx roles, which can be used in-line. A role allows you to tell Sphinx how
    to parse some input. Examples of these roles are links, math, code, and markup.
    But the most important ones are the roles within the Sphinx domains for referencing
    other classes, even for external projects. Within Sphinx, the default domain is
    the Python one so a role such as `:py:meth:` can be used as `:meth:` as well.
    These roles are really useful to link to different packages, modules, classes,
    methods, and other objects. The basic usage is simple enough. To link to a class,
    use the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Sphinx指令，它们是单独的块。现在我们将讨论Sphinx角色，这些角色可以在行内使用。角色允许您告诉Sphinx如何解析某些输入。这些角色的示例包括链接、数学、代码和标记。但最重要的是Sphinx领域内用于引用其他类的角色，甚至是外部项目。在Sphinx中，默认领域是Python领域，因此像`:py:meth:`这样的角色也可以使用`:meth:`。这些角色非常有用，可以链接到不同的包、模块、类、方法和其他对象。基本用法非常简单。要链接到一个类，请使用以下内容：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '![Sphinx roles](images/4711_09_27.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![斯芬克斯角色](images/4711_09_27.jpg)'
- en: 'The same goes for just about any other object, functions, exceptions, attributes,
    and so on. The Sphinx documentation offers a list of supported objects: [http://sphinx-doc.org/domains.html#cross-referencing-python-objects](http://sphinx-doc.org/domains.html#cross-referencing-python-objects).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于几乎任何其他对象，函数、异常、属性等。Sphinx文档提供了支持的对象列表：[http://sphinx-doc.org/domains.html#cross-referencing-python-objects](http://sphinx-doc.org/domains.html#cross-referencing-python-objects)。
- en: 'One of the nicer features of Sphinx is that this is actually possible across
    projects as well, adding a reference to the `int` object in the standard Python
    documentation is easily possible using `:obj:`int``. And adding references to
    your own projects on other sites is fairly trivial as well. Perhaps you remember
    the `intersphinx` question from the `sphinx-quickstart` script:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx的一个更好的功能是，这实际上也可以跨项目实现，通过使用`:obj:`int``可以轻松地在标准Python文档中添加对`int`对象的引用。在其他站点上添加对您自己项目的引用也相当简单。也许您还记得`sphinx-quickstart`脚本中的`intersphinx`问题：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s what makes cross-referencing between external Sphinx documentation
    and your local one possible. With `intersphinx` you can add links between projects
    with virtually no effort whatsoever. The standard `intersphinx_mapping` in `conf.py`
    is a bit limited:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使外部Sphinx文档和您的本地文档之间的交叉引用成为可能的原因。使用`intersphinx`，您可以在项目之间添加链接，几乎不需要任何努力。`conf.py`中的标准`intersphinx_mapping`有点有限：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, it can easily be extended to other documentation sites:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它可以很容易地扩展到其他文档站点：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can easily link to the documentation on the Sphinx homepage:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地链接到Sphinx主页上的文档：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Following is the output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Sphinx roles](images/4711_09_28.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![斯芬克斯角色](images/4711_09_28.jpg)'
- en: This links to [http://www.sphinx-doc.org/en/stable/ext/intersphinx.html](http://www.sphinx-doc.org/en/stable/ext/intersphinx.html).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将链接到[http://www.sphinx-doc.org/en/stable/ext/intersphinx.html](http://www.sphinx-doc.org/en/stable/ext/intersphinx.html)。
- en: Documenting code
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录代码
- en: 'There are currently three different documentation styles supported by Sphinx:
    the original Sphinx style and the more recent NumPy and Google styles. The differences
    between them are mainly in style but it''s actually slightly more than that.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Sphinx支持三种不同的文档样式：原始的Sphinx样式和较新的NumPy和Google样式。它们之间的区别主要在于样式，但实际上略有不同。
- en: 'The Sphinx style was developed using a bunch of reStructuredText roles, a very
    effective method but when used a lot it can be detrimental for readability. You
    can probably tell what the following does but it''s not the nicest syntax:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx风格是使用一堆reStructuredText角色开发的，这是一种非常有效的方法，但是如果经常使用，可能会对可读性产生不利影响。你可能能够猜出以下内容的含义，但它的语法并不是最好的：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The Google style was (as the name suggests) developed by Google. The goal was
    to have a simple/readable format which works both as in-code documentation and
    parse able for Sphinx. In my opinion, this comes closer to the original idea of
    reStructuredText, a format that''s very close to how you would document instinctively.
    This example has the same meaning as the Sphinx style example shown earlier:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Google风格（顾名思义）是由Google开发的。其目标是具有简单/易读的格式，既可以作为代码内文档，又可以被Sphinx解析。在我看来，这更接近于reStructuredText的原始理念，这是一种非常接近你本能地记录文档的格式。这个例子与之前展示的Sphinx风格例子具有相同的含义：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The NumPy style was created specifically for the NumPy project. The NumPy project
    has many functions with a huge amount of documentation and generally a lot of
    documentation per argument. It is slightly more verbose than the Google format
    but quite easy to read as well:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy风格是专门为NumPy项目创建的。NumPy项目有许多函数，文档量很大，通常每个参数都有很多文档。它比Google格式稍微冗长，但同样易于阅读：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the future, with the Python 3.5 type hint annotations, at least the argument
    type part of these syntaxes might become useless. For the time being, Sphinx has
    no specific support for the annotations yet, so explicit type hinting through
    the docs must be used. But perhaps we can use the following soon:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在将来，随着Python 3.5类型提示注释的出现，至少这些语法中的参数类型部分可能会变得无用。目前，Sphinx还没有针对注释的特定支持，因此必须通过文档进行显式类型提示。但也许我们很快就可以使用以下内容：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Documenting a class with the Sphinx style
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sphinx风格记录一个类
- en: 'First of all, let''s look at the traditional style, the Sphinx style. While
    it''s easy to understand what all the parameters mean, it''s a bit verbose and
    not all that readable. Nonetheless, it''s pretty clear and definitely not a bad
    style to use:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看传统风格，即Sphinx风格。虽然很容易理解所有参数的含义，但有点冗长，不太易读。尽管如此，它非常清晰，绝对不是一个糟糕的风格。
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Following is the output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Documenting a class with the Sphinx style](images/4711_09_29.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sphinx风格记录一个类](images/4711_09_29.jpg)'
- en: This is a very useful output indeed with documented functions, classes, and
    arguments. And more importantly, the types are documented as well, resulting in
    a clickable link towards the actual type. An added advantage of specifying the
    type is that many editors understand the documentation and will provide auto-completion
    based on the given types.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常有用的输出，其中包括了文档化的函数、类和参数。更重要的是，类型也被记录下来，从而产生了指向实际类型的可点击链接。指定类型的一个额外优势是，许多编辑器都能理解文档，并将根据给定的类型提供自动补全。
- en: To explain what's actually happening here, Sphinx has a few roles within the
    docstrings that offer hints as to what we are documenting.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这里实际发生了什么，Sphinx在文档字符串中有一些角色，提供了我们正在记录的提示。
- en: The `param` role paired with a name sets the documentation for the parameter
    with that name. The `type` role paired with a name tells Sphinx the data type
    of the parameter. Both the roles are optional and the parameter simply won't have
    any added documentation if they are omitted, but the `param` role is always required
    for any documentation to show. Simply adding the `type` role without the `param`
    role will result in no output whatsoever, so take note to always pair them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`param`角色与名称配对，设置了具有该名称的参数的文档。`type`角色与名称配对，告诉Sphinx参数的数据类型。这两个角色都是可选的，如果省略它们，参数就不会有任何额外的文档，但`param`角色对于任何文档都是必需的。只是添加`type`角色而不添加`param`角色将导致没有任何输出，因此请注意始终将它们配对使用。'
- en: The `returns` role is similar to the `param` role with regards to documenting.
    While the `param` role documents a parameter, the `returns` role documents the
    returned object. They are slightly different however. Opposed to the `param` role,
    the `returns` role is not dependent of the `rtype` role or vice versa. They both
    work independently of each other making it possible to use either or both of the
    roles.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns`角色类似于`param`角色，用于文档记录。`param`角色记录参数，`returns`角色记录返回的对象。但它们有一些不同。与`param`角色相反，`returns`角色不依赖于`rtype`角色，反之亦然。它们都可以独立工作，可以使用其中一个或两个角色。'
- en: The `rtype`, as you can expect, tells Sphinx (and several editors) what type
    of object is returned from the function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`rtype`告诉Sphinx（以及一些编辑器）函数返回的对象的类型。'
- en: Documenting a class with the Google style
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Google风格记录一个类
- en: The Google style is just a more legible version of the Sphinx style documentation.
    It doesn't actually support more or less but it's a lot more intuitive to use.
    The only thing to keep in mind is that it's a fairly recent feature of Sphinx.
    With the older versions, you were required to install the `sphinxcontrib-napoleon`
    package. These days it comes bundled with Sphinx but still needs to be enabled
    through the `conf.py` file. So, depending on the Sphinx version (Napoleon was
    added in Sphinx 1.3), you will need to add either `sphinx.ext.napoleon` or `sphinxcontrib.napoleon`
    to the extensions list in `conf.py`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Google风格只是Sphinx风格文档的更易读版本。它实际上并不支持更多或更少，但使用起来更直观。唯一需要记住的是，这是Sphinx的一个相当新的特性。在旧版本中，你需要安装`sphinxcontrib-napoleon`包。如今它已经捆绑在Sphinx中，但仍然需要通过`conf.py`文件启用。因此，根据Sphinx的版本（Napoleon是在Sphinx
    1.3中添加的），你需要在`conf.py`的扩展列表中添加`sphinx.ext.napoleon`或`sphinxcontrib.napoleon`。
- en: 'Once you have everything configured correctly, we can use both the Google and
    NumPy style. Here''s the Google style version of the `Spam` class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确配置了所有内容，我们可以同时使用Google和NumPy风格。这是`Spam`类的Google风格版本：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is easier on the eyes than the Sphinx style and has the same amount of
    possibilities. For longer argument documentation, it's less than convenient though.
    Just imagine how a multiline description of `amount` would look. That is why the
    NumPy style was developed, a lot of documentation for its arguments.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这比Sphinx风格更容易阅读，并且具有相同数量的可能性。对于更长的参数文档，这并不方便。想象一下`amount`的多行描述会是什么样子。这就是为什么开发了NumPy风格，用于其参数的大量文档。
- en: Documenting a class with the NumPy style
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NumPy风格记录类
- en: 'The NumPy style is meant for having a lot of documentation. Honestly, most
    people are too lazy for that, so for most projects it would not be a good fit.
    If you do plan to have extensive documentation of your functions and all their
    parameters, the NumPy style might be a good option for you. It''s a bit more verbose
    than the Google style but it''s very legible, especially with more detailed documentation.
    Just remember that, similar to the Google style, this requires the Napoleon extension
    for Sphinx, so make sure you have Sphinx 1.3 or above installed. Following is
    the NumPy version of the `Spam` class:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy风格适用于大量文档。老实说，大多数人都太懒了，所以对于大多数项目来说，这并不合适。如果您计划对函数及其所有参数进行广泛的文档记录，那么NumPy风格可能是一个不错的选择。它比Google风格更冗长，但非常易读，特别是在更详细的文档中。请记住，与Google风格类似，这需要Sphinx的Napoleon扩展，因此请确保您已安装了Sphinx
    1.3或更高版本。以下是`Spam`类的NumPy版本：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: While the NumPy style definitely isn't bad, it's just very verbose. This example
    alone is about 1.5 times as long as the alternatives. So, for longer and more
    detailed documentation it's a very good choice, but if you're planning to have
    short documentation anyhow, just use the Google style instead.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NumPy风格绝对不错，但它非常冗长。仅这个例子就比其他选择长约1.5倍。因此，对于更长和更详细的文档，这是一个非常好的选择，但如果您计划无论如何都有简短的文档，那就使用Google风格吧。
- en: Which style to choose
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择哪种风格
- en: For most projects, the Google style is the best choice since it is readable
    but not too verbose. If you are planning to use large amounts of documentation
    per parameter then the NumPy style might be a good option as well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目来说，Google风格是最佳选择，因为它既易读又不太冗长。如果您计划对每个参数使用大量文档，那么NumPy风格也可能是一个不错的选择。
- en: The only reason to choose the Sphinx style is legacy. Even though the Google
    style might be more legible, consistency is more important.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Sphinx风格的唯一原因是传统。尽管Google风格可能更易读，但一致性更重要。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Documentation can help greatly in a project's popularity and bad documentation
    can kill productivity. I think there are few aspects of a library that have more
    impact on the usage by third parties than documentation. Thus in many cases, documentation
    is a more important factor in deciding the usage of a project than the actual
    code quality. That's why it is very important to always try to have some documentation
    available.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以极大地帮助项目的受欢迎程度，而糟糕的文档可能会破坏生产力。我认为在库的几个方面中，没有比文档对第三方使用的影响更大的了。因此，在许多情况下，文档是决定项目使用的更重要因素，而不是实际的代码质量。这就是为什么始终努力提供一些文档非常重要。
- en: With Sphinx it is actually easy to generate documentation. With just a few minutes
    of your time, you can have a fully functioning website with documentation available,
    or a PDF, or ePub, or one of the many other output formats. There really is no
    excuse for having no documentation anymore. And even if you don't use the documentation
    that much yourself, offering type hints to your editor can help a lot in productivity
    as well. Making your editor smarter should always help in productivity. I for
    one have added type hints to several projects simply to increase my productivity.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sphinx实际上很容易生成文档。只需花几分钟时间，您就可以拥有一个完全运行的网站，可用的文档，或者PDF，ePub或其他许多输出格式之一。现在真的没有不编写文档的借口了。即使您自己不怎么使用文档，为编辑器提供类型提示也可以大大提高生产力。让您的编辑器更智能应该总是有助于提高生产力。我本人已经在几个项目中添加了类型提示，只是为了提高我的生产力。
- en: The next chapter will explain how code can be tested in Python and some part
    of the documentation will return there. Using `doctest`, it is possible to have
    example code, documentation, and tests in one.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释如何在Python中测试代码，文档的一部分将在那里返回。使用`doctest`，可以将示例代码、文档和测试合而为一。
