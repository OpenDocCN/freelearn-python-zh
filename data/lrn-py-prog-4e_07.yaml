- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Exceptions and Context Managers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常和上下文管理器
- en: The best-laid schemes o’ mice an’ men Gang aft agley.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最精心的计划，老鼠和人类都会出错。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Robert Burns
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 罗伯特·彭斯
- en: This famous line by Robert Burns should be etched into the mind of every programmer.
    Even if our code is correct, errors will happen. If we do not deal with them properly,
    they can cause our best-laid schemes to go awry.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·彭斯这句著名的话应该铭刻在每个程序员的脑海中。即使我们的代码是正确的，错误仍然会发生。如果我们没有正确处理它们，它们可能会使我们的精心策划的计划走向歧途。
- en: Unhandled errors can cause software to crash or misbehave. Depending on the
    nature of the software in question, this could have serious consequences. Therefore,
    it is important to learn how to detect and handle errors. We encourage you to
    cultivate the habit of always thinking about what errors can occur and how your
    code should respond when they do.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的错误可能导致软件崩溃或行为异常。根据所涉及软件的性质，这可能会产生严重后果。因此，学习如何检测和处理错误非常重要。我们鼓励你养成总是思考可能发生的错误以及当它们发生时你的代码应该如何响应的习惯。
- en: This chapter is all about errors and dealing with the unexpected. We will be
    learning about **exceptions** , which are Python’s way of signaling that an error
    or other exceptional event has occurred. We will also talk about **context managers**
    , which provide a mechanism to encapsulate and reuse error-handling code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于错误和应对意外情况。我们将学习关于**异常**的内容，这是Python表示错误或其他异常事件发生的方式。我们还将讨论**上下文管理器**，它提供了一种封装和重用错误处理代码的机制。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Exceptions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Context managers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Exceptions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Even though we have not covered the topic yet, we expect that by now you have
    at least a vague idea of what an exception is. In the previous chapters, we saw
    that when an iterator is exhausted, calling `next()` on it raises a `StopIteration`
    exception. We got an `IndexError` when we tried accessing a list at a position
    that was outside the valid range. We also encountered `AttributeError` when we
    tried accessing an attribute that did not exist on an object, and `KeyError` when
    we tried to access a nonexistent key in a dictionary. In this chapter, we will
    discuss exceptions in more depth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有涉及这个主题，但我们预计到现在你至少对异常有一个模糊的概念。在前几章中，我们看到当迭代器耗尽时，对其调用`next()`会引发`StopIteration`异常。当我们尝试访问一个不在有效范围内的列表位置时，我们得到了`IndexError`。当我们尝试访问一个对象上不存在属性时，我们遇到了`AttributeError`，当我们尝试访问字典中不存在的键时，我们遇到了`KeyError`。在本章中，我们将更深入地讨论异常。
- en: Even when an operation or a piece of code is correct, there are often conditions
    in which something may go wrong. For example, if we are converting user input
    from `str` to `int` , the user could have accidentally typed a letter in place
    of a digit, making it impossible for us to convert that value into a number. When
    dividing numbers, we may not know in advance whether we might attempt a division
    by 0. When opening a file, it could be missing or corrupted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个操作或一段代码是正确的，也常常存在可能出现错误的情况。例如，如果我们正在将用户输入从`str`转换为`int`，用户可能会不小心输入了一个字母代替数字，这使得我们无法将那个值转换为数字。在除法操作中，我们可能事先不知道是否可能尝试除以0。在打开文件时，它可能不存在或已损坏。
- en: 'When an error is detected during execution, it is called an **exception** .
    Exceptions are not necessarily lethal; in fact, the `StopIteration` exception
    is deeply integrated into the Python generator and iterator mechanisms. Normally,
    however, if you do not take the necessary precautions, an exception will cause
    your application to break. Sometimes, this is the desired behavior, but in other
    cases, we want to prevent and control problems such as these. For example, if
    a user tries to open a corrupted file, we can alert them to the problem and give
    them an opportunity to fix it. Let us see an example of a few exceptions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当在执行过程中检测到错误时，它被称为**异常**。异常并不一定是致命的；实际上，`StopIteration`异常已经深深集成到Python的生成器和迭代器机制中。然而，通常情况下，如果你不采取必要的预防措施，异常将导致你的应用程序崩溃。有时，这是期望的行为，但在其他情况下，我们希望防止和控制这些问题。例如，如果用户尝试打开一个损坏的文件，我们可以提醒他们问题，并给他们机会修复它。让我们看看几个异常的例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the Python shell is quite forgiving. We can see `Traceback`
    so that we have information about the error, but the shell itself still runs normally.
    This is a special behavior; a regular program or a script would normally exit
    immediately if nothing were done to handle exceptions. Let us see a quick example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python的shell非常宽容。我们可以看到`Traceback`，这样我们就有关于错误的信息，但shell本身仍然正常运行。这是一种特殊的行为；一个常规程序或脚本如果没有处理异常，通常会立即退出。让我们看一个快速示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we run this code, we get the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会得到以下输出：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because we did nothing to handle the exception, Python immediately exits once
    an exception occurs (after printing out information about the error).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有做任何处理异常的事情，所以一旦发生异常，Python就会立即退出（在打印出错误信息之后）。
- en: Raising exceptions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引发异常
- en: 'The exceptions we have seen so far were raised by the Python interpreter when
    it detected an error. However, you can also raise exceptions yourself, when a
    situation occurs that your own code considers to be an error. To raise an exception,
    use the `raise` statement. Here is an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的异常是由Python解释器在检测到错误时引发的。然而，你也可以在发生你自己的代码认为的错误的情况时引发异常。要引发异常，请使用`raise`语句。以下是一个示例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are no restrictions on which exception types you can raise. This allows
    you to choose the exception type that best describes the error condition that
    has occurred. You can also define your own exception types (we will see how to
    do that in a moment). Notice that the argument we passed to the `Exception` class
    is printed out as part of the error message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以引发任何类型的异常没有限制。这允许你选择最能描述已发生错误条件的异常类型。你还可以定义自己的异常类型（我们将在下一刻看到如何做到这一点）。请注意，我们传递给`Exception`类的参数被打印出来作为错误消息的一部分。
- en: Python has too many built-in exceptions to list here, but they are all documented
    at [https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions)
    .
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python有太多内置异常无法在此列出，但它们都在[https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions)中进行了文档说明。
- en: Defining your own exceptions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自己的异常
- en: As we mentioned in the previous section, you can define your own custom exceptions.
    In fact, it is pretty common for libraries, for example, to define their own exceptions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，你可以定义自己的自定义异常。实际上，对于库来说，定义自己的异常是很常见的。
- en: All you need to do is define a class that inherits from any other exception
    class. All exceptions derive from `BaseException` ; however, this class is not
    intended to be directly subclassed. Your custom exceptions should inherit from
    `Exception` instead. In fact, nearly all built-in exceptions also inherit from
    `Exception` . Exceptions that do not inherit from `Exception` are meant for internal
    use by the Python interpreter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的只是定义一个继承自任何其他异常类的类。所有异常都源自`BaseException`；然而，这个类并不打算被直接子类化。你的自定义异常应该继承自`Exception`。实际上，几乎所有内置异常也都继承自`Exception`。不继承自`Exception`的异常是打算由Python解释器内部使用的。
- en: Tracebacks
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tracebacks
- en: 'The **traceback** that Python prints when an unhandled exception occurs may
    initially look intimidating, but it is quite useful for understanding what happened
    to cause the exception. For this example, we are using a mathematical formula
    to solve quadratic equations; it is not important if you are not familiar with
    it, as you do not need to understand it. Let us look at a traceback and see what
    it can tell us:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python遇到未处理的异常时打印的**traceback**可能一开始看起来令人畏惧，但它对于理解导致异常的原因非常有用。在这个例子中，我们使用一个数学公式来解二次方程；如果你不熟悉它，没关系，因为你不需要理解它。让我们看看traceback，看看它能告诉我们什么：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we defined a function called `quadratic()` , which uses the famous quadratic
    formula to find the solution of a quadratic equation. Instead of using the `sqrt()`
    function from the `math` module, we wrote our own version ( `squareroot()` ),
    which raises an exception if the number is negative. When we call `quadratic(1,
    0, 1)` to solve the equation *x* ² *+1=0* , we will get a `ValueError` because
    `d` is negative. When we run this, we get the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`quadratic()`的函数，它使用著名的二次公式来找到二次方程的解。我们不是使用`math`模块中的`sqrt()`函数，而是编写了自己的版本（`squareroot()`），如果数字是负数，它会引发异常。当我们调用`quadratic(1,
    0, 1)`来解方程*x*² + 1 = 0时，我们会得到一个`ValueError`，因为`d`是负数。当我们运行这个程序时，我们得到以下结果：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is often useful to read tracebacks from bottom to top. On the very last
    line, we have the error message, telling us what went wrong: `ValueError: No negative
    numbers please` . The preceding lines tell us where the exception was raised (line
    4 of `exceptions/trace.back.py` in the `squareroot()` function).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '从下到上阅读堆栈跟踪通常很有用。在最后一行，我们有错误消息，告诉我们出了什么问题：`ValueError: No negative numbers please`。前面的行告诉我们异常是在哪里引发的（`squareroot()`
    函数中的 `exceptions/trace.back.py` 文件的第 4 行）。'
- en: 'We can also see the sequence of function calls that got us to the point where
    the exception was raised: `squareroot()` was called on line 11 by the function
    `quadratic()` , which was called on line 16, at the top level of the module. As
    you can see, the traceback is like a map that shows us the path through the code
    to where the exception happened. Following that path and examining the code in
    each function along the way is often helpful when you want to understand why an
    exception happened.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到导致异常发生的函数调用序列：在模块的最顶层，函数 `quadratic()` 在第 16 行被调用，它又调用了在第 11 行的 `squareroot()`
    函数。正如你所看到的，堆栈跟踪就像一张地图，显示了代码中异常发生的位置。沿着这条路径检查每个函数中的代码，当你想要了解异常发生的原因时通常很有帮助。
- en: There have been several improvements to error messages in Python 3.10, 3.11,
    and 3.12. For example, the `^^^^` characters underlining the exact part of each
    statement or expression in the traceback that led to the exception were added
    in Python 3.11.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.10、3.11 和 3.12 中对错误消息进行了几次改进。例如，在 Python 3.11 中添加了 `^^^^` 字符，在堆栈跟踪中下划线了导致异常的每个语句或表达式的确切部分。
- en: Handling exceptions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: To handle an exception in Python, you use the `try` statement. When you enter
    the `try` clause, Python will watch out for one or more different types of exceptions
    (according to how you instruct it), and if they are raised, it allows you to react.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中处理异常，你使用 `try` 语句。当你进入 `try` 子句时，Python 会监视一个或多个不同类型的异常（根据你的指示），如果它们被引发，它允许你做出反应。
- en: The `try` statement is composed of the `try` clause, which opens the statement,
    followed by one or more `except` clauses that define what to do when an exception
    is caught. The `except` clauses may optionally be followed by an `else` clause,
    which is executed when the `try` clause is exited without any exception raised.
    After the `except` and `else` clauses, we can have a `finally` clause (also optional),
    whose code is executed regardless of whatever happened in the other clauses. The
    `finally` clause is typically used to clean up resources. You are also allowed
    to omit the `except` and `else` clauses and only have a `try` clause followed
    by a `finally` clause. This is helpful if we want exceptions to be propagated
    and handled elsewhere, but we do have some cleanup code that must be executed
    regardless of whether an exception occurs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句由 `try` 子句组成，它打开语句，后面跟着一个或多个 `except` 子句，这些子句定义了在捕获异常时要执行的操作。`except`
    子句后面可以有一个可选的 `else` 子句，当 `try` 子句在没有引发任何异常的情况下退出时执行。在 `except` 和 `else` 子句之后，我们可以有一个可选的
    `finally` 子句，其代码无论在其他子句中发生什么都会执行。`finally` 子句通常用于清理资源。你也可以省略 `except` 和 `else`
    子句，只保留一个 `try` 子句后跟一个 `finally` 子句。如果我们希望异常在其他地方传播和处理，但我们必须执行一些无论是否发生异常都必须执行的清理代码，这很有帮助。'
- en: 'The order of the clauses is important. It must be `try` , `except` , `else`
    , then `finally` . Also, remember that `try` must be followed by at least one
    `except` clause or a `finally` clause. Let us see an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 子句的顺序很重要。它必须是 `try`，`except`，`else`，然后是 `finally`。同时，记住 `try` 后必须跟至少一个 `except`
    子句或一个 `finally` 子句。让我们看一个例子：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example defines a simple `try_syntax()` function. We perform the division
    of two numbers. We are prepared to catch a `ZeroDivisionError` exception, which
    will occur if we call the function with `denominator = 0` . Initially, the code
    enters the `try` block. If `denominator` is not `0` , `result` is calculated and,
    after leaving the `try` block, execution resumes in the `else` block. We print
    `result` and return it. Take a look at the output, and you’ll notice that just
    before returning `result` , which is the exit point of the function, Python executes
    the `finally` clause.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个简单的 `try_syntax()` 函数。我们执行两个数的除法。我们准备捕获一个 `ZeroDivisionError` 异常，如果用
    `denominator = 0` 调用函数，这个异常就会发生。最初，代码进入 `try` 块。如果 `denominator` 不是 `0`，则计算 `result`，然后离开
    `try` 块后，执行继续在 `else` 块中。我们打印 `result` 并返回它。看看输出，你会发现就在返回 `result` 之前，这是函数的退出点，Python
    执行了 `finally` 子句。
- en: When `denominator` is `0` , things change. Our attempt to calculate `numerator
    / denominator` raises a `ZeroDivisionError` . As a result, we enter the `except`
    block and print `zde` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `denominator` 为 `0` 时，情况会改变。我们尝试计算 `numerator / denominator` 会引发一个 `ZeroDivisionError`。因此，我们进入
    `except` 块并打印 `zde`。
- en: 'The `else` block is not executed because an exception was raised in the `try`
    block. Before (implicitly) returning `None` , we still execute the `finally` block.
    Look at the output and see whether it makes sense to you:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 块没有执行，因为在 `try` 块中引发了异常。在（隐式地）返回 `None` 之前，我们仍然会执行 `finally` 块。看看输出，看看它对你是否有意义：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you execute a `try` block, you may want to catch more than one exception.
    For example, when calling the `divmod()` function, you can get a `ZeroDivisionError`
    if the second argument is `0` , or `TypeError` if either argument is not a number.
    If you want to handle both in the same way, you can structure your code like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行一个 `try` 块时，你可能想要捕获多个异常。例如，当调用 `divmod()` 函数时，如果第二个参数是 `0`，你会得到一个 `ZeroDivisionError`，如果任一参数不是数字，你会得到一个
    `TypeError`。如果你想以相同的方式处理这两个异常，你可以这样组织你的代码：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code will catch both `ZeroDivisionError` and `TypeError` . Try changing
    `values = (1, 2)` to `values = (1, 0)` or `values = ('one', 2)` , and you will
    see the output change.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将捕获 `ZeroDivisionError` 和 `TypeError`。尝试将 `values = (1, 2)` 改为 `values =
    (1, 0)` 或 `values = ('one', 2)`，你将看到输出发生变化。
- en: 'If you need to handle different exception types differently, you can use multiple
    `except` clauses, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要以不同的方式处理不同的异常类型，你可以使用多个 `except` 子句，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind that an exception is handled in the first block that matches that
    exception class or any of its base classes. Therefore, when you stack multiple
    `except` clauses like we have done here, make sure that you put specific exceptions
    at the top and generic ones at the bottom. In OOP terms, derived classes should
    be placed before their base classes. Moreover, remember that only one `except`
    handler is executed when an exception is raised.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，异常是在第一个匹配该异常类或其基类的块中处理的。因此，当你像我们这里这样做多个 `except` 子句时，确保将特定的异常放在顶部，通用的异常放在底部。在面向对象编程术语中，派生类应该放在其基类之前。此外，请记住，当引发异常时，只有一个
    `except` 处理器被执行。
- en: Python also allows you to use an `except` clause without specifying any exception
    type (this is equivalent to writing `except BaseException` ). You should, however,
    avoid doing this as it means you will also capture exceptions that are intended
    for internal use by the interpreter. They include the so-called *system-exiting
    exceptions* . These are `SystemExit` , which is raised when the interpreter exits
    via a call to the `exit()` function, and `KeyboardInterrupt` , which is raised
    when the user terminates the application by pressing *Ctrl* + *C* (or *Delete*
    on some systems).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还允许你使用一个不指定任何异常类型的 `except` 子句（这相当于写 `except BaseException`）。然而，你应该避免这样做，因为这意味着你也会捕获到那些打算由解释器内部使用的异常。这些包括所谓的
    *退出系统异常*。这些是 `SystemExit`，当解释器通过调用 `exit()` 函数退出时引发，以及 `KeyboardInterrupt`，当用户通过按下
    *Ctrl* + *C*（或在某些系统上是 *Delete*）来终止应用程序时引发。
- en: 'You can also raise exceptions from within an `except` clause. For example,
    you might want to replace a built-in exception (or one from a third-party library)
    with your own custom exception. This is quite a common technique when writing
    libraries, as it helps shield users from the implementation details of the library.
    Let us see an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `except` 子句内部引发异常。例如，你可能想用一个自定义异常替换内置异常（或第三方库中的异常）。当编写库时，这是一个相当常见的技巧，因为它有助于保护用户免受库的实现细节的影响。让我们看一个例子：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, Python assumes that an exception that happens within an `except`
    clause is an unexpected error and helpfully prints out tracebacks for both exceptions.
    We can tell the interpreter that we are deliberately raising the new exception
    by using a `raise from` statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 假设发生在 `except` 子句中的异常是一个意外错误，并且会友好地打印出两个异常的跟踪信息。我们可以通过使用 `raise
    from` 语句来告诉解释器我们故意引发新的异常：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The error message has changed, but we still get both tracebacks, which is very
    handy for debugging. If you really wanted to completely suppress the original
    exception, you could use `from None` instead of `from e` (try this yourself).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息已更改，但我们仍然得到两个跟踪信息，这对于调试非常有用。如果你真的想完全抑制原始异常，可以使用 `from None` 而不是 `from e`（自己试试）。
- en: You can also use `raise` by itself, without specifying a new exception, to re-raise
    the original exception. This is sometimes useful if you want to log the fact that
    an exception has occurred without suppressing or replacing the exception.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以仅使用`raise`，而不指定新的异常，来重新引发原始异常。如果你只想记录异常发生的事实，而不抑制或替换异常，这有时是有用的。
- en: 'Since Python 3.11, it is also possible to add notes to exceptions. This allows
    you to add extra information to be displayed as part of the traceback without
    suppressing or replacing the original exception. To see how this works, we will
    modify the quadratic formula example from earlier in the chapter, and add a note
    to the exception:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.11以来，也可以向异常添加注释。这允许你添加额外的信息，作为跟踪信息的一部分显示，而不抑制或替换原始异常。为了了解这是如何工作的，我们将修改本章前面提到的二次公式示例，并向异常添加注释：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have highlighted the lines where we added a note and re-raised the exception.
    The output when we run this looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了添加注释和重新引发异常的行。运行此代码时的输出如下：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The note has been printed below the original error message. You can add as many
    notes as you need, by calling `add_note()` multiple times. The notes must all
    be strings.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注释已打印在原始错误消息下方。你可以通过多次调用`add_note()`来添加所需数量的注释。所有注释都必须是字符串。
- en: 'Programming with exceptions can be tricky. You could inadvertently hide bugs
    by trapping exceptions that would have alerted you to their presence. Play it
    safe by keeping these simple guidelines in mind:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常进行编程可能很棘手。你可能会无意中隐藏那些本应提醒你其存在的错误。通过牢记以下简单指南来确保安全：
- en: Keep the `try` clause as short as possible. It should contain only the code
    that may cause the exception(s) that you want to handle.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使`try`子句尽可能短。它应该只包含可能引发你想要处理的异常（s）的代码。
- en: Make the `except` clauses as specific as you can. It may be tempting to just
    write `except Exception` , but if you do, you will almost certainly end up catching
    exceptions you did not actually intend to catch.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使`except`子句尽可能具体。可能有人会想只写`except Exception`，但如果你这样做，你几乎肯定会捕获到你实际上并不想捕获的异常。
- en: Use tests to ensure that your code handles both expected and unexpected errors
    correctly. We shall talk more about writing tests in *Chapter 10, Testing* .
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试来确保你的代码能够正确处理预期的和意外的错误。我们将在第10章*测试*中更详细地讨论编写测试。
- en: If you follow these suggestions, you will minimize the chance of getting it
    wrong.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些建议，你将最大限度地减少出错的可能性。
- en: Exception groups
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常组
- en: When working with large collections of data, it can be inconvenient to immediately
    stop and raise an exception when an error occurs. It is often better to process
    all the data and report on all errors that occurred at the end. This allows the
    user to deal with all the errors at once, rather than having to rerun the process
    multiple times, fixing errors one by one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量数据集时，如果发生错误，立即停止并引发异常可能不方便。通常更好的做法是处理所有数据，并在最后报告所有发生的错误。这使用户能够一次性处理所有错误，而不是需要多次重新运行过程，逐个修复错误。
- en: One way of achieving this is to build up a list of errors and return it. However,
    this has the disadvantage that you cannot use a `try` / `except` statement to
    handle the errors. Some libraries have worked around this by creating a container
    exception class and wrapping the collected errors in an instance of this class.
    This allows you to handle the container exception in an `except` clause and inspect
    it to access the nested exceptions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是通过构建一个错误列表并返回它。然而，这种方法有一个缺点，那就是你不能使用`try` / `except`语句来处理错误。一些库通过创建一个容器异常类并将收集到的错误包装在这个类的实例中来解决这个问题。这允许你在`except`子句中处理容器异常，并检查它以访问嵌套的异常。
- en: Since Python 3.11, there is a new built-in exception class, `ExceptionGroup`
    , that was specifically designed as such a container exception. Having this feature
    built into the language has the advantage that the traceback also shows the tracebacks
    of each of the nested exceptions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.11以来，有一个新的内置异常类`ExceptionGroup`，它被专门设计为这样的容器异常。将此功能内置到语言中的优点是，跟踪信息也会显示每个嵌套异常的跟踪信息。
- en: 'For example, suppose we need to validate a list of ages to ensure that the
    values are all positive integers. We could write something like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要验证一个年龄列表，以确保所有值都是正整数。我们可以编写如下内容：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `validate_ages()` function calls `validate_age()` for each element of `ages`
    . It catches any exceptions that occur and appends them to the `errors` list.
    If the list of errors is not empty after the loops complete, we raise `ExceptionGroup`
    , passing in the error message `"Validation errors"` and the list of errors that
    occurred.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_ages()` 函数对 `ages` 的每个元素调用 `validate_age()`。它捕获发生的任何异常并将它们追加到 `errors`
    列表中。如果循环完成后错误列表不为空，我们抛出 `ExceptionGroup`，传入错误消息 `"Validation errors"` 和发生的错误列表。'
- en: 'If we call this from a Python console with a list containing some invalid ages,
    we get the following traceback:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Python 控制台调用这个函数，并传入包含一些无效年龄的列表，我们会得到以下跟踪输出：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we get the traceback for the `ExceptionGroup` , including the error
    message we specified when raising it ( `"Validation errors"` ) and an indication
    that the group contains three sub-exceptions. Indented below this, we get the
    traceback for each of the nested sub-exceptions. To aid readability, the sub-exception
    tracebacks are numbered and separated by dashed lines.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们得到了 `ExceptionGroup` 的跟踪输出，包括我们抛出时指定的错误消息（`"Validation errors"`）以及指示该组包含三个子异常。在此之下缩进，我们得到每个嵌套子异常的跟踪输出。为了提高可读性，子异常跟踪输出被编号并用虚线分隔。
- en: 'We can handle `ExceptionGroup` exceptions just like any other type of exception:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理其他类型的异常一样处理 `ExceptionGroup` 异常：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we can access the nested list of sub-exceptions via the (read-only)
    `exceptions` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过（只读的）`exceptions` 属性访问嵌套的子异常列表。
- en: 'PEP 654 ( [https://peps.python.org/pep-0654/](https://peps.python.org/pep-0654/)
    ), which introduced `ExceptionGroup` to the language, also introduced a new variant
    of the `try` / `except` statement that allows us to handle nested sub-exceptions
    of particular types within an `ExceptionGroup` . This new syntax uses the keyword
    `except*` instead of `except` . In our validation example, this allows us to have
    separate handling for invalid types and invalid values without having to manually
    iterate and filter the exceptions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 654（[https://peps.python.org/pep-0654/](https://peps.python.org/pep-0654/)），它将
    `ExceptionGroup` 引入语言，还引入了 `try` / `except` 语句的新变体，允许我们在 `ExceptionGroup` 内部处理特定类型的嵌套子异常。这种新语法使用关键字
    `except*` 而不是 `except`。在我们的验证示例中，这允许我们对无效类型和无效值进行单独处理，而无需手动迭代和过滤异常：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The call to `validate_ages()` raises an exception group containing three exceptions:
    two instances of `TypeError` and a `ValueError` . The interpreter matches each
    `except*` clause to the nested exceptions. The first clause matches, so the interpreter
    creates a new `ExceptionGroup` containing all the `TypeError` instances from the
    original group and assigns this to `e` within the body of this clause. We print
    the string `"Invalid types"` , followed by the type and value of `e` and then
    `e.exceptions` . The remaining exceptions are then matched against the next `except*`
    clause.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_ages()` 的调用抛出一个包含三个异常的异常组：两个 `TypeError` 实例和一个 `ValueError`。解释器将每个
    `except*` 子句与嵌套异常匹配。第一个子句匹配，因此解释器创建一个新的 `ExceptionGroup`，包含原始组中的所有 `TypeError`
    实例，并将其分配给此子句体内的 `e`。我们打印字符串 `"Invalid types"`，然后是 `e` 的类型和值以及 `e.exceptions`。然后剩余的异常将与下一个
    `except*` 子句匹配。'
- en: This time, all the `ValueError` instances match, so `e` is assigned to a new
    `ExceptionGroup` containing these. We print the string `"Invalid values"` , again
    followed by `type(e)` , `e` , and `e.exceptions` . At this point, there are no
    unhandled exceptions left in the group, so execution resumes normally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，所有的 `ValueError` 实例都匹配，因此 `e` 被分配给一个新的包含这些异常的 `ExceptionGroup`。我们打印字符串 `"Invalid
    values"`，然后是 `type(e)`，`e` 和 `e.exceptions`。此时，组中不再有未处理的异常，因此执行恢复正常。
- en: 'It is important to be aware that this behavior is different from a normal `try`
    / `except` statement. In a normal `try` / `except` statement, only one `except`
    clause is executed: the first that matches the raised exception. In a `try` /
    `except*` statement, each matching `except*` clause is executed until there are
    no unhandled exceptions remaining in the group. If any unhandled exceptions remain
    after all the `except*` clauses have been processed, they will be reraised at
    the end as a new `ExceptionGroup` :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种行为与正常的 `try` / `except` 语句不同。在正常的 `try` / `except` 语句中，只有一个 `except`
    子句被执行：第一个匹配抛出异常的子句。在 `try` / `except*` 语句中，每个匹配的 `except*` 子句都会被执行，直到组中不再有未处理的异常。如果在所有
    `except*` 子句处理完毕后仍有未处理的异常，它们将在最后作为新的 `ExceptionGroup` 重新抛出：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another important point to note is that if an exception is raised within a
    `try` / `except*` statement that is not an `ExceptionGroup` instance, its type
    will be matched against the `except*` clauses. If a match is found, the exception
    will be wrapped in an `ExceptionGroup` before being passed to the `except*` body:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要点是，如果在不是`ExceptionGroup`实例的`try` / `except*`语句中抛出异常，其类型将与`except*`子句进行匹配。如果找到匹配项，异常将在传递到`except*`主体之前被包装在一个`ExceptionGroup`中：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means that it is always safe to assume that the exception being handled
    within an `except*` clause is an `ExceptionGroup` instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们总是可以安全地假设在`except*`子句中处理的异常是一个`ExceptionGroup`实例。
- en: Not only for errors
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅用于错误
- en: 'Before we move on to talk about context managers, we want to show you a different
    use of exceptions. In this example, we will demonstrate that exceptions can be
    used for more than just errors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论上下文管理器之前，我们想向你展示异常的不同用法。在这个例子中，我们将演示异常不仅可以用于错误：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the code above, we use three nested loops to find a combination of three
    integers ( `a` , `b` , and `c` ) that satisfy a particular equation. At the start
    of each of the outer loops, we check the value of a flag ( `found` ), which is
    set to `True` when we find a solution to the equation. This allows us to break
    out of all three loops as quickly as possible when we have a solution. We find
    the logic to check the flag rather inelegant, as it obscures the rest of the code,
    so we came up with an alternative approach:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用三个嵌套循环来找到一个满足特定方程的三个整数（`a`、`b`和`c`）的组合。在每个外部循环的开始，我们检查一个标志（`found`）的值，当我们找到一个方程的解时，该标志被设置为`True`。这使我们能够在找到解时尽可能快地跳出所有三个循环。我们认为检查标志的逻辑相当不优雅，因为它掩盖了其余的代码，所以我们想出了一个替代方法：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hopefully, you can appreciate how much more elegant this is. Now the breakout
    logic is entirely handled with a simple exception whose name even hints at its
    purpose. As soon as the result is found, we raise `ExitLoopException` with the
    values that satisfy our condition, and immediately the control is given to the
    `except` clause that handles it. Notice that we can use the `args` attribute of
    the exception to get the values that were passed to the constructor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能欣赏这种方式的优雅。现在，跳出逻辑完全由一个简单的异常来处理，其名称甚至暗示了其目的。一旦找到结果，我们就使用满足我们条件的值抛出`ExitLoopException`，然后立即将控制权交给处理它的`except`子句。注意，我们可以使用异常的`args`属性来获取传递给构造函数的值。
- en: 'Now we should have a good understanding of what exceptions are, and how they
    are used to manage errors, flow, and exceptional situations. We are ready to move
    on to the next topic: **context managers** .'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该已经很好地理解了异常是什么，以及它们是如何被用来管理错误、流程和异常情况的。我们准备好继续下一个主题：**上下文管理器**。
- en: Context managers
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: When working with external resources, we usually need to perform some cleanup
    steps when we are done. For example, after writing data to a file, we then need
    to close the file. Failing to clean up properly could result in all manner of
    bugs. Therefore, we must ensure that our cleanup code will be executed even if
    an exception happens. We could use `try` / `finally` statements, but this is not
    always convenient and could result in a lot of repetition, as we often have to
    perform similar cleanup steps whenever we work with a particular type of resource.
    **Context managers** solve this problem by creating an execution context in which
    we can work with a resource and automatically perform any necessary cleanup when
    we leave that context, even if an exception was raised.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当与外部资源一起工作时，我们通常在完成工作后需要执行一些清理步骤。例如，在将数据写入文件后，我们需要关闭文件。未能正确清理可能会导致各种错误。因此，我们必须确保即使在发生异常的情况下，我们的清理代码也会被执行。我们可以使用`try`
    / `finally`语句，但这并不总是方便，并且可能会导致大量重复，因为我们经常在处理特定类型的资源时必须执行类似的清理步骤。**上下文管理器**通过创建一个执行上下文来解决这个问题，在这个上下文中我们可以使用资源，并在离开该上下文时自动执行任何必要的清理，即使抛出了异常。
- en: 'Another use case of context managers is to make temporary changes to the global
    state of our program. One example of a global state that we may want to modify
    temporarily is the precision for decimal computations. For example, in data science
    applications, we sometimes need to perform a particular computation to a specific
    precision, but we want to retain the default precision for the rest of our computations.
    We could achieve this by doing something like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器的另一个用途是暂时更改我们程序的全球状态。我们可能想要暂时修改的全球状态的一个例子是十进制计算的精度。例如，在数据科学应用中，我们有时需要以特定的精度执行特定的计算，但我们希望保留其余计算中的默认精度。我们可以通过以下方式实现这一点：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we store the current context, set a new context (with a modified
    precision), perform our calculation, and finally restore the original context.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们存储了当前上下文，设置了一个新的上下文（具有修改后的精度），执行了我们的计算，最后恢复了原始上下文。
- en: You may recall that the `Decimal` class allows us to perform arbitrary precision
    computations with decimal numbers. If not, you may want to review the relevant
    section of *Chapter 2* , *Built-In Data Types* , now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，`Decimal` 类允许我们使用十进制数进行任意精度的计算。如果不记得，现在你可以回顾一下 *第二章*，*内置数据类型*，的相关部分。
- en: 'Running this produces the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the above example, we have printed the `context` object to show you what
    it contains. The rest of the code seems fine, but if an exception happened before
    we could restore the original context, the results of all subsequent computations
    would be incorrect. We can fix this by using a `try` / `finally` statement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们打印了 `context` 对象以显示它包含的内容。其余的代码看起来没有问题，但如果在恢复原始上下文之前发生异常，所有后续计算的结果都将是不正确的。我们可以通过使用
    `try` / `finally` 语句来修复这个问题：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That is much safer. Even if an exception does happen in that `try` block, we
    will always restore the original context. It is not very convenient to have to
    save the context and then restore it in a `try` / `finally` statement every time
    we need to work with a modified precision, though. Doing so would also violate
    the **DRY** principle. We can avoid that by using the `localcontext` context manager
    from the `decimal` module. This context manager will set and restore the context
    for us:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更安全。即使 `try` 块中发生异常，我们也会始终恢复原始上下文。但是，每次需要使用修改后的精度工作时，都必须保存上下文并在 `try` / `finally`
    语句中恢复它，这并不方便。这样做也会违反 **DRY** 原则。我们可以通过使用 `decimal` 模块中的 `localcontext` 上下文管理器来避免这种情况。这个上下文管理器会为我们设置和恢复上下文：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `with` statement is used to enter a runtime context defined by the `localcontext`
    context manager. When exiting the code block delimited by the `with` statement,
    any cleanup operation defined by the context manager (in this case, restoring
    the decimal context) is executed automatically.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 语句用于进入由 `localcontext` 上下文管理器定义的运行时上下文。当退出由 `with` 语句分隔的代码块时，上下文管理器定义的任何清理操作（在这种情况下，恢复十进制上下文）会自动执行。'
- en: 'It is also possible to combine multiple context managers in one `with` statement.
    This is quite useful for situations where you need to work with multiple resources
    at the same time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能在一个 `with` 语句中组合多个上下文管理器。这在需要同时处理多个资源的情况下非常有用：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we enter a local context and open a file (which acts as a context manager)
    in one `with` statement. We perform a calculation and write the result to the
    file. When we exit the `with` block, the file is automatically closed, and the
    default decimal context is restored. Do not worry too much about the details of
    working with files for now; we will discuss that in detail in *Chapter 8* , *Files
    and Data Persistence* .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进入一个局部上下文，并在一个 `with` 语句中打开一个文件（它充当上下文管理器）。我们执行计算并将结果写入文件。当我们退出 `with`
    块时，文件会自动关闭，并且默认的十进制上下文会恢复。现在不必太担心与文件操作相关的细节；我们将在 *第八章*，*文件和数据持久性* 中详细讨论。
- en: Before Python 3.10, surrounding multiple context managers in parentheses, as
    we did here, would have resulted in a `SyntaxError` . In older versions of Python,
    we would have had to fit both context managers into a single line of code or put
    the line break inside the parentheses of the `localcontext()` or `open()` calls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.10 之前，像我们这里这样在多个上下文管理器周围使用括号会导致 `SyntaxError`。在 Python 的旧版本中，我们必须将两个上下文管理器放入一行代码中，或者将换行符放在
    `localcontext()` 或 `open()` 调用的括号内。
- en: 'Apart from decimal contexts and files, many other objects in the Python standard
    library can be used as context managers. Here are some examples:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了十进制上下文和文件之外，Python标准库中的许多其他对象也可以用作上下文管理器。以下是一些示例：
- en: Socket objects, which implement a low-level networking interface, can be used
    as context managers to automatically close network connections.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现低级网络接口的套接字对象可以用作上下文管理器来自动关闭网络连接。
- en: The lock classes used for synchronization in concurrent programming use the
    context manager protocol to automatically release locks.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发编程中用于同步的锁类使用上下文管理器协议来自动释放锁。
- en: In the rest of this chapter, we will show you how you can implement your own
    context managers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将向您展示如何实现您自己的上下文管理器。
- en: Class-based context managers
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于类的上下文管理器
- en: 'Context managers work via two magic methods: `__enter__()` is called just before
    entering the body of the `with` statement and `__exit__()` is called when exiting
    the `with` statement body. This means that you can create your own context manager
    simply by writing a class that implements these methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器通过两个魔术方法工作：`__enter__()`在进入`with`语句的主体之前被调用，而`__exit__()`在退出`with`语句主体时被调用。这意味着您可以通过编写一个实现这些方法的类来创建自己的上下文管理器：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we have defined a context manager class called `MyContextManager` . There
    are a few interesting things to note about this class. Notice that the `__enter__()`
    method returns `self` . This is quite common, but by no means required; you can
    return whatever you want from `__enter__()` , even `None` . The return value of
    the `__enter__()` method will be assigned to the variable named in the `as` clause
    of the `with` statement. Also, notice the `exc_type` , `exc_val` , and `exc_tb`
    parameters of the `__exit__()` function. If an exception is raised within the
    body of the `with` statement, the interpreter will pass the *type* , *value* ,
    and *traceback* of the exception as arguments through these parameters. If no
    exception is raised, all three arguments will be `None` .
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`MyContextManager`的上下文管理器类。关于这个类有几个有趣的地方需要注意。请注意，`__enter__()`方法返回`self`。这是很常见的，但并非必须；您可以从`__enter__()`返回任何您想要的内容，甚至`None`。`__enter__()`方法的返回值将被分配给`with`语句中`as`子句中命名的变量。此外，请注意`__exit__()`函数的`exc_type`、`exc_val`和`exc_tb`参数。如果在`with`语句的主体内部抛出异常，解释器将通过这些参数将异常的*类型*、*值*和*跟踪信息*作为参数传递。如果没有抛出异常，所有三个参数都将为`None`。
- en: Also, notice that the `__exit__()` method returns `True` . This will cause any
    exception raised within the `with` statement body to be suppressed (as if we had
    handled it in a `try` / `except` statement). If we had returned `False` instead,
    such an exception would continue to be propagated after our `__exit__()` method
    has executed. The ability to suppress exceptions means that a context manager
    can be used as an exception handler. The benefit of this is that we can write
    our exception-handling logic once and reuse it wherever we need it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`__exit__()`方法返回`True`。这将导致在`with`语句主体内部抛出的任何异常被抑制（就像我们在`try` / `except`语句中处理它一样）。如果我们返回`False`而不是`True`，那么这样的异常在`__exit__()`方法执行后将继续传播。抑制异常的能力意味着上下文管理器可以用作异常处理程序。这种做法的好处是我们可以在需要的地方重用我们的异常处理逻辑。
- en: 'Let us see our context manager in action:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的上下文管理器是如何工作的：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we have instantiated our context manager in a separate statement, before
    the `with` statement. We did this to make it easier for you to see what is happening.
    However, it is much more common for those steps to be combined, like `with MyContextManager()
    as mgr` . Running this code produces the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`with`语句之前单独声明了我们的上下文管理器。我们这样做是为了让您更容易看到正在发生的事情。然而，将这些步骤合并，如`with MyContextManager()
    as mgr`，更为常见。运行此代码会产生以下输出：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Study this output carefully to make sure you understand what is happening. We
    have printed some IDs to help verify that the object assigned to `mgr` is really
    the same object that we returned from `__enter__()` . Try changing the return
    values from the `__enter__()` and `__exit__()` methods and see what effect that
    has.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个输出，以确保您理解正在发生的事情。我们打印了一些ID，以帮助验证分配给`mgr`的对象确实是来自`__enter__()`返回的同一个对象。尝试更改`__enter__()`和`__exit__()`方法的返回值，看看会有什么影响。
- en: Generator-based context managers
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于生成器的上下文管理器
- en: If you are implementing a class that represents some resource that needs to
    be acquired and released, it makes sense to implement that class as a context
    manager. Sometimes, however, we want to implement context manager behavior, but
    we do not have a class that it makes sense to attach that behavior to. For example,
    we may just want to use a context manager to reuse some error-handling logic.
    In such situations, it would be rather tedious to have to write an additional
    class purely to implement the desired context manager behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个表示需要获取和释放的资源类的类，将其实现为上下文管理器是有意义的。然而，有时我们想要实现上下文管理器行为，但没有一个类适合附加这种行为。例如，我们可能只想使用上下文管理器来重用一些错误处理逻辑。在这种情况下，不得不编写一个额外的类来纯粹实现所需的上下文管理器行为，这会相当繁琐。
- en: 'The `contextmanager` decorator from the `contextlib` module is useful for situations
    like this. It takes a *generator function* and converts it into a context manager
    (if you do not remember how generator functions work, you should review *Chapter
    5* , *Comprehensions and Generators* ). The decorator wraps the generator in a
    context manager object. The `__enter__()` method of this object starts the generator
    and returns whatever the generator yields. If an exception occurs within the `with`
    statement body, the `__exit__()` method passes the exception into the generator
    (using the generator’s `throw` method). Otherwise, `__exit__()` simply calls `next`
    on the generator. Note that the generator must only yield once; a `RuntimeError`
    will be raised if the generator yields a second time. Let us convert our previous
    example into a generator-based context manager:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `contextlib` 模块的 `contextmanager` 装饰器对于这种情况非常有用。它接受一个 *生成器函数* 并将其转换为上下文管理器（如果你不记得生成器函数是如何工作的，你应该回顾一下
    *第5章* ，*列表推导式和生成器*）。装饰器将生成器包装在一个上下文管理器对象中。该对象的 `__enter__()` 方法启动生成器并返回生成器产生的任何内容。如果在
    `with` 语句的主体内部发生异常，`__exit__()` 方法将异常传递给生成器（使用生成器的 `throw` 方法）。否则，`__exit__()`
    简单地调用生成器的 `next` 方法。请注意，生成器只能产生一次；如果生成器第二次产生，将引发 `RuntimeError`。让我们将之前的示例转换为基于生成器的上下文管理器：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output from running this is similar to the previous example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出与之前的示例类似：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most context manager generators have a similar structure to `my_context_manager()`
    in this example. They have some setup code, followed by a `yield` inside a `try`
    statement. Here, we yielded an arbitrary object so that you can see that the same
    object is made available via the `as` clause of the `with` statement. It is also
    common to have just a bare `yield` with no value (in which case, `None` is yielded).
    This is equivalent to returning `None` from the `__enter__()` method of a context
    manager class. In such cases, the `as` clause of the `with` statement will typically
    be omitted.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于生成器的上下文管理器生成器在这个示例中具有类似的结构 `my_context_manager()`。它们有一些设置代码，然后是在 `try`
    语句内部的 `yield`。在这里，我们产生了一个任意对象，以便你可以看到通过 `with` 语句的 `as` 子句提供了相同的对象。通常，也会有一个不带值的裸
    `yield`（在这种情况下，产生 `None`）。这相当于从上下文管理器类的方法 `__enter__()` 中返回 `None`。在这种情况下，`with`
    语句的 `as` 子句通常会被省略。
- en: Another useful feature of generator-based context managers is that they can
    also be used as function decorators. This means that if the entire body of a function
    needs to be inside a `with` statement context, you could save a level of indentation
    and just decorate the function instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于生成器的上下文管理器的另一个有用特性是它们也可以用作函数装饰器。这意味着如果函数的全部主体需要位于 `with` 语句的上下文中，你可以节省一个缩进级别，只需装饰该函数即可。
- en: In addition to the `contextmanager` decorator, the `contextlib` module also
    contains many useful context managers. The documentation also provides several
    helpful examples of using and implementing context managers. Make sure you read
    it at [https://docs.python.org/3/library/contextlib.html](https://docs.python.org/3/library/contextlib.html)
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `contextmanager` 装饰器之外，`contextlib` 模块还包含许多有用的上下文管理器。文档还提供了使用和实现上下文管理器的几个有帮助的示例。确保你阅读了它：[https://docs.python.org/3/library/contextlib.html](https://docs.python.org/3/library/contextlib.html)。
- en: The examples we gave in this section do not do anything useful. They were created
    purely to show you how context managers work. Study these examples carefully until
    you are confident that you understand them completely. Then start writing your
    own context managers (both as classes and generators). Try to convert the `try`
    / `except` statement for breaking out of a nested loop that we saw earlier in
    this chapter into a context manager. The `measure` decorator that we wrote in
    *Chapter 6* , *OOP, Decorators, and Iterators* , is also a good candidate for
    converting to a context manager.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中给出的示例并没有做任何有用的事情。它们被创建纯粹是为了向您展示上下文管理器是如何工作的。仔细研究这些示例，直到您确信您完全理解了它们。然后开始编写您自己的上下文管理器（无论是作为类还是生成器）。尝试将本章前面看到的用于从嵌套循环中退出的
    `try` / `except` 语句转换为上下文管理器。我们在 *第 6 章* 中编写的 `measure` 装饰器也是一个很好的候选，可以转换为上下文管理器。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at exceptions and context managers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了异常和上下文管理器。
- en: We saw that exceptions are Python’s way of signaling that an error has occurred.
    We showed you how to catch exceptions so that your program does not fail when
    errors inevitably do happen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到异常是 Python 用来表示发生错误的方式。我们向您展示了如何捕获异常，以便在错误不可避免地发生时，您的程序不会失败。
- en: We also showed you how you can raise exceptions yourself when your own code
    detects an error, and that you can even define your own exception types. We saw
    exception groups and the new syntax that extends the `except` clause. We ended
    our exploration of exceptions by seeing that they are not only useful for signaling
    errors but can also be used as a flow-control mechanism.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向您展示了您如何在自己的代码检测到错误时引发异常，并且您可以定义自己的异常类型。我们看到了异常组和扩展 `except` 子句的新语法。我们通过看到异常不仅用于表示错误，还可以用作流程控制机制来结束对异常的探索。
- en: We ended the chapter with a brief overview of context managers. We saw how to
    use the `with` statement to enter a context defined by a context manager that
    performs cleanup operations when we exit the context. We also showed you how to
    create your own context managers, either as part of a class or by using a generator
    function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的结尾简要概述了上下文管理器。我们展示了如何使用 `with` 语句进入由上下文管理器定义的上下文，当退出上下文时，上下文管理器会执行清理操作。我们还向您展示了如何创建自己的上下文管理器，无论是作为类的一部分还是通过使用生成器函数。
- en: We will see more context managers in action in the next chapter, which focuses
    on files and data persistence.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到更多上下文管理器的实际应用，该章重点介绍文件和数据持久性。
- en: Join our community on Discord
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_7.xhtml)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_7.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
