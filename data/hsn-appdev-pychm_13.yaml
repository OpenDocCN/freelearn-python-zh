- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Dynamic Data Viewing with SciView and Jupyter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SciView和Jupyter进行动态数据查看
- en: 'In this chapter, we will continue our scientific voyage through the exploration
    of two vital features of PyCharm: **SciView** and integration with **Jupyter notebooks**.
    Both features give us integrated and usable interfaces, allowing us to view and
    work with data and variables in our science projects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续我们的科学之旅，通过探索PyCharm的两个重要功能：**SciView**和与**Jupyter笔记本**的集成。这两个功能都提供了集成和可用的界面，使我们能够查看和在我们的科学项目中处理数据和变量。
- en: We’ll begin by discussing the SciView panel, which was introduced tacitly in
    the last chapter. Here, we’ll be going into more depth and realism by working
    with NumPy arrays and pandas DataFrames.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论SciView面板开始，该面板在上章中隐晦地介绍。在这里，我们将通过使用NumPy数组和pandas DataFrame进行工作，更深入和现实地探讨。
- en: After that, we’ll evolve our workflow even further to include coverage of working
    with interactive Python computing tools such as Jupyter notebooks within the context
    of our scientific projects in PyCharm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将进一步发展我们的工作流程，包括在PyCharm科学项目上下文中处理交互式Python计算工具（如Jupyter笔记本）的覆盖。
- en: 'By the end of this chapter, you should have gained understanding in the following
    areas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对以下领域有所了解：
- en: Viewing and interacting with data in the SciView panel in PyCharm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm的SciView面板中查看和交互数据
- en: The integration of **Interactive Python** (**IPython**) within PyCharm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm中**交互式Python**（**IPython**）的集成
- en: Using Jupyter notebook support for interactive programming within a PyCharm
    scientific project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm科学项目中使用Jupyter笔记本支持进行交互式编程
- en: By the time you’re flipping the page to the next chapter, you’ll be armed with
    the knowledge needed to wield the two most important weapons in the war to tame
    your data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到你翻到下一章时，你将拥有掌握驯服数据战争中两个最重要的武器的知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Since we’ve switched to the topic of data science, I’ve switched my preferred
    Python distribution to Anaconda, which is a Python distribution tailored to data
    science workloads. You can find it, along with installation instructions for your
    operating system, at [https://anaconda.com](https://anaconda.com).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经转向数据科学主题，我将我的首选Python发行版切换到Anaconda，这是一个针对数据科学工作负载定制的Python发行版。你可以在[https://anaconda.com](https://anaconda.com)找到它，以及适用于你操作系统的安装说明。
- en: Likewise, instead of the usual `pip`, I’ll be leveraging `conda`, which is Anaconda’s
    package manager. It is installed alongside Anaconda.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我将使用`conda`而不是通常的`pip`，因为`conda`是Anaconda的包管理器。它与Anaconda一起安装。
- en: You’ll need an installed and working copy of PyCharm. Installation was covered
    in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*,
    in case you are jumping into the middle of the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个已安装并正常工作的PyCharm副本。如果你是在书的中间部分开始阅读，安装部分已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中介绍。
- en: You’ll also need this book’s sample source code from GitHub. We covered cloning
    the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and
    Configuration*. You’ll find this chapter’s code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从GitHub获取这本书的示例源代码。我们已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中介绍了如何克隆代码。你可以在这个章节的代码中找到[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13)。
- en: Data viewing made easy with PyCharm’s SciView panel
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyCharm的SciView面板轻松查看数据
- en: We took a 10,000-foot view of the SciView panel in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298),
    so we know what’s coming. We know SciView is a panel that allows us to visualize
    our data graphically, alongside a second panel that allows us easy and integrated
    access to documentation for the more complex data science libraries at play in
    a typical scientific project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[*第12章*](B19644_12.xhtml#_idTextAnchor298)中从10,000英尺的高度概述了SciView面板，因此我们知道接下来会发生什么。我们知道SciView是一个面板，允许我们以图形方式可视化我们的数据，同时还有一个面板，允许我们轻松且集成地访问典型科学项目中使用的更复杂的数据科学库的文档。
- en: 'In order to see this magic in action, we’re going to revisit some code we wrote
    back in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), with a small enhancement.
    Rather than having you go back into the code for [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298),
    I’ve copied the project into the [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318)
    folder in the repository so everything is together. You can find it in the `chapter-13/sci_view_panel`
    project within the `main.py` file. Don’t forget you’ll need to install the requirements
    within the `requirements.txt` file in a virtual environment in order to use the
    sample project. If you need a refresher on how to do this, refer back to [*Chapter
    3*](B19644_03.xhtml#_idTextAnchor052):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个魔法的效果，我们将回顾我们在[*第12章*](B19644_12.xhtml#_idTextAnchor298)中编写的某些代码，并进行一些小的改进。而不是让你回到[*第12章*](B19644_12.xhtml#_idTextAnchor298)的代码中，我已经将项目复制到存储库中的[*第13章*](B19644_13.xhtml#_idTextAnchor318)文件夹中，以便所有内容都在一起。你可以在`chapter-13/sci_view_panel`项目中的`main.py`文件中找到它。别忘了你需要在虚拟环境中安装`requirements.txt`文件中的要求才能使用示例项目。如果你需要复习如何做这件事，请参阅[*第3章*](B19644_03.xhtml#_idTextAnchor052)。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ll recognize what this does from the last chapter. The code generates two
    sample sets of data and then plots the results as a histogram. The difference
    is that we’ve added `for _ in range(5)`. It’s the same code; we’re simply running
    it five times in succession, which will generate five different histograms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上一章中识别出这个功能。代码生成两组样本数据，然后以直方图的形式绘制结果。区别在于我们添加了`for _ in range(5)`。这是相同的代码；我们只是连续运行了五次，这将生成五个不同的直方图。
- en: Viewing and working with plots
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看和使用图表
- en: For this example, you should take advantage of the ability to run your code
    in the console. The setting for this is probably already ticked, but you can double-check
    in the default run configuration as shown in *Figure 13**.1*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你应该利用在控制台中运行代码的能力。这个设置可能已经勾选了，但你可以在默认运行配置中再次检查，如图*图13.1*所示。
- en: '![Figure 13.1: The pointed-to setting indicates this code will run in the console
    window, which is frequently used in scientific projects](img/B19644_13_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1：指向的设置表示此代码将在控制窗口中运行，这在科学项目中经常使用](img/B19644_13_001.jpg)'
- en: 'Figure 13.1: The pointed-to setting indicates this code will run in the console
    window, which is frequently used in scientific projects'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：指向的设置表示此代码将在控制窗口中运行，这在科学项目中经常使用
- en: You saw this plot in the graph in the previous chapter, but take a look at the
    results for this run in *Figure 13**.2*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一章的图表中看到了这个图表，但看看这个运行的结果在*图13.2*中。
- en: '![Figure 13.2: The SciView window shows us the latest plot but also allows
    us to pick the plots from the other runs](img/B19644_13_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：SciView窗口显示最新的图表，同时也允许我们选择其他运行中的图表](img/B19644_13_002.jpg)'
- en: 'Figure 13.2: The SciView window shows us the latest plot but also allows us
    to pick the plots from the other runs'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：SciView窗口显示最新的图表，同时也允许我们选择其他运行中的图表
- en: 'You can already see a difference: there are five plots this time. Clicking
    each plot will change the histogram that changes in the viewer. This is an improvement
    over normal Python runs since the plot view would normally block execution while
    it displayed the histogram. You can normally only view one at a time, and the
    next is only generated when you hit the *Q* key to quit the current plot.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到区别了：这次有五个图表。点击每个图表将改变在查看器中变化的直方图。这比正常的Python运行有所改进，因为通常在显示直方图时，图表视图会阻塞执行。你通常只能一次查看一个，下一个只有在按*Q*键退出当前图表时才会生成。
- en: Instead of the default functionality, PyCharm grabbed all your plots to save
    you from having to individually export each image by hand. This is a huge time
    saver! You also have the option to zoom in and out using the toolbar at the top
    of the panel, remove the plot from view using the **X** button to the right of
    its icon, save the plot to an image file, or remove all the plots from view by
    right-clicking on the plot icon, as shown in *Figure 13**.3*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认功能不同，PyCharm抓取了所有图表以节省你手动逐个导出每个图像的时间。这是一个巨大的时间节省！你还可以使用面板顶部的工具栏进行缩放和缩小，使用其图标右侧的**X**按钮将其从视图中移除，将图表保存到图像文件，或者通过在图表图标上右键单击来移除所有图表，如图*图13.3*所示。
- en: '![Figure 13.3: PyCharm gives you many options for working with plots](img/B19644_13_003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：PyCharm为你提供了许多处理图表的选项](img/B19644_13_003.jpg)'
- en: 'Figure 13.3: PyCharm gives you many options for working with plots'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：PyCharm为你提供了许多处理图表的选项
- en: In addition to the ability to save the graphs that interest you, your viewer
    has some viewing options, such as the ability to zoom in, which is indicated by
    the arrow in the preceding figure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够保存您感兴趣的数据图之外，您的查看器还有一些查看选项，例如缩放功能，如前图中的箭头所示。
- en: Heatmaps and correlational data
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热图和相关性数据
- en: 'PyCharm is able to color heatmap plots to help you easily spot correlations
    within a correlation matrix. To see this, let’s generate some data that will have
    some data points that are correlated and some that are not. You’ll find a file
    in the chapter source called `correlation_heatmap.py`. The substance of the code
    is this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 能够将热图图例着色，以帮助您轻松地在一个相关性矩阵中找到相关性。为了看到这一点，让我们生成一些数据，其中将有一些相关数据点，也有一些不相关。您将在本章源文件中找到一个名为
    `correlation_heatmap.py` 的文件。代码的实质如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the code contains cell separators delineated by `#%%` characters.
    We covered the special meaning of these characters to PyCharm in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码中包含由 `#%%` 字符分隔的单元格分隔符。我们在 [*第 12 章*](B19644_12.xhtml#_idTextAnchor298)
    中介绍了这些字符在 PyCharm 中的特殊含义。
- en: In this program, we are creating a `x`, `y`, and `z`) that are randomly generated.
    We’re adjusting these random numbers between `x`, `y`, and `z` so that there will
    be some level of correlation between them. Then, we compute the correlation matrix
    of this dataset using the `corr()` method. Finally, we display this correlation
    matrix as a heatmap using the `matshow()` method from Matplotlib.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了一个 `x`、`y` 和 `z`（）的随机生成。我们调整这些随机数在 `x`、`y` 和 `z` 之间，以便它们之间将存在某种程度的相关性。然后，我们使用
    `corr()` 方法计算这个数据集的相关矩阵。最后，我们使用 Matplotlib 的 `matshow()` 方法将这个相关性矩阵显示为热图。
- en: On the theoretical side, a correlation matrix tells us how much an attribute
    in each dataset is correlated to another. A higher value means a higher correlation
    between a pair of attributes. Generally, knowing which attributes are highly correlated
    to each other will offer valuable insights into the dataset of a data science
    project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论方面，一个相关性矩阵告诉我们每个数据集中一个属性与另一个属性的相关程度。数值越高，表示一对属性之间的相关性越高。通常，了解哪些属性彼此高度相关将为数据科学项目的数据集提供有价值的见解。
- en: To demonstrate this point, we generate the `y` attribute to be roughly two times
    the size of the `x` attribute, creating a correlation between these two attributes.
    The `z` attribute, on the other hand, is generated randomly and independently
    from `x` and `y`, so there should not be a high correlation between `z` and either
    of the other attributes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们生成 `y` 属性的大小大约是 `x` 属性的两倍，从而在这两个属性之间创建相关性。另一方面，`z` 属性是独立于 `x` 和 `y`
    随机生成的，因此 `z` 与其他任何属性之间不应有高度的相关性。
- en: The project should have a run configuration called `correlation`. The settings
    for the run configuration are shown in *Figure 13**.4*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 项目应该有一个名为 `correlation` 的运行配置。运行配置的设置如图 *13.4* 所示。
- en: '![Figure 13.4: This is the run configuration for the correlation_heatmap.py
    file](img/B19644_13_004.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4：这是 correlation_heatmap.py 文件的运行配置](img/B19644_13_004.jpg)'
- en: 'Figure 13.4: This is the run configuration for the correlation_heatmap.py file'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：这是 correlation_heatmap.py 文件的运行配置
- en: Remember, it is important that we check the **Run with Python Console** checkbox.
    Go ahead and run the file and view the plot result. Mine is in *Figure 13**.5*.
    Since the data is random, yours may appear differently than mine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，检查 **使用 Python 控制台运行** 复选框非常重要。继续运行文件并查看绘图结果。我的结果在 *图 13.5* 中。由于数据是随机的，您的结果可能与我的不同。
- en: '![Figure 13.5: Correlational heatmaps are rendered using colors to indicate
    the level of correlation within the correlational matrix](img/B19644_13_005.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5：相关性热图使用颜色来表示相关性矩阵中相关性的程度](img/B19644_13_005.jpg)'
- en: 'Figure 13.5: Correlational heatmaps are rendered using colors to indicate the
    level of correlation within the correlational matrix'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：相关性热图使用颜色来表示相关性矩阵中相关性的程度
- en: Since this book is printed in black and white, I’ve tried to do you a solid
    here by adding letters to indicate the colors. This isn’t a feature of the graph.
    The cells labeled **Y** are yellow. **G** is for green and **P** is for purple.
    The first and second attributes are highly correlated, so the color in the corresponding
    cells in the correlation matrix (row 1 column 2 and row 2 column 1) is bright
    (yellow or green, each of similar brightness). The correlation between the third
    attribute with the other two is low, indicated by a dark purple color. Naturally,
    each attribute is perfectly correlated with itself, hence the bright yellow or
    green color in the diagonal cells.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是黑白印刷的，我尝试在这里为你做点好事，通过添加字母来指示颜色。这不是图表的一个特性。标记为**Y**的单元格是黄色。**G**代表绿色，**P**代表紫色。第一和第二个属性高度相关，因此相关矩阵中相应单元格（第1行第2列和第2行第1列）的颜色明亮（黄色或绿色，亮度相似）。第三个属性与其他两个属性的相关性较低，用深紫色表示。自然地，每个属性与其自身完全相关，因此对角线单元格中的颜色是明亮的黄色或绿色。
- en: The visual ramifications here are very helpful. When working with correlation
    matrices, we can instantly see the relationships between our variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的视觉影响非常有帮助。当处理相关矩阵时，我们可以立即看到变量之间的关系。
- en: The **Plots** tab in SciView gives us a lot of great tools we can use to view
    and manage plots in our data science projects. Note, too, that there are two tabs
    shown in *Figure 13**.2* (circled) at the top of the SciView panel. We’ll talk
    about the **Data** tab next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SciView中的**图表**选项卡为我们提供了许多我们可以在数据科学项目中查看和管理图表的强大工具。注意，在SciView面板顶部也显示了两个标签页，如图13.2*（圆圈所示）*。接下来，我们将讨论**数据**选项卡。
- en: Viewing and working with data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看和使用数据
- en: When you click on the **Data** tab, you might be a little underwhelmed. As you
    can see in *Figure 13**.6*, the real action is further down in the debugger window.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**数据**选项卡时，你可能会感到有些失望。如图13.6*所示，真正的操作在调试窗口的下方。
- en: '![Figure 13.6: Nothing shows up in the Data tab until you select one of the
    sample sets to view as an array](img/B19644_13_006.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6：在数据选项卡中，直到你选择一个样本集以数组形式查看之前，都不会显示任何内容](img/B19644_13_006.jpg)'
- en: 'Figure 13.6: Nothing shows up in the Data tab until you select one of the sample
    sets to view as an array'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：在数据选项卡中，直到你选择一个样本集以数组形式查看之前，都不会显示任何内容
- en: Shift your attention to the `N`, this panel is sufficient. However, if you are
    using NumPy arrays, as we are, viewing the array in the context of a normal debugger
    window like this one is problematic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的注意力转向`N`，这个面板就足够了。然而，如果你像我们一样使用NumPy数组，在像这样的正常调试窗口中查看数组是有问题的。
- en: If you click on the **View as Array** link, which can also be activated by right-clicking
    the variable, you can see a spreadsheet-like table in the **Data** panel. Check
    out *Figure 13**.7*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**以数组形式查看**链接，也可以通过右键单击变量激活，你可以在**数据**面板中看到一个类似电子表格的表格。查看图13.7*。
- en: '![Figure 13.7: Having selected the X variable in the lower panel, the Data
    tab now displays the elements of the NumPy array within X](img/B19644_13_007.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7：在下方面板中选择X变量后，数据选项卡现在显示X中的NumPy数组元素](img/B19644_13_007.jpg)'
- en: 'Figure 13.7: Having selected the X variable in the lower panel, the Data tab
    now displays the elements of the NumPy array within X'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：在下方面板中选择X变量后，数据选项卡现在显示X中的NumPy数组元素
- en: As you can see, the `X`, and so I see `X` displayed as a long row of colored
    data. I can scroll to the right and inspect all 100 elements. Cells with high
    values are filled with warmer colors, while the ones with low values are filled
    with cooler colors. This provides you with contrast so you can visually detect
    differences between values without squinting at the decimal place.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`X`，因此我看到`X`以一长串彩色数据的形式显示。我可以向右滚动并检查所有100个元素。高值单元格填充了较暖的颜色，而低值单元格填充了较冷的颜色。这为你提供了对比度，你可以通过视觉检测值之间的差异，而无需眯着眼睛看小数点。
- en: The leftmost arrow in *Figure 13**.7* shows you that `X` in the textbox above
    relates to `X` in the window below. You can change the value in the textbox to
    `Y`, or any other valid variable name present in the lower console, and see the
    data represented more graphically above. The key here is the word *valid*. The
    `N` variable will display an error in the **Data** tab.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7中最左侧的箭头显示，上方的文本框中的`X`与下方的窗口中的`X`相关。你可以将文本框中的值更改为`Y`，或任何在下方控制台中的有效变量名，并看到上方更图形化的数据表示。这里的关键词是*有效*。`N`变量将在**数据**选项卡中显示错误。
- en: To the right of the textbox is the formatter. This allows you to specify how
    the numbers in the **Data** tab appear. The formatting string uses the same format
    as normal Python string formatting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文本框的右侧是格式化工具。这允许你指定**数据**标签页中数字的显示方式。格式化字符串使用与正常Python字符串格式化相同的格式。
- en: When you select multiple variables in the console view, each variable will be
    displayed in its own tab as shown in *Figure 13**.8*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在控制台视图中选择多个变量时，每个变量都会在自己的标签页中显示，如图*13.8*所示。
- en: '![Figure 13.8: Picking multiple variables in the console will open a tab for
    each variable in the Data tab](img/B19644_13_008.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8：在控制台中选取多个变量将在数据标签页中为每个变量打开一个标签页](img/B19644_13_008.jpg)'
- en: 'Figure 13.8: Picking multiple variables in the console will open a tab for
    each variable in the Data tab'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：在控制台中选取多个变量将在数据标签页中为每个变量打开一个标签页
- en: Just remember, this only works for NumPy arrays and pandas DataFrames. This
    data is a little boring since there’s just one row. Let’s try something a little
    spicier, so we can see more of the features in the **Data** tab.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，这仅适用于NumPy数组和pandas DataFrame。由于只有一行，所以这些数据有点无聊。让我们尝试一些更有趣的东西，这样我们就能在**数据**标签页中看到更多功能。
- en: 'In the chapter code, you’ll find a file called `meteor.py` that only has two
    lines in it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节代码中，你会找到一个名为`meteor.py`的文件，里面只有两行：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This data comes from the **National Aeronautical and Space Administration**
    (**NASA**) in the United States. You’ll find it, along with thousands of other
    freely available datasets, at [https://data.gov](https://data.gov), all courtesy
    of me personally, since I pay a lot in taxes. Sure, others helped, but at least
    once per year, it feels like it is all up to me.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据来自美国**国家航空航天局**（**NASA**）。你可以在[https://data.gov](https://data.gov)找到它，以及成千上万的免费数据集，这都是我个人的功劳，因为我交了很多税。当然，其他人也帮忙了，但至少每年一次，感觉这一切都是我的责任。
- en: The data file contains NASA’s data on meteorite landings. Specifics can be found
    at [https://catalog.data.gov/dataset/meteorite-landings](https://catalog.data.gov/dataset/meteorite-landings).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件包含NASA关于陨石降落的资料。具体信息可以在[https://catalog.data.gov/dataset/meteorite-landings](https://catalog.data.gov/dataset/meteorite-landings)找到。
- en: There should be a run configuration for `meteor_data.py` in the project from
    the repository, but just in case, my settings are in *Figure 13**.9*. If you need
    a refresher on run configurations, we covered this topic in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库的项目中，应该有一个名为`meteor_data.py`的运行配置，但以防万一，我的设置在*图13.9*中。如果你需要关于运行配置的复习，我们已经在[*第3章*](B19644_03.xhtml#_idTextAnchor052)中讨论了这个主题。
- en: '![Figure 13.9: This is the run configuration settings dialog for the meteor.py
    file. Be sure that Run with Python Console is checked](img/B19644_13_009.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9：这是流星.py文件的运行配置设置对话框。请确保已选中“使用Python控制台运行”](img/B19644_13_009.jpg)'
- en: 'Figure 13.9: This is the run configuration settings dialog for the meteor.py
    file. Be sure that Run with Python Console is checked'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：这是流星.py文件的运行配置设置对话框。请确保已选中“使用Python控制台运行”
- en: As before, the key here is to make sure the file runs in **Python Console**
    so you get the panel view needed for SciView. Go ahead and run the file. You can
    see the result of my run in *Figure 13**.10*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，关键是要确保文件在**Python控制台**中运行，这样你就能得到SciView所需的面板视图。现在运行文件。你可以在*图13.10*中看到我运行的结果。
- en: '![Figure 13.10: My run of the meteor data has to be squished and stretched
    so you can see everything](img/B19644_13_010.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10：我的流星数据运行需要被压缩和拉伸，这样你才能看到所有内容](img/B19644_13_010.jpg)'
- en: 'Figure 13.10: My run of the meteor data has to be squished and stretched so
    you can see everything'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：我的流星数据运行需要被压缩和拉伸，这样你才能看到所有内容
- en: I had to seriously drag panels around to get it all to fit in the screenshot.
    Note that, this time, the button indicated by the arrow says **View as DataFrame**
    since this time we used pandas instead of NumPy. I’ve clicked it and the **Data**
    tab has loaded the DataFrame for viewing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不认真地拖动面板，才能让所有内容都适合截图。注意，这次，箭头所指的按钮上写着**以DataFrame查看**，因为我们这次使用的是pandas而不是NumPy。我点击了它，**数据**标签页已经加载了DataFrame以供查看。
- en: Filtering in the Data tab
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据标签页中进行过滤
- en: The meteor dataset is a little more realistic. It contains a lot of values and
    it might make sense to filter on some of the fields. PyCharm gives you the ability
    to filter the data appearing in the data tab using either a wildcard or an expression.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 流星数据集更接近现实。它包含很多值，并且可能对某些字段进行过滤是有意义的。PyCharm允许你使用通配符或表达式来过滤数据标签页中显示的数据。
- en: Filtering with a wildcard
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通配符进行过滤
- en: In *Figure 13**.11*, you can see I am hovering over the `name` column in the
    **Data** tab.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.11*中，你可以看到我在**数据**选项卡上悬停在`name`列上。
- en: '![Figure 13.11: Hovering over a column reveals a filter icon, which resembles
    a funnel](img/B19644_13_011.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11：将鼠标悬停在列上会显示一个过滤器图标，它类似于漏斗](img/B19644_13_011.jpg)'
- en: 'Figure 13.11: Hovering over a column reveals a filter icon, which resembles
    a funnel'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：将鼠标悬停在列上会显示一个过滤器图标，它类似于漏斗
- en: When I do this, a filter icon appears. Click that icon to bring up your filtering
    options as seen in *Figure 13**.12*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我这样做时，会出现一个过滤器图标。点击该图标即可显示你的过滤选项，如*图13.12*所示。
- en: '![Figure 13.12: You can filter by expression or by substring (wildcard)](img/B19644_13_012.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12：你可以通过表达式或子串（通配符）进行过滤](img/B19644_13_012.jpg)'
- en: 'Figure 13.12: You can filter by expression or by substring (wildcard)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：你可以通过表达式或子串（通配符）进行过滤
- en: Click on the `Bal`. You can see mine in *Figure 13**.13*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`Bal`。你可以在*图13.13*中看到我的。
- en: '![Figure 13.13: We’re filtering the name column to show all names with the
    characters Bal somewhere in the name](img/B19644_13_013.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13.13：我们正在过滤名称列，以显示所有名称中包含字符Bal的名称](img/B19644_13_013.jpg)'
- en: 'Figure 13.13: We’re filtering the name column to show all names with the characters
    Bal somewhere in the name'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：我们正在过滤名称列，以显示所有名称中包含字符Bal的名称
- en: Note that the trashcan icon lets you remove the filter. While the substring
    filter can be useful, the expression filter is far more powerful and precise.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，垃圾桶图标允许你移除过滤器。虽然子串过滤器可能很有用，但表达式过滤器更强大、更精确。
- en: Filtering with expressions
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用表达式进行过滤
- en: Using expressions, you can be a little more selective. Meteors are pretty cool,
    but nobody is impressed by a tiny pebble. For example, let’s filter meteors larger
    than 10kg in *Figure 13**.14*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式，你可以有更多的选择性。流星很酷，但没有人会对一块小石子印象深刻。例如，让我们在*图13.14*中过滤掉大于10kg的流星。14*。
- en: '![Figure 13.14: Filtering on the mass column where x (the value in the column)
    is greater than 10,000](img/B19644_13_014.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14：在质量列上过滤，其中x（列中的值）大于10,000](img/B19644_13_014.jpg)'
- en: 'Figure 13.14: Filtering on the mass column where x (the value in the column)
    is greater than 10,000'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：在质量列上过滤，其中x（列中的值）大于10,000
- en: There are quite a few! Now let’s filter to more recent strikes by filtering
    to only those occurring from the year 2010 onward. Mine is in *Figure 13**.15*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多！现在让我们通过过滤只显示从2010年开始发生的更近期的违规事件。我的在*图13.15*中。
- en: '![Figure 13.15: Limit data to just meteor strikes during and after 2010](img/B19644_13_015.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15：限制数据仅限于2010年和之后的流星撞击](img/B19644_13_015.jpg)'
- en: 'Figure 13.15: Limit data to just meteor strikes during and after 2010'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：限制数据仅限于2010年和之后的流星撞击
- en: Thankfully, there are not as many, and the data ends with only one strike in
    2013\. As coincidence would have it, that’s the last year I paid my income taxes
    on time. I told you it was all me.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，它们并不多，数据在2013年结束时只有一次违规。碰巧的是，那是我最后一次按时缴纳所得税的年份。我告诉你，这都是我自己的事。
- en: Dear Internal Revenue Service
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的国内税务局
- en: That last line is what we in the writing biz call “a joke.” I know this is a
    foreign concept to you all, but trust me, everybody else laughed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后一行就是我们写作界所说的“笑话”。我知道这对你们所有人来说都是一个外国概念，但请相信我，其他人都在笑。
- en: I am so getting audited.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我肯定会被审计。
- en: Anyway, another thing we can see through our filtering experiment is there is
    missing data in the `reclat`, `reclong`, and `GeoLocation` fields. These were
    no doubt recorded in Area 51 where geolocation data is illegal. Nevertheless,
    this can be a quick way to check your data for anomalies as part of creating a
    data pipeline, which we’ll be covering in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，通过我们的过滤实验，我们还可以看到`reclat`、`reclong`和`GeoLocation`字段中存在缺失数据。毫无疑问，这些数据是在地理定位数据非法的51区记录的。尽管如此，这可以是一个快速检查数据异常的方法，作为创建数据管道的一部分，我们将在下一章中介绍。
- en: Exporting to files or new tabs
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出到文件或新标签页
- en: Take a look at the top of the **Data** tab in *Figure 13**.16*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*图13.16*中**数据**选项卡的顶部。
- en: '![Figure 13.16: You can export your data or pop it out into a new tab in the
    editor window](img/B19644_13_016.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16：你可以将数据导出到文件或在新标签页中弹出](img/B19644_13_016.jpg)'
- en: 'Figure 13.16: You can export your data or pop it out into a new tab in the
    editor window'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16：你可以将数据导出到文件或在新标签页中弹出
- en: The `.csv` or `.tsv` file. This is pretty straightforward, so I think you can
    live without a screenshot. You can also pop the contents of your data tab in SciView
    into the regular tab in your editor view. I’ve done this in *Figure 13**.17*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`.csv` 或 `.tsv` 文件。这很简单，所以我认为你可以没有截图也能过得去。你还可以将 SciView 中的数据标签内容弹出到编辑器视图中的常规标签中。我在
    *图 13.17* 中做了这个操作。'
- en: '![Figure 13.17: I’ve popped the SciView Data tab contents into a tab in the
    main editor window](img/B19644_13_017.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.17：我已经将 SciView 数据标签的内容弹出到主编辑窗口的标签中](img/B19644_13_017.jpg)'
- en: 'Figure 13.17: I’ve popped the SciView Data tab contents into a tab in the main
    editor window'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17：我已经将 SciView 数据标签的内容弹出到主编辑窗口的一个标签中
- en: All totaled, the **Data** tab in SciView contains a lot of useful features for
    performing explorations on your data, whether it be raw, as with the meteor data,
    or generated through calculation, as with our earlier random set. When you combine
    this graphical way to view input and output data with PyCharm’s cell mode described
    in the last chapter, you start to see the power of the data science tools in PyCharm.
    They are just a few simple panels, but there is so much we can do with them!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，SciView 中的 **数据** 标签包含了许多有用的功能，用于对数据进行探索，无论是原始数据，如气象数据，还是通过计算生成，如我们之前的随机集。当你将这种图形方式查看输入和输出数据与上一章中描述的
    PyCharm 的单元格模式结合起来时，你开始看到 PyCharm 中数据科学工具的力量。它们只是几个简单的面板，但我们可以用它们做很多事情！
- en: Understanding IPython and magic commands
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 IPython 和魔法命令
- en: '**IPython** is an enhanced interactive shell for the Python programming language.
    It provides a more feature-rich and user-friendly environment compared to the
    default Python interactive interpreter. IPython was developed to make interactive
    computing and data analysis tasks more convenient and efficient.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython** 是 Python 编程语言的增强型交互式外壳。它提供了一个比默认 Python 交互式解释器更丰富、更用户友好的环境。IPython
    旨在使交互式计算和数据分析任务更加方便和高效。'
- en: When working with IPython beyond the confines of PyCharm, you’ll find some features
    you won’t find in any standard console or REPL environment. The shell experienced
    is heavily enhanced to support features you’d expect within PyCharm, such as tab
    completion, syntax highlighting, and history navigation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 PyCharm 之外使用 IPython 时，你会发现一些你不会在任何标准控制台或 REPL 环境中找到的功能。所提供的 shell 经验被大大增强，以支持你期望在
    PyCharm 中找到的功能，例如自动完成、语法高亮和历史导航。
- en: The tool allows for an array of rich display options. Imagine a command-line
    interface that includes the ability to work with images, videos, audio, and interactive
    widgets directly within the interactive environment. Obviously, you can execute
    Python code in the form of snippets, expressions, or entire scripts, and you do
    all of this in an interactive fashion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提供了一系列丰富的显示选项。想象一下，一个命令行界面，它可以直接在交互式环境中处理图像、视频、音频和交互式小部件。显然，你可以以片段、表达式或整个脚本的形式执行
    Python 代码，而你所有这些操作都是交互式的。
- en: IPython also makes it easier to work in a distributed compute environment. As
    you may know, threaded computing is effectively disabled in most mainline Python
    interpreters owing to the **Global Interpreter Lock** (**GIL**). The GIL is a
    mechanism in the CPython interpreter, the most widely used implementation of Python.
    The GIL is a mutex (or a lock) that only allows one thread to execute in the interpreter
    at a time, even on multi-core systems. This means that in a multithreaded Python
    program, only one thread can execute Python bytecode at any given moment, regardless
    of how many CPU cores are available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 还使得在分布式计算环境中工作变得更加容易。正如你可能知道的，由于 **全局解释器锁**（**GIL**），线程计算在大多数主流 Python
    解释器中被有效禁用。GIL 是 CPython 解释器中的一个机制，它是 Python 最广泛使用的实现。GIL 是一个互斥锁（或锁），一次只允许一个线程在解释器中执行，即使在多核系统上也是如此。这意味着在多线程
    Python 程序中，在任何给定时刻，只有一个线程可以执行 Python 字节码，无论有多少 CPU 核心可用。
- en: The GIL was introduced to simplify memory management and avoid potential conflicts
    that could arise from multiple threads accessing and modifying Python objects
    concurrently. While the GIL ensures that Python memory management remains simpler
    and safer, it also has implications for multithreaded programs insofar as Python
    programs tend to struggle to actually utilize all the compute resources available
    on a system that supports multiple threads.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GIL 的引入是为了简化内存管理，并避免由于多个线程同时访问和修改 Python 对象而可能出现的潜在冲突。虽然 GIL 确保了 Python 内存管理保持简单和安全，但它对多线程程序也有影响，因为
    Python 程序往往难以真正利用支持多线程的系统上的所有计算资源。
- en: While IPython doesn’t have any secret sauce that defeats the GIL limitation,
    it does provide a module called `ipython.parallel` that makes it easy to work
    with parallel compute resources. You can create clusters of IPython engines that
    can run code in parallel across multiple processes or even multiple machines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IPython 没有任何可以克服 GIL 限制的秘密配方，但它确实提供了一个名为 `ipython.parallel` 的模块，这使得与并行计算资源一起工作变得容易。你可以创建
    IPython 引擎的集群，这些集群可以在多个进程甚至多台机器上并行运行代码。
- en: IPython seems like something we should be very interested in, given that it
    is obviously a powerful tool that more fully enables a mode of enriched stepwise
    data interaction that is the modus operandi of modern data science workflows.
    The standing question then is, how can we leverage IPython within PyCharm?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它显然是一个强大的工具，能够更充分地实现现代数据科学工作流程中富步骤数据交互的模式，IPython 似乎是我们应该非常感兴趣的东西。那么，问题来了，我们如何在
    PyCharm 中利用 IPython？
- en: Installing and setting up IPython
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和设置 IPython
- en: Installing IPython is done like any other Python library. You can use `pip install
    ipython` from PyCharm’s terminal, or you can use the package management screen
    we’ve been working with since [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
    *Figure 13**.18* shows me about to install using the **Python Packages** panel
    in PyCharm.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 IPython 的方式与其他 Python 库类似。你可以从 PyCharm 的终端使用 `pip install ipython`，或者你可以使用我们从
    *第 3 章* ([*Chapter 3*](B19644_03.xhtml#_idTextAnchor052)) 开始使用的包管理屏幕。*图 13*.18*
    显示了我准备使用 PyCharm 的 **Python 包** 面板进行安装。
- en: '![Figure 13.18: I’ve searched for ipython in the Python Packages pane and I’m
    about to install it to my project using conda](img/B19644_13_018.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.18：我在 Python 包面板中搜索了 ipython，并准备使用 conda 将它安装到我的项目中](img/B19644_13_018.jpg)'
- en: 'Figure 13.18: I’ve searched for ipython in the Python Packages pane and I’m
    about to install it to my project using conda'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18：我在 Python 包面板中搜索了 ipython，并准备使用 conda 将它安装到我的项目中
- en: If you plan to work with IPython often, you might consider installing this one
    globally so it is available to all your projects. You’d do this by simply installing
    IPython outside the confines of a virtual environment using `pip`, `conda`, or
    whichever tool you prefer for package management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用 IPython，你可能会考虑全局安装它，以便它对所有项目都可用。你可以通过在虚拟环境之外使用 `pip`、`conda` 或你喜欢的任何包管理工具来安装
    IPython 来完成这项工作。
- en: Once IPython is available, PyCharm will use it owing to the default settings
    in the IDE’s **Build, Execution, Deployment** settings, as shown in *Figure 13**.19*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 IPython 可用，PyCharm 将根据 IDE 的 **构建、执行、部署** 设置中的默认设置使用它，如 *图 13*.19* 所示。
- en: '![Figure 13.19: By default, PyCharm will use IPython for its console if it
    is available](img/B19644_13_019.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.19：默认情况下，如果可用，PyCharm 将使用 IPython 作为其控制台](img/B19644_13_019.jpg)'
- en: 'Figure 13.19: By default, PyCharm will use IPython for its console if it is
    available'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.19：默认情况下，如果可用，PyCharm 将使用 IPython 作为其控制台
- en: We covered settings in great detail in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    so if you’ve skipped to this chapter and you’re not sure how to get to the settings,
    go review the earlier chapter. Once IPython is available in your project, you
    need to close or cycle any consoles that might be open. So far, we’ve run three
    programs that we intentionally set to run in the console, so you won’t see any
    change to those since they were running before we installed IPython. *Figure 13**.20*
    shows you what an IPython prompt looks like.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 *第 2 章* ([*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)) 中详细介绍了设置，所以如果你跳到了这一章并且不确定如何访问设置，请回顾前面的章节。一旦你的项目中可用
    IPython，你需要关闭或循环任何可能打开的控制台。到目前为止，我们已经运行了三个程序，我们故意将它们设置为在控制台中运行，所以你不会看到任何变化，因为它们在我们安装
    IPython 之前就已经在运行了。*图 13*.20* 显示了 IPython 提示符的外观。
- en: '![Figure 13.20: The IPython prompt appears after I close or restart my existing
    console](img/B19644_13_020.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.20：关闭或重启现有控制台后，IPython 提示符出现](img/B19644_13_020.jpg)'
- en: 'Figure 13.20: The IPython prompt appears after I close or restart my existing
    console'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20：关闭或重启现有控制台后，IPython 提示符出现
- en: In *Figure 13**.20*, I’ve drawn an arrow to remind you how to open the console,
    if it isn’t already open. If you don’t see that icon, try clicking the three-dot
    icon above the arrow. If you still can’t find it, review [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)
    where we talk about working with the console for the first time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13.20* 中，我画了一个箭头来提醒你如何打开控制台，如果它还没有打开。如果你看不到那个图标，尝试点击箭头上方的三个点图标。如果你仍然找不到它，请回顾
    [*第 2 章*](B19644_02.xhtml#_idTextAnchor028)，我们在那里讨论了第一次与控制台一起工作。
- en: As I mentioned, if you already have consoles open, they need to be restarted.
    I’ve circled the button for this in *Figure 13**.20*. When the console is restarted,
    you should see a different prompt beginning with the word `In`, in contrast to
    the normal prompt, which displayed `>>>` symbols. Following the word `In`, you’ll
    see some square brackets containing a number. In *Figure 13**.20*, it’s showing
    `2`. This number indicates the order of commands entered so far. If you look at
    the top of the new IPython console, you’ll see a few commands were entered automatically,
    which import the `sys` library, print out the Python version, and extend our path.
    That’s three commands, but remember we start at `0`. The next command you enter
    will be the fourth command and will be labeled as `3`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，如果你已经打开了控制台，它们需要被重启。我在 *图 13.20* 中画了一个圆圈来标记这个按钮。当控制台重启后，你应该会看到一个以单词 `In`
    开头的不同提示符，与显示 `>>>` 符号的正常提示符不同。在 `In` 之后，你会看到一些包含数字的方括号。在 *图 13.20* 中，它显示的是 `2`。这个数字表示迄今为止输入命令的顺序。如果你查看新的
    IPython 控制台顶部，你会看到一些命令被自动输入，这些命令导入 `sys` 库，打印出 Python 版本，并扩展我们的路径。这是三个命令，但请记住我们是从
    `0` 开始的。你输入的下一条命令将是第四条命令，并标记为 `3`。
- en: If PyCharm were a video game, installing IPython would be like unlocking the
    super gun, sword, or magic power you can use to vanquish your unwitting and utterly
    unprepared foes. If this is your first time, you probably can’t wait to explode
    some data zombies, so let’s take a look at IPython’s magic commands. Hyperbole
    aside, *magic commands* are literally what they are called!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PyCharm 是一款视频游戏，安装 IPython 就像是解锁超级枪、剑或魔法力量，你可以用它来击败那些毫无防备的对手。如果你是第一次使用，你可能迫不及待想要消灭一些数据僵尸，那么让我们来看看
    IPython 的魔法命令。抛开夸张的说法，*魔法命令*确实就是它们的名字！
- en: Introducing IPython magic commands
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 IPython 魔法命令
- en: In IPython, a `%` (for line magics) or `%%` (for cell magics) symbol and is
    used within an IPython session or Jupyter notebook cell. These magic commands
    provide shortcuts for performing various tasks, from running code with specific
    options to interacting with the environment or controlling IPython’s behavior.
    Magic commands are a convenient way to execute common operations without writing
    extensive code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 中，一个 `%`（用于行魔法）或 `%%`（用于单元格魔法）符号，在 IPython 会话或 Jupyter 笔记本单元格中使用。这些魔法命令提供了执行各种任务的快捷方式，从使用特定选项运行代码到与环境交互或控制
    IPython 的行为。魔法命令是执行常见操作而不必编写大量代码的便捷方式。
- en: 'There are two types of magic commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法命令有两种类型：
- en: '`%` symbol and are used on a single line. They typically take arguments and
    options to modify their behavior. For example, `%run script.py` can be used to
    run an external script within the IPython session.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%` 符号用于单行。它们通常接受参数和选项来修改其行为。例如，`%run script.py` 可以用来在 IPython 会话中运行外部脚本。'
- en: '`%%` and are used at the beginning of a cell. They allow you to affect the
    entire cell’s content. For example, `%%time` can be used to measure the execution
    time of the entire cell’s code.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%%` 和它们被用于单元格的开始处。它们允许你影响整个单元格的内容。例如，`%%time` 可以用来测量整个单元格代码的执行时间。'
- en: 'Here are a few common examples of magic commands you’ll use daily:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你每天会使用的常见魔法命令的例子：
- en: '`%run script.py`: Runs an external Python script in the IPython session.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%run script.py`：在 IPython 会话中运行外部 Python 脚本。'
- en: '`%timeit`: Measures the execution time of a Python statement or expression.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%timeit`：测量 Python 语句或表达式的执行时间。'
- en: '`%matplotlib inline`: Configures `matplotlib` to display plots directly in
    the notebook.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%matplotlib inline`：配置 `matplotlib` 以在笔记本中直接显示图表。'
- en: '`%%writefile filename.txt`: Writes the contents of a notebook cell to a file
    named `filename.txt`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%%writefile filename.txt`：将笔记本单元格的内容写入名为 `filename.txt` 的文件。'
- en: '`%load_ext extension_name`: Loads a specific IPython extension.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%load_ext extension_name`：加载特定的 IPython 扩展。'
- en: '`%%html`: Renders the content of a cell as HTML.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%%html`：将单元格的内容渲染为 HTML。'
- en: '`%reset`: Resets the namespace by removing all names defined by the user.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%reset`：通过删除用户定义的所有名称来重置命名空间。'
- en: '`object_name?`: Don’t take me literally on this one. You don’t type *object_name?*.
    Instead, you type the name of an object you’ve instantiated. Maybe we should just
    do this in just a moment, so you understand.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object_name?`：在这个问题上，不要字面理解。你不需要输入 *object_name?*。相反，你输入你实例化的对象的名字。也许我们稍后再做这个，这样你就能理解了。'
- en: By now, you’re starting to smell what we’re cooking up here. We’ve seen cell
    mode in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), but now, with IPython,
    there is a lot more we can do with a cell using these magic commands. Like any
    good magic spell from the movies, there is just enough cryptic but short syntax
    to learn, which adds to the mystique and makes you feel just a little more elite
    than your non-magic-using colleagues.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你开始闻到我们在这里煮的东西了。我们看到了 *第 12 章* 中的单元格模式（[*Chapter 12*](B19644_12.xhtml#_idTextAnchor298)），但现在，有了
    IPython，我们可以使用这些魔法命令对单元格做更多的事情。就像电影中的任何好魔法一样，有足够的神秘但简短的语法可以学习，这增加了神秘感，让你感觉比那些不使用魔法的同事更精英一些。
- en: Let’s try a few out, shall we?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试几个，好吗？
- en: In your IPython console, type `a = 1`. Now, let’s try the `object_name?` magic.
    You don’t type *object_name?*; instead, you type `a?`. The name of the object
    is `a` and you follow it with a question mark as if you were Canadian or Australian.
    Whatever object name you use, assuming it is valid, you’ll get back information
    about that object. You can see my result in *Figure 13**.21*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 IPython 控制台中，输入 `a = 1`。现在，让我们尝试 `object_name?` 魔法命令。你不需要输入 *object_name?*；相反，你输入
    `a?`。对象的名字是 `a`，你后面跟着一个问号，就像你是加拿大人或澳大利亚人一样。无论你使用什么对象名，假设它是有效的，你都会得到关于该对象的信息。你可以在
    *图 13**.21* 中看到我的结果。
- en: '![Figure 13.21: How’s it goin, a?](img/B19644_13_021.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.21：a 怎么样？](img/B19644_13_021.jpg)'
- en: 'Figure 13.21: How’s it goin, a?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21：a 怎么样？
- en: 'We’ve learned a lot about `a`, eh? Okay, eh, let’s try another one. Type `%precision
    4`. The result should be `''%.4f''`. This tells us we’ve set our session to four
    decimals of precision. Let’s test that by typing in this code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `a` 了解了很多，对吧？好吧，嗯，让我们再试一个。输入 `%precision 4`。结果应该是 `'%.4f'`。这告诉我们我们已经将我们的会话设置为四位小数的精度。让我们通过输入以下代码来测试一下：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lowercase `e` is a reference to `e` to 10 places is 2.7182818285\. We, though,
    are set for 4 decimal places of precision, so the result from IPython should show
    `2.7183`, as shown in *Figure 13**.22*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 小写 `e` 是对 `e` 到 10 位的参考，即 2.7182818285。然而，我们设置为四位小数的精度，所以 IPython 的结果应该显示 `2.7183`，如图
    *图 13**.22* 所示。
- en: '![Figure 13.22: Having set our precision to four decimal places, we can see
    the constant e is rendered properly](img/B19644_13_022.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.22：将精度设置为四位小数后，我们可以正确地看到常数 e 的表示](img/B19644_13_022.jpg)'
- en: 'Figure 13.22: Having set our precision to four decimal places, we can see the
    constant e is rendered properly'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22：将精度设置为四位小数后，我们可以正确地看到常数 e 的表示
- en: 'Let’s try one more. The `%%timeit` magic is very useful during the creation
    of algorithms. Algorithms are simply repeatable sets of instructions; however,
    in order to be useful, an algorithm needs to be efficient. Efficiency is judged
    by two vectors: time needed to complete and space required to work. For example,
    the **National Health System** (**NHS**) in England has devised an algorithm that
    matches organ donors to recipients based on a number of complicated factors. It
    is meant to match an organ to a donor in a way that minimizes risks of tissue
    rejection, among other factors. As you can imagine, this is a complicated algorithm
    that has to operate against a dataset containing thousands of registered donors
    and thousands of registered recipients. When an organ becomes available, it has
    a limited shelf life. If the matching algorithm takes too long to generate a match,
    the organ becomes unviable for transplant, and the algorithm is effectively useless.
    We covered profiling in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145), but this
    was really meant for software engineering workflows to help find bottlenecks in
    execution.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次。`%%timeit`魔法在创建算法时非常有用。算法只是可重复的指令集；然而，为了有用，算法需要高效。效率由两个向量判断：完成所需的时间和完成工作所需的空间。例如，英国的**国家卫生系统**（**NHS**）设计了一个算法，根据许多复杂因素将器官捐赠者与接受者匹配。它的目的是以最小化组织排斥风险等方式将器官与捐赠者匹配。正如你可以想象的那样，这是一个复杂的算法，必须在一个包含数千名注册捐赠者和数千名注册接受者的数据集上运行。当器官可用时，它有有限的保质期。如果匹配算法花费太长时间来生成匹配，器官将无法用于移植，该算法实际上就变得毫无用处。我们在[*第6章*](B19644_06.xhtml#_idTextAnchor145)中介绍了分析，但这实际上是为了帮助软件工程工作流程找到执行瓶颈。
- en: In data science, we’re operating outside the confines of a typical software
    project, so it makes sense to time individual steps to at least gain some insight
    into how a step of our calculations might scale. Even if our objective isn’t to
    create an algorithm, we still have to deal with practical limitations on time
    and compute space (such as memory and storage) in our regular exploratory work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学中，我们的操作超出了典型软件项目的限制，因此对单个步骤进行计时至少可以让我们对计算步骤可能如何扩展有所了解。即使我们的目标不是创建算法，我们仍然需要在常规的探索性工作中处理时间和计算空间（如内存和存储）的实际限制。
- en: The `%%timeit` magic then becomes an integral part of our work. Now that I’ve
    spent all this time building up a huge example, let’s try it out with something
    laughably trivial in *Figure 13**.23*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`%%timeit`魔法随后成为我们工作的一部分。现在我已经花了很多时间构建了一个巨大的示例，让我们用*图13**.23*中的可笑的琐事来试试。'
- en: "![Figure 13.23: We’re trying out %\uFEFF%timeit with a simple sort to find\
    \ the operation completes in around 318 ns](img/B19644_13_023.jpg)"
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: "![图13.23：我们尝试使用简单的排序来测试%\uFEFF%timeit，以找到操作大约在318纳秒内完成](img/B19644_13_023.jpg)"
- en: 'Figure 13.23: We’re trying out %%timeit with a simple sort to find the operation
    completes in around 318 ns'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23：我们尝试使用%%timeit进行简单的排序，以找到操作大约在318纳秒内完成
- en: This truly was a trivial task. Start by typing `%%timeit` in the IPython console.
    When you press *Enter*, it takes you to the next line. In the second line, we’re
    creating a list with the numbers 0 through 9 in reverse order. On the last line,
    we’re sorting them back into their normal order. This is super boring! Hit *Enter*
    on the last blank line to run the code. Look at what `%%timeit` did! It could
    have just started a clock, run the script, then stopped the clock and reported
    the delta. Instead, `%%timeit` ran this code over and over to gain a sample size
    where it can compute a mean and standard deviation. This gives us better and more
    accurate insight into how long this code will take to run. Naturally, different
    computers will perform differently. For me, it ran in 318 nanoseconds plus or
    minus 3.44 nanoseconds.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个琐事。首先在IPython控制台中输入`%%timeit`。当你按下*Enter*键时，它会带你到下一行。在第二行中，我们创建了一个包含0到9的数字的列表，顺序相反。在最后一行，我们将它们按正常顺序排序。这太无聊了！在最后一行空白处按*Enter*键来运行代码。看看`%%timeit`做了什么！它本可以只启动一个时钟，运行脚本，然后停止时钟并报告差值。相反，`%%timeit`反复运行此代码以获得一个样本大小，其中它可以计算平均值和标准差。这使我们能够更好地了解这段代码将需要多长时间运行。当然，不同的计算机性能会有所不同。对我来说，它运行了318纳秒加减3.44纳秒。
- en: 'Here, we have considered three of the most common magic commands in IPython.
    Of course, there are many other useful commands that you can take advantage of,
    which can be found in IPython’s official documentation: [https://ipython.readthedocs.io/en/stable/index.html](https://ipython.readthedocs.io/en/stable/index.html).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们考虑了IPython中最常见的三个魔术命令。当然，还有很多其他有用的命令可以利用，这些可以在IPython的官方文档中找到：[https://ipython.readthedocs.io/en/stable/index.html](https://ipython.readthedocs.io/en/stable/index.html)。
- en: With that said, the main purpose of IPython is not simply the ability to utilize
    convenient APIs to facilitate specific tasks such as variable inspection, formatting,
    or profiling—IPython actually uses those functionalities to power its underlying
    interactive characteristics. In the context of data science projects, IPython,
    when used in PyCharm, offers a great way for us to inspect and test small blocks
    of code before using them in a large program.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，IPython的主要目的并不仅仅是利用方便的API来简化特定任务，如变量检查、格式化或性能分析——IPython实际上使用这些功能来支持其底层的交互特性。在数据科学项目的背景下，当在PyCharm中使用时，IPython为我们提供了一个很好的方法来检查和测试在大型程序中使用之前的小块代码。
- en: With that, let’s move on to the next section, where we will consider the other
    notable support PyCharm offers for scientific computing—Jupyter notebooks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，让我们继续到下一节，我们将考虑PyCharm为科学计算提供的其他显著支持——Jupyter笔记本。
- en: Leveraging Jupyter notebooks
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Jupyter笔记本
- en: '**Jupyter notebooks** are arguably the most-used tool in Python scientific
    computing and data science projects. In this section, we will briefly discuss
    the basics of Jupyter notebooks as well as the reasons why they are a great tool
    for data analysis purposes. Then, we will consider the way PyCharm supports the
    usage of these notebooks.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jupyter笔记本**可以说是Python科学计算和数据科学项目中用得最多的工具。在本节中，我们将简要讨论Jupyter笔记本的基本知识以及为什么它们是数据分析的绝佳工具。然后，我们将考虑PyCharm如何支持这些笔记本的使用。'
- en: We will be working with the `jupyter_notebooks` project in the chapter source.
    Don’t forget you’ll need to install the requirements within the `requirements.txt`
    file in a virtual environment in order to use the sample project. If you need
    a refresher on how to do this, refer back to [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在章节源中与`jupyter_notebooks`项目合作。别忘了，你需要在一个虚拟环境中安装`requirements.txt`文件中的要求，以便使用示例项目。如果你需要复习如何做这件事，请参阅[*第3章*](B19644_03.xhtml#_idTextAnchor052)。
- en: 'Even though we will be writing code in Jupyter notebooks, it is beneficial
    to first consider a bare-bones program in a traditional Python script so that
    we can fully appreciate the advantages of using a notebook later on. Let’s look
    at the `main.py` file and see how we can work with it. We can see that this file
    contains the same program from the previous section, where we randomly generate
    a dataset of three attributes (`x`, `y`, and `z`) and consider their correlation
    matrix:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在Jupyter笔记本中编写代码，但首先考虑一个传统的Python脚本中的裸骨程序是有益的，这样我们才能充分欣赏使用笔记本的优势。让我们看看`main.py`文件，看看我们如何与之合作。我们可以看到这个文件包含与上一节相同的程序，其中我们随机生成一个包含三个属性（`x`、`y`和`z`）的数据集，并考虑它们的相关矩阵：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is roughly the same code we used earlier in this chapter when we wanted
    to expose the heatmap features in PyCharm when reviewing a correlational matrix.
    Here, we have added the last two lines, which are different. Instead of a heatmap,
    this time we’re drawing a scatter plot. I explained earlier that we have intentionally
    and artificially introduced correlation into our otherwise randomly generated
    data. Examine where we set `y` and you’ll see we multiplied the matrix from `x`
    by 2, then added some small numbers from another random sample generation. This
    will make `y` appear to be roughly, but not exactly, correlated to `x` allowing
    us to see a plausible, though contrived, correlation matrix. This proves out when
    we run the file. My result is shown in *Figure 13**.24*. Don’t forget that our
    data is random, so yours will not precisely match mine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们在本章早期想要在PyCharm中查看相关矩阵时使用过的相同代码。在这里，我们添加了最后两行，它们是不同的。这次我们不是绘制热图，而是绘制散点图。我之前解释过，我们故意并且人为地在我们随机生成数据中引入了相关性。检查我们设置`y`的地方，你会看到我们将`x`的矩阵乘以2，然后添加了一些来自另一个随机样本生成的小数。这将使`y`看起来大致但不是完全与`x`相关，从而让我们看到一个合理但人为的相关矩阵。当我们运行文件时，这得到了证明。我的结果是*图13**.24*所示。别忘了，我们的数据是随机的，所以你的数据不会精确匹配我的。
- en: '![Figure 13.24: This is the scatter plot produced by our code](img/B19644_13_024.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24：这是我们的代码生成的散点图](img/B19644_13_024.jpg)'
- en: 'Figure 13.24: This is the scatter plot produced by our code'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24：这是我们的代码生成的散点图
- en: Like I said, there’s nothing new or amazing here besides the change from a heatmap
    to a scattelot. We ran this as a point of comparison for our discussion of Jupyter
    notebooks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的一样，这里除了从热图到散点图的转变之外，没有什么是新的或惊人的。我们运行这个作为我们讨论Jupyter笔记本的比较点。
- en: Understanding Jupyter basics
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Jupyter基础知识
- en: Jupyter notebooks are built on the idea of iterative development. In any development
    effort regardless of what you are creating, breaking a large project into smaller
    pieces always yields rewards. Nobody at the Ford Motor Company just builds a car.
    They build millions of pieces that are later assembled into a car. Each piece
    can be designed, produced, tested, and inspected as individual pieces.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter笔记本建立在迭代开发的理念之上。在任何开发工作中，无论你正在创建什么，将大型项目分解成更小的部分总是会有回报。福特汽车公司的任何人都不只是建造一辆汽车。他们建造了数百万个零件，这些零件最终被组装成汽车。每个零件都可以单独设计、生产、测试和检查。
- en: Similarly, by separating a given program into individual sections that can be
    written and run independently from each other, programmers in general and data
    scientists specifically can work on the logic of their programs in an incremental
    way.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过将给定的程序分解成可以独立编写和运行的各个部分，程序员和特别是数据科学家可以以增量方式工作在程序的逻辑上。
- en: The idea of iterative development
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代开发的想法
- en: Most practitioners in the world of software development are used to the ideals
    behind agile methodologies. There are dozens of agile frameworks designed to help
    you manage software, or really, any project with the aim of creating some useful
    product. One thing they consistently have in common is the idea of iterative development.
    The development effort is broken down into smaller, simpler tasks called an iteration.
    At the end of each iteration, we should have some usable product. This is important!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上软件开发领域的多数从业者已经习惯了敏捷方法背后的理念。有数十个敏捷框架旨在帮助你管理软件，或者实际上，任何旨在创建有用产品的项目。它们一致共有的一个理念就是迭代开发。开发工作被分解成更小、更简单的任务，称为迭代。在每次迭代的结束时，我们应该有一些可用的产品。这很重要！
- en: You might think about making a car, but think truly about the research and development
    that went into the first cars. Our main concern at that time was to produce a
    vehicle to take us from point A to some distant point B in a manner that was faster
    and more efficient than using a domesticated animal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑制造一辆汽车，但真正思考一下最初汽车的研究和开发过程。当时我们主要关注的是制造一种车辆，它能以比使用驯养动物更快、更有效的方式，将我们从A点带到遥远的B点。
- en: We already know about the wheel, so let’s entertain at a somewhat comical level
    the process your average software developer might use if they were going to create
    the world’s first automobile. Remember, each iteration must produce some usable
    means of traveling from place to place. Our development team might start with
    a skateboard. This is something simple we could make in a short iteration. The
    next iteration might produce a scooter, the next a bicycle, the next might be
    a powered tricycle, then eventually, a rudimentary car. See *Figure 13**.25*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了轮子，那么让我们以某种有些滑稽的水平来娱乐一下，如果他们要创造世界上第一辆汽车，平均水平的软件开发者可能会使用的过程。记住，每次迭代都必须产生某种可用的旅行方式。我们的开发团队可能从滑板开始。这是我们可以在一个短暂的迭代中制作的东西。下一个迭代可能会产生一辆滑板车，下一个是一个自行车，下一个可能是一辆带动力的三轮车，然后最终是一辆原始的汽车。参见*图13.25*。
- en: '![Figure 13.25: An iterative process realizes a goal one step at a time](img/B19644_13_025.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图13.25：逐步过程一步一步实现目标](img/B19644_13_025.jpg)'
- en: 'Figure 13.25: An iterative process realizes a goal one step at a time'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25：逐步过程一步一步实现目标
- en: Each iteration produces a usable result, and we can point to this as continuous
    progress. At the end of each iteration, you should reflect upon the next because,
    with each iteration, your understanding of the final objective becomes clearer.
    You learn a lot from each iteration, and if you keep your iterations small, you
    have the flexibility to change direction when you discover you need to.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都会产生一个可用的结果，我们可以将其视为连续的进步。在每次迭代的结束时，你应该反思下一步，因为随着每次迭代，你对最终目标的了解会变得更加清晰。你从每次迭代中学到很多东西，如果你保持迭代的小规模，当你发现需要改变方向时，你有灵活性去调整。
- en: This happens all the time in traditional software development and in data science
    work. You may set out with a particular research objective in mind, but ultimately,
    you have to go where the data leads you rather than succumbing to your own bias.
    Iterative processes make this possible.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这在传统的软件开发和数据科学工作中经常发生。你可能一开始就有一个特定的研究目标，但最终，你必须跟随数据指引的方向，而不是屈服于自己的偏见。迭代过程使得这一点成为可能。
- en: 'We can apply this to the ideas behind Jupyter notebooks since these involve
    building up your work one cell, or iteration, at a time. During each iteration,
    you add or make the appropriate changes in the code cell that reads in the dataset
    and rerun the subsequent cells, as opposed to rerunning the code before it. As
    a tribute to its users, Jupyter notebooks were named after the three most common
    scientific programming languages: **Julia**, **Python**, and **R**.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这一点应用到Jupyter笔记本背后的理念上，因为这些理念涉及一次构建一个单元格或迭代的工作。在每次迭代中，你会在读取数据集的代码单元格中添加或做出适当的更改，然后重新运行后续的单元格，而不是重新运行之前的代码。作为对用户的致敬，Jupyter笔记本以三种最常用的科学编程语言命名：**Julia**、**Python**和**R**。
- en: Another integral part of Jupyter notebooks is the support for the Markdown language.
    As we mentioned previously, at the beginning of the previous chapter, Markdown
    is a markup language that’s commonly used in `README.md` files in GitHub. Furthermore,
    because of its ability to work with LaTeX (which is typically used for writing
    mathematical equations and scientific papers in general), Markdown is heavily
    favored by the data science community.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter笔记本的另一个重要部分是对Markdown语言的支撑。正如我们之前提到的，在上一章的开头，Markdown是一种常用于GitHub中`README.md`文件的标记语言。此外，由于它能够与LaTeX（通常用于撰写数学方程和科学论文）协同工作，Markdown在数据科学社区中受到了极大的青睐。
- en: Next, let’s see how we can use a Jupyter notebook in a regular PyCharm project
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在常规的PyCharm项目中使用Jupyter笔记本
- en: Jupyter notebooks in PyCharm
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm中的Jupyter笔记本
- en: For this task, we will be translating the program we have in the `main.py` file
    into a Jupyter notebook so that we can see the interface that Jupyter offers compared
    to a traditional Python script. I’ll be leveraging my existing `jupyter_notebooks`
    project we started with. You can find it in the chapter’s sample code. If you
    don’t have that repository, we cover cloning it in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028).
    If you’d like to start from scratch, you can simply create a new scientific project,
    which was covered in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将把`main.py`文件中的程序翻译成Jupyter笔记本，以便我们可以看到Jupyter提供的界面与传统的Python脚本相比。我将利用我们之前开始的`jupyter_notebooks`项目。你可以在本章的示例代码中找到它。如果你没有那个仓库，我们在[*第2章*](B19644_02.xhtml#_idTextAnchor028)中介绍了如何克隆它。如果你想从头开始，你可以简单地创建一个新的科学项目，这在[*第12章*](B19644_12.xhtml#_idTextAnchor298)中有介绍。
- en: Creating a notebook and adding our code
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建笔记本并添加我们的代码
- en: To add a new Jupyter notebook in a PyCharm project, create it as though it were
    just a file. Click **File** | **New** | **Jupyter Notebook** as shown in *Figure
    13**.26*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PyCharm项目中添加一个新的Jupyter笔记本，就像创建一个文件一样创建它。如图13.26所示，点击**文件** | **新建** | **Jupyter笔记本**。
- en: '![Figure 13.26: Create a new Jupyter notebook using the File | New menu option](img/B19644_13_026.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图13.26：使用文件 | 新建菜单选项创建一个新的Jupyter笔记本](img/B19644_13_026.jpg)'
- en: 'Figure 13.26: Create a new Jupyter notebook using the File | New menu option'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26：使用文件 | 新建菜单选项创建一个新的Jupyter笔记本
- en: You are immediately prompted to name your notebook. I called mine `basic.ipynb`.
    The file was created in the root folder of my project, but I went ahead and dragged
    it into the `notebooks` folder. You can see my starting point in *Figure 13**.27*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即被提示为你的笔记本命名。我把它命名为`basic.ipynb`。文件创建在我的项目的根目录中，但我把它拖到了`notebooks`文件夹中。你可以在*图13.27*中看到我的起点。
- en: '![Figure 13.27: My new notebook is ready!](img/B19644_13_027.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图13.27：我的新笔记本准备好了！](img/B19644_13_027.jpg)'
- en: 'Figure 13.27: My new notebook is ready!'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27：我的新笔记本准备好了！
- en: 'Let’s begin by typing some documentation along with some known imports. At
    the prompt, type this code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从输入一些文档和一些已知的导入开始。在提示符下，输入以下代码：
- en: '[PRE5]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you type the last `#%%`, you’ll find PyCharm starts a new cell for you.
    In the second cell, let’s enter some of the code we had earlier in our illustrative
    Python script:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入最后一个`#%%`时，你会发现PyCharm为你启动了一个新的单元格。在第二个单元格中，让我们输入我们之前在示例Python脚本中的一些代码：
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’ve explained this code earlier in this chapter, so I won’t do that again.
    As before, the last `#%%` will create a new cell. See *Figure 13**.28* to see
    what I have so far.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中已经解释了这段代码，所以不会再重复了。和之前一样，最后的 `#%%` 将创建一个新的单元格。查看 *图 13.28* 看看我现在有什么。
- en: '![Figure 13.28: I now have two cells containing our code from our earlier program](img/B19644_13_028.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.28：我现在有两个单元格，包含我们之前程序中的代码](img/B19644_13_028.jpg)'
- en: 'Figure 13.28: I now have two cells containing our code from our earlier program'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.28：我现在有两个单元格，包含我们之前程序中的代码
- en: So far so good! I have my imports and a cell that generates my dataset for me
    just as I had in my Python script. I’ve been breaking my program up into small,
    iterative steps. First, my imports, then my dataset. Next, I can look at doing
    something with my data. We know from earlier discussions that this is going to
    be a correlative matrix. What if this is a university project, and our professor
    wants us to document the formulae we use? That’s probably a good idea even if
    you’re out of school. Let’s take a moment to look at a cool documentation feature
    we can use. We know we can have code cells. We can also have documentation cells
    that leverage not only Markdown but also LaTeX.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！我已经有了导入，还有一个为我生成数据集的单元格，就像我在 Python 脚本中做的那样。我已经将我的程序分解成小的、迭代的步骤。首先，我的导入，然后是我的数据集。接下来，我可以查看如何处理我的数据。从之前的讨论中我们知道这将是一个相关矩阵。如果这是一个大学项目，而我们的教授希望我们记录我们使用的公式，这可能是一个好主意，即使你已经离开了学校。让我们花点时间看看我们可以使用的酷炫文档功能。我们知道我们可以有代码单元格。我们还可以有利用不仅
    Markdown 而且是 LaTeX 的文档单元格。
- en: Documenting with Markdown and LaTeX
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Markdown 和 LaTeX 进行文档编写
- en: Markdown is something we’ve already seen. It is a simple markup language that
    lets you create HTML-like documents, but instead of a rich set of tags, you use
    symbols to mark your documentation. Markdown only covers basics, such as headings,
    lists, and simple images. We covered the use of PyCharm’s integrated Markdown
    plugin in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown 是我们已经见过的一种东西。它是一种简单的标记语言，允许你创建类似 HTML 的文档，但与丰富的标签集不同，你使用符号来标记你的文档。Markdown
    只涵盖基本功能，如标题、列表和简单的图片。我们在 [*第 12 章*](B19644_12.xhtml#_idTextAnchor298) 中介绍了 PyCharm
    集成 Markdown 插件的使用。
- en: Working with Markdown in our notebooks allows us some simple formatting to enhance
    the look and readability of our notebooks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的笔记本中使用 Markdown 允许我们进行一些简单的格式化，以增强笔记本的外观和可读性。
- en: LaTeX, which is pronounced “LAY-tech” or “LAH-tech," depending on where your
    math professor studied, is a typesetting convention used in the fields of science
    and mathematics. This kind of thing is needed in academic journals because you
    can’t very well type complicated formulas easily on a keyboard, and not many math
    professors can bust out Adobe Illustrator and do their own illustration work.
    Instead of a graphical tool, they instead invented a terse, hard-to-understand,
    and impossible-to-remember convention for marking up their formulas in their journal
    articles. Then they named it a common English word but insisted we all mispronounce
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: LaTeX，根据你的数学教授在哪里学习，发音为“LAY-tech”或“LAH-tech”，是一种在科学和数学领域使用的排版约定。这种东西在学术期刊中是必需的，因为你不太可能在键盘上轻松地输入复杂的公式，而且很少有数学教授能熟练使用
    Adobe Illustrator 并进行自己的插图工作。他们没有使用图形工具，而是发明了一种简短、难以理解且难以记忆的约定，用于在他们的期刊文章中标记公式。然后他们给这个约定起了一个常见的英语单词，但坚持要求我们错误地发音。
- en: Let’s try it out!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧！
- en: First, I haven’t been totally up-front with you on how to create cells. Sure,
    you can just start typing stuff in, and using `#%%` to separate cells works just
    fine. You can also hover over the space between cells, or where the division would
    be if you’re at the top or bottom of the notebook. Check out *Figure 13**.29*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我还没有完全向你坦白如何创建单元格。当然，你可以直接开始输入内容，使用 `#%%` 来分隔单元格效果也很好。你也可以悬停在单元格之间的空间，或者如果你在笔记本的顶部或底部，悬停在分隔处。查看
    *图 13.29*。
- en: '![Figure 13.29: You can hover in the space between cells to get a little GUI
    help with adding new cells](img/B19644_13_029.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.29：你可以在单元格之间的空间悬停以获得添加新单元格的简单 GUI 帮助](img/B19644_13_029.jpg)'
- en: 'Figure 13.29: You can hover in the space between cells to get a little GUI
    help with adding new cells'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.29：你可以在单元格之间的空间悬停以获得添加新单元格的简单 GUI 帮助
- en: When you click these buttons between cells, it triggers a process of cell division
    called mitosis. Wait, no, that’s biology. It does split the cells by adding a
    new one between the two we have. I’m going to add a cell below my last one by
    hovering just below the last cell and clicking **Add Markdown Cell**. See *Figure
    13**.30*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单元格之间点击这些按钮时，会触发一个称为有丝分裂的细胞分裂过程。等等，不，那是生物学。它确实通过在两个已有的细胞之间添加一个新的细胞来分裂细胞。我将通过将鼠标悬停在最后一个细胞下方并点击**添加
    Markdown 单元格**来在我的最后一个单元格下方添加一个单元格。见*图 13**.30*。
- en: '![Figure 13.30: Hover above the last empty cell and click Add Markdown Cell](img/B19644_13_030.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.30：将鼠标悬停在最后一个空单元格上方并点击添加 Markdown 单元格](img/B19644_13_030.jpg)'
- en: 'Figure 13.30: Hover above the last empty cell and click Add Markdown Cell'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.30：将鼠标悬停在最后一个空单元格上方并点击添加 Markdown 单元格
- en: 'This will create a light blue cell without the IPython prompt. Since it’s a
    Markdown cell, PyCharm isn’t expecting code, so there’s no need for the prompt.
    Now, within the cell, type this absolute nonsense:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个不带 IPython 提示的浅蓝色单元格。由于它是一个 Markdown 单元格，PyCharm 不期望代码，因此不需要提示。现在，在单元格内，输入以下绝对废话：
- en: '[PRE7]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is LaTeX markup syntax that will convey Pearson’s formula for correlation.
    Trust me, it will be quite impressive in just a moment when we run our notebook.
    Let’s go ahead and add our two plots from earlier.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种 LaTeX 标记语法，它将传达皮尔逊的相关公式。相信我，当我们运行笔记本时，它将非常令人印象深刻。让我们继续添加我们之前的两张图表。
- en: Adding our plots
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加我们的图表
- en: 'Add a new code cell below the last one and add this code for our heatmap:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个单元格下方添加一个新的代码单元格，并添加以下代码用于我们的热图：
- en: '[PRE8]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add another code cell for our scattelot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为我们的 scattelot 添加另一个代码单元格：
- en: '[PRE9]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our implementation of our code as a Jupyter notebook is complete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码作为 Jupyter 笔记本实现完成。
- en: Executing the cells
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行单元格
- en: You can execute the notebook by clicking the run button at the top of the notebook
    as shown in *Figure 13**.31*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击笔记本顶部的运行按钮来执行笔记本，如图*图 13**.31*所示。
- en: '![Figure 13.31: Run all the cells in the notebook using the double green arrow
    button](img/B19644_13_031.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.31：使用双绿色箭头按钮运行笔记本中的所有单元格](img/B19644_13_031.jpg)'
- en: 'Figure 13.31: Run all the cells in the notebook using the double green arrow
    button'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.31：使用双绿色箭头按钮运行笔记本中的所有单元格
- en: This triggers a marvelous transformation in PyCharm. *Figure 13**.32* is a good
    starting place.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在 PyCharm 中触发一个奇妙的变化。*图 13**.32*是一个很好的起点。
- en: '![Figure 13.32: We’ve run the notebook, which causes a lot of changes in the
    PyCharm UI](img/B19644_13_032.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.32：我们已经运行了笔记本，这导致 PyCharm UI 发生了大量变化](img/B19644_13_032.jpg)'
- en: 'Figure 13.32: We’ve run the notebook, which causes a lot of changes in the
    PyCharm UI'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.32：我们已经运行了笔记本，这导致 PyCharm UI 发生了大量变化
- en: First, notice there is a new tool on the left sidebar for Jupyter. We can see
    we’ve started a Jupyter server running on port `8888`. If you were using Jupyter
    independently of PyCharm, this would be the normal mode of operation. You’d have
    run the Jupyter server from the command line and navigated to the notebook in
    your browser. PyCharm is replacing that experience within the IDE, but we still
    need to run the server to get the results.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意左侧边栏上有一个新的 Jupyter 工具。我们可以看到我们已经开始了一个在端口 `8888` 上运行的 Jupyter 服务器。如果你在没有
    PyCharm 的情况下使用 Jupyter，这将是一种正常的操作模式。你会从命令行运行 Jupyter 服务器，并在浏览器中导航到笔记本。PyCharm
    在 IDE 中替换了这种体验，但我们仍然需要运行服务器以获取结果。
- en: If you scroll up, you’ll see the LaTeX markup has been rendered in our Markdown
    cell shown in *Figure 13**.33*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向上滚动，你会看到 LaTeX 标记语法已经在我们的 Markdown 单元格中渲染，如图*图 13**.33*所示。
- en: '![Figure 13.33: The nonsense now looks absolutely stunning!](img/B19644_13_033.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.33：现在的废话看起来绝对惊人！](img/B19644_13_033.jpg)'
- en: 'Figure 13.33: The nonsense now looks absolutely stunning!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.33：现在的废话看起来绝对惊人！
- en: If you scroll down to inspect the scatterplot, we see… Well phooey! There’s
    an error! See *Figure 13**.34*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动以检查散点图，我们会看到……唉，出错了！见*图 13**.34*。
- en: '![Figure 13:34: The error message shows us exactly what is wrong](img/B19644_13_034.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 13:34：错误信息显示出了 exactly what is wrong](img/B19644_13_034.jpg)'
- en: 'Figure 13:34: The error message shows us exactly what is wrong'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13:34：错误信息显示出了 exactly what is wrong
- en: 'I messed up. I put parentheses alongside the DataFrame object, `df`. I need
    to take those off so it looks like it’s a neighbor:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我搞砸了。我在 DataFrame 对象 `df` 旁边加了括号。我需要去掉它们，让它看起来像是一个邻居：
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, I could rerun the whole notebook, but I don’t need to. The problem was
    in the last cell, so I could just put my cursor in the last cell and click the
    single green run arrow. See *Figure 13**.35*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以重新运行整个笔记本，但我不需要这样做。问题出在最后一个单元格中，所以我只需将光标放在最后一个单元格中，然后点击单个绿色运行箭头。见图*图13.35*。
- en: '![Figure 13.35: Yes, that’s much better!](img/B19644_13_035.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图13.35：是的，这要好得多！](img/B19644_13_035.jpg)'
- en: 'Figure 13.35: Yes, that’s much better!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35：是的，这要好得多！
- en: Let’s finish up our coverage of Jupyter with a few odds and ends.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些零散的内容来完成对Jupyter的介绍。
- en: Odds and ends
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零散的内容
- en: At present, we’re running a Jupyter server. We saw a moment ago this created
    a new tool icon on the left side menu. Let’s click that and see what’s up. See
    *Figure 13**.36*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在运行一个Jupyter服务器。我们刚才看到这在新工具图标上创建了一个左侧菜单。让我们点击它，看看发生了什么。见图*图13.36*。
- en: '![Figure 13.36: The Jupyter panel opens and we can see the output from the
    running server on the Server tab](img/B19644_13_036.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图13.36：Jupyter面板打开，我们可以在服务器选项卡上看到运行服务器的输出](img/B19644_13_036.jpg)'
- en: 'Figure 13.36: The Jupyter panel opens and we can see the output from the running
    server on the Server tab'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36：Jupyter面板打开，我们可以在服务器选项卡上看到运行服务器的输出
- en: Scrolling to the top of this window will reveal the local URL for the Jupyter
    server if you’d like to work with your notebook in the browser. But why would
    you do that when PyCharm is so much better?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将滚动条滚动到窗口顶部，如果你想在浏览器中与你的笔记本一起工作，将显示Jupyter服务器的本地URL。但为什么要在PyCharm如此出色的前提下这样做呢？
- en: Note the stop button that allows you to stop the running Jupyter server. Next
    to the **Server** tab is the **Variables** tab shown in *Figure 13**.37*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意允许你停止正在运行的Jupyter服务器的停止按钮。在**服务器**选项卡旁边是显示在*图13.37*中的**变量**选项卡。
- en: '![Figure 13.37: The Variables tab in the Jupyter pane allows for deep inspection
    into variables within your notebook](img/B19644_13_037.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图13.37：Jupyter面板中的“变量”选项卡允许深入检查笔记本中的变量](img/B19644_13_037.jpg)'
- en: 'Figure 13.37: The Variables tab in the Jupyter pane allows for deep inspection
    into variables within your notebook'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.37：Jupyter面板中的“变量”选项卡允许深入检查笔记本中的变量
- en: In the **Variables** tab, you get the inspections that allow you to drill down
    into any variable within the notebook. Notice, too, that the **View as Array**
    and **View as DataFrame** options are there so you can also use the SciView panel
    to see and filter your array contents.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在**变量**选项卡中，你可以获得允许你深入到笔记本中任何变量的检查。请注意，**以数组查看**和**以DataFrame查看**选项也在那里，这样你还可以使用SciView面板查看和过滤你的数组内容。
- en: We didn’t really talk much about the toolbar at the top of the notebook tab,
    as shown in *Figure 13**.38*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有太多讨论笔记本标签页顶部的工具栏，如图*图13.38*所示。
- en: '![Figure 13.38: Controls for manipulating cells in your notebook](img/B19644_13_038.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图13.38：操作笔记本中单元格的控制按钮](img/B19644_13_038.jpg)'
- en: 'Figure 13.38: Controls for manipulating cells in your notebook'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.38：操作笔记本中单元格的控制按钮
- en: There is a set of tools for cutting, copying, and pasting your cells (**1**).
    The arrows at (**2**) allow you to reorder the cells in the notebook by shifting
    them up or down. There is a broad set of run and debug tools at (**3**) that you
    no doubt recognize as a common theme.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具用于剪切、复制和粘贴你的单元格（**1**）。在(**2**)处的箭头允许你通过上下移动来重新排列笔记本中的单元格。在(**3**)处有一系列运行和调试工具，你无疑会将其视为一个常见主题。
- en: The broom icon will clear the output from a cell, which is handy if you’re working
    on salary projections based on the raise you’re about to ask for just as your
    boss walks up behind you. The trashcan deletes a cell entirely. There is also
    a dropdown here, marked **Code**, that allows you to change the type of cell,
    maybe from a code cell to a markup cell, or vice versa.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 扫帚图标将清除单元格的输出，如果你正在处理基于你即将提出的加薪的薪资预测，而你的老板正好从你身后走来，这将非常有用。垃圾桶将完全删除单元格。这里还有一个标记为**代码**的下拉菜单，允许你更改单元格的类型，比如从代码单元格更改为标记单元格，反之亦然。
- en: We have gone through the main features of PyCharm in the context of Jupyter
    notebooks. In general, one of the biggest drawbacks of using traditional Jupyter
    notebooks is the lack of code completion while writing code in individual code
    cells. Specifically, when we write code in Jupyter notebooks in our browser, the
    process is very similar to writing code in a simple text editor with limited support.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Jupyter笔记本的上下文中介绍了PyCharm的主要功能。总的来说，使用传统Jupyter笔记本的一个最大的缺点是在单独的代码单元格中编写代码时缺乏代码补全。具体来说，当我们在我们浏览器中的Jupyter笔记本中编写代码时，这个过程与在有限支持的简单文本编辑器中编写代码非常相似。
- en: However, as we work with Jupyter notebooks directly inside the PyCharm editor,
    we will see that all the code-writing support features that are available to regular
    Python scripts are also available here. In other words, when using PyCharm to
    write Jupyter notebooks, we get the best of both worlds—powerful, intelligent
    support from PyCharm and an iterative development style from Jupyter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们直接在PyCharm编辑器中处理Jupyter笔记本时，我们会看到所有可用于常规Python脚本的代码编写支持功能也在这里可用。换句话说，当使用PyCharm编写Jupyter笔记本时，我们得到了两者的最佳结合——来自PyCharm的强大、智能支持以及来自Jupyter的迭代开发风格。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A Python programmer typically works on a data science project in two ways—writing
    a traditional Python script or using a Jupyter notebook, both of which are heavily
    supported by PyCharm. Specifically, the SciView panel in PyCharm is a comprehensive
    and dynamic way to view, manage, and inspect data within a data science project.
    It offers a great way for us to display visualizations that have been produced
    by Python scripts as well as to inspect the values within pandas DataFrames and
    NumPy arrays.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员通常以两种方式在数据科学项目中工作——编写传统的Python脚本或使用Jupyter笔记本，这两种方式都得到了PyCharm的大力支持。具体来说，PyCharm中的SciView面板是一种全面且动态的方式来查看、管理和检查数据科学项目中的数据。它为我们提供了一个很好的方式来显示由Python脚本生成的可视化，以及检查pandas
    DataFrame和NumPy数组中的值。
- en: On the other hand, Jupyter notebooks are a great tool for facilitating iterative
    development in Python, allowing users to make incremental steps toward analyzing
    and extracting insights from their datasets. Jupyter notebooks are also well supported
    by PyCharm, being able to be edited directly inside the PyCharm editor. This allows
    us to skip the middle step of using a web browser to run our Jupyter notebooks
    while being able to utilize the powerful code-writing support features that PyCharm
    provides.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Jupyter笔记本是促进Python中迭代开发的强大工具，使用户能够逐步分析并从他们的数据集中提取见解。Jupyter笔记本也得到了PyCharm的良好支持，可以直接在PyCharm编辑器中进行编辑。这使得我们能够在利用PyCharm提供的强大代码编写支持功能的同时，跳过使用网络浏览器运行Jupyter笔记本的中间步骤。
- en: By going in depth into what PyCharm helps with regarding the process of viewing
    and working with data, either via the SciView panel or with Jupyter notebooks,
    we have learned how to use PyCharm to facilitate various data science tasks in
    Python. With this, we have equipped ourselves with enough knowledge and tools
    to tackle real-life projects using PyCharm.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入了解PyCharm在数据查看和操作过程中的帮助，无论是通过SciView面板还是使用Jupyter笔记本，我们已经学会了如何使用PyCharm在Python中促进各种数据科学任务。有了这些，我们已经拥有了足够的知识和工具来使用PyCharm处理现实生活中的项目。
- en: In the next chapter, we will combine all the knowledge we have learned so far
    regarding the topic of data science and scientific computing and walk through
    the process of building a data science pipeline in PyCharm.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结合到目前为止我们所学到的关于数据科学和科学计算的所有知识，并在PyCharm中逐步构建数据科学管道的过程。
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看本书的配套网站[https://www.pycharm-book.com](https://www.pycharm-book.com)。
- en: Questions
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What two main features does the SciView panel contain?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SciView面板包含哪两个主要功能？
- en: What is the advantage of using the plot viewer in the SciView panel when multiple
    visualizations are generated by a Python program?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Python程序生成多个可视化时，在SciView面板中使用绘图查看器的优势是什么？
- en: What kind of data structures does the data viewer in the SciView panel support?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SciView面板中的数据查看器支持哪些类型的数据结构？
- en: What is the idea of iterative development and how do Jupyter notebooks support
    that?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代开发的概念是什么？Jupyter笔记本是如何支持这一点的？
- en: What are Markdown and LaTeX? Why is it beneficial to have support for them in
    Jupyter notebooks?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Markdown和LaTeX？为什么在Jupyter笔记本中支持它们是有益的？
- en: How is a Jupyter code cell represented in the PyCharm editor?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm编辑器中，Jupyter代码单元是如何表示的？
- en: What are the benefits of writing Jupyter notebooks in the PyCharm editor?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm编辑器中编写Jupyter笔记本有哪些好处？
