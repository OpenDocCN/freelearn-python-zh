- en: Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: This chapter will introduce a variety of topics related to performing network
    operations. Simple low-level examples, such as performing DNS lookups using the
    low-level socket libraries, will be presented. HTTP client and server implementations
    will also be presented. We will then show you how to create an application that
    lets you control the LEDs on board the microcontroller using a web browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍与执行网络操作相关的各种主题。将呈现一些简单的低级示例，例如使用低级套接字库执行DNS查找。还将呈现HTTP客户端和服务器实现。然后，我们将向您展示如何创建一个应用程序，该应用程序可以让您使用Web浏览器控制微控制器上的LED灯。
- en: This chapter will help you create a MicroPython project that needs to fetch
    information from the internet. This can help you whenever you want to provide
    a way for people to use their web browsers on their phones and computers to directly
    connect and interact with your MicroPython boards.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您创建一个需要从互联网获取信息的MicroPython项目。这可以帮助您在需要为人们提供一种使用其手机和计算机上的Web浏览器直接连接和与您的MicroPython板交互的方式时使用。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performing a DNS lookup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行DNS查找
- en: Creating a function to wait for internet connectivity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个等待互联网连接的函数
- en: Performing an HTTP request using raw sockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始套接字执行HTTP请求
- en: Performing an HTTP request using the urequests library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用urequests库执行HTTP请求
- en: Fetching JSON data from a RESTful web service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从RESTful web服务获取JSON数据
- en: Creating an HTTP server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTTP服务器
- en: Creating a web handler module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个web处理程序模块
- en: Controlling LEDs through the web server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过web服务器控制LED灯
- en: Developing a RESTful API to control the LEDs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个RESTful API来控制LED灯
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in the `Chapter12` folder in this
    book's GitHub repository, available at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的GitHub存储库的`Chapter12`文件夹中找到，网址为[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266\. CircuitPython 3.1.2
    was used for all the recipes in this chapter. You should apply the configuration
    we described in the *Connecting to an existing Wi-Fi network* recipe from [Chapter
    10](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml), *Controlling the ESP8266*. This
    recipe will let you run all the recipes in this chapter that connect to the internet,
    as well as the recipes that involve you connecting to your board from your computer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用Adafruit Feather HUZZAH ESP8266。本章中的所有配方都使用了CircuitPython 3.1.2。您应该应用我们在[第10章](d2b921f5-f861-412c-819d-46a68c0ddf18.xhtml)中描述的*连接到现有Wi-Fi网络*配方中的配置，*控制ESP8266*。此配方将使您能够运行本章中连接到互联网的所有配方，以及涉及您从计算机连接到您的板的配方。
- en: Performing a DNS lookup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行DNS查找
- en: This recipe will show you how to write code that will run on MicroPython to
    perform a DNS lookup. Whenever our applications try and connect to the host, one
    of the first steps is to look up the hostname using the DNS protocol and get the
    host's IP address so that you can open a connection to that IP address.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示如何编写可以在MicroPython上运行的代码，以执行DNS查找。每当我们的应用程序尝试连接到主机时，首先要做的一步是使用DNS协议查找主机名并获取主机的IP地址，以便您可以打开到该IP地址的连接。
- en: This recipe shows you how to perform that DNS lookup, and then takes those lines
    of code and packages them into a function that you can call whenever you want
    to get the IP address of a specific host. This recipe can be useful in your projects
    whenever you want to keep track of a hostname and its related IP address, or when
    you face networking issues on your devices or network and want some simple tests
    to troubleshoot what's going on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程向您展示了如何执行DNS查找，然后将这些代码行打包到一个函数中，您可以在需要获取特定主机的IP地址时调用该函数。当您的设备或网络出现网络问题并且需要一些简单的测试来排除故障时，本教程可以在您的项目中发挥作用，或者当您想要跟踪主机名及其相关IP地址时。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL，以运行本教程中提供的代码。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to perform a DNS lookup:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何执行DNS查找：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve used the `getaddrinfo` function to perform a DNS lookup on `python.org`
    and get its IP address. The following block of code will access the specified
    string in the returned data structure that contains the IP address:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经使用`getaddrinfo`函数对`python.org`执行了DNS查找，并获取了其IP地址。以下代码块将访问返回的数据结构中包含IP地址的指定字符串：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now wrap this code up in a function that returns the IP address for
    a given hostname:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将这段代码封装在一个函数中，以返回给定主机名的IP地址：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will call this function with a number of different hostnames to verify that
    it is working correctly:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用不同主机名调用此函数，以验证其是否正常工作：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this script is executed, it will perform DNS lookups on three hostnames
    and print out the results of each lookup.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，它将对三个主机名执行DNS查找，并打印出每次查找的结果。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `get_ip` function that is defined will receive the hostname as its the first
    argument and will perform a DNS lookup on the hostname, before returning the IP
    address at the end of each function call. There is one optional argument that
    specifies the TCP port to use when connecting to the host. The TCP port default
    value is set to port `80`. This is the port number for the HTTP protocol. This
    means that this function will work for hosts that are hosting a web server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的`get_ip`函数将接收主机名作为第一个参数，并在每次函数调用结束时执行主机名的DNS查找，然后返回IP地址。还有一个可选参数，用于指定连接到主机时要使用的TCP端口。TCP端口的默认值设置为端口`80`。这是HTTP协议的端口号。这意味着此函数将适用于托管web服务器的主机。
- en: The `main` function sleeps for five seconds to allow the board to establish
    a connection to the Wi-Fi network on boot-up before performing the DNS lookups.
    Then, the `main` function loops through three hostnames and performs a DNS lookup
    on each one, printing out the hostname and returned IP of each entry through the
    `for` loop.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数在启动时睡眠五秒，以便让板子在启动时建立到Wi-Fi网络的连接，然后执行DNS查找。然后，`main`函数循环遍历三个主机名，并对每个主机名执行DNS查找，通过`for`循环打印出每个条目的主机名和返回的IP地址。'
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This script performs its task well enough, but there is room for improvement.
    The five-second delay is sufficient on most Wi-Fi networks. There are, however,
    networks that will take longer, so this value should be increased. But if we set
    this value very high and the network is fast to connect, then we are unnecessarily
    waiting too long. In the next recipe, we will introduce a way to wait for internet
    connectivity that will address both limitations in a much more effective fashion.
    Any time you use hardcoded sleep values in your code, you should dig deep and
    try to find better solutions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本完成了它的任务，但还有改进的空间。大多数Wi-Fi网络上的五秒延迟已经足够了。然而，有些网络可能需要更长的时间，所以这个值应该增加。但是，如果我们把这个值设置得很高，而网络连接很快，那么我们就会不必要地等待太久。在下一个教程中，我们将介绍一种等待互联网连接的方法，以更有效的方式解决这两个限制。每当你在代码中使用硬编码的睡眠数值时，你应该深入挖掘并寻找更好的解决方案。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于本教程的一些参考资料：
- en: Documentation on the `getaddrinfo` function can be found at [https://docs.python.org/3/library/socket.html#socket.getaddrinfo](https://docs.python.org/3/library/socket.html#socket.getaddrinfo).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`getaddrinfo`函数的文档可以在[https://docs.python.org/3/library/socket.html#socket.getaddrinfo](https://docs.python.org/3/library/socket.html#socket.getaddrinfo)找到。
- en: An example of using `getaddrinfo` on MicroPython can be found at [https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation](https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MicroPython上使用`getaddrinfo`的示例可以在[https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation](https://docs.micropython.org/en/latest/esp8266/tutorial/network_tcp.html#star-wars-asciimation)找到。
- en: Creating a function to wait for internet connectivity
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个等待互联网连接的函数
- en: This recipe will show you how to write a function that polls the status of your
    Wi-Fi connection on boot-up. We will name this function `wait_for_networking`.
    Once it has detected that a connection has been successfully established and that
    an IP address has been assigned over DHCP, then the `wait_for_networking` function
    will return.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示如何编写一个函数，在启动时轮询您的Wi-Fi连接状态。我们将把这个函数命名为`wait_for_networking`。一旦它检测到连接已成功建立，并且通过DHCP分配了IP地址，`wait_for_networking`函数将返回。
- en: Whenever you have a project that requires internet connectivity, you will face
    this issue at boot-up. If your script starts immediately, connecting to the internet
    before the network connection has come up, it will raise exceptions and fail to
    continue. Using the method in this recipe will let you start the rest of your
    program's execution once the network connection is properly established.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个需要互联网连接的项目时，你都会在启动时面临这个问题。如果你的脚本立即启动，在网络连接建立之前连接到互联网，它将引发异常并无法继续执行。使用本教程中的方法将允许你在网络连接正确建立后开始程序的其余执行。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在ESP8266上访问REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to create a function that waits for internet
    connectivity:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建一个等待互联网连接的函数：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the code is run early enough, it will return a `False` value. Calling
    `isconnected` again, but at a later stage, will result in the following output:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码运行得足够早时，它将返回一个`False`值。再次调用`isconnected`，但在稍后的阶段，将得到以下输出：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following block of code can be used to retrieve the assigned IP address
    once the network is connected:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块可以用来在网络连接后检索分配的IP地址：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following function brings all this code together into one function that
    will wait until a network connection is established and an IP address is allocated
    to the device. It then returns the IP address:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数将所有这些代码整合到一个函数中，该函数将等待直到建立网络连接并为设备分配IP地址。然后返回IP地址：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code should be put into the `netcheck.py` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`netcheck.py`文件中：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following block of code should be put into the `main.py` file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块应该放入`main.py`文件中：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When this script is executed, it will wait for a network connection to be established
    and then print out the IP address assigned to the device.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个脚本时，它将等待网络连接建立，然后打印出分配给设备的IP地址。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Python module called `netcheck`. The `wait_for_networking`
    function in that module will create a WLAN object called `station`. The `station`
    object will be used to poll the network at 1-second intervals until a network
    connection is established. Then, it will get the assigned IP from the `station`
    object using the `ifconfig` method. This IP address is then returned to the calling
    function. The main script in this recipe simply imports the `wait_for_networking`
    function from the `netcheck` module and calls it at the start of its execution,
    before printing out the returned IP address.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们创建了一个名为`netcheck`的Python模块。该模块中的`wait_for_networking`函数将创建一个名为`station`的WLAN对象。`station`对象将用于以1秒的间隔轮询网络，直到建立网络连接。然后，它将使用`ifconfig`方法从`station`对象中获取分配的IP。然后将这个IP地址返回给调用函数。本教程中的主要脚本只是从`netcheck`模块中导入`wait_for_networking`函数，并在执行开始时调用它，然后打印出返回的IP地址。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So many network connected projects should only start their main block of code
    once the network is connected. When you run Python on a typical computer, the
    operating system takes care of the process of ensuring all network connections
    are up before starting other services for you. In the case of MicroPython, there
    is no operating system—it's just your script running on bare metal. You have to
    take these things into account so that your code can run correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络连接的项目应该在网络连接后才启动其主要代码块。当你在典型的计算机上运行Python时，操作系统会在为你启动其他服务之前确保所有网络连接正常。在MicroPython的情况下，没有操作系统，它只是在裸机上运行你的脚本。你必须考虑这些因素，以便你的代码能够正确运行。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个教程的一些参考资料：
- en: Documentation on the **Dynamic Host Configuration Protocol** (**DHCP**) can
    be found at [https://tools.ietf.org/html/rfc2131](https://tools.ietf.org/html/rfc2131).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于**动态主机配置协议**（**DHCP**）的文档可以在[https://tools.ietf.org/html/rfc2131](https://tools.ietf.org/html/rfc2131)找到。
- en: Documentation on how `systemd` on Linux handles detecting network connectivity
    can be found at [https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/](https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Linux上的`systemd`如何处理检测网络连接的文档可以在[https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/](https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/)找到。
- en: Performing an HTTP request using raw sockets
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始套接字执行HTTP请求
- en: This recipe will use the `socket` library that comes with both MicroPython and
    Python to perform an HTTP request. We will create a function that receives a URL
    as its input and returns the response from the requested web server after performing
    the HTTP request. We will also create a function that can parse a URL and return
    the hostname and path components of the URL. These pieces will be needed to perform
    the HTTP request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将使用MicroPython和Python都带有的`socket`库来执行HTTP请求。我们将创建一个接收URL作为输入并在执行HTTP请求后返回所请求的Web服务器的响应的函数。我们还将创建一个函数，它可以解析URL并返回URL的主机名和路径组件。这些部分将需要执行HTTP请求。
- en: There's a whole class of MicroPython projects that will want to connect to web
    servers on the internet and fetch different results. You will see one way to do
    this using the `socket` library, which gives you direct access to TCP sockets
    to read and write bytes of data from them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一整类MicroPython项目希望连接到互联网上的Web服务器并获取不同的结果。你将看到一种使用`socket`库来实现这一点的方法，它可以直接访问TCP套接字，从中读取和写入数据字节。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to perform an HTTP request using raw sockets:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用原始套接字执行HTTP请求：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have successfully created the `parse_url` function, which takes a URL and
    returns the `host` and `path` components:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经成功创建了`parse_url`函数，它接受一个URL并返回`host`和`path`组件：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`parse_url` is then called with an example URL to demonstrate its functionality.
    In the following block of code, we define and call a function to look up the IP
    address for a specific hostname:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用示例URL调用`parse_url`以演示其功能。在下面的代码块中，我们定义并调用一个函数来查找特定主机名的IP地址：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now define the `fetch` function, which receives a URL as its input and
    retrieves its content from a web server:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以定义`fetch`函数，它接收URL作为输入，并从Web服务器检索其内容：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now call this function and inspect the results that it returns:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以调用这个函数并检查它返回的结果：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this script gets executed, it will fetch the content of a specific URL
    and output the returned results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个脚本被执行时，它将获取特定URL的内容并输出返回的结果。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `parse_url` function will return the two main parts of the URL that we are
    interested in. This is done by removing the initial part of the URL and performing
    a single string split using the `/` character. Once these operations are performed,
    we will be left with the hostname and path part of the URL, which we can then
    return. The `fetch` function first calls `parse_url` and `get_ip` to get the hostname,
    path, and IP address information for a given URL. Once this is done, a socket
    connection is created to the web server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_url`函数将返回我们感兴趣的URL的两个主要部分。这是通过删除URL的初始部分并使用`/`字符进行单个字符串分割来完成的。一旦执行了这些操作，我们将得到URL的主机名和路径部分，然后我们可以返回它。`fetch`函数首先调用`parse_url`和`get_ip`来获取给定URL的主机名、路径和IP地址信息。一旦完成，就会创建一个到Web服务器的套接字连接。'
- en: The HTTP request is created by filling in the template called `HTTP_REQUEST`.
    This request is then transmitted over the network to the web server. The results
    are continually read as a series of chunks until the end of the response is reached.
    These chunks of data are concatenated together into a variable called response.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填写名为`HTTP_REQUEST`的模板来创建HTTP请求。然后将此请求通过网络传输到Web服务器。结果将不断被读取为一系列块，直到达到响应的末尾。这些数据块被连接在一起成为一个名为response的变量。
- en: The response has both the HTTP headers and body in the response. We are only
    interested in the body portion, so we use the `split` method to extract it. Once
    extracted, it is converted from a `bytes` object into a string and returned. The
    `main` function, when called, will wait for network connectivity and then call
    the `fetch` function to get the HTML content of the URL. This content is then
    printed out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中包含了HTTP头和响应体。我们只对响应体感兴趣，所以我们使用`split`方法来提取它。一旦提取出来，它就会从`bytes`对象转换为字符串并返回。`main`函数在调用时将等待网络连接，然后调用`fetch`函数获取URL的HTML内容。然后将此内容打印出来。
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A lot is going on in this recipe. In a way, this is a great way to learn about
    TCP sockets, HTTP, HTML, and URLs, because all the low-level details are exposed
    to you. MicroPython doesn't ship with the higher-level HTTP request libraries
    that come with the Python standard library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中有很多内容。在某种程度上，这是一个学习TCP套接字、HTTP、HTML和URL的好方法，因为所有的低级细节都暴露给了你。MicroPython没有提供与Python标准库一起提供的高级HTTP请求库。
- en: So, when you want to write code from scratch that fetches content from a web
    server, you have to use the `socket` library in the same way that was presented
    in this recipe. In the next recipe, we will see that there is a Python module
    that works with MicroPython that we can add to our projects to make performing
    these HTTP requests much simpler.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您想要从头开始编写代码从Web服务器获取内容时，您必须以与本示例中介绍的相同方式使用`socket`库。在下一个示例中，我们将看到有一个Python模块可以与MicroPython一起工作，我们可以将其添加到我们的项目中，以使执行这些HTTP请求变得更简单。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个示例的一些参考资料：
- en: Documentation on the `send` method on MicroPython socket objects can be found
    at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MicroPython套接字对象上`send`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.send)找到。
- en: Documentation on the `recv` method on MicroPython socket objects can be found
    at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MicroPython套接字对象上`recv`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.recv)找到。
- en: Performing an HTTP request using the urequests library
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`urequests`库执行HTTP请求
- en: This recipe will use the `urequests` library, which was specially written to
    work with MicroPython. It provides a convenient way to connect to web servers
    and perform HTTP requests. This library provides an object that you can use to
    perform all your HTTP interactions. After the request is completed, you can access
    different attributes of this object to get a variety of information on the completed
    request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将使用`urequests`库，这个库是专门为与MicroPython一起使用而编写的。它提供了一种方便的方式来连接到Web服务器并执行HTTP请求。这个库提供了一个对象，您可以使用它来执行所有的HTTP交互。请求完成后，您可以访问这个对象的不同属性，以获取有关完成请求的各种信息。
- en: This recipe will explore using this library and the different attributes that
    you might want to access on its objects. When you start creating MicroPython projects
    that need to make HTTP requests, this library will take care of a lot of the low-level
    details of making these requests. This will keep your code simpler and more readable,
    and lets you focus on the task at hand instead of getting bogged down with low-level
    TCP socket details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将探讨如何使用这个库以及可能想要在其对象上访问的不同属性。当您开始创建需要进行HTTP请求的MicroPython项目时，这个库将处理许多低级细节，使得您的代码更简单、更易读，并让您专注于手头的任务，而不是被低级TCP套接字细节所困扰。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to perform an HTTP request using `urequests`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用`urequests`执行HTTP请求：
- en: Download `urequests.py` from [https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py](https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py](https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py)下载`urequests.py`。
- en: Save this Python module on your board's top-level directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个Python模块保存在您的开发板的顶层目录中。
- en: 'Run the following lines of code in the REPL:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now have a completed HTTP request, and its results are stored in the `req`
    variable. The following block of code will output the HTML response we received
    from the web server:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有一个完成的HTTP请求，并且其结果存储在`req`变量中。以下代码块将输出我们从Web服务器收到的HTML响应：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also access the raw content in its binary form, as shown in the following
    block of code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以以二进制形式访问原始内容，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `status_code` attribute provides us with the HTTP status code of the response:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`status_code`属性为我们提供了响应的HTTP状态代码：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following block of code will attempt to access a page that doesn''t exist:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将尝试访问一个不存在的页面：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now inspect the values of the status code and the explanatory text:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以检查状态代码和解释文本的值：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When this script is executed, it will use the `urequests` library to fetch the
    content of a specific URL and output the page's HTML content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将使用`urequests`库来获取特定URL的内容，并输出页面的HTML内容。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `urequests` library provides a function called `get` that lets you perform
    HTTP `GET` requests on web servers. Once you call this function, it will return
    an object that has a number of useful properties that you can then access to retrieve
    the results of this request.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`urequests`库提供了一个名为`get`的函数，让您可以在Web服务器上执行HTTP `GET`请求。一旦调用了这个函数，它将返回一个对象，该对象具有许多有用的属性，您可以访问这些属性来检索此请求的结果。'
- en: You can get the raw response as a bytes object by accessing the content attribute,
    or you can get the value as a string by accessing the `text` attribute. Finally,
    you can use the `status_code` and `reason` attributes to check whether a request
    was successful or failed, and what the reason for its failure was. This code is
    then wrapped up and put into the `main` function. When the main function is called,
    it will connect to the web server and output the contents of the returned HTML
    document.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问`content`属性获取原始响应作为字节对象，或者通过访问`text`属性获取值作为字符串。最后，您可以使用`status_code`和`reason`属性来检查请求是否成功或失败，以及失败的原因是什么。然后将此代码封装并放入`main`函数中。当调用主函数时，它将连接到Web服务器并输出返回的HTML文档的内容。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe shows a nice way of getting productive in MicroPython HTTP requests
    without having to go to a very low level of detail. It’s a great example of how
    a well-designed library can make your code more readable and maintainable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程展示了一种在MicroPython中进行HTTP请求的良好方式，而无需深入细节。这是一个很好的例子，说明了一个设计良好的库如何使您的代码更易读和可维护。
- en: This library provides a number of HTTP methods, beyond a basic HTTP `GET` request.
    The `HEAD`, `POST`, `PUT`, `PATCH`, and `DELETE` methods are all made available
    too. They can all be accessed using function names that match the request method.
    This can be very useful at times when you're interacting with web services that
    need the correct HTTP method to be specified for them to work correctly. If you
    are getting warning messages each time you make HTTP calls using the `urequests`
    library, you can try and use the `fix_urequests_warnings.py` file to fix this
    issue. You can find this script in the `Chapter12` folder of this book's GitHub
    repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了许多HTTP方法，除了基本的HTTP `GET`请求。`HEAD`、`POST`、`PUT`、`PATCH`和`DELETE`方法也都可用。它们都可以使用与请求方法匹配的函数名称进行访问。在与需要正确指定HTTP方法才能正常工作的网络服务进行交互时，这可能非常有用。如果您每次使用`urequests`库进行HTTP调用时都收到警告消息，您可以尝试使用`fix_urequests_warnings.py`文件来解决此问题。您可以在本书的GitHub存储库的`Chapter12`文件夹中找到此脚本。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于本教程的一些参考资料：
- en: Documentation on the list of HTTP response status codes can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)找到有关HTTP响应状态代码列表的文档。
- en: The popular requests library is what the design of `urequests` is based on,
    and can be found at [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的requests库是`urequests`设计基础，可以在[http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/)找到。
- en: Fetching JSON data from a RESTful web service
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从RESTful网络服务获取JSON数据
- en: This recipe will show you an example of connecting to a server on the internet
    in order to consume its RESTful web service. The web service will provide data
    in JSON format, which will then be parsed so that we can access different parts
    of the returned dataset.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示一个示例，以连接到互联网上的服务器，以便使用其RESTful网络服务。网络服务将以JSON格式提供数据，然后对其进行解析，以便我们可以访问返回数据集的不同部分。
- en: We will consume a web service that provides the current location of the **International
    Space Station** (**ISS**). Since the ISS moves at an incredible speed of 28,000
    km/h, we can watch its position, which is expressed in terms of longitude and
    latitude, change as we repeatedly call this web service. Whenever you want to
    create a MicroPython project that connects to the rich world of internet-based
    web services, you can use the techniques covered in this recipe as a starting
    point to build these connections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个提供**国际空间站**（**ISS**）当前位置的网络服务。由于ISS以每小时28,000公里的惊人速度移动，我们可以观察到它的位置（以经度和纬度表示）随着我们反复调用这个网络服务而发生变化。每当您想要创建一个连接到基于互联网的网络服务丰富世界的MicroPython项目时，您可以使用本教程中介绍的技术作为构建这些连接的起点。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to fetch JSON data from a RESTful web service:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何从RESTful网络服务获取JSON数据：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have successfully connected to the web service and retrieved the space station''s
    position. The following block of code will inspect the data that has been returned
    to us:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已成功连接到网络服务并检索到了空间站的位置。以下代码块将检查返回给我们的数据：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The data is provided in JSON format. We can use the following block of code
    to parse the text data and generate a set of nested dictionaries:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据以JSON格式提供。我们可以使用以下代码块来解析文本数据并生成一组嵌套字典：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following block of code shows how we can access the latitude and longitude
    data from the returned data structure:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块显示了我们如何从返回的数据结构中访问纬度和经度数据：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will create and call the `track_space_station` function, which will
    track the space station''s position every second over a period of `10` seconds:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建并调用`track_space_station`函数，该函数将在`10`秒的时间内每秒跟踪空间站的位置：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When this script is executed, it will track the position of the ISS and display
    the changes in the latitude and longitude each second for a fixed period of time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将跟踪ISS的位置，并在固定时间内每秒显示纬度和经度的变化。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We defined a constant called `ISS_API_URL` that has the URL that we can use
    to retrieve information on where the ISS is currently located. When we call this
    API by performing an HTTP `GET` request, the server returns its output in JSON
    format. We can then use the `json` method on the returned request object to parse
    this response into Python data structures. We can access the `iss_position` key
    and the latitude and longitude information within that dictionary. The rest of
    the `track_space_station` function just loops for `10` iterations, with a 1-second
    sleep between each loop, before calling the API and printing its parsed results.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`ISS_API_URL`的常量，其中包含我们可以使用的URL，以检索ISS当前位置的信息。当我们通过执行HTTP `GET`请求调用此API时，服务器会以JSON格式返回其输出。然后，我们可以使用返回的请求对象上的`json`方法将此响应解析为Python数据结构。我们可以访问`iss_position`键以及该字典中的纬度和经度信息。`track_space_station`函数的其余部分只是循环执行`10`次迭代，每次循环之间间隔1秒，然后调用API并打印其解析的结果。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe is a great example of how rich and varied the world of web services
    can be. You can connect these tiny low-powered microcontrollers to all sorts of
    rich information sources. JSON is the most popular serialization format for these
    web services, so it's a very powerful feature to have built-in support for parsing
    this format with MicroPython.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是Web服务世界丰富多彩的一个很好的例子。您可以将这些微型低功耗微控制器连接到各种丰富的信息源。JSON是这些Web服务最流行的序列化格式，因此具有内置支持解析此格式的MicroPython功能非常强大。
- en: MicroPython also fully supports creating JSON output so that you can equally
    submit data to web services from your MicroPython project. You could connect some
    sensors to your boards and continually upload sensor data in JSON format to a
    remote server using web services.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: MicroPython还完全支持创建JSON输出，以便您可以从MicroPython项目向Web服务提交数据。您可以将一些传感器连接到您的开发板，并使用Web服务将传感器数据以JSON格式持续上传到远程服务器。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于此主题的一些参考资料：
- en: Documentation on the ISS Current Location API can be found at [http://open-notify.org/Open-Notify-API/ISS-Location-Now/](http://open-notify.org/Open-Notify-API/ISS-Location-Now/).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISS当前位置API的文档可以在[http://open-notify.org/Open-Notify-API/ISS-Location-Now/](http://open-notify.org/Open-Notify-API/ISS-Location-Now/)找到。
- en: Documentation on the JSON format can be found at [https://www.json.org/](https://www.json.org/).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON格式的文档可以在[https://www.json.org/](https://www.json.org/)找到。
- en: Creating an HTTP server
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP服务器
- en: This recipe will show you how we can create a web server in MicroPython that
    will serve web pages with dynamic content on the ESP8266\. Each time a browser
    visits the web server, it will display the current uptime of the board in seconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向您展示如何在ESP8266上使用MicroPython创建一个可以提供动态内容的Web页面的Web服务器。每当浏览器访问Web服务器时，它将显示开发板的当前正常运行时间（以秒为单位）。
- en: We'll ensure that the web page that's generated will render well on computer
    web browsers, as well as phone browsers. It can be a very powerful tool for the
    projects you create, as that you have the ability to interact with them from any
    phone or computer on your network using a web browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确保生成的网页在计算机网络浏览器和手机浏览器上都能很好地显示。它可以成为您创建的项目的强大工具，因为您可以使用网络浏览器从任何手机或计算机与它们进行交互。
- en: This recipe shows you how to create projects like this, where you can submit
    any live sensor data or information straight to people's browsers, regardless
    of whether they connect from their phone or desktop computer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向您展示了如何创建这样的项目，您可以将任何实时传感器数据或信息直接提交到人们的浏览器，无论他们是从手机还是台式电脑连接的。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to create an HTTP server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建HTTP服务器：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this stage, we have all the necessary Python modules imported and constants
    defined. The following block of code will define an HTML template that we will
    use to generate pages before submitting them to the connecting browsers:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经导入了所有必要的Python模块并定义了常量。以下代码块将定义一个HTML模板，我们将使用它来生成页面，然后将其提交给连接的浏览器：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following function is defined and called, and will bind and listen to the
    default HTTP port:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数被定义并调用，并将绑定并监听默认的HTTP端口：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following block of code defines and calls the `serve_requests` function,
    which will be in charge of serving any requests that are made to the web server.
    The function is called, and then the web server is visited by a browser three
    separate times. Each time a request is served, its details are printed out:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块定义并调用了`serve_requests`函数，该函数将负责为Web服务器发出的任何请求提供服务。调用该函数，然后浏览器分别访问了Web服务器三次。每次提供服务时，其详细信息都会被打印出来：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When this script is executed, it will kick off a web server each time the board
    boots up, which will display a message with the server's uptime each time it is
    visited by a browser.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，每次开发板启动时都会启动一个Web服务器，每次被浏览器访问时都会显示服务器的正常运行时间。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the first things that are defined in the script is the HTML template.
    This template will generate valid HTML5 web pages, which will render correctly
    on both mobiles and desktops.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中定义的第一件事是HTML模板。此模板将生成有效的HTML5网页，可以在移动设备和台式电脑上正确显示。
- en: The `icon` link tag is present to prevent web browsers from unnecessarily asking
    for `favicon.ico` files. The `socket_listen` function is called to bind and listen
    to the default HTTP port. The `serve_requests` function is then called and will
    endlessly serve all incoming HTTP requests. The start time of the web server is
    recorded in a variable called `start`. We will use this to calculate the server
    uptime for each request.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`icon`链接标签存在是为了防止Web浏览器不必要地请求`favicon.ico`文件。调用`socket_listen`函数来绑定并监听默认的HTTP端口。然后调用`serve_requests`函数，将无休止地处理所有传入的HTTP请求。Web服务器的启动时间记录在一个名为`start`的变量中。我们将使用这个变量来计算每个请求的服务器正常运行时间。'
- en: We call the `accept` method, which will block the code until a new request comes
    to the web server. Once we receive this new request, we consume all the HTTP request
    headers by repeatedly calling the `readline` method until we have detected the
    end of the request headers. We can now generate our HTML response and send it
    to the HTTP client using the `send` method. After transmitting the response, we
    close the connection with the client.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`accept`方法，它将阻塞代码，直到有新的请求到达web服务器。一旦我们收到这个新请求，我们通过反复调用`readline`方法来消耗所有的HTTP请求头，直到检测到请求头的结束。现在我们可以生成我们的HTML响应，并使用`send`方法将其发送给HTTP客户端。传输响应后，我们关闭与客户端的连接。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can take this recipe and extend it in many ways. You could read data from
    different sensors and buttons connected to the board and send this data back to
    the browser. You can also easily change and add more content to the template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采用这个方法，并以多种方式进行扩展。您可以从连接到板子的不同传感器和按钮中读取数据，并将这些数据发送回浏览器。您还可以轻松地更改和添加模板的内容。
- en: 'Currently, it only has HTML content, but there is nothing preventing you from
    adding CSS, JavaScript, and image content to your responses. The board comes with
    4 MB of flash memory, so there is a good amount of room on the board to add all
    of this content. The following screenshot shows the page that was generated from
    this recipe shown on a desktop browser:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它只有HTML内容，但没有什么可以阻止您向响应中添加CSS、JavaScript和图像内容。该板子配备了4MB的闪存，因此板子上有足够的空间来添加所有这些内容。以下截图显示了在桌面浏览器上显示的从此方法生成的页面：
- en: '![](assets/8cda4654-5660-4151-80e3-da43da40165f.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cda4654-5660-4151-80e3-da43da40165f.png)'
- en: 'The following screenshot is taken from the browser on an Android smartphone:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是从安卓智能手机的浏览器中获取的：
- en: '![](assets/895000ce-dd00-4fff-90e5-b8ed76ed427c.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/895000ce-dd00-4fff-90e5-b8ed76ed427c.png)'
- en: The way the HTML is designed in this recipe is to make it easy to have one code
    base serve both categories of devices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中设计HTML的方式是为了使一个代码库可以为两类设备提供服务。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关此方法的一些参考资料：
- en: Documentation on the `bind` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`bind`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.bind)找到。
- en: Documentation on the `listen` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`listen`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.listen)找到。
- en: Creating a web handler module
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web处理程序模块
- en: This recipe will show you how we can take a lot of the code and logic involved
    in handling sockets, parsing HTTP request headers, and generating HTML, and bundle
    it all into a single Python module. Once we have it in one module, we can import
    this module and pass it our web handler, which will do all the heavy lifting for
    us.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将向您展示如何将处理套接字、解析HTTP请求头和生成HTML所涉及的大量代码和逻辑捆绑到一个单独的Python模块中。一旦我们将它放入一个模块中，我们就可以导入这个模块，并将我们的Web处理程序传递给它，它将为我们完成所有繁重的工作。
- en: You will find this recipe useful when you are creating projects that create
    a web-based application on your microcontroller and you want to get productive
    fast, without getting bogged down in all the low-level details of sockets and
    parsing HTTP headers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建在微控制器上创建基于Web的应用程序的项目时，您会发现这个方法非常有用，而且您希望快速提高生产力，而不会陷入套接字和解析HTTP头的所有低级细节中。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL才能运行此处提供的代码。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to create a web handler module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建Web处理程序模块：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have created a variable called `BASE_TEMPLATE` that will act as a generic
    template. Now, we can fill its `body` tag with any content we desire. The following
    block of code defines `socket_listen`, which does the initial socket configuration
    for the server:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`BASE_TEMPLATE`的变量，它将充当通用模板。现在，我们可以用任何我们想要的内容填充它的`body`标签。以下代码块定义了`socket_listen`，它为服务器进行了初始套接字配置：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following block of code has a function that receives the web handler as
    an argument. When called, it will handle incoming requests so that it can collect
    their request headers, and then parse the HTTP method and requested path. This
    information is then passed to the handler, which will return the HTML content
    to be sent to the HTTP client:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块具有一个接收web处理程序作为参数的函数。当调用时，它将处理传入的请求，以便可以收集它们的请求头，然后解析HTTP方法和请求的路径。然后将此信息传递给处理程序，处理程序将返回要发送给HTTP客户端的HTML内容：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `run_server` function is then defined in the following block of code. It
    is provided with a handler, and will create the sockets and call `serve_requests`
    to start serving all incoming requests:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run_server`函数在以下代码块中定义。它提供了一个处理程序，并将创建套接字并调用`serve_requests`来开始处理所有传入的请求：'
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following block of code shows an example handler that creates a web application
    that generates random numbers each time anyone visits it:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块显示了一个示例处理程序，该处理程序创建一个Web应用程序，每次有人访问时都会生成随机数：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following code should be put into the `web.py` file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`web.py`文件中：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, put the following code in the `main.py` file:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码放入`main.py`文件中：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When this script is executed, it will start a web server at boot-up that generates
    random numbers whenever people visit it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本时，它将在启动时启动一个Web服务器，每当有人访问时都会生成随机数。
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: The bulk of this recipe is the code in the `web` Python module. This code provides
    the `BASE_TEMPLATE` variable, which can be filled with any content in its `body`
    tag. Then, three functions are defined in the module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的主要部分是`web`Python模块中的代码。此代码提供了`BASE_TEMPLATE`变量，可以在其`body`标记中填充任何内容。然后，在模块中定义了三个函数。
- en: The `socket_listen` function has logic that we are familiar with; that is, setting
    up the socket, binding it, and making it listen to port `80`. The `serve_requests`
    function now receives a handler and will collect the HTTP request headers in a
    variable called `request`. This `request` is then parsed to extract the HTTP method
    in use and the requested path. These three variables are then passed to the provided
    handler, which returns an HTML response to be transmitted to the HTTP client.
    The `run_server` function is the main point of entry into this module. You can
    call it and provide it with your handler, and it will set up the server and start
    processing requests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket_listen`函数具有我们熟悉的逻辑；即设置套接字、绑定套接字并使其监听端口`80`。`serve_requests`函数现在接收处理程序，并将HTTP请求标头收集到名为`request`的变量中。然后解析此`request`以提取正在使用的HTTP方法和请求的路径。然后将这三个变量传递给提供的处理程序，该处理程序返回要传输到HTTP客户端的HTML响应。`run_server`函数是此模块的主要入口点。您可以调用它并向其提供处理程序，它将设置服务器并开始处理请求。'
- en: The code in the `main.py` file imports the `web` module and passes the handler
    it has defined. Its handler simply generates a random number for each HTTP request
    and sends this number back to the web browser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py`文件中的代码导入了`web`模块，并传递了它定义的处理程序。它的处理程序简单地为每个HTTP请求生成一个随机数，并将此数字发送回Web浏览器。'
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe lends itself to being extended. The bulk of the code related to
    socket handling and dealing with byte conversion is all done by the `web` module.
    You can import this module and start creating web applications on your MicroPython
    board in a relatively short amount of time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例适合扩展。与套接字处理和处理字节转换相关的大部分代码都由`web`模块完成。您可以导入此模块并在相对较短的时间内在MicroPython板上开始创建Web应用程序。
- en: You can also extend the `web` module to add more features. You could create
    more built-in templates or parse the HTTP headers further to get access to more
    request information automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以扩展`web`模块以添加更多功能。您可以创建更多内置模板或进一步解析HTTP标头，以自动获取更多请求信息。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关此示例的一些参考资料：
- en: Documentation on the `accept` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`accept`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.accept)找到。
- en: Documentation on the `close` method can be found at [https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`close`方法的文档可以在[https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close](https://docs.micropython.org/en/latest/library/usocket.html#usocket.socket.close)找到。
- en: Controlling LEDs through the web server
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Web服务器控制LED
- en: This recipe will show you how to create a web-based application that will let
    people see the status of the red and blue LED lights, as well as turn each of
    them on and off. This recipe will help you whenever you want to create projects
    that control the output of different hardware components, such as LEDs, screens,
    or speakers through a web-based application that can be accessed from computers
    and phones alike.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将向您展示如何创建一个基于Web的应用程序，让人们看到红色和蓝色LED灯的状态，并打开和关闭它们。每当您想要创建控制不同硬件组件输出的项目时，例如通过可以从计算机和手机访问的基于Web的应用程序控制LED、屏幕或扬声器时，此示例都会帮助您。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL才能运行此示例中提供的代码。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Follow these steps to learn how to control LEDs through the web server:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何通过Web服务器控制LED：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `pins` and `state` variables have been created so that we can keep track
    of the status of the red and blue LEDs, as well as access their `Pin` objects.
    The following block of code will define the HTML `BODY` template and will show
    the current state of the LEDs, as well as provide buttons to toggle them on and
    off:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已创建`pins`和`state`变量，以便我们可以跟踪红色和蓝色LED的状态，并访问它们的`Pin`对象。以下代码块将定义HTML `BODY`模板，并显示LED的当前状态，并提供按钮以切换它们的开和关：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following block of code has a function that will format Boolean values
    into the `On` and `Off` labels for the HTML content we will generate:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块中有一个函数，它将布尔值格式化为HTML内容中的“On”和“Off”标签：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `gen_body` function generates the body portion of the HTML content:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gen_body`函数生成HTML内容的主体部分：'
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `toggle_color` function will switch the LED on and off. The first call
    will switch the red LED off, while then the second call will switch it back on:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toggle_color`函数将切换LED的开和关。第一次调用将关闭红色LED，而第二次调用将重新打开它：'
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `handler` function will toggle colors for `POST` requests, and for all
    requests, it will return the generated HTML body, which shows the LEDs'' statuses
    and provides toggle buttons:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handler`函数将为`POST`请求切换颜色，并且对于所有请求，它将返回生成的HTML主体，其中显示LED的状态并提供切换按钮：'
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When this script is executed, it will start a web application that shows the
    current status of the LEDs and provides buttons that can be used to toggle the
    LEDs on and off.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将启动一个Web应用程序，显示LED的当前状态，并提供按钮，可用于切换LED的开关。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `format` function takes Boolean values and returns values to indicate the
    light status of `On` or `Off`. The `gen_body` function will then loop through
    all the LED state values and format them so that they can fill the HTML template.
    This template is then filled and returned. The `toggle_color` function receives
    the name of the LED to toggle and then updates the state data structure before
    accessing the `Pin` object in order to apply the change to the LEDs. The `handler`
    function will take incoming requests and toggle the LEDs if the request is a `POST`
    request. Then, it will always return the generated body to show the latest values
    of the LEDs and provide the buttons to toggle them on and off. The `main` function
    initializes the LED `Pin` objects, and then calls the `run_server` function with
    the defined handler so that it can start processing incoming requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`函数接受布尔值并返回值以指示`On`或`Off`的灯状态。然后，`gen_body`函数将循环遍历所有LED状态值并格式化它们，以便它们可以填充HTML模板。然后填充并返回此模板。`toggle_color`函数接收要切换的LED的名称，然后在访问`Pin`对象之前更新状态数据结构，以便将更改应用于LED。`handler`函数将接收传入的请求并在请求为`POST`请求时切换LED。然后，它将始终返回生成的主体，以显示LED的最新值并提供按钮以打开或关闭它们。`main`函数初始化LED
    `Pin`对象，然后调用具有定义的处理程序的`run_server`函数，以便它可以开始处理传入的请求。'
- en: There's more...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe provides all the controls we need to inspect the current settings
    of the LEDs and switch them on and off. We can, however, extend and improve it
    in many ways. We could add some CSS to improve the look and feel of the application.
    We could also use some rich JavaScript controls that can create animations when
    someone interacts with the UI controls so that they act more like toggle buttons.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程提供了我们需要检查LED的当前设置并打开或关闭它们的所有控件。但是，我们可以以许多方式扩展和改进它。我们可以添加一些CSS来改善应用程序的外观和感觉。我们还可以使用一些丰富的JavaScript控件，可以在某人与UI控件交互时创建动画，以便它们更像切换按钮。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于此教程的一些参考资料：
- en: Documentation on a toggle control for web browsers can be found at [http://www.bootstraptoggle.com/](http://www.bootstraptoggle.com/).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Web浏览器切换控件的文档可以在[http://www.bootstraptoggle.com/](http://www.bootstraptoggle.com/)找到。
- en: Documentation on the HTTP `POST` method can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关HTTP `POST`方法的文档可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)找到。
- en: Developing a RESTful API to control the LEDs
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful API来控制LED
- en: This recipe will show you how to create a RESTful API hosted on the ESP8266
    that will let API clients inquire about the status of the LEDs, as well as toggle
    them on and off. In previous recipes, we've seen how you can use MicroPython as
    a client to access RESTful web services.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将向您展示如何在ESP8266上创建一个RESTful API，该API将允许API客户端查询LED的状态，并切换它们的开关。在之前的教程中，我们已经看到您可以使用MicroPython作为客户端来访问RESTful
    web服务。
- en: Now, we will flip this around, and provide RESTful web services so that other
    devices and computers on the network can connect to the board and control its
    hardware. You will find this recipe very useful whenever you need to have other
    computers and devices on the network remotely connect to your projects and control
    components on them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将扭转这一点，并提供RESTful web服务，以便网络上的其他设备和计算机可以连接到板并控制其硬件。每当您需要让网络上的其他计算机和设备远程连接到您的项目并控制其上的组件时，您会发现这个教程非常有用。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. You will also need the `curl` command-line tool, which can be downloaded
    from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问ESP8266上的REPL来运行本教程中提供的代码。您还需要`curl`命令行工具，可以从[https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)下载。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to develop a RESTful API to control the LEDs:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何开发RESTful API来控制LED：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have imported the `json` library and set up the `pins` and `state` variables.
    The following block of code will define the `JSON_HEADERS` template, which we
    will use to provide the HTTP response headers for our JSON responses:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经导入了`json`库并设置了`pins`和`state`变量。以下代码块将定义`JSON_HEADERS`模板，我们将使用它为我们的JSON响应提供HTTP响应头：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following block of code will perform the LED toggling for the RESTful API
    calls:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将执行RESTful API调用的LED切换：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `handler` function in the following code will toggle LEDs when a request
    uses the `POST` method. In all cases, it will return the values of the state variable
    in JSON serialized form:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码中的`handler`函数将在请求使用`POST`方法时切换LED。在所有情况下，它将以JSON序列化形式返回状态变量的值：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该放入`main.py`文件中：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Execute the `main.py` script so that we can start accessing the RESTful APIs.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`main.py`脚本，以便我们可以开始访问RESTful API。
- en: Download and install the `curl` command line on your computer ([https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机上下载并安装`curl`命令行（[https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)）。
- en: 'Run the following command in the Terminal:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will retrieve the status of the LEDs. Execute the following command to
    switch the red LED off:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将检索LED的状态。执行以下命令关闭红色LED：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we run the following command, the red LED will be switched back on:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行以下命令时，红色LED将被重新打开：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `curl` command line is an excellent way to test and interact with most RESTful
    APIs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令行是测试和与大多数RESTful API交互的绝佳方式。'
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The structure of the code is very similar to the previous recipe. Some of the
    main differences are that the `JSON_HEADERS` template provides the necessary HTTP
    response headers to indicate that the content type of the response will be JSON.
    The `dumps` function in the `json` module is also used to generate the JSON data
    from the state data structure. The server needs to be started before we can test
    and interact with the APIs through `curl`. The first `curl` command simply performs
    a `GET` request, which returns the status of the LEDs. We then use the `-X` option
    in `curl` to specify that we want to use the POST method so that we can toggle
    the LEDs on and off.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结构与上一个配方非常相似。一些主要的区别是`JSON_HEADERS`模板提供了必要的HTTP响应头，指示响应的内容类型将是JSON。`json`模块中的`dumps`函数也用于从状态数据结构生成JSON数据。在通过`curl`测试和与API交互之前，服务器需要启动。第一个`curl`命令只是执行一个`GET`请求，返回LED的状态。然后我们在`curl`中使用`-X`选项指定我们要使用POST方法，这样我们就可以切换LED的开关。
- en: There's more...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe offers a basic set of APIs so that we can control the lights on
    the board. We could extend it to respond to requests on how long the server has
    been running or its disk usage. You could create an API that lets you remotely
    list and delete files. RESTful APIs are very powerful tools that you can use to
    glue many different scripts and computers together across the network. The approach
    that we used in this recipe can be extended to provide more services and features
    with relative ease.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方提供了一组基本的API，这样我们就可以控制板上的灯。我们可以扩展它来响应关于服务器运行时间或磁盘使用情况的请求。您可以创建一个API，让您远程列出和删除文件。RESTful
    API是非常强大的工具，您可以使用它来在网络上连接许多不同的脚本和计算机。我们在这个配方中使用的方法可以轻松扩展以提供更多的服务和功能。
- en: See also
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references regarding this recipe:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个配方的一些参考资料：
- en: Documentation on using the `curl` command for HTTP `POST` requests can be found
    at [https://ec.haxx.se/http-post.html](https://ec.haxx.se/http-post.html).
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用`curl`命令进行HTTP `POST`请求的文档可以在[https://ec.haxx.se/http-post.html](https://ec.haxx.se/http-post.html)找到。
- en: A tutorial on RESTful APIs can be found at [https://www.restapitutorial.com/](https://www.restapitutorial.com/).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API的教程可以在[https://www.restapitutorial.com/](https://www.restapitutorial.com/)找到。
