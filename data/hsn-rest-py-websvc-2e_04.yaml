- en: Testing and Deploying an API in a Microservice with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Flask 微服务中测试和部署 API
- en: 'In this chapter, we will configure, write, and execute unit tests and learn
    a few things related to deployment. We will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将配置、编写和执行单元测试，并学习一些与部署相关的内容。我们将执行以下操作：
- en: Set up unit tests with `pytest`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pytest` 设置单元测试
- en: Create a database for testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于测试的数据库
- en: Create fixtures to perform setup and teardown tasks for running clean tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于执行设置和清理任务的固定值
- en: Write the first round of unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Run unit tests with `pytest` and check testing coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pytest` 运行单元测试并检查测试覆盖率
- en: Improve testing coverage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Understand strategies for deployments and scalability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: Setting up unit tests with pytest
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 设置单元测试
- en: So far, we have been writing code to add features to our RESTful API. We used
    command-line and GUI tools to understand how all the pieces worked together and
    to check the results of diverse HTTP requests made to the RESTful API with Flask's
    development server. Now we will write unit tests that will allow us to make sure
    that the RESTful API works as expected. Before we can start writing unit tests,
    it is necessary to install many additional packages in our virtual environment,
    create a new PostgreSQL database that we will use for testing, and build a configuration
    file for the testing environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写代码以向我们的 RESTful API 添加功能。我们使用命令行和 GUI 工具来了解所有组件如何协同工作，并检查使用 Flask
    开发服务器对 RESTful API 发出的各种 HTTP 请求的结果。现在我们将编写单元测试，以确保 RESTful API 如预期那样工作。在我们开始编写单元测试之前，有必要在我们的虚拟环境中安装许多附加包，创建一个新的
    PostgreSQL 数据库供测试使用，并构建测试环境的配置文件。
- en: Make sure you quit Flask's development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你退出 Flask 的开发服务器。你只需在运行它的终端或命令提示符窗口中按 *Ctrl* + *C*。
- en: Now we will install many additional packages. Make sure you have activated the
    virtual environment named `Flask01`, which we created in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*. After you activate
    the virtual environment, it is time to run many commands, which will be the same
    for macOS, Linux, or Windows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装许多附加包。请确保您已激活名为 `Flask01` 的虚拟环境，该环境在 [第 1 章](dbf75cef-4962-4e40-8192-03873b774c48.xhtml)
    *使用 Flask 开发 RESTful API 和微服务 1.0.2* 中创建。激活虚拟环境后，是时候运行许多命令了，这些命令在 macOS、Linux
    或 Windows 上都是相同的。
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑现有的 `requirements.txt` 文件，以指定我们的应用程序在任意支持平台上需要安装的附加包集。这样，在任意新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/requirements.txt` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器编辑虚拟环境根目录下名为 `requirements.txt` 的现有文本文件。在最后一行之后添加以下行，以声明新版本的 API 所需的附加包及其版本。示例代码文件包含在
    `restful_python_2_04_01` 文件夹中，位于 `Flask01/requirements.txt` 文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 文件中添加的每一行都表示需要安装的包及其版本。以下表格总结了我们作为附加要求指定的包及其版本号：'
- en: '| Package name | Version to be installed |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `pytest` | 4.0.1 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `pytest` | 4.0.1 |'
- en: '| `coverage` | 4.5.2 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `coverage` | 4.5.2 |'
- en: '| `pytest-cov` | 2.6.0 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-cov` | 2.6.0 |'
- en: 'We will install the following Python packages in our virtual environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的虚拟环境中安装以下 Python 包：
- en: '`pytest`: This is a very popular Python unit testing framework that makes testing
    easy and reduces boilerplate code.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`：这是一个非常流行的 Python 单元测试框架，它使测试变得简单，并减少了样板代码。'
- en: '`coverage`: This tool measures code coverage of Python programs and we will
    use it to determine which parts of the code are being executed by unit tests and
    which parts aren''t.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coverage`：这个工具测量 Python 程序的代码覆盖率，我们将使用它来确定哪些代码部分被单元测试执行，哪些部分没有被执行。'
- en: '`pytest-cov`: This plugin for `pytest` makes it easy to produce coverage reports
    that use the `coverage` tool under the hood, and provides some additional features.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-cov`：这个 `pytest` 插件使得使用 `coverage` 工具生成覆盖率报告变得简单，并提供了额外的功能。'
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions outlined in the previous table with `pip`
    using the recently edited `requirements.txt` file. Make sure you are in the folder
    that has the `requirements.txt` file before running the command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 macOS、Linux 或 Windows 上运行以下命令，使用最近编辑的 `requirements.txt` 文件通过 `pip`
    安装之前表格中概述的附加包和版本。在运行命令之前，请确保你位于包含 `requirements.txt` 文件的文件夹中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last lines for the output will indicate all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有新包及其依赖项已成功安装。如果你下载了示例的源代码，而你之前没有使用过该 API 的旧版本，`pip` 也会安装 `requirements.txt`
    文件中包含的其他包：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a database for testing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于测试的数据库
- en: Now we will create the PostgreSQL database that we will use as a repository
    for our testing environment. Notice that the testing computer or server must have
    PostgreSQL 10.5 installed on it, as explained in the previous chapters for the
    development environment. I assume that you are running the tests on the same computer
    in which you worked with the previous examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们将用作测试环境存储库的 PostgreSQL 数据库。请注意，测试计算机或服务器必须安装了 PostgreSQL 10.5，正如前几章中为开发环境所解释的那样。我假设你正在运行测试的计算机与你在之前示例中工作的计算机相同。
- en: Remember to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal, Command Prompt, or Windows PowerShell.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住确保 PostgreSQL 的 bin 文件夹包含在 `PATH` 环境变量中。你应该能够从当前的 Terminal、命令提示符或 Windows
    PowerShell 中执行 `psql` 命令行工具。
- en: We will use the PostgreSQL command-line tools to create a new database named
    `test_flask_notifications`. If you already ...
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PostgreSQL 命令行工具创建一个名为 `test_flask_notifications` 的新数据库。如果你已经 ...
- en: Creating fixtures to perform setup and teardown tasks for running clean tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建夹具以执行运行干净测试的设置和清理任务
- en: 'Test fixtures provide a fixed baseline to enable us to reliably and repeatedly
    execute tests. Pytest makes it easy to declare a test fixture function by marking
    a function with the `@pytest.fixture` decorator. Then, whenever we use the fixture
    function name as an argument in a test function declaration, `pytest` will make
    the fixture function provide the fixture object. Now we will create the following
    two `pytest` fixture functions, which we will use in future test functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试夹具提供了一个固定的基线，使我们能够可靠地重复执行测试。Pytest 通过使用 `@pytest.fixture` 装饰器标记函数，使得声明测试夹具函数变得简单。然后，无论何时我们在测试函数声明中使用夹具函数名作为参数，`pytest`
    都会使得夹具函数提供夹具对象。现在我们将创建以下两个 `pytest` 夹具函数，我们将在未来的测试函数中使用它们：
- en: '`application`: This test fixture function will perform the necessary setup
    tasks to create the Flask test app with the appropriate testing configuration
    and create all the necessary tables in the test database. The fixture will launch
    the test execution and when the test finishes, the fixture will perform the necessary
    teardown tasks to leave the database as it was before running the test.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application`：这个测试夹具函数将执行必要的设置任务，以创建具有适当测试配置的 Flask 测试应用，并在测试数据库中创建所有必要的表。夹具将启动测试执行，当测试完成后，夹具将执行必要的清理任务，使数据库在运行测试之前的状态保持不变。'
- en: '`client`: This test fixture function receives `application` as an argument,
    and therefore, it receives the Flask app created in the previously explained application
    test fixture function in this argument. Hence, the `client` test fixture function
    configures the application for testing, initializes the database, creates a test
    client for this application and returns it. We will use the test client in our
    test methods to easily compose and send requests to our API.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client`：这个测试固定函数接收`application`作为参数，因此，它接收在之前解释的应用程序测试固定函数中作为参数创建的Flask应用。因此，`client`测试固定函数为测试配置应用，初始化数据库，为该应用创建一个测试客户端并返回它。我们将在测试方法中使用测试客户端轻松地组合和发送请求到我们的API。'
- en: 'Create a new `conftest.py` file within the `service` folder. Add the following
    lines that declare many `import` statements and the previously explained `pytest`
    test fixture functions. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/conftest.py` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service`文件夹内创建一个新的`conftest.py`文件。添加以下行，这些行声明了许多`import`语句以及之前解释过的`pytest`测试固定函数。示例代码文件包含在`restful_python_2_04_01`文件夹中，位于`Flask01/service/conftest.py`文件中：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `application` fixture function will be executed each time a test that uses
    either `application` or `client` as arguments. The function calls the `create_app`
    function, declared in the `app` module, with `'test_config'` as an argument. The
    function will set up a Flask app with this module as the configuration file, and
    therefore, the app will use the previously created configuration file that specifies
    the desired values for our testing database and environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`application`固定函数将在每次使用`application`或`client`作为参数的测试时执行。该函数使用`app`模块中声明的`create_app`函数，并传入`''test_config''`作为参数。该函数将使用此模块作为配置文件设置Flask应用，因此，该应用将使用之前创建的配置文件，该文件指定了测试数据库和环境的所需值。'
- en: The next line calls the `orm.create_all` method to create all the necessary
    tables in our test database configured in the `test_config.py` file. All the code
    after the `yield app` line works as the teardown code that is executed after `app`
    is used and the test is executed. The code removes the SQLAlchemy session and
    drops all the tables that we created in the test database before starting the
    execution of the test. This way, after each test finishes its execution, the test
    database will be empty again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用`orm.create_all`方法来创建在`test_config.py`文件中配置的测试数据库中所有必要的表。在`yield app`行之后的所有代码作为清理代码执行，在`app`被使用和测试执行之后执行。这段代码将移除SQLAlchemy会话并删除在测试数据库中创建的所有表，这样，每次测试完成后，测试数据库将再次为空。
- en: Writing the first round of unit tests
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: 'Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the user and notification category resources: `UserResource`,
    `UserListResource`, `NotificationCategoryResource`, and `NotificationCategoryListResource`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写第一轮单元测试。具体来说，我们将编写与用户和通知类别资源相关的单元测试：`UserResource`、`UserListResource`、`NotificationCategoryResource`和`NotificationCategoryListResource`。
- en: 'Create a new `tests` subfolder within the `service` folder. Then, create a
    new `test_views.py` file within the new `service/tests` subfolder. Add the following
    lines that declare many `import` statements and the first functions that we will
    use in many test functions. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/tests/test_views.py` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service`文件夹内创建一个新的`tests`子文件夹。然后，在新的`service/tests`子文件夹内创建一个新的`test_views.py`文件。添加以下行，这些行声明了许多`import`语句以及我们将在许多测试函数中使用的第一个函数。示例代码文件包含在`restful_python_2_04_01`文件夹中，位于`Flask01/service/tests/test_views.py`文件中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running unit tests with pytest and checking testing coverage
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytest运行单元测试并检查测试覆盖率
- en: 'Create a new `setup.cfg` file within the `service` folder. The following lines
    show the code that specifies the desired configuration for `pytest` and the `coverage`
    tools. The code file for the sample is included in the `restful_python_2_04_01`
    folder, in the `Flask01/service/setup.cfg` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service`文件夹内创建一个新的`setup.cfg`文件。以下行显示了指定pytest和`coverage`工具所需配置的代码。示例代码文件包含在`restful_python_2_04_01`文件夹中，位于`Flask01/service/setup.cfg`文件中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `tool:pytest` section specifies the configuration for `pytest`. The `testpaths`
    setting assigns the `tests` value to indicate that the tests are located within
    the `tests` subfolder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`tool:pytest`部分指定了pytest的配置。`testpaths`设置将`tests`值分配给指示测试位于`tests`子文件夹中。'
- en: The `coverage:run` section specifies the configuration for the `coverage` tool.
    The `branch` setting is set to `True` to enable branch coverage measurement, in
    addition to the default statement coverage. The `source` setting specifies the
    modules that we want to be considered for the coverage measurement. We just want
    to include the `models` and `views` modules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage:run`部分指定了`coverage`工具的配置。`branch`设置设置为`True`以启用分支覆盖率测量，除了默认的语句覆盖率之外。`source`设置指定了我们希望考虑覆盖率测量的模块。我们只想包括`models`和`views`模块。'
- en: 'Now we will use the `pytest` command to run tests and measure their code coverage.
    Make sure you run the command in the Terminal or Command Prompt window in which
    you have activated the virtual environment and that you are located within the
    `service` folder. Run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`pytest`命令来运行测试并测量它们的代码覆盖率。请确保你在激活了虚拟环境的终端或命令提示符窗口中运行此命令，并且你位于`service`文件夹内。运行以下命令：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The test runner will execute all the functions defined in the `test_views.py`
    that start with the `test_` prefix and will display the results. We will use the
    `-v` option to instruct `pytest` to print the test function names and statuses
    in verbose mode. The `--cov` option turns on test-coverage-reporting generation
    with the usage of the `pytest-cov` plugin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器将执行所有在`test_views.py`中定义并以`test_`前缀开始的函数，并将显示结果。我们将使用`-v`选项来指示`pytest`以详细模式打印测试函数名称和状态。`--cov`选项通过使用`pytest-cov`插件启用测试覆盖率报告生成。
- en: The tests won't make changes to the database we have been using when working
    on the API. Remember that we configured the `test_flask_notifications` database
    as our test database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在API上工作时，测试不会更改我们一直在使用的数据库。请记住，我们已将`test_flask_notifications`数据库配置为我们的测试数据库。
- en: 'The following lines show the sample output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pytest uses the configuration specified in the previously created `setup.cfg`
    file to determine which path includes the modules whose names start with the `test`
    prefix. In this case, the only module that matches the criteria is the `test_views`
    module. In the modules that match the criteria, `pytest` loads tests from all
    the functions whose names start with the `test` prefix.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest使用之前创建的`setup.cfg`文件中指定的配置来确定哪些路径包含以`test`前缀开始的模块名称。在这种情况下，唯一符合标准的模块是`test_views`模块。在符合标准的模块中，`pytest`从所有以`test`前缀开始的函数中加载测试。
- en: The output provided details that the test runner discovered and executed five
    tests and all of them passed. The output displays the module and function names
    for each method in the `test_views` module that started with the `test_` prefix
    and represented a test to be executed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，测试运行器发现了并执行了五个测试，并且所有测试都通过了。输出显示了`test_views`模块中每个以`test_`前缀开始的方法的模块和函数名称，这些方法代表要执行的测试。
- en: 'The test code coverage measurement report provided by the `coverage` package
    in combination with the `pytest-cov` plugin uses the code analysis tools and the
    tracing hooks included in the Python standard library to determine which lines
    of code are executable and which of these lines have been executed. The report
    provides a table with the following columns:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由`coverage`包和`pytest-cov`插件提供的测试代码覆盖率测量报告使用Python标准库中包含的代码分析工具和跟踪钩子来确定哪些代码行是可执行的，以及这些行中的哪些已被执行。报告提供了一个包含以下列的表格：
- en: '`Name`: The Python module name'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`: Python模块名称'
- en: '`Stmts`: The count of executable statements for the Python module'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stmts`: Python模块中可执行语句的数量'
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Miss`: 未执行的执行语句数量，即那些未执行的语句'
- en: '`Branch`: The count of possible branches for the Python module'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Branch`: Python模块中可能的分支数量'
- en: '`BrPart`: The number of branches that were executed during tests'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrPart`: 测试过程中执行的分支数量'
- en: '`Cover`: The coverage of executable statements and branches, expressed as a
    percentage'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cover`: 可执行语句和分支的覆盖率，以百分比表示'
- en: We definitely have incomplete coverage for the `views.py` and `models.py` modules
    based on the measurements shown in the report. In fact, we just wrote a few tests
    related to the notification categories and users, and therefore, it makes sense
    that the coverage is lower than 50% for the `views.py` module. We didn't create
    tests related to notifications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据报告中显示的测量结果，我们确实对 `views.py` 和 `models.py` 模块存在不完整的覆盖率。实际上，我们只编写了一些与通知类别和用户相关的测试，因此，对于
    `views.py` 模块覆盖率低于 50% 是有道理的。我们没有创建与通知相关的测试。
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有 `-m` 命令行选项的 `coverage` 命令来显示新 `Missing` 列中缺失语句的行号：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command will use the information from the last execution and will display
    the missing statements and the missing branches. The next lines show a sample
    output that corresponds to the previous execution of the unit tests. A dash (`-`)
    is used to indicate a range of lines that were missed. For example, `22-23` means
    that lines `22` and `23` were missing statements. A dash followed by a greater
    than sign (`->`) indicates that the branch from the line before `->` to the line
    after it was missed. For example, `41->42` means that the branch from line `41`
    to line `42` was missed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将使用上次执行的信息，并显示缺失的语句和缺失的分支。以下行显示了与之前单元测试执行相对应的示例输出。破折号（`-`）用于表示遗漏的行范围。例如，`22-23`
    表示第 22 行和第 23 行缺少语句。破折号后跟大于号（`->`）表示从 `->` 前一行到其后一行的分支被遗漏。例如，`41->42` 表示从第 41
    行到第 42 行的分支被遗漏：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now run the following command to get annotated HTML listings detailing missed
    lines. The command won''t produce any output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令以获取详细说明遗漏行的注释 HTML 列表。该命令不会产生任何输出：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    web browser. The following screenshot shows an example report that coverage generated
    in HTML format:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的网页浏览器打开在 `htmlcov` 文件夹中生成的 `index.html` HTML 文件。以下截图显示了生成的 HTML 格式报告的示例：
- en: '![](img/aec4ebbd-55ec-4b41-b625-ca440e70f178.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aec4ebbd-55ec-4b41-b625-ca440e70f178.png)'
- en: 'Click or tap `views.py` and the web browser will render a web page that displays
    the statements that were run, including the missing ones, the excluded ones, and
    the partially executed ones, with different colors. We can click or tap on the
    run, missing, excluded, and partial buttons to show or hide the background color
    that represents the status for each line of code. By default, the missing lines
    of code will be displayed with a pink background and the partially executed will
    be displayed with a yellow background. Thus, we must write unit tests that target
    these lines of code to improve our tests coverage. The following screenshot shows
    the buttons with the summary:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触 `views.py`，网页浏览器将渲染一个显示已运行语句的网页，包括缺失的、排除的和部分执行的语句，并用不同的颜色标出。我们可以点击或轻触运行、缺失、排除和部分按钮来显示或隐藏代表每行代码状态的背景色。默认情况下，缺失的代码行将以粉色背景显示，部分执行的代码行将以黄色背景显示。因此，我们必须编写针对这些代码行的单元测试来提高我们的测试覆盖率。以下截图显示了带有总结的按钮：
- en: '![](img/9c948132-01e0-4bee-acbd-b6e8ca63d362.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c948132-01e0-4bee-acbd-b6e8ca63d362.png)'
- en: 'The next screenshot shows the highlighted missing lines and the partially evaluated
    branches for some lines of code in the `views.py` module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了 `views.py` 模块中某些代码行的突出显示的缺失行和部分评估的分支：
- en: '![](img/419e2a16-088a-40cf-8159-205b45bac59a.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/419e2a16-088a-40cf-8159-205b45bac59a.png)'
- en: Improving testing coverage
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Now we will write additional tests functions to improve the testing coverage.
    Specifically, we will write unit tests related to notifications and users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写额外的测试函数来提高测试覆盖率。具体来说，我们将编写与通知和用户相关的单元测试。
- en: 'Open the existing `service/tests/test_views.py` file and insert the following
    lines after the last line. The code file for the sample is included in the `restful_python_2_04_02`
    folder, in the `Flask01/service/tests/test_views.py` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有的 `service/tests/test_views.py` 文件，在最后一行之后插入以下行。示例代码文件包含在 `restful_python_2_04_02`
    文件夹中，位于 `Flask01/service/tests/test_views.py` 文件：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Understanding strategies for deployments and scalability
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: Flask is a lightweight microframework for the web, and therefore, it is an ideal
    choice whenever we have to provide a RESTful API encapsulated in a microservice.
    So far, we have been working with the built-in development server provided by
    Werkzeug and with plain HTTP.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 是一个轻量级的网络微框架，因此，在我们需要提供一个封装在微服务中的 RESTful API 时，它是一个理想的选择。到目前为止，我们一直在使用
    Werkzeug 提供的内置开发服务器和纯 HTTP 进行工作。
- en: It is very important to understand that Flask's built-in development server
    is not suitable for production.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解 Flask 的内置开发服务器不适合生产环境。
- en: There are dozens of deployment options for Flask, and the different stacks and
    procedures are out of the scope of this book, which is focused on development
    tasks for RESTful APIs with the most popular Python frameworks. The most prominent
    cloud providers include instructions on how to deploy Flask applications with
    diverse possible configurations. In addition, there are many options to use **WSGI**
    (short for **Web Server Gateway Interface**) servers, which implement the web
    server side of the WSGI interface, allowing us to run Python web applications,
    such as Flask applications, in production.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 有数十种部署选项，不同的堆栈和流程超出了本书的范围，本书专注于使用最流行的 Python 框架进行 RESTful API 的开发任务。最突出的云服务提供商包括如何使用不同配置部署
    Flask 应用程序的说明。此外，还有许多选项可以使用 **WSGI**（即 **Web 服务器网关接口**）服务器，这些服务器实现了 WSGI 接口中的网络服务器部分，允许我们在生产环境中运行
    Python 网络应用程序，例如 Flask 应用程序。
- en: Of course, in a production environment, we will also want to work with HTTPS
    instead of HTTP. We will have to configure the appropriate TLS certificates, also
    known as SSL certificates.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在生产环境中，我们也会希望使用 HTTPS 而不是 HTTP。我们将不得不配置适当的 TLS 证书，也称为 SSL 证书。
- en: We used Flask to develop a RESTful web service. The key advantage of these kinds
    of web services is that they are stateless, that is, they shouldn't keep a client
    state on any server. Our API is a good example of a stateless RESTful web service
    with Flask. Flask-RESTful and PostgreSQL 10.5 can be containerized in a Docker
    container. For example, we can produce an image with our application configured
    to run with NGINX, uWSGI, Redis, and Flask. Thus, we can make the API run as a
    microservice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Flask 开发了一个 RESTful 网络服务。这类网络服务的关键优势在于它们是无状态的，也就是说，它们不应该在任何服务器上保持客户端状态。我们的
    API 就是使用 Flask 实现的无状态 RESTful 网络服务的良好例子。Flask-RESTful 和 PostgreSQL 10.5 可以在 Docker
    容器中容器化。例如，我们可以创建一个包含我们的应用程序配置，以运行 NGINX、uWSGI、Redis 和 Flask 的镜像。因此，我们可以使 API 作为微服务运行。
- en: We always have to make sure that we profile the API and the database before
    we deploy our first version of our API. It is very important to make sure that
    the generated queries run properly on the underlying database and that the most
    popular queries do not end up in sequential scans. It is usually necessary to
    add the appropriate indexes to the tables in the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们 API 的第一个版本之前，我们始终必须确保我们对 API 和数据库进行性能分析。确保生成的查询在底层数据库上运行正常，以及最常用的查询不会最终导致顺序扫描，这一点非常重要。通常需要在数据库中的表上添加适当的索引。
- en: We have been using basic HTTP authentication. We can improve it with a token-based
    authentication. We must make sure that the API runs under HTTPS in production
    environments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用基本的 HTTP 身份验证。我们可以通过基于令牌的认证来改进它。我们必须确保 API 在生产环境中运行在 HTTPS 下。
- en: It is convenient to use a different configuration file for production. However,
    another approach that is becoming extremely popular, especially for cloud-native
    applications, is storing configuration in the environment. If we want to deploy
    cloud-native RESTful web services and follow the guidelines established in the
    Twelve-Factor App, we should store config in the environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的配置文件进行生产环境部署很方便。然而，另一种越来越受欢迎的方法，尤其是对于云原生应用，是将配置存储在环境中。如果我们想部署云原生 RESTful
    网络服务并遵循《十二要素应用》中确立的指南，我们应该将配置存储在环境中。
- en: 'Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file, which lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file. We
    have been updating this file each time we needed to install a new package in our
    virtual environment. However, it is a good idea to run the following `pip freeze`
    within the root folder of our virtual environment, `Flask01`, to generate the
    final `requirements.txt` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都包含了部署我们应用的详细说明。它们都会要求我们生成`requirements.txt`文件，该文件列出了应用程序的依赖项及其版本。这样，平台就能够安装文件中列出的所有必要依赖项。每当我们需要在我们的虚拟环境中安装新包时，我们都会更新这个文件。然而，在虚拟环境的根目录`Flask01`中运行以下`pip
    freeze`命令以生成最终的`requirements.txt`文件是一个好主意：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. Notice that the generated file also includes all the dependencies that were
    installed by the packages we specified in the original `requirements.txt` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的示例`requirements.txt`文件的内容。请注意，生成的文件还包括了我们在原始`requirements.txt`文件中指定的所有依赖项：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Test your knowledge
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'Pytest makes it easy to declare a test fixture function by marking a function
    with which of the following decorators?:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pytest通过标记函数以下哪个装饰器来声明一个测试固定函数？
- en: '`@pytest.fixture_function`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@pytest.fixture_function`'
- en: '`@pytest.test_fixture`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@pytest.test_fixture`'
- en: '`@pytest.fixture`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@pytest.fixture`'
- en: 'By default, pytest discovers and executes functions as text functions when
    they start with which of the following prefixes?:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，pytest在函数以以下哪个前缀开始时将其发现和执行为文本函数？
- en: '`test`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test`'
- en: '`test_`'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test_`'
- en: '`test-`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test-`'
- en: 'Which of the following commands displays the line numbers of the missing statements
    in the `Missing` column for a coverage report?:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令显示覆盖率报告中`Missing`列中缺失语句的行号？
- en: '`coverage report -m`'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`coverage report -m`'
- en: '`coverage report missing`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`coverage report missing`'
- en: '`coverage -missing`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`coverage -missing`'
- en: 'Pytest is a very popular Python:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pytest是一个非常流行的Python：
- en: Unit test framework that makes testing easy and reduces boilerplate code
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使测试变得简单并减少样板代码的单元测试框架
- en: WSGI server that we can ...
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行的WSGI服务器...
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up a testing environment. We installed `pytest` to make
    it easy to discover and execute unit tests and we created a new database to be
    used for testing. We wrote a first round of unit tests, measured test coverage
    with the `pytest-cov` plugin combined with the `coverage` tool, and then we wrote
    additional unit tests to improve test coverage. Finally, we understood many considerations
    for deployment and scalability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们搭建了一个测试环境。我们安装了`pytest`以便于发现和执行单元测试，并创建了一个新的数据库用于测试。我们编写了一轮单元测试，使用`pytest-cov`插件和`coverage`工具测量测试覆盖率，然后编写了额外的单元测试以提高测试覆盖率。最后，我们了解了关于部署和可扩展性的许多考虑因素。
- en: We built a complex API with Flask combined with Flask-RESTful and a PostgreSQL
    10.5 database that we can run as a microservice, and we tested it. Now we will
    move to another popular Python web framework, Django, which is the topic for the
    next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Flask结合Flask-RESTful和PostgreSQL 10.5数据库构建了一个复杂的API，我们可以将其作为微服务运行，并对其进行了测试。现在，我们将转向另一个流行的Python网络框架Django，这是下一章的主题。
