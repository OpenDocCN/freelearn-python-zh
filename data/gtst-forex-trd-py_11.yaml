- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Backtesting and Theoretical Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测和理论性能
- en: It’s been a long and, hopefully, interesting – although difficult at times –
    journey. It took us ten chapters to get familiar with all the essentials of market
    structure and the key concepts that create the foundation of systematic and algo
    trading. Now, we have approached the conclusion of this entire book. It’s time
    to bring all the pieces together and start developing our first trading application
    that can be used in both research and production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一段漫长且希望是充满趣味的旅程——尽管有时也很艰难。我们用了十章来熟悉市场结构的所有基本要素以及构建系统化和算法交易基础的关键概念。现在，我们已经接近这本书的结尾。是时候将所有碎片拼凑在一起，开始开发我们的第一个既可以用于研究也可以用于生产的交易应用了。
- en: We are going to develop a universal prototype that you will be able to use and
    reuse by just re-writing some parts without modifying the entire structure. We
    will trace all the paths from receiving a tick to placing an order – while checking
    the consistency of all our actions. We will learn how to keep parts of the trading
    application synchronized and see why it’s so important to do so. And finally,
    we will collect some very basic statistics of a sample trading strategy and calculate
    its theoretical performance – the most essential logical point in the entire research
    and development process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个通用原型，您只需重新编写部分内容而不修改整个结构，就可以使用和重用。我们将追踪从接收tick到下单的所有路径——同时检查我们所有行动的一致性。我们将学习如何保持交易应用各部分的同步，并了解为什么这样做如此重要。最后，我们将收集一些示例交易策略的基本统计数据，并计算其理论性能——在整个研究和开发过程中最重要的逻辑点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Trading app architecture – revised and improved
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易应用架构——修订和改进
- en: Multithreading – convenient but full of surprises
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程——方便但充满惊喜
- en: Trading application with a live data feed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有实时数据流的交易应用
- en: Backtesting – speed up the research
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测——加速研究
- en: Trading app architecture – revised and improved
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易应用架构——修订和改进
- en: 'In [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014), *Developing Trading Strategies
    – Why They Are Different*, we proposed a generalized architecture of a trading
    application. In brief, it consists of the following components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B19145_01.xhtml#_idTextAnchor014)，*开发交易策略——为什么它们不同*中，我们提出了一个交易应用的通用架构。简要来说，它包括以下组件：
- en: '**Data receiver**: Something that retrieves live data from the market or historical
    data stored locally; see [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving
    and Handling Market Data* *with Python*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据接收器**：从市场检索实时数据或从本地存储检索历史数据的组件；参见[*第5章*](B19145_05.xhtml#_idTextAnchor086)，*使用Python检索和处理市场数据*'
- en: '**Data cleanup**: A component that eliminates non-market prices; see [*Chapter
    1*](B19145_01.xhtml#_idTextAnchor014), *Developing Trading Strategies – Why They*
    *Are Different*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清理**：一个消除非市场价格的组件；参见[*第1章*](B19145_01.xhtml#_idTextAnchor014)，*开发交易策略——为什么它们不同*'
- en: '**Trading logic**: The *brains* of the trading app that make trading decisions
    (see [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental Analysis
    and Its Possible Use in FX Trading*, [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114),
    *Technical Analysis and Its Implementation in Python*, and [*Chapter 9*](B19145_09.xhtml#_idTextAnchor152),
    *Trading Strategies and Their Core Elements*), frequently with integrated pre-trade
    risk management'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易逻辑**：交易应用的大脑，负责做出交易决策（参见[*第6章*](B19145_06.xhtml#_idTextAnchor101)，*基本面分析基础及其在FX交易中的可能应用*，[*第7章*](B19145_07.xhtml#_idTextAnchor114)，*技术分析及其在Python中的实现*，以及[*第9章*](B19145_09.xhtml#_idTextAnchor152)，*交易策略及其核心要素*），通常还包含集成的事前风险管理'
- en: '**Ordering interface**: A component that receives trading signals from the
    trading logic, converts them into orders, and keeps track of their execution;
    see [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation* *in Python*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单界面**：接收交易逻辑的交易信号，将它们转换为订单，并跟踪其执行情况；参见[*第10章*](B19145_10.xhtml#_idTextAnchor171)，*Python中的订单类型及其模拟*'
- en: '**Post-trade risk management** and **open positions management**, such as keeping
    track of the running loss and liquidating losing positions or all positions'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交易后风险管理**和**开放头寸管理**，例如跟踪运行亏损和清算亏损头寸或所有头寸'
- en: 'Anyway, this simplified architecture lists the essential components but does
    not say anything about how they communicate with each other. Of course, it is
    possible to use a linear architecture where all the components are implemented
    as dependent pieces of code executed one after another in sequence. Such a solution
    is simple, but has significant drawbacks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这个简化的架构列出了基本组件，但没有说明它们之间是如何相互通信的。当然，可以使用线性架构，其中所有组件都作为依赖的代码片段依次执行。这种解决方案很简单，但存在显著的缺点：
- en: You won’t be able to add more trading logic components to run multiple strategies
    in parallel
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法添加更多交易逻辑组件以并行运行多个策略
- en: You won’t be able to send orders to multiple trading venues
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法向多个交易场所发送订单
- en: You won’t be able to receive information about the actual consolidated market
    position in the trading logic
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法在交易逻辑中接收关于实际综合市场头寸的信息
- en: You won’t be able to reuse the same code (at least in parts) for both development
    and production
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法重用相同的代码（至少在部分上）用于开发和生产
- en: Let’s stop for a while at these four disadvantages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时停下来，谈谈这四个缺点。
- en: Regarding the first two points, you may probably say that you’re not going to
    run multiple strategies and trade at multiple trading venues as we’re only making
    our first steps into algo trading, and doing that cross-venue and cross-trading
    logic is more of an institutional activity. I could argue that, in reality, it’s
    more than normal for private traders to do all that, but these two points are
    less important than the remaining two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前两点，你可能可能会说，您不会运行多个策略并在多个交易场所进行交易，因为我们只是刚开始接触算法交易，而且跨场所和跨交易逻辑更像是一种机构活动。我可以说，在现实中，私人交易者做所有这些事情是非常正常的，但这两个点的重要性不如剩下的两个点。
- en: 'To understand the importance of the third point, we have to introduce a new
    term: **consolidated** **market position**.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解第三点的重要性，我们必须引入一个新术语：**综合** **市场头寸**。
- en: 'Imagine that you have several strategies and all of them trade in the same
    market – say, EURUSD. The first one bought 100,000 euros, the second one sold
    80,000, and the third one bought 50,000\. Why has this happened? It’s quite a
    common situation: for example, you run a short-term mean reversion strategy, longer-term
    breakout, and long-term trend following strategies (see [*Chapter 9*](B19145_09.xhtml#_idTextAnchor152),
    *Trading Strategies and Their Core Elements*); they generate trading signals independently,
    but so long as they all trade the same market, they all contribute to the amount
    of the asset currently traded. This amount is called the consolidated market position.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有几种策略，它们都在同一个市场上交易——比如说，EURUSD。第一个策略购买了10万欧元，第二个策略卖出了8万，第三个策略购买了5万。这是为什么？这是一个相当常见的情况：例如，您运行了一个短期均值回归策略，一个长期突破策略，以及一个长期趋势跟踪策略（见[*第9章*](B19145_09.xhtml#_idTextAnchor152)，*交易策略及其核心要素*）；它们独立生成交易信号，但只要它们都在同一个市场上交易，它们都会对当前交易的资产数量做出贡献。这个数量被称为综合市场头寸。
- en: In our example, the individual positions per strategy are 100,000 long, 80,000
    short, and another 50,000 long, so the consolidated position is *70,000 long*.
    This is your real market exposure and all position sizing calculations should
    rely on this figure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，每个策略的个别头寸是100,000多，80,000空，还有另一个50,000多，所以综合头寸是*70,000多*。这是您的实际市场敞口，所有头寸规模计算都应该基于这个数字。
- en: But what about the entry price for such a consolidated position?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样的综合头寸的入场价格是多少呢？
- en: In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*, we explored the average execution price for an order that
    was executed in parts. The same approach can be used to calculate the average
    entry price for the consolidated market position. Let’s do this simple math for
    our example with three open positions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19145_10.xhtml#_idTextAnchor171)，*订单类型及其在Python中的模拟*中，我们探讨了部分执行订单的平均执行价格。同样的方法可以用来计算综合市场头寸的平均入场价格。让我们用我们三个开放头寸的例子来做这个简单的数学计算。
- en: 'Suppose that the first (100,000 long) position was opened at 1.0552, the second
    (80,000 short) at 1.0598, and the third (50,000 long) at 1.0471\. First, we calculate
    the sum of these prices multiplied by the respective trading size. Don’t forget
    that short positions (which effectively reduce the consolidated market position)
    should be accounted for as negative numbers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一个（100,000多单）头寸是在1.0552时*打开*的，第二个（80,000空单）是在1.0598时，第三个（50,000多单）是在1.0471时。首先，我们计算这些价格乘以相应交易规模的和。别忘了将空单（实际上减少了综合市场头寸）计为负数：
- en: '`S = 100000 * 1.0552 – 80000 * 1.0598 + 50000 * 1.0471 =` `73091`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`S = 100000 * 1.0552 – 80000 * 1.0598 + 50000 * 1.0471 =` `73091`'
- en: 'Now, we divide the sum, *S*, by the actual consolidated market position, *MP*,
    which equals *70,000*, and we get the average entry price:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将总和，*S*，除以实际的综合市场头寸，*MP*，它等于*70,000*，我们得到平均入场价格：
- en: '![](img/Formula_B19145_11_001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![公式图片](img/Formula_B19145_11_001.jpg)'
- en: In our example, the consolidated average price is approximately 1.0442\. At
    first glance, it looks ridiculous as it is way lower than the lowest of the actual
    traded prices. But it’s really easy to make sure it’s correct.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，综合平均价格大约为1.0442。乍一看，这似乎很荒谬，因为它远远低于实际交易价格中的最低价。但确保它是正确的其实非常简单。
- en: 'Imagine that the current market price is 1.0523\. Let’s calculate the running
    **profit or loss** (typically referred to as running **PnL** or running **P/L**;
    see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview from
    a Developer’s Standpoint*, the *Trade mechanics – again some terminology* section)
    for each position: it’s just the distance between the current price and the entry
    price multiplied by the trading size. The first position running PnL at 1.0523
    equals (1.0523 – 1.0552) * 100,000 = -$290, the second position running PnL equals
    (1.0523 – 1.0598) * -80,000 = $600, and the third position running PnL equals
    (1.0523 – 1.0471) * 50,000 = $260\. Thus, for the consolidated market position,
    the running PnL equals $570.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当前市场价格为1.0523。让我们计算每个头寸的运行**利润或亏损**（通常称为运行**PnL**或运行**P/L**；参见[*第3章*](B19145_03.xhtml#_idTextAnchor044)，*从开发者角度的FX市场概述*，*交易机制——再次一些术语*部分）:它只是当前价格与入场价格之间的距离乘以交易规模。在1.0523的运行PnL等于(1.0523
    – 1.0552) * 100,000 = -$290，第二个头寸的运行PnL等于(1.0523 – 1.0598) * -80,000 = $600，第三个头寸的运行PnL等于(1.0523
    – 1.0471) * 50,000 = $260。因此，对于综合市场头寸，运行PnL等于$570。
- en: Now, let’s do the same math with the price and the size of only one consolidated
    market position. Given it was *opened* at 1.0442 and the current market price
    is 1.0523, its running PnL is (1.0523 – 1.0442) * 70,000 = $567, which is not
    exactly equal to $570 only because we rounded the average price to the 4th digit.
    So, we can indeed use the average price and the resulting trading size of the
    consolidated market position instead of calculating the PnL for each position
    separately.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只使用一个综合市场头寸的价格和规模来做同样的数学计算。鉴于它是在1.0442时*打开*的，当前市场价格为1.0523，其运行PnL为(1.0523
    – 1.0442) * 70,000 = $567，这并不完全等于$570，仅仅是因为我们将平均价格四舍五入到第四位。因此，我们确实可以使用综合市场头寸的平均价格和结果交易规模，而不是分别计算每个头寸的PnL。
- en: Note for nerds
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 知识分子笔记
- en: Such a consolidated position calculated as the average of all orders with their
    respective trade volume is often called the **Volume Weighted Average Price**
    (**VWAP**). However, the VWAP is normally only used to evaluate a position that
    was accumulated by multiple entries to the same direction, and so long as we are
    discussing the net position as the result of trades taken to both sides, I prefer
    using *consolidated*, although it’s not a regular term.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将所有订单及其相应的交易量平均计算的综合头寸通常被称为**量加权平均价格**（**VWAP**）。然而，VWAP通常仅用于评估通过多个同一方向的头寸累积的头寸，只要我们讨论的是作为双边交易结果的网络头寸，我更喜欢使用*综合*，尽管它不是一个常规术语。
- en: A consolidated market position is extremely important to correctly implement
    risk management. If you don’t know this position, you have no idea about your
    running profit or loss, so you don’t know when to liquidate a losing position
    – which may end up with a disastrous loss. Moreover, you may not know even how
    much to liquidate, and open a new position instead of only covering a loss.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 综合市场头寸对于正确实施风险管理至关重要。如果你不知道这个头寸，你就不知道你的运行利润或亏损，因此你不知道何时平仓亏损头寸——这可能导致灾难性的损失。此外，你可能甚至不知道要平仓多少，而是打开一个新头寸，而不是仅仅弥补损失。
- en: 'Even if you run only one strategy in one market, it is no less important to
    know the exact market position as it exists in the real market: don’t forget that
    a certain order may not be executed or executed at a price different as expected
    due to several reasons (see [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*). So, if you don’t let your code
    provide feedback from the broker to the trading logic, you may have a hard time
    managing your positions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在单一市场中运行一个策略，了解实际市场中存在的确切市场位置也同样重要：不要忘记，由于多种原因，某些订单可能无法执行或以不同于预期的价格执行（见[*第
    10 章*](B19145_10.xhtml#_idTextAnchor171)，*订单类型及其在 Python 中的模拟*）。因此，如果你不让你代码从经纪人向交易逻辑提供反馈，你可能很难管理你的头寸。
- en: 'The fourth disadvantage is hopefully more evident: if we can suggest an architecture
    that is flexible, modular, and reusable, then it has an advantage over something
    that should be modified entirely every time you want just to switch a data source.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个缺点希望更加明显：如果我们能提出一个灵活、模块化和可重用的架构，那么它相对于每次想要切换数据源时都需要完全修改的东西具有优势。
- en: So, with all these considerations in mind, what can we suggest to make the architecture
    of our trading app meet all the requirements mentioned?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到所有这些因素，我们建议如何使我们的交易应用架构满足所提到的所有要求？
- en: We already know the solution, and we used it quite successfully in [*Chapter
    5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving and Handling Market Data with
    Python*. This solution is to use *threads* and *queues* to make the components
    of the app work independently. I strongly recommend that you refresh your memory
    regarding threads and queues by referring to the *Working with saved and live
    data – keep your app universal* section of that chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道解决方案，并在[*第 5 章*](B19145_05.xhtml#_idTextAnchor086)，*使用 Python 获取和处理市场数据*中相当成功地使用了它。这个解决方案是使用*线程*和*队列*使应用组件独立工作。我强烈建议你通过参考该章节的*与保存和实时数据一起工作
    – 保持你的应用通用*部分来刷新你对线程和队列的记忆。
- en: Now, let’s redraw the app architecture diagram, this time at a bit lower level,
    closer to the transport layer, not just business logic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新绘制应用架构图，这次稍微低一些级别，更接近传输层，而不仅仅是业务逻辑。
- en: 'As always, we will start from the beginning: receiving live (tick) market data.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从开始：接收实时（订阅）市场数据。
- en: Market data component
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 市场数据组件
- en: 'This component should be able to receive ticks from virtually any source, clean
    it up, translate them into the single format used throughout our app, and put
    them into the data queue:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件应能够从几乎任何来源接收订阅数据，对其进行清理，将其转换为整个应用中使用的单一格式，并将它们放入数据队列：
- en: '![Figure 11.1 – Tick data receiving component](img/B19145_11_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 订阅数据接收组件](img/B19145_11_01.jpg)'
- en: Figure 11.1 – Tick data receiving component
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 订阅数据接收组件
- en: The beauty of this approach is that as soon as the tick is sent to the tick
    queue, we can forget about it. This process is now isolated from the rest of the
    app, and should we need to change the data vendor or the broker, we can do that
    by rewriting the respective module without making a single change in the rest
    of the code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，一旦订阅数据被发送到订阅队列，我们就可以忘记它。这个过程现在与整个应用的其他部分隔离，如果我们需要更改数据供应商或经纪人，我们可以通过重写相应的模块来完成，而无需在其余代码中进行任何更改。
- en: Many strategies require tick data. For example, arbitrage strategies (see [*Chapter
    9*](B19145_09.xhtml#_idTextAnchor152), *Trading Strategies and Their Core Elements*)
    can work using *only* tick data. However, the majority of trading strategies use
    logic based on compressed data, not ticks. So, we need to add a component that
    can aggregate ticks into bars (see [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, the *Data compression – keep
    the amounts to the reasonable* *minimum* section).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多策略都需要订阅数据。例如，套利策略（见[*第 9 章*](B19145_09.xhtml#_idTextAnchor152)，*交易策略及其核心要素*）可以使用*仅*订阅数据来工作。然而，大多数交易策略使用基于压缩数据的逻辑，而不是订阅数据。因此，我们需要添加一个组件，可以将订阅数据聚合为条形图（见[*第
    5 章*](B19145_05.xhtml#_idTextAnchor086)，*使用 Python 获取和处理市场数据*，*数据压缩 – 将金额保持在合理的最低限度*部分）。
- en: Data aggregation component
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据聚合组件
- en: 'This module should be able to not only aggregate live tick data into bars.
    When we develop a strategy, we normally use historical market data stored locally
    already in a compressed form, so there’s no need to waste time aggregating ticks
    during a test run. Thus, we must add the following part to our app architecture:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块不仅应该能够将实时tick数据聚合为bars。当我们开发策略时，我们通常使用已经存储在本地并以压缩形式存储的历史市场数据，因此在测试运行期间没有必要浪费时间聚合tick数据。因此，我们必须将以下部分添加到我们的应用架构中：
- en: '![Figure 11.2 – Reading bars from storage or forming bars from ticks](img/B19145_11_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 从存储中读取bars或从ticks形成bars](img/B19145_11_02.jpg)'
- en: Figure 11.2 – Reading bars from storage or forming bars from ticks
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 从存储中读取bars或从ticks形成bars
- en: Again, as in the previous case, this process is isolated from the rest of the
    application, so we can implement it once and forget about it until we need to
    modify something in the way we aggregate ticks into bars.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如前一个案例一样，此过程被隔离于应用的其他部分，因此我们可以一次性实现它，直到我们需要修改将tick数据聚合为bars的方式。
- en: Next, we should implement the trading logic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该实现交易逻辑。
- en: Trading logic component
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易逻辑组件
- en: 'This component may use both tick and bar data as input and produce orders as
    output. This output should go into the order execution control component of our
    trading app, so it’s quite natural to use another queue again: the ordering queue
    that would isolate the order execution component from the rest of the application.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件可以使用tick数据和bar数据作为输入，并生成订单作为输出。此输出应进入交易应用的订单执行控制组件，因此再次使用另一个队列是很自然的：隔离订单执行组件与其他应用部分的订单队列。
- en: However, besides just sending orders out, we need another connection between
    the trading logic and the order execution components. This connection should provide
    feedback from the execution of the order to the trading logic. How do we establish
    such a connection?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了发送订单之外，我们还需要在交易逻辑和订单执行组件之间建立另一个连接。此连接应提供订单执行的反馈给交易逻辑。我们如何建立这样的连接？
- en: 'The first idea that probably comes to mind at this point is to use yet another
    queue. However, in this case, it’s not convenient. Queues are great when you want
    to trigger a certain process as soon as data is in the queue – in other words,
    they are ideal for event-driven processes. But market position or equity values
    do not trigger any process by themselves: they are only used by various components
    of the trading app as auxiliary values. Therefore, instead of a queue, we will
    create an object that will store all the required data about the implemented trading
    strategy and share this object across all components of our trading app.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时可能首先想到的想法是再使用另一个队列。然而，在这种情况下，这并不方便。当您希望数据进入队列后立即触发某个过程时，队列是非常好的——换句话说，它们非常适合事件驱动的过程。但是，市场位置或权益值并不会自行触发任何过程：它们只是被交易应用的各种组件作为辅助值使用。因此，我们不会使用队列，而是创建一个对象来存储关于实施交易策略的所有必要数据，并将此对象共享给交易应用的所有组件。
- en: 'This object can contain any strategy metadata, such as market position, equity
    time series (see below), running PnL, realized profit or loss, various statistical
    metrics, and so on:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象可以包含任何策略元数据，例如市场位置、权益时间序列（见下文）、运行PnL、实现利润或损失、各种统计指标等：
- en: '![Figure 11.3 – Prototype of an object that stores trading strategy metadata](img/B19145_11_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 存储交易策略元数据的对象原型](img/B19145_11_03.jpg)'
- en: Figure 11.3 – Prototype of an object that stores trading strategy metadata
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 存储交易策略元数据的对象原型
- en: 'Last price means the quote received with the previous tick (or bar) and it
    serves to calculate the running PnL between two ticks (or bars): if the position
    is *long* and the price has *increased*, then the running PnL has also *increased*,
    if the position is *short* and the price has *decreased*, then the running PnL
    nevertheless *increased*, and so on. If we sum all changes in the running PnL
    on every tick or bar from the moment when the strategy started until the present,
    then we will get the overall profit and loss, which is frequently referred to
    by traders as **equity**. This is a bit of professional slang because formally,
    the equity is the value attributable to the owners of a business (see, for example,
    [https://corporatefinanceinstitute.com/resources/valuation/equity/](https://corporatefinanceinstitute.com/resources/valuation/equity/)
    for details), but in algo trading, *equity* frequently means just the realized
    profit and loss, plus the value of the open position.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后价格指的是与上一个tick（或bar）收到的报价，它用于计算两个tick（或bar）之间的运行损益：如果头寸是*多头*且价格*上涨*，则运行损益也*增加*，如果头寸是*空头*且价格*下跌*，则运行损益仍然*增加*，依此类推。如果我们从策略开始到现在的每个tick或bar的运行损益变化进行汇总，那么我们将得到总损益，这通常被交易者称为**权益**。这是一个有点专业术语的词汇，因为正式来说，权益是归因于企业所有者的价值（例如，参见[https://corporatefinanceinstitute.com/resources/valuation/equity/](https://corporatefinanceinstitute.com/resources/valuation/equity/)以获取详细信息），但在算法交易中，*权益*通常只指实现的损益，加上未平仓头寸的价值。
- en: 'We can also save the equity value on each tick or bar, thus creating a time
    series. This time series is normally referred to as the equity curve and works
    as the most common illustration of the trading strategy’s performance: the way
    the strategy behaved in the past and when and how much money it made (or lost).
    This information can also be used by the trading logic, along with market price
    data and market position.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在每个tick或bar上保存权益价值，从而创建一个时间序列。这个时间序列通常被称为权益曲线，它是交易策略性能最常见的说明：策略过去的表现以及何时以及赚了多少钱（或亏损）。这些信息也可以由交易逻辑使用，连同市场价格数据和市场头寸。
- en: 'We also included two money management-related parameters: **initial capital**
    and **leverage**. These values can be used to check if we have sufficient funds
    to trade and also to determine the actual trading size for our orders.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了两个与资金管理相关的参数：**初始资本**和**杠杆**。这些值可以用来检查我们是否有足够的资金进行交易，也可以用来确定我们订单的实际交易规模。
- en: 'Now that we’ve added such a universal object that transfers strategy metadata
    between the trading logic and the order execution component, we can add the trading
    logic component to our architectural diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个在交易逻辑和订单执行组件之间传输策略元数据的通用对象，我们可以将交易逻辑组件添加到我们的架构图中：
- en: '![Figure 11.4 – Trading logic and common trading strategy parameters container](img/B19145_11_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 交易逻辑和常见交易策略参数容器](img/B19145_11_04.jpg)'
- en: Figure 11.4 – Trading logic and common trading strategy parameters container
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 交易逻辑和常见交易策略参数容器
- en: The last mandatory component to be added is the order execution component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的最后一个强制性组件是订单执行组件。
- en: Order execution component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单执行组件
- en: 'This component not only implements an ordering interface with the broker or
    emulates the execution of orders locally. It will also do some basic analysis
    of the strategy’s performance – for the needs of the trading logic. It should
    process the order, send it to a broker or emulate it locally, receive the execution
    status, process this status (for example, if the order was rejected, decide what
    to do: cancel or submit again), calculate the running PnL, and build the equity
    curve. Let’s add it to our diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件不仅实现了与经纪商的订单接口或本地模拟订单执行，它还将对策略性能进行一些基本分析——以满足交易逻辑的需求。它应该处理订单，将其发送给经纪商或本地模拟，接收执行状态，处理此状态（例如，如果订单被拒绝，决定如何操作：取消或再次提交），计算运行中的损益，并构建权益曲线。让我们将其添加到我们的图中：
- en: '![Figure 11.5 – Order execution control module and its interaction with the
    trading strategy properties object](img/B19145_11_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 订单执行控制模块及其与交易策略属性对象的交互](img/B19145_11_05.jpg)'
- en: Figure 11.5 – Order execution control module and its interaction with the trading
    strategy properties object
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 订单执行控制模块及其与交易策略属性对象的交互
- en: Let’s see how it works. First, we receive an order or orders from the order
    queue. These orders were generated and put into the queue by the trading logic.
    Then, we send an order to the broker or emulate its execution locally and receive
    the order status. If the order was executed, then we update the PnL and add another
    data point to the equity time series. If the order was rejected, we return it
    to the order queue and the whole process starts over automatically.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。首先，我们从订单队列中接收一个或多个订单。这些订单是由交易逻辑生成并放入队列中的。然后，我们将订单发送给经纪人或本地模拟其执行并接收订单状态。如果订单已执行，则更新损益并添加另一个数据点到股本时间序列。如果订单被拒绝，我们将它返回到订单队列，整个过程将自动重新开始。
- en: Note that the strategy metadata (market position, equity, and so on) is updated
    with every processed order. This ensures the ultimate precision in making trading
    decisions and controlling the actual market exposure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，策略元数据（市场位置、股本等）会随着每笔处理过的订单进行更新。这确保了在做出交易决策和控制实际市场敞口时的最终精度。
- en: Great! We now have a general view of the entire trading app architecture. And
    the most pleasant thing is that it is split into small, relatively simple components.
    We know how these components should communicate with each other, we know the data
    formats, and we know the sequence in which they should operate, so it seems we
    know everything we need to implement a trading application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在对整个交易应用架构有一个全面的了解。最令人愉快的是，它被分割成小而相对简单的组件。我们知道这些组件应该如何相互通信，我们知道数据格式，也知道它们应该按什么顺序操作，所以似乎我们知道了实现交易应用所需的一切。
- en: But before we start coding, I’d like to emphasize two advantages of the suggested
    architecture that are very hard to overvalue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始编码之前，我想强调一下建议的架构的两个优势，这两个优势非常难以高估。
- en: Advantages of the modular architecture
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化架构的优势
- en: First of all, this architecture makes sure that **your trading app will never
    peek ahead** during the research phase (while using historical data). At this
    point, I recommend that you refresh your memory regarding peeking ahead, which
    was considered in detail in [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073), *Trading
    Application – What’s Inside?*, in the *Trading logic – this is where a small mistake
    may cost a fortune* section – I am sure you will appreciate the suggested architecture
    of our trading app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种架构确保了**你的交易应用在研究阶段（使用历史数据时）永远不会提前查看**。在此阶段，我建议你刷新一下关于提前查看的记忆，这在[*第4章*](B19145_04.xhtml#_idTextAnchor073)，*交易应用
    – 内部结构是什么？*，*交易逻辑 – 这里的一个小错误可能代价巨大*部分中进行了详细讨论——我相信你会欣赏我们交易应用建议的架构。
- en: 'Second, this architecture provides for a flexible modular code that conforms
    to the concept of a universal trading application: you can quickly switch data
    sources and trading venues and use the same application both for research and
    production.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这种架构提供了一种灵活的模块化代码，符合通用交易应用的概念：你可以快速切换数据源和交易场所，并使用相同的应用程序进行研究和生产。
- en: 'It seems like we have covered everything we need to start coding our first
    trading application. However, there is one point of extreme importance that is
    surprisingly too frequently missed by so many developers: the problem of thread
    synchronization. To understand this problem and find out the right solutions to
    it, let’s do a brief **lyrical digression** about multithreading.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经涵盖了开始编写我们的第一个交易应用所需的所有内容。然而，有一个极端重要的问题却经常被许多开发者忽视：线程同步的问题。为了理解这个问题并找到正确的解决方案，让我们简要地**抒情地**谈谈多线程。
- en: Multithreading – convenient but full of surprises
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程 – 方便但充满惊喜
- en: We already worked with multithreading (see [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, the *Universal data connector*
    section), and we found that using multiple threads makes life way easier when
    we develop modular scalable applications. However, we never explored how multithreading
    is implemented in Python.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用多线程（参见[*第5章*](B19145_05.xhtml#_idTextAnchor086)，*使用Python检索和处理市场数据*，*通用数据连接器*部分），我们发现当开发模块化可扩展的应用程序时，使用多个线程会使生活变得容易得多。然而，我们从未探索过Python中多线程的实现方式。
- en: 'Two concepts are frequently confused: **multiprocessing** and **multithreading**.
    The difference between them is that the former uses the concept of isolated processes,
    each of them having a **global interpreter lock** (**GIL**), thus enabling parallel
    execution using separate physical or logical processors or processor cores (so-called
    **true parallelism**), whereas the latter runs a single process that doesn’t care
    about the number of processors or cores: it executes threads in small portions,
    allowing each thread to run for several milliseconds and then switching to another
    one. Of course, from a human perspective, it does look like processes are running
    in parallel. In most cases, we don’t even think about which thread is executed
    at which moment. But when implementing event-driven processes, it becomes critical
    to know what happens first: for example, if we try to generate an order before
    market data is received, it may end with an error in the best case.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 两个概念经常被混淆：**多进程** 和 **多线程**。它们之间的区别在于前者使用隔离进程的概念，每个进程都有一个 **全局解释器锁**（**GIL**），从而能够使用单独的物理或逻辑处理器或处理器核心（所谓的
    **真正并行**）来启用并行执行，而后者运行一个不关心处理器或核心数量的单个进程：它以小部分执行线程，允许每个线程运行几毫秒，然后切换到另一个线程。当然，从人类的角度来看，它看起来像进程是并行运行的。在大多数情况下，我们甚至不会考虑哪个线程在何时执行。但在实现事件驱动进程时，了解先发生什么变得至关重要：例如，如果我们试图在收到市场数据之前生成订单，最坏的情况可能会导致错误。
- en: 'To learn how real multithreading works, let’s write some simple code with three
    threads emulating the respective components of our trading application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解真正的多线程是如何工作的，让我们编写一些简单的代码，使用三个线程来模拟我们的交易应用的相关组件：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we start the threads one by one (1, 2, and then 3), we may expect to
    see messages stating `Receive data`, `Trading logic`, and `Processing orders`
    and repeating in this same order. However, when we run the code, we will see something
    different:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是逐个启动线程的（1、2，然后是3），我们可能会看到显示“接收数据”、“交易逻辑”和“处理订单”的消息，并按此顺序重复。然而，当我们运行代码时，我们会看到一些不同的情况：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that while on average the number of messages of each kind is more
    or less the same, the order in which they appear is almost random, making the
    output chaotic. This happens because, by default, no thread has any priority and
    each runs a small portion as soon as it can.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管每种类型消息的平均数量大致相同，但它们出现的顺序几乎是随机的，使得输出变得混乱。这是因为默认情况下，没有任何线程有优先级，每个线程一旦有机会就会运行一小部分。
- en: 'Of course, such a behavior is not suitable for a trading app: we want to make
    sure that we first receive a tick, then process it, then generate an order, and
    finally send it for execution – in this very order and not any other!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的行为不适合交易应用：我们想确保首先接收tick数据，然后处理它，然后生成订单，最后将其发送执行 – 按照这个顺序，而不是其他任何顺序！
- en: 'There are several solutions to this problem. We will use two: using data streams
    as events for synching and using `threading.Event()` objects to switch between
    threads. We will consider each approach in detail in the upcoming sections.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几个方案。我们将使用两种：使用数据流作为同步的事件，以及使用 `threading.Event()` 对象在线程之间切换。我们将在接下来的章节中详细讨论每种方法。
- en: Let’s start by implementing a version of the trading app that works with live
    tick data, and then see how we can easily transform it into a powerful backtesting
    tool (if you don’t clearly remember the meaning of backtesting, just jump back
    to [*Chapter 2*](B19145_02.xhtml#_idTextAnchor028), *Using Python for Trading
    Strategies*, the *What is paper trading and* *backtesting?* section).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个与实时tick数据交互的版本交易应用，然后看看我们如何轻松地将它转换成一个强大的回测工具（如果你不记得回测的含义，只需跳回到 [*第2章*](B19145_02.xhtml#_idTextAnchor028)，*使用Python进行交易策略*，*什么是纸交易和*
    *回测？* 部分）。
- en: Trading application with live data feed
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有实时数据流的交易应用
- en: 'As always, we start by doing some imports:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先进行一些导入：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we create a class that contains the strategy metadata (see the *Trading
    logic* *component* section):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个包含策略元数据的类（参见 *交易逻辑* *组件* 部分）：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we prepare three (!) tick data queues:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备三个（！）tick数据队列：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Why three? This is one of the solutions to the thread synching problem explained
    in the *Multithreading – convenient but full of* *surprises* section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是三个？这是在 *多线程 – 方便但充满* *惊喜* 部分中解释的线程同步问题的一种解决方案。
- en: The first queue (`tick_feed_0`) connects the market data receiver with the ticks
    aggregation component, which forms bars. This component is activated every time
    a new tick is in the first queue. After the component has finished, it puts the
    same tick into the second queue (`tick_feed_1`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个队列（`tick_feed_0`）将市场数据接收器与tick聚合组件连接起来，该组件形成条形图。每次第一个队列中有新的tick时，该组件就会被激活。组件完成后，它将相同的tick放入第二个队列（`tick_feed_1`）。
- en: '`tick_feed_1` connects the ticks aggregator with the trading logic, and the
    trading logic is invoked only when there’s a new tick in `tick_feed_1`. But it
    may enter this queue only after the first component has finished working! So,
    trading logic cannot be invoked earlier than a new tick is processed. Then, similarly,
    the trading logic components put the same tick into the third queue (`tick_feed_2`).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick_feed_1` 将tick聚合器与交易逻辑连接起来，并且只有在`tick_feed_1`中有新的tick时才会调用交易逻辑。但它在第一个组件完成工作后才能进入这个队列！因此，交易逻辑不能在处理完新的tick之前被调用。然后，类似地，交易逻辑组件将相同的tick放入第三个队列（`tick_feed_2`）。'
- en: '`tick_feed_2` connects the trading logic with the order execution component,
    and this component is invoked no earlier than there’s a new tick in `tick_feed_2`.
    So, using three queues to connect components one to another ensures the correct
    sequence of operations.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick_feed_2` 将交易逻辑与订单执行组件连接起来，并且该组件只有在 `tick_feed_2` 中有新的tick时才会被调用。因此，使用三个队列将组件相互连接确保了操作的正确顺序。'
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This method of synching threads would work only if the interval between ticks
    is greater than the round trip time for all threads triggered by it to finish
    working. This is valid for most data feeds as normally, we receive no more than
    10 ticks per second, and the round trip processing time is typically around 0.0001
    seconds. This approach won’t work with heavy load exchange market data received
    via the `ITCH` protocol, which sometimes receives over 10,000 ticks per second.
    However, this is specific to institutional trading and we don’t consider solutions
    of this kind in this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同步线程的方法只有在tick之间的间隔大于由它触发的所有线程完成工作的往返时间时才会有效。这对于大多数数据源都是有效的，因为我们通常每秒接收不到10个tick，往返处理时间通常在0.0001秒左右。这种方法不适用于通过`ITCH`协议接收的重负载交易所市场数据，它有时每秒接收超过10,000个tick。然而，这仅限于机构交易，我们在这本书中不考虑此类解决方案。
- en: 'Next, we must add a queue to process aggregated market data (`bar_feed`), a
    queue to store orders (`orders_stream`), create an instance of the system metadata
    class, and specify the parameters required to connect to a data feed (in our example,
    we use `LMAX` as the source of market data):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加一个队列来处理聚合的市场数据（`bar_feed`），一个队列来存储订单（`orders_stream`），创建系统元数据类的实例，并指定连接到数据源所需的参数（在我们的例子中，我们使用`LMAX`作为市场数据源）：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can reuse the code that we developed in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130),
    *Data Visualization in FX Trading with Python*, in the *Plotting live tick* *data*
    section:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在*Plotting live tick data*部分重用我们在[*第8章*](B19145_08.xhtml#_idTextAnchor130)，*使用Python进行外汇交易中的数据可视化*中开发的代码：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have to put the tick into the first tick queue. But before we do that,
    we have to check the consistency of the received market data. We discussed non-market
    prices in [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014), *Developing Trading
    Strategies – Why They Are Different*, so let’s just quickly refresh it: a non-market
    price is *too far* from the market. Of course, sometimes, it’s difficult to judge
    whether it is *too far* or *not so far*, but in essence, we can at least filter
    out ticks in which the difference between the bid and ask (also known as spread)
    is several times greater than normal. Events of this sort are quite infrequent,
    but I was lucky to capture one of these moments while plotting tick charts (see
    [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130), *Data Visualization in FX Trading
    with Python*). The following figure illustrates such a *bad tick* in which the
    bid is way lower than it should be:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将tick放入第一个tick队列。但在这样做之前，我们必须检查接收到的市场数据的一致性。我们在[*第1章*](B19145_01.xhtml#_idTextAnchor014)中讨论了非市场价格，*《开发交易策略
    – 为什么它们不同*》，所以让我们快速回顾一下：非市场价格*太远*于市场价格。当然，有时很难判断它是*太远*还是*不太远*，但本质上，我们至少可以过滤掉那些买卖价差（也称为价差）比正常情况下大几倍的tick。这类事件相当罕见，但我幸运地捕捉到了在绘制tick图表时（见[*第8章*](B19145_08.xhtml#_idTextAnchor130)，*使用Python进行外汇交易中的数据可视化*）的一个这样的时刻。以下图展示了这样一个*不良tick*，其买入价远低于应有的水平：
- en: '![Figure 11.6 – Non-market price](img/B19145_11_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 非市场价格](img/B19145_11_06.jpg)'
- en: Figure 11.6 – Non-market price
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 非市场价格
- en: 'To filter out at least bad ticks of this sort, let’s add a simple check: if
    the spread is greater than 10 pips, then skip this tick:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤掉至少这种类型的坏tick，让我们添加一个简单的检查：如果价差大于10点，则跳过这个tick：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we need to implement the ticks aggregator. In our example, let’s form
    10-second bars so that we can test our app and check if everything works correctly
    faster (without waiting for 1 minute or 1-hour bars to complete).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现tick聚合器。在我们的例子中，让我们形成10秒的条形图，这样我们可以更快地测试我们的应用程序并检查一切是否正常工作（而不必等待1分钟或1小时的条形图完成）。
- en: We will use only bid data to form bars for simplicity. Why is this possible?
    Because most of the time (except for the time around important news releases,
    bank settlement time, and the end/beginning of the week), the spread (the difference
    between the bid and ask) is more or less constant. So, if we want to emulate the
    real execution of orders, then we can use real bid and ask in the tick data stream,
    but for the trade logic, we can use bars built with only one price. Of course,
    for strategies of a certain kind, such as arbitrage, both bid and ask data are
    essential (and sometimes last trade along with the two), but now, we’re building
    a prototype that you will be able to customize the way you want when you are familiar
    with the approach in general.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅使用市价数据来形成条形图以简化问题。为什么这是可能的呢？因为大多数时候（除了重要新闻发布、银行结算时间以及一周的开始/结束时段），价差（买价和卖价之间的差异）或多或少是恒定的。因此，如果我们想模拟订单的实际执行，那么我们可以使用实时买价和卖价在tick数据流中，但对于交易逻辑，我们可以使用仅使用一个价格的条形图。当然，对于某些策略，如套利，买价和卖价数据都是必不可少的（有时还包括最后成交价和这两个价格），但现在，我们正在构建一个原型，当你熟悉一般方法时，你将能够自定义你想要的方式。
- en: 'For aggregating ticks into bars, we used almost the same code from [*Chapter
    8*](B19145_08.xhtml#_idTextAnchor130), *Data Visualization in FX Trading with
    Python*, in the *Plotting live tick data* section, so not much commenting is required
    here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在将tick聚合到条形图中时，我们几乎使用了与[*第8章*](B19145_08.xhtml#_idTextAnchor130)中相同的代码，*使用Python进行外汇交易数据可视化*，在*实时tick数据绘图*部分，因此这里不需要太多的注释：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created a bar, received a tick, and updated the bar’s high, low, and close
    values. Now, as soon as the time since the bar’s open is greater than or equal
    to 10 seconds, we start a new bar:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个条形图，收到了一个tick，并更新了条形图的高、低和收盘价。现在，一旦条形图开盘以来的时间大于或等于10秒，我们就开始一个新的条形图：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note the last line of this function. It puts the same tick that’s received
    into `tick_feed_1`. This is done to trigger the next component, the trading logic:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数的最后一行。它将收到的相同tick放入`tick_feed_1`。这样做是为了触发下一个组件，即交易逻辑：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, it’s time to add some trading logic.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加一些交易逻辑了。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For testing purposes, we don’t care whether our test strategy is profitable
    or not – we only want to generate as many orders as possible to watch the emulated
    execution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试目的，我们不在乎我们的测试策略是否盈利——我们只想尽可能多地生成订单来观察模拟执行。
- en: 'So, let’s implement the following simple logic:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现以下简单的逻辑：
- en: If the bar closes up (`close > open`), then sell
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条形图收盘价上涨（`close > open`），则卖出
- en: If the bar closes down (`close < open`), then buy
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条形图收盘价下跌（`close < open`），则买入
- en: 'With this "*strategy"*, we may expect many orders to be generated quickly,
    so we will be able to test our app without waiting for too long:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个"*策略*"，我们可能预期会快速生成许多订单，因此我们将能够测试我们的应用程序而无需等待太久：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are checking that the bar’s closing price is greater than `Open` and
    also that the current consolidated market position is positive. We’re doing this
    because we don’t want to open multiple positions in the same direction. In other
    words, if we are already long in the market, we only wait for a short position
    to open, and vice versa:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查条形图的收盘价是否高于`开盘价`，并且当前的综合市场位置是正的。我们这样做是因为我们不希望在同一个方向上打开多个仓位。换句话说，如果我们已经在市场上做多，我们只等待一个做空仓位打开，反之亦然：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following `if...else` statement checks whether we are opening the position
    for the first time. If we are, then we don’t have any current market position
    at the time of order generation, so in our example, the trading size is 10,000\.
    But if there is already an open position and we want to open a new position in
    the opposite direction, then *we should first close the existing position* and
    *then open the new one*, which effectively requires twice the trading size. We
    have to use `10000` to close and `10000` to open a new position, which means a
    trading size of 2 * 10,000 = 20,000:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `if...else` 语句检查我们是否是第一次开仓。如果是，那么在订单生成时我们没有任何当前市场仓位，所以在我们的例子中，交易量是 10,000。但如果已经有一个开仓，并且我们想要在相反方向上开一个新仓，那么*我们首先应该关闭现有仓位*，然后*再开新仓*，这实际上需要两倍的交易量。我们必须用
    `10000` 来关闭，用 `10000` 来开新仓，这意味着交易量是 2 * 10,000 = 20,000：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we must put the order into the order queue:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将订单放入订单队列：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we must do exactly the opposite for the buy order:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须对买入订单做完全相反的操作：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why do we use 10,000 base currency as the trading size?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用10,000作为基础货币的交易量？
- en: If we trade EURUSD, a currency pair quoted with 4 or 5 digits, then buying or
    selling 10,000 euro (see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX
    Market Overview from a Developer’s Standpoint*, the *Naming conventions* section)
    would mean that 1 pip costs $1\. Therefore, we can interpret the results of our
    tests both as in money and in pips. Since the FX market is highly leveraged (see
    the same in the *Trade mechanics – again some terminology* section in [*Chapter
    3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview from a Developer’s
    Standpoint*), it’s more convenient to calculate all PnL in pips and then scale
    it using leverage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们交易EURUSD，一个报价为4或5位数的货币对，那么买入或卖出10,000欧元（见[*第3章*](B19145_03.xhtml#_idTextAnchor044)，*从开发者角度的FX市场概述*，*命名约定*部分）意味着1个点值是1美元。因此，我们可以将我们的测试结果既解释为金钱，也解释为点数。由于外汇市场高度杠杆化（见[*第3章*](B19145_03.xhtml#_idTextAnchor044)，*从开发者角度的FX市场概述*中的*交易机制-再次一些术语*部分），使用点数计算所有PnL更方便，然后使用杠杆进行缩放。
- en: 'Note that this function uses a `try...except` statement. The reason is that
    we use two queues: `tick_feed_1` to receive ticks and `bar_feed` to receive actual
    bars. However, ticks are only used in this function to trigger its execution (see
    the detailed explanation at the very beginning of this section), while bars are
    used to make actual trading decisions. The problem is that bars normally arrive
    far less frequently than ticks, so we can’t wait until there’s a bar in the `bar_feed`
    queue; otherwise, the normal execution of our app would be interrupted. That’s
    why we use the `block = False` attribute when reading from the `bar_feed` queue.
    However, if there’s a new tick in `tick_feed_1`, but there’s no bar in `bar_feed`,
    then the attempt to read from there would raise an exception. Therefore, we catch
    this exception and – in our current implementation – just do nothing, waiting
    for a new bar to arrive in the queue.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数使用了一个 `try...except` 语句。原因是，我们使用了两个队列：`tick_feed_1` 用于接收tick，`bar_feed`
    用于接收实际的bar。然而，tick只在这个函数中用于触发其执行（见本节开头详细解释），而bar用于做出实际的交易决策。问题是，bar通常比tick到达的频率低得多，所以我们不能等到
    `bar_feed` 队列中有bar；否则，我们应用程序的正常执行会被中断。这就是为什么我们在从 `bar_feed` 队列中读取时使用 `block =
    False` 属性。然而，如果 `tick_feed_1` 中有一个新的tick，但 `bar_feed` 中没有bar，那么尝试从那里读取会引发异常。因此，我们捕获这个异常，在我们的当前实现中，只是什么也不做，等待队列中出现新的bar。
- en: 'The final component of our trading app is order execution. We invoke this function
    by a tick received in `tick_feed_2`, where it’s put by `tradeLogic()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交易应用程序的最终组件是订单执行。我们通过在 `tick_feed_2` 中接收到的tick来调用这个函数，它是由 `tradeLogic()` 放入的：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With every received tick, we update the equity value of the trading system.
    Remember that *equity* in traders’ slang means the sum of all PnL values calculated
    on each tick or bar. If we have a long position and the current price is greater
    than the previous price, then the equity value increases on this tick/bar. The
    opposite is also true: if we have a short position and the current price is less
    than the previous price, then the equity value also increases on this tick/bar.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收到tick，我们都会更新交易系统的权益价值。记住，在交易者的行话中，“权益”是指在每个tick或bar上计算的所有PnL值的总和。如果我们持有多头仓位，并且当前价格高于前一个价格，那么在这个tick/bar上的权益价值会增加。相反的情况也是成立的：如果我们持有空头仓位，并且当前价格低于前一个价格，那么在这个tick/bar上的权益价值也会增加。
- en: 'I believe you’ve got it: if we’re long and the price decreases or if we’re
    short and the price increases, then the equity decreases on this tick or bar.
    To calculate the actual equity value on the current tick, we multiply the difference
    in price between the current and the previous ticks by the market position value:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经明白了：如果我们是多头，价格下降，或者如果我们是空头，价格上升，那么在这个tick或bar上，权益会减少。为了计算当前tick的实际权益值，我们将当前tick和前一个tick之间的价格差异乘以市场头寸的价值：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we start scanning the order queue and executing orders as they appear
    there. Note that we again use the `block = False` attribute, so we never wait
    for an order in the order queue: if there’s no order by the time a new tick is
    received, we just go ahead and proceed with the main loop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始扫描订单队列，并按照它们出现的顺序执行订单。请注意，我们再次使用`block = False`属性，所以我们永远不会在订单队列中等待订单：如果在收到新的tick之前没有订单，我们就继续进行主循环：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we’ve received an order, we should do the risk management check: whether
    we have sufficient funds to execute this order. To calculate the available funds,
    we should add the current equity (positive or negative) to the initial capital
    and subtract the margin required for the currently open market position, which
    is the value of this market position divided by the leverage:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收到订单后，我们应该进行风险管理检查：是否有足够的资金执行这个订单。为了计算可用资金，我们应该将当前权益（正或负）加到初始资本上，并减去目前开放市场头寸所需的保证金，即这个市场头寸的价值除以杠杆率：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to calculate available funds
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如何计算可用资金
- en: The calculation of available funds that we are using in our code is not 100%
    correct. The problem is that it is possible to have a huge position in the market
    with some positive running PnL. In this case, our formula would say we have sufficient
    funds, but in reality, until this huge position is closed, we may not have enough
    money in the trading account. So, to be perfectly precise with this calculation,
    we should have introduced yet another variable to the system metadata that would
    account only for realized PnL (calculated by closed positions). However, we are
    not going to do this now, again for simplicity and transparency’s sake.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用可用资金的计算并不完全正确。问题是，在市场上有可能持有巨大的头寸，同时有一些正的运行PnL。在这种情况下，我们的公式会表明我们有足够的资金，但事实上，直到这个巨大的头寸关闭，我们的交易账户可能没有足够的钱。所以，为了使这个计算完全精确，我们应该向系统元数据中引入另一个变量，它只计算已实现的PnL（通过关闭的头寸计算）。然而，我们现在不会这样做，为了简单和透明起见。
- en: 'Now, if the order size is less than the available funds in the trading account,
    we can execute the order. A bit later, we will write a separate function that
    emulates the order execution. In production, this function can be replaced by
    an actual call to the broker’s API:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果订单大小小于交易账户中的可用资金，我们可以执行订单。稍后，我们将编写一个单独的函数来模拟订单执行。在生产环境中，这个函数可以被替换为对经纪商API的实际调用：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After attempting to execute the order, its status is changed either to `''Executed''`
    or `''Rejected''` (or any other status returned by your broker), so let’s decide
    what to do with it. Of course, if the order was successfully executed, we only
    update the strategy metadata (and print the result for testing purposes):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试执行订单后，其状态会变为`'Executed'`或`'Rejected'`（或任何其他由你的经纪商返回的状态），所以让我们决定如何处理它。当然，如果订单成功执行，我们只更新策略元数据（并打印结果以供测试）：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the order was rejected, we return it to the same order queue:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单被拒绝，我们将它返回到同一个订单队列：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, let me reiterate that, in reality, you may need more complex order handling,
    but it will depend on both the type of strategy you’re going to run and the types
    of order statuses provided by your broker.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在现实中，你可能需要更复杂的订单处理，但这将取决于你将要运行的策略类型以及你的经纪商提供的订单状态类型。
- en: 'Finally, we will just add the `except` clause so that nothing happens if there’s
    no order in the order queue:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加`except`子句，以便在没有订单在订单队列中的情况下不发生任何事情：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’re almost there! All we need to add now is the function that emulates the
    order execution at the broker. For the first version of our emulator, we will
    implement only the execution of market orders:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！现在我们只需要添加一个模拟经纪商订单执行的函数。对于我们的模拟器第一个版本，我们将只实现市场订单的执行：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It’s time for the final preflight check: making sure the market has sufficient
    liquidity before sending the order!'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行最后的预飞检查了：在发送订单之前确保市场有足够的流动性！
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Don’t confuse bids and asks! If we buy, we check the liquidity at the offer
    (ask) and execute at the ask price, while if we sell, we use bids:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆买价和卖价！如果我们买入，我们检查出价（卖价）的流动性并在卖价处执行，而如果我们卖出，我们使用买价：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s review the components of the trading application we have added so
    far:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们迄今为止添加的交易应用组件：
- en: Strategy metadata object (`class tradingSystemMetadata`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易系统元数据对象（`class tradingSystemMetadata`）
- en: Queues for price data and orders (`tick_feed_0`, `tick_feed_1`, `tick_feed_2`,
    `bar_feed`, and `orders_stream`)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格数据和订单的队列（`tick_feed_0`，`tick_feed_1`，`tick_feed_2`，`bar_feed`和`orders_stream`）
- en: A function that connects to the data source (`LMAX_connect(url, subscription_msg)`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个连接数据源的功能（`LMAX_connect(url, subscription_msg)`）
- en: A function that forms bars from ticks (`getBarRealtime()`)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从刻度生成条形图的功能（`getBarRealtime()`）
- en: A function that makes trading decisions (`tradeLogic()`)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个做出交易决策的功能（`tradeLogic()`）
- en: A function that processes orders (`processOrders()`)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理订单的功能（`processOrders()`）
- en: A function that emulates order execution at the broker (`emulateBrokerExecution(tick,
    order)`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在经纪人处模拟订单执行的功能（`emulateBrokerExecution(tick, order)`）
- en: 'All we have to add to the very end of our code is a block that initializes
    and starts all four threads:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在我们的代码最后添加一个初始化并启动所有四个线程的块：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have just developed our first trading app! It’s time to run it and check
    if it’s doing what we expect. I will run it and wait until the second order is
    executed (because I want to make sure that I submit correct orders both in case
    the strategy has an open position in the market and in case there’s no open position).
    If you repeated all these steps correctly, you should see an output like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开发出了我们的第一个交易应用！现在是时候运行它并检查它是否如我们所期望的那样工作。我会运行它并等待第二个订单执行（因为我想要确保在策略在市场上有一个开仓位置以及没有开仓位置的情况下，我都提交了正确的订单）。如果你正确地重复了所有这些步骤，你应该会看到以下输出：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We started at `12:03:20`, so we received nine ticks (remember, LMAX doesn’t
    send actual ticks, but 1-second snapshots of market data). At the 10th second,
    we form a bar:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`12:03:20`开始，所以收到了九个刻度（记住，LMAX不发送实际的刻度，而是市场数据的1秒快照）。在第10秒，我们形成一个条形图：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The bar’s close is greater than the bar’s open, so according to our test strategy
    logic, it is a signal to sell – and indeed, there’s an order that immediately
    follows the bar:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 条形的收盘价高于条形的开盘价，因此根据我们的测试策略逻辑，这是一个卖出信号——而且确实，有条形图紧随其后：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that the order size is `10000` because we opened the position for the
    very first time and we don’t have open positions in the market yet. We check the
    10th tick to make sure that its price equals the closing price of the bar and
    the order price:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，订单大小是`10000`，因为我们刚刚第一次开仓，我们在市场上还没有任何开仓。我们检查第10个刻度以确保其价格等于条形的收盘价和订单价格：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can see the execution report:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到执行报告：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So far, so good. Let’s wait for the next bar to form:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们等待下一个条形图的形成：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’re lucky: the very next bar closed in the opposite direction (close is less
    than open), so it’s time to generate a buy order:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运：紧接着的下一个条形图以相反的方向收盘（收盘价小于开盘价），所以是时候生成一个买入订单了：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that the order size this time is `20000`: we need to close the currently
    open position of `10000` and then open a new one with the remaining `10000`. Let’s
    check the tick price to make sure that the bar’s closing price and the order price
    are correct:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次订单大小是`20000`：我们需要关闭目前`10000`的开仓，然后使用剩余的`10000`开一个新仓。让我们检查刻度价格以确保条形的收盘价和订单价格是正确的：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great, everything looks good. Now, let’s proceed to order execution...
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，一切看起来都很正常。现在，让我们继续进行订单执行...
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Stop. What’s that? The last tick’s price was `1.05665`, but the order is executed
    at `1.05672`! Why?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 停止。那是什么？最后一个刻度的价格是`1.05665`，但订单是在`1.05672`执行的！为什么？
- en: This happens because we form bars using only bid prices and execute orders at
    actual market prices – bid for sell orders and ask for buy orders. The first order
    was a sell, so we used the bid price and all prices (bar, tick, order, and execution)
    coincided. But the second order was a buy, but we still used only the bid price
    to form a bar – that’s why we had the execution price greater than the bar’s closing
    price.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们只使用买价形成条形图，并在实际市场价格处执行订单——卖价订单使用买价，买价订单使用卖价。第一个订单是卖出，所以我们使用了买价，所有价格（条形图、刻度、订单和执行）都一致。但第二个订单是买入，但我们仍然只使用买价来形成条形图——这就是为什么执行价格大于条形的收盘价。
- en: The importance of market spread
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 市场价差的重视
- en: This issue perfectly illustrates the importance of taking spread (the difference
    between the bid and ask prices) into consideration when running tests. So many
    developers forget about it and run their testing using only bid prices – for simplicity,
    you know. These tests are not adequate for the real market, and quite frequently
    generate trade logic that is profitable only when you can buy and sell at the
    same price, effectively assuming the spread to be zero at all times. Now, you
    know how to avoid this trap and make sure your tests are always realistic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题完美地说明了在运行测试时考虑价差（买价和卖价之间的差异）的重要性。所以许多开发者忘记了这一点，只用买价进行测试 - 你知道，为了简单起见。这些测试不足以反映真实市场，而且经常产生只有在你能以相同价格买卖时才盈利的交易逻辑，实际上是在任何时候都假设价差为零。现在，你知道如何避免这个陷阱并确保你的测试始终是现实的。
- en: 'Before we move on, let’s quickly review our code and see whether it meets the
    requirements outlined in [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014), *Developing
    Trading Strategies – Why They* *Are Different*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们快速回顾一下我们的代码，看看它是否符合在[*第一章*](B19145_01.xhtml#_idTextAnchor014)中概述的要求，*开发交易策略
    - 为什么它们* *不同*：
- en: It filters the incoming tick data feed and excludes non-market prices
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它过滤传入的tick数据流并排除非市场价格
- en: It is event-driven – it generates and executes orders as soon as the trade logic
    confirms a trade
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是事件驱动的 - 一旦交易逻辑确认交易，它就会生成并执行订单
- en: It does some basic risk management checks – position size, leverage, and available
    funds
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它进行一些基本的风险管理检查 - 仓位大小、杠杆和可用资金
- en: It is capable of emulating bad order execution and handling these situations
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够模拟不良订单执行并处理这些情况
- en: 'And probably the main benefit: this code will never – never! – peek ahead,
    neither in testing nor in production (see [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073),
    *Trading Application – What’s Inside?*, the *Trading logic – this is where a small
    mistake may cost a* *fortune* section)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且可能是主要的好处：这段代码永远不会 - 永远不会！ - 窥视未来，无论是在测试中还是在生产中（参见[*第四章*](B19145_04.xhtml#_idTextAnchor073)，*交易应用
    - 它里面有什么？*，*交易逻辑 - 这里的一个小错误可能会造成* *巨大的损失*部分）
- en: So, we have developed a robust application suitable for serious production!
    Of course, it can be improved further, but its core will remain almost unchanged.
    However, we don’t have a tested strategy to run. How can we develop such a strategy?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经开发了一个适合严肃生产的健壮应用程序！当然，它可以进一步改进，但它的核心几乎不会改变。然而，我们没有经过测试的策略来运行。我们如何开发这样的策略？
- en: This is when we can use the concept of backtesting, which we mentioned earlier,
    almost at the beginning of this book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这时我们可以使用我们之前提到的回测概念，几乎是在这本书的开头。
- en: Backtesting – speeding up the research
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测 - 加速研究过程
- en: 'The process of developing a trading strategy (I mean the trading logic, not
    the application) is an infinite loop:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 开发交易策略的过程（我的意思是交易逻辑，而不是应用程序）是一个无限循环：
- en: Suggest a hypothesis.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出一个假设。
- en: Code it.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码。
- en: Run a test.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: If the result is not satisfactory, tweak the parameters and repeat.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果不满意，调整参数并重复。
- en: If nothing helps, look for an alternative hypothesis.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果什么都没有帮助，寻找一个替代假设。
- en: 'The question is: what kind of application shall we use for testing in *step
    3*?'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：在*第3步*中，我们应该使用哪种应用程序进行测试？
- en: Of course, we could use our existing trading app, draft some strategy logic,
    and then run it in test mode, as we’ve just done, collecting orders and analyzing
    the equity time series. But then a single test may take days, weeks, and even
    months if we want to test the strategy under different market conditions. Do you
    think it’s a bit too long? I agree. That’s why, for research and development purposes,
    we use backtesting.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用我们现有的交易应用，草拟一些策略逻辑，然后以测试模式运行它，就像我们刚才做的那样，收集订单并分析股票时间序列。但如果我们想在不同市场条件下测试策略，单个测试可能需要几天、几周甚至几个月。你认为这有点太长了？我同意。这就是为什么，出于研究和开发的目的，我们使用回测。
- en: 'We discussed backtesting in [*Chapter 2*](B19145_02.xhtml#_idTextAnchor028),
    *Using Python for Trading Strategies*, in the *Paper trading, and backtesting
    – an essential part of systemic trader’s risk management* section. In essence,
    instead of emulating the execution of orders using live data streams, we emulate
    the data stream itself using pre-saved historical market data. In this case, we
    can dramatically speed up the testing because computers can process dozens of
    thousands of ticks or bars per second, compressing months of live testing into
    minutes or seconds of backtesting. Of course, due to its nature, backtesting cannot
    guarantee the future performance of a strategy, just because it tests using past
    data. But regardless, it helps us understand the strategy’s behavior under various
    market conditions. Generally speaking, if a backtest shows that the emulated equity
    was mostly growing in the past, then we may suppose that it continues growing
    in the future, and vice versa: if we saw that the emulated equity was only decreasing
    over time, or oscillating around zero at best, then we should be very cautious
    with such a strategy as it’s hard to imagine why it would suddenly start making
    money when put to production.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B19145_02.xhtml#_idTextAnchor028)中讨论了回测，*使用Python进行交易策略*部分，在*纸交易和回测——系统交易员风险管理的重要组成部分*。本质上，我们不是使用实时数据流来模拟订单执行，而是使用预先保存的历史市场数据来模拟数据流本身。在这种情况下，我们可以显著加快测试速度，因为计算机可以每秒处理数十万个tick或柱状图，将数月的实时测试压缩到几分钟或几秒钟的回测中。当然，由于其本质，回测不能保证策略的未来表现，仅仅因为它使用过去的数据进行测试。但无论如何，它帮助我们了解策略在各种市场条件下的行为。一般来说，如果回测显示模拟的权益在过去大部分时间都在增长，那么我们可能会假设它将继续增长，反之亦然：如果我们看到模拟的权益随着时间的推移只呈下降趋势，或者最多在零点附近波动，那么我们应该非常谨慎地对待这种策略，因为它很难想象为什么它在投入生产后会突然开始赚钱。
- en: 'I hope you got the idea: we are going to run our code using saved data, not
    live, so we can process 1,000 or 10,000, or even more seconds of historical data
    in 1 second.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能理解我们的想法：我们将使用保存的数据而不是实时数据来运行我们的代码，这样我们就可以在1秒钟内处理1,000或10,000甚至更多的历史数据秒数。
- en: 'Now, I believe you will appreciate the approach we followed when developing
    our code: if you have pre-saved tick historical data, then *all you need to do
    is modify the only function* – the one that receives ticks from the data provider
    – and have it receive data from a local file.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我相信你会欣赏我们开发代码时采取的方法：如果你有预先保存的tick历史数据，那么你只需要修改一个函数——接收数据提供者提供的tick的那个函数——并让它从本地文件接收数据。
- en: That’s it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。
- en: Isn’t it impressive? Yes, you can use the same code for both research and production,
    thus reducing the probability of making an error to almost zero.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这不令人印象深刻吗？是的，你可以使用相同的代码进行研究和生产，从而将出错的可能性降低到几乎为零。
- en: 'However, you can’t always get hold of historical tick data. Moreover, for strategies
    that use bars with a higher time frame (such as 1 hour, 4 hours, 1 day, 1 week,
    and so on), it would be a waste of time waiting until our application forms each
    bar from ticks. So, we may want to make the following modifications to our code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你并不总是能获取到历史tick数据。此外，对于使用更高时间框架的策略（例如1小时、4小时、1天、1周等），等待我们的应用程序从tick中形成每个柱状图将是一种时间的浪费。因此，我们可能想要对我们的代码进行以下修改：
- en: It should now be able to read data from a local file instead of receiving it
    from a data vendor
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它现在应该能够从本地文件读取数据，而不是从数据供应商接收数据。
- en: It should be able to process already compressed data (bars) without receiving
    tick data at all
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该能够处理已经压缩的数据（柱状图），而无需接收任何tick数据。
- en: It should be able to emulate order execution, which may happen within the duration
    of a single bar (for example, if the strategy bases its logic on 1-hour bars,
    then we should be able to emulate order execution between hh:00 and hh:59, where
    hh stands for the hours’ value).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该能够模拟订单执行，这可能发生在单个柱状图（例如，如果策略的逻辑基于1小时柱状图，那么我们应该能够模拟hh:00和hh:59之间的订单执行，其中hh代表小时值）的持续时间之内。
- en: Looking at the architecture of our existing code, it seems like quite a straightforward
    task. However, there is one caveat.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们现有代码的架构，这似乎是一个相当直接的任务。然而，有一个需要注意的地方。
- en: Do you remember how we used tick data in the existing code? Yes, we aggregated
    it into bars, but besides that, ticks were served as a system clock that synchronized
    the components of the entire application. How do we synchronize them in case we
    don’t use tick data at all?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在现有代码中使用tick数据的方式吗？是的，我们将其聚合为条形图，但除此之外，tick数据还作为系统时钟为整个应用程序的组件提供同步。如果我们根本不使用tick数据，我们如何同步它们呢？
- en: Here, we can use another method of controlling the execution of threads – using
    events.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用另一种控制线程执行的方法——使用事件。
- en: Syncing threads using events
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件同步线程
- en: Let’s quickly jump back to the code that we drafted in the *Multithreading –
    convenient but full of surprises* section earlier in this chapter. The problem
    with that code was that each thread was running *when possible*, thus producing
    output at random to a certain degree. And we want all three threads to work one
    by one – `t1`, `t2`, `t3`, and then again `t1`, and so on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回到本章前面“多线程——方便但充满惊喜”部分中我们草拟的代码。那个代码的问题在于每个线程都在**可能**的时候运行，因此在一定程度上产生了随机的输出。而我们希望所有三个线程依次工作——`t1`、`t2`、`t3`，然后再次是`t1`，以此类推。
- en: The threading module in Python provides several very efficient methods to solve
    the problem of controlling threads. One of them is using `Event()` objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python的线程模块提供了几个非常高效的方法来解决控制线程的问题。其中之一是使用`Event()`对象。
- en: 'A `threading.Event()` object is placed inside the thread’s code and it works
    like a traffic light. It has two possible states: set or cleared. When the event
    is set, the thread works as normal. When the event is cleared, the thread stops.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`threading.Event()`对象被放置在线程的代码中，它就像交通灯一样工作。它有两种可能的状态：设置或清除。当事件被设置时，线程正常工作。当事件被清除时，线程停止。
- en: Besides just clearing and setting the events, it is possible to instruct the
    thread to *wait* until the event is set. In this case, the thread waits for the
    event and as soon as it’s set again, it resumes working.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了清除和设置事件之外，还可以指示线程**等待**直到事件被设置。在这种情况下，线程等待事件，一旦它再次被设置，它就会继续工作。
- en: 'If we want threads to run in a particular order, then we should stick to the
    following guidelines:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望线程以特定的顺序运行，那么我们应该坚持以下指南：
- en: We need as many events as there are threads
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要的事件数量应该和线程数量一样多
- en: An event controlling a specific thread should be cleared *inside* this thread
    but set *outside* it
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制特定线程的事件应该在**内部**清除，但在**外部**设置
- en: Now, let’s make some modifications to the code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对代码进行一些修改。
- en: 'First, we need three events:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要三个事件：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our example, `f1` will control the `t1` thread, `f2` will control `t2`, and
    `f3` will control `t3`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`f1`将控制`t1`线程，`f2`将控制`t2`，而`f3`将控制`t3`。
- en: 'Next, to the very end of the `t1()` function, we do the following actions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`t1()`函数的末尾，我们执行以下操作：
- en: We clear the `f1` event (which controls the first thread)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们清除`f1`事件（它控制第一个线程）
- en: We set the `f2` event (which gives the green light to the `t2` thread)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置`f2`事件（为`t2`线程提供绿灯）
- en: We set thread `t1` to wait for the `f1` event to be set again
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将线程`t1`设置为等待`f1`事件再次被设置
- en: 'The modified code will look like follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的代码将如下所示：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We modify the `t2()` and `t3()` functions in the same way (so that each thread
    controls its next neighbor) and run all three threads:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以同样的方式修改`t2()`和`t3()`函数（以便每个线程控制其下一个邻居）并运行所有三个线程：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can enjoy the output in the perfectly correct order:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以完全正确的顺序享受输出：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '...and so on.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '...等等。'
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is possible that for the first two execution loops, the output may still
    go in an incorrect order: this may happen until two events are cleared and awaited,
    and only one event is set.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对于前两个执行循环，输出仍然可能以错误的顺序进行：这可能会发生，直到两个事件被清除并等待，而只有一个事件被设置。
- en: Now that we’re familiar with `threading.Event()` objects, it’s time to modify
    our trading application for backtesting purposes. For clarity and ease of use,
    I will reproduce its entire code here and point to the exact places where we made
    any modifications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了`threading.Event()`对象，现在是时候修改我们的回测应用了。为了清晰和易于使用，我将在这里重现其全部代码，并指出我们做了任何修改的确切位置。
- en: Backtesting platform with a historical data feed
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有历史数据馈送的历史回测平台
- en: 'As always, we start with several imports:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从几个导入开始：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we reuse the same `tradingSystemMetadata` class and only add three events
    to the control threads. We name them `F1`, `F2` and `F3` (flags):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重用相同的`tradingSystemMetadata`类，并只为控制线程添加三个事件。我们称它们为`F1`、`F2`和`F3`（标志）：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we need data and order queues. Since we no longer use tick data to sync
    threads, there’s no need to have multiple tick data queues – we only need one
    queue for bars and another one for orders:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要数据和订单队列。由于我们不再使用tick数据来同步线程，因此不需要多个tick数据队列——我们只需要一个用于K线的队列，另一个用于订单：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, we must create an instance of the system metadata object and read the
    historical data from the file into `all_data`. We must also start the stopwatch
    (the `time.perf_counter()` method) to keep track of time spent on various operations
    – just out of curiosity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建系统元数据对象的实例，并将历史数据从文件中读取到`all_data`中。我们还必须启动计时器（`time.perf_counter()`方法）以跟踪各种操作所花费的时间——纯粹出于好奇。
- en: 'Note that we read the data using `csv.DictReader()` so that we receive each
    bar as a dictionary – this ensures maximum compatibility with the production code
    that we developed earlier in this chapter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`csv.DictReader()`读取数据，这样我们接收到的每个K线都是一个字典——这确保了与我们在本章早期开发的原始生产代码的最大兼容性：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we need a modified function that takes bars from the read data one by
    one, converts necessary fields from `str` into `float`, and puts the bar into
    the queue. We must also break the execution of this loop after the first 10 bars
    for debugging purposes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个修改后的函数，该函数从读取的数据中逐个获取K线，将必要的字段从`str`转换为`float`，并将K线放入队列。我们还必须为了调试目的在第一个10个K线后中断此循环的执行：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note the three flags (`System.F1`, `System.F2`, and `System.F3`) at the end
    of the function: they control the execution of threads and make sure that first,
    we read a bar, then we generate an order and, finally, we execute – or, rather,
    emulate – the execution of this order.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数末尾的三个标志（`System.F1`、`System.F2`和`System.F3`）：它们控制线程的执行，并确保首先读取一个K线，然后生成一个订单，最后执行——或者更确切地说，模拟这个订单的执行。
- en: 'Also, note that we do not check data consistency and do not exclude any data
    points: when we work with saved historical data, we assume this data is already
    clean.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们不检查数据一致性，也不排除任何数据点：当我们处理保存的历史数据时，我们假设这些数据已经清洗过。
- en: Next goes the `tradeLogic()` function. The best news here is that its main logical
    part remains completely unchanged – no modification is required between the `trade
    logic starts here` and `trade logic ends here` comments in the original code!
    We only modify this function at its beginning and at its end.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`tradeLogic()`函数。这里最好的消息是，其主要逻辑部分保持完全不变——在原始代码中的`trade logic starts here`和`trade
    logic ends here`注释之间不需要任何修改！我们只在这个函数的开始和结束处进行修改。
- en: 'At its beginning, we must add a `try...except` statement that will terminate
    the respective thread when all the data has been processed. To do that, we must
    set the timeout attribute of the `get()` method to `1`. This means that `get()`
    will wait for `1` second for a new bar to appear in the queue, and if no bar is
    there after 1 second, then an exception is generated. On exception, we just break
    the loop and effectively terminate the thread:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们必须添加一个`try...except`语句，当所有数据都被处理时，将终止相应的线程。为此，我们必须将`get()`方法的超时属性设置为`1`。这意味着`get()`将等待`1`秒，以在队列中出现新的K线，如果在1秒后没有K线，则生成异常。在异常发生时，我们只需中断循环，从而有效地终止线程：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We omitted the entire trade logic because it is indeed identical to what we
    used in our first version of the trading app.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了整个交易逻辑，因为它确实与我们用于我们交易应用第一个版本的逻辑相同。
- en: 'Note that at end of the function code, we return the bar into the queue: its
    data will be required by the orders processing component. And as in the case of
    the previous function, we set the `F3` flag, giving the green light to the next
    operation (orders processing), clear `F2`, and stop the trade logic thread until
    the `F2` flag is set.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数代码的末尾，我们将K线返回到队列中：其数据将被订单处理组件所需要。并且，就像上一个函数的情况一样，我们设置`F3`标志，为下一个操作（订单处理）发出绿灯，清除`F2`，并停止交易逻辑线程，直到`F2`标志被设置。
- en: 'Next, we must rewrite the order execution emulator quite substantially: the
    difference between the production and backtesting versions is that while backtesting,
    we only work with compressed data, so checking order execution on every tick no
    longer makes sense.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须相当大幅度地重写订单执行模拟器：生产版本和回测版本之间的区别在于，在回测时，我们只处理压缩数据，因此在每个tick上检查订单执行不再有意义。
- en: Emulating order execution during backtesting
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回测期间模拟订单执行
- en: 'Let’s start by emulating market orders since they’re the easiest to implement,
    and stick to the following guidelines:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先模拟市场订单，因为它们最容易实现，并坚持以下指南：
- en: We assume that a market order can be generated by the trade logic only at the
    bar’s closing time
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设只有当交易逻辑在bar的收盘时间才能生成市场订单
- en: We emulate the execution of a market order only at the bar’s closing price
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在bar的收盘价时模拟市场订单的执行
- en: We assume that the liquidity in the market is always sufficient and therefore
    we don’t have to check it before executing an order
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设市场中的流动性总是充足的，因此我们不需要在执行订单之前检查它
- en: We assume that the actual execution price was the same as the requested order
    price as we don’t have real-time tick data to test the execution
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设实际执行价格与请求的订单价格相同，因为我们没有实时tick数据来测试执行
- en: 'With all these considerations in mind, the modified `emulateBrokerExecution`
    function will now look much simpler:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，修改后的`emulateBrokerExecution`函数现在看起来会简单得多：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We do not add any flags here as this function is called from inside the `processOrders`
    function. Let’s add this function: you will see that its logic looks very much
    like the one we used previously, with live tick data:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有添加任何标志，因为这个函数是在`processOrders`函数内部被调用的。让我们添加这个函数：你会看到它的逻辑与我们之前使用的非常相似，使用了实时tick数据：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We started with a similar `try...except` statement that terminates the execution
    of the thread when there’s no more data in the bars queue. Next, we make the same
    updates to the system metadata as we did previously; the only difference is that
    we use the bar’s closing price instead of the last tick price:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个类似的`try...except`语句开始，当bars队列中没有更多数据时，终止线程的执行。接下来，我们对系统元数据进行相同的更新，与之前不同的是，我们使用bar的收盘价而不是最后tick的价格：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The orders processing logic is again quite similar to the tick-driven code,
    with the main difference being the absence of risk management checks (whether
    we have sufficient funds to trade) and rejected orders handling: during backtesting,
    we assume that all orders are executed:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 订单处理逻辑与tick驱动的代码非常相似，主要区别是没有风险管理检查（我们是否有足够的资金进行交易）和拒绝订单的处理：在回测期间，我们假设所有订单都得到了执行：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the end of the function’s code, we again add the respective flags to control
    the execution order of the threads.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数代码的末尾，我们再次添加相应的标志来控制线程的执行顺序。
- en: 'Well, this is it! All we must do now is check the time spent on the backtest
    (just for fun) and start the threads:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就完成了！我们现在必须做的就是检查回测所花费的时间（只是为了好玩）并启动线程：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: But how do we check that the code produces correct results?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何检查代码是否产生正确的结果呢？
- en: 'Of course, we could add several print statements, as we did with the live trading
    application, but the goal of backtesting is different: we want to process as much
    data as possible within as brief a period as possible, and then analyze the collected
    data. 5 years’ worth of 1-minute bars of historical data makes over 2 million
    data points, so if we just print the updated equity value on each bar, it would
    make over 2 million prints – which would take forever because `print()` is one
    of the slowest instructions. So, how do systematic traders analyze the strategy’s
    performance?'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以添加几个打印语句，就像我们在实时交易应用中做的那样，但回测的目标是不同的：我们希望在尽可能短的时间内处理尽可能多的数据，然后分析收集到的数据。5年的1分钟历史数据bar超过200万个数据点，所以如果我们只是在每个bar上打印更新的权益价值，就会超过200万个打印——这将花费很长时间，因为`print()`是速度最慢的指令之一。那么，系统交易者如何分析策略的表现呢？
- en: Equity curve and statistics
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权益曲线和统计数据
- en: 'When running a backtest with the code we’ve just written, we save some basic
    statistical data: the equity value updated on every tick or bar. If we plot the
    equity time series, we get an **equity curve**: a visual representation of the
    dynamics of the trading system’s profits and losses over time. Such a chart is
    the first thing to check after the backtest is complete:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用我们刚刚编写的代码运行回测时，我们保存一些基本统计数据：每个tick或bar更新的权益价值。如果我们绘制权益时间序列，我们得到一个**权益曲线**：这是交易系统随时间利润和损失动态的视觉表示。这样的图表是在回测完成后首先要检查的东西：
- en: If the equity curve shows growth over time, then there is a chance (but not
    a guarantee!) that the strategy may also perform well in the future
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果权益曲线显示随着时间的增长，那么策略未来可能表现良好（但不是保证！）的机会就存在
- en: 'If the equity curve exhibits steady systematical loss over time, it again may
    not be really bad: consider inverting the rules of the trade logic'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果权益曲线随着时间的推移表现出稳定的系统性损失，这再次可能不是真的坏：考虑反转交易逻辑的规则
- en: If the equity curve oscillates around zero, it’s probably the worst case as
    this strategy logic is unlikely to make any money in the future
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果权益曲线围绕零振荡，这可能是最坏的情况，因为这个策略逻辑未来不太可能赚钱
- en: Let’s add code for plotting the equity curve to our code after the backtest
    is complete. We will use the techniques that we discussed in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130),
    *Data Visualization in FX Trading with Python*, so I recommend refreshing your
    memory about using `matplotlib` at this point.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在回测完成后，在我们的代码中添加绘制权益曲线的代码。我们将使用我们在[*第8章*](B19145_08.xhtml#_idTextAnchor130)，*使用Python进行外汇交易中的数据可视化*中讨论的技术，所以我建议在这个时候复习一下使用`matplotlib`。
- en: 'The `matplotlib` main loop cannot be run in a thread (at least easily), so
    we must add charting in the main thread (like we did when plotting live bar charts
    in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130), *Data Visualization in FX
    Trading with Python*) and keep an eye on the `incoming_price_feed` thread: while
    it’s alive, we just wait and do nothing, but as soon as it finishes working, we
    plot the equity curve.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib`的主循环不能在线程中运行（至少不容易），因此我们必须在主线程中添加图表（就像我们在[*第8章*](B19145_08.xhtml#_idTextAnchor130)，*使用Python进行外汇交易中的数据可视化*)中绘制实时K线图表时做的那样），并关注`incoming_price_feed`线程：当它存活时，我们只需等待并做任何事情，但一旦它完成工作，我们就绘制权益曲线。'
- en: 'So, we just add `import matplotlib.pyplot as plt` to the `imports` section
    at the beginning of the code and the following simple infinite loop to its end,
    once all the threads have been started:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需在代码开头的`import`部分添加`import matplotlib.pyplot as plt`，并在所有线程启动后，将其末尾添加以下简单的无限循环：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you did everything correctly and used the same historical data file as I
    did, you will see a chart like the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，并且使用了与我相同的历 史数据文件，你将看到以下图表：
- en: '![Figure 11.7 – Equity curve of the sample strategy, built on the first 10
    bars](img/B19145_11_07.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 基于前10根K线的样本策略的权益曲线](img/B19145_11_07.jpg)'
- en: Figure 11.7 – Equity curve of the sample strategy, built on the first 10 bars
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 基于前10根K线的样本策略的权益曲线
- en: This looks great, but how can we make sure that this result is correct? If a
    backtester emulates the performance incorrectly, we can’t rely on the backtesting
    results.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒，但我们如何确保这个结果是正确的？如果回测器模拟性能不正确，我们就不能依赖回测结果。
- en: Fortunately, it’s not difficult to check this result. As you may remember, we
    intentionally used a very simplistic test strategy that generates orders on almost
    every bar. So, we can rebuild a similar equity curve manually, for example using
    MS Excel or OpenOffice, and compare it with the chart generated by our backtesting
    app.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，检查这个结果并不困难。如您所记得，我们故意使用了一个非常简单的测试策略，该策略几乎在每一根K线上都生成订单。因此，我们可以手动重建一个类似的权益曲线，例如使用MS
    Excel或OpenOffice，并将其与我们的回测应用程序生成的图表进行比较。
- en: Let’s open the data file and remove the unnecessary columns (`UpVolume`, `DownVolume`,
    `TotalVolume`, `UpTicks`, `DownTicks`, and `TotalTicks`).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开数据文件并删除不必要的列（`UpVolume`、`DownVolume`、`TotalVolume`、`UpTicks`、`DownTicks`和`TotalTicks`）。
- en: '![Figure 11.8 – First 10 bars of the source data file](img/B19145_11_08.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 源数据文件的前10根K线](img/B19145_11_08.jpg)'
- en: Figure 11.8 – First 10 bars of the source data file
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 源数据文件的前10根K线
- en: 'Next, we must reproduce the strategy logic: if the bar closes up (`close >
    open`), then we buy; if the bar closes down, we sell. We will add a new column
    that contains the direction of our trade:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须重现策略逻辑：如果K线收盘价上涨（`close > open`），则我们买入；如果K线收盘价下跌，则我们卖出。我们将添加一个包含我们交易方向的新的列：
- en: '![Figure 11.9 – Determining the direction of simulated trade](img/B19145_11_09.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 确定模拟交易的方向](img/B19145_11_09.jpg)'
- en: Figure 11.9 – Determining the direction of simulated trade
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 确定模拟交易的方向
- en: 'Then, we must add a column where we calculate the actual PnL per bar by multiplying
    the difference between the bars’ closing prices by the direction and the trading
    size:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个列，通过将K线收盘价之间的差异乘以方向和交易量来计算每根K线的实际PnL：
- en: '![Figure 11.10 – Calculating returns per bar](img/B19145_11_10.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 计算每根K线的回报](img/B19145_11_10.jpg)'
- en: Figure 11.10 – Calculating returns per bar
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 计算每根K线的回报
- en: 'And finally, we must calculate the cumulative sum of per-bar returns, which
    is effectively the equity time series:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须计算每条柱状图的累计回报总和，这实际上就是权益时间序列：
- en: '![Figure 11.11 – Calculating the equity time series](img/B19145_11_11.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 计算权益时间序列](img/B19145_11_11.jpg)'
- en: Figure 11.11 – Calculating the equity time series
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 计算权益时间序列
- en: 'Now, if we plot the equity curve by creating a line chart based on data in
    column I, we will see the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们通过基于I列数据创建折线图来绘制权益曲线，我们会看到以下内容：
- en: '![Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice](img/B19145_11_12.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – 在LibreOffice中手动重建权益曲线](img/B19145_11_12.jpg)'
- en: Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 在LibreOffice中手动重建权益曲线
- en: We can see that the equity curve is identical to what was plotted by our code
    – and this means that our backtest is reliable! Having checked it only once, we
    can now trust its results any time we do a test.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，权益曲线与我们代码绘制的曲线完全一致——这意味着我们的回测是可靠的！检查过一次之后，我们现在可以在进行任何测试时都信任其结果。
- en: 'I bet you are dying to see a long-term performance report for our great strategy,
    not limited to just 10 bars. Remember, 1 bar in our source data file is 1 minute,
    so 10 minutes worth of a backtest is not representative. Let’s run the test for
    the first 1 million bars, which would equate to approximately 32 months’ worth
    of history. We only need to modify one line in the code: replace `10` with `1000000`
    in `if counter == 1000000:` in the `getBar()` function.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你迫不及待地想看到我们伟大策略的长期表现报告，而不仅仅是10条柱状图。记住，我们源数据文件中的1条柱状图代表1分钟，所以10分钟的回测并不具有代表性。让我们对前1百万条柱状图进行测试，这相当于大约32个月的历史。我们只需要修改代码中的一行：在`getBar()`函数中的`if
    counter == 1000000:`处将`10`替换为`1000000`。
- en: 'Now, we also can estimate the backtesting speed as per the output in the console.
    On my (by far not the latest) laptop (Macbook Pro 2012 with a quad-core Core i7
    processor, SSD drive, and 16 GB of memory), it took 12 seconds to read the data
    from the file and 93 seconds to process 1 million bars. Not bad: we can emulate
    32 months in less than 2 minutes!'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以根据控制台输出估计回测速度。在我的（远非最新）笔记本电脑（2012年款Macbook Pro，配备四核Core i7处理器、SSD驱动器和16
    GB内存）上，读取文件数据花费了12秒，处理1百万条柱状图花费了93秒。还不错：我们可以在不到2分钟内模拟32个月的时间！
- en: 'What about the equity curve from such a long-term perspective? Here you are:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从这样一个长期的角度来看，权益曲线又是怎样的呢？这里就是：
- en: '![Figure 11.13 – Theoretical performance (equity curve) of the sample strategy
    calculated using the first 1,000,000 data points](img/B19145_11_13.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13 – 使用前1,000,000个数据点计算得到的样本策略的理论表现（权益曲线）](img/B19145_11_13.jpg)'
- en: Figure 11.13 – Theoretical performance (equity curve) of the sample strategy
    calculated using the first 1,000,000 data points
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 使用前1,000,000个数据点计算得到的样本策略的理论表现（权益曲线）
- en: Wow! Looks like the Holy Grail of trading! Is it possible that such a primitive
    strategy can indeed generate such steady returns over such a long period?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！看起来就像是交易的圣杯！这样的原始策略真的能够在如此长的时间内产生如此稳定的回报吗？
- en: Generally speaking, every time you get such an optimistic result, focus on finding
    errors. In our case, it is doubtful that we made an error in the trading logic
    – it’s too primitive and we tested it manually. So, what is it that we probably
    missed in our backtesting that led to this unrealistically great result? Or maybe
    this result is indeed realistic?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，每次你得到这样乐观的结果时，都要专注于寻找错误。在我们的案例中，我们怀疑我们没有在交易逻辑上犯错误——它太原始了，我们手动测试过。那么，我们在回测中可能遗漏了什么导致了这个不切实际的良好结果？或者，这个结果确实是现实的？
- en: Of course and unfortunately, it is not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不幸的是，它并不是。
- en: 'Let’s go back to the `emulateBrokerExecution` function again. We assume that
    any order is executed on the bar’s close – which is fine as we don’t have tick
    data for backtesting. But our code makes no difference between the execution of
    buy and sell orders: they are both executed at the same price, in our example
    – bid. But when testing the live trading application earlier in this chapter,
    we saw that executing orders at actual prices (bid for sell orders and ask for
    buy orders) may make quite a difference in PnL. So, as we don’t have ask prices
    in our historical data, let’s emulate it: we will add a typical spread to the
    bar’s closing price, thus accounting for the difference between the bid and ask:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到`emulateBrokerExecution`函数。我们假设任何订单都是在收盘时执行的——这很好，因为我们没有回测的tick数据。但是我们的代码在执行买入和卖出订单时没有区别：它们都以相同的价格执行，在我们的例子中是出价。但是当我们在本章早期测试实时交易应用时，我们发现以实际价格（卖出订单的出价和买入订单的询价）执行订单可能会在损益表（PnL）上产生很大的差异。因此，由于我们的历史数据中没有询价，让我们来模拟它：我们将典型价差加到收盘价上，从而考虑到出价和询价之间的差异：
- en: '[PRE53]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In reality, the spread in EURUSD may vary from as low as 0 to as much as 0.0010
    and even greater (usually before the release of important economic news; see [*Chapter
    6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental Analysis and Its
    Possible Use in FX Trading*), but it’s safe to assume that 1/2 pip is more or
    less adequate to emulate the average spread.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，EURUSD的价差可能从0低至0.0010甚至更高（通常在重要经济新闻发布之前；参见[*第6章*](B19145_06.xhtml#_idTextAnchor101)，*基本面分析的基础及其在FX交易中的可能用途*)，但可以安全地假设1/2点足以模拟平均价差。
- en: 'Let’s run the backtest again and see the equity curve:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行回测并查看权益曲线：
- en: '![Figure 11.14 – More realistic emulated equity curve of the test strategy](img/B19145_11_14.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14 – 测试策略更现实的模拟权益曲线](img/B19145_11_14.jpg)'
- en: Figure 11.14 – More realistic emulated equity curve of the test strategy
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 测试策略更现实的模拟权益曲线
- en: 'What a radical difference! Now, instead of steadily gaining money, the strategy
    is steadily losing money, and is doing so very, very quickly: it lost $100,000
    in less than 3 years by trading only one so-called mini-lot (10,000 base currency).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多么激进的变化！现在，策略不再是稳步盈利，而是稳步亏损，而且亏损速度非常快：它仅通过交易一个所谓的迷你合约（10,000基础货币）在不到3年的时间里亏损了100,000美元。
- en: How has this happened?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么发生的？
- en: 'Although the strategy *made money* on paper without accounting for the spread,
    on average, it produced a ridiculously small amount of paper money *per trade*:
    it was *less than the spread*. As soon as we correctly emulated the execution
    of orders at the bid and ask, the Holy Grail vanished into thin air and the sad
    truth was revealed.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管策略在纸上没有考虑价差的情况下盈利，但平均而言，它每笔交易产生的纸面金额非常小：它甚至少于价差。一旦我们正确地模拟了以出价和询价执行订单，圣杯就消失得无影无踪，而令人悲伤的真相被揭露。
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This story should always be kept in mind when you do any market research and
    develop any strategy. Always make sure that you emulate the real market conditions
    to the best possible extent – to avoid getting too optimistic theoretical results
    and quite painful disappointment in production.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行任何市场研究和发展任何策略时，这个故事应该始终牢记在心。始终确保尽可能真实地模拟市场条件——以避免得到过于乐观的理论结果和在生产中遭受的痛苦失望。
- en: 'The greatest news after all this is that you now have a tool you can rely on:
    our backtesting platform.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些之后最伟大的新闻是，你现在有一个可以信赖的工具：我们的回测平台。
- en: Summary – where do we go now?
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结 – 我们接下来该去哪里？
- en: Congratulations on getting so far in our studies! I know that this chapter was
    very long, but hopefully not boring. We covered virtually all aspects of developing
    live trading applications and backtesters, so now, you are well equipped with
    powerful tools that should help you develop great trading strategies.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你在我们的学习中走这么远！我知道这一章非常长，但希望不会无聊。我们几乎涵盖了开发实时交易应用和回测器的所有方面，所以现在，你拥有了强大的工具，这些工具应该能帮助你开发出优秀的交易策略。
- en: Let’s quickly summarize what we learned in this chapter and outline some vistas.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下本章学到的内容，并概述一些前景。
- en: 'We now fully understand all four essential components of any trading app: receiving
    data, processing it, generating orders, and controlling their execution.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全理解了任何交易应用的所有四个基本组成部分：接收数据、处理数据、生成订单以及控制它们的执行。
- en: We are also familiar with the most typical technical issues, such as incorrectly
    emulating order execution or processing non-market prices, and we also know how
    to work around them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还熟悉最典型的技术问题，例如错误地模拟订单执行或处理非市价价格，我们也知道如何解决这些问题。
- en: Then, we learned how to synchronize multiple threads by using queues and threading
    event objects, and we know how to make sure that every component of the trading
    app runs exactly at the expected moment.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何通过使用队列和线程事件对象来同步多个线程，我们也知道如何确保交易应用中的每个组件都恰好运行在预期的时刻。
- en: Next, we learned how to rebuild parts of strategy performance manually to check
    the correctness of a test or live orders generation and execution. Now, we can
    be 100% sure that we can rely on the code we wrote.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何手动重建策略性能的部分来检查测试或实时订单生成和执行的准确性。现在，我们可以100%确信我们可以信赖我们编写的代码。
- en: 'We even created our first Holy Grail of trading – and immediately broke it
    into pieces by critically reviewing the code, thus learning the main lesson of
    systematic trading: not the tiniest detail can be missed, intentionally or occasionally,
    and you should check your results twice before going to production to avoid very
    unpleasant surprises when trading with real money.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至创造了我们交易的第一件圣杯——通过批判性地审查代码，我们立即将其拆解成碎片，从而学到了系统交易的主要教训：任何最微小的细节都不能被忽视，无论是故意还是偶然，在将结果用于生产之前，你应该检查你的结果两次，以避免在用真钱交易时遇到非常不愉快的惊喜。
- en: Now, let’s point out where we can go further in our development.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们指出我们可以在我们的开发中更进一步的地方。
- en: First, at the moment, our platform only supports market orders. Yes, from the
    previous chapter, you may remember that in many cases, market orders are preferred
    and that we can always emulate orders of all other types with market orders only.
    However, at least for development purposes, it would be great to add emulation
    for limit and stop orders.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，目前，我们的平台仅支持市价订单。是的，你们可能还记得，在前一章中，在许多情况下，市价订单是首选的，我们可以用市价订单来模拟所有其他类型的订单。然而，至少从开发目的来看，添加对限价和止损订单的模拟会很好。
- en: In its present form, the code does not implement any risk management, neither
    at the position nor the strategy level. It is essential to add at least basic
    stop-loss orders that will protect the trading account from an unexpected catastrophic
    scenario.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前形式下，该代码在仓位和策略层面均未实现任何风险管理。添加至少基本的止损订单对于保护交易账户免受意外灾难性场景的影响是至关重要的。
- en: 'It would also be great to calculate at least some very basic statistics about
    the strategy’s performance: at the moment, we can only analyze the equity time
    series, but we want to know more about the average trade value, number of trades,
    percent of profitable trades, and so on.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，计算策略性能的一些非常基本的统计数据也会很棒：目前，我们只能分析权益时间序列，但我们想了解更多关于平均交易价值、交易次数、盈利交易百分比等信息。
- en: And of course, we can complicate the platform further by adding multiple strategies,
    grouping them into portfolios, and achieving the highest level of sophistication
    by adding multiple incoming live data streams. Although this is definitely outside
    the scope of this book, let me encourage you to be bold and curious, as any true
    researcher should be, and play with the existing code and try improving it –you
    will see that, in the long run, your efforts will be highly rewarded.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以通过添加多个策略、将它们分组到投资组合中，并通过添加多个实时数据流来实现平台的进一步复杂化，以达到最高水平的复杂性。尽管这肯定超出了本书的范围，但我鼓励你们大胆好奇，就像任何真正的研究者应该做的那样，玩转现有的代码并尝试改进它——你们会发现，从长远来看，你们的努力将得到高度回报。
- en: The remaining chapters of this book are dedicated to implementing trading strategies
    of specific types. We will add a few components to the backtesting platform we
    created in this chapter, but no significant changes will be made. Instead, we
    will focus on developing the strategic logic and analyzing its theoretical performance.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余的章节致力于实现特定类型的交易策略。我们将为本章创建的回测平台添加一些组件，但不会进行重大更改。相反，我们将专注于开发战略逻辑并分析其理论性能。
- en: 'Part 4: Strategies, Performance Analysis, and Vistas'
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：策略、性能分析和展望
- en: In previous parts, we gained sufficient knowledge to be able to develop a robust
    trading platform suitable for both backtesting and – with minimal modifications
    – live trading. We even coded a dummy strategy and as expected found that it could
    not make money if not tested properly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们获得了足够的知识，能够开发出一个既适合回测又适合——经过最小修改——实时交易的平台。我们甚至编写了一个模拟策略，并如预期的那样发现，如果没有经过适当的测试，它是无法赚钱的。
- en: '*Part 4* explains how to build a profitable trading strategy, from searching
    for trading ideas to implementing them in code. We will also learn how to generate
    the most important strategy performance data and analyze it to make the final
    verdict on whether such a strategy can be used in real life or not. Then, we will
    see how to correctly implement limit and stop orders and consider another trading
    strategy, based on a completely different trading idea. Finally, the last chapter
    suggests a few guidelines for further self-development in algorithm trading, with
    links to useful and valuable resources.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4部分* 解释了如何构建一个盈利的交易策略，从寻找交易想法到将其编码实现。我们还将学习如何生成最重要的策略性能数据，并分析它，以最终判断这样的策略是否可以在现实生活中使用。然后，我们将看到如何正确地实施限价和止损订单，并考虑另一种基于完全不同交易想法的交易策略。最后，最后一章提出了一些关于算法交易进一步自我发展的指导方针，并附有链接到有用和有价值的资源。'
- en: 'This part comprises the following chapters:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 12*](B19145_12.xhtml#_idTextAnchor203), *Sample Strategy – Trend-Following*'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19145_12.xhtml#_idTextAnchor203)，*示例策略——趋势跟踪*'
- en: '[*Chapter 13*](B19145_13.xhtml#_idTextAnchor215), *To Trade or Not to Trade
    – Performance Analysis*'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19145_13.xhtml#_idTextAnchor215)，*交易还是不交易——性能分析*'
- en: '[*Chapter 14*](B19145_14.xhtml#_idTextAnchor231), *Where to Go Now?*'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19145_14.xhtml#_idTextAnchor231)，*现在该去哪里？*'
