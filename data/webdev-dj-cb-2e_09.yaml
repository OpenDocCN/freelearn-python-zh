- en: Chapter 9. Data Import and Export
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 数据导入和导出
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍以下菜谱：
- en: Importing data from a local CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地 CSV 文件导入数据
- en: Importing data from a local Excel file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地 Excel 文件导入数据
- en: Importing data from an external JSON file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部 JSON 文件导入数据
- en: Importing data from an external XML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部 XML 文件导入数据
- en: Creating filterable RSS feeds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可筛选的 RSS 源
- en: Using Tastypie to create API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tastypie 创建 API
- en: Using Django REST framework to create API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django REST 框架创建 API
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are times when your data needs to be transported from a local format to
    the database, imported from external resources, or provided to third parties.
    In this chapter, we will take a look at some practical examples of how to write
    management commands and APIs to do this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您的数据需要从本地格式传输到数据库，从外部资源导入，或提供给第三方。在这一章中，我们将探讨一些编写管理命令和 API 的实际示例，以实现这些操作。
- en: Importing data from a local CSV file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地 CSV 文件导入数据
- en: The **comma-separated values** (**CSV**) format is probably the simplest way
    to store tabular data in a text file. In this recipe, we will create a management
    command that imports data from CSV to a Django database. We will need a CSV list
    of movies with a title, URL, and release year. You can easily create such files
    with Excel, Calc, or another spreadsheet application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值**（**CSV**）格式可能是将表格数据存储在文本文件中最简单的方式。在这个菜谱中，我们将创建一个管理命令，用于从 CSV 导入数据到
    Django 数据库。我们需要一个包含电影标题、URL 和发行年份的 CSV 电影列表。你可以使用 Excel、Calc 或其他电子表格应用程序轻松创建此类文件。'
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a `movies` app with the `Movie` model containing the following fields:
    `title`, `url`, and `release_year`. Place the app under `INSTALLED_APPS` in the
    settings.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下字段的 `Movie` 模型的 `movies` 应用：`title`、`url` 和 `release_year`。将应用放置在设置中的
    `INSTALLED_APPS` 下。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create and use a management command that imports movies
    from a local CSV file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和使用一个管理命令，用于从本地 CSV 文件导入电影：
- en: In the `movies` app, create a `management` directory and then a `commands` directory
    in the new `management` directory. Put the empty `__init__.py` files in both new
    directories to make them Python packages.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `movies` 应用中，创建一个 `management` 目录，然后在新的 `management` 目录中创建一个 `commands` 目录。在这两个新目录中放置空的
    `__init__.py` 文件，以使它们成为 Python 包。
- en: 'Add an `import_movies_from_csv.py` file there with the following content:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里添加一个 `import_movies_from_csv.py` 文件，内容如下：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For a management command, we need to create a `Command` class deriving from
    `BaseCommand` and overwriting the `add_arguments()` and `handle()` method. The
    `help` attribute defines the help text for the management command. It can be seen
    when you type the following in the command line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个管理命令，我们需要创建一个从 `BaseCommand` 继承并重写 `add_arguments()` 和 `handle()` 方法的 `Command`
    类。`help` 属性定义了管理命令的帮助文本。当你输入以下内容到命令行时，可以看到它：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Django management commands use the built-in argparse module to parse the passed
    arguments. The `add_arguments()` method defines what positional or named arguments
    should be passed to the management command. In our case, we will add a positional
    `file_path` argument of Unicode type. By `nargs` set to the `1` attribute, we
    allow only one value. To learn about the other arguments that you can define and
    how to do this, refer to the official argparse documentation at [https://docs.python.org/2/library/argparse.html#the-add-argument-method](https://docs.python.org/2/library/argparse.html#the-add-argument-method).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Django 管理命令使用内置的 argparse 模块来解析传递的参数。`add_arguments()` 方法定义了应该传递给管理命令的位置参数或命名参数。在我们的情况下，我们将添加一个
    Unicode 类型的位置参数 `file_path`。通过将 `nargs` 设置为 `1` 属性，我们允许只有一个值。要了解您可以定义的其他参数以及如何进行此操作，请参阅官方
    argparse 文档：[https://docs.python.org/2/library/argparse.html#the-add-argument-method](https://docs.python.org/2/library/argparse.html#the-add-argument-method)。
- en: 'At the beginning of the `handle()` method, the `verbosity` argument is checked.
    Verbosity defines how verbose the command is, from `0` not giving any output to
    the command-line tool to `3` being very verbose. You can pass this argument to
    the command as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle()` 方法的开始处，检查 `verbosity` 参数。详细程度定义了命令的详细程度，从 `0` 不向命令行工具输出任何内容到 `3`
    非常详细。你可以按如下方式将此参数传递给命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, we also expect the filename as the first positional argument. The `options["file_path"]`
    returns a list of the values defined in the nargs, therefore, it is one value
    in this case.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还期望文件名作为第一个位置参数。`options["file_path"]`返回nargs中定义的值的列表，因此在这种情况下它是一个值。
- en: We open the given file and pass its pointer to `csv.reader`. Then, for each
    line in the file, we will create a new `Movie` object if a matching movie doesn't
    exist yet. The management command will print out the imported movie titles to
    the console, unless you set the verbosity to `0`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开给定的文件，并将其指针传递给`csv.reader`。然后，对于文件中的每一行，如果不存在匹配的电影，我们将创建一个新的`Movie`对象。管理命令将打印出导入的电影标题到控制台，除非你将详细程度设置为`0`。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to debug the errors of a management command while developing it,
    pass the `--traceback` parameter for it. If an error occurs, you will see the
    full stack trace of the problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在开发过程中调试管理命令的错误，为它传递`--traceback`参数。如果发生错误，你将看到问题的完整堆栈跟踪。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can learn more about the CSV library from the official documentation at
    [https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方文档[https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html)了解更多关于CSV库的信息。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: The *Importing data from a local Excel file* recipe
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地Excel文件导入数据*的菜谱'
- en: Importing data from a local Excel file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地Excel文件导入数据
- en: Another popular format to store tabular data is an Excel spread sheet. In this
    recipe, we will import movies from a file of this format.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的存储表格数据的格式是Excel电子表格。在这个菜谱中，我们将从这种格式的文件中导入电影。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start with the `movies` app that we created in the previous recipe.
    Install the `xlrd` package to read Excel files, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前菜谱中创建的`movies`应用开始。按照以下步骤安装`xlrd`包以读取Excel文件：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create and use a management command that imports movies
    from a local XLS file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和使用一个导入本地XLS文件的管理命令：
- en: If you haven't done that, in the `movies` app, create a `management` directory
    and then a `commands` directory in the new `management` directory. Put the empty
    `__init__.py` files in both the new directories to make them Python packages.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，在`movies`应用中，创建一个`management`目录，然后在新的`management`目录中创建一个`commands`目录。在这两个新目录中放入空的`__init__.py`文件，使它们成为Python包。
- en: 'Add the `import_movies_from_xls.py` file with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容的`import_movies_from_xls.py`文件添加到你的项目中：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The principle of importing from an XLS file is the same as with CSV. We open
    the file, read it row by row, and create the `Movie` objects from the provided
    data. A detailed explanation is as follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从XLS文件导入的原则与CSV相同。我们打开文件，逐行读取，并从提供的数据中创建`Movie`对象。详细解释如下。
- en: Excel files are workbooks containing sheets as different tabs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel文件是包含不同标签页的工作簿。
- en: We are using the `xlrd` library to open a file passed as a positional argument
    to the command. Then, we will read the first sheet from the workbook.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`xlrd`库打开命令中传递的文件。然后，我们将从工作簿中读取第一张工作表。
- en: Afterwards, we will read the rows one by one (except the first row with the
    column titles) and create the `Movie` objects from them. Once again, the management
    command will print out the imported movie titles to the console, unless you set
    the verbosity to `0`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将逐行读取（除了带有列标题的第一行）并从这些行中创建`Movie`对象。再次提醒，管理命令将打印出导入的电影标题到控制台，除非你将详细程度设置为`0`。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can learn more about how to work with Excel files at [http://www.python-excel.org/](http://www.python-excel.org/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.python-excel.org/](http://www.python-excel.org/)了解更多关于如何处理Excel文件的信息。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: The *Importing data from a local CSV file* recipe
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从本地CSV文件导入数据*的菜谱'
- en: Importing data from an external JSON file
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部JSON文件导入数据
- en: The `Last.fm` music website has an API under the [http://ws.audioscrobbler.com/](http://ws.audioscrobbler.com/)
    domain that you can use to read the albums, artists, tracks, events, and more.
    The API allows you to either use the JSON or XML format. In this recipe, we will
    import the top tracks tagged disco using the JSON format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Last.fm`音乐网站在[http://ws.audioscrobbler.com/](http://ws.audioscrobbler.com/)域名下有一个API，你可以使用它来读取专辑、艺术家、曲目、事件等。该API允许你使用JSON或XML格式。在这个菜谱中，我们将使用JSON格式导入被标记为disco的顶级曲目。'
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps in order to import data in the JSON format from `Last.fm`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从 `Last.fm` 导入 JSON 格式的数据：
- en: To use `Last.fm`, you need to register and get an API key. The API key can be
    created at [http://www.last.fm/api/account/create](http://www.last.fm/api/account/create).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `Last.fm`，你需要注册并获取一个 API 密钥。API 密钥可以在 [http://www.last.fm/api/account/create](http://www.last.fm/api/account/create)
    创建。
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 密钥必须在设置中设置为 `LAST_FM_API_KEY`。
- en: 'Also, install the `requests` library in your virtual environment using the
    following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，使用以下命令在你的虚拟环境中安装 `requests` 库：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s check the structure of the JSON endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json)):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 JSON 端点的结构 ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json))：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We want to read the track name, artist, URL, and medium-sized images.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想读取曲目名称、艺术家、URL 和中等大小的图片。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a `Track` model and management command, which
    imports top tracks from `Last.fm` to the database:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 `Track` 模型和管理命令，该命令从 `Last.fm` 导入顶级曲目到数据库：
- en: 'Let''s create a `music` app with a simple `Track` model, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个具有简单 `Track` 模型的 `music` 应用程序，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, create the management command as shown in the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建如下所示的管理命令：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the list is paginated, we will add the `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the dictionary with the
    top tracks from a single page as a parameter, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于列表是分页的，我们将向 `Command` 类添加 `save_page()` 方法以保存单个页面的曲目。此方法接受一个参数，即包含单个页面顶级曲目的字典，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The optional named `max_pages` argument limits the imported data to three pages.
    Just skip it if you want to download all the available top tracks; however, beware
    that there are above 26,000 pages as detailed in the `totalPages` value and this
    will take a while.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的命名参数 `max_pages` 限制导入的数据为三页。如果你想下载所有可用的顶级曲目，请跳过它；然而，请注意，有超过 26,000 页，如 `totalPages`
    值中详细说明，这将花费一些时间。
- en: Using the `requests.get()` method, we read the data from `Last.fm`, passing
    the `params` query parameters. The response object has a built-in method called
    `json()`, which converts a JSON string and returns a parsed dictionary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `requests.get()` 方法，我们从 `Last.fm` 读取数据，传递 `params` 查询参数。响应对象有一个内置方法称为 `json()`，它将
    JSON 字符串转换为解析后的字典。
- en: We read the total pages value from this dictionary and then save the first page
    of results. Then, we get the second and later pages one by one and save them.
    One interesting part in the import is downloading and saving the image. Here,
    we also use `request.get()` to retrieve the image data and then we pass it to
    `File` through `StringIO`, which is accordingly used in the `image.save()` method.
    The first parameter of `image.save()` is a filename that will be overwritten anyway
    by the value from the `upload_to` function and is necessary only for the file
    extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个字典中读取总页数值，然后保存第一页的结果。然后，我们逐页获取第二页及以后的页面并保存它们。导入过程中一个有趣的部分是下载和保存图片。在这里，我们也使用
    `request.get()` 来检索图片数据，然后通过 `StringIO` 将其传递给 `File`，这相应地用于 `image.save()` 方法。`image.save()`
    的第一个参数是一个文件名，它将被 `upload_to` 函数的值覆盖，仅用于文件扩展名。
- en: See also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Importing data from an external XML file* recipe
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部 XML 文件导入数据* 的配方'
- en: Importing data from an external XML file
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部 XML 文件导入数据
- en: The `Last.fm` file also allows you to take data from their services in XML format.
    In this recipe, I will show you how to do this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Last.fm` 文件还允许你从他们的服务中以 XML 格式获取数据。在这个配方中，我将向你展示如何做到这一点。'
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To prepare importing top tracks from `Last.fm` in the XML format, follow these
    steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备从 `Last.fm` 以 XML 格式导入顶级曲目，请按照以下步骤操作：
- en: Start with the first three steps from the *Getting ready* section in the *Importing
    data from an external JSON file* recipe.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *准备就绪* 部分的第一个三个步骤开始，在 *从外部 JSON 文件导入数据* 配方中。
- en: 'Then, let''s check the structure of the XML endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml)),
    as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们检查XML端点的结构（[http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml)），如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following steps one by one to import the top tracks from `Last.fm`
    in the XML format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序执行以下步骤以导入`Last.fm`的XML格式的顶级曲目：
- en: Create a `music` app with a `Track` model similar to the previous recipe, if
    you've not already done this.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，创建一个具有类似之前食谱的`Track`模型的`music`应用。
- en: 'Then, create an `import_music_from_lastfm_as_xml.py` management command. We
    will be using the `ElementTree` XML API that comes with Python to parse the XML
    nodes, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`import_music_from_lastfm_as_xml.py`管理命令。我们将使用Python附带的`ElementTree`
    XML API来解析XML节点，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As the list is paginated, we will add a `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the root node of the
    XML as a parameter, as shown in the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于列表是分页的，我们将在`Command`类中添加一个`save_page()`方法来保存单个页面的曲目。此方法以XML的根节点作为参数，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process is analogous to the JSON approach. Using the `requests.get()` method,
    we read the data from `Last.fm`, passing the query parameters as `params`. The
    XML content of the response is passed to the `ElementTree` parser and the root
    node is returned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程类似于JSON方法。使用`requests.get()`方法，我们从`Last.fm`读取数据，将查询参数作为`params`传递。响应的XML内容传递给`ElementTree`解析器，并返回根节点。
- en: The `ElementTree` nodes have the `find()` and `findall()` methods, where you
    can pass XPath queries to filter out specific subnodes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementTree`节点有`find()`和`findall()`方法，您可以通过传递XPath查询来过滤出特定的子节点。'
- en: 'The following is a table of the available XPath syntax supported by `ElementTree`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，列出了`ElementTree`支持的可用XPath语法：
- en: '| XPath Syntax Component | Meaning |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| XPath语法组件 | 含义 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `tag` | This selects all the child elements with the given tag. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `tag` | 这选择具有给定标签的所有子元素。|'
- en: '| `*` | This selects all the child elements. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 这选择所有子元素。|'
- en: '| `.` | This selects the current node. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 这选择当前节点。|'
- en: '| `//` | This selects all the subelements on all the levels beneath the current
    element. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `//` | 这选择当前元素所有级别下的所有子元素。|'
- en: '| `..` | This selects the parent element. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `..` | 这选择父元素。|'
- en: '| `[@attrib]` | This selects all the elements that have the given attribute.
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib]` | 这选择具有给定属性的所有元素。|'
- en: '| `[@attrib=''value'']` | This selects all the elements for which the given
    attribute has the given value. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib=''value'']` | 这选择具有给定属性值的所有元素。|'
- en: '| `[tag]` | This selects all the elements that have a child named tag. Only
    immediate children are supported. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `[tag]` | 这选择所有具有名为tag的子元素的元素。仅支持直接子元素。|'
- en: '| `[position]` | This selects all the elements that are located at the given
    position. The position can either be an integer (`1` is the first position), the
    `last()`expression (for the last position), or a position relative to the last
    position (for example, `last()-1`). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `[position]` | 这选择位于给定位置的元素。位置可以是整数（`1`是第一个位置），`last()`表达式（对于最后一个位置），或者相对于最后一个位置的位置（例如，`last()-1`）。|'
- en: Therefore, using `root.find("tracks").attrib["totalPages"]`, we read the total
    amount of pages. We will save the first page and then go through the other pages
    one by one and save them too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`root.find("tracks").attrib["totalPages"]`，我们读取总页数。我们将保存第一页，然后逐页保存其他页面。
- en: In the `save_page()` method, `root.findall("tracks/track")` returns an iterator
    through the `<track>` nodes under the `<tracks>` node. With `track_node.find("image[@size='medium']")`,
    we get the medium-sized image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save_page()`方法中，`root.findall("tracks/track")`返回一个通过`<tracks>`节点下的`<track>`节点进行迭代的迭代器。使用`track_node.find("image[@size='medium']")`，我们获取中等大小的图像。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can learn more about XPath at [https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath)上了解更多关于XPath的信息。
- en: The full documentation of `ElementTree` can be found at [https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementTree`的完整文档可以在[https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html)找到。'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Importing data from an external JSON file* recipe
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从外部JSON文件导入数据*的配方'
- en: Creating filterable RSS feeds
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可过滤的RSS订阅源
- en: Django comes with a syndication feed framework that allows you to create RSS
    and Atom feeds easily. RSS and Atom feeds are XML documents with specific semantics.
    They can be subscribed in an RSS reader such as Feedly or they can be aggregated
    in other websites, mobile applications, or desktop applications. In this recipe,
    we will create `BulletinFeed`, which provides a bulletin board with images. Moreover,
    the results will be filterable by URL query parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Django自带了一个内容聚合框架，允许你轻松创建RSS和Atom订阅源。RSS和Atom订阅源是具有特定语义的XML文档。它们可以在RSS阅读器如Feedly中订阅，也可以在其他网站、移动应用程序或桌面应用程序中聚合。在这个配方中，我们将创建`BulletinFeed`，它提供了一个带有图像的公告板。此外，结果可以通过URL查询参数进行过滤。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new `bulletin_board` app and put it under `INSTALLED_APPS` in the settings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`bulletin_board`应用，并将其放在设置中的`INSTALLED_APPS`下。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a `Bulletin` model and an RSS feed for it. We will be able to
    filter the RSS feed by type or category so that it is possible to only subscribe
    to the bulletins that are, for example, offering used books:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Bulletin`模型和相应的RSS订阅源。我们将能够通过类型或类别过滤RSS订阅源，以便只订阅例如提供二手书的公告：
- en: 'In the `models.py` file of this app, add the `Category` and `Bulletin` models
    with a foreign key relationship between them, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此应用的`models.py`文件中，添加`Category`和`Bulletin`模型，并在这两者之间建立外键关系，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, create `BulletinFilterForm` that allows the visitor to filter the bulletins
    by type and category, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建`BulletinFilterForm`，允许访客通过类型和类别过滤公告，如下所示：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a `feeds.py` file with the `BulletinFeed` class, as shown in the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含`BulletinFeed`类的`feeds.py`文件，如下所示：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a template for the bulletin description that will be provided in the
    feed, as shown in the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将在订阅源中提供的公告描述创建一个模板，如下所示：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a URL configuration for the bulletin board app and include it in the
    root URL configuration, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为公告板应用创建一个URL配置，并将其包含在根URL配置中，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will also need the views and templates for the filterable list and details
    of the bulletins. In the `Bulletin` list page template, add the following link:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要为可过滤的公告列表和详情提供视图和模板。在`Bulletin`列表页面模板中，添加以下链接：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Therefore, if you have some data in the database and you open `http://127.0.0.1:8000/bulletin-board/rss/?bulletin_type=offering&category=4`
    in your browser, you will get an RSS feed of bulletins with the `Offering` type
    and the `4` category ID.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在数据库中有一些数据，并在浏览器中打开`http://127.0.0.1:8000/bulletin-board/rss/?bulletin_type=offering&category=4`，你将获得具有`Offering`类型和`4`类别ID的公告RSS订阅源。
- en: The `BulletinFeed` class has the `get_objects()` method that takes the current
    `HttpRequest` and defines the `obj` dictionary used in other methods of the same
    class. The `obj` dictionary contains the bulletin type, category, and current
    query string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulletinFeed`类有一个`get_objects()`方法，它接受当前的`HttpRequest`并定义了该类其他方法中使用的`obj`字典。`obj`字典包含公告类型、类别和当前查询字符串。'
- en: The `title()` method returns the title of the feed. It can either be generic
    or related to the selected bulletin type or category. The `link()` method returns
    the link to the original bulletin list with the filtering done. The `feed_url()`
    method returns the URL of the current feed. The `items()` method does the filtering
    itself and returns a filtered `QuerySet` of bulletins. Finally, the `item_pubdate()`
    method returns the creation date of the bulletin.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`title()`方法返回订阅源的标题。它可以是通用的，也可以与所选的公告类型或类别相关。`link()`方法返回经过过滤的原始公告列表的链接。`feed_url()`方法返回当前订阅源的URL。`items()`方法执行过滤并返回过滤后的公告`QuerySet`。最后，`item_pubdate()`方法返回公告的创建日期。'
- en: To see all the available methods and properties of the `Feed` class that we
    are extending, refer to the following documentation at [https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们正在扩展的`Feed`类的所有可用方法和属性，请参阅以下文档：[https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference)。
- en: The other parts of the code are self-explanatory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分是自解释的。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a model mixin with URL-related methods* recipe in [Chapter 2](ch02.html
    "Chapter 2. Database Structure"), *Database Structure*
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在第二章*（[ch02.html "第二章. 数据库结构"](ch02.html "Chapter 2. Database Structure")）中，*数据库结构*的*创建具有与
    URL 相关方法的模型混入器*食谱'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Chapter 2](ch02.html "Chapter 2. Database Structure"), *Database Structure*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在第二章*（[ch02.html "第二章. 数据库结构"](ch02.html "Chapter 2. Database Structure")）中，*数据库结构*的*创建用于处理创建和修改日期的模型混入器*食谱'
- en: The *Using Tastypie to create API* recipe
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Tastypie 创建 API* 食谱'
- en: Using Tastypie to create API
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tastypie 创建 API
- en: '**Tastypie** is a framework for Django to create web service **Application
    Program Interface** (**API**). It supports full `GET`/`POST`/`PUT`/`DELETE`/`PATCH
    HTTP` methods to deal with online resources. It also supports different types
    of authentication and authorization, serialization, caching, throttling, and so
    on. In this recipe, you will learn how to provide bulletins to third parties for
    reading, that is, we will implement only the `GET HTTP` method.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tastypie** 是一个用于 Django 创建网络服务 **应用程序编程接口**（**API**）的框架。它支持完整的 `GET`/`POST`/`PUT`/`DELETE`/`PATCH
    HTTP` 方法来处理在线资源。它还支持不同类型的身份验证和授权、序列化、缓存、节流等功能。在本教程中，你将学习如何为第三方提供公告以供阅读，也就是说，我们只实现
    `GET HTTP` 方法。'
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, install `Tastypie` in your virtual environment using the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在你的虚拟环境中安装 `Tastypie`：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add Tastypie to `INSTALLED_APPS` in the settings. Then, enhance the `bulletin_board`
    app that we defined in the *Creating filterable RSS feeds* recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置中将 Tastypie 添加到 `INSTALLED_APPS`。然后，增强我们在 *创建可过滤的 RSS 源* 食谱中定义的 `bulletin_board`
    应用。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create an API for bulletins and inject it in the URL configuration
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为公告创建一个 API 并将其注入到 URL 配置中，如下所示：
- en: 'In the `bulletin_board` app, create an `api.py` file with two resources, `CategoryResource`
    and `BulletinResource`, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bulletin_board` 应用中，创建一个 `api.py` 文件，包含两个资源，`CategoryResource` 和 `BulletinResource`，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the main URL configuration, include the API URLs, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主 URL 配置中，包含 API URL，如下所示：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create a Tastypie API key for the admin user in the model administration. To
    do this, navigate to **Tastypie** | **Api key** | **Add Api key**, select the
    admin user, and save the entry. This will generate a random API key, as shown
    in the following screenshot:![How to do it...](img/B04912_09_01.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模型管理中为管理员用户创建一个 Tastypie API 密钥。为此，导航到 **Tastypie** | **Api key** | **添加 Api
    key**，选择管理员用户，并保存条目。这将生成一个随机 API 密钥，如下面的截图所示：![如何操作...](img/B04912_09_01.jpg)
- en: 'Then, you can open this URL to see the JSON response in action (simply replace
    xxx with your API key): `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以打开此 URL 来查看 JSON 响应在操作中的效果（只需将 xxx 替换为你的 API 密钥）：`http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx`。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each endpoint of `Tastypie` should have a class extending `ModelResource` defined.
    Similar to the Django models, the configuration of the resource is set in the
    `Meta` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tastypie` 的每个端点都应该有一个扩展 `ModelResource` 的类定义。类似于 Django 模型，资源的配置设置在 `Meta`
    类中：'
- en: The `queryset` parameter defines the `QuerySet` of objects to list.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryset` 参数定义了要列出的对象的 `QuerySet`。'
- en: The `resource_name` parameter defines the name of the URL endpoint.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_name` 参数定义了 URL 端点的名称。'
- en: The `fields` parameter lists out the fields of the model that should be shown
    in the API.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields` 参数列出了在 API 中应显示的模型字段。'
- en: The `allowed_methods` parameter lists out the request methods, such as `get`,
    `post`, `put`, `delete`, and `patch`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowed_methods` 参数列出了请求方法，例如 `get`、`post`、`put`、`delete` 和 `patch`。'
- en: The `authentication` parameter defines how third parties can authenticate themselves
    when connecting to the API. The available options are `Authentication`, `BasicAuthentication`,
    `ApiKeyAuthentication`, `SessionAuthentication`, `DigestAuthentication`, `OAuthAuthentication`,
    `MultiAuthentication`, or your own custom authentication. In our case, we are
    using `ApiKeyAuthentication` as we want each user to use `username` and `api_key`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authentication`参数定义了第三方在连接到API时如何进行身份验证。可用的选项有`Authentication`、`BasicAuthentication`、`ApiKeyAuthentication`、`SessionAuthentication`、`DigestAuthentication`、`OAuthAuthentication`、`MultiAuthentication`或你自己的自定义身份验证。在我们的案例中，我们使用`ApiKeyAuthentication`，因为我们希望每个用户使用`username`和`api_key`。'
- en: 'The `authorization` parameter answers the authorization question: is permission
    granted to this user to take the stated action? The possible choices are `Authorization`,
    `ReadOnlyAuthorization`, `DjangoAuthorization`, or your own custom authorization.
    In our case, we are using `ReadOnlyAuthorization` as we only want to allow read
    access to the users.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorization`参数回答了授权问题：是否允许此用户执行所声明的操作？可能的选项有`Authorization`、`ReadOnlyAuthorization`、`DjangoAuthorization`或你自己的自定义授权。在我们的案例中，我们使用`ReadOnlyAuthorization`，因为我们只想允许用户进行读取访问。'
- en: 'The `filtering` parameter defines by which fields one can filter the lists
    in the URL query parameters. For example, with the current configuration, you
    can filter the items by titles that contain the word "`movie`": `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx&title__contains=movie`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtering`参数定义了可以通过哪些字段在URL查询参数中过滤列表。例如，根据当前配置，你可以通过包含单词"`movie`"的标题来过滤项目：`http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx&title__contains=movie`。'
- en: Also, there is a `category` foreign key that is defined in `BulletinResource`
    with the `full=True` argument, meaning that the full list of category fields will
    be shown in the bulletin resource instead of an endpoint link.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个在`BulletinResource`中定义的`category`外键，使用`full=True`参数，这意味着在公告资源中会显示完整的类别字段列表，而不是一个端点链接。
- en: Besides JSON, `Tastypie` allows you to use other formats such as XML, YAML,
    and bplist.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JSON之外，`Tastypie`还允许你使用其他格式，如XML、YAML和bplist。
- en: There is a lot more that you can do with APIs using Tastypie. To find out more
    details, check the official documentation at [http://django-tastypie.readthedocs.org/en/latest/](http://django-tastypie.readthedocs.org/en/latest/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tastypie可以与API做更多的事情。要了解更多详细信息，请查看官方文档[http://django-tastypie.readthedocs.org/en/latest/](http://django-tastypie.readthedocs.org/en/latest/)。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建可过滤的RSS源* 配方'
- en: The *Using Django REST framework to create API* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Django REST框架创建API* 的配方'
- en: Using Django REST framework to create API
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django REST框架创建API
- en: Besides Tastypie, there is a newer and fresher framework to create API for your
    data transfers to and from third parties. That's Django REST Framework. This framework
    has more extensive documentation and Django-ish implementation, it is also more
    maintainable. Therefore, if you have to choose between Tastypie or Django REST
    Framework, I would recommend the latter one. In this recipe, you will learn how
    to use Django REST Framework in order to allow your project partners, mobile clients,
    or Ajax-based website to access data on your site to create, read, update, and
    delete.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Tastypie之外，还有一个更新、更鲜活的框架可以用来为你的数据传输到第三方创建API。那就是Django REST Framework。这个框架有更广泛的文档和类似Django的实现，它也更容易维护。因此，如果你必须在Tastypie和Django
    REST Framework之间选择，我会推荐后者。在这个配方中，你将学习如何使用Django REST Framework来允许你的项目合作伙伴、移动客户端或基于Ajax的网站访问你网站上的数据，以创建、读取、更新和删除。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, install Django REST Framework and its optional dependencies in
    your virtual environment using the following commands:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在你的虚拟环境中安装Django REST Framework及其可选依赖项：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add `rest_framework` to `INSTALLED_APPS` in the settings. Then, enhance the
    `bulletin_board` app that we defined in the *Creating filterable RSS feeds* recipe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将`rest_framework`添加到设置中的`INSTALLED_APPS`。然后，增强我们在*创建可过滤的RSS源*配方中定义的`bulletin_board`应用。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To integrate a new REST API in our `bulletin_board` app, execute the following
    steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的`bulletin_board`应用中集成一个新的REST API，请执行以下步骤：
- en: 'Add the specific configurations to the settings:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将特定的配置添加到设置中：
- en: '[PRE27]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `bulletin_board` app, create the `serializers.py` file with the following
    content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bulletin_board`应用中，创建一个名为`serializers.py`的文件，内容如下：
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add two new class-based views to the `views.py` file in the `bulletin_board`
    app:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bulletin_board`应用中的`views.py`文件中添加两个新的基于类的视图：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, plug in the new views to the URL configuration:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将新视图连接到URL配置：
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: What we created here is an API for the bulletin board, where one can read a
    paginated bulletin list; create a new bulletin; and read, change, or delete a
    single bulletin by ID. Reading is allowed without authentication; whereas, one
    has to have a user account with appropriate permissions to add, change, or delete
    a bulletin.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的是一个公告板的API，用户可以读取分页的公告列表；创建一个新的公告；通过ID读取、更改或删除单个公告。读取不需要认证；而添加、更改或删除公告则需要拥有具有适当权限的用户账户。
- en: 'Here''s how you can approach the created API:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以如何接近创建的API：
- en: '| URL | HTTP Method | Description |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| URL | HTTP 方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `GET` | List bulletins
    paginated by 100 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `GET` | 以分页方式列出100条公告
    |'
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `POST` | Create a new
    bulletin if the requesting user is authenticated and authorized to create bulletins
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `POST` | 如果请求用户已认证并有权创建公告，则创建一个新的公告
    |'
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `GET` | Get a bulletin
    with the `1` ID |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `GET` | 获取ID为`1`的公告
    |'
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `PUT` | Update a bulletin
    with the `1` ID, if the user is authenticated and authorized to change bulletins
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `PUT` | 如果用户已认证并有权更改公告，则更新ID为`1`的公告
    |'
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `DELETE` | Delete the
    bulletin with the `1` ID, if the user is authenticated and authorized to delete
    bulletins |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `DELETE` | 如果用户已认证并有权删除公告，则删除ID为`1`的公告
    |'
- en: 'How to use the API practically? For example, if you have the `requests` library
    installed, you can create a new bulletin in the Django shell as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实际使用API？例如，如果你已经安装了`requests`库，你可以在Django shell中按照以下方式创建一个新的公告：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, Django REST Framework provides you with a web-based API documentation
    that is shown when you access the API endpoints in a browser. There you can also
    try out the APIs by integrated forms, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Django REST Framework为你提供了一个基于Web的API文档，当你通过浏览器访问API端点时，它会显示出来。在那里，你也可以通过集成表单尝试API，如下面的截图所示：
- en: '![How it works...](img/B04912_09_02.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04912_09_02.jpg)'
- en: Let's take a quick look at how the code that we wrote works. In the settings,
    we have set the access to be dependent on the permissions of the Django system.
    For anonymous requests, only reading is allowed. Other access options include
    allowing any permission to everyone, allowing any permission only to authenticated
    users, allowing any permission to staff users, and so on. The full list can be
    found at [http://www.django-rest-framework.org/api-guide/permissions/](http://www.django-rest-framework.org/api-guide/permissions/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们编写的代码是如何工作的。在设置中，我们已将访问设置为依赖于Django系统的权限。对于匿名请求，只允许读取。其他访问选项包括允许任何权限给所有人，允许任何权限仅给认证用户，允许任何权限给工作人员用户，等等。完整的列表可以在[http://www.django-rest-framework.org/api-guide/permissions/](http://www.django-rest-framework.org/api-guide/permissions/)找到。
- en: Then, in the settings, pagination is set. The current option is to have the
    `limit` and `offset` parameters like in an SQL query. Other options are to have
    either pagination by page numbers for rather static content or cursor pagination
    for real-time data. We set the default pagination to 100 items per page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在设置中，分页被设置为。当前选项是使用类似于SQL查询的`limit`和`offset`参数。其他选项包括使用页码分页来处理相对静态的内容，或者使用游标分页来处理实时数据。我们将默认分页设置为每页100项。
- en: Later we define serializers for categories and bulletins. They handle the data
    that will be shown in the output or validated by the input. In order to handle
    category retrieval or saving, we had to overwrite the `create()` and `update()`
    methods of `BulletinSerializer`. There are various ways to serialize relations
    in Django REST Framework and we chose the most verbose one in our example. To
    read more about how to serialize relations, refer to the documentation at [http://www.django-rest-framework.org/api-guide/relations/](http://www.django-rest-framework.org/api-guide/relations/).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为类别和公告定义了序列化器。它们处理将在输出中显示或由输入验证的数据。为了处理类别检索或保存，我们必须重写`BulletinSerializer`的`create()`和`update()`方法。在Django
    REST Framework中处理关系有多种方式，我们在示例中选择了最详细的一种。要了解更多关于如何序列化关系的信息，请参阅[http://www.django-rest-framework.org/api-guide/relations/](http://www.django-rest-framework.org/api-guide/relations/)的文档。
- en: After defining the serializers, we created two class-based views to handle the
    API endpoints and plugged them in the URL configuration. In the URL configuration,
    we have a rule (`/api-auth/`) for browsable API pages, login, and logout.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义序列化器之后，我们创建了两个基于类的视图来处理API端点，并将它们插入到URL配置中。在URL配置中，我们有一个规则（`/api-auth/`）用于可浏览的API页面、登录和注销。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建可过滤的RSS源*菜谱'
- en: The *Using Tastypie to create API* recipe
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Tastypie创建API*菜谱'
- en: The *Testing API created using Django REST framework* recipe in [Chapter 11](ch11.html
    "Chapter 11. Testing and Deployment"), *Testing and Deployment*
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第11章[测试和部署](ch11.html "第11章。测试和部署")中，*使用Django REST framework创建的API测试*菜谱
