- en: Chapter 3. Further Test Customization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。进一步测试定制
- en: 'This chapter covers syntax and styles necessary to create reusable test components
    for automated tests. Apart from the Robot Framework centric tests, it also covers
    an introduction to behavior-driven development and covers the following major
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了创建可复用测试组件所需的语法和样式，以便进行自动化测试。除了以Robot Framework为中心的测试外，它还介绍了行为驱动开发，并涵盖了以下主要主题：
- en: Need for test re-use
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试复用的必要性
- en: Internal and external re-use
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部和外部复用
- en: Feeding data into test scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据输入到测试脚本中
- en: Higher order test re-use
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶测试复用
- en: Different styles of writing tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同风格的测试编写
- en: Automation and agile
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化和敏捷
- en: The agile manifesto places tremendous importance on usable code over conventional
    documents. It encourages practices such as extreme programming, which is a type
    of agile software development practice that improves software quality and makes
    the software development more responsive to the ever changing customer requirements.
    Amongst other important tenets of this practice is the automated acceptance testing.
    An acceptance test is simply some code that can be run and captures at its heart
    some aspect of the functionality of the system. The idea is that both the developer
    and the stakeholder collaborate on writing this test together, to capture the
    requirements in the code, which when passed, forms some kind of seal of approval.
    These are distinct from unit and integration tests as they are largely written
    by the developer, and for the developer. They help them emerge, validate design,
    and protect against errors. Acceptance tests are written by the stakeholder and
    the developer, for the stakeholder and the developer. Agile methodology places
    importance over tests as tests themselves become specifications rather than business
    reports or documentation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷宣言非常重视可用的代码而非传统文档。它鼓励诸如极限编程等实践，这是一种敏捷软件开发实践，可以提高软件质量，并使软件开发更能响应不断变化的客户需求。该实践的其他重要原则之一是自动化的验收测试。验收测试简单来说是一些可以运行并捕捉系统功能某个方面的代码。其理念是开发者和利益相关者共同编写此测试，以将需求体现在代码中，当测试通过时，形成某种形式的批准印章。这些测试与单元测试和集成测试不同，因为它们主要是由开发者为开发者编写的，有助于他们出现、验证设计和防止错误。验收测试是由利益相关者和开发者编写的，为利益相关者和开发者而写。敏捷方法将重要性放在测试上，因为测试本身成为规范而不是业务报告或文档。
- en: A commonly used expression is that the difference between unit tests and acceptance
    tests is that unit tests helps you build the thing right, whereas acceptance tests
    helps you build the right thing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的说法是，单元测试和验收测试之间的区别在于，单元测试帮助你正确构建事物，而验收测试帮助你构建正确的事物。
- en: As mentioned before, the Robot Framework as an automated acceptance test-driven
    development tool provides various capabilities out of the box and allows the user
    with enough flexibility to go about with automation to ensure that the software
    in question can always have its basic functionality in place.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Robot Framework作为一个自动化的验收测试驱动开发工具，提供了各种开箱即用的功能，并允许用户有足够的灵活性来进行自动化，以确保所讨论的软件始终具备其基本功能。
- en: 'Before proceeding with writing down the tests, it is necessary to know how
    to implement a design that will help scale and maintain the tests for future requirements.
    Similar to the creation of any other software, the tests written in modular fashion
    enable re-use through selection of different test modules as required. This can
    better be explained by the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试之前，有必要了解如何实现一个设计，该设计将有助于扩展和维护测试以适应未来的需求。与其他任何软件的创建类似，以模块化方式编写的测试可以通过选择不同的测试模块来实现复用。以下图表可以更好地解释这一点：
- en: '![Automation and agile](img/3033OS_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![自动化和敏捷](img/3033OS_03_01.jpg)'
- en: Here, it is evident that separation of test **1** into a unique module has enabled
    us to use the same set of tests in part of three other tests, thereby reducing
    the amount of repetition involved in writing if the tests were to be created manually.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很明显，将测试**1**分离到一个独特的模块中，使我们能够在三个其他测试的部分中使用相同的测试集，从而减少了手动创建测试时的重复量。
- en: However, generally, during acceptance tests, there are some portions that are
    unique to the situation under which the test is executing. Consider the following
    example that needs to perform acceptance testing for a large website consisting
    of hundreds of pages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常在验收测试期间，有一些部分是特定于测试执行情况的。考虑以下需要为包含数百页面的大型网站执行验收测试的示例。
- en: 'Test website module functionality:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网站模块功能：
- en: Open the browser.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器。
- en: Go to the specific page URL.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往特定的页面URL。
- en: Ensure that it is not an empty page/invalid URL.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它不是一个空页面/无效的**URL**。
- en: Check whether the site headers and footers exist and are displayed properly.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查网站头部和尾部是否存在并且显示正确。
- en: Ascertain if the actual page content (excluding the header and footer) is not
    empty.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认实际页面内容（不包括头部和尾部）不为空。
- en: Search and verify whether a specific element exists in the page.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并验证页面中是否存在特定元素。
- en: Close the browser.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Even in this brief test, there are innumerable possibilities and a single test
    cannot address all of them. For this reason, testers make copies of tests such
    as this and after making changes, put them elsewhere to meet another requirement.
    However, copying leads to presence of duplicate tests that are hard to change
    as change in the environment requires changes across the different tests. On the
    other hand, if there is test re-use, then changes in the re-used test at one place
    can reflect across different tests. To address the concern of uniqueness in different
    scenarios, one can parameterize the same test. In the preceding example, a possible
    parameterization can be as follows.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简短的测试中，也有无数的可能性，单个测试无法涵盖所有这些。因此，测试人员会复制此类测试，并在进行更改后将其放置在其他地方以满足其他要求。然而，复制会导致存在难以更改的重复测试，因为环境的变化需要在不同的测试中进行更改。另一方面，如果存在测试复用，那么在某个地方对复用测试的更改可以反映到不同的测试中。为了解决不同场景中独特性的问题，可以对相同的测试进行参数化。在前面的示例中，可能的参数化可以是以下这样。
- en: 'Test website module functionality(browser, URL, and content):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网站模块功能（浏览器、URL和内容）：
- en: Open the **browser** (select the specified browser).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**浏览器**（选择指定的浏览器）。
- en: Go to the specific page **URL** (as specified in the parameters).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往特定的页面**URL**（如参数中指定）。
- en: Ensure that it is not an empty page/invalid **URL**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它不是一个空页面/无效的**URL**。
- en: Check whether the site headers and footers exist and are displayed properly.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查网站头部和尾部是否存在并且显示正确。
- en: Ascertain if the actual page **content** (excluding the header and footer as
    specified in the parameter) is not empty.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认实际页面**内容**（不包括参数中指定的头部和尾部）不为空。
- en: Search and verify whether the parameterized **content** exists in the page.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并验证页面中是否存在参数化的**内容**。
- en: Close the browser.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Now the same test can be used in a wide variety of scenarios (read pages) and
    different portions of the entire website can be tested for page contents using
    the same test.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相同的测试可以在广泛的场景（阅读页面）中使用，并且可以使用相同的测试来测试整个网站的不同部分的内容。
- en: As mentioned here, the same parameterized approach to create reusable tests
    can be applied to the Robot Framework through the use of variables. The variables
    can be used as an input mechanism from a given source of information which is
    not related with the test and the execution of tests occurs depending upon the
    obtained data. As repetition of test actions forms the cornerstone of test re-use,
    there is a possibility to repeat test actions even within the tests. While doing
    so, a single test or use case can repeat the same instructions again internally,
    often with some variable data that is unique to a specific repetition. These are
    detailed in the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所述，创建可复用测试的相同参数化方法可以通过使用变量应用于Robot Framework。变量可以用作从给定信息源（与测试和测试执行无关）的输入机制，测试执行取决于获得的数据。由于测试操作的重复是测试复用的基石，因此即使在测试内部也有可能重复测试操作。在这样做的时候，单个测试或用例可以再次内部重复相同的指令，通常伴随着一些特定重复的独特变量数据。这些内容将在以下章节中详细说明。
- en: Internal re-use
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部复用
- en: As mentioned earlier, repetition within the single test constitutes test re-use
    internally. Note that the data, if any, involved in different instances of the
    iterations might come from outside, but the repetition only occurs within the
    test action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单个测试内的重复构成内部测试复用。请注意，涉及不同迭代实例的数据（如果有的话）可能来自外部，但重复仅发生在测试操作内部。
- en: Loops and flow control
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环和流程控制
- en: Having gained a good background of the syntax of writing a test, it is time
    to move on to the most common and convenient way of iteration, that is, a loop.
    Robot Framework solves this problem through the use of Python styled `for` loops,
    but that's easily understandable for the uninitiated as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了编写测试的语法背景之后，现在是时候转向最常见且方便的迭代方式了，那就是循环。Robot Framework通过使用Python风格的`for`循环来解决这一问题，但对于初学者来说也容易理解。
- en: It follows a straightforward syntax, the loop is started with `FOR` which is
    a special keyword. This is followed with a variable that is present within the
    loop. This variable is followed by a mandatory `IN` statement. This is followed
    by the variable or a collection over which the `for` loop is to run. Like Python
    loops, the subsequent statements are indented by a single space. As soon as the
    indentation stops, it is assumed that the body of the loop is finished.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循直接的语法，循环以特殊关键词`FOR`开始。接下来是一个存在于循环内的变量。这个变量后面跟着一个强制性的`IN`语句。然后是`for`循环要运行的变量或集合。与Python循环一样，后续语句缩进一个空格。一旦缩进停止，就假定循环体已经完成。
- en: 'All this seems like an iterative construct of any programming language, but
    in the Robot Framework there are a couple of exceptions, such as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来像是任何编程语言的迭代结构，但在Robot Framework中存在一些例外，例如：
- en: The `for` loop can iterate with multiple variables
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环可以使用多个变量进行迭代。'
- en: The loop cannot have directly nested loops within itself, but can make use of
    custom keywords within the loops that can contain loops within themselves
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环不能在其内部直接嵌套循环，但可以在循环中使用自定义关键词，这些关键词可以包含嵌套循环。
- en: The **scalar variable** collection over which the loop iterates can be specified
    as different arguments
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环迭代的**标量变量**集合可以指定为不同的参数
- en: Note that the `for` loop requires explicit whitespace definition to clearly
    demarcate different columns as a simple text file with space/tab delimiters wouldn't
    do. If tried to run, it will print out the error message "FOR loop contains no
    keywords". This is because the body of the loop requires (an extra) indentation,
    which is not possible in simple whitespace as two or more than two spaces are
    only constructed as a single separation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`for`循环需要显式地定义空白，以清楚地划分不同的列，因为简单的文本文件使用空格/制表符作为分隔符是不够的。如果尝试运行，它将打印出错误信息“FOR
    loop contains no keywords”。这是因为循环体需要（额外的）缩进，而在简单的空白中这是不可能的，因为两个或两个以上的空格只能作为一个分隔符。
- en: 'The `for` loop has a variant that allows for iteration over a range of values.
    This is idiomatic Python, but is quite convenient at times. Its syntax is: `FOR`
    keyword followed by a single variable. Next comes the `In Range` keyword that
    provides various range limits through arguments. This can be demonstrated as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环有一个变体，允许遍历一系列值。这是Python的惯用法，但有时非常方便。其语法是：`FOR`关键词后跟一个变量。接下来是`In Range`关键词，它通过参数提供各种范围限制。以下是如何演示的：'
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Flow control
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: At times during the loop iteration, there may be cases where the execution needs
    to be changed, which can be done either to skip the present and continue with
    the next iteration or to terminate the loop entirely.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环迭代过程中，有时需要改变执行方式，这可以是跳过当前迭代并继续下一个迭代，或者完全终止循环。
- en: Sometimes, the loop contents need to be processed in such a manner, which is
    not iterative in nature. In this case, we need to issue special commands that
    allow us to manipulate the contents of the flow of contents within the loop irrespective
    of the iteration status. In most conventional programming languages, this is specified
    by the `continue` and `break` constructs. Robot Framework offers a similar approach
    by providing some special keywords for this purpose in its default library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，循环内容需要以非迭代的方式进行处理。在这种情况下，我们需要发出特殊的命令，允许我们根据迭代状态来操作循环内容流中的内容。在大多数传统编程语言中，这通过`continue`和`break`结构来实现。Robot
    Framework通过在其默认库中提供一些特殊关键词来实现类似的方法。
- en: Breaking off without finishing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在完成前中断
- en: 'By using the `Exit For Loop` or the `Exit For Loop If` built-in keywords, it
    is possible to terminate the loop and continue with the further statements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用内置关键词`Exit For Loop`或`Exit For Loop If`，可以终止循环并继续执行后续语句：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, `Run Keyword if` is used, which is present in the
    built-in library. As soon as its condition is evaluated to true, it is executed
    and the `Exit for Loop` keyword causes the loop to terminate. If the test case
    contains any other statements after the loop, then they will get executed normally.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了`Run Keyword if`，这是内置库中的一个功能。一旦其条件评估为真，它就会被执行，并且`Exit for Loop`关键字会导致循环终止。如果测试用例在循环之后有任何其他语句，那么它们将正常执行。
- en: 'This can be simplified through the use of `Exit For Loop If` keyword as it
    acts as a handler for the break operation without requiring a separate `if` condition
    and hence the preceding command can be rewritten as:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`Exit For Loop If`关键字来简化，因为它作为break操作的处理器，而不需要单独的`if`条件，因此前面的命令可以重写为：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Continuing with the next iteration, similar to breaking the loop, sometimes
    there are exceptional cases where there is a need to continue with the next iteration
    of the loop before the present iteration has completed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行下一个迭代，类似于中断循环，有时在当前迭代完成之前，需要继续进行循环的下一个迭代，这时会有一些特殊情况：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the use of the `If` suffix on various commands. The `If` statement is not
    a specific keyword, but many statements, such as the `Exit For Loop` and `continue`
    keywords, have alternate definitions that act conditionally in the presence of
    certain conditions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意各种命令上`If`后缀的使用。`If`语句不是一个特定的关键字，但许多语句，如`Exit For Loop`和`continue`关键字，在特定条件下有条件性的替代定义。
- en: Feeding external data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供外部数据
- en: Tests can be fed data from any external data store such as a database, an Excel,
    or a CSV file or some external application that returns values dynamically and
    then can execute over the same data. To demonstrate this concept of test re-use
    further, we will undertake another exercise that focuses on performing the same
    task repeatedly. For the sake of the reader, we have abstracted the concepts now
    as these can then be implemented in whichever manner possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以从任何外部数据存储中获取数据，例如数据库、Excel或CSV文件，或者某些返回动态值的外部应用程序，然后可以在相同的数据上执行。为了进一步演示测试重用的概念，我们将进行另一个练习，该练习侧重于重复执行相同的任务。为了方便读者，我们现在将这些概念抽象化，因为它们可以用任何可能的方式实现。
- en: 'Basically, if we are having a set of repeatable tasks specified in a collection
    of values, then we can perform them in two different manners:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果我们有一组在值集合中指定的可重复任务，那么我们可以以两种不同的方式执行它们：
- en: Perform the set of tasks repeatedly inside a test for each value
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中对每个值重复执行任务集
- en: Perform the entire test repeatedly for the values
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对这些值重复执行整个测试
- en: Performing a set of tasks repeatedly within a test
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试中重复执行一系列任务
- en: 'In this scenario, we create a test that takes in the argument or uses a variable
    containing a list of elements and iterate over it. As a precursor to this, first
    let us create the file containing the dynamic variable. Here, the system under
    test is a Python script that selects values out of current time in an array whose
    value we cannot predetermine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建一个测试，它接受一个参数或使用包含元素列表的变量，并遍历它。作为这个过程的先导，首先让我们创建包含动态变量的文件。在这里，被测试的系统是一个Python脚本，它从当前时间中选取数组中的值，而我们无法预先确定这些值：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding script first imports the `time` module as it will be used in the
    program later on. Next, the `var` array is created. This is followed by a `while`
    loop that checks the last decimal value of the currently elapsed time and checks
    if it is less than `8`. If it is, then it adds this last value as an integer into
    the array and sleeps for a second to get another value. Although, the `var` array
    is not randomized, its size and contents are unknown beforehand, which makes the
    `var` array dynamic at runtime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本首先导入了`time`模块，因为它将在程序后面使用。接下来创建`var`数组。然后是一个`while`循环，它检查当前已过时间的最后一位小数，并检查它是否小于`8`。如果是，则将这个最后值作为一个整数添加到数组中，并暂停一秒钟以获取另一个值。尽管`var`数组不是随机的，但它的尺寸和内容在事先是未知的，这使得`var`数组在运行时是动态的。
- en: 'This lets us have the variable `var` with an unspecified amount of value. Now
    we can use it to better utilize collection of values within tests. Within the
    test, first this Python variable file is loaded and then the contents are iterated
    upon:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有了变量`var`，它可以具有未指定的值量。现在我们可以利用它更好地利用测试中的值集合。在测试中，首先加载这个Python变量文件，然后迭代其内容：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will load the contents from the script, and iterate over the collection
    of values and perform a sample task over the value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载脚本中的内容，并对值集合进行迭代，对每个值执行一个样本任务。
- en: Application in test automation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测试自动化中的应用
- en: The outlined concept of looping can be applied in test automation through the
    use of customized user keywords and loading of test data via an external program
    that can leverage any available data medium to load the data for the system under
    test. As explained earlier, this is useful in achieving test re-use and ensuring
    that as testers, we follow the principals of **Don't Repeat Yourself** (**DRY**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自定义用户关键词和通过外部程序加载测试数据（该程序可以利用任何可用的数据介质来加载测试系统的数据），可以将概述的循环概念应用于测试自动化。如前所述，这有助于实现测试重用，并确保我们作为测试人员遵循**不要重复自己**（**DRY**）的原则。
- en: Higher order re-use
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶重用
- en: The tests can be repeated within the test suite through the creation and use
    of constructs of higher order that contain various test commands and at times
    even entire tests. This enables the tester to combine similar or equivalent user
    stories or use cases into a single test and provide different inputs depending
    upon the circumstances. Another significant advantage that test re-use offers
    is the overall clarity of the project. Tests if re-used have to be called from
    various places, thereby giving the benefits of DRY.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建和使用包含各种测试命令甚至整个测试的高阶结构，可以在测试套件中重复测试。这使得测试人员可以将类似或等效的用户故事或用例组合成一个单独的测试，并根据情况提供不同的输入。测试重用提供的另一个显著优势是项目的整体清晰度。如果重用测试，则必须从各个地方调用它们，从而带来DRY的好处。
- en: User keywords
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户关键词
- en: As mentioned earlier, user keywords can be used to embed a part of test into
    a single custom keyword. These can be re-used and they can also specify arguments
    in their definition, which can be used to pass on test data parameters by the
    callers of these tests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户关键词可以用来将测试的一部分嵌入到一个单独的自定义关键词中。这些可以重用，它们还可以在其定义中指定参数，这些参数可以通过这些测试的调用者传递测试数据参数。
- en: Test templates
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模板
- en: 'Test templates are used to create components within a test that can accept
    different parameters at runtime. This is different from user keywords as the user
    keywords have to be called with their name and arguments by the caller, but templates
    are provided with only the data to be processed. A better picture can be obtained
    from a sample template that just logs the provided data to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模板用于在测试中创建可以接受不同运行时参数的组件。这与用户关键词不同，因为用户关键词必须通过调用者以它们的名称和参数来调用，但模板只提供要处理的数据。可以从以下示例模板中获得更好的图片，该模板只是将提供的数据记录到其中：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example provides the arguments to the template one at a time in order
    to get itself processed. Here the test repeats the operation specified by the
    templates to its arguments and the test effectively becomes the shorter version
    of the following actual test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例按顺序向模板传递参数，以便自身被处理。在这里，测试重复执行模板指定的操作，并且测试实际上变成了以下实际测试的简短版本：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this is a simple example of template that is only visible inside the
    test cases table. There are other possibilities in creation of a template that
    can be re-used across different tests. Through the use of templates, the test
    becomes more oriented towards data and the official Robot Framework documentation
    states that, through templates, the keyword driven tests can be converted into
    data driven tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个简单的模板示例，仅在测试用例表中可见。还有其他创建模板的可能性，可以在不同的测试中重用。通过使用模板，测试变得更加面向数据，Robot Framework官方文档指出，通过模板，关键字驱动测试可以转换为数据驱动测试。
- en: User libraries
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户库
- en: User libraries provide wrappers for implementing functionality into the Robot
    Framework. By using user libraries, we are able to extend the framework to provide
    for a certain task, or more importantly, extend the capability of this tool to
    work on some other tool. Conversely, to use a custom library, the Robot Framework
    test must follow the keywords made available by such a library and provide data
    to the necessary arguments, thereby fulfilling the keyword format contract that
    leads to correct execution of the tests. This technique of creating customized
    library and consuming it in various tests will be dealt in detail in the next
    chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用户库为将功能实现到Robot Framework中提供了包装器。通过使用用户库，我们能够扩展框架以提供特定任务，或者更重要的是，扩展工具的能力以在其他工具上工作。相反，要使用自定义库，Robot
    Framework测试必须遵循该库提供的关键字，并提供必要参数的数据，从而满足导致测试正确执行的关键字格式合约。这种创建自定义库并在各种测试中使用的技巧将在下一章中详细讨论。
- en: Approaches towards writing tests
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试的方法
- en: There are various approaches involved in testing and it is often the different
    nature of various test writing styles that separates the tests from other forms
    of software development. Writing acceptance tests can either be done by using
    the standard and external library keywords directly as mentioned before, or by
    using some mechanism to simplify the text of tests and make them more readable
    from the perspective of a non-technical person. This is crucial in agile software
    development as the stakeholders are involved in the design of software early on
    that might not be technically inclined or requiring to understand the syntax of
    tests like a programmer. However, they can provide a vision of how an application
    is supposed to work or behave; their input and feedback are important.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试涉及多种方法，通常不同测试编写风格的不同性质将测试与其他软件开发形式区分开来。编写验收测试可以通过直接使用之前提到的标准库和外部库关键字来完成，或者通过使用某种机制简化测试文本，使其对非技术人员更具可读性。这在敏捷软件开发中至关重要，因为利益相关者在软件设计早期就参与其中，可能不具备技术倾向或需要像程序员一样理解测试的语法。然而，他们可以提供关于应用程序应该如何工作或表现的观点；他们的输入和反馈很重要。
- en: 'The Robot Framework supports mainly three styles of writing tests. While the
    execution and output of the tests are not different, it is the nature of the test''s
    syntax itself that separates it from a similar test written in a different style.
    These are explained in detail in the following section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Robot Framework主要支持三种编写测试的风格。虽然测试的执行和输出没有区别，但测试语法的本质正是将其与不同风格编写的类似测试区分开来。这些内容将在以下部分详细解释：
- en: Keyboard-driven tests
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘驱动测试
- en: Keyboard-driven test is the most commonly used technique where the test is broken
    down into different portions known as keywords, which determine the contents of
    the tests. These keywords may further contain other keywords or tests, which are
    able to be re-used and extracted wherever needed. Through the use of keywords,
    test constructs can be made abstract and multiple and/or complex statements can
    be added under a single keyword that can make the tests a lot easier to understand
    and its function can be easily understood.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘驱动测试是最常用的技术，其中测试被分解为称为关键字的不同部分，这些关键字决定了测试的内容。这些关键字可以进一步包含其他关键字或测试，这些关键字或测试可以在需要的地方重用和提取。通过使用关键字，测试结构可以变得抽象和多样化，并且可以在单个关键字下添加多个和/或复杂的语句，从而使测试更容易理解，其功能也容易理解。
- en: 'To better understand this approach, consider the following test code, which
    uses the process library to open the Firefox browser with [google.com](http://google.com)
    as the opened page:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种方法，考虑以下测试代码，它使用进程库以[google.com](http://google.com)作为打开的页面打开Firefox浏览器：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now consider the keyword approach:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑关键字方法：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This does exactly the same as the previous code, but offers much clearer view
    in the test. Its implementation details can be hidden in the `Keyword` table as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的代码完全相同，但在测试中提供了更清晰的视图。其实现细节可以像以下这样隐藏在`Keyword`表中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Data-driven tests
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据驱动测试
- en: The data-driven tests are useful while doing parameterization as the same test
    can be re-used with data comprising of different values. This makes tests like
    these versatile and without performing the same set of actions, one can easily
    have various test cases where the task to be carried out largely remains the same
    with only the inputs and outputs to be changed. This differs from the keyword-driven
    tests as these tests are coarser, granular, and depend on the test templates to
    provide the necessary tests in place as explained in the test template section
    earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动测试在进行参数化时很有用，因为相同的测试可以用包含不同值的不同的数据重新使用。这使得这些测试具有多功能性，并且在不执行相同的一组操作的情况下，可以轻松地拥有各种测试案例，其中要执行的任务在很大程度上保持不变，只需更改输入和输出即可。这与关键字驱动测试不同，因为这些测试更粗糙、更细粒度，并且依赖于测试模板来提供必要的测试，正如在之前的测试模板部分所解释的那样。
- en: Behavior-driven tests
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动测试
- en: One of the popular styles that has recently seen an increased growth is the
    behavior-driven development. Creating tests that cover software behavior and writing
    actual software based on these tests is known as **Behavior-Driven Development**
    (**BDD**). However, so far this book was dealing with keyword-driven acceptance
    test, which is quite rigid in its structure. To deal with automation, external
    data streams can be used and the tests can be fed this information based on the
    data. However, the tests can also be structured to suit the business user requirements
    oriented towards behavior. However, first we need to understand BDD before applying
    the same in our tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最近增长迅速的流行风格之一是行为驱动开发。创建覆盖软件行为的测试，并根据这些测试编写实际的软件，这被称为**行为驱动开发**（**BDD**）。然而，到目前为止，这本书主要处理的是基于关键字的验收测试，其结构相当僵化。为了处理自动化，可以使用外部数据流，并根据数据将测试信息输入到测试中。然而，测试也可以根据面向行为的业务用户需求进行结构化。但是，在我们将BDD应用到测试之前，首先需要理解BDD。
- en: Behavior-driven development
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: 'Despite the obvious benefits of automated acceptance tests, in practice, even
    amongst experienced XP and TDD teams, it''s rarely done, or done well. One of
    the reasons is that finding a stakeholder with the technical ability, interest,
    and patience to sit in front of a computer writing pure code for even a DSL like
    gerkin or RSpec is hard. Consider the following `rspec` test present in WEBrick
    (an HTTP server in Ruby commonly used in development):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动化验收测试具有明显的优势，但在实践中，即使在经验丰富的XP和TDD团队中，也很少这样做，或者做得不好。其中一个原因是很难找到一个具有技术能力、兴趣和耐心坐在电脑前编写纯代码的利益相关者，即使是像gerkin或RSpec这样的DSL。考虑以下存在于WEBrick（Ruby中常用的HTTP服务器）中的`rspec`测试：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example observes the behavior that is based on the response from the server,
    from this it can be concluded that the server is a WEBrick server or not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例观察基于服务器响应的行为，由此可以得出结论，该服务器是WEBrick服务器或不是。
- en: However, at time this may be deeply integrated into the code of test and requires
    that the internals of the system under test are exposed to it. This is because
    the developer is required to provide the actual method calls/interfaces or code
    mocks or stubs of the software right into the `rspec` tests, which might be fine
    in projects involving developers, but is not feasible where black box testing,
    as in acceptance testing is required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时这可能会深度集成到代码中，并要求测试代码能够访问被测系统的内部结构。这是因为开发者需要将实际的方法调用/接口或软件的代码模拟或存根直接集成到`rspec`测试中，这在涉及开发者的项目中可能没问题，但在需要黑盒测试，如验收测试的情况下则不可行。
- en: BDD using the Robot Framework
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Robot Framework进行BDD
- en: Robot Framework not only provides a DSL or a platform to easily write the code
    in a human-readable format, but also separates itself from understanding the internals
    of the concerned software as it only performs the acceptance testing for a given
    behavior. These tests only differ in the manner in which the user keywords take
    in arguments, which is done within the keywords themselves. Here these keywords
    comprise of multiple letters and describe a specific thing to do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Robot Framework不仅提供了一个DSL或平台，可以轻松以人类可读的格式编写代码，而且它还与理解相关软件的内部结构分离，因为它只为给定的行为执行验收测试。这些测试仅在用户关键字如何接收参数的方式上有所不同，这是在关键字内部完成的。在这里，这些关键字由多个字母组成，描述了要执行的具体操作。
- en: Standard libraries
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: 'The Robot Framework provides various keywords, which have been discussed so
    far. These are contained in the `builtIn` library and are available to any test
    by default. In addition to these, there are certain extra keywords that are part
    of the framework which are bundled as separate libraries and to use them, an explicit
    reference needs to be provided without any installation. These libraries are as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人框架提供了各种关键字，到目前为止已经讨论过。这些关键字包含在`builtIn`库中，并且默认情况下对任何测试都是可用的。除了这些之外，还有一些额外的关键字是框架的一部分，作为单独的库捆绑在一起，要使用它们，需要提供显式的引用，无需安装。以下是一些库：
- en: Collections
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Dialogs
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框
- en: Operating System
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: Process
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Screenshot
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截图
- en: String
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Telnet
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Telnet
- en: XML
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML
- en: Collections
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'This library uses the supplied lists and dictionaries from an external Python
    file and performs various operations, such as comparison and modification over
    it. Some keywords from the `builtin` library that operate over lists and dictionaries
    can also be used in conjunction with this library. For example, consider the following
    example where the Python file defines the following variables:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库使用从外部Python文件提供的列表和字典，并对其进行各种操作，如比较和修改。`builtin`库中的一些操作列表和字典的关键字也可以与这个库一起使用。例如，考虑以下示例，其中Python文件定义了以下变量：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These variables can be manipulated in the test as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量可以在测试中按以下方式操作：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly, other keywords belonging to the collections library can be used together
    with other libraries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，集合库中的其他关键字也可以与其他库一起使用。
- en: Dialogs
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话框
- en: Dialogs provide a way to let the user input data during the test execution.
    Although this goes against the principles of automated testing, but is desired
    at times.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框提供了一种在测试执行期间让用户输入数据的方式。尽管这与自动化测试的原则相悖，但在某些情况下却是所需的。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that currently, this library does not work on IronPython runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前，这个库在IronPython运行时不可用。
- en: 'For instance, the following command lets the user pass or fail a given step:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令允许用户通过或失败一个给定的步骤：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This provides the following dialog box which waits for the user input to continue:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了以下对话框，等待用户输入以继续：
- en: '![Dialogs](img/36033OS_03_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![对话框](img/36033OS_03_02.jpg)'
- en: On specifying the **Fail** option, the user is further requested for the failure
    message before failing the test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定**失败**选项后，用户在测试失败之前会被进一步要求输入失败信息。
- en: Similarly, the other keywords specified in this library can be used.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个库中指定的其他关键字也可以使用。
- en: Operating System
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: This library provides the Robot Framework interaction with the OS environment,
    such as files and folders, environment variables, and the ability to call various
    processes. Most of the methods declared in this library are self-explanatory.
    However, keywords that manage processes are deprecated and are now also present
    in process library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库提供了机器人框架与操作系统环境的交互，例如文件和文件夹、环境变量，以及调用各种进程的能力。这个库中声明的多数方法都是自解释的。然而，管理进程的关键字已被弃用，现在也存在于进程库中。
- en: Process
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: This library allows the test to run external programs. It uses the sub process
    module in Python where the external process is spawned, the input/error/output
    message pipes are connected, and the return codes are obtained. It can either
    run process and wait for their termination or run the processes in the background.
    For better management, it can also terminate one or all the processes started
    by the test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库允许测试运行外部程序。它使用Python中的子进程模块来生成外部进程，连接输入/错误/输出消息管道，并获取返回代码。它可以运行进程并等待其终止，或者以在后台运行进程。为了更好地管理，它还可以终止由测试启动的一个或所有进程。
- en: Screenshot
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 截图
- en: This library enables capture of screens during the Robot Framework test execution,
    which allows detailed reporting of the project if there are screens present in
    the test environment. If using with Python runtime, this will require additional
    libraries like `wxPython` or `pygtk`. Other runtimes provide an out of the box
    support for screen capture. The `take` screenshot takes the screenshot of the
    screen and saves it where the log file or the XML output is generated if no setting
    or file location is specified. If no name is given, then `Screenshot_number.jpg`
    is saved where the number gets incremented after every execution to create a unique
    saved image. Similarly, the width argument specifies how much area gets allocated
    to the image in the log file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库允许在 Robot Framework 测试执行期间捕获屏幕，如果测试环境中存在屏幕，则允许详细地报告项目。如果与 Python 运行时一起使用，这需要额外的库，如
    `wxPython` 或 `pygtk`。其他运行时提供开箱即用的屏幕捕获支持。`take` 截图将屏幕截图保存到日志文件或 XML 输出生成的位置，如果没有指定设置或文件位置。如果没有给出名称，则将
    `Screenshot_number.jpg` 保存到每次执行后数字递增的位置以创建一个唯一的保存图像。同样，宽度参数指定了在日志文件中分配给图像的区域大小。
- en: 'The following specifies the file name and size of screen capture image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指定了屏幕截图图像的文件名和大小：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This saves the following image and embeds it into the log file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保存以下图像并将其嵌入到日志文件中：
- en: '![Screenshot](img/3033OS_03_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/3033OS_03_03.jpg)'
- en: String
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: This provides the normal String operation, such as substring, replace, and splitting
    strings, as well as specialized functions that generate random string. This also
    contains utility methods that operate over strings present across multiple lines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了正常的字符串操作，如子字符串、替换和字符串分割，以及生成随机字符串的专用函数。这还包含操作跨多行字符串的实用方法。
- en: Telnet
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet
- en: 'This library enables the Robot Framework test to connect to a Telnet server
    and pass commands to run over the server. An easiest way to test this is to set
    up a test server on your machine itself. Considering you set the Telnet server
    correctly on your machine with user and password both set to `test`, then the
    following code will perform as desired:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库允许 Robot Framework 测试连接到 Telnet 服务器并传递在服务器上运行的命令。测试这个功能的最简单方法是设置一个本机的测试服务器。假设你在机器上正确设置了
    Telnet 服务器，用户名和密码都设置为 `test`，那么以下代码将按预期执行：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that setting up prompt in the `Open Connection` command is not mandatory,
    but is needed for certain commands like the `execute` command. This library is
    sufficient for opening, closing, as well as changing between multiple Telnet connections
    and covers most of the Telnet features.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `Open Connection` 命令中设置提示不是强制性的，但对于某些命令（如 `execute` 命令）是必需的。这个库足以打开、关闭以及在不同
    Telnet 连接之间切换，并涵盖了大多数 Telnet 功能。
- en: XML
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML
- en: This is the XML parser supplied by the framework and can be used to search and
    validate supplied XML file or text. It uses the ElementTree library internally
    and offers capabilities to parse and find different elements, attributes, values,
    and supports Xpath-styled lookup.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是框架提供的 XML 解析器，可以用来搜索和验证提供的 XML 文件或文本。它内部使用 ElementTree 库，并提供了解析和查找不同元素、属性、值的能力，并支持
    Xpath 风格的查找。
- en: Remote test execution
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程测试执行
- en: The Robot Framework also supports the use of remote libraries, where a part
    of the test can be hosted as a server and can be used by other tests remotely.
    This is useful in centralizing a part of test at a single place and all the client
    tests can derive information based on that test itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Robot Framework 也支持远程库的使用，其中测试的一部分可以作为服务器托管，并且可以被其他远程测试使用。这在将测试的一部分集中在一个地方非常有用，并且所有客户端测试都可以根据该测试本身获取信息。
- en: It uses the XML-RPC protocol for the remote interaction and offers various capabilities
    for distributed testing, such as making different keywords available remotely
    that can be used to perform some operation over the remote server by different
    tests. Hence, a method in the remote library can be used to perform some task
    that can be called as a library keyword in the tests which provides re-usability
    of code across different tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 XML-RPC 协议进行远程交互，并提供各种分布式测试功能，例如远程提供不同的关键字，这些关键字可以由不同的测试在远程服务器上执行某些操作。因此，远程库中的一个方法可以用来执行一些任务，这些任务可以在测试中以库关键字的形式调用，从而实现代码在不同测试中的可重用性。
- en: 'To start off with the remote test, within the test, only the setting table
    needs to specify the location of the remote test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始远程测试，在测试中只需指定远程测试的位置：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the server side, the following can be specified:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，可以指定以下内容：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, this file can be run from the Python command to set up a Robot Remote
    Server and the methods defined here can be used as keywords, such as `strings
    should be equal`. If you are wondering if the code needs anything more, then you
    need to download the provided `RobotRemoteServer` script file separately and place
    it besides this script. Currently, the servers for Python and Ruby are present,
    but other servers can also be created. Thus, writing distributed tests in the
    Robot Framework is trivial and can easily be used through HTTP.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可以从Python命令行运行此文件以设置Robot远程服务器，并且这里定义的方法可以用作关键字，例如`字符串应该相等`。如果你想知道代码是否需要更多，那么你需要单独下载提供的`RobotRemoteServer`脚本文件并将其放置在此脚本旁边。目前，有Python和Ruby的服务器，但也可以创建其他服务器。因此，在Robot
    Framework中编写分布式测试是微不足道的，并且可以通过HTTP轻松使用。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter dealt with the philosophy and style of writing the tests. As the
    tests should be written with automation in mind, both the internal and external
    re-use through iteration and parameterization of test cases as well as getting
    data into the tests was covered as these are amongst the important things to consider
    while going forward with the automation. Next, all three different writing styles
    consisting of keyword, data, and behavior driven tests was covered followed with
    brief discussion of importance of behavior-driven development and comparison with
    other development tools currently in popular use. This chapter provides all the
    remaining portions of the Robot Framework library and you can now confidently
    begin writing tests that can be automated and provide testing for small to large
    enterprise software systems by using the wide variety of tools and support provided
    within the framework itself. In order to extend the capabilities of the framework
    and make it usable with a wide variety of software, extensive focus will be made
    on user library in the following chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了测试的哲学和风格。由于测试应该考虑到自动化，因此涵盖了通过迭代和参数化测试用例的内部和外部重用，以及将数据引入测试的情况，因为这些是在进行自动化时需要考虑的重要事项。接下来，本章涵盖了三种不同的编写风格，包括关键字、数据和行为驱动测试，随后对行为驱动开发的重要性进行了简要讨论，并与当前流行的其他开发工具进行了比较。本章提供了Robot
    Framework库的所有剩余部分，你现在可以自信地开始编写可自动化的测试，通过框架本身提供的广泛工具和支持，为从小型企业软件系统到大型企业软件系统提供测试。为了扩展框架的功能并使其能够与各种软件一起使用，下一章将重点介绍用户库。
