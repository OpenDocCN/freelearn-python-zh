- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: 'The Interface Adapters Layer: Controllers and Presenters'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口适配器层：控制器和展示者
- en: In *Chapters 4 and 5*, we built the core of our task management system—the domain
    entities that represent our business concepts and the use cases that orchestrate
    them. The Application layer’s request/response models handle translation between
    use cases and domain objects, ensuring our core business rules remain pure and
    focused. However, there’s still a gap between these use cases and the outside
    world such as web interfaces or command-line tools. This is where the **Interface
    Adapters layer** comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章和第5章中，我们构建了任务管理系统的基础——代表我们业务概念的领域实体以及编排它们的用例。应用层的请求/响应模型处理用例和领域对象之间的转换，确保我们的核心业务规则保持纯净和专注。然而，这些用例与外部世界（如Web界面或命令行工具）之间仍然存在差距。这就是接口适配器层的作用所在。
- en: The Interface Adapters layer serves as the translator between our application’s
    core and external concerns. It converts data between formats convenient for external
    agencies and those expected by our use cases. Through carefully designed controllers
    and presenters, this layer maintains the architectural boundaries that keep our
    core business rules isolated and maintainable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接口适配器层作为我们应用程序核心和外部关注点之间的翻译者。它转换外部机构方便的数据格式和我们的用例期望的数据格式。通过精心设计的控制器和展示者，这一层维护了保持我们的核心业务规则隔离和可维护性的架构边界。
- en: In this chapter, we’ll explore how to implement the Interface Adapters layer
    in Python, seeing how it upholds Clean Architecture’s Dependency Rule. We’ll learn
    how controllers coordinate external input with our use cases, and how presenters
    transform domain data for various output needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在Python中实现接口适配器层，了解它是如何维护清洁架构的依赖规则的。我们将学习控制器如何协调外部输入与我们的用例，以及展示者如何将领域数据转换为各种输出需求。
- en: By the end of this chapter, you’ll understand how to create a flexible Interface
    Adapters layer that protects your core business logic while supporting multiple
    interfaces. You’ll implement clean architectural boundaries that make your system
    more maintainable and adaptable to change.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何创建一个灵活的接口适配器层，它既能保护你的核心业务逻辑，又能支持多个接口。你将实现清洁架构的边界，使你的系统更易于维护和适应变化。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Designing the Interface Adapters layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计接口适配器层
- en: Implementing controllers in Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中实现控制器
- en: Enforcing boundaries through Interface Adapters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口适配器强制边界
- en: Building presenters for data formatting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于数据格式化的展示者
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, code examples in the chapter may be
    partially implemented. Complete versions of all examples can be found in the book’s
    accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分提供的代码示例均使用Python 3.13进行测试。为了简洁，章节中的代码示例可能只部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: Designing the Interface Adapters layer
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计接口适配器层
- en: In Clean Architecture, each layer serves a specific purpose in maintaining separation
    of concerns. As we’ve seen in previous chapters, the Domain layer encapsulates
    our core business rules, while the Application layer orchestrates use cases. But
    how do we connect these pure business-focused layers with the practical needs
    of user interfaces, databases, and external services? This is the role of the
    Interface Adapters layer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在清洁架构中，每一层都在维护关注点分离方面发挥着特定的作用。正如我们在前面的章节中看到的，领域层封装了我们的核心业务规则，而应用层则编排用例。但我们如何将这些纯业务导向的层与用户界面、数据库和外部服务的实际需求相连接呢？这就是接口适配器层的作用。
- en: '![Figure 6.1: Interface Adapters layer with the primary components](img/B31577_06_1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：接口适配器层的主要组件](img/B31577_06_1.png)'
- en: 'Figure 6.1: Interface Adapters layer with the primary components'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：接口适配器层的主要组件
- en: In the next section we will dive into the details of the Interface Adapters
    layer’s role and see examples of this layer in our tasks management application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨接口适配器层的作用，并展示该层在我们任务管理应用程序中的示例。
- en: Interface Adapters layer’s role in Clean Architecture
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口适配器层在整洁架构中的作用
- en: 'The Interface Adapters layer acts as a set of translators between our application’s
    core and external details such as a web framework or a command-line interface.
    This layer is crucial because it allows us to maintain clean architectural boundaries
    while enabling practical interaction with external concerns. By sitting between
    the Application layer and external interfaces, it ensures that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接口适配器层充当了我们应用核心与外部细节（如Web框架或命令行界面）之间的一组翻译器。这一层至关重要，因为它允许我们在保持整洁架构边界的同时，使外部关注点能够进行实际交互。通过位于应用层和外部接口之间，它确保：
- en: Our core business logic remains pure and focused
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的核心业务逻辑保持纯净和专注
- en: External concerns can’t leak into inner layers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部关注点不能渗透到内部层
- en: Changes to external interfaces don’t affect our core logic
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部接口的更改不会影响我们的核心逻辑
- en: Multiple interfaces can interact with our system consistently
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个接口可以一致地与我们的系统交互
- en: 'The key principle governing this layer is the Dependency Rule: dependencies
    must point inward toward the core business rules. The Interface Adapters layer
    rigidly enforces this rule by ensuring all translations maintain proper architectural
    boundaries.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该层的主导原则是依赖规则：依赖关系必须指向核心业务规则。接口适配器层通过确保所有翻译保持适当的架构边界来严格执行此规则。
- en: Responsibilities of the Interface Adapters layer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口适配器层的职责
- en: As we delve deeper into Clean Architecture’s Interface Adapters layer, it’s
    essential to understand its core responsibilities. Just as a translator must be
    fluent in both languages they work with, this layer must understand both the precise
    language of our application core and the varied dialects of external interfaces.
    These responsibilities form two distinct but complementary flows of data through
    our system, each requiring careful handling to maintain our architectural boundaries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究整洁架构的接口适配器层时，理解其核心职责至关重要。正如翻译者必须精通他们所使用的两种语言一样，这一层必须理解我们应用核心的精确语言和外部接口的多种方言。这些职责形成了通过我们系统传递的两个截然不同但互补的数据流，每个都需要仔细处理以保持我们的架构边界。
- en: '![Figure 6.2: Bidirectional data flow through the Interface Adapters layer](img/B31577_06_2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：通过接口适配器层的双向数据流](img/B31577_06_2.png)'
- en: 'Figure 6.2: Bidirectional data flow through the Interface Adapters layer'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：通过接口适配器层的双向数据流
- en: 'In *Figure 6.2,* we see the Interface Adapters layer manages the bidirectional
    flow of data between our application core and external concerns:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.2*中，我们看到接口适配器层管理着我们的应用核心与外部关注点之间的双向数据流：
- en: '**Inbound data flow**:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入站数据流**:'
- en: Converting external requests into application-specific formats
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部请求转换为应用特定格式
- en: Ensuring data meets application requirements
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据满足应用要求
- en: Coordinating with use cases to execute operations
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用例协调以执行操作
- en: '**Outbound data flow**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出站数据流**:'
- en: Transforming application results for external consumption
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用结果转换为外部消费格式
- en: Providing interface-appropriate data formats
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供适合接口的数据格式
- en: Maintaining separation between core logic and external interfaces
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在核心逻辑和外部接口之间保持分离
- en: These responsibilities form the foundation for the specific components we’ll
    examine next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些责任构成了我们接下来要检查的具体组件的基础。
- en: Interface Adapters layer versus Application layer boundaries
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口适配器层与应用层边界
- en: When first working with Clean Architecture, it’s common to wonder about the
    distinction between data transformation in the Interface Adapters layer versus
    the Application layer. After all, both layers appear to handle data conversion.
    However, these layers serve fundamentally different purposes in our architecture,
    and understanding these differences is crucial for maintaining clean boundaries
    in our system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次与整洁架构合作时，人们常常会想知道接口适配器层与应用层之间的数据转换区别。毕竟，这两个层似乎都处理数据转换。然而，在我们的架构中，这两个层起着根本不同的作用，理解这些差异对于保持我们系统中的整洁边界至关重要。
- en: 'While both the Interface Adapters layer and Application layer handle data transformation,
    they serve different purposes and maintain different boundaries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接口适配器层和应用层都处理数据转换，但它们服务于不同的目的，并保持不同的边界：
- en: '**Application layer**:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**:'
- en: Transforms between domain entities and use case-specific formats
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在领域实体和用例特定格式之间进行转换
- en: Focuses on business rule coordination
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于业务规则协调
- en: Works with domain-specific types and structures
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定领域的类型和结构一起工作
- en: '**Interface****Adapters****layer**:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配器层**：'
- en: Transforms between use case formats and external interface needs
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用例格式和外部接口需求之间进行转换
- en: Focuses on external interface coordination
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于外部接口协调
- en: Works with interface-specific formats and primitive types
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定接口的格式和原始类型一起工作
- en: This clear separation ensures that our system maintains strong boundaries between
    its core business logic and external interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种清晰的分离确保了我们的系统在核心业务逻辑和外部接口之间保持了强大的边界。
- en: Key components and their relationships
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键组件及其关系
- en: With an understanding of the Interface Adapters layer’s responsibilities and
    boundaries, we can now examine the specific components that implement these concepts.
    These components work together like a well-orchestrated team, each playing a specific
    role in maintaining our architectural boundaries while enabling practical system
    interaction. While we’ll explore detailed implementations later in this chapter,
    understanding how these components collaborate provides essential context for
    our Clean Architecture design.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解接口适配器层的责任和边界之后，我们现在可以检查实现这些概念的具体组件。这些组件像一个精心编排的团队一样协同工作，每个组件都在维护我们的架构边界的同时，使系统交互变得实用。虽然我们将在本章后面探索详细的实现，但了解这些组件如何协作为我们清洁架构设计提供了基本背景。
- en: 'The Interface Adapters layer implements its responsibilities through three
    key components:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接口适配器层通过三个关键组件实现其责任：
- en: '**Controllers** handle inbound flow, serving as entry points for external requests
    into our system. They ensure that data crossing into our application core meets
    our system’s requirements while protecting our use cases from external concerns.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**处理输入流，作为外部请求进入我们系统的入口点。它们确保进入我们应用程序核心的数据符合我们系统的要求，同时保护用例免受外部关注。'
- en: '**Presenters** manage outbound flow, transforming use case results into formats
    suitable for external consumption. The Interface Adapters layer defines the presenter
    interfaces, establishing the contract that both use cases and concrete presenter
    implementations must follow.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演示者**管理输出流，将用例结果转换为适合外部消费的格式。接口适配器层定义了演示者接口，确立了用例和具体演示者实现都必须遵循的合同。'
- en: '**View models** serve as data carriers between presenters and views, containing
    only primitive types and simple data structures. This simplicity ensures that
    views can easily consume the formatted data while maintaining clean architectural
    boundaries.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**作为演示者和视图之间的数据载体，仅包含原始类型和简单的数据结构。这种简单性确保了视图可以轻松消费格式化数据，同时保持清晰的架构边界。'
- en: 'These components interact in a carefully orchestrated flow that always respects
    the Dependency Rule:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件在一个精心编排的流程中相互作用，始终遵守依赖规则：
- en: External requests flow through controllers
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部请求通过控制器流动
- en: Controllers coordinate with use cases
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器与用例协调
- en: Use cases return results through defined interfaces
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用例通过定义的接口返回结果
- en: Presenters format results into view models
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演示者将结果格式化为视图模型
- en: Views consume the formatted data
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图消费格式化数据
- en: This carefully orchestrated interaction ensures that our system maintains clean
    boundaries while remaining practical and maintainable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这场精心策划的交互确保了我们的系统在保持实用性和可维护性的同时，维持了清晰的边界。
- en: Interface design principles
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口设计原则
- en: When designing interfaces in the Interface Adapters layer, we must balance clean
    architectural boundaries with practical implementation concerns. As we saw in
    [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123) with request/response models,
    careful interface design enables smooth data flow while maintaining proper separation
    between layers. The principles guiding interface design in this layer help us
    achieve this balance while adhering to Clean Architecture’s core tenets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口适配器层的接口时，我们必须在清晰的架构边界和实用的实现关注之间取得平衡。正如我们在[*第五章*](Chapter_05.xhtml#_idTextAnchor123)中看到的请求/响应模型，仔细的接口设计能够实现流畅的数据流，同时保持层之间的适当分离。本层指导接口设计的原则帮助我们实现这种平衡，同时遵守清洁架构的核心原则。
- en: 'Three key principles shape our interface design:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 三个关键原则塑造了我们的接口设计：
- en: The **Dependency Rule** takes precedence in all design decisions. All dependencies
    must point inward toward use cases and entities. This means our interface adapters
    depend on application interfaces (like the `CreateTaskUseCase` we saw in [*Chapter
    5*](Chapter_05.xhtml#_idTextAnchor123)), but the application never depends on
    our adapters. This rule ensures that changes to external interfaces can’t affect
    our core business logic.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖规则**在所有设计决策中占优先地位。所有依赖都必须指向用例和实体。这意味着我们的接口适配器依赖于应用程序接口（如我们在[*第五章*](Chapter_05.xhtml#_idTextAnchor123)中看到的`CreateTaskUseCase`），但应用程序永远不会依赖于我们的适配器。这一规则确保外部接口的变化不会影响我们的核心业务逻辑。'
- en: 'The **Single Responsibility Principle** guides component boundaries. Each adapter
    handles one specific type of transformation: controllers handle input validation
    and conversion, while presenters manage output formatting. This separation makes
    our system easier to maintain and modify. For example, a `TaskController` focuses
    solely on validating and converting task-related input, while a `TaskPresenter`
    handles only the formatting of task data for display.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**指导组件边界。每个适配器处理一种特定的转换类型：控制器处理输入验证和转换，而展示者管理输出格式。这种分离使得我们的系统更容易维护和修改。例如，`TaskController`专注于验证和转换与任务相关的输入，而`TaskPresenter`仅处理任务数据的显示格式。'
- en: The **Interface Segregation Principle** ensures our interfaces remain focused
    and cohesive. Rather than creating large, monolithic interfaces, we design small,
    purpose-specific interfaces that serve distinct client needs. For instance, instead
    of a single large `TaskOperations` interface, we might have separate interfaces
    for task creation, completion, and querying. This granularity provides flexibility
    and makes our system more adaptable to change.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口分离原则**确保我们的接口保持专注和一致。我们不是创建大型、单一接口，而是设计小型、目的特定的接口，以满足不同的客户端需求。例如，我们可能不会有一个单一的`TaskOperations`接口，而是为任务创建、完成和查询分别设计接口。这种粒度提供了灵活性，并使我们的系统更能适应变化。'
- en: By following these principles, we create interfaces that effectively bridge
    the gap between our clean, focused core business logic and the practical needs
    of external interfaces. As we explore specific implementations in the following
    sections, we’ll see how these principles guide our design decisions and lead to
    more maintainable code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些原则，我们创建了有效地连接我们干净、专注的核心业务逻辑和外部接口实际需求的接口。在我们接下来的具体实现探讨中，我们将看到这些原则如何指导我们的设计决策，并导致代码更加易于维护。
- en: Implementing controllers in Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现控制器
- en: Having established the theoretical foundations of the Interface Adapters layer,
    we turn now to practical implementation using Python. Python’s language features
    offer several elegant mechanisms for implementing Clean Architecture’s controller
    patterns. Through data classes, abstract base classes (ABCs), and type hints,
    we can create clear and maintainable interface boundaries while keeping our code
    Pythonic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了接口适配器层的理论基础之后，我们现在转向使用Python的实际实现。Python的语言特性为实施Clean Architecture的控制器模式提供了几个优雅的机制。通过数据类、抽象基类（ABCs）和类型提示，我们可以在保持Python风格的同时创建清晰且易于维护的接口边界。
- en: While Clean Architecture provides a set of principles and patterns, it does
    not prescribe a rigid implementation approach. As we proceed, remember that this
    represents one possible implementation of Clean Architecture’s principles; the
    key is maintaining clean boundaries and separation of concerns, regardless of
    specific implementation details.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Clean Architecture提供了一套原则和模式，但它并没有规定一个严格的实现方法。在我们继续前进的过程中，请记住，这代表了对Clean Architecture原则的一种可能实现；关键是保持清晰的边界和关注点的分离，无论具体的实现细节如何。
- en: Controller responsibilities and patterns
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器职责和模式
- en: 'As we saw in our examination of Interface Adapters layer components, controllers
    in Clean Architecture have a focused set of responsibilities: they accept input
    from external sources, validate and transform that input into the format our use
    cases expect, coordinate use case execution, and handle the results appropriately.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在检查接口适配器层组件时所见，Clean Architecture中的控制器有一组专注的职责：它们接受来自外部来源的输入，验证和转换该输入为用例期望的格式，协调用例执行，并适当地处理结果。
- en: 'Let’s examine a concrete implementation that demonstrates these principles:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个具体实现，以展示这些原则：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This controller demonstrates several key Clean Architecture principles. First,
    notice how it depends only on injected dependencies: both the use case and presenter
    are constructed elsewhere and brought into the controller via constructor injection.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器演示了几个关键的清洁架构原则。首先，注意它只依赖于注入的依赖项：用例和展示者都是在其他地方构建的，并通过构造函数注入引入控制器。
- en: 'To understand why this **dependency injection pattern** is so important, consider
    this counter example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这种**依赖注入模式**如此重要，考虑以下反例：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This counter or anti-example demonstrates several problems:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反例或反例演示了几个问题：
- en: Direct instantiation of concrete classes creates tight coupling
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接实例化具体类会导致紧密耦合
- en: The controller knows too much about implementation details
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器对实现细节了解过多
- en: Testing becomes difficult as dependencies can’t be replaced
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于依赖关系无法替换，测试变得困难
- en: Changes to implementations force changes to the controller
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的变化迫使控制器发生变化
- en: Returning to our clean implementation, the `handle_create` method shows the
    controller’s core responsibilities in action. It begins by accepting primitive
    types (`title` and `description` strings) from the external world—keeping the
    interface simple and framework-agnostic. These inputs are then transformed into
    a proper request object, validating and formatting the data before it reaches
    our use case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的清洁实现，`handle_create`方法展示了控制器核心职责的实际操作。它首先从外部世界接受原始类型（`title`和`description`字符串）——保持接口简单且与框架无关。然后，这些输入被转换成一个合适的请求对象，在它到达我们的用例之前进行验证和格式化。
- en: For brevity, we’re showing only the `handle_create` implementation, but in practice,
    this controller would have additional use cases injected (like `complete_use_case`,
    `set_priority_use_case`, etc.) and corresponding handler methods implemented.
    This pattern of dependency injection and handler implementation remains consistent
    across all controller operations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们只展示了`handle_create`的实现，但在实践中，这个控制器会有额外的用例注入（如`complete_use_case`、`set_priority_use_case`等）和相应的处理方法实现。这种依赖注入和处理实现的模式在所有控制器操作中保持一致。
- en: The controller’s error-handling strategy is particularly noteworthy. It catches
    validation errors before they reach the use case and handles both successful and
    failed results from the use case execution. In all cases, it uses the presenter
    to format responses appropriately for external consumption, returning them wrapped
    in an `OperationResult` that makes success and failure cases explicit. This pattern
    builds on the result type we introduced in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123),
    adding view model support for interface-specific formatting. We’ll discuss the
    use of `OperationResult` in more detail in *Building Presenters for Data Formatting*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的错误处理策略特别值得注意。它在验证错误到达用例之前捕获它们，并处理用例执行的成功和失败结果。在所有情况下，它都使用展示者适当地格式化响应，以便外部消费，并将它们包装在`OperationResult`中，使成功和失败情况明确。这种模式建立在我们在[*第五章*](Chapter_05.xhtml#_idTextAnchor123)中引入的结果类型之上，增加了对特定接口格式化的视图模型支持。我们将在*构建用于数据格式化的展示者*中更详细地讨论`OperationResult`的使用。
- en: This clean separation of concerns ensures that our business logic remains unaware
    of how it’s being called while providing a robust and maintainable interface for
    external clients.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的清晰分离确保我们的业务逻辑不知道它是如何被调用的，同时为外部客户端提供了一个强大且易于维护的接口。
- en: Working with request models in controllers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中与请求模型协同工作
- en: 'We saw `CreateTaskRequest` earlier in our examination of the `TaskController`,
    and in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123)’s coverage of the Application
    layer. Now let’s examine more closely how controllers work with these request
    models to maintain clean boundaries between external input and our use cases:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前对`TaskController`的审查中，我们看到了`CreateTaskRequest`，在[*第五章*](Chapter_05.xhtml#_idTextAnchor123)对应用层的覆盖中也有所提及。现在让我们更仔细地研究控制器如何与这些请求模型协同工作，以保持外部输入和我们的用例之间的清晰边界：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While the Application layer defines these request models, controllers are responsible
    for their proper instantiation and use. The controller ensures input validation
    occurs before use case execution:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用层定义了这些请求模型，但控制器负责它们的正确实例化和使用。控制器确保在使用用例执行之前进行输入验证：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This separation ensures that our use cases only ever receive properly validated
    and formatted data, maintaining clean architectural boundaries while providing
    robust input handling.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离确保我们的用例始终只接收经过适当验证和格式化的数据，在保持清洁的架构边界的同时提供强大的输入处理。
- en: Maintaining controller independence
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护控制器独立性
- en: The effectiveness of our Interface Adapters layer depends heavily on maintaining
    proper isolation between our controllers and both external and internal concerns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接口适配器层的有效性在很大程度上取决于在控制器与外部和内部关注点之间保持适当的隔离。
- en: 'Let’s look more closely into how our `TaskController` achieves this independence:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`TaskController`是如何实现这种独立性的：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple dependency structure demonstrates several key principles. First,
    the controller depends only on abstractions; it knows nothing about concrete implementations
    of either the use case or presenter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的依赖结构展示了几个关键原则。首先，控制器只依赖于抽象；它对用例或展示者的具体实现一无所知。
- en: Let’s take a moment to clarify what we mean by *abstractions* in Python. As
    we’ll soon see, the `TaskPresenter` follows a classical interface pattern using
    Python’s ABC, establishing a formal interface contract. For use cases like `CreateTaskUseCase`,
    we take advantage of Python’s duck typing, since each use case needs only an `execute`
    method with defined parameters and return types, any class providing this method
    fulfills the interface contract without needing ABC formality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间澄清一下我们所说的Python中的*抽象*。正如我们很快就会看到的，`TaskPresenter`遵循经典的接口模式，使用Python的ABC建立正式的接口契约。对于像`CreateTaskUseCase`这样的用例，我们利用Python的鸭子类型，因为每个用例只需要一个具有定义参数和返回类型的`execute`方法，任何提供此方法的类都满足了接口契约，无需ABC的正式性。
- en: This flexibility in defining interfaces is one of Python’s strengths. We can
    choose formal ABC interfaces when we need to enforce complex contracts or rely
    on duck typing for simpler interfaces. It’s the developer’s choice of the style
    they prefer. Both approaches maintain Clean Architecture’s dependency principles
    while staying idiomatic to Python.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义接口方面的这种灵活性是Python的强项之一。当我们需要强制执行复杂的契约或依赖于鸭子类型来简化接口时，我们可以选择正式的ABC接口。这是开发者选择他们偏好的风格。两种方法都维护了Clean
    Architecture的依赖原则，同时保持Python的惯用性。
- en: 'Taking a mental inventory, notice what’s missing from our controller:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 进行心理盘点，注意我们的控制器中缺少了什么：
- en: No web framework imports or decorators
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有Web框架导入或装饰器
- en: No database or storage concerns
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有数据库或存储问题
- en: No direct instantiation of dependencies
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有直接实例化依赖项
- en: No knowledge of concrete view implementations
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对具体视图实现没有了解
- en: 'This careful isolation means our controller can be used by any delivery mechanism—whether
    it’s a web API, command-line interface (CLI), or message queue consumer. Consider
    what happens when we violate this isolation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种谨慎的隔离意味着我们的控制器可以被任何交付机制使用——无论是Web API、命令行界面（CLI）还是消息队列消费者。考虑一下当我们违反这种隔离会发生什么：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This counter example violates our isolation principles by:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反例通过以下方式违反了我们的隔离原则：
- en: Importing and depending on a specific web framework
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入并依赖于特定的Web框架
- en: Handling HTTP-specific concerns
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP特定问题
- en: Mixing framework error handling with business logic
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将框架错误处理与业务逻辑混合
- en: The decision about how to expose our controller’s functionality belongs in the
    Frameworks layer. In [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168), we’ll see
    how to create proper framework-specific adapters that wrap our clean controller
    implementation. This allows us to maintain clean architectural boundaries while
    still leveraging the full capabilities of frameworks like FastAPI, Click for command-line,
    or message queue libraries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何公开我们的控制器功能的决定属于框架层。在第[*7章*](Chapter_07.xhtml#_idTextAnchor168)中，我们将看到如何创建适当的框架特定适配器，这些适配器封装了我们的清洁控制器实现。这允许我们在利用FastAPI、Click（用于命令行）或消息队列库等框架的完整功能的同时，保持清洁的架构边界。
- en: 'The interfaces our controller depends on demonstrate Clean Architecture’s careful
    attention to boundaries: use case interfaces defined by the Application layer
    establish our inward dependencies, while presenter interfaces defined in our Interface
    Adapters layer give us control over outward data flow. This careful arrangement
    of interfaces ensures we maintain the Dependency Rule while keeping our system
    flexible and adaptable.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器所依赖的接口展示了清洁架构对边界的细致关注：由应用层定义的使用案例接口建立了我们的内向依赖，而我们在接口适配器层中定义的表示器接口则让我们能够控制外向数据流。这种仔细的接口安排确保我们在保持系统灵活性和适应性的同时，维护了依赖规则。
- en: Enforcing boundaries through interface adapters
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过接口适配器强制执行边界
- en: While our examination of controllers demonstrated how to handle incoming requests,
    Clean Architecture’s interface boundaries require careful attention to data flow
    in both directions. In this section, we’ll explore patterns for maintaining clean
    boundaries throughout our system, particularly focusing on the explicit handling
    of success and failure cases. These patterns complement our controllers and presenters
    while ensuring that all cross-boundary communication remains clear and maintainable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对控制器的审查展示了如何处理传入的请求，但清洁架构的接口边界要求我们仔细关注双向的数据流。在本节中，我们将探讨在整个系统中保持清洁边界的模式，特别是关注对成功和失败情况的明确处理。这些模式补充了我们的控制器和表示器，同时确保所有跨边界通信都保持清晰和可维护。
- en: Explicit success/failure patterns at boundaries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界处的显式成功/失败模式
- en: At our architectural boundaries, we need clear, consistent ways to handle both
    successful operations and failures. Operations can fail for many reasons— invalid
    input, business rule violations, or system errors—and each type of failure might
    need different handling by the external interface. Similarly, successful operations
    need to provide their results in a format suitable for the interface that requested
    them. We’ve seen this mechanism in play in the controller examples shown earlier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构边界处，我们需要清晰、一致的方式来处理成功操作和失败情况。操作可能因多种原因而失败——无效输入、业务规则违规或系统错误——每种类型的失败可能需要通过外部接口进行不同的处理。同样，成功的操作需要以适合请求它们的接口的格式提供其结果。我们已经在前面展示的控制器示例中看到了这种机制的应用。
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `OperationResult` pattern addresses these needs by providing a standardized
    way to handle both success and failure cases. This pattern ensures that our interface
    adapters always communicate outcomes explicitly, making it impossible to overlook
    error cases and providing a clear structure for success scenarios:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationResult` 模式通过提供一种标准化的方式来处理成功和失败情况，来满足这些需求。此模式确保我们的接口适配器始终明确地传达结果，使得错误情况不可能被忽略，并为成功场景提供清晰的架构：'
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how the class is defined as `OperationResult(Generic[T])`. This means
    our class can work with any type `T`. When we instantiate the class, we replace
    `T` with a specific type—for example, when we write `OperationResult[TaskViewModel]`,
    we’re saying: *this operation will either succeed with a* `TaskViewModel` *or
    fail with an error (*`ErrorViewModel`*)*. This type safety helps catch potential
    errors early while making our code’s intent clearer.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类是如何定义为 `OperationResult(Generic[T])` 的。这意味着我们的类可以与任何类型 `T` 一起工作。当我们实例化类时，我们将
    `T` 替换为特定的类型——例如，当我们编写 `OperationResult[TaskViewModel]` 时，我们是在说：*这个操作要么成功返回一个*
    `TaskViewModel` *，要么失败返回一个错误 (*`ErrorViewModel`*)*。这种类型安全性有助于早期捕获潜在的错误，同时使我们的代码意图更加清晰。
- en: This explicit handling of outcomes provides a foundation for clean boundary
    crossing that we’ll see applied throughout our interface adapters. As we move
    into looking at data transformation patterns, we’ll see how this clarity in success
    and failure handling helps maintain clean architectural boundaries while enabling
    practical functionality.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对结果的明确处理为我们将在接口适配器中看到的清洁边界跨越提供了一个基础。当我们进入查看数据转换模式时，我们将看到这种对成功和失败处理的清晰度如何帮助保持清洁的架构边界，同时实现实用的功能。
- en: 'If we look at some application code (residing in the Frameworks layer) we see
    how this `OperationResult` can be utilized to drive application flow:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看一些应用程序代码（位于框架层），我们会看到如何利用这个 `OperationResult` 来驱动应用程序流程：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clean data transformation flows
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁的数据转换流程
- en: 'As data moves through our architectural boundaries, it undergoes several transformations.
    Understanding these transformation flows helps us maintain clean boundaries while
    ensuring our system remains maintainable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据穿过我们的架构边界时，它经历了几个转换。理解这些转换流程有助于我们在确保系统可维护的同时保持清晰的边界：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This example shows a complete transformation chain:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了一个完整的转换链：
- en: External input validation and conversion
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部输入验证和转换
- en: Use case execution with domain types
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用域类型执行用例
- en: Success case transformation to view model
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功案例转换为视图模型
- en: Error case handling and formatting
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误情况处理和格式化
- en: Validation error handling
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证错误处理
- en: Each step in this chain maintains clean boundaries while ensuring data moves
    properly between layers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此链中的每一步都保持清晰的边界，同时确保数据在层之间正确移动。
- en: Interface adapters and architectural boundaries
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口适配器和架构边界
- en: While we’ve focused on controllers and presenters as key interface adapters,
    not every interaction between layers requires an adapter. Understanding when adapters
    are needed helps maintain Clean Architecture without unnecessary complexity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们一直关注控制器和展示者作为关键接口适配器，但并非每一层之间的交互都需要适配器。理解何时需要适配器有助于在不引入不必要复杂性的情况下维护清晰的架构。
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'No adapter is needed here because:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要适配器，因为：
- en: The Application layer defines the exact interface needed
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层定义了所需的精确接口
- en: Implementation can directly fulfill this interface
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可以直接满足此接口
- en: No data format conversion is required
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要数据格式转换
- en: The Dependency Rule is maintained without adaptation
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖规则无需适配
- en: 'This differs from controllers and presenters which must handle varying external
    formats and protocols. The key question when deciding if an adapter is needed
    is: *Does this interaction need format conversion between layers*? If the outer
    layer can work directly with the interface defined by the inner layer, an adapter
    in the Interface layer may not be necessary.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与必须处理不同外部格式和协议的控制器和展示者不同。在决定是否需要适配器时，关键问题是：*这种交互需要在层之间进行格式转换吗*？如果外层可以直接与内层定义的接口工作，那么在接口层可能不需要适配器。
- en: This distinction helps us maintain Clean Architecture principles while avoiding
    unnecessary abstraction. By understanding when adapters are needed, we can create
    more maintainable systems that respect architectural boundaries without overcomplicating
    our design.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分有助于我们在避免不必要抽象的同时维护清晰架构的原则。通过理解何时需要适配器，我们可以创建更可维护的系统，尊重架构边界而不使我们的设计过于复杂。
- en: Building presenters for data formatting
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为数据格式化构建展示者
- en: Throughout this chapter, we’ve referenced presenters as key components of our
    Interface Adapters layer. Now we’ll examine them in detail, seeing how they maintain
    clean architectural boundaries while preparing domain data for external consumption.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直将展示者作为接口适配器层的关键组件进行引用。现在我们将详细检查它们，看看它们是如何在准备域数据以供外部消费的同时保持清晰的架构边界。
- en: Presenters complement our controllers, handling the outbound flow of data just
    as controllers manage inbound requests. By implementing the humble object pattern,
    presenters help us create more testable and maintainable systems while keeping
    our views simple and focused.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 展示者补充了我们的控制器，处理数据的输出流，就像控制器管理输入请求一样。通过实现谦逊对象模式，展示者帮助我们创建更可测试和可维护的系统，同时保持视图简单和专注。
- en: Understanding the humble object pattern
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解谦逊对象模式
- en: 'The **humble object pattern** addresses a common challenge in Clean Architecture:
    how to handle presentation logic, which often resists unit testing, while maintaining
    clean architectural boundaries.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**谦逊对象模式**解决了清晰架构中一个常见的挑战：如何在保持清晰架构边界的同时处理展示逻辑，展示逻辑通常难以进行单元测试。'
- en: The term *humble object* comes from the strategy of making a component as simple
    and devoid of complex logic as possible. In presentation contexts, this means
    creating an extremely basic view that does nothing more than display pre-formatted
    data. The view becomes *humble* by design, containing minimal intelligence.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “谦逊对象”这个术语来自使组件尽可能简单且逻辑尽可能简单的策略。在展示环境中，这意味着创建一个极其基本的视图，它除了显示预格式化数据之外不做任何事情。视图通过设计变得“谦逊”，包含最少的智能。
- en: 'For example, a humble view might be:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个谦逊的视图可能是：
- en: A simple HTML template rendering pre-formatted data
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的HTML模板渲染预格式化数据
- en: A React component that only displays passed props
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仅显示传递的props的React组件
- en: A CLI display function that prints formatted strings
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个打印格式化字符串的CLI显示函数
- en: 'The pattern splits responsibilities between two components:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在两个组件之间分割责任：
- en: A *humble view* containing minimal logic that’s hard to test
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*谦逊的视图*，包含最少且难以测试的逻辑
- en: A Presenter containing all presentation logic in an easily testable form
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有演示逻辑的演示者，以易于测试的形式
- en: 'Consider how our task management system might display task information in a
    CLIs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的任务管理系统如何在CLI中显示任务信息：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All formatting decisions—how to display status, priority levels, dates—live
    in our presenter, not the view model (`TaskViewModel`) itself. This separation
    brings several benefits:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式化决策——如何显示状态、优先级级别、日期——都存在于我们的演示者中，而不是视图模型（`TaskViewModel`）本身。这种分离带来了几个好处：
- en: Views remain simple and focused on display
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图保持简单，专注于显示
- en: Presentation logic stays testable
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示逻辑保持可测试
- en: Business rules remain isolated from display concerns
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则保持与显示关注点的隔离
- en: Multiple interfaces can share formatting logic
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个接口可以共享格式化逻辑
- en: It’s worth noting that the emphasis on presenters can vary based on your specific
    needs. If you’re building a Python API that serves data to a JavaScript frontend,
    you might need minimal presentation logic. However, in full-stack Python applications
    using frameworks like Django or Flask, robust presenters help maintain clean separation
    between business logic and display concerns. Understanding the pattern lets you
    make informed decisions based on your circumstances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对演示者的强调可以根据您的具体需求而变化。如果您正在构建一个将数据提供给JavaScript前端Python API，您可能需要最少的演示逻辑。然而，在像Django或Flask这样的全栈Python应用程序中，强大的演示者有助于保持业务逻辑和显示关注点之间的清晰分离。了解这个模式可以让您根据您的具体情况做出明智的决定。
- en: Defining presenter interfaces
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义演示者接口
- en: 'Clean Architecture’s success relies heavily on well-defined interfaces at architectural
    boundaries. For presenters, these interfaces establish clear contracts for transforming
    domain data into presentation-ready formats:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的成功在很大程度上依赖于在架构边界上定义良好的接口。对于演示者，这些接口为将领域数据转换为演示准备格式建立了清晰的合同：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This interface, defined in our Interface Adapters layer, serves several key
    purposes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口定义在我们的接口适配器层中，它服务于几个关键目的：
- en: Establishes a clear contract for task presentation
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任务演示建立清晰的合同
- en: Enables multiple interface implementations
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用多个接口实现
- en: Maintains the Dependency Rule by keeping domain logic unaware of presentation
    details
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过保持领域逻辑对演示细节的无知来维护依赖规则
- en: Makes testing easier through clear abstraction
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过清晰的抽象使测试更容易
- en: Notice how the interface uses domain-specific types (`TaskResponse`) as input
    but returns view-specific types (`TaskViewModel`). This boundary crossing is where
    we transform domain concepts into presentation-friendly formats.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到接口如何使用领域特定类型（`TaskResponse`）作为输入，但返回视图特定类型（`TaskViewModel`）。这种边界跨越是我们将领域概念转换为演示友好格式的位置。
- en: Working with view models
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与视图模型一起工作
- en: 'View models serve as data carriers between presenters and views, ensuring clean
    separation between presentation logic and display concerns. They encapsulate formatted
    data in a way that any view implementation can easily consume:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型作为演示者和视图之间的数据载体，确保演示逻辑和显示关注点之间的清晰分离。它们以任何视图实现都可以轻松消费的方式封装格式化数据：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Several key principles guide our view model design:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 几个关键原则指导我们的视图模型设计：
- en: Use only primitive types (strings, numbers, booleans)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用原始类型（字符串、数字、布尔值）
- en: Pre-format all display text
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预格式化所有显示文本
- en: Make no assumptions about the display mechanism
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要对显示机制做任何假设
- en: Remain immutable (notice the `frozen=True`)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意到`frozen=True`如何保持不可变
- en: Include only data needed for display
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只包含显示所需的数据
- en: This simplicity ensures that our views remain truly *humble*—they need only
    read and display these pre-formatted values, with no knowledge of domain concepts
    or formatting rules.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单性确保我们的视图真正地*谦逊*——它们只需要读取和显示这些预格式化的值，无需了解领域概念或格式化规则。
- en: Implementing concrete presenters
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现具体的演示者
- en: 'With our presenter interfaces and view models defined, we can implement concrete
    presenters for specific interface needs. These concrete presenters are implemented
    in the Frameworks and Drivers layer, but we give you a sneak peek here for context.
    Let’s examine a CLI-specific presenter implementation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的演示者接口和视图模型之后，我们可以为特定的接口需求实现具体的演示者。这些具体的演示者是在框架和驱动层实现的，但我们在这里提前展示一下以供参考。让我们检查一个针对CLI的特定演示者实现：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `present_task` method transforms our domain-specific `TaskResponse` into
    a view-friendly `TaskViewModel`. To support this transformation, the presenter
    implements several private formatting methods that handle specific aspects of
    the data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`present_task`方法将我们的领域特定`TaskResponse`转换为视图友好的`TaskViewModel`。为了支持这种转换，展示器实现了几个私有格式化方法，这些方法处理数据的特定方面：'
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This implementation demonstrates several key Clean Architecture principles:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现展示了几个关键的清洁架构原则：
- en: All formatting logic lives in the presenter, not views
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有格式化逻辑都存在于展示器中，而不是视图中
- en: Domain concepts (like `TaskStatus`) are converted to display strings
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域概念（如`TaskStatus`）被转换为显示字符串
- en: Error handling remains consistent with success cases
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理与成功案例保持一致
- en: Interface-specific formatting (CLI in this case) stays isolated
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口特定的格式化（在本例中为命令行界面）保持隔离
- en: 'The presenter’s formatting methods remain highly testable: we can verify that
    overdue tasks are properly marked, dates are correctly formatted, and error messages
    maintain consistency. This testability stands in stark contrast to testing UI
    components directly, demonstrating a key benefit of the humble object pattern.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 展示器的格式化方法保持高度可测试性：我们可以验证逾期任务是否被正确标记，日期是否正确格式化，以及错误消息是否保持一致性。这种可测试性与直接测试UI组件形成鲜明对比，展示了谦逊对象模式的关键优势。
- en: '**Implementation flexibility**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现灵活性**'
- en: If you’re building an API that primarily serves JSON to a JavaScript frontend,
    you might need minimal presentation logic. The presenter pattern becomes most
    valuable when you need complex formatting or support multiple interface types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个主要服务于JavaScript前端JSON的API，你可能需要最少的展示逻辑。当需要复杂的格式化或支持多种接口类型时，展示器模式变得最有价值。
- en: In [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168), we’ll see how different
    interfaces (CLI, web, or APIs) can implement their own presenters while sharing
    this common architecture. This flexibility demonstrates how Clean Architecture’s
    careful attention to boundaries enables system evolution without compromising
    core business logic.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第七章*](Chapter_07.xhtml#_idTextAnchor168)中，我们将看到不同的接口（命令行界面、Web或API）如何在共享这一共同架构的同时实现它们自己的展示器。这种灵活性展示了清洁架构对边界的细致关注如何使系统进化而不会损害核心业务逻辑。
- en: 'Through our exploration of controllers and presenters, we’ve now implemented
    a complete Interface Adapters layer for our task management system. Let’s take
    a moment to review our architectural progress by examining the structure we’ve
    built across *Chapters 4–6*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对控制器和展示器的探索，我们现在已经为我们的任务管理系统实现了完整的接口适配器层。让我们花点时间回顾我们的架构进展，通过检查我们在*第4章到第6章*中构建的结构：
- en: '![Figure 6.3: Folder structure with all layers in place](img/B31577_06_3.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：所有层都就位时的文件夹结构](img/B31577_06_3.png)'
- en: 'Figure 6.3: Folder structure with all layers in place'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：所有层都就位时的文件夹结构
- en: This structure reflects Clean Architecture’s concentric layers. Our Domain layer,
    established in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091), remains pure
    and focused on business rules. The Application layer, added in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123),
    orchestrates these domain objects to accomplish specific use cases. Now, with
    our Interface Adapters layer, we’ve implemented the controllers and presenters
    that translate between our core business logic and external concerns, maintaining
    clean boundaries while enabling practical interaction with our system. See the
    accompanying GitHub repository ([https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python))
    for a more extensive code example of the task management application example being
    used throughout the book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构反映了清洁架构的同心层。我们建立的领域层，在[*第四章*](Chapter_04.xhtml#_idTextAnchor091)中，保持纯粹和专注于业务规则。应用层，在[*第五章*](Chapter_05.xhtml#_idTextAnchor123)中添加，协调这些领域对象以完成特定用例。现在，随着我们的接口适配器层的实现，我们已经实现了控制器和展示器，它们在核心业务逻辑和外部关注点之间进行转换，同时保持清晰的边界，并使与我们的系统进行实际交互成为可能。请参阅随附的GitHub仓库([https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python))，以获取本书中使用的任务管理应用程序示例的更广泛的代码示例。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the Interface Adapters layer of Clean Architecture,
    implementing controllers and presenters that maintain clean boundaries while enabling
    practical interaction with external systems. We learned how controllers handle
    incoming requests, converting external input into formats our use cases can process,
    while presenters transform domain data into view-friendly formats.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了清洁架构的接口适配器层，实现了控制器和展示者，它们在保持清洁边界的同时，允许与外部系统进行实用交互。我们学习了控制器如何处理传入的请求，将外部输入转换为我们的用例可以处理的格式，同时展示者将领域数据转换为视图友好的格式。
- en: Using our task management system as an example, we saw how to implement controllers
    that remain independent of specific input sources and presenters that separate
    formatting logic from view implementation details. We built on the result pattern
    from [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123), introducing `OperationResult`
    for explicit success and failure handling at our architectural boundaries. The
    humble object pattern showed us how to maintain clean separation between presentation
    logic and views, improving both testability and maintainability.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的任务管理系统为例，我们看到了如何实现控制器，使其独立于特定的输入源，以及展示者如何将格式化逻辑与视图实现细节分离。我们基于第[*5章*](Chapter_05.xhtml#_idTextAnchor123)中的结果模式，引入了`OperationResult`，以便在架构边界处进行显式的成功和失败处理。谦逊的对象模式向我们展示了如何保持展示逻辑和视图之间的清洁分离，从而提高可测试性和可维护性。
- en: In [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168) we’ll explore how to implement
    specific interfaces that consume our controllers and presenters. You’ll learn
    how to create command-line and web interfaces that interact with our system while
    maintaining the clean boundaries we’ve established.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](Chapter_07.xhtml#_idTextAnchor168)中，我们将探讨如何实现特定接口，这些接口消费我们的控制器和展示者。你将学习如何创建命令行和Web界面，这些界面与我们的系统交互，同时保持我们已建立的清洁边界。
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Clean DDD Lessons: Presenters* ([https://medium.com/unil-ci-software-engineering/clean-ddd-lessons-presenters-6f092308b75e](https://medium.com/unil-ci-software-engineering/clean-ddd-lessons-presenters-6f092308b75e)).
    A discussion of approaches to Presenters in Clean Architecture.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清洁 DDD 课程：展示者* ([https://medium.com/unil-ci-software-engineering/clean-ddd-lessons-presenters-6f092308b75e](https://medium.com/unil-ci-software-engineering/clean-ddd-lessons-presenters-6f092308b75e))。关于清洁架构中展示者方法的讨论。'
- en: '*Implementing Clean Architecture—Are Asp.Net Controllers “Clean”?* ([https://www.plainionist.net/Implementing-Clean-Architecture-AspNet/](https://www.plainionist.net/Implementing-Clean-Architecture-AspNet/)).
    An in-depth article discussing the pros and cons of multiple approaches to implementing
    views in Clean Architecture.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现清洁架构——Asp.Net 控制器“清洁”吗？* ([https://www.plainionist.net/Implementing-Clean-Architecture-AspNet/](https://www.plainionist.net/Implementing-Clean-Architecture-AspNet/))。一篇深入讨论在清洁架构中实现视图的多种方法优缺点的文章。'
