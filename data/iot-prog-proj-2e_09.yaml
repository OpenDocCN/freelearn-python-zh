- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Understanding LoRa
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解LoRa
- en: In this chapter, we explore the world of **LoRa** (short for **Long Range**),
    a key technology in IoT communication. LoRa is known for transmitting data over
    extensive distances with minimal power. We will explore its practical applications
    in areas such as agriculture, where it enables efficient management of large-scale
    sensor networks, and urban settings, where it assists in smart city initiatives
    such as street lighting control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索**LoRa**（即**长距离**）的世界，这是物联网通信的关键技术。LoRa以其在最小功率下传输数据到长距离而闻名。我们将探讨其在农业等领域的实际应用，如实现大规模传感器网络的效率管理，以及在城市化环境中协助智能城市倡议，如街道照明控制。
- en: We will also investigate the **radio frequency spectrum** and understand how
    different frequencies are allocated for various wireless communications, allowing
    us to better comprehend the operational range of LoRa technology. By studying
    the frequency spectrum, we can identify which frequency bands are most suitable
    for LoRa transmissions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究**射频频谱**，了解不同频率如何分配给各种无线通信，使我们能够更好地理解LoRa技术的操作范围。通过研究频谱，我们可以确定哪些频段最适合LoRa传输。
- en: 'Our focus then shifts to the practical aspect: building a LoRa sensory transmitter
    and LoRa receiver using a Raspberry Pi Pico and Pico W, respectively. We’ll start
    with assembling the transmitter circuit by integrating an RFM95W LoRa module,
    a DHT22 temperature sensor, and a Raspberry Pi Pico. We will then house these
    components in a custom 3D-printed case. We’ll emphasize using the standard Raspberry
    Pi Pico for its efficiency in tasks that don’t require Wi-Fi, benefiting from
    its lower power consumption and reduced firmware overhead.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的重点转向实际方面：使用Raspberry Pi Pico和Pico W分别构建LoRa传感器发射器和LoRa接收器。我们将从组装发射器电路开始，整合RFM95W
    LoRa模块、DHT22温度传感器和Raspberry Pi Pico。然后，我们将将这些组件放入定制的3D打印外壳中。我们将强调使用标准的Raspberry
    Pi Pico，因为它在不需要Wi-Fi的任务中效率高，得益于其较低的功耗和减少的固件开销。
- en: For the receiver, we use a Raspberry Pi Pico W, focusing on its Wi-Fi capabilities
    for future developments. We’ll construct a custom case for the receiver, as with
    the transmitter, but with an LED for status indication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接收器，我们使用Raspberry Pi Pico W，专注于其Wi-Fi功能以供未来的开发使用。我们将为接收器构建一个定制外壳，就像发射器一样，但带有LED进行状态指示。
- en: The development process includes setting up CircuitPython, installing necessary
    libraries, and writing the code for both the transmitter and receiver. CircuitPython
    is an open-source derivative of MicroPython, developed by Adafruit, designed to
    simplify coding for microcontrollers. In our code, we’ll use a delay between transmissions
    to adhere to European duty-cycle limitations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程包括设置CircuitPython，安装必要的库，以及编写发射器和接收器的代码。CircuitPython是MicroPython的开源衍生产品，由Adafruit开发，旨在简化微控制器的编程。在我们的代码中，我们将使用传输之间的延迟来遵守欧洲占空比限制。
- en: Finally, we will test our application outdoors, demonstrating LoRa’s impressive
    range capabilities as compared with the limited range of Wi-Fi.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在户外测试我们的应用程序，展示LoRa令人印象深刻的范围能力，与Wi-Fi有限的范围相比。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Exploring LoRa
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LoRa
- en: Building a LoRa sensory transmitter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建LoRa传感器发射器
- en: Building a LoRa receiver
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建LoRa接收器
- en: Let’s begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python编程的中级知识
- en: 1 x Raspberry Pi Pico WH (with headers) for development (may add headers to
    a Raspberry Pi Pico W instead)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Raspberry Pi Pico WH（带引脚）用于开发（可添加引脚到Raspberry Pi Pico W）
- en: 1 x Pico GPIO expander for development
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Pico GPIO扩展器用于开发
- en: 1 x Raspberry Pi Pico (for LoRa sensory transmitter)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Raspberry Pi Pico（用于LoRa传感器发射器）
- en: 1 x Raspberry Pi Pico W (for LoRa receiver)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x Raspberry Pi Pico W（用于LoRa接收器）
- en: 2 x RFM95W LoRa modules
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x RFM95W LoRa模块
- en: 1 x DHT22 temperature and humidity sensor
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x DHT22温度和湿度传感器
- en: 1 x LED (any color)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x LED（任何颜色）
- en: 1 x 220 Ohm resistor
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 220 欧姆电阻
- en: 4 x M3 10 mm bolts
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x M3 10毫米螺栓
- en: 12 x M2 5 mm screws
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12 x M2 5毫米螺丝
- en: 2 x M5 20 mm bolts
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x M5 20毫米螺栓
- en: 2 x M5 nuts
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x M5螺母
- en: Hot glue gun
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热胶枪
- en: Access to a 3D printer or 3D printer service to print custom cases
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有访问3D打印机或3D打印机服务以打印定制外壳的能力
- en: Build files for custom cases may be found in our GitHub repository
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制外壳的构建文件可在我们的GitHub仓库中找到
- en: 'The code and build files for this chapter may be found here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和构建文件可在此处找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9)'
- en: Exploring LoRa
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LoRa
- en: LoRa is a wireless communication technology known for its ability to transmit
    data over long distances while consuming very little power. It has become increasingly
    significant in the field of IoT due to its efficiency and reliability in various
    environments. Originating as a solution for extending the range of wireless communications,
    LoRa technology has evolved to play a pivotal role in connecting a wide array
    of IoT devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: LoRa是一种无线通信技术，以其能够在长距离传输数据同时消耗极低功率的能力而闻名。由于其效率和可靠性在各种环境中，LoRa在物联网领域变得越来越重要。作为扩展无线通信范围的解决方案，LoRa技术已经发展到在连接广泛的物联网设备中扮演关键角色的地步。
- en: In the following sections, we will look at the practical uses of LoRa before
    we explore the frequency spectrum and how it relates to LoRa.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，在我们探讨频谱及其与LoRa的关系之前，我们将查看LoRa的实际应用。
- en: Practical uses for LoRa technology
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LoRa技术的实际应用
- en: LoRa technology is instrumental in areas such as agriculture, enabling farmers
    to deploy sensory networks for monitoring soil moisture, temperature, and other
    vital parameters over large areas, enhancing crop management and resource efficiency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: LoRa技术在农业等领域发挥着重要作用，使农民能够在大片土地上部署传感器网络来监测土壤湿度、温度和其他关键参数，从而提高作物管理和资源效率。
- en: '**LoRa nodes** offer a cost-effective solution for modernizing agricultural
    practices, contrasting with costlier alternatives such as **Long Term Evolution**
    (**LTE**)-based systems or extensive wired sensor networks. While LTE supports
    more data-intensive applications, its higher power requirements and operational
    costs can be prohibitive.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**LoRa节点**为现代化农业实践提供了一种经济有效的解决方案，与成本更高的替代方案（如基于**长期演进**（**LTE**）的系统或广泛的线缆传感器网络）形成对比。虽然LTE支持更密集的数据应用，但其更高的功率需求和运营成本可能成为障碍。'
- en: 'In *Figure 9**.1*, we see an AI-generated image of LoRa nodes used to measure
    soil and weather conditions for a modern farm:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.1*中，我们看到一个由AI生成的图像，展示了用于测量现代农场土壤和天气条件的LoRa节点：
- en: '![Figure 9.1 – Modern farm using LoRa technology](img/B21282_09_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 使用LoRa技术的现代农场](img/B21282_09_01.jpg)'
- en: Figure 9.1 – Modern farm using LoRa technology
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 使用LoRa技术的现代农场
- en: 'In urban environments, LoRa may be used to manage smart city applications such
    as street lighting. In *Figure 9**.2*, we see a smart light post used in an urban
    environment. In this setting, control of the light is determined by a central
    office with a LoRa message sent to the light post to turn it on or off or control
    its brightness:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在城市环境中，LoRa可能被用于管理智能城市应用，如街灯。在*图9**.2*中，我们看到一个用于城市环境的智能路灯。在这种情况下，灯光的控制由一个中央办公室通过发送到路灯的LoRa消息来决定是打开或关闭，或者控制其亮度：
- en: '![Figure 9.2 – Smart light post using LoRa messages for control](img/B21282_09_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用LoRa消息进行控制的智能路灯](img/B21282_09_02.jpg)'
- en: Figure 9.2 – Smart light post using LoRa messages for control
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用LoRa消息进行控制的智能路灯
- en: This method of control is beneficial as it allows for remote management of lighting
    based on real-time data and needs, such as adjusting brightness according to traffic
    conditions or time of day.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种控制方法有益，因为它允许根据实时数据和需求远程管理照明，例如根据交通状况或一天中的时间调整亮度。
- en: To better understand the application of LoRa communication technology, let’s
    examine the radio frequency spectrum it uses, focusing on how different frequencies
    cater to various application needs and scenarios.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解LoRa通信技术的应用，让我们考察它所使用的射频频谱，重点关注不同频率如何满足各种应用需求和场景。
- en: Investigating the radio frequency spectrum
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查射频频谱
- en: The radio frequency spectrum is used for various wireless communications, including
    television broadcasting, mobile data, satellite, and IoT technologies such as
    LoRa. Frequencies are allocated for specific uses to avoid interference and optimize
    communication efficiency. **Ultra high frequency** (**UHF**) bands, for example,
    are commonly used for television broadcasting, mobile phones, and Wi-Fi. Each
    frequency band has unique characteristics such as propagation range and penetration
    ability, making them suitable for specific applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电频谱被用于各种无线通信，包括电视广播、移动数据、卫星以及LoRa等物联网技术。频率被分配给特定用途，以避免干扰并优化通信效率。例如，**超高频**(**UHF**)波段通常用于电视广播、移动电话和Wi-Fi。每个频段都有独特的特性，如传播范围和穿透能力，使它们适用于特定应用。
- en: In general, lower frequencies, characterized by their longer wavelengths, can
    travel greater distances and are more effective at penetrating obstacles compared
    to higher frequencies. Conversely, higher frequencies, while having shorter wavelengths,
    possess the ability to carry more data due to their larger bandwidth. These characteristics
    are crucial in determining the suitable frequency band for different types of
    communication.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，低频，以其较长的波长为特征，可以传播更远的距离，并且比高频更有效地穿透障碍。相反，高频虽然波长较短，但由于其较大的带宽，能够携带更多的数据。这些特性对于确定不同类型通信的合适频段至关重要。
- en: 'A common example of the effectiveness of the penetration of low frequencies
    is how we often hear the bass, or lower frequencies, from music playing loudly
    inside a club when we are outside, but not higher frequencies, as lower frequencies
    are better at penetrating the walls of the club. This ability to penetrate through
    objects makes lower frequencies especially useful for communications that need
    to cover larger areas or pass through obstructions. For instance, lower frequency
    bands such as those used in AM radio can cover vast geographical areas, while
    higher frequencies, despite offering more bandwidth, have a shorter range and
    are more suited to urban settings with **Line-Of-Sight** (**LOS**) communication.
    Higher frequencies are desirable for technologies such as cell phone communication
    because they can carry more data, providing greater capacity for voice and data
    transmission. In *Figure 9**.3*, we see an illustration of the frequency spectrum
    used for wireless communications and associated technologies that operate in specific
    ranges:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 低频穿透力的一个常见例子是，当我们身处俱乐部外时，经常能听到音乐中低音或低频部分，但不会听到高频部分，因为低频比高频更擅长穿透俱乐部的墙壁。这种穿透物体的能力使得低频特别适用于需要覆盖较大区域或穿越障碍的通信。例如，像AM广播中使用的低频波段可以覆盖广阔的地理区域，而尽管高频提供了更多的带宽，但它们的覆盖范围较短，更适合具有**视距**(**LOS**)通信的城市环境。高频对于像手机通信这样的技术来说更受欢迎，因为它们可以携带更多的数据，提供更大的语音和数据传输容量。在
    *图9**.3* 中，我们可以看到用于无线通信及其特定频段内运行的相关技术的频率谱图：
- en: '![Figure 9.3 – The frequency spectrum for wireless communications](img/B21282_09_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 无线通信的频率谱](img/B21282_09_03.jpg)'
- en: Figure 9.3 – The frequency spectrum for wireless communications
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 无线通信的频率谱
- en: LoRa operates in the unlicensed frequency range of 867-869 MHz in Europe, 902-928
    MHz in North America, and 915-928 MHz in Australia (*Figure 9**.4*). These frequencies
    are chosen for their balance of range and penetration, ideal for the low-power,
    long-range communication that LoRa enables.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: LoRa在欧洲运行于867-869 MHz的未授权频段，在北美为902-928 MHz，在澳大利亚为915-928 MHz (*图9**.4*). 这些频率的选择是为了平衡其覆盖范围和穿透力，非常适合LoRa所支持的低功耗、长距离通信。
- en: 'The specific frequency bands can vary within the ranges shown in *Figure 9**.4*
    based on national regulations. We should always check local regulations to ensure
    compliance with the specific frequencies allowed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的频段可以在 *图9**.4* 中所示的范围内根据国家法规有所不同。我们应始终检查当地法规，以确保符合允许的特定频率：
- en: '![Figure 9.4 – LoRa frequencies based on location](img/B21282_09_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 根据位置确定的LoRa频率](img/B21282_09_04.jpg)'
- en: Figure 9.4 – LoRa frequencies based on location
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 根据位置确定的LoRa频率
- en: The use of unlicensed bands comes with regulatory limitations to ensure fair
    usage and minimize interference. In Europe, the 868 MHz band is subject to a duty-cycle
    limitation of 1%, restricting transmission time. In North America, the 915 MHz
    band has dwell-time restrictions, limiting the occupancy time of a signal on a
    channel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未授权频段伴随着监管限制，以确保公平使用并最小化干扰。在欧洲，868 MHz频段受到1%的占空比限制，限制了传输时间。在北美，915 MHz频段有逗留时间限制，限制了信号在信道上的占用时间。
- en: These limitations encourage efficient spectrum use and innovative communication
    protocol development, as seen in LoRa’s effectiveness within these frameworks.
    We will consider these limitations when we start writing LoRa code in the upcoming
    section, *Building a LoRa* *sensory transmitter*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制鼓励了频谱的有效使用和创新通信协议的开发，正如LoRa在这些框架中的有效性所展示的那样。在我们即将在下一节中开始编写LoRa代码时，我们将考虑这些限制，*构建一个LoRa*
    *传感器发射器*。
- en: Now that we have a basic understanding of the frequency spectrum and LoRa’s
    position within it, let’s explore the **Spreading Factor** (**SF**), a key parameter
    in LoRa that impacts the network’s range, data rate, and power efficiency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对频谱和LoRa在其中的位置有了基本的了解，让我们来探讨**扩频因子**（**SF**），这是影响LoRa网络范围、数据速率和功率效率的关键参数。
- en: Understanding the LoRa SF
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解LoRa SF
- en: LoRa employs **Chirp Spread Spectrum** (**CSS**) technology, where signals vary
    in frequency over time to encode data. This technique boosts signal reliability
    and minimizes power consumption, making it ideal for IoT devices that operate
    over extended periods. The use of a broad frequency range in LoRa enables devices
    to maintain connectivity over long distances while consuming less power. In this
    process, data transmission involves changing the signal’s frequency across a wide
    spectrum, significantly enhancing its resistance to interference and noise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: LoRa采用**跳频扩频**（**CSS**）技术，其中信号随时间变化频率以编码数据。这种技术提高了信号可靠性并最小化了功耗，使其非常适合长时间运行的物联网设备。LoRa使用广泛的频率范围允许设备在长距离内保持连接，同时消耗更少的能量。在这个过程中，数据传输涉及在宽频谱内改变信号的频率，显著增强了其抗干扰和噪声的能力。
- en: Complementing this, LoRa’s SF, a key parameter in LoRa communication, ranges
    from `SF7` to `SF12`. The SF determines the duration of each symbol (data packet)
    transmission, essentially balancing transmission range and data rate. Higher SFs,
    such as `SF12`, extend the range but reduce the data rate, making them suitable
    for long-distance communication. In contrast, lower SFs such as `SF7` offer faster
    data rates over shorter distances. This flexibility allows LoRa to cater to a
    wide array of use cases, from densely populated urban areas in smart cities to
    remote areas requiring long-range monitoring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，LoRa的SF，这是LoRa通信中的一个关键参数，范围从`SF7`到`SF12`。SF决定了每个符号（数据包）传输的持续时间，本质上平衡了传输范围和数据速率。较高的SF值，如`SF12`，可以扩展范围但降低数据速率，因此适合长距离通信。相比之下，较低的SF值，如`SF7`，在较短的距离上提供更快的速率。这种灵活性使得LoRa能够满足各种用例，从智能城市中人口密集的城市区域到需要长距离监控的偏远地区。
- en: 'In *Figure 9**.5*, we see the SF illustrated in an agricultural setting:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.5*中，我们看到在农业环境中展示了SF：
- en: '![Figure 9.5 – SF illustrated in an agricultural setting](img/B21282_09_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 在农业环境中展示的SF](img/B21282_09_05.jpg)'
- en: Figure 9.5 – SF illustrated in an agricultural setting
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 在农业环境中展示的SF
- en: The range increases with the SF number, but higher SFs also require more power
    due to extended transmission times. For effective communication, it’s essential
    that both the sender and receiver are configured with the same SF.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SF数值的增加，范围也会增加，但更高的SF值由于传输时间的延长而需要更多的能量。为了有效通信，发送方和接收方必须配置相同的SF。
- en: Now that we’ve explored LoRa communication technology, let’s incorporate what
    we’ve learned into the Raspberry Pi Pico and Pico W.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了LoRa通信技术，让我们将所学知识应用到Raspberry Pi Pico和Pico W上。
- en: Using LoRa with the Raspberry Pi Pico and Pico W
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico和Pico W的LoRa
- en: 'In this chapter, we will develop both a LoRa sensory transmitter and a LoRa
    receiver. Our LoRa sensory transmitter will utilize the Raspberry Pi Pico, a DHT22
    temperature sensor, and an RFM95W LoRa module. Our LoRa receiver will use a Raspberry
    Pi Pico W, an LED, and an RFM95W LoRa module. We may see our application outlined
    in *Figure 9**.6*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个 LoRa 传感器发射器和 LoRa 接收器。我们的 LoRa 传感器发射器将使用 Raspberry Pi Pico、DHT22
    温度传感器和 RFM95W LoRa 模块。我们的 LoRa 接收器将使用 Raspberry Pi Pico W、LED 和 RFM95W LoRa 模块。我们可能会在
    *图 9.6* 中看到我们的应用程序概述：
- en: '![Figure 9.6 – LoRa sensory transmitter and LoRa receiver](img/B21282_09_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – LoRa 传感器发射器和 LoRa 接收器](img/B21282_09_06.jpg)'
- en: Figure 9.6 – LoRa sensory transmitter and LoRa receiver
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – LoRa 传感器发射器和 LoRa 接收器
- en: We will begin creating our application by building a LoRa sensory transmitter.
    We will start with wiring up an RFM95W LoRa module to a Raspberry Pi Pico before
    we move on to installing the temperature sensor in a test circuit. Finally, we
    will install the components into a custom 3D-printed case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建我们的应用程序，首先构建一个 LoRa 传感器发射器。在我们将温度传感器安装到测试电路中之前，我们将首先将 RFM95W LoRa 模块连接到
    Raspberry Pi Pico。最后，我们将将这些组件安装到定制的 3D 打印机箱中。
- en: Building a LoRa sensory transmitter
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 LoRa 传感器发射器
- en: In this section, we will build a LoRa sensory transmitter with a temperature
    sensor using a Raspberry Pi Pico, an RFM95W LoRa module, and a DHT22 temperature
    sensor. Our goal is to create a device that reads temperature and humidity data
    from a DHT22 temperature sensor and transmits this information using the RFM95W
    LoRa module. We will use the Raspberry Pi Pico and not Pico W for our design,
    although we could just as easily swap out the Pico for the Pico W.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Raspberry Pi Pico、RFM95W LoRa 模块和 DHT22 温度传感器构建一个带有温度传感器的 LoRa 传感器发射器。我们的目标是创建一个从
    DHT22 温度传感器读取温度和湿度数据并使用 RFM95W LoRa 模块传输这些信息的设备。虽然我们可以轻松地将 Pico 替换为 Pico W，但我们将使用
    Raspberry Pi Pico 而不是 Pico W 进行设计。
- en: For building and testing our circuit, we will use a Raspberry Pi Pico WH installed
    on a Pico GPIO expander. Using a Pico WH allows us to build and test circuits
    for both Pico and Pico W applications. We will use Pico W for the receiver part
    of our application and not the Pico WH due to size constraints.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建和测试我们的电路，我们将使用安装在 Pico GPIO 扩展器上的 Raspberry Pi Pico WH。使用 Pico WH 允许我们构建和测试适用于
    Pico 和 Pico W 应用程序的电路。由于尺寸限制，我们将使用 Pico W 作为我们应用程序的接收器部分，而不是 Pico WH。
- en: Advantages of using a standard Pico over a Pico W
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准 Pico 而非 Pico W 的优势
- en: Besides its cost advantage, the Raspberry Pi Pico offers benefits over the Raspberry
    Pi Pico W for our LoRa sensory transmitter. The standard Pico, known for its lower
    power consumption, is well-suited for tasks that don’t require Wi-Fi. Its simpler
    design leads to reduced firmware overhead, allowing the device to focus its resources
    on specific tasks rather than managing Wi-Fi connectivity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了成本优势外，Raspberry Pi Pico 相比于 Raspberry Pi Pico W，为我们提供的 LoRa 传感器发射器带来了更多好处。以其较低的功耗而闻名的标准
    Pico，非常适合不需要 Wi-Fi 的任务。其更简单的设计导致固件开销减少，使设备能够将资源集中在特定任务上，而不是管理 Wi-Fi 连接。
- en: We’ll also build a custom case to house our components. This case will not only
    offer protection but will also ensure organized wiring and enhance the overall
    durability and portability of our LoRa sensory transmitter. We will start off
    by adding wires to the RFM95W LoRa module and wiring it up to our Raspberry Pi
    Pico WH for development. We will later replace the Pico WH with a Pico as we install
    our components into a custom case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将构建一个定制的机箱来容纳我们的组件。这个机箱不仅提供保护，还将确保线路整齐，并提高我们 LoRa 传感器发射器的整体耐用性和便携性。我们将首先将电线添加到
    RFM95W LoRa 模块，并将其连接到我们的 Raspberry Pi Pico WH 以进行开发。在我们将组件安装到定制机箱中时，我们将用 Pico
    替换 Pico WH。
- en: Constructing our circuit
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的电路
- en: The RFM95W is a compact LoRa module favored for its long-range capabilities
    and low power consumption. Designed for sub-GHz frequency operation, it’s well-suited
    for applications that demand efficient, long-distance wireless communication.
    Despite its small size, the RFM95W excels in covering greater distances than conventional
    wireless technologies, making it particularly effective in open environments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RFM95W 是一款紧凑型 LoRa 模块，因其长距离能力和低功耗而受到青睐。专为亚 GHz 频率操作设计，非常适合需要高效、长距离无线通信的应用。尽管体积小巧，RFM95W
    在覆盖比传统无线技术更远距离方面表现出色，使其在开阔环境中特别有效。
- en: We will start by soldering jumper wires onto the RFM95W.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将跳线焊接在 RFM95W 上。
- en: Adding wires to the RFM95W
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将电线添加到 RFM95W 上
- en: Measuring only 16 mm by 16 mm, the RFM95W module is tiny. Care must be taken
    when soldering the jumper wires to the holes of the RFM95W. This is not a soldering
    job for someone first learning to solder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: RFM95W模块的尺寸仅为16毫米乘以16毫米，非常小巧。在焊接跳线到RFM95W的孔时必须小心。这不是一个适合初学者焊接的工作。
- en: 'In *Step 1* of *Figure 9**.7*, we see the RFM95W prior to adding our jumper
    wires. The type of jumper wires we add depends on the breadboarding option we
    choose. For example, in this case, we are adding female jumper wires (*Step 2*
    of *Figure 9**.7*) as we will be using a GPIO expander for our Raspberry Pi Pico
    WH:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.7*的*步骤1*中，我们看到在添加跳线之前RFM95W的样子。我们添加的跳线类型取决于我们选择的面包板选项。例如，在这种情况下，我们正在添加母跳线（*图9.7*的*步骤2*），因为我们将会使用GPIO扩展器为我们的Raspberry
    Pi Pico WH：
- en: '![Figure 9.7 – Adding wires to the RFM95W](img/B21282_09_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 将线连接到RFM95W](img/B21282_09_07.jpg)'
- en: Figure 9.7 – Adding wires to the RFM95W
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 将线连接到RFM95W
- en: '![Figure 9.8 – RFM95W pins for wiring](img/B21282_09_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – RFM95W的接线引脚](img/B21282_09_08.jpg)'
- en: Figure 9.8 – RFM95W pins for wiring
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – RFM95W的接线引脚
- en: 'We do not need to solder wires to every terminal of the RFM95W. In *Figure
    9**.8*, we outline the terminals that we require jumper wires for and the length
    of wire needed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将线焊接在RFM95W的每个端子上。在*图9.8*中，我们概述了需要跳线的端子和所需的线长：
- en: Our table illustrates that the length of the wire used for our antenna differs
    based on the specific frequency model of the RFM95W LoRa module we choose. To
    account for this variation, we’ve designed different versions of our custom case
    to accommodate each model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表格显示，我们使用的天线线长度取决于我们选择的RFM95W LoRa模块的具体频率型号。为了适应这种变化，我们设计了不同版本的定制外壳以适应每个型号。
- en: Each case version incorporates a straight antenna wire enclosure, effectively
    creating a built-in antenna specifically tailored for the respective frequency.
    This aspect of the design is particularly appealing for those of us who have encountered
    issues with low-cost antennas that don’t accurately match their labeled frequencies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本都包含一个直天线线封装，有效地创建了一个针对相应频率定制的内置天线。这个设计特点对我们这些遇到过低成本天线无法准确匹配其标称频率的问题的人来说特别有吸引力。
- en: Adafruit RFM95W LoRa Radio Transceiver Breakout
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit RFM95W LoRa无线收发器扩展板
- en: For those of us who wish to work with a LoRa board that is larger than the standard
    RFM95W, the Adafruit RFM95W LoRa Radio Transceiver Breakout is a great option.
    Unlike our RFM95W, this board is breadboard-friendly, using header pins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望使用比标准RFM95W更大的LoRa板的人来说，Adafruit RFM95W LoRa无线收发器扩展板是一个不错的选择。与我们的RFM95W不同，这个板子适合面包板使用，使用了引脚头。
- en: To reinforce the soldered connections of the jumpers on our RFM95W, we can apply
    glue from a hot glue gun, as detailed in *Step 3* of *Figure 9**.7*. We use these
    jumpers to plug the module into the Raspberry Pi Pico WH GPIO expander for initial
    testing and prototyping.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强RFM95W上跳线的焊接连接，我们可以使用热胶枪上的胶水，如*图9.7*的*步骤3*中详细说明。我们使用这些跳线将模块插入Raspberry Pi
    Pico WH GPIO扩展器进行初始测试和原型制作。
- en: Assembling our circuit
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装我们的电路
- en: 'With the jumper wires soldered to our RFM95W model, we may now construct our
    circuit on a Raspberry Pi Pico GPIO expander. *Figure 9**.9* illustrates a wiring
    diagram for the Raspberry Pi Pico, Raspberry Pi Pico WH, and the RFM95W LoRa module:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在将跳线焊接到我们的RFM95W模型后，我们现在可以在Raspberry Pi Pico GPIO扩展器上构建我们的电路。*图9.9*展示了Raspberry
    Pi Pico、Raspberry Pi Pico WH和RFM95W LoRa模块的接线图：
- en: '![Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico](img/B21282_09_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 将RFM95W模块连接到Raspberry Pi Pico](img/B21282_09_09.jpg)'
- en: Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 将RFM95W模块连接到Raspberry Pi Pico
- en: 'To complete our circuit, we add a DHT22 temperature sensor to our circuit using
    the wiring diagram in *Figure 9**.10*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的电路，我们使用*图9.10*中的接线图将DHT22温度传感器添加到电路中：
- en: '![Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)](img/B21282_09_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 将DHT22连接到Raspberry Pi Pico (WH)](img/B21282_09_10.jpg)'
- en: Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 将DHT22连接到Raspberry Pi Pico (WH)
- en: 'In *Figure 9**.11* (*A*), we get a practical view of our circuit layout using
    a Raspberry Pi Pico with a GPIO expander (before the DHT22 is added). In our example,
    we’re utilizing a Raspberry Pi Pico WH and the GPIO expander for circuit construction
    and testing:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.11*（*A*）中，我们通过使用带有GPIO扩展器的Raspberry Pi Pico（在添加DHT22之前）来获得我们电路布局的实际视图。在我们的例子中，我们正在使用Raspberry
    Pi Pico WH和GPIO扩展器进行电路构建和测试：
- en: '![Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module](img/B21282_09_11.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 配有 GPIO 扩展器和 RFM95W LoRa 模块的 Raspberry Pi Pico WH](img/B21282_09_11.jpg)'
- en: Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 配有 GPIO 扩展器和 RFM95W LoRa 模块的 Raspberry Pi Pico WH
- en: We can see a table with the wire connections in *Figure 9**.11* (*B*) and what
    our Raspberry Pi Pico and RFM95W will look like wired together in the case in
    *Figure* *9**.11* (*C*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 9.11* (*B*) 中看到一个表格，显示了线缆连接，以及我们的 Raspberry Pi Pico 和 RFM95W 连接在一起时的样子（*图*
    *9.11* (*C*))。
- en: With our circuit wired up, we are now ready to write our code to send temperature
    and humidity data through LoRa. We will use Thonny as our development environment
    and the CircuitPython firmware.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电路连接好之后，我们现在可以编写代码，通过 LoRa 发送温度和湿度数据。我们将使用 Thonny 作为我们的开发环境，并使用 CircuitPython
    固件。
- en: Developing the code
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发代码
- en: For our application, we will use **CircuitPython** over **MicroPython** due
    to several key differences between these Python implementations. CircuitPython,
    a derivative of MicroPython developed by Adafruit, offers a more streamlined experience
    for specific use cases, particularly with its comprehensive library support.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些 Python 实现之间存在几个关键差异，因此我们的应用程序将使用 **CircuitPython** 而不是 **MicroPython**。CircuitPython
    是 Adafruit 开发的 MicroPython 衍生品，为特定用例提供了更流畅的体验，特别是其全面的库支持。
- en: We will start our development by installing the CircuitPython firmware onto
    our Raspberry Pi Pico WH.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过将 CircuitPython 固件安装到我们的 Raspberry Pi Pico WH 上来开始我们的开发。
- en: Setting up CircuitPython and sensor libraries
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 CircuitPython 和传感器库
- en: We develop our application for the Raspberry Pi Pico (WH) using the Thonny IDE,
    a tool that’s compatible with various development environments such as Raspberry
    Pi, Windows, Linux, and macOS. For our example, we are using Thonny on Windows.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Thonny IDE 为 Raspberry Pi Pico (WH) 开发我们的应用程序，这是一个兼容各种开发环境（如 Raspberry
    Pi、Windows、Linux 和 macOS）的工具。在我们的示例中，我们正在 Windows 上使用 Thonny。
- en: In terms of setting up the Raspberry Pi Pico (WH), the installation of CircuitPython
    via Thonny is a straightforward process, like how we would install MicroPython.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 Raspberry Pi Pico (WH) 方面，通过 Thonny 安装 CircuitPython 是一个简单的过程，就像我们安装 MicroPython
    一样。
- en: 'To install CircuitPython on our Raspberry Pi Pico (WH), we do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的 Raspberry Pi Pico (WH) 上安装 CircuitPython，我们执行以下操作：
- en: If Thonny is not available on our operating system, we visit the Thonny website
    and download an appropriate version ([https://thonny.org](https://thonny.org)).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的操作系统上没有 Thonny，我们访问 Thonny 网站，下载合适的版本（[https://thonny.org](https://thonny.org)）。
- en: We then launch Thonny using the appropriate method for our operating system.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用适合我们操作系统的适当方法启动 Thonny。
- en: 'While holding the *BOOTSEL* button on the Pico (WH), the small white button
    near the USB port, we insert it into an available USB port and disregard any pop-up
    windows that may appear:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住 Pico（WH）上的 *BOOTSEL* 按钮的同时，即靠近 USB 端口的白色小按钮，我们将它插入一个可用的 USB 端口，并忽略可能出现的任何弹出窗口：
- en: '![Figure 9\. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)](img/B21282_09_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – Pico WH（与 Pico 相似）上的 BOOTSEL 按钮](img/B21282_09_12.jpg)'
- en: Figure 9\. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – Pico WH（与 Pico 相似）上的 BOOTSEL 按钮
- en: 'We then click on the interpreter information at the bottom right-hand side
    of the screen and select **Install CircuitPython…**:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在屏幕右下角点击解释器信息，并选择**安装 CircuitPython…**：
- en: '![Figure 9.13 – Install CircuitPython… option](img/B21282_09_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 安装 CircuitPython… 选项](img/B21282_09_13.jpg)'
- en: Figure 9.13 – Install CircuitPython… option
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 安装 CircuitPython… 选项
- en: 'For `RPI-RP2 (D:)`). In our example, we select the **Raspberry Pi • Pico /
    Pico H** CircuitPython variant and the latest version:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `RPI-RP2 (D:)`)。在我们的示例中，我们选择了**Raspberry Pi • Pico / Pico H** CircuitPython
    变体和最新版本：
- en: '![Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W](img/B21282_09_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 在 Raspberry Pi Pico W 上安装 MicroPython](img/B21282_09_14.jpg)'
- en: Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 在 Raspberry Pi Pico W 上安装 MicroPython
- en: Even though we are developing on a Pico WH, we treat it as a Pico for development
    purposes. We click on the **Install** button and then the **Close** button once
    the installation has completed.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们在 Pico WH 上进行开发，但我们将其视为一个用于开发的 Pico。我们点击**安装**按钮，然后在安装完成后点击**关闭**按钮。
- en: 'To have Thonny configured to run the CircuitPython interpreter on our Pico
    (WH), we select it from the bottom right-hand side of the screen:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 Thonny 配置为在我们的 Pico（WH）上运行 CircuitPython 解释器，我们从屏幕右下角选择它：
- en: '![Figure 9.15 – Selecting the CircuitPython interpreter](img/B21282_09_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 选择 CircuitPython 解释器](img/B21282_09_15.jpg)'
- en: Figure 9.15 – Selecting the CircuitPython interpreter
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 选择 CircuitPython 解释器
- en: 'We confirm that Thonny is using the CircuitPython interpreter on our Raspberry
    Pi Pico (WH) by checking the **Shell**:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过检查 **Shell** 来确认 Thonny 是否在我们的 Raspberry Pi Pico (WH) 上使用 CircuitPython
    解释器：
- en: '![Figure 9.16 – CircuitPython prompt in Thonny](img/B21282_09_16.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – Thonny 中的 CircuitPython 提示](img/B21282_09_16.jpg)'
- en: Figure 9.16 – CircuitPython prompt in Thonny
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – Thonny 中的 CircuitPython 提示
- en: With CircuitPython installed, we are now ready to install the libraries we need
    for our code. This involves downloading the package from the Adafruit website
    and copying over the library files we need to our Raspberry Pi Pico (WH).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 CircuitPython 之后，我们现在可以安装我们代码所需的库。这涉及到从 Adafruit 网站下载包，并将我们需要的库文件复制到我们的
    Raspberry Pi Pico (WH) 上。
- en: 'To do this, we do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们执行以下操作：
- en: 'Using a web browser, we navigate to the following URL: [https://circuitpython.org/libraries](https://circuitpython.org/libraries).'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网页浏览器，我们导航到以下 URL：[https://circuitpython.org/libraries](https://circuitpython.org/libraries)。
- en: As we are using CircuitPython 8, we download the `adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP file and unzip it to a location on our computer.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用的是 CircuitPython 8，我们下载 `adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP 文件，并将其解压到我们的计算机上的某个位置。
- en: 'The two files we are interested in are `adafruit_rfm9x.mpy` and `adafruit_dht.mpy`,
    both of which may be found in the `lib` folder in the unzipped directory. These
    files are library files for our RFM95W and DHT22 sensors respectively. To install
    these libraries onto our Raspberry Pi Pico (WH) from Thonny, we locate them in
    the **Files** section and right-click to get the following dialog:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们感兴趣的文件是 `adafruit_rfm9x.mpy` 和 `adafruit_dht.mpy`，这两个文件都可以在解压目录的 `lib` 文件夹中找到。这些文件分别是我们的
    RFM95W 和 DHT22 传感器的库文件。要从 Thonny 将这些库安装到我们的 Raspberry Pi Pico (WH) 上，我们在 **文件**
    部分找到它们，然后右键点击以获取以下对话框：
- en: '![Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)](img/B21282_09_17.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 将库文件上传到 Raspberry Pi Pico (WH)](img/B21282_09_17.jpg)'
- en: Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 将库文件上传到 Raspberry Pi Pico (WH)
- en: 'We must ensure that we upload these libraries to the `lib` folder on our Pico
    (WH) and not the root directory. This would involve double-clicking on the `lib`
    folder under the **CircuitPython device** section in Thonny to open it. After
    uploading the libraries to the Pico (WH), the file structure on our Pico (WH)
    should look like the following:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保将这些库上传到我们的 Pico (WH) 上的 `lib` 文件夹，而不是根目录。这涉及到在 Thonny 的 **CircuitPython
    设备** 部分下双击 `lib` 文件夹以打开它。在将库上传到 Pico (WH) 之后，我们的 Pico (WH) 上的文件结构应该如下所示：
- en: '![Figure 9.18 – Pico file structure after uploading libraries](img/B21282_09_18.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 上传库后 Pico 文件结构](img/B21282_09_18.jpg)'
- en: Figure 9.18 – Pico file structure after uploading libraries
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 上传库后 Pico 文件结构
- en: With our circuit built and CircuitPython and the libraries installed, it is
    time to write our code. As we will see, we do not require a great amount of code
    to send temperature and humidity data through LoRa.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电路搭建好，并安装了 CircuitPython 和库之后，现在是时候编写我们的代码了。正如我们将看到的，我们不需要大量的代码就能通过 LoRa
    发送温度和湿度数据。
- en: Creating LoRa transmission code
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 LoRa 传输代码
- en: To comply with different regulatory standards, we’ll use a delay for our LoRa
    transmissions. While Europe’s 1% duty-cycle limit allows for a 99-second delay
    between messages, we’ll extend this to 120 seconds, due to the stable nature of
    temperature and humidity data. This will result in a duty cycle of approximately
    0.83%.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合不同的监管标准，我们将为我们的 LoRa 传输使用延迟。虽然欧洲的 1% 负载周期限制允许消息之间有 99 秒的延迟，但鉴于温度和湿度数据的稳定性，我们将此延迟扩展到
    120 秒，这将导致负载周期大约为 0.83%。
- en: Although North America’s regulations focus on dwell time, the period a transmitter
    occupies a frequency channel rather than a duty cycle, we’re adopting this duty-cycle
    approach for uniformity. We will use the 915 MHz frequency version of the RFM95W
    for our application as the author is based in North America.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管北美法规侧重于占用时间，即发射机占用频率通道的时间段而不是负载周期，但我们为了统一性采用这种负载周期方法。由于作者位于北美，我们将使用 RFM95W
    的 915 MHz 频率版本来应用我们的应用。
- en: 'To write our LoRa transmission code, we do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的 LoRa 传输代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico (WH) to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this. In our example, we
    are using Thonny on Windows.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的 Raspberry Pi Pico (WH) 连接到 USB 端口并启动 Thonny。我们可以使用 Raspberry Pi 或其他操作系统来完成这个操作。在我们的例子中，我们正在
    Windows 上使用 Thonny。
- en: We then activate the CircuitPython environment on our Pico (WH) by selecting
    it from the bottom right-hand side of the screen.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从屏幕的右下角选择 Pico (WH) 上的 CircuitPython 环境，以激活它。
- en: 'In a new tab, we enter the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新标签页中，我们输入以下代码：
- en: '[PRE0]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our code, we do the following:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: '`time`, `board`, `busio`, `digitalio`, `adafruit_rfm9x` (for LoRa communication),
    and `adafruit_dht` (for the DHT22 sensor).'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time`，`board`，`busio`，`digitalio`，`adafruit_rfm9x`（用于 LoRa 通信）和 `adafruit_dht`（用于
    DHT22 传感器）。'
- en: '**We then set up SPI communication**: We configure SPI with specific GPIO pins
    (GP18, GP19, GP16) for the RFM95W LoRa module.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后设置 SPI 通信**：我们使用特定的 GPIO 引脚（GP18，GP19，GP16）配置 SPI，用于 RFM95W LoRa 模块。'
- en: '**We initialize Chip Select (CS) and Reset (RST) pins**: We set up digital
    I/O for CS (GP17) and RST (GP14) pins.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们初始化芯片选择（CS）和复位（RST）引脚**：我们为 CS（GP17）和 RST（GP14）引脚设置数字 I/O。'
- en: '**We then create an RFM95W LoRa object**: We initialize the RFM9x object for
    LoRa communication at 915.0 MHz. This value should be set based on local regulations.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后创建一个 RFM95W LoRa 对象**：我们初始化 RFM9x 对象以在 915.0 MHz 的频率上进行 LoRa 通信。此值应根据当地法规设置。'
- en: '**We initialize the DHT22 sensor**: We set up the DHT22 temperature and humidity
    sensor on GPIO 4 (GP4).'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们初始化 DHT22 传感器**：我们在 GPIO 4（GP4）上设置 DHT22 温度和湿度传感器。'
- en: '**We then print a status message**: We indicate that temperature and humidity
    data will be sent every 120 seconds.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后打印一个状态消息**：我们指示每 120 秒将发送温度和湿度数据。'
- en: '**We continuously send data**: In an infinite loop, we read temperature and
    humidity from the DHT22 sensor, format the data, and send it over LoRa. If a read
    error occurs, we print an error message.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们持续发送数据**：在一个无限循环中，我们从 DHT22 传感器读取温度和湿度，格式化数据，并通过 LoRa 发送。如果发生读取错误，我们打印错误消息。'
- en: '**We then delay between transmissions**: We wait for 120 seconds before sending
    the next set of data.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**然后我们在传输之间延迟**：我们在发送下一组数据之前等待 120 秒。'
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择 **文件** | **另存为...**。这将打开以下对话框：
- en: '![Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)](img/B21282_09_19.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 将文件保存到我们的 Raspberry Pi Pico (WH)](img/B21282_09_19.jpg)'
- en: Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 将文件保存到我们的 Raspberry Pi Pico (WH)
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico (WH), we click on the corresponding button.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对话框中，我们被提供选择文件存储位置的选择。要将文件保存到我们的 Raspberry Pi Pico (WH)，我们点击相应的按钮。
- en: We then give the file the name `code.py` and click `code.py` is special because
    the system automatically executes this file upon startup or reset, making it the
    default script that runs when the device powers up.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件命名为 `code.py` 并点击 `code.py` 是特殊的，因为系统在启动或重置时自动执行此文件，使其成为设备启动时运行的默认脚本。
- en: What SF are we using?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是哪个 SF？
- en: In our code, we don’t explicitly set the SF, so the `adafruit_rfm9x` library’s
    default is used. Typically, this is an SF of `7`. Since we’re using the default
    SF for both `transmit` and `receive` nodes, there’s no need to focus on this setting
    in our application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们没有明确设置 SF，因此使用的是 `adafruit_rfm9x` 库的默认值。通常，这是一个 SF 为 `7` 的值。由于我们正在使用默认的
    SF 为 `transmit` 和 `receive` 节点，因此在我们的应用程序中不需要关注此设置。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色运行按钮，在键盘上按 *F5*，或者点击顶部菜单的 **运行** 选项，然后点击 **运行** **当前脚本**。
- en: 'In the **Shell**, we’ll see a notification confirming the creation of a LoRa
    message containing temperature and humidity data:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Shell** 中，我们将看到一个通知，确认已创建包含温度和湿度数据的 LoRa 消息：
- en: '![Figure 9.20 – LoRa message notification](img/B21282_09_20.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – LoRa 消息通知](img/B21282_09_20.jpg)'
- en: Figure 9.20 – LoRa message notification
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – LoRa 消息通知
- en: To recap, we have just created a LoRa sensory transmitter that sends temperature
    and humidity sensory data wirelessly. In the absence of errors, it’s reasonable
    to assume successful transmission of our LoRa message. However, without a LoRa
    receiver, we can’t confirm this. We’ll address this by building one in the next
    section. Before constructing the receiver, we’ll first house our components in
    a custom 3D-printed case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们刚刚创建了一个无线发送温度和湿度传感数据的LoRa传感器发射器。如果没有错误，我们可以合理地假设我们的LoRa消息已成功传输。然而，没有LoRa接收器，我们无法确认这一点。我们将在下一节中通过构建一个接收器来解决这个问题。在构建接收器之前，我们首先将我们的组件放入一个定制的3D打印外壳中。
- en: Installing the components in a custom case
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在定制外壳中安装组件
- en: Continuing our practice from previous projects, we’ll install our components
    in a custom case. This approach allows convenient placement of our LoRa sensory
    transmitter wherever it’s needed. We can see the custom case for our LoRa sensory
    transmitter displayed in *Figure 9**.21*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前项目的实践，我们将把我们的组件安装在一个定制外壳中。这种方法允许我们在需要的地方方便地放置我们的LoRa传感器发射器。我们可以在 *图9**.21*
    中看到我们的LoRa传感器发射器的定制外壳。
- en: 'The design of our custom case accommodates the DHT22 sensor, allowing it to
    extend from the front for accurate temperature and humidity readings. The antenna,
    a straight wire soldered to the RFM95W module, is housed in a protruding section
    attached to the base plate of the case. An antenna cover specifically designed
    for this purpose completes the enclosure, protecting and isolating the antenna.
    The 915 MHz version of the custom case is displayed in *Figure 9**.21*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制外壳设计容纳了DHT22传感器，允许它从前端伸出，以进行准确的温度和湿度读取。天线，一根焊接在RFM95W模块上的直导线，被放置在连接到外壳底板的突出部分中。一个专门为此目的设计的天线盖完成了封闭，保护并隔离了天线。定制外壳的915
    MHz版本在 *图9**.21* 中显示：
- en: '![Figure 9.21 – Custom case used for our LoRa transmitter node](img/B21282_09_21.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21 – 用于我们LoRa发射节点的定制外壳](img/B21282_09_21.jpg)'
- en: Figure 9.21 – Custom case used for our LoRa transmitter node
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 用于我们LoRa发射节点的定制外壳
- en: Our custom case is designed with a versatile GoPro-style hook at the back, enabling
    compatibility with various stands we’ve constructed in earlier chapters of the
    book. This feature allows for easy and flexible mounting of our LoRa sensory transmitter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制外壳在后面设计了一个多功能的GoPro式挂钩，使得它能够与我们在本书早期章节中构建的各种支架兼容。这一特性使得我们的LoRa传感器发射器易于且灵活地安装。
- en: The micro-USB port on the Raspberry Pi Pico is exposed, allowing us to provide
    power to our device. We may also use this port to program our Raspberry Pi Pico.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico上的微型USB端口是暴露的，这使得我们可以为我们的设备供电。我们也可以使用这个端口来编程我们的Raspberry Pi
    Pico。
- en: Using power banks for our Raspberry Pi Pico
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动电源为我们的Raspberry Pi Pico供电
- en: We can power our node remotely using a standard cell phone power bank. However,
    it’s important to select a power bank that doesn’t automatically shut off due
    to low power draw, as the Raspberry Pi Pico has minimal power requirements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的手机移动电源远程为我们的节点供电。然而，选择一个不会因为低功耗而自动关机的移动电源很重要，因为Raspberry Pi Pico的功耗要求很低。
- en: We will start the construction of our custom case by identifying the parts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建我们的定制外壳，首先识别部件。
- en: Identifying the parts of our custom LoRa case
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别我们的定制LoRa外壳的部件
- en: 'Our custom case features 3D-printed parts that screw together. We may see the
    parts and major components displayed in *Figure 9**.22*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制外壳由3D打印部件组成，可以拧在一起。我们可以在 *图9**.22* 中看到部件和主要组件：
- en: '![Figure 9.22 – Parts for custom case](img/B21282_09_22.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – 定制外壳的部件](img/B21282_09_22.jpg)'
- en: Figure 9.22 – Parts for custom case
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 定制外壳的部件
- en: 'Let’s break down each part:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析每个部件：
- en: 'Raspberry Pi Pico (*A* in *Figure 9**.22*): We use the header-less version
    of the Raspberry Pi Pico due to space constraints.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Raspberry Pi Pico (*A* 在 *图9**.22*): 由于空间限制，我们使用无引脚版本的Raspberry Pi Pico。'
- en: 'Backplate (*B* in *Figure 9**.22*): The backplate secures both the Raspberry
    Pi Pico and the RFM95W LoRa module. The length of the extension for the antenna
    is based on the frequency model used. In this example, we see the 915 MHz model.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '后盖 (*B* 在 *图9**.22*): 后盖固定了Raspberry Pi Pico和RFM95W LoRa模块。天线延长部分的长度基于所使用的频率模型。在这个例子中，我们看到的是915
    MHz模型。'
- en: 'Antenna cover (*C* in *Figure 9**.22*): The antenna cover is used to enclose
    the wire antenna with the back plate (*B*).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '天线盖 (*C* 在 *图9**.22*): 天线盖用于将带后盖 (*B*) 的线状天线封闭起来。'
- en: 'Front shell (*D* in *Figure 9**.22*): The front shell holds the DHT22 sensor
    and encloses the back plate (*B*) to complete the case.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前壳（*图9.22*中的*D*）：前壳固定DHT22传感器，并封闭后板（*图9.22*中的*B*），以完成外壳。
- en: DHT22 temperature and humidity sensor (*E* in *Figure 9**.22*).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DHT22温度和湿度传感器（*图9.22*中的*E*）。
- en: 'RFM95W LoRa module (*F* in *Figure 9**.22*): The version shown is the 915 MHz
    model.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFM95W LoRa模块（*图9.22*中的*F*）：所示版本是915 MHz型号。
- en: Hook (*G* in *Figure 9**.22*).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接器（*图9.22*中的*G*）。
- en: 2 x M3 10 mm bolts (not shown).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x M3 10 mm螺栓（未显示）。
- en: 4 x M2 5 mm screws (not shown).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x M2 5 mm螺丝（未显示）。
- en: With the parts identified, it is now time to assemble our custom case.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了部件后，现在是时候组装我们的定制外壳了。
- en: Building the custom LoRa case
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建定制的LoRa外壳
- en: 'To build the custom case, we follow the steps shown in *Figure 9**.23* and
    outlined next:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建定制外壳，我们遵循*图9.23*中显示的步骤和以下概述：
- en: '![Figure 9.23 – Steps to build custom case](img/B21282_09_23.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23 – 构建定制外壳的步骤](img/B21282_09_23.jpg)'
- en: Figure 9.23 – Steps to build custom case
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 – 构建定制外壳的步骤
- en: We start by securing the hook (*G* in *Figure 9**.22*) to the back plate (*B*
    in *Figure 9**.22*) using either epoxy glue or two M2 5 mm screws (*Figure 9**.23*,
    *Step 1*).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用环氧胶或两个M2 5 mm螺丝（*图9.23*，步骤1）将连接器（*图9.22*中的*G*）固定在后板（*图9.22*中的*B*）上。
- en: Using the wiring diagrams from *Figures 9.9* and *9.10*, we solder the wires
    from the RFM95W and DHT11 sensors to the Raspberry Pi Pico.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*图9.9*和*图9.10*中的接线图，我们将RFM95W和DHT11传感器的电线焊接到Raspberry Pi Pico上。
- en: Using four M2 5 mm screws, we secure the Raspberry Pi Pico (*A* in *Figure 9**.22*)
    to the back plate (*B* in *Figure 9**.22*) such that the USB port is facing down
    and pointing toward the bottom of the back plate or away from the antenna (*Figure
    9**.23*, *Step 2*).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个M2 5 mm螺丝，我们将Raspberry Pi Pico（*图9.22*中的*A*）固定在后板（*图9.22*中的*B*）上，使得USB端口向下并指向后板底部或远离天线（*图9.23*，步骤2）。
- en: Using a hot glue gun, we secure the DHT22 (*E* in *Figure 9**.22*) to the front
    shell (*D* in *Figure 9**.22*). Alternatively, two M3 5 mm bolts may be used depending
    on the holes present on the DHT22 (*Figure 9**.23*, *Step 3*).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用热胶枪，我们将DHT22（*图9.22*中的*E*）固定在前壳（*图9.22*中的*D*）上。或者，根据DHT22上存在的孔，可以使用两个M3 5
    mm螺栓（*图9.23*，步骤3）。
- en: We friction fit the RFM95W (*F* in *Figure 9**.22*) to the back plate (*B* in
    *Figure 9**.22*) such that the antenna wire sits next to the wire slot on the
    back plate and extends through (*Figure 9**.23*, *Step 3*). If the RFM95W does
    not stay in place, glue from a hot glue gun may be used to secure it in place.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将RFM95W（*图9.22*中的*F*）摩擦固定在后板（*图9.22*中的*B*）上，使得天线线紧挨着后板上的线槽并延伸出来（*图9.23*，步骤3）。如果RFM95W没有固定好，可以使用热胶枪的胶水将其固定在原位。
- en: Using two M3 10 mm, bolts we secure the back plate to the front shell (*Figure
    9**.23*, *Step 4*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个M3 10 mm螺栓，我们将后板固定到前壳上（*图9.23*，步骤4）。
- en: We secure the antenna cover (*C* in *Figure 9**.22*) to the front of the back
    plate using two M2 5 mm screws.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用两个M2 5 mm螺丝将天线盖（*图9.22*中的*C*）固定在后板的前面。
- en: As we used a separate Raspberry Pi Pico WH for writing our coding, we’ll need
    to install CircuitPython, the necessary libraries, and our code onto the new Pico.
    Testing the code with Thonny is advisable to check for any issues that might arise
    during the installation of components into the custom case.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了一个单独的Raspberry Pi Pico WH来编写代码，因此我们需要在新的Pico上安装CircuitPython、必要的库以及我们的代码。建议使用Thonny测试代码，以检查在将组件安装到定制外壳中时可能出现的任何问题。
- en: Now that our LoRa sensory transmitter is ready, we’ll proceed to construct a
    LoRa receiver. This device will be responsible for receiving sensory information
    from the transmitter. We’ll keep the receiver design simple, with its primary
    function being to acknowledge the receipt of LoRa messages. For this purpose,
    an LED will suffice to indicate the status.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了LoRa传感器发射器，我们将继续构建一个LoRa接收器。这个设备将负责从发射器接收传感器信息。我们将保持接收器设计简单，其主要功能是确认接收LoRa消息。为此，一个LED灯足以指示状态。
- en: Building a LoRa receiver
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建LoRa接收器
- en: In *Figure 9**.6*, we see a LoRa receiver processing messages from our LoRa
    sensory transmitter. Our receiver design is straightforward, requiring only an
    LED to acknowledge received messages. We’re utilizing a Raspberry Pi Pico W for
    the receiver as we plan to leverage its Wi-Fi capabilities in the next chapter
    and publish sensory data to the internet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.6中，我们看到LoRa接收器正在处理来自我们的LoRa传感器发射器的消息。我们的接收器设计简单，只需要一个LED来确认接收到的消息。我们正在使用Raspberry
    Pi Pico W作为接收器，因为我们计划在下一章利用其Wi-Fi功能并将传感器数据发布到互联网。
- en: We will not cover the steps to install CircuitPython or the required libraries
    onto the Pico W of the LoRa receiver as we covered these steps already for the
    LoRa sensory transmitter, and we merely need to do the same for the receiver.
    We should use the Pico W version of CircuitPython for this part of the project
    as we will implement Wi-Fi functionality in the next chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍在LoRa接收器的Pico W上安装CircuitPython或所需库的步骤，因为我们已经为LoRa传感器发射器介绍了这些步骤，我们只需为接收器做相同的事情。我们应该使用本项目的Pico
    W版本的CircuitPython，因为我们将在下一章实现Wi-Fi功能。
- en: Also, we won’t detail the construction of the custom case for the LoRa receiver
    as it mirrors the transmitter’s process. The key variation is fitting an LED with
    a resistor and LED holder in place of the DHT22 sensor in the front shell. The
    steps for installing an LED were previously outlined in *Figures 6.22* and *6.23*
    of [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不会详细说明为LoRa接收器构建定制外壳的过程，因为它与发射器的过程类似。关键的区别是在前壳中用带有电阻和LED支架的LED替换DHT22传感器。安装LED的步骤在[*第6章*](B21282_06.xhtml#_idTextAnchor091)的*图6.22*和*图6.23*中已有概述。
- en: In this section, we will focus on the code for the LoRa receiver and highlight
    the results of an outdoor test of both the LoRa sensory transmitter and the LoRa
    receiver.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注LoRa接收器的代码，并突出展示LoRa传感器发射器和LoRa接收器在户外测试的结果。
- en: We will start with a wiring diagram of the LED with a resistor to our Raspberry
    Pi Pico W.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从LED与电阻连接到Raspberry Pi Pico W的布线图开始。
- en: Wiring an LED to the Raspberry Pi Pico W
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LED连接到Raspberry Pi Pico W
- en: 'For our LoRa receiver, we require an LED to use for acknowledging LoRa messages.
    Based on what we have learned so far in this book, we could easily enhance our
    LoRa receiver with a more robust visualization such as an OLED screen. As we aim
    to focus only on acknowledging a LoRa signal, we will stick with a simple LED.
    We may monitor LoRa messages from the Shell in Thonny while running our LoRa receiver
    in that environment:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的LoRa接收器，我们需要一个LED来用于确认LoRa消息。根据我们在本书中到目前为止所学的内容，我们可以轻松地通过添加一个OLED屏幕等更健壮的视觉方式来增强我们的LoRa接收器。由于我们旨在仅关注确认LoRa信号，我们将坚持使用简单的LED。我们可以在运行LoRa接收器的同时，在Thonny的Shell中监控LoRa消息：
- en: '![Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED](img/B21282_09_24.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24 – Raspberry Pi Pico W，220欧姆电阻和LED](img/B21282_09_24.jpg)'
- en: Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – Raspberry Pi Pico W，220欧姆电阻和LED
- en: To connect an LED to our Raspberry Pi Pico W, we solder a 220 Ohm resistor to
    the anode of an LED. We then connect the resistor to the GP5 port on the Pico.
    For ground, we connect the cathode of the LED to any GND pin on the Pico W (*Figure
    9**.24*).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要将LED连接到我们的Raspberry Pi Pico W，我们需要在LED的正极上焊接一个220欧姆的电阻。然后我们将电阻连接到Pico的GP5端口。对于地线，我们将LED的负极连接到Pico
    W上的任何GND引脚（*图9**.24*）。
- en: With the 220 Ohm resistor and LED connected to our Pico W, we then connect an
    RMM95W LoRa module to our Pico W using the steps from the previous section, *Building
    a LoRa* *sensory transmitter*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将220欧姆电阻和LED连接到我们的Pico W后，我们使用上一节中*构建LoRa* *传感器发射器*的步骤将RMM95W LoRa模块连接到我们的Pico
    W。
- en: We are now ready to start writing code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始编写代码。
- en: Creating code to receive LoRa messages
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建接收LoRa消息的代码
- en: Our LoRa receiver code uses the Adafruit `adafruit_rfm9x` library to listen
    for LoRa messages. Upon receipt, it prints the message to the Shell in Thonny
    and flashes the LED twice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LoRa接收器代码使用Adafruit `adafruit_rfm9x`库来监听LoRa消息。在接收到消息后，它将消息打印到Thonny的Shell中，并使LED闪烁两次。
- en: 'To write our LoRa receiver code, we do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的LoRa接收器代码，我们需要做以下几步：
- en: We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use
    our Raspberry Pi or another operating system for this.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Raspberry Pi Pico W连接到USB端口并启动Thonny。我们可以使用Raspberry Pi或其他操作系统来完成这项工作。
- en: We then activate the CircuitPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从屏幕的右下角选择CircuitPython环境，以激活我们的Pico W。
- en: 'In a new tab, we enter the following code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新标签页中，我们输入以下代码：
- en: '[PRE1]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In our code, we do the following:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: 'We start by importing the necessary libraries: `time`, `board`, `busio`, `digitalio`,
    and `adafruit_rfm9x` for LoRa communication.'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入必要的库：`time`、`board`、`busio`、`digitalio`和`adafruit_rfm9x`用于LoRa通信。
- en: We then set up SPI communication by configuring SPI using GPIO pins GP18 (SCK),
    GP19 (MOSI), and GP16 (MISO).
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过配置SPI使用GPIO引脚GP18（SCK）、GP19（MOSI）和GP16（MISO）来设置SPI通信。
- en: We initialize CS and RST pins by setting up GP17 for CS and GP14 for RST.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将GP17设置为CS和GP14设置为RST来初始化CS和RST引脚。
- en: We create an RFM95W LoRa object and initialize the object for 915.0 MHz communication.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个RFM95W LoRa对象，并初始化该对象以进行915.0 MHz的通信。
- en: We initialize an LED on GP5.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在GP5初始化一个LED。
- en: We then print a status message indicating that the device is listening for LoRa
    messages.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们打印一条状态消息，表明设备正在监听LoRa消息。
- en: We define a function to flash the LED so that we may flash the LED a specified
    number of times with a set duration.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个用于闪烁LED的函数，这样我们就可以用设定的持续时间闪烁LED指定次数。
- en: In a continuous loop, we listen for LoRa messages, checking for incoming LoRa
    packets, printing any received message, and flashing the LED twice for 0.5 seconds
    each upon receiving a packet.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个连续的循环中，我们监听LoRa消息，检查传入的LoRa数据包，打印任何接收到的消息，并在接收到数据包时闪烁LED两次，每次0.5秒。
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
    This will open the **Where to save** **to?** dialog.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**。这将打开**保存位置**对话框。
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W, we click on the corresponding button.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对话框中，我们被提供了选择文件存储位置的选择。为了将其保存在我们的Raspberry Pi Pico W上，我们点击相应的按钮。
- en: We then give the file the name `code.py` and click **OK**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将文件命名为`code.py`并点击**确定**。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色运行按钮，在键盘上按*F5*，或者点击顶部的**运行**菜单选项，然后点击**运行** **当前脚本**。
- en: If it is not already running, we power up and run the LoRa sensory transmitter.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有运行，我们打开电源并运行LoRa传感器发射器。
- en: 'In the Shell, we’ll see a notification confirming the receipt of a LoRa message:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Shell中，我们将看到一条通知，确认收到了LoRa消息：
- en: '![Figure 9.25 – Receiving LoRa messages](img/B21282_09_25.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25 – 接收LoRa消息](img/B21282_09_25.jpg)'
- en: Figure 9.25 – Receiving LoRa messages
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – 接收LoRa消息
- en: We should also observe our LED flashes twice.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该观察我们的LED闪烁两次。
- en: With a positive result, we not only confirm that our LoRa receiver is working
    properly but our LoRa sensory transmitter as well. To take full advantage of our
    application, we need to use our transmitter and receiver outside. To do this,
    we should install our LoRa receiver in its own custom case. As mentioned, we follow
    the same steps outlined for the LoRa sensory transmitter substituting the LED
    with a resistor and the LED holder with a DHT22 temperature sensor.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正面结果不仅证实了我们的LoRa接收器工作正常，而且我们的LoRa传感器发射器也是如此。为了充分利用我们的应用程序，我们需要将我们的发射器和接收器放在室外。为此，我们应该将我们的LoRa接收器安装在其自己的定制外壳中。正如提到的，我们遵循为LoRa传感器发射器概述的相同步骤，用电阻代替LED，用DHT22温度传感器代替LED支架。
- en: With both the LoRa sensory transmitter and LoRa, it is time to take our application
    outdoors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在LoRa传感器发射器和LoRa都准备好后，是时候将我们的应用程序带到户外了。
- en: Testing our application
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的应用程序
- en: LoRa communication is known for its ability to cover long distances, a feature
    that sets it apart in the field of wireless communication technologies. While
    typical LoRa transmissions range from a few kilometers in urban settings to over
    10 kilometers in rural areas, the technology has demonstrated far greater potential
    under optimal conditions. A world record was established with a LoRa transmission
    reaching 766 kilometers (476 miles) using just 25 mW of transmission power. This
    record highlights LoRa’s exceptional long-range capabilities, especially when
    conditions are favorable and the setup is optimized for maximum reach.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: LoRa通信以其覆盖长距离的能力而闻名，这是它在无线通信技术领域的独特之处。虽然典型的LoRa传输在城市环境中从几公里到农村地区超过10公里，但在最佳条件下，这项技术已经显示出更大的潜力。使用仅25
    mW的传输功率，一项世界纪录被打破，LoRa传输达到了766公里（476英里）。这一记录突出了LoRa卓越的远程能力，尤其是在条件有利且设置优化以实现最大范围的情况下。
- en: 'In *Figure 9**.26*, we observe the results of testing our application over
    a modest distance of 160 meters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.26*中，我们观察了在160米距离上测试我们应用程序的结果：
- en: '![Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a
    distance of 160 meters](img/B21282_09_26.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图9.26 – 在160米距离上测试我们的LoRa传感器发射器和LoRa接收器](img/B21282_09_26.jpg)'
- en: Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a distance
    of 160 meters
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 – 在160米距离上测试我们的LoRa传感器发射器和LoRa接收器
- en: Alternative testing methods
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 交替的测试方法
- en: We may also test our application by applying heat from a source such as a hair
    dryer, or we may even place our LoRa transmitter in a fridge and observe the results.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过应用吹风机等热源的热量来测试我们的应用程序，或者甚至将我们的LoRa发射器放入冰箱中并观察结果。
- en: This distance, while modest for LoRa, is significant when considering applications
    such as farm monitoring, where sensors can be spread over large areas, far beyond
    the reach of traditional Wi-Fi networks, which are typically constrained to about
    50 meters indoors and less than 100 meters in open spaces.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LoRa来说，这个距离虽然不大，但在考虑诸如农场监控等应用时却具有重要意义，在这些应用中，传感器可以分布在广阔的区域，远远超出传统Wi-Fi网络的覆盖范围，Wi-Fi网络通常在室内约50米，在开阔空间中不到100米。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored LoRa technology, an important component in IoT
    communication. We started by discussing LoRa’s ability to transmit data over long
    distances with low power use, emphasizing its importance in wireless technology.
    We looked at its applications in agriculture, where it improves sensory network
    management for crop management, and in urban settings for smart city initiatives
    such as street lighting control.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了LoRa技术，这是物联网通信的一个重要组成部分。我们首先讨论了LoRa在低功耗下传输数据的能力，强调了它在无线技术中的重要性。我们研究了其在农业中的应用，它改善了作物管理中的传感器网络管理，以及在城市环境中的智能城市倡议，如街道照明控制。
- en: We then examined the technical aspects of LoRa within the radio frequency spectrum.
    This includes understanding how frequencies are allocated for wireless communications,
    which is important for identifying the right frequency bands for LoRa transmissions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查了LoRa在射频频谱中的技术方面。这包括理解频率是如何分配给无线通信的，这对于确定LoRa传输的正确频段非常重要。
- en: For our hands-on sections, we built a LoRa sensory transmitter and LoRa receiver
    using Raspberry Pi Pico and Pico W respectively. This involved constructing a
    transmitter with a LoRa module and temperature sensor and a LoRa receiver using
    a simple LED acknowledgment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的动手部分，我们分别使用Raspberry Pi Pico和Pico W构建了LoRa传感器发射器和LoRa接收器。这包括构建一个带有LoRa模块和温度传感器的发射器，以及使用简单的LED确认的LoRa接收器。
- en: In the next chapter, we will take things further as we connect our LoRa receiver
    to the internet and use this to control a new version of the analog-metered weather
    indicator we created in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨，我们将我们的LoRa接收器连接到互联网，并使用它来控制我们在[*第3章*](B21282_03.xhtml#_idTextAnchor048)中创建的新版本模拟仪表式天气指示器。
