- en: 10 Implementing Common Use Cases with Sanic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用Sanic实现常见用例
- en: We have learned how to use Sanic, and we have learned some good practices and
    habits to get into. Now, let’s go build some fun stuff. When starting to work
    on a new project it is very tempting to start here. Afterall, the idea you have
    in your head about what to build is the implementation, right? You have a final
    idea of what you want (a chat bot for example). So, you sit down and you start
    building the bot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用Sanic，我们也学到了一些良好的实践和习惯。现在，让我们开始构建一些有趣的东西。当你开始一个新的项目时，从这里开始是非常诱人的。毕竟，你头脑中关于要构建的想法就是实现，对吧？你有一个最终的想法（比如聊天机器人）。所以，你坐下来开始构建机器人。
- en: But the reason this chapter is at the end of the book is because you obviously
    cannot start here. Only after gaining the knowledge of HTTP and Sanic, and leveling
    up our technical skills along the way, can we dig into implementation details.
    The goal of this chapter is to look at some practical features that you may be
    tasked to build. With the plubming out of the way, and now that we have a solid
    foundation and understanding of HTTP and Sanic, we can start to build some real-world
    use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但本章放在书的末尾的原因是因为你显然不能从这里开始。只有在你获得了HTTP和Sanic的知识，并在过程中提升我们的技术技能之后，我们才能深入研究实现细节。本章的目标是查看一些你可能需要构建的实际功能。随着管道问题的解决，现在我们已经有了对HTTP和Sanic的稳固基础和理解，我们可以开始构建一些真实世界的用例。
- en: When considering what topics to include in this chapter I thought about what
    are some common use cases that I know Sanic is used for. It makes sense to select
    a handful of implementations that often come up, and then try and build them together.
    This book is obviously a bit space constrained, and so we will not dive into the
    minute details here. Instead, we will look at some implementation details, talk
    about some of the considerations, and describe the general approach you might
    take to the problem. I hope to show you some insight into my own thought process
    when tasked with a project like this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑本章要包含哪些主题时，我想到了一些我知道Sanic被用于的常见用例。选择一些经常出现的实现，然后尝试一起构建是有意义的。显然，这本书的空间有限，所以我们不会深入细节。相反，我们将查看一些实现细节，讨论一些考虑因素，并描述你可能会采取的一般方法来解决这个问题。我希望向你展示我在处理类似这样的项目时的思考过程。
- en: Just like the previous chapter, there will be a lot of code in the repository
    that will not be in the book. It is simply is not all relevant to the conversation,
    but I wanted to make sure that you have full working examples to use as a launching
    pad for your own projects. To receive a complete understanding, you really ought
    to follow along with the source code online while reading this chapter. I will
    point out specific design decisions and include some choice bits that are particularly
    worth mentioning.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章一样，仓库中将有大量代码，但书中并没有。这仅仅是因为它并不都与对话相关，但我想要确保你有完整的工作示例来作为你自己的项目的起点。为了获得完整的理解，你真的应该在线跟随源代码阅读本章。我会指出具体的设计决策，并包括一些特别值得提到的精选片段。
- en: 'So, what are we going to build? The list includes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们将要构建什么？列表包括：
- en: Synchronized websocket feeds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步WebSocket数据流
- en: Progressive web app backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式Web应用后端
- en: GraphQL API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL API
- en: Chat bot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天机器人
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: Since this chapter builds upon the previous chapters, you should have all of
    the technical needs already fulfilled. We will start seeing some additional third-party
    packages in use, so make sure you have `pip` handy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章建立在前面章节的基础上，你应该已经满足了所有的技术需求。我们将开始看到一些额外的第三方包的使用，所以请确保你有`pip`。
- en: 'If you would like to jump ahead to make sure your environment is setup, here
    are the pip packages that we plan to use:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提前跳过以确保你的环境已经设置好，以下是我们将要使用的pip包：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Furthermore, if you recall, back in Chapter 2 we discussed using factory patterns.
    Because we are now starting to build what can become the base of a *real world*
    application, I feel it is much better to use a factory pattern here that can be
    expanded. Therefore, for the remainder of this book you will see more and more
    usage of the factory pattern that we already have established and used.///
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你还记得，在第二章中我们讨论了使用工厂模式。因为我们现在开始构建可能成为*真实世界*应用基础的东西，我觉得在这里使用一个可扩展的工厂模式会更好。因此，在这本书的剩余部分，你将看到越来越多的我们已经建立并使用的工厂模式的用法。
- en: Websocket feeds
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket数据流
- en: Earlier in this book we explored websockets in *Websockets for two-way communication*
    section *Chapter 5* . If you have not read that section yet, I encourage you to
    do that now. At this time, we are going to take our websocket implementation and
    create a horizontally scalable websocket feed. The basic premise of the code here
    will be the same as in that section, which is why you should have an understanding
    of what we build there before moving onto the example here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们在第5章的“Websockets for two-way communication”部分探讨了websockets。如果您还没有阅读该部分，我鼓励您现在去阅读。现在，我们将对我们的websocket实现进行扩展，创建一个水平可扩展的websocket
    feed。这里代码的基本前提将与该部分相同，这就是为什么在继续到这里的示例之前，您应该了解我们在那里构建的内容。
- en: The purpose of the feed we will build is to share events that happen in one
    browser across to another browser. Building upon the example from Chapter 5, we
    are going to add a third-party broker that will allow us to run multiple application
    instances. This means that we can horizontally scale our application. The previous
    implementation suffered from the fact that it stored client information in memory.
    With no mechanism to share state or broadcast messages across multiple application
    instances, there was no way for one websocket connection to guarantee that it
    would be able to push messages to every other client. At best it would only be
    able to push messages to clients that happened to be routed and connected to the
    same application instance. Ultimately, this made it impossible to scale the application
    with multiple workers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的feed的目的是在多个浏览器之间共享发生的事件。基于第5章的示例，我们将添加一个第三方代理，这将使我们能够运行多个应用程序实例。这意味着我们可以水平扩展我们的应用程序。之前的实现存在一个问题，即它在内存中存储客户端信息。由于没有机制在多个应用程序实例之间共享状态或广播消息，因此一个websocket连接无法保证能够将消息推送到每个其他客户端。最多它只能将消息推送到恰好被路由并连接到同一应用程序实例的客户端。最终，这使得无法通过多个工作者扩展应用程序。
- en: The goal now will be to create what is known as a **pubsub**. This is a term
    that means “publish and subscribe” since the pattern relies upon multiple sources
    subscribing to a central broker. When one of those sources publishes a message
    to the broker, all of the other sources that are subscribed receive that message.
    The term pubsub is a simple description of this push and pull between the broker
    and the sources. We will use this concept when building our feed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目标现在将是创建所谓的**pubsub**。这是一个意味着“发布和订阅”的术语，因为该模式依赖于多个源订阅中央代理。当这些源中的任何一个向代理发布消息时，所有已订阅的其他源都会接收到该消息。术语pubsub是对代理和源之间这种推送和拉取的简单描述。我们在构建feed时将使用这个概念。
- en: 'The simplest way to handle pubsub in my opinion is with Redis, which has a
    very simple built-in pubsub mechanism. The idea is simple: every application instance
    will be a source. At startup, the application instance will subscribe to a specific
    channel on the Redis instance. With this connection established, it now has the
    ability to push and pull messages from that Broker on a specific channel By pushing
    this off to a third-party service, all of our applications will be able to access
    the same information through the push and pull of the pubsub.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，处理pubsub的最简单方法是使用Redis，它有一个非常简单的内置pubsub机制。想法很简单：每个应用程序实例都将是一个源。在启动时，应用程序实例将订阅Redis实例上的特定频道。通过建立这种连接，现在它现在具有从该代理在特定频道上推送和拉取消息的能力。通过将此推送到第三方服务，所有我们的应用程序都将能够通过pubsub的推送和拉取访问相同的信息。
- en: In the Chapter 5 websockets example, when a message was received, the server
    would push that message out to other clients that were connected to the same application
    instance. We will still do something similar. Browser clients will open a websocket
    with one of many web servers, which will hold onto that client connection. This
    again will be held in memory. When there is an incoming message from a client
    instance, it will publish that message not by directly distributing it to the
    other clients, but instead it will push the message to the pubsub broker. Then,
    all of the other instances will receive that message since they are subscribed
    to the same broker and can push the message to any websocket clients that happen
    to be connected to that application instance. In this way, we can build a distributed
    websocket feed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章的websockets示例中，当收到消息时，服务器会将该消息推送到连接到同一应用程序实例的其他客户端。我们还将做类似的事情。浏览器客户端将使用多个web服务器之一打开一个websocket连接，该连接将保持与客户端的连接。这同样会被保存在内存中。当客户端实例有传入消息时，它不会直接将消息分发到其他客户端，而是将消息推送到pubsub代理。然后，所有其他实例都会接收到该消息，因为它们都订阅了同一个代理，并且可以将消息推送到任何连接到该应用程序实例的websocket客户端。这样，我们可以构建一个分布式websocket流。
- en: 'To get started, we will spin up a Redis service using `docker-compose`, as
    well as our development application. Take a look in the repository for the details
    on how to accomplish that: ___. We will assume that you have a Redis instance
    available and running.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使用`docker-compose`启动一个Redis服务以及我们的开发应用程序。请查看仓库中的详细信息，了解如何完成此操作：____。我们将假设你有一个可用的Redis实例并且正在运行。
- en: We begin by creating a websocket handler and attaching it to a Blueprint.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个websocket处理程序并将其附加到一个蓝图上。
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the entirety of our Sanic integration on this example. We defined a
    websocket endpoint. The endpoint requires us to access a feed by going to a `channel_name`
    which is meant to be a unique listening location. This could either be a username
    or chatroom stock ticker and so on. The point is that the `channel_name` is meant
    to represent some location in your application where people will want to continuously
    retrieve information from your application as a feed. For example, this also could
    be used to build out a sort of shared editing application where multiple users
    are able to make changes simultaneously to the same resource.The handler in this
    example works by fetching a `Channel` object. If it created a new `Channel`, then
    we send off a `receiver` task to the background that is responsible for listening
    to our pubsub broker. The next thing in the handler is to register our current
    websocket connection on the channel, and then create another `receiver`. The point
    of this second `client.receiver` is to listen to the websocket connection, and
    take incoming messages to push off to the pubsub broker.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们在这个示例中Sanic集成的全部内容。我们定义了一个websocket端点。该端点要求我们通过访问`channel_name`来访问一个源，这个`channel_name`意味着一个唯一的监听位置。这可以是用户名或聊天室股票行情等。重点是`channel_name`意味着代表你应用程序中的一个位置，人们将希望作为源持续从你的应用程序中检索信息。例如，这也可以用来构建一种共享编辑应用程序，其中多个用户可以同时更改同一资源。在这个示例中，处理程序通过获取一个`Channel`对象来工作。如果它创建了一个新的`Channel`，那么我们将向后台发送一个`receiver`任务，该任务负责监听我们的pubsub代理。处理程序中的下一件事是将我们的当前websocket连接注册到通道上，然后创建另一个`receiver`。第二个`client.receiver`的目的就是监听websocket连接，并将传入的消息推送到pubsub代理。
- en: Let’s take a quick look at the `Client` object.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速看一下`Client`对象。
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As just stated, the purpose of this object is to listen to the current websocket
    connection and send messages off to the pubsub broker when there is a message.
    That happens with the `publish` method.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如刚才所说的，这个对象的目的是在有消息时监听当前的websocket连接并将消息发送到pubsub代理。这是通过`publish`方法实现的。
- en: We now will take a look at the `Channel` object. This class is a bit longer
    than the `Client`, so we will look at the code for it in sections. It might be
    helpful to open the GitHub repository to see the class definition in full.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将查看`Channel`对象。这个类比`Client`类要长一些，所以我们将分部分查看其代码。打开GitHub仓库查看完整的类定义可能会有所帮助。
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A channel is created and cached in each application instance in memory. This
    means that for every single application instance where an incoming request asks
    to join a specific channel, there is only one instance of that channel being created.
    Even if we have ten (10) application instances, it does not matter that we have
    ten (10) instances of the channel. What we care about is that on any *single*
    application instance, there is never more than one `Channel` subscribing to a
    single Redis pubsub channel. Having multiple channels on the same application
    instance could get messy and lead to a memory leak. Therefore, we also want to
    add a mechanism to clean up the cache when a channel is no longer needed. We can
    do that like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序实例都会在内存中创建并缓存一个频道。这意味着对于每个请求加入特定频道的传入请求的应用程序实例，只有一个该频道的实例被创建。即使我们有十个（10）应用程序实例，我们也不关心我们是否有十个（10）个频道的实例。我们关心的是在任何单个应用程序实例上，永远不会超过一个`Channel`订阅单个Redis
    pubsub频道。在同一个应用程序实例上有多个频道可能会变得混乱并导致内存泄漏。因此，我们还想添加一个机制，在频道不再需要时清理缓存。我们可以这样做：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason we are using a `Lock` on this is to try and avoid race conditions
    where multiple requests make an attempt to destroy a channel instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`Lock`的原因是试图避免多个请求尝试销毁频道实例的竞态条件。
- en: 'If you recall from above, after the channel is created (or fetched from the
    cache), we register the websocket connection on the Channel instance which looks
    like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上面提到的，在频道创建（或从缓存中检索）之后，我们在Channel实例上注册了websocket连接，看起来像这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We simply create the `Client` object, add it to the known clients that need
    to be notified from this instance on an incoming message, and send off a message
    to let other clients know that someone has just joined. The publish message method
    simply looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地创建`Client`对象，将其添加到需要在此实例上接收消息的已知客户端中，并发送一条消息让其他客户端知道有人刚刚加入。发布消息的方法看起来就像这样：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once a client has been registered, it also needs to have the ability to unregister.
    A method to unregister is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端已注册，它还需要有注销的能力。注销的方法如下：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we remove the current client from the known clients on the `Channel`.
    If there are no longer anymore clients listening to this channel, then we can
    close it and clean up after ourselves.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将当前客户端从`Channel`上的已知客户端中移除。如果不再有客户端监听此频道，那么我们可以关闭它并自行清理。
- en: This is a super simple pattern that provides an immense amount of flexibility.
    In fact, in my course of providing support and helping people with their Sanic
    applications, I have provided assistance in building applications using a similar
    pattern to this on numerous occasions. Using this, you could create some truly
    incredible frontend applications. I know I have. Speaking of which, in our next
    section we are going to start looking at the interplay between Sanic and frontend
    web applications that run in the browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的模式，提供了巨大的灵活性。事实上，在我提供支持和帮助人们使用Sanic应用程序的过程中，我多次提供了使用与此类似模式构建应用程序的帮助。使用这个，你可以创建一些真正令人难以置信的前端应用程序。我知道我做到了。说到这里，在我们接下来的章节中，我们将开始探讨Sanic与在浏览器中运行的前端Web应用程序之间的相互作用。
- en: Powering a progressive web app
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持渐进式Web应用
- en: A lot of use cases for building web APIs are to power a **progressive web application**
    (PWA, also known as a single-page application, or SPA). Like many other web developers
    out there, the real draw to web development was for the purpose of building a
    usable application or website in the browser. Let’s be honest, not many of us
    are out there writing `curl` commands to use our favorite APIs. The real power
    of a web API is when it powers something else.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Web API的许多用例是为了支持**渐进式Web应用**（PWA，也称为单页应用，或SPA）。像许多其他Web开发者一样，真正吸引我从事Web开发的原因是为了在浏览器中构建一个可用的应用程序或网站。让我们说实话，我们中很少有人会编写`curl`命令来使用我们最喜欢的API。Web
    API的真正力量在于它能够支持其他事物。
- en: 'What does a PWA need in order to run? Well, when you build a PWA the final
    product is a bunch of static files. Okay, so we put those files into a directory
    called `./public` and then we serve them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PWA需要什么才能运行？当你构建一个PWA时，最终产品是一堆静态文件。好吧，所以我们将这些文件放入一个名为`./public`的目录中，然后我们提供这些文件：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There you go, we now are running a PWA. We’re finished.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们现在正在运行一个PWA。我们已经完成了。
- en: Well, not so fast. Being able to serve the static content is important, but
    it is also not the only factor you need to consider. Let’s look at some considerations
    when building PWAs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，不是那么快。能够提供静态内容很重要，但这不是你需要考虑的唯一因素。让我们看看构建PWA时需要考虑的一些因素。
- en: Dealing with subdomains and CORS
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理子域名和CORS
- en: In Chapter 7 we spent a significant amount of time looking into CORS from a
    security lens. I would venture a guess that by far the biggest rationale for requiring
    CORS protection is the need to serve content to a PWA. These types of applications
    are ubiquitous on the Internet, and usually have to tackle. The reason this usually
    happens is that often times the frontend of a PWA and the backend are on different
    subdomains. This usually is because they are running on different servers. The
    static content might be served with a CDN, and the backend is on a VPS or PAAS
    offering (see Chapter 8 for more on Sanic deployment options).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们花了很多时间从安全的角度研究CORS。我敢打赌，要求CORS保护的最大理由是需要为PWA提供服务。这类应用在互联网上无处不在，通常需要应对。这种情况通常发生的原因是，PWA的前端和后端通常位于不同的子域名上。这通常是因为它们运行在不同的服务器上。静态内容可能由CDN提供，而后端位于VPS或PAAS提供（有关Sanic部署选项的更多信息，请参阅第8章）。
- en: CORS is a big topic. It is also something easy to get wrong. Luckily, there
    is a simple method for getting this up and running using Sanic Extensions, a package
    that is developed and maintained by the Sanic team to add some extra features
    to Sanic. Sanic Extensions focus on all of the more opinionated and use-case specific
    implementations that are inappropriate for the core project. CORS is one of those
    features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CORS是一个大话题。它也是容易出错的东西。幸运的是，有一个简单的方法可以使用Sanic Extensions来实现这一点，这是一个由Sanic团队开发和维护的包，用于向Sanic添加一些额外功能。Sanic
    Extensions专注于所有更具有意见和特定用例实现的特性，这些特性不适合核心项目。CORS就是其中之一。
- en: So, how do we get going out of the box?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何开始呢？
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: or
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s it. Just install the `sanic-ext` package into your environment and you
    will get CORS protection out of the box. As of version 21.12, if you have the
    `sanic-ext` in your environment, Sanic will auto-instantiate it for you.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。只需将`sanic-ext`包安装到你的环境中，你就可以获得开箱即用的CORS保护。截至版本21.12，如果你环境中已有`sanic-ext`，Sanic将为你自动实例化它。
- en: 'The only thing we need to do now is to configure it. Usually, to get started
    with CORS configuration, we need to set the allowed origins:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一需要做的就是进行配置。通常，要开始进行CORS配置，我们需要设置允许的源：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Well, hang on a minute, you say, “Can’t I just serve the frontend assets from
    Sanic and avoid CORS because the front and back are on the same server?” Yup.
    If that approach works for you, go for it. Let’s see what that might look like
    (from a development perspective).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，等等，你说，“我不能只从Sanic提供前端资源并避免CORS，因为前后端都在同一台服务器上吗？”是的。如果这种方法对你有效，那就去做吧。让我们看看这可能是什么样子（从开发的角度来看）。
- en: Running a development server
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行开发服务器
- en: What happens when you decide that you want both frontend and backend applications
    to run on the same server? Or, when you want to use the `app.static` method shown
    above to serve your project files? Building this locally could be very tricky.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定希望前端和后端应用都在同一台服务器上运行时会发生什么？或者，当你想使用上面显示的`app.static`方法来提供你的项目文件时？在本地构建这可能非常棘手。
- en: The reason this is the case is because when building a frontend application,
    you need a frontend server. Most frameworks have some sort of a build requirement.
    That is to say that you type some code, hit save, then some package like `webpack`
    or `rollup` compiles your JS and serves it to you from a local development web
    server. Your frontend development server might run on port 5555, so you go to
    `http://localhost:5555`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况之所以如此，是因为在构建前端应用时，你需要一个前端服务器。大多数框架都有某种构建要求。也就是说，你输入一些代码，保存后，然后像`webpack`或`rollup`这样的包会编译你的JS，并通过本地开发Web服务器为你提供服务。你的前端开发服务器可能运行在5555端口上，所以你访问`http://localhost:5555`。
- en: But, you want to access your locally running backend from that frontend application
    to populate content. The backend is running on `http://localhost:7777`. Uh oh,
    do you see where this is going? We are right back to CORS all over again. As long
    as your frontend application is being run by a different server than your backend,
    you will continue to run into CORS issues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你希望从前端应用程序访问本地运行的后端以填充内容。后端运行在 `http://localhost:7777`。哎呀，你看到这里的问题了吗？我们又回到了
    CORS 的问题。只要你的前端应用程序是由与后端不同的服务器运行的，你将继续遇到 CORS 问题。
- en: Ultimately, we are trying to get a single server to run both the backend and
    frontend. Since we are talking about local development, we also want auto-reload
    capabilities for both our Python files and our Javascript files. We also need
    to trigger a rebuild of the Javascript, and finally we need to serve this all
    from one location.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们试图让单个服务器同时运行后端和前端。由于我们谈论的是本地开发，我们还想为我们的 Python 文件和 JavaScript 文件提供自动重新加载功能。我们还需要触发
    JavaScript 的重建，最后我们需要从这个位置提供所有服务。
- en: Luckily, Sanic can do all of this for us. Let’s now use Sanic as a local development
    server for a frontend project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Sanic 可以为我们做所有这些。现在让我们使用 Sanic 作为前端项目的本地开发服务器。
- en: 'This will work with any frontend tools you want since we will essentially be
    calling those tools from within Python. My frontend development framework of choice
    is Svelte, but feel free to try this with React, Vue, or any of the other many
    alternatives. I will not walk you through the steps of setting up a frontend project
    since that is not important here. Imagine that you have already done it. If you
    would like to follow along in code, please see the GitHub repository: ___.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于你想要的任何前端工具，因为我们本质上将在 Python 中调用这些工具。我选择的前端开发框架是 Svelte，但你可以随意尝试使用 React、Vue
    或其他许多替代方案。我不会带你设置前端项目的步骤，因为这里并不重要。想象一下你已经完成了。如果你想跟随代码，请参阅 GitHub 仓库：___。
- en: To accomplish our goals, we will setup the Sanic server to add auto-reload capabilities
    to the build directory of the frontend application. For Svelte projects using
    `rollup` (a popular JS build tool), that is a `./public` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们将设置 Sanic 服务器，为前端应用程序的构建目录添加自动重新加载功能。对于使用 `rollup`（一个流行的 JS 构建工具）的
    Svelte 项目，这是一个 `./public` 目录。
- en: 'We start by declaring the location of the static files and serving them with
    `static`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明静态文件的位置，并使用 `static` 来提供服务：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run Sanic, make sure to add that directory to the auto-reloader like
    this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行 Sanic 时，请确保将此目录添加到自动重新加载器中，如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next thing we want to do is define a custom signal. We are going to use
    this later, so all it needs to do now is define it. It just needs to exist so
    that we can later await the event.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来想要做的是定义一个自定义信号。我们将稍后使用它，所以现在它只需要定义它。它只需要存在，这样我们就可以稍后等待事件。
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are now ready to build something that will check the files that were reloaded
    and decide whether or not we need to trigger the `rollup` build process. We will
    look at this in two parts. First, we create a startup listener that checks the
    file extensions to determine the server start was triggered by a reload from any
    `.svelte` or `.js` file extensions.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备构建一个将检查重新加载的文件并决定是否需要触发 `rollup` 构建过程的程序。我们将分两部分来看。首先，我们创建一个启动监听器，该监听器检查文件扩展名以确定服务器启动是由任何
    `.svelte` 或 `.js` 文件扩展名的重新加载触发的。
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As of version 21.12, the files that triggered a reload are stashed in a `SANIC_RELOADED_FILES`
    environment variable. Since any environment variables starting with SANIC_ prefix
    are loaded into our `app.config`, we can simply read that value if it exists and
    check the file extensions.Assuming there is a rebuild required, we next want to
    trigger a subprocess call to our shell to run the build command:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至 21.12 版本，触发重新加载的文件被存储在 `SANIC_RELOADED_FILES` 环境变量中。由于任何以 SANIC_ 前缀开始的任何环境变量都被加载到我们的
    `app.config` 中，因此如果存在，我们可以简单地读取该值并检查文件扩展名。假设需要重建，我们接下来想要触发对我们的 shell 的子进程调用以运行构建命令：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, when this is all done, we are going to dispatch that custom event that
    we created earlier.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，当所有这些都完成时，我们将触发我们之前创建的定制事件。
- en: 'Up until now, we have the auto-reload and auto-rebuilding working as expected.
    The only thing we are missing now is the ability to trigger the web browser to
    refresh the page. This can be accomplished using a tool called `livereload.js`.
    You can access livereload.js by searching for it and installing the Javascript.
    Essentially what it will do is create a websocket connection to a server on port
    35729\. Then from that websocket you can send messages prompting the browser to
    perform a refresh. To do this from Sanic, we are going to run nested applications.
    Add a second application definition:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，自动重新加载和自动重建都按预期工作。我们现在唯一缺少的是触发网页刷新的能力。这可以通过一个名为`livereload.js`的工具来实现。您可以通过搜索并安装JavaScript来访问livereload.js。本质上，它将创建一个到端口35729的服务器的websocket连接。然后，从这个websocket中，您可以发送消息提示浏览器刷新。为了从Sanic中这样做，我们将运行嵌套应用程序。添加第二个应用程序定义：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also will need to declare a few more constants. These are mainly to run
    the two types of messages that livereload needs to send from the server:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要声明几个更多的常量。这些主要是为了运行livereload需要从服务器发送的两种类型的信息：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, setup the necessary listeners to run the nested server:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置必要的监听器以运行嵌套服务器：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `runner` task used in the code above should look like this:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面代码中使用的`runner`任务应该看起来像这样：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is time to add the websocket handler:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候添加websocket处理器了：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the handler accepts an initial message from livereload, and
    then sends a `HELLO` message back. Afterwards we are going to run a loop and wait
    until the custom signal we created is triggered. When it is, we send off the RELOAD
    message, which triggers the browser to refresh the webpage.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理器接受来自livereload的初始消息，然后发送一个`HELLO`消息回。之后，我们将运行一个循环并等待我们创建的自定义信号被触发。当它被触发时，我们发送RELOAD消息，这将触发浏览器刷新网页。
- en: Voila! We now have a full Javascript development environment running inside
    of Sanic. This is a perfect setup for those PWAs where you want to serve the frontend
    and backend content from the same location.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在我们已经在Sanic内部运行了一个完整的JavaScript开发环境。这对于那些希望从同一位置提供前端和后端内容的PWA来说是一个完美的设置。
- en: 'Since we are already talking about frontend content, we will next visit another
    important topic for frontend developers: GraphQL'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在谈论前端内容，接下来我们将探讨前端开发者另一个重要的话题：GraphQL
- en: GraphQL
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: In 2015, Facebook publicly released a project of meant to rival traditional
    web APIs and flip the concept of a RESTful web application on its head. This project
    is what we now know as GraphQL. This book has so far assumed that we are building
    out endpoints using the traditional method of combining HTTP Methods with thoughtful
    paths to point to specific resources. In this approach, web servers are responsible
    for being the interface between a client and the source of data (i.e, a database).
    The concept of GraphQL pushes all of that aside and allows the client to directly
    request what information it wants to receive. There is a single endpoint (usually
    `/graphql`) and a single HTTP Method (usually `POST`). The single route definition
    is meant to be used for both retrieving data and causing state changes in the
    application. This all happens through a set of queries that are sent as the body
    on that single endpoint. GraphQL was meant to revolutionize the way we build the
    web, and to take over as the standard practice of the future. At least, that is
    what many people said was going to happen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年，Facebook公开发布了一个旨在与传统Web API竞争并颠覆RESTful Web应用程序概念的项目。这个项目就是我们今天所知道的GraphQL。这本书到目前为止都假设我们正在使用将HTTP方法与深思熟虑的路径相结合的传统方法来构建端点。在这种方法中，Web服务器负责作为客户端和数据源（即数据库）之间的接口。GraphQL的概念摒弃了所有这些，并允许客户端直接请求它想要接收的信息。有一个单一的端点（通常是`/graphql`）和一个单一的HTTP方法（通常是`POST`）。单一的路线定义旨在用于检索数据和在应用程序中引起状态变化。所有这些都在通过该单一端点发送的查询体中完成。GraphQL旨在彻底改变我们构建Web的方式，并成为未来标准的实践。至少，这是许多人所说的将要发生的事情。
- en: This has not actually come to pass. At the time of this writing, the popularity
    of GraphQL has seemingly peaked and is now on a decline. Nevertheless, I do believe
    that GraphQL fulfills a necessary niche in the web application world, and it will
    continue to live on as an alternative implementation for years to come (just not
    as a replacement). We, therefore, do need to know how to integrate it with Sanic
    for the instances where you may be asked to deploy one of these servers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有发生这种情况。在撰写本文时，GraphQL 的流行似乎已经达到顶峰，现在正在下降。尽管如此，我确实相信 GraphQL 在 Web 应用程序世界中填补了一个必要的空白，并且它将继续作为替代实现存在多年（只是不是作为替代品）。因此，我们确实需要了解如何将其与
    Sanic 集成，以便在需要部署这些服务器的情况下。
- en: 'Before we can answer the question of “why use GraphQL?” we must understand
    what it is. As the name seemingly implies, **GraphQL** is a sort of query language.
    A query is a JSON-like request for information to be delivered in a specific format.
    A client looking to receive information from a web server might send a `POST`
    request with a body that includes a query like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回答“为什么要使用 GraphQL？”这个问题之前，我们必须了解它是什么。正如其名称所暗示的，**GraphQL** 是一种查询语言。查询是一种类似于
    JSON 的请求，用于以特定格式提供信息。一个希望从 Web 服务器接收信息的客户端可能会发送一个包含查询的 `POST` 请求，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In return, a server would go and fetch whatever data it needed and compile
    a return JSON document matching that description:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，服务器将去获取它所需的数据，并编译一个符合该描述的返回 JSON 文档：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you might be able to tell, this becomes a very powerful tool for the client
    as it can bundle what might otherwise be multiple network calls into a single
    operation. It also allows a client (for example a PWA) to specifically retrieve
    the exact data that it needs in the format that it needs it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这成为了一个非常强大的客户端工具，因为它可以将可能需要多个网络调用的信息捆绑成一个单一的操作。它还允许客户端（例如 PWA）以它需要的格式具体检索它所需的数据。
- en: Why would I want to use GraphQL?
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我为什么要使用 GraphQL？
- en: I believe that GraphQL is the best friend of the frontend developer, but the
    bane of existence for the backend developer. It is certainly true that web applications
    using GraphQL will generally issue fewer HTTP calls to web servers than their
    counterparts. It is also certainly true that a frontend developer will have an
    easier time manipulating responses from a web server using GraphQL since they
    get to be the architect of how that data is structured.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 GraphQL 是前端开发者的最佳拍档，但对于后端开发者来说却是噩梦。确实，使用 GraphQL 的 Web 应用程序通常比它们的替代品向 Web
    服务器发出更少的 HTTP 请求。同样确实的是，前端开发者使用 GraphQL 操作来自 Web 服务器获取的响应会更加容易，因为他们可以成为数据结构架构的设计师。
- en: GraphQL provides a very easy method for data retrieval. Because it is a strongly
    typed specification, it makes it possible to have tools that make the whole process
    of generating a query very elegant. For example, many GraphQL implementations
    come with an out-of-the-box web UI that can be used for development. These UIs
    usually include the ability to navigate the schema and see exactly what types
    of queries can be made, and what information is retrievable. See Figure __ for
    an example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 提供了一种非常简单的数据检索方法。因为它是一个强类型规范，这使得可以拥有使生成查询过程非常优雅的工具。例如，许多 GraphQL 实现都附带了一个开箱即用的
    Web UI，可用于开发。这些 UI 通常包括导航模式的能力，可以看到可以执行的所有类型的查询，以及可以检索的信息。见图 __ 中的示例。
- en: INSERT IMAGE
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 插入图片
- en: Figure ___. Example of a GraphQL UI showing the “SCHEMA” tab that displays all
    of the available information
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 ___. 显示“模式”选项卡的 GraphQL UI 示例，该选项卡显示了所有可用的信息
- en: 'There is certainly a fun factor that goes into these tools as you play with
    them to craft exactly the information you want. Simply put: GraphQL is simple
    to use and implement. It also has a very satisfying “coolness” factor to it when
    you start building ad-hoc custom queries.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些工具时，你可以玩得很开心，以构建你想要的确切信息。简单来说：GraphQL 使用简单，易于实现。当你开始构建临时的自定义查询时，它还具有非常令人满意的“酷”感。
- en: 'Except, it is a nightmare in the backend. For all of the simplification from
    the client perspective, the web server now needs to deal with a much greater level
    of complexity. For this reason, when someone tells me that they want to build
    a GraphQL application I usually ask them: why? If they are building it as a public
    facing API, then this may be wonderful. GitHub is a great example of a public-facing
    GraphQL API that is a treat to work in. Querying the GitHub API is simple and
    intuitive. If, however, they are building the API for their own internal purposes,
    then there is a set of tradeoffs that must be considered.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在后台是个噩梦。尽管从客户端的角度来看简化了很多，但现在的网络服务器需要处理更高级别的复杂性。因此，当有人告诉我他们想要构建一个 GraphQL 应用程序时，我通常会问他们：为什么？如果他们是为了构建一个面向公众的
    API，那么这可能是很棒的。GitHub 是一个很好的例子，它提供了一个面向公众的 GraphQL API，使用起来非常愉快。查询 GitHub API 简单直观。然而，如果他们是为了自己的内部用途构建
    API，那么必须考虑一系列权衡。
- en: GraphQL is not in totality any easier or simpler than REST. Instead, it represents
    the shifting of complexity almost entirely to the web server. This may be acceptable,
    but it is a tradeoff that you must consider. I generally find the overall increase
    in complexity of the backend outweighs any benefits of implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 并非在总体上比 REST 更容易或更简单。相反，它几乎将复杂性完全转移到网络服务器上。这可能是可以接受的，但这是一个你必须考虑的权衡。我通常发现后端复杂性的总体增加超过了实施带来的任何好处。
- en: I know it may sound like I am not a fan of GraphQL. This is not true. I do think
    that GraphQL is a great concept, and I think there are some amazing tools out
    there (including in the Python world) to help build these applications. If you
    want to include GraphQL in your Sanic application, I would highly recommend tools
    like `Ariadne` ([https://ariadnegraphql.org/](https://ariadnegraphql.org/)) and
    `Strawberry` ([https://strawberry.rocks/](https://strawberry.rocks/)). Even with
    these tools, a good GraphQL application in my opinion is more difficult to build
    with a few pitfalls waiting to swallow you up. As we look into how we can build
    a Sanic GraphQL application, I will try and point out these issues so that we
    can work around them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来可能像我不喜欢 GraphQL。这并不是真的。我认为 GraphQL 是一个很好的概念，并且我认为有一些非常出色的工具（包括 Python
    世界中的工具）可以帮助构建这些应用程序。如果你想将 GraphQL 包含在你的 Sanic 应用程序中，我强烈推荐使用像 `Ariadne` ([https://ariadnegraphql.org/](https://ariadnegraphql.org/))
    和 `Strawberry` ([https://strawberry.rocks/](https://strawberry.rocks/)) 这样的工具。即使有了这些工具，在我看来，构建一个好的
    GraphQL 应用程序仍然比较困难，而且还有一些陷阱等着吞噬你。当我们探讨如何构建 Sanic GraphQL 应用程序时，我会尝试指出这些问题，以便我们可以绕过它们。
- en: Adding GraphQL to Sanic
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 GraphQL 添加到 Sanic
- en: 'I have built a small GraphQL application for this section. All of the code
    is, of course, on the GitHub repository for this book: ___. I highly suggest you
    have the code available while reading. Quite frankly the code in its entirety
    is much too complex and lengthy to include it all here. So, instead we will talk
    through it in general, and I will refer you back to the repository for specifics.
    For your convenience I have also added a number of comments and further discussion
    points in the code base itself.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这一部分构建了一个小的 GraphQL 应用程序。当然，所有的代码都存放在这本书的 GitHub 仓库中：____。我强烈建议你在阅读时将代码准备好。坦白说，整个代码过于复杂和冗长，无法全部在这里展示。因此，我们将一般性地讨论它，并将具体细节指回仓库。为了方便起见，我在代码库本身中也添加了一些注释和进一步的讨论点。
- en: 'When we discussed database access in Chapter 9 in the section called *To ORM
    or Not to ORM, that is the question*, we talked about whether you should or should
    not implement an ORM. The discussion was about whether you should use a tool to
    help you build the SQL queries or to build them yourself. There are very good
    arguments on both sides: pro-ORM versus anit-ORM. I opted for a somewhat hybrid
    approach to build the SQL queries by hand, and then build a lightweight utility
    to hydrate the data to a usable model.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 9 章的 *To ORM or Not to ORM, that is the question* 节中讨论数据库访问时，我们讨论了是否应该实现
    ORM。讨论的是你是否应该使用工具来帮助你构建 SQL 查询，还是自己构建它们。双方都有非常好的论点：支持 ORM 与反对 ORM。我选择了一种相对混合的方法，手动构建
    SQL 查询，然后构建一个轻量级的实用工具来将数据填充到可用的模型中。
- en: 'A similar question *could* be posed here: should I build it myself or use a
    package? My answer is that you should absolutely use a package. I cannot see any
    reason to try and build a custom implementation yourself. There are several good
    options in Python; my personal preference is Ariadne. I particularly like the
    schema-first approach that the package takes. Using it allows me to define the
    GraphQL parts of my application in `.gql` files, therefore enabling my IDE to
    add syntax highlighting and other language specific conveniences.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里也可以提出一个类似的问题：我应该自己构建还是使用一个包？我的回答是，你应该绝对使用一个包。我看不出有任何理由要尝试自己构建一个自定义实现。Python
    中有几个不错的选择；我个人的偏好是 Ariadne。我特别喜欢这个包采用的 schema-first 方法。使用它允许我在 `.gql` 文件中定义我的应用程序的
    GraphQL 部分，因此使我的 IDE 能够添加语法高亮和其他语言特定便利。
- en: 'Let’s begin:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Since we are using Ariadne in our example here, we begin by installing it into
    our virtual environment:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在示例中使用了 Ariadne，所以我们首先将其安装到我们的虚拟环境中：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To get up and running with Ariadne’s “hello world” application does not take
    much:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动 Ariadne 的“hello world”应用程序并不需要太多：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, there are two endpoints:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有两个端点：
- en: a `GET` that displays the GraphQL query builder
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示 GraphQL 查询构建器的 `GET` 请求
- en: a `POST` that is the ingress to the GraphQL backend
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `POST` 请求，是 GraphQL 后端的入口
- en: From this humble beginning, you can build from Sanic and Ariadne however your
    heart desires. Let’s take a look at a potential strategy you might take.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的起点开始，你可以根据你的心愿构建 Sanic 和 Ariadne。让我们看看你可能采取的一种潜在策略。
- en: Scrapping the above, we begin with an app that looks very similar in structure
    to what we have seen before. Create `./blueprints/graphql/query.py` and place
    your root level GraphQL object.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放弃上述内容，我们开始创建一个结构与我们之前看到的非常相似的程序。创建 `./blueprints/graphql/query.py` 并放置您的根级
    GraphQL 对象。
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we create the two endpoints needed inside of a CBV on our GraphQL Blueprint
    instance:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在我们的 GraphQL 蓝图实例内部创建所需的两个端点：
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, this is nearly identical to the simple version from before.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这几乎与之前的简单版本相同。
- en: On this same Blueprint instance, we are going to place all of our startup logic.
    This keeps it all in a convenient location and allows us to attach it to our application
    instance all at once.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个相同的蓝图实例上，我们将放置所有我们的启动逻辑。这使所有内容都位于一个方便的位置，并允许我们一次性将其附加到我们的应用程序实例上。
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may be wondering, what is an integrator, and what is it all of that code
    doing. This is where I am going to refer you to the repository for the specifics,
    but we will walk through the concept here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，什么是集成器，所有这些代码都在做什么。这就是我将要向您推荐查看特定细节的仓库的地方，但我们将在这里解释这个概念。
- en: In my application example, an `Integrator` is an object that lives inside of
    a domain and is the conduit to setting up a GraphQL schema that Ariadne can use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的应用程序示例中，`Integrator` 是一个存在于领域内的对象，它是设置 Ariadne 可使用的 GraphQL 模式的通道。
- en: 'In the GitHub repository, you will see that the simplest Integrator is for
    the `languages` module. It looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库中，您将看到最简单的集成器是为 `languages` 模块设计的。它看起来像这样：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next to it is a file called `schema.gql`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 旁边有一个名为 `schema.gql` 的文件：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is then the job of the `RootIntegrator` to marshall all of the various domains
    together and generate the schema for Ariadne using both dynamically generated
    schema, and the hardcoded schema like the snippet above.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RootIntegrator` 的任务是整合所有不同的领域，并使用动态生成的模式和如上所示的硬编码模式为 Ariadne 生成模式。
- en: 'We also need to create a place for our GraphQL query to start. A query might
    look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的 GraphQL 查询创建一个起始点。一个查询可能看起来像这样：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A user creates a query and we go and fetch it from the database. The Executor
    here works exactly as it does in the `hikingapp`. Refer back to Chapter ___. Therefore,
    with a query like this, we can now translate the GraphQL query to an object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用户创建一个查询，然后我们从数据库中获取它。这里的 Executor 与 `hikingapp` 中的工作方式完全相同。请参阅第 ___ 章。因此，有了这样的查询，我们现在可以将
    GraphQL 查询转换为对象。
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the power of GraphQL, our response should be this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 GraphQL 的力量，我们的响应应该是这样的：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The way that Ariadne (and other GraphQL implementations) works is that you
    define a strongly typed schema. With the knowledge of that schema, you might end
    up with nested objects. For example, the above `Country` schema might look like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ariadne（以及其他 GraphQL 实现）的工作方式是，你定义一个强类型模式。有了对这个模式的了解，你可能会得到嵌套对象。例如，上面的 `Country`
    模式可能看起来像这样：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Country type has a field called `capital`, which is a `City` type. Since
    this is not a simple scalar value that easily serializes to JSON, we need to tell
    Ariadne how to translate—or resolve—that field. Given the example in GitHub, it
    would be to query our database like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`类型有一个名为`capital`的字段，它是一个`City`类型。由于这不是一个简单可以序列化为JSON的标量值，我们需要告诉Ariadne如何翻译或解析这个字段。根据GitHub中的示例，我们需要像这样查询我们的数据库：'
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is how we can follow the path between different objects. It is then the
    job of Ariadne to piece all of these different queries and resolvers together
    to generate a final object to return. This is the power of GraphQL.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在不同对象之间跟随路径的方法。然后，Ariadne的任务是将所有这些不同的查询和解析器拼凑在一起，生成一个最终要返回的对象。这是GraphQL的力量。
- en: You may have also noticed a flaw. Because every resolver is meant to operate
    independently and to handle the conversion of a single field into a value, you
    can very easily overfetch data from the database. This is especially true if you
    have an array of objects that all resolve to the same database instance. This
    is known as the “n+1” problem. While it is not a unique problem to GraphQL, the
    design of many GraphQL systems make it acutely prone to it. If you ignore this
    problem, while responding to a single request your server might ask the database
    for the same information over and over again even though it should otherwise already
    have it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了一个缺陷。因为每个解析器都旨在独立操作，并将单个字段转换为值，所以你很容易从数据库中检索过量的数据。这尤其在你有一个所有对象都解析到同一数据库实例的数组时更为明显。这被称为“n+1”问题。虽然这不是GraphQL特有的问题，但许多GraphQL系统的设计使其特别容易受到这个问题的影响。如果你忽略这个问题，当响应单个请求时，你的服务器可能会反复从数据库请求相同的信息，尽管它应该已经有了这些信息。
- en: Many applications suffer from this issue. They rely on many more database queries
    than may otherwise be needed. All of this overfetching adds up and reduces the
    performance and efficiency of web applications. While you should certainly be
    aware of this issue and cognizant as you develop any application, I feel it is
    something you must particularly plan for with GraphQL implementations since they
    thrive off of simplified resolvers. Therefore, the biggest piece of advice I can
    provide when building one of these applications is to think about in-memory, request-based
    caching. That is to say that caching objects on a request instance might save
    a ton of SQL queries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序都存在这个问题。它们依赖的数据库查询比实际需要的要多得多。所有这些过度检索累积起来，降低了Web应用程序的性能和效率。虽然你在开发任何应用程序时都应该意识到这个问题，并且要有意识地去处理，但我认为在GraphQL实现中，你必须特别计划这一点，因为GraphQL依赖于简化的解析器。因此，我在构建这类应用程序时能提供的最重要的建议就是考虑基于内存、基于请求的缓存。也就是说，在请求实例上缓存对象可能会节省大量的SQL查询。
- en: 'I encourage you to take some time to review the rest of the code in the GitHub
    repository. There are some helpful patterns that could be usable in a real-world
    application. Since they are not necessarily on-point to Sanic or implementing
    GraphQL in Sanic, we will leave the discussion here for now and turn to another
    popular use case with Sanic: chat bots.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你花些时间审查GitHub仓库中的其余代码。有一些有用的模式可以在实际应用中使用。由于它们不一定与Sanic或Sanic中的GraphQL实现直接相关，我们在这里暂时停止讨论，转而讨论另一个Sanic的流行用例：聊天机器人。
- en: Building a Discord bot (running Sanic in another service)
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个Discord机器人（在另一个服务中运行Sanic）
- en: At some point early in 2021, I was convinced by a few people in the Sanic community
    that we needed to move our primary discussion and community building tool. We
    had a somewhat underutilized chat application and also the community forums that
    were mainly used for longer style support questions. Discord is a more intimate
    conversation than what other options could offer. When it was suggested to me
    that we use Discord, I was a little hesitant to add another application to my
    tool belt. Nevertheless, we went forward with it. If there are Discord fans out
    there reading this book, then you do not need me to explain to you its benefits.
    For everyone else, Discord is a very easy to use and engaging platform that really
    facilitates the types of discussion helpful to our corner of the Internet.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在2021年初的某个时候，我被Sanic社区的一些人说服，我们需要迁移我们的主要讨论和社区建设工具。我们有一个相对未被充分利用的聊天应用程序，还有一个主要用于较长风格支持问题的社区论坛。Discord比其他选项提供的对话更加亲密。当有人建议我使用Discord时，我有点犹豫是否要在我的工具箱中添加另一个应用程序。尽管如此，我们还是继续了。如果这本书的读者中有Discord的粉丝，那么你不需要我向你解释它的好处。对于其他人来说，Discord是一个非常易于使用且引人入胜的平台，它真正促进了对我们这个网络角落有益的讨论。
- en: As I learned more about the platform, the biggest thing that stuck out to me
    was that chat bots are everywhere. There is an incredible underculture I was unaware
    of relating to the building of bots. The vast majority of these bots are built
    using the SDKs, which are open-source projects that wrap much of the client HTTP
    interactions needed to interface with Discord’s API. There are entire ecosystems
    and frameworks built up on top of this to help developers make engaging bots.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我对这个平台了解的越来越多，最让我印象深刻的是聊天机器人无处不在。有一个我之前不知道的、与构建机器人相关的惊人亚文化。这些机器人中的绝大多数都是使用SDKs构建的，这些SDKs是围绕与Discord
    API接口所需的大部分客户端HTTP交互的开放源代码项目。在这个基础上建立起了整个生态系统和框架，以帮助开发者构建引人入胜的机器人。
- en: 'Naturally, one of the next questions that gets asked all the time is: how can
    I integrate Sanic with my bot application? We are going to try and do that.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，人们经常问的下一个问题是：我该如何将Sanic集成到我的机器人应用程序中？我们将尝试做到这一点。
- en: But first, I want to point out that while the example we are going to build
    uses Discord, the principles are in no way connected to running this on Discord.
    The core of what we are about to do is to run some `asyncio` process and reuse
    that loop for running Sanic. This means that you could in fact use this exact
    same technique to run nested Sanic applications. We will see what that looks like
    in the next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我想指出的是，虽然我们将要构建的示例使用的是Discord，但其中的原则与在Discord上运行这一点毫无关联。我们即将要做的是运行一些`asyncio`进程，并重用这个循环来运行Sanic。这意味着你实际上可以使用这种完全相同的技术来运行嵌套的Sanic应用程序。我们将在下一节中看到这会是什么样子。
- en: Building a simple discord bot
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建简单的Discord机器人
- en: I am not an expert with Discord. There is an entire realm of development that
    occurs based upon this platform and I will not pretend to be an authority. Our
    goal here is to integrate a bot application with Sanic. To do this, we are going
    to standup a basic Discord bot using `nextcord`. If you are not familiar with
    `nextcord`, as of the time of the writing of this book, it is an actively maintained
    fork of the abandoned `discord.py` project. If you are also not familiar with
    that, no worries. The simple explanation is that these are frameworks used to
    build a bot application on Discord. Similar to how Sanic provides tools for HTTP
    communications, these frameworks provide tools to communicate with Discord.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是Discord的专家。基于这个平台，有一个完整的开发领域，我并不假装自己是这方面的权威。我们的目标是集成一个与Sanic的机器人应用程序。为此，我们将使用`nextcord`搭建一个基本的Discord机器人。如果你对`nextcord`不熟悉，截至本书编写时，它是对已废弃的`discord.py`项目的活跃维护分支。如果你对那个也不熟悉，不用担心。简单的解释是，这些是用于在Discord上构建机器人应用程序的框架。类似于Sanic提供HTTP通信的工具，这些框架提供了与Discord通信的工具。
- en: 'Let’s take a minute to consider the basic hello world application from their
    documentation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间来考虑一下他们文档中的基本“Hello World”应用程序：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To be honest, this looks not too dissimilar from what we build in Sanic. It
    starts with an application instance. Then, there are decorators that wrap handlers.
    The last thing we see is a `client.run`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这看起来与我们构建的Sanic并没有太大的不同。它从应用程序实例开始。然后，有装饰器包装处理程序。最后我们看到的是`client.run`。
- en: 'This is the key to what we want to build. This `run` method is going to create
    a loop and run it until the application is shutdown. Our job now is to run Sanic
    inside of this application. This means we will *not* be using the Sanic cli to
    standup our application. Instead, we will run the application using:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要构建的关键。这个`run`方法将创建一个循环，并在应用程序关闭之前运行它。我们现在的任务是运行Sanic在这个应用程序内部。这意味着我们**不会**使用Sanic
    cli来启动我们的应用程序。相反，我们将使用以下方式运行应用程序：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s get started.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'Start by copying the minimal bot example from their documentation into `bot.py`.
    You can grab the code here: [https://nextcord.readthedocs.io/en/latest/quickstart.html](https://nextcord.readthedocs.io/en/latest/quickstart.html)'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从他们的文档中复制最小的机器人示例到`bot.py`。你可以在这里获取代码：[https://nextcord.readthedocs.io/en/latest/quickstart.html](https://nextcord.readthedocs.io/en/latest/quickstart.html)
- en: Create a simple Sanic application as a proof of concept.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的Sanic应用程序作为概念验证。
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Nothing fancy is happening so far. We have a single handler that will send off
    a message in a listener before the server starts. And, we also have a single handler
    that will also trigger a message to our Discord server when the route endpoint
    is hit.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前还没有什么特别的事情发生。我们有一个单独的处理程序，在服务器启动之前在监听器中发送消息。此外，我们还有一个单独的处理程序，当路由端点被击中时，也会触发向我们的Discord服务器发送消息。
- en: To integrate this with the Discord bot, we will use the `on_ready` event to
    run our sanic server.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将此与Discord机器人集成，我们将使用`on_ready`事件来运行我们的Sanic服务器。
- en: '[PRE39]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**IMPORTANT NOTICE**'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要通知**'
- en: ''
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the sake of simplicity, I am just importing from server import app. That
    is because it is a super simple implementation. In actuality, if I were building
    a proper application, I would **NOT** use this pattern. Instead, I would use the
    factory pattern discussed repeatedly throughout this book and build my application
    from a callable. This is to help with import management and to avoid passing global
    scope variables.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了简化，我只是从`server`导入`app`。这是因为这是一个超级简单的实现。实际上，如果我要构建一个合适的应用程序，我**不会**使用这种模式。相反，我会使用本书中反复讨论的工厂模式，并从可调用对象构建我的应用程序。这是为了帮助导入管理和避免传递全局作用域变量。
- en: A few things are happening here that we need to discuss. First, as mentioned,
    this is the syntax used to tell `nextcord` to run this handler when the application
    starts up and is connected to Discord, and therefore “ready.” But, according to
    their documentation, this event could be triggered multiple times. That would
    be a mistake to try and run Sanic multiple times since it would fail to properly
    bind to a socket.To avoid this, we look at the `app.is_running` flag to determine
    if we should run this again.What happens next is that we are going to manually
    create a Sanic server. After that–and this part is critical—we pass that app server
    instance into a *NEW* task. Why? Because if we ran Sanic from the current task
    it would block indefinitely, and the Discord bot would never actually run. Since
    we want them both to run concurrently, it is imperative that we run Sanic from
    another `asyncio` task.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里发生了一些我们需要讨论的事情。首先，如前所述，这是告诉`nextcord`在应用程序启动并连接到Discord且因此“就绪”时运行此处理器的语法。但是，根据他们的文档，此事件可能会被触发多次。尝试多次运行Sanic将是一个错误，因为它将无法正确绑定到套接字。为了避免这种情况，我们查看`app.is_running`标志以确定是否应该再次运行它。接下来会发生的事情是，我们将手动创建一个Sanic服务器。之后——这部分非常重要——我们将该应用程序服务器实例传递给一个**新**的任务。为什么？因为如果我们从这个当前任务运行Sanic，它将无限期地阻塞，Discord机器人永远不会真正运行。由于我们希望它们同时运行，因此从另一个`asyncio`任务运行Sanic是至关重要的。
- en: Next, we need to create that `runner` operation. The job here is to run the
    created server. This means that we need to manually trigger all of the listener
    events. It also means that we need to perform some shutdown of connections. Because
    we are operating at a MUCH lower level than normal, you will be required to be
    more hands on.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建那个`runner`操作。这里的任务是运行创建的服务器。这意味着我们需要手动触发所有监听事件。这也意味着我们需要执行一些连接关闭操作。因为我们操作的水平比正常情况低得多，所以你需要更加亲自动手。
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The job here looks simple. It starts the application, runs some listener events
    and then will listen forever until the application shuts down. Before completely
    exiting, we need to run some cleanup operations inside the finally block.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的工作看起来很简单。它启动应用程序，运行一些监听事件，然后将持续监听，直到应用程序关闭。在完全退出之前，我们需要在`finally`块中运行一些清理操作。
- en: Once you have all of this implemented, you can run it as we said before by executing
    the bot.py script. You should now see this message in your Discord server that
    was triggered by Sanic during the application startup lifecycle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您实现了所有这些，您就可以像我们之前所说的那样通过执行bot.py脚本来运行它。现在，您应该会在启动应用程序生命周期期间由Sanic触发的Discord服务器上看到这条消息。
- en: <<<< IMAGE >>>>>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <<<< 图片 >>>>>
- en: 'Next, you should be able to hit your single endpoint and see another message:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该能够点击您的单个端点并看到另一条消息：
- en: <<<< IMAGE >>>>>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <<<< 图片 >>>>>
- en: Because we are not using the standard method for running Sanic, I do not like
    to recommend this approach. For starters, it is easy to mess up the order of calls
    and either leave out some critical events, or improperly handle things like shutdown.
    Admittedly the shutdown mechanism above is incomplete. For starters, it does not
    include any sort of handling for the graceful shutdown of existing connections.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是使用运行Sanic的标准方法，我不太推荐这种方法。首先，很容易搞错调用顺序，要么遗漏一些关键事件，要么不恰当地处理像关闭这样的操作。诚然，上面的关闭机制是不完整的。首先，它不包括对现有连接的优雅关闭处理。
- en: 'This leads to the next question: instead of running Sanic inside the Discord
    bot, can we run the bot inside Sanic? Yes. That is what we will do next.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了下一个问题：我们是否可以在Sanic内部运行Discord机器人，而不是在Discord机器人内部运行Sanic？是的，这正是我们接下来要做的。
- en: Running the Discord bot from Sanic
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Sanic中运行Discord机器人
- en: Before we get started, let’s consider what `client.run` is doing. It does whatever
    internal instantiation is needed to run its service, including making a connection
    to the Discord server. Then, it enters into a loop to asynchronously receive and
    send messages to the Discord server. This sounds very similar to what Sanic server
    does. And, therefore, we can do the exact same thing that we just did, except
    in reverse.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们考虑一下`client.run`正在做什么。它执行运行其服务所需的任何内部实例化，包括连接到Discord服务器。然后，它进入一个循环，异步接收和发送消息到Discord服务器。这听起来非常类似于Sanic服务器所做的事情。因此，我们可以做与我们刚才所做完全相同的事情，只是顺序相反。
- en: Take the code we just built and remove the `on_ready` event from the bot.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取出我们刚刚构建的代码，并从机器人中移除`on_ready`事件。
- en: Add a startup time listener that starts the bot in a new background task.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个启动时间监听器，在新的后台任务中启动机器人。
- en: '[PRE41]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this listener, we are also doing the same thing we did in the previous example.
    We setup `app.ctx.wadsworth` and `app.ctx.general` so that they are easily accessible
    for use later on in the build. Also, we want to send a message when Wadsworth
    is online and ready to work. Yes, we could do this from the bot using `on_ready`
    as before, but we can also do this from Sanic. In the above code, we create a
    loop to check for the state of the bot. Once it is ready, we will send the message
    and close out the loop.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个监听器中，我们也在做与上一个示例中相同的事情。我们设置了`app.ctx.wadsworth`和`app.ctx.general`，以便它们在构建过程中易于访问和使用。此外，我们希望在Wadsworth上线并准备好工作的时候发送一条消息。是的，我们可以像之前一样使用`on_ready`从机器人中完成这个操作，但我们也可以从Sanic中完成这个操作。在上面的代码中，我们创建了一个循环来检查机器人的状态。一旦它准备好了，我们将发送消息并关闭循环。
- en: The next thing we need to make sure to do is to properly close the bot connection.
    We will do that in a shutdown listener.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来需要确保正确关闭机器人连接。我们将在关闭监听器中完成这个操作。
- en: '[PRE42]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, you have full capability to run your bot from Sanic. This should behave
    exactly as before, but you have the full power of running your application with
    the Sanic CLI as we have throughout the rest of this book. Go ahead and fire it
    up now:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经具备了从Sanic运行机器人的全部能力。这应该表现得与之前完全一样，但您现在可以使用Sanic CLI运行应用程序的全部功能，正如我们在本书的其余部分所做的那样。现在就启动它吧：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This pattern of nesting other `asyncio` applications has broader applicability
    than just running Discord bots and Sanic together. It also allows us to run multiple
    Sanic applications in the same process, albeit on different ports. This is what
    we are going to do next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套其他`asyncio`应用程序的模式不仅适用于同时运行Discord机器人和Sanic，其适用范围更广。它还允许我们在同一进程中运行多个Sanic应用程序，尽管它们在不同的端口上。这正是我们接下来要做的。
- en: 'Nested Sanic applications: running Sanic inside Sanic to create a HTTP proxy'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套Sanic应用程序：在Sanic内部运行Sanic以创建HTTP代理
- en: Running Sanic from within Sanic seems a bit like those Russian nesting dolls.
    While it may initially seem like an amazing thought experiment, it does have some
    real-world applicability. The most obvious example of running two instances of
    Sanic together like this would be to create your own HTTP to HTTPS proxy. That
    is what we are going to do now. Or, at least sort of.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanic 内运行 Sanic 似乎有点像俄罗斯套娃。虽然这最初可能看起来像是一个惊人的思想实验，但它确实有一些实际应用。这种运行两个 Sanic
    实例的最明显例子是创建你自己的 HTTP 到 HTTPS 代理。这正是我们现在要做的。或者，至少是某种程度上的。
- en: The caveat that I want to add to this is that this example will use a **self-signed
    certificate**. That means that it is not suitable for production use. You should
    look at the section called ___ in Chapter 7 for details on how to properly secure
    your application using TLS.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我想添加的一个注意事项是，这个示例将使用 **自签名证书**。这意味着它不适合生产使用。你应该查看第 7 章中名为 ___ 的部分，以了解如何使用 TLS
    正确保护你的应用程序的详细信息。
- en: To begin, we will create two servers. For the sake of simplicity, one will be
    server.py (your main application running HTTPS over port 443) and the other will
    be redirect.py (the HTTP to HTTPS proxy running on port 80).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个服务器。为了简单起见，一个将是 server.py（你的主要应用程序在 443 端口上运行 HTTPS），另一个将是 redirect.py（在
    80 端口上运行的 HTTP 到 HTTPS 代理）。
- en: We will start by creating our self-signed certificate. If you are on a Windows
    machine, you might need to lookup how to do this on your OS.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的自签名证书。如果你在 Windows 机器上，你可能需要查找如何在你的操作系统上完成这个操作。
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, we start building our Sanic application in server.py with a simple factory
    pattern. The code for this build is available at ___.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 server.py 中使用简单的工厂模式开始构建我们的 Sanic 应用程序。这个构建的代码可以在 ___ 找到。
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**TIP**'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first thing that I would like to point out is the usage of `SERVER_NAME`.
    This is a configuration value that is unset out of the box in Sanic. It is usually
    something that you should use in all of your applications. It is a helpful value
    used by Sanic behind the scenes in a few locations. For our purpose in this example,
    we want to use it to help us generate URLs further down the road with app.url_for.
    The value should be the domain name of your application, plus the port (if it
    is not using a standard 80 or 443). You should not include the http:// or https://.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我首先想指出的是 `SERVER_NAME` 的使用。这是一个在 Sanic 中默认未设置的配置值。这通常是你应该在所有应用程序中使用的东西。这是一个在
    Sanic 背景中在几个位置使用的有用值。在我们的示例中，我们想使用它来帮助我们使用 app.url_for 生成稍后路线的 URL。该值应该是你的应用程序的域名，加上端口（如果它不是使用标准
    80 或 443）。你不应该包括 http:// 或 https://。
- en: What is `attach_redirect_app`? This is another application factory. But it will
    work a little bit differently since it will also act to nest the resitect app
    inside of the `MainApp`.The last thing worth pointing out is that there is the
    Blueprint Group bp that we will attach all of our Blueprints to. Except, the `info_view`
    will be separate. More on that in just a bit.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`attach_redirect_app` 是什么？这是一个另一个应用程序工厂。但它的运作方式会有所不同，因为它还将负责将 resitect 应用程序嵌套在
    `MainApp` 内。最后一点值得指出的是，有一个 Blueprint Group bp，我们将把所有的 Blueprints 都附加到它上面。不过，`info_view`
    将是独立的。更多细节稍后揭晓。'
- en: 'We begin the second factory pattern: `attach_redirect_app` at `redirect.py`.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始第二个工厂模式：`attach_redirect_app` 在 `redirect.py`。
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are attaching two views: the same `info_view` that we just attached to the
    `MainApp`, and the `redirect_view` that will do our redirection logic. We will
    look at that once we are done with the factory and server here in `redirect.py`.Also,
    please notice that we are attaching the `main_app` to the `redirect_app.ctx` for
    later retrieval. As we have learned, passing objects through the ctx is the preferred
    method for handling objects that need to be referenced throughout an application.'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将附加两个视图：我们刚刚附加到 `MainApp` 的相同 `info_view`，以及将执行重定向逻辑的 `redirect_view`。我们将在完成这里的工厂和
    `redirect.py` 中的服务器后查看它。此外，请注意，我们将 `main_app` 附加到 `redirect_app.ctx` 以便稍后检索。正如我们所学的，通过
    ctx 传递对象是处理需要在应用程序中引用的对象的首选方法。
- en: Next we will add a few listeners to the `MainApp`. This is going to happen inside
    of the `attach_redirect_app` factory. There are some software architects that
    may dislike my nesting of logical concerns together, we are going to silence the
    critics and do it anyway because what we are after is necessarily tightly couple
    logic that will be easy for us to debug and update in the future.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `MainApp` 添加一些监听器。这将在 `attach_redirect_app` 工厂内部发生。有些软件架构师可能不喜欢我将逻辑关注点嵌套在一起，但我们将忽略批评者并继续这样做，因为我们追求的是必须紧密耦合的逻辑，这将使我们未来更容易调试和更新。
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here we are dropping down into some lower level operations of the Sanic server.
    We basically need to mimic what the Sanic CLI and app.run do, except inside the
    confines of the already existing loop.When you run a Sanic server instance, it
    will block the process until shutdown. But we need to have two servers running.
    Therefore, the `RedirectApp` server needs to be run in a background task. We accomplish
    that by pushing off the work of running the server by using add_task. We will
    come back to runner when we are done with the factory.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们深入到 Sanic 服务器的较低级别操作。我们基本上需要模仿 Sanic CLI 和 app.run 所做的操作，但要在现有循环的范围内进行。当你运行一个
    Sanic 服务器实例时，它将阻塞进程直到关闭。但我们需要运行两个服务器。因此，`RedirectApp` 服务器需要作为一个后台任务运行。我们通过使用 add_task
    推迟运行服务器的工作来实现这一点。我们将在完成工厂后回到 runner。
- en: The `RedirectApp` also needs to be turned down. Therefore, we attach to the
    MainApp another listener to do that.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RedirectApp` 也需要关闭。因此，我们向 MainApp 添加另一个监听器来完成这项工作。'
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, what we are accomplishing are some of the high level steps that Sanic
    takes under the hood to stand up a server. It does run `before_start` slightly
    out of order. Typically, that would happen before `create_server`. The impact
    is minimal. Since our `RedirectApp` does not even use any of the even listeners,
    we could do without `before_start` and `after_start` (and the shutdown events
    too).
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，我们正在完成 Sanic 在幕后启动服务器的一些高级步骤。它确实在 `create_server` 之前运行 `before_start`。影响很小。由于我们的
    `RedirectApp` 甚至没有使用任何事件监听器，我们可以没有 `before_start` 和 `after_start`（以及关闭事件）。
- en: 'Now to the important part of the application: the redirection view.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到应用程序的重要部分：重定向视图。
- en: '[PRE49]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This route is going to be fairly all-encompassing. It basically will accept
    every endpoint that remains unmatched, not matter what HTTP method is used. This
    is accomplished using the path parameter type and passing the `HTTP_METHODS` constant
    to the route definition.The job is to redirect the exact same request to the https
    version. You could do this a few ways. For example, the following works:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此路由将非常全面。它基本上将接受所有未匹配的端点，无论使用什么 HTTP 方法。这是通过使用路径参数类型并将 `HTTP_METHODS` 常量传递给路由定义来实现的。任务是重定向到
    https 版本的精确相同的请求。你可以这样做几种方式。例如，以下方法有效：
- en: '[PRE50]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, for me and my brain, I like to use `url_for`. If you prefer the alternative:
    you do you. The redirect function is a convenience method for generating the appropriate
    redirection response. Since our use case calls for a redirection from http to
    https, we use a 301 redirect to indicate that this is a permanent (and not temporary)
    redirection. Let’s see it in action.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，对我来说和我的大脑，我喜欢使用 `url_for`。如果你更喜欢替代方案：你做你的。重定向函数是一个方便的方法，用于生成适当的重定向响应。由于我们的用例需要从
    http 重定向到 https，我们使用 301 重定向来表示这是一个永久（而不是临时）的重定向。让我们看看它是如何工作的。
- en: To run our application, we need to use the TLS certificates that we generated.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的应用程序，我们需要使用我们生成的 TLS 证书。
- en: '[PRE51]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We are running the application again using the CLI. Make sure to use `--factory`
    since we are passing it a callable. Also, we are telling Sanic where it can find
    the certificate and key that were generated for the TLS encryption.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次使用 CLI 运行应用程序。请确保使用 `--factory`，因为我们正在传递一个可调用对象。同时，我们告诉 Sanic 它可以在哪里找到为
    TLS 加密生成的证书和密钥。
- en: 'Once that is running, we jump into a terminal to test with `curl`. First we
    will make sure that both applications are accessible:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行起来，我们将进入终端使用 `curl` 进行测试。首先，我们将确保两个应用程序都是可访问的：
- en: '[PRE52]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This also looks right. Please note that I included `-k` in the curl command.
    This is because of the self-signed certificate we created. Since it is not from
    an official trusted Certificate Authority, `curl` will not automatically issue
    the request until you specifically tell it that the certificate is okay.Something
    that is really interesting about this is that the `/info` endpoint is *NOT* defined
    twice. If you look in the source code, you will see that it is a single blueprint
    that has been applied to both applications. Super handy.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来也是正确的。请注意，我在curl命令中包含了`-k`。这是因为我们创建的自签名证书。由于它不是来自官方受信任的证书颁发机构，`curl`将不会自动发出请求，直到你明确告诉它证书是好的。关于这一点，真正有趣的是`/info`端点**并没有**被定义两次。如果你查看源代码，你会看到它是一个蓝图，已经应用于两个应用程序。非常方便。
- en: 'And now we come to the final test: the redirection.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来到了最后的测试：重定向。
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Make sure to notice that we are hitting the 8080 port, which is the `RedirectApp`.
    We again use `-k` to tell curl to not worry about certificate validation. We also
    use `-L` to tell `curl` to follow forward any redirections. Lastly, we add `-i`
    to output the full HTTP responses so that we can see what is going on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保注意我们正在访问8080端口，这是`RedirectApp`。我们再次使用`-k`来告诉curl不要担心证书验证。我们还使用`-L`来告诉`curl`跟随任何重定向。最后，我们添加`-i`来输出完整的HTTP响应，这样我们就可以看到发生了什么。
- en: As you can see from the above response, we generated an appropriate 301 redirection
    and sent the user on to the https version, which greeted me so nicely by first
    name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上面的响应中可以看到，我们生成了一个适当的301重定向，并将用户引导到了https版本，它用我的名字亲切地问候了我。
- en: 'And that’s it: a simple HTTP to HTTPS redirection application running Sanic
    inside Sanic.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：一个简单的HTTP到HTTPS重定向应用程序，在Sanic内部运行Sanic。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: What I love about building web applications is the chance to build solutions
    to problems. For example, earlier in this chapter we had the problem of wanting
    to run a Javascript development server from Sanic. If you put five different developers
    on that problem, you might end up with five different solutions. I believe that
    building web applications is on some level an art form. That is to say that it
    is not a strict field that must be solved in only one *obvious* way. Rather, what
    is obvious can only be determined given the unique circumstances and parameters
    surrounding your build.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢构建Web应用程序的机会，可以构建解决问题的方案。例如，在本章的早期，我们遇到了从Sanic运行JavaScript开发服务器的问题。如果你让五位不同的开发者来解决这个问题，你可能会得到五种不同的解决方案。我相信，在某种程度上，构建Web应用程序是一种艺术形式。也就是说，它不是一个必须以唯一一种*明显*的方式解决的问题的严格领域。相反，什么是明显的，只能根据你构建的独特环境和参数来确定。
- en: Of course, what we have built here is just the tip of the iceberg for what is
    possible with Sanic. The choices displayed are both some popular use cases, and
    also some use cases that might not be so straightforward. I hope that you can
    take some of the ideas and patterns and put them to good use. By reading this
    book and internalizing the examples in this Chapter, I hope that I have helped
    to stimulate the creative ideas of application building for you.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在这里构建的只是Sanic可能性的冰山一角。显示的选择既有一些流行的用例，也有一些可能不太直接的用例。我希望你能从中汲取一些想法和模式，并加以有效利用。通过阅读这本书并内化本章中的示例，我希望我已经帮助激发了你在构建应用程序方面的创造性思维。
- en: If we mash up all of the ideas from this chapter into a single application,
    you would end up with a PWA powered by Sanic using distributed websocket feeds
    and a GraphQL API, that also runs a Discord bot. My point is that creating features
    to implement in your application cannot be done in a vacuum. You must consider
    other parts of your architecture when deciding on how to build something. This
    chapter is meant to help see some of my thought process when I tackled these problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将本章的所有想法整合成一个单一的应用程序，你将得到一个由Sanic驱动的PWA，使用分布式WebSocket流和GraphQL API，同时还运行一个Discord机器人。我的观点是，在应用程序中实现功能不能在真空中完成。在决定如何构建某物时，你必须考虑你的架构的其他部分。本章旨在帮助您了解我在解决这些问题时的思考过程。
- en: 'As we near the conclusion of this book, the last things we need to do is actually
    pull together a lot of what we know into a single deployable application. That
    is what we do next in Chapter 11: build a fully functional, production grade Sanic
    application.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近本书的结尾，我们最后需要做的是将我们所知的大量内容整合成一个可部署的应用程序。这就是我们在第11章要做的：构建一个完全功能、适用于生产的Sanic应用程序。
