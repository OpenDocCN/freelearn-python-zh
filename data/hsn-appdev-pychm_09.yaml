- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating a RESTful API with FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 创建 RESTful API
- en: In the last chapter, we learned about a framework called Flask. Flask represents
    Python in a landscape of traditional web development frameworks designed to generate
    content on the server and send it back to the browser. This is how we have developed
    web applications for decades. The 2010s brought a paradigm shift, but it didn’t
    happen overnight.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了一个名为 Flask 的框架。Flask 在一个传统的网络开发框架领域中代表了 Python，这些框架旨在服务器上生成内容并将其发送回浏览器。这就是我们几十年来开发网络应用的方式。2010
    年代带来了一个范式转变，但这并不是一夜之间发生的。
- en: 'In 2004, the term **AJAX**, an acronym for **Asynchronous JavaScript and XML**,
    was coined by Jesse James Garrett in an article titled *Ajax: A New Approach to
    Web Applications*. This article helped popularize the concept and techniques of
    asynchronous web applications. By 2005, mainstream browsers all supported a new
    **XMLHttpRequest** (**XHR**) web API call. The feature allowed a developer to
    request pure data instead of a generated HTML page with the data integrated with
    markup.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '2004 年，术语 **AJAX**（异步 JavaScript 和 XML 的缩写），由 Jesse James Garrett 在一篇题为 *Ajax:
    A New Approach to Web Applications* 的文章中提出。这篇文章帮助推广了异步网络应用的概念和技术。到 2005 年，主流浏览器都支持了一个新的
    **XMLHttpRequest**（XHR）网络 API 调用。这个特性允许开发者请求纯数据，而不是与标记结合生成的 HTML 页面。'
- en: The rise of **single-page applications** (**SPAs**) in the 2010s was closely
    associated with the advancement of JavaScript frameworks such as AngularJS (now
    Angular), React, and Vue.js. These provided developers with the tools and capabilities
    to build dynamic, interactive web applications differently from traditional applications,
    which make requests for HTML and data at the same time. SPAs load all their markup,
    CSS, and JavaScript in a single request. After that, the app uses XHR to request
    data, and in response to the data received and the user’s interactions, the developer
    used JavaScript to show and hide different elements in the user experience rather
    than re-rendering the entire page each time there was a change in data or a user
    interaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2010 年代单页应用（SPAs）的兴起与 JavaScript 框架（如 AngularJS（现在为 Angular）、React 和 Vue.js）的进步密切相关。这些框架为开发者提供了构建动态、交互式网络应用的工具和能力，这些应用与传统应用不同，它们同时请求
    HTML 和数据。SPAs 在一个请求中加载所有标记、CSS 和 JavaScript。之后，应用使用 XHR 请求数据，在接收到数据和用户交互的响应后，开发者使用
    JavaScript 显示和隐藏用户体验中的不同元素，而不是每次数据或用户交互发生变化时都重新渲染整个页面。
- en: '**AngularJS**, released by Google in 2010, played a significant role in popularizing
    the concept of SPAs. It introduced a declarative approach to building web applications,
    allowing developers to create rich, responsive user interfaces without the need
    for full-page reloads. AngularJS provided a solid foundation for building SPAs,
    and its success inspired the development of other JavaScript frameworks that further
    refined and improved the SPA development experience.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Google 于 2010 年发布的 **AngularJS**，在推广 SPAs 概念方面发挥了重要作用。它引入了一种声明式的方法来构建网络应用，允许开发者创建丰富的、响应式的用户界面，而无需进行完整的页面刷新。AngularJS
    为构建 SPAs 提供了一个坚实的基础，其成功也激发了其他 JavaScript 框架的开发，这些框架进一步精炼和改善了 SPAs 的开发体验。
- en: '**React**, developed by Facebook and released in 2013, also contributed to
    the popularity of SPAs. React introduced a component-based architecture that made
    it easier to manage the state and UI components of an application. React’s virtual
    **DOM** (**Document Object Model**) diffing algorithm and efficient rendering
    mechanism made it well suited for building fast and scalable SPAs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Facebook 开发并于 2013 年发布的 **React**，也促进了 SPAs 的普及。React 引入了一种基于组件的架构，这使得管理应用程序的状态和
    UI 组件变得更加容易。React 的虚拟 **DOM**（文档对象模型）diff 算法和高效的渲染机制使其非常适合构建快速可扩展的 SPAs。
- en: '**Vue.js**, created by Evan You and released in 2014, gained popularity as
    a lightweight and approachable framework for building SPAs. It offered a gentle
    learning curve and provided a flexible and intuitive way to build user interfaces.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Evan You 创建并于 2014 年发布的 **Vue.js**，因其轻量级和易于接近的特性而成为构建单页应用（SPAs）的流行框架。它提供了一个温和的学习曲线，并提供了灵活直观的方式来构建用户界面。
- en: Overall, the combination of these JavaScript frameworks, along with advancements
    in browser technologies and APIs, led to the rise of SPAs in the early 2010s onward.
    SPAs today continue to provide a more seamless and responsive user experience
    by dynamically updating content on a single web page, eliminating the need for
    full page reloads, and providing a more app-like feel to web applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些JavaScript框架的组合，加上浏览器技术和API的进步，导致了从2010年代初开始单页应用（SPAs）的兴起。如今，SPAs通过在单个网页上动态更新内容，消除了完全重新加载页面的需要，并为Web应用提供了更类似应用程序的感觉。
- en: We could certainly create an SPA backend using Flask, but it might not be the
    best choice. This is especially true if you expect your application’s user base
    to be large. Flask is criticized as being a bit slow when you have server requests
    at high volume. Thankfully, there are other players in the game, and in this chapter,
    we’re going to focus on FastAPI.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用Flask创建一个SPA后端，但这可能不是最佳选择。特别是如果你预期你的应用程序的用户基数很大。当服务器请求量高时，Flask被认为有点慢。幸运的是，游戏中有其他参与者，在本章中，我们将重点关注FastAPI。
- en: 'The interesting thing about FastAPI is the way it handles web requests. Most
    products, including Flask, use a worker model. A pool of workers is responsible
    for servicing multiple incoming requests on separate processes managed by the
    operating system. FastAPI uses an **asynchronous programming** model. In the realm
    of asynchronous programming, functions are invoked, but the immediate return of
    outcomes is not guaranteed. Let’s explore the following illustrative Python code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI最有趣的地方在于它处理Web请求的方式。大多数产品，包括Flask，都使用工作模型。一群工作进程负责在操作系统管理的不同进程中服务多个传入请求。FastAPI使用**异步编程**模型。在异步编程领域，函数会被调用，但并不保证立即返回结果。让我们来探索以下具有说明性的Python代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When calling `add_two` in a synchronous programming context, the execution thread
    halts until the function is completed and the outcome is furnished. However, the
    mechanics differ when employing asynchronous programming. An asynchronous invocation
    doesn’t halt the invoking thread. Instead, the calling thread persists in execution
    after obtaining a `a + b` once this computation has been executed. It’s important
    to acknowledge that this may not happen instantaneously, but during the computation,
    other operations remain unblocked. Naturally, performing an addition of integers
    is likely to conclude swiftly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步编程环境中调用`add_two`时，执行线程会暂停，直到函数完成并返回结果。然而，当使用异步编程时，机制会有所不同。异步调用不会停止调用线程。相反，在执行完计算`a
    + b`后，调用线程会继续执行。重要的是要认识到，这可能不会立即发生，但在计算过程中，其他操作不会被阻塞。当然，执行整数的加法运算很可能会迅速完成。
- en: Consider an alternative scenario where a request is made to a networked resource,
    such as fetching a web page. The speed of response is no longer solely contingent
    on the processor’s execution speed. It encompasses factors such as computer performance,
    network latency, and various other elements that might introduce delays ranging
    from seconds to even minutes. This is particularly true for those who don’t reside
    in well-connected urban areas with high-speed internet access. Since the asynchronous
    software doesn’t block, it can serve many requests serially since none of them
    are waiting for the previous function call or, in this case, web request, to finish.
    You can think of it as a restaurant with one waiter. You submit your order serially
    with other diners, but the cook only returns your food when it has been cooked.
    With this expectation set, the cook is free to cook as many dishes at once as
    their stove allows, and there is an implicit promise given that once your food
    is cooked, the waiter will bring it to you. Someone who orders a glass of juice
    might get their order back immediately, whereas your baked Alaska will take a
    little longer to produce.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个替代场景，其中对网络资源（如获取网页）发出请求。响应速度不再仅仅取决于处理器的执行速度。它包括计算机性能、网络延迟以及可能引入从几秒到甚至几分钟的延迟的各种其他因素。这对于居住在高速互联网接入良好、连接紧密的城市地区的那些人来说尤其如此。由于异步软件不会阻塞，因此它可以串行地服务许多请求，因为它们中没有一个正在等待前一个函数调用或，在这种情况下，网页请求完成。你可以把它想象成只有一个服务员的一家餐厅。你与其他用餐者一样串行地提交订单，但厨师只有在食物做好后才会给你送来。有了这样的预期，厨师可以自由地一次烹饪他们炉灶允许的尽可能多的菜肴，并且有一个隐含的承诺，即一旦你的食物做好，服务员就会把它给你。订购一杯果汁的人可能会立即得到他们的订单，而你的烤阿拉斯加可能需要更长的时间来制作。
- en: A synchronous restaurant, by contrast, would employ, say, eight cooks. Eight
    orders can come in at once, but each cook is completely dedicated to fixing that
    one order until it is complete. As it turns out, the throughput, at least for
    computers, is often faster when employing the asynchronous model for typical web
    request workloads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个同步餐厅可能会雇佣，比如说，八个厨师。可以同时进来八个订单，但每个厨师都会完全专注于完成那个订单，直到它完成。结果证明，至少对于计算机来说，在典型的Web请求工作负载中采用异步模型时，吞吐量通常更快。
- en: In Python 3.4, we got a new module called `asyncio`, which brought asynchronous
    programming features to our favorite language. Three years later, we found the
    first GitHub commit to a library project called **Starlette**. Starlette is an
    asynchronous web framework for building high-performance applications with Python.
    It provides the core functionality for handling HTTP requests and responses in
    an efficient manner. Starlette is known for its simplicity, speed, and support
    for modern Python features, making it an ideal foundation for building web applications.
    Like Werkzeug, though, which powers Flask, Starlette was only meant to be a foundation.
    This chapter covers **FastAPI**, a framework built on top of Starlette that represents
    a full implementation of a web framework specializing in the development of **RESTful
    Application Programming Interfaces** (**REST APIs**) Where Flask used a worker
    model, FastAPI uses an asynchronous model, and where Flask was designed to create
    traditional round trip, template-driven content generation, FastAPI normally used
    the SPAs to handle serving data in the form of **JavaScript Object** **Notation**
    (**JSON**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.4中，我们得到了一个新的模块，名为`asyncio`，它将异步编程特性带到了我们最喜欢的语言中。三年后，我们发现了第一个名为**Starlette**的库项目的GitHub提交。Starlette是一个异步Web框架，用于使用Python构建高性能应用程序。它以高效的方式提供了处理HTTP请求和响应的核心功能。Starlette以其简洁、速度和对现代Python特性的支持而闻名，使其成为构建Web应用的理想基础。尽管如此，像为Flask提供动力的Werkzeug一样，Starlette最初也只打算作为一个基础。本章涵盖了**FastAPI**，这是一个建立在Starlette之上的框架，代表了专门用于开发**RESTful应用程序编程接口（REST
    APIs**）的完整Web框架。与Flask使用工作模型不同，FastAPI使用异步模型；与Flask旨在创建传统的往返、模板驱动的内容生成不同，FastAPI通常使用单页应用（SPAs）来处理以**JavaScript对象表示法（JSON**）形式提供的数据。
- en: I realize we just introduced a lot of jargon, which may be new to Python developers
    who aren’t normally web developers. We’ll explain our terminology in context as
    we cover building a simple FastAPI project using PyCharm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到我们刚刚介绍了很多术语，这些术语可能对那些不是通常的Web开发者的Python开发者来说是新的。在我们介绍使用PyCharm构建简单的FastAPI项目时，我们将根据上下文解释我们的术语。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Explain the difference between a traditional template-driven content generation
    system such as Flask and one that strictly serves data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释传统模板驱动的内容生成系统（如Flask）与严格服务数据的系统之间的区别
- en: Describe the stateless nature of HTTP (and HTTPS) along with how **representational
    state transfer** (**REST**) is used to mitigate the lack of state in HTTP
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述HTTP（和HTTPS）的无状态特性，以及如何使用**表示状态转移**（**REST**）来弥补HTTP中的状态缺失
- en: Create a FastAPI project using the built-in template provided in PyCharm Professional
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyCharm Professional内置的模板创建一个FastAPI项目
- en: Perform tests on your FastAPI project using PyCharm’s HTTP REST client
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyCharm的HTTP REST客户端对FastAPI项目进行测试
- en: Create a React frontend application in a separate but connected (attached) project
    in PyCharm, allowing you to develop a full stack application without mingling
    the frontend JavaScript code with the backend Python code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm中创建一个独立的但连接（附加）的React前端应用程序，这样你就可以在不混淆前端JavaScript代码和后端Python代码的情况下开发全栈应用程序
- en: Manage multiple run configurations and debug the entire request-response pipeline
    in PyCharm’s debugger
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PyCharm的调试器中管理多个运行配置并调试整个请求-响应流程
- en: Bear in mind that this chapter isn’t meant to be a full tutorial on either FastAPI
    or React. The core purpose of this book is to teach PyCharm within the context
    of creating applications. Our coverage of FastAPI might be tacit, whereas our
    coverage of PyCharm as a tool to make an application with FastAPI will be very
    complete.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本章的目的不是全面介绍FastAPI或React。本书的核心目的是在创建应用程序的背景下教授PyCharm。我们对FastAPI的介绍可能比较隐晦，而我们对PyCharm作为创建FastAPI应用程序的工具的介绍将非常全面。
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续阅读本章，以及本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并正常工作的Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will be using `pip` and `virtualenv`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了`pip`和`virtualenv`。当你将Python安装在Windows上时，你会自动获得这些，macOS在每台系统上都包含它们。如果你使用Linux，你需要单独安装包管理器，如`pip`，以及虚拟环境工具，如`virtualenv`。我们的示例将使用`pip`和`virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并正常工作的PyCharm副本。安装已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍，以防你在书的中途开始阅读。
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书提供的示例源代码来自GitHub。我们在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍了代码克隆。你可以在[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09)找到本章的相关代码。
- en: There is no REST in a wicked stateless world
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个无状态的恶劣世界中没有REST
- en: I’ve heard it said that computers are the dumbest creatures on the planet. They
    only do exactly as they are told, and they take your instructions in an extremely
    literal way. This is what makes programming a computer so difficult. You must
    choose exactly the right syntax and structure your ideas precisely and succinctly
    because any ambiguity will result in a bug.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我听说有人说过，计算机是地球上最愚蠢的生物。它们只会按照指示行事，并以极其字面的方式接受你的指令。这就是编程计算机如此困难的原因。你必须选择完全正确的语法，并精确简洁地组织你的想法，因为任何含糊不清都会导致错误。
- en: 'There is only one way to make our lives hard, and that is to base our work
    and our careers on a system with the attention span of a fruit fly. I’m talking
    about web servers, of course. The term web server can mean two different things:
    it can refer to hardware or software. The hardware is any computer system running
    the software. I’ve seen people build web server hardware that fits in a matchbox,
    and I’ve seen web server hardware fill expansive rack mount systems in specially
    cooled data centers. In truth, for us at least, the hardware is the boring part.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一能让我们的生活变得艰难的方式，就是将我们的工作和职业建立在一种像果蝇一样注意力分散的系统上。我当然是在谈论网络服务器。术语网络服务器可以指两件不同的事情：它可以指硬件或软件。硬件是指运行该软件的任何计算机系统。我看到过人们用火柴盒大小的硬件构建网络服务器，也看到过网络服务器硬件占据了宽敞的机架式系统，这些系统位于特别冷却的数据中心中。实际上，至少对我们来说，硬件是无聊的部分。
- en: 'Web server software is a little more interesting to those of us who write code.
    Web server software, such as **Apache**, **Nginx** (pronounced “engine-ex”), **LightHTTPD**,
    and others, are designed to be simple yet robust implementations of a common specification
    for the HTTP protocol. These specifications are internationally agreed to by the
    **World Wide Web Consortium** (**W3C**). The protocol itself is very straightforward.
    We’ve mentioned a few things about it already in earlier chapters, such as the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器软件对我们这些编写代码的人来说更有趣。网络服务器软件，例如 **Apache**、**Nginx**（发音为“engine-ex”）、**LightHTTPD**
    以及其他一些，都是为了实现 HTTP 协议的通用规范而设计的简单而健壮的实现。这些规范是由 **万维网联盟**（**W3C**）在国际上达成一致的。该协议本身非常直接。我们已经在前面的章节中提到了一些关于它的内容，例如以下内容：
- en: '**Client-server model**: HTTP follows a client-server model, where the client
    (typically a web browser) sends a request to the server, and the server responds
    with the requested data.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器模型**：HTTP 遵循客户端-服务器模型，其中客户端（通常是网络浏览器）向服务器发送请求，服务器以请求的数据进行响应。'
- en: '`GET`, `POST`, `PUT`, or `DELETE`), a **Uniform Resource Identifier** (**URI**)
    that identifies the resource being accessed, and headers that provide additional
    information. The server responds with a status code indicating the success or
    failure of the request and includes the requested data in the response body. In
    case you missed it, there’s a full discussion of the request-response paradigm
    (complete with pictures) in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203), *Building
    a Dynamic Web Application* *with Flask*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT` 或 `DELETE`），一个 **统一资源标识符**（**URI**）用于标识正在访问的资源，以及提供额外信息的头部信息。服务器会以状态码的形式响应请求的成功或失败，并在响应体中包含请求的数据。如果你错过了，可以在
    [*第 8 章*](B19644_08.xhtml#_idTextAnchor203) 的 *使用 Flask 构建动态网络应用程序* 中找到对请求-响应范式的完整讨论（包括图片）。'
- en: '**Text-based protocol**: HTTP is a text-based protocol, meaning that both the
    request and response messages are human-readable. The messages follow a specific
    format called the HTTP message format, which consists of headers and an optional
    message body.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文本的协议**：HTTP 是一种基于文本的协议，这意味着请求和响应消息都是可读的。消息遵循一种称为 HTTP 消息格式的特定格式，该格式由头部和可选的消息体组成。'
- en: '**Secure variant**: HTTP can be augmented with encryption and security features
    using **HTTPS** (**HTTP Secure**). HTTPS adds a layer of **Transport Layer Security**
    (**TLS**) or **Secure Sockets Layer** (**SSL**) encryption to protect the confidentiality
    and integrity of the data transmitted between the client and the server.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全版本**：HTTP 可以通过使用 **HTTPS**（**HTTP Secure**）来增加加密和安全功能。HTTPS 在客户端和服务器之间传输的数据的机密性和完整性方面添加了一层
    **传输层安全性**（**TLS**）或 **安全套接字层**（**SSL**）加密。'
- en: 'In our immediate discussion, I want to point out a nugget we have heretofore
    glossed over: HTTP is stateless. This means that each request from a client is
    treated independently, without any knowledge of previous requests. The server
    does not retain any information about the client’s previous interactions. In the
    US, there is a famous advertising campaign for the city of Las Vegas, which states
    “What happens in Vegas stays in Vegas.” Likewise, what happens within the request-response
    mechanism stays in that request-response life cycle. Once the response is received
    and acknowledged by the web browser, there is nothing other than a log entry somewhere
    that the request even took place.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的讨论中，我想指出一个我们之前忽略的要点：HTTP是无状态的。这意味着来自客户端的每个请求都被独立处理，没有任何关于之前请求的知识。服务器不会保留关于客户端之前互动的任何信息。在美国，有一个著名的为拉斯维加斯市做的广告活动，其口号是“拉斯维加斯发生的事情留在拉斯维加斯。”同样，请求-响应机制中发生的事情也留在那个请求-响应的生命周期中。一旦响应被网络浏览器接收并确认，除了某个地方的日志条目表明请求发生过之外，就没有其他东西了。
- en: In concert, what we have here is a dumb machine executing requests of which
    it has no memory. This can make our job somewhat frustrating. We want our users
    to be continually interacting with our application, but the server isn’t going
    to help us do that without some form of cajoling.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作中，我们这里所拥有的只是一个执行它没有记忆的请求的愚蠢机器。这可能会让我们的工作变得有些令人沮丧。我们希望用户持续地与我们的应用程序互动，但服务器不会不经过某种形式的哄骗就帮助我们做到这一点。
- en: Over the years, a number of mechanisms have been invented to help with the state
    in our application. If you’re not sure what I mean by state, I like to describe
    it as a saved game in your favorite video game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，已经发明了许多机制来帮助我们在应用程序中处理状态。如果你不确定我所说的状态是什么，我喜欢将其描述为你最喜欢的电子游戏中的保存游戏。
- en: Imagine you are playing an adventure game. You’ve been playing for quite a while,
    and you’ve found the entrance to the dark castle, which is on level three. You’ve
    answered the gatekeeper’s riddle, and you have obtained the vorpal sword of smiting.
    You have amassed 32,768 gold pieces and your character is at full health. Then
    your mom yells for you to go take out the trash. As we all know, this is “mom
    code” for “quit playing video games and do something productive.” She’ll never
    understand, will she? Naturally, you’d like to pick up where you left off, so
    you save your game. You can turn off your computer and turn it back on tomorrow,
    at which point you can load your game and it will behave as though you never stopped
    playing. This is because your saved game represents a saved state for the program.
    It is a snapshot of all the objects, variables, and data used by your game at
    the time you saved it. This is the program’s state. This is what web applications
    intrinsically lack, at least at the protocol level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在玩一个冒险游戏。你已经玩了很长时间，你找到了位于第三层的黑暗城堡的入口。你已经回答了守门人的谜题，并获得了斩妖剑。你已经积累了32,768枚金币，你的角色处于满血状态。然后你的妈妈叫你去倒垃圾。众所周知，这是“妈妈代码”表示“停止玩电子游戏，做些有productive的事情。”她永远不会理解，对吧？自然地，你希望从你离开的地方继续，所以你保存了游戏。你可以关掉电脑，明天再打开，然后你可以加载你的游戏，它将表现得好像你从未停止过玩。这是因为你的保存游戏代表了程序的一个保存状态。这是你在保存游戏时游戏所使用的所有对象、变量和数据的快照。这是程序的状态。这是网络应用程序本质上缺乏的，至少在协议层面上。
- en: 'The state can be managed using a few techniques. Server solutions such as Flask
    allow you to implement sticky sessions where HTTP requests generate a token. The
    request details can be stored between sessions with reference to the token. This
    is not handled by your web server, but by your application server, which leverages
    the web server for the communications part: the request-response mechanism. Sessions
    are generally not desirable because, in most cases, they don’t scale. If you have
    a lot of web traffic, it is common practice to balance the traffic load between
    several servers. If your session is stored on server A on the first request, and
    a subsequent request goes to server B, it won’t have your session. Naturally,
    we’ve come up with solutions for that too, but let’s not get down in the weeds.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以通过几种技术进行管理。服务器解决方案，如 Flask，允许你实现粘性会话，其中 HTTP 请求生成一个令牌。请求详情可以通过令牌在会话之间存储。这不是由你的
    web 服务器处理的，而是由你的应用服务器处理的，它利用 web 服务器进行通信部分：请求-响应机制。会话通常是不受欢迎的，因为在大多数情况下，它们无法扩展。如果你有大量的网络流量，通常的做法是在几个服务器之间平衡流量负载。如果你的会话在第一次请求时存储在服务器
    A 上，而后续请求转到服务器 B，它将不会包含你的会话。自然地，我们也为此想出了解决方案，但让我们不要陷入细节。
- en: You can use cookies, which store the data on the client side. Unfortunately,
    cookies have a bad reputation as they have been highly abused over the years.
    The major browsers expose the cookies you are saving, and your ever-paranoid users
    can choose to not accept your request to store cookies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 cookies，它们在客户端存储数据。不幸的是，cookies 由于多年来被过度使用而声名狼藉。主要的浏览器暴露了你正在保存的 cookies，而你那些永远警惕的用户可以选择不接受你存储
    cookies 的请求。
- en: 'The best answer is to store the state of your application in the application
    itself. The idea here is called representational state transfer, or REST for short.
    In a RESTful scenario, we maintain the program’s state in memory on the client.
    We transfer any part of the state, or even (but not usually) the entire state
    using the request-response mechanism. The program essentially sends the parts
    of the state the server will need to fulfill the request. The server does whatever
    it is supposed to do, and then sends back the altered state in the response. If
    you are familiar with software design patterns, REST reminds me of the command
    pattern: the request encapsulates everything the server needs to complete the
    request.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的办法是将应用程序的状态存储在应用程序本身中。这里的想法被称为表示状态转移，简称 REST。在 RESTful 场景中，我们在客户端内存中维护程序的状态。我们使用请求-响应机制传输任何状态的部分，甚至（但通常不是）整个状态。程序基本上发送服务器需要以完成请求的状态部分。服务器执行它应该执行的操作，然后在响应中发送修改后的状态。如果你熟悉软件设计模式，REST
    让我想起了命令模式：请求封装了服务器完成请求所需的所有内容。
- en: Now that the stage is set, let’s remember that SPAs are now responsible for
    maintaining their state, that all of the markup HTML, CSS, and JavaScript is loaded
    in the browser, and that all subsequent requests contain only the state data,
    which is sent to the server where it is altered and returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在舞台已经搭建好了，让我们记住，单页应用（SPAs）现在负责维护它们的状态，所有的标记 HTML、CSS 和 JavaScript 都在浏览器中加载，并且所有后续请求只包含状态数据，这些数据被发送到服务器，在那里被修改并返回。
- en: 'The format of the data transfer can be any form of text. Most often, it is
    JSON. Back in ye olde days of yore, we used XML, but we stopped because XML processing
    is ridiculously slow in a browser. JSON is faster since the browser already inherently
    understands JavaScript, so there is no parsing of the text required. Just in case
    this is your first rodeo, let’s compare the two formats. First, here’s some XML:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输的格式可以是任何形式的文本。最常见的是 JSON。在古老的过去，我们使用 XML，但我们停止使用它，因为 XML 在浏览器中的处理速度极其缓慢。JSON
    更快，因为浏览器已经内建地理解 JavaScript，因此不需要解析文本。以防这是你第一次参加这样的活动，让我们比较一下这两种格式。首先，这里有一些 XML：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'XML is tag-based markup like HTML, but you can define your own tags using an
    XML schema. This was the format originally used in browsers with the **XMLHttpRequest**
    (**XHR**) API call. The *X* actually stands for *XML*. XHR is still used, but
    almost nobody (Microsoft Azure API teams notwithstanding) still uses XML. Instead,
    for performance reasons already mentioned, I give you the same thing in JSON:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是类似于 HTML 的基于标签的标记语言，但你可以使用 XML 架构定义自己的标签。这是最初在浏览器中使用 **XMLHttpRequest**
    （**XHR**）API 调用的格式。这里的 *X* 实际上代表 *XML*。XHR 仍然在使用，但几乎没有人（不包括微软 Azure API 团队）还在使用
    XML。相反，出于已经提到的性能原因，我给你同样的东西，但以 JSON 格式：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The same data is represented as is the structure of that data. As a Python
    developer, you’ve no doubt recognized this as a `dict`. Instead of tags with content
    and attributes, we have key-value pairs stored within curly braces. It is a rule
    of JSON that keys and textual values be enclosed in double quotations. Be careful
    here. JavaScript and Python both consider single and double quotation marks to
    be interchangeable, but JSON does not. Only double quotes are acceptable! Thankfully,
    Python has a `json` library available within the standard library that will convert
    your structures to JSON, and back again, without any fuss:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的表示方式与数据结构相同。作为一名Python开发者，您无疑已经认出这是一个`dict`。我们不再有带有内容和属性的标签，而是有存储在花括号内的键值对。这是JSON的一个规则，即键和文本值必须用双引号括起来。在这里要小心。JavaScript和Python都认为单引号和双引号可以互换，但JSON不行。只有双引号是可接受的！幸运的是，Python标准库中有一个`json`库，可以将您的结构转换为JSON，然后再转换回来，无需任何麻烦：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These first few lines import the `json` library, then convert it to a JSON
    object with the `json.dumps` method. Just remember, we’re dumping to a string,
    hence `dumps` (the *s* is for *string*). Now let’s convert the other direction:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行首先导入`json`库，然后使用`json.dumps`方法将其转换为JSON对象。只需记住，我们是在转换为字符串，因此使用`dumps`（*s*代表*string*）。现在让我们转换另一个方向：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We used `json.loads` to convert the JSON back to a `dict`. Just remember it
    as “We’re loading a JSON string,” hence `loads` (the *s* is for *string*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.loads`将JSON转换回`dict`。只需记住它为“我们正在加载一个JSON字符串”，因此使用`loads`（*s*代表*string*）。
- en: You now understand the basic mechanics of what we’re going to be doing with
    FastAPI. Requests will be coming in like they did with Flask, but generally, instead
    of simple `GET` requests, which are intercepted and processed using the Jinja2
    template engine, the requests will contain JSON payloads, which we will process.
    The results of the processing will be returned as JSON. The request-response mechanism
    will be handled using asynchronous functions, so the code will look a little different
    than it did with Flask.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经理解了我们将要使用FastAPI的基本机制。请求将像Flask中那样到来，但通常，不是简单的`GET`请求，这些请求会被拦截并使用Jinja2模板引擎处理，而是请求将包含JSON有效负载，我们将对其进行处理。处理的结果将以JSON形式返回。请求-响应机制将使用异步函数处理，因此代码将看起来与Flask略有不同。
- en: Let’s get our hands dirty so you can see what I mean!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手实践，以便您能理解我的意思！
- en: Creating a FastAPI project in PyCharm Professional
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm Professional中创建FastAPI项目
- en: By now, we’ve created many projects in PyCharm Professional and this isn’t very
    different. I’ll remind you that this set of features is only available in the
    Professional edition of PyCharm. If you need to use the Community edition, you
    can, but you’re on your own in terms of setting up the project since you won’t
    have access to the tooling we’re about to use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们在PyCharm Professional中已经创建了多个项目，这并没有太大不同。我要提醒您，这一系列功能仅在PyCharm的专业版中可用。如果您需要使用社区版，您当然可以，但您将不得不自己设置项目，因为您将无法访问我们即将使用的工具。
- en: 'Create a new project in PyCharm by clicking **File** | **New Project**. Then,
    find **FastAPI**in the list of templates. You can see mine in *Figure 9**.1*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中通过点击**文件** | **新建项目**来创建一个新的项目。然后，在模板列表中找到**FastAPI**。您可以在*图9.1*中看到我的示例：
- en: '![Figure 9.1: The PyCharm project menu contains a template for a FastAPI project](img/B19644_09_01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：PyCharm项目菜单包含一个FastAPI项目模板](img/B19644_09_01.jpg)'
- en: 'Figure 9.1: The PyCharm project menu contains a template for a FastAPI project'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：PyCharm项目菜单包含一个FastAPI项目模板
- en: 'As with Flask, the FastAPI project template generates some starter code and
    a run configuration for us, as seen in *Figure 9**.2*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flask一样，FastAPI项目模板为我们生成了一些启动代码和运行配置，如图9.2所示：
- en: '![Figure 9.2: The template generates our FastAPI starter code and run configuration](img/B19644_09_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：模板生成我们的FastAPI启动代码和运行配置](img/B19644_09_02.jpg)'
- en: 'Figure 9.2: The template generates our FastAPI starter code and run configuration'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：模板生成我们的FastAPI启动代码和运行配置
- en: There is a lot to talk about in *Figure 9**.2*, so I’ve numbered the diagram
    for reference.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.2*中有许多内容可以讨论，所以我为它编号以供参考。
- en: PyCharm has created a virtual environment, along with two files as seen at `main.py`
    and `test_main.http`. We’ll come back to the files in a moment. PyCharm generated
    a run configuration for us. You can tell because it is the currently selected
    run configuration at **(2)** where that menu would normally say **Current File**
    if PyCharm didn’t have a run configuration set up.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 为我们创建了一个虚拟环境，以及两个文件，如 `main.py` 和 `test_main.http` 所见。我们稍后会回到这些文件。PyCharm
    为我们生成了一个运行配置。你可以通过它现在是当前选中的运行配置，在 **(2)** 处，如果 PyCharm 没有设置运行配置，那个菜单通常会显示 **当前文件**
    来判断。
- en: At position `Hello World` endpoint for our FastAPI project. The power of these
    starter code templates is the psychological prompting they provide. If you have
    used any system for working with web routing and endpoints, regardless of language
    or framework, you can read this code and tell what is happening.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 FastAPI 项目中，位于 `Hello World` 端点。这些入门代码模板的强大之处在于它们提供的心理提示。如果你使用过任何用于处理网页路由和端点的系统，无论语言或框架如何，你都可以阅读这段代码并了解正在发生什么。
- en: Lines 1 and 3 show us a typical constructor for the imported library instance
    of FastAPI. Line 6 shows us how FastAPI decorates endpoints. `@app` comes from
    the instantiation on line 3 and we’re invoking the HTTP `GET` method here so requests
    coming in using that method will be received and processed. If a client makes
    a request using another HTTP verb such as `PUT` or `POST`, they’ll receive an
    error since, currently, there is no code to handle that HTTP method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 行和第 3 行展示了导入的 FastAPI 实例的典型构造函数。第 6 行展示了 FastAPI 如何装饰端点。`@app` 来自第 3 行的实例化，我们在这里调用
    HTTP `GET` 方法，因此使用该方法发送的请求将被接收和处理。如果客户端使用其他 HTTP 动词，如 `PUT` 或 `POST` 发送请求，他们将收到错误，因为目前没有代码来处理该
    HTTP 方法。
- en: Position `async` function below the decorator on line 7, and we can see we are
    returning something that looks like a `dict`, which also looks like JSON.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 行装饰器下方定位到 `async` 函数，我们可以看到我们返回了一个看起来像 `dict` 的东西，它也看起来像 JSON。
- en: Position `GET` endpoint defined as `/hello/{name}`. The `name` variable offset
    in curly braces refers to part of the URL that can vary and is called a path parameter
    or a path variable. You can see it is duplicated in the `async` function definition
    on line 12\. The contents of the branches (`name`) on line 11 should match the
    name of the parameter for the function on line 12.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到 `GET` 端点，定义为 `/hello/{name}`。花括号中偏移的 `name` 变量指的是 URL 中可以变化的部分，称为路径参数或路径变量。你可以在第
    12 行的 `async` 函数定义中看到它被重复。第 11 行分支（`name`）的内容应该与第 12 行函数的参数名称匹配。
- en: Position `f` string expression fills the name into the data. There is no special
    templating mechanism other than a normal Python `f` string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到 `f` 字符串表达式，将名称填充到数据中。除了正常的 Python `f` 字符串之外，没有特殊的模板机制。
- en: Running the FastAPI project
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 FastAPI 项目
- en: 'Naturally, we can run the FastAPI project by clicking the green arrowed run
    button near position **(2)**in *Figure 9**.2*. If you’ve skipped the chapter on
    setting up and using run and debug configurations, you might want to peek at [*Chapter
    6*](B19644_06.xhtml#_idTextAnchor145), *Seamless Testing, Debugging, and Profiling*,
    for details on how this feature works in PyCharm. You can see my program running
    in *Figure 9**.3*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们可以通过点击 *图 9**.2* 中靠近 **(2)** 位置的绿色箭头运行按钮来运行 FastAPI 项目。如果你跳过了关于设置和使用运行和调试配置的章节，你可能想看看
    [*第 6 章*](B19644_06.xhtml#_idTextAnchor145)，*无缝测试、调试和性能分析*，以了解 PyCharm 中此功能的工作方式。你可以在
    *图 9**.3* 中看到我的程序正在运行：
- en: '![Figure 9.3: I clicked the green run button, which spawned a tab in the run
    window for my project in PyCharm](img/B19644_09_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：我点击了绿色的运行按钮，这在 PyCharm 的运行窗口中为我的项目创建了一个标签](img/B19644_09_03.jpg)'
- en: 'Figure 9.3: I clicked the green run button, which spawned a tab in the run
    window for my project in PyCharm'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：我点击了绿色的运行按钮，这在 PyCharm 的运行窗口中为我的项目创建了一个标签
- en: This looks similar to the runs in Flask, but there isn’t a warning about the
    development server. This is because FastAPI runs in an application called `uvicorn`,
    which is a variant of Green Unicorn (`gunicorn`). Uvicorn is production ready,
    so there is no warning. You can develop using the same application server software
    you will use when you deploy your application to your customers. The difference
    between `uvicorn` and `gunicorn`, which is most often used as a production server
    for Flask applications, is that `uvicorn` handles the async programming model
    while `gunicorn` uses traditional workers, as described earlier in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与Flask中的运行类似，但没有关于开发服务器的警告。这是因为FastAPI在名为`uvicorn`的应用中运行，它是Green Unicorn
    (`gunicorn`)的一个变体。Uvicorn是生产就绪的，所以没有警告。您可以使用与您将应用部署给客户时相同的同一应用程序服务器软件进行开发。`uvicorn`和`gunicorn`之间的区别在于，`uvicorn`处理异步编程模型，而`gunicorn`使用前面在本章中描述的传统工作者。
- en: 'At this point, we are left with something of a quandary. When we did this with
    Flask, the app was generating some HTML for us to view. This one isn’t. You can
    view the endpoint in a browser if you would like, as I am in *Figure 9**.4*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们面临一些困惑。当我们用Flask做这件事时，应用为我们生成了一些可以查看的HTML。而这个应用没有。如果您愿意，可以在浏览器中查看端点，就像我在*图9.4*中做的那样：
- en: '![Figure 9.4: Visiting the root route isn’t very exciting, but it works](img/B19644_09_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：访问根路由并不令人兴奋，但它有效](img/B19644_09_04.jpg)'
- en: 'Figure 9.4: Visiting the root route isn’t very exciting, but it works'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：访问根路由并不令人兴奋，但它有效
- en: 'I can also visit the other URL with the path parameter as part of the URL as
    shown in *Figure 9**.5*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以访问包含路径参数作为URL一部分的其他URL，如图*图9.5*所示：
- en: '![Figure 9.5: Supplying a path parameter alters the data in the response](img/B19644_09_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：提供路径参数会改变响应中的数据](img/B19644_09_05.jpg)'
- en: 'Figure 9.5: Supplying a path parameter alters the data in the response'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：提供路径参数会改变响应中的数据
- en: This time, I added the path parameter to the end of the URL, and as we saw in
    the code earlier, we’re getting back the generated JSON data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我在URL的末尾添加了路径参数，并且正如我们在前面的代码中看到的，我们正在返回生成的JSON数据。
- en: There’s a problem with using the browser. The browser only allows you to submit
    HTTP `GET` requests. There are quite a few more HTTP methods typically used in
    a REST API project. In fact, the four most popular methods, sometimes referred
    to as verbs, map to the typical CRUD operations used in database applications.
    `GET` and `POST`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器存在问题。浏览器只允许您提交HTTP `GET`请求。在REST API项目中通常使用相当多的HTTP方法。事实上，最常用的四种方法，有时被称为动词，映射到数据库应用程序中使用的典型CRUD操作。`GET`和`POST`。
- en: 'In addition to standards for your requests, your responses can be standardized
    via best practice by using proper HTTP status codes. These are documented in the
    HTTP specifications provided by the W3C. Reading the specification is a sure-fire
    cure for insomnia, so I’ll refer you to the excellent **Mozilla Developer Network**
    (**MDN**) page for the status codes. This is a handy address to bookmark in your
    browser: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您请求的标准之外，您还可以通过最佳实践使用适当的HTTP状态码来标准化响应。这些由W3C提供的HTTP规范中进行了记录。阅读规范是治疗失眠的灵丹妙药，所以我将向您推荐优秀的**Mozilla开发者网络**（**MDN**）页面中的状态码。这是您在浏览器中需要书签的方便地址：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。
- en: '| **HTTP Verb /** **Method** | **CRUD Operation** | **HTTP Status for** **Successful
    Response** | **Explanation** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **方法** | **CRUD操作** | **成功响应的HTTP状态码** | **说明** |'
- en: '| `GET` | `READ` | `200 (OK)` | Used to retrieve or get information from the
    server or database. For example, getting a list of users in your application.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `READ` | `200 (OK)` | 用于从服务器或数据库检索或获取信息。例如，获取应用程序中的用户列表。|'
- en: '| `POST` | `CREATE` | `201 (Created)` | Used to create a new record in a database.
    Use this anytime you are creating something on the server. For example, new user
    registration. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `CREATE` | `201 (Created)` | 用于在数据库中创建新记录。在服务器上创建任何内容时都使用此方法。例如，新用户注册。|'
- en: '| `PUT` | `UPDATE` | `204 (No Content)` or `200 (OK)` | Use this method when
    you are sending an update to something that already exists, such as a database
    record. For example, updating a password. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `UPDATE` | `204 (No Content)`或`200 (OK)` | 当您向已存在的东西发送更新时使用此方法，例如数据库记录。例如，更新密码。|'
- en: '| `DELETE` | `DELETE` | `204 (No Content)` or `200 (OK)` | Use this when you
    want to delete something. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `DELETE` | `204 (无内容)` 或 `200 (OK)` | 当你想删除某些内容时使用此操作。 |'
- en: 'Figure 9.6: HTTP methods map to CRUD operations 1:1 and have standard response
    codes to denote successful responses'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：HTTP方法与CRUD操作一一对应，并且有标准响应代码来表示成功的响应
- en: 'With your browser limited to HTTP `GET` requests, and the 100% likelihood that
    we will want to use at least one of the other methods in our project, we need
    something better than just a browser for testing our API. We have a few options:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的浏览器仅限于HTTP `GET`请求，并且我们有100%的可能会在我们的项目中使用至少其他一种方法，因此我们需要比浏览器更好的工具来测试我们的API。我们有几种选择：
- en: There are browser plugins that allow you to send different kinds of requests.
    You can find them in your favorite browser’s marketplace.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些浏览器插件允许你发送不同类型的请求。你可以在你喜欢的浏览器市场里找到它们。
- en: Command-line tools such as cURL allow you to craft HTTP requests using any of
    the HTTP methods.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具，如cURL，允许你使用任何HTTP方法来构建HTTP请求。
- en: Dedicated API testing tools such as Insomnia ([https://www.insomnia.rest](https://www.insomnia.rest))
    or Postman ([https://getpostman.com](https://getpostman.com)) allow you a graphical
    tool for working with API requests. These tools can be very bloated as they are
    meant to do a lot more than just allow you to make the various request types.
    With that said, I use both because of their wide adoption rate. Believe it or
    not, there are developers on my team who don’t use PyCharm.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门的API测试工具，如Insomnia ([https://www.insomnia.rest](https://www.insomnia.rest))
    或Postman ([https://getpostman.com](https://getpostman.com))，为你提供了一个用于处理API请求的图形化工具。这些工具可能非常庞大，因为它们旨在做更多的事情，而不仅仅是允许你发送各种请求类型。话虽如此，我之所以使用这两个工具，是因为它们的普及率很高。信不信由你，我的团队中有些开发者不使用PyCharm。
- en: PyCharm’s built-in HTTP `Requests` feature.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm内置的HTTP `Requests`功能。
- en: Obviously, we’re going to be focusing on the fourth option.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们将专注于第四个选项。
- en: Working with PyCharm’s HTTP Requests
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyCharm的HTTP请求进行工作
- en: 'When we generated our project, PyCharm created two files. It created `main.py`,
    which we have already examined. It also created a file called `test_main.http`.
    This file is unique to PyCharm. Let’s examine the file shown in *Figure 9**.7*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成项目时，PyCharm创建了两个文件。它创建了`main.py`，这是我们之前已经检查过的。它还创建了一个名为`test_main.http`的文件。这个文件是PyCharm特有的。让我们检查*图9.7*中显示的文件：
- en: '![Figure 9.7: The HTTP test file generated by PyCharm as part of a FastAPI
    project](img/B19644_09_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：PyCharm作为FastAPI项目一部分生成的HTTP测试文件](img/B19644_09_06.jpg)'
- en: 'Figure 9.7: The HTTP test file generated by PyCharm as part of a FastAPI project'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：PyCharm作为FastAPI项目一部分生成的HTTP测试文件
- en: You’ll find the file itself directly next to `main.py` `test-main.http`, which
    lets us know exactly what is being tested. The `main.py` file will contain endpoints
    and `test_main.http` will then contain tests for all the endpoints.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在`main.py`旁边找到该文件`test-main.http`，这让我们确切地知道正在测试什么。`main.py`文件将包含端点，而`test_main.http`将包含所有端点的测试。
- en: 'This `http` test file isn’t code, as we saw in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*. This is a specification for HTTP
    requests. Positions `main.py`, which is a good starting point. These tests are
    very simple, and like unit tests, they can be run individually using the green
    arrows. If you want to run all the tests in the file, you can use the toolbar
    **(2)**, which has a button with two green arrows. There is also an environment
    selector, which we’ll come back to soon. Position **(5)** shows a link that gives
    you a set of examples that can be pasted into your test files. We’ll come back
    to that too. First, let’s exercise our test and see what it does. I’ll click the
    double arrow run button shown by the top arrow in *Figure 9**.8*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`http`测试文件不是代码，正如我们在[*第6章*](B19644_06.xhtml#_idTextAnchor145)中看到的，*无缝测试、调试和性能分析*。这是一个HTTP请求的规范。定位`main.py`，这是一个很好的起点。这些测试非常简单，就像单元测试一样，可以使用绿色箭头单独运行。如果你想运行文件中的所有测试，可以使用工具栏**（2**），其中有一个带有两个绿色箭头的按钮。还有一个环境选择器，我们很快就会回到它。**（5**）位置显示了一个链接，提供了可以粘贴到测试文件中的一组示例。我们也会回到那里。首先，让我们练习我们的测试并看看它做了什么。我会点击*图9.8*中顶部箭头所示的双箭头运行按钮：
- en: '![Figure 9.8: Click the double arrow to run all the tests and you’ll find they
    both fail! Oh no!](img/B19644_09_07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8：点击双箭头以运行所有测试，你会发现它们都失败了！哦，不！](img/B19644_09_07.jpg)'
- en: 'Figure 9.8: Click the double arrow to run all the tests and you’ll find they
    both fail! Oh no!'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：点击双箭头以运行所有测试，你会发现它们都失败了！哦，不！
- en: This isn’t good. Both of the tests fail spectacularly. I say *spectacularly*
    because PyCharm leaves no ambiguity. I see a red banner telling me my test failed.
    I see red text, by the lower arrow, telling me two tests failed. I see red Xs
    next to the test list. I see a message stating **Stopped. Tests failed 2 of 2**.
    If that isn’t enough, there is a log area that also lets you know your code missed
    the mark. In short, there are more red marks on this screen than there are on
    this chapter’s manuscript after the editor made their first pass! Trust me, that’s
    a lot! What in the world could be wrong? Why would PyCharm generate a failing
    test code like that in a *Hello* *World* example?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不好。两个测试都彻底失败了。我说“彻底失败”是因为PyCharm没有留下任何歧义。我看到一个红色的横幅告诉我测试失败了。我看到红色的文字，通过下方的箭头，告诉我两个测试失败了。我看到测试列表旁边的红色X。我看到一条消息说“停止。测试失败2个中的2个”。如果还不够，还有一个日志区域也会告诉你你的代码没有达到预期。简而言之，这个屏幕上的红色标记比编辑器第一次审阅后这一章的手稿上的还要多！相信我，那真的很多！究竟出了什么问题？为什么PyCharm会在一个“Hello
    World”示例中生成那样的失败测试代码？
- en: 'There’s nothing wrong with the code! In [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, we learned about unit testing. Unit
    tests comprise code that exercises the code you are testing using assertions.
    The HTTP file doesn’t contain code, and this is not unit testing, this is integration
    testing. These tests require a running server in order to work. Let’s try this
    again. Examine *Figure 9**.9* and follow along if you like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码没有问题！在[*第6章*](B19644_06.xhtml#_idTextAnchor145)，“无缝测试、调试和性能分析”中，我们学习了单元测试。单元测试由使用断言测试你正在测试的代码的代码组成。HTTP文件不包含代码，这不是单元测试，这是集成测试。这些测试需要运行中的服务器才能工作。让我们再试一次。查看*图9.9*并跟随操作，如果你愿意的话：
- en: '![Figure 9.9: You have to run the development server before you run the HTTP
    tests](img/B19644_09_08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9：在运行HTTP测试之前，你必须运行开发服务器](img/B19644_09_08.jpg)'
- en: 'Figure 9.9: You have to run the development server before you run the HTTP
    tests'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：在运行HTTP测试之前，你必须运行开发服务器
- en: Click the run button for the API project **(1)**. Then click the run button
    for the tests **(2)**. With the server running, all the tests will pass **(3)**.
    If they don’t, call JetBrains and ask for your money back. That probably won’t
    work, which is OK because your tests should pass.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 点击API项目的运行按钮**（1**）。然后点击测试的运行按钮**（2**）。服务器运行时，所有测试都将通过**（3**）。如果它们没有通过，请联系JetBrains并要求退款。这可能不会奏效，但这没关系，因为你的测试应该会通过。
- en: Examining the details of the return
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查返回的详细信息
- en: 'It isn’t enough to know we passed, because all that really means is both requests
    were made against the local development server, and both came back with a status
    code of `200`. What you really want, most of the time, is to be able to see the
    JSON data that came back on the response. Let’s go find that. Locate the output
    for the test and scroll down until you see a mention of a JSON file like the one
    shown in *Figure 9**.10*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们通过了测试是不够的，因为这实际上只意味着两个请求都是针对本地开发服务器进行的，并且都返回了状态码`200`。你真正想要的，大多数情况下，是能够看到响应中返回的JSON数据。让我们去找找看。找到测试的输出，向下滚动直到你看到类似*图9.10*中所示的JSON文件提及：
- en: '![Figure 9.10: Scroll through the log and find the links to the JSON files.
    Click them to open the data in the tabbed area in the editor](img/B19644_09_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10：在日志中滚动，找到指向JSON文件的链接。点击它们在编辑器的选项卡区域打开数据](img/B19644_09_09.jpg)'
- en: 'Figure 9.10: Scroll through the log and find the links to the JSON files. Click
    them to open the data in the tabbed area in the editor'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：在日志中滚动，找到指向JSON文件的链接。点击它们在编辑器的选项卡区域打开数据
- en: 'This section in the log window tells us all the details about the request and
    response made in the test. We can see the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 日志窗口中的这一部分告诉我们测试中请求和响应的所有详细信息。我们可以看到以下内容：
- en: The version of HTTP being used (1.1)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在使用的HTTP版本（1.1）
- en: The status code of the response (`200 OK`)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的状态码（`200 OK`）
- en: The date of the request
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的日期
- en: The server that generated the result (`uvicorn`)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成结果的服务器（`uvicorn`）
- en: The content type of the response (`application/json`)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的内容类型（`application/json`）
- en: The location where the test result was saved
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试结果保存的位置
- en: 'Yahtzee! PyCharm saved the result of the response in a JSON file that is date
    stamped, along with the status code, and presented it as a hyperlink in the log.
    If you click the link, the JSON file opens like any other text file in its own
    tab. In *Figure 9**.10*, I had to expand the log to be large enough to make for
    a good screenshot, but this obscured the contents of the open tab, so check out
    *Figure 9**.11* to see the return data in its tab having clicked the hyperlink
    in the log:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Yahtzee! PyCharm 将响应结果保存在一个带日期戳的 JSON 文件中，其中包含状态码，并在日志中以超链接的形式展示。如果您点击链接，JSON
    文件将像任何其他文本文件一样在其自己的标签页中打开。在 *图 9**.10* 中，我不得不将日志扩展到足够大，以便拍摄到良好的截图，但这掩盖了打开标签页的内容，因此请查看
    *图 9**.11* 以查看点击日志中的超链接后其标签页中的返回数据：
- en: '![Figure 9.11: The returned data appears in its own tab when you click the
    hyperlink](img/B19644_09_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11：点击超链接后，返回数据出现在其自己的标签页中](img/B19644_09_10.jpg)'
- en: 'Figure 9.11: The returned data appears in its own tab when you click the hyperlink'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11：点击超链接后，返回数据出现在其自己的标签页中
- en: 'If you notice, it says the file is saved, but it doesn’t appear in the project
    files. If you are wondering where it was saved, you can right-click the tab as
    indicated in *Figure 9**.12*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，它说文件已保存，但它没有出现在项目文件中。如果您想知道它在哪里保存，您可以按照 *图 9**.12* 中的指示右键单击标签页：
- en: '![Figure 9.12: Right-click the tab and use the Open In menu to open the location
    of the test result JSON file](img/B19644_09_11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12：右键单击标签页，使用“打开方式”菜单打开测试结果 JSON 文件的存储位置](img/B19644_09_11.jpg)'
- en: 'Figure 9.12: Right-click the tab and use the Open In menu to open the location
    of the test result JSON file'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：右键单击标签页，使用“打开方式”菜单打开测试结果 JSON 文件的存储位置
- en: 'The contents of the menu will differ depending on your operating system. You’re
    looking for the top option, which for me is **Files**, which is the default file
    manager in **Gnome 42**. Windows will have a reference to Explorer and macOS ought
    to have a reference to Finder. Clicking that option will show you the location
    in your OS-specific file manager. You can see mine in *Figure 9**.13*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的内容将根据您的操作系统而有所不同。您正在寻找的是顶部选项，对我来说是 **文件**，这是 **Gnome 42** 的默认文件管理器。Windows
    将有对资源管理器的引用，而 macOS 应该有对 Finder 的引用。点击该选项将在您特定的操作系统文件管理器中显示位置。您可以在 *图 9**.13*
    中看到我的：
- en: '![Figure 9.13: My file manager reveals the location for the HTTP response files,
    which is in the project’s .idea folder](img/B19644_09_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13：我的文件管理器显示了 HTTP 响应文件的存储位置，该位置在项目的 .idea 文件夹中](img/B19644_09_12.jpg)'
- en: 'Figure 9.13: My file manager reveals the location for the HTTP response files,
    which is in the project’s .idea folder'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：我的文件管理器显示了 HTTP 响应文件的存储位置，该位置在项目的 .idea 文件夹中
- en: 'As you can see, the test results are stored in the PyCharm project folder:
    the hidden `.idea` folder the IDE creates when you either create a new project
    or open a folder in PyCharm. Remember, any folder with a name beginning with a
    dot is hidden on a Mac or in Linux, but you can see them in Windows because Bill
    likes to be different. If you test often, as you should, these files might begin
    to stack up in numbers. I personally prefer to exclude these from my repositories.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试结果存储在 PyCharm 项目文件夹中：当您在 PyCharm 中创建新项目或打开文件夹时，IDE 创建的隐藏的 `.idea` 文件夹。请记住，任何以点开头的文件夹在
    Mac 或 Linux 上都是隐藏的，但在 Windows 上您可以看到它们，因为比尔喜欢与众不同。如果您经常测试，这些文件可能会开始以数量堆积。我个人更喜欢将它们排除在我的存储库之外。
- en: We just generated a new run configuration
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们刚刚生成了一个新的运行配置
- en: 'A neat side effect of running all tests from the test window is that PyCharm
    creates a new run configuration, which you will find in the run configuration
    dropdown shown in *Figure 9**.14*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试窗口运行所有测试的一个整洁副作用是 PyCharm 会创建一个新的运行配置，您可以在 *图 9**.14* 中所示的运行配置下拉菜单中找到：
- en: '![Figure 9.14: PyCharm created a new run configuration automatically following
    the first time we ran the HTTP tests](img/B19644_09_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14：在第一次运行 HTTP 测试后，PyCharm 自动创建了一个新的运行配置](img/B19644_09_13.jpg)'
- en: 'Figure 9.14: PyCharm created a new run configuration automatically following
    the first time we ran the HTTP tests'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：在第一次运行 HTTP 测试后，PyCharm 自动创建了一个新的运行配置
- en: 'If we edit the configuration, you can see more details, as seen in *Figure
    9**.15*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编辑配置，您可以看到更多详细信息，如图 *图 9**.15* 所示：
- en: '![Figure 9.15: Options for HTTP Request test runs can be found in the run configuration
    editor](img/B19644_09_14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15：HTTP 请求测试运行的选项可以在运行配置编辑器中找到](img/B19644_09_14.jpg)'
- en: 'Figure 9.15: Options for HTTP Request test runs can be found in the run configuration
    editor'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：HTTP请求测试运行的选项可以在运行配置编辑器中找到
- en: As you can see, you can opt to run individual requests or all the requests in
    the file. Running single requests is handy if you’re focusing on the code for
    one endpoint and you need to run it over and over. If you had many endpoints in
    the test, your tests might take a while to complete.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以选择运行单个请求或文件中的所有请求。如果你专注于一个端点的代码并需要反复运行它，运行单个请求就很有用。如果你在测试中有许多端点，你的测试可能需要一段时间才能完成。
- en: Using Before launch actions in run configurations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用运行配置中的“启动前操作”
- en: We’ve seen that every run of our HTTP tests generates a new JSON file containing
    the response. This can fill up a folder pretty quickly with hundreds of files.
    Since PyCharm gives us a run configuration, we have the opportunity to set up
    some automation to delete older files. In this section, we’ll explore some automation
    capabilities available in PyCharm’s run configuration settings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们每次运行HTTP测试都会生成一个新的包含响应的JSON文件。这可能会很快让文件夹里充满数百个文件。由于PyCharm为我们提供了运行配置，我们有设置一些自动化来删除旧文件的机会。在本节中，我们将探讨PyCharm运行配置设置中可用的自动化功能。
- en: To do this you’ll need a script to delete the JSON files as you see fit. Perhaps
    you want to delete everything older than a week, or maybe you just want to keep
    the last 25 runs. This part is up to you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要一个脚本来删除你想要的JSON文件。也许你想要删除一周之前的所有文件，或者你可能只想保留最后25次运行。这部分取决于你。
- en: 'In order to automate this, you need to create a shell script for your operating
    system. If you aren’t a shell scripting guru, that’s OK, because modern artificial
    intelligence can come to your rescue. *Figure 9**.16* shows me asking ChatGPT
    to create a shell script for the Bash shell that keeps only the last 25 JSON files
    generated by our test runs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这个过程，你需要为你的操作系统创建一个shell脚本。如果你不是shell脚本高手，那没关系，因为现代人工智能可以来帮助你。*图9.16*显示了我是如何请求ChatGPT为Bash
    shell创建一个只保留我们测试运行生成的最后25个JSON文件的shell脚本的：
- en: '![Figure 9.16: I’ve asked ChatGPT about a few different ways to delete old
    files and it has generated a script for me](img/B19644_09_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16：我询问ChatGPT关于删除旧文件的一些不同方法，并为我的需求生成了一个脚本](img/B19644_09_15.jpg)'
- en: 'Figure 9.16: I’ve asked ChatGPT about a few different ways to delete old files
    and it has generated a script for me'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：我询问ChatGPT关于删除旧文件的一些不同方法，并为我的需求生成了一个脚本
- en: I realize you can’t see the whole script for Bash in the figure, so I’ll be
    sure to include it in the project source for this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到你无法在图中看到Bash脚本的全部内容，所以我将确保将其包含在本章的项目源代码中。
- en: Warning – never run generated scripts you don’t understand!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 - 永远不要运行你不理解的生成脚本！
- en: You should never blindly run a script generated by ChatGPT or anything (or anyone)
    else, including or even especially me, without fully understanding how it works!
    ChatGPT will probably not give you the same result it gave me, so exercise caution
    when running any script it gives you. Be especially wary if the script includes
    anything like `-Force` switches, as in the PowerShell script in the figure. If
    you don’t know what the script does, don’t run it on your computer!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝不应该在没有完全理解其工作原理的情况下盲目运行由ChatGPT或其他任何东西（或任何人）生成的脚本！ChatGPT可能不会给你和我相同的结果，所以在运行它给出的任何脚本时要格外小心。如果脚本中包含类似`-Force`这样的开关，就像图中的PowerShell脚本那样，更要特别小心。如果你不知道脚本做什么，不要在你的电脑上运行它！
- en: To use the generated code, you can just add a new file to your project as you
    would any other. I’m going to right-click my project in the `Project` window and
    create a new file called `delete-old-http-test-results.sh`. Naturally, if you
    are on Windows, you’ll want to use PowerShell, which typically bears an extension
    of `.ps1`, so it would be `delete-old-http-test-results.ps1`. Copy the script
    generated by the AI once you fully understand the ramifications of running said
    script and save the file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用生成的代码，你只需像添加其他任何文件一样将新文件添加到你的项目中。我将在“项目”窗口中右键单击我的项目，创建一个名为`delete-old-http-test-results.sh`的新文件。当然，如果你使用的是Windows，你将想要使用PowerShell，它通常有一个`.ps1`的扩展名，所以它将是`delete-old-http-test-results.ps1`。一旦你完全理解运行该脚本的影响，就复制AI生成的脚本并保存文件。
- en: Make sure the script has run permissions
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 确保脚本具有运行权限
- en: Make sure the script file you create has permission to run on your computer.
    Most editions of Windows heavily restrict running any PowerShell script, and your
    ability to do this might even be restricted by your employer’s security policy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你创建的脚本文件有权限在你的计算机上运行。大多数版本的 Windows 严格限制运行任何 PowerShell 脚本，而你执行此操作的能力甚至可能受到你雇主的安全策略的限制。
- en: 'On Mac and Linux, you might need to run this in a terminal before PyCharm will
    execute the script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 和 Linux 上，你可能需要在 PyCharm 执行脚本之前在终端中运行此命令：
- en: '`chmod +``x delete-old-http-test-results.sh`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod +x delete-old-http-test-results.sh`'
- en: If you can’t run the script manually, it probably won’t work in PyCharm either.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法手动运行脚本，那么它可能也无法在 PyCharm 中运行。
- en: 'Next, we need to create a run configuration that executes the script. Click
    the run configuration dropdown and click **Edit Configurations**. If you don’t
    remember how to do this, review [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052),
    *Customizing Interpreters and Virtual Environments*. Add a new run configuration
    using the Shell Script template. You can see mine in *Figure 9**.17*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个执行脚本的运行配置。点击运行配置下拉菜单并点击 **编辑配置**。如果你不记得如何操作，请回顾 [*第 3 章*](B19644_03.xhtml#_idTextAnchor052)，*自定义解释器和虚拟环境*。使用
    Shell 脚本模板添加一个新的运行配置。你可以在 *图 9**.17* 中看到我的配置：
- en: '![Figure 9.17: Create a run configuration for the shell script we just created](img/B19644_09_16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17：为刚刚创建的 shell 脚本创建一个运行配置](img/B19644_09_16.jpg)'
- en: 'Figure 9.17: Create a run configuration for the shell script we just created'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：为刚刚创建的 shell 脚本创建一个运行配置
- en: 'You can navigate to the shell script using the folder button in the `httpRequests`
    folder inside the project’s `.idea` folder. Click the folder icon in the **Working
    directory** textbox to browse this folder. If you are not on Windows, this will
    be a hidden folder, so be sure to turn on viewing hidden folders in the selection
    dialog as I did in *Figure 9**.18*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过项目 `.idea` 文件夹中的 `httpRequests` 文件夹中的文件夹按钮来导航到 shell 脚本。点击 **工作目录** 文本框中的文件夹图标来浏览此文件夹。如果你不在
    Windows 上，这将是一个隐藏文件夹，所以请确保在选择对话框中像我一样打开查看隐藏文件夹，如图 *图 9**.18* 所示：
- en: '![Figure 9.18: To find the httpRequests folder inside the .idea folder, you
    need to turn on hidden folders by clicking the eyeball (ouch) on the top toolbar](img/B19644_09_17.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18：为了找到 .idea 文件夹中的 httpRequests 文件夹，你需要通过点击顶部工具栏上的眼睛图标（ouch）来打开隐藏文件夹](img/B19644_09_17.jpg)'
- en: 'Figure 9.18: To find the httpRequests folder inside the .idea folder, you need
    to turn on hidden folders by clicking the eyeball (ouch) on the top toolbar'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：为了找到 .idea 文件夹中的 httpRequests 文件夹，你需要通过点击顶部工具栏上的眼睛图标（ouch）来打开隐藏文件夹
- en: You now have a run configuration that executes your `delete` script. You should
    test it. Run your tests 26 more times, and verify you only have the last 25 results
    in your `httpRequests` folder. I’ll show you my results in the next 25 full-page
    color screenshots. Just kidding. Sometimes it’s fun to scare my editors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有一个执行你的 `delete` 脚本的运行配置了。你应该测试它。运行你的测试 26 次，并验证你 `httpRequests` 文件夹中只有最后
    25 个结果。我将在接下来的 25 张全页彩色屏幕截图中展示我的结果。开玩笑的。有时候吓唬我的编辑也很有趣。
- en: 'If it works, and you’re happy, then there’s one more thing you can do to make
    it extra awesome. You can chain your delete script run configuration with your
    test run configuration. Edit the run configuration for the tests and add a `Before
    build` condition. Click the **+** button to add a new condition. Click **Run another
    run configuration**. Click **Delete Old HTTP Results run configuration**. You
    should see something like *Figure 9**.19*, which shows the deletion script will
    run before each new test run:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，并且你感到满意，那么你还可以做一件事来让它更加出色。你可以将你的删除脚本运行配置与你的测试运行配置链式连接。编辑测试的运行配置并添加一个“在构建之前”条件。点击
    **+** 按钮添加一个新条件。点击 **运行另一个运行配置**。点击 **删除旧 HTTP 结果运行配置**。你应该会看到类似于 *图 9**.19* 的内容，它显示删除脚本将在每次新的测试运行之前运行：
- en: '![Figure 9.19: The deletion run configuration will now run before each launch
    of my tests](img/B19644_09_18.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19：删除运行配置现在将在每次测试启动之前运行](img/B19644_09_18.jpg)'
- en: 'Figure 9.19: The deletion run configuration will now run before each launch
    of my tests'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19：删除运行配置现在将在每次测试启动之前运行
- en: 'For the sake of the book, I changed my retention number to the last five JSON
    files and tried it out. After each run, I can look in my file browser, shown in
    *Figure 9**.20*, and see whether it’s working:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我将我的保留数量更改为最后五个 JSON 文件并尝试了一下。每次运行后，我可以在我的文件浏览器中查看，如图 *图 9**.20* 所示，看看它是否在运行：
- en: '![Figure 9.20: After my run, there are seven JSON files since the delete script
    reduces the file count to five before the run, and the test produces results for
    two endpoints](img/B19644_09_19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20：运行后，由于删除脚本在运行前将文件数量减少到五个，并且测试为两个端点生成结果，因此有七个JSON文件](img/B19644_09_19.jpg)'
- en: 'Figure 9.20: After my run, there are seven JSON files since the delete script
    reduces the file count to five before the run, and the test produces results for
    two endpoints'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：运行后，由于删除脚本在运行前将文件数量减少到五个，并且测试为两个端点生成结果，因此有七个JSON文件
- en: You’ll only ever have at most 25 results in your folder, or however many you
    specified in your script! Don’t forget, though, the deletion script runs first
    and PyCharm will generate one new JSON file for each tested endpoint. If I set
    my delete script to retain five JSON files and I run the generated test script,
    I’ll have seven files after the run since there are two endpoints being tested.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你文件夹中最多只有25个结果，或者你脚本中指定的那么多！不过，别忘了，删除脚本首先运行，PyCharm将为每个测试端点生成一个新JSON文件。如果我将我的删除脚本设置为保留五个JSON文件，并且运行生成的测试脚本，那么运行后我将有七个文件，因为有两个端点正在被测试。
- en: Using this technique, you can enable a great many automation scenarios for your
    code. Python doesn’t generally have a build script, like many languages, so it’s
    nice to know you have this level of automation available in the IDE itself. There
    were several options besides running another run configuration. I recommend you
    explore all the possibilities!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，你可以为你的代码启用许多自动化场景。Python通常没有像许多其他语言那样的构建脚本，所以知道你可以在IDE本身中拥有这种自动化水平是件好事。除了运行另一个运行配置之外，还有几个选项。我建议你探索所有可能性！
- en: Working with HTTP Request environments
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与HTTP请求环境一起工作
- en: Most web projects begin their life on a developer’s computer. When you test,
    you run your application locally on your laptop or PC, and all of your test requests
    are usually going to localhost, which is the loopback address assigned to every
    computer with a network card. The project starts out there, but assuming the app
    enjoys any level of success, it will not stay there.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web项目最初是在开发者的电脑上开始的。当你测试时，你会在你的笔记本电脑或PC上本地运行你的应用，而你所有的测试请求通常都会发送到localhost，这是分配给每个带有网络卡的电脑的回环地址。项目从这里开始，但假设应用达到任何程度的成功，它将不会停留在那里。
- en: Best practice dictates that applications intended for publication should use
    some sort of **continuous integration** (**CI**) environment where automated tests
    can be run. In fact, JetBrains makes a CI product called Team City. I used Team
    City for many years and can attest that it is an excellent CI system that is easy
    to set up, and it is free for small teams. These days, there is even a cloud version,
    so you needn’t set up your own servers if that’s not your thing. Team City, though,
    has the same plugin we’ve been using to create tests for our HTTP endpoints in
    our FastAPI project. This allows you to test your project automatically every
    time someone commits code to your source repository.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践规定，打算发布的应用应该使用某种**持续集成**（CI）环境，以便运行自动化测试。实际上，JetBrains有一个名为Team City的CI产品。我使用Team
    City多年，可以证明它是一个易于设置且免费的优秀CI系统，适用于小型团队。如今，甚至还有一个云版本，所以如果你不想设置自己的服务器，你也不必这么做。然而，Team
    City拥有我们一直在使用的插件，用于在FastAPI项目中为我们的HTTP端点创建测试。这允许你在有人向你的源代码库提交代码时自动测试你的项目。
- en: 'Once your code passes muster with the CI system, it is common for the code
    to be deployed to a testing server. This should be a server that is as much like
    production as you can manage. Some people call this a staging server, some call
    it **user acceptance test** (**UAT**). No matter what you call it, it represents
    an environment. Production too is an environment. An environment is simply a configuration
    environment where you can run your code. To be clear, so far, we’ve mentioned
    four such environments:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码通过了CI系统的审查，通常会将代码部署到测试服务器。这应该是一个尽可能接近生产环境的服务器。有些人称之为预发布服务器，有些人称之为**用户验收测试**（UAT）。无论你叫它什么，它代表了一个环境。生产环境也是一个环境。环境简单来说就是一个配置环境，你可以在其中运行你的代码。为了清楚起见，到目前为止，我们已经提到了四种这样的环境：
- en: Your local computer (localhost)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的本地电脑（localhost）
- en: A CI environment, which these days is probably a Docker container
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CI环境，这些天可能是一个Docker容器
- en: A UAT/staging environment where you can test your app before you release it
    to production
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个UAT/预发布环境，你可以在将应用发布到生产环境之前对其进行测试
- en: A production environment where your real customers use your app
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个生产环境，你的真实客户在这里使用你的应用
- en: Each of these environments might have different attributes. For example, your
    FastAPI app running on your laptop can be accessed using the IP address `127.0.0.1`.
    By default, the app runs on port `8000`, and also by default, the protocol used
    is HTTP and not HTTPS since few developers take the time to set up an SSL/TLS
    certificate on their laptops.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境中的每一个可能都有不同的属性。例如，您在笔记本电脑上运行的 FastAPI 应用程序可以通过 IP 地址 `127.0.0.1` 访问。默认情况下，应用程序在端口
    `8000` 上运行，并且默认情况下，使用的协议是 HTTP 而不是 HTTPS，因为很少有开发者在他们的笔记本电脑上花费时间设置 SSL/TLS 证书。
- en: However, when you test your application in staging, all of those parameters
    are different. You probably will have an SSL certificate, so you’ll use HTTPS
    as your protocol. You’ll definitely have a different IP address. You might even
    have a domain name server resolving a nice test domain name for your app. You
    probably won’t be using port `8000` since that would not be very production-like.
    Instead, you’ll be using port `443` or `80`, and in that case, you needn’t necessarily
    fill in the port at all.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您在预发布环境中测试您的应用程序时，所有这些参数都不同。您可能有一个 SSL 证书，所以您将使用 HTTPS 作为协议。您肯定有一个不同的 IP
    地址。您甚至可能有一个域名服务器解析一个漂亮的测试域名供您的应用程序使用。您可能不会使用端口 `8000`，因为这不太像生产环境。相反，您将使用端口 `443`
    或 `80`，在这种情况下，您可能根本不需要填写端口。
- en: The production too will have different attributes again.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境也将有不同的属性。
- en: 'In our API tests, we are able to configure a set of variables to be used in
    our test script, which are assigned to an environment name. Make sure you have
    the `test_main.http` file, or any `.http` file. Click the environment dropdown
    shown in *Figure 9**.21*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 API 测试中，我们能够配置一组变量用于我们的测试脚本，这些变量被分配给一个环境名称。请确保您有 `test_main.http` 文件，或任何
    `.http` 文件。点击 *图 9**.21* 中显示的环境下拉菜单：
- en: '![Figure 9.21: You can select an environment for running your tests each with
    it’s own configuration variables](img/B19644_09_20.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21：您可以为运行您的测试选择一个具有各自配置变量的环境](img/B19644_09_20.jpg)'
- en: 'Figure 9.21: You can select an environment for running your tests each with
    it’s own configuration variables'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21：您可以为运行测试选择一个具有各自配置变量的环境
- en: 'I’ll be honest. I worked ahead and set one up, but we’ll pretend I didn’t.
    Right now, your only option is `http-client.env.json`. You can see mine in *Figure
    9**.22*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我会坦白。我提前工作并设置了一个，但我们假装我没有。现在，您唯一的选择是 `http-client.env.json`。您可以在 *图 9**.22*
    中看到我的：
- en: '![Figure 9.22: PyCharm created http-client.env.json, which will allow me to
    set up different environments for testing](img/B19644_09_21.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22：PyCharm 创建了 http-client.env.json，这将允许我为测试设置不同的环境](img/B19644_09_21.jpg)'
- en: 'Figure 9.22: PyCharm created http-client.env.json, which will allow me to set
    up different environments for testing'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22：PyCharm 创建了 http-client.env.json，这将允许我为测试设置不同的环境
- en: If you had chosen the `http-client-private.env.json`. The purpose of and difference
    between the two files isn’t in the documentation as I write this, so we’ll have
    to use our imaginations. Personally, I put environments I want to share with my
    development team in the public file. If I want to create some sort of private
    environment, maybe a virtual machine, Windows Subsystem for Linux, custom experiments
    in Docker, or maybe a Kubernetes cluster in a lab, I can use the private file,
    which I would likely put in my `.gitignore` file. Since the file contents are
    the same, I’ll focus on the public file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择了 `http-client-private.env.json`。这两个文件的目的和区别在我写这篇文档时并未在文档中说明，所以我们将发挥想象力。我个人将我想与我的开发团队共享的环境放在公共文件中。如果我想创建某种私有环境，比如虚拟机、Windows
    Subsystem for Linux、Docker 中的自定义实验，或者可能在实验室中的 Kubernetes 集群，我可以用私有文件，我可能会将其放在我的
    `.gitignore` 文件中。由于文件内容相同，我将专注于公共文件。
- en: 'I’m going to add a definition for my local computer. Change the contents of
    `http-client.env.json` to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加一个定义用于我的本地计算机。将 `http-client.env.json` 的内容更改为以下内容：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now have a dev environment set up with some environment variables. Let’s
    use them in our `test_main.http` file. Your first endpoint definition looks like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有一些环境变量的开发环境。让我们在 `test_main.http` 文件中使用它们。您的第一个端点定义看起来像这样：
- en: 'To use the environment variables, replace the parts of your URL with mustache-formatted
    text. Mustache format entails putting the variables you want to resolve in double
    curly braces like {{ this }}:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用环境变量，请将您的 URL 中的部分替换为 mustache 格式的文本。Mustache 格式意味着将您想要解析的变量放在双大括号中，例如 {{
    this }}：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Taken together, the URL will resolve to the original, which is [http://localhost:8000](http://localhost:8000),
    or if you prefer, [http://127.0.0.1:8000](http://127.0.0.1:8000). To*may*to to*mah*to.
    The difference is, now you can create your other environments in the same way.
    You can switch the environment and run the tests unchanged, and the environment
    variables will resolve your URLs for you.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 结合起来，URL 将解析为原始地址，即 [http://localhost:8000](http://localhost:8000)，或者如果您更喜欢，[http://127.0.0.1:8000](http://127.0.0.1:8000)。现在您可以用同样的方式创建其他环境。您可以在不更改测试的情况下切换环境并运行测试，环境变量会为您解析
    URL。
- en: If you review my code in this chapter’s sample code, you’ll find I’ve tricked
    out the whole file this way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看本章示例代码中的我的代码，您会发现我以这种方式对整个文件进行了修改。
- en: Let’s get CRUDdier and then get testier!
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们变得更加 CRUD（创建、读取、更新、删除），然后再进行测试！
- en: Right now, the only thing in our app is two pre-generated endpoints. Let’s add
    some more to make this a little more interesting. We’re going to make a fake list
    app as we did in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203), *Building a
    Dynamic Web Application* *with Flask*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应用中唯一的东西是两个预生成的端点。让我们再添加一些，使这个应用更有趣。我们将创建一个假名单应用，就像我们在[*第8章*](B19644_08.xhtml#_idTextAnchor203)中做的那样，*使用
    Flask 构建动态 Web 应用*。
- en: Open up `main.py` and let’s add one endpoint for each CRUD operation, and in
    turn, each of the four main methods used in building RESTful APIs. We’re going
    to make some sweeping changes, so I’ll simply present them starting at the top
    of the file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `main.py` 并为每个 CRUD 操作添加一个端点，以及构建 RESTful API 时使用的四个主要方法。我们将进行一些重大更改，所以我会从文件顶部开始简单介绍它们。
- en: 'On the first line, where we have the import, change it to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将导入的地方改为这个：
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The app instantiate was unchanged. Below it, though, add this list of amazing
    people:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应用实例化没有变化。不过，下面添加这个令人惊叹的人名单：
- en: '[PRE8]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This list will serve as a fake database, saving us the time of setting up servers
    and the blah blah blah, which would seriously bloat the book and not contribute
    to our soon-to-be champion-level PyCharm prowess. We’re going to leave the first
    two generated endpoints alone, so just start your editing below the `say_hello`
    function’s return. Our first CRUD endpoint is going to give us a list of names
    as if from a database query:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表将作为假数据库使用，节省我们设置服务器和等等的时间，这会严重膨胀书籍，并且不会对我们的即将成为冠军级的 PyCharm 技能做出贡献。我们将保留前两个生成的端点不变，所以请在
    `say_hello` 函数的返回下面开始编辑。我们的第一个 CRUD 端点将提供一个类似从数据库查询得到的名单：
- en: '[PRE9]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is best practice to start the endpoints in your project, which are expected
    to return JSON data, rather than markup, with a prefix of `API` followed by a
    version designation. Trust me when I say that you want to do this. As your API
    code matures, you may want to offer updated endpoints that may not necessarily
    be backward compatible, and this technique allows you to keep your API backward
    compatible and non-breaking with your older clients while introducing improved
    functionality for newer clients. As the code matures further, you can remove the
    `v1` endpoints at a time of your choosing:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目中启动预期返回 JSON 数据的端点，而不是标记，使用前缀 `API` 后跟版本标识符，这是一种最佳实践。当我说您想这样做时，请相信我。随着您的
    API 代码成熟，您可能希望提供更新的端点，这些端点可能不一定与旧客户端向后兼容，而这种技术允许您在为较新客户端引入改进功能的同时，保持 API 与旧客户端向后兼容且不会中断。随着代码进一步成熟，您可以在您选择的时间逐步删除
    `v1` 端点：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the preceding `POST` endpoint, it is a best practice for the successful
    call to return an HTTP status code of `201` indicating new data was created by
    the API. The FastAPI code works very differently from Flask. Instead of discrete
    request and response objects, everything is implicit. If you are expecting JSON
    to be posted as a payload to your API, you need only specify this using an argument
    type of `dict`. In this case, I am expecting data to be posted in this format:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `POST` 端点中，对于成功的调用返回 HTTP 状态码 `201`，表示 API 创建了新数据，这是一种最佳实践。FastAPI 的工作方式与
    Flask 非常不同。它没有离散的请求和响应对象，一切都是隐式的。如果您期望将 JSON 作为有效载荷发布到您的 API，您只需指定一个 `dict` 类型的参数即可。在这种情况下，我期望以以下格式发布数据：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A real app would have a richer structure. We’re keeping it simple. When this
    JSON comes in as the payload for `POST`, we extract the name and append it to
    our list. For the sake of simplicity, I am not doing any validation on this endpoint.
    You should always validate your incoming data to protect yourself against toxic
    data and injection attacks. That’s the subject of another book. With that said,
    I won’t be a total slouch. I’ll do a little bit of this in the `PUT` endpoint,
    so you can see what some of this would look like. Remember, a `PUT` call is an
    `UPDATE` operation. We’re taking an `id` value and a new `name` value and we’ll
    change the existing value accordingly. Add these lines below your `create_name`
    function return:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的应用程序会有更丰富的结构。我们保持简单。当这个JSON作为`POST`的负载进来时，我们提取名字并将其添加到我们的列表中。为了简化，我在这端点没有进行任何验证。你应该始终验证你的输入数据，以保护自己免受有毒数据和注入攻击。这是另一本书的主题。话虽如此，我不会完全偷懒。我会在`PUT`端点做一点，这样你可以看到一些这样的样子。记住，`PUT`调用是一个`UPDATE`操作。我们正在获取一个`id`值和一个新的`name`值，并将相应地更改现有值。在你的`create_name`函数返回下面添加这些行：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now back to the code. Let’s make sure the ID attribute submitted is a number,
    specifically an integer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到代码。让我们确保提交的ID属性是一个数字，具体来说是一个整数：
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What’s happening here? If you submit an ID attribute that doesn’t resolve to
    a number, I’m going to send you back an HTTP error status code of `400`, which
    means your request is malformed. Just to be nice, I’m going to add a little message
    telling you what you did wrong. For example, say you use `PUT` on this data as
    follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？如果你提交了一个无法解析为数字的ID属性，我会给你返回一个HTTP错误状态码`400`，这意味着你的请求格式不正确。为了表示友好，我会添加一条消息告诉你你做错了什么。例如，假设你这样使用`PUT`：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Everything should work. But say you use `PUT` for the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该正常工作。但是，如果你使用以下`PUT`：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Your request will fail. Raising the HTTP extension will cause the response
    to be sent immediately, and the rest of this code isn’t executed. So, let’s continue.
    If you submitted good data, we can move on and grab the new name:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你的请求将会失败。提升HTTP扩展会导致响应立即发送，并且这段代码的其余部分不会执行。所以，让我们继续。如果你提交了良好的数据，我们可以继续并获取新的名字：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we detect whether the numeric ID you submitted isn’t out of range. Our
    list starts off with four names in it. If you try to send an update to `id` 600,
    that shouldn’t work unless you’ve added at least as many names to the list via
    the `POST` endpoint. In a `PUT`, if you present an invalid `id` value, it is customary
    to send back a `404` error stating you couldn’t find that ID in your database
    (or list in our case):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检测你提交的数字ID是否超出了范围。我们的列表最初包含四个名字。如果你尝试向`id` 600发送更新，除非你通过`POST`端点至少添加了同样多的名字到列表中，否则这是不应该工作的。在`PUT`中，如果你提供了一个无效的`id`值，通常的做法是返回一个`404`错误，表示你无法在数据库（或在我们的情况下是列表）中找到该ID：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That’s three down and only one to go. For the `DELETE` endpoint, all I need
    is `id`. Sending a JSON payload for something this simple would be silly, so I’ll
    just take the ID as a parameter on the endpoint URL. I still need to check to
    make sure it is within range of the length of the `names` list:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 已经完成了三个，只剩下一个。对于`DELETE`端点，我只需要`id`。为这样简单的事情发送JSON负载是愚蠢的，所以我将只从端点URL中获取ID。我仍然需要检查它是否在`names`列表的长度范围内：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If it is, then I’ll just pop it out of the list and return a nice message:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我就会直接从列表中移除它，并返回一条友好的消息：
- en: '[PRE19]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the app and make sure it starts. Make any adjustments needed. Remember,
    the final working code is in the chapter’s sample code from the repository we
    checked out in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并确保它启动。进行必要的调整。记住，最终的代码在本书的示例代码中，位于我们从仓库中检出[*第2章*](B19644_02.xhtml#_idTextAnchor028)的示例代码中。
- en: Getting testier
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变得更加挑剔
- en: If I were all cruddy, chances are I’d be pretty testy, right? Now that we have
    more varied endpoints, let’s learn more about testing them with HTTP clients.
    As it turns out, the tool is extremely rich, as rich as dedicated tools such as
    Insomnia or Postman, just without all that UI in the way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我心情不好，可能会很烦躁，对吧？现在我们有更多样化的端点，让我们学习如何使用HTTP客户端测试它们。事实上，这个工具非常丰富，就像Insomnia或Postman这样的专用工具一样丰富，只是没有那么多UI界面阻碍。
- en: Open your `test_main.http` file and let us add tests. Not just simple ones,
    let’s make some real ones and get a feel for how the PyCharm workflow helps you
    build RESTful APIs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`test_main.http`文件，让我们添加一些测试。不仅仅是简单的测试，让我们做一些真正的测试，感受一下PyCharm工作流程如何帮助你构建RESTful
    API。
- en: These testing features of PyCharm work with any framework
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm的这些测试功能与任何框架都兼容
- en: I should mention that while we’re using FastAPI, these features are not unique
    or tied to that framework. These tools would work the same if you developed your
    API in Flask, or even in some other framework.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到，虽然我们正在使用FastAPI，但这些功能并不是独特的或与该框架相关联。如果你在Flask或其他框架中开发API，这些工具也会以相同的方式工作。
- en: 'So far, you just have two tests, which were generated when you created your
    project:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只有两个测试，这些测试是在你创建项目时生成的：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I didn’t specifically tell you to modify the second test endpoint with the
    environment variables we made earlier, but I went ahead and did it since that
    seems like an obvious improvement. As you add code to the test file, there are
    a few things worth noting:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有明确要求你使用我们之前创建的环境变量修改第二个测试端点，但我还是做了，因为这看起来像是一个明显的改进。随着你向测试文件添加代码，有几个值得注意的事项：
- en: Requests may be stored in files with either `.http` or `.rest` extensions. So
    far, we’ve worked with the `.http` file that was generated with the project. In
    the wild, you may see either extension and there is no fundamental difference
    between them other than the icons displayed in the IDE. This is purely cosmetic.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求可以存储在具有`.http`或`.rest`扩展名的文件中。到目前为止，我们使用的是与项目一起生成的`.http`文件。在野外，你可能看到任一扩展名，它们之间除了在IDE中显示的图标外，没有根本的区别。这完全是装饰性的。
- en: Code highlighting and syntax completion are active. The syntax of these files
    is specialized, but you can expect the same level of tooling here as you would
    anywhere else.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码高亮和语法补全都是激活的。这些文件的语言是专业的，但你可以期待在这里获得与其他任何地方相同级别的工具。
- en: Inline documentation will also appear for the code in this file.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件中的代码也将显示内联文档。
- en: 'Requests must be separated by three hashtag/pound signs: `###`. If you fail
    to add these, the IDE will let you know with a sea of red squiggly lines.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求必须通过三个井号/磅符号（`###`）进行分隔。如果你没有添加这些符号，IDE会通过一片红色的波浪线来提醒你。
- en: You can paste a command-line cURL command into this file, and it will automatically
    convert it to the syntax used by PyCharm.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将命令行cURL命令粘贴到这个文件中，它将自动将其转换为PyCharm使用的语法。
- en: Templating is supported. We’ve already seen the environment variable substitution
    at work. Stay tuned, it’s about to get amazing!
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持模板。我们已经看到了环境变量替换在起作用。请保持关注，它即将变得非常精彩！
- en: 'The test editor has a little bit of UI to it, but to be honest, once you learn
    the syntax, you probably won’t use it. Let me show you. Refer to *Figure 9**.23*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 测试编辑器有一点点用户界面，但说实话，一旦你学会了语法，你可能就不会使用它。让我给你展示一下。参见图9.23：
- en: '![Figure 9.23: The test editor has a minimal UI](img/B19644_09_22.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23：测试编辑器具有最小化的用户界面](img/B19644_09_22.jpg)'
- en: 'Figure 9.23: The test editor has a minimal UI'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：测试编辑器具有最小化的用户界面
- en: 'Let’s look at the numbers:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数字：
- en: The **+** icon at **(1)** allows you to add another test. To be honest, this
    is easier to do directly in the editor, but if you like clicking things, here’s
    your jam.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**（1）**处的**+**图标允许你添加另一个测试。说实话，直接在编辑器中这样做更容易，但如果你喜欢点击东西，这里就是你的选择。'
- en: The clock icon `httpRequests` folder inside the `.idea` project folder. Since
    PyCharm automatically reloads files when they change, leaving this file open allows
    you to see everything that is happening without having to look at the individual
    response files. Earlier, we added automation to remove many of these response
    files since there are often so many of them. This doesn’t affect the log file
    since the request information is appended from the log window instead of the response
    file itself. In fact, the log shows the response data too.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.idea`项目文件夹内的`httpRequests`文件夹中有一个时钟图标。由于PyCharm在文件更改时会自动重新加载文件，所以保持此文件打开状态可以让你看到所有发生的事情，而无需查看单个响应文件。之前，我们添加了自动化功能来删除许多这些响应文件，因为通常会有很多。这不会影响日志文件，因为请求信息是从日志窗口而不是响应文件本身附加的。实际上，日志也显示了响应数据。
- en: Pro tip – open the log in a split view so you can always see it
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 高级技巧 - 在拆分视图中打开日志，这样你就可以始终看到它
- en: If you right-click the tab containing the log file and select one of the split
    options, such as **Split Right**, the tab will open in a separate tab group. If
    you have a nice wide 4K monitor, you have plenty of room to keep the log open
    alongside your code and test files so you can see it all together.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键单击包含日志文件的选项卡并选择拆分选项之一，例如**拆分右侧**，则选项卡将在单独的选项卡组中打开。如果你有一个宽大的4K显示器，你有很多空间同时打开日志、代码和测试文件，以便你可以一起查看它们。
- en: The document icon at **(3)** is there to make command-line mavens happy. If
    you select a request and click this button, you are able to generate a cURL command,
    which can then be pasted into a terminal window. The import icon at **(4)** gives
    you a UI where you can paste a cURL command whereupon it will be converted to
    the request format used by PyCharm. This isn’t all that useful since you can paste
    a cURL command directly into the editor itself and the conversion happens automatically.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**（3）**处的文档图标是为了让命令行爱好者感到高兴。如果您选择一个请求并点击此按钮，您就可以生成一个cURL命令，然后可以将其粘贴到终端窗口中。**（4）**处的导入图标为您提供了一个UI，您可以将cURL命令粘贴到其中，然后它将被转换为PyCharm使用的请求格式。这并不是特别有用，因为您可以直接将cURL命令粘贴到编辑器中，转换会自动发生。'
- en: 'We’ve already seen the **Run All Tests** button at **(5)**, as well as the
    environment selection dropdown. Probably, the most useful item on this toolbar,
    apart from the history log, is the link to the examples at **(6)**. This is not
    fancy, but it is useful. Clicking this link will open a file that contains a slew
    of examples that you can copy, paste, and modify. Essentially, this is the same
    thing that happens when you click the UI button at position **(1)**. To me, opening
    the samples is faster and easier because you can see them all in one place. To
    use it, just click the ***Examples** link as shown in *Figure 9**.24*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了**（5）**处的**运行所有测试**按钮，以及环境选择下拉菜单。除了历史日志之外，此工具栏上最有用的项目可能是**（6）**处的示例链接。这并不花哨，但很有用。点击此链接将打开一个包含大量示例的文件，您可以复制、粘贴并修改这些示例。本质上，这与您点击位置**（1）**处的UI按钮时发生的事情相同。对我来说，打开示例更快、更简单，因为您可以在一个地方看到所有内容。要使用它，只需点击如图*图9.24*所示的**示例**链接：
- en: '![Figure 9.24: The test examples are broken out by category](img/B19644_09_23.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24：测试示例按类别划分](img/B19644_09_23.jpg)'
- en: 'Figure 9.24: The test examples are broken out by category'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：测试示例按类别划分
- en: 'I like to use the `POST` requests sample open to the side, as in *Figure 9**.25*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用旁边的`POST`请求示例，如图*图9.25*所示：
- en: '![Figure 9.25: You can open the samples to the side for easy pasting](img/B19644_09_24.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25：您可以将示例打开到旁边以便轻松粘贴](img/B19644_09_24.jpg)'
- en: 'Figure 9.25: You can open the samples to the side for easy pasting'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：您可以将示例打开到旁边以便轻松粘贴
- en: To split the files like this, just right-click the tab and click **Split Right**,
    or left, up, or down according to your preferences.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要像这样拆分文件，只需右键单击选项卡并点击**拆分右侧**，或根据您的偏好选择左、上或下。
- en: Creating the tests
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试
- en: 'Let’s create those tests! Make sure you are working in `test_main.http`. Add
    these lines below your last test:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些测试！请确保您正在`test_main.http`中工作。在您的最后一个测试下方添加以下行：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The three hashtags are the separator between tests. The rest are variables
    coming from the environment variables we created earlier. This will translate
    to http://localhost:8000/api/v1/names. Make sure your app is running and run the
    test. You should see some results like those in *Figure 9**.26*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 三个井号（#）是测试之间的分隔符。其余的都是来自我们之前创建的环境变量的变量。这将转换为 http://localhost:8000/api/v1/names。请确保您的应用程序正在运行，并运行测试。您应该会看到像*图9.26*中那样的结果：
- en: '![Figure 9.26: When you run the test, you can see the response data in the
    log view. The left side of my results will normally look different than yours](img/B19644_09_25.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图9.26：当您运行测试时，您可以在日志视图中看到响应数据。我的结果左侧通常会与您的不同](img/B19644_09_25.jpg)'
- en: 'Figure 9.26: When you run the test, you can see the response data in the log
    view. The left side of my results will normally look different than yours'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：当您运行测试时，您可以在日志视图中看到响应数据。我的结果左侧通常会与您的不同
- en: 'This is nice, right? You can see you got back a good status code (`200`), and
    you can see your data. What if you could turn this into a proper test? You can!
    Go back to the `test_main.http` file. Every great moment in American, and perhaps
    world, history was preceded by the phrase I will utter next: *Hold my beer and*
    *watch this*.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '这很棒，对吧？您可以看到您得到了一个良好的状态码（`200`），并且您可以看到您的数据。如果您能将此转换为有效的测试怎么办？您可以！回到`test_main.http`文件。美国（也许是世界）历史上的每一个伟大时刻都
    precedes by the phrase I will utter next: *Hold my beer and* *watch this*。'
- en: 'Right below your test, add this code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试下方，添加以下代码：
- en: '[PRE22]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first character is crucial. You have to type a `>` followed by `{%`. If
    you don’t, PyCharm will become quite cross! Just stare at the majesty for a moment.
    Take it all in. What we have here is a test. WRITTEN IN JAVASCRIPT! I’m sorry.
    I should have warned you to sit down or something. I did, however, mention that
    beer was involved. There is some magic here. There is a `client` object inherent
    in this test window, not unlike the `window` object that is ever-present in a
    browser window. We’re invoking the `.test` method on that client object and we’re
    passing it two arguments. The first is a string that describes the test. This
    can be anything you’d like. The contents do not affect the test in any way. The
    second argument is an anonymous function that actually executes the test. If you’re
    not up on JavaScript’s use of lambda-style functions, you’re just going to have
    to roll with it and copy these tests from examples. I suppose you could also go
    learn JavaScript, but that might take a while. Thankfully, the `client.assert`
    part seems like the tests we wrote in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, so let’s keep going. The assert
    takes an expression that will evaluate to true or false. JavaScript uses a triple
    equals sign for testing equality without coercion. If you have not heard of this,
    for now, just know you should always be using three equals signs because using
    two means something else and you don’t want that. A double equals sign, which
    is the norm in Python, might yield a false failure in your JavaScript test code
    because JavaScript will attempt to force any data types it encounters to match.
    The triple equals avoid this.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符至关重要。你必须输入一个`>`后面跟着`{%`。如果不这样做，PyCharm会变得非常不高兴！只需暂时凝视一下它的庄严。全部吸收进去。这里有一个测试。用JavaScript编写的！很抱歉，我应该提醒你坐下或类似的事情。然而，我确实提到了啤酒。这里有一些魔法。在这个测试窗口中有一个固有的`client`对象，这与浏览器窗口中始终存在的`window`对象非常相似。我们在那个客户端对象上调用`.test`方法，并传递两个参数。第一个是一个描述测试的字符串。这可以是任何你想要的东西。内容不会以任何方式影响测试。第二个参数是一个匿名函数，它实际上执行了测试。如果你不熟悉JavaScript中lambda风格函数的使用，你只能照着例子复制这些测试。我想你也可以去学习JavaScript，但这可能需要一段时间。幸运的是，`client.assert`部分看起来就像我们在[*第6章*](B19644_06.xhtml#_idTextAnchor145)，“无缝测试、调试和性能分析”中编写的测试，所以让我们继续。断言接受一个将评估为真或假的表达式。JavaScript使用三个等号来测试不进行强制转换的相等性。如果你还没有听说过这个，现在，只需知道你应该始终使用三个等号，因为使用两个等号意味着其他事情，你不想那样。Python中常见的双等号可能会在JavaScript测试代码中产生错误的失败，因为JavaScript会尝试强制任何遇到的数据类型匹配。三个等号避免了这种情况。
- en: 'After the conditional statement, we have a JavaScript template literal. This
    is the equivalent of a Python `f`-string. You use the gravure marks for quotes.
    The gravure mark is the shifted tilde (~) on a US keyboard, and it looks like
    a heavy single quote: `. Enclosing a string within the gravure marks specifies
    the string to be a template literal. You can substitute expressions or variable
    values using `${whever}` in the curly braces. So, in Python, given the `foo =
    bar variable`, an `f`-string would be as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句之后，我们有一个JavaScript模板字符串。这相当于Python的`f`字符串。你使用引号标记。引号标记是美式键盘上按下的波浪号(~)，它看起来像重单引号：`.
    将字符串包围在引号标记内指定该字符串为模板字符串。你可以使用`${whever}`在花括号中替换表达式或变量值。所以，在Python中，给定`foo = bar
    variable`，一个`f`字符串将是这样的：
- en: '`f"I''d rather be at` `the {foo}."`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`f"I''d rather be at` `the {foo}."`'
- en: 'In JavaScript, given `const foo = "bar"`, it would be as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，给定`const foo = "bar"`，它将是这样的：
- en: '`` `I''d rather be at `` `` the ${foo}` ``'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `我宁愿在 `` `` ${foo}` ``'
- en: Here, I’ve used the template literal to give a little more information since
    this second string literally exposes a message seen when the test fails.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我使用了模板字符串来提供更多一点的信息，因为第二个字符串实际上暴露了测试失败时看到的消息。
- en: This particular test checks to make sure that the HTTP response code for the
    request was `200`, which indicates it was successful. If you don’t include a test
    like this, then your results will always be green even if your endpoint code melted
    the server and summoned the great Cthulu from his deep slumber at the heart of
    the cosmos. This is a test that should be included every single time, though the
    expected code might change depending on what you’re doing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的测试确保请求的HTTP响应代码是`200`，这表示它是成功的。如果你不包含这样的测试，那么即使你的端点代码熔化了服务器，从宇宙中心的深处召唤出伟大的克苏鲁，你的结果也总是绿色的。尽管预期的代码可能会根据你所做的事情而改变，但这种测试应该每次都包含在内。
- en: More tests you should always add
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该始终添加的更多测试
- en: 'Checking your status code is the bare minimum. I assert (see what I did there?)
    that you should check as many things as you can think of. Here, I’ll add a test
    to verify the returned data has a mime type of `application/json`, which is important
    to the way clients will consume this data. Add this below our earlier test:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的状态码是最基本的要求。我断言（看看我做了什么？）你应该检查尽可能多的事情。在这里，我将添加一个测试来验证返回的数据具有 `application/json`
    的 MIME 类型，这对于客户端如何消费这些数据非常重要。在下面的早期测试下方添加此内容：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember, it’s JavaScript! So here, I’ve added a constant called `type` and
    pulled the value from another magical object available in the test window. `response.contentType.mimeType`
    gives you exactly that. We test to make sure it is `"application/json"`. Personally,
    I think attention to detail is important, and I see APIs created by professionals
    as being very unprofessional if the content type isn’t set correctly. As it happens,
    FastAPI does this for us, but not every framework will.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是 JavaScript！所以在这里，我添加了一个名为 `type` 的常量，并从测试窗口中可用的另一个神奇对象中获取值。`response.contentType.mimeType`
    会给你这个值。我们测试以确保它是 `"application/json"`。我个人认为关注细节很重要，如果内容类型没有正确设置，我认为专业人士创建的 API
    非常不专业。碰巧的是，FastAPI 为我们做了这件事，但并非每个框架都会这样做。
- en: Now that you have the basics down, I invite you to explore my finished `test_main.http`
    file in the chapter’s sample code. There are tests there for all the conditions
    we put into the `PUT` endpoint allowing you to make sure the `400` status is returned
    if your user sends a non-numeric ID. There is also a test to make sure you get
    a `404` error if your ID is beyond the acceptable range for the `names` list.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了基础知识，我邀请您探索本章示例代码中的完成后的 `test_main.http` 文件。那里有针对我们放入 `PUT` 端点的所有条件的测试，以确保如果您的用户发送非数字
    ID，则返回 `400` 状态。还有一个测试来确保如果您的 ID 超出了 `names` 列表的可接受范围，您会得到 `404` 错误。
- en: Editing and debugging a full stack app by attaching projects
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过附加项目来编辑和调试全栈应用程序
- en: PyCharm has the ability to attach multiple projects together allowing you to
    work on full stack applications in the same instance of the IDE. When you are
    running multiple attached projects in your PyCharm IDE, you can debug them together
    in a seamless fashion! This capability alone is probably reason enough to stop
    using vim or VS Code and never look back! While it is possible to do this in other
    IDEs or even VS Code, PyCharm makes it so easy you’ll probably not want to.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 有能力将多个项目组合在一起，让您能够在同一个 IDE 实例中处理全栈应用程序。当您在 PyCharm IDE 中运行多个附加项目时，您可以无缝地一起调试它们！仅此一项功能可能就足以让您停止使用
    vim 或 VS Code，并且永远不再回头！虽然您可以在其他 IDE 或甚至 VS Code 中这样做，但 PyCharm 使其变得如此简单，您可能不会想再使用其他工具。
- en: Creating a React app in a separate project
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单独的项目中创建一个 React 应用程序
- en: To create a frontend for our FastAPI backend, we’re going to leverage React.
    As usual, I won’t have the space here to teach you a lot about React. I’ll make
    sure there is some reference reading in the *Further reading* section at the end
    of this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的 FastAPI 后端创建前端，我们将利用 React。像往常一样，我无法在这里向您传授很多关于 React 的知识。我会在本章末尾的**进一步阅读**部分确保有一些参考资料。
- en: To create a React app in PyCharm Professional, just use the usual **File | Project**
    operation to which you have hopefully become accustomed. There is a project template
    that leverages an open source product called **create-react-app** (**CRA**). This
    is a tool widely used by React developers because, in truth, setting up a full-on
    React app from scratch is tedious and time-consuming.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm Professional 中创建一个 React 应用程序，只需使用您可能已经习惯的常规**文件 | 项目**操作即可。这里有一个项目模板，它利用了一个名为
    **create-react-app**（**CRA**）的开源产品。这是一个被 React 开发者广泛使用的工具，因为实际上，从头开始设置一个完整的 React
    应用程序既繁琐又耗时。
- en: 'In order for this `create-react-app` script to work, you need to have Node.js
    installed. If you don’t, PyCharm will attempt to install it for you, as you can
    see in *Figure 9**.27*:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个 `create-react-app` 脚本正常工作，您需要安装 Node.js。如果您没有安装，PyCharm 将尝试为您安装，正如您在**图
    9**.27 中所看到的。27*：
- en: '![Figure 9.27: When creating a JavaScript project, such as a React project,
    you’ll need to have Node.js installed, otherwise PyCharm will try to install it
    for you](img/B19644_09_26.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27：当创建一个 JavaScript 项目，如 React 项目时，您需要安装 Node.js，否则 PyCharm 将尝试为您安装](img/B19644_09_26.jpg)'
- en: 'Figure 9.27: When creating a JavaScript project, such as a React project, you’ll
    need to have Node.js installed, otherwise PyCharm will try to install it for you'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27：在创建一个 JavaScript 项目，例如 React 项目时，您需要安装 Node.js，否则 PyCharm 会尝试为您安装
- en: In my experience, this doesn’t always work out. This same feature exists in
    Visual Studio, and I usually advise my students to install Node.js manually, rather
    than have an IDE do it. In general, the IDEs often don’t point to the latest release
    of Node.js. I can see in *Figure 9**.27* that PyCharm intends to install 16.16.0,
    which isn’t the latest. Besides, looking at the right version, I further recommend
    you use the latest **long-term support** (**LTS**) version of Node.js rather than
    the version with the highest version number. The LTS product is guaranteed stable,
    whereas the absolute newest version isn’t.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，这并不总是奏效。Visual Studio 中也有同样的功能，我通常建议我的学生手动安装 Node.js，而不是让 IDE 来做。一般来说，IDE
    通常不会指向 Node.js 的最新版本。我可以在 *图 9.27* 中看到 PyCharm 意图安装 16.16.0，这不是最新的。此外，查看正确的版本，我进一步建议您使用
    Node.js 的最新 **长期支持** (**LTS**) 版本，而不是版本号最高的版本。LTS 产品保证稳定，而绝对最新的版本则不一定。
- en: Another thing I recommend with Node.js, and Python too, for that matter, is
    to use a package manager such as **Chocolately** ([https://chocolatey.org/](https://chocolatey.org/))
    or **Homebrew** ([https://brew.sh/](https://brew.sh/)). Package managers are standard
    affairs on Linux, and every distribution uses their own, so if you’re using Linux,
    I’ll assume you know which one you need. The reason I advocate using package managers
    for installing Node.js is that the package manager makes it very easy to update,
    or even fully remove, your software should you ever need to. If you want to try
    out Homebrew for Mac, there is a short, free course on my website that teaches
    you to set up an Apple computer for Node.js development. You can find it at [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos).
    I’ll look at making more of these after I finish writing this book, so check the
    site if you want to see the Windows version.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我还推荐使用 Node.js，以及 Python，使用包管理器，如 **Chocolately** ([https://chocolatey.org/](https://chocolatey.org/))
    或 **Homebrew** ([https://brew.sh/](https://brew.sh/))。包管理器在 Linux 上是标准配置，每个发行版都有自己的包管理器，所以如果您使用
    Linux，我会假设您知道您需要哪个。我提倡使用包管理器安装 Node.js 的原因是，包管理器使得更新，甚至完全删除您的软件变得非常容易。如果您想尝试 Mac
    上的 Homebrew，我网站上有一个简短的、免费的课程，教您如何为 Node.js 开发设置苹果电脑。您可以在 [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos)
    找到它。在我完成这本书的写作之后，我会看看制作更多这样的课程，所以如果您想查看 Windows 版本，请访问该网站。
- en: Having installed Node.js manually, let’s get back to creating our React project.
    I called my project `namelist`. React is picky about names, so I picked one that
    I know will work. I’ll leave fancier names to books about React. Click the **Create**
    button. CRA takes a while, but once it is finished, you should have a project
    folder ready to go. We are now ready to go 100% full stack! Next, I’m going to
    show you my favorite technique in PyCharm to work on both projects as if they
    were one, while maintaining full separation of the UI code from the backend.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 手动安装了 Node.js 之后，让我们回到创建我们的 React 项目。我给我的项目命名为 `namelist`。React 对名称很挑剔，所以我选择了一个我知道会工作的名字。我会把更花哨的名字留给关于
    React 的书籍。点击 **创建** 按钮。CRA 需要一些时间，但一旦完成，你应该会有一个准备好的项目文件夹。我们现在可以全栈式工作了！接下来，我将向您展示我在
    PyCharm 中最喜欢的技巧，即同时处理这两个项目，就像它们是一个项目一样，同时保持 UI 代码与后端完全分离。
- en: Attaching the project to the FastAPI project we created earlier
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们之前创建的 FastAPI 项目附加到项目中
- en: 'Open the `fastAPIProject` folder we created at the beginning of this chapter.
    Now, use the `namelist` folder containing the React project. Usually, when we
    do this, we tell PyCharm to open the project either in a new window or in the
    current window. This time, I want you to tell it to attach the project to the
    current one, as shown in *Figure 9**.28*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在本章开头创建的 `fastAPIProject` 文件夹。现在，使用包含 React 项目的 `namelist` 文件夹。通常，当我们这样做时，我们会告诉
    PyCharm 在新窗口或当前窗口中打开项目。这次，我想让您告诉它将项目附加到当前项目上，如图 *图 9.28* 所示：
- en: '![Figure 9.28: Pick the attach option when you open the React project](img/B19644_09_27.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28：打开 React 项目时选择附加选项](img/B19644_09_27.jpg)'
- en: 'Figure 9.28: Pick the Attach option when you open the React project'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28：打开 React 项目时选择附加选项
- en: 'You will find both projects open at the same time in the IDE. This is evident
    in the project window shown in *Figure 9**.29*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在IDE中同时找到两个项目打开。这在*图9.29*的项目窗口中很明显：
- en: '![Figure 9.29: Both halves of a full stack app can be open at the same time,
    allowing you to run and debug them as if they were one project](img/B19644_09_28.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图9.29：一个全栈应用的两侧都可以同时打开，允许你像处理一个项目一样运行和调试它们](img/B19644_09_28.jpg)'
- en: 'Figure 9.29: Both halves of a full stack app can be open at the same time,
    allowing you to run and debug them as if they were one project'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：一个全栈应用的两侧都可以同时打开，允许你像处理一个项目一样运行和调试它们
- en: 'Working with attached projects makes for a very enjoyable experience in full
    stack development. Consider the benefits:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中使用附加项目会带来非常愉快的体验。考虑以下好处：
- en: Technically, they are separate projects in separate repositories.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术上，它们是分别存储在各自仓库中的独立项目。
- en: PyCharm allows you to create run and debug configurations for all attached projects.
    For example, it is possible to set a breakpoint in your React app to examine some
    form of data just before it is submitted. Then in your FastAPI project, you can
    set a breakpoint in the endpoint function to inspect the data received, making
    it easy to find errors in data formatting between the two projects.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm允许您为所有附加项目创建运行和调试配置。例如，您可以在React应用程序中设置断点来检查提交之前的数据。然后在FastAPI项目中，您可以在端点函数中设置断点来检查接收到的数据，这使得在两个项目之间查找数据格式错误变得容易。
- en: Other people who are not able to work full stack can still work on individual
    projects separately.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他不能全栈工作的人仍然可以单独工作在各自的项目上。
- en: 'In [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding Database
    Management with PyCharm*, we’ll learn that you can work with the frontend, the
    backend, and databases, all from within one PyCharm window. For full stack development,
    PyCharm is hard to beat! But first, in the next chapter, let’s look at a third
    web development framework supported by PyCharm: Pyramid.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B19644_11.xhtml#_idTextAnchor266)“使用PyCharm理解数据库管理”，我们将了解到您可以在一个PyCharm窗口中与前端、后端和数据库一起工作。对于全栈开发，PyCharm难以匹敌！但在下一章中，让我们先看看PyCharm支持的第三个Web开发框架：Pyramid。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we effectively covered everything you need to know in order
    to get started creating a RESTful API project using FastAPI in PyCharm.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有效地涵盖了您需要了解的所有内容，以便在PyCharm中使用FastAPI开始创建RESTful API项目。
- en: FastAPI is distinct from Flask, and many other template-oriented web development
    frameworks, in that it is specifically designed to create only RESTful APIs. A
    RESTful API is a backend that is decoupled from any frontend markup, layout, interactivity,
    or display logic. Instead, the API focuses solely on receiving requests bearing
    user interaction data and returning processed data, such as that retrieved or
    processed in a relational database.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI与Flask以及其他许多以模板为导向的Web开发框架不同，因为它专门设计用来创建仅RESTful API。RESTful API是一种后端，它从任何前端标记、布局、交互性或显示逻辑中解耦。相反，API专注于仅接收携带用户交互数据的请求，并返回处理后的数据，例如从关系型数据库检索或处理的数据。
- en: Since these types of applications focus on data, we learned that an SPA is normally
    used to serve as the frontend presentation layer. A number of modern frameworks
    support this paradigm, including React, Angular, and Vue. It is the frontend application’s
    job to control the application state since HTTP is a stateless protocol, and any
    backend would be ill suited to this responsibility.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些类型的应用程序专注于数据，我们了解到SPA通常用作前端表示层。包括React、Angular和Vue在内的许多现代框架支持这种范式。控制应用程序状态是前端应用程序的职责，因为HTTP是无状态协议，任何后端都不适合承担这一责任。
- en: Creating the FastAPI project was easy using the template built into PyCharm
    Professional. It generated starting code as well as a special type of test file
    unique to PyCharm. The HTTP file contains a specification for a request, and a
    testing framework based on JavaScript, which allows us to validate the response
    with the same kind of assertion logic we saw in our earlier exposure to unit testing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyCharm Professional内置的模板创建FastAPI项目非常简单。它生成了起始代码以及PyCharm特有的特殊测试文件。HTTP文件包含请求的规范，以及基于JavaScript的测试框架，这允许我们使用与我们在单元测试早期接触到的相同的断言逻辑来验证响应。
- en: Finally, we created a React frontend in a separate, but connected (attached),
    project in PyCharm, allowing you to develop a full stack application without mingling
    the frontend JavaScript code with the backend Python code. In the next chapter,
    we will discuss Django and Pyramid.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在PyCharm中创建了一个独立的、但连接的（附加的）React前端项目，允许你在不混淆前端JavaScript代码与后端Python代码的情况下开发全栈应用程序。在下一章中，我们将讨论Django和Pyramid。
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What framework serves as the basis for FastAPI, and what makes it different
    from Flask and Werkzeug?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个框架是FastAPI的基础，它与Flask和Werkzeug有什么不同？
- en: What is meant by “representational state transfer” and what problem does it
    solve?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “表征状态转移”是什么意思，它解决了什么问题？
- en: Where is the application state stored in a RESTful API project using an SPA
    as its frontend?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用SPA作为其前端的一个RESTful API项目中，应用程序状态存储在哪里？
- en: What are the four most widely used HTTP methods?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是最常用的四种HTTP方法是什么？
- en: What are CRUD methods, and how do the HTTP methods map to CRUD methods?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRUD方法是什么，HTTP方法是如何映射到CRUD方法的？
- en: What are the benefits of keeping frontend and backend projects separate, and
    how does PyCharm make working with such full stack projects easier?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持前端和后端项目分开有什么好处，PyCharm是如何使处理此类全栈项目更简单的？
- en: Further reading
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Garret, J. J. (2005). A new approach to web applications. [http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php).
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Garret, J. J. (2005). 网络应用程序的新方法。 [http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php)。
- en: Pandey, R. (2023) Build Full Stack Projects with FARM Stack [Video]. Packtpub.com
    [https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667](https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandey, R. (2023) 使用FARM Stack构建全栈项目 [视频]. Packtpub.com [https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667](https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667)
- en: Van Horn, B. (2021) Setting Up a Python Development Workstation in Windows 10\.
    maddevskilz.com [https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows](https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows
    )
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Van Horn, B. (2021) 在Windows 10中设置Python开发工作站\. maddevskilz.com [https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows](https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows)
- en: Van Horn, B. (2021) Setting Up a NodeJS Development Workstation in MacOS. maddevskilz.com
    [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Van Horn, B. (2021) 在MacOS中设置NodeJS开发工作站\. maddevskilz.com [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos)
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定要查看本书的配套网站：[https://www.pycharm-book.com](https://www.pycharm-book.com)。
