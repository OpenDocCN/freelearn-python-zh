- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Data Visualization in FX Trading with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 进行外汇交易中的数据可视化
- en: In previous chapters, we learned how to receive and store market data, how to
    process it, and how to calculate various technical indicators. However, working
    with large amounts of time series data frequently leads to errors typically caused
    by sad mistakes – for example, using incorrect data feed or wrong timestamps.
    Besides that, when working with TA indicators, it’s really wise to check the result
    of the calculations visually – for example, you want to use a large period moving
    average to determine long-term price movements, but you make a mistake, enter
    a small period value, and then find yourself lost in debugging because no real
    long-term trend can be found. Making your research visual helps identify various
    mistakes very quickly and saves a lot of time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何接收和存储市场数据，如何处理它，以及如何计算各种技术指标。然而，处理大量时间序列数据时，经常会遇到由令人沮丧的错误引起的错误，例如，使用错误的数据源或错误的戳记。除此之外，当处理技术指标时，检查计算结果的可视化是非常明智的
    – 例如，您想使用大周期移动平均来确定长期价格走势，但您犯了一个错误，输入了一个小的周期值，然后发现自己陷入调试中，因为找不到真正的长期趋势。使您的调查可视化有助于非常快速地识别各种错误，并节省大量时间。
- en: In this chapter, we will learn how to visualize data using one of the industry
    standard libraries, `matplotlib`, and then go on to plotting bar and candlestick
    charts with the `mplfinance` library, and we will see how it’s possible to create
    charts with live updates and use additional graphics with price charts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用行业标准库之一 `matplotlib` 来可视化数据，然后继续使用 `mplfinance` 库绘制条形图和蜡烛图，我们将看到如何创建具有实时更新和使用价格图表的附加图形的图表。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Charting and plotting basics – how to use graphical libraries with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图和绘图基础知识 – 如何使用 Python 中的图形库
- en: Quick plotting using scripts or an interactive console
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本或交互式控制台进行快速绘图
- en: Visualizing historical market data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化历史市场数据
- en: Creating bar and candlestick charts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建条形图和蜡烛图
- en: Visualizing live market data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化实时市场数据
- en: Adding other objects to price charts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向价格图表添加其他对象
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the practical examples in this chapter, you only require Python 3.9 or
    above.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的实际示例，您只需要 Python 3.9 或更高版本。
- en: The basics of charting with Python
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 绘图的基础知识
- en: 'There are many libraries that implement charting with Python but at the time
    of writing, two of them are industry standards – `matplotlib` and `plotly`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库实现了 Python 中的图表功能，但在撰写本文时，其中两个是行业标准 – `matplotlib` 和 `plotly`：
- en: '`numpy` arrays, support numerous types of charts, including financial ones
    (which is what we need!), provides full control over chart objects, features almost
    unlimited chart customizations, and can be used with different backends.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy` 数组，支持多种类型的图表，包括金融图表（这正是我们所需要的！），对图表对象有完全控制权，具有几乎无限的图表定制功能，并且可以与不同的后端一起使用。'
- en: '`matplotlib` so the choice between the two is not obvious. Plotly definitely
    wins when it comes to interactivity and working with chart objects via an API
    but loses the competition in speed and abilities for customization.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib`，因此两者之间的选择并不明显。在交互性和通过 API 与图表对象一起工作时，Plotly 一定胜出，但在速度和定制能力方面则输给了竞争。'
- en: Which one do we choose? Generally speaking, if you do not plan to develop a
    commercial-grade GUI application, then `matplotlib` is the obvious choice because
    it’s easy to use, is very well documented, and has decent community support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择哪一个？一般来说，如果您不打算开发商业级 GUI 应用程序，那么 `matplotlib` 是一个明显的选择，因为它易于使用，文档非常完善，并且拥有良好的社区支持。
- en: Before we start, let’s quickly look at how `matplotlib` (and similar charting
    libraries in general) work and clearly decide what we are going to do, and especially
    what we are *not* going to do. We will learn about different backends, consider
    the peculiarities of plotting real-time and static data, and get familiar with
    the internal organization of graphical engines and their interaction with the
    *outer world* (your code).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们快速了解一下 `matplotlib`（以及一般类似的图表库）是如何工作的，并明确决定我们将要做什么，以及我们特别不打算做什么。我们将了解不同的后端，考虑实时数据和静态数据绘制的特殊性，并熟悉图形引擎的内部组织和它们与
    *外部世界*（您的代码）的交互。
- en: Graphical backends
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形后端
- en: 'Any charting package used with Python has various **backends** – the very engines
    that render graphics on screen. Out of the box, we have a choice of four backends:
    Agg, **PS** (**postscript**), PDF (yes, the standard PDF format used for documents),
    and SVG (the standard for vector graphics).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何与Python一起使用的绘图包都有各种**后端**——这些后端是渲染屏幕上图形的引擎。开箱即用，我们有四种后端可供选择：Agg、**PS**（**postscript**）、PDF（是的，用于文档的标准PDF格式）和SVG（矢量图形的标准）。
- en: Backends have **bindings** – in simple terms, wrappers that facilitate calls
    to backends from Python. Some backends offer interactive tools and controls out
    of the box; in this case, you only need to draw a chart and then you can pan and
    zoom in using built-in controls provided by the backend. Using other backends
    requires full implementation of the user interface, which is great if you want
    to customize and polish your app to a commercial-grade level but is pretty annoying
    if you only want to quickly look at some piece of data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 后端有**绑定**——简单来说，是便于从Python调用后端的包装器。一些后端提供开箱即用的交互式工具和控制；在这种情况下，你只需绘制一个图表，然后你可以使用后端提供的内置控件进行平移和缩放。使用其他后端需要完全实现用户界面，如果你想要定制和润色你的应用程序以达到商业级水平，这很好；但如果你只想快速查看一些数据，这会很烦人。
- en: We are going to use the standard `matplotlib`, so you don’t need to use any
    special commands in your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准的`matplotlib`，因此你不需要在代码中使用任何特殊命令。
- en: Static versus real-time data and related issues
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态数据与实时数据及其相关问题
- en: It is important to note the key difference between visualizing static data and
    dynamic data. By **static data**, we mean any data that is read only once, received,
    calculated, and so on, and is not modified in real time. Typically, it is used
    during the research phase when you develop, test, and optimize your trading strategy.
    In this case, we work with historical data saved on the disk or retrieved via
    an API from our broker – but in any case, it is not being modified live. This
    means that both charting libraries work just perfectly without any serious efforts
    from the developer’s side; once the dataset is formed, it can be plotted with
    a single command.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意可视化静态数据和动态数据之间的关键区别。我们所说的**静态数据**是指只读取一次、接收、计算等，并且不在实时中被修改的数据。通常，它用于研发阶段，当你开发、测试和优化你的交易策略时。在这种情况下，我们与存储在磁盘上的历史数据或通过API从我们的经纪人那里检索的数据一起工作——但在任何情况下，它都不是实时修改的。这意味着图表库都可以在没有开发者付出太多努力的情况下完美工作；一旦数据集形成，就可以用一条命令进行绘制。
- en: However, once we switch to real-time data visualization, we encounter problems
    because we need to update the chart(s) either periodically or upon an event –
    for example, upon receipt of a new tick. And here, we can encounter issues related
    to multithreading. To better understand these issues, let’s do a quick recap.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们切换到实时数据可视化，我们会遇到问题，因为我们需要定期更新图表或根据事件更新——例如，在收到新的tick时。在这里，我们可能会遇到与多线程相关的问题。为了更好地理解这些问题，让我们快速回顾一下。
- en: Do you remember the concept of multithreading that we covered in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*? Running several processes in
    parallel and connecting them using queues makes our trading apps universal, in
    the sense that we can develop all logic only once and then switch between data
    sources in order to go from research and development to production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在[*第5章*](B19145_05.xhtml#_idTextAnchor086)“使用Python检索和处理市场数据”中讨论的多线程概念吗？并行运行多个进程并通过队列连接它们使我们的交易应用程序通用，从某种意义上说，我们只需开发一次所有逻辑，然后就可以在数据源之间切换，以便从研发过渡到生产。
- en: However, when we add graphics to our applications, we can sometimes encounter
    issues, and these issues are rooted in the fact that graphics are also running
    in a separate thread. This thread is controlled by a separate mechanism, not the
    one that we use to organize data-receiving and processing threads.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们向我们的应用程序添加图形时，我们有时会遇到问题，这些问题源于图形也在一个单独的线程中运行。这个线程由一个独立的机制控制，而不是我们用来组织数据接收和处理线程的那个机制。
- en: Therefore, adding charting in yet another thread to keep it completely separate
    from the main thread is tricky, to say the least. So, we will sacrifice the universality
    of our application in favor of keeping the usage of the graphics simple.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将绘图添加到另一个线程以使其与主线程完全分离是非常棘手的，至少可以说。所以，我们将牺牲我们应用程序的通用性，以保持图形使用的简单性。
- en: Important note about threads, loops, and process termination
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程、循环和进程终止的重要注意事项
- en: The problem with multithreading is the termination of a thread. If you start
    a thread and don’t add any check on whether to keep it running or terminate, then
    it will run virtually forever. To keep your code correct, you may want to always
    add an exit condition to any thread and/or the entire program (which is also a
    thread). However, when using `matplotlib`, you don’t have explicit control over
    the thread that renders graphics, so you may want to use callbacks from the operating
    system. Therefore, despite the risk of being criticized by programming purists,
    I personally use keyboard termination from inside an IDE to stop the graphics
    loop – keeping in mind that, in production, we won’t have to do that, as we never
    include charting in the production code. It’s up to you to choose how you handle
    this issue, but in my opinion, the simpler, the better.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程的问题在于线程的终止。如果你启动了一个线程，并且没有添加任何检查以确定是否继续运行或终止，那么它将几乎无限期地运行。为了保持你的代码正确，你可能想要在任何一个线程和/或整个程序（它也是一个线程）中始终添加一个退出条件。然而，当使用
    `matplotlib` 时，你并没有对渲染图形的线程有明确的控制权，因此你可能想要使用操作系统的回调。因此，尽管有被编程纯粹主义者批评的风险，我个人在 IDE
    内使用键盘终止来停止图形循环——考虑到在生产中，我们不需要这样做，因为我们永远不会在生产代码中包含图表。如何处理这个问题取决于你，但在我看来，越简单越好。
- en: So, what we *are* going to do is to integrate some basic charting as part of
    the main thread of the main module. It will serve the only purpose of quick visualization
    without any intent to be used as a universal charting software, and will be disabled
    or removed before switching from development mode to production.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们*将要*做的是将一些基本的图表集成到主模块的主线程中。它将只用于快速可视化，没有任何意图将其用作通用的图表软件，并且在从开发模式切换到生产模式之前将被禁用或移除。
- en: What we *are not* going to do is to write complex code that would provide our
    app with a sophisticated GUI that would fully imitate commercial applications,
    such as MetaTrader or MultiCharts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*不会*编写复杂的代码，以提供给我们应用一个复杂的 GUI，该 GUI 将完全模仿商业应用程序，例如 MetaTrader 或 MultiCharts。
- en: Enough talk – let’s get coding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的讨论了——让我们开始编码。
- en: Installing Matplotlib
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Matplotlib
- en: Unless you use a clean Python installation, chances are that you already have
    `matplotlib` installed, so check before trying to install it. Just type `import
    matplotlib` in the console and watch the result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你使用的是干净的 Python 安装，否则你很可能已经安装了 `matplotlib`，所以在尝试安装之前先检查一下。只需在控制台中输入 `import
    matplotlib` 并查看结果。
- en: 'If you don’t have `matplotlib` installed, you can use the standard installation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 `matplotlib`，你可以使用标准安装：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you use Conda packages, then you can install `matplotlib` using the following
    command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Conda 软件包，你可以使用以下命令安装 `matplotlib`：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generally speaking, all major third-party Python distributions such as Anaconda,
    ActiveState, ActivePython, and WinPython have `matplotlib` as part of them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，所有主要的第三方 Python 发行版，如 Anaconda、ActiveState、ActivePython 和 WinPython，都将
    `matplotlib` 作为其一部分。
- en: Using Matplotlib in your code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的代码中使用 Matplotlib
- en: '`matplotlib` is quite a large library and we actually need only a part of it
    – the very module that does the plotting. As always, I strongly recommend using
    `import` rather than `from ... import` – to keep namespaces separate:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib` 是一个相当大的库，我们实际上只需要其中的一部分——即进行绘图的模块。一如既往，我强烈建议使用 `import` 而不是 `from
    ... import` ——以保持命名空间分离：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This imports the `pyplot` module that actually creates and handles plots. Let’s
    create our first plot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了 `pyplot` 模块，它实际上创建并处理图表。让我们创建我们的第一个图表：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will look like the following figure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将看起来像以下图：
- en: "![Figure 8.1 – A basic \uFEFFMatplotlib plot](img/B19145_8_01.jpg)"
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 一个基本的 Matplotlib 图表](img/B19145_8_01.jpg)'
- en: Figure 8.1 – A basic Matplotlib plot
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 一个基本的 Matplotlib 图表
- en: 'Let’s see what actually happened:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际上发生了什么：
- en: The graphics library created a figure – the very **canvas** on which all the
    following charting should be made.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图形库创建了一个图形——即所有后续图表都应该制作的**画布**。
- en: Then, **axes** were created in the figure – the rectangle box with scales from
    0 to 10, in our case.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在图中创建了**坐标轴**——在我们的例子中，是一个从 0 到 10 的刻度矩形框。
- en: Then, a graph object was added to the axes – in our case, it’s the diagonal
    line.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个图形对象被添加到坐标轴上——在我们的例子中，它是对角线。
- en: And finally, `plt.show()` was called – the method that actually displays the
    chart on screen.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用了 `plt.show()` ——这是实际上在屏幕上显示图表的方法。
- en: 'Multithreading: revisited'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程：回顾
- en: When you run this code, you will now see a separate process. This process is
    created by the `plt.show()` method and its name is `python`. Don’t confuse it
    with the Python interpreter! This new process handles only the figure that is
    currently being displayed on screen. If you kill it, the `matplotlib` main loop
    is terminated and the figure disappears, but other threads will keep running!
    So, a better idea is to stop the execution of your code from the IDE, to kill
    all threads along with this `python` process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你现在会看到一个单独的进程。这个进程是由`plt.show()`方法创建的，其名称是`python`。不要把它与Python解释器混淆！这个新的进程只处理当前在屏幕上显示的图表。如果你杀掉它，`matplotlib`主循环将终止，图表将消失，但其他线程将继续运行！所以，一个更好的主意是从IDE停止代码的执行，以杀死包括这个`python`进程在内的所有线程。
- en: As you can see, we had 10 elements in the `y` list, and the horizontal axis
    is graduated accordingly, 0 to 10\. It’s clear that the current plot displays
    the `y = x` linear function, where arguments are integer numbers. However, what
    if we wanted to calculate the same function for fractional arguments – say, the
    same 10 points, but taken between 0 and 1, not 0 and 10?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在`y`列表中有10个元素，水平轴相应地进行了刻度，从0到10。很明显，当前的图表显示了`y = x`的线性函数，其中参数是整数。然而，如果我们想计算分数参数的相同函数——比如说，相同的10个点，但取值范围在0到1之间，而不是0到10呢？
- en: 'Let’s give it a try:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: 'First, as always, we import `pyplot`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像往常一样，我们导入`pyplot`：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we import `numpy` – the universal mathematical library for Python that
    adds support for vectors and matrices, along with myriads of math functions. We’re
    going to use `arange`, which is somewhat similar to the native Python range but
    supports fractional steps:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入`numpy`——这是Python的通用数学库，它增加了对向量和矩阵的支持，以及无数的数学函数。我们将使用`arange`，它在某种程度上类似于原生的Python范围，但支持分数步长：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we form the range to display:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们确定要显示的范围：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The rest of the code is unchanged – just creating a plot and displaying it
    on screen:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的其他部分没有改变——只是创建一个图表并在屏幕上显示：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you should see a figure similar to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该会看到一个类似于以下图表的图形：
- en: '![Figure 8.2 – The plot of the linear function in the range between 0 and 1
    – the incorrect X-axis scale](img/B19145_8_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 在0到1范围内的线性函数的图表——错误的X轴刻度](img/B19145_8_02.jpg)'
- en: Figure 8.2 – The plot of the linear function in the range between 0 and 1 –
    the incorrect X-axis scale
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 在0到1范围内的线性函数的图表——错误的X轴刻度
- en: But wait! There’s something wrong with our chart. Yes, the *Y* axis has now
    graduated from 0 to 1 with a step of 0.1, but the *X* axis has still graduated
    from 0 to 10\. This happened because we plotted the new array but did nothing
    to tell the `plt.plot()` method about the new scale by the *X* axis – and by default,
    this method assumes that we plot any array versus indices of its elements, which
    is always an array of integers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们的图表有些问题。是的，现在*Y*轴已经从0增加到1，步长为0.1，但*X*轴仍然从0增加到10。这是因为我们绘制了新的数组，但没有做任何事情来告诉`plt.plot()`方法关于新的刻度，即*X*轴——默认情况下，这个方法假设我们绘制任何数组与它的元素索引相对应，这始终是一个整数数组。
- en: 'Let’s fix this mistake by adding the correct `X`-axis data:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加正确的`X`轴数据来修复这个错误：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s also modify the call of the `plot()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也修改`plot()`方法的调用：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will see the correct plot, shown in the following figure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到正确的图表，如下面的图所示：
- en: '![Figure 8.3 – The plot of the linear function in the range between 0 and 1
    – now the correct X-axis scale](img/B19145_8_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 在0到1范围内的线性函数的图表——现在正确的X轴刻度](img/B19145_8_03.jpg)'
- en: Figure 8.3 – The plot of the linear function in the range between 0 and 1 –
    now the correct X-axis scale
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 在0到1范围内的线性函数的图表——现在正确的X轴刻度
- en: Now that we know a bit about how the `plot()` method works, let’s plot some
    actual market data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`plot()`方法的工作原理有了一些了解，让我们绘制一些实际的市场数据。
- en: Simple plots of market data
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 市场数据的简单图表
- en: In the following examples, we will use historical data only. We will learn how
    to plot live data received from a broker later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将只使用历史数据。我们将在本章的后面学习如何绘制从经纪人那里接收到的实时数据。
- en: There are many ways to read and handle market data, some of which were considered
    in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086), *Retrieving and Handling Market
    Data with Python*. Now, we are going to learn some alternative approaches so that
    you can best choose what suits your current research and development needs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以读取和处理市场数据，其中一些在第 5 章[*“使用 Python 获取和处理市场数据”*](B19145_05.xhtml#_idTextAnchor086)中考虑过。现在，我们将学习一些替代方法，以便你能够根据当前的研究和开发需求做出最佳选择。
- en: 'Let’s start with the most straightforward approach, which uses only native
    Python data structures. As we saw in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    the preferred way of storing and manipulating market data is a dictionary because
    of its full compatibility with the JSON standard and the ability to extract the
    necessary data by keywords. We will start with dictionaries as well:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最直接的方法开始，它只使用原生 Python 数据结构。正如我们在 [*第 5 章*](B19145_05.xhtml#_idTextAnchor086)
    中看到的，由于与 JSON 标准的完全兼容性以及能够通过关键字提取必要数据的能力，存储和操作市场数据的首选方式是字典。我们将从字典开始：
- en: 'First, we still need to do some imports:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们仍然需要做一些导入：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `csv` module contains very convenient methods to read and parse **comma-separated
    value** (**CSV**) files, which is the de facto standard for storing historical
    market data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv` 模块包含非常方便的方法来读取和解析 **逗号分隔值**（**CSV**）文件，这是存储历史市场数据的既定标准。'
- en: 'Now, let’s open a data file and create a `DictReader()` object:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个数据文件并创建一个 `DictReader()` 对象：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `DictReader()` method parses the CSV file into a dictionary or set of dictionaries
    and returns a `DictReader` object. It uses the first line of the file as the source
    for keywords, so make sure you have it in your source data. In the sample file
    I’m using, the header (the first line) looks like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`DictReader()` 方法将 CSV 文件解析为字典或一组字典，并返回一个 `DictReader` 对象。它使用文件的第一个行作为关键字源，所以请确保你在源数据中有它。在我使用的示例文件中，标题（第一行）看起来如下所示：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, these are the very keywords that will appear in the dictionaries when I
    have read the file and parsed it with `DictReader()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些就是在我使用 `DictReader()` 读取文件并解析它时将在字典中出现的非常关键词。
- en: 'Now, we need to convert this object into a list:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将这个对象转换为列表：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we now look at the last three elements in the list by entering `print(all_data[-3:])`,
    we will see something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在通过输入 `print(all_data[-3:])` 来查看列表中的最后三个元素，我们会看到如下内容：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, we indeed now have 1-minute data in the form of OHLC bars, along with some
    information about the volume and the number of ticks per interval (1 minute).
    Each bar is represented by a separate dictionary, and dictionaries are collected
    in a list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在确实有了以 OHLC 条形图形式表示的 1 分钟数据，以及一些关于成交量以及每个区间（1 分钟）的刻度数的信息。每个条形图都由一个单独的字典表示，而字典被收集在一个列表中。
- en: 'Now, we need to extract only the data we want to plot – say, closing prices.
    In order to avoid possible issues by plotting too much data, let’s plot just the
    last 100 data points. There are many ways to do this; we will use list comprehensions:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要提取我们想要绘制的仅有的数据 – 比如，收盘价。为了避免绘制过多数据可能引起的问题，让我们只绘制最后 100 个数据点。有许多方法可以做到这一点；我们将使用列表推导式：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The rest of the code is the same:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码都是相同的：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you did everything correctly, you should see a chart similar to the one
    shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该会看到一个类似于以下截图所示的图表：
- en: '![Figure 8.4 – A simple line chart of closing prices](img/B19145_8_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 简单的收盘价折线图](img/B19145_8_04.jpg)'
- en: Figure 8.4 – A simple line chart of closing prices
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 简单的收盘价折线图
- en: 'Great, but what about the *X*-axis labels? Oh, it again just counts the data
    points, 0 to 100, but we want to see something more meaningful here. Let’s recall
    that the `plot()` method actually plots one iterable versus another, so we’ll
    create labels from the timestamps:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，但关于 *X* 轴标签怎么办呢？哦，它只是简单地计数数据点，从 0 到 100，但我们希望看到更有意义的内容。让我们回忆一下，`plot()`
    方法实际上是在一个可迭代对象与另一个可迭代对象之间绘制，所以我们将从时间戳创建标签：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can see that the numbers along the *X* axis were indeed replaced with
    something, but this something is really hard to read and understand:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到沿 *X* 轴的数字确实被替换了，但这个“替换”的内容真的很难阅读和理解：
- en: '![Figure 8.5 – Using timestamps as X-axis labels without proper formatting
    gets erratic results](img/B19145_8_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 使用时间戳作为 X 轴标签而没有适当的格式化会导致结果不规则](img/B19145_8_05.jpg)'
- en: Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets
    erratic results
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 使用未正确格式化的时间戳作为X轴标签会导致结果不稳定
- en: Unsurprisingly, the labels (the timestamps) are rather long, there are too many
    of them, and they are displayed one over another, making the result unusable.
    So, we want to format them somehow, printing labels only every 10, 20, or 100
    ticks and rotating them to save screen space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，标签（时间戳）相当长，有很多，它们一个接一个地显示，使得结果无法使用。因此，我们希望以某种方式格式化它们，只打印每10、20或100个刻度处的标签，并将它们旋转以节省屏幕空间。
- en: In order to do that, we should recall the sequence of events that is triggered
    by the call to the `plot()` method, which is explained in the *Using matplotlib
    in your code* section in this chapter. First, a *figure* (a blank canvas) is created,
    an *axis* (rectangle box with axes) is added, and then the actual *plot* is drawn.
    All three objects were created automatically by a single call to the `plot()`
    method. However, in order to be able to modify the visual representation of the
    plot, we need to get access to the `axes` object directly. We now want to rewrite
    the entire code responsible for plotting in order to separate the three aforementioned
    objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们应该回忆一下由调用`plot()`方法触发的事件序列，这在本章的*在代码中使用matplotlib*部分中有所解释。首先，创建了一个*figure*（一个空白画布），添加了一个*axis*（带有轴的矩形框），然后绘制了实际的*plot*。这三个对象都是通过单个调用`plot()`方法自动创建的。然而，为了能够修改图表的可视表示，我们需要直接访问`axes`对象。现在，我们想要重写整个绘图代码，以便分离上述三个对象。
- en: 'So, after we formed the `time` list and before the `plot()` call, we add the
    following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在我们形成了`time`列表并在调用`plot()`之前，我们添加以下内容：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This creates a new empty figure object and returns a handle to the `fig` variable.
    Then, we add the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个新的空图对象，并返回了对`fig`变量的句柄。然后，我们添加以下内容：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This one creates a new subplot, or axis – the very rectangle that we want to
    customize. Great – now we can access it using the `ax` variable. So, let’s limit
    the number of tick labels printed along the *X* axis:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个新的子图，或轴——我们想要定制的矩形。太好了——现在我们可以通过`ax`变量访问它。所以，让我们限制沿*X*轴打印的刻度标签数量：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `set_xticks()` method uses only one argument here – an iterable that specifies
    indices of only those elements in the `time` list that we want to plot. In our
    example, we use a `numpy` `arange` that contains integer numbers with a step of
    15 to plot every 15th timestamp.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_xticks()`方法在这里只使用一个参数——一个可迭代对象，它指定了我们想要绘制的`time`列表中那些元素的索引。在我们的例子中，我们使用了一个`numpy`的`arange`，它包含以15为步长的整数数字，以绘制每个15个时间戳。'
- en: 'Finally, to make our plot even more readable, let’s turn the labels by 45°
    and plot the result:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使我们的图表更加易于阅读，让我们将标签旋转45°并绘制结果：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you did everything correctly, you should see a chart like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该看到以下这样的图表：
- en: '![Figure 8.6 – A slightly better-looking simple price chart](img/B19145_8_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 略微更好看的简单价格图表](img/B19145_8_06.jpg)'
- en: Figure 8.6 – A slightly better-looking simple price chart
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 略微更好看的简单价格图表
- en: So far, we have plotted charts only for the last 100 data points, but what if
    we want to plot the market data of a certain day in the past?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为最后100个数据点绘制了图表，但如果我们想绘制过去某一天的市场数据呢？
- en: 'Let’s rewrite the entire code now to keep everything that we’ve learned so
    far together:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重写整个代码，以便将我们迄今为止所学的一切内容放在一起：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far, there’s no difference; we just import the necessary modules and read
    the data file. Now, we want to plot 100 bars, starting from midnight of December
    12, 2019\. So, we find the position of the dictionary with the relevant value
    of the `Date` keyword in the `all_data` list of dictionaries:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有区别；我们只是导入了必要的模块并读取了数据文件。现在，我们想要从2019年12月12日午夜开始绘制100个条形图。因此，我们在字典列表`all_data`中找到与`Date`关键字相关值的字典位置：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we extract the required data for plotting:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提取绘图所需的数据：
- en: '[PRE35]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we actually plot using some nice formatting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实际上使用一些漂亮的格式进行绘图：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That’s it! Now, we can enjoy our chart:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，我们可以享受我们的图表了：
- en: '![Figure 8.7 – A simple price chart of data from a specified date and time](img/B19145_8_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 指定日期和时间的数据的简单价格图表](img/B19145_8_07.jpg)'
- en: Figure 8.7 – A simple price chart of data from a specified date and time
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 指定日期和时间的数据的简单价格图表
- en: Here, we omit all the capabilities of `matplotlib`, including the formatting
    of titles, using colors, multiple subplots, and much more – at the end of the
    day, this book is not a `matplotlib` tutorial. If you’re interested in learning
    more about this reliable charting package, I’d recommend starting with its official
    website ([https://matplotlib.org](https://matplotlib.org)), where you’ll find
    a lot of examples, tutorials, and general documentation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们省略了 `matplotlib` 的所有功能，包括标题格式化、使用颜色、多个子图以及更多内容——毕竟，这本书不是 `matplotlib`
    教程。如果你对学习这个可靠的图表包感兴趣，我建议从其官方网站 ([https://matplotlib.org](https://matplotlib.org))
    开始，在那里你可以找到很多示例、教程和一般文档。
- en: Alright, now we know how to plot basic price charts – simple line charts of
    closing (or any other) prices versus timestamps. However, we all know that the
    most common format for charting in the financial world is a bar chart or candlestick
    chart. How do we plot such a chart with `matplotlib`?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了如何绘制基本的价格图表——简单的收盘价（或任何其他价格）与时间戳的简单线形图。然而，我们都知道在金融世界中，最常见的图表格式是柱状图或蜡烛图。我们如何使用
    `matplotlib` 绘制这样的图表呢？
- en: Well, a few years ago, `matplotlib` itself used to have a `finance` module that
    supported the charts in question. However, now it’s deprecated. So, we have only
    two options – either building financial charts bar by bar using matplotlib’s `bar()`
    method or opting for a relatively new but advanced package, `mplfinance`. This
    package offers very simplistic and straightforward methods to plot price charts,
    but it won’t plot data stored in native Python structures, such as lists or dictionaries.
    Instead, it uses **pandas** to handle market data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，几年前，`matplotlib` 本身曾经有一个 `finance` 模块，支持相关的图表。然而，现在它已被弃用。因此，我们只有两个选择——要么使用
    matplotlib 的 `bar()` 方法逐条构建金融图表，要么选择一个相对较新但功能强大的包，`mplfinance`。这个包提供了非常简单直接的方法来绘制价格图表，但它不会绘制存储在原生
    Python 结构（如列表或字典）中的数据。相反，它使用 **pandas** 来处理市场数据。
- en: So, what is pandas and how can we use it?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，pandas 是什么，我们如何使用它？
- en: Visualizing static market data with pandas
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pandas 可视化静态市场数据
- en: pandas is *“a fast, powerful, flexible, and easy to use open source data analysis
    and manipulation tool, built on top of the Python programming language”*, as declared
    on its official web page at [https://pandas.pydata.org](https://pandas.pydata.org).
    It was originally developed exactly for the purpose of manipulating time series
    data, especially market prices.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其官方网页 [https://pandas.pydata.org](https://pandas.pydata.org) 上的声明，pandas 是
    *“一个快速、强大、灵活且易于使用的开源数据分析和管理工具，建立在 Python 编程语言之上”*。它最初正是为了处理时序数据，特别是市场价格数据而开发的。
- en: Instead of native Python lists or NumPy arrays, pandas uses **DataFrames** as
    a core data object. You can think of a DataFrame as a table, where columns represent
    various named time series (or any other series) and rows contain actual data,
    with the first row always containing the names of the series. Pretty much the
    same as with the historical market data file that we’ve used so far? Yes, and
    this makes the learning curve with pandas really steep.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生的 Python 列表或 NumPy 数组不同，pandas 使用 **DataFrames** 作为核心数据对象。你可以将 DataFrame
    视为一个表格，其中列代表各种命名的时序数据（或任何其他序列），而行包含实际数据，第一行总是包含序列的名称。这与我们迄今为止使用的历 史市场数据文件非常相似吗？是的，这也使得使用
    pandas 的学习曲线非常陡峭。
- en: pandas offers methods to add, delete, and rearrange columns, create and modify
    indices, slice and create subsets, merge and reshape DataFrames, and even handle
    missing data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 提供了添加、删除和重新排列列、创建和修改索引、切片和创建子集、合并和重塑 DataFrame 以及处理缺失数据的方法。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: pandas is quite a comprehensive package that offers various methods to handle
    data to suit very different needs. This book is in no way a pandas tutorial; we
    are going to use only those methods that are required to accomplish the task of
    plotting market data. If you are interested in learning more about pandas, I’d
    recommend starting with a simple tutorial at [https://www.w3schools.com/python/pandas/default.asp](https://www.w3schools.com/python/pandas/default.asp).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 是一个相当全面的包，提供了各种方法来处理数据，以满足非常不同的需求。这本书绝不是 pandas 教程；我们将只使用那些完成绘制市场数据任务所需的方法。如果你对学习
    pandas 感兴趣，我建议从 [https://www.w3schools.com/python/pandas/default.asp](https://www.w3schools.com/python/pandas/default.asp)
    上的简单教程开始。
- en: Installing pandas
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 pandas
- en: 'The official pandas website recommends installing Anaconda, which comes with
    pandas on board, and refers to other installation methods as *advanced*. However,
    there’s nothing really advanced about them. You can use the standard PyPI installation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的 pandas 网站推荐安装 Anaconda，它自带 pandas，并将其他安装方法称为 *高级*。然而，它们并没有真正高级。你可以使用标准的
    PyPI 安装：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you can use Conda:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 Conda：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Reading data from CSV files with pandas
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pandas 读取 CSV 文件中的数据
- en: 'pandas offers a straightforward method to read data from a CSV file. Let’s
    try the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 提供了一种直接从 CSV 文件读取数据的方法。让我们尝试以下代码：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, as always, you want to replace the value of `file_name` with the
    actual path to the locally stored historical data CSV file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像往常一样，你想要将 `file_name` 的值替换为本地存储的历史数据 CSV 文件的实际路径。
- en: 'If you did everything correctly, you will see output like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你会看到以下输出：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see that the first row was used to create column names and the rest
    formed the actual data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，第一行用于创建列名，其余部分形成了实际的数据。
- en: Note that in front of the data read from the file, there’s an additional column
    without a name, and it contains just integer numbers from 0 to 2,136,278 (in the
    example with my file). This is the **DataFrame index**. We can retrieve any specific
    records by referring to them using these numbers – again, pretty much as we would
    do if we used lists. Of course, it’s very inconvenient, as we want to be able
    to retrieve any piece of historical data by referring to a particular date or
    time range. Fortunately, pandas offers a way to build a custom index for a DataFrame,
    so let’s continue with our code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在从文件读取的数据前面，有一个额外的没有命名的列，它只包含从 0 到 2,136,278（在我的示例文件中）的整数。这是 **DataFrame
    索引**。我们可以通过这些数字引用任何特定的记录——再次，这与我们使用列表时几乎一样。当然，这很不方便，因为我们希望能够通过引用特定的日期或时间范围来检索任何历史数据。幸运的是，pandas
    提供了一种为 DataFrame 建立自定义索引的方法，所以让我们继续我们的代码。
- en: Setting index for a dataframe
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 dataframe 设置索引
- en: 'First, let’s form the timestamps from the `date` and `time` fields:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 `date` 和 `time` 字段形成时间戳：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we use built-in methods, `to_datetime()` and `to_timedelta()`, which convert
    string values into a single `Timestamp` object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置方法 `to_datetime()` 和 `to_timedelta()`，它们将字符串值转换为单个 `Timestamp` 对象。
- en: Referencing columns in pandas
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中引用列
- en: In the preceding code, you can see how pandas allows you to reference a certain
    column by its name. This is very similar to finding values by keywords in a dictionary,
    but in pandas, the entire column is returned, not a scalar value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到 pandas 如何允许你通过名称引用某个列。这非常类似于在字典中通过关键字查找值，但在 pandas 中，返回的是整个列，而不是一个标量值。
- en: Assignment to a column with a non-existent name (`Timestamp`, in our case) effectively
    creates a new column with this name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给一个不存在的列名（在我们的例子中是 `Timestamp`）实际上创建了一个具有该名称的新列。
- en: 'Having created the new column, let’s set it as the index:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新列后，让我们将其设置为索引：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we now check the contents of `source_data`, we will see that the new index
    was generated and added to the DataFrame:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查 `source_data` 的内容，我们会看到新索引已生成并添加到 DataFrame 中：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Great! Now we have indexed all our data points (minute bars) by timestamps.
    Let’s now create a simple bar chart for the same 1-minute historical data that
    we used earlier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经通过时间戳索引了所有我们的数据点（分钟柱状图）。现在让我们创建一个简单的柱状图，用于之前使用的相同 1 分钟历史数据。
- en: Creating simple bar charts using pandas and mplfinance
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pandas 和 mplfinance 创建简单的柱状图
- en: 'Of course, we don’t want to plot all data in one chart. The data file I’m using
    in this chapter contains about 5 years’ worth of 1-minute bars, or more than 2
    million records, so creating a chart with more than 2 million bars in it would
    simply freeze rendering forever. Let’s create a chart for just a piece of history,
    specifying the date, the starting, and the ending time:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想在一张图表中绘制所有数据。我在本章使用的数据文件包含大约 5 年的 1 分钟柱状图，或超过 200 万条记录，所以创建一个包含超过 200
    万个柱子的图表将永远冻结渲染。让我们只为一段历史创建一个图表，指定日期、开始时间和结束时间：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The data in my file is in the GMT+1 time zone, so 23:00 here equals 17:00 in
    New York time, which is the bank settlement time for the FX market (see the *Trading
    the FX market – what and how* section in [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*). Also, note that the first
    timestamp for the day (the `start_time` variable) is 1 minute past midnight; for
    bars, timestamps mean the time of the last tick or the closing price of the interval
    (see the *Universal data connector* section in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, for a detailed explanation
    of data compression and timestamps).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我文件中的数据位于 GMT+1 时区，所以这里的 23:00 等于纽约时间的 17:00，这是外汇市场的银行结算时间（参见 [*第 3 章*](B19145_03.xhtml#_idTextAnchor044)
    中的 *Trading the FX market – what and how* 部分，*从开发者的角度来看的外汇市场概述*）。此外，请注意，一天中的第一个时间戳（`start_time`
    变量）是午夜过后的 1 分钟；对于柱状图，时间戳表示最后一笔交易的时间或区间的收盘价（参见 [*第 5 章*](B19145_05.xhtml#_idTextAnchor086)
    中的 *Universal data connector* 部分，*使用 Python 获取和处理市场数据*，以获取数据压缩和时间戳的详细解释）。
- en: Making slices and subsets in pandas
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 pandas 中制作切片和子集
- en: 'The most heavily used method to extract a subset from a DataFrame is `.loc()`.
    Its usage is again very intuitive, as it’s very similar to making slices of native
    Python lists; you only need to specify the start and end indexes for the new sub-DataFrame,
    as shown in this pseudocode:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DataFrame 中提取子集最常用的方法是 `.loc()`。它的使用同样非常直观，因为它与原生 Python 列的切片非常相似；你只需要指定新子
    DataFrame 的起始和结束索引，如以下伪代码所示：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In our actual code, it will look like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际代码中，它将看起来像以下这样：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we want to strip away all unnecessary data and keep only `Open`, `High`,
    `Low`, and `Close`. Again, with pandas, it can be done in the same straightforward
    way by just specifying the columns to retain in a list – and the rest will be
    thrown away:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望去除所有不必要的数据，只保留 `Open`、`High`、`Low` 和 `Close`。同样，使用 pandas，只需指定要保留的列的列表即可完成，其余的将被丢弃：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the double brackets; the outer pair means that we create a sub-DataFrame
    based on the specified set of columns, and the inner pair actually specifies the
    columns in a list. That’s all done – now, it’s time to create our first bar chart.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意双括号；外层一对括号表示我们根据指定的列集创建一个子 DataFrame，而内层一对括号实际上指定了列表中的列。这一切都完成了——现在，是时候创建我们的第一个柱状图了。
- en: Plotting market charts with mplfinance
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mplfinance 绘制市场图表
- en: 'All charts created by `mplfinance` are, by default, bar charts, so let’s start
    with the most simplistic one:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由 `mplfinance` 创建的图表默认都是柱状图，所以让我们从最简单的开始：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you did everything correctly, you should see a figure like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该会看到一个像下面的图：
- en: '![Figure 8.8 – A default bar chart plotted with mplfinance](img/B19145_8_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 使用 mplfinance 绘制的默认柱状图](img/B19145_8_08.jpg)'
- en: Figure 8.8 – A default bar chart plotted with mplfinance
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 使用 mplfinance 绘制的默认柱状图
- en: 'At first glance, it looks like the same line chart, but this is because we
    have a few too many bars on a relatively small canvas. Here, we can benefit from
    the fact that the `TkAgg` backend used by default in `matplotlib` (and `mplfinance`
    is built on top of `matplotlib`) is interactive; you can click the magnifying
    glass icon and zoom in to any part of the chart – say, the spike in the middle
    of the day:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像同一条线形图，但这是因为我们在相对较小的画布上放置了太多的柱子。在这里，我们可以利用 `matplotlib`（`mplfinance`
    是基于 `matplotlib` 构建的）默认使用的 `TkAgg` 后端是交互式的；你可以点击放大镜图标并放大图表的任何部分——比如，白天中间的峰值：
- en: '![Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and
    out](img/B19145_8_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 使用 TkAgg 后端的交互性进行缩放和放大](img/B19145_8_09.jpg)'
- en: Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 使用 TkAgg 后端的交互性进行缩放和放大
- en: 'There are several options to customize the `mplfinance` charts. For example,
    we can plot a candlestick chart instead of a bar chart and even add a number of
    moving averages to it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项可以自定义 `mplfinance` 图表。例如，我们可以绘制蜡烛图而不是柱状图，甚至可以向其中添加多个移动平均线：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, `mav` means **moving averages**, and their periods are specified in a
    tuple. The result is shown in the following figure:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`mav` 代表 **移动平均线**，它们的周期由元组指定。结果如图所示：
- en: '![Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance](img/B19145_8_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 使用 mplfinance 绘制的带有移动平均线的蜡烛图](img/B19145_8_10.jpg)'
- en: Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 使用mplfinance绘制的带有移动平均线的蜡烛图
- en: Now, we can use both Matplotlib’s `pyplot` and `mplfinance` to create price
    charts in the form of simple line charts or nice-looking bar or candlestick charts.
    However, so far, we have worked only with saved data that is static and not updated
    in real time. But what do we do with data being received live from a broker or
    a data vendor? Let’s see how we can solve this problem using the universal data
    connector approach.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Matplotlib的`pyplot`和`mplfinance`来创建以简单折线图或漂亮的条形图或蜡烛图形式的价格图表。然而，到目前为止，我们只处理了静态且不实时更新的保存数据。那么，当我们从经纪人或数据供应商那里实时接收数据时，我们该怎么办？让我们看看如何使用通用数据连接器方法来解决这个问题。
- en: Visualizing live market data
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化实时市场数据
- en: Before we move on, I strongly recommend you reread the *Working with saved and
    live data – keep your app universal* section in [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, and the *Sliding windows* section
    in [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114), *Technical Analysis and Its
    Implementation in Python*. We are going to use the same architecture to create
    live plots of market data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我强烈建议你重新阅读[*第5章*](B19145_05.xhtml#_idTextAnchor086)中的*使用保存和实时数据——保持你的应用通用*部分，以及[*第7章*](B19145_07.xhtml#_idTextAnchor114)中的*滑动窗口*部分，*使用Python检索和处理市场数据*和*在Python中实现技术分析及其应用*。我们将使用相同的架构来创建市场数据的实时图表。
- en: Important reminder
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提醒
- en: Whatever data we receive from a live data source should go into a queue. This
    should be done in a separate thread. Then, data is read from the queue into a
    sliding window that controls the actual amount of data – for any processing or
    plotting.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们从实时数据源接收什么数据，都应该进入队列。这应该在单独的线程中完成。然后，数据从队列中读取到滑动窗口中，该窗口控制实际数据的数量——用于任何处理或绘图。
- en: When we worked with static historical data, we used very convenient methods
    that allowed us to read an entire dataset into memory in one line of code and
    then navigate through it. Of course, any convenience is always paid for, and in
    this case, the fee is running the risk of peeking ahead (see the *Trading logic
    – this is where a small mistake may cost a fortune* section in [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073),
    *Trading Application – What’s Inside?*), which was efficiently solved in [*Chapter
    7*](B19145_07.xhtml#_idTextAnchor114) by using sliding windows and threading and
    feeding data points into them one by one, regardless of whether they were saved
    locally or being received from the broker.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理静态历史数据时，我们使用了非常方便的方法，允许我们用一行代码将整个数据集读入内存，然后导航它。当然，任何便利性都是要付出代价的，在这种情况下，代价是冒着提前查看的风险（参见[*第4章*](B19145_04.xhtml#_idTextAnchor073)中的*交易逻辑——这里一个小错误可能损失一大笔钱*部分，[*第7章*](B19145_07.xhtml#_idTextAnchor114)通过使用滑动窗口和线程，并逐个将数据点喂入其中，无论它们是本地保存的还是从经纪人那里接收的，有效地解决了这个问题）。
- en: So, in other words, what we were doing so far in this chapter is convenient,
    but it contradicts the idea of building a universal trading application suitable
    for both research and live trading.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，换句话说，到目前为止，我们在本章中所做的是方便的，但它与构建一个既适合研究又适合实时交易的全能交易应用的理念相矛盾。
- en: Why, therefore, did we do all that, you may ask?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你们可能想知道，我们为什么要做所有这些？
- en: There are two reasons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个原因。
- en: First, don’t forget that we use charts only to *either* visually confirm an
    idea during the research phase *or* to check the consistency of live ordering
    in production. When we work on the development of a trading idea, it is infinitely
    more convenient to be able to immediately visualize a certain piece of historical
    data, especially if you work in an interactive environment such as IPython. That’s
    where using pandas with `mplfinance` may be the right choice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，别忘了我们只使用图表在研究阶段**要么**直观地确认一个想法，**要么**在生产中检查实时订单的一致性。当我们致力于交易想法的开发时，能够立即可视化某些历史数据会非常方便，尤其是如果你在一个交互式环境中工作，比如IPython。这就是使用pandas与`mplfinance`可能是正确选择的地方。
- en: Second, visualization is used not only to plot market data but also (and probably
    even more intensively) to plot the results of a backtest, running simulated trades
    over historical data. And since a backtest is by definition something *carved
    in stone* – that is, not updated live – then using the approaches that we considered
    earlier in this chapter will serve our purpose just fine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，可视化不仅用于绘制市场数据，还（可能甚至更频繁地）用于绘制回测结果，在历史数据上运行模拟交易。由于回测按定义是某种*刻在石头上*的东西——也就是说，不会实时更新——因此，我们在此章前面考虑的方法将非常适合我们的目的。
- en: All in all, we want to visualize live market data in order to check its correctness,
    see various indicators, and/or track the order execution. Let’s see how it’s done.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们希望可视化实时市场数据，以检查其正确性，查看各种指标，以及/或跟踪订单执行。让我们看看它是如何完成的。
- en: Plotting live tick data
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制实时tick数据
- en: 'As always, we start with several imports:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从几个导入开始：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `json` module will help us parse the response from the data server; we are
    already familiar with the other modules
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`模块将帮助我们解析数据服务器的响应；我们已熟悉其他模块'
- en: 'Then, we import a method to establish WebSocket connections from the `websocket`
    library:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`websocket`库导入建立WebSocket连接的方法：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we create a class that implements the sliding window (see the *Sliding
    windows* section in [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of
    Fundamental Analysis and Its Possible Use in* *FX Trading*):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个实现滑动窗口的类（请参阅[*第6章*](B19145_06.xhtml#_idTextAnchor101)，*基本面分析的基础及其在*
    *FX交易* *中的可能用途*中的*滑动窗口*部分）：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we add a function that creates and maintains the WebSocket connection
    with the market data server. This function has three arguments:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个函数来创建并维护与市场数据服务器的WebSocket连接。此函数有三个参数：
- en: The URL to connect
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的URL
- en: The message we send to the server to subscribe to market data
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发送给服务器以订阅市场数据的消息
- en: The queue in which we place incoming ticks
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们放置传入tick的队列
- en: 'You can also implement the function as a class method if you plan to build
    a complex application with multiple connections:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建一个具有多个连接的复杂应用程序，你也可以将此函数实现为`class`方法：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the connection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建连接：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, send the subscription message, which we will specify later, outside the
    function code (if you implement the function as a `class` method, you may want
    to pass the subscription message as a parameter or have it as a `class` attribute):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发送订阅消息，我们将在后面指定，将其放在函数代码之外（如果你将函数实现为`class`方法，你可能想将订阅消息作为参数传递或将其作为`class`属性）：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Upon successful subscription, the function awaits incoming ticks and places
    them into a queue:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅成功后，函数等待传入的tick并将它们放入队列：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `print(tick)` statement is added only for debugging purposes. All preparations
    are done, so now, let’s proceed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(tick)`语句仅用于调试目的。所有准备工作都已完成，现在，让我们继续：'
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we specify the server to connect to and the message we will send to subscribe
    to market data. Please refer to [*Chapter 5*](B19145_05.xhtml#_idTextAnchor086),
    *Retrieving and Handling Market Data with Python*, for a detailed description
    of the LMAX data structure and the *Retrieving data – garbage in – garbage out*
    section in [*Chapter 4*](B19145_04.xhtml#_idTextAnchor073), *Trading Application
    – What’s Inside?*, to refresh your memory on important issues regarding receiving
    and processing data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定要连接的服务器和我们将发送以订阅市场数据的消息。请参阅[*第5章*](B19145_05.xhtml#_idTextAnchor086)，*使用Python检索和处理市场数据*，以获取LMAX数据结构的详细描述，以及[*第4章*](B19145_04.xhtml#_idTextAnchor073)，*交易应用程序——里面有什么？*中的*检索数据——垃圾进，垃圾出*部分，以刷新你对接收和处理数据的重要问题的记忆。
- en: 'Next, we’ll create the queue to store the incoming ticks:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建队列以存储传入的tick：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will also create a thread to retrieve data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个线程来检索数据：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you did everything correctly and ran the code, you will see the order book
    data coming from the WebSocket:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确并运行了代码，你将看到来自WebSocket的订单簿数据：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We want to plot only the top of the book – that is, the current best bid and
    best ask – so let’s add another function that will parse incoming ticks and send
    `bid` and `ask` values to the respective sliding windows. We implement this function
    without arguments because it shares data structures (bid and ask sliding windows)
    with the charting part of the code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想绘制书籍的顶部——也就是说，当前的最佳买入价和最佳卖出价——所以让我们添加另一个函数，该函数将解析传入的tick并将`bid`和`ask`值发送到相应的滑动窗口。我们实现此函数时没有参数，因为它与代码的图表部分共享数据结构（`bid`和`ask`滑动窗口）：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function gets ticks from the queue, extracts bids and asks, and sends
    them to the respective sliding windows (`bids` and `asks`). Let’s create them
    – first, we specify the length of the sliding window (let’s set it to 60, which
    will display about 1 minute’s worth of data, given that LMAX sends an update at
    a rate of about 1 tick per second):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从队列中获取跳动，提取买卖双方，并将它们发送到相应的滑动窗口（`bids`和`asks`）。让我们创建它们——首先，我们指定滑动窗口的长度（让我们将其设置为60，这样将显示大约1分钟的数据，考虑到LMAX以大约每秒1跳的速度发送更新）：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, add two windows, for `bids` and `asks` respectively:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加两个窗口，分别用于`bids`和`asks`：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we wrap the processing function into a thread:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理函数包装进一个线程中：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we now run the code we have developed so far, we will see pairs of bids
    and asks updated about every 1 second:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行到目前为止所开发的代码，我们将看到每秒大约更新一次的买卖对：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Great job! Now, we want to plot this live data in a chart.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在，我们想在图表中绘制实时数据。
- en: At this point, the most natural course of action would be to create the third
    thread and do all the plotting inside it, to keep all three processes (retrieving
    data, processing, and plotting) separate from each other and the main thread.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最自然的做法是创建第三个线程，并在其中完成所有绘图，以保持三个过程（检索数据、处理和绘图）彼此以及与主线程的分离。
- en: Alas, with `matplotlib` (and many other charting suites), to do this is very
    complex (although not impossible). So, unfortunately, we have to live with the
    fact that charting is (easily) available only in the main thread.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，使用`matplotlib`（以及许多其他图表套件）来做这件事非常复杂（尽管并非不可能）。所以，不幸的是，我们必须接受图表只能在主线程中（轻易地）可用的事实。
- en: 'First, let’s wait till the entire data in the sliding windows is filled with
    meaningful values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们等待滑动窗口中的所有数据都填充了有意义的值：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we create the figure and the axes separately (as we did earlier in this
    chapter when we customized the axis labels):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分别创建图形和坐标轴（就像我们在本章前面自定义坐标轴标签时做的那样）：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we add two lines for our two data series (the bids and asks):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的两个数据系列（买卖双方）添加两条线：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we start the main charting loop, which will draw the lines and refresh
    the figure once every second:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动主绘图循环，该循环将每秒绘制线条并刷新图形：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following command adds small margins above and below the plots, just to
    improve the visual perception:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在图表上方和下方添加了小的边距，只是为了提高视觉感知：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we actually plot the chart:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实际绘制图表：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We then wait for 1 second for the graphics to be rendered and appear on screen;
    otherwise, the loop blocks the rendering we don’t let it run during this pause:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待1秒钟，直到图形被渲染并出现在屏幕上；否则，循环会阻塞渲染，我们不希望在这次暂停期间让它运行：
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'So simple! If you did everything correctly, you should see a figure similar
    to the following one updating every second:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！如果你一切都做对了，你应该看到以下类似的图形，每秒更新一次：
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It takes time to fill the entire sliding window. In our example, it will be
    about 60 seconds before the figure appears.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 填充整个滑动窗口需要时间。在我们的例子中，大约需要60秒才能出现图形。
- en: '![Figure 8.11 – A simple live price tick chart showing both bid and ask](img/B19145_8_11.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 一个简单的实时价格跳动图表，显示买卖双方](img/B19145_8_11.jpg)'
- en: Figure 8.11 – A simple live price tick chart showing both bid and ask
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 一个简单的实时价格跳动图表，显示买卖双方
- en: Well, now we can draw live charts of market prices, and it has turned out to
    be quite simple and straightforward – but only in form of lines for every tick.
    What if we want to aggregate data and then plot a bar or candlestick chart? Let’s
    find the solution in the next section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们可以绘制市场价格的实时图表，这已经变得相当简单直接——但仅以每跳的线条形式。如果我们想聚合数据然后绘制条形图或蜡烛图呢？让我们在下一节中找到解决方案。
- en: Plotting live bar or candlestick charts
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制实时条形图或蜡烛图
- en: 'Earlier in this chapter, we worked with bar and candlestick charts, and we
    know that the most streamlined way of doing that is by using the `mplfinance`
    library. The idea is to use the `mplfinance.plot()` method in a loop and update,
    similar to how we just did for line plots of tick data. So, what we want to do
    now is add a new function that would split the incoming tick data stream into
    bars according to a certain rule, adds the formed bars to a DataFrame, and sends
    the resulting DataFrame to the charting loop:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们处理过柱状图和蜡烛图，我们知道最流畅的方式是使用`mplfinance`库。想法是在循环中使用`mplfinance.plot()`方法，并更新，类似于我们刚刚对tick数据的线形图所做的。所以，我们现在想要做的是添加一个新的函数，该函数将根据一定的规则将传入的tick数据流分割成柱，将形成的柱添加到DataFrame中，并将结果DataFrame发送到图表循环：
- en: 'Let’s start with imports. Some imported modules are the same as in the previous
    example because we need them to retrieve data from a WebSocket connection again:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导入开始。一些导入的模块与上一个例子相同，因为我们需要它们从WebSocket连接中再次检索数据：
- en: '[PRE74]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we import the `datetime` method, as we will convert string timestamps
    into `datetime` objects:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入`datetime`方法，因为我们将会将字符串时间戳转换为`datetime`对象：
- en: '[PRE78]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, we have some imports to facilitate charting:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一些导入语句以方便图表绘制：
- en: '[PRE79]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Then, we will reuse some of the code from the *Plotting live tick data* section
    – the assignment of the `sliding_window` class, `url`, and `subscription_msg`
    variables, and the initialization of `pipe`, `window_size`, `bids`, and `asks`.
    We will also reuse the `LMAX_connect()` function without changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重用*绘图实时tick数据*部分的一些代码 – `sliding_window`类、`url`和`subscription_msg`变量的赋值，以及`pipe`、`window_size`、`bids`和`asks`的初始化。我们还将重用`LMAX_connect()`函数而不做任何修改。
- en: 'Now, we will create a new queue into which we will send DataFrames for plotting:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的队列，我们将向其中发送用于绘图的DataFrames：
- en: '[PRE82]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We will also create a new function that will do the job of splitting the incoming
    tick data stream into bars:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个新的函数，该函数将执行将传入的tick数据流分割成柱的任务：
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We’ve created an empty DataFrame, set the column titles, and assigned `Timestamp`
    as the index. Next, we set the time frame (resolution) to 10 seconds and initialize
    the timestamp:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个空的DataFrame，设置了列标题，并将`Timestamp`设置为索引。接下来，我们将时间框架（分辨率）设置为10秒，并初始化时间戳：
- en: '[PRE84]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, as always, if we work with infinite processes in threads, we start the
    loop, in which we read a tick, extract its timestamp and last bid price (we assume
    we want to plot bids; if you want to plot any other data from the order book,
    just choose the appropriate key and value in the dictionary), and if this is the
    very first tick we received, initialize the `open`, `high`, `low`, and `close`
    values for the upcoming bar and set `last_sample_ts` to `ts`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像往常一样，如果我们使用线程处理无限过程，我们就开始循环，在这个循环中我们读取一个tick，提取其时间戳和最后出价（我们假设我们想要绘制出价；如果你想要绘制订单簿中的任何其他数据，只需在字典中选择适当的关键字和值即可），并且如果这是我们收到的第一个tick，初始化即将到来的柱的`open`、`high`、`low`和`close`值，并将`last_sample_ts`设置为`ts`：
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we specify the condition with which we will start a new bar. In this case,
    we do it as soon as the difference between the current time (`ts`) and the time
    of the previous bar (`last_bar_sample`) becomes greater than the value stored
    in the `resolution` variable:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们指定启动新柱的条件。在这种情况下，一旦当前时间(`ts`)与上一柱时间(`last_bar_sample`)之间的差异大于存储在`resolution`变量中的值，我们就立即执行：
- en: '[PRE87]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'So, as soon as a new 10-second interval is started, we create a new DataFrame
    bar using the `Open`, `High`, `Low`, and `Close` values and the current timestamp,
    and add it to the main DataFrame bars. The rest of the function’s code is pretty
    apparent; first, we again initialize all four price variables, update the timestamp
    of the last bar, and put the DataFrame in the queue:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，一旦一个新的10秒间隔开始，我们就使用`Open`、`High`、`Low`和`Close`值以及当前时间戳创建一个新的DataFrame柱，并将其添加到主DataFrame
    `bars`中。该函数其余部分的代码相当明显；首先，我们再次初始化所有四个价格变量，更新最后柱的时间戳，并将DataFrame放入队列：
- en: '[PRE91]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Of course, if the condition is not `true` (the time since the bars opened did
    not exceed the resolution threshold), we just update the price variables:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果条件不是`true`（柱子开启的时间没有超过分辨率阈值），我们只需更新价格变量：
- en: '[PRE94]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The trick is done; now, let’s create two threads:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 诀窍已经完成；现在，让我们创建两个线程：
- en: '[PRE95]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create the figure and get a handle on the axes:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图形并获取坐标轴句柄：
- en: '[PRE99]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, run the plotting loop:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行绘图循环：
- en: '[PRE101]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `block = False` optional argument to the `mpf.plot()` method tells the renderer
    to release the chart after drawing and allow adding or modifying objects in it
    (so that we can do live updates). Don’t forget to add a pause (`plt.pause(1)`);
    otherwise, the loop will always be busy and won’t let the system display the chart
    on screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`mpf.plot()`方法的`block = False`可选参数告诉渲染器在绘制后释放图表，并允许在其中添加或修改对象（这样我们就可以进行实时更新）。别忘了添加一个暂停（`plt.pause(1)`）；否则，循环将一直忙碌，不会让系统在屏幕上显示图表。'
- en: 'If you run this code, the first thing you will see is a single huge candlestick
    because we don’t have enough data yet:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你首先会看到一个巨大的蜡烛图，因为我们还没有足够的数据：
- en: '![Figure 8.12 – The initial view of the live candlestick chart](img/B19145_8_12.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 实时蜡烛图初始视图](img/B19145_8_12.jpg)'
- en: Figure 8.12 – The initial view of the live candlestick chart
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 实时蜡烛图初始视图
- en: 'Then, the chart will update every 10 seconds, and after 4 minutes, you will
    see something like what is shown in the following screenshot:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，图表将每10秒更新一次，4分钟后，你将看到以下截图所示的内容：
- en: '![Figure 8.13 – A 10-second candlestick chart made with live price data](img/B19145_8_13.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 使用实时价格数据制作的10秒蜡烛图](img/B19145_8_13.jpg)'
- en: Figure 8.13 – A 10-second candlestick chart made with live price data
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 使用实时价格数据制作的10秒蜡烛图
- en: 'As we receive more and more data, there will be more and more candles on the
    chart, so at a certain point, it will become unreadable. Therefore, you may want
    to add a limit and throw away the oldest row from the DataFrame as the newest
    one comes in, just before we place the DataFrame in the `data_for_chart` queue:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们接收越来越多的数据，图表上会有越来越多的蜡烛，所以到了某个点，它将变得难以阅读。因此，你可能想在将DataFrame放入`data_for_chart`队列之前，添加一个限制并丢弃最老的一行，当新的一行到来时：
- en: '[PRE102]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, I specified 100 bars to display, and as soon as this limit is reached,
    older bars will disappear from the screen – pretty much like in MetaTrader, MultiCharts,
    TradeStation, or any other charting application.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我指定了显示100根蜡烛，一旦达到这个限制，较老的蜡烛将从屏幕上消失——这和在MetaTrader、MultiCharts、TradeStation或任何其他图表应用中几乎一样。
- en: Very frequently, we will need to plot something else along with the price data.
    It can be a technical indicator, a trendline, just a mark denoting an entry or
    exit, or anything else. Let’s see how we can do that in the next section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 非常频繁地，我们需要在价格数据旁边绘制其他内容。这可能是一个技术指标、趋势线、标记一个入场或退场，或者任何其他内容。让我们看看在下一节中我们如何做到这一点。
- en: Adding objects to price charts
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向价格图表添加对象
- en: It is not difficult to add any objects to the chart if we know their coordinates
    because all `matplotlib` methods always plot one array-like object versus another.
    So, basically, all we need to do to add any special objects to a chart is to calculate
    their position in the list, or the array along the *X* axis and the corresponding
    value along the *Y* axis.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道它们的坐标，添加任何对象到图表并不困难，因为所有的`matplotlib`方法总是绘制一个类似于另一个数组对象。所以，基本上，我们添加任何特殊对象到图表所需要做的就是计算它们在列表中的位置，或者沿*X*轴的数组以及沿*Y*轴的相应值。
- en: Let’s consider a simple yet valuable example. In [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*, we saw that price takers can
    only buy at the ask and sell at the bid. We also saw that a large order can move
    the price a few points (pips) up or down because it consumes the liquidity from
    several levels in the order book. So, we can assume with a good degree of confidence
    that if the best bid suddenly became greater than the best ask at the previous
    tick, then it was possibly a trace of a significant buy order. And it works vice
    versa – if we observe a plunge of the best ask below the previous best bid, then
    it may be a footprint of a significant sell order.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单但很有价值的例子。在[*第3章*](B19145_03.xhtml#_idTextAnchor044)，“从开发者角度的FX市场概述”中，我们了解到价格接受者只能以要价买入，以出价卖出。我们还看到，大订单可以移动价格几个点（pip），因为它消耗了订单簿中几个级别的流动性。因此，我们可以有相当大的信心假设，如果最佳出价在上一刻突然大于最佳要价，那么这可能是一个重大买入订单的迹象。反之亦然——如果我们观察到最佳要价低于上一最佳出价，那么这可能是一个重大卖出订单的痕迹。
- en: 'Let’s visualize these two situations by adding triangle markers, pointing up
    and down on the tick chart for supposed buys and sells respectively. For this
    purpose, we will use the code that we wrote to visualize live tick data (see the
    *Plotting live tick data* section) and just add a few lines:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加三角形标记来可视化这两种情况，分别指向上下，以表示假设的买入和卖出。为此，我们将使用我们编写的用于可视化实时tick数据的代码（见*实时tick数据绘图*部分），并添加几行：
- en: 'First, we need to add two new objects that will display the markers. We add
    them just below the lines where we create objects to display bids and asks (`line1`
    and `line2`):'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加两个新的对象来显示标记。我们就在创建显示买卖报价的对象（`line1`和`line2`）的下方添加它们：
- en: '[PRE103]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Special modifiers here denote the color and the style of the graphics – `'g^'`
    means a green triangle pointing up and `'mv'` means a magenta triangle pointing
    down. You can find a comprehensive list of the optional parameters of the `pyplot.plot()`
    method at [https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的特殊修饰符表示图形的颜色和样式 – `'g^'`表示一个向上的绿色三角形，`'mv'`表示一个向下的洋红色三角形。你可以在[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot)找到`pyplot.plot()`方法的可选参数的完整列表。
- en: 'Next, we need to calculate the coordinates (positions) of these markers. We
    will do it at the very beginning of the main charting loop (immediately after
    `while True:`). Let’s add four respective lists to store the coordinates:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要计算这些标记的坐标（位置）。我们将在主绘图循环的非常开始处（在`while True:`之后立即）做这件事。让我们添加四个相应的列表来存储坐标：
- en: '[PRE105]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, fill them at all occurrences of the best bid being greater than the previous
    best ask, or the best ask being lower than the previous best bid:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在最佳买入价大于前一个最佳卖出价或最佳卖出价低于前一个最佳买入价的所有发生处填充它们：
- en: '[PRE110]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Note that we start counting from 1 and not from 0 because we want to compare
    a value in the list with the `bids.data[0]` to `bids.data[-1]`, which is effectively
    the **last** element in the list, not the **previous** one:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们从1开始计数，而不是从0开始，因为我们想将列表中的值与`bids.data[0]`到`bids.data[-1]`进行比较，这实际上是列表中的**最后一个**元素，而不是**前一个**元素：
- en: '[PRE111]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We add a margin of 1 `pip` to the values along the *Y* axis so that the markers
    will be placed slightly away from the main chart.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*Y*轴上的值中添加了1`pip`的边距，这样标记就会稍微远离主图表。
- en: 'The rest is the same as what we did for plotting bids and asks; just add calls
    to the `set_xdata()` and `set_ydata()` methods:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的与绘制买卖报价相同；只需添加对`set_xdata()`和`set_ydata()`方法的调用：
- en: '[PRE117]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'That’s it! If we run our script now, we will see green and magenta markers
    pointing to the exact places where supposedly big buys or sells happened:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果我们现在运行我们的脚本，我们将看到绿色和洋红色的标记指向假设的大规模买入或卖出的确切位置：
- en: '![Figure 8.14 – A tick chart with spread-crossing marks added](img/B19145_8_14.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 添加了价差交叉标记的tick图表](img/B19145_8_14.jpg)'
- en: Figure 8.14 – A tick chart with spread-crossing marks added
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 添加了价差交叉标记的tick图表
- en: Wow! Does the chart show the exact points to buy or sell? Looks like we’ve found
    an excellent trading strategy. Now, is the only thing left to do to automate it
    and look for a bank with reliable safe deposit boxes to store the earned cash?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这个图表显示的是确切的买卖点吗？看起来我们找到了一个优秀的交易策略。现在，唯一剩下的事情就是自动化它，并寻找一个有可靠保险箱的银行来存储赚取的现金？
- en: 'Of course not. Just look at the following screenshot, and you will see that
    sometimes chasing *big money* can be quite a disappointing experience:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不是。只需看看下面的截图，你就会看到，有时候追逐**大钱**可能是一种相当令人失望的经历：
- en: '![Figure 8.15 – Another illustration of spread-crossing – the price reverses
    and goes in the opposite direction](img/B19145_8_15.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 另一个展示价差交叉的例子 – 价格反转并朝相反方向移动](img/B19145_8_15.jpg)'
- en: Figure 8.15 – Another illustration of spread-crossing – the price reverses and
    goes in the opposite direction
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 另一个展示价差交叉的例子 – 价格反转并朝相反方向移动
- en: So, as I have maintained throughout the book, there is no free lunch and there
    is no Holy Grail in trading, which means that it is impossible to make money consistently
    for a reasonably long period of time by using only one magical trading rule. Instead,
    we need to develop a trading strategy, something that will incorporate trading
    logic (when we enter and exit the market and why, which normally consists of plenty
    of rules), money management (how much we trade), and risk management (what we
    do if things go wrong or, preferably, how to anticipate that and avoid trading).
    And this is what we are going to consider in the remaining part of this book.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我在整本书中一直强调的那样，没有免费的午餐，在交易中也没有圣杯，这意味着仅靠一条神奇的交易规则，不可能在相当长的时间内持续赚钱。相反，我们需要制定一个交易策略，这需要结合交易逻辑（我们何时进入和退出市场以及为什么，这通常包括许多规则）、资金管理（我们交易多少）和风险管理（事情出错时我们做什么，或者最好是预测这种情况并避免交易）。这正是我们在本书剩余部分将要考虑的内容。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the general principles of handling charts
    with Python. Now, we can quickly find the required part of historical data and
    plot it as line or candlestick charts. We also learned how to plot live market
    data and update the charts in real time. Finally, we learned how to add custom
    graphics to a price chart and discovered that crossing the spread can indeed be
    a potentially valuable trading signal. We are prepared to visualize any data,
    be it market prices or the performance of our trading algorithm, so it’s high
    time we step into the domain of trading strategies to understand how and why they
    work, and to make the right choice for further development. This is what we are
    going to consider in the next chapter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用Python处理图表的一般原则。现在，我们可以快速找到所需的历史数据部分，并将其绘制成线形图或蜡烛图。我们还学习了如何绘制实时市场数据并实时更新图表。最后，我们学习了如何向价格图表添加自定义图形，并发现跨价差确实可能是一个有价值的潜在交易信号。我们已经准备好可视化任何数据，无论是市场价格还是我们交易算法的表现，因此现在是时候进入交易策略的领域，了解它们是如何以及为什么有效，并为进一步的发展做出正确的选择。这就是我们在下一章将要考虑的内容。
- en: 'Part 3: Orders, Trading Strategies, and Their Performance'
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：订单、交易策略及其表现
- en: In previous parts, we learned about the FX markets, understood how they operate,
    and discovered how to avoid the intrinsic risks. We also considered the essential
    components of most trading algorithms, which aim at addressing the peculiarities
    of the subject domain.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们学习了外汇市场，了解了它们的运作方式，并发现了如何避免固有的风险。我们还考虑了大多数交易算法的基本组成部分，这些算法旨在解决该领域的特殊性。
- en: '*Part 3* moves forward by explaining the ideas behind most trading strategies,
    including all-time classics such as trend following, momentum, and mean reversion,
    along with more advanced arbitrage and stat arbitrage, market making, and high-frequency
    trading. We will also learn about the most common types of orders, typical issues
    with their execution, and ways to mitigate the associated risks. Finally, we will
    build our first trading app, test it, and learn about one of the most common mistakes
    among quant traders.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*第三部分* 通过解释大多数交易策略背后的理念来推进，包括所有时代的经典策略，如趋势跟踪、动量、均值回归，以及更高级的套利和统计套利、市场制作和高频交易。我们还将学习最常见的订单类型、它们执行的典型问题以及减轻相关风险的方法。最后，我们将构建我们的第一个交易应用，对其进行测试，并了解量化交易者中最常见的错误之一。'
- en: 'This part comprises the following chapters:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B19145_09.xhtml#_idTextAnchor152), *Trading Strategies and Their
    Core Elements*'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19145_09.xhtml#_idTextAnchor152)，*交易策略及其核心要素*'
- en: '[*Chapter 10*](B19145_10.xhtml#_idTextAnchor171), *Types of Orders and Their
    Simulation in Python*'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19145_10.xhtml#_idTextAnchor171)，*订单类型及其在Python中的模拟*'
- en: '[*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical
    Performance*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19145_11.xhtml#_idTextAnchor186)，*回测和理论表现*'
