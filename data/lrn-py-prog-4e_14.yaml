- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Introduction to API Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 开发简介
- en: ”The one goal of compassionate communication is to help others suffer less.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “有同情心的沟通的唯一目标是帮助他人减少痛苦。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Thich Nhat Hanh
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 释达·南欣
- en: In this chapter, we are going to learn about the concept of **Application Programming
    Interface** , or **API** .
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 **应用程序编程接口**（**API**）的概念。
- en: 'We are going to discuss the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下内容：
- en: The HTTP protocol
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 协议
- en: Introduction to API design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 设计简介
- en: A complete API example
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的 API 示例
- en: We are going to briefly touch on the HTTP protocol, as it is the infrastructure
    upon which we will build the API. Moreover, since the framework we are going to
    use, **FastAPI** , leverages Type Hinting extensively, you may want to make sure
    you have read *Chapter 12, Introduction to Type Hinting* , as a prerequisite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍 HTTP 协议，因为它是我们将构建 API 的基础设施。此外，由于我们将使用的框架 **FastAPI** 广泛使用类型提示，您可能需要确保您已经阅读了
    *第 12 章，类型提示简介*，作为先决条件。
- en: After a short general introduction to APIs, we are going to show you a railway
    project, which you can find in its complete state in the source code for this
    chapter, along with its requirements and a README file that explains all you need
    to know to run the API and query it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 API 进行简短的一般介绍之后，我们将向您展示一个铁路项目，您可以在本章的源代码中找到其完整状态，包括其需求和一份 README 文件，该文件解释了您运行
    API 和查询 API 所需要了解的所有内容。
- en: FastAPI has proven to be the optimal choice for this project. Thanks to its
    capabilities, we have been able to create an API with clean, concise, and expressive
    code. We believe it to be a good starting point for you to explore and expand
    on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 已被证明是这个项目的最佳选择。得益于其功能，我们能够创建一个具有清晰、简洁和表达性的 API。我们相信它是一个很好的起点，让您探索和扩展。
- en: As a developer, it is quite likely that you will have to work on APIs, at some
    point in your career. Technology and frameworks evolve all the time, so we recommend
    that you also focus on the theoretical concepts we are going to expose, as that
    knowledge will help you be less dependent on any particular framework or library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，在您的职业生涯中某个时刻，您很可能需要处理 API。技术和框架不断演变，因此我们建议您也关注我们将要介绍的理论概念，因为这种知识将帮助您减少对任何特定框架或库的依赖。
- en: Let us start with HTTP.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 HTTP 开始。
- en: The Hypertext Transfer Protocol
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超文本传输协议
- en: The **World Wide Web** ( **WWW** ), or simply the **Web** , is a way of accessing
    information using the **Internet** . The Internet is a vast network of networks,
    a networking infrastructure. Its purpose is to connect billions of devices together,
    all around the globe, so that they can communicate with one another. Information
    travels through the Internet in a rich variety of languages, called **protocols**
    , that allow different devices to share content.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**（**WWW**）或简单地称为 **Web**，是一种使用 **互联网** 访问信息的方式。互联网是一个庞大的网络网络，是一个网络基础设施。其目的是连接全球数十亿设备，使它们能够相互通信。信息通过互联网以丰富的语言（称为
    **协议**）传输，这些协议允许不同的设备共享内容。'
- en: The Web is an information-sharing model, built on top of the Internet, which
    employs the **Hypertext Transfer Protocol** ( **HTTP** ) as a basis for data communication.
    The Web, therefore, is just one of several ways information can be exchanged over
    the Internet; email, instant messaging, news groups, and so on, all rely on different
    protocols.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是一个信息共享模型，建立在互联网之上，它使用 **超文本传输协议**（**HTTP**）作为数据通信的基础。因此，万维网只是互联网上信息交换的几种方式之一；电子邮件、即时消息、新闻组等等，都依赖于不同的协议。
- en: How does HTTP work?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 是如何工作的？
- en: 'HTTP is an asymmetric **request-response** **client-server** protocol. An HTTP
    client – for example, your web browser – sends a request message to an HTTP server.
    The server, in turn, returns a response message. HTTP is primarily a **pull-based
    protocol** , which means the client pulls information from the server, rather
    than the server pushing it to the client. There are techniques, implemented over
    HTTP, that simulate push-based behavior, for example, long polling, WebSockets,
    and HTTP/2 Server Push. Despite these, the foundation of HTTP remains a pull-based
    protocol, where it is the client that initiates the requests. Look at the diagram
    in *Figure 14.1* :'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一种非对称的 **请求-响应** **客户端-服务器** 协议。一个 HTTP 客户端——例如，您的网页浏览器——向 HTTP 服务器发送一个请求消息。服务器反过来返回一个响应消息。HTTP
    主要是一种 **基于拉取的协议**，这意味着客户端从服务器拉取信息，而不是服务器推送给客户端。有一些在 HTTP 上实现的技巧可以模拟基于推送的行为，例如长轮询、WebSocket
    和 HTTP/2 服务器推送。尽管如此，HTTP 的基础仍然是一个基于拉取的协议，其中客户端是发起请求的一方。请看图 *14.1*：
- en: '![img](img/B30992_14_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_14_01.png)'
- en: 'Figure 14.1: A simplified depiction of the HTTP protocol'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：HTTP 协议的简化表示
- en: HTTP is transmitted via the **Transmission Control Protocol/Internet Protocol**
    ( **TCP/IP)** , which provides the tools for a reliable communication exchange
    over the Internet.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 通过 **传输控制协议/互联网协议**（**TCP/IP**）传输，它为在互联网上进行可靠的通信交换提供了工具。
- en: An important feature of the HTTP protocol is that it is **stateless** . This
    means that the current request has no knowledge about what happened in previous
    requests. This technical limitation exists for good reasons, but it is easy to
    overcome. In practice, most websites offer the ability to “log in” and the illusion
    of carrying a state from page to page. When a user logs in to a website, a token
    of user information is saved (most often on the client side, in special files
    called **cookies** ) so that each request the user makes carries the means for
    the server to recognize the user and provide a custom interface by showing their
    name, keeping their basket populated, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议的一个重要特性是它是 **无状态的**。这意味着当前请求不知道之前请求发生了什么。这种技术限制存在合理的理由，但很容易克服。在实践中，大多数网站都提供了“登录”功能，以及从一页到另一页携带状态的错觉。当用户登录到网站时，会保存一个用户信息的令牌（通常在客户端，在称为
    **cookies** 的特殊文件中），这样用户发出的每个请求都携带了服务器识别用户并提供定制界面的手段，例如显示他们的名字，保持购物车内容，等等。
- en: 'HTTP defines a set of methods—also known as *verbs* —to indicate the desired
    action to be performed on a given resource. Each of them is different, but some
    of them share some common features. In particular, the ones we will use in our
    API are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 定义了一组方法——也称为 *动词* ——来指示对给定资源要执行的操作。每个方法都不同，但其中一些方法有一些共同的特征。特别是，我们将在我们的
    API 中使用以下方法：
- en: '**GET** : The `GET` method requests a representation of the specified resource.
    Requests using `GET` should only retrieve data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：`GET` 方法请求指定资源的表示。使用 `GET` 的请求应仅用于检索数据。'
- en: '**POST** : The `POST` method is used to submit an entity to the specified resource,
    often causing a change in state or side effects on the server.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：`POST` 方法用于向指定的资源提交一个实体，通常会导致服务器状态的变化或副作用。'
- en: '**PUT** : The `PUT` method requests that the target resource creates or updates
    its state with the state defined by the representation enclosed in the request.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：`PUT` 方法请求目标资源使用请求中封装的表示创建或更新其状态。'
- en: '**DELETE** : The `DELETE` method requests that the target resource delete its
    state.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：`DELETE` 方法请求目标资源删除其状态。'
- en: Other methods are `HEAD` , `CONNECT` , `OPTIONS` , `TRACE` , and `PATCH` . For
    a comprehensive explanation of all of these methods, please refer to [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)
    .
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法有 `HEAD`、`CONNECT`、`OPTIONS`、`TRACE` 和 `PATCH`。关于所有这些方法的全面解释，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)。
- en: The API we are going to write works over HTTP, which means we will write code
    to perform and handle HTTP requests and responses. We will not keep prepending
    “HTTP” to the terms “request” and “response” from now on, as we trust there will
    not be any confusion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的 API 将通过 HTTP 工作，这意味着我们将编写代码来执行和处理 HTTP 请求和响应。从现在起，我们将不再在“请求”和“响应”这两个词前加上“HTTP”，因为我们相信不会引起任何混淆。
- en: Response status codes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应状态码
- en: One thing to know about HTTP responses is that they include a status code, which
    expresses the outcome of the request in a concise way. Status codes consist of
    a number and a brief description, for example, *404 Not Found* . You can check
    the complete list of HTTP status codes at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HTTP响应，有一件事需要知道的是，它们包括一个状态码，以简洁的方式表达请求的结果。状态码由一个数字和简短描述组成，例如，*404 未找到*。您可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)上查看完整的HTTP状态码列表。
- en: 'Status codes are classified in this way:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是这样分类的：
- en: '1xx informational response: The request was received, continuing process.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1xx 信息响应：请求已接收，继续处理。
- en: '2xx successful: The request was successfully received, understood, and accepted.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2xx 成功：请求已成功接收、理解和接受。
- en: '3xx redirection: Further action needs to be taken to complete the request.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3xx 重定向：需要采取进一步的操作以完成请求。
- en: '4xx client error: The request contains bad syntax or cannot be fulfilled.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4xx 客户端错误：请求包含错误的语法或无法满足。
- en: '5xx server error: The server failed to fulfill a valid request.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx 服务器错误：服务器未能满足有效的请求。
- en: When consuming the API, we will receive status codes in the responses, so it
    is important that you at least have an idea about what they mean.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用API时，我们将在响应中接收到状态码，因此您至少应该了解它们的意义。
- en: APIs – An introduction
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API – 简介
- en: Before we delve into the details of this chapter’s specific project, let us
    spend a moment talking about APIs in general.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨本章具体项目的细节之前，让我们花一点时间来谈谈API的一般情况。
- en: What is an API?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是API？
- en: As we mentioned at the beginning of the chapter, API stands for **Application
    Programming Interface** . An API is a set of rules, protocols, and tools for building
    software and applications. It acts as a connection layer between computers, or
    computer programs. In contrast, user interfaces provide a bridge between computers
    and people.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，API代表**应用程序编程接口**。API是一套规则、协议和工具，用于构建软件和应用程序。它充当计算机或计算机程序之间的连接层。相比之下，用户界面在计算机和人们之间提供桥梁。
- en: An API is normally accompanied by a *specification document* , or *standard*
    , which serves as a blueprint that outlines how software components are meant
    to interact. A system that meets the specification is said to implement, or expose,
    the API. The term API can describe both the implementation and the specification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API通常伴随着一份*规范文档*或*标准*，它作为蓝图概述了软件组件应该如何交互。符合规范的系统被称为实现了或公开了API。术语API可以描述实现和规范。
- en: In essence, an API defines the methods and data formats that developers can
    use to interact with a program, a web service, or any other software.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，API定义了开发人员可以使用的方法和数据格式来与程序、网络服务或任何其他软件进行交互。
- en: 'Broadly speaking, there are two types of APIs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，API有两种类型：
- en: 'Web APIs: Accessible over the Internet, they are often used to enable web applications
    to interact with each other or with backend servers. They are the backbone of
    web development, enabling functionalities such as fetching data from a server,
    posting data, or integrating with third-party services like media platforms, payment
    gateways, and so on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API：可通过互联网访问，通常用于使Web应用程序能够相互交互或与后端服务器交互。它们是Web开发的骨架，使诸如从服务器获取数据、发布数据或与第三方服务（如媒体平台、支付网关等）集成等功能成为可能。
- en: 'Frameworks and software libraries: These provide a set of functions and procedures
    that perform specific tasks, and help speed up application development by providing
    building blocks to the developers.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架和软件库：这些提供了一组执行特定任务的函数和过程，并通过为开发人员提供构建块来加速应用程序开发。
- en: In this chapter, we will be focusing on Web APIs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Web API。
- en: An API is normally made of different parts. These are known by different names,
    the most common of which are *methods* , *subroutines* , or *endpoints* (we will
    call them endpoints in this chapter). When we use these parts, the technical term
    for this is *calling* them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API通常由不同的部分组成。这些部分有不同的名称，其中最常见的是*方法*、*子程序*或*端点*（在本章中我们将称其为端点）。当我们使用这些部分时，这个技术的术语是*调用*它们。
- en: The API specification instructs you on how to call each endpoint, what type
    of requests to make, which parameters and headers to pass, which addresses to
    reach, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: API规范指导你如何调用每个端点，要发送什么类型的请求，传递哪些参数和头信息，要到达哪些地址，等等。
- en: What is the purpose of an API?
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API的目的是什么？
- en: There are several reasons to introduce an API into a system. One we have already
    mentioned is to create the means for different applications to communicate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中引入API有几个原因。我们已经提到的一个原因是创建不同应用程序之间通信的手段。
- en: Another important reason is to give access to a system by providing a layer
    through which the external world can communicate with the system itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要原因是，通过提供一个外部世界可以与之通信的系统层的访问权限，来提供对系统的访问。
- en: The API layer takes care of security by performing the **authentication** and
    **authorization** of users, as well as **validation** of all the data that is
    exchanged in the communications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: API层通过执行用户的**认证**和**授权**，以及所有在通信中交换的数据的**验证**来负责安全。
- en: '*Authentication* means the system can validate user credentials to unequivocally
    identify them. *Authorization* means the system can verify what a user has access
    to.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证*意味着系统可以验证用户凭据，明确地识别他们。*授权*意味着系统可以验证用户可以访问的内容。'
- en: Users, systems, and data are checked and validated at the border, and if they
    pass the check, they can interact with the rest of the system (through the API).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用户、系统和数据在边境进行检查和验证，如果通过检查，他们就可以通过API与系统的其余部分进行交互。
- en: This mechanism is conceptually like landing at an airport and having to show
    the border control our passports to be able to interact with the system, which
    is the country we landed in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制在概念上类似于在机场降落并需要向边境控制出示我们的护照才能与系统（即我们降落的该国）进行交互。
- en: 'The fact that the API layer hides the internals of the systems from the outside
    world provides another benefit: if the internal system changes, in terms of technology,
    languages, or even workflows, the API can adapt the way it interfaces to it, but
    still provide a consistent interface to the public side. If we put a letter into
    a letterbox, we do not need to know or control how the postal service will deal
    with it, as long as the letter arrives at the destination. So, the interface (the
    letterbox) is kept consistent, while the other side (the mail carrier, their vehicles,
    technology, workflows, and so on) is free to change and evolve.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: API层隐藏系统内部结构对外部世界的这一事实提供了另一个好处：如果内部系统在技术、语言或甚至工作流程方面发生变化，API可以调整其与系统交互的方式，但仍然向公众提供一致的接口。如果我们把一封信放入信箱，我们不需要知道或控制邮政服务如何处理它，只要信件到达目的地即可。因此，接口（信箱）保持一致，而另一边（邮递员、他们的车辆、技术、工作流程等）可以自由地改变和进化。
- en: It should not be surprising that virtually any electronic device we own today,
    that is connected to the Web, is talking to a (potentially wide) range of APIs
    to perform its tasks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天拥有的几乎所有连接到网络的电子设备都在与（可能广泛的）一系列API进行通信以执行其任务，这并不令人惊讶。
- en: API protocols
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API协议
- en: There are several types of API. They can be open to the public, or private.
    They can provide access to data, services, or both. APIs can be written and designed
    using different methods and standards, and they can employ different protocols.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的API。它们可以是公开的，也可以是私有的。它们可以提供对数据、服务或两者的访问。API可以使用不同的方法和标准编写和设计，并且可以采用不同的协议。
- en: 'These are the most common protocols:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的协议：
- en: '**Hypertext Transfer Protocol/Secure (HTTP/HTTPS)** : The foundation of data
    communication for the Web.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本传输协议/安全（HTTP/HTTPS**）：Web数据通信的基础。'
- en: '**Representational State Transfer (REST)** : Technically not a protocol, but
    rather a type of architecture built over HTTP, APIs designed in this style are
    called RESTful APIs. They are stateless and capable of leveraging data caching.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表征状态转移（REST**）：技术上不是一个协议，而是一种在HTTP之上构建的架构类型，按照这种风格设计的API被称为RESTful API。它们是无状态的，并且能够利用数据缓存。'
- en: '**Simple Object Access Protocol (SOAP)** : A well-established protocol for
    building web services, its messages are normally XML-formatted, and its specification
    is quite strict, which is why this protocol is suitable for situations that require
    high security standards and transactional reliability.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单对象访问协议（SOAP**）：一个建立已久的用于构建Web服务的协议，其消息通常是XML格式的，其规范相当严格，这就是为什么这个协议适用于需要高安全标准和交易可靠性的情况。'
- en: '**GraphQL** : A query language for APIs that employs a type system to define
    the data. Unlike REST, GraphQL uses a single endpoint to allow clients to fetch
    only the data they need.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL**：一种用于API的查询语言，它使用类型系统来定义数据。与REST不同，GraphQL使用单个端点允许客户端获取他们需要的仅有的数据。'
- en: '**WebSocket** : Ideal for applications that require bidirectional communication
    between client and server, as well as real-time data updates. They provide full-duplex
    communication over a single TCP connection.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSocket**：非常适合需要客户端和服务器之间双向通信以及实时数据更新的应用程序。它们通过单个TCP连接提供全双工通信。'
- en: '**Remote Procedural Call (RPC)** : It allows programmers to execute code on
    the server side by remotely calling a procedure (hence the name). These of APIs
    are tightly coupled with the server implementation, so they are usually not made
    for public consumption.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程过程调用 (RPC)**：它允许程序员通过远程调用一个过程（因此得名）在服务器端执行代码。这些API与服务器实现紧密耦合，因此它们通常不用于公共消费。'
- en: API data-exchange formats
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API数据交换格式
- en: We said that an API is an interface between at least two computer systems. It
    would be quite impractical, when interfacing with other systems, to have to shape
    the data into whatever format they implement. Therefore, the API, which provides
    the communication layer between systems, specifies not only the communication
    protocols but also which formats can be adopted for the data exchanges.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，API是至少两个计算机系统之间的接口。在与其他系统接口时，必须将数据格式化为它们实现的任何格式，这将是相当不切实际的。因此，提供系统之间通信层的API不仅指定了通信协议，还指定了可以采用的数据交换格式。
- en: The most common data-exchange formats today are **JSON** , **XML** , and **YAML**
    . We saw JSON in *Chapter 8, Files and Data Persistence* , and we will use it
    as the format for the API of this chapter too. JSON is widely adopted today by
    many APIs, and many frameworks provide the ability to translate data from and
    to JSON, out of the box.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 今天最常见的数据交换格式是**JSON**、**XML**和**YAML**。我们在*第8章，文件和数据持久性*中看到了JSON，我们也将使用它作为本章API的格式。JSON今天被许多API广泛采用，许多框架提供将数据从JSON转换为JSON以及从JSON转换为其他格式的功能。
- en: The railway API
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 铁路API
- en: Now that we have a working knowledge of what an API is, let us turn to something
    more concrete.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对API有了实际的知识，让我们转向更具体的内容。
- en: Before we show you the code, allow us to stress that this code is not production-ready,
    as that would have been too long and needlessly complex for a book’s chapter.
    However, this code is fully functional, and it should provide you with a good
    starting point to learn more, especially if you experiment with it. We will leave
    suggestions on how to do so at the end of this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向您展示代码之前，请允许我们强调，这段代码不是生产就绪的，因为如果要在书籍的章节中展示，这将太长且过于复杂。然而，这段代码是完全功能性的，它应该为你提供一个良好的起点来学习更多，特别是如果你对其进行实验。我们将在本章末尾提供如何做到这一点的建议。
- en: We have a database with some entities that model a railway application. We want
    to allow an external system to perform **CRUD** operations on the database, so
    we are going to write an API to serve as the interface to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个数据库，其中包含一些实体，这些实体模拟了一个铁路应用程序。我们希望允许外部系统对数据库执行**CRUD**操作，因此我们将编写一个API作为其接口。
- en: '**CRUD** stands for **Create** , **Read** , **Update** , and **Delete** . These
    are the four basic database operations. Many HTTP services also model CRUD operations
    through REST or REST-like APIs.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRUD**代表**创建**、**读取**、**更新**和**删除**。这是四个基本的数据库操作。许多HTTP服务也通过REST或类似REST的API来模拟CRUD操作。'
- en: 'Let us start by looking at the project files, so you will have an idea of where
    things are. You can find them in the folder for this chapter, in the source code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看项目文件，这样你就可以知道它们在哪里。你可以在本章的文件夹中找到它们，在源代码中：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Within the `api_code` folder, you can find all the files belonging to the FastAPI
    project. The main application module is `main.py` . We have left the `dummy_data.py`
    script in the code, which you can use to generate a new `train.db` , the database
    file. Make sure you read the `README.md` in this chapter’s folder for instructions
    on how to use it. We have also collected a list of queries to the API for you
    to copy and try out, in `queries.md` .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api_code`文件夹中，你可以找到属于FastAPI项目的所有文件。主要应用程序模块是`main.py`。我们在代码中留下了`dummy_data.py`脚本，你可以使用它来生成新的`train.db`数据库文件。请确保阅读本章文件夹中的`README.md`，以获取有关如何使用它的说明。我们还为你收集了一组API查询，你可以复制并尝试，在`queries.md`中。
- en: 'Within the `api` package, we have the application modules. The database models
    are in `models.py` , and the schemas used to describe them to the API are in `schemas.py`
    . The other modules’ purposes should be evident from their names: `users.py` ,
    `stations.py` , `tickets.py` , `trains.py` , and `admin.py` all contain the definitions
    of the corresponding endpoints of the API. `util.py` contains some utility functions;
    `deps.py` defines the dependency providers; `config.py` holds the configuration
    settings; `crud.py` contains the functions that perform CRUD operations on the
    database and, finally, `.env.example` is a template for you to create a `.env`
    file to provide settings to your application.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api`包中，我们有应用程序模块。数据库模型在`models.py`中，用于描述它们的API的架构在`schemas.py`中。其他模块的用途可以从它们的名称中看出：`users.py`、`stations.py`、`tickets.py`、`trains.py`和`admin.py`都包含API相应端点的定义。`util.py`包含一些实用函数；`deps.py`定义依赖提供者；`config.py`包含配置设置；`crud.py`包含在数据库上执行CRUD操作的功能，最后，`.env.example`是你创建`.env`文件的模板，以向应用程序提供设置。
- en: 'In software engineering, **dependency injection** is a design pattern in which
    an object receives other objects that it depends on, called dependencies. The
    software responsible for constructing and injecting those dependencies is known
    as the *injector* , or *provider* . Hence, a dependency provider is a piece of
    software that creates and provides a dependency, so that other parts of the software
    can use it without having to take care of creating it, setting it up, and disposing
    of it. To learn more about this pattern, please refer to this Wikipedia page:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，**依赖注入**是一种设计模式，其中对象接收它所依赖的其他对象，这些对象被称为依赖。负责构建和注入这些依赖的软件被称为*注入器*或*提供者*。因此，依赖提供者是一段创建并提供依赖的软件，这样软件的其他部分就可以使用它，而无需担心创建、设置和销毁它。要了解更多关于这个模式的信息，请参阅这个维基百科页面：
- en: '[https://en.wikipedia.org/wiki/Dependency_injection](https://en.wikipedia.org/wiki/Dependency_injection)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Dependency_injection](https://en.wikipedia.org/wiki/Dependency_injection)'
- en: Modeling the database
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型化数据库
- en: 'When preparing the entity-relationship schema for this project, we sought to
    design something interesting and, at the same time, simple and contained. This
    application considers four entities: *Stations* , *Trains* , *Tickets* , and *Users*
    . A Train is a journey from one station to another one. A Ticket is a connection
    between a Train and a User. Users can be passengers or administrators, according
    to what they are supposed to be able to do with the API.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这个项目准备实体-关系架构时，我们试图设计一些有趣的东西，同时又要简单且易于控制。这个应用程序考虑了四个实体：*Stations*、*Trains*、*Tickets*和*Users*。一列火车是从一个车站到另一个车站的旅程。一张票是火车和用户之间的连接。用户可以是乘客或管理员，根据他们应该能够使用API做什么。
- en: 'In *Figure 14.2* , you can see the **entity relationship** ( **ER** ) model
    of the database. It describes the four entities and how they relate to one another:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图14.2*中，你可以看到数据库的**实体关系**（**ER**）模型。它描述了四个实体以及它们之间的关系：
- en: '![img](img/B30992_14_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_14_02.png)'
- en: 'Figure 14.2: ER model of the database'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：数据库的ER模型
- en: We have defined the database models using SQLAlchemy, and we have chosen SQLite
    as the DBMS, for simplicity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用SQLAlchemy定义了数据库模型，并选择了SQLite作为DBMS，以保持简单。
- en: If you skipped *Chapter 8, Files and Data Persistence* , this would be a good
    moment to read it, as it will provide you with a foundation to understand the
    models in this chapter’s project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了*第8章，文件和数据持久性*，现在是一个很好的时候去阅读它，因为它将为你提供理解本章项目模型的基础。
- en: 'Let us see the `models` module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`models`模块：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As usual, at the top of the module, we import all that is necessary. We then
    define a couple of variables to indicate the default length of Unicode fields
    ( `UNICODE_LEN` ) and the length of the salt used to hash passwords ( `SALT_LEN`
    ).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在模块顶部，我们导入所有必要的组件。然后我们定义了几个变量来表示Unicode字段的默认长度（`UNICODE_LEN`）和用于散列密码的盐的长度（`SALT_LEN`）。
- en: For a refresher on what a salt is, please refer to *Chapter 9, Cryptography
    and Tokens* .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要回顾一下盐的定义，请参阅*第9章，密码学和令牌*。
- en: 'We also define two enumerations: `Classes` and `Roles` , which will be used
    in the models’ definitions. We used the `StrEnum` class as a base, which was introduced
    in Python 3.11, and makes it possible to compare its members directly to strings.
    The `auto()` function automatically generates values for `Enum` attributes. For
    `StrEnum` , it will set the value to the lowercase version of the attribute name.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了两个枚举：`Classes` 和 `Roles`，这些枚举将在模型定义中使用。我们使用了Python 3.11中引入的`StrEnum`类作为基类，这使得可以直接将枚举成员与字符串进行比较。`auto()`函数会自动为`Enum`属性生成值。对于`StrEnum`，它将值设置为属性名称的小写版本。
- en: 'Let us see the definition of the `Station` model:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Station`模型的定义：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Station` model is quite straightforward. There are a few attributes: `id`
    acts as the primary key, and then we have `code` , `country` , and `city` , which
    (when combined) tell us all we need to know about a station. There are two relationships
    that link station instances to all the trains departing from, and arriving to,
    them. The rest of the code defines the `__repr__()` method, which provides a string
    representation for instances, and whose implementation is also assigned to `__str__()`
    , so the output will be the same whether we call `str(station_instance)` or `repr(station_instance)`
    . This technique is quite commonly adopted to prevent code repetition.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Station`模型相当简单。有几个属性：`id`作为主键，然后是`code`、`country`和`city`，这些属性（当结合使用时）告诉我们关于站点的所有需要知道的信息。有两个关系将站点实例与所有从该站点出发和到达的火车联系起来。其余的代码定义了`__repr__()`方法，它为实例提供字符串表示形式，并且其实现也被分配给`__str__()`，所以无论我们调用`str(station_instance)`还是`repr(station_instance)`，输出都将相同。这种技术相当常见，用于防止代码重复。'
- en: Notice that we defined a unique constraint on the `code` field to ensure that
    no two stations with the same code can exist in the database. Big cities like
    Rome, London, and Paris have more than one train station, so the fields `city`
    and `country` can be the same for stations located in the same city, but each
    of them must have its own unique `code` .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`code`字段上定义了一个唯一约束，以确保数据库中不会存在两个具有相同代码的站点。像罗马、伦敦和巴黎这样的大城市有多个火车站，所以对于位于同一城市的站点，`city`
    和 `country` 字段可以相同，但每个站点都必须有自己的唯一`code`。
- en: 'Following that, we find the definition of the `Train` model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们找到了`Train`模型的定义：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `Train` model, we find all the attributes we need to describe a train
    instance, plus a handy relationship, `tickets` , that gives us access to all the
    tickets that have been created against a train. The `first_class` and `second_class`
    fields hold how many first- and second-class cars a train has.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Train`模型中，我们找到了描述火车实例所需的所有属性，以及一个方便的关系`tickets`，它使我们能够访问针对火车的所有已创建的票。`first_class`和`second_class`字段表示火车有多少个一等和二等车厢。
- en: 'We also added relationships to station instances: `station_from` and `station_to`
    . These allow us to fetch the station instances as objects, instead of only having
    access to their IDs.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了与站点实例的关系：`station_from` 和 `station_to`。这些关系使我们能够以对象的形式获取站点实例，而不仅仅是它们的ID。
- en: 'Next, the `Ticket` model:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Ticket`模型：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `Ticket` has some properties too and includes two relationships: `user` and
    `train` , which point to the user who bought the ticket, and to the train the
    ticket is for, respectively.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket`也有一些属性，并包括两个关系：`user`和`train`，分别指向购买票的用户和票对应的火车。'
- en: Notice how we have used the `Classes` enumeration in the definition of the `car_class`
    attribute. This translates to an enumeration field in the database schema definition.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在`car_class`属性的定义中使用了`Classes`枚举。这对应于数据库模式定义中的枚举字段。
- en: 'Finally, the `User` model:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是`User`模型：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `User` model defines some properties for each user. Note how here we have
    another enumeration used for the user’s role. A user can either be a passenger
    or an admin. This will allow us to present you with a simple example of how to
    write an endpoint that allows access only to authorized users.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`模型为每个用户定义了一些属性。注意这里我们使用了另一个枚举来表示用户的角色。用户可以是乘客或管理员。这将允许我们向您展示一个简单的示例，说明如何编写一个端点，该端点只允许授权用户访问。'
- en: There are a couple of methods on the `User` model that are used to hash and
    validate passwords. You might recall from *Chapter 9, Cryptography and Tokens*
    , that passwords should never be stored in a database in plain text (which means,
    as they are). So, in our API, when saving a password for a user, we create a hash
    and store it alongside the salt that was used for the encryption. In the source
    code for the book, you will find, at the end of this module, the implementation
    of the `_hash()` function, which we have omitted here for brevity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型上有几个方法用于散列和验证密码。您可能还记得在 *第 9 章，密码学和令牌* 中提到，密码永远不应该以纯文本形式存储在数据库中（这意味着，正如它们所是的那样）。因此，在我们的
    API 中，当为用户保存密码时，我们创建一个散列并将其与用于加密的盐一起存储。在本书的源代码中，您将在本模块的末尾找到 `_hash()` 函数的实现，我们在这里省略了它以节省篇幅。'
- en: Main setup and configuration
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要设置和配置
- en: 'Now that we understand the database models, let us inspect the main entry point
    of the application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据库模型，让我们检查应用程序的主要入口点：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is all the code in the `main.py` module. It imports the various endpoint
    modules and includes their routers in the main app. By including a router in the
    main app, we enable the application to serve all the endpoints declared using
    that specific router. We will explain what routers are later in the chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `main.py` 模块中的所有代码。它导入了各种端点模块，并将它们的路由器包含在主应用程序中。通过在主应用程序中包含一个路由器，我们使应用程序能够为使用该特定路由器声明的所有端点提供服务。我们将在本章后面解释什么是路由器。
- en: There is only one endpoint in the main module, which serves as a greeting message.
    An endpoint is a simple function – in this case, `root()` – that contains the
    code to be executed when a request is made against it. When and how this function
    will be invoked depends on the decorator(s) applied to the function. In this case,
    the `app.get()` decorator instructs the API to serve this endpoint when called
    with a GET request. The decorator accepts an argument to specify the URL path
    on which the endpoint will be served. Here, we use `"/"` to specify that this
    endpoint will be found at the root, which is the base URL on which the app is
    running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主模块中只有一个端点，它充当问候消息。端点是一个简单的函数——在这种情况下，`root()` 函数——它包含在对其发起请求时要执行的代码。这个函数何时以及如何被调用取决于应用于函数的装饰器。在这种情况下，`app.get()`
    装饰器指示 API 在收到 GET 请求时提供此端点。装饰器接受一个参数来指定端点将提供的 URL 路径。在这里，我们使用 `"/"` 来指定此端点将在根目录下找到，这是应用程序运行的基本
    URL。
- en: If this API were served at the base URL `http://localhost:8000` , this endpoint
    would be called when we requested either `http://localhost:8000` or `http://localhost:8000/`
    (notice the difference is in the trailing slash).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个 API 在基本 URL `http://localhost:8000` 上提供服务，当请求 `http://localhost:8000` 或
    `http://localhost:8000/`（注意尾部的斜杠不同）时，这个端点会被调用。
- en: Application settings
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序设置
- en: 'Within the greeting message from the last snippet of code, there is a variable,
    `api_version` , taken from the `settings` object. All frameworks allow for a collection
    of settings to be injected into the application to configure its behavior. We
    did not really need to use settings in this example project—we could have just
    hardcoded those values in the main module—but we thought it was worth showing
    you how they work:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码的问候消息中，有一个变量 `api_version`，它来自 `settings` 对象。所有框架都允许将设置集合注入到应用程序中以配置其行为。在这个示例项目中，我们实际上并不需要使用设置——我们可以在主模块中直接硬编码这些值——但我们认为展示它们的工作方式是值得的：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Settings are defined within a Pydantic model ( [https://github.com/pydantic/pydantic](https://github.com/pydantic/pydantic)
    ). **Pydantic** is a library that provides data validation using Python-type annotations.
    Older versions of Pydantic also provided settings management, but that feature
    has been extracted into a separate library called `pydantic-settings` ( [https://github.com/pydantic/pydantic-settings](https://github.com/pydantic/pydantic-settings)
    ), which also adds additional settings management capabilities. In this case,
    we have three pieces of information within the settings:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设置是在 Pydantic 模型中定义的 ([https://github.com/pydantic/pydantic](https://github.com/pydantic/pydantic)).
    **Pydantic** 是一个提供使用 Python 类型注解进行数据验证的库。Pydantic 的旧版本也提供了设置管理功能，但该功能已被提取到一个名为
    `pydantic-settings` 的独立库中 ([https://github.com/pydantic/pydantic-settings](https://github.com/pydantic/pydantic-settings))，该库还增加了额外的设置管理功能。在这种情况下，设置中包含三条信息：
- en: '`secret_key` : Used to sign and verify JSON Web Tokens (JWTs).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret_key`：用于签名和验证 JSON Web Tokens (JWT)。'
- en: '`debug` : When set to `True` , it instructs the SQLAlchemy engine to log verbosely,
    which is helpful to debug queries.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：当设置为`True`时，它指示SQLAlchemy引擎详细记录，这对于调试查询很有帮助。'
- en: '`api_version` : The version of the API. We do not really make use of this information,
    apart from displaying it in the greeting message, but normally the version plays
    an important role because it is tied to a specific API specification.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api_version`：API的版本。我们实际上并没有真正使用这个信息，除了在问候消息中显示它之外，但通常版本起着重要的作用，因为它与特定的API规范相关联。'
- en: 'FastAPI plucks these settings from a `.env` file, as specified when we create
    the `SettingsConfigDict` instance. Here is how that file looks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI从创建`SettingsConfigDict`实例时指定的`.env`文件中提取这些设置。以下是该文件的外观：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this to work, FastAPI needs help from a library called `python-dotenv` .
    It is part of this chapter’s requirements, so if you have installed them in your
    virtual environment, you are all set.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，FastAPI需要从名为`python-dotenv`的库中获得帮助。它是本章要求的一部分，所以如果你已经在你的虚拟环境中安装了它们，你就准备好了。
- en: Station endpoints
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 站点端点
- en: We are going to explore some FastAPI endpoints. Because this API is CRUD-oriented,
    there is some repetition in the code. We will therefore show you one example for
    each of the CRUD operations, and we will do so by using the `Station` endpoints
    examples. Please refer to the source code to explore the endpoints related to
    the other models. You will find that they all follow the same patterns and conventions.
    The main difference is that they relate to different database models.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一些FastAPI端点。因为这个API是面向CRUD的，所以代码中有些重复。因此，我们将为每个CRUD操作展示一个示例，我们将通过使用`Station`端点示例来实现这一点。请参考源代码以探索与其它模型相关的端点。你会发现它们都遵循相同的模式和约定。主要区别是它们与不同的数据库模型相关。
- en: Reading data
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取数据
- en: Let us start our exploration with a GET request. In this case, we are going
    to get all the stations in the database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个GET请求开始我们的探索。在这种情况下，我们将获取数据库中的所有站点。
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Within the `stations.py` module, we start by importing the necessary objects
    from the `typing` module, and from `fastapi` . We also import `Session` from `sqlalchemy`
    , and a few other tools from the local codebase.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stations.py`模块中，我们首先从`typing`模块和`fastapi`模块导入必要的对象。我们还从`sqlalchemy`导入`Session`，以及从本地代码库导入一些其他工具。
- en: The endpoint `get_stations()` is decorated with a `router` object, instead of
    `app` like in the main file. `APIRouter` can be thought of as a mini `FastAPI`
    class, in that it takes all the same arguments. We declare `router` and assign
    a prefix to it ( `"` `/stations"` , in this case), which means all functions decorated
    with this router become endpoints that can be called at addresses that start with
    `http://localhost:8000/stations` . In this case, the empty string fed to the `router.get()`
    method instructs the app to serve this endpoint on the root URL for this router,
    which will be the concatenation of the base URL and the router prefix, as explained
    above.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_stations()`端点用`router`对象装饰，而不是像主文件中那样用`app`。`APIRouter`可以被视为一个迷你`FastAPI`类，因为它接受所有相同的参数。我们声明`router`并给它分配一个前缀（在这种情况下是`"/stations"`），这意味着所有用这个`router`装饰的函数都成为可以调用以`http://localhost:8000/stations`开头的地址的端点。在这种情况下，传递给`router.get()`方法的空字符串指示应用程序在这个路由器的根URL上提供此端点，这将是基础URL和路由器前缀的连接，如上所述。'
- en: FastAPI provides a couple of alternative ways to specify the type of data returned
    from an endpoint. One is to pass a `response_model` argument to the decorator.
    In our case, though, it is enough to specify the return value of the function
    using type annotations. For this endpoint, we return a list of `Station` instances.
    We will see their implementation shortly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI提供了一些指定从端点返回的数据类型的方法。一种是将`response_model`参数传递给装饰器。然而，在我们的情况下，仅使用类型注解指定函数的返回值就足够了。对于此端点，我们返回一个`Station`实例的列表。我们很快就会看到它们的实现。
- en: The `tags` argument is used for documentation purposes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`参数用于文档目的。'
- en: The function itself takes some arguments, which are a database session, `db`
    , and an optional string, `code` , which, when specified, will instruct the endpoint
    to serve only the stations whose `code` field matches the one provided.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身接受一些参数，这些参数是一个数据库会话，`db`，以及一个可选的字符串，`code`，当指定时，将指示端点只提供`code`字段与提供的匹配的站点。
- en: 'A few things to notice:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 几个需要注意的事项：
- en: Data coming with the request, such as query parameters, is specified in the
    endpoint declaration. If the endpoint function requires data to be sent in the
    body of the request, this is specified using Pydantic models (in this project,
    they are defined in the `schemas.py` module).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随请求一起发送的数据，如查询参数，在端点声明中指定。如果端点函数需要在请求体中发送数据，则使用Pydantic模型（在本项目中，它们在`schemas.py`模块中定义）来指定。
- en: Whatever an endpoint returns becomes the body of the response. FastAPI will
    try to serialize the returned data to JSON. However, when the response model is
    set, serialization goes first through the Pydantic model specified in `response_model`
    , and then from the Pydantic model to JSON.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点返回的任何内容都成为响应体。FastAPI将尝试将返回的数据序列化为JSON。然而，当设置了响应模型时，序列化首先通过`response_model`中指定的Pydantic模型进行，然后从Pydantic模型到JSON。
- en: To use a database session in the body of an endpoint, we use a dependency provider,
    which, in this case, is specified using the `Depends` class, to which we pass
    the `get_db()` `function` . This function yields a local database session and
    closes it when the endpoint call terminates.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在端点体中使用数据库会话，我们使用依赖提供者，在这种情况下，使用`Depends`类来指定，我们将`get_db()`函数传递给它。此函数产生一个本地数据库会话，并在端点调用结束时关闭它。
- en: We use the `Optional` class, from the `typing` module, to specify that parameters
    are optional in a request.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`typing`模块中的`Optional`类来指定请求中的参数是可选的。
- en: The body of the `get_stations()` function simply calls the function of the same
    name from the `crud` module and returns the resulting value. All the functions
    that regulate the interaction with the database live in the `crud.py` module.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_stations()`函数的体只是调用来自`crud`模块的同名函数，并返回结果值。所有管理数据库交互的函数都位于`crud.py`模块中。'
- en: 'This was a design choice that should make this code easier to reuse and test.
    Moreover, it simplifies reading the entry point code. Let us see the body of `get_stations()`
    in the `crud.py` module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设计选择，应该使此代码更容易重用和测试。此外，它简化了读取入口点代码。让我们看看`crud.py`模块中`get_stations()`函数的体：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how similar this function’s signature is to the one for the endpoint
    that calls it. `get_stations()` selects and returns all instances of `Station`
    , optionally filtered by `code` (in case it is not `None` ).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数的签名与调用它的端点签名是多么相似。`get_stations()`选择并返回所有`Station`实例，可选地按`code`（如果它不是`None`）过滤。
- en: 'To start the API, activate your virtual environment and run the following command
    from within the `api_code` folder:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动API，请激活您的虚拟环境，并在`api_code`文件夹内运行以下命令：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Uvicorn** is a lightning-fast **ASGI server** , built on `uvloop` and `httptools`
    . It works seamlessly with both normal and asynchronous functions.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Uvicorn**是一个闪电般的**ASGI服务器**，基于`uvloop`和`httptools`构建。它与正常和异步函数无缝工作。'
- en: 'From the ASGI documentation page ( [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/)
    ):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从ASGI文档页面（[https://asgi.readthedocs.io/](https://asgi.readthedocs.io/)）：
- en: '**ASGI** ( **Asynchronous Server Gateway Interface** ) is a spiritual successor
    to **WSGI** ( **Web Server Gateway Interface** ), intended to provide a standard
    interface between async-capable Python web servers, frameworks, and applications.'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ASGI**（**异步服务器网关接口**）是**WSGI**（**Web服务器网关接口**）的精神继承者，旨在为具有异步能力的Python网络服务器、框架和应用程序提供标准接口。'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where WSGI provided a standard for synchronous Python apps, ASGI provides one
    for both asynchronous and synchronous apps, with a WSGI backwards-compatibility
    implementation and multiple servers and application frameworks.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: WSGI为同步Python应用提供了一个标准，ASGI为异步和同步应用提供了一个标准，具有WSGI向后兼容的实现以及多个服务器和应用程序框架。
- en: For this chapter’s project, we have chosen to write synchronous code as the
    asynchronous equivalent would have only made the code more difficult to understand.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的项目，我们选择编写同步代码，因为异步代码会使代码更难以理解。
- en: If you are comfortable writing asynchronous code, please refer to the FastAPI
    documentation ( [https://fastapi.tiangolo.com](https://fastapi.tiangolo.com) )
    to learn how to write asynchronous endpoints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉编写异步代码，请参阅FastAPI文档（[https://fastapi.tiangolo.com](https://fastapi.tiangolo.com)），了解如何编写异步端点。
- en: The `--reload` flag in the `uvicorn` command above configures the server to
    automatically reload whenever a file is saved. It is optional, but quite useful
    for saving time when you are working on the API source code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `uvicorn` 命令中的 `--reload` 标志配置服务器在文件保存时自动重新加载。这是可选的，但当你正在处理 API 源代码时，它可以节省很多时间。
- en: 'If we called the `get_stations()` endpoint, this is what we would see:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `get_stations()` 端点，我们会看到以下内容：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the command we are using to call the API: `http` . This is a command
    that comes with the **Httpie** utility.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们用来调用 API 的命令：`http`。这是一个随 **Httpie** 工具一起提供的命令。
- en: You can find Httpie at [https://httpie.io](https://httpie.io) . Httpie is a
    user-friendly command-line HTTP client for the API era. It comes with JSON support,
    syntax highlighting, persistent sessions, wget-like downloads, plugins, and more.
    There are other tools to perform requests, such as **curl** . The choice is up
    to you, as it makes no difference which tool you use to make requests from the
    command line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://httpie.io](https://httpie.io) 找到 Httpie。Httpie 是一个针对 API 时代的用户友好的命令行
    HTTP 客户端。它包含 JSON 支持、语法高亮、持久会话、类似 wget 的下载、插件等功能。还有其他工具可以执行请求，例如 **curl**。选择权在你，因为使用哪个工具从命令行发送请求并没有区别。
- en: The API is served by default at `http://localhost:8000` . You can add arguments
    to the `uvicorn` command to customize this, if you so desire.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，API 在 `http://localhost:8000` 上提供服务。如果你愿意，你可以向 `uvicorn` 命令添加参数来自定义这一点。
- en: The first few lines of the response are information from the API engine. We
    learn the protocol used was HTTP1.1, and that the request succeeded (status code
    *200 OK* ). We have info on the content length, and its type, which is JSON. Finally,
    we get a timestamp and the type of server. We are going to omit the part of this
    information that just repeats, from now on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的前几行是来自 API 引擎的信息。我们了解到使用的协议是 HTTP1.1，请求成功（状态码 *200 OK*）。我们还有关于内容长度和类型的详细信息，它是
    JSON 类型。最后，我们得到了一个时间戳和服务器类型。从现在开始，我们将省略这些信息中重复的部分。
- en: The body of the response is a list of `Station` instances, in their JSON representation,
    thanks to `list[Station` ] type annotation, which we indicated in the function
    signature.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体是一个 `Station` 实例的列表，它们的 JSON 表示形式，这要归功于我们在函数签名中指定的 `list[Station]` 类型注解。
- en: 'If we were to search by `code` , for example, the London station, we could
    use the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们按 `code` 搜索，比如伦敦车站，我们可以使用以下命令：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above command uses the same URL as before but adds the `code` query parameter
    (separated from the URL path with a `?` ). The result is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用与之前相同的 URL，但添加了 `code` 查询参数（用 `?` 与 URL 路径分开）。结果是以下内容：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we got one match, which corresponds to the London station, but still,
    it is returned as a list, as indicated by the type annotation for this endpoint.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们得到了一个匹配项，对应于伦敦车站，但仍然以列表的形式返回，正如该端点的类型注解所指示的。
- en: 'Let us now explore an endpoint dedicated to fetching a single station by ID:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索一个用于通过 ID 获取单个车站的端点：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For this endpoint, we configure the router to accept GET requests, at the URL
    `http://localhost:8000/stations/{station_id}` , where `station_id` will be an
    integer. Hopefully, the way URLs are constructed is starting to make sense for
    you. There is the base part, `http://localhost:8000` , then the prefix for the
    router, `/stations` , and finally, the specific URL information that we feed to
    each endpoint, which in this case is `/{station_id}` .
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此端点，我们配置路由器以接受 GET 请求，在 URL `http://localhost:8000/stations/{station_id}`
    上，其中 `station_id` 将是一个整数。希望 URL 的构建方式对你来说开始变得有意义。有基础部分 `http://localhost:8000`，然后是路由器的前缀
    `/stations`，最后是我们提供给每个端点的特定 URL 信息，在这种情况下是 `/{station_id}`。
- en: 'Let us fetch the Kyiv station, with ID `3` :'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取 ID 为 `3` 的基辅车站：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how this time we got back an object by itself, instead of it being wrapped
    in a list like it was in the `get_stations()` endpoint. This is in accordance
    with the type annotation for this endpoint, which is set to `Station` , and it
    makes sense, as we are fetching a single object by ID.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次我们得到了一个单独的对象，而不是像在 `get_stations()` 端点那样被列表包裹。这与该端点的类型注解一致，设置为 `Station`，这是有道理的，因为我们通过
    ID 获取单个对象。
- en: The `get_station()` function takes the `station_id` , type-annotated as an integer,
    and the usual `db` session object. Using type annotations to specify parameters
    allows FastAPI to do data validation on the type of the arguments we use when
    calling an endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_station()`函数接受一个`station_id`，类型注解为整数，以及通常的`db`会话对象。使用类型注解来指定参数允许FastAPI在我们调用端点时对参数的类型进行数据验证。'
- en: 'If we were to pass a non-integer value for `station_id` , this would happen:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`station_id`传递一个非整数值，会发生以下情况：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice we had to abridge the error message due to its length. FastAPI responds
    with useful information: `station_id` , from the path, is not a valid integer.
    Notice also that the status code is *422 Unprocessable Entity* , as opposed to
    *200 OK* , this time. In general, errors in the four hundreds ( *4xx* ) express
    client errors, while errors in the five hundreds ( *5xx* ) express server errors.
    In this case, we are making a call using an incorrect URL (we are not using an
    integer). Therefore, it is an error on the client side. Other API frameworks would
    return a simple *400 Bad Request* status code in the same scenario, but FastAPI
    returns *422 Unprocessable Entity* , which is oddly specific. It is easy though,
    in FastAPI, to customize which status would be returned upon a bad request; there
    are examples in the official documentation.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不得不缩短错误信息，因为它太长了。FastAPI响应提供了有用的信息：来自路径的`station_id`不是一个有效的整数。注意，这次状态码是*422
    Unprocessable Entity*，而不是*200 OK*。一般来说，四百（*4xx*）的错误表示客户端错误，而五百（*5xx*）的错误表示服务器错误。在这种情况下，我们使用了一个错误的URL（我们没有使用整数）。因此，这是一个客户端的错误。在其他API框架中，相同的场景可能会返回一个简单的*400
    Bad Request*状态码，但FastAPI返回了奇特的特定状态码*422 Unprocessable Entity*。不过，在FastAPI中，很容易自定义在请求错误时返回的状态码；官方文档中有示例。
- en: 'Let us see what happens when we try to fetch a station with an ID that does
    not exist:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们尝试获取一个不存在的ID的站点时会发生什么：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time the URL is correct, in that `station_id` is an integer; however, there
    is no station with ID 100. The API returns the *404 Not Found* status, as the
    response body tells us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这次URL是正确的，因为`station_id`是一个整数；然而，没有ID为100的站点。API返回了*404 Not Found*状态，正如响应体所告知的。
- en: 'If you go back to the code of this endpoint, you will notice how straightforward
    its logic is: provided that the arguments passed are correct—in other words, they
    respect the type—it tries to fetch the corresponding station from the database
    by using another simple function from the `crud` module. If the station is not
    found, it raises an `HTTPException` with the desired status code (404) and a detail
    that will hopefully help the consumer understand what went wrong. If the station
    is found, then it is returned. The process of returning a JSON serialized version
    of objects is done automatically by FastAPI. The object retrieved from the database
    is a SQLAlchemy instance of the `Station` class ( `models.Station` ). That instance
    is fed to the Pydantic `Station` class ( `schemas.Station` ), which is used to
    produce a JSON representation that is then returned by the endpoint.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到这个端点的代码，你会注意到它的逻辑是多么简单：只要传入的参数是正确的——换句话说，它们尊重类型——它就会尝试通过`crud`模块中的另一个简单函数从数据库中获取相应的站点。如果找不到站点，它将抛出一个带有期望状态码（404）和详细信息的`HTTPException`，希望这能帮助消费者理解出了什么问题。如果找到了站点，则将其返回。返回对象的JSON序列化版本的过程是由FastAPI自动完成的。从数据库检索到的对象是`Station`类的SQLAlchemy实例（`models.Station`）。该实例被喂给Pydantic的`Station`类（`schemas.Station`），用于生成随后由端点返回的JSON表示。
- en: 'This might seem complicated, but it is an excellent example of decoupling.
    FastAPI takes care of the workflow, and all we need to do is take care of the
    wiring: request parameters, response models, dependencies, and so on.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很复杂，但它是一个优秀的解耦示例。FastAPI负责工作流程，而我们只需要负责连接：请求参数、响应模型、依赖关系等等。
- en: Creating data
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据
- en: 'Let us now see something a bit more interesting: how to create a station. First,
    the endpoint:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些更有趣的东西：如何创建一个站点。首先，是端点：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This time, we instruct the router that we want to accept a POST request to
    the root URL (remember: base part, plus router prefix). We type-annotate the return
    to be `Station` , as the endpoint will be returning the newly created object,
    and we also specify the default status code for the response, which is `201 Created`
    .'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们指示路由器我们想要接受对根URL的POST请求（记住：基础部分，加上路由器前缀）。我们将返回类型注解为`Station`，因为端点将返回新创建的对象，我们还指定了响应的默认状态码，即`201
    Created`。
- en: The `create_station()` function takes the usual `db` session and a `station`
    object. The `station` object is created for us, behind the scenes. FastAPI takes
    the data from the body of the request and feeds it to the Pydantic schema `StationCreate`
    . That schema defines all the data we need to receive, and the result is the `station`
    object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_station()` 函数接受一个 `db` 会话和一个 `station` 对象。`station` 对象是由我们创建的，在幕后。FastAPI
    从请求体中提取数据并将其馈送到 Pydantic 模式 `StationCreate` 。该模式定义了我们需要接收的所有数据，结果是 `station` 对象。'
- en: 'The logic in the body follows this flow: it tries to get a station using the
    code provided; if a station is found, we cannot create one with that data. The
    code field is defined to be unique. Therefore, creating a station with the same
    code would result in a database error. Hence, we return status code *400 Bad Request*
    , informing the caller that the station already exists. If the station is not
    found, we can instead proceed to create it and return it. Let us see the declaration
    of the Pydantic schemas involved:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 主体中的逻辑遵循以下流程：它尝试使用提供的代码获取一个站点；如果找到了站点，我们无法使用该数据创建一个相同的站点。代码字段被定义为唯一的。因此，使用相同代码创建站点会导致数据库错误。因此，我们返回状态码
    *400 Bad Request* ，通知调用者该站点已存在。如果未找到站点，我们可以继续创建它并返回它。让我们看看涉及的 Pydantic 模式的声明：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how we used inheritance to define the schemas. It is normal practice to
    have a base schema that provides functionalities common to all children. Then,
    each child specifies its needs separately. In this case, in the base schema, we
    have `code` , `country` , and `city` . When fetching stations, we also want to
    return the `id` , so we specify that in the `Station` class. Moreover, since this
    class is used to translate SQLAlchemy objects, we need to tell the model about
    it, and we do so by specifying the `model_config` attribute. Remember that SQLAlchemy
    is an **object-relational mapping** ( **ORM** ), so we need to tell the model
    to read the attributes of an object by setting `from_attributes=True` .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用继承来定义模式。通常的做法是有一个提供所有子类共同功能的基模式。然后，每个子类分别指定其需求。在这种情况下，在基模式中，我们有 `code`、`country`
    和 `city`。在检索站点时，我们还想返回 `id`，所以我们指定了 `Station` 类。此外，由于此类用于转换 SQLAlchemy 对象，我们需要告诉模型关于它的信息，我们通过指定
    `model_config` 属性来实现。记住，SQLAlchemy 是一个 **对象关系映射**（**ORM**），因此我们需要告诉模型通过设置 `from_attributes=True`
    来读取对象的属性。
- en: The `StationCreate` model does not need anything extra, so we simply use the
    `pass` instruction as a body.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`StationCreate` 模型不需要额外内容，所以我们只需使用 `pass` 指令作为主体。'
- en: 'Let us now see the CRUD functions for this endpoint:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看此端点的 CRUD 函数：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `get_station_by_code()` function is fairly simple. It selects a `Station`
    object with a case-insensitive match on `code` (the “i” prefix in `ilike()` means
    case-insensitive).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_station_by_code()` 函数相当简单。它通过在 `code` 上进行不区分大小写的匹配来选择一个 `Station` 对象（`ilike()`
    中的“i”前缀表示不区分大小写）。'
- en: There are other ways to perform a case-insensitive comparison, which do not
    involve using `ilike` . Those might be the right way to go when performance is
    important, but for this chapter’s purpose, we found the simplicity of `ilike`
    to be exactly what we needed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以进行不区分大小写的比较，而不涉及使用 `ilike`。当性能很重要时，这些可能正是正确的做法，但为了本章的目的，我们发现 `ilike`
    的简单性正是我们所需要的。
- en: The `create_station()` function takes a `db` session and a `StationCreate` instance.
    First, we get the station data in the form of a Python dictionary (by calling
    `model_dump()` ). We know all data must be there; otherwise, the endpoint would
    have already failed during the initial Pydantic validation stage.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_station()` 函数接受一个 `db` 会话和一个 `StationCreate` 实例。首先，我们以 Python 字典的形式获取站点数据（通过调用
    `model_dump()`）。我们知道所有数据都必须在那里；否则，端点已经在初始 Pydantic 验证阶段失败。'
- en: Using the data from `station.model_dump()` , we create an instance of the SQLAlchemy
    `Station` model. We add it to the database, commit the transaction, and return
    it. Note that when we initially create the `db_station` object, it does not have
    an `id` attribute. The `id` is automatically assigned by the database engine when
    the row is inserted into the `stations` table (which happens when we call `db.commit()`
    ). SQLAlchemy will automatically set the `id` attribute when we call `commit()`
    .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `station.model_dump()` 的数据，我们创建了一个 SQLAlchemy `Station` 模型的实例。我们将其添加到数据库中，提交事务，并返回它。请注意，当我们最初创建
    `db_station` 对象时，它没有 `id` 属性。`id` 是在将行插入 `stations` 表（在我们调用 `db.commit()` 时发生）时由数据库引擎自动分配的。当调用
    `commit()` 时，SQLAlchemy 将自动设置 `id` 属性。
- en: 'Let us see this endpoint in action. Notice how we need to specify `POST` to
    the `http` command, which allows us to send data, in JSON format, within the body
    of the request. Previous requests were of the GET type, which is the default type
    for the `http` command. Notice also that we have split the command over two lines
    due to the book’s line length constraints:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个端点的实际效果。注意我们如何需要指定`POST`到`http`命令，这允许我们在请求体中发送数据，格式为JSON。之前的请求是GET类型，这是`http`命令的默认类型。注意，我们还因为书籍的行长度限制而将命令拆分成了两行：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We successfully created a station. Let us now try again, but this time omitting
    the code, which is mandatory:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功创建了一个站点。现在让我们再次尝试，但这次省略了强制性的代码：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As expected, we get a *422 Unprocessable Entity* status code again, because
    the Pydantic `StationCreate` model validation failed, and the response body tells
    us why: `code` is missing in the body of the request. It also provides a useful
    link to look up the error.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们再次得到了*422 Unprocessable Entity*状态码，因为Pydantic `StationCreate`模型验证失败，响应体告诉我们原因：请求体中缺少`code`。它还提供了一个有用的链接来查找错误。
- en: Updating data
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'The logic to update a station is a bit more complex. Let us go through it together.
    First, the endpoint:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更新站点的逻辑稍微复杂一些。让我们一起来过一遍。首先，端点：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The router is instructed to listen for a PUT request, which is the type you
    should use to modify a web resource. The URL terminates with the `station_id`
    , which identifies the station we want to update. The function takes the `station_id`
    , a Pydantic `StationUpdate` instance, and the usual `db` session.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 路由被指示监听PUT请求，这是您应该用于修改网络资源的类型。URL以`station_id`结尾，它标识了我们想要更新的站点。该函数接受`station_id`、Pydantic
    `StationUpdate`实例以及常规的`db`会话。
- en: We start by fetching the desired station from the database. If the station is
    not found in the database, we simply return a *404 Not Found* status code, as
    there is nothing to update. Otherwise, we update the station and return a *204
    No Content* status code, which is the common way to respond to a PUT request.
    We could also have returned *200 OK* , but in that case, we should have returned
    the updated resource within the body of the response.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从数据库中检索所需的站点。如果站点在数据库中未找到，我们简单地返回*404 Not Found*状态码，因为没有要更新的内容。否则，我们更新站点并返回*204
    No Content*状态码，这是对PUT请求的常见响应方式。我们也可以返回*200 OK*，但那样的话，我们应该在响应体中返回更新的资源。
- en: 'The Pydantic model for a station update is this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 站点更新的Pydantic模型如下：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All properties are declared as `Optional` because we want to allow the caller
    to pass only what they wish to update.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都声明为`Optional`，因为我们希望允许调用者只传递他们希望更新的内容。
- en: 'Let us see the code for the CRUD function responsible for updating a station:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看负责更新站点的CRUD函数的代码：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `update_station()` function takes the necessary arguments to identify the
    station to update, and the station data that will be used to update the record
    in the database, plus the usual `db` session.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_station()`函数接受识别要更新的站点的必要参数，以及将用于更新数据库中记录的站点数据，以及常规的`db`会话。'
- en: We build a statement using the `update()` helper from `sqlalchemy` . We use
    `where()` to filter the station by `id` , and we specify the new values by asking
    the Pydantic station object to give us a Python dictionary excluding anything
    that has not been passed to the call. This serves the purpose of allowing partial
    updates to be executed. If we omitted `exclude_unset=True` from the code, any
    argument that was not passed would end up in the dictionary, set to its default
    value ( `None` ).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sqlalchemy`的`update()`辅助函数构建一个语句。我们使用`where()`通过`id`过滤站点，并通过要求Pydantic站点对象给我们一个Python字典（排除任何未传递给调用的内容）来指定新值。这有助于执行部分更新。如果我们从代码中省略了`exclude_unset=True`，任何未传递的参数最终都会出现在字典中，并设置为默认值（`None`）。
- en: Strictly speaking, we should use a PATCH request to do a partial update, but
    it is fairly common to use PUT for both complete and partial updates.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们应该使用PATCH请求进行部分更新，但使用PUT请求进行完整和部分更新相当常见。
- en: We execute the statement and return the number of rows affected by this operation.
    We do not use this information in the endpoint body, but it would be a nice exercise
    for you to do it. We will see how to make use of that information in the endpoint
    that deletes a station.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行该语句并返回此操作影响的行数。我们不在端点体中使用此信息，但这对您来说是一个很好的练习。我们将看到如何在删除站点的端点中使用这些信息。
- en: 'Let us use this endpoint on the station we created in the previous section,
    with ID `12` :'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一节中创建的ID为`12`的站点的此端点：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We got what we expected. Let us verify that the update was successful:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的结果。让我们验证更新是否成功：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All three properties of the object with ID `12` have been changed. Let us now
    try a partial update:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对ID为`12`的对象的所有三个属性都已更改。现在让我们尝试部分更新：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time we only updated the station code. Let us verify again:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只更新了站点代码。让我们再次验证：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As expected, only `code` was changed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，只有`code`被更改。
- en: Deleting data
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'Finally, let us explore how to delete a station. As usual, let us start with
    the endpoint:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们探索如何删除一个站点。像往常一样，让我们从端点开始：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To delete stations, we instruct the router to listen for a DELETE request. The
    URL is the same one we used to get a single station, as well as to update one.
    It is the HTTP verb we choose that triggers the right endpoint. The `delete_station()`
    function takes `station_id` and the `db` session.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除站点，我们指示路由器监听DELETE请求。URL与我们用来获取单个站点以及更新站点的URL相同。我们选择的HTTP动词触发了正确的端点。`delete_station()`函数接受`station_id`和`db`会话。
- en: Inside the body of the endpoint, we get the number of rows affected by the operation.
    In this case, if there is one, we return a *204 No Content* status code, which
    tells the caller that the deletion was successful. If no rows were affected, we
    return a *404 Not Found* status code. Notice that we could have written the update
    method exactly like this, making use of the number of affected rows, but we chose
    another approach there so that you had a different example to learn from.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点的主体内部，我们获取操作影响的行数。在这种情况下，如果有，我们返回一个*204 No Content*状态码，这告诉调用者删除是成功的。如果没有行受到影响，我们返回一个*404
    Not Found*状态码。请注意，我们可以像这样编写更新方法，利用受影响的行数，但我们选择了另一种方法，这样你就有不同的例子可以学习。
- en: 'Let us see the `CRUD` function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`CRUD`函数：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function makes use of the `delete()` helper from `sqlalchemy` . Similar
    to what we did for the update scenario, we create a statement that identifies
    a station by ID and instructs for its deletion. We execute the statement and return
    the number of affected rows.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用了来自`sqlalchemy`的`delete()`辅助函数。类似于我们为更新场景所做的那样，我们创建了一个通过ID识别站点并指示其删除的语句。我们执行该语句并返回受影响的行数。
- en: 'Let us see this endpoint in action, on a successful scenario first:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个端点在实际场景中的表现，首先是一个成功的场景：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We got a *204 No Content* status code, which tells us the deletion was successful.
    Let us verify it indirectly by trying to delete the station with ID `12` again.
    This time we expect the station to be gone, and a *404 Not Found* status code
    in return:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个*204 No Content*状态码，这告诉我们删除是成功的。让我们通过再次尝试删除ID为`12`的站点来间接验证它。这次我们预计站点将消失，并返回一个*404
    Not Found*状态码：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As expected, we received a *404 Not Found* status code, which means a station
    with ID 12 was not found, proving that the first attempt to delete it was successful.
    There are a few more endpoints in the `stations.py` module, which you should check
    out.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们收到了*404 Not Found*状态码，这意味着ID为12的站点未找到，这证明了删除它的第一次尝试是成功的。`stations.py`模块中还有几个更多端点，你应该检查一下。
- en: The other endpoints we have written are there to create, read, update, and delete
    users, trains, and tickets. Apart from the fact that they act on different database
    and Pydantic models, they would not really bring any more insight to this exposition.
    Therefore, let us instead look at an example of how to authenticate a user.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的其他端点用于创建、读取、更新和删除用户、火车和车票。除了它们作用于不同的数据库和Pydantic模型之外，它们实际上不会为这个展示带来更多的见解。因此，让我们看看如何验证用户身份的一个例子。
- en: User authentication
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: Authentication, in this project, is done via a JWT. Once again, please refer
    to *Chapter 9, Cryptography and Tokens* , for a refresher on JWTs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，身份验证是通过JWT完成的。请再次参考*第9章，密码学和令牌*，以刷新JWT的知识。
- en: 'Let us start from the authentication endpoint, in the `users.py` module:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`users.py`模块中的身份验证端点开始：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This router has the prefix `"` `/users"` . To authenticate a user, we need to
    make a POST request to this endpoint. It takes a Pydantic `Auth` schema, the usual
    `db` session, and the `settings` object, which is needed to provide the secret
    key that is used to create the token.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由器具有前缀`"` `/users"` 。为了验证用户，我们需要向此端点发送POST请求。它需要一个Pydantic `Auth`模式，一个常规的`db`会话，以及`settings`对象，该对象用于提供用于创建令牌的秘密密钥。
- en: 'If the user is not found, we return a *404 Not Found* status code. If the user
    is found, but the password provided does not correspond to the one in the database
    record, we return status code *401 Unauthorized* . Finally, if the user is found
    and the password is correct, we create a token with two claims: `email` and `role`
    . We will use the role to perform authorization functions.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到用户，我们返回`404 Not Found`状态码。如果找到用户，但提供的密码与数据库记录中的密码不匹配，我们返回状态码`401 Unauthorized`。最后，如果找到用户且密码正确，我们创建一个带有两个声明的令牌：`email`和`role`。我们将使用角色来执行授权功能。
- en: 'The `create_token()` function is a wrapper around `jwt.encode()` that also
    adds a couple of timestamps to the payload of the token. It is not worth showing
    that code here. Let us instead see the `Auth` model:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_token()`函数是`jwt.encode()`的包装器，它还在令牌的有效载荷中添加了几个时间戳。在这里展示那段代码不值得。让我们看看`Auth`模型：'
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We authenticate users with their email (which serves as the username) and password.
    That is why, in the SQLAlchemy `User` model, we have set up a uniqueness constraint
    on the `email` field. We need each user to have a unique username, and email is
    a commonly used field for this need.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用用户的电子邮件（作为用户名）和密码来认证用户。这就是为什么在SQLAlchemy的`User`模型中，我们在`email`字段上设置了一个唯一性约束。我们需要每个用户都有一个唯一的用户名，而电子邮件是满足这一需求常用的字段。
- en: 'Let us exercise this endpoint:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习这个端点：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We got a token back (abridged, in the snippet), so we can use it. The user
    we have authenticated is an admin, so we are going to show you how we could have
    written the endpoint to delete a station if we wanted to allow only admins to
    do so. Let us see the code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了一个令牌（在片段中省略），因此我们可以使用它。我们认证的用户是管理员，因此我们将向您展示如果我们只想允许管理员这样做，我们如何编写删除端点的代码。让我们看看代码：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this example, you can see that the endpoint declaration and body are nearly
    the same as their naïve counterpart, with one important difference: before attempting
    to delete anything, we call `ensure_admin()` . In the endpoint, we need to grab
    the authorization header from the request, which is responsible for bearing the
    token information, so that we can pass it to the `ensure_admin()` function. We
    do this by declaring it in the function signature, as an optional string that
    comes from the `Header` object.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以看到端点声明和主体几乎与它们的直观对应物相同，但有一个重要的区别：在尝试删除任何内容之前，我们调用`ensure_admin()`。在端点中，我们需要从请求中获取授权头，它负责携带令牌信息，以便我们可以将其传递给`ensure_admin()`函数。我们通过在函数签名中声明它来实现，作为一个来自`Header`对象的可选字符串。
- en: The `ensure_admin()` function delegates to the `util.is_admin()` function, which
    unpacks the token, verifies its validity, and inspects the `role` field within
    the payload to see if it is that of an admin. If all the checks are successful,
    it returns `True` , or `False` otherwise. The `ensure_admin()` function does nothing
    when the check is successful but raises an `HTTPException` with a *403 Forbidden*
    status code when the check is unsuccessful. This means that if, for any reason,
    the user is not authorized to make this call, the execution of the endpoint’s
    body will immediately stop and return after its first line.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensure_admin()`函数委托给`util.is_admin()`函数，该函数解包令牌，验证其有效性，并检查有效载荷中的`role`字段以查看它是否是管理员。如果所有检查都成功，它返回`True`，否则返回`False`。当检查成功时，`ensure_admin()`函数不执行任何操作，但在检查失败时，它会抛出一个带有`403
    Forbidden`状态码的`HTTPException`。这意味着如果由于任何原因用户没有权限执行此调用，端点主体的执行将立即停止并在第一行后返回。'
- en: There are more sophisticated ways to do authentication and authorization, but
    it would have been impractical to fit them within the chapter. This simple example
    is good enough as a start to understand how to implement this feature in an API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有更复杂的方法来进行身份验证和授权，但将它们包含在章节中是不切实际的。这个简单的例子足以作为入门，了解如何在API中实现此功能。
- en: Documenting the API
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录API文档
- en: 'Documenting APIs is a tedious activity. One advantage of using FastAPI is that
    you do not need to document your project: the documentation is automatically generated
    by the framework. This is possible thanks to the use of type annotations and Pydantic.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 记录API文档是一项繁琐的活动。使用FastAPI的一个优点是您不需要记录您的项目：文档由框架自动生成。这是由于使用了类型注解和Pydantic才成为可能。
- en: 'Make sure your API is running, then open a browser and navigate to `http://localhost:8000/docs`
    . A page will open that should look something like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的API正在运行，然后打开浏览器并导航到`http://localhost:8000/docs`。将打开一个页面，其外观应类似于以下内容：
- en: '![img](img/B30992_14_05.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_14_05.png)'
- en: 'Figure 14.3: A partial screenshot of FastAPI self-generated documentation'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：FastAPI 自生成的文档的部分截图
- en: In *Figure 14.3* , you can see a list of endpoints. They are categorized using
    the `tags` argument, which we have specified in each endpoint declaration. This
    documentation not only allows you to inspect each endpoint in detail but is also
    interactive, which means you can test the endpoints by making requests directly
    from the page.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图14.3* 中，你可以看到一个端点列表。它们使用 `tags` 参数进行分类，我们在每个端点声明中指定了该参数。这份文档不仅允许你详细检查每个端点，而且还是交互式的，这意味着你可以通过直接从页面发起请求来测试端点。
- en: Where do we go from here?
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们接下来该做什么？
- en: 'You should now have a basic understanding of API design and main concepts.
    Of course, studying this chapter’s code will deepen your understanding and likely
    provoke questions. Here are some suggestions if you wish to learn more on the
    subject:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对 API 设计和主要概念有一个基本的了解。当然，研究本章的代码将加深你的理解，并可能引发一些问题。如果你希望在该主题上学习更多，以下是一些建议：
- en: Learn FastAPI well. The website offers tutorials both for beginners and advanced
    programmers. They are quite thorough and cover much more than we could ever include
    in a single chapter.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学好 FastAPI。网站提供了针对初学者和高级程序员的教程。它们相当详尽，涵盖了比我们能在单个章节中包含的更多内容。
- en: Using the source code from this chapter, enhance the API by adding advanced
    searching and filtering capabilities. Try implementing a more sophisticated authentication
    system and exploring the use of background tasks, sorting, and pagination. You
    could also expand the admin section by adding other endpoints only for admin users.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本章的源代码，通过添加高级搜索和过滤功能来增强 API。尝试实现更复杂的认证系统，并探索使用后台任务、排序和分页。你也可以通过添加仅针对管理员用户的端点来扩展管理部分。
- en: Amend the endpoint that books a ticket so that it checks that there are free
    seats on the train. Each train specifies how many first- and second-class cars
    there are, as well as the number of seats per car. We designed the train model
    this way specifically to allow you to practice with this exercise.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改预订车票的端点，以便检查火车上是否有空座位。每辆火车都指定了有多少个一等和二等车厢，以及每节车厢的座位数。我们特意以这种方式设计火车模型，以便你可以通过这个练习进行练习。
- en: Add tests for the existing endpoints, and for anything else you add to the source
    code.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为现有的端点添加测试，并为源代码中添加的任何其他内容添加测试。
- en: Learn about WSGI ( [https://wsgi.readthedocs.io/](https://wsgi.readthedocs.io/)
    ) and, if you are familiar with asynchronous programming, ASGI, its asynchronous
    equivalent ( [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/) ).
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 WSGI ([https://wsgi.readthedocs.io/](https://wsgi.readthedocs.io/))，如果你熟悉异步编程，了解
    ASGI，它是异步的等效物 ([https://asgi.readthedocs.io/](https://asgi.readthedocs.io/))。
- en: Learn about middleware in FastAPI, and concepts like **Cross-Origin Resource
    Sharing (CORS** ), which are important when we run an API in the real world.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 FastAPI 中的中间件和像 **跨源资源共享 (CORS**) 这样的概念，这在我们在现实世界中运行 API 时非常重要。
- en: Learn other API frameworks, like Falcon ( [https://falcon.readthedocs.io/](https://falcon.readthedocs.io/)
    ), or Django Rest Framework ( [https://www.django-rest-framework.org](https://www.django-rest-framework.org)
    ).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解其他 API 框架，如 Falcon ([https://falcon.readthedocs.io/](https://falcon.readthedocs.io/))
    或 Django Rest Framework ([https://www.django-rest-framework.org](https://www.django-rest-framework.org))。
- en: Learn more about Representational State Transfer (REST). It is used everywhere,
    but there are different ways to write APIs with it.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于表示状态转移 (REST) 的知识。它无处不在，但使用它编写 API 的方式有很多。
- en: Learn about more advanced API concepts, such as versioning, data formats, protocols,
    and so on. Learn what headers can do more in-depth.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多高级 API 概念，例如版本控制、数据格式、协议等。深入了解头部可以做什么。
- en: Finally, if you are familiar with asynchronous programming, we recommend rewriting
    the code for this chapter so that it is asynchronous.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你熟悉异步编程，我们建议重写本章的代码，使其异步。
- en: Remember to set `DEBUG=true` in the `.env` file, when working with the API,
    so that you get all the database queries logged automatically in your terminal,
    and you can check if the SQL code they produce reflects your intentions. This
    is quite a handy tool to have when SQLAlchemy operations become a bit more complex.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 `.env` 文件中设置 `DEBUG=true`，当与 API 一起工作时，这样你就可以自动将所有数据库查询记录到你的终端中，并检查它们产生的
    SQL 代码是否反映了你的意图。当 SQLAlchemy 操作变得稍微复杂一些时，这是一个非常有用的工具。
- en: API design is such an important skill. We cannot emphasize enough how essential
    it is for you to master this subject.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: API设计是一项如此重要的技能。我们无法强调掌握这一主题的重要性。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of APIs. We started with a brief overview
    of the Web and moved on to FastAPI, which leverages type annotations. Those were
    introduced in *Chapter 12, Introduction to Type Hinting* .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了API的世界。我们从一个关于Web的简要概述开始，然后转向FastAPI，它利用了类型注解。这些注解在*第12章，类型提示简介*中介绍。
- en: We then discussed APIs in generic terms. We saw different ways to classify them,
    and the purposes and benefits of their use. We also explored protocols and data-exchange
    formats.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着以通用术语讨论了API。我们看到了不同的分类方式，以及它们的使用目的和好处。我们还探讨了协议和数据交换格式。
- en: Finally, we delved into the source code, analyzing a small part of the FastAPI
    project that we wrote for this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入研究了源代码，分析了本章我们为该项目编写的FastAPI项目的一部分。
- en: We concluded the chapter with a series of suggestions for the next steps.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一系列下一步的建议结束了本章。
- en: The next chapter discusses developing CLI applications with Python.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论使用Python开发CLI应用程序。
- en: Join our community on Discord
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_14.xhtml)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_14.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
