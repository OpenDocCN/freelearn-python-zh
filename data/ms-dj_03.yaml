- en: Chapter 3. Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。模板
- en: 'In the previous chapter, you may have noticed something peculiar in how we
    returned the text in our example views. Namely, the HTML was hard-coded directly
    in our Python code, like this:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您可能已经注意到我们在示例视图中返回文本的方式有些奇怪。换句话说，HTML直接硬编码在我们的Python代码中，就像这样：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although this technique was convenient for the purpose of explaining how views
    work, it''s not a good idea to hard-code HTML directly into your views. Here''s
    why:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术对于解释视图如何工作的目的很方便，但直接在视图中硬编码HTML并不是一个好主意。原因如下：
- en: Any change to the design of the page requires a change to the Python code. The
    design of a site tends to change far more frequently than the underlying Python
    code, so it would be convenient if the design could change without needing to
    modify the Python code.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对页面设计的任何更改都需要对Python代码进行更改。网站的设计往往比底层Python代码更频繁地发生变化，因此如果设计可以在不需要修改Python代码的情况下进行更改，那将是很方便的。
- en: This is only a very simple example. A common webpage template has hundreds of
    lines of HTML and scripts. Untangling and troubleshooting program code from this
    mess is a nightmare (*cough-PHP-cough*).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是一个非常简单的例子。一个常见的网页模板有数百行HTML和脚本。从这个混乱中解开和排除程序代码是一场噩梦（*咳嗽-PHP-咳嗽*）。
- en: Writing Python code and designing HTML are two different disciplines, and most
    professional web development environments split these responsibilities between
    separate people (or even separate departments). Designers and HTML/CSS coders
    shouldn't be required to edit Python code to get their job done.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Python代码和设计HTML是两种不同的学科，大多数专业的Web开发环境将这些责任分开给不同的人（甚至是不同的部门）。设计师和HTML/CSS编码人员不应该被要求编辑Python代码来完成他们的工作。
- en: It's most efficient if programmers can work on Python code and designers can
    work on templates at the same time, rather than one person waiting for the other
    to finish editing a single file that contains both Python and HTML.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序员和设计师可以同时工作在Python代码和模板上，而不是一个人等待另一个人完成编辑包含Python和HTML的单个文件，那将是最有效的。
- en: For these reasons, it's much cleaner and more maintainable to separate the design
    of the page from the Python code itself. We can do this with Django's *template
    system*, which we discuss in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，将页面的设计与Python代码本身分开会更加清晰和易于维护。我们可以通过Django的*模板系统*来实现这一点，这是我们在本章中讨论的内容。
- en: Template system basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板系统基础知识
- en: A Django template is a string of text that is intended to separate the presentation
    of a document from its data. A template defines placeholders and various bits
    of basic logic (template tags) that regulate how the document should be displayed.
    Usually, templates are used for producing HTML, but Django templates are equally
    capable of generating any text-based format.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板是一串文本，旨在将文档的呈现与其数据分离。模板定义了占位符和各种基本逻辑（模板标签），规定文档应该如何显示。通常，模板用于生成HTML，但Django模板同样能够生成任何基于文本的格式。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Philosophy behind Django templates**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django模板背后的哲学**'
- en: If you have a background in programming, or if you're used to languages which
    mix programming code directly into HTML, you'll want to bear in mind that the
    Django template system is not simply Python embedded into HTML.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有编程背景，或者习惯于将编程代码直接嵌入HTML的语言，您需要记住Django模板系统不仅仅是Python嵌入到HTML中。
- en: 'This is by design: the template system is meant to express presentation, not
    program logic.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意设计的：模板系统旨在表达演示，而不是程序逻辑。
- en: 'Let''s start with a simple example template. This Django template describes
    an HTML page that thanks a person for placing an order with a company. Think of
    it as a form letter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的示例模板开始。这个Django模板描述了一个HTML页面，感谢一个人向公司下订单。把它想象成一封表格信：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This template is basic HTML with some variables and template tags thrown in.
    Let''s step through it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板是基本的HTML，其中包含一些变量和模板标签。让我们逐步进行：
- en: 'Any text surrounded by a pair of braces (for example, `{{ person_name }}`)
    is a *variable*. This means "*insert the value of the variable with the given
    name*". How do we specify the values of the variables? We''ll get to that in a
    moment. Any text that''s surrounded by curly braces and percent signs (for example,
    `{% if ordered_warranty %}`) is a *template tag*. The definition of a tag is quite
    broad: a tag just tells the template system to "*do something*".'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何被一对大括号包围的文本（例如，`{{ person_name }}`）都是*变量*。这意味着“*插入具有给定名称的变量的值*”。我们如何指定变量的值？我们马上就会讨论到。任何被大括号和百分号包围的文本（例如，`{%
    if ordered_warranty %}`）都是*模板标签*。标签的定义非常广泛：标签只是告诉模板系统“*做某事*”。
- en: This example template contains a `for` tag (`{% for item in item_list %}`) and
    an `if` tag (`{% if ordered_warranty %}`). A `for` tag works very much like a
    `for` statement in Python, letting you loop over each item in a sequence.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个示例模板包含一个`for`标签（`{% for item in item_list %}`）和一个`if`标签（`{% if ordered_warranty
    %}`）。`for`标签的工作方式与Python中的`for`语句非常相似，让您可以循环遍历序列中的每个项目。
- en: An `if` tag, as you may expect, acts as a logical if statement. In this particular
    case, the tag checks whether the value of the `ordered_warranty` variable evaluates
    to `True`. If it does, the template system will display everything between the
    `{% if ordered_warranty %}` and `{% else %}`. If not, the template system will
    display everything between `{% else %}` and `{% endif %}`. Note that the `{% else
    %}` is optional.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`if`标签，正如您可能期望的那样，充当逻辑if语句。在这种特殊情况下，标签检查`ordered_warranty`变量的值是否评估为`True`。如果是，模板系统将显示`{%
    if ordered_warranty %}`和`{% else %}`之间的所有内容。如果不是，模板系统将显示`{% else %}`和`{% endif
    %}`之间的所有内容。请注意，`{% else %}`是可选的。
- en: Finally, the second paragraph of this template contains an example of a *filter*,
    which is the most convenient way to alter the formatting of a variable. In this
    example, `{{ ship_date|date:"F j, Y" }}`, we're passing the `ship_date` variable
    to the `date` filter, giving the `date` filter the argument `"F j, Y"`. The `date`
    filter formats dates in a given format, as specified by that argument. Filters
    are attached using a pipe character (`|`), as a reference to Unix pipes.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个模板的第二段包含了一个*filter*的例子，这是改变变量格式的最方便的方法。在这个例子中，`{{ ship_date|date:"F j,
    Y" }}`，我们将`ship_date`变量传递给`date`过滤器，并给`date`过滤器传递参数`"F j, Y"`。`date`过滤器根据该参数指定的格式格式化日期。过滤器使用管道字符（`|`）进行连接，作为对Unix管道的引用。
- en: Each Django template has access to several built-in tags and filters, many of
    which are discussed in the sections that follow. [Appendix E](ape.xhtml "Appendix E. Built-in
    Template Tags and Filters"), *Built-in Template Tags and Filters*, contains the
    full list of tags and filters, and it's a good idea to familiarize yourself with
    that list so you know what's possible. It's also possible to create your own filters
    and tags; we'll cover that in [Chapter 8](ch08.xhtml "Chapter 8. Advanced Templates"),
    *Advanced Templates*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Django模板都可以访问多个内置标签和过滤器，其中许多在接下来的章节中讨论。[附录E](ape.xhtml "附录E。内置模板标签和过滤器")，*内置模板标签和过滤器*，包含了标签和过滤器的完整列表，熟悉该列表是一个好主意，这样您就知道可能发生什么。还可以创建自己的过滤器和标签；我们将在[第8章](ch08.xhtml
    "第8章。高级模板")，*高级模板*中进行介绍。
- en: Using the template system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板系统
- en: 'A Django project can be configured with one or several template engines (or
    even zero if you don''t use templates). Django ships with a built-in backend for
    its own template system-the **Django Template Language** (**DTL**). Django 1.8
    also includes support for the popular alternative Jinja2 (for more information
    visit [http://jinja.pocoo.org/](http://jinja.pocoo.org/)). If you don''t have
    a pressing reason to choose another backend, you should use the DTL-especially
    if you''re writing a pluggable application and you intend to distribute templates.
    Django''s `contrib` apps that include templates, like `django.contrib.admin`,
    use the DTL. All of the examples in this chapter will use the DTL. For more advanced
    template topics, including configuring third-party template engines, see [Chapter
    8](ch08.xhtml "Chapter 8. Advanced Templates"), *Advanced Templates*. Before we
    go about implementing Django templates in your view, lets first dig inside the
    DTL a little so you can see how it works. Here is the most basic way you can use
    Django''s template system in Python code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目可以配置一个或多个模板引擎（甚至可以不使用模板）。Django自带了一个用于其自己模板系统的内置后端-**Django模板语言**（**DTL**）。Django
    1.8还包括对流行的替代品Jinja2的支持（有关更多信息，请访问[http://jinja.pocoo.org/](http://jinja.pocoo.org/)）。如果没有紧迫的理由选择其他后端，应该使用DTL-特别是如果您正在编写可插拔应用程序并且打算分发模板。Django的`contrib`应用程序包括模板，如`django.contrib.admin`，使用DTL。本章中的所有示例都将使用DTL。有关更高级的模板主题，包括配置第三方模板引擎，请参阅[第8章](ch08.xhtml
    "第8章。高级模板")，*高级模板*。在您的视图中实现Django模板之前，让我们先深入了解DTL，以便您了解其工作原理。以下是您可以在Python代码中使用Django模板系统的最基本方式：
- en: Create a `Template` object by providing the raw template code as a string.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供原始模板代码作为字符串来创建`Template`对象。
- en: Call the `render()` method of the `Template` object with a given set of variables
    (the context). This returns a fully rendered template as a string, with all of
    the variables and template tags evaluated according to the context.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的一组变量（上下文）调用`Template`对象的`render()`方法。这将根据上下文返回一个完全呈现的模板字符串，其中所有变量和模板标签都根据上下文进行评估。
- en: 'In code, here''s what that looks like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，它看起来像这样：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following sections describe each step in much more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将更详细地描述每个步骤。
- en: Creating template objects
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模板对象
- en: The easiest way to create a `Template` object is to instantiate it directly.
    The `Template` class lives in the `django.template` module, and the constructor
    takes one argument, the raw template code. Let's dip into the Python interactive
    interpreter to see how this works in code. From the `mysite` project directory
    you created in [Chapter 1](ch01.xhtml "Chapter 1. Introduction to Django and Getting
    Started"), *Introduction to Django and Getting Started*, type `python manage.py
    shell` to start the interactive interpreter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Template`对象的最简单方法是直接实例化它。`Template`类位于`django.template`模块中，构造函数接受一个参数，即原始模板代码。让我们进入Python交互式解释器，看看这在代码中是如何工作的。从您在[第1章](ch01.xhtml
    "第1章。Django简介和入门")中创建的`mysite`项目目录中，键入`python manage.py shell`以启动交互式解释器。
- en: 'Let''s go through some template system basics:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些模板系统的基础知识：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you''re following along interactively, you''ll see something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在交互式地跟随，您会看到类似于这样的内容：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That `0x030396B0` will be different every time, and it isn't relevant; it's
    a Python thing (the Python "identity" of the `Template` object, if you must know).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x030396B0`每次都会不同，这并不重要；这是一个Python的东西（如果你一定要知道的话，这是`Template`对象的Python“标识”）。'
- en: 'When you create a `Template` object, the template system compiles the raw template
    code into an internal, optimized form, ready for rendering. But if your template
    code includes any syntax errors, the call to `Template()` will cause a `TemplateSyntaxError`
    exception:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个`Template`对象时，模板系统会将原始模板代码编译成内部优化形式，准备好进行呈现。但是，如果您的模板代码包含任何语法错误，对`Template()`的调用将引发`TemplateSyntaxError`异常：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The term "block tag" here refers to `{% notatag %}`. "Block tag" and "template
    tag" are synonymous. The system raises a `TemplateSyntaxError` exception for any
    of the following cases:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“块标签”是指`{% notatag %}`。 “块标签”和“模板标签”是同义词。系统对以下任何情况都会引发`TemplateSyntaxError`异常：
- en: Invalid tags
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效标签
- en: Invalid arguments to valid tags
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对有效标签的无效参数
- en: Invalid filters
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的过滤器
- en: Invalid arguments to valid filters
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对有效过滤器的无效参数
- en: Invalid template syntax
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的模板语法
- en: Unclosed tags (for tags that require closing tags)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未关闭的标签（对于需要关闭标签的标签）
- en: Rendering a template
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 呈现模板
- en: 'Once you have a `Template` object, you can pass it data by giving it a *context*.
    A context is simply a set of template variable names and their associated values.
    A template uses this to populate its variables and evaluate its tags. A context
    is represented in Django by the `Context` class, which lives in the `django.template`
    module. Its constructor takes one optional argument: a dictionary mapping variable
    names to variable values.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`Template`对象，你可以通过给它*上下文*来传递数据。上下文只是一组模板变量名及其关联的值。模板使用这个来填充它的变量并评估它的标记。在Django中，上下文由`Context`类表示，它位于`django.template`模块中。它的构造函数接受一个可选参数：将变量名映射到变量值的字典。
- en: 'Call the `Template` object''s `render()` method with the context to *fill*
    the template:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文调用`Template`对象的`render()`方法来*填充*模板：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A special Python prompt**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个特殊的Python提示**'
- en: 'If you''ve used Python before, you may be wondering why we''re running python
    manage.py shell instead of just python (or python3). Both commands will start
    the interactive interpreter, but the `manage.py` shell command has one key difference:
    before starting the interpreter, it tells Django which settings file to use. Many
    parts of Django, including the template system, rely on your settings, and you
    won''t be able to use them unless the framework knows which settings to use.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过Python，你可能会想知道为什么我们要运行python manage.py shell而不是只运行python（或python3）。这两个命令都会启动交互式解释器，但`manage.py`
    shell命令有一个关键的区别：在启动解释器之前，它会告诉Django要使用哪个设置文件。Django的许多部分，包括模板系统，都依赖于你的设置，除非框架知道要使用哪些设置，否则你将无法使用它们。
- en: If you're curious, here's how it works behind the scenes. Django looks for an
    environment variable called DJANGO_SETTINGS_MODULE, which should be set to the
    import path of your settings.py. For example, DJANGO_SETTINGS_MODULE might be
    set to 'mysite.settings', assuming mysite is on your Python path.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，这是它在幕后是如何工作的。Django会查找一个名为DJANGO_SETTINGS_MODULE的环境变量，它应该设置为你的settings.py的导入路径。例如，DJANGO_SETTINGS_MODULE可能设置为'mysite.settings'，假设mysite在你的Python路径上。
- en: When you run python manage.py shell, the command takes care of setting DJANGO_SETTINGS_MODULE
    for you. You will need to use python manage.py shell in these examples or Django
    will throw an exception.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行python manage.py shell时，该命令会为你设置DJANGO_SETTINGS_MODULE。在这些示例中，你需要使用python
    manage.py shell，否则Django会抛出异常。
- en: Dictionaries and contexts
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典和上下文
- en: A Python dictionary is a mapping between known keys and variable values. A `Context`
    is similar to a dictionary, but a `Context` provides additional functionality,
    as covered in [Chapter 8](ch08.xhtml "Chapter 8. Advanced Templates"), *Advanced
    Templates*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典是已知键和变量值之间的映射。`Context`类似于字典，但`Context`提供了额外的功能，如[第8章](ch08.xhtml "第8章。高级模板")中所述的*高级模板*。
- en: 'Variable names must begin with a letter (A-Z or a-z) and may contain more letters,
    digits, underscores, and dots. (Dots are a special case we''ll get to in a moment.)
    Variable names are case sensitive. Here''s an example of template compilation
    and rendering, using a template similar to the example in the beginning of this
    chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名必须以字母（A-Z或a-z）开头，可以包含更多的字母、数字、下划线和点。（点是一个我们马上会讨论的特殊情况。）变量名是区分大小写的。以下是使用类似本章开头示例的模板进行编译和渲染的示例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we import the classes `Template` and `Context`, which both live in the
    module `django.template`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们导入`Template`和`Context`类，它们都位于`django.template`模块中。
- en: We save the raw text of our template into the variable `raw_template`. Note
    that we use triple quote marks to designate the string, because it wraps over
    multiple lines; in contrast, strings within single quote marks cannot be wrapped
    over multiple lines.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将模板的原始文本保存到变量`raw_template`中。请注意，我们使用三引号来指定字符串，因为它跨越多行；相比之下，单引号内的字符串不能跨越多行。
- en: Next, we create a template object, `t`, by passing `raw_template` to the `Template`
    class constructor.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将`raw_template`传递给`Template`类的构造函数来创建一个模板对象`t`。
- en: We import the `datetime` module from Python's standard library, because we'll
    need it in the following statement.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从Python的标准库中导入`datetime`模块，因为我们在下面的语句中会用到它。
- en: Then, we create a `Context` object, `c`. The `Context` constructor takes a Python
    dictionary, which maps variable names to values. Here, for example, we specify
    that the `person_name` is "`John Smith`", `company` is "`Outdoor Equipment`",
    and so forth.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`Context`对象`c`。`Context`构造函数接受一个Python字典，它将变量名映射到值。在这里，例如，我们指定`person_name`是"`John
    Smith`"，`company`是"`Outdoor Equipment`"，等等。
- en: Finally, we call the `render()` method on our template object, passing it the
    context. This returns the rendered template-that is, it replaces template variables
    with the actual values of the variables, and it executes any template tags.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在模板对象上调用`render()`方法，将上下文传递给它。这将返回渲染后的模板-也就是说，它用变量的实际值替换模板变量，并执行任何模板标记。
- en: Note that the *You didn't order a warranty* paragraph was displayed because
    the `ordered_warranty` variable evaluated to `False`. Also note the date, `July
    2, 2015`, which is displayed according to the format string "`F j, Y`". (We'll
    explain format strings for the `date` filter in a little while.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*您没有订购保修*段落被显示，因为`ordered_warranty`变量评估为`False`。还请注意日期`2015年7月2日`，它根据格式字符串"`F
    j, Y`"显示。（我们稍后会解释`date`过滤器的格式字符串。）
- en: 'If you''re new to Python, you may wonder why this output includes newline characters
    ("`\n`") rather than displaying the line breaks. That''s happening because of
    a subtlety in the Python interactive interpreter: the call to `t.render(c)` returns
    a string, and by default the interactive interpreter displays the representation
    of the string, rather than the printed value of the string. If you want to see
    the string with line breaks displayed as true line breaks rather than "`\n`" characters,
    use the print function: `print (t.render(c))`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Python的新手，你可能会想为什么这个输出包含换行符（"`\n`"）而不是显示换行。这是因为Python交互式解释器中的一个微妙之处：对 `t.render(c)`
    的调用返回一个字符串，默认情况下交互式解释器显示字符串的表示形式，而不是字符串的打印值。如果你想看到带有换行符的字符串显示为真正的换行而不是 "`\n`"
    字符，使用print函数：`print (t.render(c))`。
- en: 'Those are the fundamentals of using the Django template system: just write
    a template string, create a `Template` object, create a `Context`, and call the
    `render()` method.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用Django模板系统的基础知识：只需编写一个模板字符串，创建一个 `Template` 对象，创建一个 `Context`，然后调用 `render()`
    方法。
- en: Multiple contexts, same template
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个上下文，同一个模板
- en: 'Once you have a `Template` object, you can render multiple contexts through
    it. For example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 `Template` 对象，你可以通过它渲染多个上下文。例如：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whenever you''re using the same template source to render multiple contexts
    like this, it''s more efficient to create the `Template` object once, and then
    call `render()` on it multiple times:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用相同的模板源来渲染多个上下文时，最好只创建一次 `Template` 对象，然后多次调用 `render()` 方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Django's template parsing is quite fast. Behind the scenes, most of the parsing
    happens via a call to a single regular expression. This is in stark contrast to
    XML-based template engines, which incur the overhead of an XML parser and tend
    to be orders of magnitude slower than Django's template rendering engine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模板解析非常快。在幕后，大部分解析是通过对单个正则表达式的调用来完成的。这与基于XML的模板引擎形成鲜明对比，后者需要XML解析器的开销，而且往往比Django的模板渲染引擎慢几个数量级。
- en: Context variable lookup
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文变量查找
- en: In the examples so far, we've passed simple values in the contexts-mostly strings,
    plus a `datetime.date` example. However, the template system elegantly handles
    more complex data structures, such as lists, dictionaries, and custom objects.
    The key to traversing complex data structures in Django templates is the dot character
    ("`.`").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子中，我们在上下文中传递了简单的值-大多是字符串，还有一个 `datetime.date` 的例子。然而，模板系统优雅地处理了更复杂的数据结构，如列表、字典和自定义对象。在Django模板中遍历复杂数据结构的关键是点字符（“`.`”）。
- en: 'Use a dot to access dictionary keys, attributes, methods, or indices of an
    object. This is best illustrated with a few examples. For instance, suppose you''re
    passing a Python dictionary to a template. To access the values of that dictionary
    by dictionary key, use a dot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点来访问对象的字典键、属性、方法或索引。这最好通过一些例子来说明。例如，假设你要将一个Python字典传递给模板。要通过字典键访问该字典的值，使用一个点：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, dots also allow access to object attributes. For example, a Python
    `datetime.date` object has `year`, `month`, and `day` attributes, and you can
    use a dot to access those attributes in a Django template:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，点也允许访问对象的属性。例如，Python的 `datetime.date` 对象具有 `year`、`month` 和 `day` 属性，你可以使用点来在Django模板中访问这些属性：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example uses a custom class, demonstrating that variable dots also allow
    attribute access on arbitrary objects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了一个自定义类，演示了变量点也允许在任意对象上进行属性访问：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Dots can also refer to methods of objects. For example, each Python string
    has the methods `upper()` and `isdigit()`, and you can call those in Django templates
    using the same dot syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点也可以指代对象的方法。例如，每个Python字符串都有 `upper()` 和 `isdigit()` 方法，你可以在Django模板中使用相同的点语法调用这些方法：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that you do not include parentheses in the method calls. Also, it''s not
    possible to pass arguments to the methods; you can only call methods that have
    no required arguments. (We explain this philosophy later in this chapter.) Finally,
    dots are also used to access list indices, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在方法调用中不要包括括号。而且，不可能向方法传递参数；你只能调用没有必需参数的方法（我们稍后在本章中解释这个理念）。最后，点也用于访问列表索引，例如：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Negative list indices are not allowed. For example, the template variable
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许负列表索引。例如，模板变量
- en: '`{{ items.-1 }}` would cause a `TemplateSyntaxError`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{ items.-1 }}` 会导致 `TemplateSyntaxError`。'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Python Lists**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python列表**'
- en: 'A reminder: Python lists have 0-based indices. The first item is at index 0,
    the second is at index 1, and so on.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：Python列表是从0开始的索引。第一个项目在索引0处，第二个在索引1处，依此类推。
- en: 'Dot lookups can be summarized like this: when the template system encounters
    a dot in a variable name, it tries the following lookups, in this order:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点查找可以总结如下：当模板系统在变量名称中遇到一个点时，它按照以下顺序尝试以下查找：
- en: Dictionary lookup (for example, `foo["bar"]`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典查找（例如，`foo["bar"]`）
- en: Attribute lookup (for example, `foo.bar`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性查找（例如，`foo.bar`）
- en: Method call (for example, `foo.bar()`)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用（例如，`foo.bar()`）
- en: List-index lookup (for example, `foo[2]`)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表索引查找（例如，`foo[2]`）
- en: 'The system uses the first lookup type that works. It''s short-circuit logic.
    Dot lookups can be nested multiple levels deep. For instance, the following example
    uses `{{ person.name.upper }}`, which translates into a dictionary lookup (`person[''name'']`)
    and then a method call (`upper()`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用第一个有效的查找类型。这是短路逻辑。点查找可以嵌套多层深。例如，以下示例使用 `{{ person.name.upper }}`，它转换为字典查找
    (`person['name']`)，然后是方法调用 (`upper()`)：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Method call behavior
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法调用行为
- en: 'Method calls are slightly more complex than the other lookup types. Here are
    some things to keep in mind:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用比其他查找类型稍微复杂一些。以下是一些需要记住的事项：
- en: 'If, during the method lookup, a method raises an exception, the exception will
    be propagated, unless the exception has an attribute `silent_variable_failure`
    whose value is `True`. If the exception does have a `silent_variable_failure`
    attribute, the variable will render as the value of the engine''s `string_if_invalid`
    configuration option (an empty string, by default). For example:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在方法查找期间，方法引发异常，异常将被传播，除非异常具有一个值为 `True` 的 `silent_variable_failure` 属性。如果异常确实具有
    `silent_variable_failure` 属性，则变量将呈现为引擎的 `string_if_invalid` 配置选项的值（默认情况下为空字符串）。例如：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A method call will only work if the method has no required arguments. Otherwise,
    the system will move to the next lookup type (list-index lookup).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当方法没有必需的参数时，方法调用才能正常工作。否则，系统将转到下一个查找类型（列表索引查找）。
- en: By design, Django intentionally limits the amount of logic processing available
    in the template, so it's not possible to pass arguments to method calls accessed
    from within templates. Data should be calculated in views and then passed to templates
    for display.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按设计，Django 有意限制了模板中可用的逻辑处理的数量，因此无法向从模板中访问的方法调用传递参数。数据应该在视图中计算，然后传递给模板进行显示。
- en: Obviously, some methods have side effects, and it would be foolish at best,
    and possibly even a security hole, to allow the template system to access them.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，一些方法具有副作用，允许模板系统访问它们将是愚蠢的，甚至可能是一个安全漏洞。
- en: 'Say, for instance, you have a `BankAccount` object that has a `delete()` method.
    If a template includes something like `{{ account.delete }}`, where `account`
    is a `BankAccount` object, the object would be deleted when the template is rendered!
    To prevent this, set the function attribute `alters_data` on the method:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比如，你有一个 `BankAccount` 对象，它有一个 `delete()` 方法。如果模板包含类似 `{{ account.delete }}`
    的内容，其中 `account` 是一个 `BankAccount` 对象，那么当模板被渲染时，对象将被删除！为了防止这种情况发生，在方法上设置函数属性 `alters_data`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The template system won't execute any method marked in this way. Continuing
    the preceding example, if a template includes `{{ account.delete }}` and the `delete()`
    method has the `alters_data=True`, then the `delete()` method will not be executed
    when the template is rendered, the engine will instead replace the variable with
    `string_if_invalid`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板系统不会执行以这种方式标记的任何方法。继续上面的例子，如果模板包含 `{{ account.delete }}`，并且 `delete()` 方法具有
    `alters_data=True`，那么在模板被渲染时，`delete()` 方法将不会被执行，引擎将用 `string_if_invalid` 替换变量。
- en: '**NOTE:** The dynamically-generated `delete()` and `save()` methods on Django
    model objects get `alters_data=true` set automatically.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意：** Django 模型对象上动态生成的 `delete()` 和 `save()` 方法会自动设置 `alters_data=true`。'
- en: How invalid variables are handled
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理无效变量
- en: 'Generally, if a variable doesn''t exist, the template system inserts the value
    of the engine''s `string_if_invalid` configuration option, which is an empty string
    by default. For example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果变量不存在，模板系统会插入引擎的 `string_if_invalid` 配置选项的值，默认情况下为空字符串。例如：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This behavior is better than raising an exception because it's intended to be
    resilient to human error. In this case, all of the lookups failed because variable
    names have the wrong case or name. In the real world, it's unacceptable for a
    web site to become inaccessible due to a small template syntax error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为比引发异常更好，因为它旨在对人为错误具有弹性。在这种情况下，所有的查找都失败了，因为变量名的大小写或名称错误。在现实世界中，由于小的模板语法错误导致网站无法访问是不可接受的。
- en: Basic template-tags and filters
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本模板标签和过滤器
- en: As we've mentioned already, the template system ships with built-in tags and
    filters. The sections that follow provide a rundown of the most common tags and
    filters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，模板系统附带了内置的标签和过滤器。接下来的部分将介绍最常见的标签和过滤器。
- en: Tags
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: if/else
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if/else
- en: 'The `{% if %}` tag evaluates a variable, and if that variable is `True` (that
    is, it exists, is not empty, and is not a `false` Boolean value), the system will
    display everything between `{% if %}` and `{% endif %}`, for example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% if %}` 标签评估一个变量，如果该变量为 `True`（即存在，不为空，并且不是 `false` 布尔值），系统将显示 `{% if %}`
    和 `{% endif %}` 之间的所有内容，例如：'
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An `{% else %}` tag is optional:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% else %}` 标签是可选的：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `if` tag may also take one or several `{% elif %}` clauses as well:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 标签也可以接受一个或多个 `{% elif %}` 子句：'
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `{% if %}` tag accepts and, or, or not for testing multiple variables,
    or to negate a given variable. For example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% if %}` 标签接受 and、or 或 not 用于测试多个变量，或者对给定变量取反。例如：'
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use of both `and` and `or` clauses within the same tag is allowed, with `and`
    having higher precedence than `or` for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个标签中使用 `and` 和 `or` 子句是允许的，其中 `and` 的优先级高于 `or`，例如：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'will be interpreted like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将被解释为：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'NOTE: Use of actual parentheses in the if tag is invalid syntax.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 if 标签中使用实际括号是无效的语法。
- en: 'If you need parentheses to indicate precedence, you should use nested if tags.
    The use of parentheses for controlling order of operations is not supported. If
    you find yourself needing parentheses, consider performing logic outside the template
    and passing the result of that as a dedicated template variable. Or, just use
    nested `{% if %}` tags, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用括号表示优先级，应该使用嵌套的 if 标签。不支持使用括号来控制操作的顺序。如果发现自己需要括号，考虑在模板外执行逻辑，并将结果作为专用模板变量传递。或者，只需使用嵌套的
    `{% if %}` 标签，就像这样：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Multiple uses of the same logical operator are fine, but you can''t combine
    different operators. For example, this is valid:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个逻辑运算符的多次使用是可以的，但不能组合不同的运算符。例如，这是有效的：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Make sure to close each `{% if %}` with an `{% endif %}`. Otherwise, Django
    will throw a `TemplateSyntaxError`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用 `{% endif %}` 来关闭每个 `{% if %}`。否则，Django 将抛出 `TemplateSyntaxError`。
- en: for
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for
- en: 'The `{% for %}` tag allows you to loop over each item in a sequence. As in
    Python''s `for` statement, the syntax is `for X in Y`, where `Y` is the sequence
    to loop over and `X` is the name of the variable to use for a particular cycle
    of the loop. Each time through the loop, the template system will render everything
    between `{% for %}` and `{% endfor %}`. For example, you could use the following
    to display a list of athletes given a variable `athlete_list`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% for %}`标签允许您循环遍历序列中的每个项目。 与Python的`for`语句一样，语法是`for X in Y`，其中`Y`是要循环遍历的序列，`X`是用于循环的特定周期的变量的名称。
    每次循环时，模板系统将呈现`{% for %}`和`{% endfor %}`之间的所有内容。 例如，您可以使用以下内容显示给定变量`athlete_list`的运动员列表：'
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add `reversed` to the tag to loop over the list in reverse:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签中添加`reversed`以以相反的顺序循环遍历列表：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s possible to nest `{% for %}` tags:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以嵌套`{% for %}`标签：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you need to loop over a list of lists, you can unpack the values in each
    sub list into individual variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要循环遍历一个列表的列表，可以将每个子列表中的值解压缩为单独的变量。
- en: 'For example, if your context contains a list of (x,y) coordinates called `points`,
    you could use the following to output the list of points:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的上下文包含一个名为`points`的（x，y）坐标列表，则可以使用以下内容输出点列表：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This can also be useful if you need to access the items in a dictionary. For
    example, if your context contained a dictionary `data`, the following would display
    the keys and values of the dictionary:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要访问字典中的项目，则这也可能很有用。 例如，如果您的上下文包含一个名为`data`的字典，则以下内容将显示字典的键和值：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A common pattern is to check the size of the list before looping over it, and
    outputting some special text if the list is empty:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之前检查列表的大小并在列表为空时输出一些特殊文本是一种常见模式：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because this pattern is so common, the `for` tag supports an optional `{% empty
    %}` clause that lets you define what to output if the list is empty. This example
    is equivalent to the previous one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模式很常见，`for`标签支持一个可选的`{% empty %}`子句，让您定义列表为空时要输出的内容。 此示例等效于上一个示例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is no support for breaking out of a loop before the loop is finished.
    If you want to accomplish this, change the variable you're looping over so that
    it includes only the values you want to loop over.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 没有支持在循环完成之前中断循环。 如果要实现此目的，请更改要循环遍历的变量，以便仅包括要循环遍历的值。
- en: Similarly, there is no support for a `continue` statement that would instruct
    the loop processor to return immediately to the front of the loop. (See the section
    *Philosophies and Limitations* later in this chapter for the reasoning behind
    this design decision.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，不支持`continue`语句，该语句将指示循环处理器立即返回到循环的开头。 （有关此设计决定背后的原因，请参见本章后面的*哲学和限制*部分。）
- en: 'Within each `{% for %}` loop, you get access to a template variable called
    `forloop`. This variable has a few attributes that give you information about
    the progress of the loop:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`{% for %}`循环中，您可以访问名为`forloop`的模板变量。 此变量具有一些属性，可为您提供有关循环进度的信息：
- en: '`forloop.counter` is always set to an integer representing the number of times
    the loop has been entered. This is one-indexed, so the first time through the
    loop, `forloop.counter` will be set to `1`. Here''s an example:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.counter`始终设置为表示循环已输入的次数的整数。 这是从1开始索引的，因此第一次循环时，`forloop.counter`将设置为`1`。
    以下是一个示例：'
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`forloop.counter0` is like `forloop.counter`, except it''s zero-indexed. Its
    value will be set to `0` the first time through the loop.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.counter0`类似于`forloop.counter`，只是它是从零开始索引的。 它的值将在第一次循环时设置为`0`。'
- en: '`forloop.revcounter` is always set to an integer representing the number of
    remaining items in the loop. The first time through the loop, `forloop.revcounter`
    will be set to the total number of items in the sequence you''re traversing. The
    last time through the loop, `forloop.revcounter` will be set to `1`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.revcounter`始终设置为表示循环中剩余项目数的整数。 第一次循环时，`forloop.revcounter`将设置为您正在遍历的序列中项目的总数。
    最后一次循环时，`forloop.revcounter`将设置为`1`。'
- en: '`forloop.revcounter0` is like `forloop.revcounter`, except it''s zero-indexed.
    The first time through the loop, `forloop.revcounter0` will be set to the number
    of elements in the sequence minus `1`. The last time through the loop, it will
    be set to `0`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.revcounter0`类似于`forloop.revcounter`，只是它是从零开始索引的。 第一次循环时，`forloop.revcounter0`将设置为序列中的元素数减去`1`。
    最后一次循环时，它将设置为`0`。'
- en: '`forloop.first` is a Boolean value set to `True` if this is the first time
    through the loop. This is convenient for special-casing:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.first`是一个布尔值，如果这是第一次循环，则设置为`True`。 这对于特殊情况很方便：'
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`forloop.last` is a Boolean value set to `True` if this is the last time through
    the loop. A common use for this is to put pipe characters between a list of links:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.last`是一个布尔值，如果这是最后一次循环，则设置为`True`。 这的一个常见用法是在链接列表之间放置管道字符：'
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding template code might output something like this:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的模板代码可能会输出类似于以下内容：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another common use for this is to put a comma between words in a list:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式的另一个常见用法是在列表中的单词之间放置逗号：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`forloop.parentloop` is a reference to the `forloop` object for the parent
    loop, in case of nested loops. Here''s an example:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forloop.parentloop`是对父循环的`forloop`对象的引用，以防嵌套循环。 以下是一个示例：'
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `forloop` variable is only available within loops. After the template parser
    has reached `{% endfor %}`, `forloop` disappears.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`forloop`变量仅在循环内部可用。 模板解析器达到`{% endfor %}`后，`forloop`将消失。'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Context and the forloop Variable**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文和forloop变量
- en: Inside the {% for %} block, the existing variables are moved out of the way
    to avoid overwriting the `forloop` variable. Django exposes this moved context
    in `forloop.parentloop`. You generally don't need to worry about this, but if
    you supply a template variable named `forloop` (though we advise against it),
    it will be named `forloop.parentloop` while inside the `{% for %}` block.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在{% for %}块内，现有的变量被移出以避免覆盖`forloop`变量。Django在`forloop.parentloop`中公开了这个移动的上下文。通常情况下，您不需要担心这一点，但如果您提供了一个名为`forloop`的模板变量（尽管我们建议不要这样做），它将在`{%
    for %}`块内被命名为`forloop.parentloop`。
- en: ifequal/ifnotequal
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ifequal/ifnotequal
- en: The Django template system is not a full-fledged programming language and thus
    does not allow you to execute arbitrary Python statements. (More on this idea
    in the section *Philosophies and Limitations*).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板系统不是一个完整的编程语言，因此不允许执行任意的Python语句。（有关这个想法的更多信息，请参见*哲学和限制*部分）。
- en: However, it's quite a common template requirement to compare two values and
    display something if they're equal-and Django provides an `{% ifequal %}` tag
    for that purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，比较两个值并在它们相等时显示某些内容是一个常见的模板要求，Django提供了一个`{% ifequal %}`标签来实现这个目的。
- en: The `{% ifequal %}` tag compares two values and displays everything between
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% ifequal %}`标签比较两个值，并显示两者之间的所有内容'
- en: '`{% ifequal %}` and `{% endifequal %}` if the values are equal. This example
    compares the template variables `user` and `currentuser`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% ifequal %}`和`{% endifequal %}`如果值相等。此示例比较模板变量`user`和`currentuser`：'
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The arguments can be hard-coded strings, with either single or double quotes,
    so the following is valid:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是硬编码的字符串，可以是单引号或双引号，因此以下是有效的：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Just like `{% if %}`, the `{% ifequal %}` tag supports an optional `{% else
    %}`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`{% if %}`一样，`{% ifequal %}`标签支持可选的`{% else %}`：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Only template variables, strings, integers, and decimal numbers are allowed
    as arguments to `{% ifequal %}`. These are valid examples:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许将模板变量、字符串、整数和十进制数作为`{% ifequal %}`的参数。这些是有效的示例：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Any other types of variables, such as Python dictionaries, lists, or Booleans,
    can''t be hard-coded in `{% ifequal %}`. These are invalid examples:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他类型的变量，例如Python字典、列表或布尔值，都不能在`{% ifequal %}`中进行硬编码。这些是无效的示例：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you need to test whether something is true or false, use the `{% if %}` tags
    instead of `{% ifequal %}`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要测试某些东西是真还是假，请使用`{% if %}`标签，而不是`{% ifequal %}`。
- en: An alternative to the `ifequal` tag is to use the `if` tag and the "`==`" operator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifequal`标签的替代方法是使用`if`标签和"`==`"运算符。'
- en: The `{% ifnotequal %}` tag is identical to the `ifequal` tag, except that it
    tests whether the two arguments are not equal. An alternative to the `ifnotequal`
    tag is to use the if tag and the "`!=`" operator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% ifnotequal %}`标签与`ifequal`标签相同，只是它测试两个参数是否不相等。`ifnotequal`标签的替代方法是使用`if`标签和"`!=`"运算符。'
- en: Comments
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评论
- en: 'Just as in HTML or Python, the Django template language allows for comments.
    To designate a comment, use `{# #}`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '就像在HTML或Python中一样，Django模板语言允许使用注释。要指定注释，请使用`{# #}`：'
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The comment will not be output when the template is rendered. Comments using
    this syntax cannot span multiple lines. This limitation improves template parsing
    performance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板呈现时，注释不会被输出。使用这种语法的注释不能跨越多行。这种限制提高了模板解析的性能。
- en: 'In the following template, the rendered output will look exactly the same as
    the template (that is, the comment tag will not be parsed as a comment):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的模板中，呈现的输出将与模板完全相同（即，注释标签不会被解析为注释）：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you want to use multi-line comments, use the `{% comment %}` template tag,
    like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用多行注释，请使用`{% comment %}`模板标签，如下所示：
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Comment tags cannot be nested.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 评论标签不能嵌套。
- en: Filters
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'As explained earlier in this chapter, template filters are simple ways of altering
    the value of variables before they''re displayed. Filters use a pipe character,
    like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面所解释的，模板过滤器是在显示变量值之前修改变量值的简单方法。过滤器使用管道字符，如下所示：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This displays the value of the `{{ name }}` variable after being filtered through
    the `lower` filter, which converts text to lowercase. Filters can be chained-that
    is, they can be used in tandem such that the output of one filter is applied to
    the next.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示经过`lower`过滤器过滤后的`{{ name }}`变量的值，该过滤器将文本转换为小写。过滤器可以链接-也就是说，它们可以串联使用，以便将一个过滤器的输出应用于下一个过滤器。
- en: 'Here''s an example that takes the first element in a list and converts it to
    uppercase:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，它获取列表中的第一个元素并将其转换为大写：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Some filters take arguments. A filter argument comes after a colon and is always
    in double quotes. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一些过滤器需要参数。过滤器参数在冒号后面，总是用双引号括起来。例如：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This displays the first 30 words of the `bio` variable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示`bio`变量的前30个单词。
- en: The following are a few of the most important filters. [Appendix E](ape.xhtml
    "Appendix E. Built-in Template Tags and Filters"), *Built-in Template Tags and
    Filters* covers the rest.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最重要的过滤器。[附录E](ape.xhtml "附录 E. 内置模板标签和过滤器")，*内置模板标签和过滤器*涵盖了其余部分。
- en: '`addslashes`: Adds a backslash before any backslash, single quote, or double
    quote. This is useful for escaping strings. For example:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addslashes`：在任何反斜杠、单引号或双引号之前添加一个反斜杠。这对于转义字符串很有用。例如：'
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`date`: Formats a `date` or `datetime` object according to a format string
    given in the parameter, for example:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：根据参数中给定的格式字符串格式化`date`或`datetime`对象，例如：'
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Format strings are defined in [Appendix E](ape.xhtml "Appendix E. Built-in Template
    Tags and Filters"), *Built-in Template Tags and Filters*.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式字符串在[附录E](ape.xhtml "附录 E. 内置模板标签和过滤器")中定义，*内置模板标签和过滤器*。
- en: '`length`: Returns the length of the value. For a list, this returns the number
    of elements. For a string, this returns the number of characters. If the variable
    is undefined, `length` returns `0`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：返回值的长度。对于列表，这将返回元素的数量。对于字符串，这将返回字符的数量。如果变量未定义，`length`返回`0`。'
- en: Philosophies and limitations
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哲学和限制
- en: Now that you've gotten a feel for the **Django Template Language**(**DTL**),
    it is probably time to explain the basic design philosophy behind the DTL. First
    and foremost, the **limitations to the DTL are intentional.**
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对**Django模板语言**（DTL）有了一定的了解，现在可能是时候解释DTL背后的基本设计理念了。首先，**DTL的限制是有意的。**
- en: Django was developed in the high volume, ever-changing environment of an online
    newsroom. The original creators of Django had a very definite set of philosophies
    in creating the DTL.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Django是在在线新闻编辑室这样一个高频率、不断变化的环境中开发的。Django的原始创作者在创建DTL时有一套非常明确的哲学。
- en: 'These philosophies remain core to Django today. They are:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些理念至今仍然是Django的核心。它们是：
- en: Separate logic from presentation
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑与呈现分开
- en: Discourage redundancy
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止冗余
- en: Be decoupled from HTML
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与HTML解耦
- en: XML is bad
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML很糟糕
- en: Assume designer competence
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设设计师有能力
- en: Treat whitespace obviously
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显而易见地处理空格
- en: Don't invent a programming language
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要发明一种编程语言
- en: Ensure safety and security
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安全性
- en: Extensible
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可扩展
- en: 'Following is the explanation for this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此的解释：
- en: '** Separate logic from presentation**'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将逻辑与呈现分开**'
- en: A template system is a tool that controls presentation and presentation-related
    logic-and that's it. The template system shouldn't support functionality that
    goes beyond this basic goal.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统是控制呈现和与呈现相关逻辑的工具——仅此而已。模板系统不应该支持超出这一基本目标的功能。
- en: '**Discourage redundancy**'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**防止冗余**'
- en: The majority of dynamic websites use some sort of common site-wide design—a
    common header, footer, navigation bar, and so on. The Django template system should
    make it easy to store those elements in a single place, eliminating duplicate
    code. This is the philosophy behind template inheritance.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数动态网站使用某种常见的站点范围设计——共同的页眉、页脚、导航栏等等。Django模板系统应该能够轻松地将这些元素存储在一个地方，消除重复的代码。这就是模板继承背后的哲学。
- en: '**Be decoupled from HTML**'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与HTML解耦**'
- en: The template system shouldn't be designed so that it only outputs HTML. It should
    be equally good at generating other text-based formats, or just plain text.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统不应该被设计成只输出HTML。它应该同样擅长生成其他基于文本的格式，或者纯文本。
- en: '**XML should not be used for template languages**'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不应该使用XML作为模板语言**'
- en: Using an XML engine to parse templates introduces a whole new world of human
    error in editing templates—and incurs an unacceptable level of overhead in template
    processing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XML引擎解析模板会在编辑模板时引入一整套新的人为错误，并且在模板处理中产生不可接受的开销。
- en: '**Assume designer competence**'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假设设计师有能力**'
- en: The template system shouldn't be designed so that templates necessarily are
    displayed nicely in WYSIWYG editors such as Dreamweaver. That is too severe of
    a limitation and wouldn't allow the syntax to be as nice as it is.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统不应该设计成模板必须在诸如Dreamweaver之类的所见即所得编辑器中显示得很好。这太严重了，不会允许语法像现在这样好。
- en: Django expects template authors are comfortable editing HTML directly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Django期望模板作者能够舒适地直接编辑HTML。
- en: '**Treat whitespace obviously**'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显而易见地处理空格**'
- en: The template system shouldn't do magic things with whitespace. If a template
    includes whitespace, the system should treat the whitespace as it treats text—just
    display it. Any whitespace that's not in a template tag should be displayed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统不应该对空格做魔术。如果模板包含空格，系统应该像对待文本一样对待空格——只是显示它。任何不在模板标记中的空格都应该显示出来。
- en: '**Don''t invent a programming language**'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不要发明一种编程语言**'
- en: 'The template system intentionally doesn''t allow the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统有意不允许以下情况：
- en: Assignment to variables
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量赋值
- en: Advanced logic
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级逻辑
- en: The goal is not to invent a programming language. The goal is to offer just
    enough programming—esque functionality, such as branching and looping, that is
    essential for making presentation-related decisions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是发明一种编程语言。目标是提供足够的编程式功能，如分支和循环，这对于做出与呈现相关的决策至关重要。
- en: The Django template system recognizes that templates are most often written
    by designers, not programmers, and therefore should not assume Python knowledge.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板系统认识到模板通常是由设计师而不是程序员编写的，因此不应假设有Python知识。
- en: '**Safety and security**'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: The template system, out of the box, should forbid the inclusion of malicious
    code—such as commands that delete database records. This is another reason the
    template system doesn't allow arbitrary Python code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统应该默认禁止包含恶意代码，比如删除数据库记录的命令。这也是模板系统不允许任意Python代码的另一个原因。
- en: '**Extensibility**'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可扩展性**'
- en: The template system should recognize that advanced template authors may want
    to extend its technology. This is the philosophy behind custom template tags and
    filters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统应该认识到高级模板作者可能想要扩展其技术。这就是自定义模板标记和过滤器背后的哲学。
- en: Having worked with many different templating systems myself over the years,
    I whole-heartedly endorse this approach—the DTL and the way it has been designed
    is one of the major pluses of the Django framework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来我使用过许多不同的模板系统，我完全支持这种方法——DTL及其设计方式是Django框架的主要优点之一。
- en: When the pressure is on to Get Stuff Done, and you have both designers and programmers
    trying to communicate and get all the of the last minute tasks done, Django just
    gets out of the way and lets each team concentrate on what they are good at.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当压力来临，需要完成任务时，你既有设计师又有程序员试图沟通并完成所有最后一分钟的任务时，Django只是让每个团队专注于他们擅长的事情。
- en: Once you have found this out for yourself through real-life practice, you will
    find out very quickly why Django really is the *framework for perfectionists with
    deadlines*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过实际实践发现了这一点，你会很快发现为什么Django真的是*完美主义者的截止日期框架*。
- en: With all this in mind, Django is flexible—it does not require you to use the
    DTL. More than any other component of web applications, template syntax is highly
    subjective, and programmer's opinions vary wildly. The fact that Python alone
    has dozens, if not hundreds, of open source template-language implementations
    supports this point. Each was likely created because its developer deemed all
    existing template languages inadequate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一切，Django是灵活的——它不要求你使用DTL。与Web应用程序的任何其他组件相比，模板语法是高度主观的，程序员的观点差异很大。Python本身有数十，甚至数百个开源模板语言实现，这一点得到了支持。每一个可能都是因为其开发者认为所有现有的模板语言都不够好而创建的。
- en: Because Django is intended to be a full-stack web framework that provides all
    the pieces necessary for web developers to be productive, most times it's more
    convenient to use the DTL, but it's not a strict requirement in any sense.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Django旨在成为一个提供所有必要组件的全栈Web框架，以使Web开发人员能够高效工作，所以大多数情况下更方便使用DTL，但这并不是严格的要求。
- en: Using templates in views
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中使用模板
- en: You've learned the basics of using the template system; now let's use this knowledge
    to create a view.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了使用模板系统的基础知识；现在让我们利用这些知识来创建一个视图。
- en: 'Recall the `current_datetime` view in `mysite.views`, which we started in the
    previous chapter. Here''s what it looks like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`mysite.views`中的`current_datetime`视图，我们在上一章中开始了。它看起来是这样的：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s change this view to use Django''s template system. At first, you might
    think to do something like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改这个视图以使用Django的模板系统。起初，你可能会想要做类似这样的事情：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Sure, that uses the template system, but it doesn't solve the problems we pointed
    out in the introduction of this chapter. Namely, the template is still embedded
    in the Python code, so true separation of data and presentation isn't achieved.
    Let's fix that by putting the template in a separate file, which this view will
    load.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这使用了模板系统，但它并没有解决我们在本章开头指出的问题。也就是说，模板仍然嵌入在Python代码中，因此没有真正实现数据和呈现的分离。让我们通过将模板放在一个单独的文件中来解决这个问题，这个视图将会加载。
- en: 'You might first consider saving your template somewhere on your filesystem
    and using Python''s built-in file-opening functionality to read the contents of
    the template. Here''s what that might look like, assuming the template was saved
    as the file `/home/djangouser/templates/mytemplate.html`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先考虑将模板保存在文件系统的某个位置，并使用Python的内置文件打开功能来读取模板的内容。假设模板保存为文件`/home/djangouser/templates/mytemplate.html`，那么可能会是这样：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This approach, however, is inelegant for these reasons:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法是不够优雅的，原因如下：
- en: It doesn't handle the case of a missing file. If the file `mytemplate.html`
    doesn't exist or isn't readable, the `open()` call will raise an `IOError` exception.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有处理文件丢失的情况。如果文件`mytemplate.html`不存在或不可读，`open()`调用将引发`IOError`异常。
- en: It hard-codes your template location. If you were to use this technique for
    every view function, you'd be duplicating the template locations. Not to mention
    it involves a lot of typing!
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会将模板位置硬编码。如果你要为每个视图函数使用这种技术，你将会重复模板位置。更不用说这需要大量的输入！
- en: It includes a lot of boring boilerplate code. You've got better things to do
    than to write calls to `open()`, `fp.read()`, and `fp.close()` each time you load
    a template.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含了大量乏味的样板代码。你有更好的事情要做，而不是每次加载模板时都写`open()`、`fp.read()`和`fp.close()`的调用。
- en: To solve these issues, we'll use template loading and template directories.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们将使用模板加载和模板目录。
- en: Template loading
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板加载
- en: 'Django provides a convenient and powerful API for loading templates from the
    filesystem, with the goal of removing redundancy both in your template-loading
    calls and in your templates themselves. In order to use this template-loading
    API, first you''ll need to tell the framework where you store your templates.
    The place to do this is in your settings file—the `settings.py` file that I mentioned
    last chapter, when I introduced the `ROOT_URLCONF` setting. If you''re following
    along, open your `settings.py` and find the `TEMPLATES` setting. It''s a list
    of configurations, one for each engine:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个方便而强大的API，用于从文件系统加载模板，目的是消除模板加载调用和模板本身中的冗余。为了使用这个模板加载API，首先你需要告诉框架你存储模板的位置。这个地方就是你的设置文件——我在上一章中提到的`settings.py`文件。如果你在跟着做，打开你的`settings.py`文件，找到`TEMPLATES`设置。这是一个配置列表，每个引擎一个：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`BACKEND` is a dotted Python path to a template engine class implementing Django''s
    template backend API. The built-in backends are `django.template.backends.django.DjangoTemplates`
    and `django.template.backends.jinja2.Jinja2`. Since most engines load templates
    from files, the top-level configuration for each engine contains three common
    settings:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`BACKEND`是一个点分隔的Python路径，指向实现Django模板后端API的模板引擎类。内置的后端是`django.template.backends.django.DjangoTemplates`和`django.template.backends.jinja2.Jinja2`。由于大多数引擎从文件加载模板，每个引擎的顶级配置包含三个常见的设置：'
- en: '`DIRS` defines a list of directories where the engine should look for template
    source files, in search order.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRS`定义了引擎应该在其中查找模板源文件的目录列表，按搜索顺序排列。'
- en: '`APP_DIRS` tells whether the engine should look for templates inside installed
    applications. By convention, when `APPS_DIRS` is set to `True`, `DjangoTemplates`
    looks for a "templates" subdirectory in each of the `INSTALLED_APPS`. This allows
    the template engine to find application templates even if `DIRS` is empty.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_DIRS`告诉引擎是否应该在已安装的应用程序内查找模板。按照惯例，当`APPS_DIRS`设置为`True`时，`DjangoTemplates`会在每个`INSTALLED_APPS`的"templates"子目录中查找。这允许模板引擎即使`DIRS`为空也能找到应用程序模板。'
- en: '`OPTIONS` contains backend-specific settings.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`包含特定于后端的设置。'
- en: While uncommon, it's possible to configure several instances of the same backend
    with different options. In that case you should define a unique `NAME` for each
    engine.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但是可以配置多个具有不同选项的相同后端实例。在这种情况下，你应该为每个引擎定义一个唯一的`NAME`。
- en: Template directories
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板目录
- en: '`DIRS`, by default, is an empty list. To tell Django''s template-loading mechanism
    where to look for templates, pick a directory where you''d like to store your
    templates and add it to `DIRS`, like so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DIRS`是一个空列表。要告诉Django的模板加载机制在哪里查找模板，选择一个您想要存储模板的目录，并将其添加到`DIRS`中，如下所示：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are a few things to note:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情需要注意：
- en: Unless you are building a very simple program with no apps, you are better off
    leaving `DIRS` empty. The default settings file configures `APP_DIRS` to `True`,
    so you are better off having a `templates` subdirectory in your Django app.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您正在构建一个没有应用程序的非常简单的程序，否则最好将`DIRS`留空。默认设置文件将`APP_DIRS`配置为`True`，因此最好在Django应用程序中有一个`templates`子目录。
- en: 'If you want to have a set of master templates at project root, for example, `mysite/templates`,
    you do need to set `DIRS`, like so:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在项目根目录下拥有一组主模板，例如`mysite/templates`，您确实需要设置`DIRS`，如下所示：
- en: '''DIRS'': [os.path.join(BASE_DIR, ''templates'')],'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''DIRS'': [os.path.join(BASE_DIR, ''templates'')],'
- en: Your templates directory does not have to be called `'templates'`, by the way-Django
    doesn't put any restrictions on the names you use-but it makes your project structure
    much easier to understand if you stick to convention.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺便说一句，您的模板目录不一定要被称为`'templates'`，Django对您使用的名称没有任何限制，但是如果您遵循惯例，您的项目结构会更容易理解。
- en: If you don't want to go with the default, or can't for some reason, you can
    specify any directory you want, as long as the directory and templates within
    that directory are readable by the user account under which your web server runs.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不想使用默认设置，或者由于某些原因无法使用默认设置，您可以指定任何您想要的目录，只要该目录和该目录中的模板可被您的Web服务器运行的用户帐户读取。
- en: 'If you''re on Windows, include your drive letter and use Unix-style forward
    slashes rather than backslashes, as follows:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用Windows，请包括您的驱动器号，并使用Unix风格的正斜杠而不是反斜杠，如下所示：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As we have not yet created a Django app, you will have to set `DIRS` to `[os.path.join(BASE_DIR,
    ''templates'')]` as per the example preceding for the code below to work as expected.
    With `DIRS` set, the next step is to change the view code to use Django''s template-loading
    functionality rather than hard-coding the template paths. Returning to our `current_datetime`
    view, let''s change it like so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有创建Django应用程序，因此您必须根据上面的示例将`DIRS`设置为`[os.path.join(BASE_DIR, 'templates')]`，以使下面的代码按预期工作。设置了`DIRS`之后，下一步是更改视图代码，使用Django的模板加载功能而不是硬编码模板路径。回到我们的`current_datetime`视图，让我们像这样进行更改：
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, we''re using the function `django.template.loader.get_template()`
    rather than loading the template from the filesystem manually. The `get_template()`
    function takes a template name as its argument, figures out where the template
    lives on the filesystem, opens that file, and returns a compiled `Template` object.
    Our template in this example is `current_datetime.html`, but there''s nothing
    special about that `.html` extension. You can give your templates whatever extension
    makes sense for your application, or you can leave off extensions entirely. To
    determine the location of the template on your filesystem, `get_template()` will
    look in order:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了函数`django.template.loader.get_template()`而不是手动从文件系统加载模板。`get_template()`函数以模板名称作为参数，找出模板在文件系统上的位置，打开该文件，并返回一个编译的`Template`对象。在这个例子中，我们的模板是`current_datetime.html`，但`.html`扩展名并没有什么特别之处。您可以为您的应用程序指定任何扩展名，或者完全不使用扩展名。为了确定模板在文件系统上的位置，`get_template()`将按顺序查找：
- en: If `APP_DIRS` is set to `True`, and assuming you are using the DTL, it will
    look for a `templates` directory in the current app.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`APP_DIRS`设置为`True`，并且假设您正在使用DTL，它将在当前应用程序中查找`templates`目录。
- en: If it does not find your template in the current app, `get_template()` combines
    your template directories from `DIRS` with the template name that you pass to
    `get_template()` and steps through each of them in order until it finds your template.
    For example, if the first entry in your `DIRS` is set to `'/home/django/mysite/templates'`,
    the preceding `get_template()` call would look for the template `/home/django/mysite/templates/current_datetime.html`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它在当前应用程序中找不到您的模板，`get_template()`将从`DIRS`中组合您传递给`get_template()`的模板名称，并按顺序逐个查找，直到找到您的模板。例如，如果您的`DIRS`中的第一个条目设置为`'/home/django/mysite/templates'`，那么前面的`get_template()`调用将查找模板`/home/django/mysite/templates/current_datetime.html`。
- en: If `get_template()` cannot find the template with the given name, it raises
    a `TemplateDoesNotExist` exception.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`get_template()`找不到给定名称的模板，它会引发`TemplateDoesNotExist`异常。
- en: To see what a template exception looks like, fire up the Django development
    server again by running `python manage.py runserver` within your Django project's
    directory. Then, point your browser at the page that activates the `current_datetime`
    view (for example, `http://127.0.0.1:8000/time/`). Assuming your `DEBUG` setting
    is set to `True` and you haven't yet created a `current_datetime.html` template,
    you should see a Django error page highlighting the `TemplateDoesNotExist` error
    (*Figure 3.1*).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看模板异常的样子，再次启动Django开发服务器，方法是在Django项目目录中运行`python manage.py runserver`。然后，将浏览器指向激活`current_datetime`视图的页面（例如`http://127.0.0.1:8000/time/`）。假设您的`DEBUG`设置为`True`，并且您还没有创建`current_datetime.html`模板，您应该会看到一个Django错误页面，突出显示`TemplateDoesNotExist`错误（*图3.1*）。
- en: '![Template directories](img/image_03_001.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![模板目录](img/image_03_001.jpg)'
- en: 'Figure 3.1: Missing template error page.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：缺少模板错误页面。
- en: 'This error page is similar to the one I explained in [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and Urlconfs* with one additional piece
    of debugging information: a *Template-loader postmortem* section. This section
    tells you which templates Django tried to load, along with the reason each attempt
    failed (for example, **File does not exist**). This information is invaluable
    when you''re trying to debug template-loading errors. Moving along, create the
    `current_datetime.html` file using the following template code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误页面与我在[第2章](ch02.xhtml "第2章。视图和URLconfs")中解释的类似，*视图和URLconfs*，只是增加了一个额外的调试信息部分：*模板加载器事后调查*部分。该部分告诉您Django尝试加载的模板，以及每次尝试失败的原因（例如，**文件不存在**）。当您尝试调试模板加载错误时，这些信息是非常宝贵的。接下来，使用以下模板代码创建`current_datetime.html`文件：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Save this file to `mysite/templates` (create the `templates` directory if you
    have not done so already). Refresh the page in your web browser, and you should
    see the fully rendered page.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存到`mysite/templates`（如果尚未创建`templates`目录，则创建该目录）。刷新您的网络浏览器页面，您应该看到完全呈现的页面。
- en: render()
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: render()
- en: So far, we've shown you how to load a template, fill a `Context` and return
    an `HttpResponse` object with the result of the rendered template. Next step was
    to optimize it to use `get_template()` instead of hard-coding templates and template
    paths. I took you through this process to ensure you understood how Django templates
    are loaded and rendered to your browser.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向您展示了如何加载模板，填充`Context`并返回一个包含呈现模板结果的`HttpResponse`对象。下一步是优化它，使用`get_template()`代替硬编码模板和模板路径。我带您通过这个过程是为了确保您了解Django模板是如何加载和呈现到您的浏览器的。
- en: In practice, Django provides a much easier way to do this. Django's developers
    recognized that because this is such a common idiom, Django needed a shortcut
    that could do all this in one line of code. This shortcut is a function called
    `render()`, which lives in the module `django.shortcuts`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Django提供了一个更简单的方法来做到这一点。Django的开发人员意识到，因为这是一个常见的习语，Django需要一个快捷方式，可以在一行代码中完成所有这些。这个快捷方式是一个名为`render()`的函数，它位于模块`django.shortcuts`中。
- en: Most of the time, you'll be using `render()` rather than loading templates and
    creating `Context` and `HttpResponse` objects manually-unless your employer judges
    your work by total lines of code written, that is.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您将使用`render()`而不是手动加载模板和创建`Context`和`HttpResponse`对象-除非您的雇主根据编写的代码总行数来评判您的工作。
- en: 'Here''s the ongoing `current_datetime` example rewritten to use `render()`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`render()`重写的持续`current_datetime`示例：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'What a difference! Let''s step through the code changes:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有何不同！让我们逐步了解代码更改：
- en: We no longer have to import `get_template`, `Template`, `Context`, or `HttpResponse`.
    Instead, we import `django.shortcuts.render`. The `import datetime` remains.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要导入`get_template`，`Template`，`Context`或`HttpResponse`。相反，我们导入`django.shortcuts.render`。`import
    datetime`保持不变。
- en: Within the `current_datetime` function, we still calculate `now`, but the template
    loading, context creation, template rendering, and `HttpResponse` creation are
    all taken care of by the `render()` call. Because `render()` returns an `HttpResponse`
    object, we can simply `return` that value in the view.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`current_datetime`函数中，我们仍然计算`now`，但模板加载、上下文创建、模板渲染和`HttpResponse`创建都由`render()`调用处理。因为`render()`返回一个`HttpResponse`对象，所以我们可以在视图中简单地`return`该值。
- en: The first argument to `render()` is the request, the second is the name of the
    template to use. The third argument, if given, should be a dictionary to use in
    creating a `Context` for that template. If you don't provide a third argument,
    `render()` will use an empty dictionary.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`的第一个参数是请求，第二个是要使用的模板的名称。如果给出第三个参数，应该是用于为该模板创建`Context`的字典。如果不提供第三个参数，`render()`将使用一个空字典。'
- en: Template subdirectories
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板子目录
- en: It can get unwieldy to store all of your templates in a single directory. You
    might like to store templates in subdirectories of your template directory, and
    that's fine.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有模板存储在单个目录中可能会变得难以管理。您可能希望将模板存储在模板目录的子目录中，这也是可以的。
- en: In fact, I recommend doing so; some more advanced Django features (such as the
    generic views system, which we cover in [Chapter 10](ch10.xhtml "Chapter 10. Generic
    Views"), *Generic Views*) expect this template layout as a default convention.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我建议这样做；一些更高级的Django功能（例如通用视图系统，我们在[第10章](ch10.xhtml "第10章。通用视图")中介绍，*通用视图*）期望这种模板布局作为默认约定。
- en: 'Storing templates in subdirectories of your template directory is easy. In
    your calls to `get_template()`, just include the subdirectory name and a slash
    before the template name, like so:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板目录的子目录中存储模板很容易。在对`get_template()`的调用中，只需包括子目录名称和模板名称之前的斜杠，就像这样：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Because `render()` is a small wrapper around `get_template()`, you can do the
    same thing with the second argument to `render()`, like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`render()`是围绕`get_template()`的一个小包装器，你可以用`render()`的第二个参数做同样的事情，就像这样：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There's no limit to the depth of your subdirectory tree. feel free to use as
    many subdirectories as you like.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您的子目录树的深度没有限制。随意使用尽可能多的子目录。
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows users, be sure to use forward slashes rather than backslashes. `get_template()`
    assumes a Unix-style file name designation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户，请确保使用正斜杠而不是反斜杠。`get_template()`假定Unix风格的文件名指定。
- en: The include template tag
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含模板标签
- en: 'Now that we''ve covered the template-loading mechanism, we can introduce a
    built-in template tag that takes advantage of it: `{% include %}`. This tag allows
    you to include the contents of another template. The argument to the tag should
    be the name of the template to include, and the template name can be either a
    variable or a hard-coded (quoted) string, in either single or double quotes.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了模板加载机制，我们可以介绍一个利用它的内置模板标签：`{% include %}`。此标签允许您包含另一个模板的内容。标签的参数应该是要包含的模板的名称，模板名称可以是变量，也可以是硬编码（带引号）的字符串，可以是单引号或双引号。
- en: 'Anytime you have the same code in multiple templates, consider using an `{%
    include %}` to remove the duplication. These two examples include the contents
    of the template `nav.html`. The examples are equivalent and illustrate that either
    single or double quotes are allowed:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您在多个模板中有相同的代码时，请考虑使用`{% include %}`来消除重复。这两个示例包括模板`nav.html`的内容。这两个示例是等效的，并且说明单引号和双引号都是允许的：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This example includes the contents of the template `includes/nav.html`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括模板`includes/nav.html`的内容：
- en: '[PRE65]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This example includes the contents of the template whose name is contained
    in the variable `template_name`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括变量`template_name`中包含的模板的内容：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As in `get_template()`, the file name of the template is determined by either
    adding the path to the `templates` directory in the current Django app (if `APPS_DIR`
    is `True`) or by adding the template directory from `DIRS` to the requested template
    name. Included templates are evaluated with the context of the template that's
    including them.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与`get_template()`一样，模板的文件名是通过将当前Django应用程序中的`templates`目录的路径添加到模板名称（如果`APPS_DIR`为`True`）或将`DIRS`中的模板目录添加到请求的模板名称来确定的。包含的模板将使用包含它们的模板的上下文进行评估。
- en: 'For example, consider these two templates:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这两个模板：
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you render `mypage.html` with a context containing `current_section`, then
    the variable will be available in the `included` template, as you would expect.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用包含`current_section`的上下文渲染`mypage.html`，那么该变量将在`included`模板中可用，就像您期望的那样。
- en: 'If, in an `{% include %}` tag, a template with the given name isn''t found,
    Django will do one of two things:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`{% include %}`标记中找不到给定名称的模板，Django将执行以下两种操作之一：
- en: If `DEBUG` is set to `True`, you'll see the `TemplateDoesNotExist` exception
    on a Django error page.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`DEBUG`设置为`True`，您将在Django错误页面上看到`TemplateDoesNotExist`异常。
- en: If `DEBUG` is set to `False`, the tag will fail silently, displaying nothing
    in the place of the tag.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`DEBUG`设置为`False`，标记将会静默失败，在标记的位置显示空白。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no shared state between included templates-each include is a completely
    independent rendering process.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的模板之间没有共享状态-每个包含都是完全独立的渲染过程。
- en: Blocks are evaluated before they are included. This means that a template that
    includes blocks from another will contain blocks that have already been evaluated
    and rendered-not blocks that can be overridden by, for example, an extending template.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 块在被包含之前被评估。这意味着包含另一个模板的模板将包含已经被评估和渲染的块，而不是可以被另一个扩展模板覆盖的块。
- en: Template inheritance
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板继承
- en: 'Our template examples so far have been tiny HTML snippets, but in the real
    world, you''ll be using Django''s template system to create entire HTML pages.
    This leads to a common web development problem: across a web site, how does one
    reduce the duplication and redundancy of common page areas, such as site wide
    navigation?'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模板示例都是小型的HTML片段，但在现实世界中，您将使用Django的模板系统来创建整个HTML页面。这导致了一个常见的Web开发问题：在整个网站中，如何减少常见页面区域的重复和冗余，比如整个站点的导航？
- en: A classic way of solving this problem is to use server-side includes, directives
    you can embed within your HTML pages to include one web page inside another. Indeed,
    Django supports that approach, with the `{% include %}` template tag just described.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的经典方法是使用服务器端包含，您可以在HTML页面中嵌入的指令来包含一个网页在另一个网页中。事实上，Django支持这种方法，刚刚描述的`{%
    include %}`模板标记。
- en: 'But the preferred way of solving this problem with Django is to use a more
    elegant strategy called templateinheritance. In essence, template inheritance
    lets you build a base `skeleton` template that contains all the common parts of
    your site and defines "blocks" that child templates can override. Let''s see an
    example of this by creating a more complete template for our `current_datetime`
    view, by editing the `current_datetime.html` file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用Django解决这个问题的首选方法是使用一种更优雅的策略，称为模板继承。实质上，模板继承允许您构建一个包含站点所有常见部分并定义子模板可以覆盖的“块”的基本“骨架”模板。让我们通过编辑`current_datetime.html`文件来看一个更完整的模板示例，为我们的`current_datetime`视图创建一个更完整的模板：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'That looks just fine, but what happens when we want to create a template for
    another view-say, the `hours_ahead` view from [Chapter 2](ch02.xhtml "Chapter 2. Views
    and URLconfs"), *Views and Urlconfs*? If we want again to make a nice, valid,
    full HTML template, we''d create something like:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很好，但是当我们想要为另一个视图创建一个模板时会发生什么-比如，来自[第2章](ch02.xhtml "第2章。视图和URLconfs")的`hours_ahead`视图，*视图和URLconfs*？如果我们再次想要创建一个漂亮的有效的完整HTML模板，我们会创建类似于以下内容：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Clearly, we've just duplicated a lot of HTML. Imagine if we had a more typical
    site, including a navigation bar, a few style sheets, perhaps some JavaScript—we'd
    end up putting all sorts of redundant HTML into each template.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们刚刚复制了大量的HTML。想象一下，如果我们有一个更典型的网站，包括导航栏、一些样式表，也许还有一些JavaScript-我们最终会在每个模板中放入各种冗余的HTML。
- en: 'The server-side include solution to this problem is to factor out the common
    bits in both templates and save them in separate template snippets, which are
    then included in each template. Perhaps you''d store the top bit of the template
    in a file called `header.html`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的服务器端包含解决方案是将两个模板中的共同部分分解出来，并将它们保存在单独的模板片段中，然后在每个模板中包含它们。也许您会将模板的顶部部分存储在名为`header.html`的文件中：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And perhaps you''d store the bottom bit in a file called `footer.html`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会将底部部分存储在名为`footer.html`的文件中：
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With an include—based strategy, headers and footers are easy. It's the middle
    ground that's messy. In this example, both pages feature a title—*My helpful timestamp
    site*-but that title can't fit into `header.html` because the title on both pages
    is different. If we included the h1 in the header, we'd have to include the title,
    which wouldn't allow us to customize it per page.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于包含的策略，标题和页脚很容易。中间部分很混乱。在这个示例中，两个页面都有一个标题-*我的有用的时间戳站*-但是这个标题无法放入`header.html`，因为两个页面上的标题是不同的。如果我们在头部包含h1，我们就必须包含标题，这样就无法根据页面自定义它。
- en: Django's template inheritance system solves these problems. You can think of
    it as an inside-out version of server-side includes. Instead of defining the snippets
    that are common, you define the snippets that are different.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模板继承系统解决了这些问题。您可以将其视为服务器端包含的内部版本。您不是定义常见的片段，而是定义不同的片段。
- en: 'The first step is to define a base template—a skeleton of your page that child
    templates will later fill in. Here''s a base template for our ongoing example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义一个基本模板-稍后子模板将填写的页面骨架。以下是我们正在进行的示例的基本模板：
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This template, which we'll call `base.html`, defines a simple HTML skeleton
    document that we'll use for all the pages on the site.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板，我们将其称为`base.html`，定义了一个简单的HTML骨架文档，我们将用于站点上的所有页面。
- en: It's the job of child templates to override, or add to, or leave alone the contents
    of the blocks. (If you're following along, save this file to your template directory
    as `base.html`.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 子模板的工作是覆盖、添加或保留块的内容。 （如果您在跟踪，请将此文件保存到模板目录中，命名为`base.html`。）
- en: 'We''re using a template tag here that you haven''t seen before: the `{% block
    %}` tag. All the `{% block %}` tags do is tell the template engine that a child
    template may override those portions of the template.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个您以前没有见过的模板标记：`{% block %}`标记。所有`{% block %}`标记所做的就是告诉模板引擎，子模板可以覆盖模板的这些部分。
- en: 'Now that we have this base template, we can modify our existing `current_datetime.html`
    template to use it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个基本模板，我们可以修改我们现有的`current_datetime.html`模板来使用它：
- en: '[PRE73]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'While we''re at it, let''s create a template for the `hours_ahead` view from
    this chapter. (If you''re following along with code, I''ll leave it up to you
    to change `hours_ahead` to use the template system instead of hard-coded HTML.)
    Here''s what that could look like:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 趁热打铁，让我们为本章的`hours_ahead`视图创建一个模板。（如果您正在使用代码进行跟踪，我将让您自己决定将`hours_ahead`更改为使用模板系统而不是硬编码的HTML。）以下是可能的样子：
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Isn't this beautiful? Each template contains only the code that's unique to
    that template. No redundancy needed. If you need to make a site-wide design change,
    just make the change to `base.html`, and all of the other templates will immediately
    reflect the change.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很美吗？每个模板只包含该模板独有的代码。不需要冗余。如果您需要对整个站点进行设计更改，只需对`base.html`进行更改，所有其他模板将立即反映出更改。
- en: Here's how it works. When you load the template `current_datetime.html`, the
    template engine sees the `{% extends %}` tag, noting that this template is a child
    template. The engine immediately loads the parent template-in this case, `base.html`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理。当您加载模板`current_datetime.html`时，模板引擎会看到`{% extends %}`标记，并注意到这个模板是一个子模板。引擎立即加载父模板-在这种情况下是`base.html`。
- en: At that point, the template engine notices the three `{% block %}` tags in `base.html`
    and replaces those blocks with the contents of the child template. So, the title
    we've defined in `{% block title %}` will be used, as will the `{% block content
    %}`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，模板引擎注意到`base.html`中的三个`{% block %}`标记，并用子模板的内容替换这些块。因此，我们在`{% block title
    %}`中定义的标题将被使用，`{% block content %}`也将被使用。
- en: Note that since the child template doesn't define the footer block, the template
    system uses the value from the parent template instead. Content within a
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于子模板未定义页脚块，模板系统将使用父模板中的值。在
- en: '`{% block %}` tag in a parent template is always used as a fall-back.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 父模板中的`{% block %}`标记始终用作备用。
- en: 'Inheritance doesn''t affect the template context. In other words, any template
    in the inheritance tree will have access to every one of your template variables
    from the context. You can use as many levels of inheritance as needed. One common
    way of using inheritance is the following three-level approach:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 继承不会影响模板上下文。换句话说，继承树中的任何模板都可以访问上下文中的每个模板变量。您可以使用所需的任意级别的继承。使用继承的一种常见方式是以下三级方法：
- en: Create a `base.html` template that holds the main look and feel of your site.
    This is the stuff that rarely, if ever, changes.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含站点主要外观和感觉的`base.html`模板。这通常是很少或几乎不会更改的东西。
- en: Create a `base_SECTION.html` template for each section of your site (for example,
    `base_photos.html` and `base_forum.html`). These templates extend `base.html`
    and include section-specific styles/design.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为站点的每个部分创建一个`base_SECTION.html`模板（例如，`base_photos.html`和`base_forum.html`）。这些模板扩展`base.html`并包括特定于部分的样式/设计。
- en: Create individual templates for each type of page, such as a forum page or a
    photo gallery. These templates extend the appropriate section template.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种类型的页面创建单独的模板，例如论坛页面或照片库。这些模板扩展适当的部分模板。
- en: 'This approach maximizes code reuse and makes it easy to add items to shared
    areas, such as section-wide navigation. Here are some guidelines for working with
    template inheritance:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最大程度地提高了代码的重用性，并使向共享区域添加项目变得容易，比如整个部分的导航。以下是一些使用模板继承的指导方针：
- en: If you use `{% extends %}` in a template, it must be the first template tag
    in that template. Otherwise, template inheritance won't work.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在模板中使用`{% extends %}`，它必须是该模板中的第一个模板标记。否则，模板继承将无法工作。
- en: Generally, the more `{% block %}` tags in your base templates, the better. Remember,
    child templates don't have to define all parent blocks, so you can fill in reasonable
    defaults in a number of blocks, and then define only the ones you need in the
    child templates. It's better to have more hooks than fewer hooks.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，基本模板中有更多的`{% block %}`标记，越好。请记住，子模板不必定义所有父块，因此您可以在许多块中填写合理的默认值，然后仅在子模板中定义您需要的块。拥有更多的钩子比拥有更少的钩子更好。
- en: If you find yourself duplicating code in a number of templates, it probably
    means you should move that code to a `{% block %}` in a parent template.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您发现自己在许多模板中重复使用代码，这可能意味着您应该将该代码移动到父模板中的`{% block %}`中。
- en: If you need to get the content of the block from the parent template, use `{{
    block.super }}`, which is a "magic" variable providing the rendered text of the
    parent template. This is useful if you want to add to the contents of a parent
    block instead of completely overriding it.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要从父模板获取块的内容，请使用 `{{ block.super }}`，这是一个提供父模板呈现文本的 "魔术" 变量。如果您想要添加到父块的内容而不是完全覆盖它，这将非常有用。
- en: You may not define multiple `{% block %}` tags with the same name in the same
    template. This limitation exists because a block tag works in "both" directions.
    That is, a block tag doesn't just provide a hole to fill, it also defines the
    content that fills the hole in the parent. If there were two similarly named `{%
    block %}` tags in a template, that template's parent wouldn't know which one of
    the blocks' content to use.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能不会在同一个模板中定义多个具有相同名称的 `{% block %}` 标签。这种限制存在是因为块标签在 "两个" 方向上起作用。也就是说，块标签不仅提供要填充的空白，还定义了填充父级空白的内容。如果模板中有两个类似命名的
    `{% block %}` 标签，那么该模板的父级将不知道使用哪个块的内容。
- en: The template name you pass to `{% extends %}` is loaded using the same method
    that `get_template()` uses. That is, the template name is appended to your `DIRS`
    setting, or the "templates" folder in the current Django app.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您传递给 `{% extends %}` 的模板名称是使用 `get_template()` 使用的相同方法加载的。也就是说，模板名称将附加到您的 `DIRS`
    设置，或者当前Django应用程序中的 "templates" 文件夹。
- en: In most cases, the argument to `{% extends %}` will be a string, but it can
    also be a variable, if you don't know the name of the parent template until runtime.
    This lets you do some cool, dynamic stuff.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，`{% extends %}` 的参数将是一个字符串，但它也可以是一个变量，如果您直到运行时才知道父模板的名称。这让您可以做一些很酷的、动态的事情。
- en: What's next?
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'You now have the basics of Django''s template system under your belt. What''s
    next? Most modern websites are database-driven: the content of the website is
    stored in a relational database. This allows a clean separation of data and logic
    (in the same way views and templates allow the separation of logic and display.)
    The next chapter covers the tools Django gives you to interact with a database.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了Django模板系统的基础知识。接下来呢？大多数现代网站都是数据库驱动的：网站的内容存储在关系数据库中。这允许对数据和逻辑进行清晰的分离（就像视图和模板允许逻辑和显示的分离一样）。下一章介绍了Django提供的与数据库交互的工具。
