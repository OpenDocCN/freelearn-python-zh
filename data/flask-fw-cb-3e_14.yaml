- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Additional Tips and Tricks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的技巧和窍门
- en: This book has covered almost all the areas that need to be known for the creation
    of a web application using Flask. Much has been covered, and a lot more needs
    to be explored. In this final chapter, we will go through some additional recipes
    that can be used to add value to a Flask-based web application if and when needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书几乎涵盖了使用Flask创建Web应用程序所需了解的所有领域。已经涵盖了大量的内容，还有更多需要探索。在本章的最后，我们将介绍一些额外的食谱，这些食谱可以在需要时用于为基于Flask的Web应用程序增加价值。
- en: We will learn how to implement full-text search using Elasticsearch. Full-text
    search becomes important for a web application that offers a lot of content and
    options, such as an e-commerce site. Next, we will catch up on signals that help
    decouple applications by sending notifications (signals) when an action is performed
    somewhere in the application. This signal is caught by a subscriber/receiver that
    can perform an action accordingly. This is followed by implementing caching for
    our Flask application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用Elasticsearch实现全文搜索。对于提供大量内容和选项的Web应用程序，如电子商务网站，全文搜索变得非常重要。接下来，我们将了解帮助通过发送通知（信号）来解耦应用程序的信号。当在应用程序的某个地方执行操作时，这个信号会被一个订阅者/接收者捕获，并相应地执行操作。这之后，我们将实现为我们的Flask应用程序添加缓存。
- en: We will also see how email support is added to our application and how emails
    can be sent directly from the application by performing different actions. We
    will then see how we can make our application asynchronous. By default, WSGI applications
    are synchronous and blocking – that is, by default, they do not serve multiple
    simultaneous requests together. We will see how to deal with this via a small
    example. We will also integrate Celery with our application and see how a task
    queue can be used to our application’s benefit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解如何将电子邮件支持添加到我们的应用程序中，以及如何通过执行不同的操作直接从应用程序发送电子邮件。然后我们将看到如何使我们的应用程序异步。默认情况下，WSGI应用程序是同步和阻塞的——也就是说，默认情况下，它们不会同时服务多个请求。我们将通过一个小示例来了解如何处理这个问题。我们还将集成Celery到我们的应用程序中，并了解如何利用任务队列来为我们的应用程序带来好处。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Implementing full-text search with Elasticsearch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elasticsearch实现全文搜索
- en: Working with signals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与信号一起工作
- en: Using caching with your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用缓存
- en: Implementing email support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现电子邮件支持
- en: Understanding asynchronous operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解异步操作
- en: Working with Celery
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Celery一起工作
- en: Implementing full-text search with Elasticsearch
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elasticsearch实现全文搜索
- en: Full-text search is an essential part of almost all use cases that are catered
    to via web applications. It becomes much more crucial if you intend to build an
    e-commerce platform or something similar where search plays a central role. Full-text
    search means an ability to search some text inside a large amount of textual data
    where the search results can contain full or partial matches as per configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 全文搜索是几乎所有通过Web应用程序提供的用例的一个基本部分。如果你打算构建一个电子商务平台或类似的东西，其中搜索扮演着核心角色，那么它就变得更加关键。全文搜索意味着在大量文本数据中搜索某些文本的能力，搜索结果可以包含根据配置的全匹配或部分匹配。
- en: '**Elasticsearch** is a search server based on Lucene, which is an open source
    information-retrieval library. Elasticsearch provides a distributed full-text
    search engine with a RESTful web interface and schema-free JSON documents. In
    this recipe, we will implement full-text search using Elasticsearch for our Flask
    application.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Elasticsearch**是一个基于Lucene的搜索服务器，Lucene是一个开源的信息检索库。Elasticsearch提供了一个具有RESTful网络接口和无模式JSON文档的分布式全文搜索引擎。在本食谱中，我们将使用Elasticsearch为我们的Flask应用程序实现全文搜索。'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use a Python library called `elasticsearch`, which makes dealing with
    Elasticsearch a lot easier:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`elasticsearch`的Python库，它使得处理Elasticsearch变得更加容易：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to install the Elasticsearch server itself. This can be downloaded
    from [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch).
    Unpack the package at any location of your choice on your machine and run the
    following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装Elasticsearch服务器本身。这可以从[https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch)下载。在您的机器上选择任何位置解压该包，并运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will start the Elasticsearch server on `http://localhost:9200/` by default.
    There are a couple of details that you need to make note of before moving ahead:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将默认在`http://localhost:9200/`上启动Elasticsearch服务器。在继续之前，有几个细节需要注意：
- en: 'When you run the `elasticsearch` server using the preceding command, you will
    see some details as shown in the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您使用前面的命令运行`elasticsearch`服务器时，您将看到以下截图所示的一些详细信息：
- en: '![Figure 14.1 – Elasticsearch security details](img/B19111_14_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – Elasticsearch安全细节](img/B19111_14_1.jpg)'
- en: Figure 14.1 – Elasticsearch security details
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – Elasticsearch安全细节
- en: Make note of the password for the elastic user here. You can also choose to
    reset the password using the command specified in the preceding screenshot.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处记录弹性用户的密码。您也可以选择使用前一个截图指定的命令重置密码。
- en: When you run the `elasticsearch` server, it generates an HTTP CA certificate,
    which needs to be used while establishing a connection via our Flask application.
    You can find this certificate file in the `config/certs` folder of your `elasticsearch`
    server folder. In most cases, it should be `<path to your` `elasticsearch folder>/config/certs/http_ca.crt`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您运行`elasticsearch`服务器时，它会生成一个HTTP CA证书，在通过我们的Flask应用程序建立连接时需要使用此证书。您可以在`elasticsearch`服务器文件夹的`config/certs`文件夹中找到此证书文件。在大多数情况下，它应该是`<path
    to your>` `elasticsearch folder>/config/certs/http_ca.crt`。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to perform the integration between Elasticsearch and our
    Flask application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行Elasticsearch和我们的Flask应用程序之间的集成：
- en: 'Start by adding the `elasticsearch` object to the application’s configuration
    – that is, `my_app/__init__.py`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`elasticsearch`对象添加到应用程序的配置中——即`my_app/__init__.py`：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will notice that several configuration settings are used in the preceding
    code. I have used them directly while instantiating an `es` object to make it
    easier for you to understand. In actual applications, these should come from configuration
    settings or configuration files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到前一段代码中使用了几个配置设置。我直接在实例化`es`对象时使用了它们，以便您更容易理解。在实际应用程序中，这些应该来自配置设置或配置文件。
- en: Here, we have created an `es` object from the `Elasticsearch` class, which accepts
    the server URL, HTTP CA certificate, and basic authentication using the username
    and password. The HTTP CA certificate and password were sourced in the steps outlined
    in the *Getting ready* section of this recipe. `verify_certs=False` is required
    because my application is running on HTTP, while Elasticsearch runs on HTTPS.
    If your app also runs on HTTPS, then this flag would not be needed. `ignore=400`
    will ignore any errors related to `resource_already_exists_exception` that are
    raised, as this index has been created already.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已从`Elasticsearch`类创建了一个`es`对象，该对象接受服务器URL、HTTP CA证书以及使用用户名和密码的基本身份验证。HTTP
    CA证书和密码在*准备就绪*部分的步骤中获取。`verify_certs=False`是必需的，因为我的应用程序正在运行在HTTP上，而Elasticsearch运行在HTTPS上。如果您的应用程序也运行在HTTPS上，则此标志将不需要。`ignore=400`将忽略与`resource_already_exists_exception`相关的任何错误，因为此索引已经创建。
- en: 'Next, we need to add a document to our Elasticsearch index. This can be done
    in views or models; however, in my opinion, the best way will be to add it in
    the model layer because it is more closely related to data rather than how it
    is displayed. We will do this in the `my_app/catalog/models.py` file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要向我们的Elasticsearch索引添加一个文档。这可以在视图或模型中完成；然而，在我看来，最好的方法是在模型层添加它，因为它与数据更紧密相关，而不是如何显示。我们将在`my_app/catalog/models.py`文件中完成此操作：
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, in each of the models, we added a new method called `add_index_to_es()`,
    which will add the document that corresponds to the current `Product` or `Category`
    object to the `catalog` index. You might want to index different types of data
    in separate indexes to make the search more accurate. Finally, we refreshed our
    index so that the newly created index is available for searching.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在每个模型中添加了一个名为`add_index_to_es()`的新方法，该方法将对应于当前`Product`或`Category`对象的文档添加到`catalog`索引。您可能希望将不同类型的数据分别索引以提高搜索的准确性。最后，我们刷新了索引，以便新创建的索引可用于搜索。
- en: The `add_index_to_es()` method can be called when we create, update, or delete
    a product or category.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建、更新或删除产品或类别时，可以调用`add_index_to_es()`方法。
- en: 'Next, for demonstration, just add the statement to index a document (product)
    to the `elasticsearch` index while creating the product in `my_app/catalog/views.py`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了演示，只需在创建产品时将索引文档（产品）的语句添加到`my_app/catalog/views.py`中的`elasticsearch`索引：
- en: '[PRE25]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we have also added a `product_search_es()` method to
    allow for searching on the Elasticsearch index we just created. Do the same in
    the `create_category()` method as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还添加了一个`product_search_es()`方法，以便在刚刚创建的Elasticsearch索引上进行搜索。同样，在`create_category()`方法中也进行相同的操作。
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The search query we sent to Elasticsearch in the preceding code is pretty basic
    and open-ended. I would urge you to read about Elasticsearch query building and
    apply it to your program. Refer to the following: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们发送给Elasticsearch的搜索查询相当基础且开放。我强烈建议你阅读有关Elasticsearch查询构建的内容，并将其应用于你的程序。请参考以下内容：[https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html)。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Now, let’s say we created a few categories and products in each of the categories.
    If we open `http://127.0.0.1:5000/product-search-es?q=phone`, we will get a response
    similar to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们在每个类别中创建了一些类别和产品。如果我们打开`http://127.0.0.1:5000/product-search-es?q=phone`，我们将得到以下类似的响应：
- en: '[PRE43]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I encourage you to try and enhance the formatting and display of the output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试增强输出格式和显示。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can learn more about connecting to the elasticsearch server at [https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html)了解更多关于连接到elasticsearch服务器的信息。
- en: More about the Python Elasticsearch client can be read at [https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html](https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Python Elasticsearch客户端的信息，请参阅[https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html](https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html)
- en: Working with signals
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与信号一起工作
- en: '**Signals** can be thought of as events that happen in our application. These
    events can be subscribed by certain receivers who then invoke a function whenever
    the event occurs. The occurrence of events is broadcasted by senders who can specify
    the arguments that can be used by the function, which will be triggered by the
    receiver.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**可以被视为在我们应用程序中发生的事件。这些事件可以被某些接收者订阅，当事件发生时，接收者将调用一个函数。事件的产生由发送者广播，发送者可以指定函数可以使用的参数，该函数将由接收者触发。'
- en: Important
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: You should refrain from modifying any application data in the signals because
    signals aren’t executed in a specified order and can easily lead to data corruption.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免在信号中修改任何应用程序数据，因为信号不是按照指定的顺序执行的，很容易导致数据损坏。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use a Python library called `blinker`, which provides the signals feature.
    Flask has built-in support for `blinker` and uses signaling itself to a good extent.
    There are certain core signals provided by Flask.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`blinker`的Python库，它提供了信号功能。Flask内置了对`blinker`的支持，并且大量使用了信号。Flask提供了一些核心信号。
- en: In this recipe, we will use the application from the *Implementing full-text
    search with Elasticsearch* recipe and add the `product` and `category` documents
    to make indexes work via signals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用来自*使用Elasticsearch实现全文搜索*菜谱的应用程序，并添加`product`和`category`文档，通过信号使索引工作。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to implement and understand how signaling works:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现并理解信号的工作原理：
- en: 'First, create signals for the `product` and `category` creation. This can be
    done in `my_app/catalog/models.py`. However, you can use any file you want since
    signals are created on a global scope:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为`product`和`category`创建信号。这可以在`my_app/catalog/models.py`中完成。然而，你可以使用任何你想要的文件，因为信号是在全局范围内创建的：
- en: '[PRE44]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have used `Namespace` to create signals, which will create them in a custom
    namespace rather than in the global namespace, thereby helping with the clean
    management of signals. We created two signals, `product-created` and `category-created`,
    where the intent of both is clear by their names.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Namespace`来创建信号，这将它们创建在自定义命名空间中，而不是全局命名空间中，从而有助于信号的整洁管理。我们创建了两个信号，`product-created`和`category-created`，它们的意图通过它们的名称都很清楚。
- en: 'Then, we will create subscribers to these signals and attach functions to them.
    For this, the `add_index_to_es()` methods have to be removed (if you are building
    over the code from the previous recipe), and new functions on the global scope
    have to be created in `my_app/catalog/models.py`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建对这些信号的订阅者，并将函数附加到它们。为此，必须移除（如果您是在上一个配方的基础上构建）`add_index_to_es()`方法，并在`my_app/catalog/models.py`的全局范围内创建新函数：
- en: '[PRE50]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code snippet, we created subscribers for the signals we created
    in *step 1* using `.connect()`. This method accepts the function that should be
    called when the event occurs; it also accepts the sender as an optional argument.
    The `app` object is provided as the sender because we don’t want our function
    to be called every time the event is triggered anywhere in any application. This
    specifically holds true in the case of extensions, which can be used by multiple
    applications. The function that gets called by the receiver (in this case, `add_product_index_to_es`
    and `add_category_index_to_es`) gets the sender as the first argument, which defaults
    to `None` if the sender is not provided. We provided the product/category as the
    second argument for which the record needs to be added to the `elasticsearch`
    index.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`.connect()`创建了在*步骤1*中创建的信号的订阅者。此方法接受在事件发生时应调用的函数；它还接受发送者作为可选参数。`app`对象作为发送者提供，因为我们不希望我们的函数在应用程序的任何地方触发事件时被调用。这在扩展的情况下尤其正确，因为它们可以被多个应用程序使用。接收者调用的函数（在这种情况下，`add_product_index_to_es`和`add_category_index_to_es`）将发送者作为第一个参数，如果未提供发送者，则默认为`None`。我们提供了产品/类别的第二个参数，需要将其记录添加到`elasticsearch`索引中。
- en: 'Now, emit the signal that can be caught by the receiver. This needs to be done
    in `my_app/catalog/views.py`. For this, just remove the calls to the `add_index_to_es()`
    methods and replace them with the `.``send()` methods:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，发出可以被接收者捕获的信号。这需要在`my_app/catalog/views.py`中完成。为此，只需移除对`add_index_to_es()`方法的调用，并用`.send()`方法替换它们：
- en: '[PRE64]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Do the same in the `create_category()` method as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`create_category()`方法中执行相同的操作。
- en: How it works…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever a product is created, the `product_created` signal is emitted, with
    the `app` object as the sender and the `product` as the keyword argument. This
    is then caught in `models.py` and the `add_product_index_to_es()` function is
    called, which adds the document to the catalog index.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建产品时，都会发出`product_created`信号，其中`app`对象作为发送者，`product`作为关键字参数。然后，在`models.py`中捕获此信号，并调用`add_product_index_to_es()`函数，将文档添加到目录索引中。
- en: The functionality of this recipe is exactly the same as the last recipe, *Implementing
    full-text search* *with Elasticsearch*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的功能与上一个配方*使用Elasticsearch实现全文搜索*完全相同。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Read the *Implementing full-text search with Elasticsearch* recipe for a background
    on this recipe
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读关于*使用Elasticsearch实现全文搜索*的配方，以了解此配方的背景信息
- en: You can read about the `blinker` library at [https://pypi.python.org/pypi/blinker](https://pypi.python.org/pypi/blinker)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://pypi.python.org/pypi/blinker](https://pypi.python.org/pypi/blinker)上了解`blinker`库
- en: You can view the list of core signals that are supported by Flask at [https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list](https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list](https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list)查看Flask支持的核心理信号列表
- en: You can view the signals that are provided by Flask-SQLAlchemy for tracking
    modifications to models at [https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications](https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications](https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications)查看Flask-SQLAlchemy提供的信号，用于跟踪模型修改
- en: Using caching with your application
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用缓存
- en: '**Caching** becomes an important and integral part of any web application when
    scaling or increasing the response time of your application becomes a question.
    Caching is the first thing that is implemented in these cases. Flask, by itself,
    does not provide any caching support by default, but **Werkzeug** does. Werkzeug
    has some basic support to cache with multiple backends, such as Memcached and
    Redis. This caching support of Werkzeug is implemented by a package called **Flask-Caching**,
    which we will use in this recipe.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展或增加应用程序的响应时间成为一个问题时，**缓存**成为任何Web应用程序的一个重要且不可或缺的部分。在这些情况下，缓存是首先实施的事情。Flask本身默认不提供任何缓存支持，但**Werkzeug**提供了。Werkzeug有一些基本支持，可以使用多个后端进行缓存，例如Memcached和Redis。Werkzeug的这种缓存支持是通过一个名为**Flask-Caching**的包实现的，我们将在这个菜谱中使用它。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will install a Flask extension called `flask-caching`, which simplifies
    the process of caching a lot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装一个名为`flask-caching`的Flask扩展，它简化了缓存过程：
- en: '[PRE73]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We will use our catalog application for this purpose and implement caching for
    some methods.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的目录应用程序来完成这个目的，并为某些方法实现缓存。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Implementing basic caching is pretty easy. Go through the following steps to
    do so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基本的缓存相当简单。按照以下步骤进行操作：
- en: 'First, initialize `Cache` to work with our application. This is done in the
    application’s configuration – that is, `my_app/__init__.py`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，初始化`Cache`以与我们的应用程序一起工作。这是在应用程序的配置中完成的——即`my_app/__init__.py`：
- en: '[PRE74]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we used `simple` as the `Cache` type, where the cache is stored in the
    memory. This is not advised for production environments. For production, we should
    use something such as Redis, Memcached, filesystem cache, and so on. Flask-Caching
    supports all of them with a couple more backends.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`simple`作为`Cache`类型，其中缓存存储在内存中。这不建议在生产环境中使用。对于生产环境，我们应该使用Redis、Memcached、文件系统缓存等类似的东西。Flask-Caching支持所有这些以及一些额外的后端。
- en: 'Next, add caching to the methods that need to be cached. Just add a `@cache.cached(timeout=<time
    in seconds>)` decorator to the view methods. A simple target can be the list of
    categories (we will do this in `my_app/catalog/views.py`):'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将缓存添加到需要缓存的那些方法中。只需在视图方法中添加一个`@cache.cached(timeout=<time in seconds>)`装饰器。一个简单的目标可以是分类列表（我们将在`my_app/catalog/views.py`中这样做）：
- en: '[PRE76]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This way of caching stores the value of the output of this method in the cache
    in the form of a key-value pair, with the key as the request path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存方式将此方法的输出值以键值对的形式存储在缓存中，键为请求路径。
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: After adding the preceding code, to check whether the cache works as expected,
    fetch the list of categories by pointing the browser to `http://127.0.0.1:5000/categories`.
    This will save a key-value pair for this URL in the cache. Now, create a new category
    quickly and navigate to the same category list page. You will notice that the
    newly added category is not listed. Wait for a couple of minutes and then reload
    the page. The newly added category will be shown now. This is because the first
    time the category list was cached, it expired after 2 minutes (120 seconds).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加前面的代码后，为了检查缓存是否按预期工作，请将浏览器指向`http://127.0.0.1:5000/categories`来获取分类列表。这将在这个URL的缓存中保存一个键值对。现在，快速创建一个新的分类并导航到相同的分类列表页面。你会注意到新添加的分类没有被列出。等待几分钟然后重新加载页面。现在新添加的分类将显示出来。这是因为分类列表第一次被缓存后，2分钟（120秒）后过期。
- en: This might seem to be a fault with the application but, in the case of large
    applications, this becomes a boon where the hits to the database are reduced,
    and the overall application experience improves. Caching is usually implemented
    for those handlers whose results don’t get updated frequently.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是应用程序的缺陷，但在大型应用程序的情况下，这成为了一种福音，因为减少了数据库的访问次数，整体应用程序体验得到了改善。缓存通常用于那些结果不经常更新的处理程序。
- en: There’s more…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Many of us might think that such caching will fail in the case of a single
    category or product page, where each record has a separate page. The solution
    to this is **memoization**. It is similar to caching, with the difference being
    that it stores the result of a method in the cache, along with the information
    on the parameters that were passed. So, when a method is created with the same
    parameters multiple times, the result is loaded from the cache rather than making
    a database hit. Implementing memoization is quite simple:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人可能会认为，在单个类别或产品页面的情况下，每个记录都有单独的页面，这种缓存可能会失败。解决这个问题的方法是**记忆化**。它与缓存类似，区别在于它将方法的结果存储在缓存中，同时存储传递给参数的信息。因此，当多次使用相同参数创建方法时，结果将从缓存中加载，而不是进行数据库调用。实现记忆化相当简单：
- en: '[PRE82]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, if we open a URL (say, `http://127.0.0.1:5000/product/1`) in our browser
    for the first time, it will be loaded after making calls to the database. However,
    if we make the same call again, the page will be loaded from the cache. On the
    other hand, if we open another product (say, `http://127.0.0.1:5000/product/2`),
    then it will be loaded after fetching the product details from the database when
    accessed for the first time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们第一次在我们的浏览器中打开一个URL（例如，`http://127.0.0.1:5000/product/1`），它将在调用数据库后加载。然而，如果我们再次进行相同的调用，页面将从缓存中加载。另一方面，如果我们打开另一个产品（例如，`http://127.0.0.1:5000/product/2`），那么它将在第一次访问时从数据库中获取产品详情后加载。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Flask-Caching at [https://flask-caching.readthedocs.io/en/latest/](https://flask-caching.readthedocs.io/en/latest/)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-Caching在[https://flask-caching.readthedocs.io/en/latest/](https://flask-caching.readthedocs.io/en/latest/)
- en: Memoization at [http://en.wikipedia.org/wiki/Memoization](http://en.wikipedia.org/wiki/Memoization)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化在[http://en.wikipedia.org/wiki/Memoization](http://en.wikipedia.org/wiki/Memoization)
- en: Implementing email support
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现电子邮件支持
- en: The ability to send emails is usually one of the most basic functions of any
    web application. It is usually easy to implement with any application. With Python-based
    applications, it is quite simple to implement with the help of `smtplib`. In the
    case of Flask, this is further simplified by an extension called `Flask-Mail`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件的能力通常是任何网络应用最基本的功能之一。通常，使用任何应用实现它都很简单。对于基于Python的应用，借助`smtplib`实现起来相当简单。在Flask的情况下，这通过一个名为`Flask-Mail`的扩展进一步简化。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`Flask-Mail` can be easily installed via `pip`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Mail`可以通过`pip`轻松安装：'
- en: '[PRE83]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Let’s look at a simple case where an email will be sent to a catalog manager
    in the application whenever a new category is added.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，当在应用程序中添加新类别时，将向目录管理员发送电子邮件。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, instantiate the `Mail` object in our application’s configuration – that
    is, `my_app/__init__.py`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的应用程序配置中实例化`Mail`对象——即`my_app/__init__.py`文件：
- en: '[PRE84]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We also need to do some configuration to set up the email server and sender
    account. The preceding code is a sample configuration for Gmail accounts (without
    two-factor authentication enabled). Any SMTP server can be set up like this. There
    are several other options provided; they can be found in the `Flask-Mail` documentation
    at [https://pythonhosted.org/Flask-Mail](https://pythonhosted.org/Flask-Mail).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要进行一些配置，以设置电子邮件服务器和发送者账户。前面的代码是Gmail账户（未启用双因素认证）的示例配置。任何SMTP服务器都可以这样设置。还有其他几个选项可供选择；它们可以在`Flask-Mail`文档中找到，网址为[https://pythonhosted.org/Flask-Mail](https://pythonhosted.org/Flask-Mail)。
- en: 'To send an email on category creation, we need to make the following changes
    in `my_app/catalog/views.py`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在创建类别时发送电子邮件，我们需要在`my_app/catalog/views.py`文件中进行以下更改：
- en: '[PRE85]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, a new email will be sent to the list of recipients from the default sender
    configuration that we did. You will notice that the category creation takes one
    or two seconds to execute. That is the time taken to send the email.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将向默认发送者配置中的收件人列表发送一封新电子邮件。您会注意到，创建类别需要一秒或两秒的时间来执行。这就是发送电子邮件所需的时间。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Create a new category by simply making a post request to `http://127.0.0.1:5000/category-create`.
    You can do it using the `requests` library from the `Python` prompt:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`http://127.0.0.1:5000/category-create`发送一个POST请求来创建一个新的类别。您可以使用`Python`提示中的`requests`库来完成此操作：
- en: '[PRE86]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You should receive an email on the recipient email ID(s) provided.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在提供的收件人电子邮件ID(s)上收到电子邮件。
- en: There’s more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now, let’s assume that we need to send a large email with a lot of HTML content.
    Writing all of this in our Python file will make the overall code ugly and unmanageable.
    A simple solution to this is to create templates and render their content while
    sending emails. Here, I created two templates: one for the HTML content and one
    simply for text content.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们需要发送一个包含大量HTML内容的电子邮件。将所有这些内容都写在我们的Python文件中会使整体代码变得丑陋且难以管理。一个简单的解决方案是在发送电子邮件时创建模板并渲染其内容。在这里，我创建了两个模板：一个用于HTML内容，另一个仅用于文本内容。
- en: 'The `category-create-email-text.html` template will look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`category-create-email-text.html`模板将看起来像这样：'
- en: '[PRE87]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `category-create-email-html.html` template will look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`category-create-email-html.html`模板将看起来像这样：'
- en: '[PRE88]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'After this, we need to modify the email message creation procedure that we
    created earlier:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要修改我们之前创建的电子邮件消息创建过程：
- en: '[PRE89]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Understanding asynchronous operations*, will show us how we
    can delegate the time-consuming email-sending process to an asynchronous thread
    and speed up our application experience.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方，*理解异步操作*，将向我们展示我们如何可以将耗时的电子邮件发送过程委托给异步线程，并加快我们的应用程序体验。
- en: Understanding asynchronous operations
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步操作
- en: Some of the operations in a web application can be time-consuming and make the
    overall application feel slow for the user, even though it’s not actually slow.
    This hampers the user experience significantly. To deal with this, the simplest
    way to implement the asynchronous execution of operations is with the help of
    threads. In this recipe, we will implement this using the `threading` libraries
    of Python. In Python 3, the `thread` package has been deprecated. Although it
    is still available as `_thread`, it is highly recommended to use `threading`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序中的某些操作可能很耗时，即使实际上并不慢，也会使用户的整体应用程序感觉缓慢。这会显著阻碍用户体验。为了处理这个问题，实现操作异步执行的最简单方法就是使用线程。在这个配方中，我们将使用Python的`threading`库来实现这一点。在Python
    3中，`thread`包已被弃用。尽管它仍然作为`_thread`可用，但强烈建议使用`threading`。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application from the *Implementing email support for Flask applications*
    recipe. Many of us will have noticed that, while the email is being sent, the
    application waits for the whole process to finish, which is unnecessary. Email
    sending can be easily done in the background, and our application can become available
    to the user instantaneously.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*实现Flask应用程序的电子邮件支持*配方中的应用程序。我们中的许多人都会注意到，当电子邮件正在发送时，应用程序会等待整个过程的完成，这是不必要的。电子邮件发送可以轻松地在后台完成，我们的应用程序可以立即对用户可用。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Doing an asynchronous execution with the `threading` package is very simple.
    Just add the following code to `my_app/catalog/views.py`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`threading`包进行异步执行非常简单。只需将以下代码添加到`my_app/catalog/views.py`中：
- en: '[PRE90]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the sending of an email happens in a new thread, which sends
    the message as a parameter to the newly created method. We need to create a new
    `send_mail()` method because our email templates contain `url_for`, which can
    only be executed inside an application context; this won’t be available in the
    newly created thread by default. It provides the flexibility of starting the thread
    whenever it’s needed instead of creating and starting the thread at the same time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，电子邮件的发送是在一个新的线程中进行的，该线程将消息作为参数传递给新创建的方法。我们需要创建一个新的`send_mail()`方法，因为我们的电子邮件模板包含`url_for`，它只能在应用程序上下文中执行；默认情况下，它在新创建的线程中不可用。这提供了灵活性，可以在需要时启动线程，而不是同时创建和启动线程。
- en: How it works…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It is pretty simple to observe how this works. Compare the performance of sending
    an email in this recipe with that of the application in the previous recipe, *Implementing
    email support for Flask applications*. You will notice that the application is
    more responsive. Another way can be to monitor the debug logs, where the newly
    created category page will load before the email is sent.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 观察它是如何工作的非常简单。比较在这个配方中发送电子邮件的性能与上一个配方中应用程序的性能，*实现Flask应用程序的电子邮件支持*。你会注意到应用程序的响应性更好。另一种方法是监控调试日志，其中新创建的分类页面将在发送电子邮件之前加载。
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Since I have mentioned multithreading and asynchronous operations, many of you
    must be thinking about Python’s built-in `asyncio` library and its potential here.
    Although it is possible to write Flask methods using `async..await` and they would
    work in a non-blocking fashion, there are no obvious performance gains as WSGI
    would still need to run in a single worker to handle a request. See [https://flask.palletsprojects.com/en/2.2.x/async-await/](https://flask.palletsprojects.com/en/2.2.x/async-await/)
    for more details.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我提到了多线程和异步操作，你们中的许多人可能正在思考Python内置的`asyncio`库及其潜在的应用。尽管可以使用`async..await`编写Flask方法，并且它们将以非阻塞的方式工作，但由于WSGI仍然需要在单个工作进程上运行以处理请求，因此并没有明显的性能提升。更多详情请见[https://flask.palletsprojects.com/en/2.2.x/async-await/](https://flask.palletsprojects.com/en/2.2.x/async-await/)。
- en: You can look at `asyncio` implementation of Flask or `asyncio` with a very similar
    syntax to Flask.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以查看Flask的`asyncio`实现或与Flask语法非常相似的`asyncio`。
- en: Working with Celery
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Celery一起工作
- en: Celery is a task queue for Python. There used to be an extension to integrate
    Flask and Celery but, with Celery 3.0, it became obsolete. Now, Celery can be
    directly used with Flask by just using a bit of configuration. In the *Understanding
    asynchronous operations* recipe, we implemented asynchronous processing to send
    an email. In this recipe, we will implement the same using Celery.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Celery是Python的任务队列。曾经有一个扩展用于集成Flask和Celery，但自从Celery 3.0以来，它已经过时。现在，只需进行一些配置，就可以直接使用Celery与Flask一起使用。在*理解异步操作*菜谱中，我们实现了异步处理来发送电子邮件。在这个菜谱中，我们将使用Celery实现相同的功能。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Celery can be installed simply from PyPI:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Celery可以从PyPI简单安装：
- en: '[PRE91]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: To make Celery work with Flask, we will need to modify our Flask app config
    file a bit. In order to do its job, Celery needs a broker to receive and deliver
    tasks. Here, we will use Redis as the broker (thanks to its simplicity).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Celery与Flask一起工作，我们需要修改我们的Flask应用程序配置文件。为了完成其工作，Celery需要一个代理来接收和交付任务。在这里，我们将使用Redis作为代理（感谢其简单性）。
- en: Information
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Make sure that you run the Redis server for the connection to happen. To install
    and run a Redis server, refer to [https://redis.io/docs/getting-started/](https://redis.io/docs/getting-started/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你运行Redis服务器以建立连接。要安装和运行Redis服务器，请参阅[https://redis.io/docs/getting-started/](https://redis.io/docs/getting-started/)。
- en: 'You would also need to install the Redis client in your virtual environment:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的虚拟环境中安装Redis客户端：
- en: '`$ pip` `install Redis`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ pip` `install Redis`'
- en: We will use the application from the previous recipe and implement Celery in
    the same manner.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中的应用程序，并以相同的方式实现Celery。
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to understand Celery’s integration with the Flask application:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解Celery与Flask应用程序的集成：
- en: 'First, we need to do a bit of configuration in the application’s configuration
    – that is, `my_app/__init__.py`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在应用程序的配置中进行一些配置——即`my_app/__init__.py`：
- en: '[PRE92]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The preceding snippet comes directly from the Flask website and can be used
    as is in your application in most cases. Here, we are essentially configuring
    a task in Celery to have the application context.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段直接来自Flask网站，在大多数情况下可以直接用于你的应用程序。在这里，我们实际上是在配置Celery任务以拥有应用程序上下文。
- en: 'To run the Celery process, execute the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行Celery进程，执行以下命令：
- en: '[PRE114]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, `-app` points to the `celery` object that is created in the configuration
    file, and `-l` is the log level that we want to observe.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-app`指向配置文件中创建的`celery`对象，而`-l`是我们想要观察的日志级别。
- en: Important
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Make sure that Redis is also running on the broker URL, as specified in the
    configuration.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Redis也在配置中指定的代理URL上运行。
- en: 'Now, use this `celery` object in the `my_app/catalog/views.py` file to send
    emails asynchronously:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`my_app/catalog/views.py`文件中使用这个`celery`对象来异步发送电子邮件：
- en: '[PRE115]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We add the `@celery.task` decorator to any method that we wish to use as a Celery
    task. The Celery process will detect these methods automatically.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`@celery.task`装饰器添加到任何我们希望用作Celery任务的方法上。Celery进程将自动检测这些方法。
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, when we create a category and an email is sent, we can see a task being
    run on the Celery process logs, which will look like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建一个类别并发送电子邮件时，我们可以在Celery进程日志中看到正在运行的任务，它看起来像这样：
- en: '[PRE137]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read the *Understanding asynchronous operations* recipe to see how threads can
    be used for various purposes – in our case, to send emails
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读理解异步操作*菜谱，了解线程如何用于各种目的——在我们的案例中，用于发送电子邮件
- en: You can read more about Celery at [http://docs.celeryproject.org/en/latest/index.html](http://docs.celeryproject.org/en/latest/index.html)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[http://docs.celeryproject.org/en/latest/index.html](http://docs.celeryproject.org/en/latest/index.html)了解更多关于Celery的信息。
