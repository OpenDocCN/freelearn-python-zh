- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Performance Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能模式
- en: In the previous chapter, we covered concurrency and asynchronous patterns, useful
    for writing efficient software that can handle multiple tasks at once. Next, we
    are going to discuss specific performance patterns that help enhance the speed
    and resource utilization of applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了并发和异步模式，这些模式对于编写能够同时处理多个任务的效率软件非常有用。接下来，我们将讨论一些特定的性能模式，这些模式有助于提高应用程序的速度和资源利用率。
- en: Performance patterns address common bottlenecks and optimization challenges,
    providing developers with proven methodologies to improve execution time, reduce
    memory usage, and scale effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 性能模式解决常见的瓶颈和优化挑战，为开发者提供经过验证的方法来提高执行时间、减少内存使用并有效扩展。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The Cache-Aside pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存旁路模式
- en: The Memoization pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存模式
- en: The Lazy Loading pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载模式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](B21896_01.xhtml#_idTextAnchor017)中提出的要求。本章讨论的代码的附加技术要求如下：
- en: 'Add the `Faker` module to your Python environment using the following command:
    `python -m pip` `install faker`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令将`Faker`模块添加到您的Python环境中：`python -m pip install faker`
- en: 'Add the `Redis` module to your Python environment using the following command:
    `python -m pip` `install redis`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令将`Redis`模块添加到您的Python环境中：`python -m pip install redis`
- en: 'Install the Redis server and run it using Docker: `docker run --name myredis
    -p` `6379:6379 redis`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker安装Redis服务器并运行它：`docker run --name myredis -p 6379:6379 redis`
- en: If needed, follow the documentation at [https://redis.io/docs/latest/](https://redis.io/docs/latest/)
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，请遵循[https://redis.io/docs/latest/](https://redis.io/docs/latest/)上的文档。
- en: The Cache-Aside pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存旁路模式
- en: In situations where data is more frequently read than updated, applications
    use a cache to optimize repeated access to information stored in a database or
    data store. In some systems, that type of caching mechanism is built in and works
    automatically. When this is not the case, we must implement it in the application
    ourselves, using a caching strategy that is suitable for the particular use case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据读取频率高于更新的情况下，应用程序使用缓存来优化对存储在数据库或数据存储中的信息的重复访问。在某些系统中，这种类型的缓存机制是内置的，并且可以自动工作。当这种情况不成立时，我们必须在应用程序中自行实现它，使用适合特定用例的缓存策略。
- en: One such strategy is called **Cache-Aside**, where, to improve performance,
    we store frequently accessed data in a cache, reducing the need to fetch data
    from the data store repeatedly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种策略被称为**缓存旁路**，在这种策略中，为了提高性能，我们将频繁访问的数据存储在缓存中，从而减少从数据存储中重复获取数据的需求。
- en: Real-world examples
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界案例
- en: 'We can cite the following examples in the software realm:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在软件领域引用以下示例：
- en: Memcached is commonly used as a cache server. It is a popular in-memory key-value
    store for small chunks of data from the results of database calls, API calls,
    or HTML page content.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcached通常用作缓存服务器。它是一个流行的内存键值存储，用于存储来自数据库调用、API调用或HTML页面内容的小块数据。
- en: Redis is another server solution that is used for cache. Nowadays, it is my
    go-to server for caching or application in-memory storage use cases where it shines.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis是另一种用于缓存的服务器解决方案。如今，它是我用于缓存或应用内存存储用例的首选服务器，在这些用例中，它表现出色。
- en: Amazon’s ElastiCache, according to the documentation site ([https://docs.aws.amazon.com/elasticache/](https://docs.aws.amazon.com/elasticache/)),
    is a web service that makes it easy to set up, manage, and scale a distributed
    in-memory data store or cache environment in the cloud.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据文档网站([https://docs.aws.amazon.com/elasticache/](https://docs.aws.amazon.com/elasticache/))的说明，亚马逊的ElastiCache是一种云服务，它使得在云中设置、管理和扩展分布式内存数据存储或缓存环境变得容易。
- en: Use cases for the cache-aside pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存旁路模式的使用案例
- en: The cache-aside pattern is useful when we need to reduce the database load in
    our application. By caching frequently accessed data, fewer queries are sent to
    the database. It also helps improve application responsiveness, since cached data
    can be retrieved faster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在我们的应用程序中减少数据库负载时，缓存旁路模式非常有用。通过缓存频繁访问的数据，可以减少发送到数据库的查询次数。它还有助于提高应用程序的响应速度，因为缓存数据可以更快地检索。
- en: Note that this pattern works for data that doesn’t change often and for data
    storage that doesn’t depend on the consistency of a set of entries in the storage
    (multiple keys). For example, it might work for certain kinds of document stores
    or databases where keys are never updated and occasionally data entries are deleted
    but there is no strong requirement to continue to serve them for some time (until
    the cache is refreshed).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种模式适用于不经常变化的数据，以及不依赖于存储中一组条目一致性的数据存储（多个键）。例如，它可能适用于某些类型的文档存储或数据库，其中键永远不会更新，偶尔会删除数据条目，但没有强烈的要求在一段时间内继续提供服务（直到缓存刷新）。
- en: Implementing the cache-aside pattern
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现缓存旁路模式。
- en: 'We can summarize the steps needed when implementing the Cache-Aside pattern,
    involving a database and a cache, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结实现 Cache-Aside 模式所需的步骤，涉及数据库和缓存，如下所示：
- en: '**Case 1 – When we want to fetch a data item**: Return the item from the cache
    if found in it. If not found in the cache, read the data from the database. Put
    the item we got in the cache and return it.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例 1 – 当我们想要获取数据项时**：如果缓存中找到该项，则从缓存中返回该项。如果没有在缓存中找到，则从数据库中读取数据。将我们得到的项目放入缓存并返回。'
- en: '**Case 2 – When we want to update a data item**: Write the item in the database
    and remove the corresponding entry from the cache.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例 2 – 当我们想要更新数据项时**：在数据库中写入该项，并从缓存中删除相应的条目。'
- en: Let’s try a simple implementation with a database of quotes from which the user
    can ask to retrieve some quotes via an application. Our focus here will be implementing
    the *Case* *1* part.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的实现，使用一个数据库，用户可以通过应用程序请求检索一些引语。我们在这里的重点是实现**案例 1**部分。
- en: 'Here are our choices for the additional software dependencies we need to install
    on the machine for this implementation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们为这个实现需要在机器上安装的额外软件依赖项的选择：
- en: An SQLite database, since we can query an SQLite database using Python’s standard
    module, `sqlite3`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 数据库，因为我们可以使用 Python 的标准模块 `sqlite3` 来查询 SQLite 数据库。
- en: A Redis server and the `redis-py` Python module
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 服务器和 `redis-py` Python 模块。
- en: We will use a script (in the `ch08/cache_aside/populate_db.py` file) to handle
    the creation of a database and a `quotes` table and add example data to it. For
    practical reasons, we also use the `Faker` module there to generate fake quotes
    that are used when populating the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个脚本（在 `ch08/cache_aside/populate_db.py` 文件中）来处理创建数据库和 `quotes` 表，并将示例数据添加到其中。出于实际考虑，我们也在那里使用
    `Faker` 模块生成假引语，这些引语用于填充数据库。
- en: 'Our code starts with the imports we need, followed by the creation of the Faker
    instance that we will use to generate fake quotes, as well as some constants or
    module-level variables:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从所需的导入开始，然后创建我们将用于生成假引语的 Faker 实例，以及一些常量或模块级变量：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we write a function to take care of the database setup part, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写一个函数来处理数据库设置部分，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we define a central function that takes care of adding a set of new quotes
    based on a list of sentences or text snippets. Among different things, we associate
    a quote identifier to the quote, for the `id` column in the database table. To
    make things easier, we just pick a number randomly using `quote_id = randint(1,
    100)`. The `add_quotes()` function is defined as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个中心函数，该函数负责根据句子列表或文本片段添加一组新的引语。在众多事情中，我们将引语标识符与引语关联，用于数据库表中的 `id` 列。为了简化问题，我们只是随机选择一个数字，使用
    `quote_id = randint(1, 100)`。`add_quotes()` 函数定义如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add a `main()` function, which in fact will have several parts; we
    want to use command-line argument parsing. Note the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个 `main()` 函数，实际上它将包含几个部分；我们想要使用命令行参数解析。请注意以下内容：
- en: If we pass the `init` argument, we call the `setup_db()` function
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递 `init` 参数，我们调用 `setup_db()` 函数。
- en: If we pass the `update_all` argument, we inject the quotes into the database
    and add them to the cache
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递 `update_all` 参数，我们将引语注入数据库并添加到缓存中。
- en: If we pass the `update_db_only` argument, we only inject the quotes into the
    database
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递 `update_db_only` 参数，我们只将引语注入数据库。
- en: 'The code of the `main()` function, called when running the Python script, is
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 Python 脚本时调用的 `main()` 函数的代码如下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That part is done. Now, we will create another module and script for the cache-aside-related
    operations themselves (in the `ch08/cache_aside/cache_aside.py` file).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那部分已经完成。现在，我们将创建另一个模块和脚本，用于缓存旁路相关的操作本身（在 `ch08/cache_aside/cache_aside.py` 文件中）。
- en: 'We have a few imports needed here too, followed by constants:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里也需要一些导入，然后是常量：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we define a `get_quote()` function to fetch a quote by its identifier.
    If we do not find the quote in the cache, we query the database to get it and
    we put the result in the cache before returning it. The function is defined as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个 `get_quote()` 函数，通过标识符获取引语。如果我们不在缓存中找到引语，我们将查询数据库以获取它，并在返回之前将其放入缓存。函数定义如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, in the main part of the script, we ask for user input of a quote identifier,
    and we call `get_quote()` to fetch the quote. The code is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在脚本的主体部分，我们要求用户输入一个引语标识符，并调用 `get_quote()` 来获取引语。代码如下：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now is the time to test our scripts, using the following steps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试我们脚本的时机，请按照以下步骤进行。
- en: First, by calling `python ch08/cache_aside/populate_db.py`, and choosing `"init"`
    for the mode option, we can see that a `quotes.sqlite3` file is created (in the
    `ch08/cache_aside/` folder), so we can conclude the database has been created
    and a `quotes` table created in it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过调用 `python ch08/cache_aside/populate_db.py` 并选择 `"init"` 作为模式选项，我们可以看到在
    `ch08/cache_aside/` 文件夹中创建了一个 `quotes.sqlite3` 文件，因此我们可以得出结论，数据库已经创建，并在其中创建了一个
    `quotes` 表。
- en: 'Then, we call `python ch08/cache_aside/populate_db.py` and pass the `update_all`
    mode; we get the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `python ch08/cache_aside/populate_db.py` 并传递 `update_all` 模式；我们得到以下输出：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Choose your mode! Enter ''init'' or ''update_db_only'' or ''update_all'': update_db_only'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的模式！输入 'init' 或 'update_db_only' 或 'update_all'：update_db_only
- en: 'New (fake) quotes added to the database ONLY:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仅向数据库中添加了新的（虚假的）引语：
- en: 'Added to DB: (73, ''Whose determine group what site.'')'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（73，'Whose determine group what site.'）
- en: 'Added to DB: (77, ''Standard much career either will when chance.'')'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（77，'Standard much career either will when chance.'）
- en: 'Added to DB: (5, ''Nature when event appear yeah.'')'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（5，'Nature when event appear yeah.'）
- en: 'Added to DB: (81, ''By himself in treat.'')'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（81，'By himself in treat.'）
- en: 'Added to DB: (88, ''Establish deal sometimes stage college everybody close
    thank.'')'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（88，'Establish deal sometimes stage college everybody close thank.'）
- en: 'Added to DB: (99, ''Room recently authority station relationship our knowledge
    occur.'')'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（99，'Room recently authority station relationship our knowledge occur.'）
- en: 'Added to DB: (63, ''Price who a crime garden doctor eat.'')'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（63，'Price who a crime garden doctor eat.'）
- en: 'Added to DB: (43, ''Significant hot those think heart shake ago.'')'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（43，'Significant hot those think heart shake ago.'）
- en: 'Added to DB: (80, ''Understand and view happy.'')'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到数据库中：（80，'Understand and view happy.'）
- en: 'python ch08/cache_aside/cache_aside.py command, and we are asked for an input
    to try to fetch the matching quote. Here are the different outputs I got depending
    on the values I provided:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`python ch08/cache_aside/cache_aside.py` 命令，然后我们被要求输入一个尝试获取匹配引语的输入。以下是我根据提供的值得到的不同输出：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, each time I entered an identifier number that matched a quote stored only
    in the database (as shown by the previous output), the specific output showed
    that the data was obtained from the database first, before being returned from
    the cache (where it was immediately added).
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，每次我输入一个与仅存储在数据库中的引语匹配的标识符（如前一个输出所示），具体的输出都显示数据首先从数据库中获取，然后从缓存（它立即被添加到其中）返回。
- en: We can see that things work as expected. The update part of the cache-aside
    implementation (to write the item in the database and remove the corresponding
    entry from the cache) is left to you to try. You could add an `update_quote()`
    function used to update a quote when you pass `quote_id` to it and call it using
    the right command line (such as `python` `cache_aside.py update`).
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到一切按预期工作。缓存 aside 实现的更新部分（在数据库中写入条目并从缓存中删除相应的条目）留给你去尝试。你可以添加一个 `update_quote()`
    函数，用于在传递 `quote_id` 给它时更新一个引语，并使用正确的命令行（例如 `python` `cache_aside.py update`）来调用它。
- en: The Memoization pattern
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记忆化模式
- en: The **Memoization** pattern is a crucial optimization technique in software
    development that improves the efficiency of programs by caching the results of
    expensive function calls. This approach ensures that if a function is called with
    the same inputs more than once, the cached result is returned, eliminating the
    need for repetitive and costly computations.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**记忆化** 模式是软件开发中一个关键的优化技术，通过缓存昂贵函数调用的结果来提高程序的效率。这种方法确保了如果函数多次使用相同的输入被调用，则返回缓存的值，从而消除了重复和昂贵的计算需求。'
- en: Real-world examples
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: We can think of calculating Fibonacci numbers as a classic example of the memoization
    pattern. By storing previously computed values of the sequence, the algorithm
    avoids recalculating them, which drastically speeds up the computation of higher
    numbers in the sequence.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将计算斐波那契数列视为记忆化模式的经典示例。通过存储序列之前计算过的值，算法避免了重新计算，这极大地加快了序列中更高数值的计算速度。
- en: Another example is a text search algorithm. In applications dealing with large
    volumes of text, such as search engines or document analysis tools, caching the
    results of previous searches means that identical queries can return instant results,
    significantly improving user experience.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个例子是文本搜索算法。在处理大量文本的应用中，如搜索引擎或文档分析工具，缓存先前搜索的结果意味着相同的查询可以立即返回结果，这显著提高了用户体验。
- en: Use cases for the memoization pattern
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记忆化模式的用例
- en: 'The memoization pattern can be useful for the following use cases:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记忆化模式可以用于以下用例：
- en: '**Speeding up recursive algorithms**: Memoization transforms recursive algorithms
    from having a high time complexity. This is particularly beneficial for algorithms
    such as those calculating Fibonacci numbers.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加速递归算法**：记忆化将递归算法从具有高时间复杂度转变为低时间复杂度。这对于计算斐波那契数等算法特别有益。'
- en: '**Reducing computational overhead**: Memoization conserves CPU resources by
    avoiding unnecessary recalculations. This is crucial in resource-constrained environments
    or when dealing with high-volume data processing.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**减少计算开销**：记忆化通过避免不必要的重新计算来节省 CPU 资源。这在资源受限的环境或处理大量数据处理时至关重要。'
- en: '**Improving application performance**: The direct result of memoization is
    a noticeable improvement in application performance, making applications feel
    more responsive and efficient from the user’s perspective.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提高应用性能**：记忆化的直接结果是应用性能的显著提升，使用户感觉应用响应更快、更高效。'
- en: Implementing the memoization pattern
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现记忆化模式
- en: Let’s discuss an implementation of the memoization pattern using Python’s `functools.lru_cache`
    decorator. This tool is particularly effective for functions with expensive computations
    that are called repeatedly with the same arguments. By caching the results, subsequent
    calls with the same arguments retrieve the result from the cache, significantly
    reducing execution time.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们讨论使用 Python 的 `functools.lru_cache` 装饰器实现记忆化模式的示例。这个工具对于具有昂贵计算且重复使用相同参数调用的函数特别有效。通过缓存结果，具有相同参数的后续调用将直接从缓存中检索结果，显著减少执行时间。
- en: 'For our example, we will apply memoization to a classic problem where a recursive
    algorithm is used: calculating Fibonacci numbers.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将记忆化应用于一个经典问题，其中使用了递归算法：计算斐波那契数。
- en: 'We start with the `import` statements we need:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先需要以下 `import` 语句：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Second, we create a `fibonacci_func1` function that does the Fibonacci numbers
    computation using recursion (without any caching involved). We will use this for
    comparison:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二，我们创建了一个名为 `fibonacci_func1` 的函数，该函数使用递归（不涉及任何缓存）来计算斐波那契数。我们将用它来进行比较：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Third, we define a `fibonacci_func2` function, with the same code, but this
    one is decorated with `lru_cache`, to enable memoization. What happens here is
    that the results of the function calls are stored in a cache in memory, and repeated
    calls with the same arguments fetch results directly from the cache rather than
    executing the function’s code. The code is as follows:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三，我们定义了一个名为 `fibonacci_func2` 的函数，代码与之前相同，但这次我们使用了 `lru_cache` 装饰器来启用记忆化。这里发生的情况是，函数调用的结果被存储在内存中的缓存中，具有相同参数的重复调用将直接从缓存中获取结果，而不是执行函数的代码。代码如下：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we create a `main()` function to test calling both functions using
    `n=30` as input and measuring the time spent for each execution. The testing code
    is as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `main()` 函数来测试使用 `n=30` 作为输入调用两个函数，并测量每个执行的耗时。测试代码如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To test the implementation, run the following command: `python ch08/memoization.py`.
    You should get an output like the following one:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试实现，请运行以下命令：`python ch08/memoization.py`。你应该得到以下输出：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, the durations you get would probably be different than mine, but
    the duration for the second function, the one using caching, should be less than
    the one for the function without caching. Also, the difference between both durations
    should be important.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你得到的时间可能与我不同，但使用缓存功能的第二个函数的时间应该短于没有缓存的函数的时间。而且，两者之间的时间差应该是重要的。
- en: This was a demonstration that memoization reduces the number of recursive calls
    needed to calculate Fibonacci numbers, especially for large `n` values. By reducing
    the computational overhead, memoization not only speeds up calculations but also
    conserves system resources, leading to a more efficient and responsive application.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个演示，说明记忆化减少了计算斐波那契数所需的递归调用次数，尤其是对于大的`n`值。通过减少计算开销，记忆化不仅加快了计算速度，还节省了系统资源，从而使得应用程序更加高效和响应。
- en: The Lazy Loading pattern
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 懒加载模式
- en: The **Lazy Loading** pattern is a critical design approach in software engineering,
    particularly useful in optimizing performance and resource management. The idea
    with lazy loading is to defer the initialization or loading of resources to the
    moment they are really needed. This way, applications can achieve more efficient
    resource utilization, reduce initial load times, and enhance the overall user
    experience.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**懒加载**模式是软件工程中的一个关键设计方法，尤其在优化性能和资源管理方面特别有用。懒加载的理念是在资源真正需要时才延迟初始化或加载资源。这样，应用程序可以实现更有效的资源利用，减少初始加载时间，并提升整体用户体验。'
- en: Real-world examples
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: Browsing an online art gallery provides a first example. Instead of waiting
    for hundreds of high-resolution images to load upfront, the website loads only
    images currently in view. As you scroll, additional images load seamlessly, enhancing
    your browsing experience without overwhelming your device’s memory or network
    bandwidth.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览在线艺术画廊提供了一个例子。网站不会一开始就加载数百张高分辨率图片，而是只加载当前视图中的图片。当你滚动时，额外的图片会无缝加载，从而提升你的浏览体验，而不会耗尽设备的内存或网络带宽。
- en: Another example is an on-demand video streaming service, such as Netflix or
    YouTube. Such a platform offers an uninterrupted viewing experience by loading
    videos in chunks. This approach not only minimizes buffering times at the start
    but also adapts to changing network conditions, ensuring consistent video quality
    with minimal interruptions.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个例子是按需视频流媒体服务，如Netflix或YouTube。这样的平台通过分块加载视频提供不间断的观看体验。这种方法不仅最小化了开始时的缓冲时间，还能适应不断变化的网络条件，确保视频质量一致，中断最少。
- en: In applications such as Microsoft Excel or Google Sheets, working with large
    datasets can be resource-intensive. Lazy loading allows these applications to
    load only data relevant to your current view or operation, such as a particular
    sheet or a range of cells. This significantly speeds up operations and reduces
    memory usage.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在像Microsoft Excel或Google Sheets这样的应用程序中，处理大量数据集可能非常耗费资源。懒加载允许这些应用程序仅加载与当前视图或操作相关的数据，例如特定的工作表或单元格范围。这显著加快了操作速度并减少了内存使用。
- en: Use cases for the lazy loading pattern
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 懒加载模式的用例
- en: 'We can think of the following performance-related use cases for the lazy loading
    pattern:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将以下与性能相关的用例视为懒加载模式：
- en: '**Reducing initial load time**: This is particularly beneficial in web development,
    where a shorter load time can translate into improved user engagement and retention
    rates.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**减少初始加载时间**：这在网页开发中尤其有益，较短的加载时间可以转化为更高的用户参与度和留存率。'
- en: '**Conserving system resources**: In an era of diverse devices, from high-end
    desktops to entry-level smartphones, optimizing resource usage is crucial for
    delivering a uniform user experience across all platforms.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保护系统资源**：在多样化的设备时代，从高端台式机到入门级智能手机，优化资源使用对于在所有平台上提供一致的用户体验至关重要。'
- en: '**Enhancing user experience**: Users expect fast, responsive interactions with
    software. Lazy loading contributes to this by minimizing waiting times and making
    applications feel more responsive.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提升用户体验**：用户期望与软件进行快速、响应式的交互。懒加载通过最小化等待时间并使应用程序感觉更加响应来对此做出贡献。'
- en: Implementing the lazy loading pattern – lazy attribute loading
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现懒加载模式 – 懒属性加载
- en: Consider an application that performs complex data analysis or generates sophisticated
    visualizations based on user input. The computation behind this is resource-intensive
    and time-consuming. Implementing lazy loading, in this case, can drastically improve
    performance. But for demonstration purposes, we will be less ambitious than the
    complex data analysis application scenario. We will use a function that simulates
    an expensive computation and returns a value used for an attribute on a class.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑一个执行复杂数据分析或基于用户输入生成复杂可视化的应用程序。背后的计算是资源密集型和耗时的。在这种情况下实现懒加载可以显著提高性能。但为了演示目的，我们将不会像复杂的数据分析应用场景那样雄心勃勃。我们将使用一个模拟昂贵计算并返回用于类属性值的函数。
- en: For this lazy loading example, the idea is to have a class that initializes
    an attribute only when it’s accessed for the first time. This approach is commonly
    used in scenarios where initializing an attribute is resource-intensive, and you
    want to postpone this process until it’s necessary.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '对于这个懒加载示例，我们的想法是只有当属性第一次被访问时才初始化属性。这种方法在初始化属性是资源密集型，并且你希望推迟这个过程直到必要时常用的场景中。 '
- en: 'We start with the initialization part of the `LazyLoadedData` class, where
    we set the `_data` attribute to `None`. Here, the expensive data hasn’t been loaded
    yet:'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从`LazyLoadedData`类的初始化部分开始，将`_data`属性设置为`None`。在这里，昂贵的资源尚未被加载：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We add a `data()` method, decorated with `@property`, making it act like an
    attribute (a property) with the added logic for lazy loading. Here, we check if
    `_data` is `None`. If it is, we call the `load_data()` method:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个`data()`方法，使用`@property`装饰器，使其像属性（一个属性）一样工作，并添加了懒加载的逻辑。在这里，我们检查`_data`是否为`None`。如果是，我们调用`load_data()`方法：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We add the `load_data()` method simulating an expensive operation, using `sum(i
    * i for i in range(100000))`. In a real-world scenario, this could involve fetching
    data from a remote database, performing a complex calculation, or other resource-intensive
    tasks:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了一个`load_data()`方法，模拟一个昂贵的操作，使用`sum(i * i for i in range(100000))`。在现实世界的场景中，这可能涉及从远程数据库获取数据，执行复杂的计算或其他资源密集型任务：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then add a `main()` function to test the implementation. We create an instance
    of the `LazyLoadedData` class and access the `_data` attribute twice:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们添加一个`main()`函数来测试实现。我们创建`LazyLoadedData`类的一个实例，并两次访问`_data`属性：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test the implementation, run the `python ch08/lazy_loading/lazy_attribute_loading.py`
    command. You should get the following output:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试实现，运行`python ch08/lazy_loading/lazy_attribute_loading.py`命令。你应该得到以下输出：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: import time
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: from datetime import timedelta
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: from datetime import timedelta
- en: from functools import lru_cache
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: from functools import lru_cache
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'def recursive_factorial(n):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'def recursive_factorial(n):'
- en: '"""Calculate factorial (expensive for large n)"""'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算阶乘（对于大的n来说很昂贵）"""'
- en: 'if n == 1:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n == 1:'
- en: return 1
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: return 1
- en: 'else:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return n * recursive_factorial(n - 1)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: return n * recursive_factorial(n - 1)
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '@lru_cache(maxsize=128)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '@lru_cache(maxsize=128)'
- en: 'def cached_factorial(n):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cached_factorial(n):'
- en: return recursive_factorial(n)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: return recursive_factorial(n)
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'def main():'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# Testing the performance'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '# 测试性能'
- en: n = 20
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: n = 20
- en: '# Without caching'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# Without caching'
- en: start_time = time.time()
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: 'print(f"Recursive factorial of {n}: {recursive_factorial(n)}")'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"{ n }的递归阶乘：{ recursive_factorial(n) }")
- en: duration = timedelta(time.time() - start_time)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: duration = timedelta(time.time() - start_time)
- en: 'print(f"Calculation time without caching: {duration}.")'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"无缓存的计算时间：{ duration }。")
- en: '# With caching'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '# With caching'
- en: start_time = time.time()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: 'print(f"Cached factorial of {n}: {cached_factorial(n)}")'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"缓存的{ n }的阶乘：{ cached_factorial(n) }")
- en: duration = timedelta(time.time() - start_time)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: duration = timedelta(time.time() - start_time)
- en: 'print(f"Calculation time with caching: {duration}.")'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"带缓存的计算时间：{ duration }。")
- en: start_time = time.time()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: 'print(f"Cached factorial of {n}, repeated: {cached_factorial(n)}")'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"缓存的{ n }的阶乘，重复：{ cached_factorial(n) }")
- en: duration = timedelta(time.time() - start_time)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: duration = timedelta(time.time() - start_time)
- en: 'print(f"Second calculation time with caching: {duration}.")'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"带缓存的第二次计算时间：{ duration }。")
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Recursive factorial of 20: 2432902008176640000'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 递归阶乘的20：2432902008176640000
- en: 'Calculation time without caching: 0:00:04.840851'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓存的计算时间：0:00:04.840851
- en: 'Cached factorial of 20: 2432902008176640000'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的20的阶乘：2432902008176640000
- en: 'Calculation time with caching: 0:00:00.865173'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 带缓存的计算时间：0:00:00.865173
- en: 'Cached factorial of 20, repeated: 2432902008176640000'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的20的阶乘，重复：2432902008176640000
- en: 'Second calculation time with caching: 0:00:00.350189'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 带缓存的第二次计算时间：0:00:00.350189
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
