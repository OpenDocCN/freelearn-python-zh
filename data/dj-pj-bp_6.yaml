- en: Chapter 6. Daintree – an E-commerce Site
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。戴恩特里 - 电子商务网站
- en: We have created some solid web applications in the previous chapters. They were
    simple, but had enough functionality to be used in real-world projects. With some
    frontend work, our applications could very well be deployed on the Internet and
    solve real problems. Now it's time to look at something more complicated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们创建了一些稳健的网络应用。它们很简单，但具有足够的功能，可以在真实项目中使用。通过一些前端工作，我们的应用很可能可以部署在互联网上，并解决真实问题。现在是时候看一些更复杂的东西了。
- en: I'm sure you have used, or at least heard of, some of the big names in the e-commerce
    space—names such as Amazon and Ali Baba. While these sites are very complicated
    beasts, a basic e-commerce site is pretty simple under the hood. E-commerce sites
    are also something that a lot of clients want created, so having some knowledge
    of how to make a good one will be very useful in your career.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经使用过，或者至少听说过，电子商务领域的一些大名鼎鼎的公司，比如亚马逊和阿里巴巴。虽然这些网站非常复杂，但在内部，一个基本的电子商务网站是相当简单的。电子商务网站也是许多客户想要创建的东西，因此了解如何制作一个好的电子商务网站对你的职业生涯将非常有用。
- en: 'A basic e-commerce site has one main purpose: to help users find and buy products
    from the online store. Django alone can be used to build an e-commerce site quickly,
    using database queries to allow searches across product range, but this doesn''t
    scale well. Databases are designed to quickly save and retrieve rows of data,
    but they are not optimized to search across the entire dataset (or a subset).
    Once the traffic of your site starts to increase, you''ll see the search speed
    go down very quickly. On top of that, there are some features that are very difficult
    to build with a database.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的电子商务网站有一个主要目的：帮助用户从在线商店找到并购买产品。Django可以单独用于快速构建电子商务网站，使用数据库查询来允许跨产品范围进行搜索，但这并不适合扩展。数据库被设计为快速保存和检索数据行，但它们并不是为了跨整个数据集（或子集）进行搜索而进行优化的。一旦您的网站流量开始增加，您会发现搜索速度会迅速下降。除此之外，还有一些很难用数据库构建的功能。
- en: Instead, we will use a **search server**. A search server is very much like
    a database. You give it some data to store and then you can retrieve it later.
    It also has features specifically built to help you add searching to your applications.
    You might wonder that if a search server can store our data like a database, then
    can we not just get rid of the database? We can, but usually it's not recommended.
    Why? Well, because the search server is designed for a different use case. While
    it can store your data, a database provides a lot of guarantees about the storage
    that a search server usually doesn't. For example, a good database (such as MySQL
    or PostgreSQL) gives you a guarantee that if you try to save something and the
    database returns a successful response, your data will not be lost in case of
    a crash or power outage or some other problem. This is called durability. A search
    server does not provide this guarantee because that's not what they are designed
    for. It is usually a good idea to keep our data in a database and use the search
    server just to search across our data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用**搜索服务器**。搜索服务器非常类似于数据库。您可以给它一些数据来存储，然后以后可以检索它。它还具有专门为帮助您向应用程序添加搜索而构建的功能。您可能会想，如果搜索服务器可以像数据库一样存储我们的数据，那么我们不是可以摆脱数据库吗？我们可以，但通常不建议这样做。为什么？因为搜索服务器是为不同的用例而设计的。虽然它可以存储您的数据，但数据库提供了许多关于存储的保证，搜索服务器通常不提供。例如，一个好的数据库（如MySQL或PostgreSQL）会保证，如果您尝试保存某些内容并且数据库返回成功的响应，那么在发生崩溃、停电或其他问题时，您的数据不会丢失。这被称为耐久性。搜索服务器不提供此保证，因为这不是它们的设计目的。通常最好将我们的数据保存在数据库中，并使用搜索服务器来搜索我们的数据。
- en: For the application that we will develop in this chapter, we will be using **Elasticsearch**,
    one of the most popular and perhaps easy-to-use search servers available. It's
    also open source and available for free. So let's get started. This is going to
    be an exciting chapter!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Elasticsearch**，这是最受欢迎、可能也是最易于使用的搜索服务器之一。它也是开源的，可以免费使用。所以让我们开始吧。这将是一个令人兴奋的章节！
- en: Code pack
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码包
- en: The code pack for this chapter contains a basic web application that has the
    models and views for a simple e-commerce site. Right now there is no search, just
    a page that lists all the available products. I have also provided a data dump
    that contains about 1,000 products so that our database has some data that we
    can play around with. As always, download the code pack, create a new virtual
    environment, install Django, run the migrate command, and then issue the `run
    server` command to start the development server. You should have the hang of how
    to do these things without any guidance by now.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包含了一个基本的网络应用程序，其中包含了一个简单电子商务网站的模型和视图。现在还没有搜索，只有一个列出所有可用产品的页面。我还提供了一个数据转储，其中包含大约1,000个产品，这样我们的数据库就有一些可以玩耍的数据。与往常一样，下载代码包，创建一个新的虚拟环境，安装Django，运行迁移命令，然后发出`run
    server`命令来启动开发服务器。你现在应该已经掌握了如何在没有任何指导的情况下做这些事情。
- en: 'To load the test data, run the following command after the migrate command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载测试数据，请在迁移命令之后运行以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should fill your database with a thousand sample products and give us enough
    data to play around with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会用一千个样品产品填满你的数据库，并为我们提供足够的数据来玩耍。
- en: Exploring Elasticsearch
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Elasticsearch
- en: Before we get into integrating Elasticsearch with our Django application, let's
    take some time and explore Elasticsearch. We'll look into how to get data into
    it and use the search features to get back the results we want. We won't go into
    a lot of details about the search as we'll look into it later when we are building
    the search page for our applications, but we will get a basic overview of how
    Elasticsearch works and how it can be useful for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Elasticsearch与Django应用程序集成之前，让我们花点时间来探索Elasticsearch。我们将研究如何将数据导入其中，并使用搜索功能来获取我们想要的结果。我们不会详细讨论搜索，因为我们将在构建应用程序的搜索页面时再进行研究，但我们将对Elasticsearch的工作原理和它对我们有用的地方进行基本概述。
- en: 'To start, download the latest version of Elasticsearch from [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch).
    You will need to have Java installed on your system to run Elasticsearch, so go
    ahead and install that as well if you don''t already have it. You can get Java
    from [https://java.com/en/download/](https://java.com/en/download/). Once you
    have downloaded Elasticsearch, extract the files from the compressed archive into
    a folder, open a new terminal session, and `cd` to this folder. Next, `cd` into
    the `bin` folder and run the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从[https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch)下载最新版本的Elasticsearch。你需要在系统上安装Java才能运行Elasticsearch，所以如果你还没有安装，就去安装吧。你可以从[https://java.com/en/download/](https://java.com/en/download/)获取Java。下载完Elasticsearch后，将压缩存档中的文件提取到一个文件夹中，打开一个新的终端会话，并`cd`到这个文件夹。接下来，`cd`进入`bin`文件夹，并运行以下命令：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running the Elasticsearch binary should produce a lot of output, and it will
    be different from what I've pasted here. However, you should still see the two
    messages **started** and **recovered [0] indices into cluster_state** at the end
    of the output. This means that Elasticsearch is now running on your system. That
    wasn't so hard! Of course, running Elasticsearch in production is a bit different,
    and the Elasticsearch documentation provides a lot of information about how to
    deploy it for a couple of different use cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Elasticsearch二进制文件应该会产生大量的输出，它会与我粘贴的内容不同。然而，你应该仍然能看到输出的最后出现两条消息**started**和**recovered
    [0] indices into cluster_state**。这意味着Elasticsearch现在正在你的系统上运行。这并不难！当然，在生产环境中运行Elasticsearch会有些不同，Elasticsearch文档提供了大量关于如何为几种不同的用例部署它的信息。
- en: We only cover the basics of Elasticsearch in this chapter as our focus is on
    looking at the integration between Django and Elasticsearch, but if you ever find
    yourself stuck somewhere or need some questions answered, do take a look at the
    documentation—it really is quite extensive and thorough. You can find it at [https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html).
    There is also a book style guide available at [https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html)
    if you want to really spend time learning Elasticsearch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只涵盖了Elasticsearch的基础知识，因为我们的重点是查看Django和Elasticsearch之间的集成，但如果你发现自己陷入困境或需要解答一些问题，可以查看文档——它真的非常广泛和详尽。你可以在[https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)找到它。如果你真的想花时间学习Elasticsearch，还有一本书式指南可供参考，地址是[https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html)。
- en: First steps with Elasticsearch
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elasticsearch的第一步
- en: Now that we have Elasticsearch running, what can we do with it? Well, for starters,
    you need to know that Elasticsearch exposes its functionality over a simple HTTP
    API. So you don't need any special libraries to communicate with it. Most programming
    languages, including Python, include the means to make HTTP requests. However,
    there are a couple of libraries that provide another layer of abstraction over
    HTTP and make working with Elasticsearch easier. We'll get into those later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经运行了Elasticsearch，我们可以用它做些什么呢？首先，你需要知道Elasticsearch通过一个简单的HTTP API公开其功能。因此，你不需要任何特殊的库来与其通信。大多数编程语言，包括Python，都包含了进行HTTP请求的手段。然而，有一些库提供了另一层对HTTP的抽象，并使得与Elasticsearch的工作更加容易。我们稍后会详细介绍这些。
- en: 'For now, let''s open up this URL in our browsers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在浏览器中打开这个URL：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should give you an output similar to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你一个类似于这样的输出：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While most of the values will be different, the structure of the response should
    roughly be the same. This simple test lets us know that Elasticsearch is working
    properly on our system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大部分值都会不同，但响应的结构应该大致相同。这个简单的测试让我们知道Elasticsearch在我们的系统上正常工作。
- en: Now we'll do a quick walkthrough where we insert, retrieve, and search for a
    couple of products. I won't go into a lot of details, but if you are interested,
    you should look at the documentation of Elasticsearch that I mentioned before.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速浏览一下，我们将插入、检索和搜索一些产品。我不会详细介绍，但如果你感兴趣，你应该查看我之前提到的Elasticsearch文档。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to have a working copy of the curl command-line utility installed
    on your machine to perform the steps in this section. It should be available by
    default on Linux and Unix platforms, including Mac OS X. If you're on Windows,
    you can get a copy from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你需要在你的机器上安装一个工作的curl命令行实用程序的副本才能执行这些步骤。它应该默认在Linux和Unix平台上，包括Mac OS X上可用。如果你在Windows上，你可以从[https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)获取一个副本。
- en: 'Open a new terminal window as our current one has Elasticsearch running in
    it. Next, type in the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，因为我们当前的窗口中已经运行了Elasticsearch。接下来，输入以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of the Elasticsearch APIs accept JSON objects. Here, we are asking Elasticsearch
    to PUT two documents, ids 1 and 2, in its storage. It may look complicated, but
    let me explain what's happening here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Elasticsearch API接受JSON对象。在这里，我们要求Elasticsearch将两个文档，id为1和2，放入其存储中。这可能看起来很复杂，但让我解释一下这里发生了什么。
- en: In a database server, you have databases, tables, and rows. Your database is
    like a namespace where all of your tables live. Tables define the overall shape
    of the data that you want to store, and each row is one unit of that data. Elasticsearch
    has a slightly different way of working with data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库服务器中，你有数据库、表和行。你的数据库就像一个命名空间，所有的表都驻留在其中。表定义了你想要存储的数据的整体形状，每一行都是这些数据的一个单元。Elasticsearch有一种稍微不同的处理数据的方式。
- en: In place of a database, Elasticsearch has an index. Tables are called document
    types and live inside of indexes. Finally, the rows, or documents as Elasticsearch
    calls them, are stored inside of the document type. In our preceding example,
    we told Elasticsearch to `PUT` a document with Id **1** in the **products** document
    type, which lives in the **daintree** index. One thing that we didn't do here
    is define the document structure. That's because Elasticsearch doesn't require
    a set structure. It will dynamically update the structure of its tables (the document
    types) as you insert new documents.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库的位置，Elasticsearch有一个索引。表被称为文档类型，并且存在于索引内。最后，行，或者正如Elasticsearch所称的那样，文档存储在文档类型内。在我们之前的例子中，我们告诉Elasticsearch在**daintree**索引中的**products**文档类型中`PUT`一个Id为**1**的文档。我们在这里没有做的一件事是定义文档结构。这是因为Elasticsearch不需要固定的结构。它会动态更新表的结构（文档类型），当你插入新的文档时。
- en: 'Let''s try retrieving the first document that we inserted. Run this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试检索我们插入的第一个文档。运行这个命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can probably guess, the API for Elasticsearch is very simple and intuitive.
    We used a `PUT` HTTP request when we wanted to insert a document. When we want
    to retrieve one, we use the `GET` HTTP request type and we give the same path
    that we used when inserting the document. We get back a bit more information than
    we inserted. Our document is in the `_source` field and the rest of the fields
    are metadata that Elasticsearch stores with each document.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，Elasticsearch的API非常简单和直观。当我们想要插入一个文档时，我们使用`PUT` HTTP请求。当我们想要检索一个文档时，我们使用`GET`
    HTTP请求类型，并且我们给出了与插入文档时相同的路径。我们得到的信息比我们插入的要多一些。我们的文档在`_source`字段中，其余字段是Elasticsearch与每个文档存储的元数据。
- en: 'Now we look at the star of the show—searching! Let''s see how to do a simple
    search for books with the word Django in their title. Run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看搜索的主角——搜索！让我们看看如何对标题中包含Django的书进行简单搜索。运行以下命令：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is what you would have expected for this search. Elasticsearch only
    returned the one document that had the term Django in its name and skipped the
    other one. This is called the lite search or query-string search as our query
    is sent as part of the query string parameters. However, this method quickly gets
    difficult to use for complicated queries having multiple parameters. For those
    queries, Elasticsearch provides a full query DSL, which uses JSON to specify the
    query. Let''s take a look how we could do this same search using the query DSL:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你对这次搜索的预期。Elasticsearch只返回了一个包含Django一词的文档，并跳过了其他的。这被称为lite搜索或查询字符串搜索，因为我们的查询作为查询字符串参数的一部分发送。然而，对于具有多个参数的复杂查询，这种方法很快变得难以使用。对于这些查询，Elasticsearch提供了完整的查询DSL，它使用JSON来指定查询。让我们看看如何使用查询DSL进行相同的搜索：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, instead of passing a query parameter, we send a body with the GET
    request. The body is the JSON query that we wish to execute. I won't be explaining
    the query DSL because it has a lot of features and is quite powerful and it would
    take another book to explain it properly. In fact, a couple of books have been
    written that explain the DSL fully. However, for simple usages like this, you
    can guess easily what's happening. If you want further details, I will again suggest
    taking a look at the Elasticsearch documentation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们不再传递查询参数，而是发送一个带有GET请求的主体。主体是我们希望执行的JSON查询。我不会解释查询DSL，因为它有很多功能，非常强大，需要另一本书来正确解释它。事实上，已经有几本书完全解释了DSL。然而，对于像这样的简单用法，你可以很容易地猜到发生了什么。如果你想了解更多细节，我再次建议查看Elasticsearch文档。
- en: Searching from Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python中搜索
- en: 'Now that we have a basic understanding of how we can use Elasticsearch to insert
    and search on our documents, let''s see how to do the same from Python. We could
    use the HTTP API of Elasticsearch from Python and query for the documents but
    there is a better way. There are a number of libraries that provide an abstraction
    over the HTTP API for Elasticsearch. Underneath, they are simply using the HTTP
    API, but the abstractions that they provide make it easier for us to communicate
    with Elasticsearch. The library that we will be using here is `elasticsearch_dsl`.
    Make sure that your virtual environment is activated, and install it using `pip`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何使用Elasticsearch来插入和搜索我们的文档，让我们看看如何从Python中做同样的事情。我们可以使用Python中的Elasticsearch的HTTP
    API并查询文档，但有更好的方法。有许多库提供了对Elasticsearch的HTTP API的抽象。在底层，它们只是简单地使用HTTP API，但它们提供的抽象使我们更容易与Elasticsearch通信。我们将在这里使用的库是`elasticsearch_dsl`。确保你的虚拟环境已激活，并使用`pip`安装它：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s start a Django shell so that we can play around and figure out
    how to use it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们启动一个Django shell，这样我们就可以玩耍并弄清楚如何使用它：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's take a look at each line. The first two lines simply import the library.
    The third line is important. It uses the `create_connection` method to define
    a default connection. This is the connection that will be used whenever we try
    to do a search using this library with the default settings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每一行。前两行只是导入库。第三行很重要。它使用`create_connection`方法来定义一个默认连接。这是每当我们尝试使用这个库进行搜索时使用的连接，使用默认设置。
- en: Next, we perform the search and print out the results. This is the important
    bit. This one line of code does a couple of things, so let's break it down. First,
    we construct a `Search` object, passing in the index name for the `daintree` index
    that we created earlier. As we don't pass in a custom Elasticsearch connection,
    it uses the default connection that we defined earlier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行搜索并打印结果。这是重要的部分。这一行代码做了几件事情，让我们来分解一下。首先，我们构建了一个`Search`对象，传入了我们之前创建的`daintree`索引的索引名称。由于我们没有传入自定义的Elasticsearch连接，它使用了我们之前定义的默认连接。
- en: 'Next, we use the `query` method on the `Search` object. The syntax for this
    is simple. The first argument is the name of the type of query that we want to
    use. As we did with `curl`, we are using the `match` query type. All other arguments
    to the query method need to be keyword arguments, which will be the elements of
    the query. Here, this generates the same query as our example earlier with `curl`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在“Search”对象上使用“query”方法。这种语法很简单。第一个参数是我们想要使用的查询类型的名称。就像我们使用“curl”一样，我们使用“match”查询类型。查询方法的所有其他参数都需要是关键字参数，这些参数将是查询的元素。在这里，这生成了与我们之前使用“curl”示例相同的查询：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Having added the query to the `Search` object, we need to explicitly execute
    it. This is done with the `execute` method. Finally, to see the response, we use
    the helper `to_dict` method on the response, which prints out whatever Elasticsearch
    responded with to our search; in this case, it is similar to what we got when
    using `curl` earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Search”对象中添加查询后，我们需要显式执行它。这是通过“execute”方法完成的。最后，为了查看响应，我们使用响应的辅助“to_dict”方法，该方法打印出Elasticsearch对我们的搜索做出的响应；在这种情况下，它类似于我们之前使用“curl”时得到的内容。
- en: Now that we have seen how to search, the next step would be to look at how to
    add data to our Elasticsearch index. Before we can do this, we need to learn about
    Elasticsearch mappings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何搜索，下一步将是看看如何向我们的Elasticsearch索引添加数据。在我们这样做之前，我们需要了解Elasticsearch映射。
- en: Mapping
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'I mentioned earlier that Elasticsearch doesn''t require a data structure to
    be defined for the document types. However, Elasticsearch internally figures out
    the structure of the data that we insert. We have the ability to define this structure
    manually but don''t necessarily need to. When Elasticsearch uses its own guess
    of the data structure, it''s said to be using a dynamic mapping for the document
    type. Let''s look at what Elasticsearch guessed for our `product` document type.
    Using the command line, make the following request with curl:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，Elasticsearch不需要为文档类型定义数据结构。但是，Elasticsearch在内部会弄清楚我们插入的数据的结构。我们有能力手动定义这个结构，但不一定需要这样做。当Elasticsearch使用自己猜测的数据结构时，它被称为使用文档类型的动态映射。让我们看看Elasticsearch为我们的“product”文档类型猜测了什么。使用命令行，使用curl发出以下请求：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Elasticsearch has done a pretty good job of guessing our document structure.
    As you can see, it correctly guessed the type for all our fields. However, if
    you notice the type for the tags field, you'll see that it's a string. If you
    look at the document we retrieved earlier, the tags field is an array of strings.
    What's going on here?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch已经相当准确地猜测了我们的文档结构。正如您所看到的，它正确猜测了所有字段的类型。但是，如果您注意到tags字段的类型，您会发现它是一个字符串。如果您查看我们之前检索到的文档，您会发现tags字段是一个字符串数组。这是怎么回事？
- en: Well, in Elasticsearch, an array doesn't have any special mapping. Each field
    can have one or more values; thus, each field can be an array without having to
    map it as such. One important implication of this is that arrays in Elasticsearch
    can only have one type of data. Thus, you can't have an array that contains both
    date values and strings. If you try to insert something like that, Elasticsearch
    will just go ahead and store the date as a string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在Elasticsearch中，数组没有任何特殊的映射。每个字段可以有一个或多个值；因此，每个字段都可以是一个数组，而无需将其映射为这样。这种情况的一个重要含义是，Elasticsearch中的数组只能具有一种数据类型。因此，您不能有一个同时包含日期值和字符串的数组。如果您尝试插入这样的内容，Elasticsearch将只是将日期存储为字符串。
- en: You might be wondering that if Elasticsearch is intelligent enough to figure
    out our data structure, then why do we care about the mapping? Well, the library
    we are using to work with `Elasticsearch`, `elasticsearch_dsl`, needs to define
    custom mappings to be able to insert documents into the index.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，如果Elasticsearch足够智能，可以弄清楚我们的数据结构，那么为什么我们要关心映射呢？嗯，我们使用的用于与“Elasticsearch”一起工作的库“elasticsearch_dsl”需要定义自定义映射才能将文档插入索引。
- en: It is also a good idea to be explicit in what kind of data you will be inserting
    into the index. You can set a number of options when you set your own mapping,
    such as defining a field to be an integer. This way, even if you insert the value
    "123", Elasticsearch will convert it to an integer before inserting the document
    and raise an error if it can't. This provides data validation. There are certain
    types of data, such as dates in a format different than what Elasticsearch uses
    by default, that can only be correctly indexed if you have set a custom mapping.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据插入索引时，明确指定要插入的数据类型也是一个好主意。您可以在设置自定义映射时设置许多选项，例如定义字段为整数。这样，即使您插入值“123”，Elasticsearch也会在插入文档之前将其转换为整数，并在无法转换时引发错误。这提供了数据验证。有某些类型的数据，例如日期格式与Elasticsearch默认使用的格式不同，只有在设置了自定义映射时才能正确索引。
- en: Defining a mapping
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义映射
- en: 'To define a mapping with `elasticsearch_dsl`, we create a `DocType` subclass.
    This is similar to how a Django database model is defined. Create a new `main/es_docs.py`
    file and type in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“elasticsearch_dsl”定义映射，我们创建一个“DocType”子类。这类似于定义Django数据库模型的方式。创建一个新的“main/es_docs.py”文件，并键入以下代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There shouldn't be any surprises here as the syntax is pretty self-explanatory.
    I prefer to add ES to the start of my document type classes to differentiate an
    ES doc type class from the Django model of the same name. Note that we explicitly
    specified the document type name. If we hadn't, `elasticsearch_dsl` would have
    automatically come up with a name based on the class name—`ESProduct`. However,as
    we just wanted to define a mapping for an existing document type, we set the `doc_type`
    attribute in the `Meta` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有任何意外，因为语法非常简单易懂。我喜欢在我的文档类型类的开头添加ES，以区分ES文档类型类和同名的Django模型。请注意，我们明确指定了文档类型名称。如果我们没有这样做，“elasticsearch_dsl”将根据类名自动提出一个名称——“ESProduct”。但是，由于我们只是想为现有的文档类型定义映射，因此我们在“Meta”类中设置了“doc_type”属性。
- en: 'Notice that our data types are the same as the ones that we saw before when
    we asked Elasticsearch about the mapping. There is a reason for this. You can''t
    change the data type for an existing field. Otherwise, the existing documents
    would have the wrong data type and the search would return inconsistent results.
    While this mapping already exists in our Elasticsearch, let''s see how we would
    use this class to define a new document type mapping. Open up the Django shell
    again and type in the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的数据类型与我们之前在询问Elasticsearch关于映射时看到的数据类型是一样的。这是有原因的。您不能更改现有字段的数据类型。否则，现有文档将具有错误的数据类型，搜索将返回不一致的结果。虽然这个映射已经存在于我们的Elasticsearch中，让我们看看如何使用这个类来定义一个新的文档类型映射。再次打开Django
    shell，输入以下内容：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `ESProduct.init(index='daintree')` method to create the mapping in
    Elasticsearch. As our mapping already existed and was exactly the same, this function
    didn't change anything. However, if we were creating a new mapping, this function
    would have configured Elasticsearch with the new document type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ESProduct.init(index='daintree')`方法在Elasticsearch中创建映射。由于我们的映射已经存在并且完全相同，这个函数没有改变任何东西。但是，如果我们正在创建一个新的映射，这个函数将配置Elasticsearch与新的文档类型。
- en: Note that this time we didn't pass any parameters to the `connections.create_connection()`
    method, which means that it used the default host list that assumes a locally
    running instance of Elasticsearch on the default port of 9200\. As our Elasticsearch
    is running locally on the same port, we can skip the host's argument to the `create_connection()`
    method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有向`connections.create_connection()`方法传递任何参数，这意味着它使用了默认的主机列表，假设默认端口9200上运行的本地实例Elasticsearch。由于我们的Elasticsearch在同一端口上本地运行，我们可以跳过`create_connection()`方法的主机参数。
- en: Inserting documents into Elasticsearch from Python
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python将文档插入Elasticsearch
- en: Now that we have a `DocType` subclass and have seen how to create the mapping,
    all that's left to look at is inserting documents into Elasticsearch. This section
    assumes that you have loaded the fixtures data that I provided with the code drop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`DocType`子类，并且已经看到了如何创建映射，剩下的就是插入文档到Elasticsearch。本节假设您已经加载了我提供的代码片段的fixtures数据。
- en: 'Open the Django shell again and type the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开Django shell并输入以下命令：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the empty line after the for loop body. In the shell, this empty line is
    required to tell the interactive shell that the loop body is finished and it can
    go ahead and execute the loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在for循环体之后的空行。在shell中，这个空行是必需的，告诉交互式shell循环体已经结束，可以继续执行循环。
- en: It should be pretty normal, up to where we get the product with ID `200` from
    the database. I just chose a random ID as I knew that the product with ID `200`
    would exist in your database after you had loaded the fixtures I provided.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我们从数据库中获取ID为`200`的产品为止，一切都应该很正常。我只是随机选择了一个ID，因为我知道在加载我提供的fixtures后，您的数据库中将存在ID为`200`的产品。
- en: Next, we create a new `ESProduct` instance and assign it values from our Django
    model. The ID field needs to be assigned a value using the special meta keyword
    argument because that is part of the metadata of the document in Elasticsearch
    and not part of the document body. If we didn't provide an ID, Elasticsearch would
    automatically generate a random one for us. We specify it explicitly so that we
    can tie our database models to our Elasticsearch documents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的`ESProduct`实例，并从我们的Django模型中分配值。ID字段需要使用特殊的meta关键字参数分配一个值，因为它是Elasticsearch文档的元数据，而不是文档主体的一部分。如果我们没有提供ID，Elasticsearch将自动生成一个随机的ID。我们明确指定它，以便我们可以将我们的数据库模型与我们的Elasticsearch文档联系起来。
- en: Next, we loop over all the tags in our `Product` object and append it to the
    `tags` field in our `ESProduct` object. We didn't need to set the `tags` field
    value to an empty array. When we defined the `tags` field, we passed the `multi=True`
    argument to the constructor. For `elasticsearch_dsl` fields, a multifield has
    a default empty value, which is an empty list. Thus, in our loop, we were sure
    that `esp.tags` is a list that we can append to.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们循环遍历我们的`Product`对象中的所有标签，并将其附加到我们的`ESProduct`对象中的`tags`字段。我们不需要将`tags`字段的值设置为空数组。当我们定义`tags`字段时，我们向构造函数传递了`multi=True`参数。对于`elasticsearch_dsl`字段，多字段具有默认的空值，即一个空列表。因此，在我们的循环中，我们确信`esp.tags`是一个我们可以附加的列表。
- en: 'After we have set up our `ESProduct` model instance with the correct values,
    we call the save method, passing the index name in which to insert it. Once the
    save call returns, Elasticsearch will hold our new data. We can test it using
    `curl` to retrieve this new document:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用正确的值设置了`ESProduct`模型实例之后，我们调用save方法，传递要插入的索引名称。一旦保存调用返回，Elasticsearch将保存我们的新数据。我们可以使用`curl`来检索这个新文档：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the output for this command, you should now see three products instead of
    the two that we originally inserted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令的输出中，您现在应该看到三个产品，而不是我们最初插入的两个。
- en: Getting all our data into Elasticsearch
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有数据导入Elasticsearch
- en: 'We can''t go around inserting data into Elasticsearch from the console all
    the time. We need an automated way of doing so. As we''ve seen before, Django
    management commands are a perfect way to create a script to do so. Create the
    folders that will hold our command file, `main/management/commands`, create an
    empty `__init__.py` file in both `main/management` and `main/management/commands`,
    and add the following code to `main/management/commands/index_all_data.py`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能一直从控制台向Elasticsearch插入数据。我们需要一种自动化的方法。正如我们之前所看到的，Django管理命令是创建一个脚本的完美方式。创建将保存我们命令文件的文件夹，`main/management/commands`，在`main/management`和`main/management/commands`中创建一个空的`__init__.py`文件，并将以下代码添加到`main/management/commands/index_all_data.py`中：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There isn''t anything new here. We just loop over all the product objects in
    our database and add them to Elasticsearch. Run it as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的。我们只是循环遍历数据库中的所有产品对象，并将它们添加到Elasticsearch中。运行如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will run successfully without any output and you should now have all your
    documents in Elasticsearch. To confirm this, we can get the stats for our `daintree`
    index from Elasticsearch. Run the following command from your shell:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它将成功运行而不输出任何内容，现在您应该在Elasticsearch中拥有所有文档。为了确认这一点，我们可以从Elasticsearch获取我们的`daintree`索引的统计信息。从您的shell运行以下命令：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should output lots of data about the `daintree` index. You''ll need to
    scroll up and you will find the total document count. It should be similar to
    this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出有关`daintree`索引的大量数据。您需要向上滚动，您会找到总文档数。它应该类似于这样：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, all our data is now indexed. Next, we will add search to our
    home page using Elasticsearch.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的所有数据现在都已被索引。接下来，我们将使用Elasticsearch在我们的主页上添加搜索。
- en: Adding search
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加搜索
- en: 'If you look at our home page right now, it should be a list of 50 random products
    from our database. You can open it at `http://127.0.0.1:8000` and it should look
    similar to this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看我们的主页，它应该是从我们的数据库中随机选择的50个产品的列表。您可以在`http://127.0.0.1:8000`打开它，它应该看起来类似于这样：
- en: '![Adding search](img/00698_06_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![添加搜索](img/00698_06_01.jpg)'
- en: What we'd like to do is add a basic search form to this page. The form will
    just be one field that accepts a search term and button to perform the search.
    The search term will perform a search on the name field of our products list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是在这个页面上添加一个基本的搜索表单。表单将只是一个接受搜索词的字段和执行搜索的按钮。搜索词将在我们产品列表的名称字段上执行搜索。
- en: 'Let''s create a simple Django form and add it to our page. Create a new `main/forms.py`
    file and add the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Django表单并将其添加到我们的页面上。创建一个新的`main/forms.py`文件，并添加以下代码：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to display our search form on the home page. Add the following
    to the `home.html` template, right after the opening tag of the `content` block:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在主页上显示我们的搜索表单。在`home.html`模板中添加以下内容，就在`content`块的开头标签之后：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we need to modify our `HomeView` so that it uses the user''s query
    to generate the list of results instead of getting 50 random ones from the database.
    Change `main/view.py` to match the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们的`HomeView`，以便它使用用户的查询来生成结果列表，而不是从数据库中获取50个随机的结果。更改`main/view.py`以匹配以下代码：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s test it first and then I''ll explain what this code does. Enter a search
    term in the field and press the **Search** button. As our sample data has the
    usual `Lorem Ipsum` text in all the fields, search for a term like `lorem`. You
    should see something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们测试一下，然后我会解释这段代码的作用。在字段中输入搜索词并点击**搜索**按钮。由于我们的示例数据在所有字段中都有通常的`Lorem Ipsum`文本，因此搜索一个词如`lorem`。您应该会看到类似于这样的东西：
- en: '![Adding search](img/00698_06_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![添加搜索](img/00698_06_02.jpg)'
- en: 'Try playing around with a few different search terms and see how it responds.
    If you enter something that is not found in our products list, you should see
    an empty page. We''ll change it so that the user sees a message telling them that
    their search query has no results. Additionally, the category name has disappeared.
    This happened because the attribute name used in the `product.category.name` template
    is different from what our Elasticsearch document contains. While most of our
    field names in our Elasticsearch document were the same as those in our Django
    models, the category name needs to be accessed differently as it is no longer
    a foreign key but a simple string. In `main/templates/home.html`, note the following
    line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一些不同的搜索词来玩耍，看看它的反应。如果您输入的内容在我们的产品列表中找不到，您应该会看到一个空页面。我们将更改它，以便用户看到一条消息，告诉他们他们的搜索查询没有结果。此外，类别名称已经消失了。这是因为`product.category.name`模板中使用的属性名称与我们的Elasticsearch文档包含的内容不同。虽然我们的Elasticsearch文档中大多数字段名称与我们的Django模型中的字段名称相同，但类别名称需要以不同的方式访问，因为它不再是外键，而是一个简单的字符串。在`main/templates/home.html`中，请注意以下行：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change this to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The category name for our products will reappear.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品的类别名称将重新出现。
- en: 'If you experimented a bit, you''ll notice that if you leave the field blank
    and click on the **Search** button, you don''t get back any results. That''s because
    if you give the match query an empty string to match with, it returns zero results.
    We can fix this by querying if the user specified a search term. Remove this line
    from the view code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行了一些实验，您会注意到如果您将字段留空并单击**搜索**按钮，您将不会收到任何结果。这是因为如果您给匹配查询一个空字符串进行匹配，它会返回零结果。我们可以通过查询用户是否指定了搜索词来解决这个问题。从视图代码中删除这行：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replace it with the following if condition:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下条件：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This way, if the user didn't enter any query, we ask Elasticsearch to do a search
    with no query specified, and Elasticsearch just returns us the first ten documents
    that it has. This is similar to doing `Product.objects.all()[:10]` if we were
    using the database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果用户没有输入任何查询，我们要求Elasticsearch进行没有指定查询的搜索，Elasticsearch只返回它拥有的前十个文档。这类似于如果我们使用数据库，执行`Product.objects.all()[:10]`。
- en: 'Now, let''s change our template so that if there were no results, the user
    sees a nice message explaining that, instead of an empty page which the user might
    see as a bug in our application. Change the `{% for product in products %}` loopin
    our `main/templates/home.html` template and replace it with the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改我们的模板，以便如果没有结果，用户会看到一个漂亮的消息来解释，而不是一个空页面，用户可能会认为这是我们应用程序中的一个错误。更改我们的`main/templates/home.html`模板中的`{%
    for product in products %}`循环，并将其替换为以下内容：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now if you enter a search term that doesn't have any results, you should see
    a message instead of an empty page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您输入一个没有结果的搜索词，您应该会看到一条消息，而不是一个空页面。
- en: 'The form and template code should be easy enough for you to understand by now.
    It''s the view code that looks the most interesting. Let''s take a look at the
    `get` method where all the magic happens:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，表单和模板代码应该很容易让您理解。最有趣的是视图代码。让我们看看发生魔术的`get`方法：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first few lines simply instantiate the form with the GET params from the
    request. We also add it to our context dictionary that we later pass to our template.
    Then, we check whether the form is valid. If it is, we first use the `create_connection()`
    method from the `elasticsearch_dsl` library. We need to do this here because without
    this we would not be able to do a search later on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首几行只是用请求中的GET参数实例化表单。我们还将它添加到稍后传递给模板的上下文字典中。然后，我们检查表单是否有效。如果有效，我们首先使用`elasticsearch_dsl`库中的`create_connection()`方法。我们需要在这里这样做，因为如果没有这样做，我们以后将无法进行搜索。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of you might say that this approach of configuring the connection to Elasticsearch
    in our view code feels like bad code. I agree! Later on, we'll fix this, don't
    worry.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能会说，在我们的视图代码中配置Elasticsearch连接的方法感觉像是糟糕的代码。我同意！以后，我们会解决这个问题，不用担心。
- en: After having set up our Elasticsearch connection, we check whether the user
    actually entered some search term. If they did, we then create the `Search` object
    and add our query to it. We specify that we need the `match` query type and we
    want to get documents where the `name` field has the query term entered by the
    user. In case the user didn't enter any search query, we need to set our search
    object, `s`, to a default search. As explained before, we did this because Elasticsearch
    returns an empty results list if the query term is empty.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好Elasticsearch连接后，我们检查用户是否实际输入了一些搜索词。如果他们输入了，我们就创建`Search`对象并将我们的查询添加到其中。我们指定我们需要`match`查询类型，并且我们希望获取`name`字段中包含用户输入的查询词的文档。如果用户没有输入任何搜索查询，我们需要将我们的搜索对象`s`设置为默认搜索。如前所述，我们这样做是因为如果查询词为空，Elasticsearch会返回一个空的结果列表。
- en: Finally, we execute our search and store the results in the `result` variable.
    We then extract the results from the `hits` parameter of the `result` variable
    and assign it to the `products` key in our context dictionary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行搜索并将结果存储在`result`变量中。然后，我们从`result`变量的`hits`参数中提取结果，并将其分配给上下文字典中的`products`键。
- en: At the end, we simply render the template using the context dictionary that
    we have prepared. As you can see, there isn't anything very complicated about
    using Elasticsearch with Django. The `elasticsearch_dsl` library especially makes
    this very simple.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需使用我们准备好的上下文字典来呈现模板。正如你所看到的，使用Elasticsearch与Django并不是非常复杂的事情。`elasticsearch_dsl`库特别使这变得非常简单。
- en: Configuration management
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理
- en: In the previous code, we used the `connections.create_connection()` method to
    set up our Elasticsearch connection in the view code. This is a bad practice due
    to a couple of reasons. First, you have to remember to initialize the connection
    in every view where you want to use the Search object. Our example only has one
    view so we didn't run into this problem. However, imagine that you have three
    views that use Elasticsearch. Now your `create_connection()` method call has to
    be in all three of these as you never know which order the user will visit the
    website in and which view will be run first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在视图代码中使用`connections.create_connection()`方法来设置我们的Elasticsearch连接。由于几个原因，这是一个不好的做法。首先，你必须记住在每个想要使用Search对象的视图中初始化连接。我们的示例只有一个视图，所以我们没有遇到这个问题。但是，想象一下，如果你有三个使用Elasticsearch的视图。现在你的`create_connection()`方法调用必须在这三个视图中都有，因为你永远不知道用户会以什么顺序访问网站，哪个视图会首先运行。
- en: Secondly, and most importantly, if you ever need to change the way the connection
    is configured—maybe changing the address of the Elasticsearch server or setting
    some other connection parameters—you'll need to change it in all the places where
    you have initialized the connection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更重要的是，如果你需要改变连接配置的方式——也许是改变Elasticsearch服务器的地址或设置其他连接参数——你需要在所有初始化连接的地方进行更改。
- en: Due to these reasons, it is always a good idea to have the code to initialize
    external connections in one place. Django provides us with a good way to do this
    using `AppConfig` objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，将初始化外部连接的代码放在一个地方总是一个好主意。Django为我们提供了一个很好的方法来使用`AppConfig`对象来做到这一点。
- en: When Django starts up, it will import all the applications listed in the `settings.INSTALLED_APPS`
    list. For each application, it will check whether the application's `__init__.py`
    has a `default_app_config` variable defined. This variable needs to be a string
    that holds the Python path to a subclass of the `AppConfig` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django启动时，它将导入`settings.INSTALLED_APPS`列表中列出的所有应用程序。对于每个应用程序，它将检查应用程序的`__init__.py`是否定义了`default_app_config`变量。这个变量需要是一个字符串，其中包含指向`AppConfig`类的子类的Python路径。
- en: If the `default_app_config` variable is defined, Django will use the subclass
    pointed to as the configuration options for that app. If not, Django will create
    a generic `AppConfig` object and use this instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`default_app_config`变量，Django将使用指向的子类作为该应用程序的配置选项。如果没有，Django将创建一个通用的`AppConfig`对象并使用它。
- en: The `AppConfig` subclass has a couple of interesting uses, such as setting the
    verbose name for the application and getting the models defined in the application.
    For our case, the `AppConfig` subclass can define a `ready()` method that Django
    will call once when importing the application for the first time. We can set up
    our Elasticsearch connections here and then just use the `Search` objects throughout
    our application without needing to care about whether the connection was configured
    or not. Let's do this now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppConfig`子类有一些有趣的用途，比如为应用程序设置详细名称和获取应用程序中定义的模型。对于我们的情况，`AppConfig`子类可以定义一个`ready()`方法，Django在首次导入应用程序时将调用该方法一次。我们可以在这里设置我们的Elasticsearch连接，然后只需在整个应用程序中使用`Search`对象，而不需要关心连接是否已配置。现在让我们来做这个。'
- en: 'First, edit the `main/apps.py` file and change the code to match this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑`main/apps.py`文件并更改代码以匹配以下内容：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, open up `main/__init__.py` and add the following line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`main/__init__.py`并添加以下行：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, from `main/views.py`, remove the import:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从`main/views.py`中删除导入：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remove the `connections.create_connection()` method call from the `get` method
    of the `HomeView`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从`HomeView`的`get`方法中删除`connections.create_connection()`方法调用。
- en: Open the home page again and do a couple of searches. You'll see that even without
    the `create_connection()` method call in our view, the search works fine. If you
    want to learn more about `AppConfig`, I suggest you look at the Django documentation
    at [https://docs.djangoproject.com/en/stable/ref/applications/](https://docs.djangoproject.com/en/stable/ref/applications/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开主页并进行几次搜索。您会发现即使在我们的视图中没有`create_connection()`方法调用，搜索也能正常工作。如果您想了解有关`AppConfig`的更多信息，我建议您查看Django文档[https://docs.djangoproject.com/en/stable/ref/applications/](https://docs.djangoproject.com/en/stable/ref/applications/)。
- en: More search options
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多搜索选项
- en: 'While our basic search is useful, our users will definitely need some way to
    search by price range as well. Let''s take a look at how to add this to our search
    form. We''ll use the `range` Elasticsearch query type to add this feature. First,
    let''s change `main/forms.py` to add the two fields we''ll need for this—minimum
    price and maximum price:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的基本搜索很有用，但我们的用户肯定也需要一些按价格范围搜索的方法。让我们看看如何将其添加到我们的搜索表单中。我们将使用`range` Elasticsearch查询类型来添加此功能。首先，让我们更改`main/forms.py`以添加我们需要的两个字段-最低价格和最高价格：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, change the `HomeView` code to accept and use these new fields in our
    search query:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更改`HomeView`代码以接受并使用我们搜索查询中的这些新字段：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What we have done in the view is first checked whether the user provided us
    with a value for either the minimum price or maximum price. If the user didn't
    enter any values for either fields, there's no point in adding an empty query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们首先检查用户是否为最低价格或最高价格提供了值。如果用户没有为任何字段输入任何值，那么添加空查询就没有意义。
- en: 'If the user entered values for either of the two price range fields, we first
    instantiate an empty dictionary (we''ll look at why a dictionary is needed in
    a bit). Then, depending on which of the two price range fields the user entered
    data in, we add greater-than-or-equal-to and less-than-or-equal-to clauses to
    the dictionary. Finally, we add a range query, passing in the dictionary that
    we created as the value of the field name keyword argument, `price` in our case.
    Here is the relevant line of code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户为两个价格范围字段中的任何一个输入了值，我们首先实例化一个空字典（稍后我们将看到为什么需要字典）。然后，根据用户在两个价格范围字段中输入数据的情况，我们向字典添加大于或等于和小于或等于子句。最后，我们添加一个范围查询，将我们创建的字典作为字段名称关键字参数的值传递，`price`在我们的情况下。以下是相关的代码行：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The reason we needed a dictionary here and not in the last example is because
    some Elasticsearch queries have more than just one option. In the case of a range
    query, Elasticsearch supports both `gte` and `lte` options. However, the library
    that we are using, `elasticsearch_dsl`, can accept only one parameter for any
    query type and this parameter needs to be passed as the keyword argument with
    the field name, `price` in our case. So we create a dictionary and then pass this
    to our range query.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要一个字典而不是在上一个示例中需要的原因是因为一些Elasticsearch查询不仅仅有一个选项。在范围查询的情况下，Elasticsearch支持`gte`和`lte`选项。但是，我们正在使用的库`elasticsearch_dsl`只能接受任何查询类型的一个参数，并且此参数需要作为字段名称的关键参数传递，我们的情况下是`price`。因此，我们创建一个字典，然后将其传递给我们的范围查询。
- en: 'You should now see the two fields on our home page and be able to query using
    them. You will notice that we give no feedback to the user about the price of
    the products. It''s not displayed anywhere. So we have no way to confirm if the
    search is actually working. Let''s add it now. Change `main/templates/home.html`
    to add this line right below where we display the product category:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在我们的主页上看到这两个字段，并且能够使用它们进行查询。您会注意到我们没有向用户提供有关产品价格的任何反馈。它没有显示在任何地方。因此，我们无法确认搜索是否实际起作用。让我们现在添加它。更改`main/templates/home.html`以在我们显示产品类别的下方添加这行：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now if you look at the home page, it will show you the prices for each product,
    and you''ll feel that it provides a much better user experience as well. Plus,
    you can now test the minimum and maximum price search code as well. By now, our
    home page looks something like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看主页，它将为您显示每个产品的价格，并且您会感到它提供了更好的用户体验。此外，您现在还可以测试最低和最高价格搜索代码。到目前为止，我们的主页看起来是这样的：
- en: '![More search options](img/00698_06_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![更多搜索选项](img/00698_06_03.jpg)'
- en: Up to now, we haven't done anything with Elasticsearch that wouldn't have been
    just as easy with a database. We could have built all these queries using the
    Django ORM and it would work the same. Maybe we have gained some performance benefits,
    but at the small scale that our application operates at, these gains are almost
    negligible. Next, we will add a feature that would have been very difficult to
    create using just a database, and we'll see how Elasticsearch makes it so much
    easier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Elasticsearch中还没有做任何数据库无法轻松完成的事情。我们可以使用Django ORM构建所有这些查询，并且它将起到相同的作用。也许我们获得了一些性能优势，但在我们的应用程序操作的小规模中，这些收益几乎可以忽略不计。接下来，我们将添加一个使用仅仅数据库很难创建的功能，并且我们将看到Elasticsearch如何使它变得更容易。
- en: Aggregations and filters
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合和过滤器
- en: 'If you have ever used Amazon (or any other large e-commerce site), you might
    remember that on the left-hand side of the search results, these sites provide
    a list of filters that users can easily select and navigate the search results.
    These filters are generated dynamically based on what results are shown and selecting
    one further narrows down the search results. It''s just easier to show what I
    mean with a screenshot. On Amazon, if you perform a search, you''ll see something
    similar to this on the left-hand side of the screen:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过亚马逊（或任何其他大型电子商务网站），您可能会记得在搜索结果的左侧，这些网站提供了一个用户可以轻松选择和浏览搜索结果的过滤器列表。这些过滤器是根据显示的结果动态生成的，选择一个过滤器会进一步缩小搜索结果。通过截图更容易理解我的意思。在亚马逊上，如果您进行搜索，您会在屏幕左侧看到类似于以下内容：
- en: '![Aggregations and filters](img/00698_06_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![聚合和过滤器](img/00698_06_04.jpg)'
- en: If you select any of the options listed here, you will further refine your search
    and see results relevant to only that option. They also provide the user with
    instant feedback, letting them know at a glance how many results they can expect
    to see if they select one of the available options.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择这里列出的任何选项，您将进一步细化您的搜索，并只看到与该选项相关的结果。它们还为用户提供了即时反馈，让他们一目了然地知道如果他们选择其中一个可用选项，他们可以期望看到多少结果。
- en: We want to implement something similar in our application. Elasticsearch provides
    a feature called aggregations to help us do just this. Let's see what aggregations
    are first.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在我们的应用程序中实现类似的功能。Elasticsearch提供了一个名为聚合的功能来帮助我们做到这一点。让我们先看看什么是聚合。
- en: 'Aggregations provide a way to get statistics about our search results. There
    are two types of aggregations that can be used to get two different kinds of data
    about the search results: bucket aggregations and metric aggregations.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合提供了一种获取有关我们搜索结果的统计信息的方法。有两种类型的聚合可用于获取有关搜索结果的两种不同类型的数据：bucket聚合和度量聚合。
- en: Bucket aggregations are like `GROUP BY SQL` queries. They gather documents into
    groups, or buckets, based on certain dimensions and calculate some metrics for
    each of these groups. The simplest aggregation is a `terms` aggregation. You give
    it a field name, and for each unique value of that field, Elasticsearch returns
    the count of documents where the field contains that value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Bucket聚合类似于`GROUP BY SQL`查询。它们根据某些维度将文档聚合到组或桶中，并为这些组中的每个计算一些指标。最简单的聚合是`terms`聚合。您给它一个字段名，对于该字段的每个唯一值，Elasticsearch返回包含该值的字段的文档计数。
- en: 'For example, let''s say that you have five documents in your index:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您的索引中有五个文档：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we run a terms aggregation on this data based on the category field, we
    will get back results that give us the count of books in each category: two in
    web, two in Django, and one in Java.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根据类别字段对这些数据运行terms聚合，我们将得到返回结果，这些结果给出了每个类别中书籍的数量：web中有两本，Django中有两本，Java中有一本。
- en: First, we will add aggregations for the categories in our products list and
    allow the user to filter their search based on these categories.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为产品列表中的类别添加聚合，并允许用户根据这些类别筛选他们的搜索。
- en: Category aggregation
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别聚合
- en: 'The first step is to add an aggregation to our search object and pass the results
    from this aggregation to our template. Change `HomeView` in `main/views.py` to
    match the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是向我们的搜索对象添加一个聚合，并将来自此聚合的结果传递给我们的模板。更改`main/views.py`中的`HomeView`以匹配以下代码：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I have highlighted the new code, which is just two lines. The first line is
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了新代码，只有两行。第一行如下：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line adds a bucket type aggregation to our search object. In Elasticsearch,
    each aggregation needs a name and the aggregation results are associated with
    this name in the response. We give our aggregation the name, `categories`. The
    next parameter to the method is the type of aggregation that we want. As we want
    to count the number of documents for each distinct category term, we use the `terms`
    aggregation. As we'll see later on, Elasticsearch has a lot of different aggregation
    types that provide for almost all kinds of use cases that you can think of. After
    the second parameter, all keyword arguments are part of the aggregation definition.
    Each type of aggregation requires different parameters. The `terms` aggregation
    only needs the name of the field to aggregate on, which is `category` in our documents.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行向我们的搜索对象添加了一个bucket类型的聚合。在Elasticsearch中，每个聚合都需要一个名称，并且聚合结果与响应中的此名称相关联。我们给我们的聚合起名为`categories`。方法的下一个参数是我们想要的聚合类型。因为我们想要计算每个不同类别术语的文档数量，所以我们使用`terms`聚合。正如我们将在后面看到的，Elasticsearch有许多不同的聚合类型，几乎可以满足您能想到的所有用例。在第二个参数之后，所有关键字参数都是聚合定义的一部分。每种类型的聚合需要不同的参数。`terms`聚合只需要要聚合的字段的名称，这在我们的文档中是`category`。
- en: 'The next line is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行如下：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This line adds the results from our aggregations to our template context, where
    we will use it to render in the template. The format of the aggregation results
    is similar to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将我们的聚合结果添加到我们的模板上下文中，我们将在模板中使用它进行渲染。聚合结果的格式类似于这样：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The top-level dictionary contains a key for each aggregation that we added,
    with the same name as the one we added it with. In our case, the name is `categories`.
    The value for each key is the result of that aggregation. For a bucket aggregation,
    like the `terms` one that we have used, the result is a list of buckets. Each
    bucket has a key, which is a distinct category name, and the number of documents
    that have this category.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层字典包含我们添加的每个聚合的键，与我们添加的名称相同。在我们的情况下，名称是`categories`。每个键的值是该聚合的结果。对于bucket聚合，就像我们使用的`terms`一样，结果是一个桶的列表。每个桶都有一个键，这是一个不同的类别名称，以及具有该类别的文档数量。
- en: 'Let''s display this data in our template first. Change `main/templates/home.html`
    to match the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在模板中显示这些数据。更改`main/templates/home.html`以匹配以下代码：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Again, I have highlighted the new code. Having seen the format of the preceding
    output, this new code should be simple for you to understand. We just loop over
    each bucket item and display the name of the category and number of documents
    having that category here.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我已经突出显示了新代码。看到了前面输出的格式，这个新代码对你来说应该很简单。我们只是循环遍历每个桶项，并在这里显示类别的名称和具有该类别的文档数量。
- en: 'Let''s take a look at the results. Open up the home page in your browser and
    perform a search; you should see something similar to this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看结果。在浏览器中打开主页并进行搜索；您应该会看到类似于这样的结果：
- en: '![Category aggregation](img/00698_06_05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![类别聚合](img/00698_06_05.jpg)'
- en: We now have a list of categories displayed. But wait, what's this? If you look
    closer, you'll see that none of the category names make sense (outside of the
    fact that they are in Latin). None of the categories that we see match what the
    categories our products have. How come?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个显示的类别列表。但等等，这是什么？如果你仔细看，你会发现没有一个类别名称是有意义的（除了它们是拉丁文）。我们看到的类别都不符合我们的产品类别。为什么呢？
- en: 'What''s happened here is that Elasticsearch took our list of categories, broke
    them up into individual words, and then ran the aggregation. For example, if three
    products had categories *web development*, *django development*, and *web applications*,
    this aggregation would have given us the following results:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是Elasticsearch获取了我们的类别列表，将它们分解成单个单词，然后进行了聚合。例如，如果三个产品的类别是*web development*、*django
    development*和*web applications*，这个聚合将给我们以下结果：
- en: web (2)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络（2）
- en: development (2)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发（2）
- en: django (1)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: django（1）
- en: applications (1)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序（1）
- en: However, this is not useful for our use case. Our category names should be treated
    as a unit and not broken up into individual words. Also, we never asked Elasticsearch
    to do any such thing when we were indexing our data. So what happened? To understand
    this, we need to understand how Elasticsearch works with textual data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对我们的用例没有用。我们的类别名称应该被视为一个单位，而不是分解成单个单词。此外，当我们索引数据时，我们从未要求Elasticsearch做任何这样的事情。那么发生了什么？要理解这一点，我们需要了解Elasticsearch如何处理文本数据。
- en: Full text search and analysis
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全文搜索和分析
- en: 'Elasticsearch is based on Lucene, which is a very powerful library to create
    full text search applications. Full text search is a bit like using Google on
    your own documents. You must have used the Find functionality in word processors
    such as Microsoft Word or on web pages a couple of times in your life. This approach
    to search is called exact matching. For example, you have a piece of text like
    this one taken from the preface to *Stories from The Arabian Nights*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch基于Lucene，这是一个非常强大的库，用于创建全文搜索应用程序。全文搜索有点像在自己的文档上使用Google。您一生中可能已经使用过类似Microsoft
    Word这样的文字处理器中的查找功能，或者在网页上几次。这种搜索方法称为精确匹配。例如，您有一段文本，就像从《一千零一夜故事》的序言中摘取的这段：
- en: '*Scheherazadè, the heroine of the Thousand and one Nights, ranks among the
    great story-tellers of the world much as does Penelope among the weavers. Procrastination
    was the basis of her art; for though the task she accomplished was splendid and
    memorable, it is rather in the quantity than the quality of her invention—in the
    long spun-out performance of what could have been done far more shortly—that she
    becomes a figure of dramatic interest.*'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*《一千零一夜故事》中的女主人公沙赫拉萨德（Scheherazadè）与世界上伟大的讲故事者一样，就像佩内洛普（Penelope）与织工一样。拖延是她艺术的基础；尽管她完成的任务是辉煌而令人难忘的，但她的发明量远远超过了质量——在长时间的表演中，本来可以更简短地完成的任务——这使她成为戏剧性兴趣的人物。*'
- en: If you search for the term `memorable quantity` using exact matching, it will
    not show any results. That's because the exact term "memorable quantity" is not
    found in this text.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用精确匹配搜索术语`memorable quantity`，它将不会显示任何结果。这是因为在这段文本中没有找到确切的术语“memorable quantity”。
- en: A full text search, however, would return you this text because even though
    the exact term `memorable quantity` is not seen anywhere in the text, the two
    words `memorable` and `quantity` do appear in the text. Even if you search for
    something like `memorable Django`, this text would still be returned because the
    word `memorable` is still present in the text, even though `Django` is not. This
    is how most users expect search to work on the web, especially on e-commerce sites.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，全文搜索会返回这段文本，因为即使确切术语`memorable quantity`在文本中没有出现，但`memorable`和`quantity`这两个词确实出现在文本中。即使搜索`memorable
    Django`，这段文本仍然会返回，因为`memorable`这个词仍然出现在文本中，即使`Django`没有。这就是大多数用户期望在网络上进行搜索的方式，特别是在电子商务网站上。
- en: If you are searching for `Django web development` books on our site and we do
    not have something with the exact title, but we do have a book called `Django
    Blueprints`, the user will expect to see that in the search results.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在我们的网站上搜索`Django web development`图书，但我们没有确切标题的书，但我们有一本名为`Django Blueprints`的书，用户会期望在搜索结果中看到它。
- en: This is what Elasticsearch does when you use a full text search. It breaks up
    your search term into words, and then uses these to find search results that have
    these terms in them. However, to do this, Elasticsearch also needs to break up
    your document when you index them so that it can do the search faster later on.
    This process is called analyzing the document and happens at index time for all
    string fields by default.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当您使用全文搜索时Elasticsearch所做的。它会将您的搜索词分解成单词，然后使用这些单词来查找包含这些词的搜索结果。但是，为了做到这一点，Elasticsearch还需要在索引文档时分解您的文档，以便以后可以更快地进行搜索。这个过程称为分析文档，并且默认情况下对所有字符串字段在索引时间进行。
- en: This is the reason why when we get the aggregations for our category field,
    we get individual words instead of the complete category names in the result.
    While full text search is very useful in most cases of search, for example, the
    name query search that we have, in cases like category names it actually gives
    us unexpected results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们为我们的类别字段获取聚合时，我们得到的是单个单词，而不是结果中完整的类别名称。虽然全文搜索在大多数搜索情况下非常有用，例如我们拥有的名称查询搜索，但在类别名称等情况下，它实际上给我们带来了意想不到的结果。
- en: As I've mentioned before, the analysis process that leads to Elasticsearch breaking
    up (tokenization is the technical term for this) is done at indexing time. In
    order to make sure that our category names are not analyzed, we need to change
    our `ESProduct DocType` subclass and reindex all our data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，导致Elasticsearch分解（这个技术术语称为标记化）的分析过程是在索引时间完成的。为了确保我们的类别名称不被分析，我们需要更改我们的`ESProduct
    DocType`子类并重新索引所有数据。
- en: 'First, let''s change our `ESProduct` class in `main/es_docs.py`. Note the following
    line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`main/es_docs.py`中更改我们的`ESProduct`类。注意以下行：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change this to be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改如下：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, if we now try to update the mapping, we will run into a problem. Elasticsearch
    can only create a mapping for fields, not update them. This is because if we were
    allowed to change the mapping of a field after we have some data in our index,
    the old data might not make sense anymore with the new mapping.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在尝试更新映射，我们将遇到问题。Elasticsearch只能为字段创建映射，而不能更新它们。这是因为如果允许在索引中有一些数据之后更改字段的映射，旧数据可能再也不符合新的映射了。
- en: 'To delete our existing Elasticsearch index, run the following command in the
    command line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除我们现有的Elasticsearch索引，请在命令行中运行以下命令：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we want to create our new index and add the `ESProduct` mapping. We could
    do what we did before and create the index from the Python shell. Instead, let''s
    modify our `index_all_data` command to automatically create the index when it
    is run. Change the code in `main/management/commands/index_all_data.py` to match
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建我们的新索引并添加`ESProduct`映射。我们可以像以前一样从Python shell中创建索引。相反，让我们修改我们的`index_all_data`命令，在运行时自动创建索引。更改`main/management/commands/index_all_data.py`中的代码以匹配以下内容：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I have highlighted the change, which is just the addition of a new line calling
    the `ESProduct.init` method. Finally, let''s run our command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了更改，只是添加了一行调用`ESProduct.init`方法。最后，让我们运行我们的命令：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After running the command, let''s make sure that our new mapping was inserted
    correctly. Let''s see what mapping Elasticsearch has now by running the following
    in the command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，让我们确保我们的新映射被正确插入。让我们通过在命令行中运行以下命令来查看Elasticsearch现在有什么映射：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you look at the mapping for the `category` field, it is now not analyzed.
    Let''s try that last search again and see if this fixes our category aggregations
    issue. You should now see something similar to this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`category`字段的映射，现在它不再被分析。让我们再试一次最后的搜索，看看这是否解决了我们的类别聚合问题。现在你应该看到类似于这样的东西：
- en: '![Full text search and analysis](img/00698_06_06.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![全文搜索和分析](img/00698_06_06.jpg)'
- en: As you can see, we no longer have our category names split up into individual
    words. Instead, we get a list of unique category names, which is what we wanted
    from the start. Now let's give our users the ability to select one of these categories
    to limit their search to just the selected category.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再将我们的类别名称拆分为单独的单词。相反，我们得到了一个唯一类别名称的列表，这正是我们从一开始想要的。现在让我们让我们的用户能够选择其中一个类别，将他们的搜索限制为所选的类别。
- en: Searching with aggregations
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聚合进行搜索
- en: 'The user interaction that we would like to have is this: the user opens the
    search page or does a search and sees the list of category links. The user then
    clicks on one of those links and sees only products from those categories, with
    the user''s previous search applied. So if the user searched for products with
    price between 100 and 200 and then clicked on one of the category links, the new
    search should show only products from that category while still applying the price
    filtering.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户交互是这样的：用户打开搜索页面或进行搜索并看到类别链接列表。然后用户点击其中一个链接，只看到来自这些类别的产品，并应用用户之前的搜索。因此，如果用户搜索价格在100到200之间的产品，然后点击一个类别链接，新的搜索应该只显示来自该类别的产品，同时仍然应用价格过滤。
- en: In order to achieve this, we need a way to create the category links so that
    the current search is preserved. We can pass the category to `HomeView` as another
    GET parameter. So we need to take the current GET parameters (which make up the
    current search) and add our category name to the end of it as another parameter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一种方法来创建类别链接，以便保留当前搜索。我们可以将类别作为另一个GET参数传递给`HomeView`。因此，我们需要获取当前的GET参数（构成当前搜索）并将我们的类别名称添加到其末尾作为另一个参数。
- en: Unfortunately, Django does not have a built-in way to achieve this. There are
    a number of solutions. You could build a custom template tag that adds parameters
    to the end of the current URL or you could use some if conditions in your template
    to add the category name to the end of the URL. There is another method, which
    I prefer because it is cleaner. Instead of generating the URLs in the template,
    we will generate them in the Python code where we have a lot of utilities to handle
    URL GET parameters and just pass the list of categories along with the URLs to
    the template to display.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Django没有内置的方法来实现这一点。有许多解决方案。您可以构建一个自定义模板标签，将参数添加到当前URL的末尾，或者您可以在模板中使用一些if条件将类别名称添加到URL的末尾。还有另一种方法，我更喜欢，因为它更清晰。我们将在Python代码中生成URL，而不是在模板中生成URL，我们有很多实用程序来处理URL
    GET参数，只需将类别列表与URL一起传递到模板中显示。
- en: 'Let''s change the code for `main/views.py` to match the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改`main/views.py`的代码以匹配以下内容：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I have highlighted the new code that we have added. To start, we imported the
    `reverse` method from Django. Next, while making our search query, we check whether
    the user has selected a category (by looking at the category query param). If
    the user did select something, we add it to our search as a `match` query on the
    category field.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了我们添加的新代码。首先，我们从Django导入了`reverse`方法。接下来，在进行搜索查询时，我们检查用户是否选择了一个类别（通过查看类别查询参数）。如果用户确实选择了某些内容，我们将其添加到我们的搜索中作为对类别字段的`match`查询。
- en: The more important part comes next, where we build the URLs for the category
    links. We loop over each of the buckets that we got in the aggregation results.
    For each bucket, we extract the category name and document count. Then, we make
    a copy of the request GET params. We make a copy because we want to modify the
    parameters by adding our category name in there, but `request.GET dict` is immutable
    and cannot be changed. If you try to change something in `request.GET`, you will
    get an exception. So we make a copy and add the category name for the current
    bucket in there.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的部分接下来，我们要为类别链接构建URL。我们循环遍历聚合结果中的每个桶。对于每个桶，我们提取类别名称和文档计数。然后，我们复制请求的GET参数。我们复制是因为我们想要通过添加我们的类别名称来修改参数，但`request.GET
    dict`是不可变的，不能被改变。如果你尝试改变`request.GET`中的内容，你会得到一个异常。所以我们复制一份，并在其中添加当前桶的类别名称。
- en: Next, we create a URL for the request that will search using this category.
    This URL is made by first reversing the home page URL and then adding the query
    parameters—the one that we made by copying the current request params and adding
    our category name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为使用该类别进行搜索创建一个URL。首先，我们要反转主页的URL，然后添加查询参数——我们通过复制当前请求参数并添加我们的类别名称而得到的参数。
- en: 'Finally, we add all this information to a list that we pass to the template.
    Our template needs to change as well to work with this new data format. Here is
    the new code for `main/templates/home.html`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些信息添加到一个列表中，然后传递给模板。我们的模板也需要改变以适应这种新的数据格式。以下是`main/templates/home.html`的新代码：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I have highlighted the code changes. It should be clear what we did here given
    how we have now formatted our category filters. One small change that is not relevant
    is the addition of the `<h2>` `Results </h2>`. That's because I forgot to add
    it earlier and only later realized that there was no divider between the aggregation
    filters and results. So I added that here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了代码更改。鉴于我们现在已经格式化了我们的类别过滤器，我们所做的应该是清楚的。一个不相关的小改变是添加了`<h2>` `Results </h2>`。那是因为我之前忘记添加它，后来才意识到聚合过滤器和结果之间没有分隔符。所以我在这里添加了它。
- en: 'You should go ahead and try playing around with the category filters. Select
    one of the shown categories and you should only see products from that category.
    Your screen should look similar to this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试玩一下类别过滤器。选择其中一个显示的类别，你应该只能看到该类别的产品。你的屏幕应该看起来类似于这样：
- en: '![Searching with aggregations](img/00698_06_06.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![使用聚合进行搜索](img/00698_06_06.jpg)'
- en: One last feature that I want to add is a way to cancel the category filter.
    If you think about it, we just need to remove the category query param to cancel
    a category filter, which would leave us with the original query that only included
    the search form params. Doing this is pretty simple; let's take a look.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要添加的最后一个功能是取消类别过滤器的方法。如果你仔细想想，我们只需要删除类别查询参数来取消类别过滤器，这样我们就会得到只包括搜索表单参数的原始查询。这样做非常简单，让我们来看一下。
- en: 'In `main/views.py`, right before the `render()` call in the `get() HomeView`
    method, add this code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/views.py`中，在`get() HomeView`方法的`render()`调用之前，添加以下代码：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `main/templates/home.html`, add this right after the categories `ul` tag
    ends:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/templates/home.html`中，在类别`ul`标签结束后添加以下内容：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That''s it. Try using the search now, and select a category. You should see
    a **Remove Category Filter** link that you can use to remove any category search
    terms. It should look similar to this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在尝试使用搜索，选择一个类别。你应该会看到一个**删除类别过滤器**链接，你可以用它来删除任何类别搜索条件。它应该看起来类似于这样：
- en: '![Searching with aggregations](img/00698_06_08.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![使用聚合进行搜索](img/00698_06_08.jpg)'
- en: One thing that you might have noticed is that when any category is selected,
    we no longer see the other categories. That's because Elasticsearch aggregations
    are, by default, scoped to the main query. Thus, any terms aggregation will only
    count documents that are already present in the results of the main query. When
    the search includes a category query, the categories aggregation we have will
    only be able to find documents in the selected category. To change this behavior
    and show all categories, regardless of what is selected by the user, is beyond
    the scope of the book. However, I will point you in the right direction, and with
    some work, you should be able to achieve this yourself. Have a look at [https://www.elastic.co/guide/en/elasticsearch/guide/current/_scoping_aggregations.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/_scoping_aggregations.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到的一件事是，当选择了任何类别后，我们就不再看到其他类别了。这是因为Elasticsearch的聚合默认是限定于主查询的。因此，任何术语聚合只会计算已经存在于主查询结果中的文档。当搜索包括类别查询时，我们拥有的类别聚合只能找到所选类别中的文档。要改变这种行为并显示所有类别，无论用户选择了什么，超出了本书的范围。然而，我会指引你正确的方向，通过一些工作，你应该能够自己实现这一点。看一下[https://www.elastic.co/guide/en/elasticsearch/guide/current/_scoping_aggregations.html](https://www.elastic.co/guide/en/elasticsearch/guide/current/_scoping_aggregations.html)。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! This was a pretty heavy chapter. We looked at a lot of things and gained
    a lot of knowledge. Especially where Elasticsearch was concerned, we went from
    0-60 pretty quickly, having it set up and running searches within the first 10
    pages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个相当深奥的章节。我们看了很多东西，获得了很多知识。特别是在涉及到Elasticsearch的时候，我们很快地从0到60，在前10页内就设置好并运行了搜索。
- en: However, I am confident that by now you should be able to pick up complicated
    concepts with ease. We first looked at how to get Elasticsearch up and running
    on our local systems. Then we looked at how we could easily interact with Elaticsearch
    using its HTTP API. We looked at the basic concepts for Elasticsearch and then
    inserted a few documents into our first index.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我相信到现在你应该能够轻松掌握复杂的概念。我们首先看了如何在本地系统上启动Elasticsearch。然后我们看了如何使用它的HTTP API轻松地与Elasticsearch进行交互。我们了解了Elasticsearch的基本概念，然后向我们的第一个索引插入了一些文档。
- en: Then we used the HTTP API to search for those documents and get back results.
    Once we had an overview of what Elasticsearch was and how it worked, we moved
    toward integrating it with our Django applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用HTTP API来搜索这些文档并获取结果。一旦我们了解了Elasticsearch是什么以及它是如何工作的，我们就开始将其与我们的Django应用程序集成。
- en: We again saw the power of using the Django shell to test out libraries quickly
    and find out how to approach various tasks, as we did while indexing and searching
    for documents using the `elasticsearch_dsl` library. We then created a Django
    command that essentially was just a copy of whatever we did in the Django shell
    before.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到了使用Django shell快速测试库并找出如何处理各种任务的能力，就像我们在使用`elasticsearch_dsl`库对文档进行索引和搜索时所做的那样。然后我们创建了一个Django命令，基本上只是复制了我们之前在Django
    shell中所做的事情。
- en: Then we really started working on our search view. We changed the home page
    to use Elasticsearch instead of the database to show our products and added a
    basic search for the name field. Next, we looked at how to manage configuration
    options for our applications from a central location, `AppConfig`. We also looked
    at how to use `elasticsearch_dsl` to do a bit more complicated query, the range
    query.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们真正开始处理我们的搜索视图。我们将主页更改为使用Elasticsearch而不是数据库来显示我们的产品，并添加了对名称字段的基本搜索。接下来，我们看了如何从一个中央位置`AppConfig`管理我们应用的配置选项。我们还学习了如何使用`elasticsearch_dsl`来执行更复杂的查询，比如范围查询。
- en: Finally, we looked at what Elasticsearch aggregations were and how we could
    integrate them into our application to provide our users with a great search experience.
    All in all, this was a complicated chapter and having finished it, you should
    now have the confidence to approach much larger and feature-rich applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Elasticsearch聚合是什么，以及我们如何将它们整合到我们的应用程序中，为用户提供出色的搜索体验。总的来说，这是一个复杂的章节，完成后，你现在应该有信心去处理更大型和功能丰富的应用程序。
