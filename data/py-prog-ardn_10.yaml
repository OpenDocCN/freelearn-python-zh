- en: Chapter 10. The Final Project – a Remote Home Monitoring System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 最终项目 – 一个远程家庭监控系统
- en: It is now time to combine every topic that we learned in the previous chapters
    into a project that combines Arduino programming, Python GUI development, MQTT
    messaging protocol, and a Python-based cloud application. As you might have already
    figured out from the chapter title, we are going to develop a remote home monitoring
    system using these components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们在前几章中学到的每个主题结合起来，创建一个结合Arduino编程、Python GUI开发、MQTT消息协议和基于Python的云应用的项目。正如你可能已经从章节标题中推测出的那样，我们将使用这些组件开发一个远程家庭监控系统。
- en: The first section of the chapter covers the project design process, including
    goals, requirements, architecture, and UX. Once we are done with the design process,
    we will jump into the actual development of the project, which is divided into
    three separate stages. Next, we will cover common troubleshooting topics that
    are usually faced while working with large projects. In our efforts to develop
    utilizable DIY projects, the later section covers tips and features to extend
    the project. As this is quite a large project compared to other projects in the
    book, we are not going to jump straight into the actual development process without
    having any strategy. Let's start by getting ourselves familiar with the standard
    design methodology for hardware projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分涵盖了项目设计过程，包括目标、需求、架构和UX。一旦我们完成设计过程，我们将进入项目的实际开发，这分为三个独立阶段。接下来，我们将涵盖在处理大型项目时通常会遇到的一些常见故障排除主题。在我们努力开发可用的DIY项目时，后面的部分涵盖了扩展项目的技巧和功能。由于与其他书籍中的项目相比，这是一个相当大的项目，我们不会在没有任何策略的情况下直接进入实际开发过程。让我们首先熟悉硬件项目的标准设计方法。
- en: The design methodology for IoT projects
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网项目的设计方法
- en: 'The process of developing a complex product that tightly couples hardware devices
    with high-level software services requires an additional level of planning. For
    this project, we will exercise a proper product development approach to help you
    get familiar with the process of creating real-world hardware projects. This method
    can then be used to plan your own projects and take them to the next level. The
    following diagram describes a typical prototype development process, which always
    begins by defining the major goals that you want to achieve with your product:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个将硬件设备与高级软件服务紧密耦合的复杂产品需要额外的规划层次。对于这个项目，我们将采用适当的产品开发方法，帮助你熟悉创建真实世界硬件项目的流程。然后，可以使用这种方法来规划你自己的项目并将它们提升到下一个层次。以下图表描述了一个典型的原型开发过程，它始终从定义你希望通过产品实现的主要目标开始：
- en: '![The design methodology for IoT projects](img/5938OS_10_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![物联网项目的设计方法](img/5938OS_10_01.jpg)'
- en: Once you have defined the set of major goals, you need to break them down into
    project requirements that include every detail of the tasks that your prototype
    should execute to achieve these goals. Using the project requirements, you need
    to sketch out the overall architecture of the system. The next step includes the
    process of defining the UX flow that will help you to lay out the user interaction
    points for your system. At this stage, you will be able to identify any changes
    that are required in the system architecture and the hardware and software components
    to start the development.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了主要目标集合，你需要将它们分解成项目需求，这些需求包括实现这些目标时原型应执行的每个任务的详细信息。使用项目需求，你需要勾勒出系统的整体架构。下一步包括定义UX流程的过程，这将帮助你规划系统的用户交互点。在这个阶段，你将能够识别系统架构、硬件和软件组件中所需的所有更改，以便开始开发。
- en: As you have defined the interaction points, now you need to distribute the entire
    project development process into multiple stages and delegate the tasks between
    these stages. Once you have completed the development of these stages, you will
    have to interface these stages with each other according to your architecture
    and debug the components if it is needed. At the end, you will have to test your
    project as a whole system and troubleshoot minor problems. In hardware projects,
    it is very difficult to work on your electric circuits again after the completion
    of complex development processes, as the changes can have recurring effects on
    all other components. This process will help you to minimize any hardware rework
    and subsequent software modifications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经定义了交互点，现在你需要将整个项目开发过程分成多个阶段，并在这些阶段之间分配任务。一旦你完成了这些阶段的发展，你将不得不根据你的架构将这些阶段相互连接，并在需要时调试组件。最后，你必须将你的项目作为一个整体系统进行测试，并解决小问题。在硬件项目中，在复杂开发过程完成后再次处理你的电线路是非常困难的，因为变化可能会对所有其他组件产生重复影响。这个过程将帮助你最小化任何硬件返工和随后的软件修改。
- en: Now that you have learned about the methodology, let's begin with the actual
    development process for our remote home monitoring system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了方法论，让我们开始实际开发我们的远程家庭监控系统。
- en: Project overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The smart home is one of the most well-defined and popular subdomains of the
    IoT. The most important feature of any smart home is its capability to monitor
    the physical environment. Fortunately, the exercises and projects that we covered
    in the previous chapters include components and features that can be used for
    the same purpose. In this chapter, we are going to define a project that will
    utilize these existing components and programming exercises. In the midterm project
    of [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*, we created a deployable thermostat
    with the ability to measure temperature, humidity, and ambient light. If we want
    to utilize this midterm project, the nearest IoT project that we can build on
    top of it is the remote home monitoring system. The project will have Arduino
    as the main point of interaction between the physical environment and the software-based
    services. We will have a Python program as the middle layer, which will bridge
    the sensor information coming from Arduino with the user-facing graphical interface.
    Let's start by defining the goals that we want to achieve and the project requirements
    to satisfy these goals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居是物联网中最定义明确且最受欢迎的子领域之一。任何智能家居最重要的功能是其监控物理环境的能力。幸运的是，我们在前几章中涵盖的练习和项目包括可用于相同目的的组件和功能。在本章中，我们将定义一个将利用这些现有组件和编程练习的项目。在[第7章](ch07.html
    "第7章。中期项目 – 便携式DIY恒温器")的中期项目中，即“中期项目 – 便携式DIY恒温器”，我们创建了一个可部署的恒温器，能够测量温度、湿度和环境光线。如果我们想利用这个中期项目，我们可以在其基础上构建的最近的物联网项目是远程家庭监控系统。该项目将以Arduino作为物理环境和基于软件的服务之间的主要交互点。我们将有一个Python程序作为中间层，它将连接来自Arduino的传感器信息与面向用户的图形界面。让我们首先定义我们想要实现的目标以及满足这些目标的项目需求。
- en: The project goals
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目目标
- en: The Nest thermostat provides an idea of the type of features that a properly
    designed remote monitoring system with professional features should have. Achieving
    this level of system capabilities requires a lot of development effort from a
    large team. Although it will be difficult to include each of the features that
    are supported by a commercial system in our project, we will still try to implement
    the common features that can be incorporated by a prototype project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nest恒温器提供了一个关于一个设计良好的远程监控系统应具备的特性的例子，该系统具有专业功能。实现这一级别的系统能力需要来自大型团队的大量开发工作。尽管很难在我们的项目中包含商业系统支持的每个功能，但我们仍将尝试实现原型项目可以整合的常见功能。
- en: The top-level features that we are planning to incorporate in this project can
    be described by the following goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在这个项目中整合的顶级功能可以通过以下目标来描述。
- en: Observe the physical environment and make it accessible remotely
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察物理环境并使其远程可访问
- en: Provide basic level controls to the user to interact with the system
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户提供基本级别的控制以与系统交互
- en: Demonstrate a primitive level of built-in situational awareness
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示基本的内置情境意识
- en: The project requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目需求
- en: 'Now that we have defined the major goals, let''s convert them into detailed
    system requirements. On the completion of the project, the system should be able
    to satisfy the following requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了主要目标，让我们将它们转换为详细的系统需求。项目完成后，系统应能够满足以下要求：
- en: It must be able to observe physical phenomenon such as temperature, humidity,
    motion, and ambient light.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够观察物理现象，如温度、湿度、运动和周围光线。
- en: It should provide local access to sensor information and control over actuators
    such as a buzzer, a button switch, and an LED.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应提供对传感器信息和执行器（如蜂鸣器、按钮开关和LED）的本地访问和控制。
- en: The monitoring should be done by a unit that is developed using the open source
    hardware platform, Arduino.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控应由使用开源硬件平台Arduino开发的单元进行。
- en: The monitoring unit should be limited to collect sensor information and communicate
    it to the control unit.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控单元应限于收集传感器信息并将其传达给控制单元。
- en: The control unit should not comprise of a desktop computer or laptop. Instead,
    it should be made deployable using a platform such as a Raspberry Pi.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元不应包含台式计算机或笔记本电脑。相反，它应该使用像Raspberry Pi这样的平台来部署。
- en: The control unit should demonstrate a primitive level of situation awareness
    capability by utilizing the collected sensor information.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元应通过利用收集到的传感器信息展示原始级别的态势感知能力。
- en: The control unit should have a graphical interface to provide the sensor's observation
    and the current state of the system.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元应具有图形界面，以提供传感器的观察结果和系统的当前状态。
- en: The system must be accessible via the Internet using cloud-based services.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统必须通过基于云的服务通过互联网访问。
- en: The web application that provides remote access should have the capability to
    display the sensor's observations through a web browser.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供远程访问的Web应用程序应具有通过Web浏览器显示传感器观察结果的能力。
- en: The system should also provide basic control of the actuators to complete the
    remote access experience by using the web application.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统还应提供对执行器的基本控制，通过使用Web应用程序完成远程访问体验。
- en: As the monitoring unit can be constrained by computation resources, the system
    should use hardware-oriented messaging protocols to transfer information.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于监控单元可能受到计算资源的限制，系统应使用面向硬件的消息协议来传输信息。
- en: Although there are many other minor requirements that can be part of our project,
    they have been skipped in this book. If you have any additional plans for your
    remote home monitoring system, this is the time that you must define these requirements
    before you jump into designing the architecture. Any future changes to the requirements
    can significantly affect the development stage and make hardware and software
    modification difficult. In the last section of the chapter, we have laid down
    a number of additional features that you may want to consider implementing for
    your future projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有许多其他可能成为我们项目一部分的次要要求，但它们在这本书中被省略了。如果你对你的远程家庭监控系统有任何额外的计划，这是你必须在你开始设计架构之前定义这些要求的时候。对需求的任何未来更改都可能显著影响开发阶段，并使硬件和软件修改变得困难。在章节的最后部分，我们列出了一些你可能希望考虑实现于未来项目的附加功能。
- en: Designing system architecture
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计系统架构
- en: 'Continuing from project goals, first, you need to sketch out a high-level architecture
    of the system. This architectural sketch should include major components that
    enable the system to pass on information between the sensors and the remote users.
    The following figure shows an architectural sketch for our project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目目标继续，首先，你需要绘制出系统的概要架构。这个架构草图应包括使系统能够在传感器和远程用户之间传递信息的主要组件。以下图显示了我们的项目架构草图：
- en: '![Designing system architecture](img/5938OS_10_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![设计系统架构](img/5938OS_10_02.jpg)'
- en: According to the goals, the user should be able to access the system using the
    Internet; this means that we need cloud components in the architecture. The system
    also needs to monitor the physical environment using a resource-constrained device,
    and this can be executed using Arduino. The middle layer, which connects the cloud
    service and the sensor system, can be built using a Raspberry Pi. In the last
    project, we connected Arduino and the Raspberry Pi using a serial connection,
    but we want to move away from serial connections and start using our home's Ethernet
    network to make the system deployable. Hence, the Arduino-based unit is connected
    to the network using Ethernet while the Raspberry Pi uses Wi-Fi to connect to
    the same network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标，用户应能够通过互联网访问系统；这意味着我们需要在架构中包含云组件。系统还需要使用资源受限的设备来监控物理环境，这可以使用Arduino实现。连接云服务和传感器系统的中间层可以使用Raspberry
    Pi构建。在上一个项目中，我们通过串行连接连接了Arduino和Raspberry Pi，但我们希望摆脱串行连接，开始使用我们家的以太网网络来使系统可部署。因此，基于Arduino的单元通过以太网连接到网络，而Raspberry
    Pi则使用Wi-Fi连接到同一网络。
- en: 'In order to lay out the overall system architecture, let''s utilize the sketch
    that we designed, which can be seen in the preceding figure. As you can see in
    the next figure, we have converted the overall system into three main architectural
    units:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了布局整体系统架构，让我们利用我们设计的草图，如图所示。正如您在下一张图中可以看到的，我们将整体系统转换成了三个主要架构单元：
- en: Monitoring station
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控站
- en: Control center
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制中心
- en: Cloud service
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务
- en: In this figure, we have addressed each and every major component that we are
    going to utilize in the project along with their association to each other. In
    the following sections, we are going to define these three main units briefly.
    The comprehensive description and implementation steps for these units are provided
    later in the chapter under separate sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们已经针对我们将要利用的每个主要组件及其相互关联进行了说明。在接下来的章节中，我们将简要定义这三个主要单元。这些单元的详细描述和实现步骤将在本章的单独部分提供。
- en: '![Designing system architecture](img/5938OS_10_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设计系统架构](img/5938OS_10_03.jpg)'
- en: The monitoring station
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控站
- en: We need a resource-constrained and robust unit that will communicate with the
    physical environment periodically. This monitoring unit can be built using Arduino
    since low-level microcontroller programming can provide uninterrupted stream of
    sensor data. The usage of Arduino at this stage will also help us to avoid the
    direct interfacing of basic low-level sensors with computers that are running
    on complex operating systems. The sensors and the actuators are connected to Arduino
    using digital, analog, PWM, and I2C interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个资源受限且健壮的单元，该单元将定期与物理环境进行通信。这个监控单元可以使用Arduino构建，因为低级微控制器编程可以提供不间断的传感器数据流。在这个阶段使用Arduino也将帮助我们避免将基本低级传感器直接与运行在复杂操作系统上的计算机进行接口连接。传感器和执行器通过数字、模拟、PWM和I2C接口连接到Arduino。
- en: The control center
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制中心
- en: The control center behaves as the main user interaction point between the sensor
    information and the user. It is also responsible for conveying the sensor information
    from the monitoring station to the cloud services. The control center can be developed
    using your regular computer or a single-board computer such as a Raspberry Pi.
    We are going to utilize a Raspberry Pi since it can be easily deployed as a hardware
    unit and it is also capable enough at hosting Python programs. We will replace
    a computer screen with a small TFT LCD screen for the Raspberry Pi to display
    the GUI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心作为传感器信息和用户之间的主要交互点。它还负责将监控站中的传感器信息传递到云服务。控制中心可以使用您的普通计算机或单板计算机（如Raspberry
    Pi）开发。我们将使用Raspberry Pi，因为它可以轻松部署为硬件单元，并且它也足以托管Python程序。我们将用一个小型TFT LCD屏幕替换Raspberry
    Pi的计算机屏幕来显示GUI。
- en: The cloud services
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云服务
- en: The main purpose of the cloud services is to provide an Internet-based interface
    for the control center so that the user can access it remotely. Before we host
    a web application to perform this operation, we will need an intermediate data
    relay. This sensor data relay works as a host between the cloud-based web application
    and the control center. In this project, we will be using Xively as the platform
    to collect this sensor data. The web application can be hosted on an Internet
    server; in our case, we are going to use Amazon AWS due to our familiarity with
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务的主要目的是为控制中心提供一个基于互联网的接口，以便用户可以远程访问它。在我们托管一个网络应用程序来执行此操作之前，我们需要一个中间数据中继。这个传感器数据中继充当基于云的网络应用程序和控制中心之间的主机。在这个项目中，我们将使用Xively作为平台来收集这些传感器数据。网络应用程序可以托管在互联网服务器上；在我们的情况下，我们将使用我们熟悉的Amazon
    AWS。
- en: Defining UX flow
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义UX流程
- en: Now, although we know what the architecture of the overall system looks like,
    we haven't defined how the user is going to interact with it. This process of
    designing user interaction for our system will also help us to figure out data
    flow between major components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管我们知道整个系统的架构看起来是什么样子，但我们还没有定义用户将如何与之交互。为我们的系统设计用户交互的过程也将帮助我们弄清楚主要组件之间的数据流。
- en: Let's begin with the components that are operating locally at your house, that
    is, the monitoring station and the control center. As you can see from the following
    figure, we have our first user interaction point at the control center. The user
    can observe the information or act upon it if the system's status is an alert.
    The user action to dismiss the alert prompts multiple operations to take place
    at the control center and the monitoring station. We recommend you thoroughly
    examine the figure to better understand the flow of the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从您家中本地运行的组件开始，即监测站和控制中心。如图所示，我们在控制中心有我们的第一个用户交互点。用户可以观察信息或对其采取行动，如果系统状态是警报。取消警报的用户操作会在控制中心和监测站引发多个操作。我们建议您仔细查看图表，以更好地理解系统的流程。
- en: '![Defining UX flow](img/5938OS_10_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![定义UX流程](img/5938OS_10_04.jpg)'
- en: 'Similarly, the second user interaction point is located at the web application.
    The web application displays the observations and system''s status that we calculated
    at the control center and provides an interface to dismiss the alert. In this
    scenario, the dismiss action will travel through Xively to the control center
    where the appropriate actions for the control center will remain the same as in
    the previous scenario. However, in the web application, the user has to load the
    web browser every time to request the data, which was happening automatically
    at the control center. Take a look at the following figure to understand the UX
    flow for the web application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第二个用户交互点位于网络应用程序中。网络应用程序显示我们在控制中心计算出的观察结果和系统状态，并提供一个界面来取消警报。在这种情况下，取消操作将通过Xively传输到控制中心，控制中心的适当操作将与之前的情况相同。然而，在网络应用程序中，用户每次都必须加载网络浏览器来请求数据，而这在控制中心是自动发生的。请查看以下图表以了解网络应用程序的用户体验流程：
- en: '![Defining UX flow](img/5938OS_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![定义UX流程](img/5938OS_10_05.jpg)'
- en: The list of required components
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需组件列表
- en: 'The necessary components for the project are derived using three main criteria:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 项目所需组件是根据以下三个主要标准推导出来的：
- en: Ease of availability
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于获取
- en: Compatibility with the Arduino board
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Arduino板兼容
- en: Familiarity with the components due to previous utilization in this book
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在此书中之前的使用而熟悉组件
- en: This is the list of the components that you will need to start working on the
    project. If you have completed the previous exercises and projects, you should
    already have most of the components. If you don't want to disassemble the projects,
    you can obtain them from the websites of SparkFun, Adafruit, or Amazon, whose
    links are provide in the next table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您开始项目所需的组件列表。如果您已经完成了之前的练习和项目，您应该已经拥有了大部分组件。如果您不想拆解项目，您可以从SparkFun、Adafruit或Amazon的网站上获取它们，这些网站的链接将在下一表中提供。
- en: 'The hardware components for the monitoring station are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 监测站点的硬件组件如下：
- en: '| Component (first stage) | Quantity | Link |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 组件（第一阶段） | 数量 | 链接 |'
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
- en: '| Arduino Ethernet Shield | 1 | [https://www.sparkfun.com/products/9026](https://www.sparkfun.com/products/9026)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| Arduino 以太网盾 | 1 | [https://www.sparkfun.com/products/9026](https://www.sparkfun.com/products/9026)
    |'
- en: '| Breadboard | 1 | [https://www.sparkfun.com/products/9567](https://www.sparkfun.com/products/9567)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 面包板 | 1 | [https://www.sparkfun.com/products/9567](https://www.sparkfun.com/products/9567)
    |'
- en: '| TMP102 temperature sensor | 1 | [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| TMP102 温度传感器 | 1 | [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)
    |'
- en: '| HIH-4030 humidity sensor | 1 | [https://www.sparkfun.com/products/9569](https://www.sparkfun.com/products/9569)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| HIH-4030 湿度传感器 | 1 | [https://www.sparkfun.com/products/9569](https://www.sparkfun.com/products/9569)
    |'
- en: '| Mini photocell | 1 | [https://www.sparkfun.com/products/9088](https://www.sparkfun.com/products/9088)
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 小型光敏电阻 | 1 | [https://www.sparkfun.com/products/9088](https://www.sparkfun.com/products/9088)
    |'
- en: '| PIR motion sensor | 1 | [https://www.sparkfun.com/products/8630](https://www.sparkfun.com/products/8630)
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| PIR 运动传感器 | 1 | [https://www.sparkfun.com/products/8630](https://www.sparkfun.com/products/8630)
    |'
- en: '| Super-flux RGB LED, common anode | 1 | [http://www.adafruit.com/product/314](http://www.adafruit.com/product/314)
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 超亮 RGB LED，共阳极 | 1 | [http://www.adafruit.com/product/314](http://www.adafruit.com/product/314)
    |'
- en: '| Buzzer | 1 | [http://www.adafruit.com/products/160](http://www.adafruit.com/products/160)
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 蜂鸣器 | 1 | [http://www.adafruit.com/products/160](http://www.adafruit.com/products/160)
    |'
- en: '| Push button switch | 1 | [https://www.sparkfun.com/products/97](https://www.sparkfun.com/products/97)
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 按钮开关 | 1 | [https://www.sparkfun.com/products/97](https://www.sparkfun.com/products/97)
    |'
- en: '| USB cable for Arduino(for development stage) | 1 | [https://www.sparkfun.com/products/512](https://www.sparkfun.com/products/512)
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Arduino 开发阶段用 USB 线 | 1 | [https://www.sparkfun.com/products/512](https://www.sparkfun.com/products/512)
    |'
- en: '| Arduino power supply(for deployment stage) | 1 | [http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/](http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Arduino 部署阶段电源 | 1 | [http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/](http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/)
    |'
- en: '| Resistors | As required | 220 ohm, 1 kilo-ohm, and 10 kilo-ohm |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 电阻 | 如需 | 220 欧姆、1 千欧姆和 10 千欧姆 |'
- en: '| Connection wires | As required |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 连接线 | 如需 | 无 |'
- en: 'The hardware components for the control center are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心的硬件组件如下：
- en: '| Component (first stage) | Quantity | Link |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 组件（第一阶段） | 数量 | 链接 |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Raspberry Pi | 1 | [https://www.sparkfun.com/products/11546](https://www.sparkfun.com/products/11546)
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 | 1 | [https://www.sparkfun.com/products/11546](https://www.sparkfun.com/products/11546)
    |'
- en: '| TFT LCD screen | 1 | [http://www.amazon.com/gp/product/B00GASHVDU/](http://www.amazon.com/gp/product/B00GASHVDU/)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| TFT LCD 屏幕 | 1 | [http://www.amazon.com/gp/product/B00GASHVDU/](http://www.amazon.com/gp/product/B00GASHVDU/)
    |'
- en: '| SD card (8 GB) | 1 | [https://www.sparkfun.com/products/12998](https://www.sparkfun.com/products/12998)
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| SD 卡（8 GB） | 1 | [https://www.sparkfun.com/products/12998](https://www.sparkfun.com/products/12998)
    |'
- en: '| Wi-Fi dongle | 1 | [http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY](http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY)
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Wi-Fi 拓展卡 | 1 | [http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY](http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY)
    |'
- en: '| Raspberry Pi power supply | 1 | [http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0](http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0)
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派电源 | 1 | [http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0](http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0)
    |'
- en: '| Keyboard, mouse, USB hub, and monitor | As required | Requried for development
    and debugging stages |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 键盘、鼠标、USB 集线器和显示器 | 如需 | 开发和调试阶段所需 |'
- en: Defining the project development stages
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义项目开发阶段
- en: 'As per the system architecture, we have three main units that collaboratively
    create the remote home monitoring project. The overall hardware and software development
    process is also aligned with these three units and can be distributed as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统架构，我们拥有三个主要单元，它们协同创建远程家庭监控系统项目。整体硬件和软件开发流程也与这三个单元相一致，可以如下分配：
- en: Monitoring station development stage
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控站开发阶段
- en: Control center development stage
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制中心开发阶段
- en: Web application development stage
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序开发阶段
- en: The software development for the monitoring station stage includes developing
    the Arduino code to monitor sensors and perform actuator actions on one side,
    while publishing this information to the control center on the other side. The
    middle layer of the development stage, that is, the Raspberry Pi-based control
    center, hosts the Mosquitto broker. This stage also contains the Python program
    that contains the GUI, situation awareness logic, and subroutines to communicate
    with the Xively cloud service. The last stage, the cloud services, includes two
    distinct components, sensor data relay and a web application. We will be using
    the Xively platform as our sensor data relay and the web application will be developed
    in Python on the Amazon AWS cloud instance. Now, let's jump into the actual development
    process and our first stop will be the Arduino-based monitoring station.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 监控站阶段的软件开发包括编写Arduino代码以监控传感器并执行执行器动作，同时将此信息发布到控制中心。开发阶段的中间层，即基于Raspberry Pi的控制中心，托管了Mosquitto代理。此阶段还包括包含GUI、态势感知逻辑和与Xively云服务通信的子例程的Python程序。最后阶段，云服务，包括两个不同的组件，传感器数据中继和Web应用程序。我们将使用Xively平台作为我们的传感器数据中继，并将使用Python在Amazon
    AWS云实例上开发Web应用程序。现在，让我们进入实际的开发过程，我们的第一个目的地将是基于Arduino的监控站。
- en: Stage 1 – a monitoring station using Arduino
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1阶段 - 使用Arduino的监控站
- en: As we discussed, the main tasks of the monitoring systems are to interface sensor
    components and communicate the information generated by these sensors to the observers.
    You will be using Arduino Uno as the central microcontroller component to integrate
    these sensors and actuators. We also need a means of communication between the
    Arduino Uno and the control center and we will be utilizing the Arduino Ethernet
    Shield for this purpose. Let's discuss the hardware architecture of the monitoring
    station and its components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，监控系统的主要任务是接口传感器组件并将这些传感器生成的信息传达给观察者。你将使用Arduino Uno作为中央微控制器组件来集成这些传感器和执行器。我们还需要Arduino
    Uno和控制中心之间的通信手段，我们将利用Arduino以太网盾来实现这一目的。让我们讨论监控站的硬件架构及其组件。
- en: Designing the monitoring station
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计监控站
- en: We already designed units based on Arduino and the Ethernet Shield in various
    exercises in [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"),
    *Introduction to Arduino Networking*, and [Chapter 9](ch09.html "Chapter 9. Arduino
    and the Internet of Things"), *Arduino and the Internet of Things*. Therefore,
    we have assumed that you are familiar with interfacing the Ethernet Shield with
    the Arduino board. We will connect various sensors and actuators with the Arduino
    board, as displayed in the following diagram. As you can see in this diagram,
    the sensors will provide the data to the Arduino board while the actuators will
    seek the data from the Arduino board. Although we are automatically collecting
    environment data for these sensors, the data from the button will be collected
    from manual user inputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第8章](ch08.html "第8章。Arduino网络介绍")“Arduino网络介绍”和[第9章](ch09.html "第9章。Arduino与物联网")“Arduino与物联网”的各种练习中设计了基于Arduino和以太网盾的单元。因此，我们假设你已经熟悉将以太网盾与Arduino板进行接口。我们将使用Arduino板连接各种传感器和执行器，如下面的图所示。如图所示，传感器将向Arduino板提供数据，而执行器将从Arduino板获取数据。尽管我们自动收集这些传感器的环境数据，但按钮的数据将通过手动用户输入进行收集。
- en: '![Designing the monitoring station](img/5938OS_10_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_06.jpg)'
- en: Check out the following Fritzing diagram for the detailed connections in the
    monitoring station. As you can see in our hardware design, the temperature sensor
    TMP102 is connected through the I2C interface, which means that we will need the
    SDA and SCL lines. We will be using analog pins 5 and 6 of the Arduino board to
    interface SDA and SCL respectively. The humidity (HIH-4030) and ambient light
    sensors also provide analog output and are connected to the analog pins of the
    Arduino board. Meanwhile, the buzzer, the button switch, and the PIR motion sensor
    are connected through the digital I/O pins. The super-flux RGB LED is a common
    anode LED; this means that it is always powered using the common anode pins and
    the R, G, and B pins are controlled by using the PWM pins.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下Fritzing图以了解监控站中的详细连接。正如你在我们的硬件设计中看到的那样，温度传感器TMP102通过I2C接口连接，这意味着我们需要SDA和SCL线。我们将使用Arduino板的模拟引脚5和6来分别接口SDA和SCL。湿度（HIH-4030）和环境光传感器也提供模拟输出，并连接到Arduino板的模拟引脚。同时，蜂鸣器、按钮开关和PIR运动传感器通过数字I/O引脚连接。超级流明RGB
    LED是正极LED；这意味着它总是使用正极引脚供电，而R、G和B引脚通过PWM引脚控制。
- en: 'Make sure that you properly connect all the components to the pins that are
    specified in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将所有组件正确连接到以下图中指定的引脚：
- en: '![Designing the monitoring station](img/5938OS_10_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_07.jpg)'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the interfacing of RGB LED with Arduino from the tutorial
    at [https://learn.adafruit.com/all-about-leds](https://learn.adafruit.com/all-about-leds).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://learn.adafruit.com/all-about-leds](https://learn.adafruit.com/all-about-leds)教程中了解更多关于RGB
    LED与Arduino接口的信息。
- en: If you are using an Arduino board other than Arduino Uno, you will have to adjust
    the appropriate pin numbers in the Arduino code. In addition, make sure that this
    Arduino board is compatible with the Ethernet Shield.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是除Arduino Uno以外的Arduino板，你将不得不在Arduino代码中调整适当的引脚编号。此外，确保这个Arduino板与以太网盾兼容。
- en: In terms of circuit connections, you can use a breadboard as shown in the previous
    diagram, or if you are comfortable, you can use a PCB prototype board and solder
    the components. In our setup, we first tested the components on the breadboard
    and once they were tested, we soldered the components, as shown in the following
    figure. If you venture to solder the PCB board, make sure that you have the necessary
    components for the job. The PCB prototype will yield a robust performance compared
    to the breadboard, but it will also make it difficult for you to debug and change
    the components afterwards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路连接方面，你可以使用前面图中所示的面包板，或者如果你感到舒适，你可以使用PCB原型板并焊接组件。在我们的设置中，我们首先在面包板上测试了组件，一旦测试通过，我们就焊接了组件，如图所示。如果你尝试焊接PCB板，请确保你有完成这项工作的必要组件。与面包板相比，PCB原型板将提供更坚固的性能，但这也将使你在之后调试和更换组件变得困难。
- en: '![Designing the monitoring station](img/5938OS_10_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_08.jpg)'
- en: If you are ready with your circuit connection, connect your Arduino to your
    computer using the USB cable. Also, connect the Ethernet Shield to your home router
    using an Ethernet cable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经准备好了电路连接，请使用USB线将Arduino连接到你的电脑。同时，使用以太网线将以太网盾连接到你的家庭路由器。
- en: The Arduino sketch for the monitoring station
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控站的Arduino草图
- en: Before jumping into the coding stage, make sure that you have collected the
    prebuilt Arduino code for the project. You can find it in the code folder of this
    chapter with the filename `Arduino_monitoring_station.ino`. The code implements
    the necessary logic to support the overall UX flow at the monitoring station,
    which we discussed in the previous section. In the following sections, we will
    go through the major areas of the program so that you can better understand these
    code snippets. Now, open this sketch in the Arduino IDE. You are already familiar
    with setting up the IP address for Arduino. You also learned how to use the Arduino
    MQTT library `PubSubClient` in the previous chapter, which means that your Arduino
    IDE should already have the `PubSubClient` library installed on it. At the beginning
    of the code, we have also declared few constants, such as the IP addresses of
    the MQTT server and Arduino and the pin numbers of various sensor and actuators.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入编码阶段之前，请确保你已经收集了项目的预构建Arduino代码。你可以在本章的代码文件夹中找到它，文件名为`Arduino_monitoring_station.ino`。该代码实现了支持监控站整体UX流程所需的基本逻辑，这是我们之前章节中讨论过的。在接下来的章节中，我们将逐一介绍程序的主要部分，以便你更好地理解这些代码片段。现在，在Arduino
    IDE中打开这个草图。你已经熟悉了为Arduino设置IP地址。在上一个章节中，你也学习了如何使用Arduino MQTT库`PubSubClient`，这意味着你的Arduino
    IDE上应该已经安装了`PubSubClient`库。在代码的开头，我们还声明了一些常量，例如MQTT服务器的IP地址和Arduino的IP地址，以及各种传感器和执行器的引脚号。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will have to change the IP address of the monitoring station and the control
    center according to your network setup. Make sure that you perform these modifications
    before uploading the Arduino code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据你的网络设置更改监控站和控制中心的IP地址。确保在上传Arduino代码之前执行这些修改。
- en: In the code structure, we have two mandatory Arduino functions, `setup()` and
    `loop()`. In the `setup()` function, we will set up the Arduino pin types and
    the MQTT subscriber channels. In the same function, we will also attach an interrupt
    for the press of the button while setting up the timer for the `publishData()`
    function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码结构中，我们有两个强制性的Arduino函数，`setup()`和`loop()`。在`setup()`函数中，我们将设置Arduino引脚类型和MQTT订阅通道。在同一个函数中，我们还将设置一个用于`publishData()`函数的计时器，并附加一个按钮按下时的中断。
- en: Publishing sensor information
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布传感器信息
- en: 'The `publishData()` function reads the sensor inputs and publishes this data
    to the Mosquitto broker that is located on the control center. As you can see
    in the following code snippet, we are measuring sensors values one by one and
    publishing them to the broker using the `client.publish()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`publishData()`函数读取传感器输入，并将这些数据发布到位于控制中心的Mosquitto代理。正如你在下面的代码片段中可以看到的，我们正在逐个测量传感器值，并使用`client.publish()`方法将它们发布到代理：'
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you check out the `setup()` function, you will notice that we have used
    a library called `SimpleTimer` to set up a `timer` method for this function. This
    method executes the `publishData()` function periodically without interrupting
    and blocking the actual flow of the Arduino execution cycle. In the following
    code snippet, the number `300000` represents the time delay in milliseconds, that
    is, 5 minutes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`setup()`函数，你会注意到我们使用了一个名为`SimpleTimer`的库来为这个函数设置一个`timer`方法。该方法定期执行`publishData()`函数，而不会中断和阻塞Arduino执行周期的实际流程。在下面的代码片段中，数字`300000`代表毫秒级的延迟时间，即5分钟：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to download and import the `SimpleTimer` library to compile and
    run the code successfully. You can download the library from [https://github.com/infomaniac50/SimpleTimer](https://github.com/infomaniac50/SimpleTimer).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载并导入`SimpleTimer`库才能成功编译和运行代码。你可以从[https://github.com/infomaniac50/SimpleTimer](https://github.com/infomaniac50/SimpleTimer)下载该库。
- en: Subscribing to actuator actions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅执行器动作
- en: 'You can see in the `setup()` function that we are initializing the code by
    subscribing to the `MonitoringStation/led` and `MonitoringStation/buzzer` channels.
    The `client.subscribe()` method will make sure that whenever the Mosquitto broker
    gets any updates for these channels, the Arduino-based monitoring system gets
    notified:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`setup()`函数中看到，我们通过订阅`MonitoringStation/led`和`MonitoringStation/buzzer`通道来初始化代码。`client.subscribe()`方法将确保每当Mosquitto代理收到这些通道的任何更新时，基于Arduino的监控系统都会得到通知：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Programming an interrupt to handle the press of a button
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程一个中断来处理按钮的按下
- en: 'We have taken care of the publishing and subscribing functions of the monitoring
    station. Now, we will need to integrate the button switch that is controlled by
    inputs from the user. In the Arduino programming routines, we run a periodic loop
    to check the status of the pins. However, this may not be useful if the button
    is pressed since it requires immediate action. This action of pressing the button
    is handled using the Arduino interrupts, as shown in the following line of code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了监控站的发布和订阅功能。现在，我们需要集成由用户输入控制的按钮开关。在Arduino编程例程中，我们运行一个周期性循环来检查引脚的状态。然而，如果按钮被按下，这可能没有用，因为它需要立即采取行动。按下按钮的动作是通过Arduino中断来处理的，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding line of code associates an interrupt at pin 0 (digital pin 2)
    with the `buttonPress()` function. This function sets off the buzzers whenever
    the state of the interrupt is changed. In other words, when the button is pressed
    by the user, the buzzer will be instantaneously turned off irrespective of the
    current status of the buzzer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将引脚0（数字引脚2）的中断与`buttonPress()`函数关联。这个函数会在中断状态改变时触发蜂鸣器。换句话说，当用户按下按钮时，无论蜂鸣器的当前状态如何，蜂鸣器都会立即关闭：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: The current Arduino code communicates with the control center for publishing
    and subscribing the data, but we haven't yet set up the Mosquitto broker to handle
    these requests. You can still go ahead and upload the Arduino sketch to your monitoring
    station using the USB cable. This will not result in any fruitful actions from
    the monitoring station and you will only be able to use the `Serial.prinln()`
    command to print various sensor measurements. Therefore, we will develop the control
    center next so that we can start addressing communication requests from the monitoring
    station.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Arduino代码用于与控制中心通信以发布和订阅数据，但我们还没有设置Mosquitto代理来处理这些请求。您仍然可以使用USB线将Arduino草图上传到您的监控站。这将不会导致监控站有任何有益的行动，您只能使用`Serial.prinln()`命令来打印各种传感器测量值。因此，我们将开发控制中心，这样我们就可以开始处理来自监控站的通信请求。
- en: Stage 2 – a control center using Python and the Raspberry Pi
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二阶段 - 使用Python和树莓派的控制中心
- en: In order to deliver the status of the system and other sensor observations to
    the user, the control center needs to perform various operations that include
    obtaining raw sensor data from the monitoring station, calculating the status
    of the system, reporting this data to the cloud services, and displaying observation
    using GUI. While the control center includes two major hardware components (the
    Raspberry Pi and TFT LCD screen), it is also comprised of two major software components
    (the Mosquitto broker and Python code) to handle the control center logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将系统状态和其他传感器观察结果传达给用户，控制中心需要执行各种操作，包括从监控站获取原始传感器数据，计算系统状态，将此数据报告给云服务，并使用GUI显示观察结果。虽然控制中心包括两个主要硬件组件（树莓派和TFT液晶显示屏），但它还包括两个主要软件组件（Mosquitto代理和Python代码）来处理控制中心逻辑。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using a Raspberry Pi instead of a regular computer as we want the control
    center to be a deployable and portable unit that can be mounted on a wall.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用树莓派而不是普通计算机，因为我们希望控制中心成为一个可部署和便携的单位，可以安装在墙上。
- en: You can still use your own computer to edit and test the Python code for development
    purposes instead of using a Raspberry Pi directly. However, we recommend that
    you switch back to the Raspberry Pi once you are ready for deployment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用自己的计算机来编辑和测试用于开发目的的Python代码，而不是直接使用树莓派。然而，一旦您准备部署，我们建议您切换回树莓派。
- en: The control center architecture
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制中心架构
- en: The Raspberry Pi is the main computation unit of the control center and works
    as the brain of the entire system. Since the Raspberry Pi is used as a replacement
    for a regular computer, the architecture of the control center can interchangeably
    use a computer in place of the Raspberry Pi. As you can see in the following diagram,
    the control center is connected to the home network using Wi-Fi and this will
    make it accessible to the monitoring station. The control center includes the
    Mosquitto broker; this is used as the communication point between the monitoring
    station and the Python program for the control center. The Python program utilizes
    the `Tkinter` library for GUI and the `paho_mqtt` library to communicate with
    the Mosquitto broker. By utilizing these two libraries, we can convey sensor information
    from the monitoring station to the user. However, we will need a separate arrangement
    to establish communication between the control center and cloud services. In our
    overall system architecture, the control center is designed to communicate with
    the intermediate data relay, Xively. The Python code uses the `xively-python`
    library to enable this communication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派是控制中心的主要计算单元，作为整个系统的“大脑”。由于树莓派被用作普通计算机的替代品，控制中心的架构可以互换地使用计算机代替树莓派。正如您在下图中可以看到的，控制中心通过
    Wi-Fi 连接到家庭网络，这将使其对监控站可访问。控制中心包括 Mosquitto 代理；这是监控站和用于控制中心的 Python 程序之间的通信点。Python
    程序利用 `Tkinter` 库进行 GUI，并使用 `paho_mqtt` 库与 Mosquitto 代理通信。通过利用这两个库，我们可以将监控站的传感器信息传递给用户。然而，我们需要一个单独的安排来建立控制中心和云服务之间的通信。在我们的整体系统架构中，控制中心被设计为与中间数据中继
    Xively 通信。Python 代码使用 `xively-python` 库来实现这种通信。
- en: '![The control center architecture](img/5938OS_10_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![控制中心架构](img/5938OS_10_09.jpg)'
- en: In [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"), *Introduction
    to Arduino Networking*, we already provided you with methods to install the Mosquitto
    broker, the `Python-mosquitto` library, and the `xively-python` library. We also
    learned the process of setting up the TFT LCD screen with the Raspberry Pi in
    [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please refer to those tutorials
    in case you haven't completed those exercises yet. Assuming that you have configured
    the Mosquitto broker and the required Python libraries, you can move on to the
    next section, which includes the actual Python programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html "第 8 章。Arduino 网络入门")，*Arduino 网络入门*中，我们已向您提供了安装 Mosquitto
    代理、`Python-mosquitto` 库和 `xively-python` 库的方法。我们还在 [第 7 章](ch07.html "第 7 章。中期项目
    – 便携式 DIY 温度控制器")，*中期项目 – 便携式 DIY 温度控制器*中学习了使用树莓派设置 TFT LCD 屏幕的过程。如果您尚未完成这些练习，请参阅那些教程。假设您已配置了
    Mosquitto 代理和所需的 Python 库，您可以继续到下一节，该节包括实际的 Python 编程。
- en: The Python code for the control center
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制中心的 Python 代码
- en: 'Before you start interfacing these libraries in the Python code, start your
    Mosquitto broker first from the command line using this simple command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始在 Python 代码中接口这些库之前，首先使用以下简单命令从命令行启动您的 Mosquitto 代理：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure that you restart your monitoring station every time you start or restart
    the Mosquitto broker. This action will make sure that your monitoring station
    is connected to the Mosquitto broker, since the process of establishing the connection
    only gets executed once in our Arduino code, that is, at the beginning of the
    setup process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每次启动或重启 Mosquitto 代理时都重新启动您的监控站。这个操作将确保您的监控站连接到 Mosquitto 代理，因为在我们 Arduino
    代码中，建立连接的过程只会在设置过程的开始执行一次。
- en: 'The Python code for the current project is located in the code folder of this
    chapter with the name `controlCenter.py`. Open this file using your Python IDE
    and modify the values of the appropriate parameters before executing it. These
    parameters include the IP address of the Mosquitto broker along with the feed
    ID and the API key of the Xively virtual device. You should already have the feed
    ID and the API key of your Xively virtual device from the previous chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当前项目的 Python 代码位于本章代码文件夹中，文件名为 `controlCenter.py`。使用您的 Python IDE 打开此文件，在执行之前修改适当的参数值。这些参数包括
    Mosquitto 代理的 IP 地址以及 Xively 虚拟设备的 feed ID 和 API 密钥。您应该已经从上一章中获得了 Xively 虚拟设备的
    feed ID 和 API 密钥：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using a local instance of the Mosquitto broker, you can replace the
    IP address with `127.0.0.1`. Otherwise, replace the `10.0.0.18` address with the
    appropriate IP address of the computer that is hosting the Mosquitto broker. Let's
    try to understand the code now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Mosquitto 代理的本地实例，你可以将 IP 地址替换为 `127.0.0.1`。否则，将 `10.0.0.18` 地址替换为托管
    Mosquitto 代理的计算机的适当 IP 地址。现在让我们尝试理解代码。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes on Mac OS X, you won't be able to run `Tkinter` window and Python
    threads in parallel due to an unknown bug. You should be able to execute the program
    successfully in Windows and Linux environments. This program has been tested with
    the Raspberry Pi, which means you won't encounter the same bug while deploying
    the control center.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在 Mac OS X 上，由于一个未知的错误，你无法并行运行 `Tkinter` 窗口和 Python 线程。你应该能够在 Windows 和 Linux
    环境中成功执行程序。这个程序已经在 Raspberry Pi 上进行了测试，这意味着在部署控制中心时，你不会遇到相同的错误。
- en: Creating the GUI using Tkinter
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Tkinter 创建 GUI
- en: 'In the previous exercises, we always used a single Python thread to run the
    program. This practice will not help us to perform multiple tasks in parallel
    such as obtaining sensor observation from the monitoring station and simultaneously
    updating the GUI with that information. As a solution, we have introduced multithreading
    in this exercise. As we need two separate loops, one each for `Tkinter` and `paho-mqtt`,
    we will be running them independently in separate threads. The main thread will
    run methods that are related to Mosquitto and the cloud services, while the second
    thread will handle the `Tkinter` GUI. In the following code snippet, you can see
    that we have initialized the `controlCenterWindow()` class with the `threading.thread`
    parameter. Therefore, when we execute `window = controlCenterWindow()` in the
    main program, it will create another thread for this class. Basically, this class
    creates the GUI window while populating labels and other GUI components. The labels
    need to be updated when new sensor observations arrive, are declared as class
    variables, and are accessible from the class instant. As you can see in the following
    code snippet, we have declared the labels for temperature, humidity, light, and
    motion as class variables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们总是使用单个 Python 线程来运行程序。这种做法不会帮助我们并行执行多个任务，例如从监控站获取传感器观察结果，并同时更新 GUI
    以显示该信息。作为解决方案，我们在本次练习中引入了多线程。由于我们需要两个独立的循环，一个用于 `Tkinter`，另一个用于 `paho-mqtt`，我们将它们独立地在不同的线程中运行。主线程将运行与
    Mosquitto 和云服务相关的函数，而第二个线程将处理 `Tkinter` GUI。在下面的代码片段中，你可以看到我们使用 `threading.thread`
    参数初始化了 `controlCenterWindow()` 类。因此，当我们主程序中执行 `window = controlCenterWindow()`
    时，它将为这个类创建另一个线程。基本上，这个类在填充标签和其他 GUI 组件的同时创建 GUI 窗口。当新的传感器观察结果到达时，标签需要更新，它们被声明为类变量，并且可以从类实例中访问。正如你在下面的代码片段中所看到的，我们已将温度、湿度、光和运动的标签声明为类变量：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code snippet doesn't contain the portion where we declared the
    `Tkinter` components, as it is similar to what we coded in the midterm project.
    If you have questions regarding Tkinter-related issues, please refer to [Chapter
    6](ch06.html "Chapter 6. Storing and Plotting Arduino Data"), *Storing and Plotting
    Arduino Data*, and [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable
    DIY Thermostat"), *The Midterm Project – a Portable DIY Thermostat*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段中没有包含我们声明 `Tkinter` 组件的部分，因为它与我们中期项目中编写的代码类似。如果你对 Tkinter 相关问题有疑问，请参阅[第
    6 章](ch06.html "第 6 章。存储和绘制 Arduino 数据")，*存储和绘制 Arduino 数据*，以及[第 7 章](ch07.html
    "第 7 章。中期项目 – 一款便携式 DIY 温度控制器")，*中期项目 – 一款便携式 DIY 温度控制器*。
- en: Communicating with the Mosquitto broker
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 Mosquitto 代理通信
- en: 'At the control center level, we subscribe to topics that are published from
    the monitoring station, that is, `MonitoringStation/temperature`, `MonitoringStation/humidity`,
    and so on. If you have performed any modification to the Arduino code to change
    the MQTT topics, you need to reflect those changes in this section. If the topics
    published by the monitoring station do not match the topics in the control center''s
    code, you will not get any updates. As you can see in the Python code, we are
    associating the `on_message` and `on_publish` methods with very important function.
    Whenever a message arrives from the subscriber, the client will call the functions
    associated with the `on_message` method. However, every time a message gets published
    from the Python code, the `onPublish()` function will get called:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制中心级别，我们订阅了来自监测站发布的主题，即`MonitoringStation/temperature`、`MonitoringStation/humidity`等。如果你对Arduino代码进行了任何修改以更改MQTT主题，你需要在此部分反映这些更改。如果监测站发布的话题与控制中心代码中的话题不匹配，你将不会收到任何更新。正如你在Python代码中所看到的，我们将`on_message`和`on_publish`方法与非常重要的函数关联。每当有消息从订阅者那里到达时，客户端将调用与`on_message`方法关联的函数。然而，每当Python代码发布消息时，`onPublish()`函数将被调用：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Calculating the system's status and situation awareness
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算系统的状态和情况感知
- en: 'The control center is assigned with the task of calculating the status of the
    overall system. The control center calculates the status of the system as `Alert`,
    `Caution`, or `Normal` using the current values of temperature and humidity. To
    calculate the status, the control center executes the `calculateStatus()` function
    every time it gets an update for the temperature or humidity from the monitoring
    station. According to the current situation awareness logic, if the temperature
    is measured above 45 degree Celsius or below 5 degree Celsius, we call the system''s
    status as `Alert`. Similarly, you can identify the range of temperature and humidity
    values for `Caution` and `Normal` statuses from the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心被分配了计算整个系统状态的任务。控制中心使用当前温度和湿度的值来计算系统的状态，状态可以是`Alert`（警报）、`Caution`（注意）或`Normal`（正常）。为了计算状态，每当控制中心从监测站接收到温度或湿度的更新时，它都会执行`calculateStatus()`函数。根据当前的情况感知逻辑，如果测量的温度高于45摄氏度或低于5摄氏度，我们将系统的状态称为`Alert`。同样，你可以从以下代码片段中识别出温度和湿度值的范围，以确定`Caution`和`Normal`状态：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Communicating with Xively
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Xively通信
- en: The control center is also required to communicate with Xively when it receives
    a message from the subscribed topics. We are already familiar with the process
    of setting up virtual devices and data streams on Xively. Open your Xively account
    and create a virtual device called `ControlCenter`. Note down the feed ID and
    API key for this device and replace them in the current code. Once you have these
    values, create the `Temperature`, `Humidity`, `Light`, `Motion`, `Buzzer`, and
    `Status` channels in this virtual device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心在从订阅的话题接收到消息时也需要与Xively通信。我们已经熟悉了在Xively上设置虚拟设备和数据流的过程。打开你的Xively账户，创建一个名为`ControlCenter`的虚拟设备。记下该设备的feed
    ID和API密钥，并在当前代码中替换它们。一旦你有了这些值，在这个虚拟设备中创建`Temperature`、`Humidity`、`Light`、`Motion`、`Buzzer`和`Status`通道。
- en: 'Looking at the Python code, you can see that we have declared the individual
    data stream for each topic and associated them with the appropriate Xively channel.
    The following code snippet shows the data stream for just the temperature observation,
    but the code also contains a similar configuration for all the other sensor observations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 观察Python代码，你可以看到我们为每个主题声明了单独的数据流，并将它们与适当的Xively通道关联。以下代码片段显示了仅针对温度观测的数据流，但代码还包含了对所有其他传感器观测的类似配置：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the control center receives a message from the monitoring station, it
    updates the data stream with the latest values and pushes these changes to Xively.
    At the same time, we will also update the appropriate label in the `Tkinter` GUI
    using the `onMessage()` function. We will use the same code snippet for all the
    subscribed channels:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制中心从监测站接收到消息，它将使用最新的值更新数据流，并将这些更改推送到Xively。同时，我们还将使用`onMessage()`函数更新`Tkinter`
    GUI中的适当标签。我们将使用相同的代码片段为所有订阅的通道：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The control center also implements the function to set the system''s status
    across the system, once it is calculated using the `calculateStatus()` function.
    There are three different functions to perform this task using a method that is
    similar to what we described in the previous code snippet. These functions include
    `setAlert()`, `setCaution()`, and `setNormal()` and these are associated with
    `Alert`, `Caution`, and `Normal` respectively. While updating the system''s status,
    these functions also perform buzzer and LED actions by publishing the LED and
    buzzer values to the Mosquitto broker:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心还实现了跨系统设置系统状态的功能，一旦使用 `calculateStatus()` 函数计算后。有三个不同的函数通过一种类似于我们在前一个代码片段中描述的方法来执行此任务。这些函数包括
    `setAlert()`、`setCaution()` 和 `setNormal()`，它们分别与 `Alert`、`Caution` 和 `Normal`
    相关联。在更新系统状态时，这些函数还会通过将 LED 和蜂鸣器值发布到 Mosquitto 代理来执行蜂鸣器和 LED 动作：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Checking and updating the buzzer's status
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查和更新蜂鸣器的状态
- en: In the control center, we set the buzzer's status to `ON` if the system's status
    is determined as `Alert`. If you look back at the UX flow, you will notice that
    we also want to include a feature for the user to manually turn off the buzzer.
    The `checkBuzzerFromXively()` function keeps track of the buzzer's status from
    Xively and if the user manually turns off the buzzer using the web application,
    this function sets off the buzzer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制中心，如果系统状态被确定为 `Alert`，我们将蜂鸣器的状态设置为 `ON`。如果你回顾 UX 流程，你会注意到我们还想包括一个让用户手动关闭蜂鸣器的功能。`checkBuzzerFromXively()`
    函数跟踪来自 Xively 的蜂鸣器状态，如果用户使用 Web 应用程序手动关闭蜂鸣器，这个函数就会触发蜂鸣器。
- en: 'To continue this process independently from the GUI and situation awareness
    threads, we will need to create another thread for this function. The timer on
    this thread will automatically execute the function every 30 seconds:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 GUI 和情况感知线程独立地继续此过程，我们需要为这个函数创建另一个线程。这个线程上的定时器将自动每 30 秒执行一次函数：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this function running in a separate thread every 30 seconds, the control
    center will check the status of the Xively channel and stop the buzzer if the
    status is set to `OFF`. We will explain how the user can update the Xively channel
    for the buzzer in the next section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在单独的线程上每 30 秒运行此函数，控制中心将检查 Xively 通道的状态，如果状态设置为 `OFF`，则停止蜂鸣器。我们将在下一节中解释用户如何更新蜂鸣器的
    Xively 通道。
- en: Testing the control center with the monitoring station
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用监控站测试控制中心
- en: Assuming your Mosquitto broker is running, execute the `controlCenter.py` code
    with the changed parameters. Then, start the monitoring station. After a few moments,
    you will see on the terminal that the control center has already started getting
    messages from the publishers that are initialized on the monitoring station. The
    update interval for the messages from the publisher at the control center depends
    upon the configured publishing interval at the monitoring station.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 Mosquitto 代理正在运行，使用更改后的参数执行 `controlCenter.py` 代码。然后，启动监控站。过一会儿，你将在终端上看到控制中心已经开始从监控站上初始化的发布者那里接收消息。控制中心发布者的更新间隔取决于监控站配置的发布间隔。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Arduino code executes the process of connecting to the Mosquitto broker
    only once after powering on. If you start your Mosquitto broker after that, it
    won't be able to communicate with the broker. So, you need to make sure that you
    start the Mosquitto broker before powering on the monitoring station.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 代码在开机后只执行一次连接到 Mosquitto 代理的过程。如果你在那之后启动 Mosquitto 代理，它将无法与代理通信。因此，你需要确保在启动监控站之前启动
    Mosquitto 代理。
- en: If you need to restart the Mosquitto broker for any reason, remove and restart
    the monitoring station first.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要因任何原因重新启动 Mosquitto 代理，首先移除并重新启动监控站。
- en: '![Testing the control center with the monitoring station](img/5938OS_10_10.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用监控站测试控制中心](img/5938OS_10_10.jpg)'
- en: 'On execution of the program, you will be able to see a small GUI window, as
    shown in the following screenshot. This window displays the sensor''s values for
    temperature, humidity, ambient light, and motion. Along with these values, the
    GUI also displays the status of the system, which is **Normal** in this screenshot.
    You can also observe that every time the control center gets updates from the
    monitoring station, the system''s status and sensor observations change in real
    time:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行时，你将能够看到一个小的GUI窗口，如下面的截图所示。此窗口显示传感器的温度、湿度、环境光和运动值。除了这些值，GUI还显示了系统的状态，在这个截图中是**正常**。你也可以观察到，每次控制中心从监控站获取更新时，系统的状态和传感器观察结果都会实时改变：
- en: '![Testing the control center with the monitoring station](img/5938OS_10_11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用监控站测试控制中心](img/5938OS_10_11.jpg)'
- en: If this setup is working correctly on your computer, let's move on to deploy
    the control center on the Raspberry Pi.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个设置在你的计算机上运行正确，让我们继续在树莓派上部署控制中心。
- en: Setting up the control center on the Raspberry Pi
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在树莓派上设置控制中心
- en: 'The process of installing the Raspbian operating system is explained in [Chapter
    7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"), *The
    Midterm Project – a Portable DIY Thermostat*. You can use the same module that
    you used in the Midterm project or set up a new one. Once you have installed Raspbian
    and configured the TFT screen, connect the Wi-Fi dongle through a USB port. At
    this stage, we assume that your Raspberry Pi is connected with a monitor, a keyboard,
    and a mouse to perform the basic changes. Although we won''t recommend it, you
    can also use the TFT screen for the following operations, if you are comfortable
    with it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Raspbian操作系统的过程在[第7章](ch07.html "第7章。中期项目 – 一个便携式DIY恒温器")《中期项目 – 一个便携式DIY恒温器》中解释。你可以使用中期项目中使用的相同模块，或者设置一个新的模块。一旦安装了Raspbian并配置了TFT屏幕，通过USB端口连接Wi-Fi适配器。在这个阶段，我们假设你的树莓派已经连接到显示器、键盘和鼠标以执行基本更改。虽然我们不推荐这样做，但如果你对TFT屏幕操作感到舒适，你也可以用它来进行以下操作：
- en: 'Start your Raspberry Pi and log in. At the command prompt, execute the following
    command to enter the visual desktop mode:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的树莓派并登录。在命令提示符下，执行以下命令以进入图形桌面模式：
- en: '[PRE14]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once your graphical desktop starts, you will be able to see the icon of the
    **WiFi config** utility. Double-click on this icon and open the **WiFi config**
    utility. Scan for wireless networks and connect to the Wi-Fi network that has
    the monitoring station. When asked, enter the password of your network in the
    form window called **PSK**, and connect to your network.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的图形桌面启动，你将能够看到**WiFi配置**工具的图标。双击此图标并打开**WiFi配置**工具。扫描无线网络并连接到有监控站的Wi-Fi网络。当被要求时，在名为**PSK**的表单窗口中输入你的网络密码，并连接到你的网络。
- en: 'Now, your Raspberry Pi is connected to the local home network and to the Internet
    through it. It''s time to update the existing packages and install the required
    ones. To update the Raspberry Pi''s existing system, execute the following commands
    in the terminal:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的树莓派已经通过它连接到本地家庭网络和互联网。是时候更新现有包并安装所需的包了。要更新树莓派的现有系统，请在终端中执行以下命令：
- en: '[PRE15]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once your system is updated with the latest version, it''s time to install
    the Mosquitto broker on your Raspberry Pi. The Raspbian OS has Mosquitto in the
    default repository, but it doesn''t have the current version that we need. To
    install the latest version of Mosquitto, execute following commands in the terminal:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的系统更新到最新版本，就是时候在你的树莓派上安装Mosquitto代理了。Raspbian操作系统默认仓库中有Mosquitto，但没有我们需要的当前版本。要安装Mosquitto的最新版本，请在终端中执行以下命令：
- en: '[PRE16]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To install other Python dependencies, let''s first install the Setuptools package
    using `apt-get`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装其他Python依赖项，我们首先使用`apt-get`安装Setuptools包：
- en: '[PRE17]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using Setuptools, we can now install all the required Python libraries such
    as `paho_mqtt`, `xively-python`, and `web.py`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Setuptools，我们现在可以安装所有必需的Python库，如`paho_mqtt`、`xively-python`和`web.py`：
- en: '[PRE18]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have installed all the necessary software tools that are required
    to run our control center on the Raspberry Pi, it is time to configure the Raspberry
    Pi so that it can provide uninterrupted operation for a critical system such as
    a remote home monitoring system:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有必要的软件工具，可以在树莓派上运行我们的控制中心，是时候配置树莓派，使其能够为远程家庭监控系统等关键系统提供不间断的运行：
- en: 'In the current configuration of the Raspberry Pi, the screen of the Raspberry
    Pi will go to sleep after some time and the Wi-Fi connection will be terminated
    when this happens. To avoid this problem and force the screen to remain active,
    you will need to perform the following changes. Open the `lightdm.conf` file using
    the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前配置的树莓派中，树莓派的屏幕会在一段时间后进入休眠状态，此时Wi-Fi连接也会被终止。为了避免这个问题并强制屏幕保持活跃，你需要执行以下更改。使用以下命令打开`lightdm.conf`文件：
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the file, navigate to the `SetDefaults` section and edit the following line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，导航到`SetDefaults`部分并编辑以下行：
- en: '[PRE20]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that your Raspberry Pi is set up, it is time to copy the program file from
    your computer to the Raspberry Pi. You can use SCP, PuTTY, or just a USB drive
    to transfer the necessary file to the Raspberry Pi.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的树莓派已经设置好了，是时候将程序文件从您的电脑复制到树莓派上了。您可以使用SCP、PuTTY或只是一个USB驱动器来将必要的文件传输到树莓派。
- en: 'If you install and configure everything as specified, your program should run
    without any errors. You can run the Python program constantly in the background
    using the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照指定的方式安装和配置了所有内容，你的程序应该会无错误运行。你可以使用以下命令在后台持续运行Python程序：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last thing that we want to set up on the Raspberry Pi is the TFT LCD screen.
    The installation and configuration processes of the TFT LCD screen are described
    in [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please follow the steps in
    the given order to set up the screen. The control center module along with the
    Raspberry Pi and the TFT screen can now be deployed in any part of your house.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在树莓派上最后要设置的是TFT LCD屏幕。TFT LCD屏幕的安装和配置过程在[第7章](ch07.html "第7章。中期项目 – 一个便携式DIY恒温器")《中期项目
    – 一个便携式DIY恒温器》中有描述。请按照给定的顺序设置屏幕。现在，控制中心模块、树莓派和TFT屏幕可以部署在你家的任何地方。
- en: Stage 3 – a web application using Xively, Python, and Amazon cloud service
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三阶段 – 使用Xively、Python和Amazon云服务的网络应用
- en: The cloud services module of the overall system enables remote access to your
    monitoring station through the Internet. The unit interacts with the user via
    a web application as an extended version of the control center. With the use of
    this web application, the user can observe the sensor information from the monitoring
    station and the system's status calculated by the control center while having
    remote control to turn off the buzzer. So, what does the architecture of the cloud
    services look like?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统的云服务模块使您可以通过互联网远程访问您的监控站。该单元通过作为控制中心扩展版本的Web应用与用户交互。使用这个Web应用，用户可以在远程控制关闭蜂鸣器的同时，观察来自监控站的传感器信息和由控制中心计算的系统状态。那么，云服务的架构是什么样的呢？
- en: Architecture of the cloud services
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云服务架构
- en: The architecture of the cloud services module with its associated components
    is displayed in the following diagram. In the cloud services architecture, we
    are using Xively as the intermediate data relay between the web application and
    the control center. The control center pushes the observations obtained from the
    monitoring station to the Xively channels. Xively stores and relays the data to
    the web application that is hosted on the Amazon AWS. The server instance on the
    Amazon AWS is used to make the web application accessible through the Internet.
    The server instance runs the Ubuntu operating system and the web application that
    is developed using the `web.py` library in Python.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图中显示了云服务模块及其相关组件的架构。在云服务架构中，我们使用Xively作为网络应用和控制中心之间的中间数据中继。控制中心将来自监控站的观测数据推送到Xively通道。Xively存储并转发数据到托管在Amazon
    AWS上的网络应用。Amazon AWS上的服务器实例用于使网络应用通过互联网可访问。服务器实例运行Ubuntu操作系统和用Python的`web.py`库开发的网络应用。
- en: '![Architecture of the cloud services](img/5938OS_10_12.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![云服务架构](img/5938OS_10_12.jpg)'
- en: In the previous stage, we already covered the process of setting up Xively and
    the channels to accommodate sensor data. In the control center code, we also explained
    how we can push the updated observations to the appropriate Xively channels. Therefore,
    we really do not have any ground to cover for the Xively platform at this stage
    and we can move on to the web application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的阶段，我们已经介绍了设置Xively和通道以容纳传感器数据的过程。在控制中心代码中，我们也解释了如何将更新的观测数据推送到适当的Xively通道。因此，在这个阶段，我们实际上没有关于Xively平台的内容要介绍，我们可以继续到Web应用程序。
- en: Python web application hosted on Amazon AWS
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署在Amazon AWS上的Python Web应用程序
- en: In the previous chapter, we set up an Amazon AWS cloud instance to host a web
    application. You can use the same instance to host the web application for the
    remote home monitoring system too. However, make sure that you have installed
    the `web.py` library on your server.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了一个Amazon AWS云实例来托管Web应用程序。你也可以使用相同的实例来托管远程家庭监控系统中的Web应用程序。然而，请确保你在服务器上安装了`web.py`库。
- en: In your computer, open the `Web_Application` folder and then the `RemoteMonitoringApplication.py`
    file in your editor.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上，打开`Web_Application`文件夹，然后在你的编辑器中打开`RemoteMonitoringApplication.py`文件。
- en: In the code, you will be able to see that we just expand the web application
    program that we created in [Chapter 9](ch09.html "Chapter 9. Arduino and the Internet
    of Things"), *Arduino and the Internet of Things*. We use the templates based
    on `web.py` and the `GET()` and `POST()` functions to enable the web application.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，你可以看到我们只是扩展了我们在[第9章](ch09.html "第9章。Arduino和物联网")中创建的Web应用程序程序，即*Arduino和物联网*。我们使用基于`web.py`的模板以及`GET()`和`POST()`函数来启用Web应用程序。
- en: 'In the application, we fetch information from each Xively channel and process
    it via a separate function. For example, the `fetchTempXively()` function obtains
    the temperature information from Xively. Every time the `POST()` function is executed,
    the `fetchTempXively()` function fetches the latest value of temperature reading
    from Xively. This also means that the web application does not populate and refresh
    the latest information automatically and waits for `POST()` to execute the appropriate
    functions:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中，我们从每个Xively通道获取信息，并通过一个单独的函数进行处理。例如，`fetchTempXively()`函数从Xively获取温度信息。每次执行`POST()`函数时，`fetchTempXively()`函数都会从Xively获取最新的温度读数。这也意味着Web应用程序不会自动填充和刷新最新信息，而是等待`POST()`执行适当的函数：
- en: '[PRE22]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The web application also provides access to control the buzzer from the user
    interface. The following code snippet adds the **Buzzer Off** button with other
    `Form` components. When the form is submitted after this button is pressed, the
    web application executes the `setBuzzer()` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web应用程序还提供了从用户界面控制蜂鸣器的功能。以下代码片段添加了**Buzzer Off**按钮和其他`Form`组件。在此按钮按下后提交表单，Web应用程序将执行`setBuzzer()`函数：
- en: '[PRE23]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `setBuzzer()` function access the Xively channel, `Buzzer`, and sends the
    off value if the **Buzzer Off** button is pressed. The current web application
    doesn''t include the **Buzzer On** button, but you can easily implement this functionality
    by reusing the code that we developed for the **Buzzer Off** button. This function
    provides the reference code for other control points, which you can reuse with
    minor modifications:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setBuzzer()`函数访问Xively通道`Buzzer`，如果按下**Buzzer Off**按钮，则发送关闭值。当前的Web应用程序不包括**Buzzer
    On**按钮，但你可以通过重用我们为**Buzzer Off**按钮开发的代码轻松实现此功能。此函数为其他控制点提供了参考代码，你可以稍作修改后重用：'
- en: '[PRE24]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the code, you will also have to modify the Xively feed ID and the API key
    and replace them with the values that your obtained from your virtual device.
    Once you have performed this modification, run the following command. If everything
    goes as planned, you will be able to open the web application in your web browser.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，你还需要修改Xively的feed ID和API密钥，并将它们替换为你从虚拟设备获得的值。完成此修改后，运行以下命令。如果一切按计划进行，你将能够在你的网络浏览器中打开Web应用程序。
- en: '[PRE25]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you are running the Python code on your computer, you can open `http://127.0.0.1:8080`
    to access the application. If you are running the application on the cloud server,
    you need to enter the IP address or domain name of your server to access the web
    application, `http://<AWS-IP-address>:8080`. If the web application is running
    from the cloud, it can be accessed from anywhere using the Internet, which was
    one of the original project requirements. With this last step, you have successfully
    completed the development of the remote home monitoring system that is based on
    Arduino and Python.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在电脑上运行Python代码，你可以打开`http://127.0.0.1:8080`来访问应用程序。如果你在云服务器上运行应用程序，你需要输入你的服务器IP地址或域名来访问Web应用程序，`http://<AWS-IP-address>:8080`。如果Web应用程序在云上运行，它可以通过互联网从任何地方访问，这是原始项目要求之一。通过这一最后一步，你已经成功完成了基于Arduino和Python的远程家庭监控系统开发。
- en: Testing the web application
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Web应用程序
- en: 'When you open the web application in a browser, you will be able to see a similar
    output as shown in the following screenshot. As you can see, the web application
    displays the temperature, humidity, light, and motion values. The **Refresh**
    button fetches the sensor data from Xively again and loads the application once
    more. The **Buzzer Off** button sets the value of the Xively''s `Buzzer` channel
    to `OFF`, which then get picked up by the control center, and it turns off the
    buzzer at the monitoring station subsequently:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中打开Web应用程序时，你将能够看到以下截图所示的类似输出。正如你所见，Web应用程序显示了温度、湿度、光照和运动值。**刷新**按钮从Xively再次获取传感器数据并重新加载应用程序。**蜂鸣器关闭**按钮将Xively的`蜂鸣器`通道值设置为`关闭`，然后由控制中心接收到，随后在监测站关闭蜂鸣器：
- en: '![Testing the web application](img/5938OS_10_13.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![测试Web应用程序](img/5938OS_10_13.jpg)'
- en: Testing and troubleshooting
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和故障排除
- en: 'Due to the number of components involved and complex programming associated
    with them, the overall project is a complex system to test and debug. Before you
    jump into troubleshooting, make sure that you have properly followed the steps
    that were described in the previous sections in order. The following are a few
    solutions to possible problems that can occur during the execution of the project:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及到的组件数量和与之相关的复杂编程，整个项目是一个复杂的系统，需要进行测试和调试。在你开始故障排除之前，确保你已经按照前面章节中描述的步骤正确操作。以下是在项目执行过程中可能出现的几个问题的解决方案：
- en: 'Troubleshoot individual sensor performance:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除单个传感器的性能：
- en: If your sensor measurements are way off the expected values, the first thing
    that you want to evaluate is the connection of the sensor pins to the Arduino
    board. Make sure that you have connected the digital, analog, and PWM pins correctly.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的传感器测量值远远偏离预期值，你首先想要评估的是传感器引脚与Arduino板的连接。确保你已经正确连接了数字、模拟和PWM引脚。
- en: Check whether your Ethernet Shield board is properly connected to Arduino Uno.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的以太网盾板是否正确连接到Arduino Uno。
- en: Evaluate the connections of the 5V power supply and ground for each component.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估每个组件的5V电源和地线的连接。
- en: Avoid Xively's update limit
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免Xively的更新限制
- en: Xively imposes a limit on the maximum number of transactions that you can perform
    in a limited amount of time. While running your control center code, if you encounter
    an error for exceeding the limit, wait for 5 minutes before your access limit
    gets lifted.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xively对你在有限时间内可以执行的最大交易数量有限制。在运行控制中心代码时，如果你遇到超出限制的错误，请在你的访问限制解除之前等待5分钟。
- en: 'Increase the delay between consecutive Xively updates at the control center
    level:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制中心级别增加连续Xively更新的延迟：
- en: '[PRE26]'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Reduce the frequency of published messages at the monitoring station:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少监测站发布的消息频率：
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also combine various Xively channels by formatting data into JSON or
    XML.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以通过将数据格式化为JSON或XML来组合各种Xively通道。
- en: 'Working with the maximum current draw limitation of Arudino:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Arduino的最大电流消耗限制一起工作：
- en: The +5V power pin and digital pin of Arduino can provide a maximum current of
    200 mA and 40 mA respectively. When running sensors directly from the Arduino
    board, make sure that you do not exceed these limits.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino的+5V电源引脚和数字引脚分别可以提供最大200 mA和40 mA的电流。当直接从Arduino板运行传感器时，确保你不超过这些限制。
- en: Make sure the combined current requirement of all the sensors is less than 200
    mA. Otherwise, the components won't be able to get enough power to run and this
    will translate into faulty sensor information.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有传感器的总电流需求小于200 mA。否则，组件将无法获得足够的电力来运行，这将导致传感器信息错误。
- en: You can provide external power to the components that require large amounts
    of current and control this power mechanism via Arduino itself. You will need
    a transistor that is acting as a switch that can then be controlled using the
    digital pins of Arduino. The tutorial at [https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors](https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors)
    shows a similar example for a DC motor.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为需要大量电流的组件提供外部电源，并通过Arduino本身控制此电源机制。您需要一个作为开关工作的晶体管，然后可以使用Arduino的数字引脚来控制它。[https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors](https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors)教程展示了类似用于直流电机的示例。
- en: 'Solve network problems:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决网络问题：
- en: In some scenarios, your monitoring station won't be able to communicate with
    the control center due to network problems.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，由于网络问题，您的监控站可能无法与控制中心通信。
- en: This problem can be solved by using manual IP addresses for both, Arduino and
    the Raspberry Pi. In our project, we use a manual IP address for the Arduino,
    but the Raspberry Pi is connected using the Wi-Fi network. In most cases, when
    you are using your home Wi-Fi network, Wi-Fi routers are set up to provide dynamic
    IP addresses to the device every time they reconnect to the router.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为Arduino和Raspberry Pi都使用手动IP地址，可以解决这个问题。在我们的项目中，我们为Arduino使用手动IP地址，但Raspberry
    Pi是通过Wi-Fi网络连接的。在大多数情况下，当您使用家庭Wi-Fi网络时，Wi-Fi路由器被设置为在设备每次重新连接到路由器时提供动态IP地址。
- en: You can solve this by configuring your Wi-Fi router to a fixed IP address for
    the Raspberry Pi. As the type and model of the Wi-Fi router is different for every
    scenario, you will have to use its user manual or online help forums for setting
    it up.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过将Wi-Fi路由器配置为为Raspberry Pi提供固定IP地址来解决这个问题。由于每个场景中的Wi-Fi路由器类型和型号都不同，您将需要使用其用户手册或在线帮助论坛来设置它。
- en: 'Working with buzzer-related issues:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理蜂鸣器相关的问题：
- en: Sometimes the buzzer sound can be too loud or too quiet, depending upon the
    sensor that you are using. You can use PWM to configure the intensity of the buzzer.
    In our project, we used the Arduino digital pin 9 to connect the buzzer. This
    pin also supports PWM. In your Arduino code, modify the line to reflect changes
    for the PWM pin. Replace the `digitalWrite(BUZZER, HIGH);` line with `analogWrite(BUZZER,
    127);`.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时蜂鸣器的声音可能太大或太小，这取决于您使用的传感器。您可以使用PWM来配置蜂鸣器的强度。在我们的项目中，我们使用Arduino数字引脚9连接蜂鸣器。此引脚也支持PWM。在您的Arduino代码中，修改行以反映PWM引脚的变化。将`digitalWrite(BUZZER,
    HIGH);`行替换为`analogWrite(BUZZER, 127);`。
- en: This routine will reduce the intensity of the buzzer by half from the original
    level. You can also change the PWM value from 0 to 255 and set the intensity of
    the buzzer sound from lowest to highest.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此程序将蜂鸣器的强度从原始水平减半。您还可以将PWM值从0更改为255，并将蜂鸣器声音的强度从最低设置为最高。
- en: 'Control center GUI calibration:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制中心GUI校准：
- en: Depending upon the size of the TFT LCD screen that you are using, you will have
    to adjust the size of the main window of `Tkinter`.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您使用的TFT液晶屏幕的大小，您需要调整`Tkinter`的主窗口大小。
- en: 'First, run the current code on your Raspberry Pi and if you see that the GUI
    window does not match the screen, add the following line of code after initializing
    the main window:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在您的Raspberry Pi上运行当前代码，如果您看到GUI窗口与屏幕不匹配，请在初始化主窗口后添加以下代码行：
- en: '[PRE28]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code will fix the problem with the size for a 2.8 inch TFT LCD screen.
    In the previous code snippet, `320` and `200` represent the pixel sizes for width
    and length respectively. For other screen sizes, change the pixel size accordingly.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码将修复2.8英寸TFT液晶屏幕尺寸的问题。在之前的代码片段中，`320`和`200`分别代表宽度和长度的像素大小。对于其他屏幕尺寸，相应地更改像素大小。
- en: 'Test the LED:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试LED：
- en: 'In current code configuration, the LED is turned on only when the system changes
    to `Alert` or `Caution`. That means you won''t be able to test the LEDs unless
    these situations occur. To check whether they are working correctly, execute the
    following command at the control center:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前的代码配置中，只有当系统切换到`Alert`或`Caution`时，LED才会打开。这意味着除非这些情况发生，否则您无法测试LED。要检查它们是否正常工作，请在控制中心执行以下命令：
- en: '[PRE29]'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will light up the LED in red. To turn off the LED, just use `off`
    instead of `red` in the previous code.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个命令将使LED变红。要关闭LED，只需在之前的代码中将`red`替换为`off`。
- en: If nothing lights up, you should check the connection wires of the LEDs. In
    addition, check for network-related issues as the Mosquitto itself might not be
    working.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何灯光亮起，你应该检查LED的连接线。此外，检查网络相关的问题，因为Mosquitto本身可能不工作。
- en: If you see any color other than red, this means that you haven't connected the
    LED correctly and you need to interchange the pin configuration of your LED. If
    you are using an LED different than super-flux RGB, you should check out the pin
    layout in the datasheet and reorganize the connections.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到除了红色以外的任何颜色，这意味着你没有正确连接LED，你需要交换你的LED引脚配置。如果你使用的是非超级流光RGB的LED，你应该检查数据表中的引脚布局并重新组织连接。
- en: Extending your remote home monitoring system
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展你的远程家庭监控系统
- en: To successfully create commercial products from DIY project prototypes, you
    will need an additional layer of features on top of basic functionalities. These
    features actually make things convenient for a user when they interact with the
    system. The other distinguishable feature is the tangibility of the system, which
    makes large-scale production and support possible. Although there are plenty of
    features that you can implement, we recommend the following major improvements
    to elevate the level of the current project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要从DIY项目原型成功创建商业产品，你需要在基本功能之上添加额外的功能层。这些功能实际上在使用系统时为用户提供了便利。另一个可区分的特征是系统的可触摸性，这使得大规模生产和支持成为可能。尽管你可以实现很多功能，但我们建议以下主要改进来提升当前项目的水平。
- en: Utilizing multiple monitoring stations
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用多个监测站
- en: 'In this project, we developed a monitoring station as a prototype with a range
    of functionality that is demonstrated by a remote home monitoring system. A remote
    monitoring system can have multiple numbers of monitoring stations to cover various
    geographical locations, such as different rooms inside a house, or different office
    cubicles. Basically, a large number of monitoring stations can cover an extended
    area and provide efficient surveillance of the domain that you are trying to monitor.
    If you want to extend the current project with an array of monitoring stations,
    you will require some of the following modifications:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们开发了一个作为原型的监测站，它具有一系列由远程家庭监控系统展示的功能。远程监控系统可以拥有多个监测站来覆盖各种地理区域，例如房屋内的不同房间，或不同的办公室隔间。基本上，大量的监测站可以覆盖更广泛的区域，并提供对你试图监控区域的效率监控。如果你想通过一系列监测站扩展当前项目，你将需要以下一些修改：
- en: Each monitoring station can have its own control center or a centralized control
    center for all of them, depending upon the application requirements.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个监测站可以有自己的控制中心，或者根据应用需求为所有监测站集中一个控制中心。
- en: You will have to update the Python code for the control center to accommodate
    the changes. Examples of these changes include modifying topic titles for MQTT,
    coordinating between these monitoring stations, updating data models for Xively
    updates, and so on.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将不得不更新控制中心的Python代码以适应这些变化。这些变化的例子包括修改MQTT的主题标题、在这些监测站之间协调、更新Xively数据模型以进行更新等。
- en: The free Xively account may not be able to handle the large amounts of data
    coming from the monitoring stations. In this case, you can either optimize the
    update rate and/or payload size or upgrade your Xively account to comply with
    the requirements. You can also resort to other free services such as ThingSpeak,
    Dweet.io, and Carriots, but you will have to make substantial modifications to
    the existing code structure.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费Xively账户可能无法处理来自监测站的大量数据。在这种情况下，你可以优化更新速率和/或有效载荷大小，或者升级你的Xively账户以满足要求。你也可以求助于其他免费服务，如ThingSpeak、Dweet.io和Carriots，但你将需要对现有的代码结构进行重大修改。
- en: You can also update the web application to provide you with a selection menu
    for the monitoring stations or display all of them at once. You will also have
    to change the code to yield the modified data models.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以更新网络应用程序，为你提供监测站的选项菜单或一次性显示所有监测站。你还需要更改代码以生成修改后的数据模型。
- en: Extending sensory capabilities
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展感官能力
- en: In term of sensors, we are only interfacing temperature, humidity, ambient light,
    and motion sensors. However, the actuation is limited to the buzzer and LED. You
    can implement the following changes to improve the sensory capabilities of the
    project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在传感器方面，我们只接口温度、湿度、环境光和运动传感器。然而，执行功能仅限于蜂鸣器和LED。您可以通过以下更改来提高项目的感官能力。
- en: In a real scenario, a remote home monitoring system should be able to interface
    with other existing sensors such as the security system, monitoring cameras, refrigerator
    sensors, door sensors, and garage sensors throughout a home.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际场景中，一个远程家庭监控系统应该能够与家庭中的其他现有传感器接口，例如安全系统、监控摄像头、冰箱传感器、门传感器和车库传感器。
- en: You can also interface this project with other appliances such as the air conditioner,
    heater, and security alarm, which can help you to control the environment that
    you are already monitoring. As a trial, these components can be interfaced using
    a set of relays and switches.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以将此项目与其他家用电器如空调、加热器和安全报警器接口，这可以帮助您控制您已经监控的环境。作为试验，这些组件可以使用一组继电器和开关进行接口。
- en: You can upgrade the current sensors at the monitoring station with more powerful,
    efficient, and accurate sensors. However, the monitoring station with the upgraded
    sensors may require a more powerful version of Arduino with more I/O pins and
    computation capabilities.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用更强大、更高效、更精确的传感器升级监控站上的当前传感器。然而，升级后的传感器监控站可能需要更强大的Arduino版本，具有更多的I/O引脚和计算能力。
- en: You can also use additional sensors other than those used in this project at
    the monitoring station. There are large amount of heterogeneous, Arduino-supported
    DIY sensors that you can buy off the shelf. Examples of these sensors include
    the Alcohol Gas Sensor (MQ-3), LPG Gas Sensor (MQ-6), Carbon Monoxide Sensor (MQ-7),
    Methane Gas Sensor (MQ-4), and so on. These sensors can be simply interfaced with
    the Arduino just like the other sensors that we connected earlier.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以在监控站使用除本项目使用的传感器以外的其他传感器。市面上有大量异构的、Arduino支持的DIY传感器，您可以直接购买。这些传感器的例子包括酒精气体传感器（MQ-3）、液化石油气传感器（MQ-6）、一氧化碳传感器（MQ-7）、甲烷气体传感器（MQ-4）等等。这些传感器可以像我们之前连接的其他传感器一样简单地与Arduino接口。
- en: To accommodate these changes, you will be required to change the control center
    logic and algorithms. If you are interfacing a third-party component, you may
    also have to revisit the system architecture and adjust it.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了适应这些变化，您将需要更改控制中心逻辑和算法。如果您正在接口第三方组件，您可能还需要重新审视系统架构并对其进行调整。
- en: 'Similarly, you will also have to run frequent updates to Xively for the additional
    number of sensors, making the free version inadequate. To resolve this, you can
    pay for the commercial version of a Xively account or use a limited number of
    requests using a JSON file format similar to the one displayed in the following
    code snippet:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，您还必须为额外的传感器频繁更新Xively，这使得免费版本不足。为了解决这个问题，您可以支付Xively账户的商业版本或使用类似于以下代码片段显示的JSON文件格式进行有限数量的请求：
- en: '[PRE30]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Improving UX
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进UX
- en: 'When we designed the user experience for this project, our goal was to demonstrate
    the usefulness of a UX design in developing the software flow. In the current
    UX design, the control center and the web application have limited control and
    features for a user. The following are a few changes that you need to implement
    to improve the UX of the project:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为这个项目设计用户体验时，我们的目标是展示UX设计在开发软件流程中的有用性。在当前的UX设计中，控制中心和网络应用对用户的控制和功能有限。以下是一些您需要实施以改进项目UX的更改：
- en: Add tooltips and proper naming conventions for the various descriptions. Implement
    a proper layout to differentiate between the various information categories.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为各种描述添加工具提示和适当的命名约定。实现适当的布局以区分不同的信息类别。
- en: Add buttons for the buzzer and the LED control on the control center GUI.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制中心GUI上添加蜂鸣器和LED控制的按钮。
- en: In the web application, use a JavaScript and Ajax-based interface to automatically
    refresh the changes in sensor values.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络应用中，使用基于JavaScript和Ajax的界面来自动刷新传感器值的变化。
- en: Provide a UI mechanism so that the user can change the update interval at the
    control center and the web application. Once these changes are made, propagate
    them through each program so that the monitoring station can start publishing
    messages at the new interval.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用户界面机制，以便用户可以在控制中心和网络应用程序中更改更新间隔。一旦做出这些更改，通过每个程序传播它们，以便监控站可以开始以新的间隔发布消息。
- en: Expanding cloud-based features
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展基于云的功能
- en: 'In the current setup, we are using two stages to provide cloud-based capabilities
    and enable remote monitoring. We have Xively as a data relay and Amazon AWS to
    host the web application. If you are working on a commercial-grade product and
    want to reduce the complexity of the architecture, you can implement the following
    changes:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的设置中，我们使用两个阶段来提供基于云的功能并启用远程监控。我们使用 Xively 作为数据中继，并使用 Amazon AWS 来托管网络应用程序。如果您正在开发商业级产品并希望简化架构的复杂性，您可以实施以下更改：
- en: You can develop your own data relay on your cloud instance using open source
    tools such as ThingSpeak. Your control center will then communicate directly to
    your server and eliminate dependency on third-party IoT services.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用如 ThingSpeak 等开源工具在您的云实例上开发自己的数据中继。然后，您的控制中心将直接与您的服务器通信，消除对第三方物联网服务的依赖。
- en: If Xively is your platform, you can also use additional features, such as graphs
    on your smart phone, which are provided by Xively. Once your phone is paired with
    Xively, you can access this feature directly.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Xively 是您的平台，您还可以使用 Xively 提供的附加功能，例如智能手机上的图表。一旦您的手机与 Xively 配对，您可以直接访问此功能。
- en: Alternatively, you can use other cloud services such as Microsoft Azure and
    Google App engine instead of Amazon AWS. You can also set up your own cloud server,
    depending upon your familiarity with cloud computing. Although having your own
    cloud will give you complete control of the server, third-party services such
    as Amazon can be more cost effective and require less maintenance compared to
    self-hosted servers.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以使用其他云服务，如 Microsoft Azure 和 Google App Engine，而不是 Amazon AWS。根据您对云计算的熟悉程度，您也可以设置自己的云服务器。尽管拥有自己的云将使您完全控制服务器，但与自托管服务器相比，第三方服务如
    Amazon 可能更具成本效益且维护成本更低。
- en: If you are planning to develop a large-scale system that is based on the current
    architecture, you can increase the computing capability of your existing cloud
    instance. You can also implement a distributed server system to accommodate the
    large number of remote monitoring systems that can be accessed by an even greater
    number of users.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您计划开发基于当前架构的大型系统，您可以增加现有云实例的计算能力。您还可以实现分布式服务器系统，以适应大量远程监控系统，这些系统可以由更多的用户访问。
- en: Improving intelligence for situation awareness
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高态势感知的智能程度
- en: 'In this project, we have used four different sensors to monitor the physical
    environment—each sensor obtains user inputs with two types of actuators for notification.
    Although we are using a good amount of information sources, our situation awareness
    algorithm is limited to identifying out-of-range temperature and humidity values.
    You can implement a few extended features to make your system more versatile and
    useful:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用了四种不同的传感器来监控物理环境——每个传感器都使用两种类型的执行器来获取用户输入以进行通知。尽管我们使用了大量的信息来源，但我们的态势感知算法仅限于识别超出范围的温度和湿度值。您可以通过实现一些扩展功能来使您的系统更加灵活和有用：
- en: Implement different logic for day and night scenarios, which can help you to
    avoid unwarranted false alarms at night.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现白天和夜晚场景的不同逻辑，这可以帮助您避免夜间不必要的误报。
- en: Implement an intruder detection algorithm using the motion sensor for when you
    are not at home.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运动传感器实现入侵检测算法，以便您不在家时使用。
- en: Utilize a combination of ambient light sensor values with motion sensors to
    identify energy wastage. For example, a scenario in which more light is recorded
    during the night when the motions are significantly low explains that you may
    have forgotten to turn off the lights during the night.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用环境光传感器值与运动传感器的组合来识别能源浪费。例如，当夜间运动显著减少时记录到的光线更多，这可能表明您在夜间忘记关闭灯光。
- en: Creating an enclosure for hardware components
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为硬件组件创建一个封装
- en: 'Just like software-based features, the hardware components also require a major
    revamp if you develop a commercial-grade product. Nowadays, 3D printers have become
    viable and it is really easy to design and print plastic 3D components. You can
    also use professional 3D printing services such as Shapeways ([http://www.shapeways.com](http://www.shapeways.com)),
    Sculpteo ([http://www.sculpteo.com](http://www.sculpteo.com)), or makexyz ([http://www.makexyz.com](http://www.makexyz.com))
    for your enclosures. You can even use a laser cutter or other means of model making
    to create the hardware enclosures. These are a few hardware improvements that
    you can implement:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于软件的功能一样，如果你开发的是商业级产品，硬件组件也需要进行重大改造。如今，3D打印机已经变得可行，设计和打印塑料3D组件变得非常容易。你也可以使用专业的3D打印服务，如Shapeways
    ([http://www.shapeways.com](http://www.shapeways.com))、Sculpteo ([http://www.sculpteo.com](http://www.sculpteo.com))
    或 makexyz ([http://www.makexyz.com](http://www.makexyz.com)) 来打印你的外壳。你甚至可以使用激光切割机或其他模型制作手段来创建硬件外壳。以下是一些你可以实施的硬件改进：
- en: The sensor and actuators that are assembled on a prototype board can be organized
    on a PCB and permanently fixed for stable and robust operation.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装在原型板上的传感器和执行器可以被组织在PCB板上，并永久固定以实现稳定和坚固的操作。
- en: A hardware enclosure for the monitoring station can make it portable and easily
    deployable in any environment. When designing this enclosure, you should also
    consider the proper placement of the motion sensor and the ambient light sensor,
    along with a button to make them accessible to the user.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控站的外壳可以使设备便携，并易于在任何环境中部署。在设计这个外壳时，你还应考虑运动传感器和环境光传感器的适当位置，以及一个按钮，以便用户可以访问它们。
- en: The Raspberry Pi and TFT LCD screen, which make up the control center hardware,
    can also be enclosed in a mountable package.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成控制中心硬件的Raspberry Pi和TFT液晶显示屏也可以封装在一个可安装的包装中。
- en: Adding touch screen capabilities to the TFT LCD screen can enable additional
    control over the system, expanding the UX use cases.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将触摸屏功能添加到TFT液晶显示屏上可以实现对系统的额外控制，扩展用户体验的使用案例。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a working prototype of a remote home monitoring
    system and also learned the process of hardware product development simultaneously.
    In the project, we utilized most of the hardware components and software tools
    that we used throughout the book. We began by designing the system architecture
    so that we could coordinate the utilization of these tools. Later, we ventured
    into the actual development stages, which included designing the hardware units
    and developing programs to run these units. In the end, we provided a list of
    improvements to make this prototype into a real commercial product. You are welcome
    to use this methodology to develop your future projects and products, as you now
    have experience working with this one.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个远程家庭监控系统的工作原型，并同时学习了硬件产品开发的过程。在项目中，我们使用了本书中大部分的硬件组件和软件工具。我们首先设计系统架构，以便能够协调这些工具的利用。随后，我们进入了实际的开发阶段，这包括设计硬件单元和开发运行这些单元的程序。最后，我们提供了一份改进清单，以便将这个原型转变为真正的商业产品。欢迎你使用这种方法来开发你未来的项目和产品，因为你现在已经有了与这个项目合作的经验。
- en: In the last chapter, we are going to utilize the same project development methodology
    to create an interesting project that utilizes your messages from a social network
    website to give you control over your hardware.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们将利用相同的项目开发方法来创建一个有趣的项目，该项目利用来自社交网络网站的消息来控制你的硬件。
