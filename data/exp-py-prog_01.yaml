- en: Chapter 1. Current Status of Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Python的当前状态
- en: Python is good for developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python对开发人员来说是很好的。
- en: No matter what operating system you or your customers are running, it will work.
    Unless you are coding platform-specific things, or using a platform-specific library,
    you can work on Linux and deploy on other systems, for example. However, that's
    not uncommon anymore (Ruby, Java, and many other languages work in the same way).
    Combined with the other qualities that we will discover throughout this book,
    Python becomes a smart choice for a company's primary development language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您或您的客户使用什么操作系统，它都可以工作。除非您编写特定于平台的内容，或者使用特定于平台的库，您可以在Linux上工作，然后在其他系统上部署，例如。然而，这已经不再是不寻常的事情了（Ruby、Java和许多其他语言也是这样工作的）。再加上我们将在本书中发现的其他优点，Python成为公司主要开发语言的明智选择。
- en: 'This book is focused on the latest version of Python, 3.5, and all code examples
    are written in this version of the language unless another version is explicitly
    mentioned. Because this release is not yet widely used, this chapter contains
    some description of the current *status quo* of Python 3 to introduce readers
    to it, as well as some introductory information on modern approaches to development
    in Python. This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于Python的最新版本3.5，并且所有的代码示例都是用这个版本的语言编写的，除非另一个版本被明确提到。因为这个版本还没有被广泛使用，本章包含了一些关于Python
    3当前现状的描述，以便向读者介绍它，以及一些关于Python开发的现代方法的介绍信息。本章涵盖以下主题：
- en: How to maintain compatibility between Python 2 and Python 3
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python 2和Python 3之间保持兼容性
- en: How to approach the problem of environment isolation both on application and
    operating system level for the purpose of development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在应用程序和操作系统级别上处理环境隔离问题，以便进行开发
- en: How to enhance the Python prompt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强Python提示
- en: How to install packages using pip
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用pip安装软件包
- en: A book always starts with some appetizers. So, if you are already familiar with
    Python (especially with the latest 3.x branch) and know how to properly isolate
    environments for development purposes, you can skip the first two sections of
    this chapter and just read the other sections quickly. They describe some tools
    and resources that are not essential but can highly improve productivity in Python.
    Be sure to read the section on application-level environment isolation and pip,
    though, as their installation is mandatory for the rest of the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一本书总是以一些开胃菜开始的。因此，如果您已经熟悉Python（尤其是最新的3.x分支），并且知道如何正确地隔离开发环境，您可以跳过本章的前两节，快速阅读其他部分。它们描述了一些非必要但可以极大提高Python生产力的工具和资源。但是一定要阅读有关应用级环境隔离和pip的部分，因为它们的安装对本书的其余部分是强制性的。
- en: Where are we now and where we are going?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们现在在哪里，我们将走向何方？
- en: 'Python history starts somewhere in the late 1980s, but its 1.0 release date
    was in the year 1994, so it is not a very young language. There could be a whole
    timeline of major Python releases mentioned here, but what really matters is a
    single date: December 3, 2008 – the release date of Python 3.0.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python的历史始于20世纪80年代末，但它的1.0发布日期是在1994年，所以它并不是一种非常年轻的语言。这里可以提到一系列主要的Python发布日期，但真正重要的是一个日期：2008年12月3日——Python
    3.0的发布日期。
- en: At the time of writing, seven years have passed since the first Python 3 release.
    It is also four years since the creation of PEP 404—the official document that
    "un-released" Python 2.8 and officially closed the 2.x branch. Although a lot
    of time has passed, there is a specific dichotomy in the Python community—while
    the language develops very fast, there is a large group of its users that do not
    want to move forward with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，距离第一个Python 3发布已经过去了七年。自PEP 404的创建以来已经过去了四年，这是官方文件，它“取消发布”了Python 2.8，并正式关闭了2.x分支。尽管已经过去了很长时间，但在Python社区中存在着一个特定的二分法——虽然语言发展非常迅速，但有一大群用户不愿意向前发展。
- en: Why and how does Python change?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么以及Python如何改变？
- en: The answer is simple—Python changes because there is such a need. The competition
    does not sleep. Every few months a new language pops out out of nowhere claiming
    to solve problems of all its predecessors. Most projects like these lose developers'
    attention very quickly and their popularity is driven by a sudden hype.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单——Python之所以改变，是因为有这样的需求。竞争是不会停止的。每隔几个月，就会有一种新语言突然冒出来，声称解决了所有先前语言的问题。大多数这样的项目很快就失去了开发人员的注意，它们的流行程度是由突然的热潮所推动的。
- en: Anyway, this is a sign of some bigger issue. People design new languages because
    they find the existing ones unsuitable for solving their problems in the best
    ways possible. It would be silly not to recognize such a need. Also, more and
    more wide spread usage of Python shows that it could, and should, be improved
    in many places.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这都是一些更大问题的迹象。人们设计新语言，是因为他们发现现有的语言无法以最佳方式解决他们的问题。不承认这种需求是愚蠢的。此外，Python的越来越广泛的使用表明它在许多方面都可以，也应该得到改进。
- en: Lots of improvements in Python are often driven by the needs of particular fields
    where it is used. The most significant one is web development, which necessitated
    improvements to deal with concurrency in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python的许多改进通常是由其使用领域的特定需求驱动的。最重要的一个是Web开发，这需要改进来处理Python中的并发性。
- en: Some changes are just caused by the age and maturity of the Python project.
    Throughout the years, it has collected some of the clutter in the form of de-organized
    and redundant standard library modules or some bad design decisions. First, the
    Python 3 release aimed to bring major clean-up and refreshment to the language,
    but time showed that this plan backfired a bit. For a long time, it was treated
    by many developers only like curiosity, but, hopefully, this is changing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些变化仅仅是由于Python项目的年龄和成熟度所致。多年来，它已经收集了一些混乱的东西，例如非组织化和冗余的标准库模块或一些糟糕的设计决策。首先，Python
    3发布旨在为语言带来重大的清理和更新，但时间表明这个计划有些事与愿违。很长一段时间以来，它被许多开发人员视为一种好奇心，但希望情况正在改变。
- en: Getting up to date with changes – PEP documents
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解最新变化-PEP文档
- en: The Python community has a well-established way of dealing with changes. While
    speculative Python language ideas are mostly discussed on specific mailing lists
    (`<[python-ideas@python.org](mailto:python-ideas@python.org)>`), nothing major
    ever gets changed without the existence of a new document called a PEP. A **PEP**
    is a **Python Enhancement Proposal**. It is a paper written that proposes a change
    on Python, and is a starting point for the community to discuss it. The whole
    purpose, format, and workflow around these documents is also standardized in the
    form of a Python Enhancement Proposal—precisely, PEP 1 document ([http://www.python.org/dev/peps/pep-0001](http://www.python.org/dev/peps/pep-0001)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区有一种处理变化的成熟方式。虽然关于Python语言的推测性想法大多在特定的邮件列表上讨论（`<[python-ideas@python.org](mailto:python-ideas@python.org)>`），但没有新的文件称为PEP，就不会发生重大变化。**PEP**是**Python
    Enhancement Proposal**的缩写。它是提出对Python的改变的文件，也是社区讨论的起点。这些文件的整个目的、格式和工作流程也是以Python
    Enhancement Proposal的形式标准化的，准确地说，是PEP 1文档（[http://www.python.org/dev/peps/pep-0001](http://www.python.org/dev/peps/pep-0001)）。
- en: 'PEP documents are very important for Python and depending on the topic, they
    serve different purposes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PEP文档对Python非常重要，根据主题的不同，它们有不同的用途：
- en: '**Informing**: They summarize the information needed by core Python developers
    and notify about Python release schedules'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：它们总结了核心Python开发人员所需的信息，并通知Python发布时间表'
- en: '**Standardizing**: They provide code style, documentation, or other guidelines'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化**：它们提供代码风格、文档或其他指南'
- en: '**Designing**: They describe the proposed features'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：它们描述了提出的功能。'
- en: A list of all the proposed PEPs is available as in a document—PEP 0 ([https://www.python.org/dev/peps/](https://www.python.org/dev/peps/)).
    Since they are easily accessible in one place and the actual URL is also very
    easy to guess, they are usually referred to by the number in the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '所有提出的PEP的列表都可以在一个文档中找到——PEP 0（[https://www.python.org/dev/peps/](https://www.python.org/dev/peps/)）。由于它们在一个地方很容易获得，而且实际的URL也很容易猜到，它们通常在书中按编号引用。 '
- en: Those who are wondering what the direction is in which the Python language is
    heading but do not have time to track a discussion on Python mailing lists, the
    PEP 0 document can be a great source of information. It shows which documents
    have already been accepted but are not yet implemented and also which are still
    under consideration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想知道Python语言发展方向的人，但没有时间跟踪Python邮件列表上的讨论，PEP 0文档可以是一个很好的信息来源。它显示了哪些文件已经被接受但尚未实施，以及哪些仍在考虑中。
- en: 'PEPs also serve additional purposes. Very often, people ask questions like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PEP还有其他用途。人们经常问类似的问题：
- en: Why does feature A work that way?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么A功能以这种方式工作？
- en: Why does Python not have feature B?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Python没有B功能？
- en: In most such cases, the extensive answer is available in specific PEP documents
    where such a feature has already been mentioned. There are a lot of PEP documents
    describing Python language features that were proposed but not accepted. These
    documents are left as a historical reference.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数这样的情况下，详细答案可以在特定的PEP文档中找到，其中已经提到了这样的功能。有很多PEP文档描述了提出但未被接受的Python语言功能。这些文件被留作历史参考。
- en: Python 3 adoption at the time of writing this book
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写作本书时的Python 3采用情况
- en: So, is Python 3, thanks to new exciting features, well adopted among its community?
    Sadly, not yet. The popular page Python 3 Wall of Superpowers ([https://python3wos.appspot.com](https://python3wos.appspot.com))
    that tracks the compatibility of most popular packages with the Python 3 branch
    was, until not so long ago, named Python 3 Wall of Shame. This situation is changing
    and the table of listed packages on the mentioned page is slowly turning "more
    green" with every month. Still, this does not mean that all teams building their
    applications will shortly use only Python 3\. When all popular packages are available
    on Python 3, the popular excuse—the packages that we use are not ported yet—will
    no longer be valid.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，由于新的激动人心的功能，Python 3在其社区中被广泛采用吗？可惜，还没有。跟踪Python 3分支与大多数流行软件包兼容性的流行页面Python
    3 Wall of Superpowers（[https://python3wos.appspot.com](https://python3wos.appspot.com)）直到不久前还被称为Python
    3 Wall of Shame。这种情况正在改变，提到的页面上列出的软件包表格每个月都在慢慢变得“更绿”。但是，这并不意味着所有构建应用程序的团队很快就会只使用Python
    3。当所有流行软件包都在Python 3上可用时，常见的借口——我们使用的软件包尚未移植——将不再有效。
- en: The main reason for such a situation is that porting the existing application
    from Python 2 to Python 3 is always a challenge. There are tools like 2to3 that
    can perform automated code translation but they do not ensure that the result
    will be 100% correct. Also, such translated code may not perform as well as in
    its original form without manual adjustments. The moving of existing complex code
    bases to Python 3 might involve tremendous effort and cost that some organizations
    may not be able to afford. Still such costs can be split in time. Some good software
    architecture design methodologies, such as service-oriented architecture or microservices,
    can help to achieve this goal gradually. New project components (services or microservices)
    can be written using the new technology and existing ones can be ported one at
    a time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的主要原因是，将现有应用程序从Python 2迁移到Python 3始终是一个挑战。有一些工具，比如2to3可以执行自动代码转换，但不能保证结果是100%正确。此外，这样翻译的代码可能不如原始形式那样表现良好，需要手动调整。将现有复杂代码库移植到Python
    3可能需要巨大的努力和成本，一些组织可能无法承担。但这样的成本可以分摊。一些良好的软件架构设计方法，如面向服务的架构或微服务，可以帮助逐步实现这一目标。新项目组件（服务或微服务）可以使用新技术编写，现有项目可以逐个移植。
- en: In the long run, moving to Python 3 can only have beneficial effects on a project.
    According to PEP-404, there won't be a 2.8 release in the 2.x branch of Python
    anymore. Also, there may be a time in the future when all major projects such
    as Django, Flask, and numpy will drop any 2.x compatibility and will only be available
    on Python 3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，转移到Python 3对项目只会产生有益的影响。根据PEP-404，在Python 2.x分支中将不再发布2.8版本。此外，将来可能会有一段时间，像Django、Flask和numpy这样的所有主要项目都将放弃任何2.x兼容性，只能在Python
    3上使用。
- en: My personal opinion on this topic can be considered controversial. I think that
    the best incentive for the community would be to completely drop Python 2 support
    when creating new packages. This, of course, greatly limits the reach of such
    software but it may be the only way to change the way of thinking of those who
    insist on sticking to Python 2.x.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个话题的个人看法可能是有争议的。我认为对于社区来说，最好的激励是在创建新软件包时完全放弃对Python 2的支持。当然，这大大限制了这类软件的影响范围，但这可能是改变那些坚持使用Python
    2.x的人思维方式的唯一途径。
- en: The main differences between Python 3 and Python 2
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3和Python 2之间的主要区别
- en: It has already been said that Python 3 breaks backwards compatibility with Python
    2\. Still, it is not a complete redesign. Also, it does not mean that every Python
    module written for a 2.x release will stop working under Python 3\. It is possible
    to write completely cross-compatible code that will run on both major releases
    without additional tools or techniques, but usually it is possible only for simple
    applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 已经说过Python 3与Python 2破坏了向后兼容性。但这并不意味着完全重新设计。也不意味着每个为2.x版本编写的Python模块都将在Python
    3下停止工作。可以编写完全跨兼容的代码，将在两个主要版本上运行，而无需额外的工具或技术，但通常只适用于简单的应用程序。
- en: Why should I care?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我为什么要在意？
- en: Despite my personal opinion on Python 2 compatibility, exposed earlier in this
    chapter, it is impossible to simply forget about it right at this time. There
    are still some useful packages (such as fabric, mentioned in [Chapter 6](ch06.html
    "Chapter 6. Deploying Code"), *Deploying the Code*) that are really worth using
    but are not likely to be ported in the very near future.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在本章前面提到了我对Python 2兼容性的个人看法，但现在不可能就这样忘记它。仍然有一些有用的包（比如在[第6章](ch06.html "第6章。部署代码")中提到的fabric，*部署代码*）真的值得使用，但在不久的将来可能不会被移植。
- en: Also, sometimes we may be constrained by the organization we work in. The existing
    legacy code may be so complex that porting it is not economically feasible. So,
    even if we decide to move on and live only in the Python 3 world from now on,
    it will be impossible to completely live without Python 2 for some time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能会受到我们所在组织的限制。现有的遗留代码可能非常复杂，以至于移植它在经济上是不可行的。因此，即使我们决定从现在开始只在Python 3世界中生活，也不可能在一段时间内完全不使用Python
    2。
- en: Nowadays, it is very hard to name oneself a professional developer without giving
    something back to the community, so helping the open source developers in adding
    Python 3 compatibility to the existing packages is a good way to pay off the "moral
    debt" incurred by using them. This, of course, cannot be done without knowing
    the differences between Python 2 and Python 3\. By the way, this is also a great
    exercise for those new in Python 3.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，要成为专业开发人员，很难不回馈社区，因此帮助开源开发者将现有软件包添加Python 3兼容性是偿还使用它们所带来的“道义债务”的好方法。当然，这是不可能做到的，而不知道Python
    2和Python 3之间的差异。顺便说一句，这对于那些刚接触Python 3的人来说也是一个很好的练习。
- en: The main syntax differences and common pitfalls
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要的语法差异和常见陷阱
- en: The Python documentation is the best reference for differences between every
    release. Anyway, for readers' convenience, this section summarizes the most important
    ones. This does not change the fact that the documentation is mandatory reading
    for those not familiar with Python 3 yet (see [https://docs.python.org/3.0/whatsnew/3.0.html](https://docs.python.org/3.0/whatsnew/3.0.html)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档是每个版本之间差异的最佳参考。无论如何，为了方便读者，本节总结了最重要的差异。这并不改变文档对于那些尚不熟悉Python 3的人来说是必读的事实（参见[https://docs.python.org/3.0/whatsnew/3.0.html](https://docs.python.org/3.0/whatsnew/3.0.html)）。
- en: 'The breaking changes introduced by Python 3 can generally be divided into a
    few groups:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3引入的破坏性更改通常可以分为几个组：
- en: Syntax changes, wherein some syntax elements were removed/changed and other
    elements were added
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法更改，其中一些语法元素被移除/更改，其他元素被添加
- en: Changes in the standard library
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库的更改
- en: Changes in datatypes and collections
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型和集合的更改
- en: Syntax changes
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法更改
- en: 'Syntax changes that make it difficult for the existing code to run are the
    easiest to spot—they will cause the code to not run at all. The Python 3 code
    that features new syntax elements will fail to run on Python 2 and vice versa.
    The elements that are removed will make Python 2 code visibly incompatible with
    Python 3\. The running code that has such issues will immediately cause the interpreter
    to fail raising a `SyntaxError` exception. Here is an example of the broken script
    that has exactly two statements, of which none will be executed due to the syntax
    error:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使现有代码难以运行的语法更改是最容易发现的——它们将导致代码根本无法运行。具有新语法元素的Python 3代码将无法在Python 2上运行，反之亦然。被移除的元素将使Python
    2代码与Python 3明显不兼容。具有这些问题的运行代码将立即导致解释器失败，引发`SyntaxError`异常。以下是一个破损脚本的示例，其中恰好有两个语句，由于语法错误，都不会被执行：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Its actual result when run on Python 3 is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3上运行时的实际结果如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The list of such differences is a bit long and, from time to time, any new Python
    3.x release may add new elements of syntax that will raise such errors on earlier
    releases of Python (even on the same 3.x branch). The most important of them are
    covered in [Chapter 2](ch02.html "Chapter 2. Syntax Best Practices – below the
    Class Level"), *Syntax Best Practices – below the Class Level*, and [Chapter 3](ch03.html
    "Chapter 3. Syntax Best Practices – above the Class Level"), *Syntax Best Practices
    – above the Class Level*, so there is no need to list all of them here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的差异列表有点长，而且，任何新的Python 3.x版本可能会不时地添加新的语法元素，这些元素会在早期的Python版本（甚至在同一个3.x分支上）上引发错误。其中最重要的部分在[第2章](ch02.html
    "第2章。类级别以下的语法最佳实践")和[第3章](ch03.html "第3章。类级别以上的语法最佳实践")中都有所涵盖，因此这里没有必要列出所有这些内容。
- en: 'The list of things dropped or changed from Python 2.7 is shorter, so here are
    the most important ones:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 2.7中删除或更改的事项列表较短，因此以下是最重要的事项：
- en: '`print` is no longer a statement but a function instead, so the parenthesis
    is now obligatory.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`不再是语句，而是一个函数，因此括号现在是必需的。'
- en: Catching exceptions changed from `except exc, var` to `except exc as var`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常从`except exc, var`变为`except exc as var`。
- en: The `<>` comparison operator has been removed in favor of `!=`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<>`比较运算符已被移除，改用`!=`。'
- en: '`from module import *` ([https://docs.python.org/3.0/reference/simple_stmts.html#import](https://docs.python.org/3.0/reference/simple_stmts.html#import))
    is now allowed only on a module level, no longer inside the functions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from module import *`（[https://docs.python.org/3.0/reference/simple_stmts.html#import](https://docs.python.org/3.0/reference/simple_stmts.html#import)）现在只允许在模块级别上使用，不再在函数内部使用。'
- en: '`from .[module] import name` is now the only accepted syntax for relative imports.
    All imports not starting with the dot character are interpreted as absolute imports.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from .[module] import name`现在是相对导入的唯一接受的语法。所有不以点字符开头的导入都被解释为绝对导入。'
- en: The `sort()` function and the list's `sorted()` method no longer accept the
    `cmp` argument. The `key` argument should be used instead.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`函数和列表的`sorted()`方法不再接受`cmp`参数。应该使用`key`参数代替。'
- en: Division expressions on integers such as 1/2 return floats. The truncating behavior
    is achieved through the `//` operator like `1//2`. The good thing is that this
    can be used with floats too, so `5.0//2.0 == 2.0`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数的除法表达式，如1/2会返回浮点数。截断行为是通过`//`运算符实现的，比如`1//2`。好处是这也可以用于浮点数，所以`5.0//2.0 == 2.0`。
- en: Changes in the standard library
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库中的变化
- en: Breaking changes in the standard library are the second easiest to catch after
    syntax changes. Each subsequent version of Python adds, deprecates, improves,
    or completely removes standard library modules. Such a process was regular also
    in the older versions of Python (1.x and 2.x), so it does not come as a shock
    in Python 3\. In most cases, depending on the module that was removed or reorganized
    (like `urlparse` being moved to `urllib.parse`), it will raise exceptions on the
    import time just after it was interpreted. This makes such issues so easy to catch.
    Anyway, in order to be sure that all such issues are covered, the full test code
    coverage is essential. In some cases (for example, when using lazily loaded modules),
    the issues that are usually noticed on import time will not appear before some
    modules are used in code as function calls. This is why, it is so important to
    make sure that every line of code is actually executed during tests suite.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的重大变化是在语法变化之后最容易捕捉到的。每个后续版本的Python都会添加、弃用、改进或完全删除标准库模块。这样的过程在Python的旧版本（1.x和2.x）中也是常见的，因此在Python
    3中并不令人震惊。在大多数情况下，根据被移除或重新组织的模块（比如`urlparse`被移动到`urllib.parse`），它将在导入时立即引发异常。这使得这类问题很容易被捕捉到。无论如何，为了确保所有这类问题都得到覆盖，完整的测试代码覆盖是必不可少的。在某些情况下（例如，当使用延迟加载模块时），通常在导入时注意到的问题在一些模块作为函数调用的代码中使用之前不会出现。这就是为什么在测试套件中确保每行代码实际执行非常重要。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Lazily loaded modules**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟加载模块**'
- en: A lazily loaded module is a module that is not loaded on import time. In Python,
    `import` statements can be included inside of functions so import will happen
    on a function call and not on import time. In some cases, such loading of modules
    may be a reasonable choice but in most cases, it is a workaround for poorly designed
    module structures (for example, to avoid circular imports) and should be generally
    avoided. For sure, there is no justifiable reason to lazily load standard library
    modules.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载模块是在导入时不加载的模块。在Python中，`import`语句可以包含在函数内部，因此导入将在函数调用时发生，而不是在导入时发生。在某些情况下，这种模块的加载可能是一个合理的选择，但在大多数情况下，这是对设计不佳的模块结构的一种变通方法（例如，避免循环导入），并且通常应该避免。毫无疑问，没有理由去延迟加载标准库模块。
- en: Changes in datatypes and collections
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型和集合的变化
- en: Changes in how Python represents datatypes and collections require the most
    effort when the developer tries to maintain compatibility or simply port existing
    code to Python 3\. While incompatible syntax or standard library changes are easily
    noticeable and the most easy to fix, changes in collections and types are either
    nonobvious or require a lot of repetitive work. A list of such changes is long
    and, again, official documentation is the best reference.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python表示数据类型和集合的变化需要开发人员在尝试保持兼容性或简单地将现有代码移植到Python 3时付出最大的努力。虽然不兼容的语法或标准库变化很容易被注意到并且最容易修复，但集合和类型的变化要么不明显，要么需要大量重复的工作。这样的变化列表很长，再次，官方文档是最好的参考。
- en: Still, this section must cover the change in how string literals are treated
    in Python 3 because it seems to be the most controversial and discussed change
    in Python 3, despite being a very good thing that now makes things more explicit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一部分必须涵盖Python 3中字符串文字处理方式的变化，因为尽管这是一个非常好的变化，现在使事情更加明确，但它似乎是Python 3中最具争议和讨论的变化。
- en: All string literals are now Unicode and `bytes` literals require a `b` or `B`
    prefix. For Python 3.0 and 3.1 using `u` prefix (like `u"foo"`) was dropped and
    will raise a syntax error. Dropping that prefix was the main reason for all controversies.
    It made really hard to create code that was compatible in different branches of
    Python—version 2.x relied on this prefix in order to create Unicode literals.
    This prefix was brought back in Python 3.3 to ease the integration process, although
    without any syntactic meaning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符串文字现在都是Unicode，`bytes`文字需要`b`或`B`前缀。对于Python 3.0和3.1，使用`u`前缀（如`u"foo"`）已被删除，并将引发语法错误。放弃该前缀是所有争议的主要原因。这使得在不同分支的Python版本中创建兼容的代码变得非常困难——版本2.x依赖于该前缀以创建Unicode文字。该前缀在Python
    3.3中被重新引入以简化集成过程，尽管没有任何语法意义。
- en: The popular tools and techniques used for maintaining cross-version compatibility
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于维护跨版本兼容性的流行工具和技术
- en: Maintaining compatibility between versions of Python is a challenge. It may
    add a lot of additional work depending on the size of the project but is definitely
    doable and worth doing. For packages that are meant to be reused in many environments,
    it is an absolute must have. Open source packages without well-defined and tested
    compatibility bounds are very unlikely to become popular, but also, closed third-party
    code that never leaves the company network can greatly benefit from being tested
    in different environments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python版本之间保持兼容性是一项挑战。这可能会增加很多额外的工作，具体取决于项目的规模，但绝对是可行的，也是值得做的。对于旨在在许多环境中重复使用的软件包，这是绝对必须的。没有明确定义和测试过的兼容性边界的开源软件包很不可能变得流行，但也是，从不离开公司网络的封闭的第三方代码可以从在不同环境中进行测试中获益。
- en: It should be noted here that while this part focuses mainly on compatibility
    between various versions of Python, these approaches apply for maintaining compatibility
    with external dependencies like different package versions, binary libraries,
    systems, or external services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然本部分主要关注Python的各个版本之间的兼容性，但这些方法也适用于与外部依赖项（如不同的软件包版本、二进制库、系统或外部服务）保持兼容性。
- en: 'The whole process can be divided into three main areas, ordered by importance:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分为三个主要领域，按重要性排序：
- en: Defining and documenting target compatibility bounds and how they will be managed
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和记录目标兼容性边界以及如何管理它们
- en: Testing in every environment and with every dependency version declared as compatible
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个环境和每个声明为兼容的依赖版本中进行测试
- en: Implementing actual compatibility code
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施实际的兼容性代码
- en: Declaration of what is considered compatible is the most important part of the
    whole process because it gives the users of the code (developers) the ability
    to have expectations and make assumptions on how it works and how it can change
    in the future. Our code can be used as a dependency in different projects that
    may also strive to manage compatibility, so the ability to reason how it behaves
    is crucial.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义什么被认为是兼容的是整个过程中最重要的部分，因为它为代码的用户（开发人员）提供了对其工作方式和未来可能发生变化的期望和假设的能力。我们的代码可以作为不同项目中的依赖项使用，这些项目可能也致力于管理兼容性，因此理解其行为方式的能力至关重要。
- en: 'While this book tries to always give a few choices rather than to give an absolute
    recommendation on specific options, here is one of the few exceptions. The best
    way so far to define how compatibility may change in the future is by the proper
    approach to versioning numbers using *Semantic Versioning* ([http://semver.org/](http://semver.org/)),
    or shortly, semver. It describes a broadly accepted standard for marking the scope
    of change in code by the version specifier consisting only of three numbers. It
    also gives some advice on how to handle deprecation policies. Here is an excerpt
    from its summary:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书试图总是提供几种选择，而不是对特定选项给出绝对建议，但这是少数例外之一。到目前为止，定义未来兼容性可能如何改变的最佳方法是使用*语义化版本*（[http://semver.org/](http://semver.org/)），或简称semver。它描述了一种广泛接受的标准，通过版本说明符仅由三个数字组成，标记了代码变化的范围。它还提供了一些建议，关于如何处理弃用策略。以下是其摘要的一部分：
- en: 'Given a version number `MAJOR.MINOR.PATCH`, increment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给定版本号`MAJOR.MINOR.PATCH`，递增：
- en: A `MAJOR` version when you make incompatible API changes
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您进行不兼容的API更改时，使用`MAJOR`版本
- en: A `MINOR` version when you add functionality in a backwards-compatible manner
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向后兼容的方式中添加功能时的`MINOR`版本
- en: A `PATCH` version when you make backwards-compatible bug fixes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您进行向后兼容的错误修复时，使用`PATCH`版本
- en: Additional labels for pre-release and build metadata are available as extensions
    to the `MAJOR.MINOR.PATCH` format.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 预发布和构建元数据的附加标签可作为`MAJOR.MINOR.PATCH`格式的扩展。
- en: When it comes to testing, the sad truth is that to be sure that code is compatible
    with every declared dependency version and in every environment (here, the Python
    version), it must be tested in every combination of these. This, of course, may
    not be possible when the project has a lot of dependencies because the number
    of combinations grows rapidly with every new dependency in a version. So, typically
    some trade off needs to be made so that running full compatibility tests does
    not take ages. A selection of tools that help testing in so-called matrixes is
    presented in [Chapter 10](ch10.html "Chapter 10. Test-Driven Development"), *Test-Driven
    Development*, that discusses testing in general.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及测试时，令人沮丧的事实是，为了确保代码与每个声明的依赖版本和每个环境（这里是Python版本）兼容，必须在这些组合的每个组合中进行测试。当项目具有大量依赖项时，这当然可能是不可能的，因为随着每个新版本的依赖项，组合的数量会迅速增长。因此，通常需要做出一些权衡，以便运行完整的兼容性测试不会花费很长时间。在[第10章](ch10.html
    "第10章。测试驱动开发")中介绍了一些帮助测试所谓矩阵的工具，*测试驱动开发*，讨论了测试。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The benefit of using projects that follow semver is that usually what needs
    to be tested are only major releases because minor and patch releases are guaranteed
    not to include backwards incompatible changes. This is only true if such projects
    can be trusted not to break such a contract. Unfortunately, mistakes happen to
    everyone and backward incompatible changes happen in a lot of projects, even on
    patch versions. Still, since semver declares strict compatibility on minor and
    patch version changes, breaking it is considered a bug, so it may be fixed in
    patch release.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遵循semver的项目的好处通常是只需要测试主要版本，因为次要和补丁版本保证不包含向后不兼容的更改。只有在这样的项目可以信任不违反这样的合同时才成立。不幸的是，每个人都会犯错误，并且许多项目甚至在补丁版本上也会发生向后不兼容的更改。然而，由于semver声明了次要和补丁版本更改的严格兼容性，违反它被认为是一个错误，因此可以在补丁版本中修复。
- en: Implementation of the compatibility layer is last and also least important if
    bounds of that compatibility are well-defined and rigorously tested. Still there
    are some tools and techniques that every programmer interested in such a topic
    should know.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性层的实现是最后的，也是最不重要的，如果该兼容性的边界被明确定义并经过严格测试。但是，仍然有一些工具和技术，每个对这样一个主题感兴趣的程序员都应该知道。
- en: 'The most basic is Python''s `__future__` module. It ports back some features
    from newer Python releases back into the older ones and takes the form of import
    statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的是Python的`__future__`模块。它将一些新版本Python的功能移回到旧版本，并采用import语句的形式：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Features provided by `future` statements are syntax-related elements that cannot
    be easily handled by different means. This statement affects only the module where
    it was used. Here is an example of Python 2.7 interactive session that brings
    Unicode literals from Python 3.0:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`future`语句提供的功能是与语法相关的元素，不能通过其他方式轻松处理。此语句仅影响其使用的模块。以下是Python 2.7交互会话的示例，它从Python
    3.0中引入了Unicode文字：'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a list of all the available `__future__` statement options that developers
    concerned with 2/3 compatibility should know:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有可用的`__future__`语句选项的列表，关心2/3兼容性的开发人员应该知道：
- en: '`division`: This adds a Python 3 division operator (PEP 238)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`division`：这添加了Python 3的除法运算符（PEP 238）'
- en: '`absolute_import`: This makes every form of `import` statement not starting
    with a dot character interpreted as an absolute import (PEP 328)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`absolute_import`：这使得以点字符开头的`import`语句的每种形式都被解释为绝对导入（PEP 328）'
- en: '`print_function`: This changes a `print` statement into a function call, so
    parentheses around `print` becomes mandatory (PEP 3112)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_function`：这将把`print`语句改为函数调用，因此`print`周围的括号变得必需（PEP 3112）'
- en: '`unicode_literals`: This makes every string literal interpreted as Unicode
    literals (PEP 3112)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unicode_literals`：这使得每个字符串文字都被解释为Unicode文字（PEP 3112）'
- en: A list of the `__future__` statement options is very short and it covers only
    a few syntax features. The other things that have changed like the metaclass syntax
    (which is an advanced feature covered in [Chapter 3](ch03.html "Chapter 3. Syntax
    Best Practices – above the Class Level"), *Syntax Best Practices – above the Class
    Level*), are a lot harder to maintain. Reliably handling of multiple standard
    library reorganizations also cannot be solved by `future` statements. Happily,
    there are some tools that aim to provide a consistent layer of ready-to-use compatibility.
    The most commonly known is Six ([https://pypi.python.org/pypi/six/](https://pypi.python.org/pypi/six/))
    that provides whole common 2/3 compatibility boilerplate as a single module. The
    other promising but slightly less popular tool is the future module ([http://python-future.org/](http://python-future.org/)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`__future__`语句选项的列表非常短，只涵盖了一些语法特性。像元类语法（这是一个高级特性，涵盖在[第3章](ch03.html "第3章。语法最佳实践-类级别以上")中，*语法最佳实践-类级别以上*）这样的其他更改，要维护起来就困难得多。可靠地处理多个标准库重组也不能通过`future`语句解决。幸运的是，有一些工具旨在提供一致的可用兼容性层。最常见的是Six（[https://pypi.python.org/pypi/six/](https://pypi.python.org/pypi/six/)），它提供了整个通用的2/3兼容性样板作为单个模块。另一个有前途但稍微不那么受欢迎的工具是future模块（[http://python-future.org/](http://python-future.org/)）。'
- en: 'In some situations, developers may not want to include additional dependencies
    in some small packages. A common practice is the additional module that gathers
    all the compatibility code, usually named `compat.py`. Here is an example of such
    a `compat` module taken from the `python-gmaps` project ([https://github.com/swistakm/python-gmaps](https://github.com/swistakm/python-gmaps)):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，开发人员可能不希望在一些小包中包含额外的依赖项。一个常见的做法是额外的模块，它收集所有兼容性代码，通常命名为`compat.py`。以下是从`python-gmaps`项目（[https://github.com/swistakm/python-gmaps](https://github.com/swistakm/python-gmaps)）中获取的这样一个`compat`模块的示例：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Such a `compat.py` module is popular even in projects that depends on Six for
    2/3 compatibility because it is a very convenient way to store code that handles
    compatibility with different versions of packages used as dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在依赖于Six进行2/3兼容性的项目中，这样的`compat.py`模块也很受欢迎，因为这是一种非常方便的方式来存储处理与用作依赖项的不同版本的包的兼容性的代码。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**支持**选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**代码下载和勘误**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书名。
- en: Select the book for which you're looking to download the code files.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书的位置。
- en: Click on **Code Download**.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，请确保使用最新版本的解压或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR / 7-Zip for Windows
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg / iZip / UnRarX for Mac
- en: 7-Zip / PeaZip for Linux
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip / PeaZip for Linux
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition](https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition](https://github.com/PacktPublishing/Expert-Python-Programming_Second-Edition)。我们还有其他丰富的书籍和视频代码包可供使用，网址为[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)。去看看吧！
- en: Not only CPython
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不仅仅是CPython
- en: The main Python implementation is written in the C language and is called **CPython**.
    It is the one that the majority of people refer to when they talk about Python.
    When the language evolves, the C implementation is changed accordingly. Besides
    C, Python is available in a few other implementations that are trying to keep
    up with the mainstream. Most of them are a few milestones behind CPython, but
    provide a great opportunity to use and promote the language in a specific environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Python实现是用C语言编写的，称为**CPython**。当语言发展时，C实现会相应地进行更改。除了C，Python还有其他几种实现，它们试图跟上主流。它们中的大多数都比CPython落后了几个里程碑，但为在特定环境中使用和推广该语言提供了绝佳的机会。
- en: Why should I care?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我为什么要在意呢？
- en: 'There are plenty of alternative Python implementations available. The Python
    Wiki page on that topic ([https://wiki.python.org/moin/PythonImplementations](https://wiki.python.org/moin/PythonImplementations))
    features more than 20 different language variants, dialects, or implementations
    of Python interpreter built with something else than C. Some of them implement
    only a subset of the core language syntax, features, and built-in extensions but
    there is at least a few that are almost fully compatible with CPython. The most
    important thing to know is that while some of them are just toy projects or experiments,
    most of them were created to solve some real problems – problems that were either
    impossible to solve with CPython or required too much of the developer''s effort.
    Examples of such problems are:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可用的替代Python实现。关于这个主题的Python Wiki页面（[https://wiki.python.org/moin/PythonImplementations](https://wiki.python.org/moin/PythonImplementations)）列出了20多种不同的语言变体、方言或Python解释器的实现，这些实现都是用其他语言而不是C构建的。其中一些只实现了核心语言语法、特性和内置扩展的子集，但至少有一些几乎完全兼容CPython。最重要的是要知道，虽然其中一些只是玩具项目或实验，但大多数是为了解决一些真正的问题而创建的——这些问题要么无法用CPython解决，要么需要开发人员付出太多的努力。这些问题的例子有：
- en: Running Python code on embedded systems
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌入式系统上运行Python代码
- en: Integration with code written for runtime frameworks such as Java or .NET or
    in different languages
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Java或.NET等运行时框架编写的代码集成，或者与不同语言编写的代码集成
- en: Running Python code in web browsers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web浏览器中运行Python代码
- en: This section provides a short description of subjectively most popular and up-to-date
    choices that are currently available for Python programmers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一个主观上最受欢迎和最新的选择的简短描述，这些选择目前适用于Python程序员。
- en: Stackless Python
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stackless Python
- en: Stackless Python advertises itself as an enhanced version of Python. Stackless
    is named so because it avoids depending on the C call stack for its own stack.
    It is in fact a modified CPython code that also adds some new features that were
    missing from core Python implementation at the time Stackless was created. The
    most important of them are microthreads managed by the interpreter as a cheap
    and lightweight alternative to ordinary threads that must depend on system kernel
    context switching and tasks scheduling.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Stackless Python自称是Python的增强版本。Stackless之所以被命名为Stackless，是因为它避免依赖C调用堆栈来进行自己的堆栈。实际上，它是修改过的CPython代码，还添加了一些当时核心Python实现中缺失的新功能。其中最重要的是由解释器管理的微线程，它是普通线程的一种廉价而轻量级的替代，普通线程必须依赖于系统内核上下文切换和任务调度。
- en: The latest available versions are 2.7.9 and 3.3.5 that implement 2.7 and 3.3
    versions of Python respectively. All the additional features provided by Stackless
    are exposed as a framework within this distribution through the built-in `stackless`
    module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最新可用的版本是2.7.9和3.3.5，分别实现了Python 2.7和3.3版本。Stackless提供的所有附加功能都通过内置的`stackless`模块作为该发行版中的一个框架暴露出来。
- en: Stackless isn't the most popular alternative implementation of Python, but it
    is worth knowing because ideas introduced in it have had a strong impact on the
    language community. The core switching functionality was extracted from Stackless
    and published as an independent package named `greenlet`, which is now a basis
    for many useful libraries and frameworks. Also, most of its features were re-implemented
    in PyPy—another Python implementation that will be featured later. Refer to [http://stackless.readthedocs.org/](http://stackless.readthedocs.org/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Stackless并不是Python的最受欢迎的替代实现，但它值得知道，因为它引入的想法对语言社区产生了很大的影响。核心切换功能是从Stackless中提取出来的，并发布为一个名为`greenlet`的独立包，现在已经成为许多有用的库和框架的基础。此外，它的大多数功能已经在PyPy中重新实现，PyPy是另一个稍后将介绍的Python实现。参考[http://stackless.readthedocs.org/](http://stackless.readthedocs.org/)。
- en: Jython
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jython
- en: Jython is a Java implementation of the language. It compiles the code into Java
    byte code, and allows the developers to seamlessly use Java classes within their
    Python modules. Jython allows people to use Python as the top-level scripting
    language on complex application systems, for example, J2EE. It also brings Java
    applications into the Python world. Making Apache Jackrabbit (which is a document
    repository API based on JCR; see [http://jackrabbit.apache.org](http://jackrabbit.apache.org))
    available in a Python program is a good example of what Jython allows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Jython是语言的Java实现。它将代码编译成Java字节码，并允许开发人员在其Python模块中无缝使用Java类。Jython允许人们在复杂的应用系统中使用Python作为顶级脚本语言，例如J2EE。它还将Java应用程序引入Python世界。使Apache
    Jackrabbit（这是一个基于JCR的文档存储库API；请参见[http://jackrabbit.apache.org](http://jackrabbit.apache.org)）在Python程序中可用是Jython允许的一个很好的例子。
- en: The latest available version of Jython is Jython 2.7, and this corresponds to
    2.7 version of the language. It is advertised as implementing nearly all of the
    core Python standard library and uses the same regression test suite. The version
    of Jython 3.x is under development.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Jython的最新可用版本是Jython 2.7，对应于语言的2.7版本。它被宣传为几乎实现了所有核心Python标准库，并使用相同的回归测试套件。Jython
    3.x的版本正在开发中。
- en: 'The main differences of Jython as compared to CPython implementation are:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与CPython实现相比，Jython的主要区别是：
- en: True Java's garbage collection instead of reference counting
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的Java垃圾回收，而不是引用计数
- en: The lack of **GIL** (**global interpreter lock**) allows a better utilization
    of multiple cores in multi-threaded applications
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏全局解释器锁（GIL）允许更好地利用多核在多线程应用程序中
- en: The main weakness of this implementation of the language is the lack of support
    for C Python Extension APIs, so no Python extensions written in C will work with
    Jython. This might change in the future because there are plans to support the
    C Python Extension API in Jython 3.x.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言实现的主要弱点是不支持CPython扩展API，因此不支持用C编写的Python扩展将无法在Jython中运行。这可能会在未来发生变化，因为计划在Jython
    3.x中支持CPython扩展API。
- en: Some Python web frameworks such as Pylons were known to be boosting Jython development
    to make it available in the Java world. Refer to [http://www.jython.org](http://www.jython.org).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python Web框架，如Pylons，被认为正在推动Jython的发展，使其在Java世界中可用。参见[http://www.jython.org](http://www.jython.org)。
- en: IronPython
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IronPython
- en: IronPython brings Python into the .NET Framework. The project is supported by
    Microsoft, where IronPython's lead developers work. It is quite an important implementation
    for the promotion of a language. Besides Java, the .NET community is one of the
    biggest developer communities out there. It is also worth noting that Microsoft
    provides a set of free development tools that turn Visual Studio into full-fledged
    Python IDE. This is distributed as Visual Studio plugins named **PVTS** (**Python
    Tools for** **Visual Studio**) and is available as open source code on GitHub
    ([http://microsoft.github.io/PTVS](http://microsoft.github.io/PTVS)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython将Python引入了.NET Framework。该项目得到了微软的支持，IronPython的主要开发人员在这里工作。这对于推广一种语言来说是非常重要的实现。除了Java，.NET社区是最大的开发者社区之一。值得注意的是，微软提供了一套免费的开发工具，可以将Visual
    Studio变成一个功能齐全的Python IDE。这被分发为名为**PVTS**（**Visual Studio的Python工具**）的Visual Studio插件，并且作为开源代码在GitHub上可用（[http://microsoft.github.io/PTVS](http://microsoft.github.io/PTVS)）。
- en: The latest stable release is 2.7.5 and it is compatible with Python 2.7\. Similar
    to Jython, there is some development around Python 3.x implementation, but there
    is no stable release available yet. Despite the fact that .NET runs primarily
    on Microsoft Windows, it is possible to run IronPython also on Mac OS X and Linux.
    This is thanks to Mono, a cross platform, open source .NET implementation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的稳定版本是2.7.5，与Python 2.7兼容。与Jython类似，Python 3.x实现周围也有一些开发，但目前还没有稳定版本。尽管.NET主要在Microsoft
    Windows上运行，但也可以在Mac OS X和Linux上运行IronPython。这要归功于Mono，一个跨平台的开源.NET实现。
- en: 'Main differences or advantages of IronPython as compared to CPython are as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython相对于CPython的主要区别或优势如下：
- en: Similar to Jython, the lack of GIL (global interpreter lock) allows the better
    utilization of multiple cores in multi-threaded applications
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Jython类似，缺乏全局解释器锁（GIL）允许更好地利用多核在多线程应用程序中
- en: Code written in C# and other .NET languages can be easily integrated in IronPython
    and vice versa
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用C#和其他.NET语言编写的代码可以轻松集成到IronPython中，反之亦然
- en: Can be run in all major web browsers through Silverlight
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在所有主要的Web浏览器中通过Silverlight运行
- en: When speaking about weaknesses, IronPython, again, seems very similar to Jython
    because it does not support the C Python Extension APIs. This is important for
    developers who would like to use packages such as numpy that are largely based
    on C extensions. There is a project called ironclad (refer to [https://github.com/IronLanguages/ironclad](https://github.com/IronLanguages/ironclad))
    that aims to allow using such extensions seamlessly with IronPython, albeit its
    last known supported release is 2.6 and development seems to have stopped at this
    point. Refer to [http://ironpython.net/](http://ironpython.net/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython的弱点与Jython非常相似，因为它不支持CPython扩展API。这对于希望使用诸如numpy之类的大部分基于C扩展的软件包的开发人员来说非常重要。有一个名为ironclad的项目（参见[https://github.com/IronLanguages/ironclad](https://github.com/IronLanguages/ironclad)），旨在允许使用这些扩展与IronPython无缝集成，尽管其最后已知支持的版本是2.6，开发似乎已经停止。参见[http://ironpython.net/](http://ironpython.net/)。
- en: PyPy
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPy
- en: PyPy is probably the most exciting implementation, as its goal is to rewrite
    Python into Python. In PyPy, the Python interpreter is itself written in Python.
    We have a C code layer carrying out the nuts-and-bolts work for the CPython implementation
    of Python. However, in the PyPy implementation, this C code layer is rewritten
    in pure Python.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy可能是最令人兴奋的实现，因为其目标是将Python重写为Python。在PyPy中，Python解释器本身就是用Python编写的。我们有一个C代码层来执行Python的CPython实现的基本工作。然而，在PyPy实现中，这个C代码层被重写为纯Python。
- en: This means you can change the interpreter's behavior during execution time and
    implement code patterns that couldn't be easily done in CPython.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以在执行时更改解释器的行为，并实现在CPython中无法轻松完成的代码模式。
- en: PyPy currently aims to be fully compatible with Python 2.7, while PyPy3 is compatible
    with Python 3.2.5 version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy目前旨在与Python 2.7完全兼容，而PyPy3与Python 3.2.5版本兼容。
- en: In the past, PyPy was interesting mostly for theoretical reasons, and it interested
    those who enjoyed going deep into the details of the language. It was not generally
    used in production, but this has changed through the years. Nowadays, many benchmarks
    show that surprisingly PyPy is often way faster than the CPython implementation.
    This project has its own benchmarking site that tracks the performance of each
    version measured using tens of different benchmarks (refer to [http://speed.pypy.org/](http://speed.pypy.org/)).
    It clearly shows that PyPy with JIT enabled is at least a few times faster than
    CPython. This and other features of PyPy makes more and more developers decide
    to switch to PyPy in their production environments.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，PyPy主要因理论原因而引人关注，它吸引了那些喜欢深入了解语言细节的人。它并不常用于生产，但这在多年来已经发生了改变。如今，许多基准测试显示，令人惊讶的是，PyPy通常比CPython实现要快得多。该项目有自己的基准测试网站，跟踪每个版本的性能，使用数十种不同的基准测试进行测量（参见[http://speed.pypy.org/](http://speed.pypy.org/)）。这清楚地表明，启用JIT的PyPy至少比CPython快几倍。这和PyPy的其他特性使越来越多的开发人员决定在生产环境中切换到PyPy。
- en: 'The main differences of PyPy as compared to the CPython implementation are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy与CPython实现相比的主要区别是：
- en: Garbage collection is used instead of reference counting
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用垃圾收集而不是引用计数
- en: Integrated tracing JIT compiler that allows impressive improvements in performance
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成跟踪JIT编译器可以显著提高性能
- en: Application-level Stackless features are borrowed from Stackless Python
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Stackless Python借用的应用级Stackless功能
- en: Like almost every other alternative Python implementation, PyPy lacks the full
    official support of C Python Extension API. Still it, at least, provides some
    sort of support for C extensions through its CPyExt subsystem, although it is
    poorly documented and still not feature complete. Also, there is an ongoing effort
    within the community in porting NumPy to PyPy because it is the most requested
    feature. Refer to [http://pypy.org](http://pypy.org).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有其他替代Python实现一样，PyPy缺乏对CPython扩展API的全面官方支持。尽管如此，它至少通过其CPyExt子系统提供了对C扩展的某种支持，尽管文档贫乏且功能尚不完整。此外，社区正在努力将NumPy移植到PyPy，因为这是最受欢迎的功能。参见[http://pypy.org](http://pypy.org)。
- en: Modern approaches to Python development
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python开发的现代方法
- en: A deep understanding of the programming language of choice is the most important
    thing to harness as an expert. This will always be true for any technology. Still,
    it is really hard to develop a good software without knowing the common tools
    and practices within the given language community. Python has no single feature
    that could not be found in some other language. So, in direct comparison of syntax,
    expressiveness, or performance, there will always be a solution that is better
    in one or more fields. But the area in which Python really stands out from the
    crowd is in the whole ecosystem built around the language. Its community has,
    for years, polished the standard practices and libraries that help to create more
    reliable software in a shorter time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的编程语言的深入理解是作为专家最重要的事情。这对于任何技术来说都是真实的。然而，如果不了解特定语言社区内的常用工具和实践，要开发出优秀的软件是非常困难的。Python没有任何一个特性是其他语言中找不到的。因此，在语法、表现力或性能的直接比较中，总会有一个或多个领域更好的解决方案。但Python真正脱颖而出的领域是围绕该语言构建的整个生态系统。多年来，Python社区一直在完善标准实践和库，帮助更快地创建更可靠的软件。
- en: The most obvious and important part of the mentioned ecosystem is a huge collection
    of free and open source packages that solve a multitude of problems. Writing new
    software is always an expensive and time-consuming process. Being able to reuse
    the existing code instead of *reinventing the wheel* greatly reduces the time
    and costs of development. For some companies, it is the only reason their projects
    are economically feasible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的生态系统中最明显和重要的部分是大量解决各种问题的免费开源软件包。编写新软件总是一个昂贵且耗时的过程。能够重用现有代码而不是“重复造轮子”大大减少了开发的时间和成本。对一些公司来说，这是他们的项目经济可行的唯一原因。
- en: Due to this reason, Python developers put a lot of effort on creating tools
    and standards to work with open source packages created by others. Starting from
    virtual isolated environments, improved interactive shells and debuggers, to programs
    that help to discover, search, and analyze the huge collection of packages available
    on **PyPI** (**Python Package Index**).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python开发人员花了很多精力来创建工具和标准，以处理他人创建的开源软件包。从虚拟隔离环境、改进的交互式shell和调试器，到帮助发现、搜索和分析**PyPI**（**Python软件包索引**）上可用的大量软件包的程序。
- en: Application-level isolation of Python environments
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python环境的应用级隔离
- en: Nowadays, a lot of operating systems come with Python as a standard component.
    Most Linux distributions and Unix-based systems such as FreeBSD, NetBSD, OpenBSD,
    or OS X come with Python are either installed by default or available through
    system package repositories. Many of them even use it as part of some core components—Python
    powers the installers of Ubuntu (Ubiquity), Red Hat Linux (Anaconda), and Fedora
    (Anaconda again).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多操作系统都将Python作为标准组件。大多数Linux发行版和基于Unix的系统，如FreeBSD、NetBSD、OpenBSD或OS X，都默认安装了Python，或者可以通过系统软件包存储库获得。其中许多甚至将其用作一些核心组件的一部分——Python驱动Ubuntu（Ubiquity）、Red
    Hat Linux（Anaconda）和Fedora（再次是Anaconda）的安装程序。
- en: 'Due to this fact, a lot of packages from PyPI are also available as native
    packages managed by the system''s package management tools such as `apt-get` (Debian,
    Ubuntu), `rpm` (Red Hat Linux), or `emerge` (Gentoo). Although it should be remembered
    that the list of available libraries is very limited and they are mostly outdated
    when compared to PyPI. This is the reason why `pip` should always be used to obtain
    new packages in the latest version as a recommendation of **PyPA** (**Python Packaging
    Authority**). Although it is an independent package starting from version 2.7.9
    and 3.4 of CPython, it is bundled with every new release by default. Installing
    the new package is as simple as this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个事实，PyPI上的许多软件包也可以作为系统软件包管理工具（如`apt-get`（Debian，Ubuntu），`rpm`（Red Hat Linux）或`emerge`（Gentoo））管理的本地软件包。尽管应该记住，可用库的列表非常有限，而且与PyPI相比，它们大多已经过时。这就是为什么`pip`应该始终被用来获取最新版本的新软件包，作为**PyPA**（**Python
    Packaging Authority**）的建议。尽管它是CPython 2.7.9和3.4版本的独立软件包，但它默认随每个新版本捆绑发布。安装新软件包就像这样简单：
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Among other features, `pip` allows forcing specific versions of packages (using
    the `pip install package-name==version` syntax) and upgrading to the latest version
    available (using the `––upgrade` switch). The full usage description for most
    of the command-line tools presented in the book can be easily obtained simply
    by running the command with the `-h` or `--help` switch, but here is an example
    session that demonstrates the most commonly used options:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他功能外，`pip`允许强制使用特定版本的软件包（使用`pip install package-name==version`语法）并升级到最新可用版本（使用`--upgrade`开关）。本书中介绍的大多数命令行工具的完整使用说明可以通过简单地运行带有`-h`或`--help`开关的命令来轻松获得，但这里有一个示例会话，演示了最常用的选项：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In some cases, `pip` may not be available by default. From Python 3.4 version
    onwards (and also Python 2.7.9), it can always be bootstrapped using the `ensurepip`
    module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`pip`可能不是默认可用的。从Python 3.4版本开始（也是Python 2.7.9），它始终可以使用`ensurepip`模块进行引导：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The most up-to-date information on how to install pip for older Python versions
    is available on the project's documentation page at [https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何为旧版本的Python安装pip的最新信息，请访问项目的文档页面[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)。
- en: Why isolation?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要隔离？
- en: '`pip` may be used to install system-wide packages. On Unix-based and Linux
    systems, this will require super user privileges, so the actual invocation will
    be:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`可用于安装系统范围的软件包。在基于Unix和Linux的系统上，这将需要超级用户权限，因此实际调用将是：'
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that this is not required on Windows since it does not provide the Python
    interpreter by default, and Python on Windows is usually installed manually by
    the user without super user privileges.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这在Windows上不是必需的，因为它默认不提供Python解释器，通常由用户手动安装Python而不需要超级用户权限。
- en: Anyway, installing system-wide packages directly from PyPI is not recommended
    and should be avoided. This may seem like a contradiction with the previous statement
    that using `pip` is a PyPA recommendation, but there are some serious reasons
    for that. As explained earlier, Python is very often an important part of many
    packages available through operating system package repositories and may power
    a lot of important services. System distribution maintainers put a lot of effort
    in selecting the correct versions of packages to match various package dependencies.
    Very often, Python packages that are available from system's package repositories
    contain custom patches or are kept outdated only to ensure compatibility with
    some other system components. Forcing an update of such a package using `pip`
    to a version that breaks some backwards compatibility might break some crucial
    system services.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，不建议直接从PyPI全局安装系统范围的软件包，应该避免这样做。这似乎与之前的使用`pip`是PyPA建议的说法相矛盾，但这其中有一些严重的原因。如前所述，Python往往是许多通过操作系统软件包存储库可用的软件包的重要组成部分，并且可能支持许多重要的服务。系统分发维护者在选择正确的软件包版本以匹配各种软件包依赖关系方面付出了很多努力。经常情况下，从系统软件包存储库中可用的Python软件包包含自定义补丁或者保持过时，只是为了确保与其他一些系统组件的兼容性。使用`pip`强制更新此类软件包到破坏某些向后兼容性的版本可能会破坏一些关键的系统服务。
- en: Doing such things only on the local computer for development purposes is also
    not a good excuse. Recklessly using `pip` that way is almost always asking for
    trouble and will eventually lead to issues that are very hard to debug. This does
    not mean that installing packages from PyPI globally is a strictly forbidden thing,
    but it should always be done consciously and while knowing the related risks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在本地计算机上进行开发目的的这样做也不是一个好的借口。这样鲁莽地使用`pip`几乎总是在自找麻烦，并最终会导致非常难以调试的问题。这并不意味着全局安装来自PyPI的软件包是严格禁止的，但它应该始终是有意识地并且了解相关风险的情况下进行的。
- en: 'Fortunately, there is an easy solution to this problem—environment isolation.
    There are various tools that allow the isolation of the Python runtime environment
    at different levels of system abstraction. The main idea is to isolate project
    dependencies from packages required by different projects and/or system services.
    The benefits of this approach are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的解决方案——环境隔离。有各种工具可以在不同系统抽象级别上隔离Python运行时环境。主要思想是将项目依赖项与不同项目和/或系统服务所需的软件包隔离开来。这种方法的好处是：
- en: It solves the "Project X depends on version 1.x but Project Y needs 4.x" dilemma.
    The developer can work on multiple projects with different dependencies that may
    even collide without the risk of affecting each other.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解决了“项目X依赖于1.x版本，但项目Y需要4.x”困境。开发人员可以在具有不同依赖关系的多个项目上工作，甚至可能发生冲突，而不会影响彼此。
- en: The project is no longer constrained by versions of packages that are provided
    in his system distribution repositories.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目不再受限于系统分发存储库中提供的软件包版本。
- en: There is no risk of breaking other system services that depend on certain package
    versions because new package versions are only available inside such an environment.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于新的包版本只在这样的环境中可用，所以不会有破坏依赖于特定包版本的其他系统服务的风险。
- en: A list of packages that are project dependencies can be easily "frozen", so
    it is very easy to reproduce them.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目依赖的包列表可以很容易地被“冻结”，因此很容易重现它们。
- en: The easiest and most lightweight approach to isolation is to use application-level
    virtual environments. They focus only on isolating the Python interpreter and
    packages available in it. They are very easy to set up and are very often just
    enough to ensure proper isolation during the development of small projects and
    packages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和最轻量级的隔离方法是使用应用级虚拟环境。它们只专注于隔离Python解释器和其中可用的包。它们非常容易设置，通常足以确保在开发小型项目和包时进行适当的隔离。
- en: Unfortunately, in some cases, this may not be enough to ensure enough consistency
    and reproducibility. For such cases, system-level isolation is a good addition
    to the workflow and some available solutions to that are explained later in this
    chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在某些情况下，这可能不足以确保足够的一致性和可重现性。对于这种情况，系统级别的隔离是工作流程的一个很好的补充，本章后面将解释一些可用的解决方案。
- en: Popular solutions
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的解决方案
- en: 'There are several ways to isolate Python at runtime. The simplest and most
    obvious, although hardest to maintain, is to manually change `PATH` and `PYTHONPATH`
    environment variables and/or move Python binary to a different place to affect
    the way it discovers available packages and change it to a custom place where
    we want to store our project''s dependencies. Fortunately, there are several tools
    available that help in maintaining virtual environments and how installed packages
    are stored in the system. These are mainly: `virtualenv`, `venv`, and `buildout`.
    What they do under the hood is in fact the same as what we would do manually.
    The actual strategy depends on the specific tool implementation, but generally,
    they are more convenient to use and can provide additional benefits.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种隔离Python运行时的方法。最简单和最明显的方法，尽管最难维护，是手动更改`PATH`和`PYTHONPATH`环境变量和/或将Python二进制文件移动到不同的位置，以影响它发现可用包的方式，并将其更改为我们想要存储项目依赖项的自定义位置。幸运的是，有几种可用的工具可以帮助维护虚拟环境以及安装包在系统中的存储方式。主要有：`virtualenv`、`venv`和`buildout`。它们在底层的操作实际上与我们手动操作的相同。实际的策略取决于具体的工具实现，但通常它们更方便使用并且可以提供额外的好处。
- en: virtualenv
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: virtualenv
- en: Virtualenv is by far the most popular tool in this list. Its name simply stands
    for Virtual Environment. It's not a part of the standard Python distribution,
    so it needs to be obtained using `pip`. It is one of the packages that is worth
    installing system-wide (using `sudo` on Linux and Unix-based systems).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Virtualenv是这个列表中迄今为止最受欢迎的工具。它的名字简单地代表虚拟环境。它不是标准Python发行版的一部分，因此需要使用`pip`来获取。它是值得系统范围内安装的包之一（在Linux和基于Unix的系统上使用`sudo`）。
- en: 'Once it is installed, a new virtual environment is created using the following
    command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，可以使用以下命令创建一个新的虚拟环境：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, `ENV` should be replaced by the desired name for the new environment.
    This will create a new `ENV` directory in the current working directory path.
    It will contain a few new directories inside:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ENV`应该被新环境的期望名称替换。这将在当前工作目录路径中创建一个新的`ENV`目录。它将包含几个新的目录：
- en: '`bin/`: This is where the new Python executable and scripts/executables provided
    by other packages are stored.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin/`：这是存储新Python可执行文件和其他包提供的脚本/可执行文件的地方。'
- en: '`lib/` and `include/`: These directories contain the supporting library files
    for the new Python inside the virtual environment. The new packages will be installed
    in `ENV/lib/pythonX.Y/site-packages/`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/`和`include/`：这些目录包含了虚拟环境中新Python的支持库文件。新的包将安装在`ENV/lib/pythonX.Y/site-packages/`中。'
- en: 'Once the new environment is created, it needs to be activated in the current
    shell session using Unix''s source command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的环境，就需要在当前shell会话中使用Unix的source命令激活它：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This changes the state of the current shell sessions by affecting its environment
    variables. In order to make the user aware that he has activated the virtual environment,
    it will change the shell prompt by appending the `(ENV)` string at its beginning.
    Here is an example session that creates a new environment and activates it to
    illustrate this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这会通过影响其环境变量改变当前shell会话的状态。为了让用户意识到他已经激活了虚拟环境，它会通过在其开头添加`(ENV)`字符串来改变shell提示。以下是一个创建新环境并激活它的示例会话：
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The important thing to note about `virtualenv` is that it depends completely
    on its state stored on a filesystem. It does not provide any additional abilities
    to track what packages should be installed in it. These virtual environments are
    not portable and should not be moved to another system/machine. This means that
    the new virtual environment needs to be created from scratch for each new application
    deployment. Because of that, there is a good practice used by `virtualenv` users
    to store all project dependencies in the `requirements.txt` file (this is the
    naming convention), as shown in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`virtualenv`的重要事情是，它完全依赖于存储在文件系统上的状态。它不提供任何额外的能力来跟踪应该安装在其中的包。这些虚拟环境不可移植，不应该移动到另一个系统/机器上。这意味着需要为每个新的应用部署从头开始创建新的虚拟环境。因此，`virtualenv`用户使用的一个良好的实践是将所有项目依赖项存储在`requirements.txt`文件中（这是命名约定），如下面的代码所示：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With such files, all dependencies can be easily installed using `pip` because
    it accepts the requirements file as its output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的文件，所有依赖项都可以很容易地使用`pip`进行安装，因为它接受requirements文件作为其输出。
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What needs to be remembered is that the requirements file is not always the
    ideal solution because it does not define the exact list of dependencies, only
    those that are to be installed. So, the whole project can work without problems
    in a development environment but will fail to start in others if the requirements
    file is outdated and does not reflect actual state of environment. There is, of
    course, the `pip freeze` command that prints all packages in the current environment
    but it should not be used blindly—it will output everything, even packages that
    are not used in the project but installed only for testing. The other tool mentioned
    in the book, `buildout`, addresses this issue, so it may be a better choice for
    some development teams.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，要求文件并不总是理想的解决方案，因为它并没有定义确切的依赖项列表，只有要安装的依赖项。因此，整个项目在开发环境中可以正常工作，但如果要求文件过时并且不反映环境的实际状态，它将无法在其他环境中启动。当然，有`pip
    freeze`命令可以打印当前环境中的所有软件包，但不应该盲目使用它——它会输出所有内容，甚至是仅用于测试而不在项目中使用的软件包。书中提到的另一个工具`buildout`解决了这个问题，因此对于一些开发团队来说，它可能是更好的选择。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Windows users, `virtualenv` under Windows uses a different naming for its
    internal structure of directories. You need to use `Scripts/`, `Libs/`, and `Include/`
    instead of `bin/`, `lib/`, `include/`, to better match development conventions
    on that operating system. The commands used for activating/deactivating the environment
    are also different; you need to use `ENV/Scripts/activate.bat` and `ENV/Scripts/deactivate.bat`
    instead of using `source` on `activate` and `deactivate` scripts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，在Windows下，`virtualenv`使用不同的命名方式来命名其目录的内部结构。您需要使用`Scripts/`，`Libs/`和`Include/`，而不是`bin/`，`lib/`，`include/`，以更好地匹配该操作系统上的开发约定。激活/停用环境的命令也不同；您需要使用`ENV/Scripts/activate.bat`和`ENV/Scripts/deactivate.bat`，而不是在`activate`和`deactivate`脚本上使用`source`。
- en: venv
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: venv
- en: 'Virtual environments shortly became well established and a popular tool within
    the community. Starting from Python 3.3, creating virtual environments is supported
    by standard library. The usage is almost the same as with Virtualenv, although
    command-line options have quite a different naming convention. The new `venv`
    module provides a `pyvenv` script for creating a new virtual environment:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境很快在社区内得到了很好的建立，并成为了一个受欢迎的工具。从Python 3.3开始，创建虚拟环境得到了标准库的支持。使用方式几乎与Virtualenv相同，尽管命令行选项的命名约定有很大不同。新的`venv`模块提供了一个`pyvenv`脚本来创建一个新的虚拟环境。
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `ENV` should be replaced by the desired name for the new environment.
    Also, new environments can now be created directly from Python code because all
    functionality is exposed from the built-in `venv` module. The other usage and
    implementation details, like the structure of the environment directory and activate/deactivate
    scripts are mostly the same as in Virtualenv, so migration to this solution should
    be easy and painless.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ENV`应该被新环境的期望名称所替换。此外，现在可以直接从Python代码中创建新环境，因为所有功能都是从内置的`venv`模块中公开的。其他用法和实现细节，如环境目录的结构和激活/停用脚本，大部分与Virtualenv相同，因此迁移到这个解决方案应该是简单而无痛的。
- en: For developers using newer versions of Python, it is recommended to use `venv`
    instead of Virtualenv. For Python 3.3, switching to `venv` may require more effort
    because in this version, it does not install `setuptools` and `pip` by default
    in the new environment, so the users need to install them manually. Fortunately,
    it has changed in Python 3.4, and also due to the customizability of `venv`, it
    is possible to override its behavior. The details are explained in the Python
    documentation (refer to [https://docs.python.org/3.5/library/venv.html](https://docs.python.org/3.5/library/venv.html)),
    but some users might find it too tricky and will stay with Virtualenv for that
    specific version of Python.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用较新版本Python的开发人员，建议使用`venv`而不是Virtualenv。对于Python 3.3，切换到`venv`可能需要更多的努力，因为在这个版本中，它不会默认在新环境中安装`setuptools`和`pip`，因此用户需要手动安装它们。幸运的是，这在Python
    3.4中已经改变，而且由于`venv`的可定制性，可以覆盖其行为。详细信息在Python文档中有解释（参见[https://docs.python.org/3.5/library/venv.html](https://docs.python.org/3.5/library/venv.html)），但一些用户可能会发现它太棘手，会选择在特定版本的Python中继续使用Virtualenv。
- en: buildout
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: buildout
- en: Buildout is a powerful tool for bootstrapping and the deployment of applications
    written in Python. Some of its advanced features will also be explained later
    in the book. For a long time, it was also used as a tool to create isolated Python
    environments. Because Buildout requires a declarative configuration that must
    be changed every time there is a change in dependencies, instead of relying on
    the environment state, these environments were easier to reproduce and manage.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Buildout是一个强大的用于引导和部署用Python编写的应用程序的工具。书中还将解释一些其高级功能。很长一段时间以来，它也被用作创建隔离的Python环境的工具。因为Buildout需要一个声明性的配置，必须在依赖关系发生变化时进行更改，而不是依赖于环境状态，因此这些环境更容易复制和管理。
- en: Unfortunately, this has changed. The `buildout` package since version 2.0.0
    no longer tries to provide any level of isolation from system Python installation.
    Isolation handling is left to other tools such as Virtualenv, so it is still possible
    to have isolated Buildouts, but things become a bit more complicated. A Buildout
    must be initialized inside an isolated environment in order to be really isolated.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，这已经改变了。自2.0.0版本以来，`buildout`软件包不再尝试提供与系统Python安装的任何级别的隔离。隔离处理留给其他工具，如Virtualenv，因此仍然可以拥有隔离的Buildouts，但事情变得有点复杂。必须在隔离的环境中初始化Buildout才能真正实现隔离。
- en: This has a major drawback as compared to the previous versions of Buildout,
    since it depends on other solutions for isolation. The developer working on this
    code can no longer be sure whether the dependencies description is complete because
    some packages can be installed by bypassing the declarative configuration. This
    issue can of course be solved using proper testing and release procedures, but
    it adds some more complexity to the whole workflow.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与Buildout的旧版本相比，这有一个主要缺点，因为它依赖于其他解决方案进行隔离。编写此代码的开发人员不再能确定依赖关系描述是否完整，因为一些软件包可以通过绕过声明性配置进行安装。当然，这个问题可以通过适当的测试和发布程序来解决，但它给整个工作流程增加了一些复杂性。
- en: To summarize, Buildout is no longer a solution that provides environment isolation
    but its declarative configuration can improve maintainability and the reproducibility
    of virtual environments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Buildout不再是提供环境隔离的解决方案，但其声明性配置可以提高虚拟环境的可维护性和可重现性。
- en: Which one to choose?
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择哪一个？
- en: There is no best solution that will fit every use case. What is good in one
    organization may not fit the workflow of other teams. Also, every application
    has different needs. Small projects can easily depend on sole `virtualenv` or
    `venv` but bigger ones may require additional help of `buildout` to perform more
    complex assembly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种最佳解决方案适用于所有用例。在一个组织中适用的东西可能不适合其他团队的工作流程。此外，每个应用程序都有不同的需求。小型项目可以轻松依赖于单独的`virtualenv`或`venv`，但更大的项目可能需要`buildout`的额外帮助来执行更复杂的组装。
- en: What was not described in detail earlier is that previous versions of Buildout
    (buildout<2.0.0) allowed the assembly of projects in an isolated environment with
    similar results as provided by Virtualenv. Unfortunately, 1.x branch of this project
    is no longer maintained, so using it for that purpose is discouraged.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前没有详细描述的是，Buildout的旧版本（buildout<2.0.0）允许在与Virtualenv提供的类似结果的隔离环境中组装项目。不幸的是，该项目的1.x分支不再维护，因此不鼓励将其用于此目的。
- en: I would recommend to use `venv` module instead of Virtualenv whenever it is
    possible. So, this should be the default choice for projects targeting Python
    versions 3.4 and higher. Using `venv` in Python 3.3 may be a little inconvenient
    due to a lack of built-in support for `setuptools` and `pip`. For projects targeting
    a wider spectrum of Python run times (including alternative interpreters and 2.x
    branch), it seems that Virtualenv is the best choice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尽可能使用`venv`模块而不是Virtualenv。因此，这应该是针对Python版本3.4及更高版本的项目的默认选择。在Python 3.3中使用`venv`可能有点不方便，因为缺乏对`setuptools`和`pip`的内置支持。对于针对更广泛的Python运行时（包括替代解释器和2.x分支）的项目，似乎Virtualenv是最佳选择。
- en: System-level environment isolation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统级环境隔离
- en: In most cases, software implementation can iterate fast because developers reuse
    a lot of existing components. Don't Repeat Yourself—this is a popular rule and
    motto of many programmers. Using other packages and modules to include them in
    the codebase is only a part of that culture. What also can be considered under
    "reused components" are binary libraries, databases, system services, third-party
    APIs, and so on. Even whole operating systems should be considered as reused.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，软件实现可以快速迭代，因为开发人员重用许多现有组件。不要重复自己——这是许多程序员的流行规则和座右铭。使用其他软件包和模块将它们包含在代码库中只是这种文化的一部分。可以被视为“重复使用组件”的还有二进制库、数据库、系统服务、第三方API等。甚至整个操作系统也应该被视为被重复使用。
- en: 'Backend services of web-based applications are a great example of how complex
    such applications can be. The simplest software stack usually consists of a few
    layers (starting from the lowest):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web的应用程序的后端服务是这类应用程序可以有多复杂的一个很好的例子。最简单的软件堆栈通常由几个层组成（从最低层开始）：
- en: A database or other kind of storage
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库或其他类型的存储设备
- en: The application code implemented in Python
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python实现的应用程序代码
- en: An HTTP server such as Apache or NGINX
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Apache或NGINX这样的HTTP服务器
- en: Of course such stack can be even simpler but it is very unlikely. In fact, big
    applications are often so complex that it is hard to distinguish single layers.
    Big applications can use many different databases, be divided into multiple independent
    processes, and use many other system services for caching, queuing, logging, service
    discovery, and so on. Sadly, there are no limits for complexity and it seems that
    code simply follows the second law of thermodynamics.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的堆栈可能会更简单，但这是非常不可能的。事实上，大型应用程序通常非常复杂，很难区分单个层。大型应用程序可以使用许多不同的数据库，分为多个独立的进程，并使用许多其他系统服务进行缓存、排队、日志记录、服务发现等。遗憾的是，复杂性没有限制，代码似乎只是遵循热力学第二定律。
- en: What really is important is that not all of the software stack elements can
    be isolated on the level of Python runtime environment. No matter whether it is
    an HTTP server such as NGINX or RDBMS such as PostgreSQL, they are usually available
    in different versions on different systems. Making sure that everyone in a development
    team uses the same versions of every component is very hard without proper tools.
    It is theoretically possible that all developers in a team working on a single
    project will be able to get the same versions of services on their development
    boxes. But all this effort is futile if they do not use the same operating system
    as in the production environment. And forcing a programmer to work on something
    else other than his beloved system of choice is impossible for sure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 真正重要的是，并非所有软件堆栈元素都可以在Python运行时环境的级别上进行隔离。无论是NGINX这样的HTTP服务器还是PostgreSQL这样的RDBMS，它们通常在不同系统上有不同版本。确保开发团队中的每个人使用每个组件的相同版本是非常困难的，没有适当的工具。理论上，一个团队中所有开发人员在一个项目上工作时能够在他们的开发环境中获得相同版本的服务。但是，如果他们不使用与生产环境相同的操作系统，所有这些努力都是徒劳的。而且，强迫程序员在他所钟爱的系统之外工作是不可能的。
- en: The problem lies in the fact that portability is still a big challenge. Not
    all services will work in exactly the same way in production environments as they
    do on the developer's machines and that is very unlikely to change. Even Python
    can behave differently on different systems despite how much work is put in to
    make it cross-platform. Usually, this is well documented and happens only in places
    that depend directly on system calls, but relying on the programmer's ability
    to remember a long list of compatibility quirks is quite an error prone strategy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于可移植性仍然是一个巨大的挑战。并非所有服务在生产环境中都能像在开发者的机器上那样完全相同地工作，这种情况很可能不会改变。即使是Python，尽管已经付出了很多工作来使其跨平台，但在不同的系统上可能会有不同的行为。通常，这些情况都有很好的文档记录，而且只会发生在直接依赖系统调用的地方，但依赖程序员记住一长串兼容性怪癖的能力是相当容易出错的策略。
- en: 'A popular solution to this problem is by isolating whole systems as application
    environments. This is usually achieved by leveraging different types of system
    virtualization tools. Virtualization, of course, reduces performance, but with
    modern computers that have hardware support for virtualization, the performance
    loss is usually negligible. On the other hand, a list of possible gains is very
    long:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个流行的解决方案是通过将整个系统隔离为应用程序环境。这通常是通过利用不同类型的系统虚拟化工具来实现的。虚拟化当然会降低性能，但对于具有硬件虚拟化支持的现代计算机来说，性能损失通常是可以忽略不计的。另一方面，可能获得的潜在收益列表非常长：
- en: The development environment can exactly match the system version and services
    used in production, which helps in solving compatibility issues
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境可以完全匹配生产中使用的系统版本和服务，有助于解决兼容性问题
- en: Definitions for system configuration tools such as Puppet, Chef, or Ansible
    (if used) can be reused for configuration of the development environment
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统配置工具（如Puppet、Chef或Ansible）的定义（如果使用）可以被重用于配置开发环境
- en: The newly hired team members can easily hop into the project if the creation
    of such environments is automated
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果创建这样的环境是自动化的，新加入的团队成员可以轻松地加入项目
- en: The developers can work directly with low system-level features that may not
    be available on operating systems they use for work, for example, **FUSE** (**File
    System in User Space**) that is not available in Windows
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以直接使用低级别的系统功能，这些功能可能在他们用于工作的操作系统上不可用，例如，在Windows中不可用的**FUSE**（用户空间文件系统）
- en: Virtual development environments using Vagrant
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vagrant创建虚拟开发环境
- en: Vagrant currently seems to be the most popular tool that provides a simple and
    convenient way to create and manage development environments. It is available
    for Windows, Mac OS, and a few popular Linux distributions (refer to [https://www.vagrantup.com](https://www.vagrantup.com)).
    It does not have any additional dependencies. Vagrant creates new development
    environments in the form of virtual machines or containers. The exact implementation
    depends on a choice of virtualization providers. VirtualBox is the default provider
    and it is bundled with the Vagrant installer but additional providers are available
    as well. The most notable choices are VMware, Docker, LXC (Linux Containers),
    and Hyper-V.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant目前似乎是提供创建和管理开发环境的最流行的工具。它适用于Windows、Mac OS和一些流行的Linux发行版（参见[https://www.vagrantup.com](https://www.vagrantup.com)）。它没有任何额外的依赖。Vagrant以虚拟机或容器的形式创建新的开发环境。具体的实现取决于虚拟化提供者的选择。VirtualBox是默认提供者，并且它已经与Vagrant安装程序捆绑在一起，但也有其他提供者可用。最显著的选择是VMware、Docker、LXC（Linux容器）和Hyper-V。
- en: 'The most important configuration is provided to Vagrant in a single file named
    `Vagrantfile`. It should be independent for every project. The following are the
    most important things it provides:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant中提供的最重要的配置是一个名为`Vagrantfile`的单个文件。它应该独立于每个项目。它提供的最重要的内容如下：
- en: Choice of virtualization provider
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化提供者的选择
- en: Box used as a virtual machine image
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用作虚拟机镜像的Box
- en: Choice of provisioning method
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置方法的选择
- en: Shared storage between a VM and a VM's host
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机和虚拟机主机之间的共享存储
- en: Ports that need to be forwarded between a VM and its host
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在虚拟机和其主机之间转发的端口
- en: 'Syntax language for the `Vagrantfile` is Ruby. The example configuration file
    provides a good template to start the project and has an excellent documentation,
    so the knowledge of this language is not required. Template configuration can
    be created using a single command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vagrantfile`的语法语言是Ruby。示例配置文件提供了一个很好的模板来启动项目，并且有很好的文档，因此不需要了解这种语言。可以使用一个命令创建模板配置：'
- en: '[PRE15]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create a new file named `Vagrantfile` in the current working directory.
    The best place to store this file is usually the root of the related project sources.
    This file is already a valid configuration that will create a new VM using the
    default provider and base box image. No provisioning is enabled by default. After
    the addition of `Vagrantfile`, the new VM is started using:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前工作目录中创建一个名为`Vagrantfile`的新文件。通常最好将此文件存储在相关项目源的根目录。这个文件已经是一个有效的配置，将使用默认提供者和基础盒子镜像创建一个新的虚拟机。默认情况下不启用任何配置。添加了`Vagrantfile`后，可以使用以下命令启动新的虚拟机：
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The initial start can take a few minutes because the actual box must be downloaded
    from the Web. There is also some initialization process that may take some time
    depending on the used provider, box, and system performance every time the already
    existing VM is brought up. Usually, this takes only a couple of seconds. Once
    the new Vagrant environment is up and running, developers can connect to SSH using
    this shorthand:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 初始启动可能需要几分钟，因为实际的盒子必须从网络上下载。每次启动已经存在的虚拟机时，还会有一些初始化过程，这可能需要一些时间，具体取决于所使用的提供者、盒子和系统性能。通常，这只需要几秒钟。一旦新的Vagrant环境启动并运行，开发人员可以使用以下简写连接到SSH：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This can be done anywhere in the project source tree below the location of `Vagrantfile`.
    For developers' convenience, we will look in the directories above for the configuration
    file and match it with the related VM instance. Then, it establishes the secure
    shell connection, so the development environment can be interacted with like any
    ordinary remote machine. The only difference is that the whole project source
    tree (root defined as a location of `Vagrantfile`) is available on the VM's filesystem
    under `/vagrant/`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`Vagrantfile`位置下的项目源树中的任何位置完成。为了开发者的方便起见，我们将在上面的目录中查找配置文件，并将其与相关的VM实例进行匹配。然后，它建立安全外壳连接，因此开发环境可以像任何普通的远程机器一样进行交互。唯一的区别是整个项目源树（根定义为`Vagrantfile`位置）在VM的文件系统下的`/vagrant/`下是可用的。
- en: Containerization versus virtualization
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化与虚拟化
- en: Containers are an alternative to full machine virtualization. It is a lightweight
    method of virtualization, where the kernel and operating system allow the running
    of multiple isolated user space instances. OS is shared between containers and
    host, so it theoretically requires less overhead than in full virtualization.
    Such a container contains only application code and its system-level dependencies,
    but from the perspective of processes running inside, it looks like a completely
    isolated system environment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是完整机器虚拟化的替代方案。这是一种轻量级的虚拟化方法，其中内核和操作系统允许运行多个隔离的用户空间实例。操作系统在容器和主机之间共享，因此在理论上需要的开销比完整虚拟化要少。这样的容器只包含应用程序代码和其系统级依赖项，但从内部运行的进程的角度来看，它看起来像一个完全隔离的系统环境。
- en: Software containers got their popularity mostly thanks to Docker; that is one
    of the available implementations. Docker allows to describe its container in the
    form of a simple text document called `Dockerfile`. Containers from such definitions
    can be built and stored. It also supports incremental changes, so if new things
    are added to the container then it does not need to be recreated from scratch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 软件容器主要得益于Docker而变得流行；这是其中一种可用的实现。Docker允许以称为`Dockerfile`的简单文本文档描述其容器。根据这些定义，可以构建和存储容器。它还支持增量更改，因此如果容器中添加了新内容，则不需要从头开始重新创建。
- en: Different tools such as Docker and Vagrant seem to overlap in features but the
    main difference between them is the reason why these tools were built. Vagrant,
    as mentioned earlier, is built primarily as a tool for development. It allows
    to bootstrap the whole virtual machine with a single command, but does not allow
    to simply pack it and deploy or release as is. Docker, on the other hand, is built
    exactly for that—preparing complete containers that can be sent and deployed to
    production as a whole package. If implemented well, this can greatly improve the
    process of product deployment. Because of that, using Docker and similar solutions
    (Rocket, for example) during development makes sense only if it also has to be
    used in the deployment process on production. Using it only for isolation purposes
    during development may generate too much overhead and also has a drawback of not
    being consistent.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具，如Docker和Vagrant，似乎在功能上有重叠，但它们之间的主要区别在于这些工具被构建的原因。如前所述，Vagrant主要是作为开发工具构建的。它允许用单个命令引导整个虚拟机，但不允许简单地打包并部署或发布。另一方面，Docker则是专门为此而构建的——准备完整的容器，可以作为一个整体包发送和部署到生产环境。如果实施得当，这可以极大地改善产品部署的过程。因此，在开发过程中使用Docker和类似的解决方案（例如Rocket）只有在它也必须在生产环境中的部署过程中使用时才有意义。仅在开发过程中用于隔离目的可能会产生太多的开销，而且还有一个不一致的缺点。
- en: Popular productivity tools
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的生产力工具
- en: A productivity tool is a bit of a vague term. On one hand, almost every open
    source code package released and available online is a kind of productivity booster—it
    provides ready-to-use solutions to some problem, so no one needs to spend time
    on it (ideally speaking). On the other hand, one could say that the whole of Python
    is about productivity. And both are undoubtedly true. Almost everything in this
    language and community surrounding it seems to be designed in order to make software
    development as productive as it is possible.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 生产力工具是一个有点模糊的术语。一方面，几乎每个发布并在网上可用的开源代码包都是一种提高生产力的工具——它提供了现成的解决方案，使得没有人需要花时间去解决它（理想情况下）。另一方面，有人可能会说整个Python都是关于生产力的。这两者无疑都是真的。这种语言和围绕它的社区几乎所有的东西似乎都是为了使软件开发尽可能地高效。
- en: This creates a positive feedback loop. Since writing code is fun and easy, a
    lot of programmers spend their free time to create tools that make it even easier
    and fun. And this fact will be used here as a basis for a very subjective and
    non-scientific definition of a productivity tool—a piece of software that makes
    development easier and more fun.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一个积极的反馈循环。由于编写代码是有趣且容易的，许多程序员会利用业余时间创建使其更容易和有趣的工具。这个事实将被用作生产力工具的一个非常主观和非科学的定义的基础——一种使开发更容易和更有趣的软件。
- en: By nature, productivity tools focus mainly on certain elements of the development
    process such as testing, debugging, and managing packages and are not core parts
    of products that they help to build. In some cases, they may not even be referred
    to anywhere in the project's codebase despite being used on a daily basis.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然，生产力工具主要关注开发过程的某些元素，如测试、调试和管理软件包，并不是它们帮助构建的产品的核心部分。在某些情况下，它们甚至可能根本没有在项目的代码库中被提及，尽管它们每天都在使用。
- en: The most important productivity tools, `pip` and `venv`, were already discussed
    earlier in this chapter. Some of them have packages for specific problems, such
    as profiling and testing, and have their own chapters in the book. This section
    is dedicated to other tools that are really worth mentioning, but have no specific
    chapter in the book where they could be introduced.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的生产力工具`pip`和`venv`在本章的前面已经讨论过。其中一些工具有针对特定问题的软件包，如性能分析和测试，并在本书中有它们自己的章节。本节专门介绍了其他一些值得一提的工具，但在本书中没有专门的章节可以介绍它们。
- en: Custom Python shells – IPython, bpython, ptpython, and so on
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义Python shell - IPython，bpython，ptpython等。
- en: Python programmers spend a lot of time in interactive interpreter sessions.
    It is very good for testing small code snippets, accessing documentation, or even
    debugging code at run time. The default interactive Python session is very simple
    and does not provide many features such as tab completion or code introspection
    helpers. Fortunately, the default Python shell can be easily extended and customized.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员在交互式解释器会话中花费了大量时间。它非常适合测试小的代码片段，访问文档，甚至在运行时调试代码。默认的交互式Python会话非常简单，不提供诸如制表符补全或代码内省助手之类的许多功能。幸运的是，默认的Python
    shell可以很容易地扩展和自定义。
- en: The interactive prompt can be configured with a startup file. When it starts,
    it looks for the `PYTHONSTARTUP` environment variable and executes the code in
    the file pointed to by this variable. Some Linux distributions provide a default
    startup script, which is generally located in your home directory. It is called
    `.pythonstartup`. Tab completion and command history are often provided to enhance
    the prompt and are based on the `readline` module. (You need the `readline` library.)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 交互提示可以通过启动文件进行配置。启动时，它会查找`PYTHONSTARTUP`环境变量，并执行由该变量指向的文件中的代码。一些Linux发行版提供了一个默认的启动脚本，通常位于您的主目录中。它被称为`.pythonstartup`。制表符补全和命令历史记录通常会提供以增强提示，并且基于`readline`模块。（您需要`readline`库。）
- en: 'If you don''t have such a file, you can easily create one. Here''s an example
    of the simplest startup file that adds completion with the `<Tab>` key and history:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有这样的文件，可以轻松创建一个。以下是一个添加了使用`<Tab>`键和历史记录的最简单启动文件的示例：
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create this file in your home directory and call it `.pythonstartup`. Then,
    add a `PYTHONSTARTUP` variable in your environment using the path of your file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主目录中创建此文件，并将其命名为`.pythonstartup`。然后，在环境中添加一个`PYTHONSTARTUP`变量，使用您文件的路径：
- en: Setting up the PYTHONSTARTUP environment variable
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置`PYTHONSTARTUP`环境变量
- en: 'If you are running Linux or Mac OS X, the simplest way is to create the startup
    script in your home folder. Then, link it with a `PYTHONSTARTUP` environment variable
    set into the system shell startup script. For example, the Bash and Korn shells
    use the `.profile` file, where you can insert a line as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Linux或Mac OS X，最简单的方法是在您的主文件夹中创建启动脚本。然后，将其链接到设置为系统shell启动脚本的`PYTHONSTARTUP`环境变量。例如，Bash和Korn
    shells使用`.profile`文件，您可以插入一行如下：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are running Windows, it is easy to set a new environment variable as
    an administrator in the system preferences, and save the script in a common place
    instead of using a specific user location.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows，可以在系统首选项中以管理员身份设置新的环境变量，并将脚本保存在一个常用位置，而不是使用特定的用户位置。
- en: Writing on the `PYTHONSTARTUP` script may be a good exercise but creating good
    custom shell all alone is a challenge that only few can find time for. Fortunately,
    there are a few custom Python shell implementations that immensely improve the
    experience of interactive sessions in Python.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`PYTHONSTARTUP`脚本可能是一个很好的练习，但独自创建一个良好的自定义shell是一项只有少数人能够抽出时间来完成的挑战。幸运的是，有一些自定义Python
    shell实现极大地改善了Python交互式会话的体验。
- en: IPython
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython
- en: 'IPyhton ([http://ipython.scipy.org](http://ipython.scipy.org)) provides an
    extended Python command shell. Among the features provided, the most interesting
    ones are:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: IPyhton（[http://ipython.scipy.org](http://ipython.scipy.org)）提供了一个扩展的Python命令行。提供的功能中，最有趣的是：
- en: Dynamic object introspection
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态对象内省
- en: System shell access from the prompt
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从提示中访问系统shell
- en: Profiling direct support
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接支持分析
- en: Debugging facilities
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试设施
- en: Now, IPython is a part of the larger project called Jupyter that provides interactive
    notebooks with live code that can be written in many different languages.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，IPython是一个名为Jupyter的更大项目的一部分，它提供了可以用许多不同语言编写的具有实时代码的交互式笔记本。
- en: bpython
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bpython
- en: 'bpython ([http://bpython-interpreter.org/](http://bpython-interpreter.org/))
    advertises itself as a fancy interface to the python interpreter. Here are some
    of the accented on the projects page:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: bpython（[http://bpython-interpreter.org/](http://bpython-interpreter.org/)）将自己宣传为Python解释器的时髦界面。以下是该项目页面上强调的一些内容：
- en: In-line syntax highlighting
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联语法高亮
- en: Readline-like autocomplete with suggestions displayed as you type
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似Readline的自动完成，建议在您输入时显示
- en: Expected parameter lists for any Python function
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Python函数的预期参数列表
- en: Autoindentation
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动缩进
- en: Python 3 support
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3支持
- en: ptpython
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ptpython
- en: ptpython ([https://github.com/jonathanslenders/ptpython/](https://github.com/jonathanslenders/ptpython/))
    is another approach to the topic of advanced Python shells. In this project, core
    prompt utilities implementation is available as a separate package called `prompt_toolkit`
    (from the same author). This allows you to easily create various aesthetically
    pleasing interactive command-line interfaces.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ptpython（[https://github.com/jonathanslenders/ptpython/](https://github.com/jonathanslenders/ptpython/)）是另一种高级Python
    shell主题的方法。在这个项目中，核心提示工具的实现可作为一个名为`prompt_toolkit`的单独包使用（来自同一作者）。这使您可以轻松创建各种美观的交互式命令行界面。
- en: It is often compared to bpython in functionalities but the main difference is
    that it enables a compatibility mode with IPython and its syntax that enables
    additional features such as `%pdb`, `%cpaste`, or `%profile`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它经常与bpython在功能上进行比较，但主要区别在于它启用了与IPython和其语法的兼容模式，从而启用了额外的功能，如`%pdb`，`%cpaste`或`%profile`。
- en: Interactive debuggers
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式调试器
- en: Code debugging is an integral element of the software development process. Many
    programmers can spend most of their life using only extensive logging and `print`
    statements as their primary debugging tools but most professional developers prefer
    to rely on some kind of debugger.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调试是软件开发过程的一个重要组成部分。许多程序员可能会花费大部分时间仅使用广泛的日志记录和`print`语句作为他们的主要调试工具，但大多数专业开发人员更喜欢依赖某种调试器。
- en: 'Python already ships with a built-in interactive debugger called `pdb` (refer
    to [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)).
    It can be invoked from the command line on the existing script, so Python will
    enter post-mortem debugging if the program exits abnormally:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经内置了一个名为`pdb`的交互式调试器（参见[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)）。它可以从命令行上调用现有的脚本，因此如果程序异常退出，Python将进入事后调试：
- en: '[PRE20]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Post-mortem debugging, while useful, does not cover every scenario. It is useful
    only when the application exists with some exception if the bug occurs. In many
    cases, faulty code just behaves abnormally but does not exit unexpectedly. In
    such cases, custom breakpoints can be set on a specific line of code using this
    single-line idiom:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 事后调试虽然有用，但并不涵盖每种情况。它仅在应用程序以某种异常退出时有用。在许多情况下，有错误的代码只是表现异常，但并不会意外退出。在这种情况下，可以使用这个单行习惯用法在特定代码行上设置自定义断点：
- en: '[PRE21]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will cause the Python interpreter to start the debugger session on this
    line during run time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Python解释器在运行时在此行开始调试会话。
- en: '`pdb` is very useful for tracing issues and at first glance, it may look very
    familiar to the well-known GDB (GNU Debugger). Because Python is a dynamic language,
    the `pdb` session is very similar to an ordinary interpreter session. This means
    that the developer is not limited to tracing code execution but can call any code
    and even perform module imports.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`对于追踪问题非常有用，乍一看，它可能看起来非常熟悉，就像著名的GDB（GNU调试器）。由于Python是一种动态语言，`pdb`会话非常类似于普通的解释器会话。这意味着开发人员不仅限于追踪代码执行，还可以调用任何代码，甚至执行模块导入。'
- en: Sadly, because of its roots (`bdb`), the first experience with `pdb` can be
    a bit overwhelming due to the existence of cryptic short letter debugger commands
    such as `h`, `b`, `s`, `n`, `j`, and `r`. Whenever in doubt, the `help pdb` command
    typed during the debugger session will provide extensive usage and additional
    information.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，由于其根源（`bdb`），对`pdb`的第一次体验可能会有点压倒性，因为存在着诸如`h`、`b`、`s`、`n`、`j`和`r`等神秘的短字母调试器命令。每当有疑问时，在调试器会话期间键入`help
    pdb`命令将提供广泛的用法和额外信息。
- en: 'The debugger session in pdb is also very simple and does not provide additional
    features like tab completion or code highlighting. Fortunately, there are few
    packages available on PyPI that provide such features available from alternative
    Python shells mentioned in the previous section. The most notable examples are:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: pdb中的调试器会话也非常简单，不提供诸如制表符补全或代码高亮之类的附加功能。幸运的是，PyPI上有一些包可提供这些功能，这些功能可以从前一节提到的替代Python
    shell中使用。最值得注意的例子有：
- en: '`ipdb`: This is a separate package based on `ipython`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipdb`：这是一个基于`ipython`的独立包'
- en: '`ptpdb`: This is a separate package based on `ptpython`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptpdb`：这是一个基于`ptpython`的独立包'
- en: '`bpdb`: This is bundled with `bpython`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpdb`：这是与`bpython`捆绑在一起的'
- en: Useful resources
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的资源
- en: 'The Web is full of useful resources for Python developers. The most important
    and obvious ones were already mentioned earlier but here they are repeated to
    keep this list consistent:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上充满了对Python开发人员有用的资源。最重要和明显的资源已经在前面提到过，但为了保持这个列表的一致性，这里重复一遍：
- en: Python documentation
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python文档
- en: PyPI—Python Package Index
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPI—Python包索引
- en: PEP 0—Index of Python Enhancement Proposals
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 0—Python增强提案索引
- en: 'The other resources such as books and tutorials are useful but often get outdated
    very fast. What does not get outdated are the resources that are actively curated
    by the community or released periodically. The two that are mostly worth recommending
    are:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其他资源，如书籍和教程，虽然有用，但往往很快就会过时。不会过时的是由社区积极策划或定期发布的资源。其中最值得推荐的两个是：
- en: Awesome-python ([https://github.com/vinta/awesome-python](https://github.com/vinta/awesome-python)),
    which includes a curated list of popular packages and frameworks
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Awesome-python ([https://github.com/vinta/awesome-python](https://github.com/vinta/awesome-python))，其中包括一个经过策划的流行包和框架的列表
- en: Python Weekly ([http://www.pythonweekly.com/](http://www.pythonweekly.com/))
    is a popular newsletter that delivers to its subscribers dozens of new and interesting
    Python packages and resources every week
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Weekly ([http://www.pythonweekly.com/](http://www.pythonweekly.com/))是一个流行的新闻通讯，每周向订阅者提供数十个新的有趣的Python包和资源
- en: These two resources will provide the reader with tons of additional reading
    for several months.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个资源将为读者提供数月的额外阅读。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started with topic differences between Python 2 and 3 with advice
    on how to deal with the current situation where a big part of its community is
    torn between two worlds. Then, it came to the modern approaches to Python development
    that were surprisingly developed mostly due to this unfortunate split between
    two major versions of the language. These are mostly different solutions to the
    environment isolation problem. The chapter ended with a short summary of the popular
    productivity tools as well as popular resources for further reference.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从Python 2和3之间的差异开始，提出了如何处理当前情况的建议，其中大部分社区都在两个世界之间挣扎。然后，它涉及到了由于语言的两个主要版本之间的不幸分裂而出现的Python开发的现代方法。这些主要是环境隔离问题的不同解决方案。本章以对流行的生产工具和进一步参考的流行资源的简短总结结束。
