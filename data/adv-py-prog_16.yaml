- en: '*Chapter 14*: Race Conditions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：竞态条件'
- en: In this chapter, we will discuss the concept of **race conditions** and their
    potential causes in the context of concurrency. The definition of a critical section,
    which is a concept highly relevant to race conditions and concurrent programming,
    will also be covered. We will use some example code in Python to simulate race
    conditions and the solutions that are commonly used to address them. Finally,
    real-life applications that commonly deal with race conditions will also be discussed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**竞态条件**的概念及其在并发环境中的潜在原因。还将涵盖与竞态条件和并发编程高度相关的临界区概念。我们将使用一些Python示例代码来模拟竞态条件及其常用的解决方案。最后，还将讨论处理竞态条件的现实生活应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The concept of race conditions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件的概念
- en: Simulating race conditions in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中模拟竞态条件
- en: Locks as a solution to race conditions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁作为解决竞态条件的方法
- en: Race conditions in real life
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生活中的竞态条件
- en: This chapter, similar to the previous two chapters, offers a closer look at
    what could go wrong in concurrent programming and exposes us to a wide range of
    approaches in terms of how to avoid and prevent that. In this chapter, our focus
    will be on race conditions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，与前面两章类似，更深入地探讨了并发编程中可能出错的地方，并介绍了如何避免和预防这些问题的多种方法。在本章中，我们的重点将放在竞态条件上。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter14).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter14)。
- en: The concept of race conditions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞态条件的概念
- en: Typically, a **race condition** is defined as a phenomenon during which the
    output of a system is both indeterminate and dependent on the scheduling algorithm
    and the order in which tasks are scheduled and executed. When data becomes mishandled
    or corrupted during this process, a race condition becomes a bug in the system.
    Given the nature of this problem, it is quite common for a race condition to occur
    in concurrent systems, which emphasizes the importance of scheduling and coordinating
    independent tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**竞态条件**被定义为一种现象，在此现象中，系统的输出既是不确定的，又依赖于调度算法以及任务被调度和执行的顺序。当数据在此过程中被错误处理或损坏时，竞态条件就变成了系统中的错误。鉴于这个问题本质，在并发系统中发生竞态条件是很常见的，这强调了调度和协调独立任务的重要性。
- en: A race condition can occur in both an electronic hardware system and a software
    application; in this chapter, we will only discuss race conditions in the context
    of software development – specifically, **concurrent software applications**.
    This section will cover the theoretical foundations of race conditions and their
    root causes along with the concept of *critical sections*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件可能发生在电子硬件系统和软件应用中；在本章中，我们只讨论软件开发背景下的竞态条件——特别是**并发软件应用**。本节将涵盖竞态条件的理论基础及其根本原因，以及*临界区*的概念。
- en: Critical sections
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临界区
- en: '**Critical sections** indicate shared resources that are accessed by multiple
    processes or threads in a concurrent application, These can lead to unexpected,
    and even erroneous, behavior. We have learned that there are multiple methods
    to protect the integrity of the data contained in these resources, and we call
    these protected sections *critical sections*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**临界区**指的是在并发应用程序中由多个进程或线程访问的共享资源，这些资源可能导致意外甚至错误的行为。我们已经了解到，有多种方法可以保护这些资源中包含的数据的完整性，我们将这些受保护的区域称为*临界区*。'
- en: As you can imagine, the data in these critical sections, when interacted with
    and altered concurrently or in parallel, can become mishandled or corrupted. This
    is especially true when the threads and processes interacting with it are poorly
    coordinated and scheduled. Therefore, the logical conclusion is to not allow multiple
    agents to go into a critical section at the same time. We call this concept **mutual
    exclusion**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，当这些临界区中的数据被并发或并行交互和修改时，可能会被错误处理或损坏。这尤其当与之交互的线程和进程在协调和调度方面做得不好时更为明显。因此，合乎逻辑的结论是不允许多个代理同时进入临界区。我们称这个概念为**互斥**。
- en: In the next subsection, we will discuss the relationship between critical sections
    and the causes of race conditions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将讨论临界区与竞态条件原因之间的关系。
- en: How race conditions occur
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞态条件是如何发生的
- en: 'Let''s consider a simple concurrent program in order to understand what can
    give rise to a race condition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的并发程序，以便了解什么可能导致竞态条件：
- en: Suppose that the program has a shared resource and two separate threads (*thread
    1* and *thread 2*) that will access and interact with that resource. Specifically,
    the shared resource is a number and, as per their respective execution instructions,
    each thread is to read in that number, increment it by 1, and finally, update
    the value of the shared resource with the incremented number.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设程序有一个共享资源，并且有两个独立的线程（*线程1* 和 *线程2*）将访问并交互这个资源。具体来说，共享资源是一个数字，并且根据它们各自的执行指令，每个线程都应该读取这个数字，将其增加1，最后，使用增加后的数字更新共享资源的值。
- en: Next, suppose that the shared number is originally 2, and then thread 1 accesses
    and interacts with the number; the shared resource will become 3.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，假设共享的数字最初是2，然后线程1访问并交互这个数字；共享资源将变为3。
- en: After thread 1 successfully alters and exits the resource, thread 2 begins to
    execute its instructions, and the shared resource that is a number is updated
    to 4\. Throughout this process, the number that was originally 2 was incremented
    twice (each time by a separate thread) and held a value of 4 at the end. In this
    case, the shared number was not mishandled or corrupted.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在线程1成功修改并退出资源后，线程2开始执行其指令，共享资源（一个数字）被更新为4。在整个过程中，原始的数字2被两次增加（每次由不同的线程增加），最终保持了一个值为4。在这种情况下，共享数字没有被不当处理或损坏。
- en: Then, imagine a scenario in which the shared number is still 2 at the beginning,
    yet both of the threads access the number at the same time. Now, each of the threads
    reads in the number 2 from the shared resource; they each increment the number
    2 to 3 individually, and then write the number 3 back to the shared resource.
    Even though the shared resource was accessed and interacted with twice by a thread,
    it only held a value of 3 at the end of the process.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，想象一个场景，共享的数字在开始时仍然是2，但两个线程同时访问这个数字。现在，每个线程从共享资源中读取数字2；它们各自将数字2增加到3，然后将数字3写回共享资源。尽管线程两次访问并交互了共享资源，但在整个过程中，共享资源最终只保持了一个值为3的值。
- en: 'This is an example of a race condition occurring in a concurrent program: since
    the second thread to access a shared resource does it before the first thread
    finishes its execution (in other words, before writing the new value to the shared
    resource), the second thread fails to take in the updated resource value. This
    leads to the fact that when the second thread writes to the resource, the value
    that is processed and updated by the first thread is overwritten. At the end of
    the execution of the two threads, the shared resource has, technically, only been
    updated by the second thread.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个并发程序中发生竞态条件的例子：由于第二个访问共享资源的线程在第一个线程完成其执行之前（换句话说，在将新值写入共享资源之前）进行操作，第二个线程未能获取更新的资源值。这导致当第二个线程写入资源时，被第一个线程处理和更新的值被覆盖。在两个线程执行结束时，从技术上讲，共享资源只被第二个线程更新。
- en: 'The following diagram further illustrates the contrast between a correct data
    handling process and a situation involving a race condition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进一步说明了正确数据处理过程与涉及竞态条件的情况之间的对比：
- en: '![Figure 14.1 – Mishandling shared data ](img/_B17499Figure_14.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 处理共享数据不当](img/_B17499Figure_14.1.jpg)'
- en: Figure 14.1 – Mishandling shared data
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 处理共享数据不当
- en: Intuitively, we can see that a race condition results in the mishandling and
    corruption of data. In the preceding example, we can see that a race condition
    only occurs with two separate threads accessing a common resource, causing the
    shared resource to be updated incorrectly and hold an incorrect value at the end
    of the program. We understand that most real-life concurrent applications contain
    significantly more threads and processes along with additional shared resources,
    and the more threads/processes that interact with the shared resource, the more
    likely it is that a race condition will occur.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上看，我们可以看到竞态条件会导致数据的错误处理和损坏。在先前的例子中，我们可以看到竞态条件仅在两个独立的线程访问公共资源时发生，导致共享资源被错误地更新，并在程序结束时持有错误值。我们理解，大多数现实生活中的并发应用程序包含大量线程和进程，以及额外的共享资源，并且与共享资源交互的线程/进程越多，发生竞态条件的可能性就越大。
- en: Before we discuss a solution that we can implement to solve the problem of race
    conditions, let's try to simulate the problem in Python.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论可以实施的解决方案来解决竞态条件问题之前，让我们尝试在Python中模拟这个问题。
- en: Simulating race conditions in Python
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中模拟竞态条件
- en: If you have already downloaded the code for this book from the GitHub page,
    go ahead and navigate to the `Chapter14` folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从GitHub页面下载了这本书的代码，请继续导航到`Chapter14`文件夹。
- en: 'To simulate a race condition, first, we need a common resource. In this case,
    it''s a counter variable along with multiple threads that can access it simultaneously.
    Let''s take a look at the `Chapter14/example1.py` file—specifically, the `update()`
    function, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟竞态条件，首先，我们需要一个公共资源。在这种情况下，它是一个计数器变量以及可以同时访问它的多个线程。让我们看一下`Chapter14/example1.py`文件——特别是以下`update()`函数：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of the preceding `update()` function is to increment a global variable
    called `counter`, and it is to be called by a separate thread in our script. Inside
    the function, we are interacting with a shared resource—in this case, `counter`.
    Then, we assign the value of `counter` to another local variable, called `current_counter`
    (this is to simulate the process of reading data from more complex data structures
    for the shared resources).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`update()`函数的目的是增加一个名为`counter`的全局变量，它将由我们脚本中的另一个线程调用。在函数内部，我们正在与共享资源交互——在这种情况下，`counter`。然后，我们将`counter`的值赋给另一个局部变量，称为`current_counter`（这是为了模拟从更复杂的数据结构中读取共享资源数据的过程）。
- en: Next, we will pause the execution of the function by using the `time.sleep()`
    method. The length of the period during which the program will be paused is pseudo-randomly
    chosen between `0` and `1`, generated by the function call, `random.randint(0,
    1)`. So, the program will either pause for one second or not at all. Finally,
    we assign the newly computed value of `current_counter` (which is its one-increment)
    to the originally shared resource (the `counter` variable).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`time.sleep()`方法暂停函数的执行。程序暂停的持续时间是伪随机选择的，介于`0`和`1`之间，由`random.randint(0,
    1)`函数调用生成。因此，程序将暂停一秒钟或根本不暂停。最后，我们将新计算的`current_counter`值（即它的增量）赋给原始共享资源（`counter`变量）。
- en: 'Now, we can move on to our main program:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续我们的主程序：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are initializing the `counter` global variable with a set of `threading.Thread`
    objects in order to execute the `update()` function concurrently; we are initializing
    20 `thread` objects to increment our shared counter 20 times. After starting and
    joining all of the threads that we have, we can finally print out the end value
    of our shared `counter` variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用一组`threading.Thread`对象初始化`counter`全局变量，以便并发执行`update()`函数；我们初始化了20个`thread`对象，以便将我们的共享计数器增加20次。在启动并加入我们所有的线程之后，我们最终可以打印出我们共享的`counter`变量的最终值。
- en: 'Theoretically, a well-designed concurrent program will successfully increment
    the shared counter 20 times in total, and since its original value is `0`, the
    end value of the counter should be `20` at the end of the program. However, as
    you run this script, the `counter` variable that you obtain will most likely not
    hold an end value of `20`. The following is my output, obtained from running the
    script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，一个设计良好的并发程序将总共成功增加共享计数器20次，由于它的原始值是`0`，程序结束时的计数器最终值应该是`20`。然而，当你运行这个脚本时，你获得的`counter`变量很可能不会持有`20`的最终值。以下是我运行脚本得到的输出：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding output indicates that the counter was only successfully incremented
    nine times. This is a direct result of the race condition that our concurrent
    program has. This race condition occurs when a specific thread spends time reading
    in and processing the data from the shared resource (specifically, for one second
    using the `time.sleep()` method), and another thread reads in the current value
    of the `counter` variable, which, at this point, has not been updated by the first
    thread since it has not completed its execution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明计数器只成功增加了九次。这是由我们的并发程序中的竞态条件直接导致的。这种竞态条件发生在特定线程花费时间读取和处理共享资源中的数据（具体来说，使用`time.sleep()`方法持续一秒钟）时，而另一个线程读取了当前的`counter`变量值，此时该值尚未被第一个线程更新，因为它尚未完成其执行。
- en: 'Interestingly, if a thread does not spend any time processing the data (in
    other words, when `0` is chosen by the pseudo-random `random.randint()` method),
    the value of the shared resource can potentially be updated just in time for the
    next thread to read and process it. This phenomenon is illustrated by the fact
    that the end value of the counter varies within different runs of the program.
    For example, the following is the output that I obtained after running the script
    three times. The output from the first run is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果一个线程不花费任何时间处理数据（换句话说，当伪随机`random.randint()`方法选择`0`时），共享资源的值可能刚好在下一个线程读取和处理它的时候被更新。这一现象可以通过程序运行中计数器最终值的变化来体现。例如，以下是我运行脚本三次后得到的输出。第一次运行的输出如下：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from the second run is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行的输出如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output from the third run is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次运行的输出如下：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the final value of the counter is dependent on the number of threads
    that spend one second pausing and the number of threads not pausing at all. Since
    these two numbers are, in turn, dependent on the `random.randint()` method, the
    final value of the counter changes between different runs of the program. We will
    still have a race condition in our program, except for when we can ensure that
    the final value of the counter is always `20` (that is, the counter is being successfully
    incremented 20 times in total).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，计数器的最终值取决于花费一秒钟暂停的线程数量以及完全未暂停的线程数量。由于这两个数字反过来又依赖于`random.randint()`方法，因此计数器的最终值在不同的程序运行中会有所不同。尽管如此，我们的程序仍然会存在竞态条件，除非我们能确保计数器的最终值总是`20`（也就是说，计数器总共成功增加了20次）。
- en: 'In the next section, we will discuss the most common solution to race conditions:
    locks.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论解决竞态条件最常用的方法：锁。
- en: Locks as a solution to race conditions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁作为解决竞态条件的方法
- en: Intuitively, since the race conditions that we observed arose when multiple
    threads or processes accessed and wrote to a shared resource simultaneously, the
    key idea behind solving race conditions is isolating the executions of different
    threads/processes, especially when interacting with a shared resource. Specifically,
    we need to make sure that a thread/process can only access the shared resource
    after any other threads/processes interacting with the resource have finished
    their interactions with that resource.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 直观来说，因为我们观察到的竞态条件是在多个线程或进程同时访问和写入共享资源时出现的，所以解决竞态条件的关键思想是隔离不同线程/进程的执行，尤其是在与共享资源交互时。具体来说，我们需要确保一个线程/进程只有在任何其他线程/进程与该资源完成交互后才能访问共享资源。
- en: With locks, we can turn a shared resource inside a concurrent program into a
    critical section, whose integrity of data is guaranteed to be protected. We will
    see this in action next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用锁，我们可以将并发程序中的共享资源转变为临界区，其数据的完整性将得到保证。我们将在接下来的操作中看到这一点。
- en: The effectiveness of locks
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁的有效性
- en: A critical section guarantees the mutual exclusion of a shared resource and
    cannot be accessed concurrently by multiple processes or threads; this will prevent
    any protected data from being updated or altered with conflicting information,
    resulting from race conditions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个临界区保证了共享资源的互斥访问，并且不能被多个进程或线程同时访问；这将防止任何受保护的数据被带有冲突信息的更新或修改，这些冲突信息是由竞态条件引起的。
- en: 'In the following diagram, `var`—by a **mutex** (**mutual exclusion**) lock.
    This is because **Thread A** is already accessing the resource:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，`var`通过一个**互斥锁（mutex）**。这是因为**线程A**已经正在访问资源：
- en: '![Figure 14.2 – Locks prevent simultaneous access to a critical section ](img/_B17499Figure_14.2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 锁防止同时访问临界区](img/_B17499Figure_14.2.jpg)'
- en: Figure 14.2 – Locks prevent simultaneous access to a critical section
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 锁防止同时访问临界区
- en: 'Now, we will specify that, in order to gain access to a critical section in
    a concurrent program, a thread or process needs to acquire a lock object that
    is associated with the critical section; similarly, that thread or process also
    needs to release that lock upon leaving the critical section. This setup will
    effectively prevent multiple accesses to the critical section and will, therefore,
    prevent race conditions. The following diagram illustrates the execution flow
    of multiple threads interacting with multiple critical sections, with the implementation
    of locks in place:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将指定，为了在并发程序中访问临界区，一个线程或进程需要获取与临界区相关联的锁对象；同样，该线程或进程在离开临界区时也需要释放该锁。这种设置将有效地防止对临界区的多次访问，从而防止竞态条件。以下图表展示了多个线程与多个临界区交互的执行流程，其中实现了锁：
- en: '![Figure 14.3 – Locks and critical sections in multiple threads ](img/_B17499Figure_14.3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 多线程中的锁和临界区](img/_B17499Figure_14.3.jpg)'
- en: Figure 14.3 – Locks and critical sections in multiple threads
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 多线程中的锁和临界区
- en: 'As you can see in the preceding diagram, threads **T1** and **T2** both interact
    with three critical sections in their respective execution instructions: **CS1**,
    **CS2**, and **CS3**. Here, **T1** and **T2** attempt to access **CS1** at almost
    the same time. Additionally, since **CS1** is protected with lock **L1**, only
    **T1** can acquire lock **L1** and, hence, access/interact with the critical section.
    In contrast, **T2** has to spend time waiting for **T1** to exit out of the critical
    section and release the lock before accessing the section itself. Similarly, for
    the critical sections, **CS2** and **CS3**, although both threads require access
    to a critical section at the same time, only one can process it, while the other
    has to wait to acquire the lock associated with the critical section.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，线程**T1**和**T2**在其各自的执行指令中都与三个临界区交互：**CS1**、**CS2**和**CS3**。在这里，**T1**和**T2**几乎同时尝试访问**CS1**。此外，由于**CS1**被锁**L1**保护，只有**T1**可以获取锁**L1**，因此可以访问/交互临界区。相比之下，**T2**必须等待**T1**退出临界区并释放锁后才能访问该区域。同样，对于临界区**CS2**和**CS3**，尽管两个线程同时需要访问临界区，但只有一个可以处理它，而另一个必须等待获取与临界区相关的锁。
- en: Now, let's implement this solution using *Python*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用*Python*来实现这个解决方案。
- en: Implementation in Python
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python实现
- en: 'Navigate to the `Chapter14/example2.py` file and consider our corrected `update()`
    function, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Chapter14/example2.py`文件，并考虑以下我们修正后的`update()`函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, you can see that all of the execution instructions of a thread specified
    in the `update()` function are under the context manager of a lock object named
    `count_lock`. So, every time a thread is called to run the function, it will first
    have to acquire the lock object before any instructions can be executed. In our
    main program, we simply create the lock object in addition to what we already
    have, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`update()`函数中指定的线程的所有执行指令都在名为`count_lock`的锁对象的作用域内。因此，每次调用线程运行该函数时，它必须首先获取锁对象，然后才能执行任何指令。在我们的主程序中，我们简单地创建锁对象，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program. Your output should look similar to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序。你的输出应该类似于以下内容：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you can see that the counter was successfully incremented 20 times and
    held the correct value at the end of the program. Furthermore, no matter how many
    times the script is executed, the final value of the counter will always be **20**.
    This is the advantage of using locks to implement critical sections in your concurrent
    programs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到计数器成功增加了20次，并在程序结束时保持了正确的值。此外，无论脚本执行多少次，计数器的最终值始终将是**20**。这是在并发程序中使用锁实现临界区的优势。
- en: The downside of locks
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁的缺点
- en: 'In [*Chapter 12*](B17499_12_Final_SS_ePub.xhtml#_idTextAnchor215), *Deadlocks*,
    we covered an interesting phenomenon in which the use of locks can lead to undesirable
    results. Specifically, we discovered that with enough locks implemented in a concurrent
    program, the whole program can become sequential. Let''s analyze this concept
    with our current program. Consider the `Chapter14/example3.py` file, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B17499_12_Final_SS_ePub.xhtml#_idTextAnchor215) *死锁*中，我们介绍了一种有趣的现象，即锁的使用可能导致不希望的结果。具体来说，我们发现，在并发程序中实现了足够的锁之后，整个程序可以变成顺序的。让我们用我们当前的程序来分析这个概念。考虑以下`Chapter14/example3.py`文件：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The goal of this script is to compare the speed of our current concurrent program
    with its sequential version. Here, we are still using the same `update()` function,
    with locks, and we are running it 20 times, both sequentially and concurrently,
    as we did earlier. Additionally, we are creating a list of determined periods
    for pausing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的目标是比较我们当前并发程序与其顺序版本的速度。在这里，我们仍然使用相同的带有锁的`update()`函数，并运行20次，既顺序运行又并发运行，就像我们之前做的那样。此外，我们创建了一个确定的暂停周期列表：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is so that these periods are consistent between when we simulate the sequential
    version and when we simulate the concurrent version (for this reason, the `update()`
    function now takes in a parameter that specifies the period of pausing each time
    it is called).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了确保在模拟顺序版本和并发版本时这些周期是一致的（因此，`update()`函数现在接受一个参数，指定每次调用时暂停的周期）。
- en: This is the setup we need to simulate the *sequentiality* of a program with
    many locks, which we will see firsthand in the next subsection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要模拟具有许多锁的程序**顺序性**的设置，我们将在下一小节中亲自看到。
- en: Turning a concurrent program into a sequential program
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将并发程序转换为顺序程序
- en: 'Here, we simply call the `update()` function inside a `for` loop, with 20 iterations,
    keeping track of the time it takes for the loop to finish. Note that, even though
    this is to simulate the sequential version of the program, the `update()` function
    still needs the lock object to be created beforehand, so we are initializing it
    here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在`for`循环中调用`update()`函数，进行20次迭代，并跟踪循环完成所需的时间。请注意，尽管这是为了模拟程序的顺序版本，但`update()`函数仍然需要事先创建锁对象，因此我们在这里初始化它：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last step is to reset the counter and run the concurrent version of the
    program that we already implemented. Again, we need to pass in the corresponding
    pause period while initializing each of the threads that run the `update()` function.
    Additionally, we are keeping track of the time it takes for this concurrent version
    of the program to run:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是重置计数器并运行我们已实现的并发版本程序。同样，我们需要在初始化每个运行`update()`函数的线程时传入相应的暂停期。此外，我们正在跟踪此并发版本程序运行所需的时间：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, after you have run the script, you will observe that both the sequential
    version and the concurrent version of our program took the same amount of time
    to run. Specifically, the following is the output that I obtained; in this case,
    they both took approximately 12 seconds. The actual time that your program takes
    might be different, but the speed of the two versions should still be equal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你运行脚本之后，你会观察到我们的程序顺序版本和并发版本运行所需的时间相同。具体来说，以下是我获得的结果；在这种情况下，它们都大约花费了12秒。你的程序实际所需的时间可能不同，但两个版本的速度应该仍然相等：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, our concurrent program is taking just as much time as its sequential version,
    which negates one of the biggest purposes of implementing concurrency in a program:
    *improving speed*. But why would concurrent and traditional sequential applications
    with the same sets of instructions and elements also have the same speed? Should
    the concurrent program always produce a faster speed than the sequential one?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的并发程序花费的时间与其顺序版本相同，这否定了实现程序并发的一个最大目的：*提高速度*。但为什么具有相同指令和元素集的并发和传统顺序应用程序也会有相同速度？并发程序是否总是应该比顺序程序产生更快的速度？
- en: Recall that, in our program, the critical section is being protected by a lock
    object, and no multiple threads can access it at the same time. Since the execution
    of the program (incrementing the counter 20 times) depends on a thread accessing
    the critical section, the placement of the lock object in the critical section
    means that only one thread can be executing at any given time. With this specification,
    the executions of any two threads cannot overlap with each other, and no additional
    speed can be gained from this implementation of concurrency.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在我们的程序中，临界区是由锁对象保护的，并且没有多个线程可以同时访问它。由于程序的执行（计数器增加20次）依赖于一个线程访问临界区，因此在临界区放置锁对象意味着在任何给定时间只能有一个线程在执行。根据这个规范，任何两个线程的执行都不能相互重叠，并且从这个并发实现的并发性中无法获得额外的速度。
- en: 'This is the phenomenon that we encountered when analyzing the problem of deadlock:
    if enough locks are placed in a concurrent program, that program will become entirely
    sequential. This is the reason why locks are sometimes undesirable solutions to
    problems in concurrent programming. However, this situation only happens if all
    of the executions of the concurrent program are dependent upon interacting with
    the critical section. Most of the time, reading and manipulating the data of a
    shared resource is only a portion of the entire program; therefore, concurrency
    still provides the intended additional speed for our program.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们分析死锁问题时遇到的现象：如果在并发程序中放置足够的锁，该程序将完全变为顺序执行。这就是为什么锁有时不是并发编程中解决问题的理想解决方案。然而，这种情况只会在并发程序的每次执行都依赖于与临界区交互时发生。大多数时候，读取和操作共享资源的数据只是整个程序的一部分；因此，并发仍然为我们提供了预期的额外速度。
- en: An additional aspect of locks is the fact that they do not actually lock anything.
    We will discuss this point in more detail next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的另一个方面是它们实际上并没有锁定任何东西。我们将在下一节更详细地讨论这一点。
- en: Locks do not lock anything
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁并不能锁定任何东西
- en: The only way that a lock object is utilized, with respect to a specific shared
    resource, is for the threads and processes interacting with that resource to also
    interact with the lock. In other words, if those threads and processes choose
    to not check with the lock before accessing and altering the shared resource,
    the lock object itself cannot stop them from doing so.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当线程和进程与特定共享资源交互时，锁对象才会被利用。换句话说，如果那些线程和进程选择在访问和修改共享资源之前不检查锁，锁对象本身无法阻止他们这样做。
- en: In our examples, you have discovered that to implement the acquiring/releasing
    process of a lock object, the instructions of a thread or process need to be wrapped
    around by a lock context manager; this specification is dependent on the implementation
    of *the thread/process execution logic* and not the resource. That is because
    the lock objects that we have seen are not in any way connected to the resources
    that they are supposed to protect. So, if the thread/process execution logic does
    not require any interaction with the lock object associated with the shared resource,
    that thread or process can simply gain access to the resource without difficulty,
    potentially resulting in the *mismanipulation* and corruption of data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，你已经发现，为了实现锁对象的获取/释放过程，线程或进程的指令需要被锁上下文管理器包装起来；这个规范依赖于*线程/进程执行逻辑*的实现，而不是资源。这是因为我们所看到的锁对象与它们应该保护的资源没有任何联系。所以，如果线程/进程执行逻辑不需要与与共享资源相关的锁对象进行任何交互，那么该线程或进程可以轻松地访问资源，可能造成*不当操作*和数据损坏。
- en: This is not only true in the scope of having multiple threads and processes
    in a single concurrent program. Let's suppose that we have a concurrent system
    consisting of multiple components that all interact and manipulate the data of
    a resource shared across the system, and this resource is associated with a lock
    object; it follows that, if any of these components fail to interact with that
    lock, it can simply bypass the protection implemented by the lock and access the
    shared resource. More importantly, this characteristic of locks also has implications
    regarding the security of a concurrent program. If an outside, malicious agent
    is connected to the system (for instance, a malicious client interacting with
    a server) and intends to corrupt the data shared across the system, that agent
    can be instructed to simply ignore the lock object and access that data in an
    intrusive way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于单个并发程序中存在多个线程和进程的范围。假设我们有一个由多个组件组成的并发系统，这些组件都相互作用并操作系统共享的资源，并且这个资源与一个锁对象相关联；因此，如果这些组件中的任何一个未能与该锁交互，它就可以简单地绕过锁实现的保护并访问共享资源。更重要的是，锁的这一特性对并发程序的安全性也有影响。如果外部恶意代理连接到系统（例如，恶意客户端与服务器交互）并意图破坏系统共享的数据，那么该代理可以被指示简单地忽略锁对象并以侵入的方式访问这些数据。
- en: The view that locks don't lock anything was popularized by Raymond Hettinger,
    a Python core developer who worked on the implementation of various elements in
    Python concurrent programming. It is argued that using lock objects alone does
    not guarantee a secure implementation of concurrent data structures and systems.
    Locks need to be concretely linked to the resources that they are supposed to
    protect, and nothing should be able to access a resource without first acquiring
    the lock that is associated with it. Alternatively, other concurrent synchronization
    tools, such as atomic message queues can provide a solution to this problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 认为锁无法锁定任何东西的观点是由Python核心开发者Raymond Hettinger普及的，他在Python并发编程中负责实现各种元素。有人认为，仅使用锁对象并不能保证并发数据结构和系统的安全实现。锁需要具体地与它们应该保护的资源相联系，并且没有任何东西能够在首先获取与其相关的锁之前访问资源。或者，其他并发同步工具，如原子消息队列，可以提供解决这个问题的方案。
- en: You have now learned about the concept of race conditions, how they are caused
    in concurrent systems, and how to effectively prevent them. In the next section,
    we will provide an overarching view of how race conditions can occur in real-life
    examples, within the various subfields of computer science.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了竞态条件的概念，知道了它们在并发系统中是如何产生的，以及如何有效地防止它们。在下一节中，我们将提供一个关于竞态条件如何在计算机科学的各个子领域中实际发生的总体观点。
- en: Race conditions in real life
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的竞态条件
- en: In particular, we will discuss the topics of security, file management, and
    networking. Race conditions don't simply exist in simple, minimal code examples
    about global counters. They are present in many important tasks such as security,
    file management, and networking. In this section, we will briefly discuss what
    some of these examples might look like from a theoretical perspective.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将讨论安全、文件管理和网络等主题。竞态条件不仅存在于关于全局计数器的简单、最小化代码示例中。它们存在于许多重要任务中，如安全、文件管理和网络。在本节中，我们将从理论角度简要讨论这些示例可能的样子。
- en: Security
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Concurrent programming can have significant implications in terms of the security
    of the system in question. Recall that a race condition arises between the process
    of reading and altering the data of a resource; a race condition in an authenticating
    system can cause the corruption of data between the **time of check** (when the
    credentials of an agent are checked) and the **time of use** (when the agent can
    utilize the resource). This problem is also known as a **Time-Of-Check-To-Time-Of-Use**
    (**TOCTTOU**) bug, which is undoubtedly detrimental to security systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程在涉及所讨论系统的安全性方面可能具有重大影响。回想一下，竞态条件出现在读取和修改资源数据的进程之间；在认证系统中，竞态条件可能导致在**检查时间**（检查代理凭证的时间）和**使用时间**（代理可以利用资源的时间）之间的数据损坏。这个问题也被称为**检查到使用时间**（**TOCTTOU**）错误，这对安全系统无疑是破坏性的。
- en: The careless protection of shared resources when handling race conditions, as
    we briefly touched upon in the last section, can provide external agents with
    access to those supposedly protected resources. Those agents can then change the
    data of the resources to create **privilege escalation** (simply put, to give
    themselves illegal access to more shared resources), or they can simply corrupt
    the data, causing the whole system to malfunction.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理竞态条件时对共享资源的粗心保护，正如我们在上一节中简要提到的，可能会让外部代理获得访问那些本应受保护资源的权限。这些代理随后可以更改资源的数据以创建**权限提升**（简单来说，让自己非法访问更多共享资源），或者他们可以简单地破坏数据，导致整个系统出现故障。
- en: Interestingly, race conditions can also be used to implement computer security.
    As race conditions result from the uncoordinated access of multiple threads/processes
    to a shared resource, the specification in which a race condition occurs is significantly
    random. For example, in our Python example, you learned that, when simulating
    a race condition, the final value of the counter varies between different executions
    of the program; this is (partly) because of the unpredictable nature of the situation
    in which multiple threads are running and accessing the shared resources. (I say
    partly since the randomness also results from the random pausing periods that
    we generate in each execution of the program.) So, race conditions are sometimes
    intentionally provoked, and the information obtained when the race condition occurs
    can be used to generate digital fingerprints for security processes—again, this
    information is significantly random and is, therefore, valuable for security purposes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，竞态条件也可以用于实现计算机安全。由于竞态条件是由多个线程/进程对共享资源的无序访问引起的，因此竞态条件发生的具体规范具有很大的随机性。例如，在我们的Python示例中，你了解到，在模拟竞态条件时，计数器的最终值在不同的程序执行中会有所不同；这（部分）是因为多个线程运行并访问共享资源的情况具有不可预测性。（我说部分，因为随机性也源于我们在程序每次执行中生成的随机暂停期。）因此，有时会故意引发竞态条件，而当竞态条件发生时获得的信息可以用于生成安全过程的数字指纹——再次强调，这些信息具有很大的随机性，因此对于安全目的来说非常有价值。
- en: Operating systems
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: Race conditions can occur in the context of file and memory management in an
    operating system, when two separate programs attempt to access the same resource,
    such as memory space. Imagine a situation where two processes from different programs
    have been running for a significant amount of time, and even though they were
    originally initialized apart from each other in terms of memory space, enough
    data has been accumulated and the stack of execution of one process now collides
    with that of the other process. This can lead to the two processes sharing the
    same portion of memory space and, ultimately, can result in unpredictable consequences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统的文件和内存管理上下文中，当两个不同的程序尝试访问同一资源，如内存空间时，可能会发生竞态条件。想象一下，两个来自不同程序的过程已经运行了相当长的时间，尽管它们在内存空间方面最初是分开初始化的，但已经积累了足够的数据，一个进程的执行栈现在与另一个进程的栈发生了碰撞。这可能导致两个进程共享同一部分的内存空间，并最终可能导致不可预测的后果。
- en: Another aspect of the complexity of race conditions is illustrated by version
    7 of Unix's operating system — specifically, in the `mkdir` command. Typically,
    the `mkdir` command is used to create a new directory in the Unix operating system;
    this is done by calling the `mknod` command to create the actual directory and
    the `chown` command to specify the owner of that directory. Because there are
    two separate commands to be run and a definite gap exists between when the first
    command is finished and the second is called, this can cause a race condition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件的复杂性方面另一个例子是Unix操作系统版本7——具体来说，是在`mkdir`命令中。通常，`mkdir`命令用于在Unix操作系统中创建新目录；这是通过调用`mknod`命令来创建实际目录和`chown`命令来指定该目录的所有者来完成的。因为有两个独立的命令需要运行，并且在第一个命令完成和第二个命令调用之间存在一个明确的间隔，这可能导致竞态条件。
- en: 'During the gap between the two commands, if someone deletes the new directory
    created by the `mknod` command and links the reference to another file, when the
    `chown` command is run, the ownership of that file will change. The following
    diagram further illustrates this exploitation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个命令之间的间隔期间，如果有人删除了由`mknod`命令创建的新目录并将引用链接到另一个文件，当运行`chown`命令时，该文件的所属权将发生变化。以下图表进一步说明了这种利用：
- en: '![Figure 14.4 – The mkdir race condition ](img/_B17499Figure_14.4.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – mkdir 竞态条件](img/_B17499Figure_14.4.jpg)'
- en: Figure 14.4 – The mkdir race condition
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – mkdir 竞态条件
- en: By exploiting this vulnerability, someone can, theoretically, change the ownership
    of any file in an operating system so that someone can create a new directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这个漏洞，理论上，某人可以更改操作系统中任何文件的所有权，以便某人可以创建一个新的目录。
- en: Networking
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: In networking, race conditions can take the form of giving multiple users unique
    privileges in a network. Specifically, let's say a given server should only have
    exactly one user with admin privileges. If two users, who are both eligible to
    become the server admin, request access to those privileges at the same time,
    then it is possible for both of them to gain that access. This is because, at
    the point when both of the user requests are received by the server, neither of
    the users have been granted admin privileges yet, and the server thinks that admin
    privileges can still be given out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，竞态条件可能表现为在网络中赋予多个用户独特的权限。具体来说，假设一个服务器应该恰好只有一个拥有管理员权限的用户。如果有两个用户，他们都符合成为服务器管理员的条件，同时请求访问这些权限，那么他们都有可能获得这些权限。这是因为，当两个用户请求同时被服务器接收时，还没有任何用户被授予管理员权限，服务器认为管理员权限仍然可以分配。
- en: This form of a race condition is quite common when a network is highly optimized
    for parallel processing (for example, non-blocking sockets), without any careful
    consideration of the resources shared across the network.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络高度优化以进行并行处理（例如，非阻塞套接字）时，这种形式的竞态条件相当常见，而没有任何仔细考虑网络间共享的资源。
- en: Overall, race conditions can manifest themselves in many important tasks in
    computer science and engineering, such as security, operating systems, and as
    we just saw, networking. This requires the concurrency engineer to be extra vigilant
    about the correctness of their programs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，竞态条件可以在计算机科学和工程中的许多重要任务中表现出来，例如安全、操作系统，正如我们刚才看到的，还有网络。这要求并发工程师对其程序的正确性保持额外的警惕。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A race condition occurs when two or more threads/processes access and alter
    a shared resource simultaneously, resulting in mishandled and corrupted data.
    Race conditions also have significant implications in real-life applications,
    such as security, operating systems, and networking.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程/进程同时访问和修改共享资源时，就会发生竞态条件，导致数据处理不当和数据损坏。竞态条件在现实生活应用中也具有重大影响，例如安全、操作系统和网络。
- en: In this chapter, we learned how to isolate the execution of different threads/processes
    to tackle many forms of race conditions. We have examined how to use locks to
    turn a shared resource into a critical section to protect the integrity of its
    data. Additionally, we have discussed a number of practical disadvantages when
    it comes to using locks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何隔离不同线程/进程的执行以应对多种形式的竞态条件。我们探讨了如何使用锁将共享资源转换为临界区以保护其数据的完整性。此外，我们还讨论了使用锁时的许多实际缺点。
- en: 'In the next chapter, we will consider one of the biggest problems in Python
    concurrent programming: the infamous **Global Interpreter Lock** (**GIL**). You
    will learn about the basic idea behind the GIL, its purposes, and how to effectively
    work with it in concurrent Python applications.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑 Python 并发编程中最大的问题之一：臭名昭著的**全局解释器锁**（**GIL**）。您将了解 GIL 的基本理念、其目的以及如何在并发
    Python 应用程序中有效地与之合作。
- en: Questions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a critical section?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是临界区？
- en: What is a race condition, and why is it undesirable in a concurrent program?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 竞态条件是什么，为什么它在并发程序中不受欢迎？
- en: What is the underlying cause of a race condition?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 竞态条件的根本原因是什么？
- en: How can locks solve the problem of race conditions?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁如何解决竞态条件的问题？
- en: Why are locks sometimes undesirable in a concurrent program?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在并发程序中有时锁是不受欢迎的？
- en: What is the significance of race conditions in real-life systems and applications?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现实生活和应用系统中，竞态条件有什么重要性？
- en: Further reading
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the following resources:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参考以下资源：
- en: '*Parallel Programming with Python*, by Jan Palach, Packt Publishing Ltd, 2014.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Python 并行编程*》，作者 Jan Palach，Packt Publishing Ltd，2014年。
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Python 并行编程食谱*》，作者 Giancarlo Zaccone，Packt Publishing Ltd，2015年。
- en: '*Race Conditions and Critical Sections* (tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections),
    by Jakob Jenkov.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*竞争条件与临界区* (tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections)，作者：Jakob
    Jenkov。'
- en: '*Race conditions, files, and security flaws; or the tortoise and the hare redux*,
    by Matt Bishop, Technical Report CSE-95-98 (1995).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*竞争条件、文件和安全漏洞；或者龟兔赛跑再续*，作者：Matt Bishop，技术报告CSE-95-98（1995）。'
- en: '*Computer and Information Security,* [*Chapter 11*](B17499_11_Final_SS_ePub.xhtml#_idTextAnchor195)*,
    Software Flaws and Malware 1 Illustration* (slideplayer.com/slide/10319860/).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算机与信息安全*，[第11章](B17499_11_Final_SS_ePub.xhtml#_idTextAnchor195)，软件漏洞与恶意软件1说明（slideplayer.com/slide/10319860/）。'
