- en: Chapter 7. Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。表单
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Form workflow
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单工作流程
- en: Untrusted input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不受信任的输入
- en: Form processing with class-based views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于类的视图处理表单
- en: Working with CRUD views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CRUD视图
- en: Let's set aside Django Forms and talk about web forms in general. Forms are
    not just long, boring pages with several items that you have to fill. Forms are
    everywhere. We use them every day. Forms power everything from Google's search
    box to Facebook's **Like** button.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把Django表单放在一边，谈谈一般的网络表单。表单不仅仅是一长串的、乏味的页面，上面有几个你必须填写的项目。表单无处不在。我们每天都在使用它们。表单驱动着从谷歌的搜索框到Facebook的**赞**按钮的一切。
- en: Django abstracts most of the grunt work while working with forms such as validation
    or presentation. It also implements various security best practices. However,
    forms are also common sources of confusion due to one of several states they could
    be in. Let's examine them more closely.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表单时，Django会抽象出大部分繁重的工作，例如验证或呈现。它还实现了各种安全最佳实践。然而，由于它们可能处于多种状态之一，表单也是混淆的常见来源。让我们更仔细地研究它们。
- en: How forms work
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单的工作原理
- en: Forms can be tricky to understand because interacting with them takes more than
    one request-response cycle. In the simplest scenario, you need to present an empty
    form, and the user fills it correctly and submits it. In other cases, they enter
    some invalid data and the form needs to be resubmitted until the entire form is
    valid.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解表单可能有些棘手，因为与它们的交互需要多个请求-响应周期。在最简单的情况下，您需要呈现一个空表单，用户填写正确并提交它。在其他情况下，他们输入了一些无效数据，表单需要重新提交，直到整个表单有效为止。
- en: 'So, a form goes through several states:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表单经历了几种状态：
- en: '**Empty form**: This form is called an unbound form in Django'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空表单**：这种表单在Django中称为未绑定表单'
- en: '**Filled form**: This form is called a bound form in Django'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充表单：在Django中，这种表单称为绑定表单
- en: '**Submitted form with errors**: This form is called a bound form but not a
    valid form'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交的带有错误的表单**：这种表单称为绑定表单，但不是有效的表单'
- en: '**Submitted form without errors**: This form is called a bound and valid form'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交的没有错误的表单**：这种表单在Django中称为绑定和有效的表单'
- en: Note that the users will never see the form in the last state. They don't have
    to. Submitting a valid form should take the users to a success page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用户永远不会看到表单处于最后状态。他们不必这样做。提交有效的表单应该将用户带到成功页面。
- en: Forms in Django
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django中的表单
- en: 'Django''s `form` class contains the state of each field and, by summarizing
    them up a level, of the form itself. The form has two important state attributes,
    which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`form`类包含每个字段的状态，通过总结它们到一个级别，还包括表单本身的状态。表单有两个重要的状态属性，如下所示：
- en: '`is_bound`: If this returns false, then it is an unbound form, that is, a fresh
    form with empty or default field values. If true, then the form is bound, that
    is, at least one field has been set with a user input.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_bound`：如果返回false，则它是一个未绑定的表单，也就是说，一个带有空或默认字段值的新表单。如果为true，则表单是绑定的，也就是说，至少有一个字段已经设置了用户输入。'
- en: '`is_valid()`: If this returns true, then every field in the bound form has
    valid data. If false, then there was some invalid data in at least one field or
    the form was not bound.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_valid()`: 如果返回true，则绑定表单中的每个字段都有有效数据。如果为false，则至少一个字段中有一些无效数据或者表单未绑定。'
- en: 'For example, imagine that you need a simple form that accepts a user''s name
    and age. The form class can be defined as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您需要一个简单的表单，接受用户的姓名和年龄。表单类可以定义如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class can be initiated in a bound or unbound manner, as shown in the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以以绑定或未绑定的方式初始化，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how the HTML representation changes to include the value attributes with
    the bound data in them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意HTML表示如何更改以包括带有其中的绑定数据的值属性。
- en: Forms can be bound only when you create the form object, that is, in the constructor.
    How does the user input end up in a dictionary-like object that contains values
    for each form field?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表单只能在创建表单对象时绑定，也就是在构造函数中。用户输入是如何进入包含每个表单字段值的类似字典的对象中的呢？
- en: 'To find this out, you need to understand how a user interacts with a form.
    In the following diagram, a user opens the person''s details form, fills it incorrectly
    first, submits it, and then resubmits it with the valid information:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这一点，您需要了解用户如何与表单交互。在下图中，用户打开人员详细信息表单，首先填写不正确，然后提交，然后使用有效信息重新提交：
- en: '![Forms in Django](img/6644_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Django中的表单](img/6644_07_01.jpg)'
- en: As shown in the preceding diagram, when the user submits the form, the view
    callable gets all the form data inside `request.POST` (an instance of `QueryDict`).
    The form gets initialized with this dictionary-like object—referred to this way
    since it behaves like a dictionary and has a bit of extra functionality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，当用户提交表单时，视图可调用获取`request.POST`中的所有表单数据（`QueryDict`的实例）。表单使用这个类似字典的对象进行初始化，因为它的行为类似于字典并且具有一些额外的功能。
- en: 'Forms can be defined to send the form data in two different ways: `GET` or
    `POST`. Forms defined with `METHOD="GET"` send the form data encoded in the URL
    itself, for example, when you submit a Google search, your URL will have your
    form input, that is, the search string visibly embedded, such as `?q=Cat+Pictures`.
    The `GET` method is used for idempotent forms, which do not make any lasting changes
    to the state of the world (or to be more pedantic, processing the form multiple
    times has the same effect as processing it once). For most cases, this means that
    it is used only to retrieve data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表单可以定义为以两种不同的方式发送表单数据：`GET`或`POST`。使用`METHOD="GET"`定义的表单将表单数据编码在URL本身中，例如，当您提交Google搜索时，您的URL将具有您的表单输入，即搜索字符串可见地嵌入其中，例如`?q=Cat+Pictures`。`GET`方法用于幂等表单，它不会对世界的状态进行任何持久性更改（或者更严谨地说，多次处理表单的效果与一次处理它的效果相同）。在大多数情况下，这意味着它仅用于检索数据。
- en: However, the vast majority of the forms are defined with `METHOD="POST"`. In
    this case, the form data is sent along with the body of the HTTP request, and
    they are not seen by the user. They are used for anything that involves a side
    effect, such as storing or updating data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，绝大多数的表单都是用`METHOD="POST"`定义的。在这种情况下，表单数据会随着HTTP请求的主体一起发送，用户看不到。它们用于任何涉及副作用的事情，比如存储或更新数据。
- en: Depending on the type of form you have defined, the view will receive the form
    data in `request.GET` or `request.POST`, when the user submits the form. As mentioned
    earlier, either of them will be like a dictionary. So, you can pass it to your
    form class constructor to get a bound `form` object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于您定义的表单类型，当用户提交表单时，视图将在`request.GET`或`request.POST`中接收表单数据。如前所述，它们中的任何一个都将像字典一样。因此，您可以将其传递给您的表单类构造函数以获取一个绑定的`form`对象。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**The Breach**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**入侵**'
- en: Steve was curled up and snoring heavily in his large three-seater couch. For
    the last few weeks, he had been spending more than 12 hours at the office, and
    tonight was no exception. His phone lying on the carpet beeped. At first, he said
    something incoherently, still deep in sleep. Then, it beeped again and again,
    in increasing urgency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫蜷缩着，沉沉地在他的大三座沙发上打呼噜。在过去的几个星期里，他一直在办公室呆了超过12个小时，今晚也不例外。他的手机放在地毯上发出了哔哔声。起初，他还在睡梦中说了些什么，然后，它一次又一次地响，声音越来越紧急。
- en: By the fifth beep, Steve awoke with a start. He frantically searched all over
    his couch, and finally located his phone. The screen showed a brightly colored
    bar chart. Every bar seemed to touch the high line except one. He pulled out his
    laptop and logged into the SuperBook server. The site was up and none of the logs
    indicated any unusual activity. However, the external services didn't look that
    good.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第五声响起时，史蒂夫惊醒了。他疯狂地在沙发上四处搜寻，最终找到了他的手机。屏幕上显示着一个色彩鲜艳的条形图。每根条都似乎触及了高线，除了一根。他拿出笔记本电脑，登录了SuperBook服务器。网站正常，日志中也没有任何异常活动。然而，外部服务看起来并不太好。
- en: The phone at the other end seemed to ring for eternity until a croaky voice
    answered, "Hello, Steve?" Half an hour later, Jacob was able to zero down the
    problem to an unresponsive superhero verification service. "Isn't that running
    on Sauron?" asked Steve. There was a brief hesitation. "I am afraid so," replied
    Jacob.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 电话那头似乎响了很久，直到一个嘶哑的声音回答道：“喂，史蒂夫？”半个小时后，雅各布终于把问题追溯到了一个无响应的超级英雄验证服务。“那不是运行在Sauron上吗？”史蒂夫问道。有一瞬间的犹豫。“恐怕是的，”雅各布回答道。
- en: Steve had a sinking feeling at the pit of his stomach. Sauron, a mainframe application,
    was their first line of defense against cyber-attacks and other kinds of possible
    attack. It was three in the morning when he alerted the mission control team.
    Jacob kept chatting with him the whole time. He was running every available diagnostic
    tool. There was no sign of any security breach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫感到一阵恶心。Sauron是他们对抗网络攻击和其他可能攻击的第一道防线。当他向任务控制团队发出警报时，已经是凌晨三点了。雅各布一直在和他聊天。他运行了所有可用的诊断工具。没有任何安全漏洞的迹象。
- en: Steve tried to calm him down. He reassured him that perhaps it was a temporary
    overload and he should get some rest. However, he knew that Jacob wouldn't stop
    until he found what's wrong. He also knew that it was not typical of Sauron to
    have a temporary overload. Feeling extremely exhausted, he slipped back to sleep.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫试图让自己冷静下来。他安慰自己也许只是暂时超载，应该休息一下。然而，他知道雅各布不会停止，直到找到问题所在。他也知道Sauron不会出现暂时超载的情况。感到极度疲惫，他又睡了过去。
- en: Next morning, as Steve hurried to his office building holding a bagel, he heard
    a deafening roar. He turned and looked up to see a massive spaceship looming towards
    him. Instinctively, he ducked behind a hedge. On the other side, he could hear
    several heavy metallic objects clanging onto the ground. Just then his cell phone
    rang. It was Jacob. Something had moved closer to him. As Steve looked up, he
    saw a nearly 10-foot-tall robot, colored orange and black, pointing what looked
    like a weapon directly down at him.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天早上，史蒂夫手持一个百吉饼匆匆赶往办公楼时，听到了一阵震耳欲聋的轰鸣声。他转过身，看到一艘巨大的飞船朝他飞来。本能地，他躲到了篱笆后面。在另一边，他听到几个沉重的金属物体落到地面上的声音。就在这时，他的手机响了。是雅各布。有什么东西靠近了他。史蒂夫抬头一看，看到了一个将近10英尺高的机器人，橙色和黑色相间，直指他的头上，看起来像是一把武器。
- en: His phone was still ringing. He darted out into the open barely missing the
    sputtering shower of bullets around him. He took the call. "Hey Steve, guess what,
    I found out what actually happened." "I am dying to know," Steve quipped.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 他的手机还在响。他冲到开阔地，差点被周围喷射的子弹击中。他接了电话。“嘿，史蒂夫，猜猜，我终于找到真相了。”“我迫不及待想知道，”史蒂夫说。
- en: '"Remember, we had used UserHoller''s form widget to collect customer feedback?
    Apparently, their data was not that clean. I mean several serious exploits. Hey,
    there is a lot of background noise. Is that the TV?" Steve dived towards a large
    sign that said "Safe Assembly Point". "Just ignore that. Tell me what happened,"
    he screamed.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: “记得我们用UserHoller的表单小部件收集客户反馈吗？显然，他们的数据并不那么干净。我的意思是有几个严重的漏洞。嘿，有很多背景噪音。那是电视吗？”史蒂夫朝着一个大大的标志牌扑去，上面写着“安全集结点”。“别理它。告诉我发生了什么事，”他尖叫道。
- en: '"Okay. So, when our admin opened their feedback page, his laptop must have
    gotten infected. The worm could reach other systems he has access to, specifically,
    Sauron. I must say Jacob, this is a very targeted attack. Someone who knows our
    security system quite well has designed this. I have a feeling something scary
    is coming our way."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “好的。所以，当我们的管理员打开他们的反馈页面时，他的笔记本电脑一定被感染了。这个蠕虫可能会传播到他有权限访问的其他系统，特别是Sauron。我必须说，雅各布，这是一次非常有针对性的攻击。了解我们安全系统的人设计了这个。我有一种不祥的预感，有可怕的事情即将发生。”
- en: Across the lawn, a robot picked up an SUV and hurled it towards Steve. He raised
    his hands and shut his eyes. The spinning mass of metal froze a few feet above
    him. "Important call?" asked Hexa as she dropped the car. "Yeah, please get me
    out of here," Steve begged.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在草坪上，一个机器人抓起了一辆SUV，朝着史蒂夫扔去。他举起手，闭上眼睛。金属的旋转质量在他上方几英尺处冻结了下来。 “重要电话？”Hexa问道，她放下了车。“是的，请帮我离开这里，”史蒂夫恳求道。
- en: Why does data need cleaning?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么数据需要清理？
- en: Eventually, you need to get the "cleaned data" from the form. Does this mean
    that the values that the user had entered were not clean? Yes, for two reasons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您需要从表单中获取“清理后的数据”。这是否意味着用户输入的值不干净？是的，有两个原因。
- en: First, anything that comes from the outside world should not be trusted initially.
    Malicious users can enter all sorts of exploits through a form that can undermine
    the security of your site. So, any form data must be sanitized before you use
    them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，来自外部世界的任何东西最初都不应该被信任。恶意用户可以通过一个表单输入各种各样的漏洞，从而破坏您网站的安全性。因此，任何表单数据在使用之前都必须经过清理。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Never trust the user input.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要相信用户输入。
- en: Secondly, the field values in `request.POST` or `request.GET` are just strings.
    Even if your form field can be defined as an integer (say, age) or date (say,
    birthday), the browser would send them as strings to your view. Invariably, you
    would like to convert them to the appropriate Python types before use. The `form`
    class does this conversion automatically for you while cleaning.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`request.POST`或`request.GET`中的字段值只是字符串。即使您的表单字段可以定义为整数（比如年龄）或日期（比如生日），浏览器也会将它们作为字符串发送到您的视图。无论如何，您都希望在使用之前将它们转换为适当的Python类型。`form`类在清理时会自动为您执行此转换。
- en: 'Let''s see this in action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实际操作：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The age value was passed as a string (possibly, from `request.POST`) to the
    form class. After validation, the cleaned data contains the age in the integer
    form. This is exactly what you would expect. Forms try to abstract away the fact
    that strings are passed around and give you clean Python objects that you can
    use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄值作为字符串（可能来自`request.POST`）传递给表单类。验证后，清理数据包含整数形式的年龄。这正是你所期望的。表单试图抽象出字符串传递的事实，并为您提供可以使用的干净的Python对象。
- en: Displaying forms
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示表单
- en: 'Django forms also help you create an HTML representation of your form. They
    support three different representations: `as_p` (as paragraph tags), `as_ul` (as
    unordered list items), and `as_table` (as, unsurprisingly, a table).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Django表单还可以帮助您创建表单的HTML表示。它们支持三种不同的表示形式：`as_p`（作为段落标签），`as_ul`（作为无序列表项）和`as_table`（作为，不出所料，表格）。
- en: 'The template code, generated HTML code, and browser rendering for each of these
    representations have been summarized in the following table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表示形式的模板代码、生成的HTML代码和浏览器渲染已经总结在下表中：
- en: '| Template | Code | Output in Browser |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 模板 | 代码 | 浏览器中的输出 |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `{{ form.as_p }}` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `{{ form.as_p }}` |'
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| ![Displaying forms](img/6644_07_02.jpg) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ![显示表单](img/6644_07_02.jpg) |'
- en: '| `{{ form.as_ul }}` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `{{ form.as_ul }}` |'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| ![Displaying forms](img/6644_07_03.jpg) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| ![显示表单](img/6644_07_03.jpg) |'
- en: '| `{{ form.as_table }}` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `{{ form.as_table }}` |'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| ![Displaying forms](img/6644_07_04.jpg) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| ![显示表单](img/6644_07_04.jpg) |'
- en: 'Notice that the HTML representation gives only the form fields. This makes
    it easier to include multiple Django forms in a single HTML form. However, this
    also means that the template designer has a fair bit of boilerplate to write for
    each form, as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HTML表示仅提供表单字段。这样可以更容易地在单个HTML表单中包含多个Django表单。但是，这也意味着模板设计者需要为每个表单编写相当多的样板代码，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that to make the HTML representation complete, you need to add the surrounding
    `form` tags, a CSRF token, the `table` or `ul` tags, and the **submit** button.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使HTML表示完整，您需要添加周围的`form`标签，CSRF令牌，`table`或`ul`标签和**submit**按钮。
- en: Time to be crisp
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间变得简洁
- en: It can get tiresome to write so much boilerplate for each form in your templates.
    The `django-crispy-forms` package makes writing the form template code more crisp
    (in the sense of short). It moves all the presentation and layout into the Django
    form itself. This way, you can write more Python code and less HTML.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中为每个表单编写如此多的样板代码可能会让人感到厌烦。`django-crispy-forms`包使得编写表单模板代码更加简洁（在长度上）。它将所有的演示和布局都移到了Django表单本身。这样，您可以编写更多的Python代码，而不是HTML。
- en: 'The following table shows that the crispy form template tag generates a more
    complete form, and the appearance is much more native to the Bootstrap style:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了脆弱的表单模板标记生成了一个更完整的表单，并且外观更符合Bootstrap样式：
- en: '| Template | Code | Output in Browser |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 模板 | 代码 | 浏览器中的输出 |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `{% crispy form %}` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `{% crispy form %}` |'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (HTML truncated for brevity) | ![Time to be crisp](img/6644_07_05.jpg) |
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: （为简洁起见截断了HTML）| ![时间变得简洁](img/6644_07_05.jpg) |
- en: 'So, how do you get crisper forms? You will need to install the `django-crispy-forms`
    package and add it to your `INSTALLED_APPS`. If you use Bootstrap 3, then you
    will need to mention this in your settings:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何获得更清晰的表单？您需要安装`django-crispy-forms`包并将其添加到`INSTALLED_APPS`中。如果您使用Bootstrap
    3，则需要在设置中提到这一点：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The form initialization will need to mention a helper attribute of the type
    `FormHelper`. The following code is intended to be minimal and uses the default
    layout:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表单初始化将需要提及`FormHelper`类型的辅助属性。下面的代码旨在尽量简化，并使用默认布局：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Understanding CSRF
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CSRF
- en: So, you must have noticed something called a **CSRF** token in the form templates.
    What does it do? It is a security mechanism against **Cross-Site Request Forgery**
    (CSRF) attacks for your forms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您一定会注意到表单模板中有一个名为**CSRF**令牌的东西。它是针对您的表单的**跨站请求伪造**（CSRF）攻击的安全机制。
- en: It works by injecting a server-generated random string called a CSRF token,
    unique to a user's session. Every time a form is submitted, it must have a hidden
    field that contains this token. This token ensures that the form was generated
    for the user by the original site, rather than a fake form created by an attacker
    with similar fields.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过注入一个名为CSRF令牌的服务器生成的随机字符串来工作，该令牌对用户的会话是唯一的。每次提交表单时，必须有一个包含此令牌的隐藏字段。此令牌确保表单是由原始站点为用户生成的，而不是攻击者创建的具有类似字段的伪造表单。
- en: CSRF tokens are not recommended for forms using the `GET` method because the
    `GET` actions should not change the server state. Moreover, forms submitted via
    `GET` would expose the CSRF token in the URLs. Since URLs have a higher risk of
    being logged or shoulder-sniffed, it is better to use CSRF in forms using the
    `POST` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议为使用`GET`方法的表单使用CSRF令牌，因为`GET`操作不应更改服务器状态。此外，通过`GET`提交的表单将在URL中公开CSRF令牌。由于URL有更高的被记录或被窥视的风险，最好在使用`POST`方法的表单中使用CSRF。
- en: Form processing with Class-based views
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于类的视图进行表单处理
- en: 'We can essentially process a form by subclassing the Class-based view itself:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对基于类的视图本身进行子类化来实质上处理表单：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compare this code with the sequence diagram that we saw previously. The three
    scenarios have been separately handled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与我们之前看到的序列图进行比较。这三种情况已经分别处理。
- en: Every form is expected to follow the **Post/Redirect/Get** (**PRG**) pattern.
    If the submitted form is found to be valid, then it must issue a redirect. This
    prevents duplicate form submissions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单都应遵循**Post/Redirect/Get**（**PRG**）模式。如果提交的表单被发现有效，则必须发出重定向。这可以防止重复的表单提交。
- en: 'However, this is not a very DRY code. The form class name and template name
    attributes have been repeated. Using a generic class-based view such as `FormView`
    can reduce the redundancy of form processing. The following code will give you
    the same functionality as the previous one in fewer lines of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这不是一个非常DRY的代码。表单类名称和模板名称属性已被重复。使用诸如`FormView`之类的通用基于类的视图可以减少表单处理的冗余。以下代码将以更少的代码行数为您提供与以前相同的功能：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to use `reverse_lazy` in this case because the URL patterns are not
    loaded when the view file is imported.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要使用`reverse_lazy`，因为在导入视图文件时，URL模式尚未加载。
- en: Form patterns
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单模式
- en: Let's take a look at some of the common patterns when working with forms.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些处理表单时常见的模式。
- en: Pattern – dynamic form generation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 动态表单生成
- en: '**Problem**: Adding form fields dynamically or changing form fields from what
    has been declared.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：动态添加表单字段或更改已声明的表单字段。'
- en: '**Solution**: Add or change fields during initialization of the form.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在表单初始化期间添加或更改字段。'
- en: Problem details
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Forms are usually defined in a declarative style with form fields listed as
    class fields. However, sometimes we do not know the number or type of these fields
    in advance. This calls for the form to be dynamically generated. This pattern
    is sometimes called **Dynamic Forms** or **Runtime form generation**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常以声明式样式定义表单，其中表单字段列为类字段。但是，有时我们事先不知道这些字段的数量或类型。这需要动态生成表单。这种模式有时被称为**动态表单**或**运行时表单生成**。
- en: Imagine a flight passenger check-in system, which allows for the upgrade of
    economy class tickets to first class. If there are any first-class seats left,
    there needs to be an additional option to the user if they would like to fly first
    class. However, this optional field cannot be declared since it will not be shown
    to all users. Such dynamic forms can be handled by this pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个航班乘客登机系统，允许将经济舱机票升级到头等舱。如果还有头等舱座位，需要为用户提供一个额外的选项，询问他们是否想要头等舱。但是，这个可选字段不能被声明，因为它不会显示给所有用户。这种动态表单可以通过这种模式处理。
- en: Solution details
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: Every form instance has an attribute called `fields`, which is a dictionary
    that holds all the form fields. This can be modified at runtime. Adding or changing
    the fields can be done during form initialization itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单实例都有一个名为`fields`的属性，它是一个保存所有表单字段的字典。这可以在运行时进行修改。在表单初始化期间可以添加或更改字段。
- en: 'For example, if we need to add a checkbox to a user details form only if a
    keyword argument named "`upgrade`" is true at form initialization, then we can
    implement it as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要在用户详细信息表单中添加一个复选框，只有在表单初始化时命名为"`upgrade`"的关键字参数为true时，我们可以实现如下：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we just need to pass the, `PersonDetailsForm(upgrade=True)` keyword argument
    to make an additional Boolean input field ( a checkbox) appear.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要传递`PersonDetailsForm(upgrade=True)`关键字参数，就可以使一个额外的布尔输入字段（复选框）出现。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that a newly introduced keyword argument has to be removed or popped before
    we call `super` to avoid the `unexpected keyword` error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`super`之前，新引入的关键字参数必须被移除或弹出，以避免`unexpected keyword`错误。
- en: 'If we use a `FormView` class for this example, then we need to pass the keyword
    argument by overriding the `get_form_kwargs` method of the view class, as shown
    in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个例子中使用`FormView`类，则需要通过覆盖视图类的`get_form_kwargs`方法传递关键字参数，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This pattern can be used to change any attribute of a field at runtime, such
    as its widget or help text. It works for model forms as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式可用于在运行时更改字段的任何属性，例如其小部件或帮助文本。它也适用于模型表单。
- en: In many cases, a seeming need for dynamic forms can be solved using Django formsets.
    They are used when a form needs to be repeated in a page. A typical use case for
    formsets is while designing a data grid-like view to add elements row by row.
    This way, you do not need to create a dynamic form with an arbitrary number of
    rows. You just need to create a form for the row and create multiple rows using
    a `formset_factory` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，看似需要动态表单的需求可以使用Django表单集来解决。当需要在页面中重复一个表单时，可以使用表单集。表单集的典型用例是在设计类似数据网格的视图时，逐行添加元素。这样，您不需要创建具有任意行数的动态表单。您只需要为行创建一个表单，并使用`formset_factory`函数创建多行。
- en: Pattern – user-based forms
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 基于用户的表单
- en: '**Problem**: Forms need to be customized based on the logged-in user.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：根据已登录用户的情况自定义表单。'
- en: '**Solution**: Pass the logged-in user as a keyword argument to the form''s
    initializer.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将已登录用户作为关键字参数传递给表单的初始化程序。'
- en: Problem details
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: A form can be presented in different ways based on the user. Certain users might
    not need to fill all the fields, while certain others might need to add additional
    information. In some cases, you might need to run some checks on the user's eligibility,
    such as verifying whether they are members of a group, to determine how the form
    should be constructed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的不同，表单可以以不同的方式呈现。某些用户可能不需要填写所有字段，而另一些用户可能需要添加额外的信息。在某些情况下，您可能需要对用户的资格进行一些检查，例如验证他们是否是某个组的成员，以确定应该如何构建表单。
- en: Solution details
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: As you must have noticed, you can solve this using the solution given in the
    Dynamic form generation pattern. You just need to pass `request.user` as a keyword
    argument to the form. However, we can also use mixins from the `django-braces`
    package for a shorter and more reusable solution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，您可以使用动态表单生成模式中提供的解决方案来解决这个问题。您只需要将`request.user`作为关键字参数传递给表单。但是，我们也可以使用`django-braces`包中的mixin来实现更简洁和更可重用的解决方案。
- en: 'As in the previous example, we need to show an additional checkbox to the user.
    However, this will be shown only if the user is a member of the VIP group. Let''s
    take a look at how `PersonDetailsForm` gets simplified with the form mixin `UserKwargModelFormMixin`
    from `django-braces`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们需要向用户显示一个额外的复选框。但是，只有当用户是VIP组的成员时才会显示。让我们看看如何使用`django-braces`中的表单mixin`UserKwargModelFormMixin`简化了`PersonDetailsForm`：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how `self.user` was automatically made available by the mixin by popping
    the `user` keyword argument.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，mixin通过弹出`user`关键字参数自动使`self.user`可用。
- en: 'Corresponding to the form mixin, there is a view mixin called `UserFormKwargsMixin`,
    which needs to be added to the view, along with `LoginRequiredMixin` to ensure
    that only logged-in users can access this view:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与表单mixin对应的是一个名为`UserFormKwargsMixin`的视图mixin，需要将其添加到视图中，以及`LoginRequiredMixin`以确保只有已登录用户才能访问此视图：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the `user` argument will be passed to the `PersonDetailsForm` form automatically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`user`参数将自动传递给`PersonDetailsForm`表单。
- en: Do check out other form mixins in `django-braces` such as `FormValidMessageMixin,`
    which are readymade solutions to common form-usage patterns.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`django-braces`中的其他表单mixin，例如`FormValidMessageMixin`，这些都是常见表单使用模式的现成解决方案。
- en: Pattern – multiple form actions per view
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式-单个视图中的多个表单操作
- en: '**Problem**: Handling multiple form actions in a single view or page.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：在单个视图或页面中处理多个表单操作。'
- en: '**Solution**: Forms can use separate views to handle form submissions or a
    single view can identify the form based on the `Submit` button''s name.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：表单可以使用单独的视图来处理表单提交，或者单个视图可以根据`Submit`按钮的名称来识别表单。'
- en: Problem details
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: Django makes it relatively straightforward to combine multiple forms with the
    same action, for example, a single submit button. However, most web pages need
    to show several actions on the same page. For example, you might want the user
    to subscribe or unsubscribe from a newsletter in two distinct forms on the same
    page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Django相对简单地将多个具有相同操作的表单组合在一起，例如一个单独的提交按钮。然而，大多数网页需要在同一页上显示多个操作。例如，您可能希望用户在同一页上通过两个不同的表单订阅或取消订阅通讯。
- en: However, Django's `FormView` is designed to handle only one form per view scenario.
    Many other generic class-based views also share this assumption.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Django的`FormView`设计为每个视图场景处理一个表单。许多其他通用的基于类的视图也有这种假设。
- en: Solution details
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: 'There are two ways to handle multiple forms: a separate view and single view.
    Let''s take a look at the first approach.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个表单有两种方法：单独视图和单一视图。让我们先看看第一种方法。
- en: Separate views for separate actions
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对不同操作的单独视图
- en: This is a fairly straightforward approach with each form specifying different
    views as their actions. For example, take the subscribe and unsubscribe forms.
    There can be two separate view classes to handle just the `POST` method from their
    respective forms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常直接的方法，每个表单都指定不同的视图作为它们的操作。例如，订阅和取消订阅表单。可以有两个单独的视图类来处理它们各自表单的`POST`方法。
- en: Same view for separate actions
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相同视图用于不同操作
- en: Perhaps you find the splitting views to handle forms to be unnecessary, or you
    find handling logically related forms in a common view to be more elegant. Either
    way, we can work around the limitations of generic class-based views to handle
    more than one form.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会发现拆分视图以处理表单是不必要的，或者您会发现在一个公共视图中处理逻辑相关的表单更加优雅。无论哪种方式，我们都可以解决通用基于类的视图的限制，以处理多个表单。
- en: While using the same view class for multiple forms, the challenge is to identify
    which form issued the `POST` action. Here, we take advantage of the fact that
    the name and value of the `Submit` button is also submitted. If the `Submit` button
    is named uniquely across forms, then the form can be identified while processing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用相同的视图类处理多个表单时，挑战在于识别哪个表单发出了`POST`操作。在这里，我们利用了`Submit`按钮的名称和值也会被提交的事实。如果`Submit`按钮在各个表单中具有唯一的名称，那么在处理过程中就可以识别表单。
- en: 'Here, we define a subscribe form using crispy forms so that we can name the
    `submit` button as well:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用crispy forms定义一个订阅表单，以便我们也可以命名`submit`按钮：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `UnSubscribeForm` unsubscribe form class is defined in exactly the same
    way (and hence is, omitted), except that its `Submit` button is named `unsubscribe_butn`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnSubscribeForm`取消订阅表单类的定义方式完全相同（因此被省略），只是其`Submit`按钮的名称为`unsubscribe_butn`。'
- en: 'Since `FormView` is designed for a single form, we will use a simpler class-based
    view say, `TemplateView`, as the base for our view. Let''s take a look at the
    view definition and the `get` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FormView`设计为单个表单，我们将使用一个更简单的基于类的视图，比如`TemplateView`，作为我们视图的基础。让我们来看看视图定义和`get`方法：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The keyword arguments to a `TemplateView` class get conveniently inserted into
    the template context. We create instances of either form only if they don't already
    exist, with the help of the `setdefault` dictionary method. We will soon see why.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateView` 类的关键字参数方便地插入到模板上下文中。我们只有在它们不存在时才创建任一表单的实例，借助 `setdefault` 字典方法的帮助。我们很快就会看到原因。'
- en: 'Next, we will take a look at the `POST` method, which handles submissions from
    either form:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下 `POST` 方法，它处理来自任一表单的提交：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, the form keyword arguments, such as `data` and `files`, are populated
    in a `form_args` dictionary. Next, the presence of the first form's `Submit` button
    is checked in `request.POST`. If the button's name is found, then the first form
    is instantiated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，表单关键字参数，如 `data` 和 `files`，在 `form_args` 字典中填充。接下来，在 `request.POST` 中检查第一个表单的
    `Submit` 按钮是否存在。如果找到按钮的名称，则实例化第一个表单。
- en: If the form fails validation, then the response created by the `GET` method
    with the first form's instance is returned. In the same way, we look for the second
    forms submit button to check whether the second form was submitted.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单未通过验证，则返回由第一个表单实例创建的 `GET` 方法创建的响应。同样，我们查找第二个表单的提交按钮，以检查是否提交了第二个表单。
- en: Instances of the same form in the same view can be implemented in the same way
    with form prefixes. You can instantiate a form with a prefix argument such as
    `SubscribeForm(prefix="offers")`. Such an instance will prefix all its form fields
    with the given argument, effectively working like a form namespace.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个视图中实现相同表单的实例可以通过表单前缀以相同的方式实现。您可以使用前缀参数实例化一个表单，例如 `SubscribeForm(prefix="offers")`。这样的实例将使用给定的参数为其所有表单字段添加前缀，有效地像表单命名空间一样工作。
- en: Pattern – CRUD views
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - CRUD 视图
- en: '**Problem**: Writing boilerplate for CRUD interfaces to a model is repetitive.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：为模型创建 CRUD 接口的样板代码是重复的。'
- en: '**Solution**: Use generic class-based editing views.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：使用通用基于类的编辑视图。'
- en: Problem details
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题细节
- en: In most web applications, about 80 percent of the time is spent writing, creating,
    reading, updating, and deleting (CRUD) interfaces to a database. For instance,
    Twitter essentially involves creating and reading each other's tweets. Here, a
    tweet would be the database object that is being manipulated and stored.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Web 应用程序中，大约 80% 的时间用于编写、创建、读取、更新和删除（CRUD）与数据库的接口。例如，Twitter 本质上涉及创建和阅读彼此的推文。在这里，推文将是正在被操作和存储的数据库对象。
- en: Writing such interfaces from scratch can get tedious. This pattern can be easily
    managed if CRUD interfaces can be automatically created from the model class itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始编写这样的接口可能会变得乏味。如果可以从模型类自动创建 CRUD 接口，这种模式就可以很容易地管理。
- en: Solution details
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: 'Django simplifies the process of creating CRUD views with a set of four generic
    class-based views. They can be mapped to their corresponding operations as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Django 通过一组四个通用的基于类的视图简化了创建 CRUD 视图的过程。它们可以映射到它们对应的操作，如下所示：
- en: '`CreateView`: This view displays a blank form to create a new object'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateView`：此视图显示一个空白表单以创建一个新对象'
- en: '`DetailView`: This view shows an object''s details by reading from the database'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetailView`：此视图通过从数据库中读取显示对象的详细信息'
- en: '`UpdateView`: This view allows to update an object''s details through a pre-populated
    form'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateView`：此视图允许通过预填充表单更新对象的详细信息'
- en: '`DeleteView`: This view displays a confirmation page and, on approval, deletes
    the object'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteView`：此视图显示确认页面，并在批准后删除对象'
- en: 'Let''s take a look at a simple example. We have a model that contains important
    dates, which are of interest to everyone using our site. We need to build simple
    CRUD interfaces so that anyone can view and modify these dates. Let''s take a
    look at the `ImportantDate` model itself:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。我们有一个包含重要日期的模型，这对于使用我们的网站的每个人都很重要。我们需要构建简单的 CRUD 接口，以便任何人都可以查看和修改这些日期。让我们看看
    `ImportantDate` 模型本身：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `get_absolute_url()` method is used by the `CreateView` and `UpdateView`
    classes to redirect after a successful object creation or update. It has been
    routed to the object's `DetailView`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_absolute_url()` 方法被 `CreateView` 和 `UpdateView` 类使用，用于在成功创建或更新对象后重定向。它已经路由到对象的
    `DetailView`。'
- en: 'The CRUD views themselves are simple enough to be self-explanatory, as shown
    in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 视图本身足够简单，可以自解释，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In these generic views, the model class is the only mandatory member to be mentioned.
    However, in the case of `DeleteView`, the `success_url` function needs to be mentioned
    as well. This is because after deletion `get_absolute_url` cannot be used anymore
    to find out where to redirect users.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些通用视图中，模型类是唯一必须提及的成员。然而，在 `DeleteView` 的情况下，还需要提及 `success_url` 函数。这是因为在删除后，不能再使用
    `get_absolute_url` 来找出要重定向用户的位置。
- en: 'Defining the `form_class` attribute is not mandatory. If it is omitted, a `ModelForm`
    method corresponding to the specified model will be created. However, we would
    like to create our own model form to take advantage of crispy forms, as shown
    in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `form_class` 属性不是强制性的。如果省略，将创建一个与指定模型对应的 `ModelForm` 方法。然而，我们希望创建自己的模型表单以利用
    crispy forms，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to crispy forms, we need very little HTML markup in our templates to
    build these CRUD forms.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 crispy forms，我们在模板中几乎不需要太多的 HTML 标记来构建这些 CRUD 表单。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that explicitly mentioning the fields of a `ModelForm` method is a best
    practice and will soon become mandatory in future releases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，明确提及 `ModelForm` 方法的字段是最佳实践，并且很快将在未来的版本中成为强制性的。
- en: The template paths, by default, are based on the view class and the model names.
    For brevity, we omitted the template source here. Note that we can use the same
    form for `CreateView` and `UpdateView`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模板路径基于视图类和模型名称。为简洁起见，我们在这里省略了模板源。请注意，我们可以在 `CreateView` 和 `UpdateView`
    中使用相同的表单。
- en: 'Finally, we take a look at `urls.py`, where everything is wired up together:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看 `urls.py`，在那里一切都被连接在一起：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Django generic views are a great way to get started with creating CRUD views
    for your models. With a few lines of code, you get well-tested model forms and
    views created for you, rather than doing the boring task yourself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Django通用视图是创建模型的CRUD视图的绝佳方式。只需几行代码，您就可以获得经过充分测试的模型表单和视图，而不是自己进行乏味的任务。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how web forms work and how they are abstracted
    using form classes in Django. We also looked at the various techniques and patterns
    to save time while working with forms.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看了网页表单是如何工作的，以及它们如何在Django中使用表单类进行抽象。我们还研究了在处理表单时节省时间的各种技术和模式。
- en: In the next chapter, we will take a look at a systematic approach to work with
    a legacy Django codebase, and how we can enhance it to meet evolving client needs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将系统地探讨如何处理遗留的Django代码库，并如何增强它以满足不断发展的客户需求。
