- en: Chapter 3. Encoding Secret Messages with Steganography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。使用隐写术编码秘密信息
- en: We're going to acquire intelligence data from a variety of sources. In the previous
    chapter, we searched the WWW. We might use our own cameras or recording devices.
    We'll look at image processing and encoding in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从各种来源获取智能数据。在上一章中，我们在万维网（WWW）中进行了搜索。我们可能会使用自己的相机或录音设备。在本章中，我们将探讨图像处理和编码。
- en: To work with images in Python, we'll need to install Pillow. This library gives
    us software tools to process image files. Pillow is a fork of the older PIL project;
    Pillow is a bit nicer to use than PIL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中处理图像，我们需要安装 Pillow。这个库为我们提供了处理图像文件的软件工具。Pillow 是较老 PIL 项目的分支；与 PIL
    相比，Pillow 使用起来更方便。
- en: 'Along the way, we''ll visit some additional Python programming techniques,
    including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将访问一些额外的 Python 编程技术，包括：
- en: We'll review how Python works with OS files and also look at some common physical
    formats, including ZIP files, JSON, and CSV.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾 Python 如何与操作系统文件协同工作，并查看一些常见的物理格式，包括 ZIP 文件、JSON 和 CSV。
- en: We'll introduce JPEG files and learn to process them with Pillow. We'll have
    to install Pillow before we can make this work.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将介绍 JPEG 文件，并学习使用 Pillow 处理它们。在我们可以使这成为可能之前，我们必须安装 Pillow。
- en: We'll look at several image transformations, such as getting the EXIF data,
    creating thumbnails, cropping, enhancing, and filtering.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨几种图像转换，例如获取 EXIF 数据、创建缩略图、裁剪、增强和过滤。
- en: We'll look at how we can fiddle with the individual bits that make up an integer
    value.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨如何调整构成整数值的各个单独的比特位。
- en: We'll also see how we work with Unicode characters and how characters are encoded
    into bytes.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将了解如何与 Unicode 字符协同工作，以及字符如何编码成字节。
- en: Learning to work with Unicode characters will allow us to encode data in the
    pixels of an image file. We'll look at the two common steganography algorithms.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习与 Unicode 字符协同工作将使我们能够在图像文件的像素中编码数据。我们将探讨两种常见的隐写术算法。
- en: We'll also take a quick side trip to look at secure hashes. This will show us
    how to make messages that can't be altered in transmission.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将快速浏览一下安全散列。这将向我们展示如何创建在传输过程中无法更改的消息。
- en: Python is a very powerful programming language. In this chapter, we'll see a
    lot of sophistication available. We'll also lay a foundation to look at web services
    and geocoding in the next chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种非常强大的编程语言。在本章中，我们将看到许多高级功能。我们还将为下一章查看网络服务和地理编码打下基础。
- en: Background briefing – handling file formats
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景简报 - 处理文件格式
- en: As we've observed so far, our data comes in a wide variety of physical formats.
    In [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage Toolkit*,
    we looked at ZIP files, which are archives that contain other files. In [Chapter
    2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring Intelligence
    Data*, we looked at JSON files, which serialize many kinds of Python objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，我们的数据以广泛的物理格式存在。在 [第 1 章](ch01.html "第 1 章。我们的间谍工具包")，*我们的间谍工具包* 中，我们探讨了
    ZIP 文件，它包含其他文件的存档。在 [第 2 章](ch02.html "第 2 章。获取情报数据")，*获取情报数据* 中，我们探讨了 JSON 文件，它序列化了多种
    Python 对象。
- en: In this chapter, we're going to review some previous technology and then look
    at working specifically with CSV files. The important part is to look at the various
    kinds of image files that we might need to work with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些以前的技术，然后具体探讨与 CSV 文件协同工作。重要的是要查看我们可能需要与之协同工作的各种图像文件。
- en: In all cases, Python encourages looking at a file as a kind of context. This
    means that we should strive to open files using the `with` statement so that we
    can be sure the file is properly closed when we're done with the processing. This
    doesn't always work out perfectly, so there are some exceptions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，Python 鼓励将文件视为一种上下文。这意味着我们应该努力使用 `with` 语句打开文件，以确保在处理完成后文件能够正确关闭。这并不总是完美无缺，因此存在一些例外。
- en: Working with the OS filesystem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与操作系统文件系统协同工作
- en: 'There are many modules for working with files. We''ll focus on two: `glob`
    and `os`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于处理文件的模块。我们将关注两个：`glob` 和 `os`。
- en: glob
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: glob
- en: 'The `glob` module implements filesystem *globbing* rules. When we use `*.jpg`
    in a command at the terminal prompt, a standard OS shell tool will *glob* or expand
    the wildcard name into a matching list of actual file names, as shown in the following
    snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob` 模块实现了文件系统 *globbing* 规则。当我们在终端提示符中使用 `*.jpg` 时，标准的操作系统外壳工具将 *glob* 或将通配符名称扩展为实际文件名列表，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The POSIX standard is for `*.jpg` to be expanded by the shell, prior to the
    `ls` program being run. In Windows, this is not always the case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 标准是，在运行 `ls` 程序之前，`*.jpg` 应由 shell 展开。在 Windows 上，情况并不总是如此。
- en: 'The Python `glob` module contains the `glob()` function that does this job
    from within a Python program. Here''s an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `glob` 模块包含一个 `glob()` 函数，可以在 Python 程序内部完成这项工作。以下是一个示例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we evaluated `glob.glob("*.jpg")`, the return value was a list of strings
    with the names of matching files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估 `glob.glob("*.jpg")` 时，返回值是一个包含匹配文件名的字符串列表。
- en: os
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: os
- en: 'Many files have a `path/name.extension` format. For Windows, a device prefix
    and the backslash is used (`c:path\name.ext`). The Python `os` package provides
    a `path` module with a number of functions for working with file names and paths
    irrespective of any vagaries of punctuation. As the `path` module is in the `os`
    package, the components will have two levels of namespace containers: `os.path`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件具有 `path/name.extension` 格式。对于 Windows，使用设备前缀和反斜杠（`c:path\name.ext`）。Python
    的 `os` 包提供了一个 `path` 模块，其中包含许多用于处理文件名和路径的函数，无论标点符号如何。由于 `path` 模块位于 `os` 包中，组件将具有两层命名空间容器：`os.path`。
- en: 'We must always use functions from the `os.path` module for working with filenames.
    There are numerous functions to split paths, join paths, and create absolute paths
    from relative paths. For example, we should use `os.path.splitext()` to separate
    a filename from the extension. Here''s an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终使用 `os.path` 模块中的函数来处理文件名。该模块提供了许多分割路径、连接路径和从相对路径创建绝对路径的函数。例如，我们应该使用 `os.path.splitext()`
    来将文件名与扩展名分开。以下是一个示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've separated the filename from the extension without writing any of our own
    code. There's no reason to write our own parsers when the standard library already
    has them written.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将文件名与扩展名分开，而没有编写任何自己的代码。当标准库已经提供了这些功能时，就没有必要编写自己的解析器。
- en: Processing simple text files
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理简单的文本文件
- en: 'In some cases, our files contain ordinary text. In this case, we can open the
    file and process the lines as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们的文件包含普通文本。在这种情况下，我们可以打开文件并按以下方式处理行：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the most common way to work with text files. Each line processed by
    the `for` loop will include a trailing `\n` character.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的处理文本文件的方式。`for` 循环处理的每一行都会包含一个尾随的 `\n` 字符。
- en: 'We can use a simple generator expression to strip the trailing spaces from
    each line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的生成器表达式来去除每行的尾随空格：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ve inserted a generator expression into the `for` statement. The generator
    expression has three parts: a subexpression (`raw.rstrip()`), a target variable
    (`raw`), and a source iterable collection (`data`). Each line in the source iterable,
    `data`, is assigned to the target, `raw`, and the subexpression is evaluated.
    Each result from the generator expression is made available to the outer `for`
    loop.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `for` 语句中插入了一个生成器表达式。生成器表达式有三个部分：一个子表达式（`raw.rstrip()`）、一个目标变量（`raw`）和一个源可迭代集合（`data`）。源可迭代集合
    `data` 中的每一行都分配给目标 `raw`，并评估子表达式。生成器表达式的每个结果都可供外部的 `for` 循环使用。
- en: 'We can visually separate the generator expression into a separate line of code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将生成器表达式单独写成一行代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We wrote the generator expression outside the `for` statement. We assigned
    the generator—not the resulting collection—to the `clean_lines` variable to clarify
    its purpose. A generator doesn''t generate any output until the individual lines
    are required by another iterator, in this case, the `for` loop. There''s no real
    overhead: the processing is simply separated visually.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成器表达式写在了 `for` 语句外面。我们将生成器——而不是结果集合——赋值给 `clean_lines` 变量，以明确其目的。生成器不会产生任何输出，直到另一个迭代器（在这种情况下是
    `for` 循环）需要单独的行。实际上没有开销：处理只是从视觉上分开。
- en: This technique allows us to separate different design considerations. We can
    separate the text cleanup from the important processing inside the `for` statement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使我们能够将不同的设计考虑因素分开。我们可以将文本清理与 `for` 语句中的重要处理分开。
- en: 'We can expand on the cleanup by writing additional generators:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写额外的生成器来扩展清理过程：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've broken down two preprocessing steps into two separate generator expressions.
    The first expression removes the `\n` character from the end of each line. The
    second generator expression uses the optional `if` clause—it will get lines from
    the first generator expression and only pass lines if the length is not 0\. This
    is a filter that rejects blank lines. The final `for` statement only gets nonblank
    lines that have had the `\n` character removed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个预处理步骤分解为两个单独的生成器表达式。第一个表达式从每行的末尾删除 `\n` 字符。第二个生成器表达式使用可选的 `if` 子句——它将从第一个生成器表达式获取行，并且只有当长度不为
    0 时才传递行。这是一个拒绝空白行的过滤器。最终的 `for` 语句只获取已经删除 `\n` 字符的非空白行。
- en: Working with ZIP files
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 ZIP 文件一起工作
- en: 'A ZIP archive contains one or more files. To use `with` with ZIP archives,
    we need to import the `zipfile` module:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ZIP 存档包含一个或多个文件。要使用 `with` 与 ZIP 存档一起，我们需要导入 `zipfile` 模块：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Generally, we can open an archive using something like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以使用类似以下的方式打开一个存档：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This creates a context so that we can work with the file and be sure that it's
    properly closed at the end of the indented context.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个上下文，这样我们就可以处理文件，并确保在缩进上下文结束时文件被正确关闭。
- en: 'When we want to create an archive, we can provide an additional parameter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建一个存档时，我们可以提供一个额外的参数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create a ZIP file that uses a simple compression algorithm to save
    space. If we''re reading members of a ZIP archive, we can use a nested context
    to open this member file, as shown in the following snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个使用简单压缩算法来节省空间的 ZIP 文件。如果我们正在读取 ZIP 存档的成员，我们可以使用嵌套上下文来打开此成员文件，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we showed in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"),
    *Our Espionage Toolkit*, once we''ve opened a member for reading, it''s similar
    to an ordinary OS file. The nested context allows us to use ordinary file processing
    operations on the member. We used the following example earlier:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 1 章](ch01.html "第 1 章。我们的间谍工具包") 中所展示的，*我们的间谍工具包*，一旦我们为读取打开了成员，它就类似于一个普通的操作系统文件。嵌套上下文允许我们对该成员使用普通的文件处理操作。我们之前使用了以下示例：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We used a context to open the archive. We used a nested context to open a member
    of the archive. Not all files can be read this way. Members that are images, for
    example, can''t be read directly by Pillow; they must be extracted to a temporary
    file. We''d do something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上下文打开存档。我们使用嵌套上下文打开存档的一个成员。并不是所有文件都可以这样读取。例如，图像成员不能直接由 Pillow 读取；它们必须提取到临时文件中。我们会这样做：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will extract a member named `warship.png` from the archive and create a
    local file. Pillow can then work with the extracted file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从存档中提取一个名为 `warship.png` 的成员并创建一个本地文件。Pillow 可以处理提取的文件。
- en: Working with JSON files
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 JSON 文件一起工作
- en: 'A JSON file contains a Python object that''s been serialized in JSON notation.
    To work with JSON files, we need to import the `json` module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JSON 文件包含一个以 JSON 语法序列化的 Python 对象。要处理 JSON 文件，我们需要导入 `json` 模块：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The file processing context doesn''t really apply well to JSON files. We don''t
    generally have the file open for any extended time when processing it. Often,
    the `with` statement context is just one line of code. We might create a file
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 文件处理上下文并不真正适用于 JSON 文件。我们通常在处理文件时不会长时间打开文件。通常，`with` 语句上下文只是一行代码。我们可能会创建一个像这样的文件：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is all that''s required to create a JSON-encoded file. Often, we''ll contrive
    to make the object we''re serializing a list or a dict so that we can save multiple
    objects in a single file. To retrieve the object, we generally do something that''s
    similarly simple, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 JSON 编码文件只需要这些。通常，我们会设法将我们要序列化的对象变成一个列表或字典，这样我们就可以在单个文件中保存多个对象。要检索对象，我们通常做的是类似的事情，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will decode the object and save it in the given variable. If the file contains
    a list, we can iterate through the object to process each item in the list. If
    the file contains a dictionary, we might work with specific key values of this
    dictionary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解码对象并将其保存到指定的变量中。如果文件包含一个列表，我们可以遍历对象以处理列表中的每个项目。如果文件包含一个字典，我们可能会处理这个字典的特定键值。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The processing applied to the resulting object, `an_object`, is outside the
    context of the `with` statement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到结果对象 `an_object` 上的处理是在 `with` 语句之外进行的。
- en: Once the Python object has been created, we no longer need the file context.
    The resources associated with the file can be released, and we can focus our processing
    steps on the resulting object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Python对象，我们就不再需要文件上下文。与文件关联的资源可以被释放，我们可以将我们的处理步骤集中在结果对象上。
- en: Working with CSV files
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理CSV文件
- en: '**CSV** stands for **comma-separated values**. While one of the most common
    CSV formats uses the quote character and commas, the CSV idea is readily applicable
    to any file that has a column-separator character. We might have a file with each
    data item separated by tab characters, written as `\t` in Python. This is also
    a kind of CSV file that uses the tab character to fill the role of a comma.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSV**代表**逗号分隔值**。虽然最常见的CSV格式使用引号字符和逗号，但CSV的概念可以轻松应用于任何具有列分隔符字符的文件。我们可能有一个文件，每个数据项由制表符字符分隔，在Python中写作`\t`。这也是一种使用制表符字符充当逗号角色的CSV文件。'
- en: 'We''ll use the `csv` module to process these files:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`csv`模块来处理这些文件：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we open a CSV file, we must create a *reader* or *writer* that parses the
    various rows of data in the file. Let's say we downloaded the historical record
    of bitcoin prices. You can download this data from [https://coinbase.com/api/doc/1.0/prices/historical.html](https://coinbase.com/api/doc/1.0/prices/historical.html).
    See [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring
    Intelligence Data*, for more information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开CSV文件时，我们必须创建一个*读取器*或*写入器*来解析文件中的各种数据行。假设我们下载了比特币价格的历史记录。您可以从[https://coinbase.com/api/doc/1.0/prices/historical.html](https://coinbase.com/api/doc/1.0/prices/historical.html)下载这些数据。有关更多信息，请参阅[第2章](ch02.html
    "第2章。获取情报数据")，“获取情报数据”。
- en: 'The data is in the CSV notation. Once we''ve read the string, we need to create
    a CSV reader around the data. As the data was just read into a big string variable,
    we don''t need to use the filesystem. We can use in-memory processing to create
    a file-like object, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数据使用CSV格式表示。一旦我们读取了字符串，就需要在数据周围创建一个CSV读取器。由于数据刚刚被读入一个大字符串变量中，我们不需要使用文件系统。我们可以使用内存处理来创建一个类似文件的对象，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've used the `urllib.request.urlopen()` function to make a `GET` request to
    the given URL. The response will be in bytes. We decoded the characters from these
    bytes and saved them in a variable named `history_data`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`urllib.request.urlopen()`函数向给定的URL发起一个`GET`请求。响应将以字节形式返回。我们将从这些字节中解码字符并将它们保存在名为`history_data`的变量中。
- en: In order to make this amenable to the `csv.Reader` class, we used the `io.StringIO`
    class to wrap the data. This creates a file-like object without actually wasting
    time to create a file on the disk somewhere.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`csv.Reader`类能够处理，我们使用了`io.StringIO`类来包装数据。这创建了一个类似文件的对象，而实际上并不需要在磁盘上的某个位置创建文件，从而节省了时间。
- en: 'We can now read individual rows from the `reader` object, as shown in the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像以下代码所示从`reader`对象中读取单个行。
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `for` loop will step through each row of the CSV file. The various columns
    of data will be separated; each row will be a tuple of individual column values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环将遍历CSV文件的每一行。数据的不同列将被分隔；每一行将是一个包含单个列值的元组。
- en: If we have *tab-separated* data, we'd modify the reader by providing additional
    details about the file format. We might, for example, use `rdr= csv.reader(some_file,
    delimiter='\t')` to specify that there are tab-separated values instead of comma-separated
    ones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有*制表符分隔*的数据，我们可以通过提供有关文件格式的额外详细信息来修改读取器。例如，我们可以使用`rdr= csv.reader(some_file,
    delimiter='\t')`来指定存在制表符分隔值而不是逗号分隔值。
- en: JPEG and PNG graphics – pixels and metadata
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPEG和PNG图形 – 像素和元数据
- en: An image is composed of picture elements called pixels. Each pixel is a dot.
    For computer displays, the individual dots are encoded using **red-green-blue**
    (**RGB**) colors. Each displayed pixel is a sum of the levels of red, green, and
    blue light. For printing, the colors might be switched to **cyan-magenta-yellow-key**
    (**CMYK**) colors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由称为像素的图像元素组成。每个像素是一个点。对于计算机显示器，单个点使用**红-绿-蓝**（**RGB**）颜色进行编码。每个显示的像素是红、绿和蓝光级别的总和。对于打印，颜色可能被切换到**青-品红-黄-黑**（**CMYK**）颜色。
- en: An image file contains an encoding of the various pixels of the image. The image
    file may also contain metadata about the image. The metadata information is sometimes
    called **tags** and even **Exif tags**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件包含图像各种像素的编码。图像文件也可能包含有关图像的元数据。元数据信息有时被称为**标签**，甚至**Exif标签**。
- en: An image file can use a variety of encodings for each pixel. A pure black and
    white image only needs 1 bit for each pixel. High-quality photographs may use
    one byte for each color, leading to 24 bits per pixel. In some cases, we might
    add a transparency mask or look for even higher-resolution color. This leads to
    four bytes per pixel.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件可以为每个像素使用各种编码。纯黑白图像只需要每个像素1位。高质量的摄影可能每个颜色使用1字节，导致每个像素24位。在某些情况下，我们可能会添加一个透明度蒙版或寻找更高分辨率的颜色。这导致每个像素4字节。
- en: The issue rapidly turns into a question of the amount of storage required. A
    picture that fills an iPhone display has 326 pixels per inch. The display has
    1136 by 640 pixels. If each pixel uses 4 bytes of color information, then the
    image involves 3 MB of memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 问题迅速转变为所需存储量的多少。充满iPhone显示屏的图片每英寸有326像素。显示屏有1136 x 640像素。如果每个像素使用4字节的颜色信息，那么图像将涉及3
    MB的内存。
- en: 'Consider a scanned image that''s of 8 1/2" by 11" at 326 pixels per inch The
    image is 2762 x 3586 pixels, a total of 39 MB. Some scanners are capable of producing
    images at 1200 pixels per inch: that file would be of 673 MB.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一张扫描图像，其尺寸为8 1/2英寸 x 11英寸，分辨率为每英寸326像素。该图像的像素为2762 x 3586，总大小为39 MB。一些扫描仪能够以每英寸1200像素的分辨率生成图像：这样的文件大小将是673
    MB。
- en: Different image files reflect different strategies to compress this immense
    amount of data without losing the quality of the image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的图像文件反映了不同的策略，在不丢失图像质量的情况下压缩如此大量的数据。
- en: A naive compression algorithm can make the files somewhat smaller. TIFF files,
    for example, use a fairly simple compression. The algorithms used by JPEG, however,
    are quite sophisticated and lead to relatively small file sizes while retaining
    much—but not all—of the original image. While JPEG is very good at compressing,
    the compressed image is not perfect—details are lost to achieve good compression.
    This makes JPEG weak for steganography where we'll be tweaking the bits to conceal
    a message in an image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的压缩算法可以使文件稍微小一些。例如，TIFF文件使用相当简单的压缩。然而，JPEG使用的算法相当复杂，在保持大部分（但不全部）原始图像的同时，导致相对较小的文件大小。虽然JPEG在压缩方面非常好，但压缩后的图像并不完美——为了实现良好的压缩，细节会丢失。这使得JPEG在隐写术中较弱，因为我们将在图像中调整位以隐藏消息。
- en: We can call JPEG compression lossy because some bits can be lost. We can call
    TIFF compression lossless because all the original bits can be recovered. Once
    bits are lost, they can't be recovered. As our message will only be tweaking a
    few bits, JPEG compression can corrupt our hidden message.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将JPEG压缩称为有损压缩，因为一些位可以丢失。我们可以将TIFF压缩称为无损压缩，因为所有原始位都可以恢复。一旦位丢失，它们就无法恢复。由于我们的消息将只调整几个位，JPEG压缩可能会破坏我们隐藏的消息。
- en: When we work with images in Pillow, it will be similar to working with a JSON
    file. We'll open and load the image. We can then process the object in our program.
    When we're done, we'll save the modified image.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Pillow中处理图像时，将类似于处理JSON文件。我们将打开和加载图像。然后我们可以在程序中处理该对象。完成后，我们将保存修改后的图像。
- en: Using the Pillow library
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pillow库
- en: We're going to add some cool Python software to process images. The Pillow package
    is a sophisticated image-processing library. This library provides extensive file
    format support, an efficient internal representation, and fairly powerful image
    processing capabilities. For more information, visit [https://pypi.python.org/pypi/Pillow/2.1.0](https://pypi.python.org/pypi/Pillow/2.1.0).
    The Pillow documentation will provide important background in what needs to be
    done. The installation guide on the PyPi web page is essential reading, you will
    get some additional details here. The core Pillow documentation is at [http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些酷炫的Python软件来处理图像。Pillow包是一个复杂的图像处理库。这个库提供了广泛的文件格式支持，高效的内部表示，以及相当强大的图像处理能力。更多信息，请访问[https://pypi.python.org/pypi/Pillow/2.1.0](https://pypi.python.org/pypi/Pillow/2.1.0)。Pillow文档将提供关于需要做什么的重要背景信息。PyPi网页上的安装指南是必读的，你将在这里获得一些额外的细节。Pillow的核心文档位于[http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/)。
- en: Note that Pillow will install a package named `PIL`. This assures that Pillow
    (the project) creates a module that's compatible with the **Python Imaging Library**
    (**PIL**). We'll be importing modules from the `PIL` package, even though we'll
    be installing software created by the Pillow project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Pillow将安装一个名为`PIL`的包。这确保了Pillow（项目）创建的模块与**Python Imaging Library**（**PIL**）兼容。我们将从`PIL`包导入模块，尽管我们将安装由Pillow项目创建的软件。
- en: Adding the required supporting libraries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加所需的辅助库
- en: If you're a Windows agent, then you can skip this section. The folks who build
    Pillow have you firmly in mind. For everyone else, your OS may not be Pillow ready.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 Windows 代理，那么你可以跳过这一部分。构建 Pillow 的人已经充分考虑了你的需求。对于其他人来说，你的操作系统可能还没有准备好
    Pillow。
- en: Before installing Pillow, some supporting software infrastructure must be in
    place. Once all the supporting software is ready, then Pillow can be installed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Pillow 之前，必须设置一些支持软件基础设施。一旦所有支持软件都准备就绪，然后才能安装 Pillow。
- en: GNU/Linux secrets
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GNU/Linux 秘籍
- en: 'We need to have the following libraries in our GNU/Linux configuration. Odds
    are good that these files are already present in a given distribution. If these
    files aren''t present, it''s time to perform some upgrades or installations. Install
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的 GNU/Linux 配置中拥有以下库。这些文件很可能已经存在于给定的发行版中。如果这些文件不存在，那么是时候进行一些升级或安装了。安装以下内容：
- en: '**libjpeg**: This library provides access to JPEG images; versions 6b, 8, and
    9 have been tested'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libjpeg**: 这个库提供了对 JPEG 图像的访问；已测试版本 6b、8 和 9'
- en: '**zlib**: This library provides access to compressed PNG images'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zlib**: 这个库提供了对压缩 PNG 图像的访问'
- en: '**libtiff**: This library provides access to TIFF images; versions 3.x and
    4.0 have been tested'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libtiff**: 这个库提供了对 TIFF 图像的访问；已测试版本 3.x 和 4.0'
- en: '**libfreetype**: This library provides type-related services'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libfreetype**: 这个库提供了与字体相关的服务'
- en: '**littlecms**: This library provides color management'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**littlecms**: 这个库提供了色彩管理'
- en: '**libwebp**: This library provides access to the WebP format'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libwebp**: 这个库提供了对 WebP 格式的访问'
- en: Each Linux distribution has a unique approach to installing and configuring
    the libraries. We can't cover them all.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Linux发行版都有独特的安装和配置库的方法。我们无法涵盖所有内容。
- en: Once the supporting libraries are in place, we can use the `easy_install-3.3
    pillow` command. We'll review this in the *Installing and confirming Pillow* section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦辅助库就绪，我们就可以使用 `easy_install-3.3 pillow` 命令。我们将在 *安装和确认 Pillow* 部分中回顾这一点。
- en: Mac OS X secrets
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS X 秘籍
- en: To install Pillow on a Mac, we require three preliminary steps to be performed.
    We'll need Xcode and homebrew, then we'll use homebrew.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac 上安装 Pillow，我们需要执行三个初步步骤。我们需要 Xcode 和 homebrew，然后我们将使用 homebrew。
- en: To get Xcode for Mac OS X, visit [https://developer.apple.com/xcode/downloads/](https://developer.apple.com/xcode/downloads/).
    Every Mac OS X agent should have Xcode, even if they're not going to write native
    Mac OS X or iOS apps.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Mac OS X 的 Xcode，请访问 [https://developer.apple.com/xcode/downloads/](https://developer.apple.com/xcode/downloads/)。每个
    Mac OS X 代理都应该有 Xcode，即使他们不打算编写本机 Mac OS X 或 iOS 应用程序。
- en: When installing Xcode, we must be sure that we also install the command-line
    developer tools. This is another big download above and beyond the basic XCode
    download.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Xcode 时，我们必须确保我们还安装了命令行开发者工具。这超出了基本 XCode 下载之外的另一个大型下载。
- en: Once we have Xcode command-line tools, the second preliminary step is to install
    Homebrew from [http://brew.sh](http://brew.sh). This application builds and installs
    GNU/Linux binaries for Mac OS X. Homebrew is not directly related to Python; this
    is a popular Mac OS X developer tool.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 Xcode 命令行工具，第二个初步步骤是从 [http://brew.sh](http://brew.sh) 安装 Homebrew。此应用程序为
    Mac OS X 构建和安装 GNU/Linux 二进制文件。Homebrew 与 Python 没有直接关系；这是一个流行的 Mac OS X 开发者工具。
- en: 'The Homebrew installation is a single line entered in the terminal window:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 的安装是在终端窗口中输入的单行命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will use the curl program to download the Homebrew installation kit from
    GitHub. It will use Ruby to run this installation program, building the various
    Homebrew tools and scripts. The Homebrew installation suggests using `brew doctor`
    to check the development environment. There may be some cleanup to do before proceeding.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 curl 程序从 GitHub 下载 Homebrew 安装套件。它将使用 Ruby 运行此安装程序，构建各种 Homebrew 工具和脚本。Homebrew
    安装建议使用 `brew doctor` 来检查开发环境。在继续之前可能需要进行一些清理工作。
- en: 'The third step is to use the `brew` program to install the required additional
    libraries for Pillow. This command line will handle that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是使用 `brew` 程序安装 Pillow 所需的附加库。该命令行将处理此事：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Periodically, we may need to upgrade the libraries Homebrew knows about. The
    command is simply `brew update`. We may also need to upgrade the various packages
    we installed. This is done using `brew upgrade libtiff libjpeg webp littlecms`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定期，我们可能需要升级 Homebrew 所知的库。命令很简单：`brew update`。我们可能还需要升级我们安装的各种包。这是使用 `brew upgrade
    libtiff libjpeg webp littlecms` 完成的。
- en: When we've finished the three preliminary steps, we can use the `easy_install-3.3
    pillow` command. We'll review this in the *Installing and confirming pillow* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这三个初步步骤后，我们可以使用`easy_install-3.3 pillow`命令。我们将在*安装和确认Pillow*部分进行回顾。
- en: Windows secrets
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows秘籍
- en: 'The Pillow distribution for Windows contains all the various libraries prebuilt.
    The kit will have the following already installed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow的Windows版本包含所有各种预先构建的库。套件将已经安装以下内容：
- en: '**libjpeg**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libjpeg**'
- en: '**zlib**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zlib**'
- en: '**libtiff**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libtiff**'
- en: '**libfreetype**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libfreetype**'
- en: '**littlecms**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**littlecms**'
- en: '**libwebp**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libwebp**'
- en: After the installation is complete, these modules will all be present and used
    by Pillow.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，这些模块都将存在并被Pillow使用。
- en: Installing and confirming Pillow
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和确认Pillow
- en: Once all the required supporting tools are in place (or you're a Windows agent),
    the next step is to install Pillow.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有必需的支持工具都已就绪（或者你是Windows代理），下一步就是安装Pillow。
- en: 'This should amount to the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对应以下命令：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Windows agents must omit the `sudo` command that prefixes the `easy_install`
    command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Windows代理必须省略`easy_install`命令前的`sudo`命令。
- en: 'Part of the output will look something like this (details will vary):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的一部分可能看起来像这样（具体细节会有所不同）：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells us that some libraries were not available, and we can't do every
    kind of processing. If we don't intend to work with JPEG2000 files or do complex
    color management, this is acceptable. On the other hand, if we think we're going
    to do more complex processing, we may need to track down additional modules and
    redo our Pillow installation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们一些库不可用，我们无法进行所有类型的处理。如果我们不打算处理JPEG2000文件或进行复杂色彩管理，这是可以接受的。另一方面，如果我们认为我们将进行更复杂的处理，我们可能需要追踪额外的模块并重新安装Pillow。
- en: The Pillow installation creates PIL. The top-level package will be named `PIL`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow的安装创建了PIL。顶级包将被命名为`PIL`。
- en: 'We can test Pillow using it''s own internal test script, `PIL.selftest`. Otherwise,
    we can use it like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Pillow自己的内部测试脚本`PIL.selftest`来测试Pillow。否则，我们可以这样使用它：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this works, then the PIL package is installed. We can then open an image
    file to see whether things are working properly. The following code shows us that
    PIL happily opened an image file for us:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这行得通，那么PIL包已经安装。然后我们可以打开一个图片文件来查看是否一切正常。以下代码显示PIL愉快地为我们打开了一个图片文件：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This shows us that PIL was able to save the file in a different format:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明PIL能够以不同的格式保存文件：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This simple-looking step requires Pillow do a tremendous amount of computation
    to convert from one format to another.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似简单的步骤需要Pillow进行大量的计算以将一种格式转换为另一种格式。
- en: Decoding and encoding image data
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码和编码图像数据
- en: 'Image files are encoded in a form that makes them handy for reading and writing,
    but not so useful for detailed processing. We''ll need to decode an image from
    the file format to a useful internal representation. Pillow greatly simplifies
    the processes of decoding and encoding image files. Our general strategy for working
    with an image file is to start with the following recipe:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图片文件以一种便于读取和写入的形式编码，但并不适用于详细处理。我们需要将图片从文件格式解码为有用的内部表示。Pillow大大简化了解码和编码图片文件的过程。我们处理图片文件的一般策略是以下步骤：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pillow extracts a number of interesting attributes from the image metadata.
    There's a complex hierarchy of additional information that comes along with the
    image. We'll review some of this metadata in detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow从图片元数据中提取了许多有趣的属性。与图片一起还有复杂的信息层次结构。我们将详细回顾一些这些元数据。
- en: 'At the top level, there are some pieces of information that describe some details
    of the encoding. These are available in a dictionary that is the `info` attribute
    of the `pix` object we created. We can use the `keys()` method of a dictionary
    to see what''s present in the metadata, as shown in the following snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别，有一些描述编码细节的信息。这些信息在`pix`对象的`info`属性中可用。我们可以使用字典的`keys()`方法查看元数据中有什么，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of these keys, the value mapped to the `exif` key is often the most interesting.
    This is the exchangeable image file format data that provides additional details
    about the image. The other items are technical details about the image encoding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些键中，映射到`exif`键的值通常是最有趣的。这是提供关于图片额外详细信息的可交换图像文件格式数据。其他项是关于图片编码的技术细节。
- en: 'The Exif data isn''t automatically decoded by Pillow. We need to use the `_getexif()`
    method to see what''s in the `exif` key for the image. Note the leading `_` sign
    to this name. This is atypical. This method will give us a dictionary of tags
    and values. Here''s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Exif 数据不是由 Pillow 自动解码的。我们需要使用 `_getexif()` 方法来查看图像的 `exif` 键中有什么。注意这个名称前有一个下划线
    `_` 符号。这是不寻常的。这个方法会给我们一个标签和值的字典。以下是一个例子：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This doesn''t look too useful. The good news is that the numeric codes are
    defined in a separate module. We can use a dictionary lookup to translate numeric
    codes to words. Here''s an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太有用。好消息是，这些数字代码定义在单独的模块中。我们可以使用字典查找将数字代码转换为文字。以下是一个例子：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will iterate through the Exif tags and values, translating the tag values
    to words. Now we can find the useful identifying information about the image.
    The output shows us details like these:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历 Exif 标签和值，将标签值转换为文字。现在我们可以找到关于图像的有用识别信息。输出显示了如下细节：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of these Exif tags, the number `34853`, the `GPSInfo` tag form a subdictionary
    with yet more cryptic numeric keys. This secondary set of numeric codes are defined
    by the `PIL.ExifTags.GPSTAGS` mapping.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些 Exif 标签中，数字 `34853`，`GPSInfo` 标签形成了一个包含更多神秘数字键的子字典。这组数字代码由 `PIL.ExifTags.GPSTAGS`
    映射定义。
- en: 'This leads us to something like the following to dump the information for an
    image:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们进行如下操作，以输出图像的信息：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will iterate through the top-level `.info` dictionary associated with the
    image. Within this top-level `.info` dictionary, if the key is `exif`, we'll iterate
    through the `Exif` dictionary items. Within the `Exif` dictionary, we'll translate
    the numeric keys to meaningful strings. If we find the key, `34853` (`GPSInfo`),
    we know that we have another dictionary that is more deeply nested. We'll use
    another nested `for` loop to iterate through the items of the `GPSInfo` dictionary,
    translating those keys to useful strings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历与图像关联的顶层 `.info` 字典。在这个顶层 `.info` 字典中，如果键是 `exif`，我们将遍历 `Exif` 字典项。在 `Exif`
    字典中，我们将数字键转换为有意义的字符串。如果我们找到键 `34853` (`GPSInfo`)，我们知道我们有一个更深嵌套的另一个字典。我们将使用另一个嵌套的
    `for` 循环来遍历 `GPSInfo` 字典的项，将这些键转换为有用的字符串。
- en: We might see this kind of output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会看到这样的输出。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this output, the Exif data isn't too interesting. The other details don't
    seem useful either.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，Exif 数据并不太有趣。其他细节似乎也没有什么用处。
- en: 'When we look at a picture that''s richly detailed with metadata, there might
    be over 30 individual pieces of Exif data. For example, here''s a section of some
    Exif data found in one image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看一个详细且包含元数据的图片时，可能会有超过 30 个单独的 Exif 数据。例如，这是在一幅图像中找到的一些 Exif 数据的部分：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This can tell someone a lot about how the picture was taken.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以告诉某人很多关于照片是如何拍摄的。
- en: 'When we have pictures taken with modern cameras (such as phone cameras) with
    GPS data, some additional information is packed into the Exif. For some cameras,
    we''ll find this kind of information as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用带有 GPS 数据的现代相机（如手机相机）拍摄照片时，一些额外的信息会被打包到 Exif 中。对于某些相机，我们会找到如下这类信息：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The GPS coordinates from the camera are a little odd looking. We can turn each
    of these tuple-of-tuples structures into numbers such as 36°50′40.12″N and 76°17′35.21″W.
    Once we have the location, we can figure out where the picture was taken.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的 GPS 坐标看起来有点奇怪。我们可以将这些元组结构转换为数字，例如 36°50′40.12″N 和 76°17′35.21″W。一旦我们有了位置，我们就可以确定照片是在哪里拍摄的。
- en: A quick check on the nautical chart 12253 shows that the picture was taken from
    a dock in Norfolk, Virginia. *Every secret agent has a set of nautical charts,
    right? If not, visit* [http://www.nauticalcharts.noaa.gov/mcd/Raster/](http://www.nauticalcharts.noaa.gov/mcd/Raster/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在海图 12253 上快速查看显示，照片是在弗吉尼亚州诺福克的一个码头拍摄的。*每个间谍都有一套海图，对吧？如果没有，请访问* [http://www.nauticalcharts.noaa.gov/mcd/Raster/](http://www.nauticalcharts.noaa.gov/mcd/Raster/)。
- en: The ICC profile shows the details of color and rendering for the image. For
    details on the data encoded here, see the applicable specifications from [http://www.color.org/specification/ICC1v43_2010-12.pdf](http://www.color.org/specification/ICC1v43_2010-12.pdf).
    It's not clear that this information is very helpful for what we're doing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ICC 配置文件显示了图像的颜色和渲染细节。关于这里编码的数据的详细信息，请参阅 [http://www.color.org/specification/ICC1v43_2010-12.pdf](http://www.color.org/specification/ICC1v43_2010-12.pdf)
    中的适用规范。这些信息对我们所做的事情是否有帮助并不明确。
- en: What's more helpful is looking at the picture. LHD 3 painted on the hull seems
    to be important.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更有帮助的是查看图片。涂在船体上的LHD 3似乎很重要。
- en: Manipulating images – resizing and thumbnails
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作图像 – 调整大小和缩略图
- en: The Pillow software allows us to perform a number of manipulations on the image.
    We can, without too much additional work, resize, crop, rotate, or apply any number
    of filters to an image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow软件允许我们对图像执行多种操作。我们可以在不进行太多额外工作的前提下，调整大小、裁剪、旋转或对图像应用任何数量的过滤器。
- en: The most important reason for using PIL is that we have a reproducible, automated
    process. We can find many kinds of manual image manipulation software. The problem
    with these desktop tools is that a manual sequence of steps is irreproducible.
    The benefit of using Pillow for this manipulation is we know precisely what we
    did.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PIL的最重要原因是，我们有一个可重复的、自动化的过程。我们可以找到许多种类的手动图像处理软件。这些桌面工具的问题在于，一系列的手动步骤是不可重复的。使用Pillow进行此操作的好处是我们确切地知道我们做了什么。
- en: 'One common resizing is to create a thumbnail image from a larger image. Here''s
    how we can create useful thumbnail versions of a collection of images:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的调整大小是创建一个从较大图像中生成的缩略图图像。以下是我们可以创建一组图像的有用缩略图版本的方法：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ve imported the modules we need: `PIL.Image`, `glob` and `os`. We used
    `glob.glob("*.jpg")` to locate all of the JPEG files in the current working directory.
    We used `os.path.splitext()` to tease apart the base filename and extension. If
    the filename already ends in `_thumb`, we''ll continue the `for` loop. No more
    processing will happen for this filename; the `for` statement will advance to
    the next item in the glob sequence.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了所需的模块：`PIL.Image`、`glob`和`os`。我们使用`glob.glob("*.jpg")`在当前工作目录中定位所有JPEG文件。我们使用`os.path.splitext()`将基本文件名和扩展名分开。如果文件名已经以`_thumb`结尾，我们将继续`for`循环。对于此文件名将不再进行任何处理；`for`语句将前进到glob序列中的下一个项目。
- en: We opened the image file and immediately created a copy. This allows us to work
    with the original image, if we need to, as well as work with the copy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了图像文件，并立即创建了一个副本。这允许我们在需要时使用原始图像，同时也可以使用副本。
- en: We've extracted the size of the original image and assigned each item of the
    tuples to two separate variables, `w` and `h`. We picked the largest of the two
    dimensions using the `max()` function. If the picture was in the landscape mode,
    the width will be largest; if the picture was in the portrait mode, the height
    will be largest.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提取了原始图像的大小，并将元组中的每个项分配给两个单独的变量，`w`和`h`。我们使用`max()`函数选择了两个维度中较大的一个。如果图片是横向模式，宽度将是最大的；如果图片是纵向模式，高度将是最大的。
- en: We've computed the size of the thumbnail image, `w_t` and `h_t`. The pair of
    calculations will assure that the largest dimension is limited to 128 pixels and
    the smaller dimension will be scaled proportionally.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计算了缩略图图像的大小，`w_t`和`h_t`。这对计算将确保最大尺寸限制在128像素，较小的一维将按比例缩放。
- en: We used the `thumbnail()` method of the `thumb` object, which is a copy of the
    original image. We provided a two-tuple with the new dimensions. It's essential
    that we include `()` around `(w_n, h_n)` to create a tuple for the first argument
    value to the `thumbnail()` method. We also provided the resample function to use;
    in this case, we used the `PIL.Image.ANTIALIAS` function, as this produces good
    (but slow) results.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`thumb`对象的`thumbnail()`方法，它是原始图片的一个副本。我们提供了一个包含新尺寸的两个元组。确保在`(w_n, h_n)`周围包含`()`以创建一个元组，作为`thumbnail()`方法的第一个参数值。我们还提供了要使用的重采样函数；在这种情况下，我们使用了`PIL.Image.ANTIALIAS`函数，因为它产生良好的（但较慢的）结果。
- en: 'Here''s the thumbnail of our LHD warship:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的LHD战舰的缩略图：
- en: '![Manipulating images – resizing and thumbnails](img/0420OS_03_01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![操作图像 – 调整大小和缩略图](img/0420OS_03_01.jpg)'
- en: The image is pretty small. This makes it good for attaching it to an e-mail.
    However, for more serious intelligence work, we'll need to blow it up, crop it,
    and enhance it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片相当小。这使得它非常适合附加到电子邮件中。然而，对于更严肃的情报工作，我们需要将其放大、裁剪和增强。
- en: Manipulating images – cropping
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作图像 – 裁剪
- en: When we look at our LHD warship image, we notice that the ship number is almost
    visible on the bow. We'd like to crop that portion of the image and perhaps, blow
    it up. Cropping without a visual editor involves a certain amount of hit-or-miss
    processing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的LHD战舰图像时，我们注意到船号几乎在船首可见。我们希望裁剪图像的这一部分，也许还可以将其放大。没有视觉编辑器的裁剪涉及一定程度的试错处理。
- en: 'Even from the command line, we can crop an image interactively by using the
    `show()` method of an image, as shown in the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是从命令行，我们也可以通过使用图像的 `show()` 方法交互式地裁剪图像，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can try different bounding boxes until we locate the logo. One way to start
    is to break the image into thirds in each direction; this leads to nine sections,
    computed via relatively simple rules as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试不同的边界框，直到找到标志。一种开始的方法是将图像在每个方向上分成三部分；这导致九个部分，通过以下相对简单的规则计算得出：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The bounding box for a crop operation requires a four-tuple with the left, top,
    right, and bottom sides, in that order. The values must be integers and the `()`
    brackets are required to create four-tuple, instead of four separate argument
    values. The horizontal dividing lines are at `0`, `w//3`, `2*w//3`, and `w`. The
    vertical dividing lines are at `0`, `h//3`, `2*h//3`, and `h`. We can use various
    combinations to locate the various sections of the image and show each section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪操作的边界框需要一个包含左、上、右和下四个边的四个元组，顺序依次为。这些值必须是整数，并且需要使用 `()` 括号来创建四个元组，而不是四个单独的参数值。水平分隔线在
    `0`、`w//3`、`2*w//3` 和 `w`。垂直分隔线在 `0`、`h//3`、`2*h//3` 和 `h`。我们可以使用各种组合来定位图像的各个部分并显示每个部分。
- en: 'Entering formulae like this is error prone. It''s much nicer to work with a
    bounding box defined by a top-left coordinate pair. We can fiddle in a width and
    compute the height to maintain the picture''s proportions. If we use something
    like the following, we only have to tweak the *x* and *y* coordinates:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这样的公式容易出错。使用由一对左上角坐标定义的边界框会更好。我们可以调整宽度和计算高度以保持图片的比例。如果我们使用以下方法，我们只需要调整 *x*
    和 *y* 坐标：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can fiddle with the `x` and `y` values. Then we can use the up arrow key
    to fetch the `ship.crop().show()` line back again. This allows us to step through
    the image manually, just changing `x` and `y`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整 `x` 和 `y` 的值。然后我们可以使用上箭头键再次获取 `ship.crop().show()` 行。这允许我们手动遍历图像，只需更改
    `x` 和 `y`。
- en: 'We can do a little better at generalizing the bounding boxes of image sections.
    Consider this list of fractions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更好地泛化图像部分的边界框。考虑以下分数列表：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have defined the number of slices we want to make. In this case, we''ll
    divide the image into 1/6, giving us 36 individual boxes. We then computed the
    `slice+1` lines at positions between ![Manipulating images – cropping](img/0420OS_03_13.jpg)
    and ![Manipulating images – cropping](img/0420OS_03_14.jpg). Here is an illustration
    that shows the slicing of the image into a 6 x 6 grid. Each cell has a boundary
    defined by the `box` sequence:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们想要制作的切片数量。在这种情况下，我们将图像分成 1/6，得到 36 个独立的框。然后我们在 ![操作图像 – 裁剪](img/0420OS_03_13.jpg)
    和 ![操作图像 – 裁剪](img/0420OS_03_14.jpg) 之间的位置计算了 `slice+1` 条线。这里有一个说明图像被切割成 6x6 网格的插图。每个单元格都有一个由
    `box` 序列定义的边界：
- en: '![Manipulating images – cropping](img/0420OS_03_06.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![操作图像 – 裁剪](img/0420OS_03_06.jpg)'
- en: 'This uses the following pair of nested `for` loops with the `box` fractions
    to generate the individual boundaries for various pieces of the image:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用以下成对的嵌套 `for` 循环和 `box` 分数来生成图像各个部分的单独边界：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each boundary box has the left, top, right, and bottom side as a four-tuple.
    We've picked values of two variables to enumerate all 36 combinations from (0,0)
    to (5,5). We've picked two adjacent values from our list of fractions, `lines`.
    This will give us all 36 bounding boxes from top-left to bottom-right.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界框都有左、上、右和下四个边作为四个元组。我们选取了两个变量的值来枚举从 (0,0) 到 (5,5) 的所有 36 种组合。我们从分数列表 `lines`
    中选取了相邻的两个值。这将给我们从左上角到右下角的所有 36 个边界框。
- en: We can then crop our original image using each of these definitions of box and
    show all 36 slices, looking for the one that's closest to the subject matter we're
    looking for. Also, we might want to resize each image and make it twice as big.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这些定义的框裁剪我们的原始图像，并显示所有 36 个切片，寻找最接近我们寻找的主题内容的切片。此外，我们可能还想调整每个图像的大小，使其变为原来的两倍。
- en: 'We can use the following to show each box:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法来显示每个框：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will display the original image cropped to each of the slices. The `bounds`
    object is a four-tuple with the boundary information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示裁剪到每个切片的原始图像。`bounds` 对象是一个包含边界信息的四个元组。
- en: 'We can slightly optimize the expression that computes the bounds using the
    `map()` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `map()` 函数稍微优化计算边界的表达式：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `map()` function will apply a function to each element of the associated
    collection. In this example, we apply the `int()` function to each value of the
    bounding box. It turns out that this is the image we want:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数将一个函数应用到相关集合的每个元素上。在这个例子中，我们将 `int()` 函数应用到边界框的每个值上。结果证明这正是我们想要的图片：'
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We've cropped the image using two adjacent boxes. The boxes at (3,6) and (4,6)
    incorporate the ship's identification number nicely. We created a single four-tuple
    with the combined bounding box and cropped the original image to pick up just
    the logo. We used the `show()` method of the `logo` object, which will pop up
    an image viewer. We also saved it so that we'd have a file we could work with
    later.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个相邻的框裁剪了图片。位于 (3,6) 和 (4,6) 的框很好地包含了船的识别号。我们创建了一个包含组合边界框的单个四元组，并将原始图片裁剪以仅获取标志。我们使用了
    `logo` 对象的 `show()` 方法，这将弹出一个图片查看器。我们还保存了它，以便我们稍后可以工作。
- en: 'We might want to resize the cropped image. We can use code like this to blow
    up the image:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要调整裁剪图片的大小。我们可以使用如下代码放大图片：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will use the original size as a basis so that the expanded image retains
    the original proportions. As with other operations, the size is given as a tuple
    and the inner `()` brackets are required to define a tuple. Without the inner
    `()` brackets, these would be two separate argument values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用原始大小作为基础，以便扩展的图片保留原始比例。与其他操作一样，大小以元组的形式给出，并且需要使用内层的 `()` 括号来定义元组。如果没有内层的
    `()` 括号，这些将视为两个单独的参数值。
- en: 'Here''s the cropped image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是裁剪后的图片：
- en: '![Manipulating images – cropping](img/0420OS_03_02.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![操作图片 – 裁剪](img/0420OS_03_02.jpg)'
- en: That's kind of murky and hard to work with. We'll need to enhance it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点模糊，难以处理。我们需要增强它。
- en: Manipulating images – enhancing
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作图片 – 增强
- en: The original picture is pretty grainy. We'd like to enhance the details of the
    slice we found. Pillow has a number of filters than can help modify an image.
    Unlike popular TV shows and movies, there's no enhance feature that magically
    makes a poor image spectacular.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图片相当粗糙。我们希望增强我们找到的切片的细节。Pillow 有许多过滤器可以帮助修改图片。与流行的电视节目和电影不同，没有增强功能可以神奇地使糟糕的图片变得精彩。
- en: We can modify an image, and sometimes, it's more usable. We can also modify
    an image and leave it no better than we found it. The third choice—not often available
    to secret agents—is that we might make the results more artistic than the original
    image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改图片，有时，它变得更易用。我们也可以修改图片，使其不如我们找到它时那样好。第三种选择——通常不会提供给特工——是我们可能会使结果比原始图片更有艺术性。
- en: 'We have three modules in the Pillow package that contain filter-like processing:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pillow 包中，我们有三个包含类似过滤处理的模块：
- en: '`ImageEnhance`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageEnhance`'
- en: '`ImageFilter`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageFilter`'
- en: '`ImageOps`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageOps`'
- en: The `ImageEnhance` module contains `enhance` class definitions. We create an
    enhancer object by binding an enhancer and an image. We then use that bound object
    to create enhanced versions of a given image. An enhancer allows us to make many
    incremental changes to an image. We can think of these as simple knobs, which
    might be turned to tweak the image.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageEnhance` 模块包含 `enhance` 类定义。我们通过绑定一个增强器和一张图片来创建一个增强器对象。然后我们使用这个绑定对象来创建给定图片的增强版本。增强器允许我们对图片进行许多增量更改。我们可以将这些视为简单的旋钮，可以转动来调整图片。'
- en: The `ImageFilter` module contains filters functions that will revise the image,
    creating a new image object that we might save. These various kinds of filter
    objects are plugged into the image's `filter()` method. A filter can be imagined
    as a way to reduce the volume of information in the image; the image is usually
    simpler after being filtered.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageFilter` 模块包含将修改图片的过滤器函数，这将创建一个新图片对象，我们可能需要保存。这些不同类型的过滤器对象被插入到图片的 `filter()`
    方法中。过滤器可以想象成一种减少图片信息量的方式；过滤后的图片通常更简单。'
- en: The `ImageOps` module contains functions that transform one image to create
    a new image. These are different from filtering and enhancing. They're not necessarily
    reducing the data nor are they simple knobs to tweak an image. The `ImageOps`
    module tends to perform more complex transformations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageOps` 模块包含将一个图片转换成新图片的函数。这些与过滤和增强不同。它们不一定减少数据量，也不是简单的旋钮来调整图片。`ImageOps`
    模块倾向于执行更复杂的转换。'
- en: We'll start out with some simple enhancers in the `PIL.ImageEnhance` module,
    specifically, the `Contrast` class. We won't present each individual class; the
    more systematic exploration is for field agents.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`PIL.ImageEnhance`模块中的简单增强器开始，特别是`Contrast`类。我们不会展示每个单独的类；更系统的探索留给现场特工。
- en: 'We''ll start with one of the four enhancers: the `Contrast` class. Here''s
    how we can use it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从四个增强器中的一个开始：`Contrast`类。下面是如何使用它的方法：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This builds an enhancer, based on the specific algorithm and the image we're
    working with. We've assigned this enhancer to the `e` variable. We then performed
    an `enhance` operation with a specific parameter value and showed the resulting
    image.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于特定的算法和我们要处理的图像构建了一个增强器。我们将这个增强器分配给了`e`变量。然后我们执行了一个带有特定参数值的`enhance`操作，并显示了结果图像。
- en: The last image is pretty nice. We can save a copy of this image with `e.enhance(8.0).save(
    "LHD_Number_1.jpg" )`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一张图像相当不错。我们可以使用`e.enhance(8.0).save( "LHD_Number_1.jpg" )`来保存这张图像的副本。
- en: 'Here''s how the logo looks with the `Contrast` enhancement set to `8`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当`Contrast`增强设置为`8`时标志的看起来：
- en: '![Manipulating images – enhancing](img/0420OS_03_03.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图像处理 – 增强](img/0420OS_03_03.jpg)'
- en: 'Someone might be able to work with this image. As a field agent, you''ll need
    to experiment with the other three enhancement filters: color, brightness, and
    sharpness. You might be able to extract even more detail from the image.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人能够处理这张图像。作为一名现场特工，你需要尝试其他三个增强过滤器：颜色、亮度和锐度。你可能会从图像中提取更多细节。
- en: This is the first step in defining a reproducible, automated process. Using
    Python from the command line means that we have a record of precisely what we
    did. We can reduce the process to an automated script.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义可重复、自动化过程的第一步。使用Python命令行意味着我们记录了确切的操作。我们可以将这个过程简化为一个自动化脚本。
- en: Manipulating images – filtering
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像处理 – 过滤
- en: We've looked at the `ImageEnhance` module to improve an image. We can also filter
    via the image's `filter()` method. The `ImageFilter` module defines 18 different
    filters. When we use a filter, we'll provide the filter object to the `Image.filter()`
    method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看`ImageEnhance`模块来改善图像。我们也可以通过图像的`filter()`方法进行过滤。`ImageFilter`模块定义了18种不同的过滤器。当我们使用过滤器时，我们将过滤器对象提供给`Image.filter()`方法。
- en: We'll pick just one of these filters. The `ImageFilter.EDGE_ENHANCE` module
    seems to be helpful for distinguishing between the light-colored letter and the
    dark-colored background. Emphasizing on the transition in color might make the
    letters more visible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只选择这些过滤器中的一个。`ImageFilter.EDGE_ENHANCE`模块似乎有助于区分浅色字母和深色背景。强调颜色过渡可能会使字母更明显。
- en: 'Here''s an example of using the `ImageFilter.EDGE_ENHANCE` filter in the `filter()`
    method of an image:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在图像的`filter()`方法中使用`ImageFilter.EDGE_ENHANCE`过滤器的例子：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've used the `filter` method to create and show a new image.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`filter`方法创建并显示了一个新的图像。
- en: While this is good, it seems like our enhancement attempts might work better
    with the `ImageEnhance.Contrast` class we used earlier. Here's how we can apply
    a sequence of transformations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样很好，但似乎我们之前的增强尝试使用`ImageEnhance.Contrast`类效果会更好。下面我们来看看如何应用一系列的转换。
- en: 'The following code applies the specific filter to the image and creates a new
    image:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将特定的过滤器应用于图像并创建了一个新的图像：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We've created an enhanced image and then applied a filter to it. This creates
    something even more crisp and possibly more usable than the original image.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个增强图像，然后对其应用了一个过滤器。这创建了一个比原始图像更清晰、可能更实用的图像。
- en: 'This is our filtered and enhanced image:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们过滤和增强后的图像：
- en: '![Manipulating images – filtering](img/0420OS_03_04.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图像处理 – 过滤](img/0420OS_03_04.jpg)'
- en: The filter has made some minor changes to the previously saved image. The edge
    on the lower loop of `3` might be a bit more crisp. We'll need to change some
    more things.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器对之前保存的图像做了一些细微的修改。数字`3`下方的环边缘可能更加清晰。我们还需要做一些其他改变。
- en: Some filters (such as the `EDGE_ENHANCE` object) have no parameters or options.
    Other filters have parameters that can be applied to change the way they work.
    For example, the `ModeFilter()` will reduce a given section of the image to the
    most common color value within that section; we provide a parameter for the number
    of pixels to consider when computing the mode.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一些过滤器（如`EDGE_ENHANCE`对象）没有参数或选项。其他过滤器有参数，可以应用于改变它们的工作方式。例如，`ModeFilter()`将图像的某个部分减少到该部分中最常见的颜色值；我们提供了一个参数来指定在计算模式时考虑的像素数。
- en: 'Here''s an example of combining several operations to create a new image:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将几个操作组合起来创建新图像的例子：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This seems to be tending towards art and away from proper intelligence gathering.
    However, a good field agent will work with some additional filters and filter
    parameters to look for better enhancement techniques.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎正趋向于艺术，而不是正当的情报收集。然而，一个好的现场特工会使用一些额外的过滤器和过滤参数来寻找更好的增强技术。
- en: Manipulating images – ImageOps
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像操作 – 图像处理
- en: We've looked at the `ImageEnhance` module to improve an image. We've also looked
    at a few other filters in the `ImageFilter` module. The `ImageOps` module provides
    13 additional transformations that we can use to improve our image.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了`ImageEnhance`模块来改善图像。我们还研究了`ImageFilter`模块中的几个其他过滤器。`ImageOps`模块提供了13种额外的转换，我们可以使用这些转换来改善我们的图像。
- en: We'll look at the `ImageOps.autocontrast()` function, as shown in the following
    snippet. This will adjust the various pixels so that the brightness levels fill
    the entire 8-bit space from 0 to 255\. An image that's dark or washed out lacks
    contrast, and the pixels are all piled up at the dark end or the bright end of
    the spectrum.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看以下代码片段中的`ImageOps.autocontrast()`函数。这将调整各种像素，使亮度级别填满从0到255的整个8位空间。一个暗或褪色的图像缺乏对比度，像素都堆积在光谱的暗端或亮端。
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This shows an image with `autocontrast` applied and the original image. This
    shows the striking difference between the original clipping and an image that
    uses the full range from dark to light. That seems to be just what HQ would want.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了应用了`autocontrast`的图像和原始图像。这显示了原始裁剪和使用了从暗到亮的全范围的图像之间的显著差异。这似乎正是HQ所想要的。
- en: 'Let''s tweak the contrast a little further to really make the numbers stand
    out:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步调整对比度，使数字更加突出：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This seems to be the most startling enhancement we can do:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是我们能做的最惊人的增强：
- en: '![Manipulating images – ImageOps](img/0420OS_03_05.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图像操作 – 图像处理](img/0420OS_03_05.jpg)'
- en: This might be good enough. A competent field agent should play with the rest
    of the `ImageOps` transformations to see whether more improvement is possible.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能已经足够好了。一个合格的现场特工应该尝试其他`ImageOps`转换，看看是否还有改进的空间。
- en: At this point, we have the outline for a reproducible, automated process. We
    know precisely what we did to enhance the image. We can use our series of experiments
    to create an automated script for image enhancement.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一个可重复的、自动化的流程概要。我们确切地知道我们做了什么来增强图像。我们可以使用我们的实验系列来创建一个图像增强的自动化脚本。
- en: Some approaches to steganography
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐写术的一些方法
- en: There are many more things we can do with image files. One thing we can do is
    use steganography to conceal messages inside image files. As image files are large,
    complex, and relatively noisy, adding a few extra bits of data won't make much
    of a visible change to the image or the file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用图像文件做很多事情。我们可以做的一件事是使用隐写术在图像文件中隐藏信息。由于图像文件大、复杂且相对嘈杂，添加一些额外的数据位不会对图像或文件造成太大的可见变化。
- en: Sometimes this is summarized as adding a **digital watermark** to an image.
    We're going to subtly alter the image in a way that we can recognize and recover
    it later.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这可以总结为在图像上添加一个**数字水印**。我们将微妙地改变图像，以便我们可以在以后识别和恢复它。
- en: Adding a message can be seen as a lossy modification to the image. Some of the
    original pixels will be unrecoverable. As the JPEG compression, in general, already
    involves minor losses, tweaking the image as part of steganography will be a similar
    level of image corruption.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中添加信息可以被视为对图像的损失性修改。一些原始像素将无法恢复。由于JPEG压缩通常已经涉及轻微的损失，将图像作为隐写术的一部分进行调整将导致类似程度的图像损坏。
- en: Speaking of losses, the JPEG format can, and will, tweak some of the bits in
    our image. Consequently, it's difficult to perform steganography with JPEG. Rather
    than wrestle with JPEG details, we'll use the TIFF format for our concealed messages.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 说到损失，JPEG格式可以，并且将会调整我们图像中的一些位。因此，使用JPEG进行隐写术很困难。我们不会与JPEG的细节纠缠，我们将使用TIFF格式来隐藏我们的信息。
- en: 'There are two common approaches to concealing a message in an image:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中隐藏信息有两种常见的方法：
- en: '**Using a color channel**: If we overwrite some bytes in just one color channel,
    we''ll be shifting a part of the color of a few pixels in the area we overwrote.
    It will only be a few of millions of pixels, and it will only be one of the three
    (or four) colors. If we confine the tweaking to the edge, it''s not too noticeable.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用颜色通道**：如果我们只覆盖一个颜色通道中的某些字节，我们将改变我们覆盖区域中几个像素的颜色的一部分。这只会是几百万像素中的一小部分，并且只会是三种（或四种）颜色中的一种。如果我们将调整限制在边缘，那么它不太会引人注目。'
- en: '**Using the least significant bits (LSBs) of each byte**: If we overwrite the
    least significant bit in a series of bytes, we''ll make an extremely minor shift
    in the image. We have to limit the size of our message because we can only encode
    one byte per pixel. A small picture that''s *432 * 161 = 69,552* pixels can encode
    8,694 bytes of data. If we use the UTF-8 encoding for our characters, we should
    be able to cram an 8 K message into that image. If we use UTF-16, we''d only get
    a 4 K message. This technique works even for grayscale images where there''s only
    one channel.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用每个字节的最低有效位（LSBs）**：如果我们覆盖一系列字节中的最低有效位，我们将在图像中产生一个非常小的变化。我们必须限制我们信息的大小，因为我们只能每个像素编码一个字节。一张小图片，其尺寸为*432
    * 161 = 69,552*像素，可以编码8,694字节的数据。如果我们使用UTF-8编码我们的字符，我们应该能够将一个8 K的消息塞入那张图片。如果我们使用UTF-16，我们只能得到一个4
    K的消息。这种技术在只有单一通道的灰度图像中也能工作。'
- en: In addition to the JPEG compression problem, there are some color encoding schemes
    that don't work out well with either of these steganography approaches. The modes,
    known as **P**, **I**, and **F**, present a bit of a problem. These color modes
    involve mapping a color code to a palette. In these cases, the byte is not the
    level of gray or the level of a color; when using a palette, the bytes are a reference
    to a color. Making a 1-bit change might lead to a profound change in the color
    selected from the underlying palette. The color `5` might be a pleasant sea-foam
    green, the color `4` might be an awful magenta. A 1-bit change between `5` and
    `4` may be a noticeable out-of-place dot.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JPEG压缩问题之外，还有一些颜色编码方案与这两种隐写术方法都不太兼容。被称为**P**、**I**和**F**的模式带来了一些问题。这些颜色模式涉及将颜色代码映射到调色板。在这些情况下，字节不是灰度级别或颜色级别；当使用调色板时，字节是颜色的参考。对1比特的更改可能会导致从底层调色板选择的颜色发生显著变化。颜色`5`可能是一种令人愉快的海藻绿，颜色`4`可能是一种糟糕的洋红色。`5`和`4`之间的1比特变化可能是一个明显的格格不入的点。
- en: For our purposes, we can switch the source image to RGB (or CMYK) before applying
    our steganography encoding. The basic change to the color mode might be visible
    to someone who had access to the original image. However, the hidden message will
    remain obscured unless they also know our steganography algorithm.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用我们的隐写术编码之前，为了我们的目的，我们可以将源图像切换到RGB（或CMYK）。基本颜色模式的变化可能对有机会访问原始图像的人来说是可见的。然而，除非他们也知道我们的隐写术算法，否则隐藏的信息将保持隐蔽。
- en: 'Our strategy works like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的战略是这样的：
- en: Get the bytes from the pixels of the image.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图像像素的字节。
- en: Transform our secret message from a Unicode string into a sequence of bits.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的秘密信息从Unicode字符串转换为一系列比特。
- en: For each bit of our secret message, adulterate 1 byte of the original image.
    As we're tweaking the least significant bit, one of two things will happen.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们秘密信息的每一比特，我们需要在原始图像中篡改1个字节的值。由于我们在调整最低有效位，以下两种情况中的一种将会发生。
- en: We'll make an image pixel value into an even number to encode a 0 bit from our
    secret message
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将图像像素值调整为偶数以编码秘密信息中的0比特
- en: We'll make an image pixel value into an odd number to encode a 1 bit from our
    secret message
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将图像像素值调整为奇数以编码秘密信息中的1比特
- en: 'We''ll work with two parallel sequences of values:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理两个平行的值序列：
- en: The bytes from the image (ideally enough to encode our entire message)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自图像的字节（理想情况下足够编码我们整个信息）
- en: The bits from our secret message
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自秘密信息的比特
- en: The idea is to step through each byte of the image and incorporate 1 bit of
    the secret message into that image byte. The cool feature of this is that some
    pixel values might not need to actually change. If we're encoding a byte in a
    pixel that's already odd, we won't change the image at all.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是逐步遍历图像中的每个字节，并将秘密信息的1比特融入该图像字节。这个酷的特点是某些像素值可能实际上不需要改变。如果我们在一个已经是奇数的像素中编码一个字节，我们根本不会改变图像。
- en: 'This means that we need to perform the following important steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要执行以下重要步骤：
- en: Get the bytes in the red channel of the image
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取图像红色通道中的字节
- en: Get the bytes from a Unicode message
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Unicode消息中获取字节
- en: Get the bits from the message bytes
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从消息字节中获取位
- en: Tweak the image pixel byte using a message bit, and update the image
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息位调整图像像素字节，并更新图像
- en: We'll tackle these one at a time, then we'll weld it all together at the end.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个解决这些问题，然后在最后将它们全部焊接在一起。
- en: Getting the red-channel data
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取红色通道数据
- en: Let's look at encoding our message in an image using the red channel LSB encoding.
    Why red? Why not? Men may have some degree of red-green color blindness; if they're
    less likely to see a shift in this channel, then we've further concealed our image
    from a few prying eyes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用红色通道 LSB 编码在图像中编码我们的消息。为什么是红色？为什么不呢？男性可能有一定程度的红绿色盲；如果他们不太可能看到这个通道中的变化，那么我们就进一步隐藏了我们的图像，让一些好奇的眼睛难以察觉。
- en: 'The first question is this: how do we tinker with the bytes of the original
    image?'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题：我们如何篡改原始图像的字节？
- en: The PIL `Image` object has the `getpixel()` and `putpixel()` methods that allow
    us to get the various color band values.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: PIL `Image` 对象具有 `getpixel()` 和 `putpixel()` 方法，允许我们获取各种颜色通道值。
- en: 'We can peel out individual pixels from the image like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样从图像中提取单个像素：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve provided an `(x,y)` two-tuple to the `getpixel()` method. This shows
    us that each pixel in the image is a three-tuple. It''s not obvious what the three
    numbers are. We can use `ship.getbands()` to get this information, as shown in
    the following snippet:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向 `getpixel()` 方法提供了一个 `(x,y)` 二元组。这表明图像中的每个像素都是一个三元组。这三个数字是什么并不明显。我们可以使用
    `ship.getbands()` 获取这些信息，如下面的代码片段所示：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There was little doubt in our minds that the three pixel values were red level,
    green level, and blue level. We've used the `getband()` method to get confirmation
    from Pillow that our assumption about the image encoding band was correct.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们心中几乎没有怀疑，三个像素值分别是红色级别、绿色级别和蓝色级别。我们已经使用 `getband()` 方法从 Pillow 获取确认，我们关于图像编码通道的假设是正确的。
- en: We now have access to the individual bytes of the image. The next steps are
    to get the bits from our secret message and then adulterate the image bytes with
    our secret message bits.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问图像的各个字节。下一步是从我们的秘密消息中获取位，然后使用秘密消息位篡改图像字节。
- en: Extracting bytes from Unicode characters
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Unicode 字符中提取字节
- en: In order to encode our secret message into the bytes of an image, we'll need
    to transform our Unicode message into bytes. Once we have some bytes, we can then
    make one more transformation to get a sequence of bits.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的秘密消息编码到图像的字节中，我们需要将我们的 Unicode 消息转换为字节。一旦我们有一些字节，我们就可以进行一次额外的转换，以获得位序列。
- en: The second question, is how do we get the individual bits of the message text?
    Another form of this question is, how do we turn a string of Unicode characters
    into a string of individual bits?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，我们如何获取消息文本的各个位？这个问题的另一种形式是，我们如何将一串 Unicode 字符串转换为位字符串？
- en: 'Here''s a Unicode string we can work with: [http://www.kearsarge.navy.mil](http://www.kearsarge.navy.mil).
    We''ll break the transformation into two steps: first to bytes and then to bits.
    There are a number of ways to encode strings as bytes. We''ll use the UTF-8 encoding
    as that''s very popular:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以处理的 Unicode 字符串：[http://www.kearsarge.navy.mil](http://www.kearsarge.navy.mil)。我们将把转换分为两个步骤：首先转换为字节，然后转换为位。有几种方法可以将字符串编码为字节。我们将使用
    UTF-8 编码，因为它非常流行：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It doesn't look like too much happened there. This is because the UTF-8 encoding
    happens to match the ASCII encoding that Python byte literals use. This means
    that the bytes version of a string, which happens to use only US-ASCII characters,
    will look very much like the original Python string. The presence of special `b'
    '` quotes is the hint that the string is only bytes, not full Unicode characters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 那里似乎并没有发生太多事情。这是因为 UTF-8 编码恰好与 Python 字节字面量使用的 ASCII 编码相匹配。这意味着字符串的字节版本，恰好只使用
    US-ASCII 字符，看起来会非常像原始的 Python 字符串。特殊 `b' '` 引号的存在是提示，表明字符串仅是字节，而不是完整的 Unicode
    字符。
- en: If we had some non-ASCII Unicode characters in our string, then the UTF-8 encoding
    would become quite a bit more complex.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的字符串中有一些非 ASCII 的 Unicode 字符，那么 UTF-8 编码将变得更加复杂。
- en: 'Just for reference, here''s the UTF-16 encoding of our message:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，以下是我们的消息的 UTF-16 编码：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The previous encoded message looks to be a proper mess. As expected, it's close
    to twice as big as UTF-8.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个编码的消息看起来像是一团糟。正如预期的那样，它的大小几乎是 UTF-8 的大小的两倍。
- en: 'Here''s another view of the individual bytes in the message:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是消息中各个字节的另一种视图：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've used a generator expression to apply the `hex()` function to each byte.
    This gives us a hint as to how we're going to proceed. Our message was transformed
    into 29 bytes, which is 232 bits; we want to put these bits into the first 232
    pixels of our image.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器表达式将`hex()`函数应用于每个字节。这为我们提供了如何继续进行的线索。我们的信息被转换成了29字节，即232位；我们希望将这些位放入图像的前232像素中。
- en: Manipulating bits and bytes
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作位和字节
- en: As we'll be fiddling with individual bits, we need to know how to transform
    a Python byte into a tuple of 8 bits. The inverse is a technique to transform
    an 8-bit tuple back into a single byte. If we expand each byte into an eight-tuple,
    we can easily adjust the bits and confirm that we're doing the right thing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要操作单个位，我们需要知道如何将Python字节转换成8位的元组。其逆操作是将8位元组转换回单个字节的技术。如果我们将每个字节扩展成一个八元组，我们就可以轻松调整位并确认我们正在做正确的事情。
- en: We'll need some functions to expand a list of byte into bits and contract the
    bits back to the original list of bytes. Then, we can apply these functions to
    our sequence of bytes to create the sequence of individual bits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些函数来将字节列表扩展成位，并将位收缩回原始的字节列表。然后，我们可以将这些函数应用于我们的字节序列以创建单个位的序列。
- en: 'The essential computer science is explained next:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的计算机科学将在下面解释：
- en: 'A number, ![Manipulating bits and bytes](img/0420OS_03_07.jpg), is a polynomial
    in some particular base. Here''s the polynomial for the value of 234 with base
    10:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数，![操作位和字节](img/0420OS_03_07.jpg)，是某个特定基数中的多项式。以下是234值以10为基数的这个多项式：
- en: '![Manipulating bits and bytes](img/0420OS_03_08.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![操作位和字节](img/0420OS_03_08.jpg)'
- en: 'In base 16, we have ![Manipulating bits and bytes](img/0420OS_03_09.jpg). When
    writing hex, we use letters for the 14 and 10 digits: `0xea`.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在16进制中，我们有![操作位和字节](img/0420OS_03_09.jpg)。在写十六进制时，我们使用字母表示14和10的数字：`0xea`。
- en: 'This kind of polynomial representation is true in base 2\. A number, ![Manipulating
    bits and bytes](img/0420OS_03_07.jpg), is a polynomial in base 2\. Here''s the
    polynomial for the value of 234:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多项式表示在二进制中是正确的。一个数，![操作位和字节](img/0420OS_03_07.jpg)，是二进制中的多项式。以下是234值的这个多项式：
- en: '![Manipulating bits and bytes](img/0420OS_03_10.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![操作位和字节](img/0420OS_03_10.jpg)'
- en: 'Here''s a way to extract the lower 8 bits from a numeric value:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种从数值中提取低8位的方法：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `v&1` expression applies a bitwise operation to extract the rightmost bit
    of a number. We'll append the calculated bit value to the `b` variable. The `v
    >>= 1` statement is the same as `v = v>>1`; the `v>>1` expression will shift the
    value, `v`, one bit to the right. After doing this eight times, we've extracted
    the lowest bits of the `v` value. We've assembled this sequence of bits in a list
    object, `b`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`v&1`表达式对数字执行位操作以提取最右边的位。我们将计算出的位值追加到`b`变量中。`v >>= 1`语句等同于`v = v>>1`；`v>>1`表达式将值`v`右移一位。这样做八次后，我们就提取了`v`值的最低位。我们在列表对象`b`中组装了这个位序列。'
- en: 'The results are accumulated in the *wrong* order, so we reverse them and create
    a tidy little eight-tuple object. We can compare this with the built-in `bin()`
    function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以错误的顺序累积，因此我们反转它们并创建一个整洁的八元组对象。我们可以将其与内置的`bin()`函数进行比较：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For a value over 127, both the `bin()` and `to_bits()` functions produce 8-bit
    results. For smaller values, we'll see that the `bin()` function doesn't produce
    8 bits; it produces just enough bits.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大于127的值，`bin()`和`to_bits()`函数都产生8位的结果。对于较小的值，我们会看到`bin()`函数不产生8位；它只产生足够的位。
- en: 'The opposite transformation evaluates the polynomial. We can do a little algebra
    to optimize the number of multiplications:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的转换评估多项式。我们可以进行一点代数运算来优化乘法次数：
- en: '![Manipulating bits and bytes](img/0420OS_03_11.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![操作位和字节](img/0420OS_03_11.jpg)'
- en: 'Because of the grouping, the leftmost 1 winds up multiplied by ![Manipulating
    bits and bytes](img/0420OS_03_12.jpg). As shifting bits to the left is the same
    as multiplying by 2, we can reconstruct the a byte value from a tuple of bits
    as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分组，最左边的1最终乘以![操作位和字节](img/0420OS_03_12.jpg)。因为将位向左移位等同于乘以2，我们可以根据以下方式从位元组重建字节值：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `(v<<1)|bit` expression will shift `v` to the left 1 bit, effectively performing
    a `*2` operation. An `OR` operation will fold the next bit into the value being
    accumulated.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v<<1)|bit`表达式将`v`左移1位，实际上执行了`*2`操作。一个`OR`操作将下一个位折叠到正在累积的值中。'
- en: 'We can test these two functions with a loop like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这样的循环来测试这两个函数：
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If all 256 byte values are converted to bits and back to bytes, we are absolutely
    sure that we can convert bytes to bits. We can use this to see the expansion of
    our message:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有256个字节值都转换为比特然后再转换回字节，我们就绝对确信我们可以将字节转换为比特。我们可以使用这一点来查看我们消息的扩展：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will show us a big list of 8-tuples:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个包含8元组的列表：
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Each byte of the secret message has become an eight-tuple of individual bits.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密信息的每个字节都变成了一个由单独的比特组成的八元组。
- en: Assembling the bits
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特的组装
- en: 'At this point, we''ve got two parallel sequences of values:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个并行序列的值：
- en: The bytes from the image (ideally enough to encode our entire message)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自图像的字节（理想情况下足够编码我们的整个消息）
- en: The bits from our secret message (in the example, we've got just 29 bytes, which
    is 232 bits)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自我们的秘密消息的比特（在示例中，我们只有29字节，即232比特）
- en: The idea is to step through each byte of the image and incorporate one bit of
    the secret message into that byte.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是遍历图像的每个字节，并将秘密消息的一个比特合并到该字节中。
- en: Before we can fully tweak the various image bytes with our message bits, we
    need to assemble a long sequence of individual bits. We have two choices to do
    this. We can create a `list` object with all of the bit values. This wastes a
    bit of memory, and we can do better.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够完全调整图像的各种字节与我们的信息比特之前，我们需要组装一个由单独的比特组成的长序列。我们有两个选择来做这件事。我们可以创建一个包含所有比特值的`list`对象。这会浪费一点内存，而且我们可以做得更好。
- en: We can also create a generator function that will appear to be a `sequence`
    object with all of the bits.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个生成器函数，它看起来像是一个包含所有比特的`sequence`对象。
- en: 'Here''s a generator function that we can use to emit the entire sequence of
    bits from the message:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器函数，我们可以用它来发出消息的整个比特序列：
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've stepped through each individual eight-tuple in the list-of-tuples values
    that can be created by our `to_bits()` function. For each bit in the 8-tuple,
    we've used the `yield` statement to provide the individual bit values. Any expression
    or statement that expects an iterable sequence will be able to use this function.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历了列表中由`to_bits()`函数创建的每个八元组。对于8元组中的每个比特，我们使用了`yield`语句来提供单独的比特值。任何期望可迭代序列的表达式或语句都将能够使用这个函数。
- en: 'Here''s how we can use this to accumulate a sequence of all 232 bits from a
    message:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以如何使用这个方法来累积来自消息的所有232比特的序列：
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will apply the `to_bits()` function to each byte of the message, creating
    a sequence of 8-tuples. Then it will apply the `bit_sequence()` generator to that
    sequence of eight-tuples. The output is a sequence of individual bits, which we
    collected into a `list` object. The resulting list looks like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对消息的每个字节应用`to_bits()`函数，创建一个8元组的序列。然后它将对这个八元组的序列应用`bit_sequence()`生成器。输出是一个单独比特的序列，我们将其收集到一个`list`对象中。结果列表看起来像这样：
- en: '[PRE64]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We can see the list of 232 individual bits built from our original message.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到由原始信息构建的232个单独比特的列表。
- en: 'Here''s the inverse to the `bit_sequence()` function. This will group a sequence
    of bits into eight-tuples:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`bit_sequence()`函数的逆函数。它将比特序列分组到八元组中：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We've used the built-in `enumerate()` generator function to provide a number
    for each individual bit in the original sequence. The output from the `enumerate(bits)`
    expression is a sequence of two-tuples; each two-tuple has the enumerated bit
    number (from `0` to `231`) and the bit value itself (`0` or `1`).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了内置的`enumerate()`生成器函数为原始序列中的每个单独比特提供一个编号。从`enumerate(bits)`表达式中输出的结果是两个元组的序列；每个元组包含编号的比特数（从`0`到`231`）以及比特值本身（`0`或`1`）。
- en: When the bit number is a multiple of `8` (`n%8 == 0`), we've seen a complete
    batch of eight bits. We can convert these eight bits to a byte with `to_byte()`,
    yield the byte value, and reset our temporary accumulator, `byte`, to be empty.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当比特编号是`8`的倍数时（`n%8 == 0`），我们就看到了一个完整的八比特批次。我们可以使用`to_byte()`将这些八比特转换成一个字节，产生字节值，并将我们的临时累加器`byte`重置为空。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've made a special exception for the very first byte.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为第一个字节做了特殊例外。
- en: The `enumerate()` function will assign the very first byte number `0`; since
    `0%8 == 0`, it looks like we've just accumulated eight bits to make a byte. We've
    avoided this complication by assuring that `n` is not 0; it's not the first bit
    value. We could also have used the `len(byte) != 0` expression to avoid the first-time
    complication.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数将分配第一个字节的编号`0`；由于`0%8 == 0`，这看起来我们刚刚积累了八个比特来形成一个字节。我们通过确保`n`不是0；它不是第一个比特值来避免这种复杂性。我们也可以使用`len(byte)
    != 0`表达式来避免第一次的复杂性。'
- en: The final `yield` statement is critical for success. The final batch of bits
    will have `n%8` values of `0` to `7`. The `n%8` test won't be used when the collection
    of bits is exhausted, but we'll still have eight bits accumulated in the `byte`
    variable. We yield this final batch of eight bits as an extra step.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `yield` 语句对于成功至关重要。最后的比特批次将包含 `n%8` 个从 `0` 到 `7` 的值。当比特集合耗尽时，`n%8` 测试将不会被使用，但我们在
    `byte` 变量中仍然会积累八个比特。我们将作为额外步骤提供这最后一批八个比特。
- en: 'Here''s what it looks like:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是这样的：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've taken the sequence of individual bits and collected each batch of eight
    bits into bytes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将单独的比特序列收集成每批八个比特的字节。
- en: Encoding the message
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息编码
- en: Now that we can transform any Unicode string into bits, we can encode a message
    into an image. The final nuance is how to delimit the message. We don't want to
    accidentally decode each byte in the entire image. If we did this, our message
    will be padded with random characters. We need to know when to stop decoding.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将任何 Unicode 字符串转换为比特，我们可以将信息编码成图片。最后的微妙之处在于如何界定信息。我们不希望不小心解码整个图片中的每一个字节。如果我们这样做，我们的信息将被随机字符填充。我们需要知道何时停止解码。
- en: One common technique is to include a terminator character. Another common technique
    is to provide a length in front of the string. We're going to include a length
    in front of the string so that we aren't constrained by the contents of the string
    or the encoded bytes that are produced from that string.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的技术是在字符串前包含一个终止字符。另一种常见的技术是在字符串前提供一个长度。我们将在字符串前包含一个长度，这样我们就不会受到字符串内容或从该字符串产生的编码字节的限制。
- en: 'We''ll use a 2-byte length in front of the string; we can encode it into bytes
    and bits like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在字符串前使用 2 字节长度；我们可以这样将其编码成字节和比特：
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We've used the Python `divmod()` function to compute the quotient and remainder
    after division. The results of the `divmod( len(message), 256 )` expression will
    be `len(message)//256` and `len(message)%256`. We can recover the original value
    from the `len_H*256+len_L` expression.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Python 的 `divmod()` 函数来计算除法后的商和余数。`divmod(len(message), 256)` 表达式的结果将是
    `len(message)//256` 和 `len(message)%256`。我们可以从 `len_H*256+len_L` 表达式中恢复原始值。
- en: The `size` variable is set to a short sequence composed of two eight-tuples
    built from the `len_H` and `len_L` values.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 变量被设置为一个由两个八元组组成的短序列，这些八元组是由 `len_H` 和 `len_L` 值构建的。'
- en: 'The complete sequence of bytes, including the length, looks like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 包括长度在内的完整字节序列看起来是这样的：
- en: '[PRE68]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: First, we encoded the message into bytes. Depending on the Unicode characters
    involved and the encoding used, this may be longer than the original message.
    The `bits_list` variable is a sequence of eight-tuples built from the various
    bytes of the encoded message.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将信息编码成字节。根据涉及的 Unicode 字符和使用的编码，这可能会比原始信息更长。`bits_list` 变量是由编码信息的各个字节构建的八元组序列。
- en: Then, we created two more bytes with the length information and converted them
    to bits. The `size_list` variable is a sequence of eight-tuples built from the
    bytes of the encoded size.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个包含长度信息的额外字节并将它们转换为比特。`size_list` 变量是由编码长度的字节构建的八元组序列。
- en: The `size_list+bits_list` expression shows how to concatenate the two sequences
    to create a long sequence of individual bits that we can embed into our image.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_list+bits_list` 表达式展示了如何连接两个序列以创建一个长序列的单独比特，我们可以将这些比特嵌入到我们的图片中。'
- en: 'Here''s how we use the `putpixel()` and `getpixel()` methods to update the
    image:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `putpixel()` 和 `getpixel()` 方法更新图片的方法：
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've extracted the size of the original image; this tells us how long the *x*
    axis is so that we can use multiple rows of the image if necessary. If our image
    only has 128 pixels on a row, we'll need more than one row for a 292-bit message.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取了原始图片的大小；这告诉我们 *x* 轴有多长，这样我们就可以在必要时使用图片的多个行。如果我们的图片每行只有 128 像素，我们需要超过一行来容纳
    292 比特的信息。
- en: We've applied the `enumerate()` function to the `bit_sequence(size_list+bits_list)`
    value. This will provide both a sequence number and an individual bit from the
    original message. The sequence number can be converted to a row and column using
    the `divmod()` function. We'll set `y` to `sequence // width`; we'll set `x` to
    `sequence % width`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `enumerate()` 函数应用于 `bit_sequence(size_list+bits_list)` 值。这将提供原始信息的序列号和单个比特。序列号可以通过
    `divmod()` 函数转换为行和列。我们将 `y` 设置为 `sequence // width`；我们将 `x` 设置为 `sequence % width`。
- en: If we use the thumbnail image, which is 128-pixels wide, the first 128 bits
    go to row `0`. The next 128 bits go to row `1`. The balance of the 292 bits will
    wind up on row `3`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用宽度为 128 像素的缩略图，前 128 位将进入行 `0`。接下来的 128 位将进入行 `1`。剩下的 292 位将最终落在行 `3`
    上。
- en: We got the RGB values from the pixel using `ship.getpixel( (x,y) )`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ship.getpixel( (x,y) )` 从像素中获取 RGB 值。
- en: 'We''ve highlighted the bit-fiddling part: `r_new = (r & 0xfe) | m`. This uses
    a **mask** value of `0xfe`, which is `0b11111110`. This works because the `&`
    operator has a handy feature. When we use `b&1`, the value of `b` is preserved.
    When we use `b&0`, the result is `0`.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了位操作的部分：`r_new = (r & 0xfe) | m`。这使用了一个 **掩码** 值 `0xfe`，即 `0b11111110`。这是因为
    `&` 运算符有一个方便的特性。当我们使用 `b&1` 时，`b` 的值将被保留。当我们使用 `b&0` 时，结果是 `0`。
- en: 'Try it, as shown in the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下代码，如图所示：
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The value of `b` (either `1` or `0`) was preserved. Similarly, `1 & 0` and `0
    & 0` are both `0`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除最低位时，`b` 的值（无论是 `1` 还是 `0`）将被保留。同样，`1 & 0` 和 `0 & 0` 都是 `0`。
- en: 'Using a mask value in `(r & 0xfe)` means that the leftmost seven bits of `r`
    will be preserved; the rightmost bit will be set to `0`. When we use `(r & 0xfe)
    | m`, we''ll be folding the value of `m` into the rightmost position. We''ve printed
    out the old and new pixel values to provide some details on how this works. Here
    are two rows from the output:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `(r & 0xfe)` 中使用掩码值意味着 `r` 的最高七位将被保留；最低位将被设置为 `0`。当我们使用 `(r & 0xfe) | m` 时，我们将
    `m` 的值折叠到最低位。我们打印出旧的和新的像素值，以提供一些关于这是如何工作的细节。以下是输出中的两行：
- en: '[PRE71]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can see that the old value of the red channel was `245`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到红色通道的旧值是 `245`：
- en: '[PRE72]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The value `244` shows how the rightmost bit was removed from `245`. When we
    fold in a new bit value `0`, the result remains `244`. An even value encodes a
    0 bit from our secret message.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `244` 展示了如何从 `245` 中移除最低位。当我们折叠一个新的位值 `0` 时，结果仍然是 `244`。偶数值编码了我们秘密信息中的 0 位。
- en: 'In this case, the old value of the red channel was `246`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，红色通道的旧值是 `246`：
- en: '[PRE73]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The value remains `246` when we remove the rightmost bit. When we fold in a
    new bit value of `1`, the result becomes `247`. An odd value encodes a one bit
    from our secret message.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除最低位时，值保持为 `246`。当我们折叠一个新的位值 `1` 时，结果变为 `247`。奇数值编码了我们秘密信息中的 1 位。
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `ship.show()` before and after the image reveals no perceivable change
    to the image.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像前后使用 `ship.show()` 不会揭示图像有任何可感知的变化。
- en: After all, we've only tweaked the level of the red in the image by plus or minus
    `1` on a scale of `256`, less than half percent change.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们只是在图像中调整了红色的级别，在 `256` 的尺度上加减 `1`，不到半百分比的改变。
- en: Decoding a message
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码一条信息
- en: We will decode a message concealed with steganography in two steps. The first
    step will decode just the first two bytes of length information, so we can recover
    our embedded message. Once we know how many bytes we're looking for, we can decode
    the right number of bits, recovering just our embedded characters, and nothing
    more.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步解码用隐写术隐藏的信息。第一步将解码长度信息的头两个字节，这样我们就可以恢复嵌入的信息。一旦我们知道我们要查找多少字节，我们就可以解码正确数量的位，只恢复我们的嵌入字符，不再有其他。
- en: 'As we''ll be dipping into the message twice, it will help to write a bit extractor.
    Here''s the function that will strip bits from the red channel of an image:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要两次进入信息，编写一个位提取器会有所帮助。以下是用于从图像的红色通道中剥离位的函数：
- en: '[PRE74]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ve defined a function with three parameters: an image, an offset into the
    image, and a number of bits to extract. The length information is an offset zero
    and has a length of 16 bits. We set those as default values.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个有三个参数的函数：一个图像、图像中的偏移量以及要提取的位数。长度信息是一个偏移量为零且长度为 16 位的偏移量。我们将这些值设置为默认值。
- en: We used the a common `divmod()` calculation to transform a position into *y*
    and *x* coordinates based on the overall width of the image. The `y` value is
    `position//width`; the `x` value is `position%width`. This matches the calculation
    carried out when embedding bits into the message.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个常见的 `divmod()` 计算来将位置转换为基于图像总宽度的 *y* 和 *x* 坐标。`y` 值是 `position//width`；`x`
    值是 `position%width`。这与将位嵌入信息时进行的计算相匹配。
- en: We used the image's `getpixel()` method to extract the three channels of color
    information. We used `r & 0x01` to calculate just the rightmost bit of the red
    channel.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用图像的 `getpixel()` 方法提取三个颜色信息通道。我们使用 `r & 0x01` 来计算红色通道的最低位。
- en: 'As the value was returned with a `yield` statement, this is a generator function:
    it provides a sequence of values. As our `byte_sequence()` function expects a
    sequence of values, we can combine the two to extract the size, as shown in the
    following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值是通过`yield`语句返回的，这是一个生成器函数：它提供一系列值。由于我们的`byte_sequence()`函数期望一系列值，我们可以将两者结合起来提取大小，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We grabbed 16 bits from the image using the `get_bits()` function. This sequence
    of bits was provided to the `byte_sequence()` function. The bits were grouped
    into eight-tuples and the eight-tuples transformed into single values. We can
    then multiply and add these values to recover the original message size.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get_bits()`函数从图像中提取了16个比特。这串比特被提供给`byte_sequence()`函数。比特被分成八元组，八元组被转换成单个值。然后我们可以将这些值相乘并相加以恢复原始消息的大小。
- en: 'Now that we know how many bytes to get, we also know how many bits to extract.
    The extraction looks like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了要获取多少字节，我们也知道要提取多少比特。提取看起来像这样：
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We've used the `get_bits()` function to extract bits starting from position
    16 and extending until we've found a total of `size*8` individual bits. We grouped
    the bits into eight-tuples and converted the eight-tuples to individual values.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get_bits()`函数从第16位开始提取比特，直到找到总共`size*8`个单独的比特。我们将比特分成八元组，并将八元组转换为单个值。
- en: 'Given a sequence of bytes, we can create a `bytes` object and use Python''s
    decoder to recover the original string. It looks like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字节序列，我们可以创建一个`bytes`对象，并使用Python的解码器恢复原始字符串。它看起来像这样：
- en: '[PRE77]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This will properly decode bytes into characters using the UTF-8 encoding.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确地将字节解码为字符，使用UTF-8编码。
- en: Detecting and preventing tampering
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和防止篡改
- en: We can use steganography to assure that our message isn't tampered with. If
    we can't find our digital watermark properly encoded, we know that our picture
    was touched. This is one way to detect tampering. A more robust technique to detect
    tampering is to use hash totals. There are a number of hash algorithms used to
    produce a summary or signature of a sequence of bytes. We send both the message
    and the hash code separately. If the received message doesn't match the hash code,
    we know something went wrong. One common use case for hashes is to confirm a proper
    download of a file. After downloading a file, we should compare the hash of the
    file we got with a separately published hash value; if the hash values don't match,
    something's wrong with the file. We can delete it before opening it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用隐写术来确保我们的消息没有被篡改。如果我们不能正确找到我们正确编码的数字水印，我们知道我们的图片被修改了。这是检测篡改的一种方法。检测篡改的更稳健的技术是使用哈希总和。有许多哈希算法用于生成字节序列的摘要或签名。我们分别发送消息和哈希码。如果接收到的消息与哈希码不匹配，我们知道出了问题。哈希的一个常见用途是确认文件的正确下载。下载文件后，我们应该将我们得到的文件的哈希值与单独发布的哈希值进行比较；如果哈希值不匹配，文件有问题。我们可以在打开它之前将其删除。
- en: While it seems like encryption would prevent tampering, it requires careful
    management of the encryption keys. Encryption is no panacea. It's possible to
    employ a good encryption algorithm but lose control of the keys, rendering the
    encryption useless. Someone with unauthorized access to the key can rewrite the
    file and no one would know.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然加密似乎可以防止篡改，但它需要仔细管理加密密钥。加密不是万能的。即使使用一个好的加密算法，也可能失去对密钥的控制，使加密变得无用。如果有人未经授权访问密钥，他们可以重写文件，而没有人会知道。
- en: Using hash totals to validate a file
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哈希总和验证文件
- en: 'Python has a number of hash algorithms available in the `hashlib` module. Software
    downloads are often provided with MD5 hashes of the software package. We can compute
    an MD5 digest of a file using `hashlib`, as shown in the following code:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`hashlib`模块中有许多哈希算法可用。软件下载通常附有软件包的MD5哈希值。我们可以使用`hashlib`计算文件的MD5摘要，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We've created an MD5 digest object using the `hashlib.new()` function; we named
    the algorithm to be used. We opened the file in *bytes* mode. We provided the
    entire file to the digest object's `update()` method. For really large files,
    we might want to read the file in blocks rather than read the entire file into
    memory in one swoop. Finally, we printed the hex version of the digest.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hashlib.new()`函数创建了一个MD5摘要对象；我们命名了要使用的算法。我们以*字节*模式打开文件。我们将整个文件提供给摘要对象的`update()`方法。对于非常大的文件，我们可能希望分块读取文件而不是一次性将整个文件读入内存。最后，我们打印了摘要的十六进制版本。
- en: 'This will provide a hexadecimal string version of the MD5 digest, as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供MD5摘要的十六进制字符串版本，如下所示：
- en: '[PRE79]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Having this secure hash allows us to confirm that the file has not been tampered
    with in its journey through the Internet from sender to receiver.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个安全的哈希，我们可以确认文件在其从发送者到接收者的互联网旅程中没有被篡改。
- en: Using a key with a digest
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用密钥与摘要
- en: We can provide considerably more security by adding a key to a message digest.
    This doesn't encrypt the message; it encrypts the digest to be sure that the digest
    is not touched during transmission.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向消息摘要添加密钥，我们可以提供相当多的安全性。这并不加密消息；它加密摘要以确保在传输过程中摘要不被篡改。
- en: 'The `hmac` module in the Python standard library handles this for us, as shown
    in the following code:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`hmac`模块为我们处理了这个问题，如下面的代码所示：
- en: '[PRE80]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this example, we've created an HMAC digest object and also passed the message
    content to that digest object. The `hmac.new()` function can accept both the key
    (as a string of bytes) and the body of a message.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个HMAC摘要对象，并将消息内容传递给该摘要对象。`hmac.new()`函数可以接受密钥（作为字节数组字符串）和消息体。
- en: 'The hex digest from this HMAC digest object includes both the original message
    and a key we provided. Here''s the output:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 来自此HMAC摘要对象的十六进制摘要包括原始消息和我们所提供的密钥。以下是输出：
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As HQ knows our key, they can confirm that a message comes from us.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HQ知道我们的密钥，他们可以确认消息来自我们。
- en: Similarly, HQ must use our key when sending us a message. We can then use our
    key when we read the message to confirm that it was sent to us by HQ.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，HQ在向我们发送消息时必须使用我们的密钥。然后，当我们读取消息时，我们可以使用我们的密钥来确认消息是由HQ发送给我们的。
- en: Solving problems – encrypting a message
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题——加密消息
- en: For proper encryption, the PyCrypto package can be used, which can be downloaded
    from [https://www.dlitz.net/software/pycrypto/](https://www.dlitz.net/software/pycrypto/).
    As with Pillow, this is a hefty download.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的加密，可以使用PyCrypto包，该包可以从[https://www.dlitz.net/software/pycrypto/](https://www.dlitz.net/software/pycrypto/)下载。与Pillow一样，这是一个庞大的下载。
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our
    Espionage Toolkit*, a poor choice of key will render any encryption scheme essentially
    worthless. If we encrypt a file using a single-word key that's available in a
    readily available corpus of words, we haven't really made our data very secure
    at all. A brute-force attack will break the encryption.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章。我们的间谍工具包")中看到的，*我们的间谍工具包*，一个糟糕的密钥选择将使任何加密方案基本上毫无价值。如果我们使用一个单词密钥来加密文件，而这个单词在现成的词库中很容易找到，我们实际上并没有使我们的数据非常安全。暴力攻击将破解加密。
- en: We can combine steganography with the creation of a `ZipFile` archive to embed
    a message in an image in a ZIP file. As a ZIP file can have a comment string,
    we can include an HMAC signature as the comment for the ZIP archive.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将隐写术与创建`ZipFile`存档相结合，在ZIP文件中嵌入图像中的消息。由于ZIP文件可以有注释字符串，我们可以将HMAC签名作为ZIP存档的注释。
- en: Ideally, we'd use the ZIP encryption. However, the Python `ZipFile` library
    doesn't create encrypted ZIP files. It only reads encrypted files.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会使用ZIP加密。然而，Python的`ZipFile`库不创建加密的ZIP文件。它只能读取加密的文件。
- en: 'We''re going to define a function that looks like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个如下所示的功能：
- en: '[PRE82]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We'll provide the text of our message, the image source, the key we'll use to
    create our HMAC signature, and an output filename. The output from this will be
    a ZIP file that contains the image and the signature.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供我们的消息文本、图像源、我们将用于创建HMAC签名的密钥，以及输出文件名。这将输出一个包含图像和签名的ZIP文件。
- en: 'The outline of our `package()` function looks like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`package()`函数的轮廓如下所示：
- en: '[PRE83]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We've opened the source image and used an `steg_embed()` function to put our
    secret message into the image. We've saved the updated image to a temporary file.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了源图像，并使用`steg_embed()`函数将我们的秘密消息放入图像中。我们将更新的图像保存到一个临时文件中。
- en: We computed the HMAC digest of our image file before doing anything else with
    it. We saved the digest in the `digest` variable.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在对图像文件进行其他操作之前，我们计算了其HMAC摘要。我们将摘要保存在`digest`变量中。
- en: Now that everything is prepared, we can create a new archive file. We can write
    the image into one member of the archive. When we are setting the `comment` attribute
    of the archive, this will make sure that the comment text is written when the
    archive is closed.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，我们可以创建一个新的存档文件。我们可以将图像写入存档的一个成员中。当我们设置存档的`comment`属性时，这将确保在存档关闭时写入注释文本。
- en: Note that we had to convert the key to ASCII bytes to create a digest. The HMAC
    algorithm is defined for bytes, not Unicode characters. Similarly, the resulting
    `hexdigest()` string had to be converted to ASCII bytes before it could be placed
    in the archive. ZIP archives only work in bytes and can't directly support Unicode
    characters.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须将密钥转换为ASCII字节以创建摘要。HMAC算法是为字节定义的，而不是Unicode字符。同样，结果 `hexdigest()` 字符串在放入存档之前必须转换为ASCII字节。ZIP存档只支持字节，不能直接支持Unicode字符。
- en: Finally, we removed the temporary file that had the tweaked image in it. There's
    no reason to leave potentially incriminating files laying around.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们删除了包含修改后的图像的临时文件。没有必要留下可能被指控的文件。
- en: For this to work, we need to complete the function, `steg_embed()`, that implements
    our steganographic encoding. See the *Some approaches to steganography* section
    for details on how this needs to work.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要完成实现我们的隐写术编码的函数 `steg_embed()`。有关如何实现这一点的详细信息，请参阅 *一些隐写术方法* 部分。
- en: Unpacking a message
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包消息
- en: 'We''ll also need the inverse function that can decode a message in a ZIP archive.
    This function would have a definition like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个逆函数，可以解码ZIP存档中的消息。这个函数的定义可能如下所示：
- en: '[PRE84]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'It requires a ZIP filename and a key to validate the signature. This can return
    two things: the embedded message and the image into which the message was encoded.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个ZIP文件名和一个密钥来验证签名。这可以返回两件事：嵌入的消息和将消息编码进其中的图像。
- en: 'The outline of our `unpackage()` function looks like this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `unpackage()` 函数的轮廓如下：
- en: '[PRE85]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We're going to remove any temporary file that might exist. If the file doesn't
    exist already, that's a good thing, but it will raise a `FileNotFoundError` exception.
    We need to trap and silence that exception.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除可能存在的任何临时文件。如果文件本身不存在，那是一件好事，但它将引发 `FileNotFoundError` 异常。我们需要捕获并抑制这个异常。
- en: Our first step is to open the ZIP file and then open the `image.tiff` member
    within the ZIP file. We compute the HMAC digest of this member. Then, we assert
    that the archive comment matches the hex digest of the selected member. If the
    condition in the `assert` statement is false and the HMAC keys don't match, then
    this will raise an exception and the script will stop running. This will also
    mean that our message was compromised. If the condition in the `assert` statement
    is true, it executes silently.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是打开ZIP文件，然后打开ZIP文件中的 `image.tiff` 成员。我们计算这个成员的HMAC摘要。然后，我们断言存档注释与所选成员的十六进制摘要相匹配。如果
    `assert` 语句中的条件为假且HMAC密钥不匹配，则这将引发异常并停止脚本运行。这也意味着我们的消息已被破坏。如果 `assert` 语句中的条件为真，它将静默执行。
- en: If the assertion is true, we can extract the image file to a spot in the `/tmp`
    directory. From here, we can open the file and use the `steg_extract()` function
    to recover the message hidden in the image. Windows agents can use the `os` module
    to locate a temporary directory. The value of `os.environ['TEMP']` will name a
    suitable temporary directory.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言是真实的，我们可以将图像文件提取到 `/tmp` 目录中的某个位置。从这里，我们可以打开文件并使用 `steg_extract()` 函数来恢复图像中隐藏的消息。Windows代理可以使用
    `os` 模块来定位临时目录。`os.environ['TEMP']` 的值将命名一个合适的临时目录。
- en: Once we've got the message, we can remove the temporary file.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了消息，我们就可以删除临时文件。
- en: For this to work, we need to complete the function, `steg_extract()`, that implements
    our steganographic decoding. See the *Some approaches to steganography* section
    for details on how this needs to work.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要完成实现我们的隐写术解码的函数 `steg_extract()`。有关如何实现这一点的详细信息，请参阅 *一些隐写术方法* 部分。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work on a computer's filesystem and common
    file formats. We looked in depth at image files. We also saw how Pillow allows
    us to apply operations such as cropping, filtering, and enhancing to an image.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在计算机文件系统和常见文件格式上工作。我们深入研究了图像文件。我们还看到了Pillow如何允许我们对图像应用裁剪、过滤和增强等操作。
- en: We covered Python bit-fiddling operators such as `&`, `|`, `<<`, and `>>`. These
    operators work on the individual bits of an integer value. Something like `bin(0b0100
    & 0b1100)` will show how the answer is based on doing an `AND` operation on each
    individual bit of the number.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Python位操作符，如 `&`、`|`、`<<` 和 `>>`。这些操作符作用于整数值的各个位。例如，`bin(0b0100 & 0b1100)`
    将显示答案是基于对数字的每个单独位执行 `AND` 操作的结果。
- en: We also looked at how we can apply steganographic techniques to conceal a message
    in an image file. This involved both byte and bit manipulation in Python.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何将隐写术技术应用于在图像文件中隐藏信息。这涉及到在Python中对字节和位的操作。
- en: In the next chapter, we'll look at incorporating geolocation information with
    our other information gathering. We know that pictures can be tied to locations,
    so geocoding and reverse geocoding are essential. We'll also look at ways to read
    more complex online datasets and combine multiple web services into a composite
    application.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将地理位置信息与我们的其他信息收集相结合。我们知道图片可以与地点相关联，因此地理编码和反向地理编码是必不可少的。我们还将探讨读取更复杂的在线数据集的方法，以及将多个网络服务组合成一个综合应用的方法。
