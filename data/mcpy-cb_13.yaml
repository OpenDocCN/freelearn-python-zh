- en: Interacting with the Adafruit FeatherWing OLED
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Adafruit FeatherWing OLED交互
- en: This chapter will introduce you to the Adafruit FeatherWing **organic light-emitting
    diode** (**OLED**) display. The Adafruit Feather is a standard board arrangement,
    which allows upgrades to those boards to be plugged into each other. These can
    run either stacked on top of each other or as standalone boards. FeatherWings
    are accessories that can be plugged into these Feather boards.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍Adafruit FeatherWing有机发光二极管（OLED）显示器。Adafruit Feather是一个标准的板安排，允许将这些板升级插入到彼此之间。它们可以堆叠在一起或作为独立板运行。FeatherWings是可以插入这些Feather板的附件。
- en: In this chapter, we will plug the Adafruit FeatherWing OLED display into the
    Adafruit Feather HUZZAH ESP8266 MicroPython board. This will create the powerful
    combination of a microcontroller with internet connectivity, which has a display
    that can output text graphics and interact with the user using three hardware
    push buttons that are a part of the display.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把Adafruit FeatherWing OLED显示器插入Adafruit Feather HUZZAH ESP8266 MicroPython板中。这将创建一个功能强大的组合，即具有显示器的微控制器和互联网连接功能，可以输出文本图形，并使用显示器上的三个硬件按钮与用户交互。
- en: The recipes in this chapter will help you build a whole array of projects. You
    can make little MicroPython boards that display a menu, which you can navigate
    through, and each selected action could post sensor data to other servers on your
    network or to the internet. You could also use it to fetch data from servers on
    command and display it on the screen. This chapter will focus on all the main
    features of the display, such as displaying texts, lines, and rectangle graphics,
    as well as interacting with the built-in buttons that come with the display.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的配方将帮助您构建一系列项目。您可以制作小型MicroPython板，显示一个菜单，您可以通过导航，选择的每个操作都可以将传感器数据发布到网络上的其他服务器或互联网上。您还可以使用它按命令从服务器获取数据并在屏幕上显示。本章将重点介绍显示器的所有主要功能，如显示文本、线条和矩形图形，以及与显示器配备的内置按钮进行交互。
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Detecting button presses with GPIO pins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPIO引脚检测按钮按下
- en: Connecting to the SSD1306 display
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到SSD1306显示器
- en: Filling and clearing the display
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充和清除显示器
- en: Setting pixels on the display
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示器上设置像素
- en: Drawing lines and rectangles on the display
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示器上绘制线条和矩形
- en: Writing text on the display
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示器上写文本
- en: Inverting colors on the display
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示器上反转颜色
- en: The Adafruit FeatherWing OLED
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adafruit FeatherWing OLED
- en: The FeatherWing OLED display uses an OLED that has a number of benefits compared
    to other display technologies. For example, it has a much lower power consumption
    than other display technologies. This makes it very useful for embedded projects,
    where the power requirements need to be kept as low as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FeatherWing OLED显示器使用了一种OLED，与其他显示技术相比有许多优点。例如，它的功耗比其他显示技术低得多。这使得它非常适用于嵌入式项目，其中需要尽可能降低功耗要求。
- en: 'OLEDs also have a much higher contrast ratio than other display technologies,
    making the text and graphics being displayed much clearer. The screen comes with
    three user buttons and has a number of different options in terms of headers and
    screen resolution. The following photograph shows one of these displays attached
    to an Adafruit Feather HUZZAH ESP8266 board:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OLED还具有比其他显示技术更高的对比度，使得显示的文本和图形更清晰。屏幕配备了三个用户按钮，并且在引脚和屏幕分辨率方面有许多不同的选项。以下照片显示了其中一个显示器连接到Adafruit
    Feather HUZZAH ESP8266板上：
- en: '![](assets/71a2df18-6864-4813-a115-e48db0e6c628.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/71a2df18-6864-4813-a115-e48db0e6c628.png)'
- en: The board comes in a configuration with loose headers that require soldering
    and another version with assembled headers that require no soldering. The board
    that is shown in the preceding photograph uses assembled headers and plugs right
    into the ESP8266 mainboard with no need for soldering.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该板有一个配置，带有需要焊接的松散引脚，另一个版本带有组装好的引脚，无需焊接。在上一张照片中显示的板使用了组装好的引脚，可以直接插入ESP8266主板，无需焊接。
- en: Where to buy it
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购买地址
- en: This chapter uses the Assembled Adafruit FeatherWing OLED – 128 x 32 OLED Add-on
    for Feather. This FeatherWing can be purchased directly from Adafruit ([https://www.adafruit.com/product/3045](https://www.adafruit.com/product/3045)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了组装好的Adafruit FeatherWing OLED - 128 x 32 OLED附加板。这个FeatherWing可以直接从Adafruit购买([https://www.adafruit.com/product/3045](https://www.adafruit.com/product/3045))。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found in the `Chapter13` folder of the
    following GitHub repository: [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下GitHub存储库的`Chapter13`文件夹中找到：[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266 board and the Assembled
    Adafruit FeatherWing OLED – 128 x 32 OLED Add-on for Feather board. CircuitPython
    3.1.2 was used for all the recipes in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了Adafruit Feather HUZZAH ESP8266板和组装好的Adafruit FeatherWing OLED - 128 x
    32 OLED附加板。本章中的所有配方都使用了CircuitPython 3.1.2。
- en: This chapter requires some specific modules from the CircuitPython library,
    and they will be mentioned at the beginning of each recipe. For details on downloading
    and extracting these libraries, you can refer to the *Updating the CircuitPython
    library* recipe from [Chapter 1](1c277918-6daf-4a83-8a06-6012ceda9ac1.xhtml),
    *Getting Started with MicroPython*. Version 20190212 of the CircuitPython library
    is used for all the recipes in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要CircuitPython库中的一些特定模块，它们将在每个配方的开头提到。有关下载和提取这些库的详细信息，您可以参考《使用MicroPython入门》中的*更新CircuitPython库*配方。本章中的所有配方都使用了20190212版本的CircuitPython库。
- en: Detecting button presses with GPIO pins
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO引脚检测按钮按下
- en: This recipe will demonstrate how to check the state of the three push buttons
    that come with the Adafruit FeatherWing OLED. We will poll each of these three
    buttons and continually print out their state so that we can detect the moment
    a button is pressed and when it is realized.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将演示如何检查Adafruit FeatherWing OLED附带的三个推按钮的状态。我们将轮询这三个按钮，并不断打印它们的状态，以便我们可以检测按钮被按下和释放的时刻。
- en: Each of these push buttons is attached to a different GPIO pin, so we will use
    a dictionary to map the button names to their associated GPIO pins. The physical
    buttons on the board are labeled *A*, *B*, and *C*. We will use the same naming
    to map the button events to print statements in the script.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些推按钮中的每一个都连接到不同的GPIO引脚，因此我们将使用一个字典将按钮名称映射到它们关联的GPIO引脚。板上的物理按钮标有*A*、*B*和*C*。我们将使用相同的命名将按钮事件映射到脚本中的打印语句。
- en: This recipe is useful because it will enable your project to take different
    actions, depending on which buttons are being pressed. Because there are three
    buttons on this board, you have a lot of options in terms of how you can design
    your application. For example, you could make two of the buttons up and down menu
    options, while the third button could allow users to choose a menu option. Alternatively,
    you could have one button that increases a setting value and another button that
    decreases a setting value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱很有用，因为它将使您的项目能够根据按下的按钮采取不同的操作。因为这个板上有三个按钮，所以您可以根据自己的应用设计有很多选择。例如，您可以将两个按钮作为上下菜单选项，而第三个按钮可以允许用户选择菜单选项。或者，您可以有一个按钮增加一个设置值，另一个按钮减少一个设置值。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本食谱中提供的代码。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have now imported the necessary Python libraries and have set up a `PINS`
    dictionary, which will map the button names to their associated GPIO pins as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经导入了必要的Python库，并设置了一个`PINS`字典，它将按钮名称映射到它们关联的GPIO引脚，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `get_buttons` function will return a dictionary that maps each button to
    its associated `Pin` object. On this board, buttons A and C require `PULL_UP`
    to be configured while button B does not. Run the following block of code and
    it will return a value of `1`, which indicates that button A is not pressed:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_buttons`函数将返回一个将每个按钮映射到其关联的`Pin`对象的字典。在这个板上，按钮A和C需要配置`PULL_UP`，而按钮B不需要。运行以下代码块，它将返回一个值`1`，表示按钮A没有被按下：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Hold down button A while running the next block of code, and the `Pin` value
    will show that the button is being pressed:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行下一段代码块时按住按钮A，`Pin`值将显示按钮正在被按下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next block of code creates the `names` list, which has a sorted list of
    the button names. We define a function called `get_status`, which will return
    the status of each of the three buttons:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码创建了`names`列表，其中包含按钮名称的排序列表。我们定义了一个名为`get_status`的函数，它将返回三个按钮的状态：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When run, the following block of code calls the `get_status` function and returns
    the current state of the push buttons:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时，以下代码块调用`get_status`函数并返回推按钮的当前状态：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hold down button B while running the next block of code and the status of push
    button B will show that it is being pressed:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行下一段代码块时按住按钮B，推按钮B的状态将显示为正在被按下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code should be added to the `main.py` file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应添加到`main.py`文件中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When this script is executed, it will continually print out the status of each
    of the buttons with a delay of `0.1` seconds between each loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个脚本时，它将不断打印出每个按钮的状态，每个循环之间延迟`0.1`秒。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe defines a data structure called `PINS`, which will map each of the
    three buttons to their correct GPIO pin on the ESP8266\. The `get_buttons` function
    creates `Pin` objects for each of these buttons with their correct `PULL_UP` settings.
    This `get_buttons` function is called in the `main` function and the returned
    dictionary is saved in the `buttons` variable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱定义了一个名为`PINS`的数据结构，它将三个按钮分别映射到ESP8266上的正确GPIO引脚。`get_buttons`函数为这些按钮中的每一个创建了带有正确`PULL_UP`设置的`Pin`对象。`get_buttons`函数在`main`函数中被调用，并且返回的字典被保存在`buttons`变量中。
- en: The `names` variable is simply the sorted list of button names. It is created
    to ensure that the status update is always presented in alphabetical order. The
    `get_status` function loops through each button and calls the `format` function
    to generate the status line, which gets printed out each time the status is checked.
    The main loop enters into an infinite loop, printing the button status in each
    iteration, and then pausing for `0.1` seconds before continuing to the next loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`names`变量只是按钮名称的排序列表。它被创建以确保状态更新总是按字母顺序呈现。`get_status`函数循环遍历每个按钮，并调用`format`函数生成状态行，每次检查状态时都会打印出来。主循环进入无限循环，在每次迭代中打印按钮状态，然后暂停`0.1`秒，然后继续下一个循环。'
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When using GPIO pins to interact with push buttons, they need to be properly
    configured. The correct pins need to be used and the `PULL_UP` settings need to
    be applied correctly to each pin configuration. These settings can usually be
    found with the board's documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用GPIO引脚与推按钮交互时，它们需要被正确配置。需要使用正确的引脚，并且需要正确应用`PULL_UP`设置到每个引脚配置中。这些设置通常可以在板的文档中找到。
- en: In the case of this board, the reason why push button B doesn't require a `PULL_UP`
    setting is that the button and hardware level have a 100k pull-up value included,
    and so that addresses the issue that the ESP8266 doesn't have an internal pull-up
    on pin 16\. However, the other two buttons do require `PULL_UP` to be set up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这块板上，按钮B不需要设置`PULL_UP`的原因是按钮和硬件电平已经包含了100k的上拉值，因此解决了ESP8266在引脚16上没有内部上拉的问题。然而，其他两个按钮需要设置`PULL_UP`。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following documentation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参考以下文档：
- en: More documentation on the FeatherWing OLED pinouts can be found at [https://learn.adafruit.com/adafruit-oled-featherwing/pinouts](https://learn.adafruit.com/adafruit-oled-featherwing/pinouts).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于FeatherWing OLED引脚分配的更多文档可以在[https://learn.adafruit.com/adafruit-oled-featherwing/pinouts](https://learn.adafruit.com/adafruit-oled-featherwing/pinouts)找到。
- en: Further documentation on the `Pin` object in the `machine` module can be found
    at [https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`machine`模块中的`Pin`对象的更多文档可以在[https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin)找到。
- en: Connecting to the SSD1306 display
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到SSD1306显示器
- en: This recipe will show you how to use the `adafruit_ssd1306` library to connect
    to the FeatherWing OLED display. The recipe will show you how to initialize the
    **Inter-Integrated Circuit** (**I2C**) bus that the OLED display is connected
    to. Then, we can create an `SSD1306_I2C` object that connects to the display using
    the I2C bus.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向你展示如何使用`adafruit_ssd1306`库连接到FeatherWing OLED显示器。本教程将向你展示如何初始化连接到的**I2C**总线。然后，我们可以创建一个通过I2C总线连接到显示器的`SSD1306_I2C`对象。
- en: This recipe will help you in a number of ways; there are a whole array of components
    that connect using I2C, so this recipe will give you exposure to this technology
    so that you are familiar with it whenever you need to use it in your own projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将在很多方面帮助你；有一整套组件可以使用I2C连接，所以这个教程将让你接触到这项技术，以便在你自己的项目中需要使用它时，你会对它很熟悉。
- en: You will gain an understanding of how to use a display library that can work
    with MicroPython, which can then be included in any projects that you might want
    to add a display to.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解如何使用可以与MicroPython一起工作的显示库，然后可以将其包含在任何你想要添加显示器的项目中。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. Version 20190212 of the CircuitPython library is used for this recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问ESP8266上的REPL来运行本教程中提供的代码。本教程使用的CircuitPython库版本是20190212。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: Download the CircuitPython library bundle. You will need both the `.mpy` and
    `.py` versions of the bundle.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载CircuitPython库包。你需要`.mpy`和`.py`版本的库包。
- en: Extract both of the `.zip` files to your computer.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个`.zip`文件解压到你的计算机上。
- en: It is not necessary to install all the libraries in the bundle on the ESP8266.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ESP8266上安装所有库包中的所有库是不必要的。
- en: Three specific libraries are required to connect to the display.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到显示器需要三个特定的库。
- en: The `adafruit_bus_device` and `adafruit_framebuf` libraries should have their
    `.mpy` files installed on the ESP8266\. The files for these libraries should be
    transferred to the ESP8266 and into the `.lib` folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`adafruit_bus_device`和`adafruit_framebuf`库应该在ESP8266上安装它们的`.mpy`文件。这些库的文件应该被传输到ESP8266并放入`.lib`文件夹中。'
- en: 'Execute the following code in the REPL to verify that these two libraries were
    installed correctly on the board:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码以验证这两个库是否正确安装在板上：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `adafruit_ssd1306` library should have the `.py` version of the `adafruit_ssd1306.py` file
    in the library.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`adafruit_ssd1306`库应该在库中有`adafruit_ssd1306.py`文件的`.py`版本。'
- en: The library will try to use the built-in `framebuf` MicroPython library instead
    of `adafruit_framebuf`. The library will fail to connect to the display if it
    uses the `framebuf` library for its frame buffer manipulation. To fix this issue,
    download and run the `fix_framebuf_import.py` file in the same directory as `adafruit_ssd1306.py`.
    You can find this script in the `Chapter13` folder of the book's GitHub repository.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该库将尝试使用内置的`framebuf` MicroPython库而不是`adafruit_framebuf`。如果使用`framebuf`库进行帧缓冲区操作，该库将无法连接到显示。为了解决这个问题，在与`adafruit_ssd1306.py`相同的目录中下载并运行`fix_framebuf_import.py`文件。你可以在书的GitHub存储库的`Chapter13`文件夹中找到这个脚本。
- en: Upload the fixed version of the `adafruit_ssd1306.py` file to the board's root
    directory.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修复后的`adafruit_ssd1306.py`文件上传到板的根目录。
- en: 'Run the following block of code to verify that the `adafruit_ssd1306` library
    was installed correctly on the board:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块以验证`adafruit_ssd1306`库是否正确安装在板上：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this stage, all additional libraries have been installed and imported successfully.
    Run the following block of code to import the libraries that are required to initialize
    the I2C bus:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，所有额外的库都已经成功安装和导入。运行以下代码块以导入初始化I2C总线所需的库：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the following block of code to initialize the I2C bus:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块以初始化I2C总线：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the following code to create an `SSD1306_I2C` display object:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码以创建一个`SSD1306_I2C`显示对象：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When this script gets executed, it will initialize the I2C bus and create an
    `SSD1306_I2C` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个脚本时，它将初始化I2C总线并创建一个`SSD1306_I2C`对象。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The libraries that are required to interact with the FeatherWing OLED are not
    a part of the CircuitPython firmware, so they require further installation before
    they can be used. Three libraries need to be installed, and they are called `adafruit_ssd1306`,
    `adafruit_bus_device`, and `adafruit_framebuf`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与FeatherWing OLED交互所需的库不是CircuitPython固件的一部分，因此在使用之前需要进一步安装。需要安装三个库，它们分别是`adafruit_ssd1306`、`adafruit_bus_device`和`adafruit_framebuf`。
- en: The `adafruit_ssd1306` library is the main library that we will interact with
    and it relies on the other libraries we have installed to work correctly. Once
    these libraries are installed, we can then start importing them and using their
    code to connect to the display. The first step is to initialize the I2C bus. This
    is done by creating an I2C object and passing it references to the SCL and SDA
    pins. The object is then saved in the `i2c` variable. An `SSD1306_I2C` object
    is created by passing it the values of `128` and `32`, which refer to the display
    resolution since we are using the 128 x 32 OLED. The other parameter that is passed
    is the `i2c` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`adafruit_ssd1306`库是我们将要交互的主要库，它依赖于我们已安装的其他库才能正常工作。安装这些库后，我们可以开始导入它们并使用它们的代码连接到显示器。第一步是初始化I2C总线。通过创建一个I2C对象并将其引用传递给SCL和SDA引脚来完成此操作。然后将对象保存在`i2c`变量中。通过传递值`128`和`32`来创建一个`SSD1306_I2C`对象，这些值是指显示分辨率，因为我们使用的是128
    x 32 OLED。传递的另一个参数是`i2c`对象。'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I2C is a very popular protocol for a whole range of devices. I2C is relatively
    simple to connect to and use, which is one of the reasons why it is widely used
    with many microcontrollers. It only requires two wires to connect to it and can
    use the general-purpose I/O pins that come with many microcontroller boards.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: I2C是一种非常流行的协议，适用于各种设备。 I2C相对简单，易于连接和使用，这是它被广泛用于许多微控制器的原因之一。它只需要两根线连接，并且可以使用许多微控制器板上的通用I/O引脚。
- en: A single connection can control multiple devices, which adds to its flexibility.
    One of the downsides of this protocol, however, is its low speeds compared to
    other protocols. This means that we can use it for a small monochrome display,
    but if we wanted to control a display with a higher resolution and more colors,
    then it wouldn't be fast enough.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单个连接可以控制多个设备，这增加了其灵活性。但是，与其他协议相比，这种协议的速度较慢是其缺点之一。这意味着我们可以用它来控制小型单色显示器，但是如果我们想要控制分辨率更高、颜色更多的显示器，那么它的速度就不够快了。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下内容：
- en: More details on the I2C protocol can be found at [https://i2c.info/](https://i2c.info/).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关I2C协议的更多详细信息，请访问[https://i2c.info/](https://i2c.info/)。
- en: Further documentation on installing the CircuitPython SSD1306 library can be
    found at [https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关安装CircuitPython SSD1306库的更多文档，请访问[https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup)。
- en: Filling and clearing the display
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充和清除显示
- en: This recipe will show you how to use the `adafruit_ssd1306` library to connect
    to the FeatherWing OLED display. It will demonstrate how to initialize the I2C
    bus that the OLED display is connected to. Then, we can create an `SSD1306_I2C`
    object that connects to the display using the I2C bus. This recipe will help you
    in a number of ways.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将向您展示如何使用`adafruit_ssd1306`库连接到FeatherWing OLED显示器。它将演示如何初始化连接到OLED显示器的I2C总线。然后，我们可以创建一个使用I2C总线连接到显示器的`SSD1306_I2C`对象。本教程将以多种方式帮助您。
- en: There are a whole array of components that can connect using I2C; this recipe
    will give you exposure to this technology so that you are familiar with it whenever
    you need to use it in your own projects. The recipe will also help you with the
    first steps for using a display library that can work with MicroPython, which
    can then be included in any projects that you might want to add a display to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一整套组件可以使用I2C连接；本教程将使您了解这项技术，以便在自己的项目中需要使用它时熟悉它。本教程还将帮助您进行使用可以与MicroPython一起工作的显示库的第一步，然后可以将其包含在您可能想要添加显示器的任何项目中。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The required libraries have now all been imported. Run the next block of code
    to create the `i2c` object and the `SSD1306_I2C` object called `oled`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的库现在都已导入。运行下一个代码块以创建`i2c`对象和名为`oled`的`SSD1306_I2C`对象：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using the following block of code, set all the pixels on the screen to the
    color white and apply the changes to the display by calling the `show` method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块，将屏幕上的所有像素设置为白色，并通过调用`show`方法应用更改：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will turn off all the pixels on the screen with the following block
    of code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下代码块关闭屏幕上的所有像素：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code block will loop 10 times and repeatedly turn all the pixels
    on the screen on and off, creating a blinking-screen effect:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将循环10次，并重复打开和关闭屏幕上的所有像素，创建闪烁屏幕的效果：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When this script gets executed, it will make the screen flash black and white
    10 times.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，屏幕将闪烁黑白10次。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `main` function first sets up the `i2c` object and saves the `SSD1306_I2C` object
    as a variable called `oled`. The `oled` object has two methods that we will use
    in this recipe. The `fill` method receives one argument and fills all the pixels
    on the display to either white or black. If `1` is provided, then the pixels will
    become white, otherwise, they will become black (or turned off).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数首先设置了`i2c`对象，并将`SSD1306_I2C`对象保存为名为`oled`的变量。`oled`对象有两种方法，我们将在本教程中使用。`fill`方法接收一个参数，并将显示器上的所有像素填充为白色或黑色。如果提供`1`，则像素将变为白色，否则将变为黑色（或关闭）。'
- en: The `show` method must be called after each change for the changes to take effect
    on the display. A `for` loop is started that will loop 10 times and turn the display
    all white and then all black during each iteration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次更改后必须调用`show`方法，以使更改在显示器上生效。开始一个`for`循环，循环10次，在每次迭代期间将显示器变为全白，然后变为全黑。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The two `fill` and `show` methods are great starting points for when you are
    interacting with the display, as they are relatively easy to use. Even though
    they seem simple, they are needed for a lot of operations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill`和`show`方法是与显示器交互时的绝佳起点，因为它们相对容易使用。尽管它们看起来很简单，但它们在许多操作中都是必需的。'
- en: In later recipes, we will explore how to draw lines, rectangles, and text. In
    all of these cases, we will need to call `show` for the changes to be rendered
    to the screen. We will also frequently call `fill` to clear the contents of the
    screen before we write or draw something new on the display.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的示例中，我们将探讨如何绘制线条、矩形和文本。在所有这些情况下，我们需要调用`show`来将更改呈现到屏幕上。我们还经常调用`fill`来清除屏幕上的内容，然后再在显示器上写入或绘制新内容。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下内容：
- en: Examples of using `fill` and `show` can be found at [https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html)找到使用`fill`和`show`的示例。
- en: Further documentation on the `SSD1306_I2C` object can be found at [https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`SSD1306_I2C`对象的更多文档可以在[https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html)找到。
- en: Setting pixels on the display
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示器上设置像素
- en: This recipe will demonstrate how to turn individual pixels on the screen on
    and off. The recipe starts by setting pixels with specific *x* and *y* coordinates
    to indicate on or off. Then, we'll create a simple animation that repeatedly draws
    pixels in a certain direction, and so creating a line that grows in length. We
    will place this simple line animation into its own function so that we can call
    it multiple times and create a type of zigzag line animation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将演示如何在屏幕上打开和关闭单个像素。该示例首先通过设置具有特定*x*和*y*坐标的像素来指示打开或关闭。然后，我们将创建一个简单的动画，重复在特定方向上绘制像素，从而创建一个不断增长长度的线条。我们将把这个简单的线条动画放入自己的函数中，以便我们可以多次调用它并创建一种锯齿线条动画。
- en: You will find this recipe useful for when you start controlling the display
    from your projects and want control over individual pixels. The operation of controlling
    individual pixels becomes the building block to produce ever more complex drawings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始控制显示器并希望控制单个像素时，您会发现这个示例非常有用。控制单个像素的操作成为生成更复杂图形的基本组件。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在ESP8266上访问REPL才能运行本示例中提供的代码。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Let''s perform the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the `BLACK` and `WHITE` constants, which represent the values for the
    two possible pixel colors. Then, set up the `i2c` and `oled` objects. The following
    block of code will clear the contents of the screen:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`BLACK`和`WHITE`常量，它们代表两种可能的像素颜色值。然后设置`i2c`和`oled`对象。以下代码块将清除屏幕上的内容：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following block of code will draw the pixel at (*x*, *y*), that is, position
    (`0`, `0`) for the color white:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将为白色绘制像素(*x*, *y*)，即位置(`0`, `0`)：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following block of code will turn the pixel off at position (`0`, `0`)
    by setting its color to black:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将关闭位置(`0`, `0`)处的像素，将其颜色设置为黑色：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code will set the color of the pixel at position (`10`, `30`)
    to white:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将把位置(`10`, `30`)处的像素颜色设置为白色：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code block will clear the screen, and then loop 10 times, setting
    a diagonal line of pixels on, one after the other, as an animation that will appear
    like a growing line:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将清除屏幕，然后循环10次，逐个设置对角线上的像素，形成一个看起来像是不断增长的线条的动画：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the following code block, define a function that will perform a line
    animation from a starting position of (`x`, `y`) and will then move steps in the
    *x* and *y* direction for a certain `count` of iterations:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块，定义一个函数，该函数将从起始位置(`x`, `y`)开始执行线条动画，然后在*x*和*y*方向上移动一定的`count`次数：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code block will clear the screen and call `animate_pixel` to
    draw a line from position (`0`, `0`) to (`30`, `30`), composed of 30 pixels:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块将清除屏幕并调用`animate_pixel`从位置(`0`, `0`)到(`30`, `30`)绘制由30个像素组成的线条：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following block of code will then draw a line from position (`30`, `30`)
    to (`60`, `0`). The line will continue where the last animation completed but
    move in a different direction:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，以下代码块将绘制从位置(`30`, `30`)到(`60`, `0`)的线条。该线条将在上一个动画完成的位置继续进行，但在不同的方向上移动：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now define a function called `zig_zag`, which will draw four line animations.
    Each one will continue from the point the last one finished at, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个名为`zig_zag`的函数，它将绘制四个线条动画。每个动画将从上一个动画完成的位置继续进行，如下所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the following block of code to clear the display and run the `zig_zag`
    line animation:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码块以清除显示并运行`zig_zag`线条动画：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When this script gets executed, it will draw four line animations in a zigzag
    pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将以锯齿状模式绘制四个线条动画。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After the `main` function has set up the `oled` object, it calls the `zig_zag`
    function. The `zig_zag` function makes four calls to the `animate_pixel` function.
    Each call moves the line in a different diagonal direction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数设置了`oled`对象之后，它调用`zig_zag`函数。`zig_zag`函数对`animate_pixel`函数进行了四次调用。每次调用都将线条移动到不同的对角方向。
- en: Each new line animation starts off where the last one finished so that it appears
    as one long animation from start to finish. The `animate_pixel` function takes
    a starting *x* and *y* position and loops for the number of iterations specified
    by the `count` variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的线条动画都从上一个动画结束的地方开始，因此看起来像是从开始到结束的一个长动画。`animate_pixel`函数接受起始的*x*和*y*位置，并循环执行由`count`变量指定的次数。
- en: In each loop iteration, the values of *x* and *y* are changed by the specified
    *x* and *y* step values. Once the new values are calculated, a pixel is drawn
    at that position and the `show` method is called to show it immediately.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，*x*和*y*的值会根据指定的*x*和*y*步长值进行更改。一旦计算出新值，就会在该位置绘制一个像素，并调用`show`方法立即显示它。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This recipe started off with a few simple examples of setting pixels on and
    off and the different positions on the display. Then, it expanded to do a simple
    animation and an even more involved zigzag animation. The following photograph
    shows what this animation looks like on the display once it is complete:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程从一些简单的设置像素开关和显示器上的不同位置的示例开始。然后，它扩展到进行简单的动画和更复杂的之字形动画。下面的照片展示了动画在显示器上完成后的样子：
- en: '![](assets/dcdf610e-0164-4693-ac71-673c54ae39f0.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dcdf610e-0164-4693-ac71-673c54ae39f0.png)'
- en: Many more different types of shapes and animations can be created by using the
    `math` module that comes with MicroPython. The `sine` and `cosine` functions can
    be used to draw wave animations. We can also use these trigonometric functions
    to draw circles and ellipses.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MicroPython附带的`math`模块可以创建许多不同类型的形状和动画。`sine`和`cosine`函数可用于绘制波形动画。我们还可以使用这些三角函数来绘制圆和椭圆。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下内容：
- en: More documentation on drawing pixels on the FeatherWing OLED can be found at
    [https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在FeatherWing OLED上绘制像素的更多文档可以在[https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage)找到。
- en: More documentation on the `sin` function in the `math` module can be found at [https://docs.micropython.org/en/latest/library/math.html#math.sin](https://docs.micropython.org/en/latest/library/math.html#math.sin).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`math`模块中`sin`函数的更多文档可以在[https://docs.micropython.org/en/latest/library/math.html#math.sin](https://docs.micropython.org/en/latest/library/math.html#math.sin)找到。
- en: Drawing lines and rectangles on the display
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示器上绘制线条和矩形
- en: This recipe will demonstrate how to use the methods that come with the `SSD1306_I2C`
    object, which will let us draw horizontal lines, vertical lines, squares, and
    rectangles. We can now move beyond setting individual pixels and explore drawing
    a wider range of shapes using the methods that come out of the box with the `adafruit_ssd1306`
    display library.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将演示如何使用`SSD1306_I2C`对象附带的方法，这将让我们绘制水平线、垂直线、正方形和矩形。现在我们可以超越设置单个像素，并探索使用`adafruit_ssd1306`显示库中的方法绘制更广泛范围的形状。
- en: You will find this recipe useful for when you want to draw some different shapes;
    for example, to build a simple user interface on the display. There is enough
    resolution on the display to draw a number of boxes and borders that represent
    different parts of your user interface.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要在显示器上绘制一些不同的形状时，您会发现这个教程很有用；例如，在显示器上构建一个简单的用户界面。显示器上有足够的分辨率来绘制代表用户界面不同部分的多个框和边框。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Execute the following block of code in the REPL:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行以下代码块：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The necessary modules are imported, `oled` is created, and then the display
    is cleared. Using the following block of code, draw a vertical line starting at
    coordinates (`0`, `0`) with a height of 20 pixels:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块，创建`oled`，然后清除显示器。使用下面的代码块，绘制一条从坐标（`0`，`0`）开始，高度为20像素的垂直线：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a similar fashion, draw a horizontal line starting at coordinates (`0`,
    `0`) with a width of 80 pixels:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，使用80像素宽度从坐标（`0`，`0`）开始绘制一条水平线：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A rectangle at position (`0`, `0`) having a width of 10 pixels and height of
    20 pixels can be drawn using the next block of code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用下一个代码块绘制一个位于（`0`，`0`）位置，宽度为10像素，高度为20像素的矩形：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following function will draw the `HI` text. The `H` character will be drawn
    using vertical lines and one horizontal line. The `I` character will then be drawn
    using a single vertical line:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数将绘制`HI`文本。`H`字符将使用垂直线和一条水平线绘制。然后使用单个垂直线绘制`I`字符：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code block will clear the screen and call the `draw_hi` function
    to render the message, `HI`, on the display:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块将清除屏幕并调用`draw_hi`函数在显示器上呈现消息`HI`：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using the following code block, define a function that will perform an animation
    involving boxes, which are of a certain size and are shifted in position by step
    *x* and *y* in each iteration:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下面的代码块，定义一个函数，该函数将执行涉及具有特定大小并且在每次迭代中通过步长*x*和*y*移动位置的方框动画：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, use the following code block to call `animate_boxes` and draw six boxes
    in a diagonal formation:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用下面的代码块调用`animate_boxes`并绘制六个方框以对角线形式：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define and call the `draw_x_boxes` function, which draws a set of boxes in
    two diagonal lines to create a large letter `X` made of small boxes:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并调用`draw_x_boxes`函数，该函数在两条对角线上绘制一组方框，以创建由小方框组成的大字母`X`：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When this script gets executed, it will draw a letter `X` made up of small boxes
    and draw the `HI` text, which is made of vertical and horizontal lines.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将绘制一个由小方块组成的字母`X`，并绘制由垂直和水平线组成的`HI`文本。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `draw_hi` function uses the `vline` and `hline` methods on the `oled` object
    to draw the three lines that will make up `H`. After the letter `H` is drawn,
    a vertical line is drawn using `vline` to represent the letter `I`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_hi`函数使用`oled`对象上的`vline`和`hline`方法来绘制构成`H`的三条线。在绘制字母`H`之后，使用`vline`绘制垂直线来表示字母`I`。'
- en: Calling the `draw_x_boxes` function will, in turn, call the `animate_boxes`
    function. The first call to the `animate_boxes` function draws six boxes in a
    diagonal direction to make the first part of the `X` character. The second call
    to `animate_boxes` also makes six boxes, but from a different starting position
    and going in a different direction. The second call will cut through the first
    line to form the `X` character.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`draw_x_boxes`函数将依次调用`animate_boxes`函数。对`animate_boxes`函数的第一次调用会沿对角线绘制六个方框，以形成`X`字符的第一部分。对`animate_boxes`的第二次调用也会绘制六个方框，但起始位置不同，并且方向也不同。第二次调用将穿过第一行以形成`X`字符。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The line drawing and rectangle drawing methods can be combined in many different
    ways to create all sorts of shapes and drawings. The following photograph shows
    what the display will look like once you run the `main.py` script in this recipe:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 线条绘制和矩形绘制方法可以以许多不同的方式组合，以创建各种形状和图纸。下面的照片显示了一旦在这个示例中运行`main.py`脚本，显示将会是什么样子：
- en: '![](assets/b17657f1-6db0-40b9-a81b-501a016c42e2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b17657f1-6db0-40b9-a81b-501a016c42e2.png)'
- en: In the next recipe, we will learn how to draw text on the display. It is very
    useful to combine box and line drawings and then render text on different parts
    of the display.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将学习如何在显示屏上绘制文本。将盒子和线条绘制结合起来，然后在显示屏的不同部分呈现文本非常有用。
- en: See also
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下内容：
- en: Further documentation on the main features of the FeatherWing OLED can be found
    at [https://learn.adafruit.com/adafruit-oled-featherwing/overview](https://learn.adafruit.com/adafruit-oled-featherwing/overview).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关FeatherWing OLED的主要功能的更多文档可以在[https://learn.adafruit.com/adafruit-oled-featherwing/overview](https://learn.adafruit.com/adafruit-oled-featherwing/overview)找到。
- en: More documentation on the `busio` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`busio`模块的更多文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html)找到。
- en: Writing text on the display
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示屏上写字
- en: This recipe will demonstrate how to write text output to the FeatherWing OLED.
    The recipe will show you how to control the position and content of the text to
    be displayed. A text animation will be created to perform a countdown on the display,
    and then a function will be created to show all lowercase, uppercase, and digit
    characters on the screen at the same time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将演示如何将文本输出到FeatherWing OLED。该示例将向您展示如何控制要显示的文本的位置和内容。将创建一个文本动画来执行显示倒计时，然后创建一个函数来同时显示所有小写字母、大写字母和数字字符。
- en: This recipe will help you whenever you have some information that you want to
    communicate with people using your devices. Because the display can show three
    rows of text, it gives a lot of room for presenting all sorts of information.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将在您希望使用您的设备与人们交流一些信息时帮助您。因为显示可以显示三行文本，所以它为呈现各种信息提供了很大的空间。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the followings steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: Download the CircuitPython library bundle.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载CircuitPython库包。
- en: Extract the bundle of `.zip` files to your computer.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.zip`文件包解压到您的计算机上。
- en: Copy the `font5x8.bin` font file, which is located in the bundle of the ESP8266
    root folder.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制位于ESP8266根文件夹包中的`font5x8.bin`字体文件。
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We now have the display cleared and are ready to show some text on the screen.
    Using the following block of code, display the `''hello''` text on the screen
    drawn at position (`0`, `0`) in the color white:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经清除了显示屏，并准备在屏幕上显示一些文本。使用以下代码块，在颜色为白色的位置（`0`，`0`）上显示`'hello'`文本：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use the following block of code to clear the screen and show three lines of
    text:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块清除屏幕并显示三行文本：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define a function and then call it; this will count down from the number 10
    to 0 on the display:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，然后调用它；这将在显示屏上从数字10倒数到0：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using the following block of code, define a constant called `ALPHA_NUMERIC`.
    It contains all the lowercase, uppercase, and digit characters, which are organized
    in a structure that will fit on the display:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块，定义一个名为`ALPHA_NUMERIC`的常量。它包含所有小写字母、大写字母和数字字符，这些字符以适合显示的结构组织在一起：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using the following block of code, define and call the `show_alpha_numeric` function,
    which loops through the `ALPHA_NUMERIC` list and shows each string on a separate
    line:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块，定义并调用`show_alpha_numeric`函数，该函数循环遍历`ALPHA_NUMERIC`列表，并在单独的行上显示每个字符串：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When this script gets executed, it will perform a count down animation and then
    display some alphanumeric text.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它将执行一个倒计时动画，然后显示一些字母数字文本。
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `countdown` function starts a `for` loop that will count from 10 to 0\.
    During each iteration, the screen is cleared and then the current number is displayed
    on the screen. The `ALPHA_NUMERIC` variable combines lowercase, uppercase, and
    digit characters in a format that is structured over three lines. The display
    can show 3 rows and 21 columns of text. This data fits within these limits so
    that all the characters can be displayed clearly without any cropping of text.
    The `countdown` function loops through each line of text and displays it at the
    correct position so that the 3 rows of text on the screen get filed correctly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`countdown`函数启动一个`for`循环，将从10倒数到0。在每次迭代期间，屏幕被清除，然后当前数字被显示在屏幕上。`ALPHA_NUMERIC`变量以一种结构化的格式结合了小写字母、大写字母和数字字符，分布在三行上。显示器可以显示3行21列的文本。这些数据符合这些限制，以便所有字符都可以清晰地显示，而不会裁剪文本。`countdown`函数循环遍历每行文本，并在正确的位置显示它，以便屏幕上的3行文本被正确填充。'
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The sky is the limit when it comes to what you can represent using textual
    output. The output you displayed could be as varied as sensor readings to the
    latest news headlines fetched live from the internet. The following photograph
    shows the display after the `show_alpha_numeric` function is called:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文本输出时，您可以代表各种内容，无限可能。您显示的输出可以是从传感器读数到实时从互联网获取的最新新闻标题。下面的照片显示了在调用`show_alpha_numeric`函数后显示的屏幕：
- en: '![](assets/efcd4925-a427-4cbe-939c-f805db778e89.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/efcd4925-a427-4cbe-939c-f805db778e89.png)'
- en: Even though the screen is physically quite small, it has a good resolution,
    and the font that comes with the CircuitPython library bundle has done a good
    job of using the limited screen space efficiently. This has made it possible to
    show three lines of text on a very small display.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管屏幕在物理上相当小，但它具有良好的分辨率，并且CircuitPython库包中提供的字体已经很好地利用了有限的屏幕空间。这使得在非常小的显示器上显示三行文本成为可能。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下内容：
- en: More documentation on a MicroPython project that creates an OLED watch can be
    found at [https://learn.adafruit.com/micropython-oled-watch](https://learn.adafruit.com/micropython-oled-watch).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/micropython-oled-watch](https://learn.adafruit.com/micropython-oled-watch)找到有关创建OLED手表的MicroPython项目的更多文档。
- en: Further documentation on the I2C communication protocol can be found at [https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)找到有关I2C通信协议的更多文档。
- en: Inverting colors on the display
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示器上反转颜色
- en: This recipe will demonstrate how to use the `invert` feature to flip the color
    of all the pixels. This can be used for when you are displaying white text on
    a black background, and then want the colors to be flipped so that the screen
    shows black text on a white background. A number of key operations on the display,
    such as clearing the screen, can be quite slow compared to features such as invert.
    We can take advantage of these performance differences to use invert when we want
    fast, visual feedback to appear to people using the screen.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将演示如何使用`invert`功能来翻转所有像素的颜色。当您在黑色背景上显示白色文本，然后希望颜色翻转，使屏幕显示白色背景上的黑色文本时，可以使用此功能。与清除屏幕等一些关键操作相比，`invert`等功能可能会慢得多。我们可以利用这些性能差异，当我们希望快速地向使用屏幕的人显示视觉反馈时使用`invert`。
- en: This recipe will help you whenever you are creating a project using a slow microcontroller
    and you need to find creative ways to make the device more responsive so that
    you can improve its usability.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将帮助您在使用缓慢的微控制器创建项目并需要找到创造性方法使设备更具响应性以改善其可用性时使用。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问ESP8266上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s perform the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the initial setup, the `oled` object is available for us to start inverting
    the screen. Use the following block of code to display some white text on a black
    background:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成初始设置后，`oled`对象可用于开始反转屏幕。使用以下代码块在黑色背景上显示一些白色文本：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The screen will now have black text on a white background. To flip the colors
    back, run the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕现在将显示白色背景上的黑色文本。要将颜色翻转回来，请运行以下代码：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `invert` feature is much faster than some of the other methods that are
    used to update the screen. Use the following function to time this speed difference:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`invert`功能比用于更新屏幕的其他一些方法快得多。使用以下函数来计算这种速度差异：'
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use the next block of code to call the `measure_time` function, and time how
    long the `fill` operation takes in milliseconds:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码块调用`measure_time`函数，并计算`fill`操作花费的时间（以毫秒为单位）：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now time the `show` method, and you will see that it is faster than `fill`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在计时`show`方法，你会发现它比`fill`更快：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Use the following code to check the speed of the `text` method:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查`text`方法的速度：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, the `invert` method has its speed checked, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查`invert`方法的速度如下：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following code to the `main.py` file:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.py`文件中：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When this script gets executed, it prints out the performance results for a
    number of screen-related operations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此脚本时，它会打印出与屏幕相关操作的性能结果。
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: The `measure_time` function, by default, loops for three rounds. It saves the
    current time in the `start` variable, calls the function being tested, and then
    calculates the total execution time of the function call. This value is converted
    into milliseconds and the result is then printed out. The `main` function calls
    `measure_time` four times. It calls it to measure the execution time of `fill`,
    `show`, `text`, and the `invert` method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`measure_time`函数默认循环三轮。它将当前时间保存在`start`变量中，调用被测试的函数，然后计算函数调用的总执行时间。该值转换为毫秒，然后打印出结果。`main`函数调用`measure_time`四次。它调用它来测量`fill`，`show`，`text`和`invert`方法的执行时间。'
- en: There's more...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Looking at the performance results, a number of things are quite evident. The
    good thing is that the results are pretty consistent. In this recipe, we have
    taken three readings for each measurement. It's always a good idea to take more
    than one sample when measuring execution speed. From the samples, it seems that
    a call to `fill` is approximately 500 times slower than a call to `invert`. For
    an application to feel responsive, operations shouldn't take more than 100 milliseconds,
    or it will appear to be sluggish or unresponsive. Operations such as `invert`,
    `text`, and `show` perform at a good speed. But since `fill` takes so long, we
    might want to call `invert` before performing `fill` so that users get a sign
    that our application is responding to their inputs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能结果来看，有一些事情是非常明显的。好消息是结果非常一致。在这个示例中，我们对每个测量都进行了三次读数。在测量执行速度时，最好取多个样本。从样本中看，调用`fill`大约比调用`invert`慢500倍。为了使应用程序感觉灵敏，操作不应该超过100毫秒，否则它会显得迟钝或无响应。像`invert`，`text`和`show`这样的操作速度很快。但由于`fill`时间太长，我们可能希望在执行`fill`之前调用`invert`，以便用户得到我们的应用程序正在响应他们输入的迹象。
- en: See also
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information, you can refer to the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅以下内容：
- en: More documentation on a CircuitPython project that uses the OLED display and
    the ESP8266 can be found at [https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend](https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用OLED显示屏和ESP8266的CircuitPython项目的更多文档，请访问[https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend](https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend)。
- en: Further details on OLEDs can be found at [https://www.oled-info.com/oled-introduction](https://www.oled-info.com/oled-introduction).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关OLED的更多详细信息，请访问[https://www.oled-info.com/oled-introduction](https://www.oled-info.com/oled-introduction)。
