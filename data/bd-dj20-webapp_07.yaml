- en: Searching for Questions with Elasticsearch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elasticsearch搜索问题
- en: Now that users can ask and answer questions, we'll add a search functionality
    to Answerly to help users find questions. Our search will be powered by Elasticsearch.
    Elasticsearch is a popular open source search engine powered by Apache Lucene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以提问和回答问题，我们将为Answerly添加搜索功能，以帮助用户找到问题。我们的搜索将由Elasticsearch提供支持。Elasticsearch是一个由Apache
    Lucene提供支持的流行的开源搜索引擎。
- en: 'In the chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Create an Elasticsearch service to abstract our code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Elasticsearch服务来抽象我们的代码
- en: Bulk load existing `Question` model instances into Elasticsearch
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量加载现有的`Question`模型实例到Elasticsearch
- en: Build a search view powered by Elasticsearch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建由Elasticsearch提供支持的搜索视图
- en: Save new models into Elasticsearch automatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动将新模型保存到Elasticsearch
- en: Let's start by setting up our project to use Elasticsearch.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置我们的项目以使用Elasticsearch。
- en: Starting with Elasticsearch
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Elasticsearch开始
- en: Elasticsearch is maintained by Elastic, though the server is open source. Elastic
    offers proprietary plugins to make running it in production easier. You can run
    Elasticsearch yourself or use a SaaS provider, such as Amazon, Google, or Elastic.
    In development, we'll run Elasticsearch using a Docker image provided by Elastic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch由Elastic维护，尽管服务器是开源的。Elastic提供专有插件，以使在生产中运行更容易。您可以自己运行Elasticsearch，也可以使用Amazon、Google或Elastic等SaaS提供商。在开发中，我们将使用Elastic提供的Docker镜像运行Elasticsearch。
- en: Elasticsearch is made up of zero or more indexes. Each index contains documents.
    Documents are the objects that one searches for. A document is made of up fields.
    Fields are indexed by Apache Lucene. Each index is also split up into one or more
    shards to make indexing and searching faster by distributing it across nodes in
    a cluster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch由零个或多个索引组成。每个索引包含文档。文档是搜索的对象。文档由字段组成。字段由Apache Lucene索引。每个索引还分成一个或多个分片，通过在集群中的节点之间分发来加快索引和搜索速度。
- en: We can interact with Elasticsearch using its RESTful API. Most requests and
    responses are in JSON by default.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其RESTful API与Elasticsearch进行交互。大多数请求和响应默认都是JSON格式。
- en: First, let's start by getting an Elasticsearch server running in Docker.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在Docker中运行Elasticsearch服务器来开始。
- en: Starting an Elasticsearch server with docker
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用docker启动Elasticsearch服务器
- en: The simplest way to get an Elasticsearch server running is using the Docker
    image that Elastic provides.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Elasticsearch服务器的最简单方法是使用Elastic提供的Docker镜像。
- en: 'To obtain and start the Elasticsearch docker image, run the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取并启动Elasticsearch docker镜像，请运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following command does four things, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行四个操作，如下所示：
- en: It downloads the Elasticsearch 6.0 docker image from Elastic's servers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从Elastic的服务器下载Elasticsearch 6.0 docker镜像
- en: It runs a container using the Elasticsearch 6.0 docker image as a single node
    cluster
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Elasticsearch 6.0 docker镜像作为单节点集群运行容器
- en: It detaches (`-d`) the docker command from the running container (so that we
    can run more commands in our shell)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将docker命令从运行的容器中分离（这样我们就可以在我们的shell中运行更多命令）
- en: It opens ports (`-p`) `9200` and `9300` on the host computer and redirects them
    to the container
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在主机计算机上打开端口（`-p`）`9200`和`9300`，并将它们重定向到容器
- en: 'To confirm that our server is running, we can make the following request to
    the Elasticsearch server:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认我们的服务器正在运行，我们可以向Elasticsearch服务器发出以下请求：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When interacting with Elasticsearch yourself, always add the `pretty` `GET`
    parameter to have Elasticsearch print the JSON. However, don't use this parameter
    in your code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与Elasticsearch交互时，始终添加`pretty` `GET`参数，以便Elasticsearch打印JSON。但是，在代码中不要使用此参数。
- en: Now that we have our Elasticsearch server, let's configure Django to know about
    our server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Elasticsearch服务器，让我们配置Django以了解我们的服务器。
- en: Configuring Answerly to use Elasticsearch
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Answerly以使用Elasticsearch
- en: Next, we'll update our `settings.py` and `requirements.txt` files to work with
    Elasticsearch.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的`settings.py`和`requirements.txt`文件，以便与Elasticsearch一起使用。
- en: 'Let''s update `django/config/settings.py`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/config/settings.py`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are custom settings that our app will use. Django has no built-in support
    for Elasticsearch. Instead, we’ll reference these settings in our own code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的应用程序将使用的自定义设置。Django没有内置对Elasticsearch的支持。相反，我们将在我们自己的代码中引用这些设置。
- en: 'Let''s add the Elasticsearch library to our `requirements.txt` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Elasticsearch库添加到我们的`requirements.txt`文件中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the official Elasticsearch Python library published by Elastic. This
    library offers a low-level interface that looks much like the RESTful API we can
    use with cURL. This means that we can easily build a query on the command line
    with cURL and then convert the JSON to a Python `dict`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Elastic发布的官方Elasticsearch Python库。该库提供了一个低级接口，看起来很像我们可以用cURL与之一起使用的RESTful
    API。这意味着我们可以轻松地在命令行上使用cURL构建查询，然后将JSON转换为Python`dict`。
- en: Elastic also offers a higher-level, more Pythonic API called `elasticsearch-dsl`.
    It includes a pseudo-ORM to write a more Pythonic persistence layer. This may
    be a good option if your project includes a lot of Elasticsearch code. However,
    the low-level API closely mirrors the RESTful API, making it easier to reuse code
    and get assistance from the Elasticsearch community.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic还提供了一个更高级、更Pythonic的API，称为`elasticsearch-dsl`。它包括一个伪ORM，用于编写更Pythonic的持久层。如果您的项目包含大量Elasticsearch代码，这可能是一个不错的选择。但是，低级API与RESTful
    API密切对应，这使得重用代码并从Elasticsearch社区获得帮助更容易。
- en: Next, let's create the Answerly index in our Elasticsearch server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的Elasticsearch服务器中创建Answerly索引。
- en: Creating the Answerly index
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Answerly索引
- en: 'Let''s create an index in Elasticsearch by sending a `PUT` request to our server:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向服务器发送`PUT`请求来在Elasticsearch中创建索引：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! Now, we can load our existing `Question` model instances into our Elasticsearch
    index.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以将现有的`Question`模型实例加载到我们的Elasticsearch索引中。
- en: Loading existing Questions into Elasticsearch
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现有的问题加载到Elasticsearch中
- en: Adding a search feature means that we will need to load our existing `Question` model
    instances into Elasticsearch. The simplest way to solve a problem like this is
    by adding a `manage.py` command. Custom `manage.py` commands combine the simplicity
    of writing a regular Python script with the power of the Django API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加搜索功能意味着我们需要将现有的`Question`模型实例加载到Elasticsearch中。解决这样的问题最简单的方法是添加一个`manage.py`命令。自定义的`manage.py`命令将普通Python脚本的简单性与Django
    API的强大功能结合起来。
- en: Before we add our `manage.py` command, we will need to write our Elasticsearch-specific
    code. To separate the Elasticsearch code from our Django code, we'll add an `elasticsearch`
    service to the `qanda` app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`manage.py`命令之前，我们需要编写我们的特定于Elasticsearch的代码。为了将Elasticsearch代码与Django代码分离，我们将在`qanda`应用程序中添加一个`elasticsearch`服务。
- en: Creating the Elasticsearch service
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Elasticsearch服务
- en: Much of the code that we'll be writing in this chapter will be Elasticsearch
    specific. We don't want to put that code in our views (or `manage.py` commands)
    because that would introduce coupling between two unrelated components. Instead,
    we'll isolate the Elasticsearch code into its own module inside `qanda`, then
    have our views and `manage.py` command call our service module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将编写的大部分代码都是特定于Elasticsearch的。我们不希望将该代码放在我们的视图（或`manage.py`命令）中，因为这将在两个不相关的组件之间引入耦合。相反，我们将把Elasticsearch代码隔离到`qanda`中的自己的模块中，然后让我们的视图和`manage.py`命令调用我们的服务模块。
- en: The first function we'll create will bulk load `Question` model instances into
    Elasticsearch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个函数将批量加载`Question`模型实例到Elasticsearch中。
- en: 'Let''s create a separate file for our Elastic Service code. We''ll put our
    bulk insert code into `django/qanda/service/elasticsearch.py`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Elastic服务代码创建一个单独的文件。我们将把我们的批量插入代码放入`django/qanda/service/elasticsearch.py`中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've created two functions in our new service, `get_client()` and `bulk_load()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新服务中创建了两个函数，`get_client()`和`bulk_load()`。
- en: The  `get_client()`  function will return an `Elasticcearch` client configured
    with values from `settings.py`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_client()`函数将返回一个从`settings.py`中配置的`Elasticcearch`客户端。'
- en: The `bulk_load()` function takes an iterable collection of `Question` model
    instances and loads them into Elasticsearch using the `streaming_bulk()` helper.
    Since `bulk_load()` expects an iterable collection, this means that our `manage.py`
    command will be able to send a `QuerySet` object. Remember that even though we're
    using a generator expression (which is lazy), our `questions` parameter will execute
    the full query as soon as we try to iterate over it. It's only the execution of
    the `as_elasticsearch_dict()` method that will be lazy. We'll write and discuss
    the new `as_elasticsearch_dict()` method after we're finished looking at the `bulk_load()` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`bulk_load()`函数接受一个`Question`模型实例的可迭代集合，并使用`streaming_bulk()`助手将它们加载到Elasticsearch中。由于`bulk_load()`期望一个可迭代的集合，这意味着我们的`manage.py`命令将能够发送一个`QuerySet`对象。请记住，即使我们使用了生成器表达式（它是惰性的），我们的`questions`参数也会在我们尝试迭代它时执行完整的查询。只有`as_elasticsearch_dict()`方法的执行是惰性的。我们将在完成查看`bulk_load()`函数后编写并讨论新的`as_elasticsearch_dict()`方法。'
- en: 'Next, the `bulk_load()` function uses the `streaming_bulk()` function. The
    `streaming_bulk()` function takes four arguments and returns an iterator for reporting
    the progress of the load. The four arguments are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`bulk_load()`函数使用`streaming_bulk()`函数。`streaming_bulk()`函数接受四个参数并返回一个用于报告加载进度的迭代器。四个参数如下：
- en: An `Elasticsearch` client
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Elasticsearch`客户端
- en: Our `Question` generator (an iterator)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`Question`生成器（迭代器）
- en: The index name
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引名称
- en: A flag telling the function not to raise an exception in case of an error (this
    will cause the `ok` variable to be `False` in case of errors)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标志，告诉函数在出现错误时不要引发异常（这将导致`ok`变量在出现错误时为`False`）
- en: The body of our `for` loop will log if there's an error when loading a question.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`for`循环的主体将在加载问题时出现错误时记录日志。
- en: Next, let's give `Question` a method that can convert it into a `dict` that
    Elasticsearch can correctly process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给`Question`一个方法，可以将其转换为Elasticsearch可以正确处理的`dict`。
- en: 'Let''s update the `Question` model:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`Question`模型：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `as_elasticsearch_dict()` method turns a `Question` model instance into
    a dict suitable for loading into Elasticsearch. The following are the three fields
    that we specially add to our Elasticsearch dict that aren’t in our model:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_elasticsearch_dict()`方法将`Question`模型实例转换为适合加载到Elasticsearch中的字典。以下是我们特别添加到Elasticsearch字典中的三个字段，这些字段不在我们的模型中：'
- en: '`_id`: This is the ID of the Elasticsearch document. This doesn''t have to
    be the same as the model ID. However, if we want to be able to update the Elasticsearch
    document representing a `Question`, then we need to either store the document''s
    `_id` or be able to calculate it. For simplicity''s sake, we just use the same
    ID.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_id`：这是Elasticsearch文档的ID。这不一定要与模型ID相同。但是，如果我们想要能够更新代表“问题”的Elasticsearch文档，那么我们需要存储文档的`_id`或能够计算它。为简单起见，我们只使用相同的ID。'
- en: '`_type`: This is the document''s mapping type. As of Elasticsearch 6, Elasticsearch
    indexes are only able to store one mapping type each. So, all documents in the
    index should have the same `_type` value. Mapping types are similar to database
    schema''s, telling Elasticsearch how to index and track a document and its fields.
    One of the convenient features of Elasticsearch is that it doesn''t require us
    to define our type ahead of time. Elasticsearch dynamically builds the document''s
    type based on the data we load.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_type`：这是文档的映射类型。截至Elasticsearch 6，Elasticsearch索引只能存储一个映射类型。因此，索引中的所有文档应该具有相同的`_type`值。映射类型类似于数据库模式，告诉Elasticsearch如何索引和跟踪文档及其字段。Elasticsearch的一个便利功能是，它不要求我们提前定义类型。Elasticsearch会根据我们加载的数据动态构建文档的类型。'
- en: '`text`: This is a field we will create in the document. For search, it''s convenient
    to have the title and body of the document together in an indexable field.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这是我们将在文档中创建的一个字段。对于搜索来说，将文档的标题和正文放在一个可索引的字段中是很方便的。'
- en: The rest of the fields in the dictionary are the same as the model's fields.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的其余字段与模型的字段相同。
- en: The presence of `as_elasticsearch_dict()` as a model method may seem problematic.
    Shouldn't the `elasticsearch` service know how to convert a `Question` in to an
    Elasticsearch dict? Like many design questions, the answer depends on a variety
    of factors. One factor that influenced me adding this method to the model is Django's
    *fat models* philosophy. Generally, Django encourages writing operations on the
    model as model methods. Also, the properties of this dict are coupled to the model's
    fields. Keeping both the lists of fields close together makes it easier for future
    developers to keep the two lists in sync. However, there may be projects and contexts
    in which the right thing is to put this kind of function in the service module.
    As Django developers, it's our job to evaluate the trade-offs and make the best
    decision for a particular project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模型方法的`as_elasticsearch_dict()`的存在可能会有问题。`elasticsearch`服务不应该知道如何将`Question`转换为Elasticsearch字典吗？像许多设计问题一样，答案取决于各种因素。影响我将此方法添加到模型中的一个因素是Django的*fat
    models*哲学。通常，Django鼓励在模型方法上编写操作。此外，此字典的属性与模型的字段耦合。将这两个字段列表保持紧密联系使未来的开发人员更容易保持两个列表同步。然而，在某些项目和环境中，将这种函数放在服务模块中可能是正确的选择。作为Django开发人员，我们的工作是评估权衡并为特定项目做出最佳决策。
- en: Now that our `elasticsearch` service knows how to bulk add `Questions`, let's
    expose that functionality with a `manage.py` command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`elasticsearch`服务知道如何批量添加`Questions`，让我们用`manage.py`命令暴露这个功能。
- en: Creating a manage.py command
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个manage.py命令
- en: We've used `manage.py` commands to start projects and apps as well as create
    and run migrations. Now, we'll create a custom command to load all the questions
    in our project into an Elasticsearch server. This will be a simple introduction
    to Django management commands. We'll discuss the topic more in [Chapter 12](ae91eed9-a595-4233-9215-6edc0c43918c.xhtml),
    *Building an API*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`manage.py`命令来启动项目和应用程序，以及创建和运行迁移。现在，我们将创建一个自定义命令，将我们项目中的所有问题加载到Elasticsearch服务器中。这将是对Django管理命令的简单介绍。我们将在[第12章](ae91eed9-a595-4233-9215-6edc0c43918c.xhtml)中更详细地讨论这个主题，*构建API*。
- en: A Django management command must be in an app's `manage/commands` subdirectory.
    An app may have multiple commands. Each command will be called the same as its
    filename. Inside the file should be a `Command` class that subclasses `django.core.management.BaseCommand`.
    The code that it should execute should be in the `handle()` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Django管理命令必须位于应用程序的`manage/commands`子目录中。一个应用程序可以有多个命令。每个命令的名称与其文件名相同。文件内部应该有一个继承`django.core.management.BaseCommand`的`Command`类，它应该执行的代码应该在`handle()`方法中。
- en: 'Let''s create our command in `django/qanda/management/commands/load_questions_into_elastic_search.py`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/qanda/management/commands/load_questions_into_elastic_search.py`中创建我们的命令：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When designing commands, we should think of them as views, that is, *Fat models,
    thin commands*. This may be a bit more complicated, as there isn't a separate
    template layer for command-line output, but our output shouldn't be very complex
    anyway.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计命令时，我们应该将它们视为视图，即*Fat models, thin commands*。这可能会更复杂一些，因为命令行输出没有单独的模板层，但我们的输出也不应该很复杂。
- en: In our case, the `handle()` method gets a `QuerySet` of all `Questions` then
    passes it to `elasticsearch.bulkload`. We then print out whether it was successful
    or not using helper methods of `Command`. These helper methods are preferred over
    using `print()` directly because they make writing tests easier. We'll cover this
    topic in greater detail in our next chapter, [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`handle()`方法获取所有`Questions`的`QuerySet`，然后将其传递给`elasticsearch.bulkload`。然后我们使用`Command`的辅助方法打印出是否成功或不成功。这些辅助方法优于直接使用`print()`，因为它们使编写测试更容易。我们将在下一章[第8章](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml)中更详细地讨论这个主题，*测试Answerly*。
- en: 'Let''s run the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With all the questions loaded, let’s confirm that they’re in our Elasticsearch
    server. We can access the Elasticsearch server using `curl` to confirm that our
    questions have been loaded:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有问题加载完毕后，让我们确认它们是否在我们的Elasticsearch服务器中。我们可以使用`curl`访问Elasticsearch服务器，以确认我们的问题已经加载：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Assuming your ElasticSearch server is running on localhost on port 9200, the
    preceding command will return all the data in the `answerly` index. We can review
    the results to confirm that our data has been successfully loaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的ElasticSearch服务器在本地主机的端口9200上运行，上述命令将返回`answerly`索引中的所有数据。我们可以查看结果来确认我们的数据已成功加载。
- en: Now that we have some questions in Elasticsearch, let's add a search view.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在Elasticsearch中有一些问题，让我们添加一个搜索视图。
- en: Creating a search view
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个搜索视图
- en: 'In this section, we''ll create a view that will let users search our `Question`s
    and will display the matching results. To achieve this result, we will do the
    following things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个视图，让用户搜索我们的`Question`并显示匹配的结果。为了实现这个结果，我们将做以下事情：
- en: Add a `search_for_question()` function to our `elasticsearch` service
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`elasticsearch`服务中添加一个`search_for_question()`函数
- en: Make a search view
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个搜索视图
- en: Make a template to display search results
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板来显示搜索结果
- en: Update the base template to have search available everywhere
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新基本模板以使搜索在任何地方都可用
- en: Let's start by adding search to our `elasticsearch` service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的`elasticsearch`服务添加搜索开始。
- en: Creating a search function
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个搜索功能
- en: The responsibility for querying our Elasticsearch server for a list of questions
    matching the user's query lies with our `elasticsearch` service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查询我们的Elasticsearch服务器以获取与用户查询匹配的问题列表的责任属于我们的`elasticsearch`服务。
- en: 'Let''s add a function that will send a search query and parse the results to
    `django/qanda/service/elasticsearch.py`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个函数，将搜索查询发送到`django/qanda/service/elasticsearch.py`并解析结果：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we connect with the client, we will send our query and parse the results.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 连接客户端后，我们将发送我们的查询并解析结果。
- en: Using the client's `search()` method, we send the query as a Python `dict` in
    the Elasticsearch Query DSL (domain-specific language). The Elasticsearch Query
    DSL provides a language for querying Elastic search using a series of nested objects.
    When sent by HTTP, the query becomes a series of nested JSON objects. In Python,
    we use `dict` s.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端的`search()`方法，我们将查询作为Python `dict`发送到Elasticsearch Query DSL（领域特定语言）中。Elasticsearch
    Query DSL提供了一个用于使用一系列嵌套对象查询Elasticsearch的语言。通过HTTP发送时，查询变成一系列嵌套的JSON对象。在Python中，我们使用`dict`。
- en: In our case, we're using a `match` query on the `text` field of the documents
    in the Answerly index. A `match` query is a fuzzy query that checks each document’s
    `text` field to check whether it matches. The Query DSL also supports a number
    of configuration options to let you build more complex queries. In our case, we
    will accept the default fuzzy configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们在Answerly索引的文档的`text`字段上使用了`match`查询。`match`查询是一个模糊查询，检查每个文档的`text`字段是否匹配。查询DSL还支持许多配置选项，让您构建更复杂的查询。在我们的情况下，我们将接受默认的模糊配置。
- en: Next, `search_for_questions` iterates over the results. Elasticsearch returns
    a lot of metadata describing the number of results, the quality to the match,
    and the resulting document. In our case, we will return an iterator of the matching
    documents (stored in`_source`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`search_for_questions`遍历结果。Elasticsearch返回了大量描述结果数量、匹配质量和结果文档的元数据。在我们的情况下，我们将返回匹配文档的迭代器（存储在`_source`中）。
- en: Now that we can get our results from Elasticsearch, we can write our `SearchView`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从Elasticsearch获取结果，我们可以编写我们的`SearchView`。
- en: Creating the SearchView
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SearchView
- en: Our `SearchView` will take a `GET` parameter `q` and perform a search using
    our service module’s `search_for_questions()` function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SearchView`将使用`GET`参数`q`并使用我们的服务模块的`search_for_questions()`函数进行搜索。
- en: 'We''ll build our `SearchView` using a `TemplateView`. `TemplateView` renders
    a template in response to `GET` requests. Let''s add `SearchView` to `django/qanda/views.py`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TemplateView`构建我们的`SearchView`。`TemplateView`在响应`GET`请求时呈现模板。让我们将`SearchView`添加到`django/qanda/views.py`中：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we''ll add a `path()` object routing to our `SearchView` to our URLConf
    in `django/qanda/urls.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`django/qanda/urls.py`的URLConf中添加一个`path()`对象路由到我们的`SearchView`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have our our view, let's build our `search.html` template.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的视图，让我们构建我们的`search.html`模板。
- en: Creating the search template
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建搜索模板
- en: 'We''ll put our search template in `django/qanda/templates/qanda/search.html`,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把搜索模板放在`django/qanda/templates/qanda/search.html`中，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the body of the template, we have a search form that displays the query.
    If there was a `query`, then we will also show its results (if any).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的正文中，我们有一个显示查询的搜索表单。如果有`query`，那么我们也将显示其结果（如果有的话）。
- en: We have seen many of the tags we are using here before (for example, `for`,
    `if`, `url`, and `markdownify`). A new filter that we will add is `truncate_words_html`,
    which receives text via the pipe and a number as an argument. It will truncate
    the text to the provided number of words (not counting HTML tags) and close any
    open HTML tags in the resulting fragment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在这里使用过许多标签（例如`for`，`if`，`url`和`markdownify`）。我们将添加一个新的过滤器`truncate_words_html`，它通过管道接收文本和一个数字作为参数。它将把文本截断为提供的单词数（不包括HTML标记），并关闭结果片段中的任何打开的HTML标记。
- en: The result of this template is a list of hits that match our query with a preview
    of the text of each question. Since we stored the body, title, and ID of the question
    in Elasticsearch, we are able to show the results without querying our normal
    database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的结果是一个与我们的查询匹配的命中列表，每个问题的文本预览。由于我们在Elasticsearch中存储了问题的正文、标题和ID，我们能够在不查询我们的常规数据库的情况下显示结果。
- en: Next, let's update our base template to let users search from every page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新基础模板，让用户可以从任何页面进行搜索。
- en: Updating the base template
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新基础模板
- en: 'Let''s update the base template to let users search from anywhere. To do that,
    we''ll need to edit `django/templates/base.html`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新基础模板，让用户可以从任何地方进行搜索。为此，我们需要编辑`django/templates/base.html`：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we've got the search form in our header on every page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在每个页面的页眉中有了搜索表单。
- en: With our search complete, let's make sure that every new question is automatically
    added to Elasticsearch.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成搜索后，让我们确保每个新问题都会自动添加到Elasticsearch中。
- en: Adding Questions into Elasticsearch on save()
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在保存时将问题添加到Elasticsearch中
- en: The best way to perform an operation that is each time a model is saved to override
    the `save()` method that the model inherits from `Model`. We will provide a custom
    `Question.save()` method to make sure that `Question`s are added and updated in
    ElasticSearch as soon as they're saved by the Django ORM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每次保存模型时执行操作的最佳方法是覆盖模型从`Model`继承的`save()`方法。我们将提供自定义的`Question.save()`方法，以确保`Question`在被Django
    ORM保存时立即添加和更新到ElasticSearch中。
- en: You can still perform an operation when a Django model is saved even if you
    don’t control the source code of that model. Django offers a signals dispatcher
    ([https://docs.djangoproject.com/en/2.0/topics/signals/](https://docs.djangoproject.com/en/2.0/topics/signals/))
    that lets you listen for events on models you don't own. However, signals introduce
    a lot of complexity into your code. It's *discouraged* to use signals unless there
    is no other option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不控制该模型的源代码，您仍然可以在保存Django模型时执行操作。Django提供了一个信号分发器（[https://docs.djangoproject.com/en/2.0/topics/signals/](https://docs.djangoproject.com/en/2.0/topics/signals/)），让您可以监听您不拥有的模型上的事件。但是，信号会给您的代码引入大量复杂性。除非没有其他选择，否则*不建议*使用信号。
- en: 'Let''s update our `Queston` model in `django/qanda/models.py`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/qanda/models.py`中的`Queston`模型：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `save()` method is called by `CreateView`, `UpdateView`, `QuerySet.create()`,
    `Manager.create()`, and most third-party code to persist a model. We make sure
    to call our `upsert()` method after the original `save()` method has returned
    because we want our model to have an `id` attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法被`CreateView`，`UpdateView`，`QuerySet.create()`，`Manager.create()`和大多数第三方代码调用以持久化模型。我们确保在原始`save()`方法返回后调用我们的`upsert()`方法，因为我们希望我们的模型有一个`id`属性。'
- en: Now, let's create our Elasticsearch service's `upsert` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的Elasticsearch服务的`upsert`方法。
- en: Measuring code coverage
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量代码覆盖率
- en: '**Code coverage** measures which lines of code have been executed during a
    test. Ideally, by tracking code coverage, we can ensure which code is tested and
    which code is not. Since Django projects are mainly Python, we can use Coverage.py
    to measure our code coverage. The following are the two caveats for Django projects:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖**测量了测试期间执行的代码行。理想情况下，通过跟踪代码覆盖，我们可以确保哪些代码经过了测试，哪些代码没有。由于Django项目主要是Python，我们可以使用Coverage.py来测量我们的代码覆盖率。以下是Django项目的两个注意事项：'
- en: Coverage.py won't be able to measure the coverage of our templates (they're
    not Python)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coverage.py无法测量我们的模板的覆盖范围（它们不是Python）
- en: Untested class-based views seem more covered than they are
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经测试的基于类的视图似乎比它们实际覆盖的要多
- en: 'Finding the coverage of a Django app is a two-step process:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查找Django应用程序的覆盖范围是一个两步过程：
- en: Running our tests with the `coverage` command
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage`命令运行我们的测试
- en: Generating a coverage report using `coverage report` or `coverage html`
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`coverage report`或`coverage html`生成覆盖报告
- en: 'Let''s run Django''s unit `test` command with `coverage` to take a look at
    the baseline for an untested project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`coverage`运行Django的单元`test`命令，查看未经测试的项目的基线：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command tells `coverage` to run a command (in our case, `manage.py
    test`) to record test coverage. We will use this command with the following two
    options:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令告诉`coverage`运行一个命令（在我们的情况下是`manage.py test`）来记录测试覆盖率。我们将使用此命令和以下两个选项：
- en: '`--branch`: To track whether both parts of branching statements were covered
    (for example, when an `if` statement evaluated to `True` and `False`)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--branch`：跟踪分支语句的两个部分是否都被覆盖（例如，当`if`语句评估为`True`和`False`时）'
- en: '`--source=qanda,user`: To record coverage only for the `qanda` and `user` modules
    (the code we wrote)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--source=qanda,user`：仅记录`qanda`和`user`模块（我们编写的代码）的覆盖范围'
- en: 'Now that we''ve recorded the coverage, let''s take a look at the coverage of
    an app without any tests:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经记录了覆盖率，让我们看一下没有任何测试的应用程序的覆盖率：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To understand how an untested project is 55% covered, let''s look at the coverage
    of `django/qanda/views.py`. Let''s generate an HTML report of the cover using
    the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解未经测试的项目为何覆盖率达到55％，让我们看一下`django/qanda/views.py`的覆盖情况。让我们使用以下命令生成覆盖的HTML报告：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding command will create a `django/htmlcov` directory and HTML files
    that show the coverage report and a visual display of the code coverage. Let''s
    open `django/htmlcov/qanda_views_py.html` and scroll down to around line 72:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个`django/htmlcov`目录和HTML文件，显示覆盖报告和代码覆盖的可视化显示。让我们打开`django/htmlcov/qanda_views_py.html`并向下滚动到大约第72行：
- en: '![](img/3856b79c-6ff4-43ef-8f73-f774db940d2c.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3856b79c-6ff4-43ef-8f73-f774db940d2c.png)'
- en: The preceding screenshot shows that `DailyQuestionList` is completely covered
    but `QuestionDetailView.get_context_data()` is not. In the absence of any tests,
    the difference seems counterintuitive.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图显示`DailyQuestionList`完全被覆盖，但`QuestionDetailView.get_context_data()`没有被覆盖。在没有任何测试的情况下，这种差异似乎有违直觉。
- en: Let's remind ourselves how code coverage works. Code coverage tools check whether
    a particular line of code was *executed* during a test. In the preceding screenshot,
    the `DailyQuestionList` class and its members *were* executed. When the test runner
    starts, Django will build up the root URLConf much like when it starts for development
    or production. When the root URLConf is created, it imports the other referenced
    URLConfs (for example, `qanda.urls`). Those URLConfs, in turn, import their views.
    Views import forms, models, and other modules.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下代码覆盖的工作原理。代码覆盖工具检查在测试期间是否*执行*了特定行的代码。在上述屏幕截图中，`DailyQuestionList`类及其成员*已经*被执行。当测试运行程序启动时，Django将构建根URLConf，就像在开发或生产时启动一样。创建根URLConf时，它会导入其他引用的URLConfs（例如`qanda.urls`）。这些URLConfs又会导入它们的视图。视图导入表单，模型和其他模块。
- en: This import chain means that anything at the top level of a module will appear
    covered, regardless of whether it is tested. The class definition of `DailyQuestionList`
    was executed. However, the class itself was not instantiated, nor any of its methods
    executed. This also explains why the body of `QuestionDetailView.get_context_data()` is
    not covered. The body of `QuestionDetailView.get_context_data()` was never executed.
    This is a limitation of code coverage tools when working with declarative code
    such as `DailyQuestionList`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入链意味着模块顶层的任何内容都会显示为覆盖的，无论是否经过测试。`DailyQuestionList`的类定义被执行。但是，类本身没有被实例化，也没有执行任何方法。这也解释了为什么`QuestionDetailView.get_context_data()`的主体部分没有被覆盖。`QuestionDetailView.get_context_data()`的主体部分从未被执行。这是代码覆盖工具在处理声明性代码（例如`DailyQuestionList`）时的一个限制。
- en: Now that we understand some of the limitations of code coverage, let's write
    a unit test for `qanda.models.Question.save()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了代码覆盖的一些限制，让我们为`qanda.models.Question.save()`编写一个单元测试。
- en: Upserting into Elasticsearch
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Elasticsearch插入数据
- en: An upsert operation will update an object if it exists and insert it doesn't.
    Upsert is a portmanteau of *update* and *insert*. Elasticsearch supports upsert
    operations out of the box, which can make our code much simpler.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象存在，则upsert操作将更新对象，如果不存在则插入。Upsert是*update*和*insert*的合成词。Elasticsearch支持开箱即用的upsert操作，这可以使我们的代码更简单。
- en: 'Let''s add our `upsert()` method to `django/qanda/service/elastic_search.py`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`upsert()`方法添加到`django/qanda/service/elastic_search.py`中：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've defined our `get_client()` function in the preceding code block.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上述代码块中定义了我们的`get_client()`函数。
- en: To perform an upsert, we use the `update()` method of Elasticsearch `client`.
    We provide the model as a document `dict` under the `doc` key. To force Elasticsearch
    to perform an upsert, we will include the `doc_as_upsert` key with a `True` value.
    One difference between the `update()` method and the bulk insert function we used
    earlier is that `update()` will not accept an implicit ID (`_id`) in the document.
    However, we provide the ID of the document to upsert as the `id` argument in our
    `update()` call. We also remove the `_type` key and value from the `dict` returned
    by the `question_model.as_elasticsearch_dict()` method and pass value (stored
    in the `doc_type` variable) as an argument to the `client.update()` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行upsert，我们使用Elasticsearch `client`的`update()`方法。我们将模型作为文档`dict`提供，在`doc`键下。为了强制Elasticsearch执行upsert，我们将包含`doc_as_upsert`键，并赋予`True`值。`update()`方法和我们之前使用的批量插入函数之间的一个区别是，`update()`不会在文档中接受隐式ID（`_id`）。但是，我们在`update()`调用中提供要upsert的文档的ID作为`id`参数。我们还从`question_model.as_elasticsearch_dict()`方法返回的`dict`中删除`_type`键和值，并将值（存储在`doc_type`变量中）作为参数传递给`client.update()`方法。
- en: We return the response, though our view won't use it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回响应，尽管我们的视图不会使用它。
- en: 'Finally, we can test our view by running our development server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行开发服务器来测试我们的视图：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once our development server has started, we can ask a new question at [http://localhost:8000/ask](http://localhost:8000/ask)
    and then search for it at [http://localhost:8000/q/search](http://localhost:8000/q/search).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的开发服务器启动，我们可以在[http://localhost:8000/ask](http://localhost:8000/ask)提出一个新问题，然后在[http://localhost:8000/q/search](http://localhost:8000/q/search)进行搜索。
- en: Now, we're done adding search functionalities to Answerly!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了向Answerly添加搜索功能！
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've added search so that users can search for questions.
    We set up an Elasticsearch server for development using Docker. We created a `manage.py`
    command to load all our `Question`s into Elasticsearch. We added a search view
    where users could see the results of their question. Finally, we updated `Question.save`
    to keep Elasticsearch and the Django DB in sync.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了搜索功能，以便用户可以搜索问题。我们使用Docker为开发设置了一个Elasticsearch服务器。我们创建了一个`manage.py`命令，将所有我们的`Question`加载到Elasticsearch中。我们添加了一个搜索视图，用户可以在其中看到他们问题的结果。最后，我们更新了`Question.save`以保持Elasticsearch和Django数据库同步。
- en: Next, we'll take an in-depth look at testing a Django app so that we can have
    confidence as we make future changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解测试Django应用程序，以便在未来进行更改时可以有信心。
