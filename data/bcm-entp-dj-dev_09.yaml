- en: '*Chapter 7*: Working with Messages, Email Notifications, and PDF Reports'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：处理消息、电子邮件通知和 PDF 报告'
- en: In this chapter, we will work with the Django messages framework, email notifications
    and templates, and PDF documents. In order for us to know that emails are actually
    being sent from our system and that they are rendered correctly in different email
    clients, we will be using a free third-party service to capture all of our outgoing
    emails. By capturing all outgoing emails, we can prevent development and test
    emails from being sent to people who should not be seeing them yet. We will use
    HTML, CSS, and the Django template language to create email and PDF report templates.
    Both will use context data just like how we passed context into templates in [*Chapter
    4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Django 消息框架、电子邮件通知和模板以及 PDF 文档。为了让我们知道电子邮件实际上是从我们的系统中发送的，并且在不同电子邮件客户端中正确渲染，我们将使用一个免费的第三方服务来捕获所有发出的电子邮件。通过捕获所有发出的电子邮件，我们可以防止开发测试电子邮件发送给尚未看到它们的人。我们将使用
    HTML、CSS 和 Django 模板语言来创建电子邮件和 PDF 报告模板。两者都将使用上下文数据，就像我们在 [*第 4 章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URL、视图和模板*
    中传递上下文到模板一样。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating a test environment for capturing all emails sent by the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于捕获应用发送的所有电子邮件的测试环境
- en: Using the Django messages framework to create flash messages and custom message
    levels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django 消息框架创建闪存消息和自定义消息级别
- en: Creating and sending HTML and/or plain text-formatted emails
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和发送 HTML 和/或纯文本格式的电子邮件
- en: Creating template-based emails using HTML, CSS, and the Django template language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML、CSS 和 Django 模板语言创建基于模板的电子邮件
- en: Generating PDF documents using HTML, CSS, and the Django template language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML、CSS 和 Django 模板语言生成 PDF 文档
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理本章中的代码，需要在您的本地机器上安装以下工具：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 版本 3.9 – 作为项目的底层编程语言
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 版本 4.0 – 作为项目的后端框架
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip 包管理器 – 用于管理第三方 Python/Django 包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder, which
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置* 中创建的解决方案。然而，并不需要使用
    Visual Studio IDE。主要项目本身可以使用其他 IDE 运行，或者从项目根目录（其中包含 `manage.py` 文件）独立运行，使用终端或命令行窗口。无论您使用什么编辑器或
    IDE，都需要一个虚拟环境来与 Django 项目一起工作。如何创建项目和虚拟环境的说明可以在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*
    中找到。您需要一个数据库来存储项目中的数据。在上一章的示例中选择了 PostgreSQL；然而，您可以为项目选择任何数据库类型，以使用本章中的示例。
- en: We will not be using any data found in the `chapter_3` app data fixture but
    if that data is already loaded, don't worry! The exercises in this chapter will
    all use data that is obtained from forms that the user is interacting with and
    not data coming from within a database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会使用 `chapter_3` 应用数据固定文件中的任何数据，但如果该数据已经加载，请不要担心！本章的所有练习都将使用用户交互的表单中获取的数据，而不是来自数据库的数据。
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/`
    directory.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章中展示的大部分代码可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3OzpalD](https://bit.ly/3OzpalD).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解*代码的实际应用*：[https://bit.ly/3OzpalD](https://bit.ly/3OzpalD)。
- en: Preparing for this chapter
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: Start by creating a new app in your project called `chapter_7` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in the `INSTALLED_APPS` variable found in the `settings.py` file as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中讨论的步骤，在您的项目中创建一个名为`chapter_7`的新应用。正如该节所述，不要忘记将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/apps.py`文件中您应用类中的`name
    =`变量的值更改为指向您安装应用的位置。务必还将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。
- en: 'In the main `urls.py` file of the site, add the following path, which points
    to the URL patterns of the app that we will be creating in this chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站的主要`urls.py`文件中，添加以下路径，该路径指向我们将在本章中创建的应用的URL模式：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copy the URL patterns, forms, fields, views, templates, CSS, and JavaScript
    files found in the `chapter_5` app directly into the newly created `chapter_7`
    app. This way, we can keep the exercises of each chapter separated, and the exercises
    of this chapter will build on the exercises of [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152),
    *Django Forms*. In the code that you copied into this chapter's app, make sure
    you update all file/code references from `chapter_5`/`chapter-5` to `chapter_7`/`chapter-7`
    where needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将`chapter_5`应用中找到的URL模式、表单、字段、视图、模板、CSS和JavaScript文件直接复制到新创建的`chapter_7`应用中。这样，我们可以将每个章节的练习分开，本章的练习将建立在[*第5章*](B17243_05_ePub.xhtml#_idTextAnchor152)中*Django表单*的练习之上。在您复制到本章应用的代码中，确保更新所有从`chapter_5`/`chapter-5`到`chapter_7`/`chapter-7`的文件/代码引用，如有必要。
- en: Creating a Mailtrap account
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Mailtrap账户
- en: In order to work with the email examples throughout this chapter, you will need
    an email testing service that will capture all emails being sent from the system
    being built, as we run the project locally. There are numerous different third-party
    services on the market today that all provide this solution. Each service varies
    in terms of the additional testing tools and features that they provide as well
    as the cost associated with that service. You are welcome to use a service other
    than the one chosen for this book. If you choose to do so, you will have to follow
    the instructions from that service in order to configure the settings for your
    project instead of the instructions found in this section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中与电子邮件示例一起工作，您需要一个能够捕获从正在构建的系统发送的所有电子邮件的电子邮件测试服务，因为我们是在本地运行项目。目前市场上有很多不同的第三方服务，它们都提供这种解决方案。每个服务在提供的附加测试工具和功能以及与该服务相关的成本方面都有所不同。您可以使用本书未选择的服务。如果您选择这样做，您将不得不遵循该服务的说明来配置您项目的设置，而不是本节中找到的说明。
- en: For the purpose of demonstrating the exercises throughout this chapter, we will
    be using a completely free service called **Mailtrap**. No credit card is required
    to create an account with them and it's free for personal side projects. This
    is not a trial-based plan; it is free for a lifetime, or at least until Mailtrap
    changes its policies and procedures. Mailtrap also offers upgraded paid plans,
    which provide additional tools and support should you and your team decide to
    use this service, which would be particularly useful in multiple development environments
    and with large testing teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示本章中的练习，我们将使用一个完全免费的名为 **Mailtrap** 的服务。创建账户时无需信用卡，并且对个人副项目免费。这不是基于试用期的计划；它终身免费，或者至少直到
    Mailtrap 改变其政策和程序。Mailtrap 还提供升级的付费计划，如果你和你的团队决定使用这项服务，这将特别有用，尤其是在多个开发环境和大型测试团队中。
- en: 'Follow these steps to create and set up your Mailtrap account:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建和设置你的 Mailtrap 账户：
- en: Visit [https://mailtrap.io/register/signup](https://mailtrap.io/register/signup)
    to create a new account. Follow the steps that they provide on their website.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://mailtrap.io/register/signup](https://mailtrap.io/register/signup)
    创建新账户。按照他们网站上提供的步骤进行操作。
- en: To activate your account, you will need to go back to your email inbox and click
    the `Junk` folder if you do not see it in your inbox.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要激活你的账户，你需要回到你的邮箱收件箱，如果你在收件箱中没有看到它，请点击 `垃圾邮件` 文件夹。
- en: Once that is complete, log into your new account and you will be taken to **My
    Inbox**, with the first tab, **SMTP Settings**, selected.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，登录你的新账户，你将被带到 **我的收件箱**，第一个标签页是 **SMTP 设置**。
- en: 'Under the `settings.py` file of your project, as shown:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目 `settings.py` 文件中，如下所示：
- en: '![Figure 7.1 – Mailtrap – SMTP Settings'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – Mailtrap – SMTP 设置'
- en: '](img/Figure_7.01_B17243.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17243.jpg)'
- en: Figure 7.1 – Mailtrap – SMTP Settings
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Mailtrap – SMTP 设置
- en: Add these variables, along with the credentials that were provided in your account,
    anywhere inside your `settings.py` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些变量，以及你在账户中提供的凭证，添加到 `settings.py` 文件的任何位置。
- en: 'This step is optional. To separate these variables in a production environment,
    use the following conditional statement in your `settings.py` file. The values
    of each variable are also being kept within the `.env` file of a project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤是可选的。为了在生产环境中分离这些变量，在你的 `settings.py` 文件中使用以下条件语句。每个变量的值也保存在项目的 `.env` 文件中：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure to add the variables to your local `.env` file before running your
    project when using the preceding example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在运行项目之前，将变量添加到你的本地 `.env` 文件中，当使用前面的示例时。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order for Mailtrap to work with your project on Heroku, make sure you add
    the four email variables from your local `.env` file to the config variables of
    each Heroku app. For instructions on how to do this, refer to [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*, under the subsection titled *Remote variables*. You can
    use the same connection settings for each environment and they will all go to
    the same inbox.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Mailtrap 能够与你的 Heroku 项目一起工作，确保将你的本地 `.env` 文件中的四个电子邮件变量添加到每个 Heroku 应用的配置变量中。有关如何操作的说明，请参阅
    [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*下的*远程变量*小节。你可以为每个环境使用相同的连接设置，它们都将发送到同一个收件箱。
- en: That's it. Mailtrap is now configured and will intercept all emails being sent
    from your Django project. Let's move on to creating flash messages with the Django
    messages framework next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。Mailtrap 现已配置，并将拦截来自你的 Django 项目的所有邮件。接下来，让我们继续使用 Django 消息框架创建闪存消息。
- en: Using the Django messages framework
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django 消息框架
- en: Let's begin by introducing the **Django Messages Framework**, which is a framework
    used to provide session-based messages to the user. A **flash message** is a one-time
    notification message displayed directly to the user and is the kind of message
    that this framework creates. What we can do with this is render messages to the
    user anywhere we put the code inside our templates, whether that be in a modal
    popup or a message that drops down from the top of the page or comes up from the
    bottom of the page. It can even appear above or below a form that the user is
    submitting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来介绍 **Django 消息框架**，这是一个用于向用户提供基于会话的消息的框架。**闪存消息**是一种一次性通知消息，直接显示给用户，这正是该框架创建的消息类型。我们可以将消息渲染到用户在模板中放置代码的任何位置，无论是模态弹出窗口还是从页面顶部或底部下拉的消息，甚至可以出现在用户提交的表单上方或下方。
- en: The `chapter_7` `FormClassView` class will be the primary working class throughout
    this chapter, as it will be used primarily to trigger the actions we will be writing.
    We will be writing the methods to perform those actions in the corresponding `ContactForm`
    class used by that `FormClassView` class of the `chapter_7` app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，`chapter_7` `FormClassView` 类将是主要的工作类，因为它将主要用于触发我们将要编写的操作。我们将编写在相应的 `ContactForm`
    类中执行这些操作的方法，该类用于 `chapter_7` 应用程序的 `FormClassView` 类。
- en: Before we start writing those classes, we will begin by enabling the Django
    messages framework next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写这些类之前，我们首先将启用 Django 消息框架。
- en: Enabling the Django messages framework
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 Django 消息框架
- en: These settings will enable the Django messages framework. A project does not
    require this framework to operate. These settings can be removed if desired but
    are required to work with this chapter. It is likely that when you created your
    project, these settings were generated for you automatically. Double-check just
    to make sure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置将启用 Django 消息框架。项目不需要此框架即可运行。如果需要，可以删除这些设置，但为了使用本章，它们是必需的。很可能在您创建项目时，这些设置已经自动为您生成。请再次检查以确保无误。
- en: 'In your `settings.py` file, make sure these settings and values exist:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `settings.py` 文件中，请确保存在以下设置和值：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One important thing to remember in the preceding settings is that `SessionMiddleware`
    always comes before the `MessageMiddleware` entry in the `MIDDLEWARE` list. The
    same applies to the `INSTALLED_APPS` variable; make sure the `django.contrib.sessions`
    app comes before the `django.contrib.messages` app. The Django messages framework
    context processor shown under the `TEMPLATES` configuration is also needed to
    make your Django messages framework context available from within any of your
    templates. This means that you do not have to explicitly define a variable in
    the context of each page specifically for your messages. Instead, it will be available
    via the global context of your project automatically.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，需要记住的一个重要事项是 `SessionMiddleware` 总是在 `MIDDLEWARE` 列表中的 `MessageMiddleware`
    条目之前。同样适用于 `INSTALLED_APPS` 变量；请确保 `django.contrib.sessions` 应用程序在 `django.contrib.messages`
    应用程序之前。在 `TEMPLATES` 配置下显示的 Django 消息框架上下文处理器也是必需的，以便在您的模板中从任何地方访问 Django 消息框架上下文。这意味着您不需要在每个页面的上下文中显式定义一个变量专门用于消息。相反，它将通过项目的全局上下文自动可用。
- en: Next, we will discuss additional configuring/enabling of the Django messages
    framework.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 Django 消息框架的额外配置/启用。
- en: Message storage backends
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息存储后端
- en: '`MESSAGE_STORAGE` variable in the `settings.py` file.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.py` 文件中的 `MESSAGE_STORAGE` 变量。'
- en: 'The backend choices available for `MESSAGE_STORAGE` are listed here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 `MESSAGE_STORAGE` 的后端选项在此列出：
- en: '`django.contrib.messages.storage.session.SessionStorage` – stores messages
    in the requests session and will require that the `django.contrib.sessions` app
    be included in the `INSTALLED_APPS` variable.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.messages.storage.session.SessionStorage` – 在请求会话中存储消息，并要求将
    `django.contrib.sessions` 应用程序包含在 `INSTALLED_APPS` 变量中。'
- en: '`django.contrib.messages.storage.fallback.FallbackStorage` – this option uses
    the now-legacy `CookieStorage` first and then, when cookie data exceeds the 2,048-byte
    threshold, instead of deleting those older cookies, as is the default action of
    the `CookieStorage` option, new messages will instead be placed in `SessionStorage`.
    `CookieStorage` is no longer supported in Django 4.0 but is still available in
    the `django.contrib.messages.storage` library. It is unknown when this storage
    method will be removed completely.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.messages.storage.fallback.FallbackStorage` – 此选项首先使用现在已过时的
    `CookieStorage`，然后，当 cookie 数据超过 2,048 字节阈值时，而不是像 `CookieStorage` 选项的默认操作那样删除那些较旧的
    cookie，新消息将被放置在 `SessionStorage` 中。`CookieStorage` 在 Django 4.0 中不再受支持，但仍然可在 `django.contrib.messages.storage`
    库中使用。目前尚不清楚这种存储方法何时将被完全删除。'
- en: '`django.contrib.messages.storage.base.BaseStorage` – Django provides this class
    as a way for developers to create their own storage systems. By itself, this will
    not work because this is an abstract class meant to be extended. This is considered
    an advanced topic beyond the scope of this book.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.messages.storage.base.BaseStorage` – Django 提供此类作为开发人员创建自己的存储系统的一种方式。本身，这不会工作，因为这个类是一个抽象类，旨在被扩展。这被认为是超出本书范围的进阶主题。'
- en: 'Let''s go ahead and set this to use the `SessionStorage` option for now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先将此设置为使用 `SessionStorage` 选项：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Message levels
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息级别
- en: '**Message levels** indicate the different severity levels of a message. These
    levels have a variable name, a lowercase tag name, and a numeric value indicating
    the severity level, as shown in the following table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息级别**表示消息的不同严重程度。这些级别有一个变量名、一个小写标签名和一个表示严重程度的数值，如下表所示：'
- en: '![](img/Table.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table.jpg)'
- en: By default, Django sets the `MESSAGE_LEVEL` variable to `INFO`; more specifically,
    Django sets this to a value of `20`. This means if we try to issue a `DEBUG`-related
    message, which has a value of `10`, it will never be rendered to the page. Some
    might think this is a bug in the Django framework; however, this is by intentional
    design. The reason is that in a production setting, we do not want those messages
    to appear anywhere to the user. Any custom message levels with a value below `20`
    would also not appear. Instead, we only want developers, and maybe the testers,
    to see that message in a development or local environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django将`MESSAGE_LEVEL`变量设置为`INFO`；更具体地说，Django将其设置为`20`的值。这意味着如果我们尝试发布一个值为`10`的`DEBUG`相关消息，它将永远不会渲染到页面上。有些人可能会认为这是Django框架中的错误；然而，这是有意为之的设计。原因是，在生产环境中，我们不希望这些消息出现在任何地方供用户看到。任何值低于`20`的自定义消息级别也不会出现。相反，我们只想让开发人员和可能的项目测试人员在一个开发或本地环境中看到这些消息。
- en: 'To enable `DEBUG`-related messages in your environment, the best way to do
    this is by once again utilizing the debug conditional in your `settings.py` file,
    as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的环境中启用与`DEBUG`相关的消息，最好的方法是在`settings.py`文件中再次利用调试条件，如下所示：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we are explicitly defining the `MESSAGE_LEVEL` setting to include `DEBUG`-related
    messages while the project's `DEBUG` variable is set to `True`. If `DEBUG` is
    set to `False`, as is done in the `.env` file of the production environment, then
    it will use the default Django setting of `messages.INFO` for this variable. We
    could just leave the `else` condition out of the equation altogether; however,
    it was written as a placeholder for illustrative purposes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确地定义了`MESSAGE_LEVEL`设置，以便在项目的`DEBUG`变量设置为`True`时包含与`DEBUG`相关的消息。如果`DEBUG`设置为`False`，就像生产环境的`.env`文件中所做的那样，那么它将使用Django的默认设置`messages.INFO`为此变量。我们完全可以省略等式中的`else`条件；然而，它被编写为一个占位符，用于说明目的。
- en: Message tags
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息标签
- en: '`/becoming_a_django_entdev/chapter_7/static/chapter_7/css/site.css` file provided
    with the code of this book, there are CSS styles that do just that; they style
    each message level discussed in this chapter as a different color. Copy and paste
    these styles into your project to see the same colors depicted in these images
    within your browser.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书代码中提供的`/becoming_a_django_entdev/chapter_7/static/chapter_7/css/site.css`文件中，有一些CSS样式正是这样做的；它们将本章讨论的每个消息级别样式化为不同的颜色。将这些样式复制并粘贴到您的项目中，您可以在浏览器中看到这些图像中描述的相同颜色。
- en: 'In this example, let''s change the tag for the `INFO` message from the original
    `info` to `information`, using the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们将`INFO`消息的标签从原始的`info`更改为`information`，使用以下示例：
- en: '[PRE44]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, the `DEBUG`, `SUCCESS`, `WARNING`, and `ERROR` message
    tags will all continue to use their default message tag values because we did
    not include them in this list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`DEBUG`、`SUCCESS`、`WARNING`和`ERROR`消息标签都将继续使用它们的默认消息标签值，因为我们没有将它们包含在这个列表中。
- en: Custom message levels
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义消息级别
- en: '`settings.py` file, go ahead and add three new variables with numeric values,
    as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`settings.py`文件中，请添加三个具有数值的新变量，如下所示：
- en: '[PRE52]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Each new level is defined using those numeric values. They can be named anything
    that does not conflict with other settings variables. These values can be any
    number, such as `19` or `199`, though it is best not to use any of the default
    values, such as `10`, `20`, `25`, `30`, or `40` because these values are being
    used by other levels, We also added those variables to the `MESSAGE_TAGS` variable
    because when we have events that create a new message, it will also need a message
    tag to add a CSS class to when rendering the HTML.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新级别都使用这些数值定义。它们可以命名为任何不与其他设置变量冲突的名称。这些值可以是任何数字，例如`19`或`199`，尽管最好不使用任何默认值，如`10`、`20`、`25`、`30`或`40`，因为这些值已被其他级别使用。我们还添加了这些变量到`MESSAGE_TAGS`变量中，因为当我们有创建新消息的事件时，它也需要一个消息标签来在渲染HTML时添加CSS类。
- en: Now that the settings are configured for the Django messages framework, we can
    use that framework and create messages next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Django消息框架的设置已经配置好了，我们可以使用该框架并创建消息。
- en: Creating a message
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息
- en: Creating messages is very simple. For this exercise, let's modify the `post()`
    method found in the `FormClassView` class that we duplicated into the `chapter_7`
    app. Here, we will be adding the code that will create the message when the form
    is submitted. Django provides two ways to write a message, one way using the provided
    `add_message()` method and another by explicitly adding that message to one of
    the five default message levels.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消息非常简单。为此练习，让我们修改 `FormClassView` 类中找到的 `post()` 方法，该方法已复制到 `chapter_7` 应用程序中。在这里，我们将添加在表单提交时创建消息的代码。Django
    提供了两种编写消息的方式，一种是通过提供的 `add_message()` 方法，另一种是明确将消息添加到五个默认消息级别之一。
- en: 'The following steps demonstrate using both ways. Please use only one or the
    other:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了使用两种方式。请只使用其中一种：
- en: 'In the `/chapter_7/views.py` file, add the `add_message()` statement and context
    highlighted in the following code block to the `FormClassView` class under the
    `if form.is_valid():` condition. Remember to comment out or delete the `return`
    statement found in this condition:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_7/views.py` 文件中，将以下代码块中高亮显示的 `add_message()` 语句和上下文添加到 `FormClassView`
    类的 `if form.is_valid():` 条件下。请记住取消注释或删除此条件中找到的 `return` 语句：
- en: '[PRE63]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, in the `/chapter_7/views.py` file, add the `add_message()` statement
    and context highlighted in the following code block to the `FormClassView` class
    under the `else:` condition. Remember to comment out or delete the `return` statement
    found in this condition and add the new `return` statement shown here:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `/chapter_7/views.py` 文件中，将以下代码块中高亮显示的 `add_message()` 语句和上下文添加到 `FormClassView`
    类的 `else:` 条件下。请记住取消注释或删除此条件中找到的 `return` 语句，并添加此处所示的新 `return` 语句：
- en: '[PRE64]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This step is not required; it just shows an alternative way of writing and
    using the messages shown previously. Use the `Success` and `Error` level statements
    highlighted in the following code block as alternatives to the ones shown previously.
    Use only one or the other:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤不是必需的；它只是展示了编写和使用之前显示的消息的另一种方式。使用以下代码块中高亮显示的 `Success` 和 `Error` 级别语句作为之前显示语句的替代。只使用其中一种：
- en: '[PRE65]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using either of the add message examples will perform the same add message action,
    whereas using both at the same time will result in the same message being added
    twice to your storage system. In the `post()` method depicted previously, we commented
    out the old redirect statement and are now defining a success and failure message
    on form submission, using the same condition as before to check whether the form
    is valid. The message itself can accept a string and that string can contain HTML,
    as depicted in the preceding failure message. If HTML does exist in your string,
    the message would have to use the `|safe` filter when working with messages in
    a template.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何添加消息的示例都将执行相同的添加消息操作，而同时使用两个示例将导致相同的消息被添加两次到您的存储系统中。在前面所示的 `post()` 方法中，我们注释掉了旧的重定向语句，现在正在定义在表单提交时使用相同条件的成功和失败消息。消息本身可以接受一个字符串，并且该字符串可以包含
    HTML，如图所示的失败消息。如果字符串中存在 HTML，则消息在使用模板中的消息时必须使用 `|safe` 过滤器。
- en: Next, let's go over the extra things we can do when creating a message.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下在创建消息时可以做的额外事情。
- en: Using a custom message level
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义消息级别
- en: 'If we want to use one of the custom message levels that we created, such as
    `CRITICAL`, then we can only use the `add_message()` method. We also need to import
    `settings` to access those variables, as depicted here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用我们创建的自定义消息级别之一，例如 `CRITICAL`，那么我们只能使用 `add_message()` 方法。我们还需要导入 `settings`
    来访问这些变量，如图所示：
- en: '[PRE66]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Messages are created in the same way, except `settings.LEVEL` is used instead
    of `messages.LEVEL`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的创建方式相同，只是使用 `settings.LEVEL` 而不是 `messages.LEVEL`。
- en: With extra tags
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用额外标签
- en: 'We can pass additional custom CSS classes for a message and that message only.
    This is done by adding that class(es) to the add message operation using the `extra_tags`
    attribute. For example, let''s render our message with two classes, the `success`
    class, which gets added automatically, and an additional class called `bold` to
    then bolden the text that is rendered, using the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为消息及其仅有的消息传递额外的自定义 CSS 类。这是通过使用 `extra_tags` 属性将那个类（们）添加到添加消息操作中实现的。例如，让我们使用以下示例将我们的消息渲染为两个类，`success`
    类会自动添加，以及一个额外的名为 `bold` 的类，以加粗渲染的文本，如下所示：
- en: '[PRE83]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After completing the section of this chapter titled *Displaying messages*,
    when we load the page and then inspect the message, what we should see rendered
    to the screen when inspecting that particular element is both the CSS classes
    **bold** and **success**, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章标题为*显示消息*的部分后，当我们加载页面并检查消息时，我们应该在检查该特定元素时在屏幕上看到渲染的CSS类**粗体**和**成功**，如下面的截图所示：
- en: '![Figure 7.2 – Django messages framework – extra_tags attribute'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – Django消息框架 – extra_tags属性'
- en: '](img/Figure_7.02_B17243.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.02_B17243.jpg)'
- en: Figure 7.2 – Django messages framework – extra_tags attribute
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – Django消息框架 – extra_tags属性
- en: That fails silently
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那个静默失败
- en: Creating a message that **fails silently** simply means creating a reusable
    app using the Django messages framework that does not require other developers
    using your app in a different project to actually have the Django messages framework
    enabled within their project. This means if they have disabled this framework
    or just do not have it enabled yet, the add message operations will not prevent
    their project from functioning properly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个**静默失败**的消息，简单地说就是创建一个可重用的应用程序，使用Django消息框架，不需要其他开发者在不同的项目中启用Django消息框架。这意味着如果他们已禁用此框架或尚未启用，添加消息操作将不会阻止他们的项目正常工作。
- en: 'To use this option, add the `fail_silently` attribute to your add message actions,
    as shown:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此选项，请将`fail_silently`属性添加到您的添加消息操作中，如下所示：
- en: '[PRE102]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'With the `fail_silently` attribute set to `True`, the application will run
    as normal, without errors that prevent the code from running. If the developer
    has disabled the Django messages framework and the `fail_silently` attribute is
    not included, then when running the application, that should trigger a flash message,
    where you will see a **MessageFailure** error, as shown:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将`fail_silently`属性设置为`True`时，应用程序将正常运行，而不会出现阻止代码运行的错误。如果开发人员已禁用Django消息框架且未包含`fail_silently`属性，则在运行应用程序时，应触发一个闪存消息，您将看到**MessageFailure**错误，如下所示：
- en: '![Figure 7.3 – Django messages framework – fail_silently attribute'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – Django消息框架 – fail_silently属性'
- en: '](img/Figure_7.03_B17243.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.03_B17243.jpg)'
- en: Figure 7.3 – Django messages framework – fail_silently attribute
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – Django消息框架 – fail_silently属性
- en: In the next section, we will render our messages into a template as HTML.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将我们的消息渲染成模板，即HTML。
- en: Displaying messages
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示消息
- en: 'In order for messages to actually be seen by the user, we need to add some
    code to a Django template. Using the `/chapter_7/templates/chapter_7/form-class.html`
    file, which the `chapter_7` `FormClassView` class uses as its template, add the
    following code to the top of the HTML `<form>` object found inside that template:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让消息真正被用户看到，我们需要在Django模板中添加一些代码。使用`chapter_7` `FormClassView`类使用的模板文件`/chapter_7/templates/chapter_7/form-class.html`，将以下代码添加到该模板中HTML
    `<form>`对象的顶部：
- en: '[PRE121]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: All other code in this file can be left as is. Here, we use a simple conditional
    statement checking whether any messages exist in the storage system for this request.
    If they do, a `<ul>` list is created and then iterated through every message that
    exists, creating each one as a separate `<li>` item within that list. The message
    itself is using the `|safe` filter, allowing it to render HTML that can exist
    in the message string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的所有其他代码都可以保持不变。在这里，我们使用一个简单的条件语句来检查存储系统中是否存在此请求的消息。如果存在，则创建一个`<ul>`列表，然后遍历每个存在的消息，在该列表中为每个消息创建一个单独的`<li>`项目。消息本身使用`|safe`过滤器，允许它渲染消息字符串中可能存在的HTML。
- en: 'Visit the URL `http://www.localhost:8000/chapter-7/form-class/` and submit
    the form. Either the valid or invalid message will display, depending on whether
    or not you actually triggered a validation error with that form, as shown in the
    following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 访问URL `http://www.localhost:8000/chapter-7/form-class/` 并提交表单。有效或无效的消息将显示，具体取决于您是否实际触发了该表单的验证错误，如下面的截图所示：
- en: '![Figure 7.4 – Django messages framework – displaying messages'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – Django消息框架 – 显示消息'
- en: '](img/Figure_7.04_B17243.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.04_B17243.jpg)'
- en: Figure 7.4 – Django messages framework – displaying messages
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – Django消息框架 – 显示消息
- en: The preceding message is displayed within the browser in green, if you are using
    the CSS classes provided by the book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是本书提供的CSS类，前面的消息将在浏览器中以绿色显示。
- en: Now that we have enabled the Django messages framework and added several messages
    to one of our view classes, let's practice sending an email notification instead
    of displaying a flash message next.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了Django消息框架，并在我们的视图类中添加了几条消息，接下来让我们练习发送电子邮件通知而不是显示闪存消息。
- en: Configuring email notifications
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置电子邮件通知
- en: This section will help us to build actual email notifications instead of flash
    messages. We will write our logic to trigger the send email action in the same
    `FormClassView` class where we added messages inside the `post()` method. We will
    be utilizing the Mailtrap account that we created at the beginning of this chapter
    to capture all emails that are sent by our project. If you have not already done
    so, please create an account with Mailtrap and configure that connection in your
    `settings.py` file. Without doing so, you will have difficulty executing the code
    throughout this section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助我们构建实际的电子邮件通知而不是闪存消息。我们将编写逻辑以在添加消息的同一`FormClassView`类中的`post()`方法中触发发送电子邮件操作。我们将利用本章开头创建的Mailtrap账户来捕获我们项目发送的所有电子邮件。如果您尚未这样做，请创建一个Mailtrap账户，并在您的`settings.py`文件中配置该连接。如果不这样做，您将难以执行本节中的代码。
- en: 'There are three MIME types that exist for emails, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件存在三种MIME类型，如下所示：
- en: '`text/plain`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/plain`'
- en: '`application/rtf`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/rtf`'
- en: '`text/html`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/html`'
- en: 'While there are three MIME types, only two are used by Django when sending
    emails: plain text and HTML. Rich text emails are treated as HTML emails because
    they contain HTML markup.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在三种MIME类型，但在发送电子邮件时Django只使用其中两种：纯文本和HTML。富文本电子邮件被视为HTML电子邮件，因为它们包含HTML标记。
- en: As plain text emails
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为纯文本电子邮件
- en: 'Plain text emails are just like they sound; they are just text and nothing
    else. We will be creating a method that prepares and then actually sends the email
    inside of the `ContactForm` class that we are using. The method that triggers
    the sending of an email can technically be placed in any class or any file. Follow
    these steps to create yours:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本电子邮件就像其名称所暗示的那样；它们只是文本，没有其他内容。我们将在我们使用的`ContactForm`类中创建一个方法，准备并发送电子邮件。触发发送电子邮件的方法可以从技术上放置在任何类或任何文件中。按照以下步骤创建您的：
- en: 'In the `ContactForm` class that was duplicated into the `/chapter_7/forms.py`
    file, add a new method called `send_email()` using the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`ContactForm`类复制到`/chapter_7/forms.py`文件中时，使用以下代码添加一个名为`send_email()`的新方法：
- en: '[PRE137]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'This method will handle all of the busy work involved in actually formatting
    and sending the email. Of course, this is a basic `text/plain` email consisting
    of only the phrase `msg_body` variable. The `email.content_subtype` statement
    is where we are telling Django that we want to format this email as a plain text
    email. We also imported and used the `EmailMessage` class from the `django.core.mail`
    library, used to structure the email and format headers pertaining to that email.
    Django also provides simpler method-based functions, such as `send_mail()` or
    `send_mass_mail()`, among a small handful of other methods. We will focus on just
    the `EmailMessage` class, as it will encompass every aspect of what we need to
    achieve in this chapter. To learn more about all of the email methods that Django
    provides, visit the official documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将处理与格式化和发送电子邮件相关的所有繁琐工作。当然，这是一个基本的`text/plain`电子邮件，仅由`msg_body`变量组成的短语。`email.content_subtype`语句是我们告诉Django我们希望将此电子邮件格式化为纯文本电子邮件的地方。我们还从`django.core.mail`库中导入并使用了`EmailMessage`类，用于构建电子邮件和格式化与该电子邮件相关的标题。Django还提供了基于方法的简单函数，例如`send_mail()`或`send_mass_mail()`，以及其他少量方法。我们将专注于`EmailMessage`类，因为它将涵盖我们在本章中需要实现的所有方面。要了解更多关于Django提供的所有电子邮件方法，请访问官方文档，网址为：[https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/)。
- en: Because we are keeping this example extremely basic, we are only defining the
    `subject`, `body`, `from_email`, `reply_to`, and `to` attributes. Data is accessed
    by using `self.cleaned_data` and here we assign the value of the field named `email_1`
    to be the value of the `to` attributes list, as in the recipient's email address.
    If you are sending the email to multiple addresses, separate each email address
    with a comma in that list with no spaces.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们保持此示例非常基础，我们只定义了`subject`、`body`、`from_email`、`reply_to`和`to`属性。数据通过使用`self.cleaned_data`访问，我们将名为`email_1`的字段的值分配给`to`属性列表的值，即收件人的电子邮件地址。如果你要将电子邮件发送到多个地址，请在该列表中使用逗号分隔每个电子邮件地址，不要有空格。
- en: 'In the `FormClassView` class found in the `/chapter_7/views.py` file, leave
    everything as is, relating to the sending of messages in that view class. To actually
    send the email, add the following line of code to the `post()` method, as depicted
    here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/chapter_7/views.py`文件中找到的`FormClassView`类中，保留与该视图类中发送消息相关的所有内容不变。要实际发送电子邮件，请将以下代码行添加到`post()`方法中，如图所示：
- en: '[PRE138]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here, we are placing the send email operation just above the `return` statement
    and below the conditional statement that checks whether the form is valid. We
    are not separating the send operation for valid and invalid form submissions at
    this time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将发送电子邮件操作放置在`return`语句之上和检查表单是否有效的条件语句之下。我们目前没有将有效和无效表单提交的发送操作分开。
- en: 'Now, visit the URL `http://www.localhost:8000/chapter-7/form-class/`and submit
    the form, in either a valid or invalid state. The page should refresh without
    programming errors. You should now see your email in the inbox of your Mailtrap
    account, found at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    as depicted in the following screenshot:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问URL `http://www.localhost:8000/chapter-7/form-class/`并提交表单，无论是有效还是无效状态。页面应该刷新而不会出现编程错误。你现在应该能在Mailtrap账户的收件箱中看到你的电子邮件，Mailtrap账户的网址为[https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/)，如图所示：
- en: '![Figure 7.5 – Mailtrap – plain text email'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – Mailtrap – 纯文本电子邮件](img/Figure_7.05_B17243.jpg)'
- en: '](img/Figure_7.05_B17243.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.05 – Mailtrap – 纯文本电子邮件](img/Figure_7.05_B17243.jpg)'
- en: Figure 7.5 – Mailtrap – plain text email
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – Mailtrap – 纯文本电子邮件
- en: You will also notice that the email is displayed under the `text/plain`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到电子邮件现在显示在`text/plain`下。
- en: As HTML emails
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为HTML电子邮件
- en: Configuring an HTML or rich text email is fairly easy. Using the same example
    from the previous section, *As plain text emails*, all that is needed to convert
    to an HTML email is to change two lines of code. The first line of code is to
    change the `msg_body` variable to equal `'<b>Hello World</b>'`. This way, we can
    actually pass in HTML to see whether it is working or not. The second is to change
    the value of `email.content_subtype` to equal `'html'`, and that's it!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 配置HTML或富文本电子邮件相当简单。使用上一节中的相同示例，*作为纯文本电子邮件*，将纯文本电子邮件转换为HTML电子邮件只需更改两行代码。第一行代码是将`msg_body`变量更改为等于`'<b>Hello
    World</b>'`。这样，我们实际上可以传递HTML来查看它是否工作。第二行是将`email.content_subtype`的值更改为等于`'html'`，这样就完成了！
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the **Hello World** text in bold, as depicted in the following
    screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，当你访问Mailtrap收件箱[https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/)时，你应该能看到加粗的**Hello
    World**文本，如图所示：
- en: '![Figure 7.6 – Mailtrap – HTML email'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – Mailtrap – HTML电子邮件](img/Figure_7.06_B17243.jpg)'
- en: '](img/Figure_7.06_B17243.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – Mailtrap – 纯文本电子邮件](img/Figure_7.06_B17243.jpg)'
- en: Figure 7.6 – Mailtrap – HTML email
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – Mailtrap – HTML电子邮件
- en: In the preceding screenshot, you will also see that the email is now displayed
    in the `text/html` MIME type with no text fallback provided, meaning only HTML
    is available for this email. Clicking on the **Tech Info** tab will reveal other
    detailed information about your email. In this tab, you can verify the actual
    content type. Check if the value of the Content-Type has a MIME type that equals
    **text/html; charset=utf-8**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你还会看到电子邮件现在以`text/html` MIME类型显示，没有提供文本回退，这意味着此电子邮件只提供HTML。点击**Tech
    Info**标签将揭示有关你的电子邮件的其他详细信息。在此标签中，你可以验证实际的内容类型。检查Content-Type的值是否有等于**text/html;
    charset=utf-8**的MIME类型。
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The value of `'html'` is used for both rich text- and HTML-formatted emails.
    They will both be sent as `text/html`. This is because we cannot explicitly tell
    Django to use `'application/rtf'` for rich text emails. Django just assumes rich
    text emails are HTML because they contain HTML markup.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`''html''`的值用于富文本和HTML格式的电子邮件。它们都将被发送为`text/html`。这是因为我们无法明确告诉Django为富文本电子邮件使用`''application/rtf''`。Django只是假设富文本电子邮件是HTML，因为它们包含HTML标记。'
- en: As HTML emails with a plain text alternative
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为具有纯文本替代的HTML电子邮件
- en: HTML emails that have plain text alternatives are used for email clients that
    have difficulty rendering the HTML-formatted version of the email or or if spam
    blockers only display text first. We need to use the Django-provided `EmailMultiAlternatives`
    class instead of the `EmailMessage` class to do this. `EmailMultiAlternatives`
    is an extension of the `EmailMessage` class, meaning that all of the methods and
    attributes available in the `EmailMessage` class are still available for us to
    use in this class, plus more. When using this class, what we do is format the
    email as `text/html` and then use the new `attach_alternative()` method available
    in the `EmailMultiAlternatives` class with that alternative email formatted as
    `text/plain`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 具有纯文本替代的HTML电子邮件用于难以渲染电子邮件HTML格式版本的电子邮件客户端，或者如果垃圾邮件拦截器只显示文本。我们需要使用Django提供的`EmailMultiAlternatives`类而不是`EmailMessage`类来完成此操作。`EmailMultiAlternatives`是`EmailMessage`类的扩展，这意味着`EmailMessage`类中所有可用的方法和属性都可以在这个类中使用，还有更多。当我们使用这个类时，我们格式化电子邮件为`text/html`，然后使用`EmailMultiAlternatives`类中可用的新的`attach_alternative()`方法，该替代电子邮件格式化为`text/plain`。
- en: 'Use the same code as in the *As HTML emails* subsection and make the following
    highlighted changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与*作为HTML电子邮件*子节相同的代码，并做出以下突出更改：
- en: '[PRE139]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In the preceding example, we just replaced the `EmailMessage` class with the
    new `EmailMultiAlternatives` class. Then, we added the `email.attact_alternative()`
    action statement, which formats a brand-new email as `text/plain` using the text
    that we provided, `Hello World`, and attaches that new plain text-formatted email
    to the original HTML email. We do this instead of using the `attachment` attribute
    of the `EmailMessage` class because we are actually restructuring the content
    type of the email to now be a `multipart/alternative` MIME type instead of either
    the `text/html` or `text/plain` MIME types.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是将`EmailMessage`类替换为新的`EmailMultiAlternatives`类。然后，我们添加了`email.attact_alternative()`动作语句，该语句使用我们提供的文本`Hello
    World`格式化一个新的`text/plain`电子邮件，并将该新的纯文本格式化的电子邮件附加到原始HTML电子邮件上。我们这样做而不是使用`EmailMessage`类的`attachment`属性，因为我们实际上正在重构电子邮件的内容类型，使其现在成为`multipart/alternative`
    MIME类型，而不是`text/html`或`text/plain` MIME类型。
- en: 'That''s it; you now have an email that is both HTML and plain text. Let''s
    verify this. Visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the **Hello World** text in bold and also see the **Text** tab
    is now highlighted and clickable, as shown:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你现在有一个既是HTML又是纯文本的电子邮件。让我们验证一下。访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，当你访问你的Mailtrap收件箱[https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/)时，你应该看到加粗的**Hello
    World**文本，并且也会看到**文本**标签现在突出显示并可点击，如图所示：
- en: '![Figure 7.7 – Mailtrap – HTML and plain text email'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – Mailtrap – HTML和纯文本电子邮件'
- en: '](img/Figure_7.07_B17243.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B17243.jpg)'
- en: Figure 7.7 – Mailtrap – HTML and plain text email
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – Mailtrap – HTML和纯文本电子邮件
- en: 'Clicking on the **Text** tab will show you the plain text format that is available.
    The primary format is HTML and the fallback will be plain text. The order of the
    content types can be reversed in this example. When we click on the **Tech Info**
    tab, we will now see that **Content-Type** is displaying **multipart/alternative**,
    as shown:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**文本**标签将显示可用的纯文本格式。主要格式是HTML，备用格式将是纯文本。在这个例子中，内容类型的顺序可以颠倒。当我们点击**技术信息**标签时，我们现在会看到**内容类型**显示为**multipart/alternative**，如图所示：
- en: '![Figure 7.8 – Mailtrap – multipart/alternative'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – Mailtrap – multipart/alternative'
- en: '](img/Figure_7.08_B17243.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B17243.jpg)'
- en: Figure 7.8 – Mailtrap – multipart/alternative
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – Mailtrap – multipart/alternative
- en: With file attachments
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有文件附件
- en: Sending an email with a file attachment is also very easy. Django's `EmailMessage`
    class provides a method called `attach_file()`, which easily lets us attach a
    file by passing in the two positional arguments of that method, the path of the
    file and an optional MIME type. For this next exercise, copy the example PDF document
    that has been provided along with the code of this book in the `/becoming_a_django_entdev/chapter_7/static/chapter_7/pdf/`
    directory, called `example.pdf`. Copy that file into the same directory as your
    project before following this example, or create a dummy PDF file of your own.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 发送带有文件附件的电子邮件也非常简单。Django 的 `EmailMessage` 类提供了一个名为 `attach_file()` 的方法，它允许我们通过传递该方法的两个位置参数（文件的路径和一个可选的
    MIME 类型）轻松地附加文件。对于接下来的练习，请复制随本书代码一起提供的示例 PDF 文档，该文档位于 `/becoming_a_django_entdev/chapter_7/static/chapter_7/pdf/`
    目录中，文件名为 `example.pdf`。在遵循此示例之前，请将此文件复制到与您的项目相同的目录中，或者创建一个自己的虚拟 PDF 文件。
- en: 'In this next example, we will continue with the last example we just completed
    in the *As HTML emails with a plain text alternative* section, and attach the
    `example.pdf` document to that email. The Django documentation depicts using the
    `attach_file()` method with a path written as `email.attach_file(''static/chapter_7/pdf/example.pdf'')`.
    This is how a path will be defined when using this method in many Django projects.
    However, due to using the `whitenoise` package, we will have to import the `settings.py`
    file and use the `STATIC_ROOT` variable, as shown:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将继续在“作为纯文本替代的 HTML 电子邮件”部分中刚刚完成的最后一个示例，并将 `example.pdf` 文档附加到该电子邮件中。Django
    文档描述了使用 `attach_file()` 方法，路径写为 `email.attach_file('static/chapter_7/pdf/example.pdf')`。这就是在许多
    Django 项目中使用此方法时路径的定义方式。然而，由于使用了 `whitenoise` 包，我们必须导入 `settings.py` 文件并使用 `STATIC_ROOT`
    变量，如下所示：
- en: '[PRE169]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using the `STATIC_ROOT` variable in combination with the `whitenoise`
    package, we now have to run the `collectstatic` Django management command for
    that file to be found when we run the project locally. This doesn''t need to be
    done in every Django project but in ours, it must. To do so, first stop your project
    from running. In a terminal or command-line window, this can be done by pressing
    *Ctrl* + *C* on Windows or *Cmd* + *C* on a Mac with your keyboard. Then, execute
    the following commands. When prompted to do so, type the word `yes` and press
    *Enter* when it asks whether you are sure:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `STATIC_ROOT` 变量与 `whitenoise` 包结合使用时，我们现在必须运行 Django 管理命令 `collectstatic`，以便在本地运行项目时找到该文件。这不需要在每一个
    Django 项目中执行，但在我们的项目中必须这样做。为此，首先停止项目运行。在终端或命令行窗口中，这可以通过在 Windows 上按 *Ctrl* + *C*
    或在 Mac 上按 *Cmd* + *C* 并使用键盘来完成。然后，执行以下命令。当提示您这样做时，输入单词 `yes` 并按 *Enter* 键：
- en: '`(virtual_env) python manage.py collectstatic`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`(virtual_env) python manage.py collectstatic`'
- en: '`(virtual_env) python manage.py runserver`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`(virtual_env) python manage.py runserver`'
- en: This is a built-in Django command that will collect static files from all apps
    loaded into your project and place a copy of them into the `STATIC_ROOT` of your
    project, which is defined as the `/becoming_a_django_entdev/staticfiles/` folder
    that we have ignored in our Git repository.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内置的 Django 命令，它将从您项目中加载的所有应用程序中收集静态文件，并将它们的副本放置到项目的 `STATIC_ROOT` 目录中，该目录被定义为
    `/becoming_a_django_entdev/staticfiles/` 文件夹，我们在 Git 仓库中已忽略该文件夹。
- en: 'That''s it. Now, if you visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form, this time when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the attached file in the top right-hand corner of that email, as
    shown:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，如果您访问相同的 URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单，这次当您访问
    Mailtrap 邮箱 [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/) 时，您应该能在该电子邮件的右上角看到所附加的文件，如图所示：
- en: '![Figure 7.9 – Mailtrap – PDF attachment'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – Mailtrap – PDF 附件'
- en: '](img/Figure_7.09_B17243.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B17243.jpg)'
- en: Figure 7.9 – Mailtrap – PDF attachment
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – Mailtrap – PDF 附件
- en: Mailtrap will let you click on this document to open and view it or download
    it. Open the document to see it working properly.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Mailtrap 允许您点击此文档以打开和查看它或下载它。打开文档以查看它是否正常工作。
- en: That fail silently
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个失败是静默的
- en: Developers can write reusable apps containing actions that send emails and have
    them fail silently just as we did when using the Django messages framework. This
    means that a project won't error out when a developer has installed your app but
    has not configured a connection to an email client yet. Django provides this option
    as an attribute of the `send()` method of the `EmailMessage` or `EmailMultiAlternatives`
    class.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以编写包含发送电子邮件等操作的可重用应用程序，并且让它们在失败时静默处理，就像我们使用 Django 消息框架时做的那样。这意味着当开发者安装了你的应用程序但尚未配置电子邮件客户端连接时，项目不会出错。Django
    将此选项作为 `EmailMessage` 或 `EmailMultiAlternatives` 类的 `send()` 方法的属性提供。
- en: 'To activate the `fail_silently` option on the send email examples that we just
    wrote, add the following attribute to the existing `send()` action, as shown:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活我们刚才编写的发送电子邮件示例中的 `fail_silently` 选项，请向现有的 `send()` 动作添加以下属性，如下所示：
- en: '[PRE180]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This prevents the `email.send()` action from displaying an error message when
    this code is executed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了当执行此代码时，`email.send()` 动作显示错误消息。
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Django also provides this option when using the `send_mail()` and `send_mass_mail()`
    methods mentioned earlier. To learn more, visit [https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在使用前面提到的 `send_mail()` 和 `send_mass_mail()` 方法时也提供了此选项。要了解更多信息，请访问 [https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/)。
- en: Now that we have a better understanding of how emails are being sent in Django,
    let's go ahead and create our own email templates to let us custom-tailor them
    for our clients.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Django 中电子邮件的发送方式有了更好的理解，让我们继续创建我们自己的电子邮件模板，以便为我们客户提供定制服务。
- en: Writing custom email templates
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义电子邮件模板
- en: Writing HTML as a string in Python can get really messy. We can write the body
    contents, such as `'<b>Hello World</b>'`, as a `.html` template file instead.
    That will allow us to organize multiple email templates into the `/templates/emails/`
    directory of the `chapter_7` app. Programming work can also be shared among developers
    in this way. Email templates can also be used for plain text-formatted emails,
    placing only the text without any HTML code inside of that `.html` file. While
    that may not sound appealing for plain text emails, this does have its benefits
    when working among a large team of developers. Let's begin with the simplest template
    using only plain text emails.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTML 作为字符串写入 Python 可能会变得非常混乱。我们可以将正文内容，如 `'<b>Hello World</b>'`，作为 `.html`
    模板文件编写。这将允许我们将多个电子邮件模板组织到 `chapter_7` 应用程序的 `/templates/emails/` 目录中。编程工作也可以以这种方式在开发者之间共享。电子邮件模板还可以用于纯文本格式的电子邮件，只需在
    `.html` 文件中放置文本，而不包含任何 HTML 代码。虽然这听起来可能对纯文本电子邮件没有吸引力，但在与大量开发者合作时，这确实有其好处。让我们从使用纯文本电子邮件的最简单模板开始。
- en: Django provides the `get_template()` method, found in the `django.template.loader`
    library. This method will be used for all the email template examples in the following
    subsections.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了 `get_template()` 方法，位于 `django.template.loader` 库中。此方法将在以下子节中的所有电子邮件模板示例中使用。
- en: For plain text emails
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于纯文本电子邮件
- en: 'Follow these steps to create a template for a plain text email:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个纯文本电子邮件的模板：
- en: 'In the `ContactForm` class that we have been working with, modify the `send_email()`
    method to now be the following code:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们一直在使用的 `ContactForm` 类中，修改 `send_email()` 方法为以下代码：
- en: '[PRE187]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In the preceding code, we imported the `get_template()` method and used it to
    construct the template variable, which points to the `/chapter_7/emails/plain_text_format.html`
    file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 `get_template()` 方法，并使用它来构建模板变量，该变量指向 `/chapter_7/emails/plain_text_format.html`
    文件。
- en: Now, go ahead and create that file in that same directory within your `/chapter_7/templates/`
    folder. Inside that file, just add the text `Hello World` and nothing else. If
    you place any HTML in this file, it will be rendered as a string within the plain
    text body content of that email and will not be rendered as HTML.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请在该目录下 `/chapter_7/templates/` 文件夹中创建该文件。在该文件中，只需添加文本 `Hello World`，不要添加其他内容。如果你在此文件中放置任何
    HTML，它将作为纯文本正文内容中的字符串渲染，而不会作为 HTML 渲染。
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see that the **HTML** tabs are disabled, leaving only the **Text**
    tab to view your email. This also indicates that the process was successful, as
    shown in the following screenshot:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，当您访问您的Mailtrap收件箱[https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/)时，您应该会看到**HTML**标签已被禁用，只剩下**文本**标签来查看您的电子邮件。这也表明过程是成功的，如下面的截图所示：
- en: '![Figure 7.10 – Mailtrap – plain text template'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – Mailtrap – 纯文本模板](img/Figure_7.10_B17243.jpg)'
- en: '](img/Figure_7.10_B17243.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B17243.jpg)'
- en: Figure 7.10 – Mailtrap – plain text template
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – Mailtrap – 纯文本模板
- en: For HTML emails
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于HTML电子邮件
- en: 'Writing HTML templates is done in the same way as how we loaded a template
    for the plain text example previously. Only the following alterations are needed:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 编写HTML模板的方式与之前加载纯文本示例模板的方式相同。只需进行以下修改：
- en: 'First, we load a new file called `html_format.html` and change `content_subtype`
    back to `''html''`, as is highlighted here:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们加载一个名为`html_format.html`的新文件，并将`content_subtype`改回`'html'`，如这里所示：
- en: '[PRE188]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now, create the `html_format.html` file in your `/chapter_7/templates/chapter_7/emails/`
    directory. Inside this file, place the following code, where we actually have
    to format the document like an HTML page, in addition to providing the marked-up
    `Hello World` text:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的`/chapter_7/templates/chapter_7/emails/`目录中创建`html_format.html`文件。在此文件中，放置以下代码，其中我们实际上需要像HTML页面一样格式化文档，并提供标记的`Hello
    World`文本：
- en: '[PRE189]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: In this template, you can format your HTML `<head>` and `<body>` content as
    desired. It might even be wise to include responsive email and browser/client-supported
    syntax within this document to make sure it renders properly on every device.
    Your email test client will usually provide documentation to help you with stuff
    like that.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，您可以按需格式化HTML `<head>` 和 `<body>` 内容。甚至明智的做法是在此文档中包含响应式电子邮件和浏览器/客户端支持的语法，以确保在每种设备上都能正确渲染。您的电子邮件测试客户端通常会提供文档来帮助您处理这类事情。
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see that the **HTML** tab is now enabled and the **Text** tab is disabled.
    Again, this indicates that the process was successful, as depicted here:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，当您访问您的Mailtrap收件箱[https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/)时，您应该会看到**HTML**标签现在已启用，而**文本**标签已被禁用。同样，这也表明过程是成功的，如以下所示：
- en: '![Figure 7.11 – Mailtrap – HTML template'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – Mailtrap – HTML模板](img/Figure_7.11_B17243.jpg)'
- en: '](img/Figure_7.11_B17243.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B17243.jpg)'
- en: Figure 7.11 – Mailtrap – HTML template
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – Mailtrap – HTML模板
- en: Providing template context
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供模板上下文
- en: Using template-based emails can become even more useful when we introduce dynamic
    content into the equation. To do this, we need to send context into the `template.render()`
    statement. By doing this, we can even pass the form data that was already defined
    as the `data` variable directly into the template, accessing form field values
    within that template.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将动态内容引入等式中时，使用基于模板的电子邮件可以变得更加有用。为此，我们需要将上下文发送到`template.render()`语句。通过这样做，我们甚至可以将已定义为`data`变量的表单数据直接传递到模板中，在该模板中访问表单字段值。
- en: 'In this next exercise, we will render a template that also displays exactly
    what the user typed for each field of that form. Follow these steps to do just
    that:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将渲染一个模板，该模板将显示用户为表单的每个字段输入的确切内容。按照以下步骤进行操作：
- en: 'In the `send_email()` method of `ContactForm`, make the following highlighted
    changes:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContactForm`的`send_email()`方法中，进行以下突出显示的更改：
- en: '[PRE190]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Now, create a new file called `new_contact_form_entry.html` in your `/chapter_7/templates/chapter_7/emails/`
    directory and place the following code inside that file:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的`/chapter_7/templates/chapter_7/emails/`目录中创建一个名为`new_contact_form_entry.html`的新文件，并将以下代码放入该文件中：
- en: '[PRE191]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: In this template, you can use any of the tags and filters that come standard
    with the Django template language, such as writing conditional statements to check
    whether a field value equals a specific value. This means you could write a loop
    to automatically loop through all of the fields that exist in your `data` variable
    and then use the provided field labels instead of those custom labels depicted
    previously. You can also load `static` and/or custom `templatetags` using the
    load tag depicted previously, as with any other Django template.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，您可以使用 Django 模板语言的标准标签和过滤器，例如编写条件语句来检查字段值是否等于特定值。这意味着您可以为存在于您的 `data`
    变量中的所有字段编写循环，然后使用提供的字段标签而不是之前显示的定制标签。您还可以使用之前显示的加载标签加载 `static` 和/或自定义 `templatetags`，就像使用任何其他
    Django 模板一样。
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the values of each field inside the new email, as depicted here:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问相同的 URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，当您访问
    Mailtrap 邮箱 [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/) 时，您应该看到新电子邮件中每个字段的值，如图中所示：
- en: '![Figure 7.12 – Mailtrap – template context'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – Mailtrap – 模板上下文'
- en: '](img/Figure_7.12_B17243.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B17243.jpg)'
- en: Figure 7.12 – Mailtrap – template context
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – Mailtrap – 模板上下文
- en: Next, let's add a new action that creates a PDF document in the same spot where
    we are triggering our send email actions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个新的操作，在触发发送电子邮件操作的同一点创建 PDF 文档。
- en: Generating PDF reports
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 PDF 报告
- en: Django relies on the support of third-party packages in order to generate PDF
    documents. Their own documentation even suggests using the `reportlab` package;
    however, any third-party package that provides PDF support can be used. When using
    anything other than `reportlab`, refer to that package's documentation for instructions
    on how to use that package. The `reportlab` package even provides sample PDF invoices,
    reports, catalogs, and more for developers to get started quickly and easily,
    that is, if they are using the paid Plus version of the `reportlab` package. The
    Plus version requires the `rlextra` package, which is not available to the public.
    To learn more about what this service and package can provide, visit their documentation
    at [https://www.reportlab.com/dev/docs/](https://www.reportlab.com/dev/docs/).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Django 依赖于第三方包的支持来生成 PDF 文档。他们自己的文档甚至建议使用 `reportlab` 包；然而，任何提供 PDF 支持的第三方包都可以使用。当使用除
    `reportlab` 之外的内容时，请参阅该包的文档以获取如何使用该包的说明。`reportlab` 包甚至为开发者提供了示例 PDF 发票、报告、目录等，以便他们可以快速轻松地开始使用，前提是他们使用的是
    `reportlab` 包的付费 Plus 版本。Plus 版本需要 `rlextra` 包，该包对公众不可用。要了解更多关于此服务和包可以提供的信息，请访问他们的文档
    [https://www.reportlab.com/dev/docs/](https://www.reportlab.com/dev/docs/)。
- en: For the exercises throughout this section, we will be using the `xhtml2pdf`
    package instead, which is also free but a bit simpler and easier to use when working
    with template-based PDFs. We will keep to the same idea of creating a separate
    `.html` file for the content of each static or dynamic PDF.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的所有练习中，我们将使用 `xhtml2pdf` 包，它也是免费的，但使用基于模板的 PDF 时更简单、更容易使用。我们将坚持为每个静态或动态 PDF
    的内容创建一个单独的 `.html` 文件。
- en: 'Add the `xhtml2pdf` package to your `requirements.txt` file and install it
    into your virtual environment or run the following command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `xhtml2pdf` 包添加到您的 `requirements.txt` 文件中，并将其安装到您的虚拟环境或运行以下命令：
- en: '[PRE192]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Tip
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In all packages that I have worked with, I found that some have difficulty rendering
    complex HTML tables consistently. I would recommend avoiding tables altogether,
    or if you need to structure data as a table, do so with a simple structure to
    prevent rendering discrepancies and errors during document creation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在我合作的所有包中，我发现一些人在渲染复杂的 HTML 表格时存在困难。我建议完全避免使用表格，或者如果您需要将数据结构化为表格，请使用简单的结构以防止在文档创建过程中出现渲染差异和错误。
- en: Now that we have installed a tool that generates PDF documents, let's practice
    using it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了一个生成 PDF 文档的工具，让我们来练习使用它。
- en: As template-based PDFs
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为基于模板的 PDF
- en: Here, we will be using the same Django template language to build what we will
    call **PDF templates**.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用相同的 Django 模板语言来构建我们称之为 **PDF 模板** 的内容。
- en: 'Follow these steps to create your template:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的模板：
- en: 'Create a new method called `generate_pdf()` in the `ContactForm` class and
    include the following code:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContactForm`类中创建一个名为`generate_pdf()`的新方法，并包含以下代码：
- en: '[PRE193]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Here, we import the `pisa` library from within the `xhtml2pdf` package and
    use the `CreatePDF()` method. We are also using the Python `open()` method to
    specify the destination folder and filename of the document that we want to create.
    We are using the same `STATIC_ROOT` variable that we used before, most likely
    due to the `whitenoise` package in our project stack. The file being created will
    be located in the `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/` directory.
    Then, we are setting the `result` variable to equal the result of running the
    `CreatePDF()` method where we pass in the rendered HTML template as the content
    of that PDF. Additional information is available in the documentation, found here:
    [https://xhtml2pdf.readthedocs.io/en/latest/format_html.html](https://xhtml2pdf.readthedocs.io/en/latest/format_html.html).'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`xhtml2pdf`包中导入`pisa`库，并使用`CreatePDF()`方法。我们还在使用Python的`open()`方法来指定我们想要创建的文档的目标文件夹和文件名。我们使用与之前相同的`STATIC_ROOT`变量，这很可能是由于我们的项目堆栈中的`whitenoise`包。正在创建的文件将位于`/becoming_a_django_entdev/staticfiles/chapter_7/pdf/`目录中。然后，我们将`result`变量设置为运行`CreatePDF()`方法的结果，其中我们传递渲染的HTML模板作为该PDF的内容。更多详细信息可在以下文档中找到：[https://xhtml2pdf.readthedocs.io/en/latest/format_html.html](https://xhtml2pdf.readthedocs.io/en/latest/format_html.html)。
- en: Note
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since we are creating this file, there is no need to run the `collectstatic`
    command as we had to before.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建此文件，因此无需运行之前必须运行的`collectstatic`命令。
- en: 'Next, in the `post()` method of the `FormClass_View` class, where we wrote
    our `send_email()` action, let''s add the `generate_pdf()` operation just below
    that statement, as shown and highlighted here:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`FormClass_View`类的`post()`方法中，我们在这里编写了`send_email()`操作，让我们在该语句下方添加`generate_pdf()`操作，如下所示并突出显示：
- en: '[PRE194]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Next, in the `pdf_template.html` file that we are specifying as the template
    used for the body content of the PDF, add the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在指定为PDF正文内容模板的`pdf_template.html`文件中，添加以下代码：
- en: '[PRE195]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Here, we are writing standard HTML code to create the content of the PDF. The
    preceding example creates a reusable and repeatable header and footer on every
    page of the document. We also use special vendor-specific tags to tell us things
    such as the current page or the total page count of the document, such as what
    is used in the footer of the document, `<pdf:pagenumber>` and `<pdf:pagecount>`.
    We also use the Django-provided `{% lorem %}` template tag, which generates 50
    paragraphs worth of Latin text, using the `50 p` values that we are passing into
    that function. The Latin text, represented as **Lorem Ipsum**, is used only to
    illustrate what happens when there is more than one page worth of content without
    actually writing that content.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们编写标准的HTML代码来创建PDF的内容。前面的示例在文档的每一页上创建了一个可重复使用的页眉和页脚。我们还使用特殊的供应商特定标签来告诉我们诸如当前页或文档的总页数等信息，例如在文档页脚中使用的`<pdf:pagenumber>`和`<pdf:pagecount>`。我们还使用了Django提供的`{%
    lorem %}`模板标签，该标签生成50段拉丁文本，使用我们传递给该函数的`50 p`值。代表**Lorem Ipsum**的拉丁文本仅用于说明在没有实际编写该内容的情况下，当有超过一页的内容时会发生什么。
- en: 'The `size` attribute is used to specify the HTML document size that we want
    to specify the physical size and orientation of the PDF document. Next, use the
    `@page` and `@frame` CSS objects to format your PDF document:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`size`属性用于指定我们想要指定的HTML文档大小，即PDF文档的物理大小和方向。接下来，使用`@page`和`@frame`CSS对象来格式化你的PDF文档：'
- en: '[PRE196]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The `-pdf-frame-content` attribute is used to map the `@frame` object to the
    actual `<div>` with an ID attribute that matches the value specified. This must
    be `<div>` and not a `<header>` or `<footer>` HTML object or else your content
    will not render properly.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`-pdf-frame-content`属性用于将`@frame`对象映射到具有与指定值匹配的ID属性的实际情况下的`<div>`。这必须是`<div>`而不是`<header>`或`<footer>`HTML对象，否则你的内容将无法正确渲染。'
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, you should see a new file called `test.pdf` in
    your `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/` directory. When opening
    that document, you should see about eight pages worth of randomly generated Latin
    text, and on every page, you should see the same header and footer, as depicted
    in the following screenshot:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。这次，您应该在您的`/becoming_a_django_entdev/staticfiles/chapter_7/pdf/`目录中看到一个名为`test.pdf`的新文件。当打开该文档时，您应该看到大约八页的随机生成的拉丁文文本，并且在每一页上，您都应该看到相同的页眉和页脚，如图所示：
- en: '![Figure 7.13 – xhmtl2pdf – static PDF'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.13 – xhmtl2pdf – 静态PDF'
- en: '](img/Figure_7.13_B17243.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.13 – xhmtl2pdf – 静态PDF](img/Figure_7.13_B17243.jpg)'
- en: Figure 7.13 – xhmtl2pdf – static PDF
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.13 – xhmtl2pdf – 静态PDF
- en: Tip
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When opening this document to see what it looks like, particularly on Windows,
    you must close this document before submitting your form again, triggering it
    to generate a new document. You may run into permission errors stating that another
    person or application is already using that file if you don't.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开此文档查看其外观时，尤其是在Windows上，您必须在再次提交表单之前关闭此文档，这将触发它生成一个新的文档。如果您不这样做，可能会遇到权限错误，表明另一个人或应用程序已经在使用该文件。
- en: Let's add context to the PDF templates next.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来为PDF模板添加上下文。
- en: Adding context
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加上下文
- en: Let's pass the contents of the form field values into that PDF as context. This
    method does not always need to live in a form class; the same also applies to
    the `send_email()` method. They can live in a view or model class or even exist
    as a standalone utility method that can be used anywhere.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将表单字段值的内容传递到那个PDF中作为上下文。这种方法不一定要存在于表单类中；同样的，这也适用于`send_email()`方法。它们可以存在于视图或模型类中，甚至可以作为一个独立的实用方法，可以在任何地方使用。
- en: 'For now, modify the previous example to pass in context using the following
    steps:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，修改前面的示例，使用以下步骤传递上下文：
- en: 'In the same `generate_pdf()` method of the `ContactForm` class, make the changes
    highlighted here:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContactForm`类的同一个`generate_pdf()`方法中，进行以下突出显示的更改：
- en: '[PRE197]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Next, in the same `/chapter_7/pdfs/pdf_template.html` file, add the following
    highlighted code between the two existing lines of code, as shown:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在同一个`/chapter_7/pdfs/pdf_template.html`文件中，在现有的两行代码之间添加以下突出显示的代码，如图所示：
- en: '[PRE198]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The same code written in the *Providing template context* subsection of this
    chapter is used.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*提供模板上下文*小节中编写的相同代码被使用。
- en: Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. You should see a new file called `test_2.pdf` in the `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/`
    directory on your local machine. When you open that file, there should still be
    eight pages worth of content. On the first page only, there will be a list containing
    the content of the form that we just passed into that PDF template, as depicted
    here:![Figure 7.14 – xhmtl2pdf – dynamic PDF
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问相同的URL，`http://www.localhost:8000/chapter-7/form-class/`，并提交表单。您应该在您的本地机器上的`/becoming_a_django_entdev/staticfiles/chapter_7/pdf/`目录中看到一个名为`test_2.pdf`的新文件。当您打开该文件时，应该仍然有八页的内容。在第一页上，将有一个包含我们刚刚传递到该PDF模板中的表单内容的列表，如图所示：![Figure
    7.14 – xhmtl2pdf – 动态PDF
- en: '](img/Figure_7.14_B17243.jpg)'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.14 – xhmtl2pdf – 动态PDF](img/Figure_7.14_B17243.jpg)'
- en: Figure 7.14 – xhmtl2pdf – dynamic PDF
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.14 – xhmtl2pdf – 动态PDF
- en: Now that we know how to build PDF templates and generate PDF documents, we can
    present data in a very clean and structured way that makes using these a valuable
    reporting tool.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何构建PDF模板和生成PDF文档，我们可以以非常干净和结构化的方式展示数据，这使得它们成为有价值的报告工具。
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the skills gained after completing the exercises found in this chapter,
    you can now create and send messages, notifications, and reports of various types.
    We now know how to use the Django messages framework to serve up flash messages
    every time a page loads or reloads. We can create and send emails of various content
    types and even use an email test client account to capture those emails, indicating
    that they are actually working. We even installed a package and began building
    our own PDF reports.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章中找到的练习后获得的技能之后，您现在可以创建和发送各种类型的信息、通知和报告。我们现在知道如何使用Django消息框架在每次页面加载或重新加载时提供闪存消息。我们可以创建和发送各种内容类型的电子邮件，甚至可以使用电子邮件测试客户端账户来捕获这些电子邮件，表明它们实际上正在工作。我们甚至安装了一个包并开始构建我们自己的PDF报告。
- en: Use any combination of these tools to add value to your project. Flash messages,
    email notifications, and report generating concepts all help to keep users informed
    and engaged with your application. Always remember that too much information can
    overwhelm a user, such as having thousands of email notifications flooding their
    inbox. Use them wisely!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具的任何组合来为您的项目增加价值。闪存消息、电子邮件通知和报告生成概念都有助于让用户了解并参与您的应用程序。始终记住，过多的信息可能会让用户感到不知所措，例如有成千上万的电子邮件通知涌入他们的收件箱。明智地使用它们！
- en: The Django messages framework offers a wide range of tools that can create flash
    messages for users. With a little bit of creativity, the Django messages framework
    can be used with **Asynchronous JavaScript and XML** (**AJAX**) to serve up messages
    that act more like a **Single-Page App** (**SPA**). In the next chapter, [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    we will discuss what the Django REST framework is and how it can be used to work
    with AJAX requests.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Django消息框架提供了一系列工具，可以为用户创建闪存消息。只需一点创意，Django消息框架就可以与**异步JavaScript和XML**（**AJAX**）一起使用，提供更类似于**单页应用程序**（**SPA**）的消息。在下一章，[*第8章*](B17243_08_ePub.xhtml#_idTextAnchor239)，*使用Django
    REST框架*中，我们将讨论Django REST框架是什么以及如何使用它来处理AJAX请求。
