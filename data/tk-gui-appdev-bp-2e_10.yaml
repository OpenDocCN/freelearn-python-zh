- en: Miscellaneous Tips
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项提示
- en: We have reached the final chapter of this book. Let's end our discussion on
    Tkinter by looking at some concepts that, though very common in many **graphical
    user interface** (**GUI**) programs, did not appear in the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这本书的最后一章。让我们通过探讨一些概念来结束我们对Tkinter的讨论，尽管这些概念在许多**图形用户界面**（**GUI**）程序中非常常见，但在前面的章节中并未出现。
- en: 'We will cover the following in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下内容：
- en: Tracing Tkinter variables and attaching callbacks that are triggered when the
    value of a variable changes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪 Tkinter 变量并在变量值变化时附加回调函数
- en: Understanding the default keyboard widget traversal rules to provide a consistent
    user experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解默认键盘小部件遍历规则以提供一致的用户体验
- en: Validating user inputs using built-in Tkinter mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的 Tkinter 机制验证用户输入
- en: Formatting a widget's content as the user interacts with the widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将小部件的内容格式化，以便用户与小部件交互
- en: Understanding how Tkinter handles fonts and the best practices involved in using
    custom fonts in Tkinter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Tkinter如何处理字体以及在Tkinter中使用自定义字体的最佳实践
- en: Redirecting the command-line output to Tkinter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行输出重定向到 Tkinter
- en: Taking a look at the source code of Tkinter to understand class hierarchy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Tkinter的源代码以理解类层次结构
- en: Highlighting some current best practices involved in program design and implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出一些当前在程序设计和实现中涉及的最佳实践
- en: Getting an insight into code cleanup and program optimization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解代码清理和程序优化
- en: Distributing Tkinter applications as standalone programs to end users
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Tkinter 应用程序作为独立程序分发给最终用户
- en: Understanding the limitations of Tkinter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Tkinter 的局限性
- en: Exploring alternatives to Tkinter and understanding when it is better to use them
    instead of Tkinter and the tradeoffs involved
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Tkinter 的替代方案，了解何时使用它们代替 Tkinter 更为合适以及涉及到的权衡利弊
- en: Backporting Tkinter programs are written in Python 3.x versions to older Python 2.x
    versions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Tkinter 程序回迁到较旧的 Python 2.x 版本中，这些程序是用 Python 3.x 版本编写的
- en: Let's begin!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Tracing Tkinter variables
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪 Tkinter 变量
- en: When you specify a Tkinter variable, such as `textvariable`, for a widget (`textvariable
    = myvar`), the widget automatically gets updated whenever the value of the variable
    changes. However, there might be times when, in addition to updating the widget,
    you need to do some extra processing at the time of reading or writing (or modifying)
    the variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为小部件指定一个Tkinter变量，例如`textvariable`（`textvariable = myvar`），小部件会自动在变量值变化时更新。然而，有时除了更新小部件外，你还需要在读取或写入（或修改）变量时进行一些额外的处理。
- en: Tkinter provides a method to attach a callback method that will be triggered
    every time the value of a variable is accessed. Thus, the callback acts as a variable
    observer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 提供了一种方法来附加一个回调方法，该方法将在每次访问变量的值时被触发。因此，回调函数充当变量观察者。
- en: The callback creation method is named `trace_variable(self, mode, callback)` or
    simply `trace(self, mode, callback)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回调创建方法命名为 `trace_variable(self, mode, callback)` 或简称为 `trace(self, mode, callback)`。
- en: The mode argument can take a value of `r`, `w`, or `u`, which stand for *read*,
    *write*, or *undefined*. Depending upon the mode specifications, the callback
    method is triggered when the variable is read or written.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式参数可以取值为 `r`、`w` 或 `u`，分别代表 *读取*、*写入* 或 *未定义*。根据模式指定，当变量被读取或写入时，回调方法会被触发。
- en: 'By default, the callback method gets three arguments. The arguments, in order of
    their position, are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，回调方法接收三个参数。参数按照其位置顺序如下：
- en: The name of the Tkinter variable
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 变量的名称
- en: The index of the variable in case the Tkinter variable is an array, otherwise,
    it's an empty string
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Tkinter变量是一个数组时，变量的索引，否则为空字符串
- en: The access modes (`r`, `w`, or `u`)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问模式（`r`，`w` 或 `u`）
- en: Note that the triggered callback function may also modify the value of the variable. However,
    this modification does not trigger additional callbacks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，触发的回调函数也可能修改变量的值。然而，这种修改不会触发额外的回调。
- en: 'Let''s look at an example of variable tracing in Tkinter. Take a look at how
    a change in a traced Tkinter variable triggers a callback (see code `10.01_trace_variable.py`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 Tkinter 中变量追踪的例子。看看一个追踪的 Tkinter 变量的变化是如何触发回调函数的（参见代码 `10.01_trace_variable.py`）：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following line of code attaches a callback to `trace` the variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码将回调函数附加到`trace`变量：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, every time you write in the entry widget, it modifies the value of `my_variable`. Because
    we have set a `trace` on `my_variable`, it triggers the callback method that, in
    our example, simply prints the new value into the console, as shown in the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你在条目小部件中写入内容时，都会修改`my_variable`的值。因为我们已经在`my_variable`上设置了`trace`，它会触发回调方法，在我们的例子中，这个方法简单地将在控制台中打印新的值，如下面的截图所示：
- en: '![](img/b57b5fec-2dd6-4a17-a180-4754bf9b2bc5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b57b5fec-2dd6-4a17-a180-4754bf9b2bc5.png)'
- en: 'The `trace` on a variable is active until it is explicitly deleted. You can
    delete a `trace` using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的`trace`（跟踪）在显式删除之前是活跃的。你可以使用以下命令来删除`trace`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `trace` method returns the ID and name of the callback method. This can
    be used to get the name of the callback method that needs to be deleted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace` 方法返回回调方法的 ID 和名称。这可以用来获取需要删除的回调方法的名称。'
- en: Widget traversal
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件遍历
- en: If a GUI has more than one widget, a given widget can come under focus when
    you explicitly click on the widget. Alternatively, the focus can be shifted to
    other widgets in the order that the widgets were created in the program by pressing
    the *Tab* key on the keyboard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个图形用户界面（GUI）包含多个小部件，当你明确地点击某个小部件时，该小部件可以获得焦点。或者，可以通过按键盘上的*Tab*键，按照小部件在程序中创建的顺序将焦点转移到其他小部件上。
- en: Therefore, it is vital to create widgets in the order that we want the user
    to traverse through them. Otherwise, the user will have a tough time navigating
    between the widgets using the keyboard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照我们希望用户遍历它们的顺序创建小部件至关重要。否则，用户在使用键盘在各个小部件之间导航时将会遇到困难。
- en: Different widgets are designed to behave differently to different keyboard strokes.
    Therefore, let's spend some time trying to understand the rules of traversing
    through widgets using the keyboard.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的控件被设计成对不同的键盘按键有不同的响应。因此，让我们花些时间来尝试理解使用键盘在控件之间导航的规则。
- en: 'Have a look at the `10.02_widget_traversal.py` file to understand the keyboard
    traversal behavior for different widgets. The code displays a window like the
    one shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`10.02_widget_traversal.py`文件以了解不同小部件的键盘遍历行为。代码显示的窗口如下截图所示：
- en: '![](img/0b8bc194-c422-40b9-afb6-d83a68737de3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b8bc194-c422-40b9-afb6-d83a68737de3.png)'
- en: The code will not be given here as it is very simple (see the `10.02_widget_traversal.py` code).
    It simply adds an entry widget, a few buttons, a few radio buttons, a text widget,
    a label widget, and a scale widget.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将不会在此处给出，因为它非常简单（参见`10.02_widget_traversal.py`代码）。它仅仅添加了一个条目小部件、几个按钮、几个单选按钮、一个文本小部件、一个标签小部件和一个刻度小部件。
- en: The code demonstrates the default keyboard traversal behaviors for these widgets in
    Tkinter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码演示了这些小部件在Tkinter中的默认键盘遍历行为。
- en: 'The following are a few important points that you should note:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你应该注意的重要要点：
- en: The *Tab* key can be used to traverse forward, and *Shift* + *Tab* can be used
    to traverse backward.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *Tab* 键可以向前遍历，而 *Shift* + *Tab* 可以向后遍历。
- en: A user can traverse through the widgets in the order that they were created. A
    parent widget is visited first (unless it is excluded using `takefocus = 0`), followed
    by all of its children widgets.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以按照它们创建的顺序遍历小部件。首先访问父级小部件（除非使用`takefocus = 0`将其排除），然后是所有子小部件。
- en: You can use `widget.focus_force()` to force the input focus on a widget.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `widget.focus_force()` 来强制将输入焦点置于一个部件上。
- en: You cannot traverse a text widget by using the *Tab* key because the text widget
    can contain tab characters as its content. Instead, the text widget can be traversed
    by using *Ctrl* + *Tab*.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能通过使用 *Tab* 键来遍历文本小部件，因为文本小部件可以包含作为其内容的制表符。相反，您可以通过使用 *Ctrl* + *Tab* 来遍历文本小部件。
- en: Buttons on the widget can be pressed using the spacebar. Similarly, check buttons
    and radio buttons can also be traversed using the spacebar.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件上的按钮可以使用空格键进行按下。同样，复选框和单选按钮也可以使用空格键进行遍历。
- en: You can go up and down the items in a Listbox widget by using the up and down
    arrows.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用上下箭头在列表框小部件中上下移动项目。
- en: The Scale widget responds to the left and right arrow keys and the up and down
    arrow keys. Similarly, the Scrollbar widget responds to the left/right or up/down
    arrow keys, depending on their orientation.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例控件对左右箭头键以及上下箭头键做出响应。同样，滚动条控件根据其方向对左右或上下箭头键做出响应。
- en: By default, most of the widgets (except Frame, Label, and Menus) get an outline
    when they have the focus set on them. This outline is normally displayed as a
    thin black border around the widget. You can even set the Frame and Label widgets
    to show this outline by setting the `highlightthickness` option to a nonzero integer
    value for these widgets.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，大多数小部件（除Frame、Label和菜单外）在它们获得焦点时都会有一个轮廓。这个轮廓通常显示为围绕小部件的细黑边框。您甚至可以通过将这些小部件的`highlightthickness`选项设置为非零整数来使Frame和Label小部件显示这个轮廓。
- en: We can change the color of the outline by using `highlightcolor= 'red'` in the
    code.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在代码中使用`highlightcolor= 'red'`来改变轮廓的颜色。
- en: Frame, Label, and Menu are not included in the tab's navigation path. However,
    they can be included in the navigation path by using the `takefocus = 1` option.
    You can explicitly exclude a widget from the tab's navigation path by using the
    `takefocus = 0` option.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签页的导航路径不包括框架、标签和菜单。然而，可以通过使用`takefocus = 1`选项将它们包含在导航路径中。您可以使用`takefocus =
    0`选项显式地从标签页的导航路径中排除一个小部件。
- en: Validating user input
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Let's discuss input data validation in Tkinter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论 Tkinter 中的输入数据验证。
- en: Most of the applications that we have developed in our book are point-and-click-based
    (the drum machine, the chess game, and the drawing application), where a validation
    of user input is not required. However, data validation is a must in programs
    such as the phone book application, where a user enters some data and we store
    it in a database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中开发的大部分应用程序都是基于点选的（如鼓机、棋类游戏和绘图应用），在这些应用中不需要验证用户输入。然而，在如电话簿应用这样的程序中，用户输入一些数据，我们将这些数据存储在数据库中，数据验证是必须的。
- en: Ignoring user input validation can be dangerous in such applications because
    input data can be misused for SQL injection. In general, an application in which
    a user can enter textual data is a good candidate for the validation of user input.
    In fact, not trusting user inputs is almost considered a maxim.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略用户输入验证在此类应用中可能很危险，因为输入数据可能会被用于SQL注入。一般来说，允许用户输入文本数据的应用程序是验证用户输入的良好候选者。实际上，不信任用户输入几乎被视为一条准则。
- en: Wrong user inputs may be intentional or accidental. In either case, if you fail
    to validate or sanitize data, unexpected errors may occur in your program. In
    a worst-case scenario, user input can be used to inject harmful code that may
    be capable of crashing a program or wiping out an entire database.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的用户输入可能是故意的或偶然的。在任何情况下，如果你未能验证或清理数据，你的程序可能会出现意外的错误。在最坏的情况下，用户输入可能被用来注入有害代码，这些代码可能足以使程序崩溃或清除整个数据库。
- en: Widgets, such as Listbox, Combobox, and Radiobuttons, allow limited input options and
    hence, they normally cannot be misused to input wrong data. On the other hand, widgets
    such as the Entry widget, the Spinbox widget, and the Text widget allow a large
    possibility of user inputs, and hence, they need to be validated for correctness.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件，例如列表框（Listbox）、组合框（Combobox）和单选按钮（Radiobuttons），允许有限的输入选项，因此它们通常不能被误用来输入错误的数据。另一方面，像输入框小部件（Entry
    widget）、旋转框小部件（Spinbox widget）和文本小部件（Text widget）这样的小部件允许用户有较大的输入可能性，因此它们需要被验证以确保正确性。
- en: To enable validation on a widget, you need to specify an additional option of
    the `validate = 'validationmode'` form to the widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件上启用验证，您需要向组件指定一个额外的`validate = 'validationmode'`表单选项。
- en: 'For example, if you want to enable validation on an Entry widget, you begin
    by specifying the validate option, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在 Entry 小部件上启用验证，你首先需要指定验证选项，如下所示：
- en: '`Entry( root, validate="all", validatecommand=vcmd)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry( root, validate="all", validatecommand=vcmd)`'
- en: 'Validation can occur in one of the following validation modes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 验证可以在以下验证模式之一中发生：
- en: '| **Validation Mode** | **Explanation** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **验证模式** | **说明** |'
- en: '| `none` | This is the default mode. No validation occurs if `validate` is
    set to `none`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 这是默认模式。如果将 `validate` 设置为 `none`，则不会发生验证。 |'
- en: '| `focus` | When validate is set to focus, the `validate` command is called twice—once
    when the widget receives focus, and once when the focus is lost. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 当`validate`设置为focus时，`validate`命令会被调用两次——一次是在小部件获得焦点时，另一次是在焦点丢失时。
    |'
- en: '| `focusin` | The `validate` command is called when the widget receives focus.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `focusin` | 当小部件获得焦点时调用`validate`命令。 |'
- en: '| `focusout` | The `validate` command is called when the widget loses focus.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `focusout` | 当小部件失去焦点时调用`validate`命令。 |'
- en: '| `key` | The `validate` command is called when the entry is edited. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 当条目被编辑时，会调用`validate`命令。 |'
- en: '| `all` | The `validate` command is called in all the aforementioned cases.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 在所有上述情况下都会调用 `validate` 命令。 |'
- en: The `10.03_validation_mode_demo.py` code file demonstrates all of these validation modes
    by attaching them to a single `validation` method. In the code, note the different
    ways in which different Entry widgets respond to different events. Some Entry
    widgets call the `validation` method on the focus events, others call the `validation`
    method at the time of entering keystrokes into a widget, and still others use
    a combination of the focus and key events.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`10.03_validation_mode_demo.py` 代码文件通过将它们附加到单个 `validation` 方法上来演示所有这些验证模式。在代码中，注意不同
    Entry 小部件对不同事件的响应方式。一些 Entry 小部件在焦点事件上调用 `validation` 方法，其他小部件在将按键输入到小部件时调用 `validation`
    方法，还有一些小部件则使用焦点和按键事件的组合。'
- en: Although we did set the validation mode to trigger the `validate` method, we
    need some data to validate against the rules. This is passed to the `validate`
    method using percent substitution. For instance, we passed the mode as an argument
    to the
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确实设置了验证模式以触发`validate`方法，但我们仍需要一些数据来与规则进行验证。这些数据通过百分比替换传递给`validate`方法。例如，我们将模式作为参数传递给
- en: '`validate` method by performing a percent substitution on the `validate` command, as
    demonstrated in the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`validate`命令上执行百分比替换来使用`validate`方法，如下命令所示：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This was followed by passing the value of `v` as an argument to the `validate`
    method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是将`v`的值作为参数传递给`validate`方法：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to `%V`, Tkinter recognizes the following percent substitutions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `%V`，Tkinter 还识别以下百分比替换：
- en: '| **Percent substitutions** | **Explanation** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **百分比替换** | **解释** |'
- en: '| `%d` | The type of action that is performed on a widget (`1` for insert,
    `0` for delete, and `-1` for a focus, forced, or `textvariable` validation). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 在小部件上执行的操作类型（`1` 表示插入，`0` 表示删除，`-1` 表示焦点、强制或 `textvariable` 验证）。 |'
- en: '| `%i` | The index of the char string that is inserted or deleted, if any. Otherwise,
    it will be `-1`. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `%i` | 插入或删除的字符字符串的索引（如果有的话）。否则，它将是 `-1`。 |'
- en: '| `%P` | The value of the entry in case the edit is allowed. If you are configuring the
    Entry widget to have a new `textvariable`, this will be the value of that `textvariable`.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `%P` | 如果允许编辑，条目中的值。如果您正在配置 Entry 小部件以具有新的 `textvariable`，这将是指定 `textvariable`
    的值。 |'
- en: '| `%s` | The current value of the entry prior to editing. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 编辑前的条目当前值。 |'
- en: '| `%S` | The text string being inserted or deleted if any. Otherwise, `{}`.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 正在被插入或删除的文本字符串（如果有）。否则，`{}`。 |'
- en: '| `%v` | The type of validation that has been currently set. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `%v` | 当前已设置的验证类型。 |'
- en: '| `%V` | The type of validation that triggers the callback method (`key`, `focusin`, `focusout`,
    and forced). |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `%V` | 触发回调方法的验证类型（`key`、`focusin`、`focusout`和强制）。 |'
- en: '| `%W` | The name of the Entry widget. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `%W` | 条目小部件的名称。 |'
- en: These substitution values provide us with the necessary data to validate the
    input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替换值为我们提供了验证输入所需的数据。
- en: 'Let''s pass all of these values and just print them through a dummy `validate`
    method just to see what kind of data that we can expect to get on carrying out
    the validations (see the `10.04_percent_substitutions_demo.py` code):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们传递所有这些值，并通过一个虚拟的 `validate` 方法来打印它们，只是为了看看在执行验证时我们可以期望得到什么样的数据（参见 `10.04_percent_substitutions_demo.py`
    代码）：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the line where we register a `validate` method by passing all the possible percent
    substitutions to the callback.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过传递所有可能的百分比替换到回调函数中注册的`validate`方法所在的行。
- en: Take particular note of the data returned by `%P` and `%s` because they pertain
    to the actual data entered by the user in the Entry widget. In most cases, you
    will be checking either of these two data sources against the validation rules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意由 `%P` 和 `%s` 返回的数据，因为它们与用户在输入小部件中实际输入的数据相关。在大多数情况下，您将检查这两个数据源中的任何一个，以验证规则。
- en: Now that we have a background of rules for data validation, let's have a look
    at two practical examples that demonstrate input validation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据验证的规则背景，让我们看看两个演示输入验证的实际例子。
- en: Key validation mode demo
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键验证模式演示
- en: 'Let''s assume that we have a form that asks for a username. We want users to
    input only alphabetical or space characters in the name. Thus, a number of special
    characters should not be allowed, as shown in the following screenshot of the
    widget:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个要求输入用户名的表单。我们希望用户在输入名字时只使用字母或空格字符。因此，不应允许使用一些特殊字符，如下面的小部件截图所示：
- en: '![](img/fa7793c5-9426-4a2f-9ffe-4c604b640392.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa7793c5-9426-4a2f-9ffe-4c604b640392.png)'
- en: This is clearly a case for the `key` validation mode because we want to check whether
    an entry is valid after every keypress. The percent substitution that we need
    to check is `%S` because it yields the text string being inserted or deleted in
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个需要使用`key`验证模式的案例，因为我们希望在每次按键后检查一个条目是否有效。我们需要检查的百分比替换是`%S`，因为它会返回插入或删除的文本字符串。
- en: 'the Entry widget. Therefore, the code that validates the Entry widget is as
    follows (see the `10.05_key_validation.py` code):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Entry小部件。因此，验证Entry小部件的代码如下（参见`10.05_key_validation.py`代码）：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: We first register two options, namely `validatecommand ( vcmd )` and `invalidcommand
    ( invcmd )`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先注册两个选项，即`validatecommand ( vcmd )`和`invalidcommand ( invcmd )`。
- en: In the example, `validatecommand` is registered to call the `validate_data` method,
    and the `invalidcommand` option is registered to call another method named `invalid_name`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例中，`validatecommand` 被注册为调用 `validate_data` 方法，而 `invalidcommand` 选项被注册为调用另一个名为
    `invalid_name` 的方法。
- en: The `validatecommand` option specifies a method that needs to be evaluated,
    which will validate the input. The validation method must return a Boolean value,
    where `True` signifies that the data entered is valid, and a `False` return value
    signifies that the data is invalid.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validatecommand`选项指定了一个需要评估的方法，该方法将验证输入。验证方法必须返回一个布尔值，其中`True`表示输入的数据有效，而`False`返回值表示数据无效。'
- en: In case the validate method returns `False` (invalid data), no data is added
    to the Entry widget and the script registered for `invalidcommand` is evaluated.
    In our case, a False validation will call the `invalid_name ` method. The `invalidcommand`
    method is generally responsible for displaying error messages or setting back
    the focus to the Entry widget.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证方法返回 `False`（无效数据），则不会将数据添加到条目小部件中，并且会评估为 `invalidcommand` 注册的脚本。在我们的情况下，无效验证将调用
    `invalid_name` 方法。`invalidcommand` 方法通常负责显示错误消息或将焦点设置回条目小部件。
- en: Focus-out validation mode demo
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离焦验证模式演示
- en: The previous example demonstrated validation in the `key` mode. This means that the
    validation method was called after every keypress to check whether an entry was
    valid.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了在`key`模式下的验证。这意味着验证方法在每次按键后都会被调用，以检查输入是否有效。
- en: However, there are situations where you might want to check the entire string entered
    into the widget rather than checking individual keystroke entries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下你可能想要检查整个输入到小部件中的字符串，而不是检查单个按键输入。
- en: For example, when an Entry widget accepts a valid email address, we would ideally like
    to check the validity after the user has entered the entire email address and
    not after every keystroke entry. This will qualify for a validation in the `focusout`
    mode.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个条目小部件接受一个有效的电子邮件地址时，我们理想情况下希望在用户输入完整电子邮件地址之后而不是在每次按键输入之后检查其有效性。这将适用于`focusout`模式的验证。
- en: 'Check out `10.06_focus_out_validation.py` for a demonstration of email validation
    in the `focusout` mode, which gives us the following GUI:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`10.06_focus_out_validation.py`以了解在`focusout`模式下的电子邮件验证演示，该模式为我们提供了以下GUI：
- en: '![](img/7f2093f9-0445-426e-9b5d-a8d863daa7e5.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f2093f9-0445-426e-9b5d-a8d863daa7e5.png)'
- en: 'The code for the aforementioned demo is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述演示的代码如下：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code has a lot of similarities to the previous validation example. However,
    note the following differences:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的验证示例有很多相似之处。然而，请注意以下差异：
- en: The validate mode is set to `focusout` in contrast to the `key` mode in the previous
    example. This means that the validation will be done only when the Entry widget
    loses focus. The validation occurs when you hit the *Tab* key. Thus, the input
    box does not lose its focus in case the input is invalid.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模式设置为`focusout`，与上一个示例中的`key`模式相对比。这意味着验证仅在Entry小部件失去焦点时进行。验证发生在你按下*Tab*键时。因此，如果输入无效，输入框不会失去焦点。
- en: This program uses data provided by the `%P` percentage substitution, while the
    previous example used `%S`. This is understandable because `%P` provides the value
    entered in the Entry widget, but `%S` provides the value of the last keystroke.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此程序使用由 `%P` 百分比替换提供的数据，而先前的示例使用了 `%S`。这是可以理解的，因为 `%P` 提供了在输入小部件中输入的值，但 `%S`
    提供了最后按键的值。
- en: This program uses regular expressions to check whether the entered value corresponds
    to a valid email format. Validation usually relies on regular expressions. A whole
    lot of explanation is required to cover this topic, but that is beyond the scope
    of this book. For more information on regular expression modules, visit [http://docs.python.org/3.6/library/re.html](http://docs.python.org/3.6/library/re.html).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此程序使用正则表达式来检查输入的值是否对应有效的电子邮件格式。验证通常依赖于正则表达式。要涵盖这个主题需要大量的解释，但这超出了本书的范围。有关正则表达式模块的更多信息，请访问[http://docs.python.org/3.6/library/re.html](http://docs.python.org/3.6/library/re.html)。
- en: This concludes our discussion on input validation in Tkinter. Hopefully, you
    should now be able to implement input validation to suit your custom needs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Tkinter 中输入验证的讨论。希望你现在应该能够根据你的自定义需求实现输入验证。
- en: Formatting widget data
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化小部件数据
- en: Input data such as date, time, phone number, credit card number, website URL,
    and IP number, have an associated display format. For instance, the date can be better
    represented in a `MM/DD/YYYY` format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据，如日期、时间、电话号码、信用卡号码、网站URL和IP地址，都有相应的显示格式。例如，日期可以更好地以`MM/DD/YYYY`格式表示。
- en: 'Fortunately, it is easy to format data in the required format as the user enters
    it in the widget, as shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当用户在组件中输入数据时，格式化所需格式的数据很容易，如下面的截图所示：
- en: '![](img/68a447d2-d557-46b9-b123-df47959e326c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68a447d2-d557-46b9-b123-df47959e326c.png)'
- en: 'The `10.07_formatting_entry_widget_to_display_date.py` code automatically formats
    user input to insert forward slashes at the required places to display the date
    entered by a user in the `MM/DD/YYYY` format:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`10.07_formatting_entry_widget_to_display_date.py` 代码自动格式化用户输入，在需要的位置插入正斜杠，以显示用户输入的日期，格式为
    `MM/DD/YYYY`：'
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: The Entry widget is bound to the keypress event, where every new keypress calls
    the related `format_date_entry_widget` callback method.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entry小部件绑定到按键事件，每次新的按键都会调用相关的`format_date_entry_widget`回调方法。
- en: First, the `format_date_entry_widget` method breaks down the entered text into
    an equivalent list named `entry_list` and ignores the slash/symbol that may have
    been entered by a user.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`format_date_entry_widget` 方法将输入的文本分解成一个名为 `entry_list` 的等效列表，并忽略用户可能输入的斜杠/符号。
- en: It then iterates through the `self.slash_positions` list and inserts the slash symbol
    at all the required positions in `entry_list`. The net result of this is a list
    that has slashes inserted at all the right places.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它遍历`self.slash_positions`列表，并在`entry_list`中所有必需的位置插入斜杠符号。这个操作的结果是一个在所有正确位置都插入了斜杠的列表。
- en: The next line converts this list into an equivalent string using `join()` and then
    sets the value of the Entry widget to this string. This ensures that the Entry
    widget text is formatted into the aforementioned date format.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行使用 `join()` 将此列表转换为等效的字符串，然后将 Entry 小部件的值设置为该字符串。这确保了 Entry 小部件的文本格式化为上述日期格式。
- en: The remaining pieces of code simply control the cursor to ensure that the cursor
    advances by one position whenever it encounters the slash symbol. It also ensures
    that keypresses, such as *Backspace*, right, left, up, and down are handled properly.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的代码片段仅用于控制光标，确保光标在遇到斜杠符号时前进一个位置。它还确保了诸如*退格*、右键、左键、上键和下键等按键操作得到正确处理。
- en: Note that this method does not validate the date value, and users may add an
    invalid date. The method defined here will simply format it by adding a forward
    slash at the third and sixth positions. Adding date validation to this example
    is left as an exercise for you to complete.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法并不验证日期值，用户可能会添加一个无效的日期。这里定义的方法将简单地通过在第三位和第六位添加正斜杠来格式化它。将日期验证添加到此示例作为一项练习留给你来完成。
- en: This concludes our brief discussion on formatting data within widgets. Hopefully, you
    should now be able to create formatted widgets for a wide variety of input data
    that can be better displayed in a given format.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们在小部件内格式化数据的简要讨论。希望你现在能够创建适用于各种输入数据的格式化小部件，以便在特定格式中更好地显示。
- en: More on fonts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于字体
- en: Many Tkinter widgets let you specify custom font specifications either at the
    time of widget creation or later by using the `configure()` option. For most cases, default
    fonts provide a standard look and feel. However, if you want to change font specifications,
    Tkinter lets you do so. There is one caveat, though.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Tkinter 小部件允许你在创建小部件时或稍后通过使用 `configure()` 选项来指定自定义字体规范。在大多数情况下，默认字体提供了标准的视觉和感觉。然而，如果你想更改字体规范，Tkinter
    允许你这样做。但有一个注意事项。
- en: When you specify your own font, you need to make sure that it looks good on
    all the platforms where your program is intended to be deployed because a font
    might look good on a particular platform, but it may look awful on another platform.
    Unless you know what you are doing, it is always advisable to stick to Tkinter's
    default fonts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定自己的字体时，你需要确保它在你的程序打算部署的所有平台上看起来都很好，因为某个平台上字体可能看起来不错，但在另一个平台上可能看起来很糟糕。除非你清楚自己在做什么，否则始终建议坚持使用Tkinter的默认字体。
- en: Most platforms have their own set of standard fonts that are used by the platform's native
    widgets. So, rather than trying to reinvent the wheel on what looks good on a
    given platform or what would be available for a given platform, Tkinter assigns these
    standard platform-specific fonts to its widget, thus providing a native look and
    feel on every platform.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台都有自己的标准字体集，这些字体由平台的本地小部件使用。因此，与其试图在特定平台上重新发明轮子，或者为特定平台提供什么字体可用，Tkinter
    将这些标准平台特定字体分配给其小部件，从而在每一个平台上提供原生外观和感觉。
- en: 'Tkinter assigns nine fonts to nine different names; you can use these fonts
    in your programs. The font names are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 将九种字体分配给九个不同的名称；你可以在你的程序中使用这些字体。字体名称如下：
- en: '`TkDefaultFont`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkDefaultFont`'
- en: '`TkTextFont`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkTextFont`'
- en: '`TkFixedFont`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkFixedFont`'
- en: '`TkMenuFont`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkMenuFont`'
- en: '`TkHeadingFont`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkHeadingFont`'
- en: '`TkCaptionFont`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkCaptionFont`'
- en: '`TkSmallCaptionFont`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkSmallCaptionFont`'
- en: '`TkIconFont`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkIconFont`'
- en: '`TkTooltipFont`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkTooltipFont`'
- en: 'Accordingly, you can use them in your programs in the following way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在你的程序中以以下方式使用它们：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using these kinds of fonts markups, you can rest assured that your font will
    look native across all platforms.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些字体标记，你可以放心，你的字体将在所有平台上看起来都很原生。
- en: Finer control over font
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对字体有更精细的控制
- en: In addition to the aforementioned method of handling fonts, Tkinter provides
    a separate `Font` class implementation. The source code for this class is located
    in the same folder as the source code for Tkinter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述处理字体的方法外，Tkinter 还提供了一个独立的 `Font` 类实现。这个类的源代码位于与 Tkinter 源代码相同的文件夹中。
- en: On my Linux machine, the source code is located in `/usr/local/lib/python3.6/tkinter/font.py`.
    On Windows (with a default Python 3.6 install) the location is `C:\Program Files
    (x86)\Python36-32\Lib\tkinter\font.py`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Linux 机器上，源代码位于 `/usr/local/lib/python3.6/tkinter/font.py`。在 Windows（默认安装
    Python 3.6）的情况下，位置是 `C:\Program Files (x86)\Python36-32\Lib\tkinter\font.py`。
- en: 'To use this module, you need to import fonts into your namespace, as follows (see
    the `10.08_font_demo.py` code):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，您需要将字体导入到您的命名空间中，如下所示（参见`10.08_font_demo.py`代码）：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The console output of this program on my terminal is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序在我的终端上的控制台输出如下：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `font` module provides much better fine-grained control
    over various aspects of fonts that are otherwise inaccessible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`font`模块提供了对字体各个方面的更精细的控制，这些方面在其他情况下是无法访问的。
- en: Building a font selector
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建字体选择器
- en: 'Now that we have seen the basic features that are available in Tkinter''s `font`
    module, let''s implement a font selector like the one shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Tkinter 的 `font` 模块中可用的基本功能，接下来让我们实现一个类似于以下截图所示的字体选择器：
- en: '![](img/cedda725-82e3-4356-8031-95999711f122.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cedda725-82e3-4356-8031-95999711f122.png)'
- en: 'The key to building the font selector shown in the preceding screenshot is
    to fetch a list of all the fonts installed on a system. A call to the `families()`
    method from the `font` module fetches a tuple of all the fonts available on a
    system. Accordingly, when you run the following code, a tuple of all the fonts
    available on the system gets printed (see the `10.09_all_fonts_on_a_system.py` code):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '构建前一个屏幕截图所示字体选择器的关键是获取系统上安装的所有字体的列表。从`font`模块调用`families()`方法可以获取系统上所有可用的字体的元组。因此，当你运行以下代码时，系统上所有可用的字体的元组将被打印出来（请参阅`10.09_all_fonts_on_a_system.py`代码）:'
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that since `font` is a submodule of Tkinter, it needs an instance of `Tk()`,
    which loads the Tcl interpreter, before it can fetch the tuple.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`font`是Tkinter的一个子模块，在它能够获取元组之前，需要有一个`Tk()`实例，该实例加载了Tcl解释器。
- en: Now that we have a tuple of all the fonts available on a system, we just need
    to create the GUI shown in the preceding screenshot and attach relevant callbacks to
    all the widgets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了系统上所有可用的字体元组，我们只需要创建前面截图所示的GUI，并将相关的回调函数附加到所有小部件上。
- en: 'We will not discuss the code that creates the GUI shown in the preceding screenshot. Check
    out `10.10_font_selector.py` for the complete code. However, note that the code
    attaches the following callback to all the widgets:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会讨论创建前面截图所示GUI的代码。请查看`10.10_font_selector.py`以获取完整的代码。然而，请注意，该代码将以下回调附加到所有小部件上：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `fontspecs` is a custom tag that we attached to the sample text in the
    text widget, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fontspecs` 是我们附加到文本小部件中示例文本上的自定义标签，如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This concludes our brief discussion on playing with fonts in Tkinter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们在 Tkinter 中玩转字体的简短讨论。
- en: Redirecting the command-line output to Tkinter
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将命令行输出重定向到 Tkinter
- en: You may occasionally need to redirect the output of a command line to a GUI
    such as Tkinter. The ability to pass outputs from the command line to Tkinter
    opens a large pool of possibilities for using the inherent powers of the shell
    on Unix and Linux operating systems and the Windows shell on a Windows machine.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能偶尔需要将命令行的输出重定向到图形用户界面，例如Tkinter。将命令行的输出传递到Tkinter的能力，为在Unix和Linux操作系统以及Windows机器上的Windows
    Shell使用shell的固有功能打开了一个广阔的可能性池。
- en: We will demonstrate this by using the `subprocess` Python module, which lets
    us spawn new processes, connect to the input, output, and error pipes of this
    new process, and obtain the return codes from the programs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 Python 的 `subprocess` 模块来演示这一点，该模块允许我们启动新的进程，连接到新进程的输入、输出和错误管道，并从程序中获取返回代码。
- en: A detailed discussion on the `subprocess` module can be found at [https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`subprocess`模块的详细讨论可以在[https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html)找到。
- en: We will use the `Popen` class from the `subprocess` module to create a new process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自`subprocess`模块的`Popen`类来创建一个新的进程。
- en: 'The `Popen` class provides a cross-platform way to create new processes, and
    it has the following long signature to handle most of the common and esoteric
    use cases:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Popen` 类提供了一种跨平台创建新进程的方法，并且具有以下长签名来处理大多数常见和特殊的使用场景：'
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s a simple program that shows how we can redirect the output of the `ls` Bash
    shell command to Tkinter''s text widget. As a reminder, the `ls` command in the
    Bash scripting language returns a list of all files and directories (see the `10.11_reading_from_command_line.py` code):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的程序，展示了我们如何将 `ls` Bash 命令的输出重定向到 Tkinter 的文本小部件。作为提醒，Bash 脚本语言中的 `ls`
    命令返回所有文件和目录的列表（参见 `10.11_reading_from_command_line.py` 代码）：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Windows users should note that you will have to replace `ls` with `dir` in the highlighted
    part of the preceding code to get an equivalent result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户请注意，您需要在前面代码的高亮部分将`ls`替换为`dir`以获得等效的结果。
- en: 'Furthermore, note that you can pass extra arguments to `Popen` by using the following
    format:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，您可以通过以下格式向`Popen`传递额外的参数：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Even better, you can pass the name of the script file that needs to be executed
    in the new process. The code used to run a script file is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以在新进程中传递需要执行脚本的文件名。运行脚本文件的代码如下：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, the script file that needs to be executed must include a proper shebang declaration
    to let the program choose a proper executing environment for your script. For
    instance, if you intend to run a Python script, your script must begin with the
    shebang of the `#!/usr/bin/env python3` form. Similarly, you need to include `#!/bin/sh`
    to run a Bourne-compatible shell script. A shebang isn't necessary on Windows.
    It is also not required for binary executables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要执行的脚本文件必须包含一个适当的shebang声明，以便程序为您的脚本选择一个合适的执行环境。例如，如果您打算运行Python脚本，您的脚本必须以`#!/usr/bin/env
    python3`形式的shebang开始。同样，您需要包含`#!/bin/sh`来运行与Bourne兼容的shell脚本。在Windows上不需要shebang。二进制可执行文件也不需要。
- en: 'Running the preceding program produces a window, and a listing of all the files
    from the current directory are added to the text widget, as shown in the following
    screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序会弹出一个窗口，并将当前目录下所有文件的列表添加到文本小部件中，如下面的截图所示：
- en: '![](img/05fe7cb1-51dd-4408-9e44-c07536d40593.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05fe7cb1-51dd-4408-9e44-c07536d40593.png)'
- en: While the preceding program is simple, this technique can have a lot of practical uses.
    For instance, you may recall that we built a chat server in the previous chapter. Every
    time a new client connected to the server, it printed the client details to the terminal.
    We could have easily redirected that output into a new Tkinter app. This would
    enable us to create a dashboard for the server; from there, we could have monitored
    all the incoming connections to the server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的程序很简单，但这种技术有很多实际用途。例如，你可能记得我们在上一章中构建了一个聊天服务器。每次有新的客户端连接到服务器时，它都会将客户端详细信息打印到终端。我们本可以将那个输出重定向到一个新的Tkinter应用程序。这将使我们能够为服务器创建一个仪表板；从那里，我们可以监控所有连接到服务器的传入连接。
- en: This opens the door for us to reuse any command-line script written in any other
    programming language, such as Perl or Bash, and directly integrate it with a Tkinter
    program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们打开了重用任何用其他编程语言（如Perl或Bash）编写的命令行脚本的大门，并直接将其集成到Tkinter程序中。
- en: This concludes the brief section on the redirection of command-line outputs
    into Tkinter programs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于将命令行输出重定向到Tkinter程序的简要部分。
- en: The class hierarchy of Tkinter
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 的类层次结构
- en: As programmers, we hardly need to understand the class hierarchy of Tkinter.
    After all, we have been able to code all the applications so far without bothering
    with the overall class hierarchy. However, knowing the class hierarchy enables
    us to `trace` the origin of a method within the source code or source documentation
    of a method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们几乎不需要理解 Tkinter 的类层次结构。毕竟，到目前为止，我们能够在不关心整体类层次结构的情况下编写所有应用程序。然而，了解类层次结构使我们能够`追踪`方法在源代码或方法源文档中的起源。
- en: In order to understand the class hierarchy of Tkinter, let's take a look at
    the source code of Tkinter. On the Windows installation, the source code of Tkinter
    is located at `path\of\Python\Installation\Lib\tkinter\`. On my Linux machine,
    the
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Tkinter 的类层次结构，让我们来看看 Tkinter 的源代码。在 Windows 安装中，Tkinter 的源代码位于 `path\of\Python\Installation\Lib\tkinter\`。在我的
    Linux 机器上，
- en: source code is located at `/usr/lib/python3.6/tkinter/` .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于 `/usr/lib/python3.6/tkinter/` 。
- en: 'If you open the `__init__.py` file from this folder in a code editor and look
    at its list of class definitions in Tkinter, you will see the following structure:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个代码编辑器中打开这个文件夹中的 `__init__.py` 文件，并查看其 Tkinter 中的类定义列表，你会看到以下结构：
- en: '![](img/a4c1654f-080d-44b9-93cf-14ed4a8c5b10.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4c1654f-080d-44b9-93cf-14ed4a8c5b10.png)'
- en: So, what can you see here? We have class definitions for each core Tkinter widget.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你在这里能看到什么？我们为每个核心Tkinter小部件提供了类定义。
- en: In addition to this, we have class definitions for different geometry managers
    and variable types defined within Tkinter. These class definitions are what you
    would normally expect to be there.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有为不同的几何管理器和Tkinter内部定义的变量类型提供的类定义。这些类定义正是您通常期望存在的。
- en: However, in addition to these, you will see some more class names, such as `BaseWidget,
    Misc`, `Tk`, `Toplevel`, `Widget`, and `Wm`. All of these classes are circled
    in the preceding screenshot. So, what services do these classes provide, and where
    do they fit in the larger scheme of things?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些之外，你还会看到一些更多的类名，例如`BaseWidget, Misc`, `Tk`, `Toplevel`, `Widget`, 和 `Wm`。所有这些类都在前面的截图中被圈出。那么，这些类提供了哪些服务，它们在更大的体系结构中又处于什么位置呢？
- en: Let's use the `inspect` module to look at the class hierarchy of Tkinter. We
    will first inspect the class hierarchy of the Frame widget as a representation
    of class hierarchies for all the other widgets. We will also look at the class
    hierarchy of
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`inspect`模块来查看Tkinter的类层次结构。我们将首先检查Frame小部件的类层次结构，以此代表所有其他小部件的类层次结构。我们还将查看
- en: 'the `Tk` and `Toplevel` classes to estimate their role in the overall class
    hierarchy of Tkinter (`10.12_tkinter_class_hierarchy.py`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tk` 和 `Toplevel` 类在 Tkinter 的整体类层次结构中的作用（`10.12_tkinter_class_hierarchy.py`）：'
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序的输出如下：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: The `getmro`(`classname`) function from the `inspect` module returns a tuple consisting
    of all the ancestors of `classname` in the order specified by the **method resolution
    order** (**MRO**). MRO refers to the order in which base
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect`模块中的`getmro`(`classname`)函数返回一个元组，其中包含`classname`的所有祖先，按照**方法解析顺序**（**MRO**）指定的顺序排列。MRO指的是基类被调用的顺序。'
- en: classes are searched when looking for a given method.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在查找给定方法时，会搜索类。
- en: By inspecting the MRO and the source code, you will come to know that the `Frame`
    class inherits from the `Widget` class, which in turn inherits from the `BaseWidget`
    class.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过检查MRO（方法解析顺序）和源代码，你会了解到`Frame`类继承自`Widget`类，而`Widget`类又继承自`BaseWidget`类。
- en: The `Widget` class is an empty class with the following class definition: `class
    Widget(BaseWidget, Pack, Place, Grid)`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Widget` 类是一个空的类，其类定义如下：`class Widget(BaseWidget, Pack, Place, Grid)`。'
- en: As you can see, this is how methods defined in the geometry manager (the pack,
    place, and grid mix-ins) are made available to all the widgets.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如您所看到的，这就是在几何管理器中定义的方法（包括pack、place和grid混合器）如何对所有小部件可用。
- en: The `BaseWidget` class has the following class definition: `class BaseWidget(Misc)`.
    This class exposes the destroy method that can be used by programmers.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseWidget` 类具有以下类定义：`class BaseWidget(Misc)`。此类公开了可以被程序员使用的销毁方法。'
- en: All the utility methods defined in the `Misc` class are made available to the
    widgets at this hierarchy level.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个层级中，`Misc` 类中定义的所有实用方法都对小部件可用。
- en: 'The `Misc` class is a generic mix-in that provides a lot of functionality that
    we have used in our applications. Some of the methods that we have used in our programs,
    as defined within the `Misc` class, are `after()`, `bbox()`, `bind_all()`, `bind_tag()`,
    `focus_set()`, `mainloop()`, `update()`, `update_idletask()`, and `winfo_children()`.
    For a complete list of functionalities provided by the `Misc` class, run the following
    commands in the Python interactive shell:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Misc` 类是一个通用的混入类，它提供了我们在应用程序中大量使用到的功能。我们程序中使用的部分方法，如 `Misc` 类中定义的，包括 `after()`,
    `bbox()`, `bind_all()`, `bind_tag()`, `focus_set()`, `mainloop()`, `update()`,
    `update_idletask()`, 和 `winfo_children()`。要获取 `Misc` 类提供的完整功能列表，请在 Python 交互式外壳中运行以下命令：'
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s take a look at the `Tk` and `Toplevel` classes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`Tk`和`Toplevel`类：
- en: The `Tk` class returns a new `Toplevel` widget on the screen. The `__init__` method
    of the `Tk` class is responsible for the creation of a new Tcl interpreter by
    calling a method named `loadtk()`. The class defines a method named `report_callback_exception()`,
    which is responsible for the reporting of errors and exceptions on `sys.stderr`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tk` 类在屏幕上返回一个新的 `Toplevel` 小部件。`Tk` 类的 `__init__` 方法通过调用名为 `loadtk()` 的方法来负责创建一个新的
    Tcl 解释器。该类定义了一个名为 `report_callback_exception()` 的方法，该方法负责在 `sys.stderr` 上报告错误和异常。'
- en: The `__init__` method of the `Toplevel` class of Tkinter is responsible for
    the creation of the main window of an application. The constructor of the class
    takes various optional arguments such as `bg`, `background`, `bd`, `borderwidth`,
    `class`, `height`, `highlightbackground`, `highlightcolor`, `highlightthickness`,
    `menu`, and `relief`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 的 `Toplevel` 类的 `__init__` 方法负责创建应用程序的主窗口。该类的构造函数接受各种可选参数，例如 `bg`、`background`、`bd`、`borderwidth`、`class`、`height`、`highlightbackground`、`highlightcolor`、`highlightthickness`、`menu`
    和 `relief`。
- en: To obtain a list of all the methods provided by the `Toplevel` and `Tk` classes,
    run the following command in the Python interactive shell:  `help(tkinter.Toplevel);
    help(tkinter.Tk)`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取`Toplevel`和`Tk`类提供的所有方法列表，请在Python交互式shell中运行以下命令：`help(tkinter.Toplevel);
    help(tkinter.Tk)`。
- en: In addition to inheriting from the `Misc` mixin class, the `Toplevel` and `Tk`
    classes also inherit methods from the `Wm` mixin class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了继承自`Misc`混合类之外，`Toplevel`和`Tk`类还继承自`Wm`混合类的方法。
- en: 'The `Wm` (short for the Window manager) `mixin` class provides many methods
    to let us communicate with the window manager. Some commonly used methods from
    this class include `wm_iconify, wm_deiconify`, `wm_overrideredirect`, `title`,
    `wm_withdraw`, `wm_transient`, and `wm_resizable`. For a complete list of functions
    provided by the `Wm` class, run the following command in the Python interactive
    shell: `help(tkinter.Wm)`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wm`（代表窗口管理器）混合类提供了许多方法，使我们能够与窗口管理器进行通信。这个类中一些常用的方法包括 `wm_iconify`、`wm_deiconify`、`wm_overrideredirect`、`title`、`wm_withdraw`、`wm_transient`
    和 `wm_resizable`。要获取 `Wm` 类提供的所有函数的完整列表，请在 Python 交互式外壳中运行以下命令：`help(tkinter.Wm)`。'
- en: 'After translating the class hierarchy, as obtained from the previous program
    and by inspecting the source code, we get a hierarchy structure of Tkinter, as
    shown in the following diagram:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在将类层次结构翻译后，从上一个程序中获得并通过检查源代码，我们得到了Tkinter的层次结构，如下所示：
- en: '![](img/13641faf-5200-45c6-914e-dd14ae9821b1.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13641faf-5200-45c6-914e-dd14ae9821b1.png)'
- en: In addition to the normal inheritance relation, which is shown in the preceding diagram
    with the help of unbroken lines, Tkinter provides a list of mixins (or helper classes).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的继承关系，这在前面图表中通过不间断的线条展示，Tkinter还提供了一系列的混入（或辅助类）。
- en: A `mixin` is a class that is designed not to be used directly, but to be combined with
    other classes using multiple inheritances.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixin` 是一个设计用来不直接使用，而是通过多重继承与其他类结合的类。'
- en: 'Tkinter mixins can be broadly classified into the following two categories:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 混合类可以大致分为以下两类：
- en: 'Geometry mixins: These include the `Grid`, `Pack`, and `Place` classes'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何混合类：这些包括`Grid`、`Pack`和`Place`类
- en: 'Implementation mixins: These include the following classes:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现混入（mixins）：这些包括以下类：
- en: The `Misc` class, which is used by the root window and `widget` classes,  provides
    several Tk and window-related services
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Misc` 类，由根窗口和 `widget` 类使用，提供了一些 Tk 和窗口相关的服务'
- en: The `Wm` class, which is used by the root window and the Toplevel widget, provides
    several window manager services
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wm` 类，该类被根窗口和 Toplevel 小部件使用，提供了一些窗口管理服务'
- en: This concludes our brief under-the-hood tour of Tkinter. Hopefully, this should
    give you some insight into the inner workings of Tkinter. If you ever have a doubt
    about the documentation of any given method, you can take a peek directly into
    the actual implementation of the method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Tkinter的简要内部探索。希望这能让你对Tkinter的内部工作原理有所了解。如果你对任何给定方法的文档有任何疑问，可以直接查看该方法的实际实现。
- en: Tips for program design
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序设计技巧
- en: Let's take a look at a few generic tips for program design.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些通用的程序设计技巧。
- en: The model-first policy versus the code-first policy
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型优先策略与代码优先策略
- en: A well-designed model is half the work done. That said, the model is sometimes
    not very evident when you start writing the program. In such cases, you can break the
    rules and try out the code-first philosophy. The idea is to build your program
    incrementally from the ground up, refactor your code, and model, as your vision
    for the program becomes clearer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的模型就是完成了一半的工作。话虽如此，当你开始编写程序时，模型有时并不十分明显。在这种情况下，你可以打破规则，尝试先编写代码的哲学。其思路是从零开始逐步构建你的程序，随着你对程序愿景的逐渐清晰，重构你的代码和模型。
- en: Separating the model from the view
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型与视图分离
- en: The need to separate the model or data structure from the view is the key to
    building scalable applications. While it is possible to intermix the two components,
    you will soon find your program getting messy and difficult to maintain.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型或数据结构从视图中分离出来是构建可扩展应用的关键。虽然将这两个组件混合使用是可能的，但你很快会发现你的程序变得杂乱无章，难以维护。
- en: Selecting the right data structure
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: Selecting the right data structure can have a profound impact on the performance
    of a program. If your program requires you to spend considerable time on lookups,
    use a dictionary, if feasible. When all that you need is to traverse over a collection,
    prefer lists over dictionaries because dictionaries take up more space. When your
    data is immutable, prefer tuples over lists because tuples can be traversed faster
    than lists.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的数据结构可以对程序的性能产生深远影响。如果你的程序需要你花费大量时间进行查找，如果可行的话，请使用字典。当你只需要遍历一个集合时，相比于字典，更倾向于使用列表，因为字典占用的空间更大。当你的数据是不可变时，更倾向于使用元组而不是列表，因为元组比列表遍历得更快。
- en: Naming variables and methods
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名变量和方法
- en: Use meaningful and self-documenting names for your variables and methods. The name
    should leave no scope for confusion about the intent of the variable or the method.
    Use plural names for collections and singular names otherwise. Methods that return
    Boolean values should be appended with words such as *is* or *has*. Stick to the
    style guidelines, but you should also know when to break them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的变量和方法使用有意义的、自我说明的名称。名称应该不留下任何关于变量或方法意图的混淆。对于集合使用复数名称，否则使用单数名称。返回布尔值的方法应该附加诸如
    *is* 或 *has* 这样的词语。坚持风格指南，但你也应该知道何时打破它们。
- en: The Single Responsibility Principle
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The Single Responsibility Principle suggests that a function/class/method should do
    only one thing and that it should do it all and do it well. This means that we should
    not try to handle multiple things from within a function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则建议一个函数/类/方法应该只做一件事，并且应该把它做到极致，做好。这意味着我们不应该试图在函数内部处理多件事情。
- en: Loose coupling
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: 'Whenever possible, reduce coupling or dependence in your program. The following is
    a famous quote on this subject:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地减少程序中的耦合或依赖。以下是这个主题的一个著名引言：
- en: All problems in computer science can be solved by another level of indirection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的所有问题都可以通过另一层间接方式来解决。
- en: – David Wheeler
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: – 戴维·惠勒
- en: Let's suppose that your program has a play button. An immediate impulse may
    be to link it to the `play` method of your program. However, you can further break
    it up into two methods. You could probably link the play button to a method named `on_play_button_clicked`,
    which in turn calls the actual `play` method. The advantage of this is that you
    may want to handle additional things when the play button is clicked, such as
    displaying the current track information somewhere in your program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的程序有一个播放按钮。一个直接的冲动可能是将它链接到程序中的`play`方法。然而，你可以进一步将其拆分为两个方法。你可能将播放按钮链接到一个名为`on_play_button_clicked`的方法，该方法随后调用实际的`play`方法。这种做法的优势在于，你可能希望在点击播放按钮时处理额外的事情，例如在程序中的某个位置显示当前曲目信息。
- en: Thus, you can now use the `on_play_button_clicked` method to decouple the click event
    from the actual play method and then handle calls to multiple methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你现在可以使用`on_play_button_clicked`方法将点击事件从实际播放方法中解耦，然后处理对多个方法的调用。
- en: However, you must resist the temptation of adding too many levels of indirection,
    as your program may quickly start getting messy and it may get out of control.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须抵制添加过多间接层的诱惑，因为你的程序可能会迅速变得混乱，并且可能失去控制。
- en: Handling errors and exceptions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: Python follows the **EAFP** (short for **easier to ask for forgiveness than
    permission**) style of coding as opposed to the **LBYL** (**look before you leap**)
    style that is followed by most programming languages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Python遵循**EAFP**（即**更容易请求原谅而不是请求许可**）的编码风格，这与大多数编程语言遵循的**LBYL**（即**三思而后行**）风格相反。
- en: Therefore, handling exceptions in a way that is similar to the following one
    is normally cleaner in Python than checking conditions using the if-then block.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python中，以类似于以下方式处理异常通常比使用if-then块检查条件更简洁。
- en: 'So when coding in Python, rather than using the following style in coding:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当用Python编写代码时，而不是使用以下这种编码风格：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Consider using this instead:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用这个代替：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Handling cross-platform differences
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理跨平台差异
- en: Even though Tkinter is a cross-platform module, you might come across occasions
    when code written for one operating system might not work as expected on other
    operating systems.  We already saw one such example in the case of getting command-line
    results in the previous Redirecting the command-line output to Tkinter*.* In such
    cases, you can overcome these cross-platform discrepancies by first identifying
    the operating system on which the program is being run and then using a conditional
    statement to run different lines of code for different operating systems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Tkinter是一个跨平台模块，但你可能会遇到这样的情况：为某个操作系统编写的代码在其他操作系统上可能无法按预期工作。我们已经在之前的“将命令行输出重定向到Tkinter”的例子中看到了这样一个例子。在这种情况下，你可以通过首先识别程序正在运行的操作系统，然后使用条件语句为不同的操作系统运行不同的代码行来克服这些跨平台差异。
- en: 'Here''s a brief snippet that demonstrates this concept:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简短的片段，展示了这个概念：
- en: '[PRE24]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The particular problem here is that the mouse wheel event is denoted by the `<MouseWheel>` event
    name on Windows and macOS, but as `<Button-4>` and `<Button-5>` on Linux distributions.  The
    preceding code uses the platform module of Python to identify the operating system
    and follows a different line of code for different operating systems.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里特定的问题是，在 Windows 和 macOS 上，鼠标滚轮事件由 `<MouseWheel>` 事件名称表示，但在 Linux 发行版上则是 `<Button-4>`
    和 `<Button-5>`。前面的代码使用 Python 的平台模块来识别操作系统，并为不同的操作系统遵循不同的代码行。
- en: Tips for program optimization
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序优化技巧
- en: Next, let's take a look at some generic tips to optimize your programs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些通用的优化程序的建议。
- en: Using filter and map
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器和映射
- en: Python provides two built-in functions, named `filter` and `map`, to manipulate collections
    directly rather than having to iterate over each item in the collection. The `filter`,
    `map`, and `reduce` functions are faster than loops because a lot of the work is
    done by the underlying code written in C.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了两个内置函数，名为`filter`和`map`，可以直接操作集合，而不是必须遍历集合中的每个项目。`filter`、`map`和`reduce`函数比循环更快，因为大部分工作都是由用C语言编写的底层代码完成的。
- en: 'The `filter(function, list)` function returns a list (iterators in Python 3.x) that
    contains all the items for which the function returns a true value. The following
    command is an example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(function, list)` 函数返回一个列表（Python 3.x 中的迭代器），其中包含所有函数返回真值的项目。以下命令是一个示例：'
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is faster than running a conditional if-then check against the list.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这比在列表上运行条件if-then检查要快。
- en: 'The `map(function_name, list)` function applies `function_name` to each item
    in the list and returns the values in a new list (returns iterators instead of
    lists in Python 3.x). The following command is an example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`map(function_name, list)` 函数将 `function_name` 应用到列表中的每个项目上，并返回一个新列表中的值（在 Python
    3.x 中返回迭代器而不是列表）。以下命令是一个示例：'
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is faster than running the list through a loop and adding `5` to each element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这比通过循环遍历列表并将每个元素加`5`要快。
- en: Optimizing variables
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化变量
- en: The way you select variables in your program can considerably affect the speed of
    the execution of your program. For instance, if you do not need to change the content
    or attributes of a widget after its instantiation, do not create a class-wide instance
    of the widget.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你在程序中选择变量的方式可以显著影响程序执行的速度。例如，如果你在实例化小部件后不需要更改其内容或属性，那么不要创建一个类级别的实例。
- en: 'For example, if a Label widget needs to remain static, use `Label(root, text=''Name'').pack(side=LEFT)`
    instead of using the following snippet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果需要使标签小部件保持静态，请使用`Label(root, text='Name').pack(side=LEFT)`而不是使用以下代码片段：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, do not create local variables if you are not going to use them more
    than once. For example, use `mylabel.config (text= event.keysym)` instead of first creating
    a local variable named key and then using it only once:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你不打算多次使用它们，请不要创建局部变量。例如，使用 `mylabel.config (text= event.keysym)` 而不是首先创建一个名为
    key 的局部变量然后只使用一次：
- en: '[PRE28]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the local variable needs to be used more than once, it may make sense to
    create a local variable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果局部变量需要被多次使用，那么创建一个局部变量可能是有意义的。
- en: Profiling your program
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析你的程序
- en: Profiling involves generating detailed statistics to show how often and for
    how long various routines of a program execute. This helps you isolate the offending
    parts of a program, and those parts probably need redesigning.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析涉及生成详细的统计数据，以显示程序中各种例程执行的频率和持续时间。这有助于你隔离程序中的问题部分，而这些部分可能需要重新设计。
- en: Python provides a built-in module named `cProfile`, which enables the generation
    of detailed statistics pertaining to a program. The module gives details such
    as the total program running time, the time taken to run each function, and the
    number of times each function is called. These statistics make it easy to determine
    the parts of the code that need optimization.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个名为`cProfile`的内置模块，该模块能够生成与程序相关的详细统计信息。该模块提供了诸如总程序运行时间、每个函数的运行时间以及每个函数被调用的次数等详细信息。这些统计信息使得确定需要优化的代码部分变得容易。
- en: 'In particular, `cProfile` provides the following data for a function or script:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`cProfile`为函数或脚本提供以下数据：
- en: '`ncalls`: This indicates the number of times a function is called'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`: 这表示一个函数被调用的次数'
- en: '`tottime`: This indicates the time spent on a function, which excludes the
    time spent on calling other functions'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`: 这表示一个函数所花费的时间，不包括调用其他函数所花费的时间'
- en: '`percall`: This is `tottime` divided by `ncalls`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`: 这是指 `tottime` 除以 `ncalls`'
- en: '`cumtime`: This indicates the time spent on a function, including calls to other
    functions'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`: 这表示一个函数所花费的时间，包括调用其他函数的时间'
- en: '`percall`: This is `cumtime` divided by `tottime `'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`: 这是指 `cumtime` 除以 `tottime`'
- en: 'To profile a function named `spam()`, use the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析名为 `spam()` 的函数，请使用以下代码：
- en: '[PRE29]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can then view the results of profiling by using another module called `pstats`, as
    follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用另一个名为 `pstats` 的模块来查看配置文件的结果，具体操作如下：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'More importantly, you can profile an entire script. Let''s assume that you
    want to profile a script named `myscript.py`. You can simply navigate to the directory
    of the script using a command-line tool and then type and run the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，您可以分析整个脚本。假设您想分析一个名为 `myscript.py` 的脚本。您只需使用命令行工具导航到该脚本的目录，然后输入并运行以下命令：
- en: '[PRE31]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s a partial output from running the preceding command on the `8.08_vornoi_diagram`
    code from [Chapter 8](7f88607b-582a-4f9e-a922-7cd9333d320e.xhtml), *Fun With Canvas*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`8.08_vornoi_diagram`代码上运行前面命令的部分输出如下，来自[第8章](7f88607b-582a-4f9e-a922-7cd9333d320e.xhtml)，《在画布上玩转》：
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: I specifically chose to profile this program because it takes a long time to
    execute. In this case, it took ~110 seconds to run and most of the time was spent
    running the `create_vornoi_diagram` function (~95 seconds). So now this function
    is a perfect candidate for optimization.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我特意选择分析这个程序，因为它执行时间很长。在这种情况下，它运行了大约110秒，大部分时间都花在了运行`create_vornoi_diagram`函数上（大约95秒）。所以现在这个函数是优化完美的候选者。
- en: In addition to the `cProfile` module, there are other modules, such as `PyCallGraph` and
    `objgraph`, and they provide visual graphs for the profile data.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`cProfile`模块之外，还有其他模块，例如`PyCallGraph`和`objgraph`，它们为配置数据提供可视化的图表。
- en: Other optimization tips
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他优化技巧
- en: Optimization is a vast topic, and there is a lot that you can do. If you are
    interested in knowing more about code optimization, you can start with the official
    Python optimization tips that are available at [http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个广泛的话题，有很多事情可以做。如果你对代码优化感兴趣，可以开始阅读官方的Python优化技巧，这些技巧可以在[http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips)找到。
- en: Distributing a Tkinter application
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发 Tkinter 应用程序
- en: So, you have your new application ready and want to share it with the rest of
    the world. How do you do that?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经准备好了你的新应用程序，并想要与世界上其他人分享。你该如何做呢？
- en: You, of course, need Python installed for your programs to run. Windows does
    not have Python preinstalled. Most modern Linux distributions and macOS have Python
    preinstalled, but you don't need just any version of Python. You need a version
    of Python that is compatible with the version on which the program was originally
    written.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要安装Python以便你的程序能够运行。Windows系统没有预装Python。大多数现代Linux发行版和macOS都预装了Python，但你并不需要任何版本的Python。你需要的是与程序最初编写时版本兼容的Python版本。
- en: Furthermore, if your program uses third-party modules, you need the appropriate module
    installed for the required Python version. This surely is too much diversity to
    handle.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的程序使用了第三方模块，你需要安装适合所需Python版本的相应模块。这无疑是一个处理起来过于多样化的情况。
- en: Fortunately, we have tools, such as Freeze tools, that allow us to distribute
    Python programs as standalone applications.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有像Freeze tools这样的工具，它允许我们将Python程序作为独立应用程序进行分发。
- en: Given the diversity of platforms that need to be handled, there are a large
    number of Freeze tool options from which you can choose. Therefore, a detailed
    discussion on any one of these tools is beyond the scope of this book.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要处理的平台种类繁多，您可以从大量Freeze工具选项中进行选择。因此，本书不会对其中任何一种工具进行详细讨论。
- en: We will list some of the most evolved freezing tools in the following sections.
    If you find a tool that fits into your distribution requirements, you can look
    at its documentation for more information.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中列出一些最先进的冷冻工具。如果你找到一个符合你分发需求的工具，你可以查看其文档以获取更多信息。
- en: py2exe
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: py2exe
- en: If you only need to distribute your Python application on Windows, py2exe is perhaps
    the most hardened tool. It converts Python programs into executable Windows programs
    that can run without requiring a Python installation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要在Windows上分发你的Python应用程序，py2exe可能是最坚固的工具。它可以将Python程序转换为可执行Windows程序，这些程序可以在不要求安装Python的情况下运行。
- en: More information, a download link, and tutorials on this are available at [http://www.py2exe.org/](http://www.py2exe.org/).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息、下载链接以及相关教程可在[http://www.py2exe.org/](http://www.py2exe.org/)找到。
- en: py2app
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: py2app
- en: The py2app performs the same tasks in macOS that py2exe does for Windows. If
    you just need to distribute your Python application on macOS, py2app is a time-tested tool.
    More information is available at [https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: py2app在macOS上执行的任务与py2exe在Windows上执行的任务相同。如果你只需要在macOS上分发你的Python应用程序，py2app是一个经过时间考验的工具。更多信息可在[https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/)找到。
- en: PyInstaller
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyInstaller
- en: PyInstaller has gained popularity as a freezing tool in the last few years because
    it supports a wide variety of platforms, such as Windows, Linux, macOS X, Solaris, and
    AIX.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller作为冻结工具在过去的几年中获得了人气，因为它支持广泛的平台，例如Windows、Linux、macOS X、Solaris和AIX。
- en: In addition, executables created using PyInstaller claim to take up less space than
    other freezing tools because it uses transparent compression. Another important feature
    of PyInstaller is its out-of-the-box compatibility with a large number of third-party
    packages. The full list of features, downloads, and documentation can be viewed
    by visiting [http://www.pyinstaller.org/](http://www.pyinstaller.org/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 PyInstaller 创建的可执行文件声称比其他冻结工具占用更少的空间，因为它使用了透明压缩。PyInstaller 的另一个重要特性是它对大量第三方软件包的即插即用兼容性。可以通过访问[http://www.pyinstaller.org/](http://www.pyinstaller.org/)来查看完整的功能列表、下载和文档。
- en: Other freezing tools
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他冷冻工具
- en: 'The following are a few other freezing tools:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他的冷冻工具：
- en: '**Freeze**: This tool is shipped with the standard Python distribution. Freeze
    can only be used to compile executables on Unix systems.  However, the program
    is overly simplistic, as it fails to handle even the common third-party libraries.
    More information on this is available at [http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冻结**：这个工具包含在标准的Python发行版中。冻结只能用于在Unix系统上编译可执行文件。然而，该程序过于简单，甚至无法处理常见的第三方库。更多关于这个工具的信息可以在[http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze)找到。'
- en: '**cx_Freeze**: This tool is similar to py2exe and py2app, but it claims to
    be portable across all platforms on which Python works. More information on this
    is available at [http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cx_Freeze**：这个工具与py2exe和py2app类似，但它声称可以在Python工作的所有平台上通用。更多关于这个工具的信息可以在[http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html)找到。'
- en: If you're distributing a small program, a freezing tool might be just what you
    need.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在分发一个小程序，一个冻结工具可能正是你所需要的。
- en: However, if you have a large program, say, with lots of external third-party library
    dependencies, or dependencies that are not supported by any existing freezing
    tool, your application might be the right candidate for bundling the
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有一个大型程序，比如说，有很多外部第三方库依赖，或者依赖项不被任何现有的冻结工具支持，那么你的应用程序可能正是适合进行打包的候选者。
- en: Python interpreter with your application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python解释器运行你的应用程序。
- en: The limitations of Tkinter
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 的局限性
- en: We have already explored the power of Tkinter. Perhaps the greatest power of Tkinter
    lies in its ease of use and lightweight footprint. Tkinter exposes a very powerful
    API, especially with the Text widget and the Canvas widget.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了Tkinter的强大功能。也许Tkinter最伟大的力量在于其易用性和轻量级特性。Tkinter提供了一个非常强大的API，尤其是在Text小部件和Canvas小部件方面。
- en: However, its ease of use and the fact that it is lightweight also result in
    some limitations.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其易用性和轻量级特性也带来了一些限制。
- en: A limited number of core widgets
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限数量的核心小部件
- en: Tkinter provides only a small number of basic widgets and lacks a collection
    of modern widgets. It needs Ttk, Pmw, TIX, and other extensions to provide some
    really useful widgets. Even with these extensions, Tkinter fails to match the
    range of widgets provided by other GUI tools, such as the advanced wxPython widget
    set and PyQt.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter只提供少量基本小部件，并且缺少现代小部件的集合。它需要Ttk、Pmw、TIX和其他扩展来提供一些真正有用的部件。即使有了这些扩展，Tkinter也无法与其他GUI工具提供的部件范围相匹配，例如高级wxPython部件集和PyQt。
- en: For instance, wxPython's HtmlWindow widget lets users display HTML content with
    ease. There have been attempts to provide similar extensions in Tkinter, but they
    are far from satisfactory. Similarly, there are other widgets from the Advanced User
    Interface Library and mixins in wxPython, such as floating/docking frames and perspective
    loading and saving; Tkinter users can only hope that these widgets will be included
    in future releases.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，wxPython的HtmlWindow小部件让用户能够轻松地显示HTML内容。虽然有人尝试在Tkinter中提供类似的扩展，但它们远远不能令人满意。同样，wxPython的高级用户界面库中还有其他小部件和混入，例如浮动/停靠框架和视角加载与保存；Tkinter用户只能寄希望于这些小部件将在未来的版本中包含在内。
- en: Non-Python objects
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非Python对象
- en: Tkinter widgets are not first-class Python objects. Thus, we have to use workarounds such
    as `Intvar`, `StringVar`, and `BooleanVar` to handle variables in Tkinter. This adds
    a small layer of complexity, as error messages returned by the Tcl interpreter are
    not very Python-friendly, which makes it harder to debug.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter小部件不是一等Python对象。因此，我们必须使用诸如`Intvar`、`StringVar`和`BooleanVar`之类的变通方法来处理Tkinter中的变量。这增加了一层小的复杂性，因为Tcl解释器返回的错误信息并不非常Python友好，这使得调试变得更加困难。
- en: No support for printing
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不支持打印
- en: Tkinter is rightly criticized for not providing any support for printing features.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 正确地受到批评，因为它没有提供任何打印功能的支持。
- en: The Canvas widget allows for limited printing support in the PostScript format.
    The PostScript format is too limited in what it can be used for. Compare this
    to wxPython, which provides a complete printing solution in the form of a printing
    framework.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件在PostScript格式中提供了有限的打印支持。PostScript格式在可用性方面过于受限。与此相比，wxPython提供了一个完整的打印解决方案，以打印框架的形式出现。
- en: No support for newer image formats
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不支持较新的图像格式
- en: Tkinter does not natively support image formats such as JPEG and PNG. The `PhotoImage`
    class of Tkinter can read images only in the GIF and PGM/PPM formats. Although
    there are workarounds, such as using the `ImageTk` and `Image` submodules from
    the `PIL` module, it would have been better if Tkinter natively supported popular
    image formats.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 本身不支持诸如 JPEG 和 PNG 这样的图像格式。Tkinter 的 `PhotoImage` 类只能读取 GIF 和 PGM/PPM
    格式的图像。尽管有诸如使用 `PIL` 模块的 `ImageTk` 和 `Image` 子模块等解决方案，但如果 Tkinter 本身支持流行的图像格式会更好。
- en: Inactive development community
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消极的开发社区
- en: Tkinter is often criticized for having a relatively inactive development community. This
    is true to a large extent. The documentation for Tkinter has remained a work in progress
    for many years now.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter常被批评为拥有相对不活跃的开发社区。这在很大程度上是正确的。Tkinter的文档已经多年处于持续完善的状态。
- en: A large number of Tkinter extensions have appeared over the years, but most
    of them have not been under active development for a long time.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来出现了大量的Tkinter扩展，但其中大部分已经很长时间没有进行活跃开发了。
- en: Tkinter supporters refute this with the argument that Tkinter is a stable and mature
    technology that does not need frequent revisions, unlike some other GUI modules
    that are still being developed.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter支持者用以下论点反驳：Tkinter是一种稳定且成熟的技术，不需要频繁修订，与一些仍在开发中的其他GUI模块不同。
- en: Alternatives to Tkinter
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 的替代方案
- en: If a program can be written in Tkinter, this is probably the best way to go
    in terms of simplicity and maintainability. However, in case the aforementioned
    limitations get in your way, you can explore some other alternatives to Tkinter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序可以用Tkinter编写，那么在简单性和可维护性方面，这可能是最佳选择。然而，如果上述限制阻碍了你的进程，你可以探索一些Tkinter的其他替代方案。
- en: In addition to Tkinter, there are several other popular Python GUI toolkits.
    The most popular ones include wxPython, PyQt, PySide, and PyGTK. Here's a brief
    discussion of these toolkits.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Tkinter，还有其他几个流行的Python GUI工具包。其中最受欢迎的包括wxPython、PyQt、PySide和PyGTK。以下是这些工具包的简要讨论。
- en: wxPython
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wxPython
- en: wxPython is a Python interface for `wxWidgets`, a popular open source GUI library.
    The code written in wxPython is portable across most major platforms, such as
    Windows, Linux, and macOS.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 是 `wxWidgets` 的 Python 接口，一个流行的开源 GUI 库。使用 wxPython 编写的代码可以在大多数主要平台上移植，例如
    Windows、Linux 和 macOS。
- en: The wxPython interface is generally considered to be better than Tkinter at
    building complex GUIs, primarily because it has a large base of natively supported
    widgets. However, Tkinter supporters do contest this claim.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython界面通常被认为在构建复杂GUI方面优于Tkinter，主要是因为它拥有大量原生支持的控件。然而，Tkinter的支持者对此观点提出异议。
- en: The `wxWidgets` interface was originally written in the C++ programming language.
    Hence, wxPython inherits a large portion of the complexity that is typical of
    C++ programs. wxPython provides a very large base of classes, and it often takes
    more code to produce the same interface than it would take in Tkinter. However,
    in exchange for this complexity, wxPython provides a larger base of built-in widgets than
    Tkinter offers.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`wxWidgets` 接口最初是用 C++ 编程语言编写的。因此，wxPython 继承了 C++ 程序典型的很大一部分复杂性。wxPython 提供了一个非常庞大的类库，并且通常需要更多的代码来生成与
    Tkinter 相同的界面。然而，作为这种复杂性的交换，wxPython 提供了比 Tkinter 更多的内置小部件。'
- en: Owing to its inherent complexity, wxPython has seen the emergence of several
    GUI builder toolkits, such as **wxGlade, wxFormBuilder,** and **wxDesigner.**
    The wxPython installation comes with demo programs that can help you quickly get
    started with the toolkit. To download the toolkit, or for more information on
    wxPython, visit [http://wxpython.org/](http://wxpython.org/).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其固有的复杂性，wxPython已经出现了几个GUI构建工具包，例如**wxGlade**、**wxFormBuilder**和**wxDesigner**。wxPython安装包中包含了演示程序，可以帮助你快速开始使用这个工具包。要下载工具包或获取有关wxPython的更多信息，请访问[http://wxpython.org/](http://wxpython.org/)。
- en: PyQt
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyQt
- en: PyQt is a Python interface for a cross-platform GUI toolkit named Qt, a project currently
    developed and maintained by a British firm named Riverbank Computing.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt 是一个用于跨平台 GUI 工具包 Qt 的 Python 接口，Qt 是由一家名为 Riverbank Computing 的英国公司开发和维护的项目。
- en: PyQt, with several hundred classes and thousands of functions, is perhaps the most
    fully featured GUI library currently available for GUI programming in Python.
    However, this feature load brings in a lot of complexity and a steep learning
    curve.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt，拥有数百个类和数千个函数，可能是目前Python中用于GUI编程功能最全面的GUI库。然而，这种功能负载也带来了许多复杂性和陡峭的学习曲线。
- en: Qt, and hence pyQt, has a very rich set of supported widgets. In addition to
    this, it includes built-in support for network programming, SQL databases, threads, multimedia
    frameworks, regular expressions, XML, SVG, and much more. The designer feature
    of Qtletsus generates GUI code from a **WYSIWYG** (**what you see is what you
    get**) interface.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Qt及其子库pyQt支持非常丰富的控件集。除此之外，它还内置了对网络编程、SQL数据库、线程、多媒体框架、正则表达式、XML、SVG等多种功能的支持。Qt的设计器功能允许我们从**所见即所得**（**WYSIWYG**）的界面生成GUI代码。
- en: PyQt is available under a variety of licenses, including GNU, **General Public
    License** (**GPL**), and a commercial license. However, its greatest disadvantage
    is that unlike Qt, it is unavailable under the **Lesser General Public License**
    (**LGPL**).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt 可在多种许可证下使用，包括 GNU、**通用公共许可证**（**GPL**）以及商业许可证。然而，它最大的缺点是，与 Qt 不同，它不可在 **
    Lesser General Public License**（**LGPL**）下使用。
- en: PySide
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PySide
- en: If you are looking for an LGPL Version of Qt bindings for Python, you may want
    to explore PySide. PySide was originally released under the LGPL in August 2009
    by Nokia, the former owners of the Qt Toolkit. It is now owned by Digia. More
    information on PySide can be obtained by visiting [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找适用于 Python 的 LGPL 版本的 Qt 绑定，你可能想探索 PySide。PySide 最初于 2009 年 8 月由 Qt 工具包的前所有者诺基亚以
    LGPL 许可发布。现在它归 Digia 所有。更多关于 PySide 的信息可以通过访问 [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)
    获取。
- en: PyGTK
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyGTK
- en: PyGTK is a collection of Python bindings for the GTK + GUI library. PyGTK applications
    are cross-platform and can run on Windows, Linux, macOS, and others. PyGTK is
    free and is licensed under the LGPL. Therefore, you can use, modify, and distribute
    it with very few restrictions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: PyGTK 是 GTK + 图形用户界面库的 Python 绑定集合。PyGTK 应用程序是跨平台的，可以在 Windows、Linux、macOS 以及其他操作系统上运行。PyGTK
    是免费的，并且遵循 LGPL 许可协议。因此，你可以几乎无限制地使用、修改和分发它。
- en: More information about PyGTK can be obtained by visiting [http://www.pygtk.org/](http://www.pygtk.org/).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 PyGTK 的信息可以通过访问 [http://www.pygtk.org/](http://www.pygtk.org/) 获取。
- en: Other options
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他选项
- en: Besides these popular toolkits, there are a range of toolkits available for
    GUI programming in Python.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些流行的工具包之外，还有一系列适用于Python GUI编程的工具包可用。
- en: Java programmers who are comfortable with Java GUI libraries, such as Swing and
    AWT, can seamlessly access these libraries by using **Jython.** Similarly, C# programmers
    can use **IronPython** to access GUI construction features from the **.NET** framework.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Java GUI 库（如 Swing 和 AWT）的 Java 程序员可以通过使用 **Jython** 无缝访问这些库。同样，C# 程序员可以使用
    **IronPython** 从 **.NET** 框架中访问 GUI 构建功能。
- en: For a comprehensive list of other GUI tools that are available to a Python developer, visit
    [http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一份完整的其他可供Python开发者使用的GUI工具列表，请访问[http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming)。
- en: Tkinter in Python 2.x
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 2.x 中的 Tkinter
- en: In 2008, Guido van Rossum, the author of Python, forked the language into two branches—2.x
    and 3.x. This was done to clean up the language and make it more consistent.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年，Python语言的作者Guido van Rossum将该语言分叉为两个分支——2.x和3.x。这样做是为了清理语言并使其更加一致。
- en: Python 3.x broke backward compatibility with Python 2.x. For example, the print statement
    in Python 2.x was replaced by the `print()` function that would now take arguments
    as parameters.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.x 与 Python 2.x 不再兼容。例如，Python 2.x 中的 print 语句被现在的 `print()` 函数所取代，该函数现在将参数作为参数接收。
- en: We coded all the Tkinter programs in Python Version 3.x. However, in case you
    need to maintain or write new Tkinter programs in Python 2.x, the transition should
    not be very difficult.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Python 3.x 版本编写了所有 Tkinter 程序。然而，如果你需要维护或编写新的 Python 2.x 版本的 Tkinter 程序，过渡应该不会非常困难。
- en: The core functionality of Tkinter remains the same between 2.x and 3.x. The
    only significant change to Tkinter when moving from Python 2.x to Python 3.x involves changing
    the way the Tkinter modules are imported.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的核心功能在2.x和3.x版本之间保持不变。从Python 2.x迁移到Python 3.x时，Tkinter的唯一重大变化涉及更改Tkinter模块的导入方式。
- en: Tkinter has been renamed as `tkinter` in Python 3.x (capitalization has been
    removed).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 在 Python 3.x 中已被重命名为 `tkinter`（已移除大小写）。
- en: Note that in 3.x, the `lib-tk` directory was renamed to `tkinter`. Inside this
    directory, the `Tkinter.py` file was renamed to `__init__.py`, thus making `tkinter`
    an importable module.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在3.x版本中，`lib-tk`目录被重命名为`tkinter`。在这个目录内部，`Tkinter.py`文件被重命名为`__init__.py`，因此`tkinter`成为一个可导入的模块。
- en: 'Accordingly, the biggest difference lies in the way you import the `tkinter`
    module into your current namespace:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最大的区别在于你将 `tkinter` 模块导入当前命名空间的方式：
- en: '[PRE33]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Furthermore, note the following changes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意以下变更。
- en: 'Note how the Python 3 version is cleaner, more elegant, and more systematic
    in its naming conventions regarding the use of lowercase names for its modules:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Python 3 版本在模块命名约定方面更加简洁、优雅和系统化，它使用小写字母命名模块：
- en: '| **Python 3** | **Python 2** |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **Python 3** | **Python 2** |'
- en: '| `import tkinter.ttk `     OR`from tkinter import ttk` | `import ttk` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.ttk` 或 `从 tkinter 导入 ttk` | `导入 ttk` |'
- en: '| `import tkinter.messagebox` | `import tkMessageBox` |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.messagebox` | `导入 tkMessageBox` |'
- en: '| `import tkinter.colorchooser` | `import tkColorChooser` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.colorchooser` | `导入 tkColorChooser` |'
- en: '| `import tkinter.filedialog` | `import tkFileDialog` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.filedialog` | `导入 tkFileDialog` |'
- en: '| `import tkinter.simpledialog` | `import tkSimpleDialog` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.simpledialog` | `导入 tkSimpleDialog` |'
- en: '| `import tkinter.commondialog` | `import tkCommonDialog` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.commondialog` | `导入 tkCommonDialog` |'
- en: '| `import tkinter.font` | `import tkFont` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.font` | `导入 tkFont` |'
- en: '| `import tkinter.scrolledtext` | `import ScrolledText` |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.scrolledtext` | `导入 ScrolledText` |'
- en: '| `import tkinter.tix` | `import Tix` |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `导入 tkinter.tix` | `导入 Tix` |'
- en: 'The following version will work for both cases:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本将适用于两种情况：
- en: '[PRE34]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To conclude the book, let's summarize some of the key steps involved in designing
    an application. Depending on what you want to design, choose a suitable data structure to
    represent your needs logically. If required, combine primitive data structures
    to form complex structures such as, say, a list or a tuple of dictionaries. Create
    classes for objects that constitute your application. Add attributes that need
    to be manipulated and methods to manipulate these attributes. Manipulate attributes
    by using a different API provided by a rich set of Python-standard and external
    libraries.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本书，让我们概括一下在设计应用程序时涉及的一些关键步骤。根据您想要设计的内容，选择一个合适的数据结构来逻辑地表示您的需求。如果需要，可以将原始数据结构组合成复杂结构，例如，比如说，字典列表或元组。为构成您应用程序的对象创建类。添加需要操作的和用于操作这些属性的方法。通过使用Python标准库和外部库提供的不同API来操作属性。
- en: We tried to build several applications in this book. Then, we had a look at
    an explanation for the code. However, when you try to explain a software development process
    in a sequential text, you sometimes mislead your readers by implying that
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中尝试构建了几个应用程序。然后，我们查看了一下代码的解释。然而，当你试图在顺序文本中解释软件开发过程时，你有时会通过暗示而误导你的读者，使他们认为
- en: the development of software programs is a linear process. This is hardly true.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 软件程序的开发是一个线性过程。这几乎是不正确的。
- en: Actual programming doesn't usually work this way. In fact, small- to medium-sized
    programs are normally written in an incremental trial-and-error process, where
    assumptions get changed and structures are modified throughout the course of application
    development.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的编程通常不会这样进行。实际上，中小型程序通常是在一个逐步的试错过程中编写的，在这个过程中，假设会发生变化，结构也会在应用开发的过程中进行修改。
- en: 'Here is how you would develop a small- to a medium-sized application:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何开发一个从小型到中型应用的过程：
- en: Start with a simple script.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个简单的脚本开始。
- en: Set a small achievable goal, implement it, and then think of adding the next feature
    to your program in an incremental fashion.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设定一个可实现的小目标，实施它，然后以渐进的方式考虑为你的程序添加下一个功能。
- en: You may or may not introduce a class structure initially. If you are clear about
    the problem domain, you may introduce the class structure from the very beginning.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能一开始就引入类结构，也可能不引入。如果你对问题域很清楚，你可能会从一开始就引入类结构。
- en: If you are not initially sure about the class structure, start with simple procedural
    code. As your program starts to grow, you will probably start getting a lot of
    global variables. It is here that you will start getting an idea of the structural
    dimensions of your program. It is now time to refactor and restructure your program
    to introduce a class structure.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你一开始不确定类的结构，可以先从简单的程序代码开始。随着你的程序开始增长，你可能会开始遇到很多全局变量。正是在这里，你将开始对程序的结构维度有所认识。现在就是时候重构和重新组织你的程序，引入类结构了。
- en: Harden your program against unanticipated runtime failures and edge cases to
    make it ready for production use.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强你的程序以抵御未预见的运行时故障和边缘情况，使其准备好投入生产使用。
- en: That concludes the book. If you have any suggestions or feedback, please leave
    us a comment. If you found this book helpful, please rate it online and help us
    spread the word.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的内容到此结束。如果您有任何建议或反馈，请给我们留下评论。如果您觉得这本书有帮助，请在线评分并帮助我们传播信息。
- en: QA section
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: 'Here are a few questions to reflect upon:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题供您思考：
- en: How can we handle cross-platform differences in Tkinter?
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理 Tkinter 在不同平台之间的差异？
- en: What are the advantages and limitations of using Tkinter?
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter的优点和局限性是什么？
- en: What are some of the common alternatives to Tkinter?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter有哪些常见的替代方案？
- en: What the various modes of validation in Tkinter?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 中有哪些验证模式？
- en: What is program profiling? How do we profile a program in Python?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是程序分析？我们如何在 Python 中进行程序分析？
