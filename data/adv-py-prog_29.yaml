- en: '*Chapter 26*: The Observer Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第26章* 观察者模式'
- en: We use the observer pattern when we want to be able to inform/notify all stakeholders
    (an object or a group of objects) when the state of an object changes. An important
    feature of the observer pattern is that the number of subscribers/observers, as
    well as who the subscribers are, may vary and can be changed at runtime.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在对象状态发生变化时通知/通知所有利益相关者（一个对象或一组对象）时，我们使用观察者模式。观察者模式的一个重要特性是，订阅者/观察者的数量以及订阅者是谁可能会变化，并且可以在运行时更改。
- en: In this chapter, we will learn about this design pattern while comparing it
    to a similar one we have seen in the past, known as the MVC pattern, and use it
    to implement a data formatter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习这种设计模式，并将其与我们过去看到的一个类似模式进行比较，即MVC模式，并使用它来实现数据格式化。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Understanding the observer pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: Real-world examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter26)找到。
- en: Understanding the observer pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: When we need to update a group of objects when the state of another object changes,
    a popular solution is offered by the **Model-View-Controller** (**MVC**) pattern.
    Let's assume that we are using the data of the same *model* in two *views*; for
    instance, in a pie chart and a spreadsheet. Whenever the model is modified, both
    views need to be updated. That's the role of the observer pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在另一个对象的状态发生变化时更新一组对象时，**模型-视图-控制器**（**MVC**）模式提供了一个流行的解决方案。假设我们在两个**视图**中使用相同的*模型*数据；例如，在一个饼图和一个电子表格中。每当模型被修改时，两个视图都需要更新。这就是观察者模式的作用。
- en: The observer pattern describes a publish-subscribe relationship between a single
    object – the publisher, which is also known as the **subject** or **observable**
    – and one or more objects – the subscribers, also known as **observers**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式描述了单个对象（发布者，也称为**主题**或**可观察者**）与一个或多个对象（订阅者，也称为**观察者**）之间的发布-订阅关系。
- en: In the case of MVC, the publisher is the model, while the subscribers are the
    views. There are other examples that we will discuss throughout this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC的情况下，发布者是模型，而订阅者是视图。本章中我们将讨论其他一些例子。
- en: The ideas behind the observer pattern are the same as those behind the separation
    of concerns principle; that is, to increase decoupling between the publisher and
    subscribers, and to make it easy to add/remove subscribers at runtime. Let's look
    at a couple of examples of this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式背后的思想与关注点分离原则背后的思想相同；也就是说，为了增加发布者和订阅者之间的解耦，并使在运行时添加/删除订阅者变得容易。让我们看看几个这样的例子。
- en: Real-world examples
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: In reality, an auction resembles the observer pattern. Every auction bidder
    has a numbered paddle that is raised whenever they want to place a bid. Whenever
    the paddle is raised by a bidder, the auctioneer acts as the subject by updating
    the price of the bid and broadcasting the new price to all bidders (subscribers).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，拍卖类似于观察者模式。每个拍卖竞标者都有一个编号的 paddle，每当他们想要出价时就会举起。每当竞标者举起paddle时，拍卖师作为主题通过更新出价价格并向所有竞标者（订阅者）广播新价格来行动。
- en: 'In software, we can cite at least two examples:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，我们可以至少举出两个例子：
- en: Kivy, the Python framework for developing user interfaces, has a module called
    **Properties**, which implements the observer pattern. Using this technique, you
    can specify what should happen when a property's value changes.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy，一个用于开发用户界面的Python框架，有一个名为**Properties**的模块，它实现了观察者模式。使用这种技术，您可以指定当属性值发生变化时应该发生什么。
- en: The RabbitMQ library can be used to add asynchronous messaging support to an
    application. Several messaging protocols are supported, such as HTTP and AMQP.
    RabbitMQ can be used in a Python application to implement a publish-subscribe
    pattern, which is nothing more than the observer design pattern ([j.mp/rabbitmqobs](http://j.mp/rabbitmqobs)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ库可以用于向应用程序添加异步消息支持。它支持多种消息协议，如HTTP和AMQP。RabbitMQ可以在Python应用程序中用于实现发布-订阅模式，这实际上就是观察者设计模式（[j.mp/rabbitmqobs](http://j.mp/rabbitmqobs)）。
- en: In the next section, we will discuss when this design pattern could and should
    be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论何时可以使用并应该使用这种设计模式。
- en: Use cases
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: We generally use the observer pattern when we want to inform/update *one or
    more objects* (observers/subscribers) about a change that happened on *a given
    object* (subject/publisher/observable). The number of observers, as well as who
    those observers are, may vary and can be changed dynamically.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在想要通知/更新关于在某个对象（主题/发布者/可观察对象）上发生变化的**一个或多个对象**（观察者/订阅者）时使用观察者模式。观察者的数量以及观察者是谁可能会变化，并且可以动态更改。
- en: We can think of many cases where the observer pattern can be useful. One such
    use case is **newsfeeds**. With RSS, Atom, or other related formats, you follow
    a feed, and every time it is updated, you receive a notification about the update.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想到许多情况下观察者模式是有用的。其中一个用例是**新闻源**。通过RSS、Atom或其他相关格式，你可以订阅一个源，每次它更新时，你都会收到关于更新的通知。
- en: The same concept exists in social networking. If you are connected to another
    person using a social networking service, and your connection updates something,
    you are notified about it. It doesn't matter if the connection is a Twitter user
    that you follow, a real friend on Facebook, or a business colleague on LinkedIn.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络中，也存在同样的概念。如果你通过社交网络服务与另一个人建立了联系，并且你的联系更新了某些内容，你会收到通知。无论这个联系是你关注的Twitter用户、Facebook上的真实朋友，还是在LinkedIn上的商业同事，都无关紧要。
- en: '**Event-driven systems** is another example where the observer pattern is usually
    used. In such systems, you have *listeners* that *listen* for specific events.
    The listeners are triggered when an event they are listening to is created. This
    can be typing a specific key (on the keyboard), moving the mouse, and more. The
    event plays the role of the publisher, and the listeners play the role of the
    observers. The key point, in this case, is that multiple listeners (observers)
    can be attached to a single event (publisher).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动系统**是另一个通常使用观察者模式的例子。在这样的系统中，你有**监听器**，它们**监听**特定的事件。当它们监听的事件被创建时，监听器会被触发。这可以是按特定的键（在键盘上）、移动鼠标等等。事件扮演发布者的角色，而监听器扮演观察者的角色。在这种情况下，关键点是多个监听器（观察者）可以附加到单个事件（发布者）上。'
- en: Finally, in the next section, we will implement a data formatter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下一节中，我们将实现一个数据格式化器。
- en: Implementation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The ideas described here are based on the ActiveState Python Observer code recipe
    ([https://code.activestate.com/](https://code.activestate.com/)). There is a default
    formatter that shows a value in decimal format. However, we can add/register more
    formatters. In this example, we will add a hex formatter and a binary formatter.
    Every time the value of the default formatter is updated, the registered formatters
    will be notified and take action. In this case, the action is to show the new
    value in the relevant format.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的思想基于ActiveState Python Observer代码配方([https://code.activestate.com/](https://code.activestate.com/))。有一个默认的格式化器，以十进制格式显示值。然而，我们可以添加/注册更多的格式化器。在这个例子中，我们将添加十六进制格式化器和二进制格式化器。每当默认格式化器的值更新时，注册的格式化器将被通知并采取行动。在这种情况下，操作是在相关格式中显示新值。
- en: The observer pattern is one of the patterns where inheritance makes sense. We
    can have a base `Publisher` class that contains the common functionality of adding,
    removing, and notifying observers. Our `DefaultFormatter` class derives from `Publisher`
    and adds the formatter-specific functionality. We can also dynamically add and
    remove observers on demand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是其中继承有意义的模式之一。我们可以有一个包含添加、删除和通知观察者公共功能的基类`Publisher`。我们的`DefaultFormatter`类从`Publisher`派生，并添加了格式化器特定的功能。我们还可以根据需要动态添加和删除观察者。
- en: 'We will begin with the `Publisher` class. The observers are kept in the observer''s
    list. The `add()` method registers a new observer or throws an error if it already
    exists. The `remove()` method unregisters an existing observer or throws an exception
    if it does not exist. Finally, the `notify()` method informs all observers about
    a change. This is shown in the following code block:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Publisher`类开始。观察者被保存在观察者列表中。`add()`方法注册一个新的观察者，如果它已经存在则抛出错误。`remove()`方法注销现有的观察者，如果不存在则抛出异常。最后，`notify()`方法通知所有观察者关于变化的信息。这将在下面的代码块中展示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's continue with the `DefaultFormatter` class. The first thing that `__init__()`
    does is call the `__init__()` method of the base class since this is not done
    automatically in Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续 `DefaultFormatter` 类。`__init__()` 方法首先做的事情是调用基类的 `__init__()` 方法，因为在 Python
    中这不会自动完成。
- en: 'A `DefaultFormatter` instance has a name to make it easier for us to track
    its status. We use `_data` variable to state that it should not be accessed directly.
    Note that this is always possible in Python but fellow developers have no excuse
    for doing so since the code already states that they shouldn''t. `DefaultFormatter`
    treats the `_data` variable as an integer, and the default value is `0`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultFormatter` 实例有一个名称，这使得我们更容易跟踪其状态。我们使用 `_data` 变量来表示它不应该被直接访问。请注意，在
    Python 中这始终是可能的，但其他开发者没有理由这样做，因为代码已经声明了他们不应该这样做。`DefaultFormatter` 将 `_data` 变量视为整数，默认值是
    `0`：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `__str__()` method returns information about the name of the publisher
    and the value of the `_data` attribute. `type(self).__name__` is a handy trick
    to get the name of a class without hardcoding it. It is one of those tricks that
    makes your code easier to maintain:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()` 方法返回有关发布者名称和 `_data` 属性值的信息。`type(self).__name__` 是一个方便的技巧，可以获取类的名称而不需要硬编码。这是那些使你的代码更容易维护的技巧之一：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two `data()` methods. The first one uses the `@property` decorator
    to give read access to the `_data` variable. Using this, we can just execute `object.data`
    instead of `object.data()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 `data()` 方法。第一个方法使用 `@property` 装饰器来提供对 `_data` 变量的读取访问。使用这种方式，我们可以直接执行
    `object.data` 而不是 `object.data()`：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second `data()` method is more interesting. It uses the `@setter` decorator,
    which is called every time the assignment (`=`) operator is used to assign a new
    value to the `_data` variable. This method also tries to cast a new value to an
    integer, and does exception handling in case this operation fails:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `data()` 方法更有趣。它使用 `@setter` 装饰器，每次使用赋值运算符（`=`）为 `_data` 变量分配新值时都会调用它。此方法还尝试将新值转换为整数，并在操作失败时进行异常处理：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to add the observers. The functionality of `HexFormatter`
    and `BinaryFormatter` is very similar. The only difference between them is how
    they format the value of the data that''s received by the publisher – that is,
    in hexadecimal and binary, respectively:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加观察者。`HexFormatter` 和 `BinaryFormatter` 的功能非常相似。它们之间的唯一区别是它们如何格式化发布者接收到的数据值——即分别以十六进制和二进制格式：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To help us use those classes, the `main()` function initially creates a `DefaultFormatter`
    instance named `test1` and, afterward, attaches (and detaches) the two available
    observers. We also have some exception handling to ensure that the application
    doesn't crash when erroneous data is passed by the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们使用这些类，`main()` 函数最初创建了一个名为 `test1` 的 `DefaultFormatter` 实例，之后附加（并断开）了两个可用的观察者。我们还添加了一些异常处理，以确保当用户传递错误数据时应用程序不会崩溃。
- en: 'The code is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Moreover, tasks such as trying to add the same observer twice or removing an
    observer that does not exist should cause no crashes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试添加相同的观察者两次或删除不存在的观察者等任务不应导致崩溃：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before we run this code and observe the output, let''s have a recap on the
    full code (the `observer.py` file):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行此代码并观察输出之前，让我们回顾一下完整的代码（`observer.py` 文件）：
- en: First, we define the `Publisher` class.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了 `Publisher` 类。
- en: Then, we define the `DefaultFormatter` class, along with its `special __init__`
    and `__str__` methods.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了 `DefaultFormatter` 类，以及它的 `special __init__` 和 `__str__` 方法。
- en: We add the `data` property getter and setter methods to the `DefaultFormatter`
    class.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `data` 属性的获取器和设置器方法添加到 `DefaultFormatter` 类中。
- en: We define our two observer classes.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的两个观察者类。
- en: Finally, we take care of the main part of the program.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理程序的主要部分。
- en: 'Executing the `python observer.py` command gives us the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `python observer.py` 命令会给我们以下输出：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we can see that as the extra observers are added, the more (and more
    relevant) output is shown, and when an observer is removed, it is not notified
    any longer. That''s exactly what we want: runtime notifications that we can enable/disable
    on demand.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，随着额外观察者的添加，显示的输出（更多且更相关）也越来越多，当移除观察者时，它将不再被通知。这正是我们想要的：可以按需启用/禁用的运行时通知。
- en: The defensive programming part of the application also seems to work fine. Trying
    to do funny things, such as removing an observer that does not exist or adding
    the same observer twice, is not allowed. The messages that are shown are not very
    user-friendly, but I leave it up to you to make them friendlier as an exercise.
    Runtime failures such as trying to pass a string when the API expects a number
    are also handled properly without causing the application to crash/terminate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的防御性编程部分看起来也运行良好。尝试做一些有趣的事情，比如移除一个不存在的观察者或者重复添加同一个观察者，是不被允许的。显示的消息并不十分友好，但我将这项任务留给你作为练习，使其更加友好。当API期望一个数字时尝试传递一个字符串等运行时错误也被妥善处理，不会导致应用程序崩溃/终止。
- en: This example would be much more interesting if it were interactive. Even a simple
    menu that allows the user to attach/detach observers at runtime and modify the
    value of `DefaultFormatter` would be nice because the runtime aspect becomes much
    more visible. Feel free to do this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个示例是交互式的，将会更有趣。甚至一个简单的菜单，允许用户在运行时附加/移除观察者并修改`DefaultFormatter`的值，也会很棒，因为运行时特性会变得更加明显。请随意这样做。
- en: Another nice exercise is to add more observers. For example, you can add an
    octal formatter, a Roman numeral formatter, or any other observer that uses your
    favorite representation. Be creative! With this, we have completed our discussion
    on the observer pattern.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不错的练习是添加更多的观察者。例如，你可以添加一个八进制格式器、一个罗马数字格式器或任何其他使用你喜欢的表示方法的观察者。发挥创意！通过这一点，我们完成了对观察者模式的讨论。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the observer design pattern, including many examples,
    such as Kivy, the framework for developing innovative user interfaces, along with
    its **Properties** concept and module, and the Python bindings of RabbitMQ (we
    referred to a specific example of RabbitMQ that's used to implement the publish-subscribe,
    or the observer, pattern).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了观察者设计模式，包括许多示例，例如Kivy，一个用于开发创新用户界面的框架，以及其**属性**概念和模块，以及RabbitMQ的Python绑定（我们提到了一个用于实现发布-订阅或观察者模式的RabbitMQ的具体示例）。
- en: We also learned how to use the observer pattern to create data formatters that
    can be attached and detached at runtime to enrich the behavior of an object. Hopefully,
    you will find the recommended exercises interesting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用观察者模式创建可以在运行时附加和移除的数据格式器，以丰富对象的行为。希望你会觉得推荐的练习很有趣。
- en: This also marks the end of this book. Congratulations on making it to the end,
    and I hope that the material that's been covered has been helpful for you in taking
    your Python skills to the next level!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着本书的结束。恭喜你坚持到最后，希望所涵盖的材料对你提升Python技能有所帮助！
- en: Questions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章内容的了解：
- en: What is the main motivation for the observer pattern?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者模式的主要动机是什么？
- en: How is the observer pattern different from the MVC pattern when it comes to
    updating other components of an application when a target component changes?
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当目标组件发生变化时，观察者模式与MVC模式在更新应用程序的其他组件方面有何不同？
- en: How is the observer pattern implemented in the Python example of value formatters?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python示例中，值格式器的观察者模式是如何实现的？
