- en: Chapter 6. Retrieving Information from Users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 从用户检索信息
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Selecting files with a `FileDialog`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FileDialog`选择文件
- en: Searching text with a `FindReplaceDialog`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FindReplaceDialog` 搜索文本
- en: Getting images with `ImageDialog`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ImageDialog` 获取图片
- en: Using the Print dialogs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用打印对话框
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Being able to retrieve information from users is an essential part of any application.
    Dialogs are one of the many ways of retrieving information from users; most desktop
    applications use a number of common dialogs for tasks such as opening, saving,
    and printing files.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从用户那里检索信息是任何应用程序的基本部分。对话框是检索用户信息的一种方式；大多数桌面应用程序都使用一些常见的对话框来执行诸如打开、保存和打印文件等任务。
- en: 'There are two main types of dialogs: Modal and Modeless. Modal dialogs are
    dialogs that, when shown, block and disable interaction with their parent window
    or all other windows in an application (in the case of an application-modal dialog).
    Modal dialogs are used for cases where a program must retrieve data from a user
    before proceeding to its next task. Modeless dialogs, on the other hand, behave
    similarly to Frames. When modeless dialogs are shown, the other windows in the
    application remain accessible. When closed, modeless dialogs will usually post
    an event to their parent window to inform it that the dialog has closed.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的对话框类型：模态对话框和模式对话框。模态对话框是在显示时阻止并禁用与其父窗口或应用程序中所有其他窗口（在应用程序模态对话框的情况下）的交互的对话框。模态对话框用于程序在继续其下一个任务之前必须从用户那里检索数据的情况。另一方面，模式对话框的行为类似于框架。当显示模式对话框时，应用程序中的其他窗口仍然可访问。当关闭模式对话框时，通常会将一个事件发送到其父窗口，以通知它对话框已关闭。
- en: wxPython supplies many built-in dialogs that can fill the needs of almost any
    common circumstance. So let's take a look at a handful of these common dialogs
    in action with the recipes in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 提供了许多内置对话框，可以满足几乎所有常见情况的需求。因此，让我们通过本章中的食谱来查看一些这些常见对话框的实际应用。
- en: Selecting files with a FileDialog
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FileDialog选择文件
- en: Allowing users to open and save files is one of the most fundamental capabilities
    of many applications. To provide this functionality, it is often necessary to
    give the user the ability to select which files to open, what to name a file,
    and where to put it when saving a new file. The `FileDialog` can be used to fill
    this role in your application. This recipe creates a simple text editor application
    that can open and save text files to show how to use the `FileDialog`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户打开和保存文件是许多应用最基本的功能之一。为了提供这一功能，通常需要赋予用户选择打开哪些文件、为新文件命名以及保存新文件的位置的能力。`FileDialog`
    可以在您的应用中扮演这一角色。本食谱创建了一个简单的文本编辑应用，可以打开和保存文本文件，以展示如何使用 `FileDialog`。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we will create a complete text-editor application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个完整的文本编辑器应用程序：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our main application window is defined here, and consists of a Frame, TextCtrl,
    and MenuBar:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要应用程序窗口在此定义，并包括一个框架（Frame）、文本控件（TextCtrl）和菜单栏（MenuBar）：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here are the event handlers for the `MenuItems` we added to the Frame's MenuBar
    above. These event handlers are used mostly to just delegate to the method that
    performs the action the user requested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在Frame的MenuBar上添加的`MenuItems`的事件处理器。这些事件处理器主要用于将任务委托给执行用户请求的操作的方法。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, in the `DoOpen` method, we make the first use of the `FileDialog` in
    `OPEN` mode to allow the user to select the file they wish to open:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，在`DoOpen`方法中，我们首次使用`FileDialog`的`OPEN`模式，允许用户选择他们希望打开的文件：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `DoSaveAs`, we see the second use of the `FileDialog` to allow the user to
    choose where to save the file to, by creating the dialog in `SAVE` mode.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DoSaveAs` 中，我们看到了 `FileDialog` 的第二次使用，通过以 `SAVE` 模式创建对话框，允许用户选择保存文件的位置。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just to provide a feel of how quickly you can create a usable application in
    wxPython, let's just look at the recipe above. In roughly 100 lines of code, we
    have basically implemented a Windows Notepad clone. Since this recipe was about
    the `FileDialog`, let's just focus in on the `DoOpen` and `DoSaveAs` methods of
    our text editor application, to see how it works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了提供一个感觉，看看你能在wxPython中多快地创建一个可用的应用程序，让我们来看看上面的配方。大约100行代码，我们就基本实现了一个Windows记事本克隆版。由于这个配方是关于`FileDialog`的，我们就专注于我们的文本编辑应用程序的`DoOpen`和`DoSaveAs`方法，看看它是如何工作的。
- en: 'The `FileDialog` has two basic modes: Open and Save. The mode of the dialog
    depends upon which style flags it was created with. Our `DoOpen` method creates
    it with the `FD_OPEN` style flag, which puts it into Open mode. Open mode differs
    from Save mode in that it only allows you to select a file and not enter a name
    in order to create a new one.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileDialog` 有两种基本模式：打开和保存。对话框的模式取决于它创建时使用的样式标志。我们的 `DoOpen` 方法使用 `FD_OPEN`
    样式标志来创建它，这使得它处于打开模式。打开模式与保存模式的不同之处在于，它只允许你选择一个文件，而不能输入名称来创建一个新的文件。'
- en: 'In both of our uses of the `FileDialog` in this application, we used the same
    set of optional parameters for creating it. The `wildcards` parameter accepts
    a specially-formatted string to specify the file filter list in the dialog. This
    string must be formatted as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在这个应用程序中使用的两个`FileDialog`中，我们都使用了相同的可选参数来创建它。`wildcards`参数接受一个特殊格式的字符串来指定对话框中的文件过滤器列表。这个字符串必须按照以下格式进行格式化：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The fields in this string are interpreted as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该字符串中的字段解释如下：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each field is a description followed by the pipe character as a separator, and
    then the `wx.ID_OK` wildcards to associate with that description. Multiple wildcards
    are separated by a semicolon.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都是一个描述，后面跟着管道字符作为分隔符，然后是`wx.ID_OK`通配符来与该描述关联。多个通配符由分号分隔。
- en: Once the dialog is set up, its usage is quite simple. It just needs to be shown
    by using `ShowModal`. Then, if the user closed it with the affirmative, we just
    need to call the dialog's `GetPath` method in order to get the path that was selected
    or entered into the dialog by the user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了对话框，其使用方法非常简单。只需使用 `ShowModal` 来显示它。然后，如果用户确认关闭它，我们只需调用对话框的 `GetPath` 方法，以便获取用户在对话框中选择的或输入的路径。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `FileDialog's` constructor takes a number of parameters to customize its
    behavior; see below for more information on how to setup a `FileDIalog`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileDialog`的构造函数接受多个参数以自定义其行为；有关如何设置`FileDialog`的更多信息，请参阅下文。'
- en: Default paths
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认路径
- en: The `FileDialog` has a few extra parameters that we did not use in our application,
    and that can be used to customize its initial state. The first is the `defaultDir`
    parameter, which takes a directory path as a value. This path must exist, and
    will ensure that the dialog is shown with that directory selected initially. The
    other additional parameter is `defaultFile`, which takes the name of a file as
    a value. This will be put as the default value in the dialog's filename field.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileDialog`有几个我们应用中没有使用的额外参数，可以用来自定义其初始状态。第一个是`defaultDir`参数，它接受一个目录路径作为值。这个路径必须存在，并且将确保对话框以该目录选中时显示。另一个额外的参数是`defaultFile`，它接受一个文件名作为值。这将被设置为对话框文件名字段的默认值。'
- en: Style flags
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式标志
- en: 'The style flags and their descriptions are shown in the following table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 样式标志及其描述如下表所示：
- en: '| Style Flags | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.FD_DEFAULT_STYLE` | Same as `wx.FD_OPEN` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_DEFAULT_STYLE` | 与 `wx.FD_OPEN` 相同 |'
- en: '| `wx.FD_OPEN` | Create it as an Open dialog. Cannot be combined with `wx.FD_SAVE`.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_OPEN` | 创建为打开对话框。不能与 `wx.FD_SAVE` 结合使用。 |'
- en: '| `wx.FD_SAVE` | Create it as a Save dialog. Cannot be combined with `wx.FD_OPEN`.
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_SAVE` | 创建一个保存对话框。不能与 `wx.FD_OPEN` 结合使用。 |'
- en: '| `wx.FD_OVERWRITE_PROMPT` | Prompt for confirmation if the path already exists.
    For Save dialog only. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_OVERWRITE_PROMPT` | 确认路径已存在时的提示。仅适用于保存对话框。 |'
- en: '| `wx.FD_FILE_MUST_EXIST` | Allow users to select only files that actually
    exist. For Open dialog only. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_FILE_MUST_EXIST` | 允许用户仅选择实际存在的文件。仅适用于打开对话框。 |'
- en: '| `wx.FD_MULTIPLE` | Allow multiple files to be selected. For Open dialog only.
    Should use the dialogs `GetPaths` method to get the list of selected paths. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_MULTIPLE` | 允许多个文件被选中。仅适用于打开对话框。应使用对话框的`GetPaths`方法来获取选中路径的列表。 |'
- en: '| `wx.FD_PREVIEW` | Show a preview of the selected file. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_PREVIEW` | 显示所选文件的预览。 |'
- en: '| `wx.FD_CHANGE_DIR` | Change the current working directory to where the user
    selected the file(s). If not using the `defaultDir` parameter, the next time the
    dialog is opened, it will open to the last-used location. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FD_CHANGE_DIR` | 将当前工作目录更改为用户选择文件的位置。如果不使用`defaultDir`参数，下次打开对话框时，它将打开到最后一次使用的位置。
    |'
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* explains the usage of
    the built-in IDs.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 使用wxPython入门")中的*使用库存ID*配方，在*使用wxPython入门*中解释了内置ID的用法。'
- en: The *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* covers the basics of event handling.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。响应事件")中的“*处理事件*”食谱涵盖了事件处理的基本知识。'
- en: The *Adding Menus and MenuBars* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    discusses how to add menus to a Frame.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *添加菜单和菜单栏* 菜谱，*用户界面基本构建块* 讨论了如何将菜单添加到框架中。'
- en: Searching text with a FindReplaceDialog
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FindReplaceDialog搜索文本
- en: The `FindReplaceDialog` is a common dialog for getting information from the
    user in order to perform find and replace actions in an application. The `FindReplaceDialog`
    is always used as a modeless dialog, and emits events when its buttons are clicked
    that notify the parent window of the action that the user wishes to perform. This
    recipe will extend the previous recipe (`FileDialog`) to show how to add the Find
    and Replace functionality to an application using the `FindReplaceDialog`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindReplaceDialog` 是一个常见的对话框，用于从用户那里获取信息以便在应用程序中执行查找和替换操作。`FindReplaceDialog`
    总是作为一个无模式对话框使用，当其按钮被点击时，会发出事件通知父窗口用户希望执行的操作。本食谱将扩展之前的食谱（`FileDialog`），展示如何使用 `FindReplaceDialog`
    将查找和替换功能添加到应用程序中。'
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here we will show how we subclassed the `FileEditorFrame` to add find and replace
    functionality with the `FindReplaceDialog:`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将展示我们如何通过`FindReplaceDialog:`对`FileEditorFrame`进行子类化以添加查找和替换功能：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This method is a helper method that creates the `FindReplaceDialog` in the
    correct mode, depending on which action the user selects from the Menu:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是一个辅助方法，根据用户从菜单中选择的行为，以正确的模式创建`FindReplaceDialog`：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This first event handler is used to handle the events when a menu item is selected,
    and will be used to create and show the appropriate version of the `FindReplaceDialog:`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个事件处理器用于处理当选择菜单项时的事件，并将用于创建和显示相应的`FindReplaceDialog:`版本：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These next four event handlers handle events that are generated by the `FindReplaceDialog`
    in response to user actions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个事件处理器处理由`FindReplaceDialog`在用户操作后生成的事件：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, here we have a very simple method of searching for a given string
    in the `TextCtrl`, and setting the selection if a match is found:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个在`TextCtrl`中搜索给定字符串并设置选择的非常简单的方法：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the previous code will result in a window like the following being
    shown:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将会显示如下窗口：
- en: '![How to do it...](img/1780_06_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_06_01.jpg)'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we took the `FileEditorFrame` class that we created in the last
    recipe and extended it to have find and replace functionality, by using the `FindReplaceDialog`.
    So let's take a look at how we made use of the `FindReplaceDialog` by walking
    through what we added to this class from top to bottom.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了在上一道菜谱中创建的`FileEditorFrame`类，并通过使用`FindReplaceDialog`扩展了其查找和替换功能。因此，让我们通过查看我们添加到这个类中的内容，从上到下了解我们是如何利用`FindReplaceDialog`的。
- en: 'In our `FindReplaceEditorFrame` class''s `__init__` method, we added two instance
    attributes, `finddlg` and `finddata`. Since the `FindReplaceDialog` is modeless,
    we need to keep track of it in our class so we can properly clean it up later,
    to ensure that it will get assigned to the `finddlg` attribute when it is created.
    The second attribute, `finddata`, holds a reference to the `FindReplaceData` that
    is used for initializing the dialog, as well as for passing data back and forth
    between the dialog, and its parent window. We keep a reference to this item for
    two firstly, one it allows convenient access to the dialogs flags and user entered
    find and replace field strings, and secondly, by using the same `FindReplaceData`
    object each time, the dialog will be initialized with the same settings that the
    user last used it with. The last thing to take note of in `__init__` is the event
    binding: we bound to five of the events that the `FindReplaceDialog` can emit
    as a user interacts with it.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `FindReplaceEditorFrame` 类的 `__init__` 方法中，我们添加了两个实例属性，`finddlg` 和 `finddata`。由于
    `FindReplaceDialog` 是非模态的，我们需要在我们的类中跟踪它，以便我们可以在稍后适当地清理它，确保它在创建时将被分配给 `finddlg`
    属性。第二个属性 `finddata` 保存了对 `FindReplaceData` 的引用，该数据用于初始化对话框，以及用于在对话框和其父窗口之间传递数据。我们保留对这个项目的引用有两个原因，首先，它允许方便地访问对话框的标志和用户输入的查找和替换字段字符串，其次，通过每次使用相同的
    `FindReplaceData` 对象，对话框将使用用户上次使用时相同的设置进行初始化。在 `__init__` 中需要注意的最后一件事是事件绑定：我们将五个
    `FindReplaceDialog` 可以在用户与之交互时发出的事件绑定到它。
- en: The next new method is the `_InitFindDialog` method. This method is what we
    use to initialize the `FindReplaceDialog` in response to the **Find** or **Replace**
    menu item events. Since our application is only going to support a simple one-direction,
    case-insensitive search, we disabled all the extra options in the dialog with
    the appropriate style flags. Then we simply create the dialog with the `FR_REPLACEDIALOG`
    flag if we are in replace mode, or without it if we are not, and finally assign
    the new dialog instance to our `finddlg` attribute.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新方法是 `_InitFindDialog` 方法。这个方法是我们用来响应 **查找** 或 **替换** 菜单项事件以初始化 `FindReplaceDialog`
    的。由于我们的应用程序只将支持简单的单向、不区分大小写的搜索，我们使用适当的样式标志禁用了对话框中的所有额外选项。然后，如果我们处于替换模式，我们简单地使用
    `FR_REPLACEDIALOG` 标志创建对话框，如果不处于替换模式，则不使用该标志，最后将新的对话框实例分配给我们的 `finddlg` 属性。
- en: The next section to look at is our `FindReplaceDialog` event handlers. This
    is where we handle the requested actions made by the user that is using the dialog.
    `OnFind` handles the situation where the user clicks the **Find** or **Find Next**
    buttons in the dialog. Here, we first get the string that was entered into the
    dialog by using our `finddata` attribute to access it. Then we perform a simple
    search in the text of the base class's `TextCtrl`, selecting the match if one
    is found, or use `wx.Bell` to make the computer beep at the user if no match is
    found.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要查看的部分是我们的 `FindReplaceDialog` 事件处理器。这里我们处理用户通过对话框发起的请求操作。`OnFind` 处理用户在对话框中点击
    **查找** 或 **查找下一个** 按钮的情况。在这里，我们首先通过使用我们的 `finddata` 属性来访问它，获取到对话框中输入的字符串。然后我们在基类的
    `TextCtrl` 文本中进行简单搜索，如果找到匹配项则选择它，如果没有找到匹配项则使用 `wx.Bell` 使计算机对用户发出蜂鸣声。
- en: '`OnReplace` is called in response to the `FindReplaceDialogs` **Replace** button
    in the `FindReplaceDialog` being clicked. Here we get both the entered find and
    replace strings from the `FindReplaceData`. We then try to find a match and replace
    that match with the entered replace string. `OnReplaceAll` is called in response
    to the dialog''s **Replace All** button being clicked, and does basically the
    same thing as `OnReplace`, but applies it to all matches in the `TextCtrl` text.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnReplace` 方法在点击 `FindReplaceDialog` 中的 `Replace` 按钮时被调用。在这里，我们从 `FindReplaceData`
    中获取输入的查找和替换字符串。然后我们尝试找到匹配项，并用输入的替换字符串替换该匹配项。`OnReplaceAll` 方法在点击对话框的 `Replace
    All` 按钮时被调用，它基本上与 `OnReplace` 做相同的事情，但将操作应用于 `TextCtrl` 文本中的所有匹配项。'
- en: The last event handler is `OnFindClose`. This is called when the user closes
    the `FindReplaceDialog`. We need to handle this event so that we can clean up
    the dialog by calling `Destroy` on it. That's it. Now we have a text editor application
    that has find and replace functionality!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的事件处理程序是 `OnFindClose`。当用户关闭 `FindReplaceDialog` 时会调用此函数。我们需要处理这个事件，以便通过调用其上的
    `Destroy` 方法来清理对话框。就这样。现在我们有一个具有查找和替换功能文本编辑器应用程序了！
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For simplicity's sake, this recipe disabled the dialog's extra find options.
    When these options are selected in the dialog, they can be checked for, just like
    the find and replace strings, by using the `FindReplaceData` object. It will have
    the selected option's flags set in the value returned from `GetFlags`, which is
    a bitmask of the `FindReplaceData` flags. Due to the way in which these flags
    and the dialog's style flags are named, it can be a little confusing to know which
    are which, so please refer to the following two tables to distinguish between
    these two different, yet similarly-named sets of flags.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，这个配方禁用了对话框的额外查找选项。当在对话框中选择这些选项时，可以通过使用`FindReplaceData`对象来检查它们，就像查找和替换字符串一样。它将在`GetFlags`返回的值中设置所选选项的标志，这是一个`FindReplaceData`标志的位掩码。由于这些标志和对话框样式标志的命名方式，了解它们各自是什么可能会有些困惑，因此请参考以下两个表格来区分这两组不同但名称相似的标志集。
- en: FindReplaceDialog style flags
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FindReplaceDialog样式标志
- en: 'These flags are flags that should be passed to the dialog''s constructor''s
    style parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志是应该传递给对话框构造函数的样式参数的标志：
- en: '| Flags | Description |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Flags | 描述 |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.FR_NOMATCHCASE` | Disable the "match case" checkbox |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_NOMATCHCASE` | 禁用“区分大小写”复选框 |'
- en: '| `wx.FR_NOUPDOWN` | Disable the "up" and "down" radio buttons |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_NOUPDOWN` | 禁用“上”和“下”单选按钮 |'
- en: '| `wx.FR_NOWHOLEWORD` | Disable the "whole word" checkbox |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_NOWHOLEWORD` | 禁用“全字”复选框 |'
- en: '| `wx.FR_REPLACEDIALOG` | Create the dialog in Replace mode |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_REPLACEDIALOG` | 在替换模式下创建对话框 |'
- en: FindReplaceData flags
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FindReplaceData 标志
- en: The following flags are flags that can be set in `FindReplaceData` to set the
    initial state of the dialog and to identify the user's selected find preferences.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标志是可以在`FindReplaceData`中设置的标志，用于设置对话框的初始状态以及识别用户选择的查找偏好。
- en: '| Flags | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.FR_DOWN` | The "down" radio button is selected |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_DOWN` | “向下”单选按钮被选中 |'
- en: '| `wx.FR_MATCHCASE` | The "match case" checkbox is selected |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_MATCHCASE` | “匹配大小写”复选框被选中 |'
- en: '| `wx.FR_WHOLEWORD` | The "whole word" checkbox is selected |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FR_WHOLEWORD` | “全词”复选框被选中 |'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Selecting files with a FileDialog* recipe for the base example that
    this recipe extends.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*使用FileDialog选择文件*的配方，以了解此配方扩展的基本示例。
- en: The *Understanding event propagation* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* contains more information on how events are
    delivered to different windows.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。响应事件")中的*理解事件传播*配方，*响应事件*包含了更多关于事件如何传递到不同窗口的信息。'
- en: Getting images with ImageDialog
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ImageDialog获取图片
- en: '`ImageDialog` is a custom dialog class provided by the `wx.lib.imagebrowser`
    module. It is similar in purpose to the default `FileDialog`, but is specialized
    for allowing the user to select and preview images. This recipe shows how to use
    this dialog to retrieve a user-selected image and load it into a `StaticBitmap`
    for display in the application''s main window.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageDialog` 是由 `wx.lib.imagebrowser` 模块提供的一个自定义对话框类。它在目的上与默认的 `FileDialog`
    类似，但专门用于允许用户选择和预览图像。本菜谱展示了如何使用此对话框检索用户选择的图像并将其加载到 `StaticBitmap` 中，以便在应用程序的主窗口中显示。'
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will create a very simple image viewer application that allows the
    user to select an image to view with the ImageDialog:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个非常简单的图片查看器应用程序，允许用户使用ImageDialog选择要查看的图片：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the previous code and clicking on the Choose Image button will result
    in the following dialog being shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一段代码并点击选择图片按钮，将会显示以下对话框：
- en: '![How to do it...](img/1780_06_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_06_02.jpg)'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we created a simple little image viewer application that allows
    the user to use the `ImageDialog` to choose an image that is on the computer's
    hard drive, and have this image displayed in the application's window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个简单的图像查看器应用程序，允许用户使用`ImageDialog`选择计算机硬盘上的图像，并在应用程序窗口中显示该图像。
- en: This application follows the common pattern of most simple applications. So
    let's take a detailed look at how we used the `ImageDialog`. First, we had to
    import the `wx.lib.imagebrowser` module, as the `ImageDialog` is not a part of
    the standard wx module. In our `ImageDialogFrame` class, we added three instance
    attributes. The first is to hold the path that was last used by the `ImageDialog`.
    We did this as a way to improve the usability of the application so that we can
    open the dialog to the last path the user used the next time they open it. The
    second attribute is a `StaticBitmap` object, which we will use to display the
    image that the user selects with the `ImageDialog`. Note that we used a `StaticBitmap`
    in this example for simplicity. To better support larger-sized images, it would
    be better to draw the image on the `Panel` ourselves. This approach will be covered
    by topics in [Chapter 8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing
    to the Screen*. The last attribute is just a button that will be used to trigger
    the event to show the `ImageDialog`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序遵循了大多数简单应用程序的常见模式。因此，让我们详细看看我们是如何使用`ImageDialog`的。首先，我们必须导入`wx.lib.imagebrowser`模块，因为`ImageDialog`不是标准wx模块的一部分。在我们的`ImageDialogFrame`类中，我们添加了三个实例属性。第一个是用来保存`ImageDialog`上次使用的路径。我们这样做是为了提高应用程序的可用性，以便我们可以在用户下次打开应用程序时打开对话框到他们上次使用的最后一个路径。第二个属性是一个`StaticBitmap`对象，我们将使用它来显示用户通过`ImageDialog`选择的图像。请注意，我们在这个例子中使用了`StaticBitmap`以简化示例。为了更好地支持更大尺寸的图像，最好是我们自己将图像绘制在`Panel`上。这种方法将在[第8章](ch08.html
    "第8章。屏幕绘图")，*屏幕绘图*这一主题中介绍。最后一个属性只是一个按钮，它将用来触发显示`ImageDialog`的事件。
- en: This application follows the common pattern of most simple applications. So
    let's take a detailed look at how we used the `ImageDialog`. First, we had to
    import the `wx.lib.imagebrowser` module, as the `ImageDialog` is not a part of
    the standard wx module. In our `ImageDialogFrame` class, we added three instance
    attributes. The first is to hold the path that was last used by the `ImageDialog`.
    We did this as a way to improve the usability of the application so that we can
    open the dialog to the last path the user used the next time they open it. The
    second attribute is a `StaticBitmap` object, which we will use to display the
    image that the user selects with the `ImageDialog`. Note that we used a `StaticBitmap`
    in this example for simplicity. To better support larger-sized images, it would
    be better to draw the image on the `Panel` ourselves. This approach will be covered
    by topics in [Chapter 8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing
    to the Screen*. The last attribute is just a button that will be used to trigger
    the event to show the `ImageDialog`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序遵循了大多数简单应用程序的常见模式。因此，让我们详细看看我们是如何使用`ImageDialog`的。首先，我们必须导入`wx.lib.imagebrowser`模块，因为`ImageDialog`不是标准wx模块的一部分。在我们的`ImageDialogFrame`类中，我们添加了三个实例属性。第一个是用来保存`ImageDialog`上次使用的路径。我们这样做是为了提高应用程序的可用性，以便我们可以在用户下次打开应用程序时打开对话框到他们上次使用的最后一个路径。第二个属性是一个`StaticBitmap`对象，我们将使用它来显示用户通过`ImageDialog`选择的图像。请注意，我们在这个例子中使用了`StaticBitmap`以简化示例。为了更好地支持更大尺寸的图像，最好是我们自己将图像绘制在`Panel`上。这种方法将在[第8章](ch08.html
    "第8章。屏幕绘图")，*屏幕绘图*这一主题中介绍。最后一个属性只是一个按钮，它将被用来触发显示`ImageDialog`的事件。
- en: Our `OnShowDialog` method in this recipe creates the `ImageDialog` and initializes
    it to the last path used. The first time, it will be None, which defaults to the
    current working directory. The dialog is then shown, in order to allow the user
    to navigate to and select an image to display. If they click on the dialog's **Open**
    button, the dialog will return `wx.ID_OK`. At this point, we first get and save
    a reference to the last directory that the dialog was at so that we can restore
    it next time the dialog is shown. Then all that is left is to create the Bitmap
    and call the `StaticBitmap's SetBitmap` method to change the image that is displayed.
    After this, it is necessary to call `Layout` on the `Panel`, to make sure the
    sizers can compensate for the new `Bitmap's` size, and then we finally call `Refresh`
    on the `StaticBitmap` to make sure it is completely repainted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们的 `OnShowDialog` 方法创建 `ImageDialog` 并将其初始化为上次使用的路径。第一次使用时，它将是 None，默认为当前工作目录。然后显示对话框，以便用户导航并选择要显示的图像。如果他们点击对话框的
    **打开** 按钮，对话框将返回 `wx.ID_OK`。在此阶段，我们首先获取并保存对话框最后所在的目录引用，以便下次显示对话框时可以恢复它。然后剩下的就是创建位图并调用
    `StaticBitmap` 的 `SetBitmap` 方法来更改显示的图像。之后，必须调用 `Panel` 上的 `Layout`，以确保调整器可以适应新的
    `Bitmap` 的大小，然后我们最终调用 `StaticBitmap` 上的 `Refresh` 来确保它被完全重绘。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The only other option available in the current version of the `ImageDialog`
    is the ability to change the list of supported file filters. This can be done
    by passing to the dialog's `ChangeFileTypes` method a list of tuples that contain
    the file type's description and wildcard string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 `ImageDialog` 中，唯一可用的其他选项是能够更改支持的文件过滤器列表。这可以通过向对话框的 `ChangeFileTypes`
    方法传递一个包含文件类型描述和通配符字符串的元组列表来实现。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using Bitmaps* recipe in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with wxPython"), *Getting Started* with wxPython has additional examples of using
    Bitmaps and the `StaticBitmap` class.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。使用wxPython入门")中的 *使用位图* 菜单，在 *wxPython入门* 部分提供了使用位图和 `StaticBitmap`
    类的额外示例。'
- en: Using the Print dialogs
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打印对话框
- en: Adding printing support to an application can be a difficult task, as there
    are a number of tasks that need to be handled. These include selecting and configuring
    a printer, translating your on-screen presentation to paper, and ultimately sending
    the data to the printer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印支持添加到应用程序可能是一项艰巨的任务，因为需要处理许多任务。这包括选择和配置打印机、将屏幕上的演示文稿转换为纸张，以及最终将数据发送到打印机。
- en: 'In wxPython, there are three dialog classes related to printing: the `PageSetupDialog,
    PreviewFrame`, and `Printer` classes. In addition to these classes, there are
    a number of supporting classes that must be used in conjunction with these dialogs,
    in order to add printing support to an application. This recipe shows some of
    the basics of how to use the wx printing framework, by creating a class that encapsulates
    the usage of the three printing dialogs and allows an application to print a `Bitmap`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，有三个与打印相关的对话框类：`PageSetupDialog`、`PreviewFrame`和`Printer`类。除了这些类之外，还有一些必须与这些对话框一起使用的支持类，以便将打印支持添加到应用程序中。本菜谱展示了如何使用wx打印框架的一些基本知识，通过创建一个封装三个打印对话框使用的类，允许应用程序打印`Bitmap`。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to simplify and condense the many different steps required to support
    printing in an application, we will start by defining a class to encapsulate the
    different tasks into a few simple method calls:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化并压缩在应用程序中支持打印所需的各种不同步骤，我们将首先定义一个类，将不同的任务封装成几个简单的调用方法：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `PageSetup` method handles the display of the printer setup dialog, and
    storage of the settings in the `print_data` attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageSetup` 方法处理打印机设置对话框的显示，并将设置存储在 `print_data` 属性中：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In Preview, we create the `PrintPreview` dialog to give a preview of what the
    printout will look like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览中，我们创建`PrintPreview`对话框以预览打印输出将呈现的样子：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, in the `Print` method, we show the `Printer` dialog to allow the user
    to request a printout of a `Bitmap`, and send it to the printer to be printed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Print`方法中，我们显示`Printer`对话框，允许用户请求打印一个`Bitmap`，并将其发送到打印机进行打印：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we will implement the `Printout` object for printing `Bitmaps`. The `Printout`
    object is the object that is responsible for managing the print job and drawing
    the bitmap to the printer''s device context:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现用于打印 `Bitmaps` 的 `Printout` 对象。`Printout` 对象是负责管理打印任务并将位图绘制到打印机设备上下文的对象：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `BitmapPrinter` class encapsulates the three main print-related tasks that
    an application may need to support: printer setup, print preview, and printing.
    This class is the interface that the application which wants to allow printing
    `Bitmaps` will use for all of its printing needs. All that the application requires
    is a `Bitmap`, and all that it needs to do is to use one of the three methods,
    `PageSetup, Preview`, and `Print`. So let''s take a look at how this class and
    these three methods work.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapPrinter` 类封装了应用程序可能需要支持的三个主要打印相关任务：打印机设置、打印预览和打印。这个类是想要允许打印 `Bitmaps`
    的应用程序使用的接口，用于其所有打印需求。应用程序所需的一切只是一个 `Bitmap`，而它需要做的只是使用这三个方法之一：`PageSetup`、`Preview`
    和 `Print`。那么，让我们来看看这个类和这三个方法是如何工作的。'
- en: The constructor takes one argument for a parent window. This will be used as
    the parent window for all of the dialogs. This will typically be an application's
    main window. We also create and store a reference to a `PrintData` object in the
    constructor. All of the print dialogs use `PrintData` in one form or another.
    This allows us to save any print configuration changes a user may make while using
    one of the dialogs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个参数用于父窗口。这将被用作所有对话框的父窗口。这通常是一个应用程序的主窗口。我们还在构造函数中创建并存储了一个`PrintData`对象的引用。所有打印对话框都以一种或另一种形式使用`PrintData`。这允许我们在用户使用其中一个对话框时保存用户可能做出的任何打印配置更改。
- en: '`PageSetup` is used to create and show the `PageSetupDialog`. To use the `PageSetupDialog`,
    we first create a `PageSetupDialogData` object by passing our `PrintData` object
    to its constructor, so it will use any settings that may already be persisted
    in our data object. We then simply create the dialog by passing in the `PageSetupDialogData`
    object. If the dialog is closed by the OK button, we then get the `PrintData`
    from the dialog and make a copy of it to store. It is important to make a copy,
    because when the `PageSetupDialog` is destroyed it will delete the data.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageSetup` 用于创建和显示 `PageSetupDialog`。要使用 `PageSetupDialog`，我们首先通过将其构造函数传递我们的
    `PrintData` 对象来创建一个 `PageSetupDialogData` 对象，这样它将使用我们数据对象中可能已经持久化的任何设置。然后我们只需通过传递
    `PageSetupDialogData` 对象来创建对话框。如果对话框通过“确定”按钮关闭，我们随后从对话框中获取 `PrintData` 并制作一个副本以存储。制作副本非常重要，因为当
    `PageSetupDialog` 被销毁时，它将删除数据。'
- en: '`Preview` creates a preview of what the printout will look like, and shows
    it with the `PreviewFrame`. The `PreviewFrame` requires a `PrintPreview` object.
    To create the `PrintPreview` object, it must be passed two `Printout` objects
    and a `PrintData` object. A `Printout` object is what does the actual work of
    rendering what will be printed by the printer. We will come back to the details
    about how the `Printout` works when we get to our `BitmapPrintout` class. The
    first `Printout` object is used for the `PreviewFrame`, and the second one is
    used for the actual printing if the user clicks on the `PreviewFrame''s` Print
    button.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`预览`功能会创建打印输出的预览效果，并通过`PreviewFrame`显示。`PreviewFrame`需要一个`PrintPreview`对象。要创建`PrintPreview`对象，必须传入两个`Printout`对象和一个`PrintData`对象。`Printout`对象负责实际渲染打印机将要打印的内容。当我们到达`BitmapPrintout`类时，我们将回到关于`Printout`如何工作的细节。第一个`Printout`对象用于`PreviewFrame`，第二个对象用于用户点击`PreviewFrame`的打印按钮时的实际打印。'
- en: '`Print` creates a `Printer` object that will show the printer dialog when its
    `Print` method is called. Like the `Preview` object, the `Printer` object is created
    with some `PrintData` and an instance of a `Printout` object. When the print dialog''s
    Print button is clicked, it will use the `Printout` object to tell the physical
    printer what to draw on the paper.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print` 函数创建一个 `Printer` 对象，当调用其 `Print` 方法时将显示打印机对话框。与 `Preview` 对象类似，`Printer`
    对象是在一些 `PrintData` 和一个 `Printout` 对象的实例的基础上创建的。当点击打印对话框中的打印按钮时，它将使用 `Printout`
    对象来告诉物理打印机在纸上绘制什么内容。'
- en: 'The `BitmapPrintout` class implements a `Printout` object that is used for
    printing a single bitmap to a single sheet of paper at a time. `Printout` objects
    must always be subclassed in order to implement the application-specific requirements
    of the data that needs to be printed as the base class only provides an interface
    of virtual methods to override in the subclass. In our class, we overrode the
    three following methods: `GetPageInfo, HasPage`, and `OnPrintPage`. The first
    two are for returning information about the number of pages that will be printed;
    since we are only supporting one page, these are quite trivial in this recipe.
    The `OnPrintPage` method is what does the actual drawing to the printer''s device
    context. This method gets called to do the drawing of each page that will be printed.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapPrintout` 类实现了用于一次性将单个位图打印到一张纸上的 `Printout` 对象。`Printout` 对象必须始终被子类化，以便实现需要打印的数据的应用特定要求，因为基类仅提供了一个接口，该接口在子类中需要重写虚拟方法。在我们的类中，我们重写了以下三个方法：`GetPageInfo`、`HasPage`
    和 `OnPrintPage`。前两个方法用于返回将要打印的页数信息；由于我们只支持一页，这些在这个菜谱中相当简单。`OnPrintPage` 方法是实际将绘图绘制到打印机设备上下文的方法。此方法被调用以绘制将要打印的每一页。'
- en: Drawing the `Printout` is done by using the device context object returned by
    the call to `GetDC`. The use of device contexts are covered in detail in [Chapter
    8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing to the Screen* so just
    too keep things simple all we did here was just to set the scale of the canvas
    calculations to try and center the image on the paper, and then used the DC's
    `DrawBitmap` method to draw the `Bitmap` to the device context. For an example
    of the `BitmapPrinter` class in action, see the sample code that accompanies this
    chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`GetDC`函数返回的设备上下文对象来绘制`Printout`。设备上下文的使用在[第8章](ch08.html "第8章。屏幕绘图") *屏幕绘图*中有详细说明，因此为了简化问题，我们在这里只是将画布计算的缩放比例设置为尝试将图像居中在纸张上，然后使用DC的`DrawBitmap`方法将`Bitmap`绘制到设备上下文中。关于`BitmapPrinter`类的实际应用示例，请参阅本章附带的示例代码。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below is some additional information about the print framework.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含有关打印框架的一些附加信息。
- en: Printout
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印输出
- en: The `wx.Printout` object has a number of other overrideable methods that may
    be of use for different types of documents. The following table is a reference
    to some of these other interface methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx.Printout` 对象拥有许多其他可覆盖的方法，这些方法可能对不同类型的文档有所帮助。下表是这些其他接口方法的一些参考。'
- en: '| Interface methods | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 接口方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OnBeginDocument(start, end)` | Called at the beginning of each copy of a
    document that is in the print job. If this method is overridden, the base class''s
    method must still be called in it. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `OnBeginDocument(start, end)` | 在打印作业中每个文档副本的开始时调用。如果此方法被重写，必须在其中调用基类的该方法。
    |'
- en: '| `OnEndDocument()` | Called at the end of printing each copy of a document
    in the print job. If this method is overridden, the base class method must be
    called in it. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `OnEndDocument()` | 在打印作业中打印每份文档的末尾被调用。如果此方法被重写，必须在其中调用基类方法。 |'
- en: '| `OnBeginPrinting()` | Called once and only once at the beginning of a print
    job. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `OnBeginPrinting()` | 在打印作业开始时只调用一次。 |'
- en: '| `OnEndPrinting()` | Called once and only once at the end of a print job.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `OnEndPrinting()` | 在打印作业结束时只调用一次。 |'
- en: '| `OnPreparePrinting()` | Called before any other use of the `Printout` object.
    This is usually where the calculations about things such as the number of pages
    in a document are done. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `OnPreparePrinting()` | 在使用 `Printout` 对象之前被调用。通常在这里进行关于诸如文档页数等事项的计算。 |'
- en: Bug notice
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bug notice
- en: There is a bug in wxPython 2.8 where the page orientation (Portrait or Landscape)
    cannot be retrieved from the `PageSetup` or `Print` dialog's `PrintData`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython 2.8中存在一个bug，无法从`PageSetup`或`Print`对话框的`PrintData`中检索页面方向（纵向或横向）。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* includes
    a detailed explanation of how to override virtual methods in wxPython classes.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，*wxPython入门*包含了如何覆盖wxPython类中虚拟方法的详细解释。'
- en: The *Screen drawing* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing to
    the Screen"), *Drawing to the Screen* discusses the use of Device Contexts (DCs)
    and their drawing commands.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。屏幕绘图")中的*屏幕绘图*配方，*屏幕绘图*讨论了设备上下文（DCs）及其绘图命令的使用。'
