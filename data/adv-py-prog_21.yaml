- en: '*Chapter 18*: Other Creational Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第18章*：其他创建型模式'
- en: In the previous chapter, we covered a third creational pattern, builder, which
    offers a nice way of creating the various parts of a complex object. Apart from
    the factory method, the abstract factory, and the builder patterns covered so
    far, other creational patterns are interesting to discuss, such as the **prototype**
    pattern and the **singleton** pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一种第三种创建型模式，即建造者模式，它提供了一种创建复杂对象各个部分的好方法。除了工厂方法、抽象工厂和之前提到的建造者模式之外，还有其他创建型模式值得讨论，例如**原型**模式和**单例**模式。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Implementing the prototype pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现原型模式
- en: Implementing the singleton pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单例模式
- en: These topics will complete our discussions on creational patterns and help cover
    the use cases where the design patterns we have seen so far are not appropriate.
    By the end of the chapter, we will have an overall understanding of creational
    patterns and the use cases of each one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题将完成我们对创建型模式的讨论，并帮助覆盖那些我们之前看到的设计模式不适用的情况。到本章结束时，我们将对创建型模式及其每个模式的使用案例有一个整体的理解。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18)。
- en: Implementing the prototype pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现原型模式
- en: The prototype pattern is useful when you need to create objects based on an
    existing object using the **cloning** technique. As you may have guessed, the
    idea is to use a copy of that object's complete structure to produce the new object.
    We will see that this is almost natural in Python because we have a **copy** feature
    that helps greatly in using this technique. In the general case of creating a
    copy of an object, what happens is that you make a new reference to the same object,
    a method called a **shallow copy**. But if you need to duplicate the object, which
    is the case with a prototype, you make a **deep copy**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用**克隆**技术根据现有对象创建对象时，原型模式非常有用。正如你可能猜到的，这个想法是使用该对象完整结构的副本来生成新对象。我们将看到，这在Python中几乎是自然而然的，因为我们有一个**复制**功能，这极大地帮助了使用这种技术。在创建对象副本的一般情况下，发生的情况是你创建了一个指向同一对象的新的引用，这被称为**浅复制**。但是，如果你需要复制对象，即原型模式的情况，你需要进行**深复制**。
- en: Sometimes, we need to create an exact copy of an object. For instance, assume
    that you want to create an application for storing, sharing, and editing presentation
    and marketing content for products promoted by a group of salespeople. Think of
    the popular distribution model called **direct selling** or **network marketing**,
    the home-based activity where individuals partner with a company to distribute
    products within their social network using promotional tools (brochures, PowerPoint
    presentations, videos, and so on).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要创建一个对象的精确副本。例如，假设你想为销售团队推广的产品创建一个存储、分享和编辑演示和营销内容的软件应用。想想流行的直销或网络营销模式，这是一种在家中进行的活动，个人与公司合作，在其社交网络中使用促销工具（如宣传册、PowerPoint演示文稿、视频等）来分销产品。
- en: Let's say a user, *Bob*, leads a team of distributors within a network marketing
    organization. They use a presentation video daily to introduce the product to
    their prospects. At some point, Bob gets his friend, Alice, to join him and she
    also uses the same video (one of the governing principles is to follow the system
    or, as they say, *Duplicate what already works*). But Alice soon finds prospects
    that could join her team and help her business grow, if only the video was in
    French, or at least subtitled. *What should they do?* The original presentation
    video cannot be used for the different custom needs that may arise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个用户，*鲍勃*，在一个网络营销组织中领导着一支分销团队。他们每天使用一个演示视频向潜在客户介绍产品。在某个时候，鲍勃让他的朋友，爱丽丝，加入他，她也使用了同一个视频（一个管理原则是遵循系统，或者说，*复制已经有效的方法*）。但爱丽丝很快发现了一些可以加入她团队并帮助她业务增长的人选，如果视频是法语，或者至少有字幕的话。*他们该怎么办？*原始的演示视频不能用于可能出现的不同定制需求。
- en: To help everyone, the system could allow distributors with certain rank or trust
    levels, such as *Bob*, to create independent copies of the original presentation
    video, as long as the new version is validated by the compliance team of the backing
    company before public use. Each copy is called a **clone**; it is an exact copy
    of the original object at a specific point in time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助每个人，系统可以允许具有特定等级或信任水平的分销商，例如 *Bob*，在原始演示视频被支持公司的合规团队在公开使用前验证后创建独立副本。每个副本都称为
    **克隆**；它是在特定时间点的原始对象的精确副本。
- en: So, Bob, with the validation of the compliance team, makes a copy of the presentation
    video to address the new need and hands it over to Alice. She could then adapt
    that version by adding French subtitles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Bob 在合规团队的验证下，复制了演示视频以应对新的需求，并将其交给 Alice。她可以在此基础上添加法语字幕进行修改。
- en: With cloning, Bob and Alice can have their own copy of a video, and as such,
    changes by each one of them will not affect the other person's version of the
    material. In the alternative situation, which is what actually happens by default,
    each person would hold a reference to the same (reference) object; changes made
    by Bob would impact Alice, and vice versa.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过克隆，Bob 和 Alice 可以拥有自己的视频副本，因此他们各自的更改不会影响对方的材料版本。在另一种情况下，即默认情况下实际发生的情况，每个人都会持有对同一个（引用）对象的引用；Bob
    的更改会影响 Alice，反之亦然。
- en: The prototype design pattern helps us with creating object clones. In its simplest
    version, this pattern is just a `clone()` function that accepts an object as an
    input parameter and returns a clone of it. In Python, this can be done using the
    `deepcopy()` function from the `copy` module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式帮助我们创建对象克隆。在其最简单的版本中，这个模式只是一个接受一个对象作为输入参数并返回其克隆的 `clone()` 函数。在 Python
    中，这可以通过 `copy` 模块中的 `deepcopy()` 函数来实现。
- en: The structure of our discussions will be the same as in previous chapters. First,
    we will briefly discuss real-life applications and use cases, and then implement
    a hands-on example in Python.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论结构将与前几章相同。首先，我们将简要讨论现实生活中的应用和用例，然后在一个 Python 示例中实现动手操作。
- en: Real-world examples
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: A famous non-technical example is the sheep named Dolly, which was created by
    researchers in Scotland by cloning a cell from a mammary gland.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的非技术例子是苏格兰研究人员克隆乳腺细胞创造出的绵羊多莉。
- en: Many Python applications make use of the prototype pattern (`j.mp/pythonprot`),
    but it is seldom referred to as *prototype* since cloning objects is a built-in
    feature of the language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 应用程序都使用了原型模式 (`j.mp/pythonprot`)，但它很少被称为 *原型*，因为克隆对象是语言的一个内置功能。
- en: Use cases
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The prototype pattern is useful when we have an existing object that needs to
    stay untouched, and we want to create an exact copy of it, allowing changes in
    some parts of the copy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个需要保持不变且需要创建其精确副本的现有对象时，原型模式非常有用，允许对副本的某些部分进行更改。
- en: There is also the frequent need for duplicating an object that is populated
    from a database and has references to other database-based objects. It is costly
    (multiple queries to a database) to clone such a complex object, so a prototype
    is a convenient way to solve the problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个经常需要复制从数据库中填充并引用其他基于数据库的对象的对象的需求。克隆这样一个复杂对象成本很高（对数据库进行多次查询），因此原型是一个解决这个问题的便捷方式。
- en: Implementation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Nowadays, some organizations, even of small size, deal with many websites and
    apps via their infrastructure/DevOps teams, hosting providers, or cloud service
    providers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些组织，甚至规模较小的组织，通过其基础设施/DevOps 团队、托管提供商或云服务提供商处理许多网站和应用。
- en: When you have to manage multiple websites, there is a point where it becomes
    difficult to manage everything. You need to access information quickly, such as
    IP addresses that are involved, domain names and their expiration dates, and maybe
    details about the DNS parameters. So, you need a kind of inventory tool.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须管理多个网站时，有一个点会变得难以管理一切。你需要快速访问信息，例如涉及的 IP 地址、域名及其到期日期，以及 DNS 参数的详细信息。因此，你需要一种库存工具。
- en: 'Let''s imagine how these teams deal with this type of data for daily activities
    and touch on the implementation of a piece of software that helps consolidate
    and maintain the data (other than in Excel spreadsheets):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下这些团队如何处理这种类型的数据以进行日常活动，并简要讨论一个帮助整合和维护数据的软件实现（除了 Excel 电子表格之外）：
- en: 'First, we need to import Python''s standard `copy` module, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入Python的标准`copy`模块，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the heart of this system, we will have a `Website` class for holding all
    the useful information such as the name, the domain name, the description, and
    the author of a website we are managing.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个系统的核心，我们将有一个`Website`类来存储所有有用的信息，例如我们管理的网站的名称、域名、描述和作者。
- en: In the `__init__()` method of the class, only some parameters are fixed, `name`,
    `domain`, `description`, and `author`, which correspond to the information we
    listed previously. But we also want flexibility, and client code can pass more
    parameters in the form of keywords (`name=value`) using the `kwargs` variable-length
    collection (a Python dictionary).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的`__init__()`方法中，只有一些参数是固定的，`name`、`domain`、`description`和`author`，它们对应于我们之前列出的信息。但我们还希望有灵活性，客户端代码可以使用`kwargs`变量长度集合（一个Python字典）以`name=value`的形式传递更多参数。
- en: 'Note that there is a Python idiom to set an arbitrary attribute named `attr`
    with a value, `val`, on an object, `obj`, using the `setattr()` built-in function:
    `setattr(obj, attr, val)`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一个Python惯用法，可以使用内置的`setattr()`函数在对象`obj`上设置任意属性名`attr`和值`val`：`setattr(obj,
    attr, val)`。
- en: 'So, we are using this technique for the optional attributes of our class, at
    the end of the initialization method, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这个类的可选属性中使用这种技术，在初始化方法的末尾，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, our `Website` class is defined as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Website`类定义如下：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, the `Prototype` class implements the prototype design pattern.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`Prototype`类实现了原型设计模式。
- en: At the heart of the `Prototype` class is the `clone()` method, which is in charge
    of cloning the object using the `copy.deepcopy()` function. Since cloning means
    we allow values to be set for optional attributes, notice how we use the `setattr()`
    technique here with the `attrs` dictionary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prototype`类的核心是`clone()`方法，它负责使用`copy.deepcopy()`函数克隆对象。由于克隆意味着我们允许为可选属性设置值，请注意我们在这里如何使用`setattr()`技术以及`attrs`字典。'
- en: 'Also, for more convenience, the `Prototype` class contains the `register()`
    and `unregister()` methods, which can be used to keep track of the cloned objects
    in a dictionary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了方便起见，`Prototype`类包含`register()`和`unregister()`方法，这些方法可以用来在字典中跟踪克隆的对象：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `main()` function, as shown in the following code, we can clone a first
    `Website` instance, `site1`, to get a second object, `site2`. Basically, we instantiate
    the `Prototype` class and we use its `.clone()` method. That is what the following
    code shows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，如下面的代码所示，我们可以克隆一个`Website`实例，`site1`，以获取第二个对象，`site2`。基本上，我们实例化`Prototype`类，并使用其`.clone()`方法。这正是下面代码所展示的：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To end that function, we can use the `id()` function, which returns the memory
    address of an object, for comparing both objects'' addresses, as follows. When
    we clone an object using a deep copy, the memory addresses of the clone must be
    different from the memory addresses of the original object:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了结束该函数，我们可以使用`id()`函数，该函数返回对象的内存地址，以比较两个对象的地址，如下所示。当我们使用深拷贝克隆对象时，克隆的内存地址必须与原始对象的内存地址不同：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will find the program''s full code in the `prototype.py` file. Here is
    a summary of what we do in the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`prototype.py`文件中找到程序的完整代码。以下是我们在代码中执行的操作的摘要：
- en: We start by importing the `copy` module.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`copy`模块。
- en: We define the `Website` class, with its initialization method, `(__init__())`,
    and its string representation method `(__str__()`), as shown earlier.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义`Website`类，包括其初始化方法`(__init__())`和字符串表示方法`(__str__()`），如前面所示。
- en: We define our `Prototype` class as shown earlier.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义我们的`Prototype`类，如前面所示。
- en: 'Then, we have the `main()` function, where we do the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`main()`函数，其中我们执行以下操作：
- en: We define the `keywords` list we need.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义所需的`keywords`列表。
- en: We create the instance of the `Website` class, called `site1` (we use the `keywords`
    list here).
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`Website`类的实例，称为`site1`（我们在这里使用`keywords`列表）。
- en: We create the `Prototype` object and we use its `register()` method to register
    `site1` with its identifier (this helps us keep track of the cloned objects in
    a dictionary).
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`Prototype`对象，并使用其`register()`方法将`site1`及其标识符注册（这有助于我们在字典中跟踪克隆的对象）。
- en: We clone the `site1` object to get `site2`.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们克隆`site1`对象以获取`site2`。
- en: We display the result (both `Website` objects)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们显示结果（两个`Website`对象）
- en: 'Following is the sample output when I execute the `python prototype.py` command
    on my machine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在我的机器上执行`python prototype.py`命令时的示例输出：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Indeed, `Prototype` works as expected. We can see the information about the
    original `Website` object and its clone. Looking at the output of the `id()` function,
    we can see that the two addresses are different.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，`Prototype`按预期工作。我们可以看到原始`Website`对象及其克隆的信息。查看`id()`函数的输出，我们可以看到两个地址是不同的。
- en: With this program, we mark the end of our discussion on the prototype pattern.
    In the next section, we will cover the singleton pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个程序，我们结束了关于原型模式的讨论。在下一节中，我们将介绍单例模式。
- en: Implementing the singleton pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现单例模式
- en: The singleton pattern offers a way to implement a class from which you can only
    create one object, hence the name singleton. As you will understand with our exploration
    of this pattern, or while doing your own research, there have always been discussions
    about this pattern, and some even consider it an **anti-pattern**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式提供了一种实现类的方法，只能创建一个对象，因此得名单例。正如您将在我们对这个模式的探索中理解的那样，或者在进行您自己的研究时，关于这个模式的讨论始终存在，有些人甚至认为它是一个**反模式**。
- en: Besides that, what is interesting is that it is useful when we need to create
    one and only one object, for example, to store and maintain a global state for
    our program. In Python, this pattern can be implemented using some special built-in
    features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有趣的是，当我们需要创建一个且仅创建一个对象时，它是有用的，例如，为了存储和维护程序的全局状态。在Python中，可以使用一些特殊的内置功能来实现这个模式。
- en: The singleton pattern restricts the instantiation of a class to *one* object,
    which is useful when you need one object to coordinate actions for the system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式将类的实例化限制为*一个*对象，这在需要单个对象协调系统动作时非常有用。
- en: The basic idea is that only one instance of a particular class is created for
    the needs of the program. To ensure that this works, we need mechanisms that prevent
    the instantiation of the class more than once and also prevent cloning.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是为程序的需求创建特定类的一个实例。为了确保这一点，我们需要防止类被实例化多次的机制，同时也防止克隆。
- en: First, let's discuss some real-life examples of the singleton pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一些单例模式在现实生活中的例子。
- en: Real-world examples
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: We can think of a captain of a ship or a boat as a real-life example of the
    singleton pattern. On the ship, he is the one in charge. He is responsible for
    important decisions, and several requests are directed to him because of this
    responsibility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一艘船或一艘船的船长视为单例模式的一个现实生活例子。在船上，他是负责人。他负责重要的决策，由于这个责任，许多请求都指向他。
- en: In software, the Plone CMS has, at its core, an implementation of the singleton.
    There are actually several singleton objects available at the root of a Plone
    site, called `singleton` class, and you can't create another instance of that
    `singleton` class in the context of the site.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，Plone CMS在其核心中实现了一个单例。实际上，在Plone站点的根目录下有几个单例对象可用，称为`singleton`类，您不能在站点上下文中创建该`singleton`类的另一个实例。
- en: Use cases
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'As stated previously, one use case of the singleton pattern is to create a
    single object that maintains the global state of your program. Other possible
    use cases are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单例模式的一个用例是创建一个维护程序全局状态的单一对象。其他可能的用例如下：
- en: Controlling concurrent access to a shared resource; for example, an object class
    that manages the connection to a database
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对共享资源的并发访问；例如，管理数据库连接的对象类
- en: A service or resource that is transversal in the sense that it can be accessed
    from different parts of the application or by different users and does its work;
    for example, the class at the core of the logging system or utility
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种在意义上跨越整个应用程序或由不同用户访问的服务或资源，并完成其工作；例如，日志系统或实用程序的核心类
- en: Implementation
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Let's implement a program to fetch content from web pages, inspired by the tutorial
    from Michael Ford ([https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html)).
    We have only taken the simple part since the focus is to illustrate our pattern
    more than it is to build a special web-scraping tool.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个程序，从网页中获取内容，灵感来源于Michael Ford的教程([https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html))。我们只取了简单部分，因为重点是说明我们的模式，而不是构建一个特殊的网络爬虫工具。
- en: We will use the `urllib` module to connect to web pages using their URLs; the
    core of the program would be the `URLFetcher` class, which takes care of doing
    the work via a `fetch()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`urllib`模块通过URL连接到网页；程序的核心将是`URLFetcher`类，它通过`fetch()`方法负责执行工作。
- en: 'We want to be able to track the list of web pages that were tracked, hence
    the use of the singleton pattern. We need a single object to maintain that global
    state:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够跟踪被跟踪的网页列表，因此使用了单例模式。我们需要一个单独的对象来维护这个全局状态：
- en: 'First, our naive version, inspired by the tutorial but modified to help us
    track the list of URLs that were fetched, would be as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的原始版本，受教程启发但进行了修改，以帮助我们跟踪已获取的URL列表，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As an exercise, add the usual `if __name__ == '__main__'` block with a few lines
    of code to call the `.fetch()` method on an instance of `URLFetcher`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为练习，添加一个通常的`if __name__ == '__main__'`块，其中包含几行代码来调用`URLFetcher`实例的`.fetch()`方法。
- en: But then, does our class implement a singleton? Here is a clue. To create a
    singleton, we need to make sure you can only create one instance of it. So, to
    see whether our class implements a singleton, we could use a trick that consists
    of comparing two instances using the `is` operator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们的类实现了单例模式吗？这里有一个线索。要创建一个单例，我们需要确保只能创建一个实例。因此，为了确定我们的类是否实现了单例模式，我们可以使用一个技巧，即使用`is`运算符比较两个实例。
- en: 'You may have guessed the second exercise. Put the following code in your `if
    __name__ == ''__main__''` block instead of what you had previously:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了第二个练习。将以下代码放入你的`if __name__ == '__main__'`块中，而不是你之前所用的代码：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As an alternative, use this concise, but still elegant, form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，使用这个简洁但仍然优雅的形式：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this change, when executing the program, you should get `False` as the
    output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，当执行程序时，你应该得到`False`作为输出。
- en: Okay! This means that the first try does not yet give us a singleton. Remember,
    we want to manage a global state, using one, and only one, instance of the class
    for the program. The current version of the class does not yet implement a singleton.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧！这意味着第一次尝试还没有给我们一个单例。记住，我们想要管理一个全局状态，使用一个，并且只有一个类的实例来运行程序。当前版本的类还没有实现单例。
- en: After checking the literature and the forums on the web, you will find that
    there are several techniques, each with pros and cons, and some are probably outdated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了网络上的文献和论坛后，你会发现有几种技术，每种技术都有其优缺点，其中一些可能已经过时。
- en: 'Since many people use Python 3 nowadays, the recommended technique we will
    choose is the **metaclass** technique. We first implement a metaclass for the
    singleton. This class implements the singleton pattern as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在许多人使用Python 3，我们将选择推荐的**元类**技术。我们首先为单例实现一个元类。这个类如下实现了单例模式：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will rewrite our `URLFetcher` class to use that metaclass. We also
    add a `dump_url_registry()` method, which is useful for getting the current list
    of URLs tracked:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重写我们的`URLFetcher`类以使用该元类。我们还添加了一个`dump_url_registry()`方法，这对于获取当前跟踪的URL列表非常有用：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, you get `True` by executing the program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，通过执行程序，你得到`True`。
- en: 'Let''s complete the program to do what we wanted, using a `main()` function
    that we will call as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们完成程序，使用一个`main()`函数来完成我们想要的功能，如下所示调用：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will find the program''s full code in the `singleton.py` file. Here is
    a summary of what we do:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`singleton.py`文件中找到程序的完整代码。以下是我们所做的工作的摘要：
- en: We start with our required module imports (`urllib.parse` and `urllib.request`).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从所需的模块导入开始（`urllib.parse`和`urllib.request`）。
- en: As shown earlier, we define the `SingletonType` class, with its special `__call__()`
    method.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们定义了`SingletonType`类，它有一个特殊的`__call__()`方法。
- en: As shown earlier, we define `URLFetcher`, the class implementing the fetcher
    for the web pages, initializing it with the `urls` attribute. As discussed, we
    add its `fetch()` and `dump_url_registry()` methods.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们定义了`URLFetcher`类，该类实现了网页的获取器，通过`urls`属性进行初始化。如前所述，我们添加了它的`fetch()`和`dump_url_registry()`方法。
- en: Then, we add our `main()` function.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加我们的`main()`函数。
- en: Lastly, we add Python's conventional snippet used to call the `main` function.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加Python中用于调用`main`函数的传统代码片段。
- en: 'The following is the output when executing the `python singleton.py` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`python singleton.py`命令时的输出如下：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that we get the expected result: both the content of the pages that
    the program was able to connect to and the list of URLs the operation was successful
    for.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们得到了预期的结果：程序能够连接到的页面内容和操作成功的URL列表。
- en: We see that the URL, `https://www.python.org/error`, does not come in the list
    returned by `fetcher.dump_url_registry()`; indeed, it is an erroneous URL and
    the `urlllib` request to it gets a `404` response code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到URL `https://www.python.org/error` 并不在`fetcher.dump_url_registry()`返回的列表中；确实，这是一个错误的URL，对`urllib`的请求得到了`404`响应代码。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The link to the preceding URL is not supposed to work; that's exactly the point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个URL的链接不应该工作；这正是重点所在。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have seen how to use two other creational design patterns:
    the prototype and the singleton.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用两种其他创建型设计模式：原型和单例。
- en: A prototype is used to create exact copies of objects. As seen in the implementation
    example we discussed, using a prototype in Python is natural and based on built-in
    features, so it is not something even mentioned. The singleton pattern can be
    implemented by making the `singleton` class use a metaclass, its type, having
    previously defined said metaclass. As required, the metaclass's `__call__()` method
    holds the code that ensures that only one instance of the class can be created.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 原型用于创建对象的精确副本。正如我们在讨论的实现示例中所见，在Python中使用原型是自然的，并且基于内置功能，因此这不是什么需要提及的事情。单例模式可以通过使`singleton`类使用元类来实现，其类型已经预先定义了该元类。按照要求，元类的`__call__()`方法包含确保只能创建该类的一个实例的代码。
- en: Overall, these two design patterns help us implement the use cases that other
    creational patterns do not support; in effect, we have grown our design pattern
    toolbox to cover more use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这两种设计模式帮助我们实现了其他创建型模式不支持的使用案例；实际上，我们已经扩展了我们的设计模式工具箱，以覆盖更多的使用案例。
- en: The next chapter is about the adapter pattern, a structural design pattern that
    can be used to make two incompatible software interfaces compatible.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍适配器模式，这是一种结构型设计模式，可以用来使两个不兼容的软件接口兼容。
- en: Questions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the high-level benefits of using the prototype pattern?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原型模式的高层次好处是什么？
- en: How is the prototype pattern useful in the specific case of database management?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原型模式在数据库管理特定案例中有什么用途？
- en: What are the high-level benefits of using the singleton pattern?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单例模式的高层次好处是什么？
- en: In the context of concurrency, in which situation should the singleton pattern
    be used?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在并发的情况下，应该在什么情况下使用单例模式？
- en: Further reading
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns* by Gamma Enrich, Helm Richard, Johnson Ralph, and Vlissides
    John available at [https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 《*设计模式*》由Gamma Enrich，Helm Richard，Johnson Ralph和Vlissides John所著，可在[https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)找到。
