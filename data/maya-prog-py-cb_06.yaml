- en: Chapter 6. Making Things Move – Scripting for Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章.让事物移动 - 动画脚本编写
- en: 'This chapter will cover various recipes related to animating objects with scripting:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖与脚本动画化对象相关的各种配方：
- en: Querying animation data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询动画数据
- en: Working with animation layers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与动画层一起工作
- en: Copying animation from one object to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动画从一个对象复制到另一个对象
- en: Setting keyframes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置关键帧
- en: Creating expressions via script
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过脚本创建表达式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll be looking at how to use scripting to create animation
    and set **keyframes**. We'll also see how to work with animation layers and create
    expressions from code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用脚本创建动画和设置**关键帧**。我们还将了解如何与动画层一起工作并从代码中创建表达式。
- en: Querying animation data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询动画数据
- en: In this example, we'll be looking at how to retrieve information about animated
    objects, including which attributes are animated and both the location and value
    of keyframes. Although this script is unlikely to be useful by itself, knowing
    the number, time, and values of keyframes is sometimes a prerequisite for more
    complex animation tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将探讨如何检索有关动画对象的信息，包括哪些属性是动画化的以及关键帧的位置和值。尽管这个脚本本身可能没有太大用处，但了解关键帧的数量、时间和值有时是进行更复杂动画任务的先决条件。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make get the most out of this script, you'll need to have an object with
    some animation curves defined. Either load up a scene with animation or skip ahead
    to the recipe on setting keyframes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用这个脚本，你需要有一个定义了动画曲线的对象。要么加载一个带有动画的场景，要么跳转到设置关键帧的配方。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file and add the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you select an object with animation curves and run the script, you should
    see a readout of the time and value for each keyframe on each animated attribute.
    For example, if we had a simple bouncing ball animation with the following curves:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了一个具有动画曲线的对象并运行脚本，你应该会看到每个动画属性上每个关键帧的时间和值。例如，如果我们有一个简单的弹跳球动画，如下所示：
- en: '![How to do it...](img/4657_06_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4657_06_02.jpg)'
- en: 'We would see something like the following output in the script editor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本编辑器中可能会看到以下类似输出：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We start out by grabbing the selected object, as usual. Once we''ve done that,
    we''ll iterate over all the `keyframeable` attributes, determine if they have
    any keyframes and, if they do, run through the times and values. To get the list
    of `keyframeable` attributes, we use the `listAnimateable` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先像往常一样获取选定的对象。一旦我们完成了这个步骤，我们将遍历所有`keyframeable`属性，确定它们是否有任何关键帧，如果有，我们将遍历时间和值。要获取`keyframeable`属性的列表，我们使用`listAnimateable`命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will give us a list of all the attributes on the selected object that can
    be animated, including any custom attributes that have been added to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个列表，列出了所选对象上所有可以动画化的属性，包括添加到其中的任何自定义属性。
- en: 'If you were to print out the contents of the `animAttributes` array, you would
    likely see something like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出`animAttributes`数组的内容，你可能会看到以下类似的内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although the `bouncingBall.rotateX` part likely makes sense, you may be wondering
    about the `|` symbol. This symbol is used by Maya to indicate hierarchical relationships
    between nodes in order to provide fully qualified node and attribute names. If
    the `bouncingBall` object was a child of a group named `ballGroup`, we would see
    this instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`bouncingBall.rotateX`部分可能是有意义的，但你可能想知道`|`符号的含义。这个符号由Maya用来指示节点之间的层次关系，以便提供完全限定的节点和属性名称。如果`bouncingBall`对象是名为`ballGroup`的组的子对象，我们会看到以下内容：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Every such fully qualified name will contain at least one pipe (`|`) symbol,
    as we see in the first, nongrouped example, but there can be many more—one for
    each additional layer of hierarchy. While this can lead to long strings for attribute
    names, it allows Maya to make use of objects that may have the same name, but
    under different parts of a larger hierarchy (to have control objects named `handControl`
    for each hand of a character, for example).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的完全限定名称都将至少包含一个管道（`|`）符号，正如我们在第一个非分组示例中看到的那样，但可以有更多——每个额外的层次结构层都有一个。虽然这可能会导致属性名称变得很长，但它允许Maya利用可能具有相同名称但位于更大层次结构不同部分的对象（例如，为每个角色的每只手命名`handControl`控制对象）。
- en: Now that we have a list of all of the possibly animated attributes for the object,
    we'll next want to determine if there are any keyframes set on it. To do this,
    we can use the `keyframe` command in the query mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列出了该对象所有可能被动画化的属性，接下来我们想要确定是否有任何关键帧被设置在其上。为此，我们可以在查询模式中使用`keyframe`命令。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, we have a variable (`numKeyframes`) that will be greater than
    zero for any attribute with at least one keyframe. Getting the total number of
    keyframes on an attribute is only one of the things that the `keyframe` command
    can do; we'll also use it to grab the time and value for each of the keyframes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个变量（`numKeyframes`），对于至少有一个关键帧的任何属性，它都将大于零。获取一个属性上的关键帧总数只是`keyframe`命令能做的事情之一；我们还将用它来获取每个关键帧的时间和值。
- en: 'To do this, we''ll call it two more times, both in the query mode—once to get
    the times and once to get the values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将调用它两次，都是在查询模式下——一次获取时间，一次获取值：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These two lines are identical in everything except what type of information
    we're asking for. The important thing to note here is the index flag, which is
    used to tell Maya which keyframes we're interested in. The command requires a
    two-element argument representing the first (inclusive) and last (exclusive) index
    of keyframes to examine. So, if we had a total 20 keyframes, we would pass in
    (`0`,`20`), which would examine the keys with indices from 0 to 19.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行在所有方面都相同，只是我们请求的信息类型不同。这里需要注意的是索引标志，它用于告诉Maya我们感兴趣的是哪些关键帧。该命令需要一个表示要检查的关键帧的第一个（包含）和最后一个（不包含）索引的两个元素参数。所以，如果我们有总共20个关键帧，我们将传递（`0`,`20`），这将检查索引从0到19的键。
- en: The flags we're using to get the values likely look a bit odd—both `valueChange`
    and `timeChange` might lead you to believe that we would be getting relative values,
    rather than absolute. However, when used in the previously mentioned manner, the
    command will give us what we want—the actual time and value for each keyframe,
    as they appear in the graph editor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来获取值的标志可能看起来有点奇怪——`valueChange`和`timeChange`可能让你认为我们会得到相对值，而不是绝对值。然而，当以之前提到的方式使用时，该命令将给出我们想要的结果——每个关键帧的实际时间和值，正如它们在图表编辑器中显示的那样。
- en: If you want to query information on a single keyframe, you still have to pass
    in a pair of values—just use the index that you're interested in twice—to get
    the fourth frame, for example, use (`3`,`3`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查询单个关键帧的信息，你仍然需要输入一对值——只需将你感兴趣的索引重复两次即可。例如，要获取第四帧，使用（`3`,`3`）。
- en: 'At this point, we have two arrays—the `times` array, which contains the time
    value for each keyframe, and the `values` array that contains the actual attribute
    value. All that''s left is to print out the information that we''ve found:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个数组——`times`数组，它包含每个关键帧的时间值，以及`values`数组，它包含实际的属性值。剩下要做的就是打印出我们所找到的信息：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Using the indices to get data on keyframes is an easy way to run through all
    of the data for a curve, but it''s not the only way to specify a range. The `keyframe`
    command can also accept time values. If we wanted to know how many keyframes existed
    on a given attribute between frame 1 and frame 100, for example, we could do the
    following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引来获取关键帧的数据是一种轻松地遍历曲线所有数据的方法，但这不是指定范围的唯一方式。`keyframe`命令也可以接受时间值。例如，如果我们想知道在帧1和帧100之间给定属性上有多少关键帧，我们可以这样做：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, if you find yourself with highly nested objects and need to extract just
    the object and attribute names, you may find Python''s built-in split function
    helpful. You can call split on a string to have Python break it up into a list
    of parts. By default, Python will break up the input string by spaces, but you
    can specify a particular string or character to split on. Assume that you have
    a string like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你发现自己处理的是高度嵌套的对象，并且需要提取仅包含对象和属性名称，你可能发现Python内置的split函数很有帮助。你可以在一个字符串上调用split，让Python将其拆分成一个部分列表。默认情况下，Python会通过空格拆分输入字符串，但你也可以指定一个特定的字符串或字符来拆分。假设你有一个如下所示的字符串：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, you could use split to break it apart based on the `|` symbol. It would
    give you a list, and using `−1` as an index would give you just `ball.rotateZ`.
    Putting that into a function that can be used to extract the object/attribute
    names from a full string would be easy, and it would look something like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`split`根据`|`符号将其拆分。这将给你一个列表，使用`-1`作为索引将只得到`ball.rotateZ`。将其放入一个可以用于从完整字符串中提取对象/属性名称的函数中会很简单，它看起来可能如下所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using it would look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它看起来可能像这样：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Working with animation layers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理动画层
- en: Maya offers the ability to create multiple layers of animation in a scene, which
    can be a good way to build up complex animation. The layers can then be independently
    enabled or disabled, or blended together, granting the user a great deal of control
    over the end result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Maya 提供了在场景中创建多个动画层的功能，这可以是一个构建复杂动画的好方法。然后，这些层可以独立启用或禁用，或者混合在一起，使用户能够对最终结果有更多的控制。
- en: In this example, we'll be looking at how to examine the layers that exist in
    a scene, and building a script will ensure that we have a layer of a given name.
    For example, we might want to create a script that would add additional randomized
    motion to the rotations of selected objects without overriding their existing
    motion. To do this, we would want to make sure that we had an animation layer
    named `randomMotion`, which we could then add keyframes to.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看场景中存在的层，并构建一个脚本以确保我们有一个具有特定名称的层。例如，我们可能想要创建一个脚本，该脚本可以为所选对象的旋转添加额外的随机运动，而不会覆盖它们现有的运动。为此，我们需要确保我们有一个名为`randomMotion`的动画层，然后我们可以向其中添加关键帧。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the script, and you should see an animation layer named `myLayer` appear
    in the **Anim** tab of the channel box.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该会在通道框的**Anim**选项卡中看到名为`myLayer`的动画层。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing that we want to do is to find out if there is already an animation
    layer with the given name present in the scene. To do this, we start by grabbing
    the name of the root animation layer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是找出场景中是否已经存在具有给定名称的动画层。为此，我们首先获取根动画层的名称：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In almost all cases, this should return one of two possible values—either `BaseAnimation`
    or (if there aren't any animation layers yet) Python's built-in `None` value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，这应该返回两个可能值之一——要么是`BaseAnimation`，要么（如果还没有动画层）Python 内置的`None`值。
- en: 'We''ll want to create a new layer in either of the following two possible cases:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在以下两种可能的情况下创建一个新层：
- en: There are no animation layers yet
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前还没有动画层
- en: There are animation layers, but none with the target name
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有动画层，但没有目标名称的
- en: 'In order to make the testing for the above a bit easier, we first create a
    variable to hold whether or not we''ve found an animation layer and set it to
    `False`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述测试更容易一些，我们首先创建一个变量来保存是否找到了动画层，并将其设置为`False`：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to check to see whether it''s true that *both* animation layers
    exist and one of them has the given name. First off, we check that there was,
    in fact, a base animation layer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要检查是否确实存在两个动画层，并且其中一个具有给定的名称。首先，我们检查确实存在基础动画层：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If this is the case, we want to grab all the children of the base animation
    layer and check to see whether any of them have the name we''re looking for. To
    grab the children animation layers, we''ll use the `animLayer` command again,
    again in the query mode:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，我们想要获取基础动画层的所有子代，并检查其中是否有任何一个具有我们正在寻找的名称。为了获取子动画层，我们将再次使用`animLayer`命令，再次在查询模式下：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we''ve done that, we''ll want to see if any of the child layers match
    the one we''re looking for. We''ll also need to account for the possibility that
    there were no child layers (which could happen if animation layers were created
    then later deleted, leaving only the base layer):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做到了这一点，我们就会想看看是否有任何子层与我们要找的层匹配。我们还需要考虑到没有子层的情况（这可能发生在动画层被创建然后后来被删除，只留下基础层的情况下）：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If there were child layers and the name we're looking for was found, we set
    our `foundLayer` variable to `True`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在子层并且我们正在寻找的名称被找到，我们将我们的`foundLayer`变量设置为`True`。
- en: 'If the layer wasn''t found, we create it. This''s easily done by using the
    `animLayer` command one more time, with the name of the layer we''re trying to
    create:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到层，我们创建它。这可以通过再次使用 `animLayer` 命令并指定我们想要创建的层的名称来完成：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we finish off by printing a message, if the layer was found, to let
    the user know.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果找到了层，我们通过打印一条消息来结束，让用户知道。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Having animation layers is great, in that we can make use of them when creating
    or modifying keyframes. However, we can't actually add animation to layers without
    first adding the objects in question to the animation layer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有动画层是很好的，因为我们可以在创建或修改关键帧时使用它们。然而，实际上我们无法在不首先将相关对象添加到动画层的情况下向层添加动画。
- en: 'Let''s say that we had an object named `bouncingBall`, and we wanted to set
    some keyframes on its `translateY` attribute, in the `bounceLayer` animation layer.
    The actual command to set the keyframe(s) would look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `bouncingBall` 的对象，并且我们想在 `bounceLayer` 动画层上为其 `translateY` 属性设置一些关键帧。设置关键帧的实际命令可能看起来像这样：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, this would only work as expected if we had first added the `bouncingBall`
    object to the `bounceLayer` animation layer. To do it, we could use the `animLayer`
    command in the edit mode, with the `addSelectedObjects` flag. Note that because
    the flag operates on the currently selected objects, we would need to first select
    the object we want to add:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有在我们首先将 `bouncingBall` 对象添加到 `bounceLayer` 动画层的情况下，这才会按预期工作。为了做到这一点，我们可以在编辑模式下使用
    `animLayer` 命令，并带有 `addSelectedObjects` 标志。请注意，因为标志作用于当前选中的对象，我们首先需要选择我们想要添加的对象：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adding the object will, by default, add all of its animatable attributes. You
    can also add specific attributes, rather than entire objects. For example, if
    we only wanted to add the `translateY` attribute to our animation layer, we could
    do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，添加对象将添加其所有可动画属性。你也可以添加特定的属性，而不是整个对象。例如，如果我们只想将 `translateY` 属性添加到我们的动画层，我们可以这样做：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copying animation from one object to another
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个对象复制动画到另一个对象
- en: In this example, we'll create a script that will copy all of the animation data
    on one object to one or more additional objects, which could be useful to duplicate
    motion across a range of objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个脚本，该脚本将把一个对象的全部动画数据复制到另一个或多个附加对象上，这可以在多个对象上复制运动时很有用。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the script to work, you'll need an object with some keyframes set. Either
    create some simple animation or skip ahead to the example on creating keyframes
    with script, later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了脚本能够工作，你需要一个设置了关键帧的对象。你可以创建一些简单的动画，或者跳到本章后面的示例，关于如何使用脚本创建关键帧。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Select the animated object, shift-select at least one other object, and run
    the script. You'll see that all of the objects have the same motion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择动画对象，按住 shift 键选择至少另一个对象，然后运行脚本。你会看到所有对象都有相同的运动。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The very first part of our script is a helper function that we'll be using to
    strip the attribute name off a full object name/attribute name string. More on
    it will be given later.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的第一个部分是一个辅助函数，我们将使用它来从完整的对象名/属性名字符串中剥离属性名。更多关于它的内容将在稍后提供。
- en: 'Now on to the bulk of the script. First off, we run a check to make sure that
    the user has selected at least two objects. If not, we''ll display a friendly
    error message to let the user know what they need to do:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看脚本的主要内容。首先，我们运行一个检查以确保用户至少选择了两个对象。如果没有，我们将显示一个友好的错误消息，让用户知道他们需要做什么：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `error` command will also stop the script from running, so if we''re still
    going, we know that we had at least two objects selected. We''ll set the first
    one to be selected to be our source object. We could just as easily use the second-selected
    object, but that would mean using the first selected object as the destination,
    limiting us to a single target:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 命令也会停止脚本的运行，所以如果我们还在继续，我们知道我们至少选择了两个对象。我们将第一个选中的对象设置为源对象。我们同样可以使用第二个选中的对象，但那样就意味着将第一个选中的对象作为目标，限制我们只能有一个目标：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we''re ready to start copying animation, but first, we''ll need to determine
    which attributes are currently animated, through a combination of finding all
    the attributes that *can* be animated, and checking each one to see whether there
    are any keyframes on it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始复制动画，但首先，我们需要确定哪些属性目前正在动画化，这需要通过找到所有可以动画化的属性，并检查每个属性上是否有关键帧的组合来实现：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we have at least one keyframe for the given attribute, we move forward with
    the copying:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定属性至少有一个关键帧，我们将继续复制：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `copyKey` command will cause the keyframes for a given object to be temporarily
    held in memory. If used without any additional flags, it will grab all of the
    keyframes for the specified attribute, exactly what we want in this case. If we
    wanted only a subset of the keyframes, we could use the time flag to specify a
    range.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyKey`命令将导致给定对象的关键帧临时保存在内存中。如果没有使用任何附加标志，它将获取指定属性的 所有关键帧，这正是我们在这个情况下想要的。如果我们只想获取关键帧的子集，我们可以使用时间标志来指定一个范围。'
- en: We're passing in each of the values that were returned by the `listAnimatable`
    function. These will be full names (both object name and attribute). That's fine
    for the `copyKey` command, but will require a bit of additional work for the paste
    operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递由`listAnimatable`函数返回的每个值。这些将是完整名称（对象名称和属性）。这对于`copyKey`命令来说是可以的，但对于粘贴操作需要做一点额外的工作。
- en: 'Since we''re copying the keys onto a different object than the one that we
    copied them from, we''ll need to separate out the object and attribute names.
    For example, our `attribute` value might be something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将键复制到与原始复制源不同的对象上，我们需要将对象和属性名称分开。例如，我们的`attribute`值可能如下所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From this, we''ll want to trim off just the attribute name (`rotateX`) since
    we''re getting the object name from the selection list. To do this, we created
    a simple helper function that takes a full-length object/attribute name and returns
    just the attribute name. That''s easy enough to do by just breaking the name/attribute
    string apart on the `.` and returning the last element, which in this case is
    the attribute:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们想要剪掉属性名称（`rotateX`），因为我们是从选择列表中获取对象名称。为此，我们创建了一个简单的辅助函数，它接受完整的对象/属性名称并返回仅属性名称。这很简单，只需在`.`上拆分名称/属性字符串并返回最后一个元素即可，在这种情况下是属性：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Python's `split` function breaks apart the string into an array of strings,
    and using a negative index will count back from the end, with `−1` giving us the
    last element.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`split`函数将字符串拆分为字符串数组，使用负索引将从末尾开始计数，其中`−1`给我们最后一个元素。
- en: 'Now we can actually paste our keys. We''ll run through all the remaining selected
    objects, starting with the second, and paste our copied keyframes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上可以粘贴我们的键了。我们将遍历所有剩余的选定对象，从第二个开始，粘贴我们的复制关键帧：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we're using the nature of Python's for loops to make the code a bit
    more readable. Rather than using an index, as would be the case in most other
    languages, we can just use the `for x in y` construction. In this case, `obj`
    will be a temporary variable, scoped to the for loop, that takes on the value
    of each item in the list. Also note that instead of passing in the entire list,
    we use `objs[1:]` to indicate the entire list, starting at index `1` (the second
    element). The colon allows us to specify a subrange of the `objs` list, and leaving
    the right-hand side blank will cause Python to include all the items to the end
    of the list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们利用Python的for循环的特性使代码更易于阅读。与其他大多数语言不同，我们不需要使用索引，而是可以使用`for x in y`结构。在这种情况下，`obj`将是一个临时变量，作用域限于for循环，它将取列表中每个项目的值。此外，我们不是传递整个列表，而是使用`objs[1:]`来表示整个列表，从索引`1`（第二个元素）开始。冒号允许我们指定`objs`列表的子范围，而将右手边留空将导致Python包含列表末尾的所有项目。
- en: We pass in the name of the object (from our original selection), the attribute
    (stripped from full name/attribute string via our helper function), and we use
    `option="replace"` to ensure that the keyframes we're pasting in replace anything
    that's already there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递对象名称（来自原始选择），属性（通过我们的辅助函数从完整名称/属性字符串中剥离），并使用`option="replace"`来确保我们粘贴的关键帧将替换掉任何已经存在的内容。
- en: '![How it works...](img/4657_06_01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4657_06_01.jpg)'
- en: Original animation (top). Here, we see the result of pasting keys with the default
    settings (left) and with the replace option (right). Note that the default results
    still contain the original curves, just pushed to later frames
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原始动画（顶部）。在这里，我们看到使用默认设置粘贴键的结果（左侧）和使用替换选项的结果（右侧）。请注意，默认结果仍然包含原始曲线，只是被推到了后面的帧。
- en: If we didn't include the `option` flag, Maya would default to inserting the
    pasted keyframes while moving any keyframes already present forward in the timeline.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有包含`option`标志，Maya将默认在时间轴上移动任何现有键的同时插入粘贴的关键帧。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a lot of other options for the option flag, each of which handles
    possible conflicts with the keys you're pasting and the ones that may already
    exist in a slightly different way. Be sure to have a look at the built-in documentation
    for the `pasteKeys` command for more information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选项标志有很多其他选项，每个选项都以不同的方式处理与您粘贴的键以及可能已经存在的键的潜在冲突。请务必查看`pasteKeys`命令的内置文档以获取更多信息。
- en: 'Another, and perhaps better option to control how pasted keys interact with
    existing one is to paste the new keys into a separate animation layer. For example,
    if we wanted to make sure that our pasted keys end up in an animation layer named
    `extraAnimation`, we could modify the call to `pasteKeys` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个，也许更好的选项来控制粘贴的键如何与现有的键交互，是将新键粘贴到单独的动画层中。例如，如果我们想确保粘贴的键最终出现在名为`extraAnimation`的动画层中，我们可以按如下方式修改对`pasteKeys`的调用：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that if there was no animation layer named `extraAnimation` present, Maya
    would fail to copy the keys. See the section on working with animation layers
    for more information on how to query existing layers and create new ones.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有名为`extraAnimation`的动画层，Maya将无法复制键。请参阅有关如何查询现有层和创建新层的动画层部分以获取更多信息。
- en: Setting keyframes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置关键帧
- en: While there are certainly a variety of ways to get things to move in Maya, the
    vast majority of motion is driven by keyframes. In this example, we'll be looking
    at how to create keyframes with code by making that old animation standby—a bouncing
    ball.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Maya中确实有各种方法可以使物体移动，但绝大多数运动都是由关键帧驱动的。在这个例子中，我们将探讨如何通过编写代码来创建关键帧，即那个老式的动画备用方案——弹跳球。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The script we'll be creating will animate the currently selected object, so
    make sure that you have an object—either the traditional sphere or something else
    you'd like to make bounce.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的脚本将动画化当前选定的对象，所以请确保你有一个对象——无论是传统的球体还是你想要使其弹跳的其他东西。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the preceding script with an object selected and trigger playback. You should
    see the object move up and down.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在选定了对象后运行前面的脚本并触发播放。你应该看到对象上下移动。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to get our object to bounce, we'll need to set keyframes such that
    the object alternates between a *Y*-value of zero and an ever-decreasing maximum
    so that the animation mimics the way a falling object loses velocity with each
    bounce. We'll also make it move forward along the x-axis as it bounces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的对象弹跳，我们需要设置关键帧，使对象在零的*Y*值和不断减少的最大值之间交替，这样动画就能模仿一个下落物体在每次弹跳时失去速度的方式。我们还将使其在弹跳时沿x轴移动。
- en: We start by grabbing the currently selected object and setting a few variables
    to make things easier to read as we run through our loop. Our `yVal` and `xVal`
    variables will hold the current value that we want to set the position of the
    object to. We also have a frame variable to hold the current frame and a `maxVal`
    variable, which will be used to hold the *Y*-value of the object's current height.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取当前选定的对象，并设置一些变量以使我们在循环中更容易阅读。我们的`yVal`和`xVal`变量将保存我们想要设置对象位置的当前值。我们还有一个`frame`变量来保存当前帧，以及一个`maxVal`变量，它将用于保存对象当前高度的*Y*值。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is sufficiently simple that we don't really need separate variables
    for frame and the attribute values, but setting things up this way makes it easier
    to swap in more complex math or logic to control where keyframes get set and to
    what value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子足够简单，我们实际上不需要为帧和属性值设置单独的变量，但以这种方式设置可以使交换更复杂的数学或逻辑更容易，以控制关键帧的设置位置及其值。
- en: 'This gives us the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The bulk of the script is a single loop, in which we set keyframes on both the
    *X* and *Y* positions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的大部分是一个单独的循环，在这个循环中，我们在`X`和`Y`位置上设置关键帧。
- en: For the `xVal` variable, we'll just be multiplying a constant value (in this
    case, 2 units). We'll do the same thing for our frame. For the `yVal` variable,
    we'll want to alternate between an ever-decreasing value (for the successive peaks)
    and zero (for when the ball hits the ground).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`xVal`变量，我们只需将一个常数值（在这种情况下，2个单位）相乘。对于我们的框架，我们也将做同样的事情。对于`yVal`变量，我们希望交替使用一个不断减少的值（对于连续的峰值）和零（当球击中地面时）。
- en: To alternate between zero and non-zero, we'll check to see whether our loop
    variable is divisible by two. One easy way to do this is to take the value *modulo*
    (`%`) 2\. This will give us the remainder when the value is divided by two, which
    will be zero in the case of even numbers and one in the case of odd numbers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在零和非零之间交替，我们需要检查我们的循环变量是否可以被2整除。一种简单的方法是取值`modulo`（`%`）2。这将给出当值被2除时的余数，对于偶数将是零，对于奇数将是1。
- en: For odd values, we'll set `yVal` to zero, and for even ones, we'll set it to
    `maxVal`. To make sure that the ball bounces a little less each time, we set `maxVal`
    to 80% of its current value each time we make use of it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于奇数，我们将`yVal`设置为零，对于偶数，我们将它设置为`maxVal`。为了确保球每次弹跳时都会少一点，我们每次使用`maxVal`时都将其设置为当前值的80%。
- en: 'Putting all of that together gives us the following loop:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下循环：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we''re finally ready to actually set keyframes on our object. This is easily
    done with the `setKeyframe` command. We''ll need to specify the following three
    things:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好实际上在我们的对象上设置关键帧了。这可以通过`setKeyframe`命令轻松完成。我们需要指定以下三件事：
- en: The attribute to keyframe (object name and attribute)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键帧的属性（对象名称和属性）
- en: The time at which to set the keyframe
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置关键帧的时间
- en: The actual value to set the attribute to
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置属性的实际值
- en: 'In this case, this ends up looking like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这最终看起来如下所示：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that's it! A proper bouncing ball (or other object) animated with pure code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一个通过纯代码动画化的正确弹跳球（或其他对象）。
- en: There's more...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: By default, the `setKeyframe` command will create keyframes with both in tangent
    and out tangent being set to spline. That's fine for a lot of things, but will
    result in overly smooth animation for something that's supposed to be striking
    a hard surface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`setKeyframe`命令将创建具有内切线和外切线都设置为样条的键帧。这对于很多事情来说都很好，但对于应该击中硬表面的东西来说，会导致过度平滑的动画。
- en: We can improve our bounce animation by keeping smooth tangents for the keyframes
    when the object reaches its maximum height, but setting the tangents at its minimum
    to be linear. This will give us a nice sharp change every time the ball strikes
    the ground.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过保持关键帧在对象达到最大高度时的平滑切线，但在最小值时设置为线性，来改进我们的弹跳动画。这将每次球击中地面时给我们一个很好的尖锐变化。
- en: 'To do this, all we need to do is to set both the `inTangentType` and `outTangentType`
    flags to `linear`, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要将`inTangentType`和`outTangentType`标志都设置为`linear`，如下所示：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To make sure that we only have linear tangents when the ball hits the ground,
    we could set up a variable to hold the tangent type, and set it to one of two
    values in much the same way that we set the `yVal` variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保当球击中地面时我们只有线性切线，我们可以设置一个变量来保存切线类型，并以与设置`yVal`变量相同的方式将其设置为两个值之一。
- en: 'This would end up looking like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最终看起来像这样：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating expressions via script
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过脚本创建表达式
- en: While most animation in Maya is created manually, it can often be useful to
    drive attributes directly via script, especially for mechanical objects or background
    items. One way to approach this is through Maya's expression editor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数Maya动画都是手动创建的，但直接通过脚本驱动属性通常很有用，特别是对于机械对象或背景项目。一种方法是使用Maya的表达式编辑器。
- en: In addition to creating expressions via the expression editor, it is also possible
    to create expressions with scripting, in a beautiful example of code-driven code.
    In this example, we'll be creating a script that can be used to create a sine
    wave-based expression to smoothly alter a given attribute between two values.
    Note that expressions cannot actually use Python code directly; they require the
    code to be written in the MEL syntax. But this doesn't mean that we can't use
    Python to *create* expressions, which is what we'll do in this example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过表达式编辑器创建表达式外，还可以通过脚本创建表达式，这是一个代码驱动的代码的美丽示例。在这个例子中，我们将创建一个脚本，可以用来创建一个基于正弦波的表达式，以平滑地改变给定属性在两个值之间的变化。请注意，表达式实际上不能直接使用
    Python 代码；它们需要代码以 MEL 语法编写。但这并不意味着我们不能使用 Python 来 *创建* 表达式，这正是我们将在这个例子中做的。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we dive into the script, we'll first need to have a good handle on the
    kind of expression we'll be creating. There are a lot of different ways to approach
    expressions, but in this instance, we'll keep things relatively simple and tie
    the attribute to a sine wave based on the current time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究脚本之前，我们首先需要很好地掌握我们将要创建的表达式的类型。有很多人不同的方法可以处理表达式，但在这个例子中，我们将保持相对简单，并将属性与基于当前时间的正弦波相关联。
- en: Why a sine wave? Sine waves are great because they alter smoothly between two
    values, with a nice easing into and out of both the minimum and maximums. While
    the minimum and maximum values range from −1 to 1, it's easy enough to alter the
    output to move between any two numbers we want. We'll also make things a bit more
    flexible by setting up the expression to rely on a custom `speed` attribute that
    can be used to control the rate at which the attribute animates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是正弦波？正弦波很棒，因为它们在两个值之间平滑变化，并且能够很好地从最小值和最大值中平滑过渡。虽然最小值和最大值的范围从 -1 到 1，但足以改变输出，使其在任意两个我们想要的数字之间移动。我们还将通过设置表达式依赖于一个自定义的
    `speed` 属性来使事情更加灵活，该属性可以用来控制属性动画的速度。
- en: The end result will be a value that varies smoothly between any two numbers
    at a user-specified (and keyframeable) rate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将是一个值，它在用户指定的（并且可关键帧化的）速率下在任意两个数字之间平滑变化。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script and add the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first that we do is to add a `speed` attribute to our object, as in the
    custom attribute recipe in [Chapter 5](ch05.html "Chapter 5. Adding Controls –
    Scripting for Rigging"), *Adding Controls – Scripting for Rigging*. We''ll be
    sure to make it keyable for later animation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为我们的对象添加一个 `speed` 属性，就像在 [第 5 章](ch05.html "第 5 章。添加控件 - 布尔脚本") 的自定义属性配方中一样，*添加控件
    - 布尔脚本*。我们将确保它可关键帧化，以便稍后动画：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It's generally a good idea to include at least one keyframeable attribute when
    creating expressions. While math-driven animation is certainly a powerful technique,
    you'll likely still want to be able to alter the specifics. Giving yourself one
    or more keyframeable attributes is an easy way to do just that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建表达式时，通常至少包含一个可关键帧化的属性是一个好主意。虽然数学驱动的动画确实是一种强大的技术，但你可能仍然希望能够改变具体的细节。给自己一个或多个可关键帧化的属性是做到这一点的简单方法。
- en: 'Now we''re ready to build up our expression. But first, we''ll need to understand
    exactly what we want; in this case, a value that smoothly varies between two extremes,
    with the ability to control its speed. We can easily build an expression to do
    that using the sine function, with the current time as the input. Here''s what
    it looks like in a general form:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建我们的表达式。但首先，我们需要确切地了解我们想要什么；在这种情况下，一个在两个极端之间平滑变化的值，并且能够控制其速度。我们可以很容易地使用正弦函数构建一个表达式来实现这一点，以当前时间为输入。以下是一般形式的样子：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Where:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：
- en: '`S` is a value that will either speed up (if greater than 1) or slow down (if
    less) the rate at which the input to the sine function changes'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S` 是一个值，它将加快（如果大于 1）或减慢（如果小于 1）正弦函数输入的变化速率。'
- en: '`M` is a multiplier to alter the overall range through which the value changes'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M` 是一个乘数，用于改变值变化的整体范围'
- en: '`O` is an offset to ensure that the minimum and maximum values are correct'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O` 是一个偏移量，以确保最小值和最大值正确。'
- en: You can also think about it visually—`S` will cause our wave to stretch or shrink
    along the horizontal (time) axis, `M` will expand or contract it vertically, and
    `O` will move the entire shape of the curve either up or down.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从视觉上考虑——`S` 将使我们的波形在水平（时间）轴上拉伸或收缩，`M` 将使其垂直扩展或收缩，而 `O` 将将整个曲线的形状向上或向下移动。
- en: '`S` is already taken care of; it''s our newly created "speed" attribute. `M`
    and `O` will need to be calculated, based on the fact that sine functions always
    produce values ranging from `−1` to `1`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`S` 已经处理好了；它是我们新创建的“速度”属性。`M`和`O`需要根据正弦函数总是产生从`−1`到`1`的值来计算。'
- en: 'The overall range of values should be from our `minVal` to our `maxVal`, so
    you might think that `M` should be equal to *(maxVal – minVal)*. However, since
    it gets applied to both `−1` and `1`, this would leave us with double the desired
    change. So, the final value we want is instead *(maxVal – minVal)/2*. We store
    that into our amplitude variable as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 值的范围整体应该从我们的`minVal`到`maxVal`，所以你可能认为`M`应该等于*(maxVal – minVal)*。然而，由于它应用于`−1`和`1`，这将使我们得到两倍于期望的变化。因此，我们想要的最终值是*(maxVal
    – minVal)/2*。我们将其存储到我们的振幅变量中，如下所示：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next up is the offset value `O`. We want to move our graph such that the minimum
    and maximum values are where they should be. It might seem like that would mean
    just adding our `minVal`, but if we left it at that, our output would dip below
    the minimum for 50% of the time (anytime the sine function is producing negative
    output). To fix it, we set `O` to *(minVal + M)* or in the case of our script:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是偏移值`O`。我们希望移动我们的图表，使得最小值和最大值位于它们应该的位置。这似乎意味着只需添加`minVal`，但如果我们这样做，我们的输出将有一半的时间低于最小值（任何正弦函数产生负输出的时刻）。为了解决这个问题，我们将`O`设置为*(minVal
    + M)*，或者在我们的脚本中：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way, we move the `0` position of the wave to be midway between our `minVal`
    and `maxVal`, which is exactly what we want.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将波的`0`位置移动到`minVal`和`maxVal`之间，这正是我们想要的。
- en: To make things clearer, let's look at the different parts we're tacking onto
    `sin()`, and the way they effect the minimum and maximum values the expression
    will output. We'll assume that the end result we're looking for is a range from
    `0` to `4`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地展示，让我们看看我们附加到`sin()`的不同部分，以及它们如何影响表达式输出的最小值和最大值。我们假设我们想要的最终结果是`0`到`4`的范围。
- en: '| Expression | Additional component | Minimum | Maximum |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 额外组件 | 最小值 | 最大值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *sin(time)* | None- raw sin function | −1 | 1 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| *sin(time)* | None- 原始正弦函数 | −1 | 1 |'
- en: '| *sin(time * speed)* | Multiply input by "speed" | −1 (faster) | 1 (faster)
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| *sin(time * speed)* | 将输入乘以“速度” | −1 (更快) | 1 (更快) |'
- en: '| *sin(time * speed) * 2* | Multiply output by 2 | −2 | 2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| *sin(time * speed) * 2* | 将输出乘以2 | −2 | 2 |'
- en: '| *(sin(time * speed) * 2) + 2* | Add 2 to output | 0 | 4 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| *(sin(time * speed) * 2) + 2* | 向输出添加2 | 0 | 4 |'
- en: Note that *2 = (4-0)/2* and *2 = 0 + 2*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*2 = (4-0)/2* 和 *2 = 0 + 2*。
- en: 'Here''s what the preceding progression looks like when graphed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当绘制时前面进展的样子：
- en: '![How it works...](img/4657_06_03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4657_06_03.jpg)'
- en: Four steps in building up an expression to var an attribute from 0 to 4 with
    a sine function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正弦函数从0到4构建一个表达式的四个步骤。
- en: 'Okay, now that we have the math locked down, we''re ready to translate that
    into Maya''s expression syntax. If we wanted an object named `myBall` to animate
    along *Y* with the previous values, we would want to end up with:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经确定了数学关系，我们准备将其转换为Maya的表达式语法。如果我们想让名为`myBall`的对象使用前面的值沿*Y*轴动画，我们希望最终得到：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This would work as expected if entered into Maya''s expression editor, but
    we want to make sure that we have a more general-purpose solution that can be
    used with any object and any values. That''s straightforward enough and just requires
    building up the preceding string from various literals and variables, which is
    what we do in the next few lines:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其输入Maya的表达式编辑器，这将按预期工作，但我们想确保我们有一个更通用的解决方案，可以用于任何对象和任何值。这很简单，只需要从各种字面量和变量中构建前面的字符串，这正是我们在接下来的几行中做的：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I've broken up the string creation into a few different lines to make things
    clearer, but it's by no means necessary. The key idea here is that we're switching
    back and forth between literals (`sin(time *`, `.speed`, and so on) and variables
    (`obj`, `att`, `amplitude`, and `offset`) to build the overall string. Note that
    we have to wrap numbers in the `str()` function to keep Python from complaining
    when we combine them with strings.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我将字符串创建拆分成几行，以便更清晰地展示，但这并不是必需的。这里的关键思想是我们在这几个方面来回切换：字面量（`sin(time *`, `.speed`
    等）和变量（`obj`, `att`, `amplitude`, 和 `offset`），以构建整个字符串。注意，我们必须在`str()`函数中包裹数字，以防止Python在将它们与字符串组合时发出抱怨。
- en: 'At this point, we have our expression string ready to go. All that''s left
    is to actually add it to the scene as an expression, which is easily done with
    the `expression` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好了我们的表达式字符串。剩下的只是将其作为表达式实际添加到场景中，这可以通过`expression`命令轻松完成：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And that's it! We will now have an attribute that varies smoothly between any
    two values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在将有一个在任意两个值之间平滑变化的属性。
- en: There's more...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are tons of other ways to use expressions to drive animation, and all
    sorts of simple mathematical tricks that can be employed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法可以使用表达式来驱动动画，以及各种可以采用的简单数学技巧。
- en: 'For example, you can easily get a value to move smoothly to a target value
    with a nice easing-in to the target by running this every frame:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过每帧运行此操作来轻松地将值平滑地移动到目标值，并获得对目标的良好渐入效果：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will add 20% of the current difference between the target and the current
    value to the attribute, which will move it towards the target. Since the amount
    that is added is always a percentage of the current difference, the per-frame
    effect reduces as the value approaches the target, providing an ease-in effect.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将目标与当前值之间的当前差异的20%添加到属性中，这将使其向目标移动。由于添加的量始终是当前差异的百分比，因此当值接近目标时，每帧效果会减少，从而提供一种渐入效果。
- en: If we were to combine this with some code to randomly choose a new target value,
    we would end up with an easy way to, say, animate the heads of background characters
    to randomly look in different positions (maybe to provide a stadium crowd).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此与一些随机选择新目标值的代码相结合，我们就会得到一种简单的方法，例如，动画背景角色的头部随机朝向不同的位置（可能是为了提供体育场人群）。
- en: 'Assume that we had added custom attributes for `targetX`, `targetY`, and `targetZ`
    to our object that would end up looking something like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经为我们的对象添加了`targetX`、`targetY`和`targetZ`的自定义属性，最终看起来可能如下所示：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that we're using the modulo (`%`) operator to do something (setting the
    target) only when the frame is an even multiple of 20\. We're also using the current
    time as the seed value for the `rand()` function to ensure that we get different
    results as the animation progresses.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用模数（`%`）运算符仅在帧是20的偶数倍时执行某些操作（设置目标）。我们还使用当前时间作为`rand()`函数的种子值，以确保在动画过程中获得不同的结果。
- en: The previously mentioned example is how the code would look if we entered it
    directly into Maya's expression editor; note the MEL-style (rather than Python)
    syntax. Generating this code via Python would be a bit more involved than our
    sine wave example, but would use all the same principles—building up a string
    from literals and variables, then passing that string to the `expression` command.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的示例是如果我们直接将其输入到Maya的表达式编辑器中，代码会看起来像这样；注意MEL风格的语法（而不是Python）。通过Python生成此代码会比我们的正弦波示例复杂一些，但会使用所有相同的原则——从字面量和变量构建字符串，然后将该字符串传递给`expression`命令。
