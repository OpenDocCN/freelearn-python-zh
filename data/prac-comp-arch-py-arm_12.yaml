- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: A Closer Look at the ARM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解ARM
- en: We have already introduced the ARM processor. Now, we will look at it in a little
    more depth. The ARM family of processors is probably the best vehicle to teach
    computer architecture. In particular, it is very easy to learn because of its
    streamlined instruction set and simple register model compared to many other microprocessors.Moreover,
    the ARM has some very interesting features, such as predicated execution when
    an instruction can either be executed or ignored, depending on the processor status.
    The introduction of the Raspberry Pi in computer education could not have happened
    at a better time because it enables students to get hands-on experience of the
    remarkable ARM architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了ARM处理器。现在，我们将更深入地研究它。ARM处理器系列可能是教授计算机架构的最佳工具。特别是，由于它的指令集精简和与许多其他微处理器相比的简单寄存器模型，它非常容易学习。此外，ARM还有一些非常有趣的功能，例如，当一条指令可以根据处理器状态执行或忽略时，预测执行。计算机教育中引入树莓派恰逢其时，因为它使学生能够亲身体验引人注目的ARM架构。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Introduce the ARM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍ARM
- en: Describe its register set
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述其寄存器集
- en: Examine variations in add and subtract operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查加法和减法操作的变化
- en: Cover the ARM’s multiplication instruction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖ARM的乘法指令
- en: Introduce logical operations and shifting operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍逻辑操作和移位操作
- en: Explain flow control and the ARM’s conditional execution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释流程控制和ARM的条件执行
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Because this chapter is an extension of the previous chapter, no new hardware
    or software is required. All you need is Raspberry Pi, configured as a general-purpose
    computer. The only software needed is a text editor to create assembly language
    programs and the GCC assembler and loader.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这一章节是前一章的扩展，所以不需要新的硬件或软件。你只需要配置为通用计算机的树莓派。所需的唯一软件是一个文本编辑器来创建汇编语言程序，以及GCC汇编器和加载器。
- en: Introducing the ARM
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ARM
- en: The ARM processor family has been a remarkable success story, not least because
    so many other microprocessors became popular for a few years and then declined
    into obscurity (e.g., 6502, Cyrix 486, and Itanium). At the time of its release,
    the Motorola 68K was widely thought of as far more elegant and powerful than Intel’s
    8086\. Indeed, the 68K was a true 32-bit machine at a time when the 8086 was a
    16-bit machine. The 68K was adopted by Apple’s Mac, the Atari, and Amiga computers
    – all major players in the home computer market. How could Intel’s humble 8086
    possibly ever have competed? Well, IBM selected the 8086 family for its new personal
    computer and the rest is history. Motorola later dropped out of the semiconductor
    business.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ARM处理器系列是一个引人注目的成功故事，不仅仅是因为许多其他微处理器在几年内变得流行，然后又逐渐消失在人们的视野中（例如，6502、Cyrix 486和安腾）。在其发布时，摩托罗拉的68K被认为比英特尔8086更加优雅和强大。事实上，68K在8086还是16位机器的时候，就已经是一个真正的32位机器了。68K被苹果的Mac、雅达利和Amiga电脑所采用——它们都是家用电脑市场的主要玩家。那么英特尔的8086如何可能与之竞争呢？好吧，IBM选择了8086系列作为其新型个人电脑，其余的就是历史了。后来，摩托罗拉退出了半导体业务。
- en: In the late 1980s, a new company, Advanced RISC Machines, was founded to create
    high-performance microprocessors. The architecture of their machines followed
    the register-to-register paradigm of the RISC architecture, rather than Intel
    and Motorola’s more complicated CISC instruction sets. The ARM was born.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代末，一家名为Advanced RISC Machines的新公司成立，旨在创建高性能微处理器。它们的机器架构遵循RISC架构的寄存器到寄存器范式，而不是英特尔和摩托罗拉更复杂的CISC指令集。ARM应运而生。
- en: Not only has ARM survived when many of the earlier microprocessors failed –
    it has also prospered and successfully targeted the world of mobile devices, such
    as netbooks, tablets, and cell phones. ARM incorporates some interesting architectural
    features that have given it a competitive advantage over its rivals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ARM不仅在与许多早期微处理器失败时幸存下来，而且还繁荣发展，并成功地将目标对准了移动设备的世界，如上网本、平板电脑和手机。ARM集成了许多有趣的架构特性，使其在竞争对手中具有竞争优势。
- en: ARM is, in fact, a *fabless* company – that is, it develops the architecture
    of computers and allows other companies to manufacture those computers. The term
    *fabless* is derived from fab (short for fabrication).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，ARM是一家无晶圆厂公司——也就是说，它开发计算机架构，并允许其他公司制造这些计算机。术语“无晶圆厂”来源于“fab”（制造的首字母缩写）。
- en: Before we describe ARM’s instructions, we will discuss its register set because
    all ARM data-processing instructions operate on the contents of its registers
    (a prime feature of the RISC computer).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述 ARM 指令之前，我们将讨论其寄存器集，因为所有 ARM 数据处理指令都操作于其寄存器的内容（RISC 计算机的一个主要特性）。
- en: Because the ARM’s architecture has developed over the years, and because there
    are different versions of the ARM architecture in use, a teacher of it has a problem.
    Which version should be used to illustrate a computer architecture course? In
    this chapter, we will use the ARMv4 32-bit architecture, which has 32-bit instructions.
    Some ARM processors can switch between 32-bit and 16-bit instruction states (the
    16-bit state is called the *Thumb* state). The Thumb state is intended to run
    very compact code in embedded control systems. We will not cover the Thumb state
    here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ARM 的架构在多年中不断发展，并且因为正在使用不同版本的 ARM 架构，因此 ARM 的教师面临一个问题。应该使用哪个版本来展示计算机架构课程？在本章中，我们将使用具有
    32 位指令的 ARMv4 32 位架构。一些 ARM 处理器可以在 32 位和 16 位指令状态之间切换（16 位状态称为 *Thumb* 状态）。Thumb
    状态旨在在嵌入式控制系统中运行非常紧凑的代码。我们在这里不会介绍 Thumb 状态。
- en: The ARM found in Raspberry Pi 4 has a 64-bit architecture that is very different
    from earlier 32-bit ARMs. However, since the 32-bit ARM architecture is used in
    most teaching texts and Raspberry Pi 4 supports it, we will use the 32-bit architecture
    here. In order to be consistent with other books using the ARM to illustrate computer
    architecture, most of the material here is based on ARMv4T 32-bit architecture.
    ARM’s 32-bit architectures are now referred to by the term AArch32, distinguishing
    them from ARM’s new 64-bit architecture, AArch64.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 4 中的 ARM 拥有与早期 32 位 ARM 非常不同的 64 位架构。然而，由于 32 位 ARM 架构被大多数教学文本所采用，并且
    Raspberry Pi 4 支持 32 位架构，因此我们在这里将使用 32 位架构。为了与其他使用 ARM 来说明计算机架构的书籍保持一致，这里的大部分材料都是基于
    ARMv4T 32 位架构。ARM 的 32 位架构现在被称为 AArch32，以区别于 ARM 的新 64 位架构，AArch64。
- en: Overview of the ARM’s architecture
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM 架构概述
- en: The ARM’s architecture is interesting because it has elements of both the conventional
    CISC architecture such as Motorola’s 68K and Intel’s 32/64-bit architectures,
    together with the more radical streamlined RISC architecture of processors such
    as MIPS and RISC-V.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的架构很有趣，因为它结合了传统的 CISC 架构（如摩托罗拉的 68K 和英特尔 32/64 位架构）的元素，以及像 MIPS 和 RISC-V
    这样的处理器更激进的精简 RISC 架构。
- en: 'Here, we will examine the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检查以下内容：
- en: The ARM’s register set
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM 的寄存器集
- en: Arithmetic instructions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术指令
- en: Special addition and subtraction instructions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊加法和减法指令
- en: Multiplication and ARM’s multiplication and addition instruction
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法和 ARM 的乘法与加法指令
- en: Bitwise instruction
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位操作指令
- en: Shifting operations
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位操作
- en: We don’t cover data movement operations in detail here. We have already encountered
    the `mov` operation that can be used to load a literal into a register – for example,
    `mov r1,#12`. Similarly, the `str` and `ldr` instructions load a register from
    memory and store a register in memory, respectively. A typical example is `ldr
    r4,[r5]` and `str r0,[r9]`. These two instructions use *register indirect addressing*,
    and we will devote the next chapter to them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不详细覆盖数据移动操作。我们已经遇到了可以用来将立即数加载到寄存器的 `mov` 操作，例如，`mov r1,#12`。同样，`str` 和
    `ldr` 指令分别从内存中加载寄存器和将寄存器存储到内存中。一个典型的例子是 `ldr r4,[r5]` 和 `str r0,[r9]`。这两个指令使用
    *寄存器间接寻址*，我们将在下一章中详细介绍。
- en: Arm register set
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARM 寄存器集
- en: Unlike the popular MIPS processor with its 32 general-purpose registers, ARM
    has just 16 registers, `r0` to `r15`, and a *status register*. Remarkably, the
    ARM’s registers are not all the same – that is, some are special-purpose registers.
    *Figure 10**.1* illustrates the ARM’s register set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与拥有 32 个通用寄存器的流行 MIPS 处理器不同，ARM 只有 16 个寄存器，`r0` 到 `r15`，以及一个 *状态寄存器*。值得注意的是，ARM
    的寄存器并不完全相同——也就是说，有些是专用寄存器。*图 10**.1* 展示了 ARM 的寄存器集。
- en: '![Figure 10.1 – The ARM’s register set](img/Figure_10.01_B19624.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – ARM 的寄存器集](img/Figure_10.01_B19624.jpg)'
- en: Figure 10.1 – The ARM’s register set
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – ARM 的寄存器集
- en: Fourteen registers, `r0` to `r13`, are indeed general-purpose in the sense that
    they all behave in the same way – for example, anything you can do with `r5`,
    you can do with `r10`. Registers `r13`, `r14`, and `r15` are not general-purpose
    because they have additional functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 四个寄存器，`r0` 到 `r13`，在真正意义上是通用的，因为它们都以相同的方式工作——例如，你可以用 `r5` 做的事情，用 `r10` 也可以做。寄存器
    `r13`、`r14` 和 `r15` 不是通用的，因为它们有额外的功能。
- en: Strictly speaking, `r13` is a general-purpose register, but by convention, it’s
    reserved for use as a stack pointer. If you work on a project in a team, you should
    respect this convention. Otherwise, you do not have to follow the convention,
    and you can use `r13` in any way you wish.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`r13` 是一个通用寄存器，但按照惯例，它被保留用作堆栈指针。如果你在一个团队项目中工作，你应该遵守这个惯例。否则，你不必遵循这个惯例，你可以按你希望的方式使用
    `r13`。
- en: Register `r14` has an additional function imposed by the hardware. It is a *link
    register* and can be written `lr` or `r14` in assembly programs. The ARM has an
    instruction, branch with link (`bl)`, that lets you jump to a point in the program
    (i.e., a branch) and save the address of the next instruction in sequence in the
    link register. In other words, the instruction saves the next `pc` address in
    `r14` and then jumps to the specified target. Later, you can return by copying
    the address in the link register to the pc with `mov pc,lr` or `mov 15,r14`. This
    is a faster subroutine call and return mechanism than the conventional `bsr` and
    `rts` pair of instructions that use a stack to store the return address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 `r14` 由硬件强制赋予了一个额外的功能。它是一个 *链接寄存器*，在汇编程序中可以写作 `lr` 或 `r14`。ARM 有一个指令，带链接的分支
    (`bl`)，允许你跳转到程序中的某个点（即分支）并将后续指令的地址保存到链接寄存器中。换句话说，该指令将下一个 `pc` 地址保存到 `r14` 中，然后跳转到指定的目标。稍后，你可以通过将链接寄存器中的地址复制到
    `pc` 来返回，使用 `mov pc,lr` 或 `mov 15,r14`。这是一个比传统的使用堆栈存储返回地址的 `bsr` 和 `rts` 指令对更快的子程序调用和返回机制。
- en: Register `r15` is a truly different register from all the others and can never
    be used as a general-purpose register (even though you can apply some instructions
    to it as if it were general-purpose). Register `r15` is the *program counter*
    that contains the address of the next instruction to be executed and is normally
    written `pc` rather than `r15` in ARM code. Putting the program counter in a general
    register is very rare in the world of computer architecture. Note that, in practice,
    `pc` contains an address that is 8 bytes ahead of the current `pc` because of
    the way that the ARM is internally organized.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 `r15` 是一个真正与其他寄存器不同的寄存器，永远不能用作通用寄存器（即使你可以应用一些指令到它，就像它是通用寄存器一样）。寄存器 `r15`
    是 *程序计数器*，包含下一个要执行的指令的地址，在 ARM 代码中通常写作 `pc` 而不是 `r15`。在计算机体系结构的世界中，将程序计数器放入通用寄存器是非常罕见的。请注意，在实际中，由于
    ARM 内部的组织方式，`pc` 包含一个比当前 `pc` 高 8 字节的地址。
- en: We will look at the ARM’s data processing instructions first, rather than the
    data movement operations. We take this approach because data movement instructions
    are more complicated, since they involve complex addressing modes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看 ARM 的数据处理指令，而不是数据移动操作。我们采取这种方法是因为数据移动指令更复杂，因为它们涉及到复杂的寻址模式。
- en: Arithmetic instructions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术指令
- en: 'Let’s begin with ARM’s arithmetic instructions that perform operations on data
    representing *numeric quantities*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 ARM 的算术指令开始，这些指令对表示 *数值* 的数据进行操作：
- en: Addition          `add`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法          `add`
- en: Subtraction        `sub`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法        `sub`
- en: Comparison        `cmp` (technically, `compare` is not a data-processing operation)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较操作   `cmp`（技术上讲，“比较”不是一个数据处理操作）
- en: Multiplication        `mul`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法              `mul`
- en: Shifting            `lsl, lsr, asl, asr,` `ror, rrx`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位            `lsl, lsr, asl, asr,` `ror, rrx`
- en: Addition, subtraction, and comparison
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法、减法和比较
- en: Addition is a simple operation that adds two operands to generate a sum and
    a carryout. In decimal arithmetic, adding 4 + 5 gives 9\. Adding 4 + 9 gives 13
    ; that is, a result of 3 and a carry-out of 1\. Computers deal with this by storing
    the carryout in the carry bit. ARM instructions require you to add the suffix
    `s` if you wish to update condition code flags after an operation – that is, you
    need to write `add`s `r1,r2,r3`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 加法是一个简单的操作，它将两个操作数相加生成一个和和一个进位。在十进制算术中，4 + 5 得到 9。4 + 9 得到 13；也就是说，结果是 3，进位是
    1。计算机通过将进位存储在进位位中来处理这种情况。ARM 指令要求你在操作后更新条件码标志时添加后缀 `s`——也就是说，你需要写 `add`s `r1,r2,r3`。
- en: The ARM is a 32-bit machine. How do you add 64-bit numbers? Suppose that two
    64-bit numbers are `A` and `B`, where AL is the lower-order 32 bits of A, and
    AU is the upper-32 bits of `A`. Similarly, BL is the lower-order 32 bits of `B`,
    and BU is the upper-32 bits of `B`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ARM是一个32位机器。你如何加64位数字？假设有两个64位数字`A`和`B`，其中AL是`A`的低位32位，AU是`A`的高32位。同样，BL是`B`的低位32位，BU是`B`的高32位。
- en: 'We first add AL to BL and record the carry. Then we add together AU and BU,
    plus any carry generated from the addition of the lower-order pair. In ARM assembler
    language, this is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将AL加到BL上，并记录进位。然后我们将AU和BU相加，加上从低位对加法产生的任何进位。在ARM汇编语言中，这如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second addition, `adc`, means, *add with carry*, and adds any carry out
    from the previous addition. We’ve used CL, AL, BL, and so on, rather than `r1`,
    `r2`, and `r3` to demonstrate that these are upper- and lower-order parts of a
    number distributed between two registers. We can extend this principle to perform
    extended-precision arithmetic with integers of any length.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次加法操作`adc`意味着*带进位加法*，并添加前一次加法产生的任何进位。我们使用CL、AL、BL等，而不是`r1`、`r2`和`r3`来演示这些是分布在两个寄存器之间的数字的高位和低位部分。我们可以将这个原则扩展到执行任意长度的整数的扩展精度算术。
- en: The ARM also provides a simple subtract operation, `sub`, together with a `sbc`
    or *subtract with carry* instruction to support extended-precision subtraction,
    which operate like the corresponding `adc`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ARM还提供了一个简单的减法操作`sub`，以及一个`sbc`或*带进位减法*指令来支持扩展精度减法，它们的工作方式与相应的`adc`类似。
- en: As well as `sub` and `sbc`, the ARM has a *reverse* subtract operation, where
    `rsc` r1, `r2`, `r3` perform the subtraction of `r2` from `r3`. This instruction
    may seem strange and unnecessary because you can simply reverse the order of the
    second two registers, can’t you? However, ARM lacks a *negation* instruction that
    subtracts a number from zero ; for example, the negative of `r0` is `0 – [r0]`.
    The reverse subtraction operation can be used to do this because `rsb` r1`,r1,#0`
    is equivalent to `neg r1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '除了`sub`和`sbc`，ARM还有一条*反向减法*操作，其中`rsc r1, r2, r3`执行从`r3`减去`r2`的操作。这条指令可能看起来很奇怪且不必要，因为你完全可以简单地颠倒后两个寄存器的顺序，对吧？然而，ARM缺少一条*取反*指令，该指令从零减去一个数；例如，`r0`的负数是`0
    – [r0]`。反向减法操作可以用来完成这个任务，因为`rsb r1, r1, #0`等价于`neg r1`。'
- en: 'A comparison operation compares two values by subtracting one from the other
    – for example, we can compare 3 with 5\. Suppose the two elements being compared
    are `A` and `B`. If you perform `A` – `B` and the answer is zero, then `A` and
    `B` are equal. If the result is positive, `A > B`, and if it’s negative, `A <
    B`. A comparison is a subtraction where you don’t care about the result ; only
    its sign, whether it’s zero, whether a carry was generated. Consider the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作通过从另一个值中减去一个值来比较两个值——例如，我们可以比较3和5。假设正在比较的两个元素是`A`和`B`。如果你执行`A – B`，并且结果是零，那么`A`和`B`是相等的。如果结果是正数，则`A
    > B`，如果是负数，则`A < B`。比较是一种减法，你不在乎结果；只关心它的符号，是否为零，是否产生了进位。考虑以下情况：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The operation `cmp` r1,`r2` evaluates `[r1] – [r2]` and updates the `Z`, `C`,
    `N`, and `V` bits. We can then perform operations such as `beq next` that branch
    to label `next` if `r1` and `r2` are equal. We said that you need to append `s`
    to update condition codes. Comparison operations are exceptions because setting
    condition codes is what they do. You can write `cmps` if you want, since it’s
    the same as `cmp`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 操作`cmp r1, r2`评估`[r1] – [r2]`并更新`Z`、`C`、`N`和`V`位。然后我们可以执行如`beq next`之类的操作，如果`r1`和`r2`相等，则跳转到标签`next`。我们说过你需要追加`s`来更新条件码。比较操作是例外，因为设置条件码正是它们所做的事情。如果你想写`cmps`也可以，因为它和`cmp`是相同的。
- en: There are two types of integer comparison. Consider (in 8 bits) the `A = 00000001`
    and `B = 11111111` binary values. Which is the larger? You might think that it’s
    `B`, since `B = 255` and `A = 1`. That’s true. However, if these were assigned
    `2`s complement numbers, `A` would be `1` and `B` would be `-1`; therefore, `A`
    is the larger. Like all processors, ARM provides two sets of branch operations,
    one for unsigned arithmetic and one for signed arithmetic. A programmer must select
    the appropriate branch depending on whether they use signed or unsigned arithmetic.
    The simulators we constructed earlier all provided unsigned branches only.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种整数比较类型。考虑（在 8 位中）`A = 00000001` 和 `B = 11111111` 的二进制值。哪个更大？你可能认为它是 `B`，因为
    `B = 255` 而 `A = 1`。这是真的。然而，如果这些被分配为 `2`s 补码数，`A` 将是 `1` 而 `B` 将是 `-1`；因此，`A`
    是更大的。像所有处理器一样，ARM 提供了两套分支操作，一套用于无符号算术，一套用于有符号算术。程序员必须根据他们是否使用有符号或无符号算术来选择适当的分支。我们之前构建的模拟器都只提供了无符号分支。
- en: Multiplication
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法
- en: 'ARM’s multiply instruction, `mul` Rd`,Rm,Rs`, generates the low-order 32 bits
    of the 64-bit product `Rm` `x Rs`. When using `mul`, you should ensure that the
    result does not go out of range because multiplying two m-bit numbers yields a
    `2m`-bit product. This instruction doesn’t let you multiply the contents of a
    register by a constant – that is, you can’t perform `mul` r9`,r4,#14`. Moreover,
    you can’t use the *same* register to specify both the Rd destination and the `Rm`
    operand. These restrictions are due to the implementation of this instruction
    in hardware. The following code demonstrates the use of ARM’s multiplication to
    multiply 23 by 25:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的乘法指令 `mul` Rd`,Rm,Rs` 生成 64 位乘积 `Rm` `x Rs` 的低阶 32 位。当使用 `mul` 时，你应该确保结果不会超出范围，因为两个
    m 位数的乘积会产生一个 `2m`-位结果。此指令不允许你将寄存器的内容乘以一个常数——也就是说，你不能执行 `mul` r9`,r4,#14`。此外，你不能使用**相同的**寄存器来指定
    Rd 目的和 `Rm` 操作数。这些限制是由于该指令在硬件中的实现。以下代码演示了使用 ARM 的乘法来乘以 23 和 25：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve already seen that ARM has a *multiply and accumulate instruction*, `mla`,
    with a *four-operand* format `mla` Rd,`Rm`,`Rs`,`Rn`, whose RTL definition is
    `[Rd]` ← `[Rm]` x `[Rs] + [Rn]`. The 32-bit by 32-bit multiplication is truncated
    to the lower-order 32 bits. Like the multiplication, `Rd` must not be the same
    as `Rm` (although this restriction was removed in the ARMv6 and later architectures).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 ARM 有一个**乘累加指令**，`mla`，具有**四操作数**格式 `mla` Rd,`Rm`,`Rs`,`Rn`，其 RTL 定义为
    `[Rd]` ← `[Rm]` x `[Rs]` + `[Rn]`。32 位乘以 32 位的乘法被截断为低阶 32 位。像乘法一样，`Rd` 不能与 `Rm`
    相同（尽管在 ARMv6 及以后的架构中取消了此限制）。
- en: ARM’s *multiply and accumulate* instruction supports the calculation of an *inner-product*
    by performing one multiplication and addition per instruction. The inner-product
    is used in multimedia applications – for example, if vector a consists of the
    *n* components a1, a2, … an and vector b consists of the *n* components b1, b2,
    ... , bn, then the *inner product* of a and b is the scalar value s = **a·b**
    = a1·b1 + a2·b2 + … + an·bn.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的**乘累加**指令通过每条指令执行一次乘法和加法来支持**内积**的计算。内积用于多媒体应用——例如，如果向量 a 由 *n* 个组件 a1,
    a2, … an 组成，而向量 b 由 *n* 个组件 b1, b2, ... , bn 组成，那么 a 和 b 的**内积**是标量值 s = **a·b**
    = a1·b1 + a2·b2 + … + an·bn。
- en: 'We will now demonstrate an application of the multiply and accumulate operations.
    Although we have not yet covered the ARM’s addressing modes, the following example
    includes the instruction `ldr` r0`,[r5],#4` that loads register `r0` with an element
    from the array pointed at by register `r5`, and then it updates `r5` to point
    at the next element (4 bytes on):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将演示乘累加操作的用途。尽管我们还没有介绍 ARM 的寻址模式，但以下示例包括指令 `ldr r0`,[r5],#4`，该指令将寄存器 `r0`
    加载为数组中由寄存器 `r5` 指向的元素，然后更新 `r5` 以指向下一个元素（4 字节）：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What about division? The ARMv4 architecture lacks a division instruction as
    part of its basic architecture (some variants of ARM such as the ARMv7 architecture
    do incorporate division). If you wish to do division on the ARM, you have to write
    a short program that uses an iterative loop involving shifting and subtracting
    to perform the division (rather like pencil and paper long division).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于除法？ARMv4 架构作为其基本架构的一部分缺少除法指令（一些 ARM 的变体，如 ARMv7 架构，则包含除法指令）。如果你想在 ARM 上进行除法，你必须编写一个短程序，该程序使用涉及移位和减法的迭代循环来执行除法（类似于纸和笔的长除法）。
- en: Bitwise logical operations
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位运算逻辑
- en: The ARM provides the basic `AND`, `OR`, `NOT`, and `EOR` (exclusive or) bitwise
    logical operations supported by most processors. These are used to set, clear,
    and toggle the individual bits of a word, as we already saw when assembling instructions.
    There is also an unusual *bit clear* operation, `bic`, that `AND`s its first operand
    with the *complement of the corresponding bits* of its second operand – that is,
    ci = ai ∧ bi.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ARM提供了大多数处理器支持的`AND`、`OR`、`NOT`和`EOR`（异或）基本位逻辑操作。这些操作用于设置、清除和切换字中的单个位，就像我们在汇编指令时已经看到的那样。还有一个不寻常的*位清除*操作`bic`，它将第一个操作数与第二个操作数的*对应位的补码*进行`AND`操作——即ci
    = ai ∧ bi。
- en: The ARM’s NOT operation is written as `mvn` rd,rs. This move instruction negates,
    inverts the bits of the source register and copies them to the destination register.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的NOT操作写为`mvn rd, rs`。这个移动指令否定、反转源寄存器的位，并将它们复制到目标寄存器。
- en: 'The following examples illustrate logical operations on r1 = 110010102 and
    r0 = 000011112:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了在r1 = 11001010和r0 = 00001111上的逻辑操作：
- en: '| **Logical instruction** | **Operation** | **Final value** **in r2** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑指令** | **操作** | **r2中的最终值** |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `and` r2`,r1,r0` | 11001010 ∧ 00001111 | 00001010 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `and r2, r1, r0` | 11001010 ∧ 00001111 | 00001010 |'
- en: '| `or` r2`,r1,r0` | 11001010 + 00001111 | 11001111 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `or r2, r1, r0` | 11001010 + 00001111 | 11001111 |'
- en: '| `mvn` r2`,r1` | īōōīōīō￼ | 00110101 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `mvn r2, r1` | īōōīōīō | 00110101 |'
- en: '| `eor` r2`,r1,r0` | 11001010 ⊕ 00001111￼ | 11000101 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `eor r2, r1, r0` | 11001010 ⊕ 00001111 | 11000101 |'
- en: '| `bic` r2`,r1,r0` | 11001010 ∧ ōōōōīīīī | 11000000 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `bic r2, r1, r0` | 11001010 ∧ ōōōōīīīīī | 11000000 |'
- en: When you design instruction sets, one of the major tasks is to construct binary
    codes for instructions. These operations make it easy to implement the manipulation
    of bits. For example, suppose variable `sR1` specifies source register 1, and
    `sR2` specifies source register 2, and we have to construct a 16-bit binary code,
    `C`, with the format `xxxxx`aaa`xx`bbb`xxx`. Source bits `a` are in `sR1` and
    source bits `b` are in `sR2` in the lower-order three bits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计指令集时，主要任务之一是为指令构造二进制代码。这些操作使得位操作变得容易实现。例如，假设变量`sR1`指定源寄存器1，`sR2`指定源寄存器2，我们必须构造一个16位的二进制代码`C`，其格式为`xxxxxaaa`xx`bbb`xxx`。源位`a`在`sR1`中，源位`b`在`sR2`的低位三位中。
- en: 'We must insert the bits of `sR1` and `sR2` at the appropriate places without
    changing any other bits of `C`. In Python, we can do this with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在适当的位置插入`sR1`和`sR2`的位，而不改变`C`的任何其他位。在Python中，我们可以这样做：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can readily translate this into ARM assembly language using `AND`, `OR`,
    and shift operations. Assume `sR1` is in `r1`, `sR2` is in `r2`, and `C` is in
    register `r0`. Moreover, assume that the register bits are already in place in
    their respective registers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AND`、`OR`和移位操作轻松地将这个操作翻译成ARM汇编语言。假设`sR1`在`r1`中，`sR2`在`r2`中，`C`在寄存器`r0`中。此外，假设寄存器位已经在其各自的寄存器中就位：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Shift operations
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移位操作
- en: Python can shift bits left using the `<<` operator, or right using the `>>`
    operator. ARM’s assembly language lacks explicit instructions such as `LSR` or
    `LSL` that shift bits right or left. However, it does have pseudo-instructions
    such as `lsl` r1,`r3`,`#4` that shift the contents of `r3` four places left, transferring
    the result to `r1`. The ARM’s *actual* approach to shifting is rather more unusual,
    complicated, and *versatile*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python可以使用`<<`运算符向左移位，或使用`>>`运算符向右移位。ARM的汇编语言缺少像`LSR`或`LSL`这样的显式指令，这些指令可以右移或左移位。然而，它确实有一些伪指令，如`lsl
    r1, r3, #4`，可以将`r3`的内容左移四位，并将结果转移到`r1`。ARM的*实际*移位方法相当不寻常、复杂且*多功能*。'
- en: The ARM includes shifting as part of conventional data operations. Consider
    `add` r1`,r2,r3`, which adds `r3` to `r2` and puts the result in `r1`. ARM allows
    you to shift the second operand *before* it is used in a data processing operation.
    You can write `add r1,r2,r3, lsl r4` (see *Figure 10**.2* for an explanation of
    the second destination field).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ARM将移位操作作为常规数据操作的一部分。考虑`add r1, r2, r3`，它将`r3`加到`r2`上，并将结果放入`r1`。ARM允许你在数据操作中使用第二个操作数之前对其进行移位。你可以写`add
    r1, r2, r3, lsl r4`（见*图10*.2解释第二个目标字段）。
- en: '![Figure 10.2 – The structure of a dynamic shift operation](img/Figure_10.02_B19624.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 动态移位操作的结构](img/Figure_10.02_B19624.jpg)'
- en: Figure 10.2 – The structure of a dynamic shift operation
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 动态移位操作的结构
- en: 'This instruction takes the second source operand, r3, and performs a logical
    shift left. The number of left shifts is determined by the contents of r4\. You
    can also implement a fixed shift using a constant with the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将第二个源操作数r3进行逻辑左移。左移的位数由r4的内容确定。您也可以使用以下常数实现固定移位：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, register r3 is shifted left by three bits before it is added to
    `r2`. A shift is called *dynamic* if the number of shifts is specified by a register,
    since you can change the number of shifts at runtime by changing the shift count.
    If the number of shifts is given by a literal (constant), it cannot be changed
    at runtime. This is a *static* shift.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，寄存器r3在加到`r2`之前左移了三位。如果移位的位数由寄存器指定，则称为*动态*移位，因为您可以通过更改移位计数在运行时更改移位次数。如果移位的位数由文字（常数）给出，则无法在运行时更改。这是一个*静态*移位。
- en: 'The ARM’s shift combines a data-processing operation with shifting (speeding
    up data processing), and it lets you specify four registers in an instruction.
    What do you do if you require a plain vanilla shift without including a data-processing
    instruction? You can use the `MOV` instruction, such as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的移位将数据处理操作与移位（加速数据处理）结合起来，并允许您在一个指令中指定四个寄存器。如果您需要不带数据处理指令的普通移位，可以使用`MOV`指令，如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Today, ARM assemblers let you write the pseudo-instruction `lsl` r1`,r3,#4`
    and automatically substitute the move instruction `mov` r1`,r1,lsr #4`, using
    a shifted second operand.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '今天，ARM汇编器允许您编写伪指令`lsl r1,r3,#4`并自动替换为移位操作指令`mov r1,r1,lsr #4`，使用移位后的第二个操作数。'
- en: Shift types
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位移类型
- en: All shifts look the same from the middle of a string of bits – that is, the
    bits move one (or more) places left or right. However, what happens to the bits
    at the end? When bits are shifted in a register, at one end, a bit will drop out.
    That bit can disappear into oblivion, go to the carry bit, or move around to the
    other end in a circular fashion. At the end where a bit is vacated, the new bit
    can be set to `0`, `1`, the same as the carry bit, or the bit that fell off the
    other end.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有移位从位串的中间看起来都一样 – 即，位向左或向右移动一个（或多个）位置。然而，位在末尾会发生什么？当位在寄存器中移位时，在一边，一个位会掉落。这个位可以消失在虚无中，进入进位位，或者以循环方式移动到另一边。在位被腾出的末端，新位可以设置为`0`、`1`、与进位位相同，或者从另一端掉落的位。
- en: 'The variations in the way that the bit shifted in is treated by computers correspond
    to specific types of shift – *logical*, *arithmetic*, *rotate*, and *rotate through
    carry*. Let’s look at some shift operations (*table 10.1*):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机处理移入位的方式的变化对应于特定的移位类型 – *逻辑*、*算术*、*循环*和*带进位循环*。让我们看看一些移位操作（*表10.1*）：
- en: '| **Source string** | **Direction** | **Number** **of shifts** | **Destination
    string** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **源字符串** | **方向** | **移位** **数** | **目标字符串** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0`110011111010111` | Left | 1 | `110011111010111`*0* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0`110011111010111` | 左移 | 1 | `110011111010111`*0* |'
- en: '| 01`10011111010111` | Left | 2 | `10011111010111`*00* |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 01`10011111010111` | 左移 | 2 | `10011111010111`*00* |'
- en: '| 011`0011111010111` | Left | 3 | `0011111010111`*000* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 011`0011111010111` | 左移 | 3 | `0011111010111`*000* |'
- en: '| `011001111101011`1 | Right | 1 | *0*`011001111101011` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `011001111101011`1 | 右移 | 1 | *0*`011001111101011` |'
- en: '| `01100111110101`11 | Right | 2 | *00*`01100111110101` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `01100111110101`11 | 右移 | 2 | *00*`01100111110101` |'
- en: '| `0110011111010`111 | Right | 3 | *000*`0110011111010` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `0110011111010`111 | 右移 | 3 | *000*`0110011111010` |'
- en: Table 10.1 – ARM's logical shift operations
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – ARM的逻辑移位操作
- en: 'The bits in the destination string in italic are the bits shifted in, and the
    bits in the source string in bold are the bits lost (dropped) after the shift.
    This type of shift is a *logical* shift:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在斜体中的目标字符串中的位是移入的位，而在粗体中的源字符串中的位是在移位后丢失（丢弃）的位。这种移位是一种*逻辑*移位：
- en: '**Logical shift**: The bits shifted are moved one or more places left or right.
    Bits fall off at one end and zeros enter at the other end. The last bit shifted
    out is copied to the carry flag. *Figure 10**.3* illustrates the logical shift
    left and the logical shift right.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑移位**：移位位移动一个或多个位置向左或向右。位在一边掉落，另一边进入零。最后移出的位被复制到进位标志。*图10**.3*说明了逻辑左移和逻辑右移。'
- en: '![Figure 10.3 – Logical shifts](img/Figure_10.03_B19624.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 逻辑移位](img/Figure_10.03_B19624.jpg)'
- en: Figure 10.3 – Logical shifts
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 逻辑移位
- en: '**Arithmetic shift**: This arithmetic shift treats the number being shifted
    as a signed twos complement value. An arithmetic shift left is the same as a logical
    shift for left shifts. For right shifts, the most-significant bit is propagated
    right. This shift treats the operand as a signed value, which is either divided
    by two (shift right one bit) or multiplied by two (shift left one bit), as *Figure*
    *10**.4* demonstrates.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术移位**：这种算术移位将正在移位的数视为有符号的二进制补码值。算术左移与逻辑左移相同。对于右移，最高有效位向右传播。这种移位将操作数视为有符号值，要么除以二（右移一位），要么乘以二（左移一位），如*图*
    *10**.4*所示。'
- en: The purpose of an arithmetic shift is to preserve the sign of a twos complement
    number, when it takes part in a shifting operation that represents division by
    the power of 2\. For example, the 8-bit value `10001111` becomes `01000111` when
    shifted right *logically*, but 11`000111` when shifted right *arithmetically*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 算术移位的目的在于在表示除以2的幂的移位操作中，保留二进制补码数的符号。例如，8位值`10001111`在逻辑右移时变为`01000111`，但在算术右移时变为`11000111`。
- en: '*Figure 10.4* illustrates the arithmetic shift left and shift right. The ARM
    has an `asr` operation but not `asl`, because `asl` is identical to `LSL` – that
    is, you use a logical shift left because it is exactly the same as asl.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.4*展示了算术左移和右移。ARM有`asr`操作但没有`asl`，因为`asl`与`LSL`相同——也就是说，你使用逻辑左移，因为它与`asl`完全相同。'
- en: '![Figure 10.4 – Arithmetic shifts](img/Figure_10.04_B19624.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 算术移位](img/Figure_10.04_B19624.jpg)'
- en: Figure 10.4 – Arithmetic shifts
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 算术移位
- en: '`01101110` being rotated left, one bit at a time:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01101110`逐位左旋转：'
- en: '![Figure 10.5 – Example of successive rotate operations](img/Figure_10.05_B19624.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 连续旋转操作示例](img/Figure_10.05_B19624.jpg)'
- en: Figure 10.5 – Example of successive rotate operations
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 连续旋转操作示例
- en: The rotate operation is *non-destructive* – that is, no bit is lost or changed
    by the operation. It is very useful in operations such as counting the number
    of `1`s in a bit string. *Figure 10.6* illustrates the *rotate* operation. Note
    that the ARM does *not* have a rotate right instruction – that is, there is no
    `ror`. Since rotate is a circular operation, shifting an *m*-bit word *p* places
    right is achieved by shifting `32-p` places left; consequently, `ror r0,r1,#4`
    is achieved by `rol r0,r1,#28`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转操作是非破坏性的——也就是说，操作过程中没有位丢失或改变。它在诸如计算位串中`1`的个数等操作中非常有用。*图10.6*展示了旋转操作。请注意，ARM没有实现右旋转指令——也就是说，没有`ror`。由于旋转是一个循环操作，将*m*位字右移*p*位可以通过左移`32-p`位来实现；因此，`ror
    r0,r1,#4`可以通过`rol r0,r1,#28`来实现。
- en: '![Figure 10.6 – Rotate operations (ARM does not implement ROL)](img/Figure_10.06_B19624.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 旋转操作（ARM不实现ROL）](img/Figure_10.06_B19624.jpg)'
- en: Figure 10.6 – Rotate operations (ARM does not implement ROL)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 旋转操作（ARM不实现ROL）
- en: A variation of the rotate operation is the *rotate through carry*, where the
    carry bit is considered as part of the word being shifted – that is, an *n*-bit
    word becomes an *n+1* bit word. *Figure 10.7* demonstrates a rotate through carry
    operation, where the carry shifted out is copied into the carry bit, and the old
    value of the carry bit becomes the new bit shifted in. This operation is used
    in chained arithmetic (it’s the analog of the *add with carry and subtract with
    borrow* operations).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转操作的变体是*带进位的旋转*，其中进位位被视为要移位的字的一部分——也就是说，*n*位字变成了*n+1*位字。*图10.7*演示了带进位的旋转操作，其中移出的进位被复制到进位位，而进位位的旧值成为新移入的位。这种操作用于链式算术（它是*带进位加法和带借位减法*操作的类似物）。
- en: '![Figure 10.7 – Rotate through carry](img/Figure_10.07_B19624.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 带进位的旋转](img/Figure_10.07_B19624.jpg)'
- en: Figure 10.7 – Rotate through carry
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 带进位的旋转
- en: 'ARM implements only the following five shifts (a programmer can synthesize
    the rest):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ARM仅实现了以下五种移位操作（程序员可以合成其余的操作）：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`rrx`, which rotates bits right through carry (*Figure 10.7*), behaves differently
    from other shifts. First, only one direction of shift is permitted; there is no
    left shift through carry. Second, the ARM supports both *static* and *dynamic*
    shifts for all other shift operations, whereas `rrx` allows only one single shift.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`rrx`，它通过带进位右旋转位（*图10.7*），与其他移位操作表现不同。首先，只允许一个方向的移位；没有带进位的左移位。其次，ARM支持所有其他移位操作的所有*静态*和*动态*移位，而`rrx`只允许一次移位。'
- en: 'Although there is no rotate left operation, you can readily implement it by
    means of a rotate right operation. The following example demonstrates the rotation,
    both left and right, of a 4-bit value. After four rotations, the number is unchanged.
    As you can see, there is symmetry between left and right rotations. For a 32-bit
    value, an *n*-bit shift left is identical to a 32-*n* bit shift right:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有左旋操作，但你可以通过右旋操作轻松实现它。以下示例演示了 4 位值的左旋和右旋。经过四次旋转后，数字保持不变。正如你所见，左旋和右旋之间存在对称性。对于
    32 位值，n 位左移等同于 32-n 位右移：
- en: '| Rotate right  | Rotate left |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 右旋 | 左旋 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1101 | Start | 1101 | Start |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 开始 | 1101 | 开始 |'
- en: '| 1110 | Rotate right 1 | 1011 | Rotate left 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 右旋 1 | 1011 | 左旋 1 |'
- en: '| 0111 | Rotate right 2 | 0111 | Rotate left 2 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 右旋 2 | 0111 | 左旋 2 |'
- en: '| 1011 | Rotate right 3 | 1110 | Rotate left 3 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 右旋 3 | 1110 | 左旋 3 |'
- en: '| 1101 | Rotate right 4 | 1101 | Rotate left 4 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 右旋 4 | 1101 | 左旋 4 |'
- en: Table 10.2 - Comparing successive left and right rotates
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 - 比较连续的左旋和右旋
- en: Consider `adcs` r0,`r0`,`r0` (add with carry and set status flags). This adds
    the contents of `r0` to the contents of `r0`, plus the carry bit, to generate
    `2 x [r0] + C`. Shifting left is equivalent to multiplying by 2\. Moving the carry
    bit into the least-significant position is equivalent to adding the carry bit
    to get `2 x [r0] + C`. Appending `S` to the instruction forces the `CCR` to be
    updated, which ensures that any carryout is loaded into the C-bit. Consequently,
    `adcs` r0,`r0`,`r0` and `rlx` r0 are equivalent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `adcs` r0,`r0`,`r0`（带进位加并设置状态标志）。这会将 `r0` 的内容加上 `r0` 的内容，再加上进位位，生成 `2 x [r0]
    + C`。左移等同于乘以 2。将进位位移入最低有效位置等同于加上进位位以得到 `2 x [r0] + C`。在指令后添加 `S` 强制更新 `CCR`，这确保任何进位都加载到
    C 位。因此，`adcs` r0,`r0`,`r0` 和 `rlx` r0 是等效的。
- en: Using shift operations to merge data
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用移位操作合并数据
- en: 'In the following example, we extract the least-significant byte from each of
    the three registers and put them together in a new word. The literals are in a
    hexadecimal format. Assume that the registers are, initially, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们从每个三个寄存器中提取最低有效字节，并将它们组合成一个新的字。字面量以十六进制格式表示。假设寄存器最初如下所示：
- en: '`r1` = `XXXXXX`AA   `r1` is source 1, the Xs represent don’t care values'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1` = `XXXXXX`AA   `r1` 是源 1，Xs 代表无关紧要的值'
- en: '`r2` = `XXXXXX`BB   `r2` is source 2'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r2` = `XXXXXX`BB   `r2` 是源 2'
- en: '`r3` = `XXXXXX`CC   `r3` is source 3'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r3` = `XXXXXX`CC   `r3` 是源 3'
- en: '`r4` = `00`CCBBAA   `r4` is the final result'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r4` = `00`CCBBAA   `r4` 是最终结果'
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is a brute-force approach. A better alternative is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个暴力方法。一个更好的替代方案如下：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, consider `r0 = 0x0000`AA, `r1 = 0x000000`BB, and `r2 = 0x12345678`. We
    wish to merge the four registers to get `0x`AABB`5678`. We can do this with just
    three instructions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑 `r0 = 0x0000`AA, `r1 = 0x000000`BB, 和 `r2 = 0x12345678`。我们希望合并这四个寄存器以得到
    `0x`AABB`5678`。我们可以用三条指令来完成这个操作：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`add r2,r1,r2,lsl #16` adds `r1` to `r2` after `r2` has been shifted left 16
    times. The 16-bit left shift moves the lower-order 16-bits of `r2` into the upper-order
    16-bits, and it clears the lower-order 16 bits by shifting in zeros. We’ve preserved
    the old lower-order half of `r2`, and we’ve cleared the new lower-order 16 bits
    ready to insert the bytes from `r0` and `r1`. add r2`,r2,r0,lsl #8` inserts the
    low-order byte of `r0` into bits 8 to 15 of `r2`, since `r0` is first shifted
    left by 8 bits. Since zeros are shifted into `r0`, this operation doesn’t affect
    bits 0 to 7 of `r2`. Executing `mov` r2`,r2,ror #16` performs a 16-bit rotation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`add r2,r1,r2,lsl #16` 在 `r2` 左移 16 次后将 `r1` 添加到 `r2`。16 位的左移将 `r2` 的低阶 16
    位移动到高阶 16 位，并通过移入零来清除低阶 16 位。我们保留了 `r2` 的旧的低阶半部分，并清除了新的低阶 16 位，以便插入来自 `r0` 和 `r1`
    的字节。`add r2`,r2,r0,lsl #8` 将 `r0` 的低阶字节插入到 `r2` 的第 8 位到第 15 位，因为 `r0` 首先左移 8 位。由于
    `r0` 中移入了零，这个操作不会影响 `r2` 的第 0 位到第 7 位。执行 `mov` r2`,r2,ror #16` 执行 16 位的旋转。'
- en: 'The next example of shifting demonstrates how we can implement `if x < 0: x
    = 0`. This construct sets the `x` variable to zero if `x` is negative (i.e., `msb`
    is `1`); otherwise, `x` is unchanged. The ARM code is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个移位示例演示了如何实现 `if x < 0: x = 0`。这个结构在 `x` 为负数（即，`msb` 为 `1`）时将 `x` 变量设置为零；否则，`x`
    保持不变。ARM 代码如下：'
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The arithmetic shift right propagates the sign-bit 31 times, leaving `0x00000000`
    for a positive number and `0xFFFFFFFF` for a negative number. The `bic` operation
    `AND`s the first operand and the complement of the second. If `r0` was positive,
    all bits are `AND`ed, with 1 leaving `r0` unchanged. If `r0` was negative, the
    bits are `AND`ed, with `0` leaving `0`. Therefore, a positive `x` is unchanged
    and a negative `x` is set to `0`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 算术右移将符号位31次，对于正数留下`0x00000000`，对于负数留下`0xFFFFFFFF`。`bic`操作将第一个操作数与第二个操作数的补码进行`AND`操作。如果`r0`是正数，所有位都会进行`AND`操作，1留下`r0`不变。如果`r0`是负数，位会进行`AND`操作，0留下`0`。因此，正数`x`保持不变，负数`x`被设置为`0`。
- en: The next section looks at a class of instruction that does not move data or
    process data; it determines which instruction will be executed next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨一类不移动数据或处理数据的指令；它确定下一个要执行的指令。
- en: Flow control instructions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流控制指令
- en: Computers execute instructions sequentially unless a branch causes a jump to
    an out-of-sequence instruction, or the flow of instructions is interrupted when
    a subroutine is called. The instruction flow is also changed when an interrupt
    occurs (we don’t deal with interrupts here).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机按顺序执行指令，除非分支导致跳转到非顺序指令，或者当调用子程序时中断指令流。当发生中断时，指令流也会改变（我们这里不处理中断）。
- en: 'In this section, we will look at the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看以下内容：
- en: Unconditional branches
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无条件分支
- en: Conditional branches
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件分支
- en: Unconditional branches
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无条件分支
- en: 'ARM’s unconditional branch is expressed as `b target`, where `target` denotes
    the *branch target address* (the address of the next instruction to be executed).
    The unconditional branch forces a jump (branch) from one point in a program to
    another. It is exactly the same as the unconditional branch we introduced earlier.
    The following ARM code demonstrates how the unconditional branch is used:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的无条件分支表示为`b target`，其中`target`表示*分支目标地址*（即将执行的下一条指令的地址）。无条件分支强制从程序的一个点跳转到另一个点。这与我们之前介绍的无条件分支完全相同。以下ARM代码演示了如何使用无条件分支：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The ARM’s branch instructions use a 24-bit literal to provide a twos complement
    relative offset. This is shifted left twice to create a 26-bit *byte* offset,
    which is added to the current program counter to obtain the 32-bit target address.
    The branch range is 32 MB from the current PC (in either direction). Remember
    that consecutive instruction addresses differ by four.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的分支指令使用一个24位的立即数来提供一个二进制补码相对偏移。这个偏移量左移两次以创建一个26位的*字节*偏移量，然后将其加到当前程序计数器上以获得32位的目标地址。分支范围是从当前PC（任一方向）的32MB。记住，连续的指令地址相差四。
- en: Conditional branch
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件分支
- en: 'ARM’s conditional branches consist of a mnemonic Bcc and a target address.
    The subscript defines one of 16 conditions that must be satisfied for the branch
    to be taken. If the condition is `true`, execution continues at the branch target
    address. If the condition is not `true`, the next instruction in sequence is executed.
    Consider the flowing example in ARM assembly language that implements the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的条件分支由一个助记符Bcc和一个目标地址组成。下标定义了必须满足的16个条件之一，以便分支被执行。如果条件为`true`，则执行继续在分支目标地址。如果条件不为`true`，则执行序列中的下一条指令。考虑以下ARM汇编语言示例，它实现了以下内容：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The *conditional branch* instruction tests flag bits in the processor’s condition
    code register and then takes the branch if the tested condition is true. Since
    the condition code register includes a zero bit (`Z`), negative bit (`N`), carry
    bit (`C`), and overflow bit (`V`), there are eight conditional branches based
    on the state of a single bit (four that branch on true and four that branch on
    `false`). *Table 10.3* defines all the ARM’s conditional branches. Note that there
    is a branch *always* and a branch *never* instruction.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件分支*指令检查处理器条件码寄存器中的标志位，然后如果测试条件为真则执行分支。由于条件码寄存器包括一个零位（`Z`）、负位（`N`）、进位位（`C`）和溢出位（`V`），因此基于单个位的状态有八个条件分支（四个在`true`时分支，四个在`false`时分支）。*表10.3*定义了所有ARM的条件分支。注意，有一个*总是*分支和一个*从不*分支指令。'
- en: Branch instructions can be applied to *signed* or *unsigned* data. Consider
    the four-bit values `x = 0011` and y = 1001\. We want to branch if `y` is greater
    than `x`. Using unsigned arithmetic, `x = 3` and `y` is `9`, so y > x. However,
    if we regard these as signed values, then `x = 3` and `y = -7`, so `y < x`. Clearly,
    we have to select an unsigned comparison for unsigned arithmetic and a signed
    comparison for signed arithmetic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 分支指令可以应用于*有符号*或*无符号*数据。考虑四位值 `x = 0011` 和 `y = 1001`。我们希望如果 `y` 大于 `x` 则分支。使用无符号算术，`x
    = 3` 而 `y` 是 `9`，所以 `y > x`。然而，如果我们认为这些是有符号值，那么 `x = 3` 而 `y = -7`，所以 `y < x`。显然，我们必须为无符号算术选择无符号比较，为有符号算术选择有符号比较。
- en: '| **Encoding** | **Mnemonic** | **Branch on** **flag status** | **Execute**
    **on condition** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **编码** | **助记符** | **基于** **标志状态** **执行** **条件** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0000 | EQ | Z set | Equal (i.e., zero) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | EQ | Z set | 等于（即零） |'
- en: '| 0001 | NE | Z clear | Not equal (i.e., not zero) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | NE | Z clear | 不相等（即非零） |'
- en: '| 0010 | CS or HS | C set | Unsigned higher or same |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | CS or HS | C set | 无符号更高或相同 |'
- en: '| 0011 | CC or LO | C clear | Unsigned lower |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | CC or LO | C clear | 无符号更低 |'
- en: '| 0100 | MI | N set | Negative |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | MI | N set | 负 |'
- en: '| 0101 | PL | N clear | Positive or zero |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | PL | N clear | 正或零 |'
- en: '| 0110 | VS | V set | Overflow |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | VS | V set | 溢出 |'
- en: '| 0111 | VC | V clear | No overflow |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | VC | V clear | 无溢出 |'
- en: '| 1000 | HI | C set and Z clear | Unsigned higher |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | HI | C set and Z clear | 无符号更高 |'
- en: '| 1001 | LS | C clear or Z set | Unsigned lower or same |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | LS | C clear or Z set | 无符号更低或相同 |'
- en: '| 1010 | GE | N set and V set, or N clear and V clear | Signed greater or equal
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | GE | N set and V set, or N clear and V clear | 签名大于或等于 |'
- en: '| 1011 | LT | N set and V clear, or N clear and V set | Signed less than |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | LT | N set and V clear, or N clear and V set | 有符号小于 |'
- en: '| 1100 | GT | Z clear, and either N set and V set, or N clear and V clear |
    Signed greater than |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | GT | Z clear, and either N set and V set, or N clear and V clear |
    有符号大于 |'
- en: '| 1101 | LE | Z set, or N set and V clear, or N clear and V set | Signed less
    than or equal |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | LE | Z set, or N set and V clear, or N clear and V set | 有符号小于或等于
    |'
- en: '| 1110 | AL | Unconditional | Always (default) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | AL | 无条件 | 总是（默认） |'
- en: '| 1111 | NV |  | Never (reserved) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | NV |  | 从不（保留） |'
- en: Table 10.3 – ARM’s conditional execution and branch control mnemonics
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 - ARM 的条件执行和分支控制助记符
- en: Some microprocessors have *synonyms* for conditional branch operations – that
    is, a branch condition has two mnemonics. For example, branch on carry set `(bcs)`
    can be written branch on higher or same `(bhs)`, because `C = 1` implements the
    ( `>` ) operation in unsigned arithmetic. Similarly, `bcc` can be written branch
    on lower `(blo)`, because the carry clear implements an unsigned comparison that
    is lower.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微处理器有条件分支操作的*同义词*——也就是说，一个分支条件有两个助记符。例如，带进位设置的分支（`bcs`）可以写成带更高或相同（`bhs`）的分支，因为
    `C = 1` 在无符号算术中实现了（`>`）操作。同样，`bcc` 可以写成带更低（`blo`），因为进位清除实现了无符号比较，即更低。
- en: 'One of the best examples of the use of conditional branching is in repetitive
    structures. Consider the `while` loop:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支的使用最好的例子之一是在重复结构中。考虑 `while` 循环：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final section of this chapter looks at ARM’s *conditional execution mechanism*,
    which provides a means of squashing or *annulling* instructions – that is, you
    can choose to run or not run an instruction at runtime. This is a feature found
    on very, very few processors. However, this mechanism provides the ARM with a
    very interesting means of speeding execution by creating compact code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将探讨 ARM 的 *条件执行机制*，该机制提供了一种取消或*取消*指令的方法——也就是说，您可以在运行时选择是否执行指令。这是一个在非常非常少的处理器上发现的特性。然而，这种机制通过创建紧凑的代码为
    ARM 提供了一种非常有趣的加速执行的方法。
- en: Conditional executions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件执行
- en: Here, we will deal with just one topic, conditional executing, and we will demonstrate
    how you can ignore an instruction if it does not fulfill a specified criterion
    (related to the condition control status bits). This mechanism enables programmers
    to write more compact code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将只处理一个主题，即条件执行，我们将展示如何忽略不满足指定标准（与条件控制状态位相关）的指令。这种机制使程序员能够编写更紧凑的代码。
- en: Consider the `add` instruction. When the computer reads it from memory, it is
    executed, exactly like almost every other computer. The ARM is different; each
    of its instructions is *conditionally executed* – that is, an instruction is executed
    only if a specific condition is met; otherwise, it is bypassed (annulled or squashed).
    Each ARM instruction is associated with a logical condition (one of the 16 in
    *Table 10.3*). If the stated condition is true, the instruction is executed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`add`指令。当计算机从内存中读取它时，它会执行，就像几乎每台计算机一样。ARM不同；它的每条指令都是*条件执行*的——也就是说，只有当满足特定条件时，指令才会执行；否则，它会被绕过（取消或压扁）。每个ARM指令都与一个逻辑条件相关联（*表10.3*中的16个之一）。如果声明的条件为真，则执行该指令。
- en: 'A suffix indicates conditional execution by appending `condition` – for example,
    `add`eqr1`,r2,r3` specifies that the addition is performed *only if the Z-bit
    in the CCR is set*. The RTL form of this operation is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀通过附加`condition`来表示条件执行，例如，`add eq r1, r2, r3`指定只有在CCR中的Z位被设置时才执行加法。这个操作的RTL形式如下：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is, of course, nothing to stop you from combining conditional execution
    and shifting, since the branch and shift fields of an instruction are independent.
    You can write the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有任何东西阻止你结合条件执行和移位，因为指令的分支和移位字段是独立的。你可以写出以下代码：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is interpreted as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这被解释如下：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To demonstrate the power of conditional execution, consider the following Python
    statement:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示条件执行的力量，考虑以下Python语句：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Translated into ARM code using conditional execution, we can write the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件执行将以下代码翻译成ARM代码，我们可以写出以下代码：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the test, the operation is either executed or not executed, depending
    on the result of the test. Now, consider a construct with a compound predicate:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 测试之后，操作要么执行，要么不执行，这取决于测试的结果。现在，考虑一个复合谓词的结构：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line, `cmp` r0`,r1`, compares `a` and `b`. The next line, `cmp`eqr2`,r3`,
    executes a conditional comparison only if the result of the first line was true
    (i.e., `a == b`). The third line, `add`eqr4`,r4,#1`, is executed only if the previous
    line was true (i.e., `c == d`) to implement `e = e + 1`. Without conditional execution,
    we might write the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行，`cmp r0, r1`，比较`a`和`b`。下一行，`cmp eq r2, r3`，仅在第一行的结果为真时（即`a == b`）执行条件比较。第三行，`add
    eq r4, r4, #1`，仅在上一行结果为真时（即`c == d`）执行，以实现`e = e + 1`。没有条件执行，我们可能会写出以下代码：'
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This conventional approach to compound logical conditions requires five instructions.
    You can also handle some testing with multiple conditions. Consider the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统的复合逻辑条件方法需要五条指令。你也可以用多个条件处理一些测试。考虑以下：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the same register assignments as before, we can use conditional execution
    to implement this as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的寄存器分配，我们可以使用条件执行如下实现：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using conventional non-conditional execution, we would have to write the following
    to implement this algorithm. This is rather less elegant than the previous version:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的非条件执行，我们需要编写以下代码来实现这个算法。这比之前的版本要简陋得多：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the next example, we use conditional execution to obtain the absolute value
    of a signed integer – that is, if the integer is negative, it is converted into
    the corresponding positive value. For example (in 8 bits), -2 is `11111110`, which
    would be converted into `00000010` (i.e., +2).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们使用条件执行来获取有符号整数的绝对值——也就是说，如果整数是负数，它会被转换成相应的正数。例如（在8位中），-2是`11111110`，这将转换成`00000010`（即+2）。
- en: 'We can use ARM’s `teq` instruction `teq` is similar to `CMP`, but `teq` does
    not set the `V` and `C` flags during the test. `teq` is useful to test for negative
    values *because the N-bit is set to 1 if the number tested* *is negative*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ARM的`teq`指令。`teq`与`CMP`类似，但`teq`在测试期间不设置`V`和`C`标志。`teq`在测试负数时很有用，因为如果测试的数字是负数，N位会被设置为1：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the operand in `r0` is tested, and the N-bit is set if it is negative
    and is clear if it is positive. The conditional instruction, `rsb`mi, is not executed
    if the tested operand was positive (no change is necessary). If the number was
    negative, the reverse substation performs `0 – r0`, which reverses its sign and
    makes it positive.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`r0`中的操作数被测试，如果它是负数，N位被设置，如果是正数，N位被清除。条件指令`rsb mi`在测试的操作数为正数时（不需要更改）不执行。如果数字是负数，反向减法执行`0
    – r0`，这会反转它的符号并使其变为正数。
- en: Sequential conditional execution
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序条件执行
- en: 'Since a compare or an arithmetic operation updates the `C`, `N`, `V`, and `Z`
    bits, we can perform up to four conditional acts after one comparison. The following
    example converts uppercase ASCII-encoded characters to lowercase characters –
    for example, ''M'' would be converted to ''m.'' Bit 5 of an ASCII character is
    zero for uppercase letters and one for lowercase letters. Consider the code that
    first checks whether a character is in the range of ''A'' to ''Z'' and converts
    it to lowercase if it is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于比较或算术操作会更新`C`、`N`、`V`和`Z`位，我们可以在一次比较之后执行多达四个条件操作。以下示例将大写ASCII编码字符转换为小写字符——例如，'M'将被转换为'm'。ASCII字符的位5对于大写字母为零，对于小写字母为一。考虑以下代码，它首先检查一个字符是否在'A'到'Z'的范围内，如果是，则将其转换为小写：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first instruction, `cmp`, checks whether the character is 'A' or greater
    by subtracting the ASCII code for 'A.' If it is, the `rsb`ges checks that the
    character is less than 'Z.' This test is performed only if the character in `r0`
    is greater or equal to 'A.' We use reverse subtraction because we want to test
    whether the ASCII code for Z minus the ASCII code for the character is positive.
    If we are in range, the conditional `orr` is executed, and an uppercase to lowercase
    conversion is performed by setting bit 5.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令，`cmp`，通过减去字符'A'的ASCII码来检查字符是否大于或等于'A'。如果是，`rsb`ges会检查字符是否小于'Z'。这个测试仅在`r0`中的字符大于或等于'A'时执行。我们使用反向减法，因为我们想测试Z的ASCII码减去字符的ASCII码是否为正。如果我们处于范围内，则执行条件`orr`，并通过设置位5来执行大写转小写的转换。
- en: In the next chapter, we will look at how operands are specified – that is, we
    will look at addressing modes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何指定操作数——也就是说，我们将探讨寻址方式。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve extended our knowledge of the ARM beyond the basic data-processing
    instructions we encountered in the previous chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们对ARM的了解，超出了我们在上一章中遇到的基本数据处理指令。
- en: We began with the ARM’s register set, which is different from almost every other
    processor. RISC processors generally have 32 general-purpose registers. The ARM
    has only 16 registers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从ARM的寄存器集开始，这与几乎所有其他处理器都不同。RISC处理器通常有32个通用寄存器。ARM只有16个寄存器。
- en: Two of the ARM’s registers have a special purpose. Register `r14` is called
    a *link register* and is used by the branch with link instructions to restore
    return addresses. Otherwise, it is a general-purpose register. Register `r15`
    is the program counter, and that is very unusual indeed. This makes the ARM a
    very interesting device because you can change the program counter by operating
    on `r15`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的两个寄存器具有特殊用途。寄存器`r14`被称为*链接寄存器*，用于带有链接的分支指令来恢复返回地址。否则，它是一个通用寄存器。寄存器`r15`是程序计数器，这确实非常不寻常。这使得ARM成为一个非常有趣的设备，因为你可以通过操作`r15`来更改程序计数器。
- en: We also looked at shifting operations. Shifting simply involves bits moving
    one or more places left or right. However, as bits are in registers or memory
    locations, a shift involves bits moving into one and dropping out the other. The
    different types of shifts are determined by what happens to those bits that are
    shifted in or out at the ends of the number.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了移位操作。移位只是涉及位向左或向右移动一个或多个位置。然而，由于位位于寄存器或内存位置中，移位涉及位从一个位置移动到另一个位置，并从另一个位置掉落。不同类型的移位取决于在数字两端移入或移出的位发生了什么。
- en: We discovered that the ARM has another unusual feature because it doesn’t provide
    pure shift instructions. Instead, it can apply a shift to the second operand in
    a conventional data processing operation. The ARM can execute an `add` r0`,r1,r2,
    lsl r3` instruction that shifts the contents of register `r2` left by the value
    in `r3`. The shifted value is then added to `r1`, and the result is transferred
    to `r0`. This mechanism provides a *free shift* because you can do a shift and
    not have to pay any penalty to execute it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现ARM还有一个不寻常的特性，因为它不提供纯移位指令。相反，它可以在传统的数据处理操作中将移位应用于第二个操作数。ARM可以执行`add r0,
    r1, r2, lsl r3`指令，该指令将寄存器`r2`的内容左移`r3`中的值。然后，移位值被加到`r1`上，结果被转移到`r0`。这种机制提供了一种*免费移位*，因为你可以进行移位而无需为执行它支付任何代价。
- en: Probably the most intriguing feature of the ARM is its ability to perform conditional
    execution – that is, before an instruction is executed, the condition code bits
    are checked. For example, `add`eq `r0,r1,r2` performs an addition only if the
    z-bit is set to `1`. This is a very powerful operation, and you can use it to
    write compact code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可能 ARM 最引人入胜的特性是其执行条件指令的能力——也就是说，在执行指令之前，会检查条件码位。例如，`add`eq `r0,r1,r2` 仅当 z
    位设置为 `1` 时才执行加法操作。这是一个非常强大的操作，你可以用它来编写紧凑的代码。
- en: Sadly, it appears that conditional execution is a clever technique whose time
    has passed. It’s not a cost-effective operation today. Conditional execution reduces
    the number of branches in a program and the number of clock cycles required to
    execute a program. Advances in computer technology have made conditional execution
    redundant in new CPU designs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，条件执行似乎是一种聪明的技术，但其时代已经过去。如今，它不是一个成本效益高的操作。条件执行减少了程序中的分支数量和执行程序所需的时钟周期数。计算机技术的进步使得条件执行在新
    CPU 设计中变得多余。
- en: In the next chapter, we will look at the ARM’s addressing modes – one of the
    highlights of this processor.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 ARM 的寻址模式——这是这款处理器的一个亮点。
