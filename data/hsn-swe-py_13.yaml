- en: Persisting Data to a Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据持久化到数据库
- en: With the file system-backed data persistence of the Artisan Application under
    our belt, it's time to turn our attention to their equivalents on the Central
    Office side of the system. We'll be reusing the `BaseDataObject` ABC that was
    defined previously to ensure that all data object functionality can be called
    in the same way (for example, using the `get` method to read the data and `save`
    to write it, for example), but because the underlying data storage process is significantly
    different in its implementation, that is where most of the similarities will end.
    We'll still have to decide which of the database options we're going to use, as
    well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Artisan应用程序的基于文件系统的数据持久化完成后，现在是时候将注意力转向系统中央办公室端的等效部分了。我们将重用之前定义的`BaseDataObject`
    ABC，以确保所有数据对象功能可以以相同的方式调用（例如，使用`get`方法读取数据和`save`写入数据），但由于底层数据存储过程在实现上有很大不同，这就是大部分相似之处的结束。我们还需要决定要使用哪种数据库选项。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Analyzing database options in depth and selecting a database engine for data
    object persistence
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入分析数据库选项并选择用于数据对象持久化的数据库引擎
- en: Defining a data access strategy for the code that's expected to run at the Central
    Office
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在中央办公室运行的代码定义数据访问策略
- en: Designing and implementing some supporting classes for the data access and persistence
    that are required
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现一些支持数据访问和持久化的支持类
- en: 'Implementing the concrete data objects required at the Central Office:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现中央办公室所需的具体数据对象：
- en: Artisan
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artisan
- en: Product
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: There are also some data access considerations that will postpone at least some
    of the concrete implementations, and those will be discussed in detail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些数据访问方面的考虑，将推迟至少一些具体的实现，并将详细讨论。
- en: The Artisan Gateway and Central Office application objects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Artisan Gateway和Central Office应用程序对象
- en: 'The **Artisan Gateway** and **Central Office application** both need project
    structures, so that we will have a place to put the code that''s specific to each
    of them. This need is captured in two stories:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan Gateway和Central Office应用程序都需要项目结构，这样我们就有了一个放置特定于它们各自的代码的地方。这个需求包含在两个故事中：
- en: As a developer, I need a project for the Central Office application, so that
    I have a place to put the relevant code and build the application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个Central Office应用程序的项目，这样我就有了一个放置相关代码和构建应用程序的地方
- en: As a developer, I need a project for the Artisan Gateway, so that I have a place
    to put the relevant code and build the service
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个Artisan Gateway的项目，这样我就有了一个放置相关代码和构建服务的地方
- en: 'The aforementioned structures can start with nothing more than the basic project
    template, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构可以从基本项目模板开始，如下所示：
- en: '![](assets/c423830f-96ad-4197-9e12-42c93ee49dba.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c423830f-96ad-4197-9e12-42c93ee49dba.png)'
- en: As functionality is built out for the data persistence of business objects in
    the Artisan Gateway and Central Office application, more modules can be added,
    as they were in the Artisan Application's project structure. Whether that will
    be required can be impacted substantially by the selection of the data store engine,
    but for the time being, this should suffice.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Artisan Gateway和Central Office应用程序中业务对象的数据持久化功能的构建，可以添加更多的模块，就像在Artisan应用程序的项目结构中一样。选择数据存储引擎可能会对此产生重大影响，但目前来看，这应该足够了。
- en: Picking out a backend datastore engine
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择后端数据存储引擎
- en: 'The story that drives the selection of the backend data store engine for the
    Artisan Gateway and Central Office application doesn''t really mandate any particular
    engine, just what that engine needs to provide:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动Artisan Gateway和Central Office应用程序后端数据存储引擎选择的故事实际上并不强制使用任何特定的引擎，只是需要该引擎提供以下内容：
- en: As a consumer of business object data at the HMS Central Office, I need business
    object data to be stored in a shared data store, so that data will be accessible
    by multiple consumers simultaneously, with transactional support/protection, and
    to the ends that they need access to it for.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为HMS中央办公室的业务对象数据的消费者，我需要业务对象数据存储在共享数据存储中，以便数据可以被多个消费者同时访问，并具有事务支持/保护，并且他们需要访问数据。
- en: In a real-world scenario, there might well be specific database engines that
    are allowed, are encouraged, or are not allowed, based on any number of factors—what
    system administrators are willing to install and support; what options are available,
    based on the operating systems in use in the business; and possibly other external
    factors. There can also be developmental constraints; perhaps the preferred database
    doesn't have a reliable driver/library in the language being used, or data structure
    requirements are having a direct impact on the viable options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的情况下，可能会有特定的数据库引擎是允许的、鼓励的或不允许的，这取决于许多因素，例如系统管理员愿意安装和支持的内容；根据企业使用的操作系统，可用的选项；以及可能的其他外部因素。还可能存在开发约束；也许首选的数据库在所使用的语言中没有可靠的驱动程序/库，或者数据结构要求直接影响了可行的选项。
- en: 'Another consideration, and one that does have some representation in the preceding
    scenario, is how data is accessed (locally versus over a network). In this case,
    since multiple users can access the system''s data at the same time, having a
    central database (of whatever flavor) that is accessible over the internal network
    is the easiest solution, in a number of respects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素，也在前述情景中有所体现，就是数据的访问方式（本地与网络访问）。在这种情况下，由于多个用户可以同时访问系统的数据，拥有一个可以通过内部网络访问的中央数据库（无论是哪种类型）是最简单的解决方案，从许多方面来看：
- en: It would rely on database engines that are independently installable.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将依赖于可独立安装的数据库引擎。
- en: Those engines, as prepackaged installations, do not require developer effort
    to create or maintain.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些作为预打包安装的引擎，不需要开发人员努力创建或维护。
- en: Their functionality can be tested externally, and thus, it can be trusted to
    behave as expected; therefore, development doesn't have to test the engine, but
    only interact with it.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的功能可以在外部进行测试，因此可以信任其按预期行为；因此，开发不必测试引擎，而只需与其交互。
- en: Taken together, these factors would allow for one of several options; a standard,
    SQL-based RDBMS would work, as would many of the available NoSQL database engines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 综合考虑这些因素，可以选择以下几种选项之一；标准的基于SQL的关系型数据库管理系统可以工作，许多可用的NoSQL数据库引擎也可以。
- en: Another factor to consider is how the object data structure would be represented
    in the various database options. Simple objects, such as the `Address` in `hms_core`,
    can be represented quite easily in any RDBMS with a single table. More complicated
    objects, such as an `Artisan` with its embedded `Address`, or a `Product` with
    variably sized and variable content property data (`metadata`), require either
    discrete tables for related properties (with relationships defined so that the
    objects' related properties can be retrieved) or support for dynamic, structured
    data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要考虑的因素是对象数据结构在各种数据库选项中的表示方式。简单对象，例如`hms_core`中的`Address`，可以在任何关系型数据库管理系统中以单个表格轻松表示。更复杂的对象，例如带有其嵌入式`Address`的`Artisan`，或具有可变大小和可变内容属性数据（`metadata`）的`Product`，要么需要为相关属性创建离散表（并定义关系，以便可以检索对象的相关属性），要么需要支持动态结构化数据。
- en: 'As they''d be built in a typical RDBMS implementation, the relationships are
    very simple; each `Artisan` has one address, and each `Product` has zero-to-many `metadata` items,
    which would look something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们将在典型的关系型数据库管理系统实现中构建，因此关系非常简单；每个`Artisan`都有一个地址，每个`Product`都有零到多个`metadata`项，看起来类似于以下内容：
- en: '![](assets/6163148e-104a-4b39-ab6e-507a9c208c0d.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6163148e-104a-4b39-ab6e-507a9c208c0d.png)'
- en: 'Complications start to arise when we consider how to implement different data
    retrieval processes, using the possible permutations from the `BaseDataObject.get` class
    method and assuming that the real work happens at the database engine side of
    things:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑如何实现不同的数据检索过程时，就会出现复杂性，使用`BaseDataObject.get`类方法的可能排列，并假设真正的工作发生在数据库引擎的一侧：
- en: 'Getting one `Artisan` and its `address`, or one `Product` and its `metadata`, isn''t
    too complicated; assuming an `oid` value, it boils down to variations of the following:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个`Artisan`及其`address`，或一个`Product`及其`metadata`，并不太复杂；假设一个`oid`值，它归结为以下变化：
- en: Getting the artisan or product record that matches the `oid`, then converting
    it to a `dict` so that we can use the `from_data_dict` class method to create
    an instance
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取与`oid`匹配的工匠或产品记录，然后将其转换为`dict`，以便我们可以使用`from_data_dict`类方法创建实例
- en: 'For an `Artisan`: Getting the related `address` record, converting it to a `dict`,
    and inserting it into the first `dict`, created as `address`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Artisan`：获取相关的`address`记录，将其转换为`dict`，并将其插入到作为`address`创建的第一个`dict`中
- en: 'For a `Product`: Getting the related `metadata` records, converting the records
    returned to a key/value `dict`, and inserting it into the first `dict`, created
    as ``metadata``'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Product`：获取相关的`metadata`记录，将返回的记录转换为键/值`dict`，并将其插入到作为`metadata`创建的第一个`dict`中
- en: Creating the instance by calling the appropriate `from_data_dict` class method.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用适当的`from_data_dict`类方法创建实例。
- en: Getting multiple instances based on only a list of `oid` values isn't much different;
    it simply starts with retrieving all of the records with matching `oid` values,
    then sorting out the data and creating and returning a list of instances. Realistically,
    if this process and the single-`oid` process used the same code, returning one
    (or zero) objects for a single `oid` (and no results if there was no matching `oid`),
    it wouldn't be horrible to work with.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于仅`oid`值列表获取多个实例并没有太大的不同；它只是从检索具有匹配`oid`值的所有记录开始，然后整理数据并创建并返回实例列表。实际上，如果此过程和单个`oid`过程使用相同的代码，对于单个`oid`返回一个（或零）对象（如果没有匹配的`oid`则不返回结果），那么使用起来并不会太糟糕。
- en: 'Getting zero-to-many instances based on one local `criteria` value alone—finding
    an `Artisan` or `Product` by `company_name` or `name`, respectively, is also not
    difficult by itself. The actual process at the database side of the operation
    is significantly different from the pure `oid`-based retrievals, as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅基于一个本地`criteria`值获取零到多个实例——仅通过`company_name`或`name`找到`Artisan`或`Product`，本身也并不困难。数据库操作的实际过程与纯`oid`基础的检索有很大不同，如下所示：
- en: You find all of the matches based on the `criteria` passed, and keep track of
    the `oid` values for each match
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以根据传递的`criteria`找到所有匹配项，并跟踪每个匹配项的`oid`值
- en: Then, you return the items identified by those `oid` values
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，您返回由这些`oid`值标识的项目
- en: Finding items by `address` or `metadata` values is similar, but it gets the
    initial list of `oid` values identifying results from the child table.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`address`或`metadata`值查找项目类似，但它会从子表格获取结果的初始`oid`值列表。
- en: Getting multiple `criteria` values from a single table, parent, or child is
    yet another permutation that has to be handled.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单个表格、父表格或子表格获取多个`criteria`值，是另一个必须处理的排列。
- en: Another permutation is getting `criteria` values from parent and child tables
    in the same criteria set.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个排列是从父表格和子表格中获取`criteria`值在同一个条件集中。
- en: The preceding list shows six different variations that have to be accounted
    for, assuming that the intentions of `BaseDataObject.get` are honored. These don't
    address how updates to (or deletions of) data are handled across related tables,
    either, which adds more complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表显示了六种不同的变化，假设`BaseDataObject.get`的意图得到了尊重。这些并没有解决如何跨相关表处理数据的更新（或删除）的问题，这增加了更多的复杂性。
- en: While it may be possible to implement all of them in SQL on the database side,
    such an implementation is going to be complicated. If the developers aren't pretty
    experienced database administrators, it may not be feasible at all; and, even
    if it is, it will still be a complex solution, with all of the potential risks
    that follow.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能可以在数据库端的SQL中实现它们所有，但这样的实现将会很复杂。如果开发人员不是非常有经验的数据库管理员，这可能根本不可行；即使是，它仍然是一个复杂的解决方案，带有所有随之而来的潜在风险。
- en: 'A trade-off approach that could be easily implemented, but would incur more
    processing time and/or memory usage, would be similar to the approach taken in
    the Artisan Application: loading all of the objects for any call made to `BaseDataObject.get`,
    then sorting out the results in the code. As the dataset involved grows, the data
    being retrieved and sent back will grow, and the time required to usefully retrieve
    the data that isn''t just a simple "get me objects with any of these `oid` values" request
    will take longer to find in the database and transmit to the application. Given
    enough time, or enough data, it will start to suffer from scalability issues.
    This approach is probably feasible, and it will probably work (if for a limited
    time), provided that multi-table updates and the deletion of child records can
    be managed in some fashion. The updating side of things would probably be managed
    purely in the application code, and related record deletion could be managed on
    the database side or in the application code.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以很容易实现的权衡方法，但会增加更多的处理时间和/或内存使用，类似于Artisan应用程序中采用的方法：加载所有调用`BaseDataObject.get`的对象，然后在代码中对结果进行排序。随着涉及的数据集增长，检索和发送回的数据将增长，并且需要有用地检索数据的时间不仅仅是一个简单的“获取任何这些`oid`值的对象”请求将需要更长的时间在数据库中找到并传输到应用程序。足够的时间或足够的数据，它将开始遭受可扩展性问题。这种方法可能是可行的，它可能会起作用（如果有限的时间），只要多表更新和子记录的删除可以以某种方式进行管理。事情的更新方面可能纯粹由应用程序代码进行管理，相关记录的删除可以在数据库端或应用程序代码中进行管理。
- en: 'Another option that''s still in the realm of an RDBMS-based solution is to
    use an engine that has support for structured but schema-less data; MySQL and
    MariaDB, for example, have JSON field types that would allow entire Artisan and
    Product records to be represented with a very simple table structure, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仍处于基于RDBMS的解决方案领域的选项是使用支持结构化但无模式的数据的引擎；例如，MySQL和MariaDB具有JSON字段类型，可以使用非常简单的表结构表示整个Artisan和Product记录，如下所示：
- en: '![](assets/9ec76904-a53e-40de-886e-14cccfe3641d.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ec76904-a53e-40de-886e-14cccfe3641d.png)'
- en: Provided that those JSON fields allow for queries to execute against the data
    structure within them, all of the options that `BaseDataObject.get` needs to provide
    are supported, and without the concern of having to manage child tables. For all
    practical purposes, this specific approach would pretty much involve using MySQL
    as a replacement for a document store NoSQL database such as MongoDB, but without
    some of the functionality that a document store database likely already has.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这些JSON字段允许对其内部的数据结构执行查询，`BaseDataObject.get`需要提供的所有选项都得到支持，而无需担心管理子表。在所有实际目的上，这种特定方法基本上涉及使用MySQL替代文档存储NoSQL数据库（如MongoDB），但没有文档存储数据库可能已经具有的一些功能。
- en: All things considered, that's a lot of complexity that could be considered disadvantageous
    for an RDBMS-based data store. However, there are some advantages, too, even if
    they may not seem like significant ones at first glance. An RDBMS data store will
    generally allow for multiple queries to be executed in one pass. So, the multiple
    queries that are involved with the retrieval of data from multiple tables can
    be written as multiple query statements that are executed as a single call to
    the engine.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，这对于基于RDBMS的数据存储来说可能是一种被认为不利的复杂性。然而，也有一些优点，即使乍一看可能不那么重要。RDBMS数据存储通常允许一次执行多个查询。因此，从多个表中检索数据所涉及的多个查询可以编写为多个查询语句，作为对引擎的单个调用执行。
- en: 'Most SQL-based databases also allow for some sort of precompiled/prepared functionality
    to be written: stored procedures or user functions; views; and, perhaps, other
    constructs that can move substantial chunks of functionality out of the application
    code and into the database. Those are usually quicker to execute, and, although
    SQL may not support extensive functionality (even in procedures and functions),
    there might be enough available to make their use worthwhile. Finally, and perhaps
    most significantly, the enforced data structure of tables, combined with the relational capabilities
    of pretty much any RDBMS worthy of the name, allows for pretty much any data in
    the system to be queried as needed, while enforcing solid data integrity across
    all system data if the databases are reasonably well designed.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于SQL的数据库还允许编写某种预编译/准备好的功能：存储过程或用户函数；视图；也许还有其他构造，可以将大量功能块移出应用程序代码并移到数据库中。这些通常更快执行，尽管SQL可能不支持广泛的功能（即使在过程和函数中），但可能有足够的可用性使其使用值得。最后，也许最重要的是，表的强制数据结构，再加上任何名副其实的RDBMS的关系能力，允许在需要时查询系统中的任何数据，同时在合理设计的数据库中强制执行所有系统数据的数据完整性。
- en: 'If an SQL-based RDBMS were to be selected as the engine for object state data
    persistence, the classes that used that engine to persist their state data would
    need some (or all) of the following properties to be specified:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择基于SQL的RDBMS作为对象状态数据持久性的引擎，使用该引擎来持久化其状态数据的类将需要指定以下属性中的一些（或全部）。
- en: 'A `host` specification: The hostname (FQDN, machine network name, or IP address)
    where the database resides'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主机`规范：数据库所在的主机名（FQDN、机器网络名称或IP地址）'
- en: 'A `database` name: The name of the database on the specified host that state
    data will be read from and written to'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据库`名称：指定的主机上将读取和写入状态数据的数据库的名称'
- en: 'A `user`: This will be used to connect to the database on the host'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：这将用于连接到主机上的数据库'
- en: 'A `password`: This will be used to connect to the database on the host'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：这将用于连接到主机上的数据库'
- en: Instances would also need to be able to make connections to the database, which
    could be implemented with a method (`get_connection`, perhaps) or a property (`connection`,
    which could be lazily instantiated, and written so that an active `connection` could
    be deleted and recreated, when needed). It would also need a method to execute queries
    against the database once the connection had been established (`query`, perhaps).
    If this seems familiar, it's because this is the exact structure that was mentioned
    earlier, when discussing the idea of a `BaseDatabaseConnector` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实例还需要能够连接到数据库，这可以通过一个方法（也许是`get_connection`）或一个属性（`connection`，可以懒惰地实例化，并编写成当需要时可以删除并重新创建活动的`connection`）。一旦建立了连接，它还需要一个方法来对数据库执行查询（也许是`query`）。如果这看起来很熟悉，那是因为这正是之前提到的`BaseDatabaseConnector`类的确切结构。
- en: 'On the NoSQL side, all of the standard NoSQL advantages apply, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL方面，所有标准的NoSQL优势都适用，如下所示：
- en: Since there aren't any hard and fast table structures involved in the database,
    there's no significant development time required to make changes to the data structure
    being stored. Once the data structure at the application side has been changed,
    any new or updated records will be adjusted when they are saved.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据库中没有涉及硬性的表结构，因此在存储的数据结构发生变化时，不需要花费大量的开发时间。一旦应用程序端的数据结构发生了变化，任何新的或更新的记录在保存时都将进行调整。
- en: Most of the NoSQL options already have the functionality to deal with the sort
    of data retrieval that `BaseDataObject.get` is promising to provide, and that
    has so much potential complexity in a more traditional RDBMS solution. That will
    probably translate to less development time and simpler code to maintain, both
    of which are good things.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数NoSQL选项已经具有处理`BaseDataObject.get`所承诺提供的数据检索类型的功能，并且在传统的RDBMS解决方案中具有潜在的复杂性。这可能会导致开发时间更少，代码更简单，这两者都是好事。
- en: The data writing (creation and update) processes will be simpler to implement,
    as well, since the relationships that require separate tables or unusual data
    structures in an RDBMS-based approach just go away, really—data-writes can store
    an entire data structure all at once, and don't have to worry about making sure
    that failures in a child table prevent the parent table from being written to.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据写入（创建和更新）过程也将更容易实现，因为在基于RDBMS的方法中需要单独的表或不寻常的数据结构的关系实际上消失了，数据写入可以一次存储整个数据结构，而不必担心子表中的故障会阻止父表的写入。
- en: Of the two options, the NoSQL option feels like it will be easier to manage,
    while still fulfilling all of the requirements of the data persistence stories.
    Of the various NoSQL options, MongoDB feels like it will require the fewest changes
    to data structures, as object data is read from and written to the database; so,
    MongoDB will be the backend data store engine that we'll use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个选项中，NoSQL选项似乎更容易管理，同时仍能满足数据持久化故事的所有要求。在各种NoSQL选项中，MongoDB似乎需要对数据结构进行最少的更改，因为对象数据是从数据库中读取和写入的；因此，MongoDB将是我们将使用的后端数据存储引擎。
- en: The data access strategy for the Central Office projects
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Central Office项目的数据访问策略
- en: Having selected the database engine, another decision that needs to be made
    is where that engine will ultimately live, in relation to the Artisan Gateway
    and Central Office application. Both of those will need to be able to read and
    write the same data from the same location. Since MongoDB can be used across a
    network, the data store could live pretty much anywhere that's accessible over
    that network (even on the same machine as one of the two components).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了数据库引擎之后，需要做出的另一个决定是该引擎最终将在Artisan Gateway和Central Office应用程序的哪个位置存储。这两者都需要能够从相同的位置读取和写入相同的数据。由于MongoDB可以跨网络使用，数据存储可以几乎放在任何可以通过该网络访问的地方（甚至可以放在两个组件中的一个机器上）。
- en: 'The logical architecture perspective of the relationships between the Artisan
    Gateway, several instances of the Central Office application, and the `hms_sys` database,
    then, would look something like the following diagram (allowing for any number
    of application instances, but showing only three):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Artisan Gateway、多个Central Office应用程序实例和`hms_sys`数据库之间的逻辑架构视角将如下图所示（允许任意数量的应用程序实例，但仅显示三个）：
- en: '![](assets/c09ce12c-5347-4028-9c00-0886ac403358.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c09ce12c-5347-4028-9c00-0886ac403358.png)'
- en: The physical architecture is less significant from a development perspective,
    provided that each logical component has a readily identifiable physical location.
    During development, all of those physical locations can be on a developer's local
    computer. Once deployed, the Artisan Gateway service and the `hms_sys` database might
    be installed to different machines, or they might reside on the same machine.
    This arrangement would allow all of the application instances and the service
    to share common data, reading from and writing to the `hms_sys`database from wherever
    they might live.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，物理架构并不那么重要，只要每个逻辑组件都有一个可以轻松识别的物理位置。在开发过程中，所有这些物理位置都可以在开发人员的本地计算机上。一旦部署，Artisan
    Gateway服务和`hms_sys`数据库可能安装在不同的机器上，或者它们可能驻留在同一台机器上。这种安排将允许所有应用程序实例和服务共享公共数据，从它们可能存在的任何地方读取和写入`hms_sys`数据库。
- en: Supporting objects for data persistence
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持数据持久化的对象
- en: 'It''s almost unheard of for a database installation to not require some credentials
    for access in a production system, and there are other parameters that need to
    be kept track of across the various object types whose data will be saved in the
    data store. Since those parameters will be common for all of the different object
    types in use (for the most part), creating a mechanism that can be used to gather
    them all up seems like a logical first step. The common parameters that will most
    likely be needed were noted in the RDBMS exploration earlier, and are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，几乎不可能不需要一些访问凭据，还有其他需要跟踪的参数，这些参数将在各种对象类型中保存在数据存储中。由于这些参数对于所有不同的对象类型（大部分情况下）都是通用的，创建一个可以用来收集它们的机制似乎是一个合乎逻辑的第一步。在RDBMS的探索中已经注意到了可能需要的通用参数，如下所示：
- en: '`host`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`'
- en: '`port`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`'
- en: '`database`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database`'
- en: '`user`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`'
- en: '`password`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`'
- en: 'By the time `hms_sys` is deployed to a production environment, these will almost
    certainly be saved in some sort of configuration file, and it doesn''t hurt to
    get that logic in place now, rather than waiting to do so later. All of the data
    store configuration and connection parameters can be captured in a single object
    instance—a `DatastoreConfig`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到`hms_sys`部署到生产环境时，这些几乎肯定会保存在某种配置文件中，现在就把这个逻辑放在那里，而不是等到以后再做。所有数据存储配置和连接参数可以在一个单独的对象实例中捕获
    - 一个`DatastoreConfig`：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the exception of the `port` property, which only allows `int` values from `0` through `65535` (the
    normal range of valid ports in a TCP/IP connection), there''s nothing substantially
    new in the property getter-, setter-, and deleter-methods. The `_set_port` method''s
    value checking is very straightforward, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`port`属性之外，它只允许`int`值从`0`到`65535`（TCP/IP连接中有效端口的正常范围），在属性的获取器、设置器和删除器方法中没有什么实质性的新内容。`_set_port`方法的值检查非常简单，如下所示：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `__init__` method is also very straightforward, though it has no required
    arguments, because not all database engines will need all of the parameters, and
    the class is intended to be very generic. Connection issues that occur as a result
    of incomplete or invalid configuration will have to be handled at the relevant
    object level:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法也非常简单，尽管它没有必需的参数，因为并非所有数据库引擎都需要所有参数，而且该类旨在非常通用。由于不完整或无效的配置导致的连接问题将必须在相关对象级别处理：'
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since there will eventually be a need to read configuration data from a file,
    a class method (`from_config`) is defined to facilitate that, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最终将需要从文件中读取配置数据，因此定义了一个类方法（`from_config`）来方便这样做，如下所示：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The local MongoDB connections for development can then be created as instances
    of `DatastoreConfig`, with the minimum parameters needed to connect to a local
    database, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以创建用于连接到本地数据库的本地MongoDB连接，作为`DatastoreConfig`的实例，只需提供连接到本地数据库所需的最少参数，如下所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Reading and writing data against a Mongo database, using the `pymongo` library,
    requires a few steps, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pymongo`库对Mongo数据库进行读写数据需要一些步骤，如下所示：
- en: A connection to the Mongo engine has to be established (using a `pymongo.MongoClient` object).
    This is where the actual credentials (the username and password) will apply, if
    the Mongo engine requires them. The connection (or client) allows the specification of…
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须建立到Mongo引擎的连接（使用`pymongo.MongoClient`对象）。这是实际凭据（用户名和密码）将应用的地方，如果Mongo引擎需要它们的话。连接（或客户端）允许指定…
- en: The database where the data is being stored has to be specified. The `database` value
    in the configuration takes care of specifying the name of the database, and the
    database itself, a `pymongo.database.Database` object, once returned by the client/connection
    allows the creation of…
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须指定数据存储的数据库。配置中的`database`值负责指定数据库的名称，一旦由客户端/连接返回，数据库本身，一个`pymongo.database.Database`对象，允许创建…
- en: The collection where the actual documents (records) reside (a `pymongo.collection.Collection` object),
    and where all of the data access processes actually occur.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际文档（记录）所在的集合（一个`pymongo.collection.Collection`对象），以及所有数据访问过程实际发生的地方。
- en: 'A very simple, functional example of the connection/database/collection setup for `hms_sys` development
    might include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的、功能性的连接/数据库/集合设置的示例，用于`hms_sys`开发，可能包括以下内容：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, the `objects` object, as a Mongo `Collection`, provides methods
    for reading, writing, and deleting documents/records in the `Objects` collection/table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，作为Mongo `Collection`的`objects`对象提供了用于在`Objects`集合/表中读取、写入和删除文档/记录的方法。
- en: The organization of documents in a collection can be very arbitrary. That `objects` collection
    could be used to store `Artisan`, `Product`, and `Order` state data documents
    all in the same collection. There's no functional reason that prevents it. Over
    a long enough period of time, though, reading data from that collection would
    slow down more than reads from collections that, for example, grouped those same `Artisan`, `Product`, and `Order` state
    data documents into separate collections—one collection for each object type.
    There might be other considerations that will make such a grouping beneficial,
    as well. Keeping objects of the same type would probably make managing them through
    a GUI tool easier, and might be similarly beneficial for command-line management
    tools.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中文档的组织可以是非常任意的。`objects`集合可以用来存储`Artisan`、`Product`和`Order`状态数据文档，所有在同一个集合中。没有功能上的原因阻止这样做。然而，随着时间的推移，从该集合中读取数据的速度会比从将这些`Artisan`、`Product`和`Order`状态数据文档分组到单独的集合中的集合中读取的速度要慢得多
    - 每种对象类型一个集合。可能还有其他考虑因素会使这样的分组有益。将相同类型的对象保存在一起可能会使通过GUI工具更容易管理它们，并且对于命令行管理工具也可能有类似的好处。
- en: 'Taking all of the preceding factors together, a fairly optimal integration
    of data storage and parameters across the objects in the `hms_sys` data store
    would include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有前述因素，`hms_sys`数据存储中对象之间数据存储和参数的相对最佳集成应包括以下内容：
- en: One or more client connections to a common MongoDB instance, whose credentials
    and parameters are all configurable and are eventually controlled by a configuration
    file
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个客户端连接到一个共同的MongoDB实例，其凭据和参数都是可配置的，并最终由配置文件控制
- en: One database specification that is common to all of the objects in the Central
    Office code bases, from the same configuration that the client setup uses
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央办公室代码库中所有对象的一个通用数据库规范，与客户端设置使用的相同配置
- en: One collection specification per object type, which could be as simple as using
    the name of the class
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象类型的一个集合规范，可以简单地使用类的名称
- en: Having made all of these decisions, we can create an ABC that central-office
    application and service objects can derive from in much the same way that Artisan
    Application data objects derived from `JSONFileDataObject`, as we saw in [Chapter
    12](c68ea186-809d-4c66-aa38-737f4cb070d5.xhtml), *Persisting Object Data to Files,*—call
    it `HMSMongoDataObject`. Since it will need to be available to both the Artisan
    Gateway service and the Central Office application, it needs to live in a package
    that is available to both. Without creating another package project solely for
    this purpose, the logical place for it to live would be in a new module in `hms_core`;
    and, if the naming convention established in the Artisan code base is followed,
    that module would be named `data_storage.py`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出所有这些决定之后，我们可以创建一个ABC，中央办公室应用程序和服务对象可以从中派生，方式与Artisan应用程序数据对象从`JSONFileDataObject`派生的方式类似，就像我们在[第12章](c68ea186-809d-4c66-aa38-737f4cb070d5.xhtml)中看到的那样，称之为`HMSMongoDataObject`。由于它需要对Artisan网关服务和中央办公室应用程序都可用，因此它需要存在于两者都可用的包中。在不为此目的单独创建另一个包项目的情况下，它应该存在于`hms_core`中的一个新模块中；如果遵循Artisan代码库中建立的命名约定，该模块将被命名为`data_storage.py`。
- en: 'Diagrammed, the relationship between `HMSMongoDataObject` and the final central-office
    data objects looks much like the Artisan Application''s counterparts, although `hms_co` .. `Order` is
    not included, because it may need some special consideration that we haven''t
    explored:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图表，`HMSMongoDataObject`与最终的中央办公室数据对象之间的关系看起来很像Artisan应用程序的对应关系，尽管`hms_co`..
    `Order`没有包括在内，因为它可能需要一些特殊的考虑，我们还没有探讨过：
- en: '![](assets/3078d392-c757-4609-8df1-ee6480f254fe.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3078d392-c757-4609-8df1-ee6480f254fe.png)'
- en: 'The implementation of `HMSMongoDataObject` starts by inheriting from `BaseDataObject`,
    and then it includes the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMSMongoDataObject`的实现从`BaseDataObject`继承，然后包括以下内容：'
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we''ll be using a `DatastoreConfig` object to keep track of a common
    configuration for all derived classes, that becomes a class attribute (`_configuration`),
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`DatastoreConfig`对象来跟踪所有派生类的通用配置，因此它成为一个类属性（`_configuration`），如下所示：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'MongoDB documents, when they are created, have an `_id` value that, if passed
    to a normal `from_data_dict` to create an instance of the class, will throw an
    error. There hasn''t been an `_id` argument in any of our implementations so far,
    and there''s no reason to expect one to surface anywhere down the line, because
    we''re using our own `oid` property as the unique identifier for object records.
    In order to prevent that from happening, `from_data_dict` will need to either
    explicitly remove that `_id` value from its object creation process, or keep track
    of all of the valid arguments that can exist, and filter things accordingly. Of
    those two options, the latter, while slightly more complicated, also feels more
    stable. In the (unlikely) event that more fine-grained filtering of data is needed
    during object creation in `from_data_dict`, tracking the valid arguments will
    be easier to maintain than having to modify a long list of key removals:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建MongoDB文档时，它们会有一个`_id`值，如果将其传递给一个普通的`from_data_dict`来创建类的实例，就会抛出一个错误。到目前为止，我们的任何实现中都没有`_id`参数，并且没有理由期望在未来的任何地方出现它，因为我们正在使用我们自己的`oid`属性作为对象记录的唯一标识符。为了防止发生这种情况，`from_data_dict`需要明确地从其对象创建过程中删除`_id`值，或者跟踪所有可能存在的有效参数，并相应地过滤这些参数。在这两种选项中，后者虽然稍微复杂一些，但也更加稳定。在`from_data_dict`中需要更细粒度地过滤数据进行对象创建的（不太可能发生的）情况下，跟踪有效参数将比修改一个长列表的键移除更容易维护：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we have decided that all objects of any given type should live in a collection
    with a meaningful and related name, the approach that needs the least effort is
    simply using the class name as the name of the MongoDB collection that state data
    for instances of the class live in. We can''t rule out a potential need to change
    that, though, so another class attribute that allows that default behavior to
    be overridden feels like a sensible precaution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经决定，任何给定类型的对象都应该存储在一个有意义且相关的名称的集合中，需要最少努力的方法就是简单地使用类名作为MongoDB集合的名称，该集合存储了该类的实例的状态数据。但是，我们不能排除有可能需要更改这一点，因此另一个允许覆盖默认行为的类属性看起来像是一个明智的预防措施：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The properties of `HMSMongoDataObject` look relatively normal at first glance,
    but there is a significant difference that may not be obvious at first. Since
    data access for any given class is focused on instances of that class, and creation
    of database connections and collections could be computationally expensive, having
    a single connection for all data object classes is a tempting idea—that implementation
    would have the instance-level connection and database properties' underlying storage
    attributes be members of `HMSMongoDataObject`, not of the derived classes themselves,
    or instances of those classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMSMongoDataObject`的属性看起来乍一看相对正常，但有一个重要的区别可能一开始并不明显。由于任何给定类的数据访问都集中在该类的实例上，并且创建数据库连接和集合可能是计算密集型的，拥有所有数据对象类的单个连接是一个诱人的想法
    - 该实现将使实例级的`connection`和`database`属性的底层存储属性成为`HMSMongoDataObject`的成员，而不是派生类本身或这些类的实例。'
- en: 'That would, in effect, require that all data objects for `hms_sys` live in
    the same database and be accessed through the same MongoDB instance at all times.
    While that''s not an unreasonable requirement, it could make moving live system
    data problematic. The entire system might need to be shut down for such a data
    move. As a compromise, the `connection` and `database` properties of each class
    will be members of that class, instead – which would, for example, allow `Artisan` object
    data to be moved independently of `Product` data. This may not be a likely consideration
    in the near future of the system, but it doesn''t feel like a bad compromise to
    make if it has the potential of reducing effort somewhere down the line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将要求`hms_sys`的所有数据对象都驻留在同一个数据库中，并且始终通过相同的MongoDB实例访问。虽然这并不是一个不合理的要求，但可能会使移动实时系统数据变得棘手。整个系统可能需要关闭以进行此类数据移动。作为一种妥协，每个类的`connection`和`database`属性将成为该类的成员，而不是该类的成员
    - 例如，这将允许`Artisan`对象数据独立于`Product`数据进行移动。这在系统的不久的将来可能不是一个值得考虑的问题，但如果有可能在未来减少工作量，这并不是一个坏的妥协：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `collection`, `connection`, and `database` properties are also handled
    differently, for the purposes of deletion. The actual objects that are retrieved
    by the getter methods are lazily instantiated (created when they are needed, in
    order to reduce system load when they aren''t going to be used), and, because
    they don''t exist until they are first created (by a reference to them), it''s
    just easier to truly delete them, rather than set them to some default value,
    such as `None`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除，`collection`，`connection`和`database`属性也有不同的处理方式。由getter方法检索的实际对象是惰性实例化的（在需要时创建，以减少系统负载，当它们不会被使用时），因为它们直到首次创建（通过对它们的引用）才存在，所以真正删除它们比将它们设置为某些默认值（如`None`）更容易：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The property definitions are slightly different than what we''ve used in the
    past, because those properties can be retrieved or deleted, but not set. This
    corresponds to the idea that the database and collection can only be retrieved
    (opened) or closed (deleted). Accordingly, they have no setter methods defined
    or attached to the properties themselves, and the configuration property takes
    that a step further – it is read-only:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义与我们过去使用的略有不同，因为这些属性可以被检索或删除，但不能被设置。这对应于数据库和集合只能被检索（打开）或关闭（删除）的概念。因此，它们本身没有定义或附加setter方法，并且配置属性进一步采取了这一步
    - 它是只读的：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `__init__` method looks very much like the `__init__` method of `JSONFileDataObject`,
    with the same arguments (and for the same reasons). Since we have no properties
    that require default values to be set, however, the only thing that it needs to
    do is call its own parent constructor, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法看起来非常像`JSONFileDataObject`的`__init__`方法，具有相同的参数（出于相同的原因）。然而，由于我们没有需要设置默认值的属性，它唯一需要做的就是调用自己的父构造函数，如下所示：'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Like `JSONFileDataObject`, the `_create` and `_update` methods for `HMSMongoDataObject` aren''t
    necessary. MongoDB, like the JSON file approach that was used earlier, doesn''t
    distinguish between creating and updating a document. Both processes will simply
    write all of the object data to the document, creating it if necessary. Since
    they are required by `BaseDataObject` but aren''t of use in this context, the
    same implementation, simply raising an error with developer-useful information,
    will suffice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`JSONFileDataObject`一样，`HMSMongoDataObject`的`_create`和`_update`方法并不是必需的。MongoDB与之前使用的JSON文件方法一样，不区分创建和更新文档。两个过程都只是将所有对象数据写入文档，必要时创建文档。由于它们是`BaseDataObject`所需的，但在这种情况下没有用处，因此相同的实现，简单地引发一个带有开发人员有用信息的错误，就足够了：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The implementation of `save`, supported by the class-level `collection` and
    its `database` and `connection` ancestors, is very simple. We need to acquire
    the `data_dict` for the instance and tell the MongoDB connection to `insert` that
    data. The one complicating factor in this process is the standard MongoDB `_id` value
    that was mentioned earlier. If we did nothing more than calling `insert`, there
    would be no `_id` value for the MongoDB engine to use to identify that a document
    that already exists does, in fact, exist. The inevitable result of that would
    be the creation of new document records for existing items on every update (instead
    of replacing existing documents), polluting the data with out-of-date instances
    on every update.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由类级`collection`及其`database`和`connection`祖先支持的`save`的实现非常简单。我们需要获取实例的`data_dict`并告诉MongoDB连接`insert`该数据。这个过程中的一个复杂因素是之前提到的标准MongoDB`_id`值。如果我们仅仅调用`insert`，那么MongoDB引擎将没有`_id`值用于标识已经存在的文档是否实际存在。这将不可避免地导致在每次更新时为现有项目创建新的文档记录（而不是替换现有文档），从而在每次更新时污染数据，使其包含过时的实例。
- en: Under normal circumstances, the easiest solution for this would be to either
    change the `oid` property to `_id` during data writing processes and from `_id` back
    to `oid` during data reads, or to simply change the `oid` properties that have
    been established thus far to `_id` in the classes defined thus far. The first
    option would require only a bit of effort in each `to_data_dict` and `from_data_dict` method,
    including the ones already defined in the `Artisan` data objects, but it would tend
    to be more error-prone, as well, and it would require additional testing. It's
    a viable option, but it may not be the best one. Changing the names of the `oid` properties
    to `_id` across the board would be simpler (little more than a wide-scale search-and-replace
    operation, really), but it would leave the classes with what would look like a
    protected property name that would actually be a public property. Functionally,
    that's not such a big deal, but it flies in the face of Python code standards,
    and it is not a preferred option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，最简单的解决方案是在数据写入过程中将`oid`属性更改为`_id`，并在数据读取过程中将`_id`更改回`oid`，或者简单地将到目前为止已经建立的`oid`属性更改为类中已定义的`_id`。第一种选项只需要在每个`to_data_dict`和`from_data_dict`方法中稍微努力一下，包括已经在`Artisan`数据对象中定义的方法，但它往往更容易出错，而且需要额外的测试。这是一个可行的选择，但可能不是最好的选择。全面更改`oid`属性的名称为`_id`会更简单（实际上只是一个大规模的搜索和替换操作），但这将使类具有看起来像是受保护的属性名称，实际上是一个公共属性。从功能上讲，这并不是什么大问题，但它违反了Python代码标准，也不是一个首选选项。
- en: Another option is to simply assure that the `hms_sys oid` properties and the `_id` values
    that MongoDB generates are identical. While that does mean that individual document
    record sizes will increase, that change is trivial – on the order of 12 bytes
    per document record. Since that could be handled by the `save` method's process,
    as a simple addition to the `data_dict` value being saved (and would need to be
    ignored, or otherwise dealt with, during `from_data_dict` retrievals, as a part
    of that process), there would only be two places where it would have to be written
    or maintained.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是简单地确保`hms_sys oid`属性和MongoDB生成的`_id`值是相同的。虽然这意味着单个文档记录的大小会增加，但这种变化微不足道
    - 每个文档记录大约增加12个字节。由于这可以通过`save`方法的过程来处理，作为要保存的`data_dict`值的简单添加（并且在`from_data_dict`检索期间需要被忽略或以其他方式处理，作为该过程的一部分），因此只有两个地方需要编写或维护。
- en: 'That feels like a much cleaner option, even with the additional data being
    stored. The final implementation of `save`, then, would be as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使存储了额外的数据，这感觉上是一个更干净的选项。然后，`save`的最终实现将如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The corresponding change in `from_data_dict` uses the `_data_dict_keys` class
    attribute that was defined earlier. Since `_data_dict_keys` may not have been
    defined, but needs to be, checking that it''s been defined and raising a more
    detailed error message will make debugging those (hopefully rare) occasions easier.
    Once that''s been verified, the incoming `data_dict` will simply be filtered down
    to only those keys that match an argument in the `__init__` method of the class,
    and will be passed to `__init__` to create the relevant instance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_data_dict`中的相应更改使用了之前定义的`_data_dict_keys`类属性。由于`_data_dict_keys`可能没有被定义，但需要被定义，检查它是否已经被定义并提出更详细的错误消息将使得调试这些（希望是罕见的）情况更容易。一旦验证了这一点，传入的`data_dict`将被简单地过滤，只保留那些与类的`__init__`方法中的参数匹配的键，并将被传递给`__init__`来创建相关的实例：'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to allow all `HMSMongoDataObject`-derived classes to be configured
    at once, we need to provide a class method to that end. The one caveat to the
    implementation of this method is that all of the derived classes will also have
    the method available, but  the method changes the `_configuration` attribute of
    the `HMSMongoDataObject` class, even if it''s called from a derived class. It
    can be reasonably expected that calling, say, `Artisan.configure`, would configure
    data access for only `Artisan` objects – but that is not what should happen, so
    we''ll raise an error to make sure that it doesn''t go unnoticed if it''s attempted:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一次性允许所有`HMSMongoDataObject`派生类进行配置，我们需要提供一个类方法来实现这一点。这个方法的实现的一个注意事项是，所有派生类也将拥有这个方法，但是这个方法会改变`HMSMongoDataObject`类的`_configuration`属性，即使它是从一个派生类中调用的。可以合理地期望调用，比如`Artisan.configure`，只会为`Artisan`对象配置数据访问
    - 但这不是应该发生的，所以我们将引发一个错误，以确保如果尝试这样做，它不会被忽视：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since all of the class methods that interact with the data store will need
    the relevant connection, and it may not have been created by an instance before
    the call was made, having a helper class method to acquire the connection will
    be useful. It is also possible to force the acquisition of all of the relevant
    data store objects by creating an instance, but that feels cumbersome and counter-intuitive:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有与数据存储交互的类方法都需要相关的连接，并且在调用之前可能还没有被实例创建，因此有一个辅助类方法来获取连接将是有用的。也可以通过创建一个实例来强制获取所有相关的数据存储对象，但这感觉很麻烦和违反直觉：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementation of the `delete` class method is very simple; it boils down
    to iterating over the provided `oids`, and deleting each one in the iteration.
    Since `delete` is interacting with the data store, and it''s a class method, it
    calls the `get_mongo_collection` class method that we defined first:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`类方法的实现非常简单；它归结为遍历提供的`oids`，并在迭代中删除每一个。由于`delete`正在与数据存储交互，并且它是一个类方法，它调用了我们首先定义的`get_mongo_collection`类方法：'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result of a failed check of `_data_dict_keys` is an `AttributeError` that
    includes a list of the arguments of the `__init__` method of the class, using
    the `getfullargspec` function of the `inspect` module. Python's `inspect` module
    provides a very thorough set of functions for examining code within the code that's
    running. We'll take a more in-depth look at the module when we start to look at
    metaprogramming concepts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 失败检查`_data_dict_keys`的结果是一个`AttributeError`，其中包括类的`__init__`方法的参数列表，使用`inspect`模块的`getfullargspec`函数。Python的`inspect`模块提供了一套非常全面的函数，用于检查正在运行的代码。当我们开始研究元编程概念时，我们将更深入地研究该模块。
- en: 'The `get` method of `HMSMongoDataObject` also starts by assuring that the relevant `collection` is
    available. Structurally, it looks a lot like its counterpart in `JSONFileDataObject`,
    which should come as no great surprise, since it''s performing the same sort of
    actions, and uses the same method signature that was defined in `BaseDataObject`.
    Because MongoDB has more capabilities available than the file system, there are
    some noteworthy differences:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMSMongoDataObject`的`get`方法也是通过确保相关的`collection`可用来开始的。在结构上，它看起来很像`JSONFileDataObject`中的对应方法，这应该不会让人感到意外，因为它执行的是相同类型的操作，并且使用了在`BaseDataObject`中定义的相同方法签名。由于MongoDB具有比文件系统更多的功能，因此存在一些值得注意的区别：'
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rather than try to work out a (probably complex) mechanism for dynamically generating
    arguments for the `find` functionality of `pymongo` that include both `oids` and `criteria`,
    we'll handle requests based on the combination of `oids` and `criteria` that are
    present. Each branch in the code will result in a list of `data_dict` items that
    can be converted to a list of object instances later on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会尝试为`pymongo`的`find`功能动态生成包括`oids`和`criteria`的参数（可能是复杂的机制），我们将根据存在的`oids`和`criteria`的组合来处理请求。代码中的每个分支将导致一个`data_dict`项目列表，稍后可以将其转换为对象实例列表。
- en: 'If `oids` are provided, then the initial request will only concern itself with
    those. At present, the expectation is that `get` calls with `oids` will usually
    have only a few `oids` involved (usually just one, in fact), so using very basic
    functionality to get each document that corresponds to a single `oid` in the list
    should suffice, at least for now:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`oids`，那么初始请求将只涉及这些内容。目前，预期是使用`oids`进行的`get`调用通常只涉及到少量的`oids`（实际上通常只有一个），因此，使用非常基本的功能来获取与列表中单个`oid`对应的每个文档应该足够，至少目前是这样的：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If, somewhere down the line, there is a need to handle longer collections of `oids`, `pymongo` supports
    that, as well; so, we''ll leave a comment about that in place, just in case we
    need it later:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个地方需要处理更长的`oids`集合，`pymongo`也支持，因此，我们将留下一条关于这一点的评论，以防以后需要：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If `oids` and `criteria` are both provided, the eventual list of objects will
    need to be filtered with the `matches` method, so the presence of `criteria` will
    have to be monitored and tracked. If `oids` and `criteria` are both supplied,
    then we''ll need to know that later, in order to filter the initial results:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时提供了`oids`和`criteria`，则最终的对象列表将需要使用`matches`方法进行过滤，因此必须监视和跟踪`criteria`的存在。如果同时提供了`oids`和`criteria`，那么我们将需要在以后知道这一点，以便过滤初始结果：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If only `criteria` is passed, then the entire set of `data_dicts` can be retrieved
    with a single call, using a list comprehension to gather the found items from
    the cursor that `find` returns:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只传递了`criteria`，那么可以使用列表推导来一次性检索整个`data_dicts`集合，以收集`find`返回的游标中找到的项目：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If neither `oids` nor `criteria` is passed, then we will want to return everything
    available, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未传递`oids`或`criteria`，那么我们将希望返回所有可用的内容，如下所示：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the initial `data_dict` has been generated, it will be used to create
    the initial list of object instances, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了初始的`data_dict`，它将用于创建对象实例的初始列表，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And, if we still need to filter those results down even more (if we set `post_filter` to `True` earlier),
    then the same filter process that was used in `JSONFileDataObject` can be used
    now, calling the `matches` method of each object in the initial results and only
    adding it to the final results list if it returns `True`, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然需要进一步过滤这些结果（如果我们之前将`post_filter`设置为`True`），那么现在可以使用在`JSONFileDataObject`中使用的相同过滤过程，调用初始结果中每个对象的`matches`方法，仅当它返回`True`时将其添加到最终结果列表中，如下所示：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All of the basic CRUD operations that are needed for Artisan Gateway and Central
    Office data objects should be easy to implement at this point, by simply deriving
    them from the corresponding `Base` class in `hms_core` and `HMSMongoDataObject`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于Artisan Gateway和Central Office数据对象所需的所有基本CRUD操作应该很容易实现，只需从`hms_core`和`HMSMongoDataObject`中的相应`Base`类派生即可：
- en: Create and update operations still happen simply by calling the `save` method
    of any instance.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建和更新操作仍然只需调用任何实例的`save`方法即可完成。
- en: Read operations are handled by the `get` class method, which also allows for
    a fair bit of functionality for finding objects, though there might be the need
    for additional functionality that supports more complex capabilities later on.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取操作由`get`类方法处理，该方法还允许对查找对象进行相当多的功能，尽管以后可能需要支持更复杂功能的附加功能。
- en: Delete operations are handled by the `delete` class method; again, there may
    be the need for deletion capabilities that aren't based on the `oid`, but for
    now, this will suffice.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除操作由`delete`类方法处理；同样，可能会有基于`oid`以外的删除功能的需求，但目前这样就足够了。
- en: RDBMS implementations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDBMS实现
- en: So far, both of the data object implementations that we've created have overridden
    the `_create` and `_update` methods that were required in `BaseDataObject`. It
    would be fair, under the circumstances, to question why those were put in place
    at all. The short answer to that question is that both of the implementations
    that have come together so far use the same process at the data store level for
    creating and updating records and documents. As a result, they simply haven't
    been needed. If it was expected that `hms_sys` would never need any other database
    backend, we'd be justified in removing them from the entire code base.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的两个数据对象实现都覆盖了`BaseDataObject`中所需的`_create`和`_update`方法。在这种情况下，对于为什么要放置它们，可以提出质疑。对这个问题的简短回答是，到目前为止，已经合并在一起的两个实现在数据存储级别上使用了相同的过程来创建和更新记录和文档。因此，它们根本不需要。如果预期`hms_sys`永远不需要任何其他数据库后端，我们有理由从整个代码库中删除它们。
- en: However, what would've happened if the decision to use MongoDB had gone a different
    way, and the preferred (or mandated) backend data store engine was an RDBMS such
    as Microsoft SQL Server? Or, worse, what if that sort of change was mandated after the
    system was operational?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用MongoDB的决定走向不同的方向，并且首选（或强制）的后端数据存储引擎是诸如Microsoft SQL Server之类的RDBMS，那会发生什么呢？或者更糟糕的是，如果在系统运行之后强制进行这种改变会发生什么呢？
- en: 'Setting aside the data migration planning that would have to happen and focusing
    on only the application and service code, what would that kind of change require? Not
    much, when it comes right down to it. A generic SQL/RDBMS engine ABC (`HMSSQLDataObject`)
    might look something like the following, for a given RDBMS API/library:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时搁置数据迁移规划，专注于应用程序和服务代码，这种改变需要什么？实际上并不需要太多。对于给定的RDBMS API/库，通用的SQL/RDBMS引擎ABC（`HMSSQLDataObject`）可能看起来像下面这样：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `HMSSQLDataObject` class that is shown here is by no means complete, but
    should serve as a reasonable starting point for building a full implementation
    of such a class, which connects to and uses data from any of several RDBM systems.
    The complete code, such as it is, can be found in the `hms_core/ch-10-snippets` directory
    of the project code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`HMSSQLDataObject`类绝不是完整的，但应该作为构建这样一个类的完整实现的合理起点，该类连接到并使用来自多个RDBM系统的数据。完整的代码可以在项目代码的`hms_core/ch-10-snippets`目录中找到。
- en: 'The same `_configuration` class property would probably be in use, serving
    the same purpose. It''s possible that the `_data_dict_keys` class attribute would
    also be of use in reducing record fields to a valid argument dictionary in `from_data_dict`.
    Since SQL, for the various CRUD operations, or at least for specific starting
    points for those CRUD operations, would need to be stored and accessible to the
    classes, a viable option for doing so would be to attach them as class-attributes,
    as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`_configuration`类属性可能也在使用中，具有相同的目的。`_data_dict_keys`类属性也可能在`from_data_dict`中减少记录字段到有效参数字典中使用。由于SQL对于各种CRUD操作，或者至少对于这些CRUD操作的特定起始点，需要被存储并且可以被类访问，一个可行的选择是将它们作为类属性附加在一起：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the SQL for the various CRUD operations would include the tables that
    the data is stored in, and the process of connecting to the database in most RDBMS''
    handles the equivalents to the `connection` and `database` in our MongoDB approach,
    only the `connection` itself needs to be tracked and available as a property:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种CRUD操作的SQL将包括数据存储在其中的表，并且在大多数RDBMS中连接到数据库的过程处理了我们MongoDB方法中`connection`和`database`的等效部分，因此只需要跟踪和作为属性可用的是`connection`本身：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Like its equivalent in the Mongo-based implementation, a `connection` is lazily
    instantiated and performs an actual deletion, rather than resetting to default
    values, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于Mongo的实现相同，`connection`是懒惰实例化的，并执行实际删除，而不是重置为默认值，如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The related property declaration is identical, and is shown as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的属性声明是相同的，如下所示：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Object initialization is also identical, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化也是相同的，如下所示：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The significant, substantial differences are mostly in the methods that handle
    the CRUD operations. The original `save` method, as implemented in `BaseDataObject`,
    is left in place, and will call the `_create` or `_update` methods, as determined
    by the `is_dirty` or `is_new` property values for the instance. Each of these
    methods is responsible for acquiring the SQL template from the appropriate class
    attribute, populating it, as needed, with current state data values, sanitizing
    the resultant SQL, and executing it against the connection:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的、实质性的差异主要在处理CRUD操作的方法中。原始的`BaseDataObject`中实现的`save`方法保留在原地，并且将调用`_create`或`_update`方法，由实例的`is_dirty`或`is_new`属性值决定。这些方法中的每一个都负责从适当的类属性中获取SQL模板，根据需要填充当前状态数据值，对结果SQL进行清理，并针对连接执行它：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sanitizing SQL is a very important security precaution, reducing the risk of
    a system being vulnerable to an SQL injection attack. These attacks can compromise
    data confidentiality and integrity, at a minimum, and can also raise the risk
    of authentication and authorization compromises, perhaps even across multiple
    systems, depending on password policies and the enforcement of them. Most RDBMS
    APIs will have some mechanism for sanitizing SQL before executing it, and some
    will also support query parameterization that can also reduce the risk of vulnerabilities.
    As a basic rule of thumb, if data supplied by a user is being passed into a query,
    or even into a stored procedure, it should be sanitized wherever/whenever possible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清理SQL是非常重要的安全预防措施，减少系统容易受到SQL注入攻击的风险。这些攻击最少会危害数据的保密性和完整性，还可能提高认证和授权的风险，甚至可能跨多个系统，具体取决于密码策略及其执行。大多数RDBMS
    API在执行SQL之前都会有一些机制来清理SQL，有些还支持查询参数化，这也可以减少漏洞的风险。基本的经验法则是，如果用户提供的数据被传递到查询中，甚至传递到存储过程中，无论何时何地都应该尽可能地进行清理。
- en: 'The `delete` class method is simple:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`类方法很简单：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Most of the pattern and approach behind the `get` method should look familiar;
    again, it''s got the same signature (and is intended to perform the same activities)
    as the methods that have been created so far, which implement the required functionality
    of the `BaseDataObject`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法背后的模式和方法大部分应该看起来很熟悉；再次，它具有相同的签名（并且意图执行到目前为止已经创建的方法相同的活动），这些方法实现了`BaseDataObject`的所需功能：'
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The branch that handles `oid` requests is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`oid`请求的分支如下：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `criteria` branch is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`criteria`分支如下：'
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The default branch that simply gets everything else is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认分支只是获取其他所有内容如下：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All of the branches generate a list of `data_dict` values that can be used to
    create object instances, though they may not be returned from the backend data
    store as dictionary values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有分支都生成一个`data_dict`值列表，可用于创建对象实例，尽管它们可能不会作为字典值从后端数据存储返回。
- en: 'The lowest common denominator results of a query are, as noted in the preceding
    code comments, a tuple of tuples of tuples, which might look something like the
    following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的最低公共分母结果，如前面的代码注释中所述，是一组元组的元组，可能看起来像下面这样：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the engine, or the Python API to the engine, provides a built-in mechanism
    for converting rows returned into dictionary instances, that''s probably the preferred
    approach to use to make the conversion. If there isn''t anything built in to handle
    that, converting the nested tuples to a series of dictionaries isn''t difficult
    to do:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引擎或引擎的Python API提供了将返回的行转换为字典实例的内置机制，那可能是首选的方法。如果没有内置处理它的任何内容，将嵌套元组转换为一系列字典并不难做到：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From this point on, the process is pretty much the same as in the previous
    implementations, in `JSONFileDataObject` and `HMSMongoDataObject`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，过程基本上与以前的实现一样，在`JSONFileDataObject`和`HMSMongoDataObject`中：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another (potentially major) difference concerns how child objects, such as
    the `products` in an `Artisan` object, will have to be handled. If there is a
    need to fetch those child objects as objects and populate the parent object with
    them, assuming that they use the same `BaseDataObject`-derived interface, each
    child type will have a class associated with it, each of those classes will have
    a `get` method, and that `get` method will allow the `oid` of the parent object
    to be specified as criteria. That will allow for a process that looks like the
    following, used to retrieve and attach any child objects, as needed (using `Artisan` and `Product` classes
    as an example):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个（可能是主要的）区别在于如何处理子对象，例如`Artisan`对象中的`products`。如果需要获取这些子对象作为对象并将其填充到父对象中，假设它们使用相同的`BaseDataObject`派生接口，每个子类型将有一个与之关联的类，每个类都将有一个`get`方法，并且该`get`方法将允许指定父对象的`oid`作为条件。这将允许进行以下过程，用于检索和附加任何需要的子对象（以`Artisan`和`Product`类为例）：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The other members of a final business/data object class that derives from `HMSSQLDataObject` should,
    for the most part, be expected by now, since they are also required for the implementation
    of final data objects derived from the other two `DataObject` ABCs. They would
    include the concrete implementations of `to_data_dict` and `matches` instance
    methods and the `from_data_dict` class method, and the various class-specific
    variables (mostly the `_sql` class attributes).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从`HMSSQLDataObject`派生的最终业务/数据对象类的其他成员，大部分现在应该是预期的，因为它们也是从另外两个`DataObject` ABC派生的最终数据对象的实现所需的。它们将包括`to_data_dict`和`matches`实例方法的具体实现以及`from_data_dict`类方法，以及各种类特定变量（主要是`_sql`类属性）。
- en: The concrete business objects of the Central Office projects
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室项目的具体业务对象
- en: 'Up to this point, there''s been a lot of effort concerning the foundations,
    but it''s about to pay off, as the creation of the initial Central Office classes
    gets under way. At present, since the assumption is that the Central Office application
    and the Artisan Gateway service will be using the same business object classes,
    and that they need to reside in a common package that''s not a part of the package
    set for either of those code bases, the best option for where they should live
    appears to be in the `hms_core` component project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于基础设施已经付出了很多努力，但是随着最初的中央办公室类的创建开始，这些努力即将得到回报。目前，由于假设中央办公室应用程序和Artisan网关服务将使用相同的业务对象类，并且它们需要驻留在一个不是任何这些代码库的一部分的公共软件包中，它们应该驻留的最佳选择似乎是`hms_core`组件项目：
- en: It was already in the design plan for `hms_core` to be included as a part of
    the build or deployment of all the other packages, anyway
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_core`已经在设计计划中作为所有其他软件包的构建或部署的一部分'
- en: Although it would certainly be possible to create yet another component project/package
    specifically for the data access that these concrete classes will provide, that's
    a fair amount of overhead for what will probably be a single module, with only
    three classes (so far)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然肯定可以创建另一个专门用于这些具体类将提供的数据访问的组件项目/包，但对于可能只是一个单一模块，只有三个类（到目前为止），这是相当多的开销
- en: If, at some point in the future, there is a need or desire to move them to a
    different package/project—say, if it's decided to change the Central Office application's
    data access to a web service call to the Artisan Gateway—it won't be difficult to
    move the code accordingly, although it will be somewhat tedious.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来有需要或愿望将它们移动到不同的软件包/项目中——比如，如果决定将中央办公室应用程序的数据访问更改为对Artisan网关的网络服务调用，将相应地移动代码不难，尽管有些乏味。
- en: It will probably be easier to understand how the work regarding the foundations
    is going to pay off by diving right in to one of the concrete classes, so we'll
    do that now, starting with `hms_core.co_objects.Artisan`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过立即深入其中一个具体类，很可能更容易理解基础工作将如何得到回报，因此我们现在将这样做，从`hms_core.co_objects.Artisan`开始。
- en: hms_core.co_objects.Artisan
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_core.co_objects.Artisan
- en: 'The Story that''s driving the concrete, state data persisting `Artisan` class
    is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 推动具体的、状态数据持久化`Artisan`类的故事如下：
- en: As an Artisan manager, I need to be able to manage (create, modify, and delete)
    artisans in the system, so that their statuses and information can be kept current.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan经理，我需要能够管理（创建、修改和删除）系统中的工匠，以便保持其状态和信息的最新。
- en: 'As with the `hms_artisan` equivalent, this is about being able to manage the
    data, not the UI around that data management process. The various moving parts
    of any of the data objects in `co_objects` will involve the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与`hms_artisan`相同，这是关于能够管理数据，而不是围绕数据管理过程的UI。`co_objects`中任何数据对象的各种移动部分将涉及以下操作：
- en: The properties of the object type, which will originate with the corresponding `Base` class
    in `hms_core.business_objects`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型的属性，将源自`hms_core.business_objects`中相应的`Base`类
- en: The data persistence-related properties of all data objects in the system, provided
    or required by `HMSMongoDataObject` or its parent `BaseDataObject`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中所有数据对象的数据持久化相关属性，由`HMSMongoDataObject`或其父类`BaseDataObject`提供或需要
- en: Concrete implementations of any abstract members inherited by the concrete class,
    from any of the classes it derives from
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从具体类继承的任何抽象成员的具体实现，从它派生的任何类中继承
- en: 'Using the concrete `Artisan` class as an example, the relationships involved
    are shown in the following diagram:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以具体的`Artisan`类为例，涉及的关系如下图所示：
- en: '![](assets/70640dc2-a8ac-4d72-a723-f0708907ca20.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/70640dc2-a8ac-4d72-a723-f0708907ca20.png)
- en: In this particular case, there is only one property (the `_data_dict_keys` class
    attribute that needs to be overridden from `HMSMongoDataObject`) that needs to
    be created. Three of the four instance methods (`add_product` and `remove_product`,
    and `matches`) have concrete implementations in the abstract methods that require
    their implementation, and can be implemented as nothing more than a call to the
    original methods in the classes that they originate in.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，只有一个属性（需要从`HMSMongoDataObject`覆盖的`_data_dict_keys`类属性）需要创建。四个实例方法中的三个（`add_product`和`remove_product`以及`matches`）在需要实现它们的抽象方法中具有具体实现，并且可以实现为调用它们原始方法的一种方式。
- en: The `to_data_dict` method for any class deriving from `BaseDataObject` will
    have to be implemented locally (that's just the nature of the structure that's
    been developed), but that implementation is not going to be much more than creating
    and returning a `dict` value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从`BaseDataObject`派生的任何类的`to_data_dict`方法将需要在本地实现（这只是已经开发的结构的性质），但该实现不会比创建和返回`dict`值更多。
- en: That leaves `from_data_dict`, the class method that data objects use to create
    instances from dictionaries; those dictionaries are, in turn, being supplied by
    data retrievals from the backend data store. In cases where the data object doesn't
    have any child objects, the baseline method that `BaseDataObject` provides and
    requires should simply work as an inherited class method. Object types (such as `Artisan`)
    that do have child object properties will have to accommodate those, and that
    will happen as a local override of the original class method from `BaseDataObject`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的是`from_data_dict`，数据对象用它来从字典中创建实例；这些字典反过来是由后端数据存储的数据检索提供的。在数据对象没有任何子对象的情况下，`BaseDataObject`提供和需要的基线方法应该简单地作为继承类方法工作。具有子对象属性的对象类型（例如`Artisan`）将不得不适应这些属性，并且这将作为对`BaseDataObject`的原始类方法的本地覆盖发生。
- en: 'So, all told, implementing most of these data objects will only involve the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，实现大多数这些数据对象只需要以下操作：
- en: Creating the `_data_dict_keys` class attribute, which can (more or less) be
    copied and pasted from the argument list of the class' `__init__` method
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`_data_dict_keys`类属性，可以（或多或少地）从类的`__init__`方法的参数列表中复制并粘贴
- en: Implementing the `matches` method with a call to the method defined in `BaseDataObject` that
    carries through to `HMSMongoDataObject`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在`BaseDataObject`中定义的方法调用`matches`方法，该方法传递到`HMSMongoDataObject`
- en: Implementing `to_data_dict` from scratch
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始实现`to_data_dict`
- en: Implementing a `from_data_dict` class method from scratch, if a customized method
    is needed
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始实现`from_data_dict`类方法，如果需要自定义方法
- en: Creating an `__init__` method that shouldn't need to do anything more than call
    the relevant parent class `__init__` methods
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`__init__`方法，不需要做任何比调用相关父类`__init__`方法更多的事情
- en: For most classes, then, the worst-case scenario, to get from nothing to a full,
    concrete implementation, is two detailed methods to develop, and a few copy-and-paste
    operations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数类来说，从无到完整的最坏情况是开发两个详细的方法，以及一些复制粘贴操作。
- en: 'Those two methods play out in `hms_core.co_objects.Artisan`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在`hms_core.co_objects.Artisan`中发挥作用，如下所示：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `_data_dict_keys` object is a fairly trivial effort, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`_data_dict_keys`对象是相当简单的，如下所示：'
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `__init__` method still has a fairly complicated argument list, but they
    can be copied from their source classes whole-cloth, unless those source classes'' `__init__` methods
    have an argument list (`*products`, in this case) or a keyword argument list (which
    has been avoided, in order to keep `__init__` signatures as simple as possible):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法仍然具有相当复杂的参数列表，但它们可以整体从其源类中复制，除非这些源类的`__init__`方法有参数列表（在本例中为`*products`）或关键字参数列表（为了尽可能保持`__init__`签名的简单性而避免）：'
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The instance methods that can call the parent classes'' methods are all one-liners,
    returning the results of calling the parent class'' method with the appropriate
    arguments:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用父类方法的实例方法都是一行代码，返回使用适当参数调用父类方法的结果：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `to_data_dict` method could be daunting, but, since the sequence of the
    keys in the resultant dictionary is irrelevant, grouping them by the classes they
    originate from allows several of them (the data store-related ones) to be copied
    around as needed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: “to_data_dict”方法可能会让人望而生畏，但是，由于结果字典中键的顺序是无关紧要的，将它们按它们的来源类分组允许其中的一些（与数据存储相关的）根据需要进行复制：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In retrospect, it might have been a better design to provide a method or property
    of each of the classes that would be responsible for generating their part of
    a final `data_dict`. That would've kept the code for generating those dictionary
    items in a single place, at a minimum, and would've allowed the final `data_dict` values
    to be assembled from all of the parent class values for each instance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾来看，也许提供每个类的一个方法或属性来负责生成它们的一部分最终“data_dict”可能是更好的设计。这将使生成这些字典项的代码保持在一个地方，至少可以从所有实例的父类值中组装最终的“data_dict”值。
- en: 'The `from_data_dict` for the Artisan class uses the same logic and process
    as the original class method in `HMSMongoDataObject`, but has to account for the `address` property,
    which is either `None` or contains an `Address` instance:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “Artisan”类的“from_data_dict”使用与“HMSMongoDataObject”中原始类方法相同的逻辑和过程，但必须考虑“address”属性，该属性要么为“None”，要么包含一个“Address”实例：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With a total of seven items to implement concretely, and only two of them that
    aren't manageable by calling a parent class' equivalent or writing very simple
    code, the implementation is pretty painless.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有七个项目需要具体实现，只有两个项目不能通过调用父类的等效方法或编写非常简单的代码来管理，实现起来相当轻松。
- en: hms_core.co_objects.Product
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_core.co_objects.Product
- en: 'The corresponding Story for concrete `Product` object data persistence is as
    follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 具体“Product”对象数据持久性的相应故事如下：
- en: As a product manager, I need to be able to manage products in the system, so
    that their statuses and information can be kept current.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够在系统中管理产品，以便保持其状态和信息的最新状态。
- en: 'The code that fulfills this scenario is even simpler than the code for `Artisan` objects;
    it doesn''t need any special handling of object properties, so `from_data_dict` can
    simply fall back to the default, defined in `HMSMongoDataObject`. It doesn''t
    have any extraneous methods that are required, either, so a full, functional implementation
    really just boils down to the `_data_dict_keys` class attribute and the `__init__`, `matches`, and `to_data_dict` methods,
    with `matches` being implemented as a call to `HMSMongoDataObject.matches`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种情况的代码甚至比“Artisan”对象的代码更简单；它不需要对对象属性进行任何特殊处理，因此“from_data_dict”可以简单地回退到在“HMSMongoDataObject”中定义的默认值。它也不需要任何额外的必需方法，因此一个完整的、功能性的实现实际上只需要“_data_dict_keys”类属性和“__init__”、“matches”和“to_data_dict”方法，其中“matches”被实现为调用“HMSMongoDataObject.matches”：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `__init__` method has a long argument set, which should come as no surprise:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “__init__”方法具有很长的参数集，这应该不足为奇：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The implementations of `matches` and `to_data_dict` are very straightforward,
    as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: “matches”和“to_data_dict”的实现非常简单，如下所示：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `matches` method may need to be reexamined later on, either during the creation
    of the Artisan Gateway service or when the various application UIs are being built,
    because while it works for most cases, it will not currently allow a `get` with
    any metadata criteria to return results unless `criteria` is the only value being
    searched for (no `oids` are passed). It's worth a more detailed look here and
    now, though, because it shows some aspects of how the data object code interacts
    with MongoDB.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: “matches”方法可能需要在以后重新审视，无论是在创建Artisan Gateway服务时还是在构建各种应用程序UI时，因为虽然它对大多数情况都适用，但目前不允许使用任何元数据标准返回结果，除非“criteria”是唯一要搜索的值（不传递“oids”）。然而，现在和这里值得更详细地看一下，因为它显示了数据对象代码与MongoDB的交互的一些方面。
- en: 'First, let''s create some example `Product` objects and save them, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些示例“Product”对象并保存它们，如下所示：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finding products that have `metadata` indicating that they are made of silver
    and have sapphire gemstones is fairly straightforward, although it requires criteria
    specifications that look a little odd:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 查找具有指示它们由银制成并且带有蓝宝石宝石的“metadata”的产品是相当简单的，尽管需要看起来有点奇怪的标准规范：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Creating the criteria as a `dict` allows them to be passed to `Product.get` as
    a single keyword argument set, and allows the criteria specification to be as
    detailed as we need. We could, for example, add other metadata, specify a product
    name, or add any other object properties that appear in the `data-dict` representation
    of a `Product` (as returned by `to_data_dict`). The results will come back as
    a list of objects, and, by printing the `data-dict` representations of them, we
    can see the results:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准作为“dict”传递允许它们作为单个关键字参数集传递给“Product.get”，并允许标准规范尽可能详细。例如，我们可以添加其他元数据，指定产品名称，或添加出现在“Product”的“data-dict”表示中的任何其他对象属性（由“to_data_dict”返回）。结果将作为对象列表返回，并且通过打印它们的“data-dict”表示，我们可以看到结果：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Executing the preceding code yields the dataset for the one matching the `Product`,
    our silver and sapphire necklace, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码将产生与“Product”匹配的数据集，即我们的银色和蓝宝石项链，如下所示：
- en: '![](assets/6fc418fa-cac8-4245-a48a-50bb76a6b124.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6fc418fa-cac8-4245-a48a-50bb76a6b124.png)'
- en: 'It''s worth mentioning that passing `criteria` doesn''t have to be a multi-level `dict`,
    even for `metadata` values. Using `criteria` in this format is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，传递“criteria”不必是多级“dict”，即使对于“metadata”值也是如此。使用这种格式的“criteria”如下：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This criteria structure works just as well. The underlying `find()` method provided
    by a `pymongo connection` object treats **dot-notation** specifications of this
    sort as references to a nested object structure that looks much like the `dict` value
    shown previously, and will process the request accordingly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准结构同样有效。由“pymongo连接”对象提供的“find()”方法将这种类型的**点符号**规范视为对一个嵌套对象结构的引用，该结构看起来很像先前显示的“dict”值，并将相应地处理请求。
- en: Other hms_core.co_objects classes
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他hms_core.co_objects类
- en: 'There could have been Stories and tasks in this iteration to deal with the
    data persistence of `Customer` and `Order` objects, as well. Those would have
    probably taken the same basic shape as the stories for the `Artisan` and `Product` objects,
    looking something like the following `Order` example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，可能会有关于`Customer`和`Order`对象的故事和任务来处理数据持久性，这些故事可能会采用与`Artisan`和`Product`对象相同的基本形式，看起来类似于以下`Order`示例：
- en: As an order manager, I need to be able to manage orders in the system, so that
    their statuses and information can be kept current.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为订单经理，我需要能够管理系统中的订单，以便保持其状态和信息的最新。
- en: 'To do so, I would do the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我会做以下事情：
- en: Design and implement an `Order` class for the Central Office data store that
    allows object data to be persisted.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Central Office数据存储设计和实现一个`Order`类，允许对象数据持久化。
- en: Unit test the `Order` class.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`Order`类进行单元测试。
- en: Normally, in an Agile, iterative process, a story would have to be accepted
    before being included in an iteration, and the process of it being accepted would
    involved enough review and analysis that a full understanding of the tasks involved
    would be reached, and the stories and tasks written and planned accordingly. In
    this case, though, since there is a significant dependency on an external system
    (the Web Store Application) and on an order acceptance and processing workflow
    that hasn't been detailed yet, there's not a lot that can be done, beyond a bare-bones
    implementation of the `Customer` and `Order` classes. The workflow, in particular,
    was going to be somewhat dependent on the data structure that artisans need, which
    wasn't defined until this iteration.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在敏捷的迭代过程中，故事在被包含在迭代中之前必须被接受，并且其被接受的过程涉及足够的审查和分析，以达到对涉及的任务的充分理解，并相应地编写和计划故事和任务。然而，在这种情况下，由于对外部系统（Web
    Store Application）和尚未详细说明的订单接受和处理工作流程有重大依赖，除了对`Customer`和`Order`类进行基本实现之外，几乎没有什么可以做的。特别是工作流程将在某种程度上取决于工匠需要的数据结构，而这在本次迭代之前尚未定义。
- en: For all of the preceding reasons, there are no stories to deal with these objects
    and their data persistence in this iteration. The data persistence aspects of
    the final classes created for the Artisan Gateway and/or Central Office application
    will be handled as parts of stories to implement the order processing workflow.
    In the meantime, though, we can at least stub out the bare minimum structure for
    those classes in a separate file (in `future/co_objects.py`, in the code for this
    chapter) while the data object definition process is fresh in our minds, to save
    some effort later.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述所有原因，本次迭代中没有处理这些对象及其数据持久性的故事。Artisan Gateway和/或Central Office应用程序创建的最终类的数据持久性方面将作为实现订单处理工作流程的故事的一部分来处理。与此同时，我们可以至少在单独的文件中（在本章的代码中的`future/co_objects.py`中）为这些类的最低结构制作存根，以便在我们的记忆中保存一些努力。
- en: Accounting for the other CRUD operations
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑其他CRUD操作
- en: 'Up to this point, we''ve only accounted for two of the CRUD operations that
    all of our data objects need: `create` and `read`. The `delete` operations, across
    the board, are accounted for, but not yet proven; however, since that process
    is very simple, it can wait until we unit test everything, to prove that everything
    works. The missing item, then, is the `update` operation, at least in part. The
    various object documents that have been written to the database with every `save()` call
    have shown that the process of writing object data is working, but we haven''t
    actually tried to update anything yet; and, if we were to try now, it would fail
    (and fail silently). The reason behind that failure is very simple, and can be
    seen in the code from `HMSMongoDataObject.save`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了所有数据对象需要的两个CRUD操作：`create`和`read`。删除操作已经被考虑，但尚未被证明；然而，由于该过程非常简单，可以等到我们对所有内容进行单元测试，以证明一切正常。那么缺失的部分就是`update`操作，至少在某种程度上。已经使用每个`save()`调用将各种对象文档写入数据库，显示了写入对象数据的过程正在进行，但我们实际上还没有尝试过更新任何内容；如果我们现在尝试，它将失败（并且会默默失败）。失败的原因非常简单，可以在`HMSMongoDataObject.save`的代码中看到：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In a nutshell, it's because we're checking for the status of `_is_new` and `_is_dirty`,
    and only calling the database write if one of them is `True`. By default, when
    a data object is created, its `_is_dirty` flag value is set to `False`. If that
    value doesn't get changed somewhere along the line, when an object's property
    values are altered, the `save` method will never actually write the changed dataset
    to the database.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是因为我们正在检查`_is_new`和`_is_dirty`的状态，并且只有在其中一个为`True`时才调用数据库写入。默认情况下，当创建数据对象时，其`_is_dirty`标志值被设置为`False`。如果该值在某个地方没有改变，当对象的属性值被改变时，`save`方法将永远不会实际将更改的数据集写入数据库。
- en: 'There are at least two different ways to resolve this. The more complex solution
    would be to redefine each of the setter and deleter methods for each property
    of each concrete data object class, and the property declarations for each of
    them, so that the methods call their parent methods and the instance''s `_set_is_dirty` methods
    in the process. This is the approach that was taken for the corresponding objects
    in the Artisan project. See the following code snippet, which uses the `Product.name` property
    as an example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种不同的解决方法。更复杂的解决方案是重新定义每个具体数据对象类的每个属性的setter和deleter方法，以及每个属性的声明，使得这些方法调用它们的父方法和实例的`_set_is_dirty`方法。这是Artisan项目中相应对象采取的方法。请参阅以下代码片段，其中使用`Product.name`属性作为示例：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Taking this approach would not be difficult (or even terribly time-consuming),
    but it would add some additional unit testing requirements, since each of those
    method and property overrides would register as new, local class members that
    need to be tested. That's not a bad thing, though, since those tests would ultimately
    only be concerned with verifying that the `is_dirty` state change happened when
    it was supposed to.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法并不困难（甚至不会太费时），但它会增加一些额外的单元测试要求，因为每个方法和属性覆盖都将注册为新的本地类成员，需要进行测试。不过，这并不是坏事，因为这些测试最终只关注验证`is_dirty`状态变化是否发生在应该发生的时候。
- en: 'The other approach would be to simply remove the `is_new` and `is_dirty` check
    condition from `HMSMongoDataObject.save`. That is a much simpler solution, in
    many respects, but it comes with at least one caveat: it puts the responsibility
    of making sure that the `save` of any changed object is called in the code that''s
    making those changes. Without some careful monitoring of how and when the code
    is making and saving changes, there is a good possibility that many `save` calls
    will be made, incrementally updating the data document for any given object. That
    may or may not be a significant concern (it''s unlikely to have a significant
    impact on performance for small sets of data changes, for example), but it could
    get out of control quickly, if not closely monitored. If the data store had a
    cost per query associated with it, as unlikely as that might seem, that inefficiency
    would also cost more `money` on a long-term basis.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是从`HMSMongoDataObject.save`中简单地移除`is_new`和`is_dirty`的检查条件。在许多方面，这是一个更简单的解决方案，但至少有一个警告：这样做会使得确保在进行更改的代码中调用任何更改对象的`save`的责任。如果不仔细监控代码进行更改和保存的方式和时间，很可能会进行许多`save`调用，逐步更新给定对象的数据文档。这可能是一个重要的问题（例如，对于小数据更改集，它不太可能对性能产生重大影响），但如果不进行密切监控，它可能会迅速失控。如果数据存储与查询相关联的成本，尽管这看起来不太可能，这种低效性也将在长期基础上造成更多的成本。
- en: 'Since the actual use cases involving updating the data haven''t yet been developed
    (or even had stories presented that could guide the decision), for now, in order
    to close these stories, the latter solution will be taken. This keeps things simple
    for the time being, and we know what will be involved for a more complex solution,
    should the need for it arise. That, then, revises `HMSMongoDataObject.save` as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及更新数据的实际用例尚未开发（甚至没有提出可以指导决策的故事），为了关闭这些故事，暂时采用后一种解决方案。这样可以简化事情，我们知道如果需要更复杂的解决方案，将会涉及哪些内容。这样，`HMSMongoDataObject.save`将被修改如下：
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As with the Artisan Application's data persistence, we've accounted for (if
    not proven) all of the CRUD operation requirements for data objects living in
    the Central Office code bases. Because the interface requirements are also defined
    by the same `BaseDataObject` inheritance, even though there is additional functionality
    provided between that ABC and the concrete data objects, the processes for reading
    and writing data across all of the data objects look the same across the entire
    system – at least so far.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与Artisan Application的数据持久化一样，我们已经考虑（如果不是证明）了中央办公室代码库中存储的数据对象的所有CRUD操作要求。因为接口要求也由相同的`BaseDataObject`继承定义，即使在该ABC和具体数据对象之间提供了额外功能，所有数据对象的读取和写入过程在整个系统中看起来都是相同的
    - 至少目前是这样。
- en: None of the data access has been unit tested yet, however, and that's a critical
    item for the system; at the end of the day, the data is, if not the most important
    part of the system, certainly one of the most import aspects of it. It's time,
    then, to change the context and write those unit tests, which we'll do in the
    next chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据访问尚未进行单元测试，但这对于系统来说是一个关键问题；归根结底，数据是系统中最重要的部分，如果不是最重要的部分，那么肯定也是其中最重要的部分之一。因此，现在是时候改变上下文并编写这些单元测试了，我们将在下一章中进行。
