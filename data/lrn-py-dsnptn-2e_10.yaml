- en: Chapter 10. The State Design Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。状态设计模式
- en: In this chapter, we will cover the State design pattern. Like the Command or
    Template design patterns, State pattern falls under the hood of Behavioral patterns.
    You will be introduced to the State design pattern, and we will discuss how it
    is used in software application development. We will work with a sample use case,
    a real-world scenario, and implement this in Python v3.5\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍状态设计模式。像命令或模板设计模式一样，状态模式属于行为模式。您将了解状态设计模式，我们将讨论它在软件开发中的应用。我们将使用一个示例用例、一个现实世界场景，并在Python
    v3.5中实现它。
- en: 'We will briefly cover these topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下主题：
- en: Introduction to the State design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态设计模式简介
- en: The State design pattern and its UML diagram
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态设计模式及其UML图
- en: A real-world use case with the Python v3.5 code implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有Python v3.5代码实现的现实世界用例
- en: 'State pattern: advantages and disadvantages'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式：优点和缺点
- en: At the end of this chapter, you will appreciate the application and context
    of the State design pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将欣赏到状态设计模式的应用和上下文。
- en: Defining the State design pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义状态设计模式
- en: Behavioral patterns focus on the responsibilities that an object has. They deal
    with the interaction among objects to achieve larger functionality. The State
    design pattern is a Behavioral design pattern, which is also sometimes referred
    to as an **objects for states** pattern. In this pattern, an object can encapsulate
    multiple behaviors based on its internal state. A State pattern is also considered
    as a way for an object to change its behavior at runtime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式关注对象所具有的职责。它们处理对象之间的交互以实现更大的功能。状态设计模式是一种行为设计模式，有时也被称为**对象状态模式**。在这个模式中，一个对象可以根据其内部状态封装多个行为。状态模式也被认为是一种对象在运行时改变其行为的方式。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Changing behavior at runtime is something that Python excels at!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时更改行为是Python擅长的！
- en: For example, consider the case of a simple radio. A radio has AM/FM (a toggle
    switch) channels and a scan button to scan across multiple FM/AM channels. When
    a user switches on the radio, the base state of the radio is already set (say,
    it is set to FM). On clicking the Scan button, the radio gets tuned to multiple
    valid FM frequencies or channels. When the base State is now changed to AM, the
    scan button helps the user to tune into multiple AM channels. Hence, based on
    the base state (AM/FM) of the radio, the scan button's behavior dynamically changes
    when tuning into AM or FM channels.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单收音机的案例。收音机有AM/FM（一个切换开关）频道和一个扫描按钮来扫描多个FM/AM频道。当用户打开收音机时，收音机的初始状态已经设置（比如说，设置为FM）。点击扫描按钮时，收音机会被调谐到多个有效的FM频率或频道。当基本状态现在变为AM时，扫描按钮帮助用户调谐到多个AM频道。因此，基于收音机的初始状态（AM/FM），当调谐到AM或FM频道时，扫描按钮的行为会动态改变。
- en: Thus, the State pattern allows an object to change its behavior when its internal
    state changes. It will appear as though the object itself has changed its class.
    The State design pattern is used to develop Finite State Machines and helps to
    accommodate State Transaction Actions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，状态模式允许对象在内部状态改变时改变其行为。这会给人一种对象本身已经改变了其类的感觉。状态设计模式用于开发有限状态机，并有助于适应状态事务操作。
- en: Understanding the State design pattern
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态设计模式
- en: 'The State design patterns works with the help of three main participants:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式通过与三个主要参与者合作工作：
- en: '`State`: This is considered to be an interface that encapsulates the object''s
    behavior. This behavior is associated with the state of the object.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`：这被认为是一个封装对象行为的接口。这种行为与对象的状态相关联。'
- en: '`ConcreteState`: This is a subclass that implements the `State` interface.
    `ConcreteState` implements the actual behavior associated with the object''s particular
    state.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`具体状态`：这是一个实现`状态`接口的子类。`具体状态`实现了与对象特定状态相关的实际行为。'
- en: '`Context`: This defines the interface of interest to clients. `Context` also
    maintains an instance of the `ConcreteState` subclass that internally defines
    the implementation of the object''s particular state.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`上下文`：这定义了客户端感兴趣的接口。`上下文`还维护一个`具体状态`子类的实例，该实例内部定义了对象特定状态的实施。'
- en: 'Let''s take a look at the structural code implementation of the State design
    pattern with these three participants. In this code implementation, we define
    a `State` interface that has a `Handle()` abstract method. The `ConcreteState`
    classes, `ConcreteStateA` and `ConcreteStateB`, implement the State interface
    and, thus, define the `Handle()` methods specific to the `ConcreteState` classes.
    So, when the `Context` class is set for a state, the `Handle()` method of this
    state''s `ConcreteClass` gets called. In the following example, since `Context`
    is set to `stateA`, the `ConcreteStateA.Handle()` method gets called and prints
    `ConcreteStateA`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这三个参与者（`State`、`ConcreteStateA` 和 `ConcreteStateB`）的结构代码实现。在这个代码实现中，我们定义了一个
    `State` 接口，它有一个 `Handle()` 抽象方法。`ConcreteState` 类，`ConcreteStateA` 和 `ConcreteStateB`，实现了
    `State` 接口，因此定义了针对 `ConcreteState` 类的特定 `Handle()` 方法。因此，当 `Context` 类设置一个状态时，该状态的
    `ConcreteClass` 的 `Handle()` 方法会被调用。在以下示例中，由于 `Context` 设置为 `stateA`，因此会调用 `ConcreteStateA.Handle()`
    方法并打印 `ConcreteStateA`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will see the following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '![Understanding the State design pattern](img/00040.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![理解状态设计模式](img/00040.jpeg)'
- en: Understanding the State design pattern with a UML diagram
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 UML 图解理解状态设计模式
- en: 'As we saw in the previous section, there are three main participants in the
    UML diagram: `State`, `ConcreteState`, and `Context`. In this section, we will
    try to manifest them on a UML class diagram.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，UML 图中有三个主要参与者：`State`、`ConcreteState` 和 `Context`。在本节中，我们将尝试在一个 UML 类图中体现它们。
- en: '![Understanding the State design pattern with a UML diagram](img/00041.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![使用 UML 图解理解状态设计模式](img/00041.jpeg)'
- en: 'Let''s understand the elements of UML diagram in detail:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解 UML 图的元素：
- en: '`State`: This is an interface that defines the `Handle()` abstract method.
    The `Handle()` method needs to be implemented by `ConcreteState`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`：这是一个定义 `Handle()` 抽象方法的接口。`Handle()` 方法需要由 `ConcreteState` 实现。'
- en: '`ConcreteState`: In this UML diagram, we have defined two `ConcreteClasses`:
    `ConcreteStateA`, and `ConcreteStateB`. These implement the `Handle()` method
    and define the actual action to be taken based on the `State` change.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteState`：在这个 UML 图中，我们定义了两个 `ConcreteClasses`：`ConcreteStateA` 和 `ConcreteStateB`。这些实现了
    `Handle()` 方法，并定义了基于 `State` 变化的实际操作。'
- en: '`Context`: This is a class that accepts the client''s request. It also maintains
    a reference to the object''s current state. Based on the request, the concrete
    behavior gets called.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context`：这是一个接受客户端请求的类。它还维护对对象当前状态的引用。根据请求，调用具体行为。'
- en: A simple example of the State design pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式的一个简单示例
- en: Let's understand all three participants with a simple example. Say, we want
    to implement a TV remote with a simple button to perform on/off actions. If the
    TV is on, the remote button will switch off the TV and vice versa. In this case,
    the `State` interface will define the method (say, `doThis()`) to perform actions
    such as switching on/off the TV. We also need to define `ConcreteClass` for different
    states. In this example, we have two major states, `StartState` and `StopState`,
    which indicate when the TV is switched on and the state in which the TV is switched
    off, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单示例来理解所有三个参与者。比如说，我们想要实现一个带有简单按钮的电视遥控器来执行开关操作。如果电视开启，遥控器按钮将关闭电视，反之亦然。在这种情况下，`State`
    接口将定义一个方法（比如 `doThis()`）来执行开关电视等操作。我们还需要为不同的状态定义 `ConcreteClass`。在这个例子中，有两个主要状态，`StartState`
    和 `StopState`，分别表示电视开启和关闭的状态。
- en: 'For this scenario, the `TVContext` class will implement the `State` interface
    and keep a reference to the current state. Based on the request, `TVContext` forwards
    the request to `ConcreteState`, which implements the actual behavior (for a given
    state) and performs the necessary action. So, in this case, the base state is
    `StartState` (as defined earlier) and the request received by the `TVContext`
    class is to switch Off the TV. `TVContext` class understands the need and accordingly
    forwards the request to `StopState` concrete class which inturn calls the `doThis()`
    method to actually switch off the TV:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，`TVContext` 类将实现 `State` 接口并保持对当前状态的引用。根据请求，`TVContext` 将请求转发给 `ConcreteState`，它实现了实际行为（对于给定状态）并执行必要的操作。因此，在这种情况下，基本状态是
    `StartState`（如前所述），而 `TVContext` 类接收到的请求是关闭电视。`TVContext` 类理解了需求，并相应地将请求转发给 `StopState`
    具体类，该类进而调用 `doThis()` 方法来实际关闭电视：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the output for the preceding code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![A simple example of the State design pattern](img/00042.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![状态设计模式的一个简单示例](img/00042.jpeg)'
- en: The State design pattern with v3.5 implementation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有v3.5实现的State设计模式
- en: Let's now take a look at a real-world use case for the State design pattern.
    Think of a computer system (desktop/laptop). It can have multiple states such
    as `On`, `Off`, `Suspend`, or `Hibernate`. Now, if we want to manifest these states
    with the help of State design pattern, how will we do it?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看状态设计模式在现实世界中的一个实际应用案例。想象一个计算机系统（台式机/笔记本电脑）。它可以有多个状态，例如`On`、`Off`、`Suspend`或`Hibernate`。现在，如果我们想借助状态设计模式来体现这些状态，我们将如何操作？
- en: 'Say, we start with the `ComputerState` interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，我们从`ComputerState`接口开始：
- en: The state should define two attributes, which are `name` and `allowed`. The
    `name` attribute represents the state of the object, and `allowed` is a list that
    defines the state's object, which it is allowed to get into.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态应该定义两个属性，即`name`和`allowed`。`name`属性代表对象的状态，而`allowed`是一个列表，定义了状态可以进入的对象状态。
- en: The state must define a `switch()` method, which will actually change the state
    of the object (in this case, the computer).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态必须定义一个`switch()`方法，这个方法实际上会改变对象的状态（在这个例子中，是电脑）。
- en: 'Let''s take a look at the code implementation of the `ComputerState` interface:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ComputerState`接口的代码实现：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now take a look at `ConcreteState`, which implements the `State` interface.
    We will define four states:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现`State`接口的`ConcreteState`。我们将定义四个状态：
- en: '`On`: This switches *on* the computer. The allowed states here are `Off`, `Suspend`,
    and `Hibernate`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`On`：这个操作将电脑**开启**。这里允许的状态是`Off`、`Suspend`和`Hibernate`。'
- en: '`Off`: This switches *off* the computer. The allowed state here is just `On`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Off`：这个操作将电脑**关闭**。这里允许的状态仅仅是`On`。'
- en: '`Hibernate`: This state puts the computer in the *hibernate* mode. The computer
    can only get switched on when it''s in this state.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hibernate`：这个状态将电脑置于**休眠**模式。电脑只有在处于这个状态下才能被开启。'
- en: '`Suspend`: This state *suspends* the computer, and once the computer is suspended,
    it can be switched on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspend`：这个状态将电脑**挂起**，一旦电脑被挂起，就可以将其开启。'
- en: 'Let''s now take a look at the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we explore the context class (`Computer`). The context does two main things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们探索上下文类（`Computer`）。上下文执行两个主要操作：
- en: '`__init__()`: This method defines the base state of the computer'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`: 这个方法定义了电脑的基态'
- en: '`change()`: This method will change the state of the object, and the actual
    change in behavior is implemented by the `ConcreteState` classes (`on`, `off`,
    `suspend`, and `hibernate`)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change()`：这个方法将改变对象的状态，实际的行为改变由`ConcreteState`类（`on`、`off`、`suspend`和`hibernate`）实现'
- en: 'Here is the implementation of the preceding methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面方法的实现：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the code for the client. We create the object of the `Computer`
    class (`Context`) and pass a state to it. The state can be either of these: `On`,
    `Off`, `Suspend`, and `Hibernate`. Based on the new state, the context calls its
    `change(state)` method, which eventually switches the actual state of the computer:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是客户端的代码。我们创建`Computer`类（上下文）的对象，并将一个状态传递给它。状态可以是以下之一：`On`、`Off`、`Suspend`和`Hibernate`。根据新的状态，上下文调用其`change(state)`方法，最终切换电脑的实际状态：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can observe the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以观察到以下输出：
- en: '![The State design pattern with v3.5 implementation](img/00043.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![带有v3.5实现的State设计模式](img/00043.jpeg)'
- en: '`__class__` is a built-in attribute of every class. It is a reference to the
    class. For instance, `self.__class__.__name__` represents the name of the class.
    In this example, we use `__class__ attribute` of Python to change the `State`.
    So, when we pass the state to the `change()` method, the class of the objects
    gets dynamically changed at runtime. The `comp.change(On)` code, changes the object
    state to `On` and subsequently to different states like `Suspend`, `Hibernate`,
    and `Off`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`__class__`是每个类的内置属性。它是对类的引用。例如，`self.__class__.__name__`代表类的名称。在这个例子中，我们使用Python的`__class__`属性来改变`State`。因此，当我们向`change()`方法传递状态时，对象的类在运行时会被动态地改变。`comp.change(On)`代码将对象状态更改为`On`，随后更改为不同的状态，如`Suspend`、`Hibernate`和`Off`。'
- en: Advantages/disadvantages of the State pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式的优缺点
- en: 'Here are the benefits of the State design pattern:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是状态设计模式的优点：
- en: In the State design pattern, an object's behavior is the result of the function
    of its state, and the behavior gets changed at runtime depending on the state.
    This removes the dependency on the if/else or switch/case conditional logic. For
    example, in the TV remote scenario, we could have also implemented the behavior
    by simply writing one class and method that will ask for a parameter and perform
    an action (switch the TV on/off) with an `if`/`else` block.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在状态设计模式中，对象的行为是其状态的函数结果，并且行为会根据状态在运行时改变。这消除了对if/else或switch/case条件逻辑的依赖。例如，在电视遥控器场景中，我们也可以通过简单地编写一个类和方法来实现行为，该方法将请求一个参数并执行一个动作（打开/关闭电视），使用`if`/`else`块。
- en: With State pattern, the benefits of implementing polymorphic behavior are evident,
    and it is also easier to add states to support additional behavior.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态模式，实现多态行为的优势显而易见，并且添加状态以支持额外行为也更加容易。
- en: The State design pattern also improves **Cohesion** since state-specific behaviors
    are aggregated into the `ConcreteState` classes, which are placed in one location
    in the code.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态设计模式还通过将特定状态的行为聚合到`ConcreteState`类中，这些类被放置在代码的一个位置，从而提高了**内聚性**。
- en: With the State design pattern, it is very easy to add a behavior by just adding
    one more `ConcreteState` class. State pattern thus improves the flexibility to
    extend the behavior of the application and overall improves code maintenance.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态设计模式，通过添加一个额外的`ConcreteState`类，就可以很容易地添加一个行为。因此，状态模式提高了扩展应用行为的能力，并总体上提高了代码的可维护性。
- en: 'We have seen the advantages of state patterns. However, they also have a few
    pitfalls:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了状态模式的优点。然而，它们也有一些陷阱：
- en: '**Class Explosion**: Since every state needs to be defined with the help of
    `ConcreteState`, there is a chance that we might end up writing many more classes
    with a small functionality. Consider the case of finite state machines—if there
    are many states but each state is not too different from another state, we''d
    still need to write them as separate `ConcreteState` classes. This increases the
    amount of code we need to write, and it becomes difficult to review the structure
    of a state machine.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类爆炸**：由于每个状态都需要通过`ConcreteState`来定义，所以我们可能会写出很多功能较小的类。考虑有限状态机的例子——如果有很多状态，但每个状态与其他状态没有太大区别，我们仍然需要将它们作为单独的`ConcreteState`类来编写。这增加了我们需要编写的代码量，并且使得审查状态机的结构变得困难。'
- en: With the introduction of every new behavior (even though adding behavior is
    just adding one more `ConcreteState`), the `Context` class needs to be updated
    to deal with each behavior. This makes the `Context` behavior more brittle with
    every new behavior.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每引入一个新的行为（尽管添加行为只是添加一个额外的`ConcreteState`），`Context`类都需要更新以处理每个行为。这使得每次添加新行为时`Context`的行为都变得更加脆弱。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize what we've learned so far, in State design patterns, the object's
    behavior is decided based on its state. The state of the object can be changed
    at runtime. Python's ability to change behavior at runtime makes it very easy
    to apply and implement the State design pattern. The State pattern also gives
    us control over deciding the states that objects can take up such as those in
    the computer example that we saw earlier in the chapter. The `Context` class provides
    an easier interface for clients, and `ConcreteState` makes sure it is easy to
    add behaviors to the objects. Thus, the State pattern improves cohesion, flexibility
    to extend, and removes redundant code blocks. We academically studied the pattern
    in the form of a UML diagram and learned about the implementation aspects of the
    State pattern with help of the Python v3.5 code implementation. We also took a
    look at the few pitfalls you might encounter when it comes to the State pattern,
    and the code which can significantly increase when it comes to adding more states
    or behaviors. I hope you had a nice time going through this chapter!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结到目前为止我们所学的，在状态设计模式中，对象的行为是基于其状态决定的。对象的状态可以在运行时改变。Python在运行时改变行为的能力使得应用和实现状态设计模式变得非常容易。状态模式还让我们能够控制对象可以采取的状态，例如我们在本章前面看到的计算机示例中的状态。`Context`类提供了一个更简单的接口，而`ConcreteState`确保了向对象添加行为变得容易。因此，状态模式提高了内聚性、扩展灵活性，并消除了冗余代码块。我们以UML图的形式学术性地研究了该模式，并借助Python
    3.5代码实现学习了状态模式的实现方面。我们还审视了在使用状态模式时可能会遇到的几个陷阱，以及当添加更多状态或行为时代码可能会显著增加的情况。我希望你在阅读这一章时过得愉快！
