- en: Python for Network Engineers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工程师的 Python
- en: As we are now familiar with how to write a program using the concepts used in
    programming languages, as well as best practices, now let's dig deep into writing
    an actual Python program or script. Keeping the primary focus on how to write
    a program in Python, we will also see how to write the same program in PowerShell,
    since there might be times where we would need to use PowerShell to achieve the
    results that we are looking for. We will cover various aspects of creating a program
    with some explanations of each of the statements and provide some tips and tricks
    to get through those tricky situations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了如何使用编程语言中的概念以及最佳实践来编写程序，现在让我们深入探讨编写实际的 Python 程序或脚本。主要关注如何在 Python
    中编写程序，我们还将看到如何用 PowerShell 编写相同的程序，因为在某些时候我们可能需要使用 PowerShell 来实现我们想要的结果。我们将涵盖创建程序的各种方面，并对每个语句进行一些解释，并提供一些技巧和窍门来应对那些棘手的情况。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Python interpreter and data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 解释器和数据类型
- en: Writing Python scripts using conditional loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件循环编写 Python 脚本
- en: Functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Installing new modules/libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新的模块/库
- en: Passing arguments from command line for scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为脚本从命令行传递参数
- en: Using Netmiko to interact with network devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Netmiko 与网络设备交互
- en: Multithreading
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Python interpreter and data types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 解释器和数据类型
- en: An interpreter, as the name suggests, is used to interpret instructions so that
    they are understandable by others. In our case, it is used to convert our Python
    language to a machine-understandable format that governs the flow of instructions
    that we gave to the machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，解释器用于解释指令，以便其他人可以理解。在我们的情况下，它用于将我们的 Python 语言转换为机器可理解的格式，该格式控制了我们给机器的指令流。
- en: It is also used to convert the set of values and messages given by a machine
    to a human-readable format in order to give us insights into how our program is
    being executed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被用来将机器给出的值和消息转换成人类可读的格式，以便让我们了解我们的程序是如何执行的。
- en: As mentioned in [Chapter 1](864fa562-ce4b-4b1f-a418-f91c2ac56f1f.xhtml), *Fundamental
    Concepts*, the interpreter that we are focusing on is Python 3.6\. I will be using
    it on the Windows platform, but the site has clear instructions on how to download
    and install the same on other OS like Unix or Linux machines. Once we install
    it by downloading it from the Python community  which can be found at URL [https://www.python.org/downloads](https://www.python.org/downloads),
    we can simply click on the setup file to install it. From the installation directory
    we just need to invoke `python.exe`, which will invoke the Python interpreter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](864fa562-ce4b-4b1f-a418-f91c2ac56f1f.xhtml) 中所述，*基本概念*，我们关注的解释器是 Python
    3.6。我将在 Windows 平台上使用它，但网站上提供了如何在 Unix 或 Linux 机器上下载和安装的明确说明。一旦我们从 Python 社区下载并安装它，可以在
    URL [https://www.python.org/downloads](https://www.python.org/downloads) 上找到，我们只需单击安装文件即可安装。从安装目录中，我们只需调用
    `python.exe`，这将调用 Python 解释器。
- en: In order to call Python from anywhere in your Command Prompt, just add the Python
    installation folder in your PATH variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的命令提示符的任何位置调用 Python，只需将 Python 安装文件夹添加到您的 PATH 变量中。
- en: 'Here''s an example: `set path=%path%;C:\python36`. This is going to add the
    Python36 path in the current path. Once this is done, `python.exe` can be called
    from anywhere in the Command Prompt.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：`set path=%path%;C:\python36`。这将向当前路径添加 Python36 路径。一旦完成，就可以在任何命令提示符下调用
    `python.exe`。
- en: Once we invoke the interpreter, the first step to take is to create a variable
    and assign a value to it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用解释器，首先要做的步骤是创建一个变量并给它赋值。
- en: Python, as with any other programming language, supports various data types
    for the variables. A data type typically defines the type of value that can be
    stored in a variable, but Python and PowerShell have the ability to auto-evaluate
    the type of variable based upon the value. Python supports a large number of data
    types, but typically in our daily usage we refer to native data types multiple
    times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python，就像任何其他编程语言一样，支持各种数据类型用于变量。数据类型通常定义了可以存储在变量中的值的类型，但 Python 和 PowerShell
    有能力根据值自动评估变量的类型。Python 支持大量数据类型，但在我们日常使用中，我们通常多次引用原生数据类型。
- en: 'The Python data type supports:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 数据类型支持：
- en: '**Numbers**: These are integer types, such as 1, 2, 100, and 1,000.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：这些是整数类型，例如 1、2、100 和 1,000。'
- en: '**String**: These are single or multiple characters and possibly every letter
    of ASCII, such as Python, network, age123, and India. Additionally, a string needs
    to be stored inside a double quote (`"`) or a single quote (`''`) to specify that
    a value is a string. Hence, `1` and `''1''` would be interpreted differently by
    Python.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这些是单个或多个字符，可能是 ASCII 中的每个字母，例如 Python、network、age123 和 India。此外，字符串需要存储在双引号（`"`）或单引号（`''`）内，以指定值是一个字符串。因此，`1`
    和 `''1''` 在 Python 中会被解释为不同的值。'
- en: '**Boolean**: This can be either a true or a false value.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：这可以是真或假值。'
- en: '**Byte**: These are typically binary values.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节**：这些通常是二进制值。'
- en: '**Lists**: These are an ordered sequence of values.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：这些是有序值序列。'
- en: '**Tuples**: These are similar to lists, but the values or length cannot be
    altered.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：这些与列表类似，但值或长度不能更改。'
- en: '**Sets**: These are similar to lists, but not ordered.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：这些与列表类似，但不排序。'
- en: '**Dictionary** or **hash** **values**: These are key-value pairs, like a telephone
    directory in which one primary value (name) is attached with both phone numbers
    and addresses.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**或**哈希**值：这些是键值对，类似于电话簿，其中一个主要值（名称）与电话号码和地址相关联。'
- en: 'An example on data types is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的示例如下：
- en: '![](img/c2474970-452c-46e0-b805-55f593a095d6.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2474970-452c-46e0-b805-55f593a095d6.jpg)'
- en: As we can see in the preceding example, we declared the variables with various
    values, and based upon the value, Python automatically interprets the specific
    data type. If we just type the variable name again, it prints out the value stored
    in the variable based upon its data type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们声明了具有各种值的变量，Python 根据值自动解释特定的数据类型。如果我们再次输入变量名，它将根据其数据类型打印出存储在变量中的值。
- en: 'Similarly, the following example specifies other native data types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下示例指定了其他原生数据类型：
- en: '![](img/67d39b74-ca58-4e21-881e-a2592fe25836.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67d39b74-ca58-4e21-881e-a2592fe25836.png)'
- en: 'Additionally, to see the data type we can use the `type()` function, which
    returns the type of a variable based upon the value we gave. The variable is passed
    as an argument to the `type()` function to get the data type value:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要查看数据类型，我们可以使用 `type()` 函数，该函数根据我们给出的值返回变量的类型。变量作为参数传递给 `type()` 函数以获取数据类型值：
- en: '![](img/034db3f3-17cb-44ed-8d5a-57fddeea6b8d.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/034db3f3-17cb-44ed-8d5a-57fddeea6b8d.png)'
- en: 'A PowerShell example of the same Python code is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的相同 Python 代码示例如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are operations, such as addition (`+`), for specific variables with particular
    data types. We have to be sure what types of variable we are adding. If we have
    an incompatible data type variable being added to another one, Python would throw
    an error stating the reason.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定数据类型的变量，存在一些操作，例如加法（`+`）。我们必须确保我们正在添加的变量类型。如果我们有一个不兼容的数据类型变量被添加到另一个变量中，Python
    会抛出一个错误，说明原因。
- en: 'Here in the following code, we see the result of adding two string variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们看到两个字符串变量相加的结果：
- en: '![](img/6cd58d98-458f-41c4-9183-d08529901ace.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd58d98-458f-41c4-9183-d08529901ace.jpg)'
- en: 'Similarly, observe the difference if we use the same addition on integer variables:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，观察如果我们对整型变量使用相同的加法操作时的差异：
- en: '![](img/ddcd7f1c-857a-4917-bc41-eb6872f455de.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddcd7f1c-857a-4917-bc41-eb6872f455de.jpg)'
- en: 'As mentioned, let''s see what happens when we try to add a string and an integer
    variable together:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们看看当我们尝试将字符串和整型变量相加时会发生什么：
- en: '![](img/10dc9f9f-7ee2-4592-9ef8-dad80e6403d2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10dc9f9f-7ee2-4592-9ef8-dad80e6403d2.png)'
- en: The error clearly specifies that we cannot add two different data types because
    the interpreter cannot recognize which data type needs to be assigned to the mixed
    value variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 错误清楚地指出，我们不能添加两个不同的数据类型，因为解释器无法识别需要分配给混合值变量的数据类型。
- en: Sometimes, if necessary, we can convert the values from one data type to another
    by calling specific functions that convert the data type to another. For example,
    `int("1")` will convert the string value 1 to integer value 1, or `str(1)` will
    convert the integer value 1 to the string value 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果需要，我们可以通过调用将数据类型转换为另一个数据类型的特定函数来将值从一个数据类型转换为另一个数据类型。例如，`int("1")` 将字符串值
    1 转换为整数值 1，或者 `str(1)` 将整数值 1 转换为字符串值 1。
- en: We will be extensively using the various data types depending upon the logic
    and requirements of the scripts, and also, if necessary, converting one data type
    to another to achieve certain results.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据脚本的逻辑和需求广泛使用各种数据类型，并在必要时将一种数据类型转换为另一种数据类型以实现某些结果。
- en: Conditions and loops
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件和循环
- en: Conditions are checked using a left and right value comparison. The evaluation
    returns either true or false, and a specific action is performed depending on
    the result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是通过左右值比较来检查的。评估返回 true 或 false，并根据结果执行特定操作。
- en: 'There are certain condition operators that are used to evaluate the left and
    right value comparisons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些条件运算符用于评估左右值的比较：
- en: '| **Operators** | **Meaning** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **含义** |'
- en: '| `==` | If both values are equal |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 如果两个值相等 |'
- en: '| `!=` | If both values are NOT equal |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 如果两个值不相等 |'
- en: '| `>` | If the left value is greater than the right value |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左值大于右值 |'
- en: '| `<` | If the left value is smaller than the right value |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左值小于右值 |'
- en: '| `>=` | If the left value is greater than or equal to the right value |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左值大于或等于右值 |'
- en: '| `<=` | If the left value is lesser than or equal to the right value |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左值小于或等于右值 |'
- en: '| `in` | If the left value is part of the right value |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 如果左值是右值的一部分 |'
- en: 'An example of the condition evaluation is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 条件评估的一个例子如下：
- en: '![](img/eaf5ab12-2d1b-4b85-a714-f3999aa28d03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaf5ab12-2d1b-4b85-a714-f3999aa28d03.jpg)'
- en: As we can see, we are checking whether `2>3` (2 is greater that 3). Of course,
    this would result in false, so the action in the `else` section is executed. If
    we reverse the check, `3>2`, then the output would have been `left value is greater`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们正在检查 `2>3`（2 大于 3）。当然，这将导致错误，因此 `else` 部分的操作将被执行。如果我们反转检查，`3>2`，那么输出将是
    `left value is greater`。
- en: 'In the preceding example, we used the `if` condition block, which consists
    of the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `if` 条件块，它由以下内容组成：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the indentation, which is compulsory in Python. If we had not intended
    it, Python would not interpret what action to execute in which condition, and
    hence would have thrown an error of incorrect indentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缩进，这在 Python 中是强制性的。如果我们没有打算这样做，Python 就不会解释在哪个条件下执行哪个操作，因此会抛出缩进错误。
- en: Nested and multiple conditions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套和多个条件
- en: Sometimes we need to check multiple conditions in a single `if` condition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在单个 `if` 条件中检查多个条件。
- en: 'Let''s see an example of this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '![](img/d3f16bcc-36f0-4ac8-8008-d1d459ac3155.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3f16bcc-36f0-4ac8-8008-d1d459ac3155.jpg)'
- en: 'Here, we are checking the range of the marks. The flow of the program is as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查分数的范围。程序的流程如下：
- en: Assign a value of `85` to the `marks` variable. If `marks` is less than or equal
    to `45`, print `Grade C`, else if `marks` is greater than `45` and less than equal
    to `75`, print `Grade B`, else if `marks` is greater than `75`, print `Grade A`,
    else if none of the preceding conditions match, then print `Unable to determine`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `85` 的值分配给 `marks` 变量。如果 `marks` 小于或等于 `45`，则打印 `Grade C`，否则如果 `marks` 大于
    `45` 且小于等于 `75`，则打印 `Grade B`，否则如果 `marks` 大于 `75`，则打印 `Grade A`，否则如果前面的所有条件都不匹配，则打印
    `Unable to determine`。
- en: 'The PowerShell sample code for the preceding Python task is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 之前 Python 任务的示例代码如下：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, here is an example of a nested condition (note the indentation that
    differentiates it from the earlier example of multiple conditions):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里是一个嵌套条件的示例（注意缩进，它将此与多个条件的早期示例区分开来）：
- en: '![](img/de31a5bc-0ed1-4d3f-86d0-60f80aafb500.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de31a5bc-0ed1-4d3f-86d0-60f80aafb500.jpg)'
- en: As we can see in the condition, the internal conditions will only be executed
    if its parent condition evaluates to true. If there is a false, the corresponding
    `else` action will be taken. In the example, if the `car_details` variable contains
    `Car`, contains `blue`, and it contains `sedan`, only then will the action `I
    will buy this car` be performed. If any of those conditions are not met, the relevant
    else action will be performed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在条件中，只有当父条件评估为 true 时，内部条件才会执行。如果有 false，则执行相应的 `else` 操作。在示例中，如果 `car_details`
    变量包含 `Car`，包含 `blue`，并且包含 `sedan`，那么才会执行操作 `I will buy this car`。如果这些条件中的任何一个不满足，则执行相关的
    `else` 操作。
- en: Loops
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'A loop is used to repeat a set of instructions until a specific condition is
    fulfilled. There are two common ways of creating a loop in Python, which are discussed
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 循环用于重复一组指令，直到满足特定条件。Python 中创建循环有两种常见方式，如下所述：
- en: For next loop
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于下一个循环
- en: 'This type of loop checks for a condition and repeats the instructions inside
    the loop until the condition is met:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环检查条件并在条件满足之前重复循环内的指令：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s an example of printing numbers from 1 to 10 in a for loop:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在`for`循环中打印1到10的数字的例子：
- en: '![](img/02d90031-e8fd-4810-bfcc-36b8a0552521.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02d90031-e8fd-4810-bfcc-36b8a0552521.jpg)'
- en: As we can see, we use a built-in `range(starting value, max value)` function,
    which specifies the loop to repeat from the starting value until the incremental
    value reaches the maximum value. In this case, the variable `x` is incremented
    by 1 and in each loop, the value is printed out. This is repeated until the value
    of `x` reaches `10`, where the `for` loop terminates.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用了一个内置的`range(starting value, max value)`函数，该函数指定循环从起始值开始重复，直到增量值达到最大值。在这种情况下，变量`x`增加1，并在每个循环中打印出值。这会一直重复，直到`x`的值达到`10`，此时`for`循环结束。
- en: 'In a similar way, we can also iterate through the items in a given list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们也可以遍历给定列表中的项：
- en: '![](img/2defea05-0fb5-4f17-aa98-c432036f90de.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2defea05-0fb5-4f17-aa98-c432036f90de.png)'
- en: 'PowerShell sample for the preceding Python code is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应Python代码的PowerShell示例：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see that the values are assigned to the countries variable as a
    list. The `for` loop now iterates through each item in the list, and the print
    statement adds the string value to another string value and prints the result. This
    loop is repeated until all the items in the list are printed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到值被分配给`countries`变量作为一个列表。`for`循环现在遍历列表中的每个项，打印语句将字符串值添加到另一个字符串值中并打印结果。这个循环会一直重复，直到列表中的所有项都被打印出来。
- en: 'There might be times when we do not want to parse through an entire `for` loop.
    To break from the loop while it is iterating, we use a `break` statement. Here''s
    an example in which we want to stop printing after `UK` in the `country` list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能不想遍历整个`for`循环。为了在循环迭代时跳出循环，我们使用`break`语句。以下是一个例子，我们希望在`country`列表中的`UK`之后停止打印：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While loop
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`While`循环'
- en: '`While` loop is different from `for` loop, as no new variable is needed in
    this loop, and any current variable can be used to perform the tasks inside the
    `while` loop. An example is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`While`循环与`for`循环不同，因为这个循环中不需要新的变量，任何当前变量都可以用来执行`while`循环内的任务。以下是一个例子：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/a39d5bde-5e97-44ff-865b-ca5221817d1f.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a39d5bde-5e97-44ff-865b-ca5221817d1f.jpg)'
- en: This is similar to `for`, but in this case the actions are performed first,
    and then the condition is checked. In the preceding example, the value of `x`
    is printed first, and we repeat the same set of instructions until the value of
    `x` reaches `10` or greater. Once the `if` condition is met, we break out of the
    loop. If we do not specify a `break` condition, we will go into an infinite loop
    with a increment of 1 for each `x` value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`for`循环类似，但在这个情况下，操作首先执行，然后检查条件。在上面的例子中，首先打印`x`的值，然后重复相同的指令集，直到`x`的值达到`10`或更大。一旦满足`if`条件，我们就跳出循环。如果我们没有指定`break`条件，我们将进入一个无限循环，每次`x`的值增加1。
- en: Writing Python scripts
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Python脚本
- en: We are now familiar with the basic concepts of Python. Now we will write an
    actual program or script in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了Python的基本概念。接下来，我们将编写一个实际的Python程序或脚本。
- en: 'Ask for the input of a country name, and check whether the last character of
    the country is a vowel:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请求输入一个国家名称，并检查该国家的最后一个字符是否为元音：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Output of the preceding code is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/be66c59e-ff2b-4145-88ea-a1c92005b60c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be66c59e-ff2b-4145-88ea-a1c92005b60c.png)'
- en: We ask for the input of a country name. The `input()` method is used to get
    an input from the user. The value entered is in the string format, and in our
    case the `countryname` variable has been assigned the input value.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们请求输入一个国家名称。`input()`方法用于从用户获取输入。输入的值是字符串格式，在我们的例子中，`countryname`变量已被分配了输入值。
- en: In the next line, `countryname.lower()` specifies that the input that we receive
    needs to converted into all lowercase and stored in the same `countryname` variable.
    This effectively will have the same value that we entered earlier but in lowercase.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，`countryname.lower()`指定我们接收到的输入需要转换为全小写并存储在相同的`countryname`变量中。这实际上将具有与我们之前输入相同的值，但为小写。
- en: 'In the next line, `countryname.strip()[-1]` specifies two actions in one statement:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，`countryname.strip()[-1]`在一个语句中指定了两个操作：
- en: '`countryname.strip()` ensures that the variable has all the leading and trailing
    extra values removed, such as new line or tab characters.'
  id: totrans-103
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countryname.strip()`确保变量移除了所有前导和尾随的额外值，例如换行符或制表符。'
- en: Once we get the clean variable, remove the last character of the string, which
    in our case is the last character of the country name. The `-1` denotes the character
    from right to left or end to start, whereas `+1` would denote from left to right.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们得到干净的变量，就移除字符串的最后一个字符，在我们的例子中是国名最后一个字符。`-1`表示从右到左或从结束到开始的位置，而`+1`则表示从左到右。
- en: Once we have the last character stored in the `lastcharacter` variable, all
    that is needed is a nested condition check and, based upon the result, print the
    value.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将最后一个字符存储在`lastcharacter`变量中，所需的就是嵌套条件检查，并根据结果打印值。
- en: 'To save this program, we need to save this file as `somename.py`, which will
    specify that this program needs to be executed in Python:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存此程序，我们需要将此文件保存为`somename.py`，这将指定此程序需要用Python执行：
- en: 'The PowerShell sample code for the preceding Python task is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为前面Python任务提供的PowerShell示例代码：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Python is very strict in terms of indentation. As we can see in the example,
    if we change the indentations or tabs even by a space, Python will spit out an
    error stating the indentation is not correct and the compilation will fail. This
    will result in an error and unless the indentation is fixed, the execution will
    not be performed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python在缩进方面非常严格。正如我们可以在示例中看到的那样，如果我们改变缩进或制表符，即使是一个空格，Python也会抛出一个错误，指出缩进不正确，编译将失败。这将导致错误，除非缩进被修复，否则执行将不会进行。
- en: Functions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: For any recurring set of instructions, we can define a function. In other words,
    a function is a closed set of instructions to perform a specific logic or task.
    Depending upon the input provided, a function has the ability to return the results
    or parse the input with specific instructions to get results without any return
    values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何重复的指令集，我们可以定义一个函数。换句话说，一个函数是一组封闭的指令，用于执行特定的逻辑或任务。根据提供的输入，函数能够返回结果或使用特定的指令解析输入以获取结果，而不返回任何值。
- en: A function is defined by the `def` keyword, which specifies that we need to
    define a function and provide a set of instructions related to that function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是通过`def`关键字定义的，它指定我们需要定义一个函数并提供与该函数相关的指令集。
- en: 'In this task we will print the greater of two input numbers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将打印两个输入数字中较大的一个：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/4571fb2a-3fbf-48bb-96ff-88a7f8fbd78f.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4571fb2a-3fbf-48bb-96ff-88a7f8fbd78f.jpg)'
- en: As we can see in the preceding output, the first time we call the `checkgreaternumber(2,4)`
    function, the function prints the greater value as `4`, and the second time we
    call the function with different numbers, the function prints the greater value
    as `3`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中可以看到的那样，第一次我们调用`checkgreaternumber(2,4)`函数时，函数打印出较大的值为`4`，而第二次我们用不同的数字调用该函数时，函数打印出较大的值为`3`。
- en: 'The PowerShell sample code for the preceding task is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为前面任务提供的PowerShell示例代码：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can rewrite the same function, but rather than printing the value inside
    the function, it should return the greater number:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写同一个函数，但不是在函数内部打印值，而是应该返回较大的数字：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, as we can see, the function returns the value, and the result
    is returned on the line where the function was called. In this case, as it was
    called inside the `print` function, it evaluates the input and returns the value,
    which also gets printed out inside the same `print` function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如我们所看到的，函数返回值，结果是在函数被调用的行返回的。在这种情况下，因为它是在`print`函数内部被调用的，它评估输入并返回值，该值也在同一个`print`函数内部打印出来。
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another important aspect of a function is the default values that we can provide
    in a function. Sometimes we need to write functions that might take multiple,
    say 4, 5, or more, values as inputs. Since it becomes hard to know what values
    we need and in which order for the function, we can ensure that the default value
    is taken into consideration if any value is not provided when calling that specific
    function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的另一个重要方面是我们可以在函数中提供的默认值。有时我们需要编写可能接受多个值作为输入的函数，比如4、5或更多。由于很难知道我们需要什么值以及它们的顺序，我们可以确保在调用该特定函数时，如果未提供任何值，则考虑默认值：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the code execution is given as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行的输出如下：
- en: '![](img/1754e6c1-c7d9-4ab7-b3e5-e291d27f051e.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1754e6c1-c7d9-4ab7-b3e5-e291d27f051e.jpg)'
- en: As we can see in the preceding output, we specified the default value of `number2`
    as `5`. Now, as we can see in the first call to the function, we only give the
    value `3`. Now, as the function needs two inputs or parameters, but we provided
    only one, the second value for the function is taken from the default one, which
    is `5` in this case. Hence, a comparison will be done between `3` and `5` to get
    the greater number.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，我们指定了`number2`的默认值为`5`。现在，正如我们可以在函数的第一次调用中看到的那样，我们只提供了值`3`。现在，由于函数需要两个输入或参数，但我们只提供了一个，所以函数的第二个值取自默认值，在这个例子中是`5`。因此，将`3`和`5`进行比较以获取较大的数字。
- en: In the second call to the function, a similar call is made with `6`, and since
    no other value was provided, the comparison was between `6` and `5`, and result
    returned was the greater value, which is `6`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的第二次调用中，使用`6`进行了类似的调用，并且由于没有提供其他值，比较是在`6`和`5`之间进行的，返回的是较大的值，即`6`。
- en: In the third call, we provide both values, which overrides any default value,
    so a comparison was done between `1` and `4`. The result was evaluated and the
    output of `4` was returned.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三次调用中，我们提供了两个值，这覆盖了任何默认值，因此进行了`1`和`4`的比较。结果被评估，并返回了`4`的输出。
- en: 'Another important consideration is the localization of a variable in a function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是函数中变量的本地化：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '![](img/5121cf2b-ada9-4b82-89c4-614b8d454e78.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5121cf2b-ada9-4b82-89c4-614b8d454e78.jpg)'
- en: In the preceding output, we define a variable named as `globalval` with a value
    of `6`. In the `checkglobalvalue` function, we just return the value of the `globalvalvariable`, which
    prints a value of `6` as we call the first `print` function.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前述输出中，我们定义了一个名为`globalval`的变量，其值为`6`。在`checkglobalvalue`函数中，我们只是返回`globalvalvariable`的值，当我们调用第一个`print`函数时，它打印了一个值为`6`。
- en: The second `print` function just prints the value of the same variable, which
    also prints `6`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个`print`函数只是打印相同变量的值，也打印了`6`。
- en: Now, in the third `print` function, `localvariablevalue`, we call the same `globalval`,
    but give it a value of `8` and return the value of `globalval`. In the print value
    of local, it prints the result as value 8\. It is not assumed that the `globalval`
    variable has a value of `8` now. But, as we can see in the last `print` function,
    it still prints a value of `6`, when we call the `print` function to print the
    value of `globalval`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第三个`print`函数`localvariablevalue`中，我们调用相同的`globalval`，但给它赋值为`8`并返回`globalval`的值。在打印局部值时，它打印的结果是值8。并不假设`globalval`变量现在的值是`8`。但是，正如我们在最后的`print`函数中看到的那样，当我们调用`print`函数来打印`globalval`的值时，它仍然打印了一个值为`6`的值。
- en: This clearly shows that any variable inside a function is locally effective,
    or is localized, but does not have any impact on any variables outside the function.
    We need to use the `global` command to reference the global variable and remove
    the localization impact of it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，函数内的任何变量都是局部有效的，或者说本地化的，但它不会对函数外的任何变量产生影响。我们需要使用`global`命令来引用全局变量并消除其本地化影响。
- en: 'Here is the same example before using the `global` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`global`命令之前，这里是相同的示例：
- en: '![](img/6d0972af-9161-44b9-9abb-590e9e129527.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d0972af-9161-44b9-9abb-590e9e129527.jpg)'
- en: As can we see in the preceding output, if we change the value of the `globalval`
    global variable inside the `localvariablevalue` function, we see the effect on
    the global variable with a new value of `8`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，如果我们更改`localvariablevalue`函数内部的全局变量`globalval`的值，我们会看到全局变量以新的值`8`产生的影响。
- en: Passing arguments from the command line
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行传递参数
- en: Sometimes it is necessary to pass arguments to the script from the command line.
    This is generally needed when we need to perform some quick actions in our script,
    rather than the script asking us for the inputs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要从命令行向脚本传递参数。这通常在我们需要在脚本中执行一些快速操作时需要，而不是脚本要求我们输入。
- en: 'Consider the following lines of code where we pass two numbers as arguments
    to scripts, and print the sum of them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行，我们将两个数字作为参数传递给脚本，并打印它们的和：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we run this script, say it''s saved as `checkargs.py`, and execute it
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，比如说它保存为`checkargs.py`，并按照以下方式执行：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output returned is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出如下：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The key here is the import of the `sys` module, which is a predefined module
    in Python to handle any system-related tasks of Python. The values that we pass
    as arguments are stored in `sys.argv[1]` onwards, since `sys.argv[0]` is the name
    of actual script being run. In this case, `sys.argv[0]` will be `checkargs.py`,
    `sys.argv[1]` will be `5`, and `sys.argv[2]` will be `6`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键是导入`sys`模块，这是Python中预定义的模块，用于处理任何与Python系统相关的任务。我们作为参数传递的值存储在`sys.argv[1]`及之后，因为`sys.argv[0]`是正在运行的脚本的实际名称。在这种情况下，`sys.argv[0]`将是`checkargs.py`，`sys.argv[1]`将是`5`，而`sys.argv[2]`将是`6`。
- en: 'The PowerShell code for the preceding task is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任务是PowerShell代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The arguments passed in a Python script are in string format, so we need to
    explicitly convert them to the right type for the expected output. In the preceding
    script, if we had not converted it to the integer type by using the `int()` function,
    then the output would have been `56` instead of `int(5)` + `int(6)` = `11`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python脚本中传递的参数是以字符串格式存在的，因此我们需要明确地将它们转换为预期的输出类型。在先前的脚本中，如果我们没有使用`int()`函数将其转换为整数类型，那么输出将是`56`而不是`int(5)`
    + `int(6)` = `11`。
- en: Python modules and packages
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python模块和包
- en: Because Python is the most popular open source coding language, there are many
    developers who contribute their expertise by creating specific modules and sharing
    them for others to use. These modules are a specific set of functions or instructions
    that are used to perform specialized tasks and can be called easily in our programs.
    The modules can be easily called using the `import` command inside the scripts.
    Python has many built-in modules that are directly called using `import`, but
    for specialized modules, an external installation is needed. Luckily, Python provides
    a very easy way to download and install these modules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python是最受欢迎的开源编程语言，有许多开发者通过创建特定的模块并与其他人共享来贡献他们的专业知识。这些模块是一组特定的函数或指令，用于执行特定任务，并且可以在我们的程序中轻松调用。我们可以通过在脚本中使用`import`命令轻松调用这些模块。Python有许多内置模块，可以直接使用`import`调用，但对于特定模块，需要外部安装。幸运的是，Python提供了一个非常简单的方式来下载和安装这些模块。
- en: As an example, let's install a module named `Netmiko` that can help us work
    on logging into network devices more efficiently. Python provides a well-documented
    reference for each of the modules, and for our module, the documentation can be
    found at [https://pypi.python.org/pypi/netmiko. ](https://pypi.python.org/pypi/netmiko)For
    installation, all we have to do is go into the folder from the command line where
    `python.exe` is installed or is present. There is a sub folder in that location
    called `scripts`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们安装一个名为`Netmiko`的模块，它可以帮助我们更有效地登录网络设备。Python为每个模块提供了详细的参考文档，对于我们的模块，文档可以在[https://pypi.python.org/pypi/netmiko](https://pypi.python.org/pypi/netmiko)找到。对于安装，我们只需进入命令行中`python.exe`安装或存在的文件夹。在该位置有一个名为`scripts`的子文件夹。
- en: Inside that folder, we have two options that can be used for installing modules,
    `easy_install.exe` or `pip.exe`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件夹中，我们有两种选项可以用来安装模块，`easy_install.exe`或`pip.exe`。
- en: 'Installing the library for Python, can be done in two ways:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Python库可以通过两种方式完成：
- en: 'The syntax of `easy_install` is as follows:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`easy_install`的语法如下：'
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The syntax of `pip install` is as follows:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install`的语法如下：'
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we install the required module, we need to restart Python by closing all
    open sessions and invoking IDLE again so the modules can be loaded. More information
    on modules can be gathered from [https://docs.python.org/2/tutorial/modules.html.](https://docs.python.org/2/tutorial/modules.html)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了所需的模块，我们需要通过关闭所有打开的会话并再次调用IDLE来重启Python，以便模块可以被加载。有关模块的更多信息，可以从[https://docs.python.org/2/tutorial/modules.html](https://docs.python.org/2/tutorial/modules.html)获取。
- en: Multithreading for parallel processing
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理的多线程
- en: As we are now focusing on writing our scripts efficiently, a major aspect of
    this is how efficiently, quickly, and correctly we fetch the information. When
    we use the `for` loop, we parse through each item one by one, which is fine if
    we get results quickly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在专注于高效编写脚本，这个过程中的一个重要方面是如何高效、快速和正确地获取信息。当我们使用`for`循环时，我们会逐个解析每个项目，如果我们能快速得到结果，这是可以的。
- en: Now, if each item in a `for` loop is a router from which we need to get the
    output of show version, and if each router takes around 10 seconds to log in,
    gather the output, and log out, and we have around 30 routers that we need to
    get this information from, we would need 10*30 = 300 seconds for the program to
    complete the execution. If we are looking for more advanced or complex calculations
    on each output, which might take up to a minute, then it will take 30 minutes
    for just 30 routers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个 `for` 循环中的每个项目都是一个需要获取 show 版本输出的路由器，并且如果每个路由器需要大约 10 秒来登录、收集输出和登出，而我们大约有
    30 个路由器需要获取这些信息，那么程序完成执行将需要 10*30 = 300 秒。如果我们对每个输出进行更高级或复杂的计算，这可能需要长达一分钟的时间，那么仅对
    30 个路由器进行计算就需要 30 分钟。
- en: This starts becoming very inefficient when our complexity and scalability grows.
    To help with this, we need to add parallelism to our programs. What this simply
    means is, we log in simultaneously on all 30 routers, and perform the same task
    to fetch the output at the same time. Effectively, this means that we now get
    the output on all  30 routers in 10 seconds, because we have 30 parallel threads
    being called.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的复杂性和可扩展性增长时，这开始变得非常低效。为了帮助解决这个问题，我们需要在我们的程序中添加并行性。这简单意味着，我们同时登录到所有 30 个路由器，并执行相同的任务以同时获取输出。实际上，这意味着我们现在可以在
    10 秒内获取所有 30 个路由器的输出，因为我们有 30 个并行线程被调用。
- en: A thread is nothing but another instance of the same function being called,
    and calling it 30 times means we are invoking 30 threads at the same time to perform
    the same tasks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 线程不过是同一函数的另一个实例，调用它 30 次意味着我们同时调用 30 个线程来执行相同的任务。
- en: 'Here''s an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the multi-threading code is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程代码的输出如下：
- en: '![](img/f806c994-8e32-4a82-90e9-68d1d06f0c12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f806c994-8e32-4a82-90e9-68d1d06f0c12.jpg)'
- en: As we can see in the preceding example, we created two functions, named `checksequential`
    and `checkparallel`, to print the system's date time. The `datetime` module is
    used to get the system's date time in this case. In the `for` loop, a sequential
    run was done that shows the increment time in the output when the function was
    called.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前例所示，我们创建了两个函数，分别命名为 `checksequential` 和 `checkparallel`，用于打印系统的日期时间。在这种情况下，使用
    `datetime` 模块获取系统的日期时间。在 `for` 循环中，执行了顺序运行，当函数被调用时，输出显示了增量时间。
- en: For the threading, we use a blank array named `threads`. Each of the instances
    that is created has a unique thread number or value, which is stored in this empty
    thread array each time the `checkparallel` method is spawned. This unique number
    or reference for each thread identifies each thread as and when its executed.
    The `start()` method is used to get the thread to perform the function called
    in the thread.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于线程，我们使用一个名为 `threads` 的空数组。每次 `checkparallel` 方法被创建时，每个实例都会有一个唯一的线程编号或值，这个编号或引用存储在这个空线程数组中。这个唯一的编号或引用标识每个线程，无论何时执行。
- en: The last loop is important in the thread. What it signifies is that the program
    will wait for all the threads to complete before moving forward. The `join()`
    method specifies that until all the threads are complete, the program will not
    proceed to the next step.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程中的最后一个循环很重要。它表示程序将在所有线程完成之前等待。`join()` 方法指定，直到所有线程都完成，程序将不会进行到下一步。
- en: Now, as we can see in the output of the thread, some of the timestamps are the
    same, which means that all those instances were invoked and executed at the same
    time in parallel rather than sequentially.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们在线程输出中看到的那样，一些时间戳是相同的，这意味着所有这些实例都是并行而不是顺序地在同一时间被调用和执行的。
- en: The output in the program is not in order for parallel threads, because the
    moment any thread is completed, the output is printed, irrespective of the order.
    This is different to sequential execution, since parallel threads do not wait
    for any previous thread to complete before executing another. So, any thread that
    completes will print its value and end.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的输出对于并行线程来说不是有序的，因为一旦任何线程完成，就会打印输出，而不考虑顺序。这与顺序执行不同，因为并行线程在执行另一个线程之前不会等待任何之前的线程完成。因此，任何完成的线程都会打印其值并结束。
- en: 'PowerShell sample code for the preceding task is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为前一个任务编写的 PowerShell 示例代码：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using Netmiko for SSH and network device interaction
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Netmiko 进行 SSH 和网络设备交互
- en: Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    is a library in Python that is used extensively an interaction with network devices.
    This is a multi-vendor library with support for Cisco IOS, NXOS, firewalls, and
    many other devices. The underlying library of this is Paramiko, which is again
    used extensively for SSH into various devices.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    是一个Python库，广泛用于与网络设备交互。这是一个多厂商库，支持Cisco IOS、NXOS、防火墙和其他许多设备。其底层库是Paramiko，它再次被广泛用于各种设备的SSH连接。
- en: Netmiko extends the Paramiko ability of SSH to add enhancements, such as going
    into configuration mode in network routers, sending commands, receiving output
    based upon the commands, adding enhancements to wait for certain commands to finish
    executing, and also taking care of yes/no prompts during command execution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko扩展了Paramiko的SSH能力，增加了增强功能，例如进入网络路由器的配置模式，发送命令，根据命令接收输出，增加等待特定命令执行完成的增强功能，并在命令执行期间处理是/否提示。
- en: 'Here''s an example of a simple script to log in to the router and show the
    version:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的脚本示例，用于登录到路由器并显示版本：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the execution of code against a router is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对路由器执行代码的输出如下：
- en: '![](img/a66c311b-136d-4147-b78f-10eb7cfbc53d.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a66c311b-136d-4147-b78f-10eb7cfbc53d.jpg)'
- en: 'As we can see in the sample code, we call the `ConnectHandler` function from
    the Netmiko library, which takes four inputs (`platform type`, `IP address of
    device`, `username`, and `password`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在示例代码中所见，我们调用Netmiko库中的`ConnectHandler`函数，它接受四个输入（`平台类型`、`设备的IP地址`、`用户名`和`密码`）：
- en: 'Netmiko works with a variety of vendors. Some of the supported platform types
    and their abbreviations to be called in Netmiko are:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko支持多种厂商。一些受支持的平台类型及其缩写，在Netmiko中调用时使用如下：
- en: '''a10'': A10SSH,'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '''a10'': A10SSH,'
- en: '''accedian'': AccedianSSH,'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '''accedian'': AccedianSSH,'
- en: '''alcatel_aos'': AlcatelAosSSH,'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '''alcatel_aos'': AlcatelAosSSH,'
- en: '''alcatel_sros'': AlcatelSrosSSH,'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '''alcatel_sros'': AlcatelSrosSSH,'
- en: '''arista_eos'': AristaSSH,'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '''arista_eos'': AristaSSH,'
- en: '''aruba_os'': ArubaSSH,'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '''aruba_os'': ArubaSSH,'
- en: '''avaya_ers'': AvayaErsSSH,'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '''avaya_ers'': AvayaErsSSH,'
- en: '''avaya_vsp'': AvayaVspSSH,'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '''avaya_vsp'': AvayaVspSSH,'
- en: '''brocade_fastiron'': BrocadeFastironSSH,'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '''brocade_fastiron'': BrocadeFastironSSH,'
- en: '''brocade_netiron'': BrocadeNetironSSH,'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '''brocade_netiron'': BrocadeNetironSSH,'
- en: '''brocade_nos'': BrocadeNosSSH,'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '''brocade_nos'': BrocadeNosSSH,'
- en: '''brocade_vdx'': BrocadeNosSSH,'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '''brocade_vdx'': BrocadeNosSSH,'
- en: '''brocade_vyos'': VyOSSSH,'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '''brocade_vyos'': VyOSSSH,'
- en: '''checkpoint_gaia'': CheckPointGaiaSSH,'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '''checkpoint_gaia'': CheckPointGaiaSSH,'
- en: '''ciena_saos'': CienaSaosSSH,'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '''ciena_saos'': CienaSaosSSH,'
- en: '''cisco_asa'': CiscoAsaSSH,'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_asa'': CiscoAsaSSH,'
- en: '**''cisco_ios'': CiscoIosBase**,'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**''cisco_ios'': CiscoIosBase**，'
- en: '''cisco_nxos'': CiscoNxosSSH,'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_nxos'': CiscoNxosSSH,'
- en: '''cisco_s300'': CiscoS300SSH,'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_s300'': CiscoS300SSH,'
- en: '''cisco_tp'': CiscoTpTcCeSSH,'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_tp'': CiscoTpTcCeSSH,'
- en: '''cisco_wlc'': CiscoWlcSSH,'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_wlc'': CiscoWlcSSH,'
- en: '''cisco_xe'': CiscoIosBase,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_xe'': CiscoIosBase,'
- en: '''cisco_xr'': CiscoXrSSH,'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '''cisco_xr'': CiscoXrSSH,'
- en: '''dell_force10'': DellForce10SSH,'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '''dell_force10'': DellForce10SSH,'
- en: '''dell_powerconnect'': DellPowerConnectSSH,'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '''dell_powerconnect'': DellPowerConnectSSH,'
- en: '''eltex'': EltexSSH,'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '''eltex'': EltexSSH,'
- en: '''enterasys'': EnterasysSSH,'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '''enterasys'': EnterasysSSH,'
- en: '''extreme'': ExtremeSSH,'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '''extreme'': ExtremeSSH,'
- en: '''extreme_wing'': ExtremeWingSSH,'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '''extreme_wing'': ExtremeWingSSH,'
- en: '''f5_ltm'': F5LtmSSH,'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '''f5_ltm'': F5LtmSSH,'
- en: '''fortinet'': FortinetSSH,'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '''fortinet'': FortinetSSH,'
- en: '''generic_termserver'': TerminalServerSSH,'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '''generic_termserver'': TerminalServerSSH,'
- en: '''hp_comware'': HPComwareSSH,'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '''hp_comware'': HPComwareSSH,'
- en: '''hp_procurve'': HPProcurveSSH,'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '''hp_procurve'': HPProcurveSSH,'
- en: '''huawei'': HuaweiSSH,'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''huawei'': HuaweiSSH,'
- en: '''juniper'': JuniperSSH,'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '''juniper'': JuniperSSH,'
- en: '''juniper_junos'': JuniperSSH,'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '''juniper_junos'': JuniperSSH,'
- en: '''linux'': LinuxSSH,'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '''linux'': LinuxSSH,'
- en: '''mellanox_ssh'': MellanoxSSH,'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '''mellanox_ssh'': MellanoxSSH,'
- en: '''mrv_optiswitch'': MrvOptiswitchSSH,'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '''mrv_optiswitch'': MrvOptiswitchSSH,'
- en: '''ovs_linux'': OvsLinuxSSH,'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '''ovs_linux'': OvsLinuxSSH,'
- en: '''paloalto_panos'': PaloAltoPanosSSH,'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '''paloalto_panos'': PaloAltoPanosSSH,'
- en: '''pluribus'': PluribusSSH,'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '''pluribus'': PluribusSSH,'
- en: '''quanta_mesh'': QuantaMeshSSH,'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '''quanta_mesh'': QuantaMeshSSH,'
- en: '''ubiquiti_edge'': UbiquitiEdgeSSH,'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '''ubiquiti_edge'': UbiquitiEdgeSSH,'
- en: '''vyatta_vyos'': VyOSSSH,'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '''vyatta_vyos'': VyOSSSH,'
- en: '''vyos'': VyOSSSH,'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '''vyos'': VyOSSSH,'
- en: Depending upon the selection of the platform type, Netmiko can understand the
    returned prompt and the correct way to SSH to the specific device. Once the connection
    is made, we can send commands to the device using the `send` method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台类型的选取，Netmiko可以理解返回的提示信息以及正确的方式SSH到特定设备。一旦建立连接，我们可以使用`send`方法向设备发送命令。
- en: Once we get the return value, the value stored in the `output` variable is displayed,
    which is the string output of the command that we sent to the device. The last
    line, which uses the `disconnect` function, ensures that the connection is terminated
    cleanly once we are done with our task.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到返回值，存储在`output`变量中的值就会被显示出来，这是我们发送给设备的命令的字符串输出。最后一行，使用`disconnect`函数，确保我们在完成任务后干净地终止连接。
- en: 'For configuration (example: We need to provide a description to the router
    interface `FastEthernet 0/0`), we use Netmiko as shown in the following example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置（例如：我们需要为路由器接口`FastEthernet 0/0`提供描述），我们可以像以下示例中那样使用Netmiko：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the execution of the preceding code is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行的结果如下：
- en: '![](img/135a58fa-bf71-45c9-992e-875816852d6e.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/135a58fa-bf71-45c9-992e-875816852d6e.jpg)'
- en: As we can see, for `config push` we do not have to perform any additional configs
    but just specify the commands in the same order as we will send them manually
    to the router in a list, and pass that list as an argument to the `send_config_set`
    function.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们所见，对于`config push`，我们不需要执行任何额外的配置，只需按照我们将手动发送给路由器的顺序指定命令，并将该列表作为`send_config_set`函数的参数传递。
- en: The output in `Before config push` is a simple output of the `FastEthernet0/0` interface,
    but the output under `After config push` is now with the description that we configured
    using the list of commands.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Before config push`中的输出是`FastEthernet0/0`接口的简单输出，但在`After config push`下的输出现在包含了我们使用命令列表配置的描述。
- en: In a similar way, we can pass multiple commands to the router, and Netmiko will
    go into configuration mode, write those commands to the router, and exit config
    mode.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以将多个命令传递给路由器，Netmiko将进入配置模式，将这些命令写入路由器，然后退出配置模式。
- en: 'If we want to save the configuration, we use the following command after the
    `send_config_set` command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保存配置，请在`send_config_set`命令之后使用以下命令：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This ensures that the router writes the newly pushed config in memory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了路由器将新推送的配置写入内存。
- en: Network automation use case
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络自动化用例
- en: As we have now interacted with multiple sections of Python and device interaction,
    let's create a use case to incorporate what we have learned so far. The use case
    is as follows**:**
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经与Python和设备交互的多个部分进行了交互，让我们创建一个用例来整合我们迄今为止所学到的内容。该用例如下**：
- en: 'Log into the router and fetch some information:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到路由器并获取一些信息：
- en: '`task1()`: Show the version, show the IP in brief, show the clock, and show
    the configured usernames on the router.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task1()`: 显示版本，简要显示IP，显示时钟，并显示路由器上配置的用户名。'
- en: '`task2()`: Create another username on the `test` router with the password `test`
    and check whether we can log in successfully with the newly created username.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task2()`: 在`test`路由器上创建另一个用户名为`test`的账户，并检查我们是否可以使用新创建的用户名成功登录。'
- en: '`task3()`: Log in with the newly created username `test`, and delete all the
    other usernames from the `running-config`. Once this is done, return all the current
    usernames configured on the router to confirm whether only the `test` username
    is configured on the router.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task3()`: 使用新创建的用户名`test`登录，并从`running-config`中删除所有其他用户名。一旦完成，返回路由器上配置的所有当前用户名，以确认是否只有`test`用户名被配置在路由器上。'
- en: 'Let''s build a script to tackle these tasks one by one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个脚本来逐一处理这些任务：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, the three tasks given are defined as three different functions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，给出的三个任务被定义为三个不同的函数：
- en: The first line indicates that we have imported the Netmiko library, and in the
    second line we are connecting to our `test` router with the Cisco credentials.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行表示我们已经导入了Netmiko库，而在第二行中，我们正在使用Cisco凭据连接到我们的`test`路由器。
- en: In the `task1()` function, we are fetching the outputs of all show commands.
    Additionally, since we do not want to expose the passwords of the current usernames
    we have added an extra logic wherein the returned output for `show running-config
    | in username` will be parsed by each line for every username, and each line will
    be split by a space character `" "`. Also, since the Cisco device returns the
    actual username in the second position in the output (for example, username `test`
    privilege 15 secret 5 *)*, we print the value of the second item after we split
    the output string, which is our actual username.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`task1()`函数中，我们正在获取所有显示命令的输出。此外，由于我们不希望暴露当前用户名的密码，我们添加了额外的逻辑，即对于`show running-config
    | in username`的返回输出，将按每行和每个用户名进行解析，并且每行将按空格字符`" "`分割。另外，由于思科设备在输出中的第二个位置返回实际用户名（例如，用户名`test`权限15密码5
    *），我们在分割输出字符串后打印第二个项目的值，这就是我们的实际用户名。
- en: 'Here''s the output for the `task1()` method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`task1()`方法的输出：
- en: '![](img/51c0ad39-caeb-4baa-bba0-c6b95c760bfe.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51c0ad39-caeb-4baa-bba0-c6b95c760bfe.jpg)'
- en: In the `task2()` method, we are going to create a username `test` with the password
    `test`, and authenticate with the new username. We have added a `try:` exception
    block in this method, which checks for any errors/exceptions for all the statements
    in the `try:` section, and if there are any exceptions, rather than breaking the
    script, it runs the code that is given in the exception section (under the `except:`
    keyword). If there are no errors, it continues with the statements in the `try:`
    section.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`task2()`方法中，我们将创建一个用户名`test`并设置密码为`test`，然后使用新用户名进行认证。我们在该方法中添加了一个`try:`异常块，该块检查`try:`部分中所有语句的错误/异常，如果有任何异常，而不是中断脚本，它将运行在`except:`关键字下的异常部分中的代码。如果没有错误，它将继续执行`try:`部分中的语句。
- en: 'Here''s the output for `task2()`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`task2()`函数的输出：
- en: '![](img/62f5c790-3c76-4fd4-a2d5-1c61b2744d35.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62f5c790-3c76-4fd4-a2d5-1c61b2744d35.png)'
- en: We can see that we now have two usernames configured, and the router is also
    now successfully responding to authentication with the `test` username.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在已经配置了两个用户名，并且路由器现在也成功响应了使用`test`用户名的认证。
- en: In `task3()` function, this will first fetch all the usernames that are in `running-config`,
    and if there are any usernames that are not `test`, it will create a dynamic command
    with no username `<username>` and send it to the router. Once it is done with
    all the usernames, it will go ahead and recheck and list out all the usernames
    not on the router. A success criteria is only the configured username as `test`
    should be available on the router.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`task3()`函数中，这首先将获取`running-config`中所有的用户名，如果有任何用户名不是`test`，它将创建一个没有用户名`<username>`的动态命令并发送到路由器。一旦处理完所有用户名，它将继续重新检查并列出不在路由器上的所有用户名。成功标准是只有配置的用户名`test`应该存在于路由器上。
- en: 'Here''s the output of `task3()`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`task3()`函数的输出：
- en: '![](img/44b7d3eb-4dda-4bf2-b055-a5a1e81e3d54.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44b7d3eb-4dda-4bf2-b055-a5a1e81e3d54.jpg)'
- en: The result of `task3()` is the result of all configured usernames, which in
    this case is now only test.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`task3()`的结果是所有配置的用户名的结果，在这种情况下现在只有`test`。'
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some advanced techniques for writing scripts by
    using functions, conditions, and loops; we covered multi-threading our scripts
    for faster and parallel execution, we got familiar with using Netmiko to interact
    with network devices, and looked at a real-world example of achieving a certain
    set of tasks using a single script.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用函数、条件和循环等高级技术学习了编写脚本的方法；我们介绍了多线程脚本以实现更快和并行执行，熟悉了使用Netmiko与网络设备交互，并查看了一个使用单个脚本完成一组实际任务的示例。
- en: The next chapter will focus on automation tasks using web. We will also discuss
    how to call Python scripts from the web and perform tasks using web framework.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍使用Web进行自动化任务。我们还将讨论如何从Web调用Python脚本并使用Web框架执行任务。
- en: Additionally, there will be a basic introduction to creating your own API so
    that others can use it for specific tasks.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还将简要介绍如何创建自己的API，以便他人可以使用它执行特定任务。
