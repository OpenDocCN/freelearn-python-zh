- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building an IoT Weather Indicator
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网天气指示器
- en: 'In this chapter, we will learn about servo motors and LEDs and then use this
    knowledge, along with our understanding of the Raspberry Pi and web services,
    to create a practical project: an IoT weather indicator.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习伺服电机和LED，然后利用这些知识，结合我们对树莓派和网络服务的理解，来创建一个实际项目：一个物联网天气指示器。
- en: The weather indicator will draw weather information from a web service and then
    use a pointer attached to the servo motor to indicate suitable attire based on
    the current outdoor conditions. It will include an LED that turns on when it’s
    raining and blinks on and off if there is a thunderstorm. The configuration that
    you’ll use to create this application may be used for other applications, such
    as a water quality monitor or a traffic density monitor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该天气指示器将从网络服务中获取天气信息，然后使用连接到伺服电机的指针来根据当前的户外条件指示合适的着装。它将包括一个在下雨时开启并在雷暴时闪烁的LED。您用于创建此应用程序的配置可能用于其他应用程序，例如水质监测器或交通密度监测器。
- en: We’ll start by looking at servo motors, which will help us understand what they
    are and how we may use them in our IoT applications. Then, we’ll focus on LEDs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看伺服电机开始，这将帮助我们了解它们是什么以及我们如何在物联网应用程序中使用它们。然后，我们将专注于LED。
- en: Following that, we’ll begin constructing a physical stand to house the components
    for our application. This will be the second specially designed stand for the
    Raspberry Pi that we will build for this book and the first one that features
    a motor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将开始构建一个物理支架来容纳我们应用程序的组件。这将是我们为本书构建的第二个专门设计的树莓派支架，也是第一个带有电机的支架。
- en: While the usage of the SenseHAT case, as discussed in *Chapters 1* and *2*,
    was optional, it is recommended to build this stand for the weather indicator.
    This construction will represent our first foray into creating a tangible, physical
    entity, or more specifically, an Internet of Things (IoT) *thing*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在第1章和第2章中讨论的SenseHAT外壳的使用是可选的，但建议为天气指示器构建此支架。这个构建将代表我们第一次尝试创建一个有形的、物理的实体，或者更具体地说，是一个物联网（IoT）*事物*。
- en: 'Once our stand has been assembled, we’ll dive into coding. Our goal will be
    to extract information from the **OpenWeatherMap** web service and utilize it
    to dictate the position of the needle affixed to our servo motor based on the
    temperature and wind speed. We will also adjust the LED’s behavior according to
    certain weather conditions. By implementing these processes, we will illustrate
    how real-world data can be transformed into physical movements, bridging the gap
    between the digital and mechanical worlds:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的设备组装完成，我们就会开始编码。我们的目标是从**OpenWeatherMap**网络服务中提取信息，并利用它来根据温度和风速来控制我们伺服电机上固定针的位置。我们还将根据某些天气条件调整LED的行为。通过实施这些过程，我们将展示如何将现实世界的数据转化为物理运动，架起数字世界和机械世界之间的桥梁：
- en: '![Figure 3.1 – Connecting our weather indicator to a web service](img/B21282_03_1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 将我们的天气指示器连接到网络服务](img/B21282_03_1.jpg)'
- en: Figure 3.1 – Connecting our weather indicator to a web service
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 将我们的天气指示器连接到网络服务
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Looking into servo motors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索伺服电机
- en: Exploring LEDs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LED
- en: Controlling servo motors and LEDs using Python
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python控制伺服电机和LED
- en: Building the weather indicator stand
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建天气指示器支架
- en: Developing code for our application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序开发代码
- en: Let’s begin!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the following to complete this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章，您需要以下物品：
- en: The Raspberry Pi 5 4/8 GB model is preferred, but the Raspberry Pi 4B with either
    4 GB or 8 GB may be used (the figures in this book show the Raspberry Pi 4B model).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用树莓派5 4/8 GB型号，但也可以使用带有4 GB或8 GB的树莓派4B（本书中的图示显示的是树莓派4B型号）。
- en: The latest Raspberry Pi operating system with Thonny pre-installed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有预装Thonny的最新树莓派操作系统。
- en: A keyboard, mouse, and monitor.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘、鼠标和显示器。
- en: 1x SG90 servo motor.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个SG90伺服电机。
- en: 1x LED (single color).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LED（单色）。
- en: 1x 220 Ohm resistor.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个220欧姆电阻。
- en: ½ inch PVC pipe.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ½英寸PVC管。
- en: Jumper wires with connectors for the Raspberry Pi’s **general-purpose input/output**
    (**GPIO**) port.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于树莓派**通用输入/输出**（**GPIO**）端口的跳线带连接器。
- en: Access to a 3D printer or 3D printing service for the custom stand.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定制支架的3D打印机或3D打印服务。
- en: A general knowledge of programming. We will be using the Python programming
    language in this book.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对编程的一般了解。本书中将使用 Python 编程语言。
- en: The GitHub repository for this chapter is located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库位于 [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3)。
- en: Looking into servo motors
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究伺服电机
- en: '**Servo motors** are widely used in robotics, automation, and other applications
    where precise control of angular movement is required. Hooking up servo motors
    to the Raspberry Pi is a straightforward process that offers exciting possibilities
    for various projects. The Raspberry Pi provides a suitable platform to interface
    and control servo motors. In this section, we will investigate servo motors in
    more detail.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**伺服电机**在机器人、自动化和其他需要精确控制角运动的领域中得到了广泛应用。将伺服电机连接到树莓派是一个简单的过程，为各种项目提供了令人兴奋的可能性。树莓派提供了一个合适的平台来接口和控制伺服电机。在本节中，我们将更详细地研究伺服电机。'
- en: Exploring the GPIO port
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 GPIO 端口
- en: The GPIO port on the Raspberry Pi allows for direct hardware interaction, making
    it a key tool for hands-on projects. It allows us to connect devices, sensors,
    and circuits, allowing for real-world applications such as robotics or alarm systems
    to be created. By utilizing these pins, we can design and build projects that
    interact with the physical world. We will cover the GPIO port in more depth in
    [*Chapter 5*](B21282_05.xhtml#_idTextAnchor080). For now, it is enough to know
    that we can simply connect devices such as servo motors and LEDs to the GPIO port
    using female jumper connectors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的 GPIO 端口允许直接硬件交互，使其成为动手项目的关键工具。它允许我们连接设备、传感器和电路，从而创建现实世界的应用，如机器人或报警系统。通过利用这些引脚，我们可以设计和构建与物理世界交互的项目。我们将在[*第
    5 章*](B21282_05.xhtml#_idTextAnchor080)中更深入地介绍 GPIO 端口。目前，只需知道我们可以简单地使用母头跳线连接器将伺服电机和
    LED 等设备连接到 GPIO 端口即可。
- en: We will start by hooking up an SG90 servo motor to our Raspberry Pi 5 using
    the GPIO port.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 GPIO 端口将 SG90 伺服电机连接到我们的树莓派 5。
- en: Connecting the SG90 servo motor to our Raspberry Pi
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 SG90 伺服电机连接到我们的树莓派
- en: The SG90 servo motor is a popular and widely used micro-servo motor due to its
    compact size, versatility, precise control, and ease of use. When connecting the
    SG90 servo motor to our Raspberry Pi, it is necessary to modify the wire alignment
    within the female 3-prong connector. This connector is commonly known as the **JR-style
    servo connector** or simply **servo connector** and is initially wired with the
    power (+5V) and GND wires in reverse order from what is required for our Raspberry
    Pi.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SG90 伺服电机因其紧凑的尺寸、多功能性、精确控制和易于使用而广受欢迎。在将 SG90 伺服电机连接到我们的树莓派时，有必要修改母头三脚插座的线序。这个插座通常被称为**JR
    风格伺服插座**或简单地称为**伺服插座**，其初始接线顺序与我们的树莓派所需的顺序相反。
- en: 'Referring to *Figure 3**.2*, we can adjust the wiring by performing the following
    steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图 3**.2**，我们可以通过以下步骤调整接线：
- en: First, identify the three wires in the connector – red (power), brown (ground),
    and orange (signal).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，识别插座中的三根线 – 红色（电源）、棕色（地）和橙色（信号）。
- en: Next, gently pull the wires from the connector while holding the plastic housing
    up using a sharp object such as an Xacto knife.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用尖锐物体（如 Xacto 刀）轻轻拉出插座中的线，同时用手握住塑料外壳。
- en: 'Then, rearrange them so that the red (power) wire is at one end, the brown
    (GND) wire is in the middle, and the orange (signal) wire is at the opposite end
    of the red wire:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重新排列它们，使红色（电源）线在一端，棕色（地）线在中间，橙色（信号）线在红色线的另一端：
- en: '![Figure 3.2 – Changing the wiring order for the SG90 servo](img/B21282_03_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 改变 SG90 伺服电机的接线顺序](img/B21282_03_2.jpg)'
- en: Figure 3.2 – Changing the wiring order for the SG90 servo
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 改变 SG90 伺服电机的接线顺序
- en: 'With the wiring in the correct order, we can connect the servo motor directly
    to our Raspberry Pi. Using the diagram in *Figure 3**.3* as a reference, connect
    the female 3-prong connector to the +5V, GND, and GPIO 14 pins of the Raspberry
    Pi:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正确的接线顺序下，我们可以直接将伺服电机连接到我们的树莓派。以图 3**.3** 中的图为例，将母头三脚插座连接到树莓派的 +5V、GND 和 GPIO
    14 引脚：
- en: '![Figure 3.3 – Connecting our servo to the Raspberry Pi](img/B21282_03_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 将我们的伺服电机连接到Raspberry Pi](img/B21282_03_3.jpg)'
- en: Figure 3.3 – Connecting our servo to the Raspberry Pi
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 将我们的伺服电机连接到Raspberry Pi
- en: An alternate method for connecting our servo
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 连接我们的伺服电机的另一种方法
- en: For those of us who would rather not modify the existing connector of the servo,
    we may use three male-to-female jumper wires instead, with the male end inserted
    into the connector and the female end inserted into the GPIO port on the Raspberry
    Pi.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不想修改伺服电机现有连接器的人来说，我们可以使用三根公对母跳线代替，公端插入连接器，母端插入Raspberry Pi的GPIO端口。
- en: With our servo motor connected to our Raspberry Pi, let’s investigate what servo
    motors are and how we may use them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的伺服电机连接到我们的Raspberry Pi后，让我们来研究伺服电机是什么以及我们如何使用它们。
- en: Understanding servo motors
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解伺服电机
- en: Servo motors consist of a **direct current** (**DC**) motor, a control circuit,
    and a feedback mechanism for maintaining the angular position of the output shaft.
    Robotics, toys, and radio-controlled cars are some of the applications where servos
    are predominantly used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机由一个**直流**（**DC**）电机、一个控制电路以及一个用于维持输出轴角位置的反馈机制组成。机器人、玩具和遥控汽车是伺服电机主要应用的一些领域。
- en: 'Servo motors stand out for their exceptional precision in controlling the position
    of the motor thanks to their closed-loop feedback mechanism. This mechanism constantly
    monitors the motor’s actual position and adjusts it so that it matches the desired
    position, ensuring accurate and reliable performance. *Figure 3**.4* shows the
    popular SG90 servo motor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机因其闭环反馈机制在控制电机位置方面的卓越精度而脱颖而出。该机制不断监控电机的实际位置，并调整它以匹配所需位置，确保准确可靠的性能。*图3.4*展示了流行的SG90伺服电机：
- en: '![Figure 3.4 – SG90 servo motor](img/B21282_03_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – SG90伺服电机](img/B21282_03_4.jpg)'
- en: Figure 3.4 – SG90 servo motor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – SG90伺服电机
- en: The range of movement for servo motors can vary, depending on the model. Some
    servos are designed for 180-degree movement, making them ideal for limited-range
    applications such as controlling robot joints or stabilizing camera gimbals. Other
    servos are capable of full 360-degree rotation, which makes them suitable for
    continuous motion applications, such as steering mechanisms or pan-tilt camera
    systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的运动范围可能因型号而异。一些伺服电机设计为180度运动，这使得它们非常适合范围受限的应用，如控制机器人关节或稳定相机云台。其他伺服电机能够实现完整的360度旋转，这使得它们适用于连续运动应用，如转向机构或俯仰倾斜相机系统。
- en: 'The angle control of servos is achieved through **pulse-width modulation**
    (**PWM**). PWM involves sending varying pulse widths to the servo, akin to adjusting
    a volume knob to control sound level; in servos, these pulses dictate the arm’s
    position. Different brands of servo have different maximum and minimum values
    to determine the angle of the servo needle. *Figure 3**.5* demonstrates the relationship
    between PWM and the position of a 180-degree servo:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的角度控制是通过**脉冲宽度调制**（**PWM**）实现的。PWM涉及向伺服电机发送不同脉冲宽度，类似于调整音量旋钮来控制音量；在伺服电机中，这些脉冲决定了臂的位置。不同品牌的伺服电机有不同的最大和最小值，用于确定伺服针的角度。*图3.5*展示了PWM与180度伺服电机位置之间的关系：
- en: '![Figure 3.5 – PWM and servo position](img/B21282_03_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – PWM和伺服位置](img/B21282_03_5.jpg)'
- en: Figure 3.5 – PWM and servo position
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – PWM和伺服位置
- en: Armed with our knowledge of the essentials of servo motors and their connection
    to the Raspberry Pi 5, we’ll turn our attention to LEDs. Our exploration will
    cover how they function and the steps to incorporate them into our project, providing
    an additional layer of visual feedback.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了伺服电机的基本原理及其与Raspberry Pi 5的连接方法后，我们将把注意力转向LED。我们的探索将涵盖它们的工作原理以及将它们纳入我们项目的步骤，从而提供额外的视觉反馈层。
- en: Exploring LEDs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LED
- en: LEDs were first developed in the early 1960s. The first LEDs were red and were
    first used as indicators in seven-segment displays. Today, LEDs are virtually
    everywhere – from indicator lights on our electronic devices and home appliances
    to the screens of our televisions and smartphones.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LED最初在20世纪60年代初被开发出来。最早的LED是红色的，最初用于七段显示屏的指示器。如今，LED几乎无处不在——从我们的电子设备和家用电器上的指示灯到电视和智能手机的屏幕。
- en: An LED is a simple semiconductor device. It has two leads – an anode (positive)
    and a cathode (negative). When a forward current passes through the diode from
    the anode to the cathode, it emits light. The color of the light depends on the
    materials that are used to make the diode and can range from infrared to ultraviolet,
    including all the colors of the visible spectrum.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: LED是一种简单的半导体器件。它有两个引脚——阳极（正极）和阴极（负极）。当正向电流从阳极通过二极管流向阴极时，它会发光。光的颜色取决于制造二极管所使用的材料，可以从红外到紫外，包括所有可见光谱的颜色。
- en: 'LEDs come in various types, including single-color LEDs, RGB LEDs, which are
    capable of producing a multitude of colors, infrared LEDs, which are used in remote
    controls and night-vision systems, and bi-color LEDs, which can emit two different
    colors. *Figure 3**.6* shows an array of LEDs ranging from a single-colored red
    to a seven-colored flash LED (second from left) to an RGB (second from right)
    LED capable of displaying any color. For our weather indicator, we will be using
    a single-colored LED. The color doesn’t matter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: LED有多种类型，包括单色LED、RGB LED，能够产生多种颜色，红外LED，用于遥控器和夜视系统，以及双色LED，可以发出两种不同的颜色。*图3.6*显示了从单色红色到七色闪光LED（从左数第二）再到能够显示任何颜色的RGB
    LED（从右数第二）的LED阵列。对于我们的天气指示器，我们将使用单色LED。颜色不重要：
- en: '![Figure 3.6 – LEDs in various formats](img/B21282_03_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 各种格式的LED](img/B21282_03_6.jpg)'
- en: Figure 3.6 – LEDs in various formats
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 各种格式的LED
- en: Now that we have a basic understanding of LEDs, it’s time to connect an LED
    to our Raspberry Pi.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对LED有了基本的了解，是时候将LED连接到我们的树莓派上了。
- en: Connecting an LED to our Raspberry Pi
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LED连接到我们的树莓派
- en: Connecting an LED to a Raspberry Pi requires us to carefully consider voltage
    requirements – exceeding the voltage can cause the LED to burn out. To do this,
    we must solder a resistor to one end of the LED before connecting it to the GPIO
    port with jumper wires. Since the Raspberry Pi’s GPIO pins output at a higher
    voltage than most LEDs can handle directly, the inclusion of the resistor is essential
    to regulate the voltage, ensuring that the LED operates correctly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED连接到树莓派需要我们仔细考虑电压要求——电压过高可能会导致LED烧毁。为此，我们必须在将LED通过跳线连接到GPIO端口之前，将其一端焊接上一个电阻。由于树莓派的GPIO引脚输出的电压高于大多数LED可以直接处理的电压，因此加入电阻对于调节电压至关重要，以确保LED正确运行。
- en: '*Figure 3**.7* shows the materials that we need to connect our LED to the GPIO
    port on the Raspberry Pi – an LED, two jumper wires with female ends (brown and
    red), shrink tubing, and a 220 Ohm resistor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.7*显示了连接我们的LED到树莓派GPIO端口的所需材料——一个LED、两根带有雌性端子的跳线（棕色和红色）、热缩管和一个220欧姆电阻：'
- en: '![Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi](img/B21282_03_7.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 连接我们的LED到树莓派所需的部件](img/B21282_03_7.jpg)'
- en: Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 连接我们的LED到树莓派所需的部件
- en: 'To connect our LED to our Raspberry Pi, we must do the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的LED连接到我们的树莓派，我们必须执行以下操作：
- en: 'Start by soldering the resistor to the anode (positive) or longer leg of the
    LED (see *A* in *Figure 3**.8*):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将电阻焊接在LED的正极（阳极）或较长的腿上（见图3.8中的*A*）：
- en: '![Figure 3.8 – Soldering a resistor and jumper wires to our LED](img/B21282_03_8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 将电阻和跳线焊接到我们的LED上](img/B21282_03_8.jpg)'
- en: Figure 3.8 – Soldering a resistor and jumper wires to our LED
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 将电阻和跳线焊接到我们的LED上
- en: Then, splice and solder the brown jumper wire onto the cathode (negative) leg
    of the LED (see *B* in *Figure 3**.8*).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将棕色跳线焊接在LED的负极（阴极）腿上（见图3.8中的*B*）。
- en: Next, splice and solder the red jumper wire onto the other end of the resistor.
    We may consider the extra length created by the resistor and shorten the red wire
    accordingly (see *B* in *Figure 3**.8*).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将红色跳线焊接在电阻的另一端。我们可以考虑电阻产生的额外长度，并相应地缩短红色电线（见图3.8中的*B*）。
- en: To strengthen the new connections and provide additional electrical insulation,
    apply heat shrink tubing over the soldered wires and resistor (see *C* in *Figure
    3**.8*).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加强新的连接并提供额外的电气绝缘，在焊接的电线和电阻上应用热缩管（见图3.8中的*C*）。
- en: 'Using the jumper wires, attach the brown wire to GPIO GND on the Raspberry
    Pi and the red wire to GPIO 25 (see *Figure 3**.9*):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线，将棕色电线连接到树莓派的GPIO GND，将红色电线连接到GPIO 25（见图3.9）：
- en: '![Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi](img/B21282_03_9.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 将我们的伺服电机和LED连接到Raspberry Pi](img/B21282_03_9.jpg)'
- en: Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 将我们的伺服电机和LED连接到Raspberry Pi
- en: Now that we’ve wired up our servo and LED components, let’s write some code
    so that we can control our components through Python.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了伺服电机和LED组件，让我们编写一些代码，以便我们可以通过Python控制我们的组件。
- en: Controlling servo motors and LEDs using Python
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python控制伺服电机和LED
- en: Having successfully connected the servo motor and LED to our Raspberry Pi, we’ll
    start writing the Python control code. To facilitate this, we will be using the
    **GPIO Zero Python library**, a powerful tool for Raspberry Pi GPIO programming.
    Our first step in this process will be to set up a Python virtual environment
    so that we can develop our code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 成功将伺服电机和LED连接到我们的Raspberry Pi后，我们将开始编写Python控制代码。为了便于操作，我们将使用**GPIO Zero Python库**，这是一个用于Raspberry
    Pi GPIO编程的强大工具。在此过程中的第一步将是设置一个Python虚拟环境，以便我们可以开发我们的代码。
- en: Setting up our development environment
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'Just like we did in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), we will
    use a Python virtual environment for our development. As there are libraries that
    only work with the root installation of Python, we will use system packages in
    our Python virtual environment. To do this, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[*第二章*](B21282_02.xhtml#_idTextAnchor031)中所做的那样，我们将为我们的开发使用Python虚拟环境。由于有一些库只能与Python的根安装一起工作，因此我们将使用系统包在我们的Python虚拟环境中。为此，请按照以下步骤操作：
- en: On our Raspberry Pi 5, open a Terminal application.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi 5上，打开一个终端应用程序。
- en: 'To store our project files, create a new directory by running the following
    command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储我们的项目文件，创建一个新的目录，运行以下命令：
- en: '[PRE0]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, navigate to the new directory:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到新目录：
- en: '[PRE1]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new Python virtual environment for our project:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个新的Python虚拟环境：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: source ch3-env/bin/activate
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: source ch3-env/bin/activate
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the extra packages that are required for our code with the following
    command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装我们代码所需的额外包：
- en: '[PRE4]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: exit
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 退出
- en: '[PRE5]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With our project folder created, our Python virtual environment set up and activated,
    and the `requests` package installed, we may now start writing code. We will start
    by controlling the servo motor through Python code using the Terminal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目文件夹、设置并激活Python虚拟环境以及安装`requests`包之后，我们现在可以开始编写代码。我们将首先通过Python代码使用终端控制伺服电机。
- en: Using GPIO Zero to control a servo
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GPIO Zero控制伺服电机
- en: GPIO Zero is a Python library for controlling the GPIO pins on the Raspberry
    Pi. It was created in 2016 by Ben Nuttall and Dave Jones of the Raspberry Pi Foundation.
    GPIO Zero provides a user-friendly and high-level interface, making it easier
    to work with GPIO, including controlling LEDs, buttons, servos, and more. It comes
    pre-installed with the latest Raspberry Pi operating system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO Zero是一个用于控制Raspberry Pi上GPIO引脚的Python库。它是由Raspberry Pi基金会的Ben Nuttall和Dave
    Jones于2016年创建的。GPIO Zero提供了一个用户友好的高级接口，使得与GPIO一起工作更加容易，包括控制LED、按钮、伺服电机等。它随最新的Raspberry
    Pi操作系统预安装。
- en: 'The `Servo` class is a part of GPIO Zero and provides a way to control a servo
    motor. To test our servo motor’s connection to our Raspberry Pi, follow these
    steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Servo`类是GPIO Zero的一部分，提供了一种控制伺服电机的方法。为了测试我们的伺服电机与Raspberry Pi的连接，请按照以下步骤操作：'
- en: 'Open a Terminal window and navigate to our project folder by running the following
    command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，通过运行以下命令导航到我们的项目文件夹：
- en: '[PRE6]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'ch3-env virtual environment and launch Python with the following command:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下命令启动ch3-env虚拟环境并运行Python：
- en: '[PRE7]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: from gpiozero import Servo
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from gpiozero import Servo
- en: 'Servo class provides several useful methods to control a servo motor. To set
    the servo to the minimum position, run the following command:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 伺服类提供了几个有用的方法来控制伺服电机。要将伺服设置到最小位置，运行以下命令：
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing this command, we should notice that our servo motor has pivoted
    completely to one side. To move our servo motor to the middle position, we can
    use the following Python command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该注意到我们的伺服电机已经完全转向一侧。为了将我们的伺服电机移动到中间位置，我们可以使用以下Python命令：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After executing this command, we should observe that our servo motor has moved
    to the mid position. For the final test, we’ll move our servo motor to the maximum
    position:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该观察到我们的伺服电机已经移动到中间位置。对于最终测试，我们将把伺服电机移动到最大位置：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should observe that our servo motor moves to the maximum position (we shouldn’t
    be alarmed if the motor doesn’t move as far to the maximum position as it does
    to the minimum position as we will calibrate the motor later in this chapter).
    To close our servo connection, run the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到伺服电机移动到最大位置（如果我们发现电机没有移动到最大位置，就像它移动到最小位置一样，请不要担心，我们将在本章后面校准电机）。要关闭我们的伺服连接，请运行以下命令：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Why is the servo motor jittering?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么伺服电机会抖动？
- en: We may observe jittering from our SG90 servo motor when it’s controlled through
    GPIO Zero. A multitude of factors may contribute to this issue, ranging from the
    power provided to the servo via the GPIO port, to potential mechanical problems
    with the servo, or even software-related issues within the library. Although an
    investigation into these causes falls outside the scope of this project, we must
    acknowledge the potential for motor jittering. A straightforward solution involves
    closing the connection to the servo using the `servo.close()` command after setting
    its position.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的SG90伺服电机通过GPIO Zero控制时，我们可能会观察到抖动。许多因素可能导致这个问题，从通过GPIO端口提供给伺服电机的电源，到伺服电机可能存在的机械问题，甚至库内的软件相关的问题。尽管对这些原因的调查超出了本项目范围，但我们必须承认电机抖动的可能性。一个简单的解决方案是在设置位置后，使用`servo.close()`命令关闭与伺服电机的连接。
- en: With our servo motor tested, we can focus on the LED. In the next section, we
    will write some code to control the status of our LED using the GPIO library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的伺服电机后，我们可以专注于LED。在下一节中，我们将编写一些代码来使用GPIO库控制我们的LED状态。
- en: Using GPIO Zero to control an LED
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GPIO Zero控制LED
- en: 'The `LED` class is a part of the GPIO Zero library and provides a simple interface
    to control an LED. We can use this class to control our LED. To test the connection
    of our LED, follow these steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`LED`类是GPIO Zero库的一部分，提供了一个简单的接口来控制LED。我们可以使用这个类来控制我们的LED。要测试我们的LED连接，请按照以下步骤操作：'
- en: 'First, open a new Terminal window and navigate to our project folder with the
    following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口，并使用以下命令导航到我们的项目文件夹：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: source ch3-env/bin/activate
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: source ch3-env/bin/activate
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Launch Python by running the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令启动Python：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: from gpiozero import LED
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from gpiozero import LED
- en: 'LED class provides several useful methods to control an LED. To turn on the
    LED, type the following:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LED类提供了几个有用的方法来控制LED。要打开LED，请输入以下命令：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After executing this command, we should notice that our LED has turned on.
    For the next test, we’ll turn our LED off by running the following Python command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该注意到我们的LED已经打开。对于下一个测试，我们将通过以下Python命令关闭LED：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After executing this command, we should observe that our LED has turned off.
    For the final test, we’ll blink our LED:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该观察到LED已经关闭。对于最后的测试，我们将闪烁LED：
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We should observe that our LED starts blinking. To stop this and turn the LED
    off, run the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到LED开始闪烁。要停止闪烁并关闭LED，请运行以下命令：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Should we encounter issues during testing, there could be several potential
    causes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在测试过程中遇到问题，可能有几个潜在的原因：
- en: '**Incorrect wiring**: Incorrect wiring is among the most common problems. It’s
    crucial to verify our connections and ensure we’ve wired the correct GPIO pin
    according to our Python script.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接线错误**：接线错误是最常见的问题之一。验证我们的连接并确保我们根据Python脚本正确接线GPIO引脚至关重要。'
- en: '**Issues with the power supply**: Power supply inadequacies might also lead
    to issues. While the Raspberry Pi’s GPIO pins may not supply adequate power for
    certain servos, especially under load, causing the servo to act unpredictably,
    our SG90 servo and LED shouldn’t face this issue, given they have a lower power
    demand.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源问题**：电源不足也可能导致问题。虽然Raspberry Pi的GPIO引脚可能无法为某些伺服电机提供足够的电源，尤其是在负载下，导致伺服电机行为不可预测，但鉴于我们的SG90伺服电机和LED的功率需求较低，它们不应该遇到这个问题。'
- en: '**Software**: Software-related issues could also pose problems. Keeping the
    Raspberry Pi OS and GPIO Zero library up to date is an essential preventative
    measure.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件**：软件相关的问题也可能导致问题。保持Raspberry Pi OS和GPIO Zero库的最新状态是一项基本的预防措施。'
- en: '**Components**: Issues could lie within the components themselves. By testing
    them with a known, functioning device, we can either confirm or rule out this
    possibility.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：问题可能存在于组件本身。通过使用已知的工作设备测试它们，我们可以确认或排除这种可能性。'
- en: Now that we’ve tested our servo and LED components alongside the corresponding
    code, we can construct the stand that will house our project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了我们的伺服和LED组件以及相应的代码，我们可以构建一个支架来容纳我们的项目。
- en: Building the weather indicator stand
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气指示支架
- en: In this section, our focus will shift to assembling the stand for our weather
    indicator. While it’s not imperative for running the code, building the stand
    is highly recommended as it adds a tangible, real-world aspect to our project,
    bringing the *thing* in IoT to life.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的重点将转向组装天气指示支架。虽然运行代码不是必需的，但构建支架强烈推荐，因为它为我们的项目增添了有形、现实世界的元素，使物联网中的“事物”栩栩如生。
- en: While this book does not provide a comprehensive guide on 3D printing, we will
    briefly outline the key steps involved in fabricating the stand. We’ll be using
    a standard **fused deposition modeling** (**FDM**) printer, ideally one with a
    print size such as the “Ender-3” (220mm x 220mm x 250mm). Our material of choice
    for this exercise is **polylactic acid** (**PLA**) since it’s known for its ease
    of use and suitability for beginners. Alternatively, **polyethylene terephthalate
    glycol-modified** (**PETG**) is also a great option, offering enhanced strength
    and flexibility. We’ll go through the basics of printing and assembling the stand
    components here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书并没有提供关于3D打印的全面指南，但我们将简要概述制造支架的关键步骤。我们将使用标准的**熔融沉积建模**（**FDM**）打印机，理想情况下是像“Ender-3”这样的打印机（220mm
    x 220mm x 250mm）。在这个练习中，我们选择**聚乳酸**（**PLA**）作为材料，因为它易于使用，非常适合初学者。另外，**聚对苯二甲酸乙二醇酯改性**（**PETG**）也是一个很好的选择，它提供了增强的强度和灵活性。在这里，我们将介绍打印和组装支架组件的基本知识。
- en: Should I print in PLA or PETG?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该打印PLA还是PETG？
- en: When deciding whether to print in PLA or PETG, there are several factors for
    us to consider. PLA is known for its ease of use, making it a popular choice for
    beginners. It prints at lower temperatures, doesn’t warp as easily as other materials,
    and generally provides more precise details. PETG is known for its strength and
    flexibility, which surpasses that of PLA. PETG prints at a higher temperature
    than PLA and has excellent layer adhesion, resulting in more robust prints. However,
    PETG can be more challenging to print with due to its tendency to string or ooze.
    For the weather indicator stand we built for this chapter, PLA was used. This
    was because printing was done directly on a glass plate and PETG tends to stick
    too well to glass, potentially resulting in damage being done to the build plate
    upon removing the print.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否打印PLA或PETG时，我们需要考虑几个因素。PLA因其易于使用而闻名，是初学者的热门选择。它以较低的温度打印，不像其他材料那样容易变形，并且通常提供更精确的细节。PETG以其强度和灵活性而闻名，超过了PLA。PETG的打印温度高于PLA，并且具有出色的层间粘合性，从而产生更坚固的打印件。然而，由于PETG有拉丝或滴漏的倾向，打印起来可能更具挑战性。对于本章中我们构建的天气指示支架，我们使用了PLA。这是因为打印是在玻璃板上直接进行的，而PETG容易粘附在玻璃上，可能会在移除打印件时损坏构建板。
- en: For those of us who do not have access to a 3D printer or prefer not to print
    the parts ourselves, using a 3D printing service such as Shapeways ([https://www.shapeways.com](https://www.shapeways.com))
    is a convenient alternative.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些没有3D打印机或者不愿意自己打印部件的人来说，使用Shapeways（[https://www.shapeways.com](https://www.shapeways.com)）等3D打印服务是一个方便的替代方案。
- en: Now that we’ve covered the options for obtaining our 3D-printed parts, either
    by printing them ourselves or using a service, let’s move on to the next crucial
    phase of our project – assembling the weather indicator stand.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了获取3D打印部件的选项，无论是自己打印还是使用服务，让我们继续进行项目的下一个关键阶段——组装天气指示支架。
- en: Assembling the weather indicator stand
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装天气指示支架
- en: As mentioned previously, the weather indicator stand has been engineered to
    be composed of components produced via an FDM 3D printer. Unlike the SenseHAT
    case and stand from *Chapters 1* and *2*, the design approach for this weather
    indicator stand is built with a *plate-like* configuration. This method effectively
    eliminates thin horizontal walls, a structural vulnerability that’s frequently
    found in parts created with FDM technology.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，天气指示支架已被设计成由FDM 3D打印机生产的组件组成。与第1章和第2章中的SenseHAT外壳和支架不同，这个天气指示支架的设计方法是采用**板状**配置。这种方法有效地消除了在FDM技术制造的部件中常见的薄水平墙，这是一种结构上的弱点。
- en: Finding the files for 3D printing
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找3D打印的文件
- en: The 3D model files for the parts, which have been specifically designed for
    3D printing, can be downloaded from the `Build Files` directory in this chapter’s
    GitHub repository. Please note that these files are provided in the .stl format
    only, not in other 3D model file formats.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 针对特定3D打印的部件的3D模型文件可以从本章GitHub仓库的“构建文件”目录中下载。请注意，这些文件仅提供.stl格式，不提供其他3D模型文件格式。
- en: Before we start constructing our stand, let’s look at the parts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建我们的支架之前，让我们看看这些部件。
- en: Identifying the parts
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别部件
- en: '*Figure 3**.10* shows the parts that make up the weather indicator stand. All
    the parts, except for the base, were printed on an FDM 3D printer. Two additional
    parts – a half-inch PVC pipe and the front sticker – aren’t shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.10*显示了组成气象指示器支架的部件。所有部件，除了底座外，都是使用FDM 3D打印机打印的。另外两个部件——半英寸PVC管和前贴纸——未显示：'
- en: '![Figure 3.10 – Parts of the weather indicator stand](img/B21282_03_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 气象指示器支架部件](img/B21282_03_10.jpg)'
- en: Figure 3.10 – Parts of the weather indicator stand
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 气象指示器支架部件
- en: 'Let’s take a closer look at each part:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每个部件：
- en: '**Base**: The base serves as the foundation for our stand. It’s the component
    where the **pipe base** is fastened. While the base is an integral part of the
    design, it can be considered optional, depending on the specific installation.
    For instance, the stand could be attached directly to a table, wall, or even a
    ceiling, offering flexible positioning based on individual preferences and requirements.
    The base displayed in *Figure 3**.10* was created out of 20mm pine wood using
    a CNC router (a computer-controlled cutting machine that’s used for cutting various
    hard materials, such as wood), although a 3D printer may be used to make this
    part as well.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底座**：底座作为支架的基础。这是固定**管状底座**的组件。虽然底座是设计的一部分，但它可以根据具体的安装情况被认为是可选的。例如，支架可以直接固定在桌子上、墙上，甚至天花板上，根据个人偏好和需求提供灵活的定位。图3.10中显示的底座是用20毫米松木通过CNC路由器（一种用于切割各种硬材料的计算机控制切割机）制作的，尽管也可以使用3D打印机来制作这个部件。'
- en: '**Back plate and front plate**: These halves, when glued together, form the
    stand’s plate. The division into halves aligns with the need for a flat surface
    in 3D printing, given the plate’s lack of an inherent flat side. The plate is
    the main component of our stand as it holds the servo motor, arrow, and Raspberry
    Pi, which is attached to the back. The plate has been designed to hold either
    a Raspberry Pi, a Raspberry Pi Zero, or a Raspberry Pi Pico W.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后板和前板**：这些半块粘合在一起形成支架的板。将它们分成两半是为了适应3D打印时需要平坦表面的需求，因为板本身没有固有的平坦面。板是我们支架的主要组件，因为它支撑着伺服电机、箭头和连接在背面的Raspberry
    Pi。板被设计成可以容纳Raspberry Pi、Raspberry Pi Zero或Raspberry Pi Pico W。'
- en: '**Plate hook**: Designed to be compatible with GoPro series stands, the hook
    provides the main connection of the plate on the stand. Of note here is the deliberate
    printing orientation and built-in support of the plate hook to eliminate line
    adhesion issues that would cause the plate hook to break apart if printed in the
    traditional flat side down (see *Figure 3**.11*):'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**板钩**：设计成与GoPro系列支架兼容，该钩子提供了板上板的主要连接。值得注意的是，板钩的故意打印方向和内置支撑消除了如果以传统平放方式打印（见图3.11）可能会导致的线粘附问题：'
- en: '![Figure 3.11 – Plate hook print orientation](img/B21282_03_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 板钩打印方向](img/B21282_03_11.jpg)'
- en: Figure 3.11 – Plate hook print orientation
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 板钩打印方向
- en: '**Pipe base and plate bracket**: These two components hold the ½ inch PVC pipe
    (not shown). The pipe base attaches the PVC pipe to the base and the plate bracket
    attaches the PVC pipe to the plate hook.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管状底座和板支架**：这两个组件固定了1/2英寸PVC管（未显示）。管状底座将PVC管固定到底座上，板支架将PVC管固定到板钩上。'
- en: '**8mm LED holder**: We utilize the LED holder to fasten the LED onto the front
    of the main plate face.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8mm LED固定器**：我们使用LED固定器将LED固定在主板面的前面。'
- en: '**Arrow**: The arrow is connected to the servo motor and acts as the analog
    needle for our weather indicator application.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**箭头**：箭头连接到伺服电机，作为我们气象指示应用中的模拟指针。'
- en: '**Alignment tool**: This tool acts as a guide that aligns the back plate and
    front plate correctly during gluing, ensuring they are properly aligned to avoid
    any issues when installing the servo motor.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐工具**：这个工具在粘合时作为引导，确保后板和前板正确对齐，避免安装伺服电机时出现任何问题。'
- en: '**PVC pipe (not shown)**: The stand features a half-inch PVC pipe serving as
    its stem or central support. This design offers the flexibility to adjust the
    stand’s height according to our needs. In situations where the base is unnecessary,
    such as when securing it to a table, wall, or ceiling, we can easily set the stand’s
    height to the desired level.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PVC管（未显示）**：支架配备了一英寸半的PVC管，作为其茎或中心支撑。这种设计提供了根据我们的需求调整支架高度的灵活性。在不需要底座的情况下，例如将其固定在桌子上、墙上或天花板上，我们可以轻松地将支架的高度调整到所需水平。'
- en: '`Silhouette` file and a `.svg` file with the cut lines in the `Build Files`
    folder of our GitHub repository.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Silhouette`文件和`.svg`文件，其中包含切割线，位于我们GitHub仓库的“Build Files”文件夹中。'
- en: '**M5 20mm bolt and M5 nut (not shown)**: To fasten the plate to the pedestal
    portion of the stand, we use a 20mm M5 bolt and corresponding M5 nut.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M5 20mm螺栓和M5螺母（未显示）**：为了将板固定在支架的底座部分，我们使用20mm的M5螺栓和相应的M5螺母。'
- en: With the parts identified, let’s start by creating the main plate for our stand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了部件后，让我们开始创建支架的主板。
- en: Assembling the plate
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装板
- en: 'The plate or face of the weather indicator stand is created by gluing the front
    plate and back plate together. To assemble the plate, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 气象指示器支架的板或面板是通过将前板和后板粘合在一起制成的。要组装板，请按照以下步骤操作：
- en: 'First, apply epoxy glue to the flat side of one of the plates (see *A* in *Figure
    3**.12*). When applying glue, it’s crucial to avoid spreading glue near the servo
    or LED openings. It’s recommended to apply glue right to the boundaries of the
    plate:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将环氧胶水涂抹在其中一个板的平面一侧（见图3.12中的*A*）。涂抹胶水时，务必避免在伺服器或LED开口附近涂抹。建议将胶水直接涂抹在板的边界处：
- en: '![Figure 3.12 – Assembling the plate](img/B21282_03_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 组装板](img/B21282_03_12.jpg)'
- en: Figure 3.12 – Assembling the plate
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 组装板
- en: After applying glue, put the flat sides of the plates together. Using the alignment
    tool, ensure that the plates are aligned with each other (see *B* in *Figure 3**.12*).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在涂抹胶水后，将板的平面放在一起。使用对齐工具，确保板相互对齐（见图3.12中的*B*）。
- en: Once the plates have been aligned, remove the alignment tool.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦板对齐，移除对齐工具。
- en: Should it be needed, use clamps on the plates to prevent any space from forming
    between them. Let the glue dry before proceeding (see *C* in *Figure 3**.12*).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在板上使用夹具以防止它们之间形成间隙。在继续之前，让胶水干燥（见图3.12中的*C*）。
- en: After the plates have dried, apply epoxy glue to the flat part of the hook and
    place it in the groove on the back of the plate (see *D* in *Figure 3**.12*).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在板干燥后，将环氧胶水涂抹在钩子的平面部分，并将其放置在板的背面凹槽中（见图3.12中的*D*）。
- en: After the glue has dried, paint the plate if you wish.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 胶水干燥后，如果您愿意，可以对板进行喷漆。
- en: 'To finish off the assembly, print and cut out the face sticker and apply it
    to the front of the plate inside the ridges (see *A* and *B* in *Figure* *3**.13*,
    respectively):'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成组装，打印并裁剪出面贴纸，并将其贴在板前侧的凹槽内（分别见图3.13中的*A*和*B*）：
- en: '![Figure 3.13 – Plate face sticker](img/B21282_03_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 板面贴纸](img/B21282_03_13.jpg)'
- en: Figure 3.13 – Plate face sticker
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 板面贴纸
- en: With the main plate constructed, it is now time to build the pedestal, which
    will hold the main plate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 主板构建完成后，现在是时候构建底座了，它将支撑主板。
- en: Assembling the pedestal
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装底座
- en: 'The pedestal portion of our stand includes the base, the pipe base, the PVC
    pipe, and the plate bracket. To assemble the pedestal, follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们支架的底座部分包括底座、管底座、PVC管和板支架。要组装底座，请按照以下步骤操作：
- en: 'Start by inserting the PVC pipe (cut to a desired length) into the pipe base
    (see *A* in *Figure 3**.14*):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将切割到所需长度的PVC管插入管底座（见图3.14中的*A*）：
- en: '![Figure 3.14 – Assembling the pedestal](img/B21282_03_14.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 组装底座](img/B21282_03_14.jpg)'
- en: Figure 3.14 – Assembling the pedestal
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 组装底座
- en: Then, secure the pipe base to the base, table, wall, or ceiling as desired (see
    *B* in *Figure 3**.14*).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据需要将管底座固定在底座、桌子、墙壁或天花板上（见图3.14中的*B*）。
- en: To finish assembling the pedestal, insert the plate bracket into the top of
    the PVC pipe (see *C* in *Figure 3**.14*).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成底座的组装，将板支架插入PVC管的顶部（见图3.14中的*C*）。
- en: 'Pay attention when assembling the pedestal as variations in the manufacturer’s
    PVC pipe could result in an improper fit or difficulty when inserting it into
    the pedestal parts. If the pipe fits too loosely, it is recommended to apply epoxy
    glue to securely attach the pipe. Conversely, if the pipe is too thick to fit
    properly, we have two options: either sand down the insides of the pipe base or
    plate bracket or sand the outside of the pipe to achieve a proper and snug fit.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装底座时请注意，制造商的PVC管可能会有变化，这可能导致安装不当或插入底座部件时困难。如果管子太松，建议使用环氧胶将其牢固地固定。相反，如果管子太厚而无法正确安装，我们有两个选择：要么打磨管底或板支架的内侧，要么打磨管的外侧以实现正确且紧密的安装。
- en: It’s important to be aware that in our example, the components of the pedestal
    were coated with flat black spray paint, so any additional thickness resulting
    from the paint should be considered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在我们的例子中，底座的组件被涂上了平黑色喷漆，因此任何由油漆引起的额外厚度都应该考虑在内。
- en: With the pedestal components constructed, we’re ready to integrate our electronic
    components into our weather indicator stand.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 底座组件构建完成后，我们就可以将电子组件集成到我们的天气指示器支架上了。
- en: Installing the Raspberry Pi, servo, and LED
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Raspberry Pi、伺服电机和LED
- en: With our plate and pedestal constructed, the last thing we must do before putting
    the stand together is install our Raspberry Pi, servo motor, and LED onto the
    plate and wire all these components together.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的板和底座构建完成后，在组装支架之前，我们必须做的最后一件事是将我们的Raspberry Pi、伺服电机和LED安装到板上，并将所有这些组件连接在一起。
- en: 'To do this, follow these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: Utilizing 10mm M2.5 bolts, fasten our Raspberry Pi to the base of the plate,
    ensuring it aligns correctly with the appropriate stand-offs (see *A* in *Figure
    3**.15*).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用10mm M2.5螺栓，将我们的Raspberry Pi固定在板的底部，确保它与适当的支架正确对齐（见*图3**.15*中的*A*）。
- en: 'With the aid of a hot glue gun (preferred) or epoxy glue, secure our SG90 servo
    to the rear side of the plate. To do this, align the front structure of the SG90
    with the hole present in the plate (see *B* in *Figure 3**.15*):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在热胶枪（推荐）或环氧胶的帮助下，将我们的SG90伺服电机固定在板的背面。为此，将SG90的前结构对准板上的孔（见*图3**.15*中的*B*）：
- en: '![Figure 3.15 – Installing the Raspberry Pi, servo, and LED](img/B21282_03_15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 安装Raspberry Pi、伺服电机和LED](img/B21282_03_15.jpg)'
- en: Figure 3.15 – Installing the Raspberry Pi, servo, and LED
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.15* – 安装Raspberry Pi、伺服电机和LED'
- en: Referring to the wiring diagrams in *Figure 3**.3* and *Figure 3**.9*, wire
    up our servo motor and LED to the GPIO port of the Raspberry Pi (see *C* in *Figure
    3**.15*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考图3**.3*和图3**.9*中的接线图，将伺服电机和LED连接到Raspberry Pi的GPIO端口（见*图3**.15*中的*C*）。
- en: 'With our Raspberry Pi wired up, it’s time to put the LED in place. Start by
    threading the LED through the LED hole in the plate (see *A* in *Figure 3**.16*):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi布线完成后，是时候将LED安装到位了。首先，将LED通过板上的LED孔（见*图3**.16*中的*A*）：
- en: '![Figure 3.16 – Putting our LED in place](img/B21282_03_16.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 将我们的LED安装到位](img/B21282_03_16.jpg)'
- en: Figure 3.16 – Putting our LED in place
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.16* – 将我们的LED安装到位'
- en: Then, thread the LED through the LED holder and push the holder into the LED
    hole in the front of the plate (see *B* in *Figure 3**.16*).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将LED通过LED支架，并将支架推入板子前端的LED孔中（见*图3**.16*中的*B*）。
- en: With our plate fully wired and all the components securely fastened, we can
    attach the plate to the pedestal.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在板完全布线和所有组件牢固固定后，我们可以将板固定到底座上。
- en: Connecting the plate to the pedestal
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接板到底座
- en: By attaching the plate to the pedestal, we will have finished constructing our
    weather indicator stand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将板固定到底座上，我们将完成天气指示器支架的构建。
- en: 'To complete our stand, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的支架，请按照以下步骤操作：
- en: 'Start by aligning the hook on the back of the plate with the plate bracket
    on the pedestal (*A* in *Figure 3**.17*):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将板背面的钩子与底座的板支架对齐（*图3**.17*中的*A*）：
- en: '![Figure 3.17 – Attaching the plate to the pedestal](img/B21282_03_17.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 将板固定到底座上](img/B21282_03_17.jpg)'
- en: Figure 3.17 – Attaching the plate to the pedestal
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.17* – 将板固定到底座上'
- en: Then, insert a 20mm M5 bolt and fasten it with an M5 nut (see the red rectangle
    in *A* in *Figure 3**.17*).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，插入一个20mm M5螺栓，并用M5螺母固定（见*图3**.17*中的*A*处的红色矩形）。
- en: Finally, make any final adjustments to the angle of the plate before tightening
    the bolt fully (see *B* in *Figure 3**.17*).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在完全拧紧螺栓之前，对板的倾斜角度进行任何最终调整（见*图3**.17*中的*B*）。
- en: With that, we’ve finished assembling our weather indicator stand. This setup
    could be repurposed for many other IoT applications, including monitoring traffic
    conditions or tracking fluid levels in industrial environments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了我们的天气指示器支架的组装。这个设置可以用于许多其他物联网应用，包括监控交通状况或跟踪工业环境中的液体水平。
- en: Our next step is to write the code that will retrieve weather data from a web
    service and use it to control the servo motor and LED. Now is also the best time
    to introduce the arrow into our setup as it needs to be calibrated before it can
    be used in our code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是编写代码，从网络服务检索天气数据，并使用它来控制伺服电机和LED。现在也是将箭头引入我们的设置的最佳时机，因为它在使用代码之前需要校准。
- en: Developing code for our application
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序开发代码
- en: In this section, we will connect our Raspberry Pi to the `OpenWeatherMap.org`
    web service and use the data to control the position of the needle on our weather
    indicator. For this, we need to use the API key we received from `OpenWeatherMap.org`
    when we set up an account in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把我们的树莓派连接到`OpenWeatherMap.org`网络服务，并使用这些数据来控制我们天气指示器上针的位置。为此，我们需要使用我们在`OpenWeatherMap.org`上设置账户时收到的API密钥，如[*第二章*](B21282_02.xhtml#_idTextAnchor031)中所述。
- en: Throughout this section, our Raspberry Pi, once mounted, will remain connected
    to a monitor, keyboard, and mouse. When the moment arrives to set up our weather
    indicator independently, all we’ll need is a power source and a means to remotely
    access the Raspberry Pi via SSH. Discussing how to configure a Raspberry Pi so
    that it can operate in *headless* mode falls outside the scope of this chapter.
    However, detailed instructions for this setup can easily be found through various
    online resources. Helpful starting points include the official Raspberry Pi documentation,
    technology-focused forums such as Stack Overflow, and dedicated Raspberry Pi community
    websites and blogs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，一旦安装，我们的树莓派将始终连接到显示器、键盘和鼠标。当需要独立设置我们的天气指示器时，我们只需要电源和一种通过SSH远程访问树莓派的方法。讨论如何配置树莓派以使其能够在*无头*模式下运行超出了本章的范围。然而，通过各种在线资源可以轻松找到此设置的详细说明。有用的起点包括官方树莓派文档、专注于技术的论坛如Stack
    Overflow，以及专门的树莓派社区网站和博客。
- en: 'We will follow the software architecture laid out in *Figure 3**.18* for our
    code. At the heart of our architecture is the `WeatherData` class. We will use
    this class to connect to the OpenWeatherMap web service:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循*图3.18*中概述的软件架构来编写我们的代码。我们架构的核心是`WeatherData`类。我们将使用这个类来连接到OpenWeatherMap网络服务：
- en: '![Figure 3.18 – Software architecture for our weather indicator](img/B21282_03_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 我们天气指示器的软件架构](img/B21282_03_18.jpg)'
- en: Figure 3.18 – Software architecture for our weather indicator
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 我们天气指示器的软件架构
- en: 'The `WeatherData` class fetches and processes weather data from the OpenWeatherMap
    API, while the `WeatherDashboard` class controls the display mechanisms: a needle
    indicator controlled by a servo motor and an LED that changes state based on the
    weather conditions.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherData`类从OpenWeatherMap API获取并处理天气数据，而`WeatherDashboard`类控制显示机制：一个由伺服电机控制的指针指示器和根据天气状况改变状态的LED。'
- en: These two classes work together, with `WeatherData` fetching and processing
    data, which is then used by `WeatherDashboard` to adjust the display. To keep
    the data current, the `update_dashboard()` function is set to run in an infinite
    loop, refreshing weather data and updating the display every 30 minutes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类协同工作，`WeatherData`获取并处理数据，然后由`WeatherDashboard`用于调整显示。为了保持数据最新，`update_dashboard()`函数被设置为在无限循环中运行，每30分钟刷新天气数据并更新显示。
- en: To address the unique hardware constraint of the servo motor – that is, its
    tendency to jitter if the connection is not closed after a move – we’ll create
    a fresh instance of `WeatherDashboard` (and consequently, a new `Servo` instance)
    with every cycle of the loop. While this approach may not be the most common in
    software design, it’s a practical solution that successfully solves the servo
    jitter issue by *reopening* the connection with each new instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决伺服电机的独特硬件限制——即，如果移动后连接未关闭，则其倾向于抖动——我们将在循环的每个周期中创建一个新的`WeatherDashboard`实例（以及因此，一个新的`Servo`实例）。虽然这种方法在软件设计中可能不是最常见的方法，但它是一种实用的解决方案，通过*重新打开*每个新实例的连接成功地解决了伺服抖动问题。
- en: We’ll begin by calibrating the arrow’s (or needle’s) position for optimal application
    performance before we create our `WeatherData` and `WeatherDashboard` classes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先调整箭头（或指针）的位置以实现最佳应用性能，然后再创建我们的`WeatherData`和`WeatherDashboard`类。
- en: Calibrating the needle
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整指针
- en: 'Before we can use our weather indicator application, we must calibrate the
    needle (or the position of the arrow). To do so, follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用我们的天气指示器应用程序之前，我们必须调整指针（或箭头的位置）。为此，请按照以下步骤操作：
- en: 'Close any open Terminals, open a new Terminal window, and navigate to our project
    folder by running the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭任何打开的终端，打开一个新的终端窗口，并运行以下命令导航到我们的项目文件夹：
- en: '[PRE22]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: source ch3-env/bin/activate
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: source ch3-env/bin/activate
- en: '[PRE23]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Launch Python with the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动Python：
- en: '[PRE24]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: from gpiozero import Servo
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from gpiozero import Servo
- en: servo = Servo(14)
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: servo = Servo(14)
- en: '[PRE25]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, set the servo to the mid position with the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令将伺服电机设置为中间位置：
- en: '[PRE26]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the picture of the face of our weather indicator, install the arrow into
    the servo in the mid position.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们天气指示器面部的图片，将箭头安装到伺服电机的中位位置。
- en: 'With the needle (arrow) in place, let’s do some testing. We will start by moving
    the needle to the minimum position with the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指针（箭头）就位后，让我们进行一些测试。我们将首先使用以下命令将指针移动到最小位置：
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are now ready to write code to control the needle and LED on our weather
    indicator. We will start with the `WeatherData` class.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写代码来控制天气指示器上的指针和LED。我们将从`WeatherData`类开始。
- en: Creating the WeatherData class
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建WeatherData类
- en: The `WeatherData` class is designed to pull weather information for a given
    city using the OpenWeatherMap API, after which it will process this data to calculate
    servo and LED values based on the temperature, wind speed, and weather conditions.
    When initialized with a city name, the class fetches the weather data for that
    city and stores the temperature, weather conditions, and wind speed. It also provides
    methods, `getServoValue()` and `getLEDValue()`, to determine the output for the
    servo motor and LED, respectively, based on the retrieved weather data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherData`类旨在使用OpenWeatherMap API获取特定城市的天气信息，之后它将根据温度、风速和天气状况处理这些数据来计算伺服电机和LED的值。当用城市名称初始化时，该类会获取该城市的天气数据，并存储温度、天气状况和风速。它还提供了`getServoValue()`和`getLEDValue()`方法，分别根据检索到的天气数据确定伺服电机和LED的输出。'
- en: 'Let’s get started:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny** (*Figure
    3**.19*):'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击树莓派任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**（*图3**.19*）来启动Thonny：
- en: '![Figure 3.19 – Opening Thonny from the main menu](img/B21282_03_19.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – 从主菜单打开Thonny](img/B21282_03_19.jpg)'
- en: Figure 3.19 – Opening Thonny from the main menu
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 从主菜单打开Thonny
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it isn’t already selected.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Thonny使用树莓派内置的Python版本。对于我们的项目，我们将使用我们刚刚创建的Python虚拟环境。首先，我们需要通过点击**查看**并选择**文件**来查看项目文件（如果尚未选择）。
- en: In the `ch3-env` directory.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch3-env`目录下。
- en: Then, right-click on the folder and select **Activate** **virtual environment**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击文件夹并选择**激活** **虚拟环境**。
- en: Once inside Thonny, create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入Thonny，通过选择**文件**然后**新建**或按*Ctrl* + *N*键在键盘上创建一个新的标签页。
- en: 'Let’s start our code by entering our imports:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从输入我们的导入开始：
- en: '[PRE28]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `import requests` imports the `requests` library from Python, which is
    used to send HTTP requests, such as GET and POST requests, to interact with APIs
    or web services (refer to [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), for
    clarification on HTTP requests).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`import requests`从Python导入`requests`库，该库用于发送HTTP请求，如GET和POST请求，以与API或Web服务交互（有关HTTP请求的说明，请参阅[*第2章*](B21282_02.xhtml#_idTextAnchor031)）。
- en: 'Then, define our class name, `WeatherData`, and our class variables:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义我们的类名`WeatherData`和类变量：
- en: '[PRE29]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our constructor takes one parameter, `city`. Make the call to the OpenWeatherMap
    web service in the constructor (when an instance of the `WeatherData` class is
    created):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的构造函数接受一个参数，`city`。在构造函数中调用OpenWeatherMap Web服务（当创建`WeatherData`类的实例时）：
- en: '[PRE30]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s take a closer look at our code:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的代码：
- en: '`self.city = city`: saves the city name to the object’s property'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.city = city`：将城市名称保存到对象的属性中'
- en: '`api_key = ''xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''`: Sets the OpenWeatherMap API
    key'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api_key = ''xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''`：设置OpenWeatherMap API密钥'
- en: '`base_url = "http://api.openweathermap.org/data/2.5/weather"`: Sets the base
    URL for the OpenWeatherMap API'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base_url = "http://api.openweathermap.org/data/2.5/weather"`：设置OpenWeatherMap
    API的基础URL'
- en: '`complete_url = f"{base_url}?q={self.city}&appid={api_key}&units=metric"`:
    Formats the full API URL with the city and API key'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete_url = f"{base_url}?q={self.city}&appid={api_key}&units=metric"`：使用城市和API密钥格式化完整的API
    URL'
- en: '`response = requests.get(complete_url)`: Sends a GET request to the API and
    saves the response'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response = requests.get(complete_url)`：向API发送GET请求并保存响应'
- en: '`data = response.json()`: Converts the API response from JSON format into a
    Python dictionary'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data = response.json()`：将API响应从JSON格式转换为Python字典'
- en: '`if data["cod"] != "404"`: Checks whether the API response is not a 404 error,
    which would indicate that the city was not found'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if data["cod"] != "404"`：检查API响应是否不是404错误，这表明找不到城市'
- en: '`self.temperature = main["temp"]`: Saves the current temperature in the city
    to the object’s property'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.temperature = main["temp"]`：将城市当前温度保存到对象的属性中'
- en: '`self.weather_conditions = weather[0]["main"]`: Saves the current weather conditions
    in the city to the object’s property'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.weather_conditions = weather[0]["main"]`：将城市当前天气状况保存到对象的属性中'
- en: '`self.wind_speed = wind["speed"]`: Saves the current wind speed in the city
    to the object’s property'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.wind_speed = wind["speed"]`：将城市当前风速保存到对象的属性中'
- en: 'By making the call to the OpenWeatherMap web service and setting the instance
    variables, all that’s left for our code to do is convert weather data into values
    for our servo motor and LED. We’ll start with the servo motor value and the `getServoValue()`
    method:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用OpenWeatherMap网络服务并设置实例变量，我们代码剩下的工作就是将天气数据转换为伺服电机和LED的值。我们将从伺服电机值和`getServoValue()`方法开始：
- en: '[PRE31]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s a breakdown of our code:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是我们的代码的分解：
- en: First, the method checks whether the temperature (`self.temperature`) is less
    than `0`. If the temperature is below zero, `temp_factor` is set to `0`. This
    means that if the temperature is negative, there will be no contribution to the
    final servo value.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该方法检查温度（`self.temperature`）是否小于`0`。如果温度低于零，则`temp_factor`设置为`0`。这意味着如果温度是负数，则不会对最终伺服值有任何贡献。
- en: Then, we check whether the temperature is greater than `30`. If this is true,
    then `temp_factor` is set to `1`.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查温度是否大于`30`。如果是这样，则`temp_factor`设置为`1`。
- en: If the temperature falls between 0 and 30 degrees Celsius, then we normalize
    the temperature data. Normalization is the process of bringing or converting values
    into a common range. In this case, the temperature data is being scaled to a range
    of 0 to 1, assuming the temperature is within the range of 0 to 30 degrees Celsius.
    By dividing the temperature by 30, any temperature value within this range is
    proportionally scaled down to a fraction between 0 and 1\. For example, if the
    temperature is 15 degrees Celsius, `temp_factor` will be 0.5\. This normalization
    allows the method to process temperatures consistently, irrespective of their
    actual value.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果温度在0到30摄氏度之间，则我们会对温度数据进行标准化。标准化是将值转换为公共范围的过程。在这种情况下，温度数据被缩放到0到1的范围，假设温度在0到30摄氏度之间。通过将温度除以30，任何在这个范围内的温度值都会按比例缩小到0到1之间的分数。例如，如果温度是15摄氏度，`temp_factor`将是0.5。这种标准化使得方法能够一致地处理温度，而不管它们的实际值是多少。
- en: '`wind_factor = self.wind_speed / 20` calculates the wind factor by normalizing
    the wind speed. Like the temperature normalization process, this line of code
    is used to convert the wind speed into a value within a range of 0 to 1\. The
    wind speed is assumed to be within a range of 0 to 20 kilometers per hour. For
    example, if the wind speed is 10 kilometers per hour, `wind_factor` will be 0.5\.
    Normalization is particularly useful when combining or comparing different types
    of data, such as wind speed and temperature in this case.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wind_factor = self.wind_speed / 20` 通过标准化风速来计算风力系数。就像温度标准化过程一样，这一行代码用于将风速转换为0到1之间的值。假设风速在0到20公里每小时之间。例如，如果风速是每小时10公里，`wind_factor`
    将是0.5。在结合或比较不同类型的数据时，如本例中的风速和温度，标准化特别有用。'
- en: The next step is to calculate `servo_value` using both the temperature and wind
    factors. Specifically, it creates a dampening effect on temperature due to wind
    speed, representing a wind chill factor. The formula reduces the temperature factor
    (`temp_factor`) by one-twentieth of the wind factor (`wind_factor`), thereby signifying
    that for every 5% increase in wind speed, the temperature’s impact decreases by
    1%. This is based on our discretionary assumption that wind speed has a cooling
    effect. After this adjustment for wind chill, the resulting value is transformed
    to fit into the range of -1 to 1, which is suitable for the servo’s operation.
    It multiplies the value by 2, shifting the range from 0 to 1 to 0 to 2, and subtracts
    one to adjust the range to -1 to 1\. Finally, the result is negated to account
    for the servo’s directionality (as we discovered when calibrating the needle).
    The calculated `servo_value` represents the position of the servo as per the adjusted
    temperature and wind speed readings.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用温度和风速因素来计算 `servo_value`。具体来说，它由于风速而产生了对温度的阻尼效应，表示为风寒因素。该公式通过将风速因素（`wind_factor`）的二十分之一从温度因素（`temp_factor`）中减去，从而表示每当风速增加
    5%，温度的影响就会减少 1%。这是基于我们主观的假设，即风速具有冷却效果。在此对风寒进行调整后，得到的结果被转换以适应 -1 到 1 的范围，这对于伺服电机的操作是合适的。它将值乘以
    2，将范围从 0 到 1 移动到 0 到 2，然后减去 1 以调整范围到 -1 到 1。最后，结果取反以考虑伺服电机的方向性（正如我们在校准指针时发现的那样）。计算出的
    `servo_value` 代表根据调整后的温度和风速读数确定的伺服电机位置。
- en: Finally, our method returns `servo_value`, which is a value between -1 and 1
    based on temperature, and then adjusted for wind speed. This value is ready to
    be used as input to the servo’s value property in the GPIO Zero library.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的方法返回 `servo_value`，这是一个基于温度的值，然后根据风速进行调整。此值已准备好用作 GPIO Zero 库中伺服电机值属性的输入。
- en: 'The second method within the `WeatherData` class is utilized to determine the
    operational state of the LED, which varies based on the current weather conditions.
    More specifically, the LED is programmed to flash during a thunderstorm, remain
    solidly illuminated in the event of rain, and be switched off when the weather
    conditions are neither a thunderstorm nor rain. We call this method `getLEDValue()`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeatherData` 类中的第二种方法用于确定 LED 的操作状态，该状态根据当前的天气条件而变化。更具体地说，LED 被编程在雷暴期间闪烁，在下雨时保持稳定照明，而在既不是雷暴也不是下雨的天气条件下关闭。我们称此方法为
    `getLEDValue()`：'
- en: '[PRE32]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, the `getLEDValue()` method designates specific values to different weather
    conditions: it returns `2` for thunderstorms, `1` for rain, and `0` for other
    conditions. These values are then utilized to control the LED’s behavior – blinking
    for thunderstorms (`2`), a steady one for rain (`1`), and off for clear weather
    (`0`).'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`getLEDValue()` 方法为不同的天气条件指定特定的值：对于雷暴返回 `2`，对于雨返回 `1`，对于其他条件返回 `0`。然后利用这些值来控制
    LED 的行为——雷暴时闪烁（`2`），雨时稳定照明（`1`），晴朗时关闭（`0`）。
- en: 'To test out our program directly, include the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要直接测试我们的程序，请包含以下代码：
- en: '[PRE33]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s take a closer look:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: '`if __name__=="__main__"`: This is the entry point for the program. It is only
    executed when the script is run directly, not when it is imported as a module
    in another script:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if __name__=="__main__"`：这是程序的入口点。它仅在脚本直接运行时执行，而不是当它作为另一个脚本中的模块导入时：'
- en: '`weather = WeatherData(''Toronto'')`: This creates an object of the `WeatherData`
    class, initializing it with the `''Toronto''` string. We may enter a city of our
    choice. To verify whether the city we are interested in has data available, we
    can enter it into the search box on the OpenWeatherMap website ([https://openweathermap.org/](https://openweathermap.org/)).'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather = WeatherData(''Toronto'')`：这创建了一个 `WeatherData` 类的对象，并用 `''Toronto''`
    字符串初始化它。我们可以输入我们选择的任何城市。为了验证我们感兴趣的城市的天气数据是否可用，我们可以将其输入到 OpenWeatherMap 网站的搜索框中（[https://openweathermap.org/](https://openweathermap.org/)）。'
- en: '`print(weather.getServoValue())`: This is a function call to the `getServoValue()`
    method of the `weather` object. This method calculates a value based on the temperature
    and wind speed data for Toronto and then prints this value to the console.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(weather.getServoValue())`：这是对 `weather` 对象的 `getServoValue()` 方法的函数调用。此方法根据多伦多的温度和风速数据计算一个值，然后将此值打印到控制台。'
- en: '`print(weather.getLEDValue())`: This calls the `getLEDValue()` method of the
    weather object, which sets a flag based on the weather conditions (thunderstorm,
    rain, or other) for Toronto. This flag determines the state of an LED (flashing,
    on, or off or 2, 1, or 0, respectively) and the method returns this state. The
    state is then printed to the console.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(weather.getLEDValue())`：这调用天气对象的`getLEDValue()`方法，根据多伦多的天气条件（雷暴、雨或其他）设置一个标志。这个标志决定了LED的状态（闪烁、开启或关闭或2、1或0，分别）并且该方法返回这个状态。然后这个状态被打印到控制台。'
- en: 'Save the code and name the file `WeatherData.py`. Run the code by clicking
    the green run button, hitting *F5* on your keyboard, or clicking on the **Run**
    menu option at the top and then **Run current script** (*Figure 3**.20*):'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码并将文件命名为`WeatherData.py`。通过点击绿色运行按钮，按键盘上的*F5*，或者在顶部菜单中选择**运行**选项然后选择**运行当前脚本**（*图3.20*）来运行代码：
- en: '![  Figure 3.20 – Running a script in Thonny](img/B21282_03_20.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 在Thonny中运行脚本](img/B21282_03_20.jpg)'
- en: Figure 3.20 – Running a script in Thonny
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 在Thonny中运行脚本
- en: 'You should see a response similar to the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到以下类似的响应：
- en: '![Figure 3.21 – Output from running WeatherData.py](img/B21282_03_21.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 运行WeatherData.py的输出](img/B21282_03_21.jpg)'
- en: Figure 3.21 – Output from running WeatherData.py
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 运行WeatherData.py的输出
- en: 'With the `WeatherData` class written and tested, it’s time to move on to the
    code that controls the weather indicator: the `WeatherDashboard` class.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写并测试了`WeatherData`类之后，是时候继续编写控制天气指示器的代码了：`WeatherDashboard`类。
- en: Creating the WeatherDashboard class
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建WeatherDashboard类
- en: The `WeatherDashboard` class is integral to the operation of the weather indicator
    as it’s responsible for controlling the position of the needle and the state of
    the LED. This class utilizes the `WeatherData` class to gather and interpret weather
    data, which is then utilized to guide the operation of the physical display. The
    position of the servo, which dictates the position of the needle, is determined
    by the temperature and wind speed, while the LED state is indicative of specific
    weather conditions, such as rain or thunderstorms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherDashboard`类对于天气指示器的运行至关重要，因为它负责控制指针的位置和LED的状态。这个类利用`WeatherData`类收集和解释天气数据，然后将这些数据用于指导物理显示的操作。伺服电机的位置，决定了指针的位置，由温度和风速决定，而LED的状态则表示特定的天气条件，如雨或雷暴。'
- en: 'To create this class, follow these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个类，请按照以下步骤操作：
- en: Inside Thonny, activate the `ch3-env` virtual environment if it hasn’t been
    already.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny中，如果尚未激活，激活`ch3-env`虚拟环境。
- en: 'Then, create a new tab by selecting **File** and then **New** or by hitting
    *Ctrl* + *N* on your keyboard (*Figure 3**.22*):'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过选择**文件**然后**新建**或在键盘上按*Ctrl* + *N*来创建一个新的标签页（*图3.22*）：
- en: '![Figure 3.22 – Creating a new file in Thonny](img/B21282_03_22.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – 在Thonny中创建新文件](img/B21282_03_22.jpg)'
- en: Figure 3.22 – Creating a new file in Thonny
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – 在Thonny中创建新文件
- en: 'We’ll start with our imports:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从导入开始：
- en: '[PRE34]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we do the following:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们做以下操作：
- en: We start by importing the `Servo` and `LED` classes from the `gpiozero` library.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`gpiozero`库中导入`Servo`和`LED`类。
- en: Then, we import the `sleep` function from the `time` module.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从`time`模块中导入`sleep`函数。
- en: Finally, we import the `WeatherData` class to fetch weather condition data and
    derive the control values for the servo motor and the LED accordingly.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们导入`WeatherData`类以获取天气条件数据，并根据这些数据推导出伺服电机和LED的控制值。
- en: 'With the imports added, define the class and the class variables:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导入后，定义类及其变量：
- en: '[PRE35]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we have the following:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有以下内容：
- en: '`servoCorrection = 0.5`: This line declares a class-level variable called `servoCorrection`
    and assigns it a value of `0.5`. This is used to adjust the minimum and maximum
    pulse widths for the servo motor.'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servoCorrection = 0.5`：这一行声明了一个名为`servoCorrection`的类级别变量，并将其赋值为`0.5`。这用于调整伺服电机的最小和最大脉冲宽度。'
- en: '`maxPW = (2.0 + servoCorrection) / 1000`: This line calculates and sets the
    maximum pulse width (`maxPW`) that can be provided to the servo motor. It’s computed
    by adding `2.0` to the `servoCorrection` variable and then dividing the result
    by `1000` to convert it into seconds – the servo motor expects pulse widths in
    seconds.'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxPW = (2.0 + servoCorrection) / 1000`：这一行计算并设置可以提供给伺服电机的最大脉冲宽度（`maxPW`）。它是通过将`2.0`加到`servoCorrection`变量上，然后将结果除以`1000`来转换为秒（伺服电机期望脉冲宽度以秒为单位）。'
- en: '`minPW = (1.0 - servoCorrection) / 1000`: Like the previous line, this line
    calculates and sets the minimum pulse width (`minPW`) for the servo motor. It
    subtracts `servoCorrection` from `1.0` and then divides the result by `1000` for
    the same reason as before.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minPW = (1.0 - servoCorrection) / 1000`：与上一行类似，此行计算并设置伺服电机的最小脉冲宽度（`minPW`）。它从
    `1.0` 中减去 `servoCorrection`，然后将结果除以 `1000`，原因与之前相同。'
- en: 'Create our `Servo` and `LED` instance objects while initializing the `WeatherDashboard`
    class:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化 `WeatherDashboard` 类时创建我们的 `Servo` 和 `LED` 实例对象：
- en: '[PRE36]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s take a closer look at the code:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看代码：
- en: '`self.city = city`: This line sets an instance variable, `city`, equal to the
    `city` argument that’s passed when the instance of the class is created. This
    variable represents the city for which weather data will be fetched.'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.city = city`：此行设置实例变量 `city` 等于在创建类实例时传递的 `city` 参数。此变量表示将获取天气数据的城市。'
- en: '`self.servo = Servo(servo_pin, min_pulse_width=self.minPW, max_pulse_width=self.maxPW)`:
    This line creates a `Servo` object from the GPIO Zero library. The `servo_pin`
    argument specifies the GPIO pin that the servo is connected to. `min_pulse_width=self.minPW`
    and `max_pulse_width=self.maxPW` set the minimum and maximum pulse widths for
    the servo using class variables.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.servo = Servo(servo_pin, min_pulse_width=self.minPW, max_pulse_width=self.maxPW)`：此行从
    GPIO Zero 库创建一个 `Servo` 对象。`servo_pin` 参数指定伺服电机的连接的 GPIO 引脚。`min_pulse_width=self.minPW`
    和 `max_pulse_width=self.maxPW` 使用类变量设置伺服电机的最小和最大脉冲宽度。'
- en: '`self.led = LED(led_pin)`: This line creates an `LED` object from the GPIO
    Zero library. The `led_pin` argument indicates the GPIO pin the LED is connected
    to. This LED will be controlled based on the weather conditions that have been
    fetched for the specified city.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.led = LED(led_pin)`：此行从 GPIO Zero 库创建一个 `LED` 对象。`led_pin` 参数指示 LED 连接的
    GPIO 引脚。此 LED 将根据为指定城市获取的天气条件进行控制。'
- en: 'The `update_status()` method of the `WeatherDashboard` class grabs the latest
    weather information and updates the status of the needle and LED accordingly:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeatherDashboard` 类的 `update_status()` 方法获取最新的天气信息，并相应地更新指针和 LED 的状态：'
- en: '[PRE37]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s what’s going on in our code:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是我们代码中的情况：
- en: '`weather_data = WeatherData(self.city)`: This creates an instance of the `WeatherData`
    class using the city that was specified when `WeatherDashboard` was instantiated.
    This object is used to fetch weather data for the city.'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather_data = WeatherData(self.city)`：这使用在创建 `WeatherDashboard` 实例时指定的城市创建
    `WeatherData` 类的实例。此对象用于获取该城市的天气数据。'
- en: '`self.servo.value = weather_data.getServoValue()`: This calls the `getServoValue()`
    method on the `weather_data` object to get the value for the servo, based on the
    weather conditions. This value is then set as the new position for the servo motor.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.servo.value = weather_data.getServoValue()`：这调用 `weather_data` 对象上的 `getServoValue()`
    方法，根据天气条件获取伺服电机的值。然后，将此值设置为伺服电机的新的位置。'
- en: '`led_status = weather_data.getLEDValue()`: This calls the `getLEDValue()` method
    on the `weather_data` object to get the value for the LED status, based on the
    weather conditions.'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`led_status = weather_data.getLEDValue()`：这调用 `weather_data` 对象上的 `getLEDValue()`
    方法，根据天气条件获取 LED 状态的值。'
- en: The conditional block sets the LED’s status based on the `led_status` value.
    If `led_status` is `0`, it signifies calm weather conditions without any rainfall
    or thunderstorms, so the LED is turned off (`self.led.off()`). If `led_status`
    is `1`, this indicates rain, resulting in the LED being turned on (`self.led.on()`).
    For an `led_status` value of `2`, which is specific to thunderstorm conditions,
    the LED will blink (`self.led.blink()`), representing the intermittent nature
    of thunder and lightning. This value is returned by the `getLEDValue()` method
    in the `WeatherData` class when it detects thunderstorm conditions.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件块根据 `led_status` 值设置 LED 的状态。如果 `led_status` 为 `0`，表示没有降雨或雷暴的平静天气条件，因此 LED
    被关闭（`self.led.off()`）。如果 `led_status` 为 `1`，这表示降雨，导致 LED 被打开（`self.led.on()`）。对于
    `led_status` 的值为 `2` 的情况，这专门针对雷暴条件，LED 将闪烁（`self.led.blink()`），表示雷和闪电的间歇性。当 `WeatherData`
    类检测到雷暴条件时，此值由 `getLEDValue()` 方法返回。
- en: 'The final method in our `WeatherDashboard` class, `closeServo(),` simply closes
    the `Servo` instance that we created in our class. This is done to keep the servo
    motor from jittering:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeatherDashboard` 类中的最后一个方法 `closeServo()`，简单地关闭我们在类中创建的 `Servo` 实例。这样做是为了防止伺服电机抖动：'
- en: '[PRE38]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, save the code and call it `WeatherDashboard.py`.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存代码并将其命名为 `WeatherDashboard.py`。
- en: We won’t run our code just yet, as we need to add a new method to the file (but
    not the class). We will use this method to create a new `WeatherDashboard` object
    and update the position of the needle and the state of the LED.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不会运行我们的代码，因为我们需要向文件中添加一个新的方法（但不是类）。我们将使用此方法来创建一个新的 `WeatherDashboard` 对象，并更新指针和
    LED 的状态。
- en: Adding the updateDashboard() function and main methods
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 updateDashboard() 函数和主方法
- en: The `update_dashboard()` function is a standalone function that is defined in
    the same Python file (`WeatherDashboard.py`) as the `WeatherDashboard` class,
    yet sits outside of it. It serves as an interface to encapsulate the process of
    updating the state of the weather dashboard. The reason for creating the `update_dashboard()`
    function is to help in overcoming issues related to servo motor jittering as it
    provides a controlled way to frequently create a fresh instance of the `WeatherDashboard`
    class, thereby *reopening* the `Servo` object connection each time an update to
    the dashboard is made.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_dashboard()` 函数是一个独立的函数，它定义在同一个 Python 文件 (`WeatherDashboard.py`) 中，作为
    `WeatherDashboard` 类的外部。它作为接口，用于封装更新天气仪表板状态的过程。创建 `update_dashboard()` 函数的原因是为了帮助解决与伺服电机抖动相关的问题，因为它提供了一种受控的方式，频繁地创建
    `WeatherDashboard` 类的新实例，从而每次更新仪表板时都会重新打开 `Servo` 对象的连接。'
- en: 'Let’s take a look:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: 'In Thonny, open the `WeatherDashboard.py` file and add the following method
    to the bottom:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Thonny 中打开 `WeatherDashboard.py` 文件，并在底部添加以下方法：
- en: '[PRE39]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s take a closer look:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: 'First, we define the `update_dashboard(city, servo_pin, led_pin)` function
    to take three arguments: the city for which the weather data is required, the
    PIN for the servo motor, and the PIN for the LED.'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 `update_dashboard(city, servo_pin, led_pin)` 函数，该函数接受三个参数：需要天气数据的城市、伺服电机的引脚和
    LED 的引脚。
- en: Within this function, an instance of the `WeatherDashboard` class, named `weather_dashboard`,
    is created using the given city, servo PIN, and LED PIN as inputs.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数内部，使用给定的城市、伺服引脚和 LED 引脚作为输入，创建了一个 `WeatherDashboard` 类的实例，命名为 `weather_dashboard`。
- en: Next, the `update_status()` method of the `WeatherDashboard` instance is called.
    This method fetches the current weather data for the specified city, determines
    the servo and LED values based on this data, sets the servo’s position, and sets
    the LED’s state (off, on, or blinking) accordingly.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用 `WeatherDashboard` 实例的 `update_status()` 方法。此方法获取指定城市的当前天气数据，根据此数据确定伺服电机和
    LED 的值，设置伺服电机的位置，并相应地设置 LED 的状态（关闭、开启或闪烁）。
- en: The program then pauses for 2 seconds using the `sleep(2)` statement. This pause
    ensures that the servo has enough time to move to its new position and that the
    LED displays its new state before any further actions are taken.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序随后使用 `sleep(2)` 语句暂停 2 秒。这次暂停确保伺服电机有足够的时间移动到新位置，并且 LED 显示其新状态，然后再进行任何其他操作。
- en: Finally, the `closeServo()` method of the `WeatherDashboard` instance is called.
    This method is responsible for closing the connection to the servo motor, which
    is done to avoid potential issues with the servo, such as jittering.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用 `WeatherDashboard` 实例的 `closeServo()` 方法。此方法负责关闭与伺服电机的连接，这是为了避免伺服电机可能出现的抖动等问题。
- en: 'Next, we will add code that only runs when the `WeatherDashboard.py` file is
    executed in Python. We will use this code to run our weather indicator continuously:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加仅在以 Python 执行 `WeatherDashboard.py` 文件时运行的代码。我们将使用此代码来持续运行我们的天气指示器：
- en: '[PRE40]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s take a closer look:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: This block of code will only run when this script (`WeatherDashboard.py`) is
    executed directly based on `if __name__ == "``__main__":`.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码只有在根据 `if __name__ == "__main__":` 直接执行此脚本 (`WeatherDashboard.py`) 时才会运行。
- en: First, we set the `city`, `servo_pin`, and `led_pin` variables to `Toronto`,
    `14`, and `25`, respectively. Each reader may put in the city of their choice.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 `city`、`servo_pin` 和 `led_pin` 变量分别设置为 `Toronto`、`14` 和 `25`。每个读者都可以选择他们喜欢的城市。
- en: The `while True:` loop will continuously execute the code inside it, essentially
    making the script run forever, or until it is stopped manually.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while True:` 循环将不断执行其内部的代码，本质上使脚本无限期地运行，或者直到手动停止。'
- en: Inside the loop, the `update_dashboard()` function is called with the `city`,
    `servo_pin`, and `led_pin` values as arguments. This function updates the weather
    dashboard, effectively getting the new weather data and controlling the servo
    and LED accordingly.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，使用`city`、`servo_pin`和`led_pin`值作为参数调用`update_dashboard()`函数。此函数更新天气仪表盘，有效地获取新的天气数据并相应地控制伺服和LED。
- en: After updating the dashboard, the script goes into sleep mode for 1,800 seconds,
    or 30 minutes (`sleep(1800)`). This means that the weather dashboard updates every
    30 minutes.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新仪表盘后，脚本进入休眠模式，持续1,800秒，即30分钟（`sleep(1800)`）。这意味着天气仪表盘每30分钟更新一次。
- en: After the sleep period, the loop starts over, updating the dashboard again.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 休眠期过后，循环重新开始，再次更新仪表盘。
- en: Resave the code and call it `WeatherData.py`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新保存代码，并将其命名为`WeatherData.py`。
- en: Run our code by clicking the green run button, hitting *F5* on your keyboard,
    or clicking on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击绿色运行按钮、按键盘上的*F5*键或在顶部菜单中选择**运行**然后**运行当前脚本**来运行我们的代码。
- en: Once the script is up and running, we’ll see that the position of the needle
    and the state of the LED reflect the current temperature, wind speed, and weather
    conditions accurately.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本启动并运行，我们会看到针的位置和LED的状态准确地反映了当前的温度、风速和天气状况。
- en: 'We may operate our weather indicator application independently, without the
    need for a keyboard, mouse, or monitor to be connected. *Figure 3**.23* shows
    a practical example of how our application advises us on what to wear based on
    the weather in Toronto at the time the photo was taken, also indicating that there’s
    no need for an umbrella:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以独立操作我们的天气指示器应用程序，无需连接键盘、鼠标或显示器。*图3.23*显示了一个实际例子，说明我们的应用程序如何根据拍照时的多伦多天气来建议我们穿什么，同时也表明不需要带伞：
- en: '![Figure 3.23 – It looks like T-shirt weather in Toronto today](img/B21282_03_23.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – 今天多伦多的天气看起来像是T恤天气](img/B21282_03_23.jpg)'
- en: Figure 3.23 – It looks like T-shirt weather in Toronto today
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – 今天多伦多的天气看起来像是T恤天气
- en: From the position of the needle on our weather indicator in *Figure 3**.23*,
    we can conclude that it is T-shirt weather in Toronto today.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的天气指示器在*图3.23*上的针的位置，我们可以得出结论，今天多伦多的天气适合穿T恤。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a weather indicator application, a tool that’s
    designed to provide advice on clothing choices based on current weather conditions.
    This innovative project combined coding expertise with physical component design,
    manifesting not just on a computer screen, but in a real-world, tangible form.
    Central to this was the creation of a custom stand for our weather indicator,
    made from 3D-printed parts. This stand, which was designed to house the LED and
    the servo motor, contributed both practical functionality and aesthetic appeal
    to our project, successfully bridging the gap between the digital and physical
    worlds.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个天气指示器应用程序，这是一个旨在根据当前天气条件提供服装选择建议的工具。这个创新项目结合了编码专长和物理组件设计，不仅体现在计算机屏幕上，而且以真实世界、有形的形式呈现。其中最重要的是我们为天气指示器创建了一个定制的支架，该支架由3D打印部件制成。这个支架，它被设计用来容纳LED和伺服电机，为我们的项目提供了实用功能和美学吸引力，成功地弥合了数字世界和物理世界之间的差距。
- en: 'The lessons learned and the skills gained on this journey have wide-ranging
    applications. To illustrate, envision a new undertaking: a project that utilizes
    environmental sensors to track indoor climate conditions such as temperature,
    humidity, and air quality. The core principles we’ve mastered – from acquiring
    and interpreting data to interacting with hardware components – can be directly
    employed in such a scenario.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次旅程中学到的经验和获得的技能具有广泛的应用。为了说明这一点，设想一个新的项目：一个利用环境传感器来跟踪室内气候条件，如温度、湿度和空气质量的项目。我们掌握的核心原则——从获取和解释数据到与硬件组件交互——可以直接应用于此类场景。
- en: Also, it is easy to imagine adding more functionality to our weather indicator.
    For example, imagine replacing our LED with an RGB LED capable of a myriad of
    colors. We could use these different colors and various flashing patterns to indicate
    other types of weather conditions or warnings.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，很容易想象为我们的天气指示器添加更多功能。例如，想象用能够显示多种颜色的RGB LED替换我们的LED。我们可以使用这些不同的颜色和不同的闪烁模式来指示其他类型的天气状况或警告。
- en: 'In this chapter, we added to our expertise in Python programming by focusing
    on interfacing with web services for data acquisition and analysis. In parallel,
    we ventured into the world of hardware interfaces, creating a tangible, physical
    component: our custom weather indicator stand.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过专注于与网络服务接口进行数据获取和分析，增加了我们在 Python 编程方面的专业知识。同时，我们进入了硬件接口的世界，创建了一个有形的物理组件：我们的定制天气指示器支架。
- en: With our newly acquired skills, we are poised to tackle a variety of complex
    problems. As demonstrated in our weather indicator project, being able to integrate
    web services, Python programming, and physical components can result in practical
    applications that significantly impact daily life. Whether advising on clothing
    choices based on weather conditions or envisaging new applications such as indoor
    climate monitoring, our abilities have proven versatile and invaluable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们新获得的能力，我们准备应对各种复杂问题。正如我们在天气指示器项目中展示的那样，能够整合网络服务、Python 编程和物理组件可以产生对日常生活产生重大影响的应用。无论是根据天气条件提供建议选择服装，还是设想新的应用，如室内气候监测，我们的能力已被证明是多才多艺且极具价值的。
- en: In the next chapter, we’ll construct an IoT display with a Raspberry Pi 7-inch
    touchscreen that presents real-time weather and traffic. This will involve exploring
    various screen types and creating a multifunctional dashboard, enhancing our skills
    in Raspberry Pi applications and IoT project development.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Raspberry Pi 7 英寸触摸屏构建一个物联网显示屏，展示实时天气和交通信息。这涉及到探索各种屏幕类型并创建一个多功能仪表盘，从而提升我们在
    Raspberry Pi 应用程序和物联网项目开发方面的技能。
