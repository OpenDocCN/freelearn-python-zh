- en: C Performance with Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 的 C 性能
- en: Cython is a language that extends Python by supporting the declaration of types
    for functions, variables, and classes. These typed declarations enable Cython
    to compile Python scripts to efficient C code. Cython can also act as a bridge
    between Python and C as it provides easy-to-use constructs to write interfaces
    to external C and C++ routines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种通过支持函数、变量和类的类型声明来扩展 Python 的语言。这些类型声明使 Cython 能够将 Python 脚本编译成高效的
    C 代码。Cython 还可以作为 Python 和 C 之间的桥梁，因为它提供了易于使用的结构来编写对外部 C 和 C++ 例程的接口。
- en: 'In this chapter, we will learn the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Cython syntax basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 语法基础
- en: How to compile Cython programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编译 Cython 程序
- en: How to use **static typing** to generate fast code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **静态类型** 生成快速代码
- en: How to efficiently manipulate arrays using typed **memoryviews**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用类型化的 **内存视图** 高效地操作数组
- en: Optimizing a sample particle simulator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化示例粒子模拟器
- en: Tips on using Cython in the Jupyter notebook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jupyter 笔记本中使用 Cython 的技巧
- en: The profiling tools available for Cython
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于 Cython 的分析工具
- en: While a minimum knowledge of C is helpful, this chapter focuses only on Cython
    in the context of Python optimization. Therefore, it doesn't require any C background.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对 C 的基本了解有帮助，但本章仅关注 Python 优化背景下的 Cython。因此，它不需要任何 C 背景。
- en: Compiling Cython extensions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Cython 扩展
- en: The Cython syntax is, by design, a superset of Python. Cython can compile, with
    a few exceptions, most Python modules without requiring any change. Cython source
    files have the `.pyx` extension and can be compiled to produce a C file using
    the `cython` command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 语法设计上是一个 Python 的超集。Cython 可以编译大多数 Python 模块，只有少数例外，而无需任何更改。Cython 源文件具有
    `.pyx` 扩展名，可以使用 `cython` 命令编译成 C 文件。
- en: 'Our first Cython script will contain a simple function that prints `Hello,
    World!` as the output. Create a new `hello.pyx` file containing the following
    code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个 Cython 脚本将包含一个简单的函数，该函数将打印输出 `Hello, World!`。创建一个新的 `hello.pyx` 文件，包含以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `cython` command will read `hello.pyx` and generate the `hello.c` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`cython` 命令将读取 `hello.pyx` 并生成 `hello.c` 文件：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile `hello.c` to a Python extension module, we will use the GCC compiler.
    We need to add some Python-specific compilation options that depend on the operating
    system. It''s important to specify the directory that contains the header files;
    in the following example, the directory is `/usr/include/python3.5/`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `hello.c` 编译成 Python 扩展模块，我们将使用 GCC 编译器。我们需要添加一些依赖于操作系统的特定于 Python 的编译选项。指定包含头文件的目录很重要；在以下示例中，目录是
    `/usr/include/python3.5/`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To find your Python include directory, you can use the `distutils` utility: 
    `sysconfig.get_python_inc`. To execute it, you can simply issue the following `python
    -c "from distutils import sysconfig; print(sysconfig.get_python_inc())"` command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到您的 Python 包含目录，您可以使用 `distutils` 工具：`sysconfig.get_python_inc`。要执行它，您可以简单地发出以下命令
    `python -c "from distutils import sysconfig; print(sysconfig.get_python_inc())"`。
- en: 'This will produce a file called `hello.so`, a C extension module that is directly
    importable into a Python session:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `hello.so` 的文件，这是一个可以直接导入 Python 会话的 C 扩展模块：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Cython accepts both Python 2 and Python 3 as input and output languages. In
    other words, you can compile a Python 3 script `hello.pyx` file using the `-3`
    option:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 接受 Python 2 和 Python 3 作为输入和输出语言。换句话说，您可以使用 `-3` 选项编译 Python 3 脚本 `hello.pyx`
    文件：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The generated `hello.c` can be compiled without any changes to Python 2 and
    Python 3 by including the corresponding headers with the `-I` option, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `hello.c` 可以通过包含相应的头文件并使用 `-I` 选项来编译，以便在 Python 2 和 Python 3 中使用，如下所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A Cython program can be compiled in a more straightforward way using `distutils`,
    the standard Python packaging tool. By writing a `setup.py` script, we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example,
    we can write a minimal `setup.py` containing the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `distutils`，Python 的标准打包工具，可以更直接地编译 Cython 程序。通过编写一个 `setup.py` 脚本，我们可以直接将
    `.pyx` 文件编译成扩展模块。为了编译我们的 `hello.pyx` 示例，我们可以编写一个包含以下代码的最小 `setup.py`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first two lines of the preceding code, we import the `setup` function
    and the `cythonize` helper. The `setup` function contains a few key-value pairs
    that specify the name of the application and the extensions that need to be built.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码的前两行中，我们导入了 `setup` 函数和 `cythonize` 辅助函数。`setup` 函数包含一些键值对，指定了应用程序的名称和需要构建的扩展。
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns using the
    following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`cythonize` 辅助函数接受一个字符串或一个包含我们想要编译的 Cython 模块的字符串列表。您也可以使用以下代码使用 glob 模式：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To compile our extension module using `distutils`, you can execute the `setup.py`
    script using the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `distutils` 编译我们的扩展模块，您可以执行以下代码的 `setup.py` 脚本：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, while the `--inplace` option tells the script to place the `hello.so`
    output file in the same location as the source file (instead of a build directory).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_ext` 选项告诉脚本构建 `ext_modules` 中指示的扩展模块，而 `--inplace` 选项告诉脚本将 `hello.so`
    输出文件放置在源文件相同的目录中（而不是构建目录）。'
- en: 'Cython modules can also be automatically compiled using `pyximport`. All that''s
    needed is a call to `pyximport.install()` at the beginning of your script (or
    you need to issue the command in your interpreter). After doing that, you can
    import `.pyx` files directly and `pyximport` will transparently compile the corresponding
    Cython modules:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 模块也可以通过 `pyximport` 自动编译。您只需要在脚本开头调用 `pyximport.install()`（或者您需要在解释器中发出该命令）。完成此操作后，您可以直接导入
    `.pyx` 文件，`pyximport` 将透明地编译相应的 Cython 模块：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example, when they involve a combination of C and Cython files), but it comes
    handy for testing simple scripts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`pyximport` 并不适用于所有类型的配置（例如，当它们涉及 C 和 Cython 文件的组合时），但它对于测试简单的脚本来说很方便。
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自 0.13 版本以来，IPython 包含了 `cythonmagic` 扩展，可以交互式地编写和测试一系列 Cython 语句。您可以使用 `load_ext`
    在 IPython 壳中加载扩展：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the extension is loaded, you can use the `%%cython` *cell magic* to write
    a multiline Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the IPython session namespace:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了扩展，您就可以使用 `%%cython` 单元魔法来编写多行 Cython 片段。在以下示例中，我们定义了一个 `hello_snippet`
    函数，该函数将被编译并添加到 IPython 会话命名空间中：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding static types
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态类型
- en: In Python, a variable can be associated to objects of different types during
    the execution of the program. While this feature is desirable as it makes the
    language flexible and dynamic, it also adds a significant overhead to the interpreter
    as it needs to look up type and methods of the variables at runtime, making it
    difficult to perform various optimizations. Cython extends the Python language
    with explicit type declarations so that it can generate efficient C extensions
    through compilation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，变量在程序执行过程中可以与不同类型的对象关联。虽然这个特性使得语言更加灵活和动态，但它也给解释器带来了显著的开销，因为解释器需要在运行时查找变量的类型和方法，这使得进行各种优化变得困难。Cython
    通过扩展 Python 语言，增加了显式的类型声明，以便通过编译生成高效的 C 扩展。
- en: The main way to declare data types in Cython is through `cdef` statements. The
    `cdef` keyword can be used in multiple contexts, such as variables, functions,
    and extension types (statically-typed classes).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中声明数据类型的主要方式是通过 `cdef` 语句。`cdef` 关键字可以在多个上下文中使用，例如变量、函数和扩展类型（静态类型类）。
- en: Variables
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Cython, you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the `i` variable
    as a 16 bit integer in the following way:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，您可以通过在变量前加上 `cdef` 和相应的类型来声明变量的类型。例如，我们可以以下这种方式声明 `i` 变量为 16 位整数：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `cdef` statement supports multiple variable names on the same line along
    with optional initialization, as seen in the following line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef` 语句支持在同一行上使用多个变量名，以及可选的初始化，如下所示：'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Typed variables are treated differently in comparison to regular variables.
    In Python, variables are often described as *labels* that refer to objects in
    memory. For example, we could assign the value `''hello''` to the `a` variable
    at any point in the program without restriction:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规变量相比，类型化变量被处理得不同。在 Python 中，变量通常被描述为指向内存中对象的 *标签*。例如，我们可以在程序的任何位置将值 `'hello'`
    赋予 `a` 变量，而不会受到限制：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `a` variable holds a reference to the `''hello''` string. We can also freely
    assign another value (for example, the integer `1`) to the same variable later
    in the code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`变量持有对`''hello''`字符串的引用。我们还可以在代码的稍后部分自由地将另一个值（例如，整数`1`）赋给同一个变量：'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Python will assign the integer `1` to the `a` variable without any problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python将没有任何问题地将整数`1`赋值给`a`变量。
- en: 'Typed variables behave quite differently and are usually described as *data
    containers:* we can only store values that fit into the container that is determined
    by its data type. For example, if we declare the `a` variable as `int`, and then
    we try to assign it to a `double`, Cython will trigger an error, as shown in the
    following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 带类型的变量表现得很不同，通常被描述为*数据容器*：我们只能存储适合由其数据类型确定的容器中的值。例如，如果我们将`a`变量声明为`int`，然后我们尝试将其赋值给`double`，Cython将触发一个错误，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Static typing makes it easy for the compiler to perform useful optimizations.
    For example, if we declare a loop index as `int`, Cython will rewrite the loop
    in pure C without needing to step into the Python interpreter. The typing declaration
    guarantees that the type of the index will always be `int` and cannot be overwritten
    at runtime so that the compiler is free to perform the optimizations without compromising
    the program correctness.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型使编译器能够执行有用的优化。例如，如果我们声明循环索引为`int`，Cython将重写循环为纯C，而无需进入Python解释器。类型声明保证了索引的类型始终是`int`，并且在运行时不能被覆盖，这样编译器就可以自由地进行优化，而不会损害程序的正确性。
- en: 'We can assess the speed gain in this case with a small test case. In the following
    example, we implement a simple loop that increments a variable 100 times. With
    Cython, the `example` function can be coded as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小测试用例来评估这种情况下的速度提升。在下面的示例中，我们实现了一个简单的循环，该循环将一个变量增加100次。使用Cython，`example`函数可以编写如下：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can compare the speed of an analogous, untyped, pure Python loop:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比较一个类似的无类型、纯Python循环的速度：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The speedup obtained by implementing this simple type declaration is a whopping
    100x! This works because the Cython loop has first been converted to pure C and
    then to efficient machine code, while the Python loop still relies on the slow
    interpreter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这种简单的类型声明获得的加速效果是惊人的100倍！这是因为Cython循环首先被转换为纯C，然后转换为高效的机器代码，而Python循环仍然依赖于慢速的解释器。
- en: In Cython, it is possible to declare a variable to be of any standard C type,
    and it is also possible to define custom types using classic C constructs, such
    as `struct`, `enum`, and `typedef`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cython中，可以声明变量为任何标准C类型，也可以使用经典的C构造，如`struct`、`enum`和`typedef`来定义自定义类型。
- en: 'An interesting example is that if we declare a variable to be of the `object`
    type, the variable will accept any kind of Python object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是，如果我们声明一个变量为`object`类型，该变量将接受任何类型的Python对象：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that declaring a variable as `object` has no performance benefits as accessing
    and operating on the object will still require the interpreter to look up the
    underlying type of the variable and its attributes and methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将变量声明为`object`没有性能优势，因为访问和操作该对象仍然需要解释器查找变量的底层类型及其属性和方法。
- en: 'Sometimes, certain data types (such as `float` and `int` numbers) are compatible
    in the sense that they can be converted into each other. In Cython, it is possible
    to convert (*cast*) between types by surrounding the destination type between
    pointy brackets, as shown in the following snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些数据类型（例如`float`和`int`数字）在某种意义上是兼容的，即它们可以被相互转换。在Cython中，可以通过在尖括号中包围目标类型来在类型之间进行转换（*cast*），如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of each of the argument names. Functions specified in this way
    will work and perform like regular Python functions, but their arguments will
    be type-checked. We can write a `max_python` function, which returns the greater
    value between two integers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在每个参数名称前指定类型来向Python函数的参数添加类型信息。以这种方式指定的函数将像常规Python函数一样工作并执行，但它们的参数将进行类型检查。我们可以编写一个`max_python`函数，它返回两个整数之间的较大值：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A function specified in this way will perform type-checking and treat the arguments
    as typed variables, just like in `cdef` definitions. However, the function will
    still be a Python function, and calling it multiple times will still need to switch
    back to the interpreter. To allow Cython for function call optimizations, we should
    declare the type of the return type using a `cdef` statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式指定的函数将执行类型检查并将参数视为类型化变量，就像在`cdef`定义中一样。然而，该函数仍然是一个Python函数，多次调用它仍然需要切换回解释器。为了允许Cython进行函数调用优化，我们应该使用`cdef`语句声明返回类型的类型：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Functions declared in this way are translated to native C functions and have
    much less overhead compared to Python functions. A substantial drawback is that
    they can't be used from Python, but only from Cython, and their scope is restricted
    to the same Cython file unless they're exposed in a definition file (refer to
    the *Sharing declarations* section).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明的函数将被转换为本地C函数，与Python函数相比，它们的开销要小得多。一个显著的缺点是它们不能从Python中使用，而只能从Cython中使用，并且它们的范围限制在同一个Cython文件中，除非它们在定义文件中公开（参考*共享声明*部分）。
- en: 'Fortunately, Cython allows you to define functions that are both callable from
    Python and translatable to performant C functions. If you declare a function with
    a `cpdef` statement, Cython will generate two versions of the function: a Python
    version available to the interpreter, and a fast C function usable from Cython.
    The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Cython 允许你定义既可以从Python调用也可以转换为高性能C函数的函数。如果你使用`cpdef`语句声明一个函数，Cython将生成该函数的两个版本：一个可供解释器使用的Python版本，以及一个从Cython可用的快速C函数。`cpdef`语法与`cdef`相同，如下所示：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be replaced by the function
    body itself. Our `max` function is a good candidate for *inlining*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使有C函数，调用开销也可能成为性能问题，尤其是在关键循环中多次调用同一个函数时。当函数体很小的时候，在函数定义前添加`inline`关键字是很方便的；函数调用将被函数体本身替换。我们的`max`函数是进行内联的好候选：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Classes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'We can define an extension type using the `cdef class` statement and declaring
    its attributes in the class body. For example, we can create an extension type--`Point`--as
    shown in the following code, which stores two coordinates (*x*, *y*) of the `double` type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cdef class`语句定义扩展类型，并在类体中声明其属性。例如，我们可以创建一个扩展类型--`Point`--如下面的代码所示，它存储两个`double`类型的坐标（*x*，*y*）：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Accessing the declared attributes in the class methods allows Cython to bypass
    expensive Python attribute look-ups by direct access to the given fields in the
    underlying C `struct`. For this reason, attribute access in typed classes is an
    extremely fast operation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法中访问声明的属性允许Cython通过直接访问底层C `struct`中的给定字段来绕过昂贵的Python属性查找。因此，类型化类中的属性访问是一个极快的操作。
- en: 'To use the `cdef class` in your code, you need to explicitly declare the type
    of the variables you intend to use at compile time. You can use the extension
    type name (such as `Point`) in any context where you will use a standard type
    (such as `double`, `float`, and `int`). For example, if we want a Cython function
    that calculates the distance from the origin (in the example, the function is
    called `norm`) of a `Point`, we have to declare the input variable as `Point`,
    as shown in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用`cdef class`，需要在编译时明确声明你打算使用的变量类型。你可以在任何你将使用标准类型（如`double`、`float`和`int`）的上下文中使用扩展类型名（如`Point`）。例如，如果我们想创建一个Cython函数来计算从原点（在示例中，该函数名为`norm`）到`Point`的距离，我们必须将输入变量声明为`Point`，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just like typed functions, typed classes have some limitations. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`,
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类型化函数一样，类型化类也有一些限制。如果你尝试从Python访问扩展类型属性，你会得到一个`AttributeError`，如下所示：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In order to access attributes from Python code, you have to use the `public`
    (for read/write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Python代码中访问属性，你必须使用`public`（用于读写访问）或`readonly`指定符在属性声明中，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Additionally, methods can be declared with the `cpdef` statement, just like
    regular functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用 `cpdef` 语句声明方法，就像常规函数一样。
- en: Extension types do not support the addition of extra attributes at runtime.
    In order to do that, a solution is defining a Python class that is a subclass
    of the typed class and extends its attributes and methods in pure Python.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类型不支持在运行时添加额外的属性。为了做到这一点，一种解决方案是定义一个 Python 类，它是类型类的子类，并在纯 Python 中扩展其属性和方法。
- en: Sharing declarations
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享声明
- en: When writing your Cython modules, you may want to reorganize your most used
    functions and classes declaration in a separate file so that they can be reused
    in different modules. Cython allows you to put these components in a *definition
    file* and access them with `cimport` statements*.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写您的 Cython 模块时，您可能希望将最常用的函数和类声明重新组织到一个单独的文件中，以便它们可以在不同的模块中重用。Cython 允许您将这些组件放入一个
    *定义文件* 中，并通过 `cimport` 语句访问它们*.*
- en: Let's say that we have a module with the `max` and `min` functions, and we want
    to reuse those functions in multiple Cython programs. If we simply write a bunch
    of functions in a `.pyx` file, the declarations will be confined to the same file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含 `max` 和 `min` 函数的模块，并且我们想在多个 Cython 程序中重用这些函数。如果我们简单地在 `.pyx` 文件中编写一些函数，声明将仅限于同一文件。
- en: Definition files are also used to interface Cython with external C code. The
    idea is to copy (or, more accurately, translate) the types and function prototypes
    in the definition file and leave the implementation in the external C code that
    will be compiled and linked in a separate step.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件也用于将 Cython 与外部 C 代码接口。想法是将定义文件中的类型和函数原型复制（或更准确地说，翻译）到外部 C 代码中，该代码将在单独的步骤中编译和链接。
- en: 'To share the `max` and `min` functions, we need to write a definition file
    with a `.pxd` extension. Such a file only contains the types and function prototypes
    that we want to share with other modules--a *public* interface. We can declare
    the prototypes of our `max` and `min` functions in a file named `mathlib.pxd`,
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要共享 `max` 和 `min` 函数，我们需要编写一个具有 `.pxd` 扩展名的定义文件。此类文件仅包含我们想要与其他模块共享的类型和函数原型--一个
    *公共* 接口。我们可以在名为 `mathlib.pxd` 的文件中声明 `max` 和 `min` 函数的原型，如下所示：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we only write the function name and arguments without implementing
    the function body.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只编写了函数名称和参数，而没有实现函数体。
- en: 'The function implementation goes into the implementation file with the same
    base name but the `.pyx` extension--`mathlib.pyx`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现将放入具有相同基本名称但具有 `.pyx` 扩展名的实现文件中--`mathlib.pyx`：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `mathlib` module is now importable from another Cython module.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathlib` 模块现在可以从另一个 Cython 模块导入。'
- en: 'To test our new Cython module, we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code. The Chebyshev distance between
    two coordinates--`(x1, y1)` and `(x2, y2)`--is defined as the maximum value of
    the difference between each coordinate:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们新的 Cython 模块，我们将创建一个名为 `distance.pyx` 的文件，其中包含一个名为 `chebyshev` 的函数。该函数将计算两点之间的
    Chebyshev 距离，如下面的代码所示。两点坐标--`(x1, y1)` 和 `(x2, y2)` 之间的 Chebyshev 距离定义为每个坐标之间差异的最大值：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To implement the `chebyshev` function, we will use the `max` function declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `chebyshev` 函数，我们将使用通过 `cimport` 语句导入的 `mathlib.pxd` 中声明的 `max` 函数，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `cimport` statement will read `hello.pxd` and the `max` definition will
    be used to generate the `distance.c` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`cimport` 语句将读取 `hello.pxd`，并使用 `max` 定义来生成 `distance.c` 文件。'
- en: Working with arrays
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Numerical and high performance calculations often make use of arrays. Cython
    provides an easy way to interact with them, using directly low-level C arrays,
    or the more general *typed memoryviews*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数值和高性能计算通常使用数组。Cython 提供了一种直接使用低级 C 数组或更通用的 *类型内存视图* 与它们交互的简单方法。
- en: C arrays and pointers
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 数组和指针
- en: C arrays are a collection of items of the same type, stored contiguously in
    memory. Before digging into the details, it is helpful to understand (or review)
    how memory is managed in C.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C 数组是一系列相同类型的项的集合，在内存中连续存储。在深入了解细节之前，了解（或复习）C 中内存的管理方式是有帮助的。
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64 bit floating point number (`double`), the program will allocate 64 bit (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C中的变量就像容器。当创建变量时，会在内存中预留空间以存储其值。例如，如果我们创建一个包含64位浮点数（`double`）的变量，程序将分配64位（16字节）的内存。可以通过该内存位置的地址访问这部分内存。
- en: 'To obtain the address of a variable, we can use the *address operator* denoted
    by the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取变量的地址，我们可以使用表示为`&`符号的*地址操作符*。我们还可以使用`printf`函数，如下所示，它可在`libc.stdio` Cython模块中找到，以打印该变量的地址：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Memory addresses can be stored in special variables, *pointers*, that can be
    declared by putting a `*` prefix in front of the variable name, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内存地址可以存储在特殊的变量中，称为*指针*，可以通过在变量名前加上`*`前缀来声明，如下所示：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we have a pointer, and we want to grab the value contained in the address
    it''s pointing at, we can use the *dereference operator* denoted by the `*` symbol.
    Be careful, the `*` used in this context has a different meaning from the `*`
    used in the variable declaration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指针，并且我们想获取它所指向的地址中的值，我们可以使用表示为`*`符号的*解引用操作符*。请注意，在此上下文中使用的`*`与在变量声明中使用的`*`有不同的含义：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When declaring a C array, the program allocates enough space to accommodate
    all the elements requested. For instance, to create an array that has 10 `double`
    values (16 bytes each), the program will reserve *16 * 10 = 160* bytes of contiguous
    space in memory. In Cython, we can declare such arrays using the following syntax:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明C数组时，程序会分配足够的空间来容纳请求的所有元素。例如，要创建一个包含10个`double`值（每个16字节）的数组，程序将在内存中预留*16
    * 10 = 160*字节的连续空间。在Cython中，我们可以使用以下语法声明此类数组：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also declare a multidimensional array, such as an array with `5` rows
    and `2` columns, using the following syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下语法声明多维数组，例如具有`5`行和`2`列的数组：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is depicted in the following
    figure. Arrays can also be ordered *column-major*, as is the case for the FORTRAN
    programming language:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 内存将在单个内存块中分配，一行接一行。这种顺序通常被称为*行主序*，如下面的图中所示。数组也可以按*列主序*排序，正如FORTRAN编程语言的情况：
- en: '![](img/image_04_001.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_001.png)'
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example, 0, 1, 2, 3
    ...) while when we iterate on the first dimension, we skip a few positions (0,
    2, 4, 6, 8, 1 ... ). You should always try to access memory sequentially as this
    optimizes cache and memory usage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数组排序有重要的后果。当我们遍历C数组的最后一个维度时，我们访问连续的内存块（在我们的例子中，0, 1, 2, 3 ...），而当我们遍历第一个维度时，我们会跳过一些位置（0,
    2, 4, 6, 8, 1 ...）。你应该始终尝试顺序访问内存，因为这优化了缓存和内存使用。
- en: 'We can store and retrieve elements from the array using standard indexing;
    C arrays don''t support fancy indexing or slices:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准索引来存储和检索数组中的元素；C数组不支持复杂索引或切片：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'C arrays have many of the same behaviors as pointers. The `arr` variable, in
    fact, points to the memory location of the first element of the array. We can
    verify that the address of the first element of the array is the same as the address
    contained in the `arr` variable using the dereference operator, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C数组具有许多与指针相同的行为。实际上，`arr`变量指向数组的第一个元素的内存位置。我们可以使用解引用操作符来验证数组第一个元素的地址与`arr`变量中包含的地址相同，如下所示：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You should use C arrays and pointers when interfacing with the existing C libraries
    or when you need a fine control over the memory (also, they are very performant).
    This level of fine control is also prone to mistakes as it doesn't prevent you
    from accessing the wrong memory locations. For more common use cases and improved
    safety, you can use NumPy arrays or typed memoryviews.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当与现有的C库接口或需要精细控制内存时（此外，它们性能非常出色），你应该使用C数组和指针。这种精细控制水平也容易出错，因为它不能阻止你访问错误的内存位置。对于更常见的用例和改进的安全性，你可以使用NumPy数组或类型化内存视图。
- en: NumPy arrays
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy数组
- en: NumPy arrays can be used as normal Python objects in Cython using their already
    optimized broadcasted operations. However, Cython provides a `numpy` module with
    better support for direct iteration.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，可以使用 NumPy 数组作为常规 Python 对象，利用它们已经优化的广播操作。然而，Cython 提供了一个更好的直接迭代支持的
    `numpy` 模块。
- en: When we normally access an element of a NumPy array, a few other operations
    take place at the interpreter level causing a major overhead. Cython can bypass
    those operations and checks by acting directly on the underlying memory area used
    by NumPy arrays, and thus obtaining impressive performance gains.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通常访问 NumPy 数组的一个元素时，解释器级别会发生一些其他操作，造成主要开销。Cython 可以通过直接在 NumPy 数组使用的底层内存区域上操作来绕过这些操作和检查，从而获得令人印象深刻的性能提升。
- en: 'NumPy arrays can be declared as the `ndarray` data type. To use the data type
    in our code, we first need to `cimport` the `numpy` Cython module (which is not
    the same as the Python NumPy module). We will bind the module to the `c_np` variable
    to make the difference with the Python `numpy` module more explicit:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组可以声明为 `ndarray` 数据类型。为了在我们的代码中使用该数据类型，我们首先需要 `cimport` `numpy` Cython
    模块（它与 Python NumPy 模块不同）。我们将该模块绑定到 `c_np` 变量，以使与 Python `numpy` 模块的差异更加明确：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now declare a NumPy array by specifying its type and the number of dimensions
    between square brackets (this is called *buffer syntax*). To declare a two-dimensional
    array of type `double`, we can use the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过指定类型和方括号内的维度数（这称为 *缓冲区语法*）来声明 NumPy 数组。要声明一个类型为 `double` 的二维数组，我们可以使用以下代码：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Access to this array will be performed by directly operating on the underlying
    memory area; the operation will avoid stepping into the interpreter, giving us
    a tremendous speed boost.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对此数组的访问将通过直接操作底层内存区域来完成；操作将避免进入解释器，从而给我们带来巨大的速度提升。
- en: In the next example, we will show the usage of typed numpy arrays and compare
    them with the normal Python version.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将展示使用类型化 numpy 数组的方法，并将它们与常规 Python 版本进行比较。
- en: 'We first write the `numpy_bench_py` function that increments each element of
    `py_arr`. We declare the `i` index as an integer so that we avoid the for-loop
    overhead:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写 `numpy_bench_py` 函数，该函数递增 `py_arr` 的每个元素。我们声明 `i` 索引为整数，以避免 for 循环的开销：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we write the same function using the `ndarray` type. Note that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `ndarray` 类型编写相同的函数。请注意，在定义 `c_arr` 变量使用 `c_np.ndarray` 之后，我们可以从 `numpy`
    Python 模块给它赋值一个数组：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can time the results using `timeit`, and we can see how the typed version
    is 50x faster:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `timeit` 来计时结果，并看到类型化版本的速度快了 50 倍：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Typed memoryviews
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化内存视图
- en: C and NumPy arrays as well as the built-in `bytes`, `bytearray`, and `array.array`
    objects are similar in the sense that they all operate on a contiguous memory
    area (also called memory *buffer*). Cython provides a universal interface--the
    *typed memoryview--*that unifies and simplifies the access to all these data types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 NumPy 数组以及内置的 `bytes`、`bytearray` 和 `array.array` 对象在某种程度上是相似的，因为它们都在连续的内存区域（也称为内存
    *缓冲区*）上操作。Cython 提供了一个统一的接口——*类型化内存视图*，它统一并简化了对所有这些数据类型的访问。
- en: 'A **memoryview** is an object that maintains a reference on a specific memory
    area. It doesn''t actually own the memory, but it can read and change its contents;
    in other words, it is a *view* on the underlying data. Memoryviews can be defined
    using a special syntax. For example, we can define a memoryview of `int` and a
     two-dimensional memoryview of `double` in the following way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**memoryview** 是一个保持对特定内存区域的引用的对象。它实际上并不拥有内存，但它可以读取和更改其内容；换句话说，它是对底层数据的视图。内存视图可以使用特殊语法定义。例如，我们可以以下这种方式定义
    `int` 类型的内存视图和一个二维 `double` 类型的内存视图：'
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The same syntax applies to the declaration of any type in variables, function
    definitions, class attributes, and so on. Any object that exposes a buffer interface
    (for example, NumPy arrays, `bytes`, and `array.array` objects) will be bound
    to the memoryview automatically. For example, we can bind the memoryview to a
    NumPy array using a simple variable assignment:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的语法也适用于变量、函数定义、类属性等任何类型的声明。任何暴露缓冲区接口的对象（例如，NumPy 数组、`bytes` 和 `array.array`
    对象）都将自动绑定到 `memoryview`。例如，我们可以通过简单的变量赋值将 `memoryview` 绑定到 NumPy 数组：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is important to note that the memoryview does not *own* the data, but it
    only provides a way to *access* and *change* the data it is bound to; the ownership,
    in this case, is left to the NumPy array. As you can see in the following example,
    changes made through the memoryview will act on the underlying memory area and
    will be reflected in the original NumPy structure (and vice versa):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，memoryview 并不“拥有”数据，它只提供了一种访问和更改其绑定数据的途径；在这种情况下，所有权留给了 NumPy 数组。正如您在以下示例中可以看到的，通过
    memoryview 进行的更改将作用于底层内存区域，并将反映在原始 NumPy 结构中（反之亦然）：
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a certain sense, the mechanism behind memoryviews is similar to what NumPy
    produces when we slice an array. As we have seen in [Chapter 3](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml),
    *Fast Array Operations with NumPy and Pandas*, slicing a NumPy array does not
    copy the data but returns a view on the same memory area, and changes to the view
    will reflect on the original array.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，memoryviews 背后的机制与我们在 [第 3 章](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml)
    *使用 NumPy 和 Pandas 进行快速数组操作* 中看到的 NumPy 切片时 NumPy 产生的机制相似。正如我们所见，切片 NumPy 数组不会复制数据，而是返回对相同内存区域的视图，对视图的更改将反映在原始数组上。
- en: 'Memoryviews also support array slicing with the standard NumPy syntax:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Memoryviews 也支持使用标准的 NumPy 语法进行数组切片：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To copy data between one memoryview and another, you can use syntax similar
    to slice assignment, as shown in the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个 memoryview 之间复制数据，您可以使用类似于切片赋值的语法，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, we will use the typed memoryviews to declare types for the
    arrays in our particle simulator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用类型化的 memoryviews 为粒子模拟器中的数组声明类型。
- en: Particle simulator in Cython
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 中的粒子模拟器
- en: Now that we have a basic understanding of how Cython works, we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Cython 的工作原理有了基本的了解，我们可以重写 `ParticleSimulator.evolve` 方法。多亏了 Cython，我们可以将我们的循环转换为
    C 语言，从而消除由 Python 解释器引入的开销。
- en: 'In [Chapter 3](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml), *Fast Array Operations
    with NumPy and Pandas*, we wrote a fairly efficient version of the `evolve` method
    using NumPy. We can rename the old version as `evolve_numpy` to differentiate
    it from the new version:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](fb5356db-d238-4571-b5de-663a8400ad6d.xhtml) *使用 NumPy 和 Pandas 进行快速数组操作*
    中，我们使用 NumPy 编写了一个相当高效的 `evolve` 方法版本。我们可以将旧版本重命名为 `evolve_numpy` 以区分新旧版本：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将此代码转换为 Cython。我们的策略将是利用快速的索引操作，通过移除 NumPy 数组广播，从而回到基于索引的算法。由于 Cython 生成高效的
    C 代码，我们可以自由地使用尽可能多的循环，而不会产生任何性能惩罚。
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx`. The module will contain
    a single Python function, `c_evolve`, that will take the particle positions, angular
    velocities, timestep, and number of steps as input.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计选择，我们可以决定将循环封装在一个函数中，我们将用 Cython 模块 `cevolve.pyx` 重新编写这个函数。该模块将包含一个单一的 Python
    函数 `c_evolve`，它将接受粒子位置、角速度、时间步长和步数作为输入。
- en: 'At first, we are not adding typing information; we just want to isolate the
    function and ensure that we can compile our module without errors:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们不添加类型信息；我们只想隔离函数并确保我们可以无错误地编译我们的模块：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that we don''t need a return value for `c_evolve` as values are updated
    in the `r_i` array in-place. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our benchmark function, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为 `c_evolve` 提供返回值，因为值是在 `r_i` 数组中就地更新的。我们可以通过稍微更改我们的基准函数来对无类型的 Cython
    版本与旧的 NumPy 版本进行基准测试，如下所示：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can time the different versions in an IPython shell:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 IPython 壳中计时不同的版本：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的速度相同。编译不带静态类型的 Cython 模块与纯 Python 没有任何优势。下一步是声明所有重要变量的类型，以便 Cython 可以执行其优化。
- en: 'We can start adding types to the function arguments and see how the performance
    changes. We can declare the arrays as typed memoryviews containing `double` values.
    It''s worth mentioning that if we pass an array of the `int` or `float32` type,
    the casting won''t happen automatically and we will get an error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始向函数参数添加类型，看看性能如何变化。我们可以声明数组为包含 `double` 值的 typed memoryviews。值得一提的是，如果我们传递一个
    `int` 或 `float32` 类型的数组，转换不会自动发生，我们将得到一个错误：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, we can rewrite the loops over the particles and timesteps. We
    can declare the `i` and `j` iteration indices and the `nparticles` particle number
    as `int`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以重写遍历粒子和时间步的循环。我们可以声明 `i` 和 `j` 迭代索引以及 `nparticles` 粒子数量为 `int`：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The algorithm is very similar to the pure Python version; we iterate over the
    particles and timesteps, and we compute the velocity and displacement vectors
    for each particle coordinate using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法与纯 Python 版本非常相似；我们遍历粒子和时间步，并使用以下代码计算每个粒子坐标的速度和位移向量：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, we added the `x`, `y`, `ang_speed`, `norm`, `vx`, `vy`,
    `dx`, and `dy` variables. To avoid the Python interpreter overhead, we have to
    declare them with their corresponding types at the beginning of the function,
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了 `x`、`y`、`ang_speed`、`norm`、`vx`、`vy`、`dx` 和 `dy` 变量。为了避免 Python
    解释器的开销，我们不得不在函数开始时声明它们对应的类型，如下所示：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` present in the `math` module or the one in `numpy`, we will again include
    a slow Python function in our critical loop, thus killing our performance. A fast
    `sqrt` is available in the standard C library, already wrapped in the `libc.math`
    Cython module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个名为 `sqrt` 的函数来计算范数。如果我们使用 `math` 模块或 `numpy` 中的 `sqrt`，我们将在我们的关键循环中再次包含一个慢速的
    Python 函数，从而降低我们的性能。标准 C 库中有一个快速的 `sqrt`，已经包含在 `libc.math` Cython 模块中：
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can rerun our benchmark to assess our improvements, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新运行我们的基准测试来评估我们的改进，如下所示：
- en: '[PRE59]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For small particle numbers, the speed-up is massive as we obtained a 40x performance
    over the previous version. However, we should also try to test the performance
    scaling with a larger number of particles:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小的粒子数量，速度提升非常巨大，我们获得了比上一个版本高 40 倍的性能。然而，我们也应该尝试用更多的粒子数量来测试性能缩放：
- en: '[PRE60]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to 1000, we already decreased our speed-up to
    a more modest 6x. This is likely due to the fact that, as we increase the number
    of particles, the Python for-loop overhead becomes less and less significant compared
    to the speed of other operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着粒子数量的增加，两个版本的速度越来越接近。通过将粒子大小增加到 1000，我们已经将速度提升降低到更适度的 6 倍。这可能是由于随着粒子数量的增加，Python
    for 循环的开销与其他操作速度相比变得越来越不显著。
- en: Profiling Cython
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Cython
- en: 'Cython provides a feature, called *annotated view*, that helps find which lines
    are executed in the Python interpreter and which are good candidates for ulterior
    optimizations. We can turn this feature on by compiling a Cython file with the
    `-a` option. In this way, Cython will generate an HTML file containing our code
    annotated with some useful information. The usage of the `-a` option is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 提供了一个名为 *annotated view* 的功能，有助于找到在 Python 解释器中执行的哪些行，以及哪些是后续优化的良好候选。我们可以通过使用
    `-a` 选项编译 Cython 文件来启用此功能。这样，Cython 将生成一个包含我们代码的 HTML 文件，并附有一些有用的信息。使用 `-a` 选项的方法如下：
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The HTML file displayed in the following screenshot shows our Cython file line
    by line:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示的 HTML 文件逐行显示了我们的 Cython 文件：
- en: '![](img/Screenshot-from-2017-02-01-19-11-43.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-02-01-19-11-43.png)'
- en: Each line in the source code can appear in different shades of yellow. A more
    intense color corresponds to more interpreter-related calls, while white lines
    are translated to regular C code. Since interpreter calls substantially slow down
    execution, the objective is to make the function body as white as possible. By
    clicking on any of the lines, we can inspect the code generated by the Cython
    compiler. For example, the `v_y = x/norm` line checks that the norm is not `0` and
    raises a `ZeroDivisionError` if the condition is not verified. The `x = r_i[j,
    0]` line shows that Cython checks whether the indexes are within the bounds of
    the array. You may note that the last line is of a very intense color; by inspecting
    the code, we can see that this is actually a glitch; the code refers to a boilerplate
    related to the end of the function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码中的每一行都可能以不同的黄色阴影出现。颜色越深，与解释器相关的调用就越多，而白色行则被转换为常规的 C 代码。由于解释器调用会显著减慢执行速度，目标是将函数体尽可能地变为白色。通过单击任何一行，我们可以检查
    Cython 编译器生成的代码。例如，`v_y = x/norm` 行检查 norm 是否不是 `0`，如果条件未验证，则抛出 `ZeroDivisionError`。`x
    = r_i[j, 0]` 行显示 Cython 检查索引是否在数组的边界内。您可能会注意到最后一行颜色非常深；通过检查代码，我们可以看到这实际上是一个错误；代码引用了与函数结束相关的样板代码。
- en: 'Cython can shut down checks, such as division by zero, so that it can remove
    those extra interpreter related calls; this is usually accomplished through compiler
    directives. There are a few different ways to add compiler directives:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 可以关闭检查，例如除以零，以便它可以移除那些额外的解释器相关调用；这通常是通过编译器指令完成的。有几种不同的方法可以添加编译器指令：
- en: Using a decorator or a context manager
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器或上下文管理器
- en: Using a comment at the beginning of the file
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件开头使用注释
- en: Using the Cython command-line options
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 命令行选项
- en: For a complete list of the Cython compiler directives, you can refer to the
    official documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Cython 编译器指令的完整列表，您可以参考官方文档[http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives)。
- en: 'For example, to disable bounds checking for arrays, it is sufficient to decorate
    a function with `cython.boundscheck`, in the following way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要禁用数组边界检查，只需用 `cython.boundscheck` 装饰一个函数，如下所示：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Alternatively, we can use `cython.boundscheck` to wrap a block of code into
    a context manager, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `cython.boundscheck` 将代码块包装成上下文管理器，如下所示：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If we want to disable bounds checking for a whole module, we can add the following
    line of code at the beginning of the file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想禁用整个模块的边界检查，我们可以在文件开头添加以下代码行：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To alter the directives with the command-line options, you can use the `-X` option
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行选项更改指令，您可以使用 `-X` 选项，如下所示：
- en: '[PRE65]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To disable the extra checks in our `c_evolve` function, we can disable the
    `boundscheck` directive and enable `cdivision` (this prevents checks for `ZeroDivisionError`),
    as in the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用 `c_evolve` 函数中的额外检查，我们可以禁用 `boundscheck` 指令并启用 `cdivision`（这防止了 `ZeroDivisionError`
    的检查），如下面的代码所示：
- en: '[PRE66]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we look at the annotated view again, the loop body has become completely
    white--we removed all traces of the interpreter from the inner loop. In order
    to recompile, just type `python setup.py build_ext --inplace` again. By running
    the benchmark, however, we note that we didn''t obtain a performance improvement,
    suggesting that those checks are not part of the bottleneck:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看注释视图，循环体已经完全变成白色——我们移除了内循环中所有解释器的痕迹。为了重新编译，只需再次输入 `python setup.py build_ext
    --inplace`。然而，通过运行基准测试，我们注意到我们没有获得性能提升，这表明这些检查不是瓶颈的一部分：
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Another way to profile Cython code is through the use of the `cProfile` module. As
    an example, we can write a simple function that calculates the Chebyshev distance
    between coordinate arrays. Create a `cheb.py` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对 Cython 代码进行性能分析的方法是通过使用 `cProfile` 模块。例如，我们可以编写一个简单的函数来计算坐标数组之间的 Chebyshev
    距离。创建一个 `cheb.py` 文件：
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to collect profiling information for
    the `max` and `min` functions, we need to add the `profile=True` option to the
    `mathlib.pyx` file, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试以当前状态分析此脚本，我们将无法获取关于我们在 Cython 中实现的函数的任何统计信息。如果我们想收集 `max` 和 `min` 函数的配置文件信息，我们需要将
    `profile=True` 选项添加到 `mathlib.pyx` 文件中，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 IPython 的 `%prun` 来配置文件分析我们的脚本，如下所示：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. Most of the time seems to be spent in the `benchmark` function, meaning
    that the bottleneck is likely the pure Python for-loop. In this case, the best
    strategy will be rewriting the loop in NumPy or porting the code to Cython.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到 `max` 函数存在并且不是瓶颈。大部分时间似乎花在了 `benchmark` 函数中，这意味着瓶颈很可能是纯 Python 的
    for 循环。在这种情况下，最佳策略将是用 NumPy 重写循环或将代码移植到 Cython。
- en: Using Cython with Jupyter
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 与 Jupyter
- en: Optimizing Cython code requires substantial trial and error. Fortunately, Cython
    tools can be conveniently accessed through the Jupyter notebook for a more streamlined
    and integrated experience.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 优化 Cython 代码需要大量的试验和错误。幸运的是，Cython 工具可以通过 Jupyter 笔记本方便地访问，以获得更流畅和集成的体验。
- en: You can launch a notebook session by typing `jupyter notebook` in the command
    line and you can load the Cython magic by typing `%load_ext cython` in a cell.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行中键入 `jupyter notebook` 来启动笔记本会话，并且可以在一个单元中键入 `%load_ext cython` 来加载
    Cython 魔法。
- en: 'As already mentioned earlier, the `%%cython` magic can be used to compile and
    load the Cython code inside the current session. As an example, we may copy the
    contents of `cheb.py` into a notebook cell:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以使用 `%%cython` 魔法在当前会话中编译和加载 Cython 代码。例如，我们可以将 `cheb.py` 的内容复制到一个笔记本单元中：
- en: '[PRE71]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A useful feature of the `%%cython` magic is the `-a` option that will compile
    the code and produce an annotated view (just like the command line `-a` option)
    of the source directly in the notebook, as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`%%cython` 魔法的有用功能是 `-a` 选项，它将编译代码并直接在笔记本中生成源代码的注释视图（就像命令行 `-a` 选项一样），如下面的截图所示：'
- en: '![](img/Screenshot-from-2017-02-02-18-49-37.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-02-02-18-49-37.png)'
- en: 'This allows you to quickly test different versions of your code and also use
    the other integrated tools available in Jupyter. For example, we can time and
    profile the code (provided that we activate the profile directive in the cell)
    in the same session using tools such as `%prun` and `%timeit`. For example, we
    can inspect the profiling results by taking advantage of the `%prun` magic, as
    shown in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您快速测试代码的不同版本，并使用 Jupyter 中可用的其他集成工具。例如，我们可以使用 `%prun` 和 `%timeit` 等工具在同一个会话中计时和配置文件分析代码（前提是在单元中激活配置文件指令）。例如，我们可以通过利用
    `%prun` 魔法来检查配置文件结果，如下面的截图所示：
- en: '![](img/Screenshot-from-2017-02-02-18-56-35.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-02-02-18-56-35.png)'
- en: 'It is also possible to use the `line_profiler` tool we discussed in [Chapter
    1](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml), *Benchmarking and Profiling*,
    directly in the notebook. In order to support line annotations, it is necessary
    to do the following things:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以直接在笔记本中使用我们在第 1 章[基准测试和配置文件分析](4db2c3e6-3485-41a5-8450-07220f6d80ec.xhtml)中讨论的
    `line_profiler` 工具。为了支持行注释，必须执行以下操作：
- en: Enable the `linetrace=True` and `binding=True` compiler directives
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 `linetrace=True` 和 `binding=True` 编译器指令
- en: Enable the `CYTHON_TRACE=1` flag at compile time
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时启用 `CYTHON_TRACE=1` 标志
- en: 'This can be easily accomplished by adding the respective arguments to the `%%cython`
    magic, and by setting the compiler directives, as shown in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过向 `%%cython` 魔法添加相应的参数以及设置编译器指令轻松实现，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once the code is instrumented, we can profile using the `%lprun` magic:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码被配置，我们可以使用 `%lprun` 魔法进行配置文件分析：
- en: '[PRE73]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, a good chunk of time is actually spent in line 16, which is
    a pure Python loop and a good candidate for further optimization.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分时间实际上花在了第 16 行，这是一个纯 Python 循环，是进一步优化的良好候选者。
- en: The tools available in Jupyter notebook allow for a fast edit-compile-test cycle
    so that you can quickly prototype and save time when testing different solutions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 笔记本中可用的工具允许快速编辑-编译-测试周期，以便您可以快速原型设计并在测试不同解决方案时节省时间。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Cython is a tool that bridges the convenience of Python with the speed of C.
    Compared to C bindings, Cython programs are much easier to maintain and debug,
    thanks to the tight integration and compatibility with Python and the availability
    of excellent tools.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种工具，它将 Python 的便利性与 C 的速度相结合。与 C 绑定相比，Cython 程序由于与 Python 的紧密集成和兼容性，以及优秀工具的可用性，维护和调试要容易得多。
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types to our variables and functions.
    We also learned how to work with C arrays, NumPy arrays, and memoryviews.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Cython 语言的基础知识，以及如何通过给变量和函数添加静态类型来使我们的程序运行更快。我们还学习了如何与 C 数组、NumPy
    数组和内存视图一起工作。
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to spot hard-to-find interpreter related calls and how to enable `cProfile` support
    in Cython. Also, we learned how to take advantage of the Jupyter notebook for
    integrated profiling and analysis of Cython codes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重写关键的 `evolve` 函数优化了我们的粒子模拟器，获得了巨大的速度提升。最后，我们学会了如何使用注释视图来查找难以发现的与解释器相关的调用，以及如何在
    Cython 中启用 `cProfile` 支持。此外，我们还学会了如何利用 Jupyter 笔记本来进行 Cython 代码的集成分析和性能分析。
- en: In the next chapter, we will explore other tools that can generate fast machine
    code on the fly, without requiring compilation of our code to C ahead of time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨其他可以在不预先将我们的代码编译为 C 的情况下即时生成快速机器代码的工具。
