- en: Chapter 5 – Exploring built in collection types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章 - 探索内置的集合类型
- en: We’ve already encountered some of the built-in collections
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了一些内置集合
- en: '`str` – the immutable string sequence of Unicode code points'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str` - 不可变的Unicode代码点序列'
- en: '`list` – the mutable sequence of objects'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list` - 可变的对象序列'
- en: '`dict` – the mutable dictionary mapping from immutable keys to mutable objects'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict` - 从不可变键到可变对象的可变字典映射'
- en: 'We’ve only scratched the surface of how these collections work, so we’ll explore
    their powers in greater depth in this chapter. We’ll also introduce three new
    built-in collections types:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是浅尝辄止地了解了这些集合的工作原理，所以我们将在本章更深入地探索它们的功能。我们还将介绍三种新的内置集合类型：
- en: '`tuple` - the immutable sequence of objects'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple` - 不可变的对象序列'
- en: '`range` - for arithmetic progressions of integers'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` - 用于整数的算术级数'
- en: '`set` - a mutable collection of unique, immutable objects'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` - 一个包含唯一不可变对象的可变集合'
- en: We won’t cover the `bytes` type any further here. We’ve already discussed its
    essential differences with `str`, and most of what we learn about `str` can also
    be applied to `bytes`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里进一步讨论`bytes`类型。我们已经讨论了它与`str`的基本区别，大部分关于`str`的内容也适用于`bytes`。
- en: This is not an exhaustive list of Python collection types, but it’s completely
    sufficient for the overwhelming majority of Python 3 programs you’ll encounter
    in the wild or are likely to write yourself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是Python集合类型的详尽列表，但对于你在野外遇到或可能自己编写的绝大多数Python 3程序来说，这完全足够了。
- en: In this chapter we’ll be covering these collections in the order mentioned above,
    rounding things off with an overview of the *protocols* that unite these collections
    and which allow them to be used in consistent and predictable ways.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将按照上述顺序介绍这些集合，最后概述*协议*，这些协议将这些集合联系在一起，并允许它们以一致和可预测的方式使用。
- en: '`tuple` – an immutable sequence of objects'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`tuple` - 一个不可变的对象序列'
- en: Tuples in Python are immutable sequences of arbitrary objects. Once created,
    the objects within them cannot be replaced or removed, and new elements cannot
    be added.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的元组是任意对象的不可变序列。一旦创建，其中的对象就不能被替换或移除，也不能添加新元素。
- en: Literal tuples
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文字元组
- en: 'Tuples have a similar literal syntax to lists, except that they are delimited
    by parentheses rather than square brackets. Here is a literal tuple containing
    a string, a float and an integer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 元组具有与列表类似的文字语法，只是它们用括号而不是方括号括起来。这是一个包含字符串、浮点数和整数的文字元组：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tuple element access
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元组元素访问
- en: 'We can access the elements of a tuple by zero-based index using square brackets:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号通过零基索引访问元组的元素：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The length of a tuple
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元组的长度
- en: 'We can determine the number of elements in the tuple using the built-in `len()`
    function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置的`len()`函数来确定元组中的元素数量：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Iterating over a tuple
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对元组进行迭代
- en: 'We can iterate over it using a for-loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for循环对其进行迭代：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Concatenating and repetition of tuples
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元组的连接和重复
- en: 'We can concatenate tuples using the plus operator:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用加号运算符连接元组：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we can repeat them using the multiplication operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用乘法运算符重复它们：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nested tuples
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套元组
- en: 'Since tuples can contain any object, it’s perfectly possible to have nested
    tuples:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组可以包含任何对象，因此完全可以有嵌套元组：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We use repeated application of the indexing operator to get to the inner elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用索引运算符的重复应用来访问内部元素：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Single-element tuples
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元素元组
- en: 'Sometimes a single element tuple is required. To write this, we can’t just
    use a simple object in parentheses. This is because Python parses that as an object
    enclosed in the precedence controlling parentheses of a math expression:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要一个单元素元组。要写这个，我们不能只使用括号中的简单对象。这是因为Python将其解析为数学表达式的优先控制括号中的对象：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create a single-element tuple we make use of the trailing comma separator
    which, you’ll recall, we’re allowed to use when specifying literal tuples, lists,
    and dictionaries. A single element with a trailing comma is parsed as a single
    element tuple:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个单元素元组，我们使用尾随逗号分隔符，你会记得，我们允许在指定文字元组、列表和字典时使用尾随逗号。带有尾随逗号的单个元素被解析为单个元素元组：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Empty tuples
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空元组
- en: 'This leaves us with the problem of how to specify an empty tuple. In actuality
    the answer is simple, we just use empty parentheses:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们面临一个问题，如何指定一个空元组。实际上答案很简单，我们只需使用空括号：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Optional parentheses
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选的括号
- en: 'In many cases, the parentheses of literal tuples may omitted:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以省略文字元组的括号：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Returning and unpacking tuples
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回和解包元组
- en: 'This feature is often used when returning multiple values from a function.
    Here we make a function to return the minimum and maximum values of a sequence,
    the hard work being done by two built-in functions `min()` and `max()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性经常在从函数返回多个值时使用。在这里，我们创建一个函数来返回序列的最小值和最大值，这是由两个内置函数`min()`和`max()`完成的：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Returning multiple values as a tuple is often used in conjunction with a wonderful
    feature of Python called *tuple unpacking*. Tuple unpacking is a so-called *destructuring
    operation* which allows us to unpack data structures into named references. For
    example, we can assign the result of our `minmax()` function to two new references
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个值作为元组返回经常与Python的一个称为*元组解包*的精彩特性一起使用。元组解包是一种所谓的*解构操作*，它允许我们将数据结构解包为命名引用。例如，我们可以将`minmax()`函数的结果分配给两个新引用，如下所示：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This also works with nested tuples:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于嵌套元组：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Swapping variables with tuple unpacking
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用元组解包交换变量
- en: 'Tuple unpacking leads to the beautiful Python idiom for swapping two (or more)
    variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解包导致了Python中交换两个（或更多）变量的美丽习惯用法：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The tuple constructor
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组构造函数
- en: 'Should you need to create a tuple from an existing collection object, such
    as a list, you can use the `tuple()` constructor. Here we create a `tuple` from
    a `list`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从现有集合对象（如列表）创建元组，可以使用`tuple()`构造函数。在这里，我们从一个`list`创建一个`tuple`：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here we create a tuple containing the characters of a string:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个包含字符串字符的元组：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Membership tests
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 成员资格测试
- en: 'Finally, as with most collection types in Python, we can test for membership
    using the `in` operator:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与Python中大多数集合类型一样，我们可以使用`in`运算符测试成员资格：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'or non-membership with the `not in` operator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用`not in`运算符进行非成员资格测试：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Strings in action
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串的应用
- en: We covered the `str` type at some length already in chapter two, but we’ll take
    time now to explore its capabilities in a more depth.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章已经详细介绍了`str`类型，但现在我们将花时间更深入地探索它的功能。
- en: The length of a string
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串的长度
- en: As with any other Python sequence, we can determine the length of a string with
    the built-in `len()` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他Python序列一样，我们可以使用内置的`len()`函数确定字符串的长度。
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![The sign for the railway station at Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
    on the Welsh island of Anglesey – the longest placename in Europe.](images/m05----llanfair.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![威尔士安格尔西岛上的兰韦尔普尔古因吉尔戈盖里希温德罗布尔兰蒂斯利奥戈戈戈乔火车站的标志 - 欧洲最长的地名。](images/m05----llanfair.png)'
- en: The sign for the railway station at Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
    on the Welsh island of Anglesey – the longest placename in Europe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 威尔士安格尔西岛上的兰韦尔普尔古因吉尔戈盖里希温德罗布尔兰蒂斯利奥戈戈戈乔火车站的标志 - 欧洲最长的地名。
- en: Concatenating strings
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'Concatenation of strings is supported using the plus operator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加号运算符支持字符串的连接：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'or the related augmented assignment operator:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或相关的增强赋值运算符：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Newfoundland, the sixteenth largest island in the world, is one of relative
    few closed, triple-compound words in English.](images/m05----newfoundland.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![纽芬兰岛，世界第十六大岛，是英语中相对较少的封闭的三重复合词之一。](images/m05----newfoundland.png)'
- en: Newfoundland, the sixteenth largest island in the world, is one of relative
    few closed, triple-compound words in English.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 纽芬兰岛是世界第十六大岛，是英语中相对较少的封闭的三重复合词之一。
- en: Remember that strings are immutable, so here the augmented assignment operator
    is binding a new string object to `s` on each use. The illusion of modifying `s`
    in place is achievable because `s` is a reference to an object, not an object
    itself. That is, although the string itself is immutable, the reference to it
    is mutable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串是不可变的，因此在这里，增强赋值运算符在每次使用时将一个新的字符串对象绑定到`s`上。修改`s`的假象是可行的，因为`s`是对对象的引用，而不是对象本身。也就是说，虽然字符串本身是不可变的，但对它的引用是可变的。
- en: Joining strings
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接字符串
- en: For joining large numbers of strings, avoid using the `+` or `+=` operators.
    Instead, the `join()` method should be preferred because it is substantially more
    efficient. This is because concatenation using the addition operator or it’s augmented
    assignment version can lead to the generation of large numbers of temporaries,
    with consequent costs for memory allocation and copies. Let’s see how `join()`
    is used.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接大量字符串，避免使用`+`或`+=`运算符。相反，应优先使用`join()`方法，因为它效率更高。这是因为使用加法运算符或其增强赋值版本进行连接可能会导致生成大量临时变量，从而导致内存分配和复制的成本。让我们看看`join()`是如何使用的。
- en: '`join()` is a method on `str` which takes a collection of strings as an argument
    and produces a new string by inserting a separator between each of them. An interesting
    aspect of `join()` is how the separator is specified: it is the string on which
    `join()` is called.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`是`str`上的一个方法，它接受一个字符串集合作为参数，并通过在它们之间插入分隔符来生成一个新的字符串。`join()`的一个有趣之处在于分隔符的指定方式：它是在调用`join()`的字符串。'
- en: 'As with many parts of Python, an example is the best explanation. To join a
    list of HTML color code strings into a semicolon separated string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python的许多部分一样，示例是最好的解释。将HTML颜色代码字符串列表连接成分号分隔的字符串：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we call `join()` on the separator we wish to use – the semicolon – and
    pass in the list of strings to be joined.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们希望使用的分隔符上调用`join()` - 分号 - 并传入要连接的字符串列表。
- en: 'A widespread and fast Python idiom for concatenating together a collection
    of strings is to `join()` using an empty string as the separator:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组字符串连接在一起的广泛且快速的Python习惯用法是使用空字符串作为分隔符进行`join()`：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Splitting strings
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分割字符串
- en: 'We can then split strings up again using the `split()` method (which we’ve
    already encountered, but this time we’re going to provide it’s optional argument):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以再次使用`split()`方法来分割字符串（我们已经遇到过，但这次我们将提供它的可选参数）：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The optional argument lets you specify the string — not just the character
    — on which to split the string. So, for example, you could parse a hasty breakfast
    order by splitting on the word ‘and’:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数允许您指定要在其上分割字符串的字符串 - 不仅仅是字符。因此，例如，您可以通过在单词“and”上分割来解析匆忙的早餐订单：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅之时刻
- en: '![](images/m05----zen-the-way-may-not-be-obvious.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m05----zen-the-way-may-not-be-obvious.png)'
- en: This use of `join()` is often confusing to the uninitiated, but with use, the
    approach taken by Python will be appreciated as natural and elegant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用`join()`的方法常常让初学者感到困惑，但随着使用，Python采取的方法将被认为是自然和优雅的。
- en: '* * *'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Partitioning strings
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串分区
- en: 'Another very useful string method is `partition()` which divides a string into
    three sections; the part before a separator, the separator itself, and the part
    after the separator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的字符串方法是`partition()`，它将字符串分成三个部分；分隔符之前的部分，分隔符本身，以及分隔符之后的部分：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `partition()` method returns a tuple, so this is commonly used in conjunction
    with tuple unpacking:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()`方法返回一个元组，因此这通常与元组解包一起使用：'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Often, we’re not interested in capturing the separator value, so you might
    see the underscore variable name used. This is not treated in a special way by
    the Python language, but there’s an unwritten convention that the underscore variable
    is for unused or dummy values:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们对捕获分隔符值不感兴趣，所以您可能会看到下划线变量名被使用。这在Python语言中并没有特殊对待，但有一个不成文的惯例，即下划线变量用于未使用或虚拟值：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This convention is supported by many Python-aware development tools which will
    suppress unused variable warnings for underscore.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约定得到了许多Python感知开发工具的支持，这些工具将抑制对下划线未使用变量的警告。
- en: String formatting
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'One of the most interesting and frequently used string methods is `format()`.
    This supersedes, although does not replace, the string interpolation technique
    used in older versions of Python, and which we do not cover in this book. The
    `format()` method can be usefully called on any string containing so-called *replacement
    fields* which are surrounded by curly braces. The objects provided as arguments
    to `format()` are converted to strings and used to populate these fields. Here’s
    an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣和经常使用的字符串方法之一是`format()`。这取代了旧版本Python中使用的字符串插值技术，虽然没有取代它，并且我们在本书中没有涵盖。`format()`方法可以有用地调用任何包含所谓的*替换字段*的字符串，这些字段用花括号括起来。作为`format()`参数提供的对象被转换为字符串，并用于填充这些字段。这里是一个例子：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The field names, in this case `0` and `1`, are matched up with the positional
    arguments to `format()`, and each argument is converted to a string behind the
    scenes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字段名称（`0`和`1`）与`format()`的位置参数匹配，并且每个参数在幕后被转换为字符串。
- en: 'A field name may be used more than once:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字段名称可能被多次使用：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, if the field names are used exactly once and in the same order as
    the arguments, they can be omitted:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果字段名恰好只使用一次，并且按照相同的顺序作为参数，它们可以被省略：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If keyword arguments are supplied to `format()` then named fields can be used
    instead of ordinals:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`format()`提供了关键字参数，则可以使用命名字段而不是序数：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It’s possible to index into sequences using square brackets inside the replacement
    field:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用方括号索引到序列，并放在替换字段中：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can even access object attributes. Here we pass the whole `math` module
    to `format()` using a keyword argument (Remember – modules are objects too!),
    then access two of its attributes from within the replacement fields:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以访问对象属性。在这里，我们使用关键字参数将整个`math`模块传递给`format()`（记住 - 模块也是对象！），然后从替换字段中访问它的两个属性：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Format strings also give us a lot of control over field alignment and floating-point
    formatting. Here’s the same with the constants displayed to only three decimal
    places:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串还可以让我们对字段对齐和浮点格式化有很多控制。这里是相同的常量，只显示到小数点后三位：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Other string methods
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他字符串方法
- en: 'We recommend you spend some time familiarizing yourself with the other string
    methods. Remember, you can find out what they are using:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您花一些时间熟悉其他字符串方法。记住，您可以使用以下方法找出它们是什么：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`range` – a collection of evenly spaced integers'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`range` - 一组均匀间隔的整数'
- en: Let’s move on and look at `range`, which many developers wouldn’t consider to
    be a collection^([12](chap21.xhtml#fn-range)), although we’ll see that in Python
    3 it most definitely is.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看`range`，许多开发人员不认为它是一个集合^([12](chap21.xhtml#fn-range))，尽管我们会看到在Python
    3中它绝对是。
- en: 'A `range` is a type of sequence used for representing an arithmetic progression
    of integers. Ranges are created by calls to the `range()` constructor, and there
    is no literal form. Most typically we supply only the stop value, as Python defaults
    to a starting value of zero:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`是一种用于表示整数的算术级数的序列类型。范围是通过调用`range()`构造函数创建的，没有文字形式。通常我们只提供停止值，因为Python默认为零起始值：'
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Ranges are sometimes used to create consecutive integers for use as loop counters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 范围有时用于创建连续的整数，用作循环计数器：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the stop value supplied to `range()` is one past the end of the sequence,
    which is why the previous loop didn’t print 5.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提供给`range()`的停止值比序列的末尾多一个，这就是为什么之前的循环没有打印5的原因。
- en: Starting value
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 起始值
- en: 'We can also supply a starting value if we wish:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们还可以提供一个起始值：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Wrapping this in a call to the `list()` constructor is a handy way to force
    production of each item:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个放在`list()`构造函数中是一种强制生成每个项目的方便方式：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This so-called half-open range convention — with the stop value not being included
    in the sequence — at first seems strange, but it actually makes a lot of sense
    if you’re dealing with consecutive ranges because the end specified by one range
    is the start of the next one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种所谓的半开放范围约定 - 停止值不包括在序列中 - 乍看起来很奇怪，但如果你处理连续范围，它实际上是有道理的，因为一个范围指定的结束是下一个范围的开始：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Step argument
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步长参数
- en: 'Range also supports a step argument:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Range还支持步长参数：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that in order to use the step argument, we must supply all three arguments.
    Range is curious in that it determines what its arguments mean by counting them.
    Providing only one argument means that the argument is the `stop` value. Two arguments
    are `start` and `stop`, and three arguments are `start`, `stop` and `step`. Python
    `range()` works this way so the first argument, `start`, can be made optional,
    something which isn’t normally possible. Furthermore the `range` constructor doesn’t
    support keyword arguments. You might almost describe it as unPythonic!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使用步长参数，我们必须提供所有三个参数。范围很奇怪，因为它通过计算其参数来确定它们的含义。只提供一个参数意味着该参数是`stop`值。两个参数是`start`和`stop`，三个参数是`start`，`stop`和`step`。Python
    `range()`以这种方式工作，因此第一个参数`start`可以是可选的，这在通常情况下是不可能的。此外，`range`构造函数不支持关键字参数。你几乎可以说它是不符合Python风格的！
- en: '![The arguably unPythonic constructor for range, where the interpretation of
    the arguments depends on whether one, two, or three are provided.](images/m05----range-constructor.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![arguably unPythonic constructor for range, where the interpretation of the
    arguments depends on whether one, two, or three are provided.](images/m05----range-constructor.png)'
- en: The arguably unPythonic constructor for range, where the interpretation of the
    arguments depends on whether one, two, or three are provided.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于范围的构造函数，这可能是不符合Python风格的，因为参数的解释取决于提供了一个、两个还是三个参数。
- en: 'Not using `range`: `enumerate()`'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不使用`range`：`enumerate()`
- en: 'At this point we’re going to show you another example of poorly styled code,
    except this time it’s one you can, and should, avoid. Here’s a poor way to print
    the elements in a list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将向您展示另一个样式不佳的代码示例，但这次是您可以，也应该避免的。这是一个打印列表中元素的不好的方法：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Although this works, it is most definitely unPythonic. Always prefer to use
    iteration over objects themselves:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做是有效的，但绝对不是Pythonic的。始终更喜欢使用对象本身的迭代：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you need a counter, you should use the built-in `enumerate()` function which
    returns an iterable series of pairs, each pair being a `tuple`. The first element
    of each pair is the index of the current item and the second element of each pair
    is the item itself:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个计数器，您应该使用内置的`enumerate()`函数，它返回一个可迭代的成对序列，每对都是一个`tuple`。每对的第一个元素是当前项目的索引，每对的第二个元素是项目本身：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Even better, we can use tuple unpacking and avoid having to directly deal with
    the tuple:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以使用元组解包，避免直接处理元组：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`list` in action'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`list`的操作'
- en: We’ve already covered lists a little, and we’ve been making good use of them.
    We know how to create lists using the literal syntax, add to them using the `append()`
    method, and get at and modify their contents using the square brackets indexing
    with positive, zero-based indexes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微介绍了列表，并且已经充分利用了它们。我们知道如何使用文字语法创建列表，使用`append()`方法添加到列表中，并使用带有正数、从零开始的索引的方括号索引来获取和修改它们的内容。
- en: '![Zero and positive integers index from the front of a list, so index four
    is the fifth element in the list.](images/m05----list-forward-index.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![零和正整数从列表的前面索引，因此索引四是列表中的第五个元素。](images/m05----list-forward-index.png)'
- en: Zero and positive integers index from the front of a list, so index four is
    the fifth element in the list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 零和正整数从列表的前面索引，因此索引四是列表中的第五个元素。
- en: Now we’ll take a deeper look.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入研究一下。
- en: Negative indexing for lists (and other sequences)
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表（和其他序列）的负索引
- en: 'One very convenient feature of lists (and other Python sequences, for this
    applies to tuples too) is the ability to index from the end, rather than from
    the beginning. This is achieved by supplying *negative* indices. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表（以及其他Python序列，对于元组也适用）的一个非常方便的特性是能够从末尾而不是从开头进行索引。这是通过提供*负*索引来实现的。例如：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Negative integers are −1 based backwards from the end, so index −5 is the
    last but fourth  element.](images/m05----list-reverse-index.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![负整数是从末尾向后的-1，因此索引-5是最后但第四个元素。](images/m05----list-reverse-index.png)'
- en: Negative integers are −1 based backwards from the end, so index −5 is the last
    but fourth element.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 负整数是从末尾向后的-1，因此索引-5是最后但第四个元素。
- en: 'This is much more elegant than the clunky equivalent of computing a positive
    index, which you would otherwise need to use for retrieving that last element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这比计算正索引的笨拙等效方法要优雅得多，否则您将需要使用它来检索最后一个元素：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that indexing with -0 is the same as indexing with 0 and returns the first
    element in the list. Because there is no distinction between 0 and negative zero,
    negative indexing is essentially one-based rather than zero-based. This is good
    to keep in mind if you’re calculating indices with even moderately complex logic:
    one-off errors can creep into negative indexing fairly easily.^([13](chap21.xhtml#fn-one-off))'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用-0进行索引与使用0进行索引相同，并返回列表中的第一个元素。由于0和负零之间没有区别，负索引基本上是基于1而不是基于0的。如果您正在计算具有相当复杂逻辑的索引，这一点很重要：负索引很容易出现一次性错误。^([13](chap21.xhtml#fn-one-off))
- en: Slicing lists
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切片列表
- en: 'Slicing is a form of extended indexing which allows us to refer to portions
    of a list. To use it we pass the start and stop indices of a half-open range,
    separated by a colon, as the square-brackets index argument. Here’s how:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是一种扩展索引的形式，允许我们引用列表的部分。为了使用它，我们传递一个半开放范围的开始和停止索引，用冒号分隔，作为方括号索引参数。这是如何做的：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See how the second index is one beyond the end of the returned range.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二个索引超出了返回范围的末尾。
- en: '![The slice `[1:4]`. Slicing extracts part of a list. The slice range is half-open,
    so the value at the stop index is not included.](images/m05----slice-forward-indexes.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![切片`[1:4]`。切片提取列表的一部分。切片范围是半开放的，因此停止索引处的值不包括在内。](images/m05----slice-forward-indexes.png)'
- en: The slice `[1:4]`. Slicing extracts part of a list. The slice range is half-open,
    so the value at the stop index is not included.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[1:4]`。切片提取列表的一部分。切片范围是半开放的，因此停止索引处的值不包括在内。
- en: 'This facility can be combined with negative indices. For example, to take all
    elements except the first and last:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能可以与负索引结合使用。例如，除了第一个和最后一个元素之外，可以获取所有元素：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![The slice `[1:-1]` is useful for excluding the first and last elements of
    a list.](images/m05----slice-backward-indexes.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![切片`[1：-1]`对于排除列表的第一个和最后一个元素非常有用。](images/m05----slice-backward-indexes.png)'
- en: The slice `[1:-1]` is useful for excluding the first and last elements of a
    list.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[1：-1]`对于排除列表的第一个和最后一个元素非常有用。
- en: 'Both the start and stop indices are optional. To slice all elements from the
    third to the end of the list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和停止索引都是可选的。要从第三个元素开始切片到列表的末尾：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![The slice `[3:]` retains all the elements from the fourth, up to and including
    the last element.](images/m05----slice-to-end.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![切片`[3：]`保留了从第四个元素到最后一个元素的所有元素。](images/m05----slice-to-end.png)'
- en: The slice `[3:]` retains all the elements from the fourth, up to and including
    the last element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[3：]`保留了从第四个元素到最后一个元素的所有元素。
- en: 'To slice all elements from the beginning up to, but not including, the third:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要从开头切片到第三个元素，但不包括第三个元素：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![The slice `[:3]` retains all elements from the beginning of the list up to,'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![切片`[:3]`保留了列表开头的所有元素，直到，'
- en: but *not* including, the fourth element.](images/m05----slice-from-beginning.png)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但*不*包括第四个元素。](images/m05----slice-from-beginning.png)
- en: The slice `[:3]` retains all elements from the beginning of the list up to,
    but *not* including, the fourth element.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[:3]`保留了列表开头的所有元素，但*不*包括第四个元素。
- en: Notice that these two lists are complementary, and together form the whole list,
    demonstrating the convenience of the half-open range convention.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个列表是互补的，并且一起形成整个列表，展示了半开范围约定的便利性。
- en: '![The slice `[:3]` and `[3:]` slices are complementary.](images/m05----complementary-slices.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![切片`[:3]`和`[3:]`是互补的。](images/m05----complementary-slices.png)'
- en: The slice `[:3]` and `[3:]` slices are complementary.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[:3]`和`[3:]`是互补的。
- en: 'Since both start and stop slice indices are optional, it’s entirely possible
    to omit both and retrieve all of the elements:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开始和停止切片索引都是可选的，完全可以省略两者并检索所有元素：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is a called a *full slice*, and it’s an important technique in Python.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*完整切片*，在Python中是一种重要的技术。
- en: '![The slice `[:]` is the full-slice and contains all of the elements from the
    list. It''s an important idiom for copying lists.](images/m05----full-slice.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![切片`[:]`是完整切片，包含列表中的所有元素。这是一个重要的习语，用于复制列表。](images/m05----full-slice.png)'
- en: The slice `[:]` is the full-slice and contains all of the elements from the
    list. It’s an important idiom for copying lists.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 切片`[:]`是完整切片，包含列表中的所有元素。这是一个重要的习语，用于复制列表。
- en: Copying lists
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制列表
- en: 'Indeed, the full slice is an important idiom for *copying* a list. Recall that
    assigning references never copies an object, but rather merely copies a reference
    to an object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，完整切片是*复制*列表的重要习语。请记住，分配引用永远不会复制对象，而只是复制对对象的引用：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We deploy the full slice to perform a copy into a new list:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完整切片将其复制到一个新列表中：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And confirm that the list obtained with the full slice has a distinct identity:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 并确认使用完整切片获得的列表具有独特的身份：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Although it has an equivalent value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它具有等效的值：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It’s important to understand that although we have a new list object which can
    be independently modified, the elements within it are references to the same objects
    referred to by the original list. In the event that these objects are both mutable
    and modified (as opposed to replaced) the change will be seen in both lists.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，虽然我们有一个可以独立修改的新列表对象，但其中的元素是对原始列表引用的相同对象的引用。如果这些对象都是可变的并且被修改（而不是替换），则更改将在两个列表中都可见。
- en: 'We show this full-slice list copying idiom because you are likely to see it
    in the wild, and it’s not immediately obvious what it does. You should be aware
    that there are other more readable ways of copying a list, such as the `copy()`
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示这种完整切片列表复制习语，因为您可能会在实际应用中看到它，而且它的作用并不是立即明显的。您应该知道还有其他更可读的复制列表的方法，比如`copy()`方法：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Or a simple call to the list constructor, passing the list to be copied:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单调用列表构造函数，传递要复制的列表：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Largely the choice between these techniques is a matter of taste. Our preference
    is for the third form using the list constructor, since it has the advantage of
    working with any iterable series as the source, not just lists.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些技术之间的选择在很大程度上是品味的问题。我们更偏好使用列表构造函数的第三种形式，因为它具有使用任何可迭代系列作为源的优势，而不仅仅是列表。
- en: Shallow copies
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浅复制
- en: 'You must be aware, however, that all of these techniques perform a *shallow*
    copy. That is, they create a new list containing references to the same objects
    as the source list, but they don’t copy the referred-to objects. To demonstrate
    this, we’ll use nested lists, with the inner lists serving as mutable objects.
    Here’s a list containing two elements, each of which is itself a list:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您必须意识到，所有这些技术都执行*浅*复制。也就是说，它们创建一个新的列表，其中包含对源列表中相同对象的引用，但它们不复制被引用的对象。为了证明这一点，我们将使用嵌套列表，其中内部列表充当可变对象。这是一个包含两个元素的列表，每个元素本身都是一个列表：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We copy this list using a full slice:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完整切片复制这个列表：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'and convince ourselves that we do in fact have distinct lists:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 并且让我们确信我们实际上有不同的列表：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'with equivalent values:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 具有等效值：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Notice, however, that the references within these distinct lists refer not
    only to *equivalent* objects:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这些不同列表中的引用不仅指向*等效*对象：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'but, in fact, to the *same* object:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上是指向*相同*的对象：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![Copies are shallow. When a list is copied the references to the containing
    objects (yellow diamonds) are copied, but the referred to objects (blue rectangles)
    are not.](images/m05----copies-are-shallow.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![复制是浅层的。当复制列表时，对包含对象的引用（黄色菱形）进行复制，但被引用的对象（蓝色矩形）不会被复制。](images/m05----copies-are-shallow.png)'
- en: Copies are shallow. When a list is copied the references to the containing objects
    (yellow diamonds) are copied, but the referred to objects (blue rectangles) are
    not.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是浅层的。当复制列表时，对包含对象的引用（黄色菱形）进行复制，但被引用的对象（蓝色矩形）不会被复制。
- en: 'This situation holds until we rebind the first element of `a` to a newly constructed
    list:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况持续到我们将`a`的第一个元素重新绑定到一个新构造的列表为止：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now the first elements of `a` and `b` refer to different lists:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`a`和`b`的第一个元素指向不同的列表：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![The first elements of lists `a` and `b` are now uniquely owned, whereas the
    second elements are shared.](images/m05----unique-and-shared-elements.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![列表`a`和`b`的第一个元素现在是唯一拥有的，而第二个元素是共享的。](images/m05----unique-and-shared-elements.png)'
- en: The first elements of lists `a` and `b` are now uniquely owned, whereas the
    second elements are shared.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`a`和`b`的第一个元素现在是唯一拥有的，而第二个元素是共享的。
- en: 'The second elements of both `a` and `b` still refer to the same object. We’ll
    demonstrate this by mutating that object through the `a` list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`的第二个元素仍然指向相同的对象。我们将通过`a`列表对该对象进行变异来证明这一点：'
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We see the change reflected through the `b` list:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到改变通过`b`列表反映出来：
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![Modifying an object referred to by two lists.](images/m05----mutating-shared-elements.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![修改两个列表所引用的对象。](images/m05----mutating-shared-elements.png)'
- en: Modifying an object referred to by two lists.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 修改两个列表所引用的对象。
- en: 'For completeness, here is the final state of both the `a` and `b` lists:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这是`a`和`b`列表的最终状态：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![The final state of list `a`.](images/m05----final-state-a.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![列表`a`的最终状态。](images/m05----final-state-a.png)'
- en: The final state of list `a`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`a`的最终状态。
- en: '![The final state of list `b`.](images/m05----final-state-b.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![列表`b`的最终状态。](images/m05----final-state-b.png)'
- en: The final state of list `b`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`b`的最终状态。
- en: If you need to perform true deep copies of hierarchical data structures like
    this – which in our experience is a rarity – we recommend taking a look at the
    `copy` module in the Python Standard Library.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对这样的层次数据结构执行真正的深层复制-根据我们的经验，这种情况很少见-我们建议查看Python标准库中的`copy`模块。
- en: Repeating lists
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重复列表
- en: 'As for strings and tuples, lists support repetition using the multiplication
    operator. It’s simple enough to use:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串和元组一样，列表支持使用乘法运算符进行重复。很容易使用：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'although it’s rarely spotted in the wild in this form. It’s most often useful
    for initializing a list of size known in advance to a constant value, such as
    zero:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这种形式中很少见。它最常用于将已知大小的列表初始化为常量值，例如零：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Be aware, though, that in the case of mutable elements the same trap for the
    unwary lurks here, since repetition will repeat *the reference* to each element,
    without copying the value. Let’s demonstrate using nested lists as our mutable
    elements again:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，在可变元素的情况下，这里也存在同样的陷阱，因为重复将重复*对每个元素的引用*，而不是复制值。让我们再次使用嵌套列表作为我们的可变元素来演示：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![Repetition is shallow.](images/m05----repetition-is-shallow.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![重复是浅层的。](images/m05----repetition-is-shallow.png)'
- en: Repetition is shallow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重复是浅层的。
- en: 'If we now modify the third element of the outer list:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在修改外部列表的第三个元素：
- en: '[PRE75]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'we see the change through all five references which comprise the outer list
    elements:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过外部列表元素的所有五个引用看到了变化：
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Mutating the repeated contents of a list. Any change to the object is reflected
    in every index of the outer list.](images/m05----repetition-mutation.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![改变列表中重复内容的变异。对对象的任何更改都会反映在外部列表的每个索引中。](images/m05----repetition-mutation.png)'
- en: Mutating the repeated contents of a list. Any change to the object is reflected
    in every index of the outer list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 改变列表中重复内容的变异。对对象的任何更改都会反映在外部列表的每个索引中。
- en: Finding list elements with `index()`
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`index()`查找列表元素
- en: 'To find an element in a list, use the `index()` method passing the object you’re
    searching for. The elements are compared for equivalence until the one you’re
    looking for is found:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列表中找到一个元素，使用`index()`方法并传递你要搜索的对象。元素将被比较直到找到你要找的那个：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you search for a value that isn’t present, you receive a `ValueError`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索一个不存在的值，你会收到一个`ValueError`：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We’ll learn how to handle such errors gracefully in chapter six.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第六章学习如何优雅地处理这些错误。
- en: Membership testing with `count()` and `in`
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`count()`和`in`进行成员测试。
- en: 'Another means of searching is to `count()` matching elements:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种搜索的方法是使用`count()`来计算匹配的元素：
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you just want to test for membership, you can use the `in` operator:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想测试成员资格，可以使用`in`运算符：
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'or non-membership with `not in`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`not in`进行非成员测试：
- en: '[PRE81]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Removing list elements by index with `del`
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`del`按索引删除列表元素
- en: 'Elements are removed using a keyword with which we have not yet become acquainted:
    `del`. The `del` keyword takes a single parameter which is a reference to a list
    element and removes it from the list, shortening the list in the process:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个我们尚未熟悉的关键字来删除元素：`del`。`del`关键字接受一个参数，即对列表元素的引用，并将其从列表中删除，从而缩短列表：
- en: '[PRE82]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Removing list elements by value with `remove()`
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`remove()`按值删除列表元素
- en: 'It’s also possible to remove elements by value, rather than by position, using
    the `remove()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`remove()`方法按值而不是按位置删除元素：
- en: '[PRE83]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is equivalent to the more verbose:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于更冗长的形式：
- en: '[PRE84]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Attempting to `remove()` an item which is not present will also cause a `ValueError`
    to be raised:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试`remove()`一个不存在的项目也会引发`ValueError`：
- en: '[PRE85]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Inserting into a list
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入到列表
- en: 'Items can be inserted into lists using the `insert()` method, which accepts
    the index of the new item and the new item itself:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`insert()`方法将项目插入列表，该方法接受新项目的索引和新项目本身：
- en: '[PRE86]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Concatenating lists
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接列表
- en: 'Concatenating lists using the addition operator results in a new list without
    modification of either of the operands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加法运算符连接列表会产生一个新的列表，而不会修改任何操作数：
- en: '[PRE87]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Whereas the augmented assignment operator `+=` modifies the assignee in place:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值运算符`+=`会就地修改被赋值的对象：
- en: '[PRE88]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'A similar effect can also be achieved using the `extend()` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`extend()`方法来实现类似的效果：
- en: '[PRE89]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Augmented assignment and the `extend()` method will work with any iterable series
    on the right-hand-side.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值和`extend()`方法将与右侧的任何可迭代系列一起工作。
- en: Rearranging `list` elements
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新排列`list`元素
- en: 'Before we move on from lists, let’s look at two operations which rearrange
    the elements in place: reversing and sorting.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开列表之前，让我们看看两个可以就地重新排列元素的操作：反转和排序。
- en: 'A list can be reversed in place by calling it’s `reverse()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`reverse()`方法来就地反转列表：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'A list can be sorted in place, using the `sort()` method:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sort()`方法就地对列表进行排序：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `sort()` method accepts two optional arguments, `key` and `reverse`. The
    latter is self explanatory and when set to `True` gives a descending sort:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`方法接受两个可选参数，`key`和`reverse`。后者不言自明，当设置为`True`时，会进行降序排序：'
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `key` parameter is more interesting. It accepts any *callable* object which
    is then used to extract a *key* from each item. The items will then be sorted
    according to the relative ordering of these keys. There are several types of callable
    objects in Python, although the only one we have encountered so far is the humble
    function. For example, the `len()` function is a callable object which is used
    to determine the length of a collection, such as a string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`参数更有趣。它接受任何*可调用*对象，然后用于从每个项目中提取*键*。然后根据这些键的相对顺序对项目进行排序。在Python中有几种类型的可调用对象，尽管到目前为止我们遇到的唯一一种是谦卑的函数。例如，`len()`函数是一个可调用对象，用于确定集合的长度，例如字符串。'
- en: 'Consider the following list of words:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下单词列表：
- en: '[PRE93]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Out-of-place rearrangement
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不在原地重新排列
- en: 'Sometimes an *in situ* sort or reversal is not what is required. For example,
    it may cause a function argument to be modified, giving the function confusing
    side effects. For out-of-place equivalents of the `reverse()` and `sort()` list
    methods you can use the `reversed()` and `sorted()` build-in functions which return
    a reverse iterator and a new sorted list respectively. For example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，*in situ*排序或反转并不是所需的。例如，它可能会导致函数参数被修改，给函数带来混乱的副作用。对于`reverse()`和`sort()`列表方法的out-of-place等价物，可以使用`reversed()`和`sorted()`内置函数，它们分别返回一个反向迭代器和一个新的排序列表。例如：
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'and:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE95]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Notice how we used a list constructor to evaluate the result of `reversed()`.
    This is because `reversed()` returns an iterator, a topic which we’ll cover in
    much more detail later.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用列表构造函数来评估`reversed()`的结果。这是因为`reversed()`返回一个迭代器，这是我们以后会更详细地讨论的一个主题。
- en: These functions have the advantage that they’ll work on any finite iterable
    source object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的优点是它们可以用于任何有限的可迭代源对象。
- en: Dictionaries
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'We’ll now return to dictionaries, which lie at the heart of many Python programs,
    including the Python interpreter itself. We briefly looked at literal dictionaries
    previously, seeing how they are delimited with curly braces and contain comma-separated
    key value pairs, with each pair tied together by a colon:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回到字典，它是许多Python程序的核心，包括Python解释器本身。我们之前简要地看过字面上的字典，看到它们用花括号界定，并包含逗号分隔的键值对，每对由冒号绑定在一起：
- en: '[PRE96]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '![A dictionary of URLs. The order of dictionary keys is not preserved.](images/m05----dictionary.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![一个URL字典。字典键的顺序不被保留。](images/m05----dictionary.png)'
- en: A dictionary of URLs. The order of dictionary keys is not preserved.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL字典。字典键的顺序不被保留。
- en: 'The values are accessible via the keys:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以通过键访问：
- en: '[PRE97]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Since each key is associated with exactly one value, and lookup is through keys,
    the keys must be unique within any single dictionary. It’s fine, however, to have
    duplicate values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个键只与一个值相关联，并且查找是通过键进行的，因此在任何单个字典中，键必须是唯一的。但是，拥有重复的值是可以的。
- en: Internally, the dictionary maintains pairs of references to the key objects
    and the value objects. The key objects *must* be immutable, so strings, numbers
    and tuples are fine, but lists are not. The value objects can be mutable, and
    in practice often are. Our example URL map uses strings for both keys and values,
    which is fine.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，字典维护了对键对象和值对象的引用对。键对象*必须*是不可变的，所以字符串、数字和元组都可以，但列表不行。值对象可以是可变的，在实践中通常是可变的。我们的示例URL映射使用字符串作为键和值，这是可以的。
- en: 'As with the other collections, there’s also a named constructor `dict()` which
    can convert other types to dictionaries. We can use the constructor to copy from
    an iterable series of key-value pairs stored in tuples, like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他集合一样，还有一个名为`dict()`的命名构造函数，它可以将其他类型转换为字典。我们可以使用构造函数从存储在元组中的可迭代的键值对系列中复制，就像这样：
- en: '[PRE98]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Recall that the items in a dictionary are not stored in any particular order,
    so the order of the pairs within the list is not preserved.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字典中的项目不以任何特定顺序存储，因此列表中的项目顺序不被保留。
- en: 'So long as the keys are legitimate Python identifiers it’s even possible to
    create a dictionary directly from keyword arguments passed to `dict()`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 只要键是合法的Python标识符，甚至可以直接从传递给`dict()`的关键字参数创建字典：
- en: '[PRE99]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Again, the order of the keyword arguments is not preserved.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，关键字参数的顺序不被保留。
- en: Copying dictionaries
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制字典
- en: 'As with lists dictionary copying is shallow by default, copying only the references
    to the key and value objects, not the objects themselves. There are two means
    of copying a dictionary, of which we most commonly see the second. The first technique
    is to use the `copy()` method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，默认情况下字典复制是浅复制，只复制对键和值对象的引用，而不是对象本身。有两种复制字典的方法，我们最常见的是第二种。第一种技术是使用`copy()`方法：
- en: '[PRE100]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The second is to pass an existing dictionary to the `dict()` constructor:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是将现有的字典传递给`dict()`构造函数：
- en: '[PRE101]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Updating dictionaries
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新字典
- en: 'If you need to extend a dictionary with definitions from another dictionary
    you can use the `update()` method. This is called on the dictionary to be updated
    and is passed the contents of the dictionary which is to be merged in:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用另一个字典的定义来扩展字典，可以使用`update()`方法。这个方法被调用在要更新的字典上，并传递要合并的字典的内容：
- en: '[PRE102]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If the argument to `update()` includes keys which are already present in the
    target dictionary, the values associated with these keys are replaced in the target
    by the corresponding values from the source:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`update()`的参数包括已经存在于目标字典中的键，则这些键关联的值将被源字典中对应的值替换掉：
- en: '[PRE103]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Iterating over dictionary keys
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历字典键
- en: 'As we have seen in an earlier chapter, dictionaries are iterable and so can
    be used with for-loops. The dictionary yields only the *key* on each iteration,
    and it’s up to us to retrieve the corresponding value by lookup using the square-brackets
    operator:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，字典是可迭代的，因此可以与for循环一起使用。字典在每次迭代中只产生一个*键*，我们需要使用方括号运算符进行查找来检索相应的值：
- en: '[PRE104]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Notice that the keys are returned in an arbitrary order which is neither the
    order in which they were specified nor any other meaningful sort order.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，键以任意顺序返回，既不是它们被指定的顺序，也不是任何其他有意义的排序顺序。
- en: Iterating over dictionary values
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历字典值
- en: 'If we want to iterate over only the values, we can use the `values()` dictionary
    method. This returns an object which provides an iterable *view* onto the dictionary
    values without causing the values to be copied:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想遍历值，可以使用`values()`字典方法。这将返回一个对象，它提供了一个可迭代的*视图*，而不会导致值被复制：
- en: '[PRE105]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: There is no efficient or convenient way to retrieve the corresponding *key*
    from a value, so we only print the values
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 没有有效或方便的方法来从值中检索相应的*键*，所以我们只打印值
- en: 'In the interests of symmetry, there is also a `keys()` method, although since
    the iterating over the dictionary object directly yields the keys, this is less
    commonly used:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对称起见，还有一个`keys()`方法，尽管由于直接对字典对象进行迭代会产生键，因此这种方法不太常用：
- en: '[PRE106]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Iterating over key-value pairs
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历键值对
- en: 'Often though, we want to iterate over the keys and values in tandem. Each key-value
    pair in a dictionary is called an *item* and we can get hold of an iterable view
    of items using the `items()` dictionary method. When iterated the `items()` view
    yields each key-value pair as a tuple. By using tuple unpacking in the for-statement
    we can get both key and value in one operation without the extra lookup:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们想要同时遍历键和值。字典中的每个键值对称为*项*，我们可以使用`items()`字典方法获得项的可迭代视图。当迭代`items()`视图时，会将每个键值对作为一个元组产生。通过在for语句中使用元组解包，我们可以在一次操作中获取键和值，而无需额外查找：
- en: '[PRE107]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Membership testing for dictionary keys
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于字典键的成员测试
- en: 'The membership tests for dictionaries using the `in` and `not in` operators
    work on the keys:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`和`not in`运算符对字典的成员测试适用于键：
- en: '[PRE108]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Removing dictionary items
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除字典条目
- en: 'As for lists, to remove an entry from a dictionary, we use the `del` keyword:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 至于列表，要从字典中删除条目，我们使用`del`关键字：
- en: '[PRE109]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Mutability of dictionaries
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典的可变性
- en: 'The keys in a dictionary should be immutable, although the values can be modified.
    Here’s a dictionary which maps the element symbol to a list of mass numbers for
    different isotopes of that element:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键应该是不可变的，尽管值可以被修改。这是一个将元素符号映射到该元素不同同位素的质量数列表的字典：
- en: '[PRE110]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See how we split the dictionary literal over multiple lines. That’s allowed
    because the curly braces for the dictionary literal are open.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何将字典文字分成多行。这是允许的，因为字典文字的花括号是开放的。
- en: 'Our string keys are immutable, which is a good thing for correct functioning
    of the dictionary. But there’s no problem with modifying the dictionary values
    in the event that we discover some new isotopes:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字符串键是不可变的，这对于字典的正确功能是件好事。但是，如果我们发现一些新的同位素，修改字典的值也没有问题：
- en: '[PRE111]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here, the augmented assignment operator is applied to the *list* object accessed
    through the ‘H’ (for hydrogen) key; the dictionary is not being modified.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，增强赋值运算符应用于通过‘H’（表示氢）键访问的*列表*对象；字典没有被修改。
- en: 'Of course, the dictionary itself is mutable; we know we can add new items:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，字典本身是可变的；我们知道可以添加新的条目：
- en: '[PRE112]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Pretty printing
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 漂亮的打印
- en: 'With compound data structures such as our table of isotypes, it can be helpful
    to have them printed out in a much more readable form. We can do this with the
    Python Standard Library pretty-printing module called `pprint`, which contains
    a function called `pprint`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复合数据结构，比如我们的同位素表，将它们以更可读的形式打印出来会很有帮助。我们可以使用Python标准库中的漂亮打印模块`pprint`来做到这一点，其中包含一个名为`pprint`的函数：
- en: '[PRE113]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Note that if we didn’t bind the `pprint` function to a different name `pp`,
    the function reference would overwrite the module reference, preventing further
    access to contents of the module^([14](chap21.xhtml#fn-overwrite)):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们没有将`pprint`函数绑定到另一个名称`pp`，函数引用将覆盖模块引用，阻止进一步访问模块的内容^([14](chap21.xhtml#fn-overwrite))：
- en: '[PRE114]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: gives us a much more comprehensible display.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们提供了一个更易理解的显示。
- en: Let’s move on from dictionaries and look at a new built-in data structure, the
    `set`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们离开字典，看看一个新的内置数据结构，`set`。
- en: '`set` – an unordered collection of unique elements'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`set` - 一个无序的唯一元素的集合'
- en: The `set` data type is an unordered collection of unique elements. The collection
    is mutable insofar as elements can be added and removed from the set, but each
    element must itself be immutable, very much like the keys of a dictionary.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`数据类型是一个无序的唯一元素的集合。集合是可变的，因为可以向集合添加和移除元素，但每个元素本身必须是不可变的，就像字典的键一样。'
- en: '![Sets are unordered groups of distinct elements.](images/m05----set.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![集合是无序的不同元素的组合。](images/m05----set.png)'
- en: Sets are unordered groups of distinct elements.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的不同元素的组合。
- en: 'Sets have a literal form very similar to dictionaries, again delimited by curly
    braces, but each item is a single object, rather than a pair joined by a colon:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的文字形式与字典非常相似，同样由花括号括起来，但每个项目都是单个对象，而不是由冒号连接的一对对象：
- en: '[PRE115]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Note that like a dictionary, the `set` is unordered:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与字典一样，`set`是无序的。
- en: '[PRE116]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Of course, sets have type `set`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，集合的类型是`set`：
- en: '[PRE117]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The set constructor
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合构造函数
- en: 'Recall that somewhat confusingly, empty curly braces create an empty *dictionary*,
    rather than an empty set:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有点令人困惑的是，空花括号创建的是一个空的*字典*，而不是一个空的集合：
- en: '[PRE118]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To create an empty set we must resort to the `set()` constructor:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空集合，我们必须使用`set()`构造函数：
- en: '[PRE119]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This is also the form Python echoes back to us for empty sets.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Python对我们空集合的回显形式。
- en: 'The `set()` constructor can create a set from any iterable series, such as
    a list:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`构造函数可以从任何可迭代序列（如列表）创建集合：'
- en: '[PRE120]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Duplicates in the input series are discarded. In fact, a common use of sets
    is to efficiently remove duplicate items from series of objects:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输入序列中的重复项将被丢弃。事实上，集合的常见用途是从对象序列中高效地移除重复项：
- en: '[PRE121]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Iterating over sets
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'Naturally, sets are iterable, although the order is arbitrary:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，集合是可迭代的，尽管顺序是任意的：
- en: '[PRE122]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Membership testing of sets
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合的成员测试
- en: 'Membership is a fundamental operation for sets, and as with the other collection
    types is performed using the `in` and `not in` operators:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 成员测试是集合的基本操作，与其他集合类型一样，使用`in`和`not in`运算符执行：
- en: '[PRE123]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Adding elements to sets
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向集合添加元素
- en: 'To add a single element to a set use the `add()` method:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要向集合添加单个元素，请使用`add()`方法：
- en: '[PRE124]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Adding an element that already exists has no effect:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 添加已经存在的元素不会产生任何效果：
- en: '[PRE125]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: although neither does it produce an error.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管也不会产生错误。
- en: 'Multiple elements can be added in one go from any iterable series, including
    another set, using the `update()` method:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可以一次性从任何可迭代序列中添加多个元素，包括另一个集合，使用`update()`方法：
- en: '[PRE126]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Removing elements from sets
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从集合中移除元素
- en: 'Two methods are provided for removing elements from sets. The first, `remove()`,
    requires that the element to be removed is present in the set, otherwise a `KeyError`
    is given:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两种方法来从集合中删除元素。第一种`remove()`要求要删除的元素必须存在于集合中，否则会给出`KeyError`：
- en: '[PRE127]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The second method, `discard()`, is less fussy and has no effect if the element
    is not a member of the set:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法`discard()`不那么挑剔，如果元素不是集合的成员，则没有影响：
- en: '[PRE128]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Copying sets
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制集合
- en: 'As with the other built-in collections, `set` sports a `copy()` method which
    performs a shallow copy of the set (copying references but not objects):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他内置集合一样，`set`具有`copy()`方法，执行集合的浅复制（复制引用而不是对象）：
- en: '[PRE129]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'As we have already shown, the `set()` constructor may be used:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经展示的，可以使用`set()`构造函数：
- en: '[PRE130]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Set algebra operations
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合代数操作
- en: Perhaps the most useful aspect of the set type is the group of powerful set
    algebra operations which are provided. These allow us to easily compute set unions,
    set differences, and set intersections, and to evaluate whether two sets have
    subset, superset, or disjoint relations.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 也许集合类型最有用的方面是提供的一组强大的集合代数操作。这些操作使我们能够轻松计算集合的并集、差集和交集，并评估两个集合是否具有子集、超集或不相交的关系。
- en: 'To demonstrate these methods, we’ll construct some sets of people according
    to various phenotypes:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些方法，我们将根据不同的表型构建一些人的集合：
- en: '[PRE131]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '![Set algebra operations.](images/m05----set-algebra.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![集合代数操作。](images/m05----set-algebra.png)'
- en: Set algebra operations.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 集合代数操作。
- en: Union
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 联合
- en: 'To find all the people with blond hair, blue eyes or both, we can use the `union()`
    method:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有金发、蓝眼睛或两者都有的人，我们可以使用`union()`方法：
- en: '[PRE132]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Set union collects together all of the elements which are in either or both
    sets.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 集合并集将所有在两个集合中的元素收集在一起。
- en: 'We can demonstrate that `union()` is a commutative operation (that is, we can
    swap the order of the operands) using the value equality operator to check for
    equivalence of the resulting sets:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以演示`union()`是可交换操作（即，我们可以交换操作数的顺序），使用值相等运算符来检查结果集的等价性：
- en: '[PRE133]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Intersection
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 交集
- en: 'To find all the people with blond hair *and* blue eyes, we can use the `intersection()`
    method:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到所有金发*和*蓝眼睛的人，我们可以使用`intersection()`方法：
- en: '[PRE134]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: which collects together only the elements which are present in both sets.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 它只收集两个集合中都存在的元素。
- en: 'This is also commutative:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是可交换的：
- en: '[PRE135]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Difference
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 差异
- en: 'To identify the people with blond hair who *don’t* have blue eyes, we can use
    the `difference()` method:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别金发但*没有*蓝眼睛的人，我们可以使用`difference()`方法：
- en: '[PRE136]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This finds all the elements which are in the first set which are not in the
    second set.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这找到了第一个集合中存在但不在第二个集合中的所有元素。
- en: 'This is non-commutative because the people with blond hair who don’t have blue
    eyes are not the same as the people who have blue eyes but don’t have blond hair:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非交换的，因为金发但没有蓝眼睛的人与有蓝眼睛但没有金发的人不同：
- en: '[PRE137]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Symmetric difference
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对称差
- en: 'However, if we want to determine which people have exclusively blond hair *or*
    blue eyes, but not both, we can use the `symmetric_difference()` method:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想确定哪些人只有金发*或*蓝眼睛，但不是两者都有，我们可以使用`symmetric_difference()`方法：
- en: '[PRE138]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This collects all the elements which are in the first set *or* the second set,
    but not both.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这收集了第一个集合*或*第二个集合中存在的所有元素，但不是两者都有。
- en: 'As you can tell from the name, `symmetric_difference()` is indeed commutative:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称上可以看出，`symmetric_difference()`确实是可交换的：
- en: '[PRE139]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Subset relationships
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 子集关系
- en: '![Set relationships.](images/m05----set-relationships.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![设置关系。](images/m05----set-relationships.png)'
- en: Set relationships.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 设置关系。
- en: 'In addition, three predicate methods are provided which tell us about the relationships
    between sets. We can check whether one set is a subset of another using the `issubset()`
    method. For example, to check whether all of the people who can smell hydrogen
    cyanide also have blond hair:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还提供了三种谓词方法，告诉我们集合之间的关系。我们可以使用`issubset()`方法检查一个集合是否是另一个集合的子集。例如，要检查所有能闻到氰化氢的人是否也有金发：
- en: '[PRE140]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This checks that all the elements of the first set are also present in the second
    set.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查第一个集合中的所有元素是否也存在于第二个集合中。
- en: 'To test whether all the people who can taste phenylthiocarbamide (PTC) can
    also smell hydrogen cyanide use the `issuperset()` method:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试所有能品尝苯硫脲（PTC）的人是否也能闻到氰化氢，使用`issuperset()`方法：
- en: '[PRE141]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This checks that all the elements of the second set are present in the first
    set.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查第二个集合中的所有元素是否都存在于第一个集合中。
- en: '![A representation of phenylthiocarbamide (PTC). It has the unusual property
    that it either tastes very bitter or is virtually tasteless, depending on the
    genetics of the taster.](images/m05----ptc.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![苯硫脲（PTC）的表示。它具有不寻常的特性，即根据品尝者的遗传学，它可能非常苦或几乎没有味道。](images/m05----ptc.png)'
- en: A representation of phenylthiocarbamide (PTC). It has the unusual property that
    it either tastes very bitter or is virtually tasteless, depending on the genetics
    of the taster.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 苯硫脲（PTC）的表示。它具有不寻常的特性，即根据品尝者的遗传学，它可能非常苦或几乎没有味道。
- en: 'To test that two sets have no members in common, use the `isdisjoint()` method.
    For example, your blood type is either A or O, never both:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试两个集合是否没有共同成员，使用`isdisjoint()`方法。例如，你的血型要么是A型，要么是O型，永远不会同时有：
- en: '[PRE142]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Collection protocols
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合协议
- en: In Python, a protocol is a group of operations or methods that a type must support
    if it is to implement that protocol. Protocols needn’t be defined in the source
    code as separate interfaces or base classes as they would in a nominally typed
    language such as C# or Java. It’s sufficient to have an object provide functioning
    implementations of those operations.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，协议是类型必须支持的一组操作或方法。协议不需要在源代码中定义为单独的接口或基类，就像在C#或Java等名义类型的语言中那样。只要对象提供这些操作的功能实现即可。
- en: 'We can organize the different collections we have encountered in Python according
    to which protocols they support:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据它们支持的协议来组织我们在Python中遇到的不同集合：
- en: '| Protocol | Implementing collections |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 实现集合 |'
- en: '| --- | --- |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Container | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 容器 | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
- en: '| Sized | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
- en: '| Iterable | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 可迭代 | `str`, `list`, `dict`, `range`, `tuple`, `set`, `bytes` |'
- en: '| Sequence | `str`, `list`, `tuple`, `range`, `bytes` |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | `str`, `list`, `tuple`, `range`, `bytes` |'
- en: '| Mutable Sequence | `list` |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 可变序列 | `list` |'
- en: '| Mutable Set | `set` |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| 可变集 | `set` |'
- en: '| Mutable Mapping | `dict` |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 可变映射 | `dict` |'
- en: Support for a protocol demands specific behavior from a type.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对协议的支持要求类型具有特定的行为。
- en: Container protocol
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器协议
- en: 'The *container* protocol requires that membership testing using the `in` and
    `not in` operators be supported:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*协议要求支持使用`in`和`not in`运算符进行成员测试：'
- en: '[PRE143]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Sized protocol
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小协议
- en: The *sized* protocol requires that the number of elements in a collection can
    be determined by calling `len(sized_collection)`
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*大小*协议要求可以通过调用`len(sized_collection)`来确定集合中的元素数量。'
- en: Iterable protocol
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可迭代协议
- en: Iteration is such an important concept that we’re devoting a whole chapter to
    it later in this book. In short, though, *iterables* provide a means for yielding
    elements one-by-one as they are requested.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是一个如此重要的概念，我们在本书的后面专门为它开辟了一个章节。简而言之，*可迭代*提供了一种逐个产生元素的方法，只要它们被请求。
- en: 'One important property of *iterables* is that they can be used with for-loops:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*可迭代*的一个重要特性是它们可以与for循环一起使用：'
- en: '[PRE144]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Sequence protocol
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 序列协议
- en: 'The *sequence* protocol requires that items can be retrieved using square brackets
    with an integer index:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列*协议要求可以使用整数索引和方括号检索项目：'
- en: '[PRE145]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'that items can be searched for with `index()`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`index()`搜索项目：
- en: '[PRE146]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'that items can be counted with `count()`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`count()`对项目进行计数：
- en: '[PRE147]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'and that a reversed copy of the sequence can be produced with `reversed()`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以使用`reversed()`生成序列的反向副本：
- en: '[PRE148]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: In addition, the *sequence* protocol requires that the object support the *iterable*,
    *sized*, and *containers*.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*序列*协议要求对象支持*可迭代*、*大小*和*容器*。
- en: Other protocols
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他协议
- en: We won’t cover the *mutable sequence*, *mutable mapping*, and *mutable set*
    here. Since we have only covered one representative type of each protocol, the
    generality afforded by the protocol concept doesn’t gain us much at this juncture.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里涵盖*可变序列*、*可变映射*和*可变集*。由于我们只涵盖了每个协议的一个代表类型，协议概念所提供的一般性在这一时刻并没有给我们带来太多好处。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Tuples are immutable sequence types
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组是不可变的序列类型
- en: Literal syntax is optional parentheses around a comma-separated list.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字语法是可选的，可以在逗号分隔的列表周围加上括号。
- en: Notable syntax for single element tuples utilizing the trailing comma.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个元组的值使用尾随逗号的特殊语法。
- en: Tuple unpacking - useful for multiple return values and swapping
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组解包 - 用于多个返回值和交换
- en: Strings
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: String concatenation is most efficiently performed with the `join()` method
    rather than the addition or augmented assignment operators.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接最有效的方法是使用`join()`方法，而不是使用加法或增强赋值运算符。
- en: The `partition()` method is a useful and elegant string parsing tool.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition()`方法是一个有用且优雅的字符串解析工具。'
- en: The `format()` method provided a powerful means of replacing placeholders with
    stringified values.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format()`方法提供了一个强大的方法，用字符串化的值替换占位符。'
- en: Ranges
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: '`range` objects represent arithmetic progressions.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`对象表示算术级数。'
- en: The `enumerate()` built-in function is often a superior alternative to `range()`
    for generating loop counters
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`内置函数通常是生成循环计数器的一个更好的选择，而不是`range()`。'
- en: Lists
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Lists support indexing from the end of the list with negative indices
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表支持使用负索引从列表末尾进行索引
- en: Slice syntax allows us to copy all, or part, of a list.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片语法允许我们复制列表的全部或部分。
- en: The full slice is a common Python idiom for copying lists, although the `copy()`
    method and `list()` constructor are less obscure.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整切片是Python中常见的习语，尽管`copy()`方法和`list()`构造函数不那么晦涩。
- en: List (and other collection) copies in Python are shallow copies. References
    are copied, but the referenced objects are not.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的列表（和其他集合）副本是浅层副本。引用被复制，但被引用的对象没有被复制。
- en: Dictionaries map from keys to values
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典从键映射到值
- en: Iteration and membership testing with dictionaries is done with respect to the
    keys.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对字典进行迭代和成员测试是针对键进行的。
- en: The `keys()`, `values()` and `items()` methods provide views onto the different
    aspects of a dictionary, allowing convenient iteration.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`、`values()`和`items()`方法提供了对字典不同方面的视图，允许方便的迭代。'
- en: Sets store an unordered collection of unique elements.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合存储无序的唯一元素集合。
- en: Sets support powerful set-algebra operations and predicates.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合支持强大的集合代数操作和谓词。
- en: The built in collections are can be organized according to which protocols they
    support, such as *iterable*, *sequence* and *mapping*.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的集合可以根据它们支持的协议进行组织，比如*可迭代*、*序列*和*映射*。
- en: 'In passing we have also discovered that:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们还发现：
- en: Underscore is commonly used for dummy or superfluous variables
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线通常用于虚拟或多余的变量
- en: The `pprint` module supports pretty printing of compound data structures.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprint`模块支持复杂数据结构的漂亮打印。'
