- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: 'Built-In Data Structures Part 2: Dictionaries'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内置数据结构第 2 部分：字典
- en: 'Starting with Chapter [4](ch008_split_000.xhtml#x1-2240004), [Built-In Data
    Structures Part 1: Lists and Sets](ch008_split_000.xhtml#x1-2240004), we began
    looking at Python’s rich collection of built-in data structures. These data structures
    are sometimes called ”containers” or ”collections” because they contain a collection
    of individual items.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 [4](ch008_split_000.xhtml#x1-2240004) 章开始，[内置数据结构第 1 部分：列表和集合](ch008_split_000.xhtml#x1-2240004)，我们开始探讨
    Python 丰富的内置数据结构集合。这些数据结构有时被称为“容器”或“集合”，因为它们包含一系列单独的项目。
- en: In this chapter, we’ll cover the dictionary structure. A dictionary is a mapping
    from keys to values, sometimes called an associative array. It seems sensible
    to separate mappings from the two sequences – lists and sets.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍字典结构。字典是从键到值的映射，有时也称为关联数组。将映射与两个序列（列表和集合）分开似乎是有道理的。
- en: This chapter will also look at some more advanced topics related to how Python
    handles references to mutable collection objects. This has consequences in the
    way functions need to be defined.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将探讨一些与 Python 处理可变集合对象引用相关的更高级主题。这会影响函数的定义方式。
- en: 'In this chapter, we’ll look at the following recipes, all related to Python’s
    built-in data structures:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下菜谱，所有这些都与 Python 的内置数据结构相关：
- en: '[Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建字典 – 插入和更新](ch009.xhtml#x1-2900001)'
- en: '[Shrinking dictionaries – the pop() method and the del statement](ch009.xhtml#x1-2980002)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缩小字典 – pop() 方法和 del 语句](ch009.xhtml#x1-2980002)'
- en: '[Writing dictionary-related type hints](ch009.xhtml#x1-3040003)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写与字典相关的类型提示](ch009.xhtml#x1-3040003)'
- en: '[Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解变量、引用和赋值](ch009.xhtml#x1-3100004)'
- en: '[Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建对象的浅拷贝和深拷贝](ch009.xhtml#x1-3160005)'
- en: '[Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免为函数参数使用可变默认值](ch009.xhtml#x1-3210006)'
- en: We’ll start with how to create a dictionary.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从如何创建一个字典开始。
- en: 5.1 Creating dictionaries – inserting and updating
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 创建字典 – 插入和更新
- en: A dictionary is one kind of Python mapping. The built-in type dict provides
    a number of foundational features. There are some common variations on these features
    defined in the collections module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 的一种映射类型。内置类型 dict 提供了许多基础特性。在 collections 模块中定义了一些这些特性的常见变体。
- en: As we noted in the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe at the beginning of Chapter [4](ch008_split_000.xhtml#x1-2240004), we’ll
    use a dictionary when we have a key that we need to map the key to a given value.
    For example, we might want to map a single word to a long, complex definition
    of the word, or perhaps map some value to a count of the number of times that
    value has occurred in a dataset.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 [4](ch008_split_000.xhtml#x1-2240004) 章开头的 [选择数据结构](ch008_split_000.xhtml#x1-2250001)
    菜谱中提到的，当我们有一个需要将键映射到给定值的键时，我们将使用字典。例如，我们可能想要将一个单词映射到该单词的复杂定义，或者将某个值映射到该值在数据集中出现的次数。
- en: 5.1.1 Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.1 准备工作
- en: We’ll look at an algorithm for locating the various stages in transaction processing.
    This relies on assigning a unique ID to each request and including that ID with
    each log record written during the transaction. Because a multi-threaded server
    may be handling a number of requests concurrently, the stages for each request’s
    transaction will be interleaved unpredictably. Reorganizing the log by request
    ID helps isolate each transaction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一个用于定位事务处理各个阶段的算法。这依赖于为每个请求分配一个唯一的 ID，并在事务期间包含每个日志记录中该 ID。由于多线程服务器可能同时处理多个请求，每个请求的事务阶段将不可预测地交错。按请求
    ID 重新组织日志有助于隔离每个事务。
- en: 'Here’s a simulated sequence of log entries for three concurrent requests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个模拟的三个并发请求的日志条目序列：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The lines are long, and may be wrapped haphazardly to fit within the book’s
    margins. Each line has a timestamp. The severity level is INFO for each record
    shown in the example. The next string of 20 characters is a transaction ID. This
    is followed by log information for unique to a step in the transaction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 行很长，可能随意换行以适应书籍的边距。每一行都有一个时间戳。示例中显示的每个记录的严重级别都是 INFO。接下来的 20 个字符是一个事务 ID。之后是针对事务中特定步骤的日志信息。
- en: 'The following regular expression defines the log records:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式定义了日志记录：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pattern captures the four fields of each log entry. For more information
    on regular expression, see the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式捕获每个日志条目的四个字段。有关正则表达式的更多信息，请参阅第 [1](ch005_split_000.xhtml#x1-170001) 章的 [使用正则表达式进行字符串解析](ch005_split_000.xhtml#x1-350003)
    菜谱。
- en: 'Parsing these lines will produce a sequence of four-tuples. The resulting object
    looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解析这些行将产生一个四元组序列。结果对象看起来像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to know how often each unique path is requested. This means ignoring
    some log records and collecting data from the other records. A mapping from the
    path string to a count is an elegant way to gather this data. We’ll look at how
    to implement this in detail. Later, we’ll look at some alternative implementations
    in the collections module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道每个唯一路径被请求的频率。这意味着忽略一些日志记录并从其他记录中收集数据。从路径字符串到计数的映射是一种优雅地收集这些数据的方法。我们将详细讨论如何实现。稍后，我们将查看
    collections 模块中的一些替代实现。
- en: 5.1.2 How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.2 如何实现...
- en: 'We have a number of ways to build dictionary objects:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种构建字典对象的方法：
- en: 'Literal: We can create a display of a dictionary by using a sequence of key/value
    pairs surrounded by {} characters. We use a : between a key and the associated
    value. Literals look like this: {"num": 355, "den": 113}.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文字：我们可以通过使用由 {} 字符包围的键值对序列来创建字典的显示。我们在键和关联的值之间使用冒号。文字看起来像这样：{"num": 355, "den":
    113}。'
- en: 'Conversion function: A sequence of two-tuples can be turned into a dictionary
    like this: dict([(’num’, 355), (’den’, 113)]). Each two-tuple becomes a key-value
    pair. The keys must be immutable objects like strings, numbers, or tuples of immutable
    objects. We can also build dictionaries like this: dict(num=355, den=113). Each
    of the parameter names becomes a key. This limits the dictionary keys to strings
    that are also valid Python variable names.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换函数：一个由两个元组组成的序列可以转换成这样的字典：dict([(‘num’，355)，（‘den’，113）]). 每个元组变成一个键值对。键必须是不可变对象，如字符串、数字或不可变对象的元组。我们也可以这样构建字典：dict(num=355,
    den=113). 每个参数名称都变成一个键。这限制了字典键为字符串，这些字符串也是有效的 Python 变量名。
- en: 'Insertion: We can use the dictionary [key] = value syntax to set or replace
    a value in a dictionary. We’ll look at this later in this recipe.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：我们可以使用字典 [key] = value 语法在字典中设置或替换一个值。我们将在本菜谱的后面讨论这个问题。
- en: 'Comprehensions: Similar to lists and sets, we can write a dictionary comprehension
    to build a dictionary from some source of data.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解：与列表和集合类似，我们可以编写一个字典理解来从某些数据源构建字典。
- en: Building a dictionary by setting items
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过设置项构建字典
- en: 'We build a dictionary by creating an empty dictionary and then setting items
    to it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个空字典然后向其中设置项来构建字典：
- en: 'Create an empty dictionary to map paths to counts. We can also use dict() to
    create an empty dictionary. Since we’re going to create a histogram that counts
    the number of times a path is used, we’ll call it histogram:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空字典以映射路径到计数。我们也可以使用 dict() 来创建一个空字典。由于我们将创建一个计数路径使用次数的直方图，我们将它命名为 histogram：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can also use the function dict() instead of the literal value {} to create
    an empty dictionary.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用函数 dict() 而不是字面量值 {} 来创建一个空字典。
- en: 'For each of the log lines, filter out the ones that do not have a value that
    starts with path in the item with an index of 3:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每条日志行，过滤掉那些在索引为 3 的项中没有以 path 开头的值的那些行：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the path is not in the dictionary, we need to add it. Once the value of
    the path_method string is in the dictionary, we can increment the value in the
    dictionary, based on the key from the data:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路径不在字典中，我们需要添加它。一旦 path_method 字符串的值在字典中，我们就可以根据数据中的键在字典中增加值。
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This technique adds each new path_method value to the dictionary. Once it has
    been established that the path_method key is in the dictionary, we can increment
    the value associated with the key.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将每个新的 path_method 值添加到字典中。一旦确定 path_method 键在字典中，我们就可以增加与该键关联的值。
- en: Building a dictionary as a comprehension
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过理解构建字典
- en: The last field of each log line had one or two fields inside. There may have
    been a value like path="/openapi.yaml" method=GET with two attributes, path and
    method, or a value like error="invalid query" with only one attribute, error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每条日志行的最后一个字段有一个或两个字段。可能有一个像 path="/openapi.yaml" method=GET 这样的值，包含两个属性 path
    和 method，或者一个像 error="invalid query" 这样的值，只有一个属性 error。
- en: 'We can use the following regular expression to decompose the final field of
    each line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下正则表达式来分解每行的最终字段：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The findall() method of this regular expression will provide a sequence of
    two-tuples based on the matching text. We can then build a dictionary from the
    sequence of matched groups:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式的findall()方法将基于匹配文本提供一个包含两个元组的序列。然后我们可以从匹配组的序列构建一个字典：
- en: 'For each of the log lines, apply the regular expression to create a sequence
    of pairs:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每条日志行，应用正则表达式以创建一对序列：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use a dictionary comprehension to use the first matching group as the key and
    the second matching group as the value:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字典推导式，将第一个匹配组作为键，第二个匹配组作为值：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can print the params values and we’ll see the dictionaries like the following
    examples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出参数值，我们会看到如下示例中的字典：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using a dictionary for the final fields of each log record makes it easier to
    separate the important pieces of information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典作为每个日志记录的最终字段，使得分离重要信息变得更容易。
- en: 5.1.3 How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.3 工作原理...
- en: The core feature of a dictionary is a mapping from an immutable key to a value
    object of any kind. In the first example, we’ve used an immutable string as the
    key, and an integer as the value. We describe it as dict[str, int] in the type
    hint.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的核心功能是从不可变键到任何类型值对象的映射。在第一个示例中，我们使用了不可变的字符串作为键，整数作为值。我们在类型提示中描述它为dict[str,
    int]。
- en: 'It’s important to understand how the += assignment statement works. The implementation
    of += is essentially this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理解+=赋值语句的工作方式很重要。+=的实现基本上是这样的：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The histogram[customer] value is fetched from the dictionary, a new value is
    computed, and the result is used to update the dictionary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典中获取的直方图[客户]值被计算出一个新值，并将结果用于更新字典。
- en: It’s essential that dictionary key objects be immutable. We cannot use a list,
    set, or dictionary as the key in a dictionary mapping. We can, however, transform
    a list into an immutable tuple, or make a set into a frozenset so that we can
    use one of these more complex objects as a key. In the examples shown in this
    recipe, we had immutable strings as the keys to each dictionary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保字典键对象是不可变的。我们不能使用列表、集合或字典作为字典映射的键。然而，我们可以将列表转换为不可变的元组，或者将集合转换为frozenset，这样我们就可以使用这些更复杂对象中的一个作为键。在本食谱中显示的示例中，我们使用了不可变的字符串作为每个字典的键。
- en: 5.1.4 There’s more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.4 更多...
- en: We don’t have to use an if statement to add missing keys. We can use the setdefault()
    method of a dictionary instead. It’s even easier to use one of the classes from
    the collections module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用if语句来添加缺失的键。我们可以使用字典的setdefault()方法。使用collections模块中的类甚至更容易。
- en: 'Here’s the version using the defaultdict class from the collections module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用collections模块中的defaultdict类的版本：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ve created a defaultdict instance that will initialize any unknown key values
    using the int() function. We provide int—the function object—to the defaultdict
    constructor. The defaultdict instance will evaluate the given function to create
    default values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个defaultdict实例，它将使用int()函数初始化任何未知的键值。我们将函数对象int提供给了defaultdict构造函数。defaultdict实例将评估给定的函数以创建默认值。
- en: This allows us to use histogram[path_method] += 1\. If the value associated
    with the path_method key was previously in the dictionary, the value will be incremented
    and put back into the dictionary. If the path_method key was not in the dictionary,
    the int() function is called with no argument; this default value will be incremented
    and put into the dictionary.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用histogram[path_method] += 1。如果与path_method键关联的值之前在字典中，该值将增加并放回字典中。如果path_method键不在字典中，则调用int()函数不带任何参数；这个默认值将被增加并放入字典中。
- en: 'The other way we can accumulate frequency counts is by creating a Counter object.
    We can build the Counter object from the raw data as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建Counter对象来累积频率计数。我们可以如下从原始数据构建Counter对象：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we used a generator expression to create an iterator over the filtered
    path data; this was assigned to filtered_paths. Then we created a Counter from
    the source of data; the Counter class will scan the data and count the distinct
    occurrences.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用生成表达式创建了一个过滤路径数据的迭代器；这被分配给了filtered_paths。然后我们从数据源创建了一个Counter；Counter类将扫描数据并计算不同出现的次数。
- en: 5.1.5 See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.5 参见
- en: In the [Shrinking dictionaries – the pop() method and the del statement](ch009.xhtml#x1-2980002)
    recipe, we’ll look at how dictionaries can be modified by removing items.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[收缩字典 – pop() 方法和 del 语句](ch009.xhtml#x1-2980002)的菜谱中，我们将探讨如何通过删除项来修改字典。
- en: 5.2 Shrinking dictionaries – the pop() method and the del statement
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 收缩字典 – pop() 方法和 del 语句
- en: 'A common use case for a dictionary is as an associative store: it keeps an
    association between key and value objects. This means that we may be doing any
    of the CRUD operations on an item in the dictionary:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的一个常见用途是作为关联存储：它保持键和值对象之间的关联。这意味着我们可能对字典中的项执行任何 CRUD 操作：
- en: Create a new key and value pair.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的键值对。
- en: Retrieve the value associated with a key.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取与键关联的值。
- en: Update the value associated with a key.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新与键关联的值。
- en: Delete the key (and the corresponding value) from the dictionary.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典中删除键（及其对应的值）。
- en: 5.2.1 Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.1 准备工作
- en: A great deal of processing supports the need to group items around one (or more)
    different common values. We’ll return to the log data shown in the [Creating dictionaries
    – inserting and updating](ch009.xhtml#x1-2900001) recipe in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的处理支持围绕一个（或多个）不同的共同值对项目进行分组的需求。我们将回到本章中[创建字典 – 插入和更新](ch009.xhtml#x1-2900001)菜谱中显示的日志数据。
- en: We’ll use an iterator algorithm that uses the transaction ID as a key in a dictionary.
    The value for this key will be the sequence of steps for the transaction. With
    a very long log, we don’t — generally — want to save every transaction in a gigantic
    dictionary. When we reach the termination of a transaction’s sequence, we can
    yield the list of log entries for the transaction. A function can consume this
    iterator, processing each batch of transactions independently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个迭代器算法，该算法使用交易 ID 作为字典中的键。这个键的值将是交易的步骤序列。在非常长的日志中，我们通常不想在巨大的字典中保存每一笔交易。当我们达到交易序列的终止时，我们可以产生交易日志条目的列表。一个函数可以消费这个迭代器，独立地处理每一批交易。
- en: 5.2.2 How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.2 如何做...
- en: 'The context for this recipe will require an if statement with the condition
    match := log_parser.match(line). This will apply the regular expression, and collect
    the result in the match variable. Given that context, the processing to update
    or delete from a dictionary is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的上下文将需要一个条件为 match := log_parser.match(line) 的 if 语句。这将应用正则表达式，并将结果收集在 match
    变量中。给定这个上下文，更新或从字典中删除的处理如下：
- en: 'This function uses the defaultdict class, and two additional type hints, Iterable
    and Iterator:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数使用 defaultdict 类和两个额外的类型提示，可迭代和迭代器：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a defaultdict object to hold transaction steps. The keys are 20-character
    strings. The values are lists of log records. In this case, each log record will
    have been parsed from the source text into a tuple of individual strings:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 defaultdict 对象来保存交易步骤。键是20个字符的字符串。值是日志记录的列表。在这种情况下，每个日志记录都将从源文本解析成单个字符串的元组：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define the key for each cluster of log entries:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义每个日志条目组的键：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Update a dictionary item with a log record:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用日志记录更新字典项：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If this log record completes a transaction, yield the group as part of a generator
    function. Then remove the transaction from the dictionary, since it’s complete:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个日志记录完成了一笔交易，作为生成器函数的一部分产生这个组。然后从字典中删除交易，因为它已经完成：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the end, there may be an non-empty requests dictionary. This reflects a transaction
    that was in process when the log file was switched.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可能会有一个非空的请求字典。这反映了在日志文件切换时正在进行的交易。
- en: 5.2.3 How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.3 它是如何工作的...
- en: Because a dictionary is a mutable object, we can remove keys from a dictionary.
    A del statement will delete both the key and the value object associated with
    the key. In this example, the key is removed when the data reveals the transaction
    is complete. A moderately busy web server handling an average of 10 transactions
    per second will see 864,000 transactions in a 24-hour period. If there are an
    average of 2.5 log entries per transaction, there will be at least 2,160,000 lines
    in the file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典是一个可变对象，所以我们可以从字典中删除键。del 语句将删除与键关联的键和值对象。在这个例子中，当数据表明交易完成时，键被删除。一个处理平均每秒10笔交易的繁忙的Web服务器在24小时内将看到864,000笔交易。如果每笔交易平均有2.5条日志条目，文件中至少将有2,160,000行。
- en: If we only want to know the elapsed time per resource, we don’t want to keep
    the entire dictionary of 864,000 transactions in memory. We’d rather transform
    the log into an intermediate summary file for further analysis.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想知道每个资源的耗时，我们不想在内存中保留包含864,000个事务的整个字典。我们更愿意将日志转换成一个中间摘要文件以供进一步分析。
- en: This idea of transient data leads us to accumulate the parsed log lines into
    a list instance. Each new line is appended to the appropriate list for the transaction
    in which the line belongs. When the final line has been found, the group of lines
    can be purged from the dictionary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种临时数据的概念使我们把解析的日志行累积到一个列表实例中。每行新内容都追加到属于该事务的适当列表中。当找到最后一行时，这些行可以从字典中清除。
- en: 5.2.4 There’s more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.4 更多内容...
- en: In the example, we used the del statement. The pop() method can also be used.
    The del statement will raise a KeyError exception if the given item cannot be
    found in the dictionary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用了del语句。pop()方法也可以使用。如果给定的项目在字典中找不到，del语句将引发KeyError异常。
- en: 'The pop() method would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: pop()方法看起来是这样的：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will mutate the dictionary in place, removing the item if it exists, or
    raising a KeyError exception.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将就地修改字典，如果存在则删除项目，或者引发KeyError异常。
- en: The pop() method, when provided with a default value, can return the given default
    value instead of raising an exception when a key is not found. In either case,
    the key will no longer be in the dictionary. Note that this method both mutates
    the collection and returns a value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当pop()方法提供一个默认值时，如果找不到键，它可以返回给定的默认值而不是引发异常。在任何情况下，键将不再存在于字典中。请注意，此方法既修改了集合又返回了一个值。
- en: The popitem() method will remove a key and value pair from the dictionary. The
    pairs are returned in Last-In-First-Out (LIFO) order. This means a dictionary
    is also a kind of stack.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: popitem()方法将从字典中删除一个键值对。这些对以最后进入，最先出来（LIFO）的顺序返回。这意味着字典也是一种栈。
- en: 5.2.5 See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.5 参见
- en: In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe, we look at how we create dictionaries and fill them with keys and values.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[创建字典 – 插入和更新](ch009.xhtml#x1-2900001)菜谱中，我们探讨了如何创建字典并将它们填充键和值。
- en: 5.3 Writing dictionary-related type hints
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 编写与字典相关的类型提示
- en: When we look at sets and lists, we generally expect each item within a list
    (or a set) to be the same type. When we look at object-oriented class designs,
    in Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll see how a common superclass
    can be the common type for a closely related family of object types. While it’s
    possible to have heterogeneous types in a list or set collection, it often becomes
    quite complex to process, requiring the match statement to do proper type matching.
    A dictionary, however, can be used to create a discriminated union of types. A
    particular key value may be used to define which other keys are present in the
    dictionary. This means a simple if statement can discriminate between heterogeneous
    types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看集合和列表时，我们通常期望列表（或集合）中的每个项目都是相同类型。当我们查看面向对象的类设计时，在第[7](ch011_split_000.xhtml#x1-3760007)章中，我们将看到如何一个公共超类可以成为紧密相关的对象类型家族的共同类型。虽然在一个列表或集合集合中可以有异构类型，但通常处理起来相当复杂，需要匹配语句来进行适当的类型匹配。然而，字典可以用来创建类型的区分联合。特定的键值可以用来定义字典中存在哪些其他键。这意味着一个简单的if语句可以区分异构类型。
- en: 5.3.1 Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.1 准备工作
- en: We’ll look at two kinds of dictionary type hints, one for homogeneous value
    types and the other for heterogeneous value types. We’ll look at data that starts
    out as one of these kinds of dictionaries but is transformed to have more complex
    type definitions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看两种类型的字典类型提示，一种用于同质值类型，另一种用于异构值类型。我们将查看最初是这些类型之一的数据字典，但后来被转换成更复杂的类型定义。
- en: 'We’ll be starting with the following CSV file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个以下CSV文件开始：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This describes three separate legs of a multi-day trip on a sailboat. The fuel
    is measured by the height in the tank, rather than some indirect method using
    a float or other gauges. Because the tank is approximately rectangular, 31 inches
    of depth is about 75 gallons of fuel.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了乘帆船进行的多日旅行中的三个独立阶段。燃料是通过油箱中的高度来测量的，而不是使用浮子或其他仪表的间接方法。因为油箱大约是矩形的，31英寸的深度大约是75加仑的燃料。
- en: 5.3.2 How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.2 如何做...
- en: 'The initial use of csv.DictReader will lead to dictionaries with homogeneous
    type definitions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: csv.DictReader的初始使用将导致具有同质类型定义的字典：
- en: Locate the type of the keys in the dictionary. When reading CSV files, the keys
    are strings, with the type str.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位字典中键的类型。当读取 CSV 文件时，键是字符串，类型为 str。
- en: Locate the type of the values in the dictionary. When reading CSV files, the
    values are strings, with the type str.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位字典中值的类型。当读取 CSV 文件时，值是字符串，类型为 str。
- en: Combine the types using the dict type hint. This yields dict[str, str].
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 dict 类型提示组合类型。这产生 dict[str, str]。
- en: 'Here’s an example function for reading data from a CSV file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从 CSV 文件读取数据的示例函数：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The get_fuel_use() function yields values that match the source data. In this
    case, it’s a dictionary that maps string column names to string cell values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: get_fuel_use() 函数产生与源数据匹配的值。在这种情况下，它是一个将字符串列名映射到字符串单元格值的字典。
- en: 'This data, by itself, is difficult to work with. A common second step is to
    apply transformations to the source rows to create more useful data types. We
    can describe the results with a type hint:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据本身难以处理。常见的第二步是对源行应用转换以创建更有用的数据类型。我们可以用类型提示来描述结果：
- en: 'Identify the various value types that will be needed. In this example, there
    are five fields with three different types, shown here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定所需的各种值类型。在这个例子中，有五个字段，三种不同类型，如下所示：
- en: The date field is a datetime.date object.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期字段是一个 datetime.date 对象。
- en: The engine on field is a datetime.time object.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎字段是一个 datetime.time 对象。
- en: The fuel height on field is an integer, but we know that it will be used in
    a float context, so we’ll create a float directly.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燃料高度字段是一个整数，但我们知道它将在浮点上下文中使用，因此我们将直接创建一个浮点数。
- en: The engine off field is a datetime.time object.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎关闭字段是一个 datetime.time 对象。
- en: The fuel height off field is also a float value.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 燃料高度字段也是一个浮点值。
- en: Import the TypedDict type definition from the typing module.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 typing 模块导入 TypedDict 类型定义。
- en: 'Define the subclass of TypedDict with the new heterogeneous dictionary types:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有新异构字典类型的 TypedDict 子类。
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is, in part, a teaser for Chapter [7](ch011_split_000.xhtml#x1-3760007).
    It shows a very simple kind of class definition. In this case, the class is dictionaries
    with five specific keys, all of which are required and must have values of the
    given types.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分是第 7 章的预告[7](ch011_split_000.xhtml#x1-3760007)。它展示了一种非常简单的类定义。在这种情况下，类是具有五个特定键的字典，所有这些键都是必需的，并且必须具有给定类型的值。
- en: In this example, we’ve also renamed the fields to make them into names that
    are valid Python names. Replacing punctuation with _ is the obvious first step.
    We also changed a few because the column names in the CSV file seemed awkward.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还重命名了字段，使它们成为有效的 Python 名称。用 _ 替换标点是明显的第一步。我们还更改了一些，因为 CSV 文件中的列名看起来很别扭。
- en: 'The function to perform the transformation can look like the following example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行转换的函数可能看起来像以下示例：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function consumes instances of the initial dict[str,str] dictionary and
    creates instances of the dictionary described by the History class. Here’s how
    these two functions work together:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数消耗初始 dict[str, str] 字典的实例，并创建由 History 类描述的字典的实例。以下是这两个函数如何一起工作的：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This shows how the output from the get_fuel_use() function can be processed
    by the make_history() function to create an iterable sequence of dictionaries.
    Each of the resulting dictionaries has the source data converted to a more useful
    type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何通过 make_history() 函数处理 get_fuel_use() 函数的输出，以创建一个字典的可迭代序列。每个结果字典都将源数据转换为更实用的类型。
- en: 5.3.3 How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.3 它是如何工作的...
- en: The core type hint for a dictionary names the key type and the value type, in
    the form dict[key, value]. The TypedDict class lets us be more specific about
    bindings between dictionary keys and a broad domain of values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的核心类型提示命名了键类型和值类型，形式为 dict[key, value]。TypedDict 类允许我们更具体地描述字典键与广泛值域之间的绑定。
- en: 'It’s important to note that type hints are only checked by programs like mypy.
    These hints have no runtime impact. We could, for example, write a statement like
    the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类型提示仅由 mypy 等程序检查。这些提示对运行时没有影响。例如，我们可以编写如下语句：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This statement claims that the result dictionary will match the type hints in
    the History type definition. The dictionary literal, however, has the wrong type
    for the ’date’ field and a number of other fields are missing. While this will
    execute, it will raise errors from mypy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句声称结果字典将匹配 History 类型定义中的类型提示。然而，字典字面量在 'date' 字段类型不正确，并且许多其他字段缺失。虽然这会执行，但会从
    mypy 引发错误。
- en: 'Running the mypy program reveals the error as shown in the following listing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行mypy程序会显示如下列表中的错误：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For run-time validation of data, a project like [Pydantic](https://docs.pydantic.dev/2.7/)
    can be very helpful.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行时数据验证，像Pydantic这样的项目可以非常有帮助。
- en: 5.3.4 There’s more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.4 更多...
- en: One of the common cases for heterogeneity in dictionary keys is optional items.
    The type hint Optional[str] or str | None describes this. This is rarely needed
    with a dictionary, since it can be simpler to omit the key-value pair entirely.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字典键异质性的常见情况之一是可选项。类型提示Optional[str]或str | None描述了这一点。在字典中很少需要这样做，因为它可以更简单地省略整个键值对。
- en: 'Let’s assume we need two variants of the History type:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要History类型的两个变体：
- en: The variant shown earlier in this recipe, where all fields are present.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此配方中较早展示的变体，其中所有字段都存在。
- en: Two ”incomplete” records, one without an engine off time and ending fuel height,
    and another variant without an engine on time or starting fuel height. These two
    records might be used for an overnight passage under power.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个“不完整”的记录，一个没有关机时间或结束燃油高度，另一个变体没有开机时间或起始燃油高度。这两个记录可能用于有动力过夜航行。
- en: 'In this case, we might need to use the NotRequired annotation for these fields.
    The resulting class definition would look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能需要使用NotRequired注解这些字段。生成的类定义将如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This record permits a great deal of variability in the dictionary values. It
    requires the use of if statements to determine the mix of fields present in the
    data. Furthermore, it also requires somewhat more clever processing in the make_history()
    function to create these variant records based on empty columns in the CSV file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此记录允许字典值有很大的可变性。它需要使用if语句来确定数据中存在的字段组合。此外，它还需要在make_history()函数中进行一些更复杂的处理，以根据CSV文件中的空列创建这些变体记录。
- en: There are some parallels between TypedDict and the NamedTuple type definitions.
    Changing TypedDict to NamedTuple will create a named tuple class instead of a
    typed dictionary class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TypedDict和NamedTuple类型定义之间存在一些相似之处。将TypedDict更改为NamedTuple将创建一个命名元组类而不是类型字典类。
- en: Because a NamedTuple class has an _asdict() method, it’s possible to produce
    a dictionary that matches the TypedDict structure from a named tuple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NamedTuple类有一个_asdict()方法，因此可以从命名元组生成与TypedDict结构匹配的字典。
- en: A dictionary that matches the TypedDict hint is mutable. A subclass of NamedTuple,
    however, is immutable. This is one central difference between these two type hints.
    More importantly, a dictionary uses row[’date’] syntax to refer to one item using
    the key ’date’. A named tuple uses row.date syntax to refer to one item using
    a name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与TypedDict提示匹配的字典是可变的。然而，NamedTuple的子类是不可变的。这是这两个类型提示之间的一个主要区别。更重要的是，字典使用row[‘date’]语法通过键‘date’来引用一个项目。命名元组使用row.date语法通过名称来引用一个项目。
- en: 5.3.5 See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.5 参见
- en: The [Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)
    recipe provides more details on the NamedTuple type hint.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用NamedTuples简化元组中的项目访问](ch005_split_001.xhtml#x1-7500010)的配方提供了关于NamedTuple类型提示的更多详细信息。'
- en: See the [Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004) for more about type hints
    for lists.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于列表的类型提示，请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[编写与列表相关的类型提示](ch008_split_001.xhtml#x1-2560005)配方。
- en: The [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009) recipe,
    also in Chapter [4](ch008_split_000.xhtml#x1-2240004), covers this from the view
    of set types.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第[4](ch008_split_000.xhtml#x1-2240004)章中的[编写与集合相关的类型提示](ch008_split_001.xhtml#x1-2800009)配方从集合类型的角度涵盖了这一点。
- en: For runtime validation of data, a project like Pydantic can be very helpful.
    See [https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于运行时数据验证，像Pydantic这样的项目可以非常有帮助。请参阅[https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/)。
- en: 5.4 Understanding variables, references, and assignment
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 理解变量、引用和赋值
- en: How do variables really work? What happens when we assign a mutable object to
    two variables? When two variables are sharing references to a common mutable object,
    the behaviors can be confusing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 变量实际上是如何工作的？当我们将可变对象分配给两个变量时会发生什么？当两个变量共享对公共可变对象的引用时，行为可能会令人困惑。
- en: 'This is the core principle: Python shares references; it doesn’t copy data.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是核心原则：Python共享引用；它不会复制数据。
- en: 'To see what this rule on reference sharing means, we’ll create two data structures:
    one is mutable and one is immutable.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个关于引用共享的规则意味着什么，我们将创建两个数据结构：一个是可变的，另一个是不可变的。
- en: 5.4.1 Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.1 准备工作
- en: 'We’ll look at the two kinds of sequences, although we could do something similar
    with two kinds of sets:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看两种类型的序列，尽管我们也可以用两种类型的集合做类似的事情：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ll look at what happens when references to these objects are shared.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看当这些对象的引用被共享时会发生什么。
- en: We can do a similar comparison with a set and a frozenset. We can’t easily do
    this with a mapping because Python doesn’t offer a handy immutable mapping.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式与集合和 frozenset 进行比较。我们无法轻松地这样做，因为 Python 没有提供方便的不可变映射。
- en: 5.4.2 How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.2 如何实现...
- en: 'This recipe will show how to observe the ”spooky action at a distance” when
    there are two references to an underlying mutable object. We’ll look at ways to
    prevent this in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe. Here are the steps for seeing the difference between mutable and immutable
    collections:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何观察当有两个引用到底层可变对象时的“超距作用”。我们将在[制作浅拷贝和深拷贝对象](ch009.xhtml#x1-3160005)配方中查看防止这种情况的方法。以下是查看可变和不可变集合之间差异的步骤：
- en: 'Assign each collection to an additional variable. This will create two references
    to the structure:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个集合分配给一个额外的变量。这将创建对该结构的两个引用：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have two references to the list [1, 1, 2, 3, 5, 8] and two references
    to the tuple (5, 8, 13, 21).
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有两个引用到列表 [1, 1, 2, 3, 5, 8] 和两个引用到元组 (5, 8, 13, 21)。
- en: 'We can confirm this using the is operator. This determines if two variables
    refer to the same underlying object:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 is 运算符来确认这一点。这确定两个变量是否引用了同一个底层对象：
- en: '[PRE31]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make a change to one of the two references to the collection. For the list
    type, we have methods like extend() or append(). For this example we’ll use the
    + operator:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对集合的两个引用之一进行更改。对于列表类型，我们有像 extend() 或 append() 这样的方法。在这个例子中，我们将使用 + 运算符：
- en: '[PRE32]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can do a similar thing with the immutable structure:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以用类似的方法对不可变结构进行操作：
- en: '[PRE33]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Look at the other two variables that reference the mutable structure. Because
    the two variables are references to the same underlying list object, each variable
    shows the current state:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看引用可变结构的另外两个变量。因为这两个变量是同一个底层列表对象的引用，每个变量都显示了当前状态：
- en: '[PRE34]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Look at the two variables referring to immutable structures. Initially, the
    two variables shared a common object. When the assignment statement was executed,
    a new tuple was created and only one variable changed to refer to the new tuple:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看引用不可变结构的两个变量。最初，两个变量共享一个公共对象。当执行赋值语句时，创建了一个新的元组，只有一个变量更改以引用新的元组：
- en: '[PRE35]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 5.4.3 How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.3 它是如何工作的...
- en: The two variables, mutable and mutable_b, still refer to the same underlying
    object. Because of that, we can use either variable to change the object and see
    the change reflected in the other variable’s value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量 mutable 和 mutable_b 仍然引用同一个底层对象。正因为如此，我们可以使用任何一个变量来更改对象，并看到更改反映在另一个变量的值上。
- en: The two variables, immutable_b and immutable, started out referring to the same
    object. Because the object cannot be mutated in place, a change to one variable
    means that a new object is assigned to that variable. The other variable remains
    firmly attached to the original object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量 immutable_b 和 immutable 最初引用的是同一个对象。因为该对象不能就地修改，对其中一个变量的更改意味着将新对象分配给该变量。另一个变量仍然牢固地附加到原始对象上。
- en: In Python, a variable is a label that’s attached to an object. We can think
    of them like adhesive notes in bright colors that we stick on an object temporarily.
    Multiple labels can be attached to an object. It’s the assignment statement that
    places a variable name on an object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，变量是一个附加到对象的标签。我们可以把它们想象成我们暂时贴在对象上的鲜艳颜色的粘性便签。可以对对象附加多个标签。是赋值语句将变量名放置在对象上。
- en: 'Consider the following statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下声明：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This has the same effect as this statement:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下语句具有相同的效果：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The expression on the right side of = creates a new tuple from the previous
    value of the immutable tuple. The assignment statement then assigns the label
    immutable to the newly-minted object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 等号右侧的表达式从不可变元组的上一个值创建一个新的元组。然后赋值语句将标签 immutable 分配给新铸造的对象。
- en: 'Assigning to a variable has two possible actions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给变量有两种可能的行为：
- en: For mutable objects that provide definitions for appropriate in-place assignment
    operators like +=, the assignment is transformed into a special method; in this
    case, __iadd__(). The special method will mutate the object’s internal state.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提供适当原地赋值操作符定义的可变对象，如`+=`，赋值会被转换为特殊方法；在这种情况下，`__iadd__()`。特殊方法将修改对象的内部状态。
- en: For immutable objects that do not provide definitions for assignment like +=,
    the assignment is transformed into = and +. A new object is built by the + operator
    and the variable name is attached to that new object. Other variables that previously
    referred to the object being replaced are not affected; they will continue to
    refer to old objects.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不提供如`+=`等赋值定义的不可变对象，赋值会被转换为`=`和`+`。`+`操作符将构建一个新的对象，并将变量名附加到这个新对象上。之前引用被替换对象的变量不受影响；它们将继续引用旧对象。
- en: Python counts the number of places from which an object is referenced. When
    the count of references becomes zero, the object is no longer used anywhere and
    can be removed from memory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python计算一个对象被引用的次数。当引用计数变为零时，该对象在任何地方都不再被使用，可以从内存中移除。
- en: 5.4.4 There’s more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.4 更多...
- en: Some languages have primitive types in addition to objects. In these languages,
    a += statement may leverage a feature of the hardware instructions to tweak the
    value of a primitive type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言除了对象外还有原始类型。在这些语言中，`+=`语句可以利用硬件指令的特性来调整原始类型的值。
- en: 'Python doesn’t have this kind of optimization. Numbers are immutable objects;
    there are no special instructions to tweak their values. Consider the following
    assignment statements:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有这种优化。数字是不可变对象；没有特殊的指令来调整它们的值。考虑以下赋值语句：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The processing does not tweak the internal state of the object 355\. The int
    class does not provide an __iadd__() special method. A new immutable integer object
    is created. This new object is given the label a. The old value previously assigned
    to a is no longer needed, and the storage can be reclaimed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过程不会调整对象355的内部状态。`int`类不提供`__iadd__()`特殊方法。将创建一个新的不可变整数对象。这个新对象被标记为a。之前分配给a的旧值不再需要，存储可以被回收。
- en: 5.4.5 See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.5 参见
- en: In the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005) recipe,
    we’ll look at ways we can copy mutable structures to prevent shared references.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[制作浅拷贝和深拷贝对象](ch009.xhtml#x1-3160005)的菜谱中，我们将探讨如何复制可变结构以防止共享引用。
- en: Also, see [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    for another consequence of the way references are shared in Python.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，请参阅[避免为函数参数使用可变默认值](ch009.xhtml#x1-3210006)以了解Python中引用共享方式的另一种后果。
- en: For the CPython implementation, a few objects can be immortal. See [PEP 683](https://peps.python.org/pep-0683/)
    for more on this implementation detail.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于CPython实现，一些对象可以是永生的。有关此实现细节的更多信息，请参阅[PEP 683](https://peps.python.org/pep-0683/)。
- en: 5.5 Making shallow and deep copies of objects
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 制作浅拷贝和深拷贝对象
- en: Throughout this chapter, we’ve talked about how assignment statements share
    references to objects. Objects are not normally copied.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了赋值语句如何共享对象引用。对象通常不会被复制。
- en: 'Consider this assignment statement:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下赋值语句：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This creates two references to the same underlying object. If the value of the
    b variable has a mutable type, like the list, set, or dict types, then a change
    using either a or b will update the underlying mutable object. For more background,
    see the [Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)
    recipe.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个指向相同底层对象的引用。如果b变量的值具有可变类型，如列表、集合或字典类型，那么使用a或b进行更改将更新底层可变对象。更多背景信息，请参阅[理解变量、引用和赋值](ch009.xhtml#x1-3100004)菜谱。
- en: Most of the time, this is the behavior we want. This is ideal for providing
    mutable objects to functions and having a local variable in the function mutate
    an object created outside the function. There are rare situations in which we
    want to actually have two independent objects created from one original object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们希望这种行为。这对于向函数提供可变对象并在函数中有一个局部变量来修改函数外部创建的对象是理想的。在罕见的情况下，我们希望实际上从单个原始对象创建两个独立的对象。
- en: 'There are two ways to break the connection that exists when two variables are
    references to the same underlying object:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个变量引用相同的底层对象时，有两种方法可以断开这种连接：
- en: Making a shallow copy of the structure
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作结构的浅拷贝
- en: Making a deep copy of the structure
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建结构的深拷贝
- en: 5.5.1 Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.1 准备工作
- en: 'Python does not automatically make a copy of an object. We’ve seen several
    kinds of syntax for making a copy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不会自动复制一个对象。我们已经看到了几种创建副本的语法：
- en: 'Sequences – list, as well as the str, bytes, and tuple types: we can use sequence[:]
    to copy a sequence by using an empty slice expression. This is a special case
    for sequences.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列 - 列表，以及 str、bytes 和 tuple 类型：我们可以使用序列[:] 通过使用空切片表达式来复制序列。这是序列的一个特例。
- en: Almost all collections have a copy() method.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎所有集合都有一个 copy() 方法。
- en: Calling a type, with an instance of the type as the only argument, returns a
    copy. For example, if d is a dictionary, dict(d) will create a shallow copy of
    d.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个类型，以该类型的实例作为唯一参数，返回一个副本。例如，如果 d 是一个字典，dict(d) 将创建 d 的浅拷贝。
- en: What’s important is that these are all shallow copies. When two collections
    are shallow copies, they each contain references to the same underlying objects.
    If the underlying objects are immutable, such as tuples, numbers, or strings,
    this distinction doesn’t matter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这些都是浅拷贝。当两个集合是浅拷贝时，它们各自包含对相同底层对象的引用。如果底层对象是不可变的，如元组、数字或字符串，这种区别并不重要。
- en: For example, if we have a = [1, 1, 2, 3], we can’t perform any mutation on a[0].
    The number 1 in a[0] has no internal state. We can only replace the object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有 a = [1, 1, 2, 3]，我们就无法对 a[0] 进行任何修改。a[0] 中的数字 1 没有内部状态。我们只能替换对象。
- en: 'Questions arise, however, when we have a collection that involves mutable objects.
    First, we’ll create an object, then we’ll create a copy:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们有一个涉及可变对象的集合时，问题就出现了。首先，我们会创建一个对象，然后创建一个副本：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This example created a shallow copy of the dictionary. The two copies will
    look alike because they both contain references to the same objects. There’s a
    shared reference to the immutable string ’a’ and a shared reference to the mutable
    list [1, 1, 2, 3]. We can display the value of another_dict to see that it looks
    like the some_dict object we started with:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个字典的浅拷贝。这两个副本看起来很相似，因为它们都包含对相同对象的引用。有一个共享的引用到不可变的字符串 'a' 和一个共享的引用到可变的列表
    [1, 1, 2, 3]。我们可以显示 another_dict 的值来看到它看起来像我们开始时的 some_dict 对象：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here’s what happens when we update the shared list that’s inside the copy of
    the dictionary. We’ll change the value of some_dict and see the results are also
    present in another_dict:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新字典副本中的共享列表时，会发生以下情况。我们将更改 some_dict 的值，并看到结果也出现在 another_dict 中：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see that the item is shared by using the id() function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 id() 函数看到项是共享的：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because the two id() values are the same, these are the same underlying object.
    The value associated with the key ’a’ is the same mutable list in both some_dict
    and another_dict. We can also use the is operator to see that they’re the same
    object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个 id() 值相同，所以它们是相同的底层对象。与键 'a' 关联的值在 some_dict 和 another_dict 中都是相同的可变列表。我们也可以使用
    is 操作符来看到它们是相同的对象。
- en: 'This mutation of a shallow copy works for list collections that contain all
    other mutable object types as items as well:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对浅拷贝的修改适用于包含所有其他可变对象类型作为项的列表集合：
- en: Because we can’t make a set of mutable objects, we don’t really have to consider
    making shallow copies of sets that share items.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不能创建一个包含可变对象的集合，所以我们实际上不必考虑创建共享项的集合的浅拷贝。
- en: A tuple can contain mutable objects. While the tuple is immutable, the objects
    inside it are mutable.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组可以包含可变对象。虽然元组是不可变的，但元组内的对象是可变的。
- en: The immutability of a tuple does not magically propagate to the items within
    the tuple.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的不可变性不会神奇地传播到元组内的项。
- en: What if we want to completely disconnect two copies? How do we make a deep copy
    instead of a shallow copy?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要完全断开两个副本的连接？我们如何创建深拷贝而不是浅拷贝？
- en: 5.5.2 How to do it...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.2 如何实现...
- en: 'Python generally works by sharing references. It makes copies of objects reluctantly.
    The default behavior is to make a shallow copy, sharing references to the items
    within a collection. Here’s how we make deep copies:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常通过共享引用来工作。它不情愿地复制对象。默认行为是创建浅拷贝，共享集合中项的引用。以下是创建深拷贝的方法：
- en: 'Import the copy module:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 copy 模块：
- en: '[PRE44]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the copy.deepcopy() function to duplicate an object and all of the mutable
    items contained within that object:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 copy.deepcopy() 函数复制一个对象及其包含的所有可变项：
- en: '[PRE45]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will create copies that have no shared references. A change to one copy’s
    mutable internal items won’t have any effect anywhere else:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建没有共享引用的副本。对一个副本的可变内部项的更改不会对其他任何地方产生任何影响：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We updated an item in some_dict and it had no effect on the copy in another_dict.
    We can see that the objects are distinct with the id() function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了some_dict中的某个项，但它对另一个_dict中的副本没有影响。我们可以使用id()函数看到这些对象是不同的：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the id() values are different, these are distinct objects. We can also
    use the is operator to see that they’re distinct objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于id值不同，这些是不同的对象。我们还可以使用is运算符来查看它们是不同的对象。
- en: 5.5.3 How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.3 它是如何工作的...
- en: 'Making a shallow copy is relatively easy. We can even write our own version
    of the algorithm using comprehensions (containing generator expressions):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建浅复制相对简单。我们甚至可以用自己的版本编写算法，使用推导式（包含生成器表达式）：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the list case, the items for the new list are references to the items in
    the source list. Similarly, in the dict case, the keys and values are references
    to the keys and values of the source dictionary.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的情况下，新列表的项是源列表中项的引用。同样，在字典的情况下，键和值是源字典中键和值的引用。
- en: The deepcopy() function uses a recursive algorithm to look inside each item
    that’s a mutable collection.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: deepcopy()函数使用递归算法来查看每个可变集合中的每个项。
- en: 'For an object with a list type, the conceptual algorithm is something like
    this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有列表类型的对象，概念算法类似于以下内容：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This can be used for the collection of types used in JSON documents. For the
    immutable types in the first case clause, there’s no need to make a copy; an object
    of one of these types cannot be mutated. For the two mutable types used in JSON
    documents, empty structures are built, and then copies of each item are inserted.
    The processing involves recursion to assure that — no matter how deeply nested
    — all items that are mutable are copied.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于JSON文档中使用的类型集合。对于第一种情况子句中的不可变类型，没有必要进行复制；这些类型之一的对象不能被修改。对于JSON文档中使用的两种可变类型，构建空结构，然后插入每个项的副本。处理涉及递归以确保——无论嵌套多深——所有可变项都被复制。
- en: The actual implementation of the deepcopy() function handles additional types,
    not part of the JSON specification. The point of this example is to show the general
    idea of a deep copy function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: deepcopy()函数的实际实现处理了JSON规范之外的额外类型。这个例子旨在展示深度复制函数的一般思想。
- en: 5.5.4 See also
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.4 参见
- en: In the [Understanding variables, references, and assignment](ch009.xhtml#x1-3100004)
    recipe, we look at how Python prefers to create references to objects.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[理解变量、引用和赋值](ch009.xhtml#x1-3100004)的配方中，我们探讨了 Python 如何倾向于创建对象的引用。
- en: 5.6 Avoiding mutable default values for function parameters
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 避免为函数参数使用可变默认值
- en: In Chapter [3](ch007_split_000.xhtml#x1-1610003), we looked at many aspects
    of Python function definitions. In the [Designing functions with optional parameters](ch007_split_000.xhtml#x1-1680002)
    recipe, we showed a recipe for handling optional parameters. At the time, we didn’t
    dwell on the issue of providing a reference to a mutable structure as a default.
    We’ll take a close look at the consequences of a mutable default value for a function
    parameter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [3](ch007_split_000.xhtml#x1-1610003) 章中，我们探讨了 Python 函数定义的许多方面。在[设计具有可选参数的函数](ch007_split_000.xhtml#x1-1680002)的配方中，我们展示了处理可选参数的配方。当时，我们没有深入探讨提供可变结构引用作为默认值的问题。我们将仔细研究函数参数可变默认值的后果。
- en: 5.6.1 Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.1 准备工作
- en: Let’s imagine a function that either creates or updates a mutable Counter object.
    We’ll call it gather_stats().
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个函数，它要么创建，要么更新一个可变的Counter对象。我们将称之为gather_stats()。
- en: 'Ideally, a small data gathering function could look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个小型数据收集函数可能看起来像这样：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This shows a bad design for a function. It has two scenarios:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了函数的一个糟糕设计。它有两个场景：
- en: 'The first scenario offers no argument value for the summary parameter. When
    this is omitted, the function creates and returns a collection of statistics.
    Here’s the example of this story:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个场景为摘要参数没有提供任何参数值。当省略此参数时，函数创建并返回一个统计集合。以下是这个故事的例子：
- en: '[PRE51]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second scenario allows us to provide an explicit argument value for the
    summary parameter. When this argument is provided, this function updates the given
    object. Here’s an example of this story:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个场景允许我们为摘要参数提供一个显式的参数值。当提供此参数时，此函数更新给定的对象。以下是这个故事的例子：
- en: '[PRE52]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We’ve set the random number seed to be sure that the two sequences of random
    values are identical. We provided a Counter object to confirm that the results
    are identical.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经设置了随机数种子以确保两个随机值序列是相同的。我们提供了一个 Counter 对象以确认结果是一致的。
- en: 'The problem arises when we do the following operation after the first scenario
    shown above:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在我们执行上述第一个场景之后的以下操作：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The values in this example are incorrect. They’re doubled. Something has gone
    wrong. This only happens when we use the default scenario more than once. This
    code can pass a simple unit test suite and appear correct.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的值是不正确的。它们被加倍了。出了点问题。这只有在多次使用默认场景时才会发生。这段代码可以通过一个简单的单元测试套件并看起来是正确的。
- en: 'As we saw in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe, Python prefers to share references. A consequence of that sharing is the
    object referenced by the s1 variable and the object referenced by the s3b variable
    are the same object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[制作浅拷贝和深拷贝对象](ch009.xhtml#x1-3160005)的配方中看到的，Python更喜欢共享引用。共享的一个后果是，由 s1
    变量引用的对象和由 s3b 变量引用的对象是同一个对象：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This means the value of the object referred to by the s1 variable changed when
    the object for the s3b variable was created. From this, it should be apparent
    the function is updating a single, shared collection object and returning the
    reference to the shared collection.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当为 s3b 变量的对象创建时，s1 变量引用的对象的值发生了变化。从这个例子中，应该很明显，该函数正在更新一个单一、共享的集合对象，并返回共享集合的引用。
- en: The default value used for the summary parameter of this gather_stats_bad()
    function leads to result values built from a single, shared object. How can we
    avoid this?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 gather_stats_bad() 函数的摘要参数使用的默认值导致结果值由一个单一、共享的对象构建。我们如何避免这种情况？
- en: 5.6.2 How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.2 如何操作...
- en: 'There are two approaches to solving this problem of a mutable default parameter:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 解决可变默认参数问题的有两种方法：
- en: Provide an immutable default.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个不可变的默认值。
- en: Change the design.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变设计。
- en: We’ll look at the immutable default first. Changing the design is generally
    a better idea. In order to see why it’s better to change the design, we’ll show
    a purely technical solution.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看不可变默认值。改变设计通常是一个更好的主意。为了看到为什么改变设计更好，我们将展示一个纯粹的技术解决方案。
- en: 'When we provide default values for functions, the default object is created
    exactly once and shared forever after. Here’s the alternative:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为函数提供默认值时，默认对象只创建一次，并且之后永远共享。这里有一个替代方案：
- en: 'Replace any mutable default parameter value with None:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何可变的默认参数值替换为 None：
- en: '[PRE55]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add an if statement to check for an argument value of None and replace it with
    a fresh, new mutable object of the proper type:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 if 语句来检查 None 参数值，并用一个全新的、正确的可变对象替换它：
- en: '[PRE57]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will assure us that every time the function is evaluated with no argument
    value for a parameter, we create a fresh, new mutable object. We will avoid sharing
    a single mutable object over and over again.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将确保每次函数在没有参数值的情况下评估时，我们都会创建一个全新的、可变的对象。我们将避免反复共享单个可变对象。
- en: 5.6.3 How it works...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.3 它是如何工作的...
- en: As we noted earlier, Python prefers to share references. It rarely creates copies
    of objects without explicit use of the copy module or the copy() method of an
    object. Therefore, default values for function parameter values will be shared
    objects. Python does not create fresh, new objects for default parameter values.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所提到的，Python更喜欢共享引用。它很少在没有显式使用 copy 模块或对象的 copy() 方法的情况下创建对象的副本。因此，函数参数值的默认值将是共享对象。Python不会为默认参数值创建全新的对象。
- en: Never use mutable defaults for default values of function parameters.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要为函数参数的默认值使用可变默认值。
- en: Instead of a mutable object (for example, set, list, or dict) as a default,
    use None.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用可变对象（例如，集合、列表或字典）作为默认值，使用 None。
- en: In most cases, we should consider changing the design to not offer a default
    value at all. Instead, define two separate functions. One function updates a parameter
    value, and a second function uses this function but provides a fresh, empty mutable
    object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们应该考虑改变设计，根本不提供默认值。相反，定义两个单独的函数。一个函数更新参数值，另一个函数使用这个函数，但提供一个全新的、空的、可变的对象。
- en: 'For this example, they might be called create_stats() and update_stats(), with
    unambiguous parameters:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，它们可能被称为 create_stats() 和 update_stats()，具有明确的参数：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the summary parameter to the update_stats() function is not optional.
    Similarly, there is no summary object parameter defined for the create_stats()
    function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，update_stats()函数的summary参数不是可选的。同样，create_stats()函数也没有定义summary对象参数。
- en: The idea of optional mutable arguments was not a good idea because the mutable
    object provided as a default value for a parameter is reused.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可选可变参数的想法并不好，因为作为参数默认值的可变对象被重复使用。
- en: 5.6.4 There’s more...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.4 更多内容...
- en: In the standard library, there are some examples of a cool technique that shows
    how we can create fresh default objects. A number of places use a factory function
    as a parameter. This function can be used to create a fresh, new mutable object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，有一些示例展示了如何创建新的默认对象的一个酷技术。许多地方使用工厂函数作为参数。这个函数可以用来创建一个全新的可变对象。
- en: In order to leverage this design pattern, we need to modify the design of our
    update_stats() function. We will no longer update an existing Counter object in
    the function. We’ll always create a fresh, new object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种设计模式，我们需要修改update_stats()函数的设计。我们不再在函数中更新现有的Counter对象。我们将始终创建一个全新的对象。
- en: 'Here’s a function that calls a factory function to create a useful default
    value:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个调用工厂函数来创建有用默认值的函数：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For this version, we’ve defined the Summarizer type to be a function of one
    argument that will create a Counter object. The default value uses the Counter
    class as the one-argument function. We can override the summary_func function
    with any one-argument function that will collect details instead of summarizing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个版本，我们定义了Summarizer类型为一个接受一个参数的函数，该函数将创建一个Counter对象。默认值使用Counter类作为单参数函数。我们可以用任何单参数函数来覆盖summary_func函数，该函数将收集细节而不是总结。
- en: 'Here’s an example using list instead of collections.Counter:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用list而不是collections.Counter的例子：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, we provided the list function to create a list with the individual
    random samples in it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了list函数来创建一个包含单个随机样本的列表。
- en: 'Here’s an example without an argument value. It will create a new collections.Counter
    object each time it’s used:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个不带参数值的例子。每次使用时，它都会创建一个新的collections.Counter对象：
- en: '[PRE61]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this case, we’ve evaluated the function using the default value for summary_func,
    which creates a collections.Counter object from the random samples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用默认的summary_func值来评估函数，它从随机样本中创建一个collections.Counter对象。
- en: 5.6.5 See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.5 参见
- en: See the Creating dictionaries – inserting and updating recipe, which shows how
    the defaultdict collection works.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见创建字典 – 插入和更新食谱，它展示了defaultdict集合的工作方式。
- en: Join our community Discord space
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Python Discord工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
