- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Investigating Dependency Injection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查依赖注入
- en: Since the first chapter, `BaseModel`, `Request`, `Response`, and `BackgroundTasks`
    in their processes. Applying DI proves that instantiating some FastAPI classes
    is not always the ideal approach, since the framework has a built-in container
    that can provide the objects of these classes for the API services. This method
    of object management makes FastAPI easy and efficient to use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第一章以来，`BaseModel`、`Request`、`Response` 和 `BackgroundTasks` 在其过程中应用 DI。应用 DI
    证明实例化一些 FastAPI 类并不总是理想的方法，因为框架有一个内置的容器可以提供这些类的对象给 API 服务。这种对象管理方法使得 FastAPI 使用起来既简单又高效。
- en: FastAPI has a container where the DI policy is applied to instantiate module
    classes and even functions. We only need to specify and declare these module APIs
    to the services, middleware, authenticator, data sources, and test cases because
    the rest of the object assembly, management, and instantiation is now the responsibility
    of the built-in container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 有一个容器，其中 DI 策略被应用于实例化模块类甚至函数。我们只需要将这些模块 API 指定和声明给服务、中间件、验证器、数据源和测试用例，因为其余的对象组装、管理和实例化现在由内置的容器负责。
- en: 'This chapter will help you to understand how to manage objects needed by the
    application, such as minimizing some instances and creating loose bindings among
    them. Knowing the effectiveness of DI on FastAPI is the first step in designing
    our microservice applications. Our discussions will focus on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您了解如何管理应用程序所需的对象，例如最小化某些实例并在它们之间创建松散的绑定。了解 DI 在 FastAPI 上的有效性是我们设计我们的微服务应用程序的第一步。我们的讨论将集中在以下方面：
- en: Applying **Inversion of Control** (**IoC**) and DI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 **控制反转**（**IoC**）和 DI
- en: Exploring ways of injecting dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索依赖注入的方法
- en: Organizing a project based on dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于依赖关系组织项目
- en: Using third-party containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: Scoping of instances
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例的作用域
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter uses a software prototype called *online recipe system*, which
    manages, evaluates, rates, and reports recipes of different types and origins.
    Applying a DI pattern is the priority of this project, so expect some changes
    in the development strategies and approaches, such as adding `model`, `repository`,
    and `service` folders. This software is for food enthusiasts or chefs who want
    to share their specialties, newbies looking for recipes to experiment with, and
    guests who just like to browse through different food menus. This open-ended application
    does not use any database management system yet, so all the data is temporarily
    stored in Python containers. Code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用一个名为 *在线食谱系统* 的软件原型，该系统管理、评估、评分和报告不同类型和来源的食谱。应用 DI 模式是这个项目的优先任务，因此请期待在开发策略和方法上的一些变化，例如添加
    `model`、`repository` 和 `service` 文件夹。这款软件是为想要分享他们专长的美食爱好者或厨师、寻找食谱进行实验的新手以及喜欢浏览不同食物菜单的客人准备的。这个开放式的应用程序目前还没有使用任何数据库管理系统，因此所有数据都暂时存储在
    Python 容器中。代码已全部上传至 [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03)。
- en: Applying IoC/DI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用 IoC/DI
- en: FastAPI is a framework that supports the IoC principle, which means that it
    has a container that can instantiate objects for an application. In a typical
    programming scenario, we instantiate classes to use them in many ways to build
    a running application. But with IoC, the framework instantiates the components
    for the application. *Figure 3.1* shows the whole picture of the IoC principle
    and the participation of one of its forms, called the DI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 是一个支持 IoC 原则的框架，这意味着它有一个容器可以为应用程序实例化对象。在典型的编程场景中，我们实例化类以多种方式使用它们来构建运行中的应用程序。但是，使用
    IoC，框架为应用程序实例化组件。*图 3.1* 展示了 IoC 原则的全貌及其一种形式，称为 DI。
- en: '![Figure 3.1 – The IoC principle](img/Figure_3.1_B17975.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – IoC 原则](img/Figure_3.1_B17975.jpg)'
- en: Figure 3.1 – The IoC principle
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – IoC 原则
- en: For FastAPI, DI is not only a principle but a mechanism to integrate an object
    into a component that leads to creating a *loosely coupled* but *highly cohesive*
    software structure. Almost all components can be candidates for DI, including
    *functions*. But for now, let us focus on *callable components* that provide some
    JSON objects once they are injected into an API service – injectable and callable
    components that we call *dependency functions*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FastAPI来说，依赖注入（DI）不仅是一个原则，也是一种将对象集成到组件中的机制，这有助于创建一个*松散耦合*但*高度内聚*的软件结构。几乎所有的组件都可以成为DI的候选者，包括*函数*。但就目前而言，让我们专注于*可调用组件*，一旦它们被注入到API服务中，就会提供一些JSON对象——我们称之为*依赖函数*的可注入和可调用组件。
- en: Injecting a dependency function
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入依赖函数
- en: 'A `create_login()`, as shown in the following code, which is in the project’s
    `/api/users.py` module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`create_login()`位于项目的`/api/users.py`模块中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function requires the `id`, `username`, and `password` parameters and `type`
    to continue its process and return a valid JSON `account` object, derived from
    these parameters. A dependency function sometimes uses some underlying formula,
    resource, or complex algorithms to derive its function value, but for now, we
    utilize it as a *placeholder of data* or `dict`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要`id`、`username`、`password`参数以及`type`来继续其过程并返回一个有效的JSON `account`对象，这些参数是其派生出来的。依赖函数有时会使用一些底层公式、资源或复杂算法来推导其函数值，但就目前而言，我们将其用作*数据占位符*或`dict`。
- en: 'Common to dependency functions are method parameters that serve as placeholders
    to a REST API’s incoming request. These are wired into the API’s method parameter
    list as a domain model to the query parameters or request body through DI. The
    `Depends()` function from the `fastapi` module pursues the injection before it
    wires the injectable to a local parameter. The module function can only take one
    parameter for injection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖函数来说，常见的做法是将方法参数用作REST API接收到的请求的占位符。这些参数通过DI连接到API的方法参数列表，作为领域模型，对应于查询参数或请求体。`fastapi`模块中的`Depends()`函数在将注入项连接到本地参数之前执行注入。模块函数只能接受一个参数进行注入：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding is a code fragment from our *online recipe system* that shows
    how `Depends()` injects `create_login()`into the framework’s container and fetches
    its instance for *wiring* to the `populate_user_accounts()` service. Syntactically,
    the injection process only needs the name of the function dependency without the
    parenthesis. Again, the purpose of `create_login()` is to capture the query parameters
    of the API service. The `jsonable_encoder()` is very useful to many APIs in converting
    these injectables to JSON-compatible types such as `dict`, which are essential
    for *instantiating the needed data models* and *generating responses*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是一个来自我们*在线食谱系统*的代码片段，展示了`Depends()`如何将`create_login()`注入到框架的容器中，并获取其实例以用于将`populate_user_accounts()`服务连接起来。在语法上，注入过程只需要函数依赖项的名称，无需括号。再次强调，`create_login()`的目的在于捕获API服务的查询参数。`jsonable_encoder()`对于许多API来说非常有用，它可以将这些注入项转换为JSON兼容的类型，如`dict`，这对于*实例化所需的数据模型*和*生成响应*至关重要。
- en: Important Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The term **dependencies** can be used interchangeably with **injectables**,
    **dependables**, **resources**, **providers**, or **components**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**依赖项**可以与**注入项**、**依赖项**、**资源**、**提供者**或**组件**互换使用。
- en: Injecting a callable class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入一个可调用类
- en: 'FastAPI also allows classes to be injected into any components, since they
    can also be considered *callable* components. A class becomes *callable* during
    instantiation when the call to its constructor, `__init__(self)`, is done. Some
    of these classes have *no-arg* constructors, while others, such as the following
    `Login` class, require constructor arguments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI还允许将类注入到任何组件中，因为它们也可以被视为*可调用*组件。一个类在实例化过程中成为可调用，当对其构造函数`__init__(self)`的调用完成时。其中一些类具有*无参*构造函数，而其他类，如以下`Login`类，则需要构造函数参数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Login` class, located in `/model/users.py`, needs `id`, `username`, `password`,
    and `type` passed to its constructor before the instantiation. A possible instantiation
    would be `Login(id=' 249a0837-c52e-48cd-bc19-c78e6099f931', username='admin',
    password='admin2255', type=UserType.admin)`. Overall, we can observe the similarity
    between a class and a dependency function based on their callable behavior and
    the ability to capture request data, such as a model attribute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`/model/users.py`的`Login`类在实例化之前需要将`id`、`username`、`password`和`type`传递给其构造函数。一个可能的实例化方式是`Login(id='249a0837-c52e-48cd-bc19-c78e6099f931',
    username='admin', password='admin2255', type=UserType.admin)`。总体来看，我们可以观察到类和依赖函数在可调用行为和捕获请求数据（如模型属性）方面的相似性。
- en: 'Conversely, the `populate_login_without_service()` shown in the following code
    block shows how `Depends()` injects `Login` to the service. The `Depends()` function
    tells the built-in container to instantiate `Login` and fetches that instance,
    ready to be assigned to the `user_account` local parameter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，以下代码块中展示的`populate_login_without_service()`显示了`Depends()`如何将`Login`注入到服务中。`Depends()`函数告诉内置容器实例化`Login`并获取该实例，准备分配给`user_account`局部参数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All dependencies should be declared at the right-most part of the service’s
    parameter list. If there are query, path, or form parameters, injectables should
    come last. Moreover, the use of the `jsonable_encoder()` function can be an option
    if the *injectables* do not contain data that are hard to encode by default.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖都应该在服务参数列表的最右侧声明。如果有查询、路径或表单参数，注入式依赖应该放在最后。此外，如果注入式依赖不包含默认难以编码的数据，使用`jsonable_encoder()`函数也是一个选项。
- en: Building nested dependencies
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建嵌套依赖
- en: 'There are some scenarios when injectables are also dependent on other dependencies.
    When we inject a function dependency to another function, a class dependency to
    another class injectable, or a function resource to a class, the goal is to build
    nested dependencies. Nested dependencies are beneficial to REST APIs, with lengthy
    and complex request data that needs structuring and grouping through sub-domain
    models. These sub-domains or domain models within a model are later encoded as
    sub-dependencies into JSON-compatible types by FastAPI:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景下，注入式依赖也依赖于其他依赖。当我们向另一个函数注入函数依赖、向另一个类注入式依赖或向类注入函数资源时，目标是构建嵌套依赖。嵌套依赖对REST
    API有益，特别是对于需要通过子域模型进行结构化和分组的长时间和复杂请求数据。这些子域或模型内的域模型随后被FastAPI编码为与JSON兼容的类型作为子依赖：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding asynchronous `create_user_details()` function shows that even
    a dependency function needs another dependency to satisfy its purpose. This function
    is dependent on `create_login()`, which is another dependable component. With
    this nested dependency setup, wiring the `create_user_details()` into an API service
    also includes the injection of `create_login()` into the container. In short,
    there is a chain of DIs that will be created when nested dependencies are applied:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前异步的`create_user_details()`函数表明，即使依赖函数也需要另一个依赖来满足其目的。这个函数依赖于`create_login()`，这是另一个可靠的组件。通过这种嵌套依赖设置，将`create_user_details()`连接到API服务也包括将`create_login()`注入到容器中。简而言之，当应用嵌套依赖时，将创建一系列依赖注入链：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding `add_profile_login()` service provides a clear picture of its
    dependency on `create_user_details()`, including its underlying login details.
    The FastAPI container successfully created the two functions through chained DI
    to capture the request data during the API’s request transactions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`add_profile_login()`服务清楚地展示了其对`create_user_details()`的依赖，包括其底层的登录详情。FastAPI容器通过链式依赖成功创建了两个函数，以在API请求事务中捕获请求数据。
- en: 'Conversely, a class can also be dependable on another class. An example is
    the `Profile` class, shown here, which is dependent on `UserDetails` and `Login`
    classes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个类也可以依赖于另一个类。这里以`Profile`类为例，它依赖于`UserDetails`和`Login`类：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is a nested dependency here because two classes will be injected altogether
    once `Profile` is wired to a REST API service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个嵌套依赖，因为一旦`Profile`连接到REST API服务，两个类将一起注入。
- en: 'A clear advantage of these chained dependencies is depicted in the following
    `add_profile_login_models()` service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`add_profile_login_models()`服务展示了这些链式依赖的明显优势：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The extraction of `profile.user` and `profile.login` makes it easier for the
    service to identify what query data to deserialize. It also helps the service
    determine which group of data needs `Login` instantiation and which is for `UserDetails`.
    As a result, it will be easier to manage the persistency of these objects in their
    respective `dict` repositories.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提取`profile.user`和`profile.login`使得服务更容易识别需要反序列化的查询数据。它还有助于服务确定哪些数据组需要`Login`实例化，哪些是为`UserDetails`。因此，将更容易管理这些对象在其各自的`dict`存储库中的持久性。
- en: Creating explicit dependencies between function and class will be discussed
    later, but for now, let us examine how to fine-tune whenever we use lots of these
    nested dependencies in our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后讨论如何在函数和类之间创建显式依赖关系，但现在，让我们看看如何在应用中使用大量这些嵌套依赖项时进行微调。
- en: Caching the dependencies
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存依赖项
- en: All dependencies are *cacheable*, and FastAPI caches all these dependencies
    during a request transaction. If a dependable is common to all services, FastAPI
    will not allow you to fetch these objects from its container *by default*. Rather,
    it will look for this injectable from its cache to be used multiple times across
    the API layer. Saving dependencies, especially nested ones, is a good feature
    of FastAPI because it optimizes the performance of the REST service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都是*可缓存的*，FastAPI在请求事务期间会缓存所有这些依赖项。如果一个依赖项对所有服务都是通用的，FastAPI默认不会允许你从其容器中获取这些对象。相反，它会在其缓存中寻找这个可注入项，以便在API层跨多次使用。保存依赖项，特别是嵌套依赖项，是FastAPI的一个好特性，因为它优化了REST服务的性能。
- en: 'Conversely, `Depends()` has a `use_cache` parameter that we can set to `False`
    if we want to bypass this caching mechanism. Configuring this hook will not save
    the dependencies from the cache during request transactions, allowing `Depends()`
    to fetch the instances from the container more frequently. Another version of
    the `add_profile_login_models()` service, shown here, shows how to disable dependency
    caching:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Depends()`有一个`use_cache`参数，如果我们想绕过这个缓存机制，我们可以将其设置为`False`。配置这个钩子将不会在请求事务期间从缓存中保存依赖项，允许`Depends()`更频繁地从容器中获取实例。下面所示`add_profile_login_models()`服务的另一个版本展示了如何禁用依赖项缓存：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another obvious change in the preceding service implementation is the presence
    of the `Profile` data type in the local parameter declaration. Is this really
    allowed by FastAPI?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面服务实现中的另一个明显变化是`Profile`数据类型出现在局部参数声明中。这是FastAPI允许的吗？
- en: Declaring Depends() parameter types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明Depends()参数类型
- en: 'Generally, we do not declare types of the local parameters that will reference
    the injected dependencies. Due to *type hints*, we can optionally associate the
    references with their appropriate object types. For instance, we can re-implement
    `populate_user_accounts()` to include the type of `user_account`, such as the
    following one:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会声明将引用注入依赖项的局部参数的类型。由于*类型提示*，我们可以选择性地将引用与其适当的对象类型关联起来。例如，我们可以重新实现`populate_user_accounts()`以包含`user_account`的类型，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This scenario happens very rarely, since `create_login()` is a dependency function,
    and we usually do not create classes only to provide the blueprint type of its
    returned values. But when we use class dependables, declaring the appropriate
    class type to the wired object is feasible, as in the following `add_profile_login_models()`
    service, which declares the `profile` parameter as `Profile`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景很少发生，因为`create_login()`是一个依赖函数，我们通常不会仅为了提供其返回值的蓝图类型而创建类。但是，当我们使用类依赖项时，将适当的类类型声明给连接的对象是可行的，如下面的`add_profile_login_models()`服务所示，其中将`profile`参数声明为`Profile`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although the declaration is syntactically valid, the expression looks *repetitive*
    and *redundant* because the `Profile` type appears twice in the declaration portion.
    To avoid this redundancy, we can replace the statement with a shorthand version
    by omitting the class name inside the `Depends()` function. Thus, a better way
    of declaring the preceding `profile` should be the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明在语法上是有效的，但由于`Profile`类型在声明部分出现了两次，所以表达式看起来*重复*且*冗余*。为了避免这种冗余，我们可以通过在`Depends()`函数内部省略类名来替换语句，使用简写版本。因此，声明前面`profile`的更好方式应该是以下这样：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The changes reflected on the parameter list will not affect the performance
    of the request transaction of the `add_profile_login_models()` service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表上的更改不会影响`add_profile_login_models()`服务请求事务的性能。
- en: Injecting asynchronous dependencies
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入异步依赖项
- en: 'A FastAPI built-in container does not only manage *synchronous* function dependables
    but also *asynchronous* ones. The following `create_user_details()` is an asynchronous
    dependency, read to be wired to a service:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 内置容器不仅管理 *同步* 函数依赖项，还管理 *异步* 依赖项。下面的 `create_user_details()` 是一个异步依赖项，准备好连接到服务：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The container can manage both synchronous and asynchronous function dependency.
    It can allow the wiring of *asynchronous dependables* on an asynchronous API service
    or some *asynchronous ones* on a synchronous API. In cases where the dependency
    and the services are both asynchronous, applying the `async`/`await` protocol
    is recommended to avoid discrepancies in the results. `create_user_details()`,
    which is dependent on a synchronous `create_login()`, is wired on `add_profile_login()`,
    which is an asynchronous API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以管理同步和异步函数依赖项。它允许在异步 API 服务上连接 *异步依赖项* 或在同步 API 上连接一些 *异步依赖项*。当依赖项和服务都是异步的情况下，建议使用
    `async`/`await` 协议以避免结果的不一致。依赖于同步 `create_login()` 的 `create_user_details()` 在异步
    API `add_profile_login()` 上被连接。
- en: After learning how DI design pattern works in FastAPI, the next step is to know
    the different levels of strategy for applying `Depends()` in our application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 FastAPI 中依赖注入设计模式的工作原理之后，下一步是了解在我们的应用程序中应用 `Depends()` 的不同策略级别。
- en: Exploring ways of injecting dependencies
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索注入依赖项的方法
- en: From the previous discussions, we know that FastAPI has a built-in container
    through which some objects are injected and instantiated. Likewise, we have learned
    that the only FastAPI components that are injectables are those so-called dependables,
    injectables, or dependencies. Now, let us enumerate different ways to pursue the
    DI pattern in our application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的讨论中，我们知道 FastAPI 有一个内置的容器，通过它一些对象被注入和实例化。同样，我们也了解到，唯一可注入的 FastAPI 组件是那些所谓的依赖项、可注入项或依赖。现在，让我们列举出在我们的应用程序中追求依赖注入模式的不同方法。
- en: Dependency injection on services
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务上的依赖注入
- en: 'The most common area where DI occurs is in the *parameter list* of a service
    method. Any discussions regarding this strategy have been tackled already in the
    previous examples, so we only need to present additional points concerning this
    strategy:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: DI 发生最常见的地方是在服务方法的 *参数列表* 中。关于这种策略的任何讨论已经在之前的示例中解决，所以我们只需要提出关于这种策略的额外观点：
- en: First, the number of custom injectables a service method should take is also
    part of the concern. When it comes to complex query parameters or request bodies,
    API services can take more than one injectable as long as there are no similar
    instance variable names among these dependables. This *variable name collision*
    among the dependables will lead to having one parameter entry for the conflicted
    variable during the request transactions, thus sharing the same value for all
    these conflicting variables.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，服务方法应该接受的定制可注入项的数量也是需要关注的一部分。当涉及到复杂的查询参数或请求体时，只要这些依赖项中没有相似的实例变量名，API 服务就可以接受多个可注入项。这些依赖项之间的
    *变量名冲突* 将导致在请求事务中只有一个参数条目用于冲突变量，从而使得所有这些冲突变量共享相同的值。
- en: Second, the appropriate *HTTP method operation* to work with the injectables
    is also one aspect to consider. Both function and class dependencies can work
    with the `GET`, `POST`, `PUT`, and `PATCH` operations, except for those dependables
    with attribute types such as numeric `Enum` and `UUID` that can cause an *HTTP
    Status 422* (**Unprocessable Entity**) due to conversion problems. We must plan
    which HTTP method is applicable for some dependable(s) first, before implementing
    the service method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，与可注入项一起工作的合适的 *HTTP 方法操作* 也是需要考虑的一个方面。函数和类依赖项都可以与 `GET`、`POST`、`PUT` 和 `PATCH`
    操作一起工作，但那些具有如数值 `Enum` 和 `UUID` 等属性类型的依赖项可能会因为转换问题而导致 *HTTP 状态 422*（**不可处理实体**）。我们必须首先计划适用于某些依赖项的
    HTTP 方法，然后再实现服务方法。
- en: 'Third, not all dependables are placeholders of request data. Unlike the class
    dependables, dependency functions are not specifically used for returning objects
    or `dict`. Some of them are used in *filtering request data*, *scrutinizing authentication
    details*, *managing form data*, *verifying header values*, *handling cookies*,
    and *throwing some errors* when there are violations of some rules. The following
    `get_all_recipes()` service is dependent on a `get_recipe_service()` injectable
    that will query all the recipes from the `dict` repository of the application:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，并非所有依赖项都是请求数据的占位符。与类依赖项不同，依赖函数并不专门用于返回对象或`dict`。其中一些用于**过滤请求数据**、**审查认证细节**、**管理表单数据**、**验证头值**、**处理cookie**，并在违反某些规则时**抛出一些错误**。以下`get_all_recipes()`服务依赖于一个`get_recipe_service()`注入函数，该函数将从应用的`dict`存储库中查询所有食谱：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The dependency function provides the needed transactions such as saving and
    retrieving records of recipes. Instead of the usual instantiation or method call,
    a better strategy is to inject these *dependable services* into the API implementation.
    The `handler` method parameter, which refers to the instance of `get_recipe_service()`,
    invokes the `get_recipes()` transactions of a particular service to retrieve all
    the menus and ingredients stored in the repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖函数提供了所需的交易，例如保存和检索食谱的记录。而不是使用常规的实例化或方法调用，更好的策略是将这些**依赖服务**注入到API实现中。`handler`方法参数，它指的是`get_recipe_service()`的实例，调用特定服务的`get_recipes()`交易以检索存储库中存储的所有菜单和成分。
- en: Dependency injection on path operators
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径操作符上的依赖注入
- en: 'There is always an option to implement *triggers*, *validators*, and *exception
    handlers* as injectable functions. Since these dependables work like *filters*
    to the incoming request, their injection happens in the *path operator* and not
    in the service parameter list. The following code is an implementation of the
    `check_feedback_length()` validator, found in `/dependencies/posts.py`, which
    checks whether the feedback posted by a user regarding a recipe should be at least
    20 characters, including spaces:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个选项来实现**触发器**、**验证器**和**异常处理器**作为可注入的函数。由于这些依赖项像**过滤器**一样作用于传入的请求，它们的注入发生在**路径操作符**中，而不是在服务参数列表中。以下代码是`/dependencies/posts.py`中找到的`check_feedback_length()`验证器的实现，该验证器检查用户针对食谱发布的反馈是否至少包含20个字符（包括空格）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The validator pauses the API execution to retrieve the feedback from a post
    to be validated *if its length is lower than 20*. If the dependency function finds
    it `True`, it will throw an *HTTP Status 403*. Alternatively, it will emit a *Status
    Code 500* if the feedback is missing from the request data; otherwise, it will
    let the API transaction finish its task.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证器的长度小于20，验证器会暂停API执行以从待验证的帖子中检索反馈。如果依赖函数发现它是`True`，它将抛出**HTTP状态403**。如果请求数据中缺少反馈，它将发出**状态码500**；否则，它将允许API事务完成其任务。
- en: 'Compared to the `create_post()` and `post_service()` dependables, the following
    script shows that the `check_feedback_length()` validator is not invoked anywhere
    inside the `insert_post_feedback()` service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`create_post()`和`post_service()`依赖项相比，以下脚本显示`check_feedback_length()`验证器在`insert_post_feedback()`服务内部没有任何地方被调用：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The validator will always work closely with the incoming request transaction,
    whereas the other two injectables, `post` and `handler`, are part of the API’s
    transactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器将始终与传入的请求事务紧密工作，而其他两个注入项`post`和`handler`则是API事务的一部分。
- en: Important Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The path router of `APIRouter` can accommodate more than one injectable, which
    is why its `dependencies` parameter always needs a `List` value (`[]`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIRouter`的路径路由器可以容纳多个可注入项，这就是为什么它的`dependencies`参数始终需要一个`List`值（`[]`）。'
- en: Dependency injection on routers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器上的依赖注入
- en: 'However, some transactions are not localized to work on one specific API. There
    are dependency functions created to work with a certain group of REST API services
    within an application, such as the following `count_user_by_type()` and `handler
    check_credential_error()` events that are designed to manage incoming requests
    of REST APIs under the `user.router` group. This strategy requires DI at the `APIRouter`
    level:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些事务并不是专门针对一个特定的API进行本地化的。有一些依赖函数被创建出来，用于与一个应用中特定组的REST API服务一起工作，例如以下`count_user_by_type()`和`handler
    check_credential_error()`事件，这些事件被设计用来管理`user.router`组下的REST API的传入请求。这种策略需要在`APIRouter`级别进行依赖注入：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Based on the preceding implementations, the goal of `count_user_by_type()` is
    to build an updated frequency of users in `stats_user_type` according to `UserType`.
    Its execution starts right after the REST API receives a new user and login details
    from the client. While it checks the `UserType` of the new record, the API service
    pauses briefly and resumes after the function dependency has completed its tasks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 preceding 实现，`count_user_by_type()` 的目标是根据 `UserType` 在 `stats_user_type`
    中构建用户的更新频率。它的执行是在 REST API 从客户端接收到新用户和登录详情后立即开始的。在检查新记录的 `UserType` 时，API 服务会短暂暂停，并在函数依赖完成其任务后恢复。
- en: Conversely, the task of `check_credential_error()` is to ensure that the `username`
    and `password` of the new user should not be the same. It throws an *HTTP Status
    403* when the credentials are the same, which will halt the whole REST service
    transaction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`check_credential_error()` 的任务是确保新用户的 `username` 和 `password` 不应相同。当凭证相同时，它会抛出
    *HTTP 状态 403*，这将停止整个 REST 服务事务。
- en: 'Injecting these two dependables through `APIRouter` means that all the REST
    API services registered in that `APIRouter` will always trigger the executions
    of these dependencies. The dependencies can only work with API services designed
    to persist the like of the `user` and `login` details, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `APIRouter` 注入这两个依赖项意味着在该 `APIRouter` 中注册的所有 REST API 服务都将始终触发这些依赖项的执行。这些依赖项只能与设计用于持久化
    `user` 和 `login` 详情的 API 服务一起工作，如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`check_credential_error()`, which is injected into the `APIRouter` component,
    filters the `username` and `password` derived from the `create_login()` injectable
    function. Likewise, it filters the `create_user_details()` injectable of the `add_profile_login()`
    service, as shown in the following snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注入到 `APIRouter` 组件中的 `check_credential_error()` 会过滤从 `create_login()` 注入式函数中得到的
    `username` 和 `password`。同样，它也会过滤 `add_profile_login()` 服务的 `create_user_details()`
    注入式，如下面的片段所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Login` injectable class also undergoes filtering through `check_credential_error()`.
    It also contains the `username` and `password` parameters that the injectable
    function can filter. Conversely, the injectable `Profile` of the following `add_profile_login_models()`
    service is not excluded from the error-checking mechanism because it has a `Login`
    dependency in its constructor. Having the `Login` dependable means `check_cedential_error()`
    will also filter `Profile`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login` 注入式类也会通过 `check_credential_error()` 进行过滤。它也包含注入式函数可以过滤的 `username`
    和 `password` 参数。相反，以下 `add_profile_login_models()` 服务的 `Profile` 注入式没有被排除在错误检查机制之外，因为它在其构造函数中有一个
    `Login` 依赖。拥有 `Login` 依赖意味着 `check_cedential_error()` 也会过滤 `Profile`。'
- en: 'With `check_credential_error()` is the `count_user_by_type()` injectable that
    counts the number of users that access the API service:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `check_credential_error()` 是 `count_user_by_type()` 注入式，用于统计访问 API 服务的用户数量：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A dependency function wired into `APIRouter` should apply defensive programming
    and a proper `try-except` to avoid parameter conflicts with the API services.
    If we were to run `check_credential_error()` with a `list_all_user()` service,
    for instance, expect some runtime problems because there is no `login` persistence
    involved during data retrieval.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 `APIRouter` 的依赖函数应该应用防御性编程和适当的 `try-except` 来避免与 API 服务发生参数冲突。例如，如果我们用 `list_all_user()`
    服务运行 `check_credential_error()`，可能会遇到一些运行时问题，因为在数据检索期间没有涉及 `login` 持久化。
- en: Important Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Like its path operators, the constructor of `APIRouter` can also accept more
    than one injectable because its `dependencies` parameter will allow a `List` (`[]`)
    of valid ones.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其路径操作符，`APIRouter` 的构造函数也可以接受多个注入式，因为它的 `dependencies` 参数将允许一个 `List` (`[]`)
    的有效值。
- en: Dependency injection on main.py
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 main.py 上的依赖注入
- en: There are portions of the software that are very hard to automate because of
    their vast and complex scopes, so considering them will always be a waste of time
    and effort. These *cross-cutting concerns* span from the UI level down to the
    data tier, which explains why these functionalities are impractical and even inconceivable
    to manage and implement using typical programming paradigms. These cross-cutting
    concerns are transactions such as *exception logging*, *caching*, *instrumentation*,
    and *user authorization*, common to any application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于范围广泛且复杂，软件的某些部分很难自动化，因此考虑它们将始终是时间和精力的浪费。这些 *横切关注点* 从 UI 层到数据层，这解释了为什么这些功能在实际管理和实现上是不切实际的，甚至难以想象。这些横切关注点包括如
    *异常记录*、*缓存*、*监控* 和 *用户授权* 等事务，这些是任何应用程序都共有的。
- en: 'FastAPI has an easy remedy to address these *features*: to create them as injectables
    to the FastAPI instance of `main.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 有一个简单的解决方案来解决这些 *特性*：将它们作为可注入到 `main.py` 的 FastAPI 实例中的可注入项：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding `log_transaction()` is a simple logger of the `URL` paths invoked
    or accessed by the client. While the application is running, this cross-cut should
    propagate the repository with different URLs coming from any `APIRouter`. This
    task can only happen when we inject this function through the FastAPI instance
    of `main.py`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `log_transaction()` 是一个简单的记录器，用于记录客户端调用的或访问的 `URL` 路径。当应用程序运行时，这个跨切面应该将不同的
    `APIRouter` 发来的不同 `URL` 传播到存储库中。这项任务只能在通过 `main.py` 的 FastAPI 实例注入这个函数时发生：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Dependencies *auto-wired* to the FastAPI constructor are known as *global dependencies*
    because they are accessible by any REST APIs from the routers. For instance, `log_transaction()`,
    depicted in the preceding script, will execute every time the APIs from the `recipes`,
    `users`, `posts`, or `complaints` routers process their respective request transactions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 FastAPI 构造函数自动连接的依赖项被称为 *全局依赖项*，因为它们可以通过任何路由器的 REST API 访问。例如，前面脚本中描述的 `log_transaction()`
    将在 `recipes`、`users`、`posts` 或 `complaints` 路由器处理它们各自的请求事务时执行。
- en: Important Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Like `APIRouter`, the constructor of `FastAPI` allows more than function dependency.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `APIRouter` 类似，`FastAPI` 的构造函数允许更多的函数依赖。
- en: Aside from these strategies, DI can also help us organize our application by
    having `repository`, `service`, and `model` layers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些策略之外，依赖注入（DI）还可以通过拥有 `repository`、`service` 和 `model` 层来组织我们的应用程序。
- en: Organizing a project based on dependencies
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于依赖关系组织项目
- en: It is feasible to use a *repository-service* pattern in some complex FastAPI
    applications through DI. The repository-service pattern is responsible for the
    creation of the **repository layer** of the application, which manages the Creation,
    Reading, Updates, and Deletion (CRUD) of data source. A repository layer requires
    **data models** that depict the table schemas of a collection or database. The
    repository layer needs the **service layer** to establish a connection with other
    parts of the application. The service layer operates like a business layer, where
    the data sources and business processes meet to derive all the necessary objects
    needed by the REST API. The communication between the repository and service layers
    can only be possible by creating injectables. Now, let us explore how the layers
    shown in *Figure 3.2* are built by DI using injectable components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些复杂的 FastAPI 应用程序中，可以通过依赖注入（DI）使用 *存储库-服务* 模式。存储库-服务模式负责创建应用程序的 **存储库层**，该层管理数据源的增加、读取、更新和删除（CRUD）。存储库层需要
    **数据模型** 来描述集合或数据库的表结构。存储库层需要 **服务层** 来与其他应用程序部分建立连接。服务层就像一个业务层，数据源和业务流程在这里相遇，以生成
    REST API 所需的所有必要对象。存储库和服务层之间的通信只能通过创建可注入项来实现。现在，让我们通过可注入组件来探索 *图 3.2* 中显示的层是如何构建的。
- en: '![Figure 3.2 – The repository-service layers](img/Figure_3.2_B17975.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 存储库-服务层](img/Figure_3.2_B17975.jpg)'
- en: Figure 3.2 – The repository-service layers
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 存储库-服务层
- en: The model layer
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型层
- en: 'This layer is purely composed of *resources*, *collections*, and *Python classes*
    that can be used by the repository layer to create CRUD transactions. Some model
    classes are dependable on other models, but some are just independent blueprints
    designed for data placeholder. Some of the application’s model classes that store
    recipe-related details are shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层纯粹由 *资源*、*集合* 和 *Python 类* 组成，这些类可以被存储库层用来创建 CRUD 事务。一些模型类依赖于其他模型，但有些只是为数据占位符设计的独立蓝图。以下是一些存储与食谱相关细节的应用程序模型类示例：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The repository layer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库层
- en: 'This layer is composed of class dependencies, which have access to the *data
    store* or improvised `dict` repositories, just like in our *online recipe system*.
    Together with the model layer, these repository classes build the CRUD transactions
    needed by the REST API. The following is an implementation of `RecipeRepository`
    that has two transactions, namely `insert_recipe()` and `query_recipes()`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层由类依赖组成，可以访问 *数据存储* 或即兴的 `dict` 存储库，就像在我们的 *在线食谱系统* 中一样。与模型层一起，这些存储库类构建了 REST
    API 所需要的 CRUD 事务。以下是一个具有两个事务（即 `insert_recipe()` 和 `query_recipes()`）的 `RecipeRepository`
    实现示例：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Its constructor is used to populate the recipes with some initial data. The
    constructor of an *injectable repository* class plays a role in datastore setup
    and configuration, and this is where we *auto-wire* dependency if there is any.
    Conversely, the implementation includes two `Enum` classes – `Category` and `Origin`
    – which provide lookup values to the recipe’s menu category and place of origin
    respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其构造函数用于填充一些初始数据。*可注入存储库* 类的构造函数在数据存储设置和配置中发挥作用，这也是我们在这里 *自动连接* 依赖的地方。相反，实现包括两个
    `Enum` 类 – `Category` 和 `Origin` – 分别为食谱的菜单类别和产地提供查找值。
- en: The repository factory methods
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储库工厂方法
- en: 'This layer uses the *factory design pattern* to add a more loose coupling design
    between the repository and service layer. Although this approach is optional,
    this is still an option to manage the threshold of interdependency between the
    two layers, especially when there are frequent changes in the performance, processes,
    and results of the CRUD transactions. The following are the repository factory
    methods used by our application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层使用 *工厂设计模式* 在存储库和服务层之间添加了一种更松散的耦合设计。尽管这种方法是可选的，但这仍然是一个管理两层之间相互依赖阈值的选项，尤其是在
    CRUD 事务的性能、流程和结果频繁变化时。以下是我们应用程序使用的存储库工厂方法：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see from the preceding script that `RecipeRepository` is a dependable
    object of the factory methods, which are also injectable components but of the
    service layer. For instance, `get_recipe_repo()` will be wired to a service class
    to pursue the implementation of native services that require some transactions
    from `RecipeRepository`. In a way, we are indirectly wiring the repository class
    to the service layer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的脚本中我们可以看到，`RecipeRepository` 是工厂方法的可靠对象，这些方法也是可注入的组件，但属于服务层。例如，`get_recipe_repo()`
    将与一个服务类连接，以实现需要从 `RecipeRepository` 进行一些事务的原生服务。从某种意义上说，我们间接地将存储库类连接到服务层。
- en: The service layer
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务层
- en: 'This layer has all the application’s services with the domain logic, such as
    our `RecipeService`, which provides business processes and algorithms to `RecipeRepository`.
    The `get_recipe_repo()` factory is injected through its constructor to provide
    CRUD transactions from `RecipeRepository`. The injection strategy used here is
    the function of class dependency, which is depicted in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层包含所有应用程序的服务和领域逻辑，例如我们的 `RecipeService`，它为 `RecipeRepository` 提供业务流程和算法。`get_recipe_repo()`
    工厂通过其构造函数注入，以提供来自 `RecipeRepository` 的 CRUD 事务。这里使用的注入策略是类依赖函数，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The constructor of a typical Python class is always the appropriate place to
    inject components, which can either be a function or class dependable. With the
    preceding `RecipeService`, its `get_recipes()` and `add_recipe()` are realized
    because of the transactions derived from `get_recipe_repo()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Python 类的构造函数始终是注入组件的适当位置，这些组件可以是函数或类依赖。由于前面的 `RecipeService`，其 `get_recipes()`
    和 `add_recipe()` 是通过从 `get_recipe_repo()` 得到的事务实现的。
- en: The REST API and the service layer
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 和服务层
- en: 'The REST API methods can directly inject the service class or factory method
    if it needs to access the service layer. In our application, there is a factory
    method associated with each service class to apply the same strategy used in the
    `RecipeRepository` injection. That is why, in the following script, the `get_recipe_service()`
    method is wired to the REST API instead of `RecipeService`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: REST API方法可以直接注入服务类或工厂方法，如果它需要访问服务层。在我们的应用中，每个服务类都有一个与之关联的工厂方法，以应用在`RecipeRepository`注入中使用的相同策略。这就是为什么在下面的脚本中，`get_recipe_service()`方法被连接到REST
    API而不是`RecipeService`：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `insert_recipe()` is a REST API that accepts a recipe and its ingredients
    from a client for persistency, while `get_all_recipes()` returns `List[Recipe]`
    as a response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_recipe()`是一个REST API，它接受来自客户端的食谱及其成分以进行持久化，而`get_all_recipes()`则返回`List[Recipe]`作为响应。'
- en: The actual project structure
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际项目结构
- en: With the power of DI, we have created an *online recipe system* with an organized
    set of *models*, *repository*, and *service* layers. The project structure shown
    in *Figure 3.3* is quite different from the previous prototypes because of the
    additional layers, but it still has `main.py` and all the packages and modules
    with their respective `APIRouter`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 利用DI（依赖注入）的力量，我们创建了一个包含组织良好的*模型*、*存储库*和*服务*层的*在线食谱系统*。*图3.3*中显示的项目结构由于增加了这些层而与之前的原型有很大不同，但它仍然包含`main.py`以及所有带有相应`APIRouter`的包和模块。
- en: '![Figure 3.3 – The Online Recipe System’s project structure](img/Figure_3.3_B17975.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 在线食谱系统的项目结构](img/Figure_3.3_B17975.jpg)'
- en: Figure 3.3 – The Online Recipe System’s project structure
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 在线食谱系统的项目结构
- en: 'At this point, DI has offered many advantages to FastAPI applications, from
    the engineering of object instantiation to breaking down monolithic components
    to set up loosely coupled structures. But there is only one slight problem: FastAPI’s
    default container. The framework’s container has no easy configuration to set
    all its managed objects to a *singleton* scope. Most applications prefer fetching
    singleton objects to avoid wasting memory in the **Python Virtual Machine** (**PVM**).
    Moreover, the built-in container is not open to a more detailed container configuration,
    such as having a *multiple container* setup. The next series of discussions will
    focus on the limitation of FastAPI’s default container and solutions to overcome
    it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，DI已经为FastAPI应用提供了许多优势，从对象实例化工程到分解单体组件以设置松散耦合的结构。但只有一个小问题：FastAPI的默认容器。框架的容器没有简单的配置来将所有管理的对象设置为*单例*范围。大多数应用更喜欢获取单例对象以避免在**Python虚拟机**（**PVM**）中浪费内存。此外，内置的容器不对更详细的容器配置开放，例如拥有*多个容器*设置。接下来的讨论将集中在FastAPI默认容器的限制以及克服它的解决方案。
- en: Using third-party containers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: DI has a lot to offer to improve our application, but it still depends on the
    framework we use to get the full potential of this design pattern. FastAPI’s container
    is very acceptable to some when the concerns are simply on object management and
    project organization. However, when it comes to configuring the container to add
    more advanced features, it is not feasible for short-term projects, and it will
    be impossible for huge applications due to constraints. So, the practical way
    is to rely on *third-party modules* for the set of utilities needed to support
    all these advancements. So, let us explore these popular external modules that
    integrate seamlessly with FastAPI, the *Dependency Injector* and *Lagom*, which
    we can use to set up a complete and manageable container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: DI为我们提供了很多改进应用的方法，但它仍然依赖于我们使用的框架以充分发挥这种设计模式的潜力。当关注点仅在于对象管理和项目组织时，FastAPI的容器对一些人来说是非常可接受的。然而，当涉及到配置容器以添加更多高级功能时，对于短期项目来说这是不可行的，而对于大型应用来说由于限制将变得不可能。因此，实际的方法是依靠*第三方模块*来提供支持所有这些进步所需的实用工具集。因此，让我们探索这些与FastAPI无缝集成的流行外部模块，即*依赖注入器*和*Lagom*，我们可以使用它们来设置一个完整且可管理的容器。
- en: Using configurable containers – Dependency Injector
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可配置的容器 – 依赖注入器
- en: 'When it comes to configurable containers, the *Dependency Injector* has several
    module APIs that can be used to build variations of custom containers that can
    manage, assemble, and inject objects. But before we can use this module, we need
    to install it first using `pip`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到可配置的容器时，*依赖注入器*有几个模块API可以用来构建自定义容器的变体，这些容器可以管理、组装和注入对象。但在我们能够使用此模块之前，我们需要首先使用`pip`安装它：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The containers and providers module
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器和提供者模块
- en: Among all the API types, *Dependency Injector* is popular with its *containers*
    and *providers*. One of its container types is `DeclarativeContainer`, which can
    be subclassed to contain all its providers. Its providers can be `Factory`, `Dict`,
    `List`, `Callable`, `Singleton`, or other *containers*. Both the `Dict` and `List`
    providers are easy to set up because they only need `list` and `dict` respectively
    to be instantiated. A `Factory` provider, conversely, instantiates any class,
    such as a repository, service, or a generic Python class, while `Singleton` only
    creates one instance per class, which is valid throughout the application’s runtime.
    The `Callable` provider manages function dependencies, while `Container` instantiates
    other containers. Another container type is `DynamicContainer`, which is built
    from a configuration file, databases, or other resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 API 类型中，*依赖注入器* 因其 *容器* 和 *提供者* 而受到欢迎。其容器类型之一是 `DeclarativeContainer`，它可以被继承以包含所有提供者。其提供者可以是
    `Factory`、`Dict`、`List`、`Callable`、`Singleton` 或其他 *容器*。`Dict` 和 `List` 提供者都很容易设置，因为它们只需要分别实例化
    `list` 和 `dict`。相反，`Factory` 提供者可以实例化任何类，例如存储库、服务或通用的 Python 类，而 `Singleton` 只为每个类创建一个实例，该实例在整个应用程序的运行期间都是有效的。`Callable`
    提供者管理函数依赖关系，而 `Container` 实例化其他容器。另一种容器类型是 `DynamicContainer`，它由配置文件、数据库或其他资源构建而成。
- en: The container types
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器类型
- en: 'Aside from these container APIs, the *Dependency Injector* allows us to customize
    a container based on the volume of the dependable objects, project structure,
    or other criteria from the project. The most common style or setup is the single
    declarative container that fits in small-, medium-, or large-scale applications.
    Our *o**nline recipe system* prototype owns a single declarative container, which
    is implemented in the following script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些容器 API 之外，*依赖注入器* 允许我们根据可信对象的数量、项目结构或其他项目标准来自定义容器。最常见的形式或设置是适合小型、中型或大型应用的单一声明式容器。我们的
    *在线食谱系统* 原型拥有一个单一的声明式容器，该容器在以下脚本中实现：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By simply subclassing `DeclarativeContainer`, we can easily create a single
    container, with its instances injected by the various providers previously mentioned.
    `LoginRepository` and `KeywordRepository` are both injected as new instances through
    the Factory provider. `AdminRepository` is an injected singleton object, `get_recipe_names()`
    is an injected function dependable, and `login_details` is an injected dictionary
    containing login credentials.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地继承 `DeclarativeContainer`，我们可以轻松地创建一个容器，其实例通过之前提到的各种提供者注入。`LoginRepository`
    和 `KeywordRepository` 都是通过 Factory 提供者注入的新实例。`AdminRepository` 是一个注入的单例对象，`get_recipe_names()`
    是一个注入的可信函数，而 `login_details` 是一个包含登录凭证的注入字典。
- en: FastAPI and Dependency Injector integration
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FastAPI 和依赖注入器集成
- en: To wire the dependencies to a component through the Dependency Injector, the
    `@inject` decorator is applied. `@inject` is imported from the `dependency_injector.wiring`
    module and is decorated over the *dependent* component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过依赖注入器将依赖关系连接到组件，请应用 `@inject` 装饰器。`@inject` 从 `dependency_injector.wiring`
    模块导入，并装饰在 *依赖* 组件上。
- en: 'Afterward, the instance will be fetched from the container using the `Provide`
    wiring marker. Wiring markers search for the `Provider` object that references
    the injectable in the container, and if it exists, it will prepare for *auto-wiring*.
    Both `@inject` and `Provide` belong to the same API module:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将使用 `Provide` 连接标记从容器中检索实例。连接标记在容器中搜索引用注入对象的 `Provider` 对象，如果存在，它将为 *自动连接*
    准备。`@inject` 和 `Provide` 都属于同一个 API 模块：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The integration happens when the `Depends()` function directive is invoked to
    register the wiring marker and the `Provider` instance to FastAPI. Aside from
    the acknowledgment, the registration adds *type hints* and *Pydantic validation
    rules* to the third-party `Provider` to appropriately wire the injectables into
    FastAPI. The preceding script imports `Container` from its module to wire `KeywordRepository`
    through `@inject`, the wire marker, and the `keywordservice` `Provider` of *Dependency
    Injector*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Depends()` 函数指令以注册连接标记和 `Provider` 实例到 FastAPI 时，发生集成。除了确认之外，注册还向第三方 `Provider`
    添加 *类型提示* 和 *Pydantic 验证规则*，以便适当地将注入对象连接到 FastAPI。前面的脚本从其模块导入 `Container`，通过 `@inject`
    连接标记和 *依赖注入器* 的 `keywordservice` 提供者来连接 `KeywordRepository`。
- en: 'Now, the last piece of the puzzle is to *assemble*, *create*, and *deploy*
    the single declarative container through the FastAPI platform. This last integration
    measure requires instantiating the *container* inside the module where the injections
    happened and then invoking its `wire()` method, which builds the assemblage. Since
    the preceding `insert_recipe_keywords()` is part of `/api/keywords.py`, we should
    add the following lines in the `keywords` module script, particularly at its end
    portion:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一部分是要通过FastAPI平台 *组装*、*创建* 和 *部署* 单个声明性容器。这个最后的集成措施需要在发生注入的模块内部实例化 *容器*，然后调用其
    `wire()` 方法，该方法构建组装。由于前面的 `insert_recipe_keywords()` 是 `/api/keywords.py` 的一部分，我们应该在
    `keywords` 模块脚本中添加以下行，尤其是在其末尾部分：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The multiple container setup
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多容器配置
- en: For large applications, the number of repository transactions and services increases
    based on the functionality and special features of the application. If the single
    declarative type becomes unfeasible for a growing application, then we can always
    replace it with a *multiple-container* setup.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，仓库事务和服务数量根据应用程序的功能和特殊功能而增加。如果单个声明性类型对于不断增长的应用程序来说变得不可行，那么我们总是可以用 *多容器*
    设置来替换它。
- en: 'Dependency Injector allows us to create a separate container for each group
    of services. Our application has created a sample setup found in `/containers/multiple_containers.py`,
    just in case this prototype becomes full-blown. That sample of multiple declarative
    containers is shown as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入器允许我们为每组服务创建一个单独的容器。我们的应用程序创建了一个示例设置，位于 `/containers/multiple_containers.py`
    中，以防这个原型变成完整的产品。以下是如何展示多个声明性容器的示例：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Based on the preceding configuration, the three different instances of `DeclarativeContainer`
    created are `KeywordsContainer`, `AdminContainer`, and `LoginContainer`. The `KeywordsContainer`
    instance will assemble all dependencies related to keywords, `AdminContainer`
    will hold all instances related to administrative tasks, and `LoginContainer`
    for login- and user-related services. Then, there is `RecipeAppContainer`, which
    will consolidate all these containers through DI also.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的配置，创建的三个不同的 `DeclarativeContainer` 实例是 `KeywordsContainer`、`AdminContainer`
    和 `LoginContainer`。`KeywordsContainer` 实例将组装所有与关键词相关的依赖项，`AdminContainer` 将持有所有与行政任务相关的实例，而
    `LoginContainer` 用于登录和用户相关的服务。然后，还有 `RecipeAppContainer`，它将通过DI整合所有这些容器。
- en: 'The injection of the dependencies to the API is like the single declarative
    style, except that the container needs to be indicated in the wiring marker. The
    following is an admin-related API that shows how we wire dependencies to REST
    services:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖注入到API的方式与单个声明性风格类似，只是容器需要在连接标记中指明。以下是一个与行政相关的API，展示了我们如何将依赖项连接到REST服务：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The presence of `admincontainer` inside `Provide` checks first for the container
    of the same name before it fetches the `adminservice` provider that references
    the service dependable. The rest of the details are just the same with a single
    declarative, including the FastAPI integration and object assembly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Provide` 中存在 `admincontainer` 之前，它会首先检查同名容器，然后再获取引用服务依赖项的 `adminservice`
    提供者。其余的细节与单个声明性相同，包括FastAPI集成和对象组装。
- en: What is highlighted here about *Dependency Injector* is just basic configurations
    for simple applications. There are still other features and integrations that
    this module can provide to optimize our application using DI. Now, if we need
    thread-safe and non-blocking but with simple, streamlined, and straightforward
    APIs, setup and configuration, there is the *Lagom* module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关于 *依赖注入器* 的亮点只是简单应用程序的基本配置。还有其他功能和集成可以由这个模块提供，以优化我们的应用程序使用DI。现在，如果我们需要线程安全且非阻塞，但具有简单、精简和直接的API、设置和配置，那么有
    *Lagom* 模块。
- en: Using a simple configuration – Lagom
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单的配置 – Lagom
- en: 'The third-party *Lagom* module is widely used because of its simplicity when
    it comes to wiring dependables. It is also ideal for building asynchronous microservice-driven
    applications because it is thread-safe at runtime. Moreover, it can easily integrate
    into many web frameworks, including FastAPI. To apply its APIs, we need to install
    it first using `pip`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方的 *Lagom* 模块因其连接依赖项时的简单性而广泛使用。它也适用于构建异步微服务驱动应用程序，因为它在运行时是线程安全的。此外，它可以轻松集成到许多Web框架中，包括FastAPI。要应用其API，我们首先需要使用
    `pip` 安装它：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The container
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: 'Containers in *Lagom* are created instantly using the `Container` class from
    its module. Unlike in *Dependency Injector*, Lagom’s containers are created before
    the injection happens inside the module of the REST APIs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Lagom* 中，使用其模块中的 `Container` 类可以即时创建容器。与 *Dependency Injector* 不同，Lagom 的容器是在
    REST API 模块内部注入发生之前创建的：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All dependables are injected into the container through typical instantiation.
    The container behaves like a `dict` when adding new dependables because it also
    uses a *key-value pair* as an entry. When we inject an object, the container needs
    its class name as its *key* and the instance as its *value*. Moreover, the DI
    framework also allows instantiation with arguments if the constructors require
    some parameter values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都通过典型实例化注入到容器中。当添加新的依赖项时，容器表现得像 `dict`，因为它也使用 *键值对* 作为条目。当我们注入一个对象时，容器需要其类名作为
    *键*，实例作为 *值*。此外，DI 框架还允许在构造函数需要一些参数值时使用带参数的实例化。
- en: The FastAPI and Lagom integration
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI 和 Lagom 集成
- en: 'Before the wiring happens, integration to the FastAPI platform must come first
    by instantiating a new API class called `FastApiIntegration`, which is found in
    the `lagom.integrations.fast_api` module. It takes `container` as a required parameter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行接线之前，必须首先通过实例化一个名为 `FastApiIntegration` 的新 API 类来集成到 FastAPI 平台，该类位于 `lagom.integrations.fast_api`
    模块中。它需要一个名为 `container` 的必需参数：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The dependables
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The instance of `FastAPIIntegration` has a `depends()` method, which we will
    use to perform the injection. One of the best features of Lagom is its easy and
    seamless integration mechanism into any framework. Thus, wiring the dependencies
    will not need FastAPI’s `Depends()` function anymore:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`FastAPIIntegration` 实例有一个 `depends()` 方法，我们将使用它来进行注入。Lagom 的一个最佳特性是它易于无缝集成到任何框架中。因此，不再需要
    FastAPI 的 `Depends()` 函数来连接依赖项：'
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding `report_recipe()` utilizes `BadRecipeRepository` as an injectable
    service. Since it is part of the container, *Lagom*’s `depends()` function will
    search for the object in the container, and then it will be wired to the API service,
    if that exists, to save the complaints to the `dict` datastore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `report_recipe()` 方法使用了 `BadRecipeRepository` 作为可注入的服务。由于它是容器的一部分，Lagom
    的 `depends()` 函数将在容器中搜索该对象，然后如果存在，它将被连接到 API 服务，以将投诉保存到 `dict` 数据存储中。
- en: 'So far, these two third-party modules are the most popular and elaborative
    when employing DI in our applications. These modules may change through future
    updates, but one thing is for sure: IoC and DI design patterns will always be
    the powerful solution in managing memory usage in an application. Let us now discusses
    issues surrounding memory space, container, and object assembly.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这两个第三方模块在我们应用中使用 DI 时是最受欢迎和详尽的。这些模块可能会通过未来的更新而改变，但有一点是肯定的：IoC 和 DI 设计模式将始终是管理应用内存使用的强大解决方案。现在让我们讨论围绕内存空间、容器和对象组装的问题。
- en: Scoping of dependables
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项的作用域
- en: In FastAPI, the scope of dependables can be either a new instance or a singleton.
    FastAPI’s DI does not support the creation of singleton objects by default. In
    every execution of an API service with dependencies, FastAPI always fetches a
    new instance of each wired dependable, which can be proven by getting the *object
    ID* using `id()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，依赖项的作用域可以是新实例或单例。FastAPI 的依赖注入默认不支持创建单例对象。在每次执行带有依赖项的 API 服务时，FastAPI
    总是获取每个已连接依赖项的新实例，这可以通过使用 `id()` 获取 *对象 ID* 来证明。
- en: A `singleton` object is created only once by a container, no matter how many
    times the framework injects it. Its *object ID* remains the same the entire runtime
    of the application. Services and repository classes are preferred to be singleton
    to control the increase of memory utilization of the application. And since it
    is not easy to create a singleton with FastAPI, we can use either *Dependency
    Injector* or *Lagom*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 单例对象由容器创建一次，无论框架注入多少次。其 *对象 ID* 在整个应用运行期间保持不变。服务和存储库类通常被设置为单例，以控制应用内存使用的增加。由于使用
    FastAPI 创建单例并不容易，我们可以使用 *Dependency Injector* 或 *Lagom*。
- en: 'There is a `Singleton` provider in Dependency Injector that is responsible
    for the creation of singleton dependencies. This provider was mentioned already
    during the discussions on its `DeclarativeContainer` setup. With Lagom, there
    are two ways to create singleton injectables: (a) using its `Singleton` class,
    and (b) through the constructor of `FastAPIIntegration`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Dependency Injector 中有一个 `Singleton` 提供者，负责创建单例依赖项。在讨论其 `DeclarativeContainer`
    设置时已经提到了这个提供者。使用 Lagom，有两种创建单例注入的方式：(a) 使用其 `Singleton` 类，和 (b) 通过 `FastAPIIntegration`
    构造函数。
- en: 'The `Singleton` class wraps the instance of the dependency before injecting
    it into the container. The following sample snippet shows one example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton` 类在将实例注入容器之前，会包装依赖项的实例。以下示例代码片段展示了其中一个例子：'
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The other way is to declare the dependency in the `request_singletons` parameter
    of the constructor of `FastAPIIntegration`. The following snippet shows how it
    is done:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是在 `FastAPIIntegration` 构造函数的 `request_singletons` 参数中声明依赖项。以下代码片段展示了如何实现：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By the way, the `request_singletons` parameter is a `List` type, so it will
    allow us to declare at least one dependable when we want to make singletons.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`request_singletons` 参数是 `List` 类型，因此当我们想要创建单例时，它将允许我们声明至少一个依赖项。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One aspect that makes a framework easy and practical to use is its support for
    the IoC principle. FastAPI has a built-in container that we can utilize to establish
    dependency among components. The use of a *DI* pattern to integrate all these
    components through wiring is a strong prerequisite in building microservice-driven
    applications. From simple injection using `Depends()`, we can extend DI to build
    pluggable components for database integration, authentication, security, and unit
    testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使框架易于使用且实用的一个方面是其对 IoC 原则的支持。FastAPI 内置了一个容器，我们可以利用它来建立组件之间的依赖关系。通过使用 *DI* 模式通过连接线整合所有这些组件是一个构建微服务驱动应用程序的强烈先决条件。从简单的
    `Depends()` 注入开始，我们可以扩展 DI 来构建用于数据库集成、身份验证、安全和单元测试的可插拔组件。
- en: This chapter also introduced some third-party modules such as *Dependency Injector*
    and *Lagom* that can design and customize containers. Because of the limitations
    of FastAPI on DI, there are external libraries that can help extend its responsibility
    to assemble, control, and manage object creation in a container. These third-party
    APIs can also create singleton objects, which can help decrease the heap size
    in the PVM.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了一些第三方模块，如 *Dependency Injector* 和 *Lagom*，它们可以设计和定制容器。由于 FastAPI 在 DI
    方面的限制，存在外部库可以帮助扩展其责任，以在容器中组装、控制和管理工作对象的创建。这些第三方 API 还可以创建单例对象，这有助于减少 PVM 中的堆大小。
- en: Aside from performance tuning and memory management, DI can contribute to the
    organization of a project, especially huge applications. The addition of model,
    repository, and service layers is a remarkable effect of creating dependencies.
    Injection opens the development to other design patterns, such as factory method,
    service, and data access object patterns. In the next chapter, we will start to
    build some microservice-related components based on the core design patterns of
    microservices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能调整和内存管理之外，DI 还可以促进项目的组织，尤其是大型应用程序。添加模型、存储库和服务层是创建依赖项的显著效果。注入使开发面向其他设计模式，例如工厂方法、服务和数据访问对象模式。在下一章中，我们将开始基于微服务的核心设计模式构建一些与微服务相关的组件。
