- en: Chapter 2. Views and URLconfs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。视图和URLconfs
- en: In the previous chapter, I explained how to set up a Django project and run
    the Django development server. In this chapter, you'll learn the basics of creating
    dynamic web pages with Django.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我解释了如何设置Django项目并运行Django开发服务器。在本章中，你将学习使用Django创建动态网页的基础知识。
- en: 'Your first Django-powered page: Hello World'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Django网页：Hello World
- en: 'As our first goal, let''s create a web page that outputs that famous example
    message: **Hello World**. If you were publishing a simple **Hello World** web
    page without a web framework, you''d simply type `Hello world` into a text file,
    call it `hello.html`, and upload it to a directory on a web server somewhere.
    Notice in that process you''ve specified two key pieces of information about that
    web page: its contents (the string `Hello world`) and its URL (for example, `http://www.example.com/hello.html`).
    With Django, you specify those same two things, but in a different way. The contents
    of the page are produced by a **view function**, and the URL is specified in a
    **URLconf**. First, let''s write our Hello World view function.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个目标，让我们创建一个网页，输出那个著名的例子消息：**Hello World**。如果你要发布一个简单的**Hello World**网页而没有使用Web框架，你只需在一个文本文件中输入
    `Hello world`，将其命名为 `hello.html`，然后上传到Web服务器的某个目录中。请注意，在这个过程中，你已经指定了关于该网页的两个关键信息：它的内容（字符串
    `Hello world`）和它的URL（例如 `http://www.example.com/hello.html`）。使用Django，你以不同的方式指定相同的两个内容。页面的内容由**视图函数**生成，URL在**URLconf**中指定。首先，让我们编写我们的Hello
    World视图函数。
- en: Your first view
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个视图
- en: 'Within the `mysite` directory that we created in the last chapter, create an
    empty file called `views.py`. This Python module will contain our views for this
    chapter. Our Hello World view is simple. Here''s the entire function, plus import
    statements, which you should type into the `views.py` file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在上一章中创建的`mysite`目录中，创建一个名为`views.py`的空文件。这个Python模块将包含本章的视图。我们的Hello World视图很简单。以下是整个函数以及导入语句，你应该将其输入到`views.py`文件中：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s step through this code one line at a time:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这段代码：
- en: First, we import the class `HttpResponse`, which lives in the `django.http`
    module. We need to import this class because it's used later in our code.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们导入了`django.http`模块中的`HttpResponse`类。我们需要导入这个类，因为它在我们的代码中稍后会用到。
- en: Next, we define a function called `hello`-the view function.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为 `hello` 的函数-视图函数。
- en: Each view function takes at least one parameter, called `request` by convention.
    This is an object that contains information about the current web request that
    has triggered this view, and is an instance of the class `django.http.HttpRequest`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图函数至少需要一个参数，按照惯例称为`request`。这是一个包含有关触发此视图的当前Web请求的信息的对象，是`django.http.HttpRequest`类的实例。
- en: In this example, we don't do anything with `request`, but it must be the first
    parameter of the view nonetheless. Note that the name of the view function doesn't
    matter; it doesn't have to be named in a certain way in order for Django to recognize
    it. We're calling it `hello` here, because that name clearly indicates the gist
    of the view, but it could just as well be named `hello_wonderful_beautiful_world`,
    or something equally revolting. The next section, *Your First URLconf*", will
    shed light on how Django finds this function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们并没有对 `request` 做任何操作，但它仍然必须是视图的第一个参数。请注意，视图函数的名称并不重要；它不必以某种方式命名，以便Django识别它。我们在这里称它为
    `hello`，因为这个名称清楚地表示了视图的要点，但它也可以被命名为 `hello_wonderful_beautiful_world`，或者其他同样令人讨厌的名称。接下来的部分，“你的第一个URLconf”，将解释Django如何找到这个函数。
- en: 'The function is a simple one-liner: it merely returns an `HttpResponse` object
    that has been instantiated with the text `Hello world`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个简单的一行代码：它只是返回一个用文本 `Hello world` 实例化的 `HttpResponse` 对象。
- en: 'The main lesson here is this: a view is just a Python function that takes an
    `HttpRequest` as its first parameter and returns an instance of `HttpResponse`.
    In order for a Python function to be a Django view, it must do these two things.
    (There are exceptions, but we''ll get to those later.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要教训是：视图只是一个以`HttpRequest`作为第一个参数并返回`HttpResponse`实例的Python函数。为了使Python函数成为Django视图，它必须做这两件事。（有例外情况，但我们稍后会讨论。）
- en: Your first URLconf
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个URLconf
- en: If, at this point, you ran `python manage.py runserver` again, you'd still see
    the **Welcome to Django** message, with no trace of our Hello World view anywhere.
    That's because our `mysite` project doesn't yet know about the `hello` view; we
    need to tell Django explicitly that we're activating this view at a particular
    URL. Continuing our previous analogy of publishing static HTML files, at this
    point we've created the HTML file but haven't uploaded it to a directory on the
    server yet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时再次运行 `python manage.py runserver`，你仍然会看到**欢迎使用Django**的消息，但没有我们的Hello World视图的任何痕迹。这是因为我们的`mysite`项目还不知道`hello`视图；我们需要明确告诉Django我们正在激活这个视图的特定URL。继续我们之前关于发布静态HTML文件的类比，此时我们已经创建了HTML文件，但还没有将其上传到服务器上的目录中。
- en: To hook a view function to a particular URL with Django, we use a URLconf. A
    URLconf is like a table of contents for your Django-powered web site. Basically,
    it's a mapping between URLs and the view functions that should be called for those
    URLs. It's how you tell Django, *For this URL, call this code, and for that URL,
    call that code*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将视图函数与Django中的特定URL挂钩，我们使用URLconf。URLconf就像是Django网站的目录。基本上，它是URL和应该为这些URL调用的视图函数之间的映射。这是告诉Django的方式，*对于这个URL，调用这段代码，对于那个URL，调用那段代码*。
- en: 'For example, when somebody visits the URL `/foo/`, call the view function `foo_view()`,
    which lives in the Python module `views.py`. When you executed `django-admin startproject`
    in the previous chapter, the script created a URLconf for you automatically: the
    file `urls.py`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当有人访问URL `/foo/` 时，调用视图函数 `foo_view()`，它位于Python模块 `views.py` 中。在上一章中执行 `django-admin
    startproject` 时，脚本会自动为您创建一个URLconf：文件 `urls.py`。
- en: 'By default, it looks something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它看起来像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we ignore the documentation comments at the top of the file, here''s the
    essence of a URLconf:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略文件顶部的文档注释，这就是一个URLconf的本质：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s step through this code one line at a time:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这段代码：
- en: 'The first line imports two functions from the `django.conf.urls` module: `include`
    which allows you to include a full Python import path to another URLconf module,
    and `url` which uses a regular expression to pattern match the URL in your browser
    to a module in your Django project.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行从`django.conf.urls`模块中导入了两个函数：`include`允许你包含另一个URLconf模块的完整Python导入路径，`url`使用正则表达式将浏览器中的URL模式匹配到Django项目中的模块。
- en: The second line calls the function `admin` from the `django.contrib` module.
    This function is called by the `include` function to load the URLs for the Django
    admin site.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行调用了`django.contrib`模块中的`admin`函数。这个函数是由`include`函数调用的，用于加载Django管理站点的URL。
- en: The third line is `urlpatterns`-a simple list of `url()` instances.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行是`urlpatterns`-一个简单的`url()`实例列表。
- en: 'The main thing to note here is the variable `urlpatterns`, which Django expects
    to find in your URLconf module. This variable defines the mapping between URLs
    and the code that handles those URLs. To add a URL and view to the URLconf, just
    add a mapping between a URL pattern and the view function. Here''s how to hook
    in our `hello` view:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的主要是变量`urlpatterns`，Django希望在你的URLconf模块中找到它。这个变量定义了URL和处理这些URL的代码之间的映射关系。要向URLconf添加URL和视图，只需在URL模式和视图函数之间添加映射。下面是如何连接我们的`hello`视图：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We made two changes here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了两个更改：
- en: First, we imported the `hello` view from its module-`mysite/views.py`, which
    translates into `mysite.views` in Python import syntax. (This assumes `mysite/views.py`
    is on your Python path.)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们从模块`mysite/views.py`中导入了`hello`视图，这在Python导入语法中转换为`mysite.views`。（这假设`mysite/views.py`在你的Python路径上。）
- en: Next, we added the line `url(r'^hello/$', hello),` to `urlpatterns`. This line
    is referred to as a URLpattern. The `url()` function tells Django how to handle
    the URL that you are configuring. The first argument is a pattern-matching string
    (a regular expression; more on this in a bit) and the second argument is the view
    function to use for that pattern. `url()` can take other optional arguments as
    well, which we'll cover in more depth in [Chapter 7](ch07.xhtml "Chapter 7. Advanced
    Views and URLconfs"), *Advanced Views and Urlconfs*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们在`urlpatterns`中添加了一行`url(r'^hello/$', hello),`。这行被称为URLpattern。`url()`函数告诉Django如何处理你正在配置的URL。第一个参数是一个模式匹配字符串（一个正则表达式；稍后会详细介绍），第二个参数是用于该模式的视图函数。`url()`还可以接受其他可选参数，我们将在[第7章](ch07.xhtml
    "第7章.高级视图和URLconfs")中更深入地介绍，*高级视图和URLconfs*。
- en: One more important detail we've introduced here is that `r` character in front
    of the regular expression string. This tells Python that the string is a **raw
    string**-its contents should not interpret backslashes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入的另一个重要细节是正则表达式字符串前面的`r`字符。这告诉Python该字符串是一个**原始字符串**-它的内容不应解释反斜杠。
- en: In normal Python strings, backslashes are used for escaping special characters-such
    as in the string `\n`, which is a one-character string containing a newline. When
    you add the `r` to make it a raw string, Python does not apply its backslash escaping-so,
    `r'\n'` is a two-character string containing a literal backslash and a lowercase
    `n`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的Python字符串中，反斜杠用于转义特殊字符，比如字符串`\n`，它是一个包含换行符的单字符字符串。当你添加`r`使其成为原始字符串时，Python不会应用反斜杠转义，因此`r'\n'`是一个包含字面反斜杠和小写`n`的两个字符字符串。
- en: There's a natural collision between Python's usage of backslashes and the backslashes
    that are found in regular expressions, so it's best practice to use raw strings
    any time you're defining a regular expression in Django.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python的反斜杠用法与正则表达式中的反斜杠之间存在自然冲突，因此最好在Django中定义正则表达式时始终使用原始字符串。
- en: In a nutshell, we just told Django that any request to the URL `/hello/` should
    be handled by the `hello` view function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们只是告诉Django，任何对URL`/hello/`的请求都应该由`hello`视图函数处理。
- en: 'It''s worth discussing the syntax of this URLpattern, as it may not be immediately
    obvious. Although we want to match the URL `/hello/`, the pattern looks a bit
    different than that. Here''s why:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论的是这个URLpattern的语法，因为它可能不是立即显而易见的。虽然我们想匹配URL`/hello/`，但模式看起来与此有些不同。原因如下：
- en: Django removes the slash from the front of every incoming URL before it checks
    the URLpatterns. This means that our URLpattern doesn't include the leading slash
    in `/hello/`. At first, this may seem unintuitive, but this requirement simplifies
    things-such as the inclusion of URLconfs within other URLconfs, which we'll cover
    in [Chapter 7](ch07.xhtml "Chapter 7. Advanced Views and URLconfs"), *Advanced
    Views and URLconfs*.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django在检查URLpatterns之前会从每个传入的URL中删除斜杠。这意味着我们的URLpattern不包括`/hello/`中的前导斜杠。起初，这可能看起来有点不直观，但这个要求简化了一些事情，比如在其他URLconfs中包含URLconfs，我们将在[第7章](ch07.xhtml
    "第7章.高级视图和URLconfs")中介绍，*高级视图和URLconfs*。
- en: 'The pattern includes a caret (^) and a dollar sign ($). These are regular expression
    characters that have a special meaning: the caret means *require that the pattern
    matches the start of the string*, and the dollar sign means *require that the
    pattern matches the end of the string*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式包括插入符（^）和美元符号（$）。这些是具有特殊含义的正则表达式字符：插入符表示*要求模式与字符串的开头匹配*，美元符号表示*要求模式与字符串的结尾匹配*。
- en: This concept is best explained by example. If we had instead used the pattern
    `^hello/` (without a dollar sign at the end), then any URL starting with `/hello/`
    would match, such as `/hello/foo` and `/hello/bar`, not just `/hello/`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念最好通过例子来解释。如果我们使用的是模式`^hello/`（末尾没有美元符号），那么任何以`/hello/`开头的URL都会匹配，比如`/hello/foo`和`/hello/bar`，而不仅仅是`/hello/`。
- en: Similarly, if we had left off the initial caret character (that is, `hello/$`),
    Django would match any URL that ends with `hello/`, such as `/foo/bar/hello/`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们省略了初始的插入符号（即`hello/$`），Django将匹配任何以`hello/`结尾的URL，比如`/foo/bar/hello/`。
- en: If we had simply used `hello/`, without a caret or dollar sign, then any URL
    containing `hello/` would match, such as `/foo/hello/bar`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是使用了`hello/`，没有插入符号或美元符号，那么包含`hello/`的任何URL都会匹配，比如`/foo/hello/bar`。
- en: Thus, we use both the caret and dollar sign to ensure that only the URL `/hello/`
    matches-nothing more, nothing less. Most of your URLpatterns will start with carets
    and end with dollar signs, but it's nice to have the flexibility to perform more
    sophisticated matches.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们同时使用插入符号和美元符号来确保只有URL`/hello/`匹配-没有多余，也没有少了。大多数URLpatterns将以插入符号开头，并以美元符号结尾，但具有执行更复杂匹配的灵活性也是很好的。
- en: You may be wondering what happens if someone requests the URL `/hello` (that
    is, without a trailing slash). Because our URLpattern requires a trailing slash,
    that URL would not match. However, by default, any request to a URL that doesn't
    match a URLpattern and doesn't end with a slash will be redirected to the same
    URL with a trailing slash (This is regulated by the `APPEND_SLASH` Django setting,
    which is covered in [Appendix D](apd.xhtml "Appendix D. Settings"), *Settings*).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道如果有人请求URL`/hello`（即没有尾随斜杠），会发生什么。因为我们的URLpattern需要一个尾随斜杠，那个URL就不会匹配。然而，默认情况下，任何不匹配URLpattern并且不以斜杠结尾的URL请求都会被重定向到相同的URL，但是以斜杠结尾（这由`APPEND_SLASH`
    Django设置规定，详见[附录D](apd.xhtml "附录 D. 设置")，*设置*）。
- en: 'The other thing to note about this URLconf is that we''ve passed the `hello`
    view function as an object without calling the function. This is a key feature
    of Python (and other dynamic languages): functions are first-class objects, which
    means you can pass them around just like any other variables. Cool stuff, eh?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个URLconf的另一件事是，我们将`hello`视图函数作为对象传递而不调用函数。这是Python（和其他动态语言）的一个关键特性：函数是一级对象，这意味着你可以像任何其他变量一样传递它们。很酷，对吧？
- en: To test our changes to the URLconf, start the Django development server, as
    you did in [Chapter 1](ch01.xhtml "Chapter 1. Introduction to Django and Getting
    Started"), *Introduction to Django and Getting Started*, by running the command
    `python manage.py runserver`. (If you left it running, that's fine, too. The development
    server automatically detects changes to your Python code and reloads as necessary,
    so you don't have to restart the server between changes.) The server is running
    at the address `http://127.0.0.1:8000/`, so open up a web browser and go to `http://127.0.0.1:8000/hello/`.
    You should see the text **Hello World**-the output of your Django view (*Figure
    2.1*).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们对URLconf的更改，启动Django开发服务器，就像你在[第1章](ch01.xhtml "第 1 章. Django简介和入门") *Django简介和入门*中所做的那样，通过运行命令`python
    manage.py runserver`。（如果你让它保持运行状态，也没关系。开发服务器会自动检测Python代码的更改并在必要时重新加载，因此你不必在更改之间重新启动服务器。）服务器正在运行在地址`http://127.0.0.1:8000/`，所以打开一个网络浏览器，转到`http://127.0.0.1:8000/hello/`。你应该会看到文本**Hello
    World**-这是你的Django视图的输出（*图2.1*）。
- en: '![Your first URLconf](img/image_02_001.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![你的第一个URLconf](img/image_02_001.jpg)'
- en: 'Figure 2.1: Hooray! Your first Django view'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：耶！你的第一个Django视图
- en: Regular expressions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Regular expressions (or regexes) are a compact way of specifying patterns in
    text. While Django URLconfs allow arbitrary regexes for powerful URL matching,
    you'll probably only use a few regex symbols in practice. *Table 2.1* lists a
    selection of common symbols.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（或regexes）是一种在文本中指定模式的简洁方式。虽然Django的URLconfs允许任意的正则表达式进行强大的URL匹配，但实际上你可能只会使用一些正则表达式符号。*表2.1*列出了一些常见符号。
- en: 'Table 2.1: Common regex symbols'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：常见的正则表达式符号
- en: '| **Symbol** | **Matches** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **匹配** |'
- en: '| `.` (dot) | Any single character |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `.`（点） | 任意单个字符 |'
- en: '| `\d` | Any single digit |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任意单个数字 |'
- en: '| `[A-Z]` | Any character between `A` and `Z` (uppercase) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z]` | `A`和`Z`之间的任何字符（大写） |'
- en: '| `[a-z]` | Any character between `a` and `z` (lowercase) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `[a-z]` | `a`和`z`之间的任何字符（小写） |'
- en: '| `[A-Za-z]` | Any character between `a` and `z` (case-insensitive) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Za-z]` | `a`和`z`之间的任何字符（不区分大小写） |'
- en: '| `+` | One or more of the previous expression (for example, `\d+` matches
    one or more digits) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前一个表达式的一个或多个（例如，`\d+`匹配一个或多个数字） |'
- en: '| `[^/]+` | One or more characters until (and not including) a forward slash
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `[^/]+` | 一个或多个字符，直到（但不包括）斜杠 |'
- en: '| `?` | Zero or one of the previous expression (for example, `\d?` matches
    zero or one digits) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 前一个表达式的零个或一个（例如，`\d?`匹配零个或一个数字） |'
- en: '| `*` | Zero or more of the previous expression (for example, `\d*` matches
    zero, one or more than one digit) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前一个表达式的零个或多个（例如，`\d*`匹配零个、一个或多个数字） |'
- en: '| `{1,3}` | Between one and three (inclusive) of the previous expression (for
    example, `\d{1,3}` matches one, two or three digits) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `{1,3}` | 前一个表达式的一个到三个（包括）（例如，`\d{1,3}`匹配一个、两个或三个数字） |'
- en: For more on regular expressions, see the Python regex documentation, visit [https://docs.python.org/3.4/library/re.html](https://docs.python.org/3.4/library/re.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关正则表达式的更多信息，请参阅Python正则表达式文档，访问[https://docs.python.org/3.4/library/re.html](https://docs.python.org/3.4/library/re.html)。
- en: A quick note about 404 errors
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于404错误的快速说明
- en: 'At this point, our URLconf defines only a single URLpattern: the one that handles
    requests to the URL `/hello/`. What happens when you request a different URL?
    To find out, try running the Django development server and visiting a page such
    as `http://127.0.0.1:8000/goodbye/`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的URLconf只定义了一个URLpattern：处理URL`/hello/`的URLpattern。当你请求不同的URL时会发生什么？要找出来，尝试运行Django开发服务器，并访问诸如`http://127.0.0.1:8000/goodbye/`之类的页面。
- en: You should see a **Page not found** message (*Figure 2.2*). Django displays
    this message because you requested a URL that's not defined in your URLconf.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个**页面未找到**的消息（*图2.2*）。Django显示这个消息是因为你请求了一个在你的URLconf中没有定义的URL。
- en: '![A quick note about 404 errors](img/image_02_002.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![关于404错误的快速说明](img/image_02_002.jpg)'
- en: 'Figure 2.2: Django''s 404 page'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Django的404页面
- en: The utility of this page goes beyond the basic 404 error message. It also tells
    you precisely which URLconf Django used and every pattern in that URLconf. From
    that information, you should be able to tell why the requested URL threw a 404.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的实用性不仅仅体现在基本的404错误消息上。它还会告诉您Django使用了哪个URLconf以及该URLconf中的每个模式。通过这些信息，您应该能够知道为什么请求的URL会引发404错误。
- en: Naturally, this is sensitive information intended only for you, the web developer.
    If this were a production site deployed live on the Internet, you wouldn't want
    to expose that information to the public. For that reason, this **Page not found**
    page is only displayed if your Django project is in **debug mode**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次创建Django项目时，每个Django项目都处于调试模式。如果项目不处于调试模式，Django会输出不同的404响应。这是敏感信息，仅供您作为Web开发人员使用。如果这是一个部署在互联网上的生产站点，您不希望将这些信息暴露给公众。因此，只有在您的Django项目处于**调试模式**时才会显示**Page
    not found**页面。
- en: I'll explain how to deactivate debug mode later. For now, just know that every
    Django project is in debug mode when you first create it, and if the project is
    not in debug mode, Django outputs a different 404 response.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在后面解释如何关闭调试模式。现在只需知道每个Django项目在创建时都处于调试模式，如果项目不处于调试模式，Django会输出不同的404响应。
- en: A quick note about the site root
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于站点根目录的一点说明
- en: As explained in the last section, you'll see a 404 error message if you view
    the site root-`http://127.0.0.1:8000/`. Django doesn't magically add anything
    to the site root; that URL is not special-cased in any way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中已经解释过，如果您查看站点根目录`http://127.0.0.1:8000/`，您将看到一个404错误消息。Django不会在站点根目录自动添加任何内容；该URL并没有特殊处理。
- en: It's up to you to assign it to a URLpattern, just like every other entry in
    your URLconf. The URLpattern to match the site root is a bit unintuitive, though,
    so it's worth mentioning.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于您将其分配给一个URL模式，就像URLconf中的每个其他条目一样。匹配站点根目录的URL模式有点不直观，因此值得一提。
- en: 'When you''re ready to implement a view for the site root, use the URLpattern
    `^$`, which matches an empty string. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备为站点根目录实现一个视图时，使用URL模式`^$`，它匹配空字符串。例如：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How Django processes a request
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django如何处理请求
- en: Before continuing to our second view function, let's pause to learn a little
    more about how Django works. Specifically, when you view your **Hello World**
    message by visiting `http://127.0.0.1:8000/hello/` in your web browser, what does
    Django do behind the scenes? It all starts with the **settings file**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的第二个视图函数之前，让我们暂停一下，了解一下Django是如何工作的。具体来说，当您在Web浏览器中访问`http://127.0.0.1:8000/hello/`以查看您的**Hello
    World**消息时，Django在幕后做了什么？一切都始于**settings文件**。
- en: 'When you run `python manage.py runserver`, the script looks for a file called
    `settings.py` in the inner `mysite` directory. This file contains all sorts of
    configuration for this particular Django project, all in uppercase: `TEMPLATE_DIRS`,
    `DATABASES`, and so on. The most important setting is called `ROOT_URLCONF`. `ROOT_URLCONF`
    tells Django which Python module should be used as the URLconf for this web site.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`python manage.py runserver`时，脚本会在内部`mysite`目录中查找名为`settings.py`的文件。该文件包含了这个特定Django项目的各种配置，全部都是大写的：`TEMPLATE_DIRS`、`DATABASES`等等。最重要的设置叫做`ROOT_URLCONF`。`ROOT_URLCONF`告诉Django应该使用哪个Python模块作为这个网站的URLconf。
- en: 'Remember when `django-admin startproject` created the files `settings.py` and
    `urls.py`? The auto-generated `settings.py` contains a `ROOT_URLCONF` setting
    that points to the auto-generated `urls.py`. Open the `settings.py` file and see
    for yourself; it should look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`django-admin startproject`创建了`settings.py`和`urls.py`文件吗？自动生成的`settings.py`包含一个指向自动生成的`urls.py`的`ROOT_URLCONF`设置。打开`settings.py`文件，您会看到它应该是这样的。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This corresponds to the file `mysite/urls.py`. When a request comes in for a
    particular URL-say, a request for `/hello/`-Django loads the URLconf pointed to
    by the `ROOT_URLCONF` setting. Then it checks each of the URLpatterns in that
    URLconf, in order, comparing the requested URL with the patterns one at a time,
    until it finds one that matches.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于文件`mysite/urls.py`。当请求特定URL（比如请求`/hello/`）时，Django加载`ROOT_URLCONF`设置指向的URLconf。然后，它按顺序检查该URLconf中的每个URL模式，逐个将请求的URL与模式进行比较，直到找到一个匹配的模式。
- en: When it finds one that matches, it calls the view function associated with that
    pattern, passing it an `HttpRequest` object as the first parameter. (We'll cover
    the specifics of `HttpRequest` later.) As we saw in our first view example, a
    view function must return an `HttpResponse`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到匹配的URL模式时，它调用与该模式相关联的视图函数，并将`HttpRequest`对象作为第一个参数传递给它（我们将在后面介绍`HttpRequest`的具体内容）。正如我们在第一个视图示例中看到的，视图函数必须返回一个`HttpResponse`。
- en: 'Once it does this, Django does the rest, converting the Python object to a
    proper web response with the appropriate HTTP headers and body (that is, the content
    of the web page). In summary:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样做，Django就会完成剩下的工作，将Python对象转换为适当的Web响应，包括适当的HTTP标头和正文（即网页内容）。总之：
- en: A request comes in to `/hello/`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个请求进入`/hello/`。
- en: Django determines the root URLconf by looking at the `ROOT_URLCONF` setting.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django通过查看`ROOT_URLCONF`设置来确定根URLconf。
- en: Django looks at all of the URLpatterns in the URLconf for the first one that
    matches `/hello/`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django查看URLconf中的所有URL模式，找到第一个与`/hello/`匹配的模式。
- en: If it finds a match, it calls the associated view function.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，它会调用相关的视图函数。
- en: The view function returns an `HttpResponse`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图函数返回一个`HttpResponse`。
- en: Django converts the `HttpResponse` to the proper HTTP response, which results
    in a web page.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django将`HttpResponse`转换为适当的HTTP响应，从而生成一个网页。
- en: You now know the basics of how to make Django-powered pages. It's quite simple,
    really just write view functions and map them to URLs via URLconfs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何制作Django网页的基础知识。实际上很简单，只需编写视图函数并通过URLconf将其映射到URL。
- en: 'Your second view: dynamic content'
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第二个视图：动态内容
- en: Our Hello World view was instructive in demonstrating the basics of how Django
    works, but it wasn't an example of a dynamic web page, because the content of
    the page is always the same. Every time you view `/hello/`, you'll see the same
    thing; it might as well be a static HTML file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Hello World视图在演示Django工作基础方面很有启发性，但它并不是动态网页的一个例子，因为页面的内容始终相同。每次查看`/hello/`时，您都会看到相同的内容；它可能就像是一个静态HTML文件。
- en: 'For our second view, let''s create something more dynamic-a web page that displays
    the current date and time. This is a nice, simple next step, because it doesn''t
    involve a database or any user input-just the output of your server''s internal
    clock. It''s only marginally more exciting than Hello World, but it''ll demonstrate
    a few new concepts. This view needs to do two things: calculate the current date
    and time, and return an `HttpResponse` containing that value. If you have experience
    with Python, you know that Python includes a `datetime` module for calculating
    dates. Here''s how to use it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个视图，让我们创建一个更加动态的东西-一个显示当前日期和时间的网页。这是一个不错的、简单的下一步，因为它不涉及数据库或任何用户输入-只涉及服务器内部时钟的输出。它只比Hello
    World有点更有趣，但它将演示一些新概念。这个视图需要做两件事：计算当前日期和时间，并返回包含该值的`HttpResponse`。如果您有Python经验，您就会知道Python包括一个用于计算日期的`datetime`模块。以下是如何使用它：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s simple enough, and it has nothing to do with Django. It''s just Python
    code. (We want to emphasize that you should be aware of what code is just Python
    vs. code that is Django-specific. As you learn Django, we want you to be able
    to apply your knowledge to other Python projects that don''t necessarily use Django.)
    To make a Django view that displays the current date and time, we just need to
    hook this `datetime.datetime.now()` statement into a view and return an `HttpResponse`.
    Here''s what the updated `views.py` looks like:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，与Django无关。这只是Python代码。（我们想强调的是，您应该知道哪些代码只是Python代码，哪些是特定于Django的代码。当您学习Django时，我们希望您能够将您的知识应用到其他不一定使用Django的Python项目中。）要创建一个显示当前日期和时间的Django视图，我们只需要将`datetime.datetime.now()`语句连接到一个视图并返回一个`HttpResponse`。更新后的`views.py`如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's step through the changes we've made to `views.py` to accommodate the `current_datetime`
    view.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解我们对`views.py`所做的更改，以适应`current_datetime`视图。
- en: We've added an `import datetime` to the top of the module, so we can calculate
    dates.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在模块顶部添加了`import datetime`，这样我们就可以计算日期了。
- en: The new `current_datetime` function calculates the current date and time, as
    a `datetime.datetime` object, and stores that as the local variable `now`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`current_datetime`函数计算当前日期和时间，作为`datetime.datetime`对象，并将其存储为本地变量`now`。
- en: The second line of code within the view constructs an HTML response using Python's
    **format-string** capability. The `%s` within the string is a placeholder, and
    the percent sign after the string means Replace the `%s` in the following string
    with the value of the variable `now`. The `now` variable is technically a `datetime.datetime`
    object, not a string, but the `%s` format character converts it to its string
    representation, which is something like `"2015-07-15 18:12:39.002731"`. This will
    result in an HTML string such as `"<html><body>It is now 2015-07-15 18:12:39.002731.</body></html>"`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图中的第二行代码使用Python的**格式化字符串**功能构造了一个HTML响应。字符串中的`%s`是一个占位符，字符串后面的百分号表示用变量`now`的值替换后面字符串中的`%s`。`now`变量在技术上是一个`datetime.datetime`对象，而不是一个字符串，但`%s`格式字符将其转换为其字符串表示形式，类似于`"2015-07-15
    18:12:39.002731"`。这将导致一个HTML字符串，如`"<html><body>现在是2015-07-15 18:12:39.002731。</body></html>"`。
- en: Finally, the view returns an `HttpResponse` object that contains the generated
    response-just as we did in `hello`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，视图返回一个包含生成的响应的`HttpResponse`对象-就像我们在`hello`中做的那样。
- en: 'After adding that to `views.py`, add the URLpattern to `urls.py` to tell Django
    which URL should handle this view. Something like `/time/` would make sense:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`中添加了这个之后，将URL模式添加到`urls.py`中，告诉Django哪个URL应该处理这个视图。类似`/time/`这样的东西会有意义：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've made two changes here. First, we imported the `current_datetime` function
    at the top. Second, and more importantly, we added a URLpattern mapping the URL
    `/time/` to that new view. Getting the hang of this? With the view written and
    URLconf updated, fire up the `runserver` and visit `http://127.0.0.1:8000/time/`
    in your browser. You should see the current date and time. If you don't see your
    local time, it is likely because the default time zone in your `settings.py` is
    set to `UTC`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了两个更改。首先，在顶部导入了`current_datetime`函数。其次，更重要的是，我们添加了一个URL模式，将URL`/time/`映射到这个新视图。掌握了吗？视图编写和URLconf更新后，启动`runserver`并在浏览器中访问`http://127.0.0.1:8000/time/`。您应该看到当前的日期和时间。如果您没有看到本地时间，很可能是因为您的`settings.py`中的默认时区设置为`UTC`。
- en: URLconfs and loose coupling
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URLconfs和松散耦合
- en: 'Now''s a good time to highlight a key philosophy behind URLconfs and behind
    Django in general: the principle of loose coupling. Simply put, loose coupling
    is a software-development approach that values the importance of making pieces
    interchangeable. If two pieces of code are loosely coupled, then changes made
    to one of the pieces will have little or no effect on the other.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候强调URLconfs和Django背后的一个关键理念了：松散耦合的原则。简单地说，松散耦合是一种软件开发方法，它重视使各个部分可互换的重要性。如果两个代码片段松散耦合，那么对其中一个片段的更改对另一个片段几乎没有影响。
- en: Django's URLconfs are a good example of this principle in practice. In a Django
    web application, the URL definitions and the view functions they call are loosely
    coupled; that is, the decision of what the URL should be for a given function,
    and the implementation of the function itself, reside in two separate places.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Django的URLconfs是这个原则在实践中的一个很好的例子。在Django Web应用程序中，URL定义和它们调用的视图函数是松散耦合的；也就是说，对于给定函数的URL应该是什么的决定，以及函数本身的实现，存在于两个不同的地方。
- en: For example, consider our `current_datetime` view. If we wanted to change the
    URL for the application-say, to move it from `/time/` to `/current-time/`-we could
    make a quick change to the URLconf, without having to worry about the view itself.
    Similarly, if we wanted to change the view function-altering its logic somehow-we
    could do that without affecting the URL to which the function is bound. Furthermore,
    if we wanted to expose the current-date functionality at several URLs, we could
    easily take care of that by editing the URLconf, without having to touch the view
    code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们的`current_datetime`视图。如果我们想要更改应用程序的URL——比如，将其从`/time/`移动到`/current-time/`——我们可以快速更改URLconf，而不必担心视图本身。同样，如果我们想要更改视图函数——以某种方式改变其逻辑——我们可以这样做，而不会影响函数绑定的URL。此外，如果我们想要在几个URL上公开当前日期功能，我们可以通过编辑URLconf轻松处理，而不必触及视图代码。
- en: 'In this example, our `current_datetime` is available at two URLs. It''s a contrived
    example, but this technique can come in handy:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的`current_datetime`可以通过两个URL访问。这是一个刻意制造的例子，但这种技术可能会派上用场：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: URLconfs and views are loose coupling in action. I'll continue to point out
    examples of this important philosophy throughout the book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: URLconfs和视图是松散耦合的实践。我将在整本书中继续指出这一重要的哲学。
- en: 'Your third view: dynamic URLs'
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第三个视图：动态URL
- en: 'In our `current_datetime` view, the contents of the page-the current date/time-were
    dynamic, but the URL (`/time/`) was static. In most dynamic web applications though,
    a URL contains parameters that influence the output of the page. For example,
    an online bookstore might give each book its own URL, like `/books/243/` and `/books/81196/`.
    Let''s create a third view that displays the current date and time offset by a
    certain number of hours. The goal is to craft a site in such a way that the page
    `/time/plus/1/` displays the date/time one hour into the future, the page `/time/plus/2/`
    displays the date/time two hours into the future, the page `/time/plus/3/` displays
    the date/time three hours into the future, and so on. A novice might think to
    code a separate view function for each hour offset, which might result in a URLconf
    like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`current_datetime`视图中，页面的内容——当前日期/时间——是动态的，但URL（`/time/`）是静态的。然而，在大多数动态网络应用中，URL包含影响页面输出的参数。例如，一个在线书店可能为每本书提供自己的URL，如`/books/243/`和`/books/81196/`。让我们创建一个第三个视图，显示当前日期和时间偏移了一定数量的小时。目标是以这样的方式设计网站，使得页面`/time/plus/1/`显示未来一小时的日期/时间，页面`/time/plus/2/`显示未来两小时的日期/时间，页面`/time/plus/3/`显示未来三小时的日期/时间，依此类推。一个新手可能会想要为每个小时偏移编写一个单独的视图函数，这可能会导致这样的URLconf：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Clearly, this line of thought is flawed. Not only would this result in redundant
    view functions, but also the application is fundamentally limited to supporting
    only the predefined hour ranges-one, two or three hours.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种想法是有缺陷的。这不仅会导致冗余的视图函数，而且应用程序基本上只能支持预定义的小时范围——一、两或三个小时。
- en: If we decided to create a page that displayed the time four hours into the future,
    we'd have to create a separate view and URLconf line for that, furthering the
    duplication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定创建一个显示未来四小时时间的页面，我们将不得不为此创建一个单独的视图和URLconf行，进一步增加了重复。
- en: 'How, then do we design our application to handle arbitrary hour offsets? The
    key is to use wildcard URLpatterns. As I mentioned previously, a URLpattern is
    a regular expression; hence, we can use the regular expression pattern `\d+` to
    match one or more digits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何设计我们的应用程序来处理任意小时偏移？关键是使用通配符URLpatterns。正如我之前提到的，URLpattern是一个正则表达式；因此，我们可以使用正则表达式模式`\d+`来匹配一个或多个数字：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (I'm using the `# ...` to imply there might be other URLpatterns that have been
    trimmed from this example.) This new URLpattern will match any URL such as `/time/plus/2/`,
    `/time/plus/25/`, or even `/time/plus/100000000000/`. Come to think of it, let's
    limit it so that the maximum allowed offset is something reasonable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: （我使用`# ...`来暗示可能已经从这个例子中删除了其他URLpatterns。）这个新的URLpattern将匹配任何URL，比如`/time/plus/2/`、`/time/plus/25/`，甚至`/time/plus/100000000000/`。想想看，让我们限制一下，使得最大允许的偏移量是合理的。
- en: 'In this example, we will set a maximum 99 hours by only allowing either one
    or two digit numbers-and in regular expression syntax, that translates into `\d{1,2}`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过只允许一位或两位数字来设置最大的99小时——在正则表达式语法中，这相当于`\d{1,2}`：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we''ve designated a wildcard for the URL, we need a way of passing
    that wildcard data to the view function, so that we can use a single view function
    for any arbitrary hour offset. We do this by placing parentheses around the data
    in the URLpattern that we want to save. In the case of our example, we want to
    save whatever number was entered in the URL, so let''s put parentheses around
    the `\d{1,2}`, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为URL指定了一个通配符，我们需要一种方法将通配符数据传递给视图函数，这样我们就可以对任意小时偏移使用一个视图函数。我们通过在URLpattern中希望保存的数据周围放置括号来实现这一点。在我们的例子中，我们希望保存在URL中输入的任何数字，所以让我们在`\d{1,2}`周围放上括号，就像这样：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you''re familiar with regular expressions, you''ll be right at home here;
    we''re using parentheses to capture data from the matched text. The final URLconf,
    including our previous two views, looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉正则表达式，你会在这里感到很舒适；我们使用括号来从匹配的文本中捕获数据。最终的URLconf，包括我们之前的两个视图，看起来像这样：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're experienced in another web development platform, you may be thinking,
    "Hey, let's use a query string parameter!"-something like `/time/plus?hours=3`,
    in which the hours would be designated by the `hours` parameter in the URL's query
    string (the part after the '?'). You can do that with Django (and I'll tell you
    how in [Chapter 7](ch07.xhtml "Chapter 7. Advanced Views and URLconfs"), *Advanced
    Views and URLconfs*), but one of Django's core philosophies is that URLs should
    be beautiful. The URL `/time/plus/3/` is far cleaner, simpler, more readable,
    easier to recite to somebody aloud and just plain prettier than its query string
    counterpart. Pretty URLs are a characteristic of a quality web application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其他Web开发平台上有经验，您可能会想：“嘿，让我们使用查询字符串参数！”-类似于`/time/plus?hours=3`，其中小时将由URL查询字符串（'?'后面的部分）中的`hours`参数指定。您可以在Django中这样做（我将在[第7章](ch07.xhtml
    "第7章。高级视图和URLconfs")中告诉您如何做），但Django的核心理念之一是URL应该是美观的。URL`/time/plus/3/`比其查询字符串对应项更清晰、更简单、更可读、更容易大声朗读，而且更漂亮。美观的URL是高质量Web应用的特征。
- en: Django's URLconf system encourages pretty URLs by making it easier to use pretty
    URLs than not to.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Django的URLconf系统鼓励使用美观的URL，因为使用美观的URL比不使用更容易。
- en: 'With that taken care of, let''s write the `hours_ahead` view. `hours_ahead`
    is very similar to the `current_datetime` view we wrote earlier, with a key difference:
    it takes an extra argument, the number of hours of offset. Here''s the view code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这些后，让我们编写`hours_ahead`视图。`hours_ahead`与我们之前编写的`current_datetime`视图非常相似，但有一个关键区别：它接受一个额外的参数，即偏移的小时数。以下是视图代码：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's take a closer look at this code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码。
- en: 'The view function, `hours_ahead`, takes two parameters: `request` and `offset`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数`hours_ahead`接受两个参数：`request`和`offset`。
- en: '`request` is an `HttpRequest` object, just as in `hello` and `current_datetime`.
    I''ll say it again: each view always takes an `HttpRequest` object as its first
    parameter.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`是一个`HttpRequest`对象，就像`hello`和`current_datetime`中一样。我再说一遍：每个视图总是以`HttpRequest`对象作为其第一个参数。'
- en: '`offset` is the string captured by the parentheses in the URLpattern. For example,
    if the requested URL were `/time/plus/3/`, then offset would be the string ''3''.
    If the requested URL were `/time/plus/21/`, then offset would be the string ''21''.
    Note that captured values will always be Unicode objects, not integers, even if
    the string is composed of only digits, such as ''21''.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`是URLpattern中括号捕获的字符串。例如，如果请求的URL是`/time/plus/3/`，那么`offset`将是字符串''3''。如果请求的URL是`/time/plus/21/`，那么`offset`将是字符串''21''。请注意，捕获的值将始终是Unicode对象，而不是整数，即使字符串只由数字组成，比如''21''。'
- en: I decided to call the variable `offset`, but you can call it whatever you'd
    like, as long as it's a valid Python identifier. The variable name doesn't matter;
    all that matters is that it's the second argument to the function, after `request`.
    (It's also possible to use keyword, rather than positional, arguments in a URLconf.
    I cover that in [Chapter 7](ch07.xhtml "Chapter 7. Advanced Views and URLconfs"),
    *Advanced Views and URLconfs*.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定将变量称为`offset`，但只要它是有效的Python标识符，您可以将其命名为任何您喜欢的名称。变量名并不重要；重要的是它是`request`之后的函数的第二个参数。（在URLconf中也可以使用关键字参数，而不是位置参数。我将在[第7章](ch07.xhtml
    "第7章。高级视图和URLconfs")中介绍这一点。）
- en: The first thing we do within the function is call `int()` on `offset`. This
    converts the Unicode string value to an integer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先对`offset`调用`int()`。这将把Unicode字符串值转换为整数。
- en: Note that Python will raise a `ValueError` exception if you call `int()` on
    a value that cannot be converted to an integer, such as the string `foo`. In this
    example, if we encounter the `ValueError`, we raise the exception `django.http.Http404`,
    which, as you can imagine, results in a **404 **P**** **age not found** error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您对无法转换为整数的值（如字符串`foo`）调用`int()`，Python将引发`ValueError`异常。在这个例子中，如果我们遇到`ValueError`，我们会引发异常`django.http.Http404`，这将导致**404**页面未找到错误。
- en: 'Astute readers will wonder: how could we ever reach the `ValueError` case,
    anyway, given that the regular expression in our URLpattern-`(\d{1,2})`-captures
    only digits, and therefore `offset` will only ever be a string composed of digits?
    The answer is, we won''t, because the URLpattern provides a modest but useful
    level of input validation, but we still check for the `ValueError` in case this
    view function ever gets called in some other way.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会想：无论如何，我们怎么会到达`ValueError`的情况呢？因为我们URLpattern-`(\d{1,2})`中的正则表达式只捕获数字，因此`offset`将始终是由数字组成的字符串？答案是，我们不会，因为URLpattern提供了适度但有用的输入验证级别，但我们仍然检查`ValueError`，以防这个视图函数以其他方式被调用。
- en: It's good practice to implement view functions such that they don't make any
    assumptions about their parameters. Loose coupling, remember?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现视图函数时最好不要对其参数做任何假设。记住松耦合。
- en: In the next line of the function, we calculate the current date/time and add
    the appropriate number of hours. We've already seen `datetime.datetime.now()`
    from the `current_datetime` view; the new concept here is that you can perform
    date/time arithmetic by creating a `datetime.timedelta` object and adding to a
    `datetime.datetime` object. Our result is stored in the variable `dt`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的下一行中，我们计算当前的日期/时间，并添加适当数量的小时。我们已经从`current_datetime`视图中看到了`datetime.datetime.now()`；这里的新概念是，您可以通过创建`datetime.timedelta`对象并添加到`datetime.datetime`对象来执行日期/时间算术。我们的结果存储在变量`dt`中。
- en: This line also shows why we called `int()` on `offset`-the `datetime.timedelta`
    function requires the `hours` parameter to be an integer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这行还显示了为什么我们对`offset`调用了`int()`-`datetime.timedelta`函数要求`hours`参数是一个整数。
- en: 'Next, we construct the HTML output of this view function, just as we did in
    `current_datetime`. A small difference in this line from the previous line is
    that it uses Python''s format-string capability with two values, not just one.
    Hence, there are two `%s` symbols in the string and a tuple of values to insert:
    `(offset, dt)`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建这个视图函数的HTML输出，就像我们在`current_datetime`中所做的那样。这一行与上一行的一个小区别是，它使用了Python的格式化字符串功能，而不仅仅是一个。因此，在字符串中有两个`%s`符号和一个要插入的值的元组：`(offset,
    dt)`。
- en: Finally, we return an `HttpResponse` of the HTML.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个HTML的`HttpResponse`。
- en: With that view function and URLconf written, start the Django development server
    (if it's not already running), and visit `http://127.0.0.1:8000/time/plus/3/`
    to verify it works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个视图函数和URLconf的编写，启动Django开发服务器（如果尚未运行），并访问`http://127.0.0.1:8000/time/plus/3/`来验证它是否正常工作。
- en: Then try `http://127.0.0.1:8000/time/plus/5/`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试`http://127.0.0.1:8000/time/plus/5/`。
- en: Then `http://127.0.0.1:8000/time/plus/24/`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问`http://127.0.0.1:8000/time/plus/24/`。
- en: Finally, visit `http://127.0.0.1:8000/time/plus/100/` to verify that the pattern
    in your URLconf only accepts one or two digit numbers; Django should display a
    **Page not found** error in this case, just as we saw in the section *A quick
    note about 404 errors* earlier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，访问`http://127.0.0.1:8000/time/plus/100/`来验证您的URLconf中的模式只接受一位或两位数字；在这种情况下，Django应该显示**Page
    not found**错误，就像我们在*关于404错误的快速说明*部分中看到的那样。
- en: The URL `http://127.0.0.1:8000/time/plus/` (with no hour designation) should
    also throw a 404.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: URL `http://127.0.0.1:8000/time/plus/`（没有小时指定）也应该会引发404错误。
- en: Django's pretty error pages
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django的漂亮错误页面
- en: 'Take a moment to admire the fine web application we''ve made so far-now let''s
    break it! Let''s deliberately introduce a Python error into our `views.py` file
    by commenting out the `offset = int(offset)` lines in the `hours_ahead` view:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间来欣赏我们迄今为止制作的精美Web应用程序-现在让我们打破它！让我们故意在我们的`views.py`文件中引入一个Python错误，方法是注释掉`hours_ahead`视图中的`offset
    = int(offset)`行：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Load up the development server and navigate to `/time/plus/3/`. You''ll see
    an error page with a significant amount of information, including a **TypeError**
    message displayed at the very top: **unsupported type for timedelta hours component:
    str (** *Figure 2.3*).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '加载开发服务器并导航到`/time/plus/3/`。您将看到一个错误页面，其中包含大量信息，包括在顶部显示的**TypeError**消息：**unsupported
    type for timedelta hours component: str (** *图2.3*).'
- en: '![Django''s pretty error pages](img/image_02_003.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Django的漂亮错误页面](img/image_02_003.jpg)'
- en: 'Figure 2.3: Django''s error page'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Django的错误页面
- en: 'What happened? Well, the `datetime.timedelta` function expects the `hours`
    parameter to be an integer, and we commented out the bit of code that converted
    `offset` to an integer. That caused `datetime.timedelta` to raise the **TypeError**.
    It''s the typical kind of small bug that every programmer runs into at some point.
    The point of this example was to demonstrate Django''s error pages. Take some
    time to explore the error page and get to know the various bits of information
    it gives you. Here are some things to notice:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？嗯，`datetime.timedelta`函数期望`hours`参数是一个整数，而我们注释掉了将`offset`转换为整数的代码。这导致`datetime.timedelta`引发了**TypeError**。这是每个程序员在某个时候都会遇到的典型小错误。这个例子的目的是演示Django的错误页面。花点时间来探索错误页面，并了解它提供的各种信息。以下是一些需要注意的事项：
- en: 'At the top of the page, you get the key information about the exception: the
    type of exception, any parameters to the exception (the **unsupported type** message
    in this case), the file in which the exception was raised, and the offending line
    number.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面顶部，您将获得有关异常的关键信息：异常的类型，异常的任何参数（在这种情况下是**unsupported type**消息），引发异常的文件以及有问题的行号。
- en: Under the key exception information, the page displays the full Python traceback
    for this exception. This is similar to the standard traceback you get in Python's
    command-line interpreter, except it's more interactive. For each level (frame)
    in the stack, Django displays the name of the file, the function/method name,
    the line number, and the source code of that line.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关键异常信息下面，页面显示了此异常的完整Python回溯。这类似于您在Python命令行解释器中获得的标准回溯，只是更加交互式。对于堆栈中的每个级别（帧），Django显示文件的名称，函数/方法名称，行号以及该行的源代码。
- en: Click the line of source code (in dark gray), and you'll see several lines from
    before and after the erroneous line, to give you context. Click **Local vars**
    under any frame in the stack to view a table of all local variables and their
    values, in that frame, at the exact point in the code at which the exception was
    raised. This debugging information can be a great help.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击源代码行（深灰色），您将看到错误行之前和之后的几行代码，以便为您提供上下文。单击堆栈中任何帧下的**Local vars**，以查看该帧中所有局部变量及其值的表，即在引发异常的代码的确切点上。这些调试信息可以提供很大的帮助。
- en: Note the **Switch to copy-and-paste view** text under the **Traceback** header.
    Click those words, and the traceback will switch to an alternate version that
    can be easily copied and pasted. Use this when you want to share your exception
    traceback with others to get technical support-such as the kind folks in the Django
    IRC chat room or on the Django users mailing list.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意**切换到复制和粘贴视图**文本下的**Traceback**标题。单击这些单词，回溯将切换到一个可以轻松复制和粘贴的备用版本。当您想与其他人分享您的异常回溯以获得技术支持时，可以使用此功能-例如Django
    IRC聊天室中的友好人士或Django用户邮件列表中的人士。
- en: Underneath, the **Share this traceback on a public web site** button will do
    this work for you in just one click. Click it to post the traceback to dpaste
    (for more information visit [http://www.dpaste.com/](http://www.dpaste.com/)),
    where you'll get a distinct URL that you can share with other people.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面，**在公共网站上分享此回溯**按钮将在单击一次后为您完成此工作。单击它以将回溯发布到dpaste（有关更多信息，请访问[http://www.dpaste.com/](http://www.dpaste.com/)），在那里您将获得一个独特的URL，可以与其他人分享。
- en: 'Next, the **Request information** section includes a wealth of information
    about the incoming web request that spawned the error: `GET` and `POST` information,
    cookie values, and meta information, such as CGI headers. [Appendix F](apf.xhtml
    "Appendix F. Request and Response Objects"), *Request and Response Objects*, has
    a complete reference of all the information a request object contains.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，**请求信息**部分包括关于产生错误的传入web请求的丰富信息：`GET`和`POST`信息，cookie值和元信息，比如CGI头。[附录F](apf.xhtml
    "附录 F. 请求和响应对象")，*请求和响应对象*，包含了请求对象包含的所有信息的完整参考。
- en: Following to the **Request information** section, the **Settings** section lists
    all of the settings for this particular Django installation. All the available
    settings are covered in detail in [Appendix D](apd.xhtml "Appendix D. Settings"),
    *Settings*.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**请求信息**部分之后，**设置**部分列出了此特定Django安装的所有设置。所有可用的设置都在[附录D](apd.xhtml "附录 D. 设置")，*设置*中有详细介绍。
- en: The Django error page is capable of displaying more information in certain special
    cases, such as the case of template syntax errors. We'll get to those later, when
    we discuss the Django template system. For now, uncomment the `offset = int(offset)`
    lines to get the view function working properly again.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特殊情况下，Django错误页面能够显示更多信息，比如模板语法错误的情况。我们稍后会讨论Django模板系统时再谈论这些。现在，取消注释`offset
    = int(offset)`行，以使视图函数再次正常工作。
- en: The Django error page is also really useful if you are the type of programmer
    who likes to debug with the help of carefully placed `print` statements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是那种喜欢通过精心放置`print`语句来调试的程序员，Django错误页面也非常有用。
- en: 'At any point in your view, temporarily insert an `assert False` to trigger
    the error page. Then, you can view the local variables and state of the program.
    Here''s an example, using the `hours_ahead` view:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的任何位置，临时插入`assert False`来触发错误页面。然后，您可以查看程序的本地变量和状态。以下是一个示例，使用`hours_ahead`视图：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, it's obvious that much of this information is sensitive-it exposes
    the innards of your Python code and Django configuration-and it would be foolish
    to show this information on the public Internet. A malicious person could use
    it to attempt to reverse-engineer your web application and do nasty things. For
    that reason, the Django error page is only displayed when your Django project
    is in debug mode. I'll explain how to deactivate debug mode in [Chapter 13](ch13.xhtml
    "Chapter 13. Deploying Django"), *Deploying Django*. For now, just know that every
    Django project is in debug mode automatically when you start it. (Sounds familiar?
    The **Page not found** errors, described earlier in this chapter, work the same
    way.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，显而易见，这些信息中的大部分都是敏感的-它暴露了您的Python代码和Django配置的内部，并且在公共互联网上显示这些信息是愚蠢的。恶意人士可以利用它来尝试反向工程您的Web应用程序并做坏事。因此，只有当您的Django项目处于调试模式时，才会显示Django错误页面。我将在[第13章](ch13.xhtml
    "第 13 章. 部署 Django") *部署 Django*中解释如何停用调试模式。现在，只需知道每个Django项目在启动时都会自动处于调试模式即可。（听起来很熟悉吗？本章前面描述的**页面未找到**错误也是同样的工作方式。）
- en: What's next?
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: So far, we've been writing our view functions with HTML hard-coded directly
    in the Python code. I've done that to keep things simple while I demonstrated
    core concepts, but in the real world, this is nearly always a bad idea. Django
    ships with a simple yet powerful template engine that allows you to separate the
    design of the page from the underlying code. We'll dive into Django's template
    engine in the next chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在Python代码中直接编写HTML硬编码的视图函数。我这样做是为了在演示核心概念时保持简单，但在现实世界中，这几乎总是一个坏主意。Django附带了一个简单而强大的模板引擎，允许您将页面的设计与底层代码分离。我们将在下一章深入探讨Django的模板引擎。
