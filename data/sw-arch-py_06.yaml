- en: Chapter 6. Security – Writing Secure Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 安全 - 编写安全代码
- en: Security of software applications (or lack of it) has been attracting a lot
    of importance in the past few years in the industry and the media. It looks like
    every other day, we hear about an instance or two of malicious hackers causing
    massive data breaches in software systems in different parts of the world, and
    causing millions of dollars worth of losses. The victims are either government
    departments, financial institutions, firms handling sensitive customer data such
    as passwords, credit cards, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序的安全性（或缺乏安全性）在过去几年在行业和媒体中引起了很大的重视。似乎每隔一天，我们都会听到恶意黑客在世界各地的软件系统中造成大规模数据泄露，并造成数百万美元的损失。受害者可能是政府部门、金融机构、处理敏感客户数据（如密码、信用卡等）的公司等。
- en: Software security and secure coding has assumed more importance than ever due
    to the unprecedented amounts of data being shared across software and hardware
    systems—the explosion of smart personal technologies such as smart phones, smart
    watches, smart music players, and other smart systems has created and aided this
    immense traffic of data across the Internet in a big way. With the advent of IPV6
    and expected large scale adoption of **IoT** devices (**Internet of Things**)
    in the next few years, the amount of data is only going to increase exponentially.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件和硬件系统之间共享的数据数量空前增加 - 智能个人技术（如智能手机、智能手表、智能音乐播放器等）的爆炸式增长，以及其他智能系统的出现和帮助，已经在互联网上大规模传播了大量数据。随着IPv6的出现和预计在未来几年大规模采用**物联网**设备（**物联网**）的数量将呈指数级增长，数据量只会不断增加。
- en: As we discussed in the first chapter, security is an important aspect of software
    architecture. Apart from architecting systems with secure principles, an architect
    should also try to imbibe their team with secure coding principles to minimize
    security pitfalls in the code written by their team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中讨论的，安全是软件架构的一个重要方面。除了使用安全原则构建系统外，架构师还应该尝试灌输团队安全编码原则，以最小化团队编写的代码中的安全漏洞。
- en: In this chapter, we will look at the principles of architecting secure systems,
    and also look at tips and techniques for writing secure code in Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建安全系统的原则，并探讨在Python中编写安全代码的技巧和技术。
- en: The topics we will be discussing can be summed up in the following list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的主题可以总结如下列表。
- en: Information Security Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息安全架构
- en: Secure Coding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全编码
- en: Common Security Vulnerabilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的安全漏洞
- en: Is Python Secure?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python是否安全？
- en: Reading Input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取输入
- en: Evaluating arbitrary Input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估任意输入
- en: Overflow Errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出错误
- en: Serializing Objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Security issues with web applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序的安全问题
- en: Strategies for Security – Python
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全策略 - Python
- en: Secure Coding Strategies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全编码策略
- en: Information Security architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息安全架构
- en: 'A secure architecture involves creating a system that is able to provide access
    to data, and information to authorized people and systems while preventing any
    unauthorized access. Creating an architecture for information security for your
    systems involves the following aspects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安全架构涉及创建一个能够为授权人员和系统提供数据和信息访问权限的系统，同时防止任何未经授权的访问。为您的系统创建信息安全架构涉及以下方面：
- en: '**Confidentiality**: A set of rules or procedures that restricts the envelope
    of access to information in the system. Confidentiality ensures that data is not
    exposed to unauthorized access or modification.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：一组规则或程序，限制对系统中信息的访问范围。机密性确保数据不会暴露给未经授权的访问或修改。'
- en: '**Integrity**: Integrity is the property of the system which ensures that the
    information channels are trustworthy and reliable and that the system is free
    from external manipulations. In other words, Integrity ensures the data can be
    trusted as it flows through the system across its components.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：完整性是系统的属性，确保信息通道是可信赖和可靠的，并且系统没有外部操纵。换句话说，完整性确保数据在系统中的组件之间流动时是可信的。'
- en: '**Availability**: Property that the system will ensure a level of service to
    its authorized users according to its Service Level Agreements (SLAs). Availability
    ensures that the system will not deny service to its authorized users.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：系统将根据其服务级别协议（SLA）确保向其授权用户提供一定级别的服务的属性。可用性确保系统不会拒绝向其授权用户提供服务。'
- en: The three aspects of Confidentiality, Integrity, and Availability – often called
    the CIA triad form the corner stones of building an information security architecture
    for your system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 机密性、完整性和可用性这三个方面，通常称为CIA三位一体，构成了为系统构建信息安全架构的基石。
- en: '![Information Security architecture](../Images/image00463.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![信息安全架构](../Images/image00463.jpeg)'
- en: CIA triad of Information Security Architecture
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全架构的CIA三位一体
- en: 'These aspects are aided by other characteristics, such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面受到其他特征的支持，例如以下特征：
- en: '**Authentication**: Verifies the identity of the participants of a transaction,
    and ensures that they are actually those who they purport to be. Examples are
    digital certificates used in e-mail, public keys used to log in to systems, and
    the like.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：验证交易参与者的身份，并确保他们确实是他们所声称的人。例如，在电子邮件中使用的数字证书，用于登录系统的公钥等。'
- en: '**Authorization**: Gives rights to a specific user/role to perform a specific
    task or groups of related tasks. Authorization ensures that certain groups of
    users are tied to certain roles, which limit their access (read) and modification
    (write) rights in the system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：授予特定用户/角色执行特定任务或相关任务组的权限。授权确保某些用户组与某些角色相关联，限制其在系统中的访问（读取）和修改（写入）权限。'
- en: '**Non-reputability**: Security techniques that guarantee that users involved
    in a transaction cannot later deny that the transaction happened. For example,
    a sender of an e-mail cannot later deny that they had sent the e-mail; a recipient
    of a bank funds transfer cannot later deny that they received the money, and so
    on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：保证参与交易的用户不能以后否认交易发生。例如，电子邮件的发送者不能以后否认他们发送了电子邮件；银行资金转账的接收方不能以后否认他们收到了钱，等等。
- en: Secure coding
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全编码
- en: Secure coding is the practice of software development that guards programs against
    security vulnerabilities, and makes it resistant to malicious attacks right from
    program design to implementation. It is about writing code that is inherently
    secure as opposed to thinking of security as a layer which is added on later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编码是软件开发的实践，它保护程序免受安全漏洞的侵害，并使其抵抗恶意攻击，从程序设计到实施。这是关于编写固有安全的代码，而不是将安全视为后来添加的层。
- en: 'The philosophies behind secure coding include the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编码背后的理念包括以下内容：
- en: Security is an aspect to be considered right from the design and development
    of a program or application; it is not an afterthought.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全是设计和开发程序或应用程序时需要考虑的一个方面；这不是事后的想法。
- en: Security requirements should be identified early in the development cycle, and
    these should be propagated to subsequent stages of development of the system to
    make sure that compliance is maintained.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全需求应在开发周期的早期确定，并应传播到系统开发的后续阶段，以确保合规性得到维持。
- en: 'Use threat modeling to anticipate security threats to the system from the beginning.
    Threat modeling involves the following:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用威胁建模来预测系统从一开始面临的安全威胁。威胁建模包括以下内容：
- en: Identifying important assets (code/data).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别重要资产（代码/数据）。
- en: Decomposing the application into components.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序分解为组件。
- en: Identifying and categorizing threats to each asset or component.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别和分类对每个资产或组件的威胁。
- en: Ranking the threats based on an established risk model.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据已建立的风险模型对威胁进行排名。
- en: Developing threat mitigation strategies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制定威胁缓解策略。
- en: 'The practice or strategies of secure coding include the following main tasks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安全编码的实践或策略包括以下主要任务：
- en: '**Definition of areas of interest of the application**: Identify important
    assets in code/data of the application which are critical and needs to be secured.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的兴趣领域的定义：识别应用程序中代码/数据中的重要资产，这些资产是关键的，需要得到保护。
- en: '**Analysis of software architecture**: Analyze the software architecture for
    obvious security flaws. Secure interaction between components with a view for
    ensuring data confidentiality and integrity. Ensure confidential data is protected
    via proper authentication and authorization techniques. Ensure availability is
    built into the architecture from ground up.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件架构分析：分析软件架构中的明显安全缺陷。组件之间的安全交互，以确保数据的保密性和完整性。确保通过适当的身份验证和授权技术保护机密数据。确保可用性从一开始就内置到架构中。
- en: '**Review of implementation details**: Review the code using secure coding techniques.
    Ensure peer review is done with a view to finding security holes. Provide feedback
    to the developer and ensure changes are made.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施细节审查：使用安全编码技术审查代码。确保进行同行审查以发现安全漏洞。向开发人员提供反馈并确保进行更改。
- en: '**Verification of logic and syntax**: Review code logic and syntax to ensure
    there are no obvious loop holes in the implementation. Make sure programming is
    done keeping with commonly available secure coding guidelines of the programming
    language/platform.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑和语法的验证：审查代码逻辑和语法，以确保实施中没有明显的漏洞。确保编程是根据编程语言/平台的常用安全编码指南进行的。
- en: '**Whitebox/Unit Testing**: The developer unit tests his code with security
    tests apart from tests ensuring functionality. Mock data and/or APIs can be used
    to virtualize third party data/API required for testing.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 白盒/单元测试：开发人员对其代码进行安全测试，除了确保功能的测试之外。可以使用模拟数据和/或API来虚拟化测试所需的第三方数据/API。
- en: '**Blackbox Testing**: The application is tested by an experienced QA engineer
    who looks for security loop holes such as unauthorized access to data, path ways
    accidentally exposing code and or data, weak passwords or hashes etc. The testing
    reports are fed back the stakeholders including the architect to make sure the
    loopholes identified are fixed.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黑盒测试：应用程序由经验丰富的质量保证工程师进行测试，他寻找安全漏洞，如未经授权访问数据，意外暴露代码或数据的路径，弱密码或哈希等。测试报告反馈给利益相关者，包括架构师，以确保修复已识别的漏洞。
- en: In reality, secure coding is a practice and a habit that software development
    organizations should inculcate through carefully developed and reviewed secure
    coding strategies such as the aforementioned over time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，安全编码是一个实践和习惯，软件开发组织应该通过经过精心制定和审查的安全编码策略来培养，如上述的策略。
- en: Common security vulnerabilities
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的安全漏洞
- en: 'So what are the common security vulnerabilities, a professional programmer
    today should be prepared to face and mitigate during the course of their career?
    Looking at the available literature, these can be organized into a few specific
    categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，今天的专业程序员应该准备面对和减轻职业生涯中可能遇到的常见安全漏洞？从现有的文献来看，这些可以组织成几个特定的类别：
- en: '**Overflow errors**: These include the popular and often abused **buffer overflow**
    errors, and the lesser known but still vulnerable **arithmetic or integer overflow**
    errors:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出错误：这些包括流行且经常被滥用的缓冲区溢出错误，以及较少为人知但仍然容易受到攻击的算术或整数溢出错误：
- en: '**The buffer overflow**: The buffer overflows are produced by programming errors
    that allow an application to write past the end or beginning of a buffer. The
    buffer overflows allow attackers to take control over systems by gaining access
    to the applications stack or heap memory by carefully crafted attack data.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**：缓冲区溢出是由编程错误产生的，允许应用程序在缓冲区的末尾或开头之外写入。缓冲区溢出允许攻击者通过精心制作的攻击数据访问应用程序的堆栈或堆内存，从而控制系统。'
- en: '**The integer or arithmetic overflow**: These errors occur when an arithmetic
    or mathematical operation on integers produces a result that is too large for
    the maximum size of the type used to store it.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数或算术溢出**：当对整数进行算术或数学运算产生超出所用于存储的类型的最大大小的结果时，会发生这些错误。'
- en: Integer overflows can create security vulnerabilities if they are not properly
    handled. In programming languages supporting signed and unsigned integers, overflows
    can cause the data to wrap and produce negative numbers, allowing the attacker
    with a result similar to buffer overflows to gain access to heap or stack memory
    outside the program execution limits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未正确处理，整数溢出可能会导致安全漏洞。在支持有符号和无符号整数的编程语言中，溢出可能会导致数据包装并产生负数，从而允许攻击者获得类似于缓冲区溢出的结果，以访问程序执行限制之外的堆或栈内存。
- en: '**Unvalidated/Improperly validated input**: A very common security issue with
    modern web applications, unvalidated input can cause major vulnerabilities, where
    attackers can trick a program into accepting malicious input such as code data
    or system commands, which, when executed, can compromise a system. A system that
    aims to mitigate this type of attack should have filters to check and remove content
    that is malicious, and only accept data that is reasonable and safe to the system.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经验证/未正确验证的输入**：现代Web应用程序中非常常见的安全问题，未经验证的输入可能会导致严重的漏洞，攻击者可以欺骗程序接受恶意输入，如代码数据或系统命令，当执行时可能会危害系统。旨在减轻此类攻击的系统应具有过滤器，以检查和删除恶意内容，并仅接受对系统合理和安全的数据。'
- en: Common subtypes of this type of attack include SQL injections, Server-Side Template
    Injections, **Cross-Site-Scripting** (**XSS**), and Shell Execution Exploits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此类攻击的常见子类型包括SQL注入、服务器端模板注入、**跨站脚本**（**XSS**）和Shell执行漏洞。
- en: Modern web application frameworks are vulnerable to this kind of attack due
    to use of HTML templates which mix code and data, but many of them have standard
    mitigation procedures such as escaping or filtering of input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序框架由于使用混合代码和数据的HTML模板而容易受到此类攻击的影响，但其中许多都有标准的缓解程序，如转义或过滤输入。
- en: '**Improper access control**: Modern day applications should define separate
    roles for their classes of users, such as regular users, and those with special
    privileges, such as superusers or administrators. When an application fails to
    do this or does it incorrectly, it can expose routes (URLs) or workflows (series
    of actions specified by specific URLs containing attack vectors), which can either
    expose sensitive data to attackers, or, in the worst case, allow an attacker to
    compromise and take control of the system.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不正确的访问控制**：现代应用程序应为其用户类别定义单独的角色，例如普通用户和具有特殊权限的用户，如超级用户或管理员。当应用程序未能或不正确地执行此操作时，可能会暴露路由（URL）或工作流程（由特定URL指定的一系列操作）的攻击向量，这可能会将敏感数据暴露给攻击者，或者在最坏的情况下，允许攻击者
    compromise并控制系统。'
- en: '**Cryptography issues**: Simply ensuring that access control is in place is
    not enough for hardening and securing a system. Instead, the level and strength
    of security should be verified and ascertained, otherwise, your system can still
    be hacked or compromised. Some examples are as follows:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码学问题**：仅确保访问控制已经就位并不足以加固和保护系统。相反，应验证和确定安全级别和强度，否则，您的系统仍可能被黑客入侵或妥协。以下是一些示例：'
- en: '**HTTP instead of HTTPS**: When implementing RestFUL web services, make sure
    you favor HTTPS (SSL/TLS) over HTTP. In HTTP, all communication is in plain text
    between the client and server, and can be easily captured by passive network sniffers
    or carefully crafted packet capture software or devices installed in routers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP而不是HTTPS**：在实现RestFUL Web服务时，请确保优先选择HTTPS（SSL/TLS）而不是HTTP。在HTTP中，客户端和服务器之间的所有通信都是明文的，可以被被动网络嗅探器或精心制作的数据包捕获软件或安装在路由器中的设备轻松捕获。'
- en: Projects like letsencrypt have made life easy for system administrators for
    procuring and updating free SSL certificates, so securing your servers using SSL/TLS
    is easier these days than ever before.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 像letsencrypt这样的项目已经为系统管理员提供了便利，可以获取和更新免费的SSL证书，因此使用SSL/TLS来保护您的服务器比以往任何时候都更容易。
- en: '**Insecure authentication**: Prefer secure authentication techniques on a web
    server over insecure ones. For example, prefer HTTP Digest authentication to Basic
    authentication on web servers, as in the latter, passwords are sent in the clear.
    Similarly, use **Kerberos** authentication in a large shared network over less
    secure alternatives such as **Lightweight Directory Access Protocol** (**LDAP**)
    or **NT LAN Manager** (**NTLM**).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的身份验证**：在Web服务器上，优先选择安全的身份验证技术而不是不安全的技术。例如，在Web服务器上，优先选择HTTP摘要身份验证而不是基本身份验证，因为在基本身份验证中，密码是明文传输的。同样，在大型共享网络中使用**Kerberos**身份验证，而不是**轻量级目录访问协议**（**LDAP**）或**NT
    LAN Manager**（**NTLM**）等不太安全的替代方案。'
- en: '**Use of weak passwords**: Easy-to-guess or default/trivial passwords are the
    bane of many modern-day web applications.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用弱密码**：易于猜测的或默认/琐碎的密码是许多现代Web应用程序的祸根。'
- en: '**Reuse of secure hashes/secret keys** – Secure hashes or secret keys are usually
    specific to an application or project and should never be reused across applications.
    Whenever required generate fresh hashes and or keys.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用安全哈希/密钥** - 安全哈希或密钥通常特定于应用程序或项目，不应跨应用程序重用。每当需要时生成新的哈希和/或密钥。'
- en: '**Weak encryption techniques**: Ciphers used in encrypting communication either
    on the server (SSL certificates) or personal computers (GPG/PGP keys) should use
    high-grade security – of at least 2048 bits and use peer-reviewed and crypto-safe
    algorithms.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱加密技术**：用于在服务器（SSL证书）或个人计算机（GPG/PGP密钥）上加密通信的密码应该使用高级别的安全性——至少2048位，并使用经过同行评审和加密安全的算法。'
- en: '**Weak hashing techniques**: Just as in ciphers, hashing techniques used to
    keep secrets and salts of sensitive data such as passwords should be careful in
    choosing strong algorithms. For example, if one is writing an application that
    requires hashes to be computed and stored today, they would be better off using
    the SHA-1 or SHA-2 algorithms rather than the weaker MD5.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱哈希技术**：就像密码一样，用于保持敏感数据（如密码）的哈希技术应该谨慎选择强大的算法。例如，如果今天编写一个需要计算和存储哈希的应用程序，最好使用SHA-1或SHA-2算法，而不是较弱的MD5。'
- en: '**Invalid or expired certificates/keys**: Web masters often forget to keep
    their SSL certificates updated, and this can become a big problem, compromising
    the security of their web servers, as invalid certificates offer no protection.
    Similarly, personal keys such as GPG or PGP public/private key pairs used for
    e-mail communication should be kept updated.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无效或过期的证书/密钥**：网站管理员经常忘记更新其SSL证书，这可能成为一个大问题，损害其Web服务器的安全性，因为无效的证书没有提供任何保护。类似地，用于电子邮件通信的个人密钥（如GPG或PGP公钥/私钥对）应该保持更新。'
- en: Password enabled SSH - SSH access to remote systems using clear text passwords
    is a security hole. Disable password based access and only enable access via authorized
    SSH keys for specific users only. Disable remote root SSH access.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启用密码的SSH - 使用明文密码对远程系统进行SSH访问是一个安全漏洞。禁用基于密码的访问，只允许特定用户通过授权的SSH密钥进行访问。禁用远程root
    SSH访问。
- en: '**Information leak**: A lot of web servers systems—mostly due to open configuration,
    or misconfiguration, or due to lack of validation of inputs—can reveal a lot of
    information about themselves to an attacker. Some examples are as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息泄漏**：许多Web服务器系统——主要是由于开放配置、或配置错误、或由于缺乏对输入的验证——可以向攻击者泄露许多关于自身的信息。以下是一些例子：'
- en: '**Server meta information**: Many web servers leak information about themselves
    via their 404 pages, and sometimes, via their landing pages. Here is an example:![Common
    security vulnerabilities](../Images/image00464.jpeg)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器元信息**：许多Web服务器通过其404页面泄露有关自身的信息，有时还通过其登陆页面。以下是一个例子：![常见的安全漏洞](../Images/image00464.jpeg)'
- en: 404 page of a web server exposing server meta information
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露服务器元信息的Web服务器404页面
- en: By simply requesting for a non-existing page, we came to know that the site
    seen in the preceding screenshot runs Apache version 2.4.10 on a Debian Server.
    For a crafty attacker, this is often information enough to try out specific attacks
    for that particular web-server/OS combination.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过请求一个不存在的页面，我们得知在前面截图中看到的网站在Debian服务器上运行Apache版本2.4.10。对于狡猾的攻击者来说，这通常已经足够提供特定攻击的信息，针对特定的Web服务器/操作系统组合。
- en: '**Open index pages**: Many websites don''t protect their directory pages, and
    leave them open for world access. This following image shows an example:![Common
    security vulnerabilities](../Images/image00465.jpeg)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开索引页面**：许多网站不保护其目录页面，而是让它们对世界开放。以下图片显示了一个例子：![常见的安全漏洞](../Images/image00465.jpeg)'
- en: Open index page of a web server
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Web服务器的索引页面
- en: '**Open ports**: It is a common error to provide world-access to application''s
    ports running on remote web servers instead of limiting access to them by specific
    IP addresses or security groups by using firewalls – such as *iptables*. A similar
    error is to allow a service to run on 0.0.0.0 (all IP addresses on the server)
    for a service which is only consumed on the localhost. This makes it easy for
    attackers to scan for such ports using network reconnaissance tools such as *nmap/hping3*,
    and the like, and plan their attack.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开端口**：常见的错误是在远程Web服务器上运行的应用程序端口提供全球访问权限，而不是通过使用防火墙（如*iptables*）限制它们的访问权限，例如特定IP地址或安全组。类似的错误是允许服务在0.0.0.0（服务器上的所有IP地址）上运行，而该服务仅在本地主机上使用。这使得攻击者可以使用网络侦察工具（如*nmap/hping3*等）扫描此类端口，并计划他们的攻击。'
- en: Open access to files/folders/databases - A very poor practice is to provide
    open or world access to application configuration files, log files, process ID
    files, and other artifacts so that any logged-in user can access and obtain information
    from these files. Instead, such files should be part of security policies to ensure
    that only specific roles with the required privileges have access to the files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件/文件夹/数据库开放访问 - 提供应用程序配置文件、日志文件、进程ID文件和其他文件的开放或全球访问是一个非常糟糕的做法，以便任何登录用户都可以访问并从这些文件中获取信息。相反，这些文件应该成为安全策略的一部分，以确保只有具有所需特权的特定角色可以访问这些文件。
- en: '**Race conditions**: A race condition exists when a program has two or more
    actors trying to access a certain resource, but the output depends on the correct
    order of access, which cannot be ensured. An example is two threads trying to
    increment a numerical value in shared memory without proper synchronization.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争条件**：当程序有两个或更多的参与者试图访问某个资源，但输出取决于访问的正确顺序，而这不能得到保证时，就存在竞争条件。一个例子是两个线程试图在共享内存中递增一个数值而没有适当的同步。'
- en: Crafty attackers can take advantage of the situation to insert malicious code,
    change a filename, or sometimes, take advantage of small time gaps in the processing
    of code to interfere with the sequence of operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 狡猾的攻击者可以利用这种情况插入恶意代码，更改文件名，或者有时利用代码处理中的小时间间隙干扰操作的顺序。
- en: '**System clock drifts**: This is the phenomena where the system or local clock
    time on a server slowly drifts away from the reference time due to improper or
    missing synchronization. Over time, the clock drift can cause serious security
    flaws such as error in SSL certificate validation, which can be exploited by highly
    sophisticated techniques like *timing attacks* where an attacker tries to take
    control over the system by analyzing time taken to execute cryptographic algorithms.
    Time synchronization protocols like NTP can be used to mitigate this.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统时钟漂移**：这是一个现象，即由于不正确或缺失的同步，服务器上的系统或本地时钟时间慢慢偏离参考时间。随着时间的推移，时钟漂移可能导致严重的安全漏洞，例如SSL证书验证错误，可以通过高度复杂的技术（如*定时攻击*）利用，攻击者试图通过分析执行加密算法所需的时间来控制系统。时间同步协议如NTP可以用来减轻这种情况。'
- en: '**Insecure file/folder operations**: Programmers often make assumptions about
    the ownership, location, or attributes of a file or folder that might not be true
    in practice. This can result in conditions where a security flaw can occur or
    where we may not detect tampering with the system. Some examples are as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的文件/文件夹操作**：程序员经常对文件或文件夹的所有权、位置或属性做出假设，而这在实践中可能并不成立。这可能导致安全漏洞或我们可能无法检测到对系统的篡改。以下是一些例子：'
- en: Failing to check results after a write operation assuming it succeeded
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写操作后未检查结果，假设它成功了
- en: Assuming local file paths are always local files (whereas, they might be symbolic
    links to system files for which the application may not have access)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设本地文件路径总是本地文件（而实际上，它们可能是对应用程序可能无法访问的系统文件的符号链接）
- en: Improperly using sudo in executing system commands, which, if not done correctly,
    can cause loopholes, which can be used to gain root access of the system
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行系统命令时不正确使用sudo，如果不正确执行，可能会导致漏洞，可以用来获取系统的根访问权限
- en: Generous use of permissions on shared files or folders, for example, turning
    on all the execute bits of a program which should be limited to a group or open
    home folders which can be read by any logged in user
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对共享文件或文件夹过度使用权限，例如，打开程序的所有执行位，应该限制为一个组，或者可以被任何登录用户读取的开放家庭文件夹
- en: Using unsafe serialization and deserialization of code or data objects
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不安全的代码或数据对象序列化和反序列化
- en: It is beyond the scope of this chapter to visit each and every type of vulnerability
    in this list. However, we will make an earnest attempt to review and explain the
    common classes of software vulnerabilities that affect Python, and some of its
    web frameworks in the coming section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的范围超出了访问此列表中每一种漏洞的范围。然而，我们将尽力审查和解释影响Python及其一些Web框架的常见软件漏洞类别，并在接下来的部分中进行解释。
- en: Is Python secure?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python安全吗？
- en: Python is a very readable language with simple syntax, and typically, one clearly
    stated way to do things. It comes with a set of well-tested and compact standard
    library modules. All of this seems to indicate that Python should be a very secure
    language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常易读的语言，语法简单，通常有一种清晰的方法来做事情。它配备了一组经过充分测试和紧凑的标准库模块。所有这些似乎表明Python应该是一种非常安全的语言。
- en: But is it so?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是真的吗？
- en: Let us look at a few examples in Python, and try to analyze the security aspect
    of Python and its standard libraries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Python中的一些例子，并尝试分析Python及其标准库的安全性方面。
- en: For the purposes of usefulness, we will demonstrate the code examples shown
    in this section using both Python 2.x and Python 3.x versions. This is because
    a number of security vulnerabilities that are present in Python 2.x versions are
    fixed in the recent 3.x versions. However, since many Python developers are still
    using some form or the other of Python 2.x, the code examples would be useful
    to them, and also illustrate the importance of migrating to Python 3.x.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实用性，我们将展示本节中显示的代码示例使用Python 2.x和Python 3.x版本。这是因为Python 2.x版本中存在的许多安全漏洞在最近的3.x版本中得到了修复。然而，由于许多Python开发人员仍在使用Python
    2.x的某种形式，这些代码示例对他们来说是有用的，并且还说明了迁移到Python 3.x的重要性。
- en: 'All examples are executed on a machine running the Linux (Ubuntu 16.0), x86_64
    architecture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都在运行Linux（Ubuntu 16.0），x86_64架构的机器上执行：
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Python 3.x version used for these examples are Python 3.5.2 and the Python
    2.x version used is Python 2.7.12\. All examples are executed on a machine running
    the Linux (Ubuntu 16.0), 64 bit x86 architecture'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些示例使用的Python 3.x版本是Python 3.5.2，使用的Python 2.x版本是Python 2.7.12。所有示例都在运行Linux（Ubuntu
    16.0）的机器上执行，64位x86架构
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Most of the examples will use one version of code, which will run both
    in Python 2.x and Python 3.x. In cases where this is not possible, two versions
    of the code will be listed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：大多数示例将使用一个版本的代码，该代码将在Python 2.x和Python 3.x中运行。在无法实现这一点的情况下，将列出代码的两个版本。
- en: Reading input
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取输入
- en: 'Let us look at this program that is a simple guessing game. It reads a number
    from the standard input, and compares it with a random number. If it matches,
    the user wins, otherwise, the user has to try again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的猜数字游戏程序。它从标准输入读取一个数字，并将其与一个随机数进行比较。如果匹配，用户就赢了，否则，用户必须再试一次：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is simple, except that it has some sensitive global data,
    which is the passwords of some users in the system. In a realistic example, these
    could be populated by some other functions, which read the passwords and cache
    them in memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很简单，只是有一些敏感的全局数据，即系统中一些用户的密码。在一个现实的例子中，这些可能由一些其他函数填充，这些函数读取密码并将它们缓存在内存中。
- en: 'Let us try the program with some standard inputs. We will initially run it
    with Python 2.7, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些标准输入运行程序。我们将首先使用Python 2.7运行它，如下所示：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let us try a "non-standard" input:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个“非标准”的输入：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how the preceding run exposed the global password data!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的运行暴露了全局密码数据！
- en: The problem is that in Python 2, the input value is evaluated as an expression
    without doing any check, and when it is printed, the expression prints its value.
    In this case, it happens to match a global variable, so its value is printed out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于在Python 2中，输入值被评估为一个表达式而不进行任何检查，当它被打印时，表达式打印出它的值。在这种情况下，它恰好匹配一个全局变量，所以它的值被打印出来。
- en: 'Now let us look at this one:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, not only has it exposed the passwords, it has exposed the complete global
    variables in the code including the passwords. Even if there were no sensitive
    data in the program, a hacker using this approach can reveal valuable information
    about the program such as variable names, function names, packages used, and so
    on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不仅暴露了密码，还暴露了代码中的完整全局变量，包括密码。即使程序中没有敏感数据，使用这种方法的黑客也可以揭示有关程序的有价值的信息，如变量名、函数名、使用的包等等。
- en: 'What is the fix for this? For Python 2, one solution is to replace input, which
    evaluates its contents by passing directly to `eval`, with `raw_input`, which
    doesn''t evaluate the contents. Since `raw_input` doesn''t return a number, it
    needs to be converted to the target type. (This can be done by casting the return
    data to an `int`.) The following code does not only that, but also adds an exception
    handler for the type conversion for extra safety:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是什么？对于Python 2，一个解决方案是用`raw_input`替换`input`，`raw_input`不评估内容。由于`raw_input`不返回数字，需要将其转换为目标类型。（可以通过将返回数据转换为`int`来完成。）以下代码不仅完成了这一点，还为类型转换添加了异常处理程序以提高安全性：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us see how this version fixes the security hole in evaluating inputs
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个版本如何修复评估输入的安全漏洞
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new program is now much more secure than the first version.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 新程序现在比第一个版本安全得多。
- en: This problem is not there in Python 3.x as the following illustration shows.
    (We are using the original version to run this).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在Python 3.x中不存在，如下图所示。（我们使用原始版本来运行这个）。
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Evaluating arbitrary input
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估任意输入
- en: The `eval` function in Python is very powerful, but it is also dangerous, since
    it allows one to pass arbitrary strings to it, which can evaluate potentially
    dangerous code or commands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`eval`函数非常强大，但也很危险，因为它允许将任意字符串传递给它，这可能会评估潜在危险的代码或命令。
- en: 'Let us look at this rather silly piece of code as a test program to see what
    `eval` can do:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个相当愚蠢的代码作为一个测试程序，看看`eval`能做什么：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let us assume a scenario where an attacker is trying to exploit this piece of
    code to find out the contents of the directory where the application is running.
    (For time being you can assume the attacker can run this code via a web application,
    but hasn't got direct access to the machine itself).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一个攻击者试图利用这段代码来查找应用程序运行的目录的内容。（暂时可以假设攻击者可以通过Web应用程序运行此代码，但没有直接访问机器本身）。
- en: 'Let''s assume the attacker tries to list the contents of the current folder:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者试图列出当前文件夹的内容：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This preceding attack doesn't work, because `eval` takes a second argument,
    which provides the global values to use during evaluation. Since in our code we
    are passing this second argument as an empty dictionary, we get the error, as
    Python is unable to resolve the `os` name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的攻击不起作用，因为`eval`需要一个第二个参数，在评估过程中提供要使用的全局值。由于在我们的代码中，我们将这个第二个参数作为空字典传递，我们会得到错误，因为Python无法解析`os`名称。
- en: So does this mean, `eval` is safe? No it's not. Let's see why.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`eval`是安全的？不，它不是。让我们看看为什么。
- en: What happens when we pass the following input to the code?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将以下输入传递给代码时会发生什么？
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that we are still able to coax `eval` to do our bidding by using
    the built-in function `__import__`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们仍然能够通过使用内置函数`__import__`来诱使`eval`执行我们的命令。
- en: 'The reason why this works is because names such as `__import__` are available
    in the default built-in `__builtins__` global. We can deny `eval` this by specifically
    passing this as an empty dictionary via the second argument. Here is the modified
    version:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是因为像`__import__`这样的名称在默认内置的`__builtins__`全局中是可用的。我们可以通过将其作为空字典传递给第二个参数来拒绝`eval`。这是修改后的版本：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the attacker is not able to exploit via the built-in `__import__`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击者无法通过内置的`__import__`进行利用：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this doesn''t still make `eval` any safer, as it is open to slightly
    longer, but clever attacks. Here is one such attack:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着`eval`更安全，因为它容易受到稍长一点但聪明的攻击。以下是这样一种攻击：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are able to core dump the Python interpreter with a rather obscure looking
    piece of malicious code. How did this happen ?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用一个看起来相当晦涩的恶意代码来使Python解释器崩溃。这是怎么发生的？
- en: Here is a somewhat detailed explanation of the steps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤的一些详细解释。
- en: 'First, let''s consider this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下这个：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is nothing but the base-class `object`. Since we don't have access to the
    built-ins, this is an indirect way to get access to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是基类`object`。由于我们无法访问内置函数，这是一种间接访问它的方法。
- en: 'Next, the following line of code loads all the sub-classes of `object` currently
    loaded in the Python interpreter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下代码行加载了Python解释器中当前加载的`object`的所有子类：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Among them, what we want is the `code` object type. This can be accessed by
    checking the name of the item via the `__name__` attribute:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，我们想要的是`code`对象类型。这可以通过检查项目的名称通过`__name__`属性来访问：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the same achieved by using an anonymous `lambda` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用匿名`lambda`函数实现的相同效果：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we want to execute this code object. However, `code` objects cannot be
    called directly. They need to be tied to a function in order for them to be called.
    This is achieved by wrapping the preceding `lambda` function in an outer `lambda`
    function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要执行这个代码对象。然而，`code`对象不能直接调用。它们需要绑定到一个函数才能被调用。这是通过将前面的`lambda`函数包装在外部`lambda`函数中实现的：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now our inner `lambda` function can be called in two steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的内部`lambda`函数可以分两步调用：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We finally invoke the `code` object via this outer `lambda` function by passing
    mostly default arguments. The code-string is passed as the string `BOOM`, which
    is, of course, a bogus code-string that causes the Python interpreter to segfault,
    producing a core-dump:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过这个外部的`lambda`函数调用`code`对象，传递了大多数默认参数。代码字符串被传递为字符串`BOOM`，当然，这是一个虚假的代码字符串，会导致Python解释器崩溃，产生核心转储：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows that `eval` in any context, even bereft of built-in module support,
    is unsafe, and can be exploited by a clever and malicious hacker to crash the
    Python interpreter, and thereby, possibly gain control over the system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在任何情况下，即使没有内置模块的支持，`eval`都是不安全的，并且可以被聪明而恶意的黑客利用来使Python解释器崩溃，从而可能控制系统。
- en: Note that the same exploit works in Python 3 as well, but we need some modification
    in the arguments to the `code` object, as in Python 3, `code` objects takes an
    extra argument. Also, the code-string and some arguments must be the `byte` type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，相同的利用在Python 3中也有效，但是我们需要对`code`对象的参数进行一些修改，因为在Python 3中，`code`对象需要额外的参数。此外，代码字符串和一些参数必须是`byte`类型。
- en: 'The following is the exploit running on Python 3\. The end result is the same:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python 3上运行的利用。最终结果是相同的：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Overflow errors
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出错误
- en: 'In Python 2, the `xrange()` function produces an overflow error if the range
    cannot fit into the integer range of Python:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，如果`xrange()`函数的范围无法适应Python的整数范围，则会产生溢出错误：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `range()` function also overflows with a slightly different error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数也会出现略有不同的溢出错误：'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The problem is that `xrange()` and `range()` use plain integer objects (type
    `<int>`) instead of automatically getting converted to the `long` type, which
    is limited only by the system memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`xrange()`和`range()`使用普通整数对象（类型`<int>`），而不是自动转换为仅受系统内存限制的`long`类型。
- en: 'However, this problem is fixed in the Python 3.x versions, as types `int` and
    `long` are unified into one (`int` type), and the `range()` objects manage the
    memory internally. Also, there is no longer a separate `xrange()` object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python 3.x版本中，这个问题已经得到解决，因为类型`int`和`long`被统一为一个（`int`类型），而`range()`对象在内部管理内存。此外，不再有单独的`xrange()`对象：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here is another example of integer overflow errors in Python, this time for
    the `len` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python中整数溢出错误的另一个例子，这次是针对`len`函数。
- en: In the following examples, we try the `len` function on instances of two classes
    A and B, whose magic method `__len__` has been over-ridden to provide support
    for the `len` function. Note that A is a new-style class, inheriting from `object`
    and B is an old-style class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们尝试对两个类A和B的实例使用`len`函数，这两个类的魔术方法`__len__`已被覆盖以支持`len`函数。请注意，A是一个新式类，继承自`object`，而B是一个旧式类。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the output of the code when executed with Python2:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python2中执行代码时的输出：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The same code is executed in Python 3 as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中执行相同的代码如下：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The problem in the preceding code is that `len` returns `integer` objects, and
    in this case, the actual value is too large to fit inside an `int`, so Python
    raises an overflow error. In Python 2, however, for the case when the class is
    not derived from `object`, the code executed is slightly different, which anticipates
    an `int` object, but gets `long` and throws a `TypeError` instead. In Python 3,
    both examples return overflow errors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中的问题在于`len`返回`integer`对象，在这种情况下，实际值太大而无法适应`int`，因此Python引发了溢出错误。然而，在Python
    2中，对于未从`object`派生的类的情况，执行的代码略有不同，它预期一个`int`对象，但得到了`long`并抛出了`TypeError`。在Python
    3中，这两个示例都返回溢出错误。
- en: Is there a security issue with integer overflow errors such as this?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的整数溢出错误是否存在安全问题？
- en: On the ground, it depends on the application code and the dependent module code
    used, and how they are able to deal with or catch/mask the overflow errors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况中，这取决于应用程序代码和所使用的依赖模块代码，以及它们如何处理或捕获/掩盖溢出错误。
- en: However, since Python is written in C, any overflow errors which are not correctly
    handled in the underlying C code can lead to buffer overflow exceptions, where
    an attacker can write to the overflow buffer and hijack the underlying process/application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于Python是用C编写的，任何在底层C代码中没有正确处理的溢出错误都可能导致缓冲区溢出异常，攻击者可以向溢出缓冲区写入并劫持底层进程/应用程序。
- en: Typically, if a module or data structure is able to handle the overflow error
    and raise exceptions preventing further code execution, the chances of code exploitation
    get reduced.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果一个模块或数据结构能够处理溢出错误并引发异常以阻止进一步的代码执行，那么代码利用的可能性就会减少。
- en: Serializing objects
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象序列化
- en: It is very common for Python developers to use the `pickle` module and its C
    implementation cousin `cPickle` for serializing objects in Python. However, both
    these modules allow unchecked execution of code, as they don't enforce any kind
    of type check or rules on the objects being serialized to verify whether it is
    a benign Python object or a potential command that can exploit the system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python开发人员来说，使用`pickle`模块及其C实现的`cPickle`来对Python中的对象进行序列化是非常常见的。然而，这两个模块都允许未经检查的代码执行，因为它们不对被序列化的对象进行任何类型检查或规则的强制，以验证它是一个良性的Python对象还是一个可能利用系统的潜在命令。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: In Python3, both the `cPickle` and `pickle` modules are merged into a
    single `pickle` module.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Python3中，`cPickle`和`pickle`模块合并为一个单独的`pickle`模块。
- en: 'Here is an illustration via a shell exploit, which lists the contents of the
    root folder (`/`) in a Linux/POSIX system:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过shell利用的示例，它列出了Linux/POSIX系统中根文件夹（/）的内容：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last code simply packages a `ShellExploit` class, which, upon pickling,
    returns the command for listing the contents of the root filesystem `/` by way
    of the `os.system()` method. The `Exploit` class thus masquerades malicious code
    into a `pickle` object, which, upon unpickling, executes the code, and exposes
    the contents of the root folder of the machine to the attacker. The output of
    the preceding code is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码简单地打包了一个`ShellExploit`类，该类在进行pickle时通过`os.system()`方法返回列出根文件系统`/`内容的命令。`Exploit`类将恶意代码伪装成`pickle`对象，该对象在解pickle时执行代码，并将机器的根文件夹内容暴露给攻击者。上述代码的输出如下所示：
- en: '![Serializing objects](../Images/image00466.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![序列化对象](../Images/image00466.jpeg)'
- en: Output of the shell exploit code for serializing using pickle, exposing contents
    of / folder.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pickle进行序列化的shell利用代码的输出，暴露了/文件夹的内容。
- en: As you can see, the output clearly lists the contents of the root folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输出清楚地列出了根文件夹的内容。
- en: What is the work-around to prevent such exploits?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如何防止这种利用的解决方法是什么？
- en: First of all, don't use an unsafe module like `pickle` for serialization in
    your applications. Instead, rely on a safer alternative like `json` or `yaml`.
    If your application really is dependent on using the `pickle` module for some
    reason, then use sand-boxing software or `codeJail` to create safe environments
    that prevent execution of malicious code on the system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不要在应用程序中使用像`pickle`这样的不安全模块进行序列化。而是依赖于更安全的替代方案，如`json`或`yaml`。如果你的应用程序确实依赖于某种原因使用`pickle`模块，那么使用沙箱软件或`codeJail`来创建防止系统上恶意代码执行的安全环境。
- en: 'For example, here is a slight modification of the earlier code, now with a
    simple chroot jail, which prevents code execution on the actual root folder. It
    uses a local `safe_root/` subfolder as the new root via a context-manager hook.
    Note that this is a simple-minded example. An actual jail would be much more elaborate
    than this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是对先前代码的轻微修改，现在使用一个简单的chroot监狱，防止在实际根文件夹上执行代码。它使用一个本地的`safe_root/`子文件夹作为新的根目录，通过上下文管理器钩子。请注意，这只是一个简单的例子。实际的监狱会比这个复杂得多：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this jail in place, the code executes as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个监狱，代码执行如下：
- en: '![Serializing objects](../Images/image00467.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![序列化对象](../Images/image00467.jpeg)'
- en: Output of the shell exploit code for serializing using pickle, with a simple
    chroot jail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pickle进行序列化的shell利用代码的输出，带有一个简单的chroot监狱。
- en: No output is produced now, because this is a fake jail, and Python cannot find
    the `ls` command in the new root. Of course, in order to make this work in a production
    system, a proper jail should be set up, which allows programs to execute, but
    at the same time, prevents or limits malicious program execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不会产生任何输出，因为这是一个虚假的监狱，Python在新根目录中找不到`ls`命令。当然，为了使这在生产系统中起作用，应该设置一个适当的监狱，允许程序执行，但同时防止或限制恶意程序的执行。
- en: How about other serialization formats like JSON ? Can such exploits work with
    them ? Let us see using an example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其他序列化格式如JSON怎么样？这样的利用可以使用它们吗？让我们用一个例子来看看。
- en: 'Here is the same serialization code written using the `json` module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`json`模块编写的相同序列化代码：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note how the default JSON encoder has been overridden using a custom encoder
    named `ExploitEncoder`. However, as the JSON format doesn''t support such serializations,
    it returns the correct serialization of the list passed as input:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用自定义编码器`ExploitEncoder`覆盖了默认的JSON编码器。然而，由于JSON格式不支持这种序列化，它返回了作为输入传递的列表的正确序列化：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With Python3, the exploit fails as Python3 raises an exception.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python3，利用程序失败，因为Python3会引发异常。
- en: '![Serializing objects](../Images/image00468.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![序列化对象](../Images/image00468.jpeg)'
- en: Output of the shell exploit code for serializing using json, with Python3
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python3进行序列化的shell利用代码的输出
- en: Security issues with web applications
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序的安全问题
- en: So far, we have seen four types of security issues with Python, namely, those
    with reading input, evaluating expressions, overflow errors, and serialization
    issues. All our examples so far have been with Python on the console.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Python的四种安全问题，即读取输入、评估表达式、溢出错误和序列化问题。到目前为止，我们所有的例子都是在控制台上使用Python。
- en: However, almost all of us interact with web applications on a daily basis, many
    of which are written in Python web frameworks such as Django, Flask, Pyramid,
    and others. Hence, it is more likely that we are exposed to security issues in
    such applications. We will look at a few examples here.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们几乎每天都与Web应用程序进行交互，其中许多是使用Python Web框架编写的，如Django、Flask、Pyramid等。因此，我们更有可能在这些应用程序中暴露出安全问题。我们将在这里看一些例子。
- en: Server Side Template Injection
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端模板注入
- en: '**Server Side Template Injection** (**SSTI**) is an attack using the server-side
    templates of common web frameworks as an attack vector. The attack uses weaknesses
    in the way user input is embedded on the templates. SSTI attacks can be used to
    figure out internals of a web application, execute shell commands, and even fully
    compromise the servers.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端模板注入**（**SSTI**）是一种使用常见Web框架的服务器端模板作为攻击向量的攻击。该攻击利用了用户输入嵌入模板的方式中的弱点。SSTI攻击可以用于查找Web应用程序的内部情况，执行shell命令，甚至完全破坏服务器。'
- en: We will see an example using a very popular web application framework in Python,
    namely, Flask.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个使用Python中非常流行的Web应用程序框架Flask的示例。
- en: 'The following is the sample code for a rather simple-minded web application
    in Flask with an inline template:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在Flask中使用内联模板的相当简单的Web应用程序的示例代码：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running it on the console, and opening it in the browser allows us to play
    around with the `hello-ssti` route:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上运行，并在浏览器中打开，允许我们在`hello-ssti`路由中玩耍：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, let us try some benign inputs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试一些良性输入：
- en: '![Server Side Template Injection](../Images/image00469.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入](../Images/image00469.jpeg)'
- en: Here is another example.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子。
- en: '![Server Side Template Injection](../Images/image00470.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入](../Images/image00470.jpeg)'
- en: Next, let us try with some crafty inputs which an attacker may use.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试一些攻击者可能使用的巧妙输入。
- en: '![Server Side Template Injection](../Images/image00471.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入](../Images/image00471.jpeg)'
- en: What is happening here?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: Since the template uses unsafe `%s` string templates, it evaluates anything
    that is passed to it into Python expressions. We passed `{{ person.secret }}`,
    which, in the Flask templating language (Flask uses Jinja2 templating), got evaluated
    to the value of the key secret in the dictionary `person`, effectively exposing
    the secret key of the app!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板使用不安全的`%s`字符串模板，它会将传递给它的任何内容评估为Python表达式。我们传递了`{{ person.secret }}`，在Flask模板语言（Flask使用Jinja2模板）中，它被评估为字典`person`中密钥secret的值，从而有效地暴露了应用程序的秘密密钥！
- en: 'We can perform even more ambitious attacks, as this hole in the code allows
    an attacker to try the full power of Jinja templates, including for loops. Here
    is an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行更加雄心勃勃的攻击，因为代码中的这个漏洞允许攻击者尝试Jinja模板的全部功能，包括for循环。以下是一个示例：
- en: '![Server Side Template Injection](../Images/image00472.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入](../Images/image00472.jpeg)'
- en: 'The URL used for the attack is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 用于攻击的URL如下：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This goes through a for loop, and tries to print all contents of the `person`
    dictionary.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一个for循环，尝试打印`person`字典的所有内容。
- en: This also allows an attacker easy access to the sensitive server-side configuration
    parameters. For example, he can print out the Flask configuration by passing the
    name parameter as `{{ config }}`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许攻击者轻松访问敏感的服务器端配置参数。例如，他可以通过将名称参数传递为`{{ config }}`来打印Flask配置。
- en: Here is the image of the browser, printing the server configuration using this
    attack.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器的图像，使用此攻击打印服务器配置。
- en: '![Server Side Template Injection](../Images/image00473.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入](../Images/image00473.jpeg)'
- en: Server-Side Template Injection – mitigation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端模板注入 - 缓解
- en: We saw in the previous section some examples of using server side templates
    as an attack vector to expose sensitive information of the web application/server.
    In this section, we will see how the programmer can safeguard his code against
    such attacks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到了一些使用服务器端模板作为攻击向量来暴露Web应用程序/服务器敏感信息的示例。在本节中，我们将看到程序员如何保护他的代码免受此类攻击。
- en: 'In this specific case, the fix for this is to use the specific variable that
    we want in the template rather than the dangerous, allow-all `%s` string. Here
    is the modified code with the fix:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，修复此问题的方法是在模板中使用我们想要的特定变量，而不是危险的、允许所有`%s`字符串。以下是带有修复的修改后的代码：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the earlier attacks all fizzle off.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，先前的所有攻击都会失败。
- en: 'Here is the browser image for the first attack:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次攻击的浏览器图像：
- en: '![Server-Side Template Injection – mitigation](../Images/image00474.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入 - 缓解](../Images/image00474.jpeg)'
- en: Here is the browser image for the next attack.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一次攻击的浏览器图像。
- en: '![Server-Side Template Injection – mitigation](../Images/image00475.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端模板注入 - 缓解](../Images/image00475.jpeg)'
- en: Denial of Service
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝服务
- en: Now let us look at another attack that is commonly used by malicious hackers,
    namely, **Denial of Service** (**DOS**).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一种常被恶意黑客使用的攻击，即**拒绝服务**（**DOS**）。
- en: DoS attacks target vulnerable routes or URLs in a web application, and sends
    them crafty packets or URLs, which either force the server to perform infinite
    loops or CPU-intensive computations, or forces it to load huge amounts of data
    from databases, which puts a lot of load on the server CPU preventing the server
    from executing other requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: DoS攻击针对Web应用程序中的易受攻击的路由或URL，并向其发送巧妙的数据包或URL，这些数据包或URL要么迫使服务器执行无限循环或CPU密集型计算，要么迫使服务器从数据库中加载大量数据，这会给服务器CPU带来很大负载，从而阻止服务器执行其他请求。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A DDoS or distributed DoS attack is when the DoS attack is performed in a choreographed
    way using multiple systems targeting a single domain. Usually thousands of IP
    addresses are used, which are managed via botnets for a DDoS attack.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: DDoS或分布式DoS攻击是指以协调的方式使用多个系统针对单个域的DoS攻击。通常使用数千个IP地址，这些IP地址通过僵尸网络进行管理以进行DDoS攻击。
- en: 'We will see a minimal example of a DoS attack using a variation of our previous
    example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个使用我们先前示例的变体的DoS攻击的最小示例：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we use a global template variable named `TEMPLATE`, and
    use the `safer {{ person.name }}` template variable as the one used with the SSTI
    fix. However, the additional code here is a replacement of the holding name `FOO`
    with the name value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用一个名为`TEMPLATE`的全局模板变量，并使用`safer {{ person.name }}`模板变量作为与SSTI修复一起使用的模板变量。但是，这里的附加代码是用名称值替换了持有名称`FOO`。
- en: This version has all the vulnerabilities of the original code, even with the
    `%s` code removed. For example, take a look at the following image of the browser
    exposing the `{{ person.secret }}` variable value in the body, but not in the
    title of the page.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本具有原始代码的所有漏洞，即使删除了`%s`代码。例如，看一下浏览器暴露了`{{ person.secret }}`变量值的图像，但没有在页面标题中暴露。
- en: '![Denial of Service](../Images/image00476.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![拒绝服务](../Images/image00476.jpeg)'
- en: This is due to this following line of code that we added as shown below.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于我们添加的以下代码行。
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Any expression passed is evaluated, including the arithmetic ones. For example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 任何传递的表达式都会被评估，包括算术表达式。例如：
- en: '![Denial of Service](../Images/image00477.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![拒绝服务](../Images/image00477.jpeg)'
- en: 'This opens up pathways to simple DoS attacks by passing in CPU-intensive computations
    that the server cannot handle. For example, in the following attack we pass in
    a very large computation of a number, which occupies the CPU of the system, slows
    the system down and makes the application non-responsive:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了通过传递服务器无法处理的CPU密集型计算的简单DoS攻击的途径。例如，在以下攻击中，我们传递了一个非常大的数字计算，它占用了系统的CPU，减慢了系统的速度，并使应用程序无响应：
- en: '![Denial of Service](../Images/image00478.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![拒绝服务](../Images/image00478.jpeg)'
- en: An example demonstrating a DoS style attack using computationally intensive
    code. The request never completes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算密集型代码演示DoS风格攻击的示例。请求从未完成。
- en: The URL used for this attack is `http://localhost:5000/hello-ssti?name=Tom`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此攻击使用的URL是`http://localhost:5000/hello-ssti?name=Tom`。
- en: By passing in the arithmetical expression `{{ 100**100000000 }}`, which is computationally
    intensive, the server is overloaded and cannot handle other requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传入计算密集的算术表达式`{{ 100**100000000 }}`，服务器被超载，无法处理其他请求。
- en: As you can see in the previous image, the request never completes, and also
    prevents the server from responding to other requests; as you can see from how
    a normal request to the same application on a new tab opened on the right side
    is also held up causing the effect of a DoS style attack .
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一张图片中所看到的，请求从未完成，也阻止了服务器响应其他请求；正如您可以从右侧打开的新标签页上对同一应用程序的正常请求也被阻塞，导致了DoS风格攻击的效果。
- en: '![Denial of Service](../Images/image00479.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![拒绝服务](../Images/image00479.jpeg)'
- en: A new tab opened on the right side of the tab with attack vector shows that
    the application has become unresponsive.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧打开的新标签页显示应用程序已经无响应。
- en: Cross-Site Scripting(XSS)
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）
- en: 'The code that we used in the earlier section to demonstrate a minimalistic
    DOS attack is also vulnerable to script injection. Here is an illustration:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中使用的代码来演示最小化DOS攻击也容易受到脚本注入的影响。以下是一个示例：
- en: '![Cross-Site Scripting(XSS)](../Images/image00480.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![跨站脚本攻击（XSS）](../Images/image00480.jpeg)'
- en: A simple demonstration of XSS scripting using server side templates and JavaScript
    injection
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端模板和JavaScript注入演示XSS脚本注入的简单示例
- en: 'The URL used for this attack is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此攻击使用的URL是：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These kinds of script injection vulnerabilities can lead to XSS, a common form
    of web exploit where attackers are able to inject malicious scripts into your
    server's code, which are loaded from other websites, and take control over it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本注入漏洞可能导致XSS，这是一种常见的Web利用形式，攻击者能够将恶意脚本注入到您服务器的代码中，从其他网站加载，并控制它。
- en: Mitigation – DoS and XSS
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓解- DoS和XSS
- en: We saw a few examples of DoS attacks and simple XSS attacks in the previous
    section. Now let us look at how the programmer can take steps in his code to mitigate
    such attacks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一些DoS攻击和简单的XSS攻击的示例。现在让我们看看程序员如何在他的代码中采取措施来缓解这种攻击。
- en: 'In the previous specific example that we have used for illustration, the fix
    is to remove the line that replaces the string `FOO` with the name value, and
    to replace it with the parameter template itself. For good measure, we also make
    sure that the output is properly escaped by using the escape filter, `|e`, of
    Jinja 2\. Here is the rewritten code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用于说明的先前特定示例中，修复方法是删除替换字符串`FOO`的行，并将其替换为参数模板本身。为了保险起见，我们还确保输出通过使用Jinja 2的转义过滤器`|e`进行适当的转义。以下是重写的代码：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that both of the vulnerabilities are mitigated, the attacks have no effect,
    and fail harmlessly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这两个漏洞都得到了缓解，攻击没有效果，也没有造成伤害。
- en: Here is an image demonstrating the Dos attack .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示DoS攻击的图像。
- en: '![Mitigation – DoS and XSS](../Images/image00481.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![缓解- DoS和XSS](../Images/image00481.jpeg)'
- en: Here is the one, demonstrating the XSS attack.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示XSS攻击的示例。
- en: '![Mitigation – DoS and XSS](../Images/image00482.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![缓解- DoS和XSS](../Images/image00482.jpeg)'
- en: Similar vulnerabilities due to bad code in server side templates exist in other
    Python web frameworks such as Django, Pyramid, Tornado, and others. However, a
    step-by-step discussion on each of these is beyond the scope of this chapter.
    The interested reader is directed to security resources on the web discussing
    such issues.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器端模板中的糟糕代码，类似的漏洞也存在于其他Python Web框架，如Django、Pyramid、Tornado等。然而，逐步讨论每个框架的内容超出了本章的范围。有兴趣的读者可以查阅网络上讨论此类问题的安全资源。
- en: Strategies for security – Python
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全策略- Python
- en: We have discussed quite a few vulnerabilities that exist in the core Python
    programming language, and also taken a look at some of the common security issues
    affecting Python web applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python编程语言核心中存在的许多漏洞，还看了一些影响Python Web应用程序的常见安全问题。
- en: 'The time is ripe now to go through strategies—tips and techniques that a security
    architect can use so that their team can apply secure coding principles to mitigate
    security issues right from the stage of program design and development:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候了解安全架构师可以使用的策略-提示和技术，以便他们的团队可以从程序设计和开发阶段开始应用安全编码原则来缓解安全问题：
- en: '**Reading input**: While reading console input, prefer rawinput over input,
    as the former doesn''t evaluate Python expressions, but returns input as plain
    strings. Any type conversions or validations should be done manually, and exceptions
    are thrown or errors returned if types don''t match. For reading passwords, use
    libraries such as getpass, and also perform validations on the returned data.
    Any evaluation of the data can be safely done once the validations succeed.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取输入**：在读取控制台输入时，优先使用raw_input而不是input，因为前者不会评估Python表达式，而是将输入作为纯字符串返回。任何类型转换或验证都应手动完成，如果类型不匹配，则抛出异常或返回错误。对于读取密码，使用getpass等库，并对返回的数据进行验证。一旦验证成功，可以安全地对数据进行评估。'
- en: '**Evaluating expressions**: As we''ve seen in our examples, eval always has
    loopholes whichever way it is used. Hence, the best strategy with Python is to
    avoid using evaland its evil cousin exec. If you have to use eval, make it a point
    to never use it with user input strings, or data read from third-party libraries,
    or APIs on which you have no control. Use eval only with input sources and return
    values from functions that you have control of and that you trust.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估表达式**：正如我们在示例中所看到的，eval无论如何使用都存在漏洞。因此，Python的最佳策略是避免使用eval及其邪恶的表亲exec。如果必须使用eval，请务必不要与用户输入字符串、或从第三方库或API读取的数据一起使用。只能与您控制并信任的函数的输入源和返回值一起使用eval。'
- en: '**Serialization**: Don''t use `pickle` or `cPickle` for serialization. Favor
    other modules such JASON or YAML. If you absolutely have to use `pickle`/`cPickle`,
    use mitigation strategies such as a chroot jail or sandbox to avoid the bad effects
    of malicious code execution if any.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化：不要使用`pickle`或`cPickle`进行序列化。更倾向于其他模块，如JASON或YAML。如果绝对必须使用`pickle`/`cPickle`，则使用缓解策略，如chroot监狱或沙盒，以避免恶意代码执行的不良影响。
- en: '**Overflow errors**: Guard against integer overflows by using exception handlers.
    Python doesn''t suffer from pure buffer overflow errors, as it always checks its
    containers for read/write access beyond the bounds and throws exceptions. For
    overridden `__len__` methods on classes, catch the overflow or `TypeError` exceptions
    as required.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出错误：通过使用异常处理程序来防范整数溢出。Python不会受到纯缓冲区溢出错误的影响，因为它总是检查其容器是否超出边界的读/写访问，并抛出异常。对于类中重写的`__len__`方法，根据需要捕获溢出或`TypeError`异常。
- en: '**String formatting**: Prefer the newer and safer format method of template
    strings over the older and unsafe `%s` interpolation.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化：更倾向于使用模板字符串的新方法，而不是旧的和不安全的`%s`插值。
- en: 'For example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Files**: When working with files, it is a good idea to use the with context
    managers to make sure that the file descriptors are closed after the operation.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：在处理文件时，最好使用上下文管理器来确保在操作后关闭文件描述符。
- en: 'For example, favor this approach:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，更倾向于这种方法：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And avoid the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 并避免以下情况：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will also ensure that the file descriptor is closed if any exception occurs
    during file read or write instead of keeping open file handles in the system.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将确保在文件读取或写入期间发生任何异常时关闭文件描述符，而不是在系统中保持打开文件句柄。
- en: '**Handling passwords and sensitive information**: When validating sensitive
    information like passwords, it is a good idea to compare cryptographic hashes
    rather than comparing the original data in memory:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理密码和敏感信息：在验证密码等敏感信息时，最好比较加密哈希而不是比较内存中的原始数据：
- en: 'This way, even if an attacker is able to pry out sensitive data from the program
    by exploits such as shell execution exploits or due to weaknesses in input data
    evaluation, the actual sensitive data is protected from immediate breach. Here
    is a simple approach for this:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，即使攻击者能够通过利用诸如shell执行漏洞或输入数据评估中的弱点等漏洞从程序中窃取敏感数据，实际的敏感数据也会受到保护，不会立即泄露。以下是一个简单的方法：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A more cryptographically correct technique is to use strong password-hashing
    libraries with built-in salt and a fixed number of hashing rounds.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 更加密码学上正确的技术是使用内置盐和固定数量的哈希轮次的强密码哈希库。
- en: 'Here is an example using the `passlib` library in Python:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python中使用`passlib`库的示例：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the purpose of illustration, a `passwd.db` sqlite database has been created
    with two users and their passwords, as seen in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，已创建了一个包含两个用户及其密码的`passwd.db` sqlite数据库，如下截图所示：
- en: '![Strategies for security – Python](../Images/image00483.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![安全策略- Python](../Images/image00483.jpeg)'
- en: 'Here is the code in action:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的实际操作：
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that for purposes of clarity, the typed password is shown here—it won't
    be shown in the actual program, since it uses the `getpass` library.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了清晰起见，此处显示了键入的密码-实际程序中不会显示，因为它使用`getpass`库。
- en: 'Here is the code in action:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的实际操作：
- en: '[PRE46]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Local data**: As much as possible, avoid storing sensitive data local to
    functions. Any input validation or evaluation loophole in the functions can be
    exploited then to gain access to the local stack, and hence, to the local data.
    Always store sensitive data encrypted or hashed separate modules.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地数据：尽量避免将敏感数据存储在函数的本地。函数中的任何输入验证或评估漏洞都可以被利用来访问本地堆栈，从而访问本地数据。始终将敏感数据加密或散列存储在单独的模块中。
- en: 'The following is a simple illustration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The above function is unsafe for the secret key 'secret' as any attacker gaining
    access to the function's stack can gain access to the secret as well.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数对于秘钥“secret”是不安全的，因为任何攻击者访问函数堆栈的能力都可以访问秘密。
- en: 'Such secrets are better kept in a separate module. If you are using the secret
    for hashing and verification the following code is much safer than the first,
    since it does not expose the original value of the ''secret'':'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这些秘密最好保存在一个单独的模块中。如果您正在使用秘密进行哈希和验证，以下代码比第一个更安全，因为它不会暴露“秘密”的原始值：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Race conditions**: Python provides an excellent set of threading primitives.
    If your program uses multiple threads and shared resources, follow these guidelines
    to synchronize access to resources to avoid race conditions and deadlocks:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件：Python提供了一组优秀的线程原语。如果您的程序使用多个线程和共享资源，请遵循以下准则来同步对资源的访问，以避免竞争条件和死锁：
- en: Protect resources that can be writeable concurrently by a mutex (`threading.Lock`)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过互斥锁（`threading.Lock`）保护可以同时写入的资源
- en: Protect resources that need to be serialized with respect to multiple, but limited,
    concurrent accesses by a semaphore (`threading.BoundedSemaphore`)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过信号量（`threading.BoundedSemaphore`）保护需要序列化的资源，以便对多个但有限的并发访问进行处理
- en: Use condition objects to wake up synchronize multiple threads waiting on a programmable
    condition or function ( threading.Condition)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件对象唤醒同步等待可编程条件或函数的多个线程（`threading.Condition`）
- en: Avoid loops which sleep for a while, wake up and then poll for a condition or
    criterion. Instead synchronize using condition or event objects ( threading.Event)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免循环一段时间后休眠，然后轮询条件或标准。而是使用条件或事件对象进行同步（`threading.Event`）
- en: For programs using multiple processes, similar counterparts provided by the
    `multiprocessing` library should be used to manage concurrent access to resources
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用多个进程的程序，应该使用`multiprocessing`库提供的类似对应物来管理对资源的并发访问
- en: '**Keep your system up to date**: Though this may sound cliched, keeping up
    to date with respect to security updates of packages in your system and with security
    news in general, especially on packages that impact your application, is a simple
    way to keep your system and application secure. A number of websites provide constant
    updates on the state of security of a number of opensource projects including
    Python and its standard library modules.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持系统更新**：尽管这听起来陈词滥调，但及时了解系统中软件包的安全更新以及一般安全新闻，特别是对影响您应用程序的软件包，是保持系统和应用程序安全的简单方法。许多网站提供了许多开源项目（包括Python及其标准库模块）安全状态的持续更新。'
- en: These reports usually go by the name of **Common Vulnerabilities and Exposures**
    (**CVEs**)—and sites such as Mitre ([http://cve.mitre.org](http://cve.mitre.org))
    provide a constant stream of updates.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些报告通常被称为**常见漏洞和暴露**（**CVEs**）-诸如Mitre（[http://cve.mitre.org](http://cve.mitre.org)）之类的网站提供不断更新的信息。
- en: 'A search for Python on this sites shows 213 results:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些网站上搜索Python显示了213个结果：
- en: '![Strategies for security – Python](../Images/image00484.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![安全策略- Python](../Images/image00484.jpeg)'
- en: Results for 'python' keyword search on Mitre CVE list
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mitre CVE列表上搜索'python'关键字的结果
- en: Architects, devops engineers, and webmasters can also tune in to their system
    package updates, and keep security updates always enabled by default. For remote
    severs, upgrading to the latest security patches once in two to three months is
    highly recommended.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师、运维工程师和网站管理员也可以调整系统软件包更新，并始终默认启用安全更新。对于远程服务器，建议每两到三个月升级到最新的安全补丁。
- en: Similarly, the Python **Open Web Application Security Project** (**OWASP**)
    project is a free, third-party project aimed at creating a hardened version of
    Python more resilient to security threats than the standard Cpython. It is part
    of the larger OWASP initiative.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，Python **开放式Web应用安全项目**（**OWASP**）是一个免费的第三方项目，旨在创建一个比标准Cpython更能抵御安全威胁的Python强化版本。它是更大的OWASP计划的一部分。
- en: 'The Python OWASP project makes available its Python bugreports, tools, and
    other artifacts via the website and associated GitHub projects. The main website
    for this is, and most of the code is available from the GitHub project page at:
    [https://github.com/ebranca/owasp-pysec/](https://github.com/ebranca/owasp-pysec/).![Strategies
    for security – Python](../Images/image00485.jpeg)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python OWASP项目通过其网站和相关的GitHub项目提供了Python错误报告、工具和其他工件。主要网站是，大部分代码可从GitHub项目页面获取：[https://github.com/ebranca/owasp-pysec/](https://github.com/ebranca/owasp-pysec/)。![安全策略-
    Python](../Images/image00485.jpeg)
- en: Home page of the OWASP Python security project
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP Python安全项目主页
- en: It is a good idea for the stakeholders to keep track of this project, run their
    tests, and read their reports to keep up to date on Python security aspects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于利益相关者来说，跟踪该项目、运行测试并阅读报告以了解Python安全方面的最新信息是一个好主意。
- en: Secure coding strategies
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全编码策略
- en: We are coming towards the end of our discussion on the security aspects of software
    architecture. It is a good time to summarize the strategies that one should try
    and impart to a software development team from a security architect's point of
    view. The following is a table summarizing the top 10 of these. Some of these
    may seem repeated from our earlier discussions, as we have seen them before.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束对软件架构安全方面的讨论。现在是总结应该从安全架构师的角度向软件开发团队传授的策略的好时机。以下是总结其中前10个策略的表格。其中一些可能与我们之前的讨论重复，因为我们之前已经看到过它们。
- en: '| SL | Strategy | How it helps |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| SL | 策略 | 它如何帮助 |'
- en: '| --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Validate inputs | Validate inputs from all untrusted data sources. Proper
    input validation can eliminate a vast majority of software vulnerabilities. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 验证输入 | 验证来自所有不受信任数据源的输入。适当的输入验证可以消除绝大多数软件漏洞。 |'
- en: '| 2 | Keep it simple | Keep program design as simple as possible. Complex designs
    increase the chances of security errors being made in their implementation, configuration,
    and deployment. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 保持简单 | 尽量简化程序设计。复杂的设计增加了在实施、配置和部署过程中出现安全错误的几率。 |'
- en: '| 3 | Principle of least privilege | Every process should execute with the
    least set of system privileges necessary to complete the work. For example, to
    read data from /tmp, one doesn''t need root permission, but any unprivileged user
    is fine. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 最小权限原则 | 每个进程应以完成工作所需的最少系统权限执行。例如，要从/tmp读取数据，不需要root权限，但任何非特权用户都可以。 |'
- en: '| 4 | Sanitize data | Sanitize data read from and sent to all third-party systems
    such as databases, command shells, COTs components, third-party middlewares, and
    so on. This lessens the chances of SQL injection, shell exploit, or other similar
    attacks. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 清理数据 | 清理从所有第三方系统（如数据库、命令行shell、COTs组件、第三方中间件等）读取和发送的数据。这减少了SQL注入、shell利用或其他类似攻击的机会。
    |'
- en: '| 5 | Authorize access | Separate parts of your application by roles that need
    specific authentication via login or other privileges. Don''t mix different parts
    of applications together in the same code that requires different levels of access.
    Employ proper routing to make sure that no sensitive data is exposed via unprotected
    routes. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 授权访问 | 通过需要特定身份验证的角色将应用程序的各个部分分开。不要在同一代码中混合不同部分的应用程序，这些部分需要不同级别的访问权限。采用适当的路由确保不会通过未受保护的路由暴露敏感数据。
    |'
- en: '| 6 | Perform effective QA | Good security testing techniques are effective
    in identifying and eliminating vulnerabilities. Fuzz testing, penetration testing,
    and source code audits should be performed as part of the program. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 进行有效的QA | 良好的安全测试技术能够有效地识别和消除漏洞。模糊测试、渗透测试和源代码审计应作为程序的一部分进行。'
- en: '| 7 | Practice defense in layers | Mitigate risks with multiple layers of security.
    For example, combining secure programming techniques with secure runtime configuration
    will reduce the chances of any remaining code vulnerabilities being exposed in
    the runtime environment. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 分层实践防御 | 通过多层安全性减轻风险。例如，将安全编程技术与安全运行时配置相结合，将减少在运行时环境中暴露任何剩余代码漏洞的机会。 |'
- en: '| 8 | Define security requirements | Identify and document the security constraints
    in the early lifecycle of the system, and keep updating them making sure that
    any further features down the line keep up with these requirements. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 定义安全需求 | 在系统早期生命周期中识别和记录安全约束，并不断更新它们，确保后续功能符合这些要求。 |'
- en: '| 9 | Model threats | Use threat modeling to anticipate the threats to which
    the software will be subjected. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 建模威胁 | 使用威胁建模来预测软件将受到的威胁。 |'
- en: '| 10 | Architect and design for security policies | Create and maintain a software
    architecture that enforces a pattern of consistent security policies across your
    system and its subsystems. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 为安全策略进行架构和设计 | 创建并维护一个软件架构，强制执行一致的安全策略模式，覆盖系统及其子系统。 |'
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with looking at the details of a system architecture
    that builds in security. We went on to define secure coding, and looked at the
    philosophies and principles behind the practice of secure coding.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先看了一个建立安全性的系统架构的细节。我们继续定义了安全编码，并研究了安全编码实践背后的哲学和原则。
- en: We then studied the different types of common security vulnerabilities encountered
    in software systems, such as buffer overflows, input validation issues, access
    control issues, cryptographic weaknesses, information leaks, insecure file operations,
    and so on.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了软件系统中遇到的常见安全漏洞类型，如缓冲区溢出、输入验证问题、访问控制问题、加密弱点、信息泄漏、不安全的文件操作等。
- en: We then went on to a detailed discussion on Python security issues with a lot
    of examples. We looked in detail at reading and evaluating input, overflow errors,
    and serialization issues. We then went on to look at the common vulnerabilities
    in Python web application frameworks with Flask being the candidate of choice.
    We saw how one can exploit the weaknesses on web application templates, and perform
    attacks such as SSTI, XSS, and DOS. We also saw multiple code examples of how
    to mitigate these attacks.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们详细讨论了Python安全问题，并举了很多例子。我们详细研究了读取和评估输入、溢出错误和序列化问题。然后，我们继续研究了Python Web应用程序框架中的常见漏洞，选择了Flask作为候选对象。我们看到了如何利用Web应用程序模板的弱点，并执行SSTI、XSS和DOS等攻击。我们还看到了如何通过多个代码示例来减轻这些攻击。
- en: We then went on to list specific techniques in Python for writing secure code.
    We looked in detail at managing cryptographic hashes of passwords and other sensitive
    data in code, and discussed a couple of examples of doing this the right way.
    The importance of keeping oneself updated with security news and projects, and
    keeping the system updated with security patches was also mentioned.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们列出了Python中编写安全代码的具体技术。我们详细研究了在代码中管理密码和其他敏感数据的加密哈希，并讨论了一些正确的示例。还提到了保持自己了解安全新闻和项目的重要性，以及保持系统更新安全补丁的重要性。
- en: Finally, we summarized the top 10 secure coding strategies that a security architect
    can impart to their team in order to create secure code and systems.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们总结了安全编码策略的前十名，安全架构师可以向团队传授这些策略，以创建安全的代码和系统。
- en: In the next chapter, we take a look at one of the most interesting aspects of
    software engineering and design, namely that of design patterns.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下软件工程和设计中最有趣的方面之一，即设计模式。
