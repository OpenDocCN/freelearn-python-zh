- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Distributed Systems Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统模式
- en: As technology evolves and the demand for scalable and resilient systems increases,
    understanding the fundamental patterns that govern distributed systems becomes
    paramount.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步和对可扩展和弹性系统的需求增加，了解支配分布式系统的基本模式变得至关重要。
- en: From managing communication between nodes to ensuring **fault tolerance** (**FT**)
    and consistency, this chapter explores essential design patterns that empower
    developers to architect robust distributed systems. Whether you’re building microservices
    or implementing cloud-native applications, mastering these patterns will equip
    you with the tools to tackle the complexities of distributed computing effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理节点间的通信到确保**容错性**（**FT**）和一致性，本章探讨了使开发者能够构建强大分布式系统的基本设计模式。无论你是构建微服务还是实施云原生应用程序，掌握这些模式都将为你提供有效应对分布式计算复杂性的工具。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The Throttling pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流模式
- en: The Retry pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试模式
- en: The Circuit Breaker pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器模式
- en: Other distributed systems patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他分布式系统模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).The
    additional technical requirements for the code discussed in this chapter are the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](B21896_01.xhtml#_idTextAnchor017)中提出的需求。本章讨论的代码的附加技术要求如下：
- en: Install Flask and Flask-Limiter, using `python -m pip install` `flask flask-limiter`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`python -m pip install flask flask-limiter`安装Flask和Flask-Limiter
- en: Install PyBreaker, using `python -m pip` `install pybreaker`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`python -m pip install pybreaker`安装PyBreaker
- en: The Throttling pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流模式
- en: Throttling is an important pattern we may need to use in today’s applications
    and APIs. In this context, throttling means controlling the rate of requests a
    user (or a client service) can send to a given service or API in a given amount
    of time, to protect the resources of the service from being overused. For example,
    we may limit the number of user requests for an API to 1,000 per day. Once that
    limit is reached, the next request is handled by sending an error message with
    the 429 HTTP status code to the user with a message saying that there are too
    many requests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 节流是我们今天的应用程序和API中可能需要使用的重要模式。在这种情况下，节流意味着控制用户（或客户端服务）在给定时间内可以向特定服务或API发送请求的速率，以保护服务资源不被过度使用。例如，我们可能将API的用户请求限制为每天1000次。一旦达到这个限制，下一个请求将通过向用户发送包含429
    HTTP状态代码的错误消息来处理，并告知用户请求过多。
- en: There are many things to understand about throttling, including which limiting
    strategy and algorithm one may use and measuring how the service is used. You
    can find technical details about the Throttling pattern in the catalog of cloud
    design patterns by Microsoft ([https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling](https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于节流有许多需要理解的内容，包括可能使用的限制策略和算法以及如何衡量服务的使用情况。你可以在微软的云设计模式目录中找到有关节流模式的详细技术信息（[https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling](https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling)）。
- en: Real-world examples
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'There are a lot of examples of throttling in real life, such as the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中有很多节流的例子，如下所示：
- en: '**Highway traffic management**: Traffic lights or speed limits regulate the
    flow of vehicles on a highway'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高速公路交通管理**：交通信号灯或限速规定调节高速公路上的车辆流量'
- en: '**Water faucet**: Adjusting the flow of water from a faucet'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水龙头**：调节水龙头的水流'
- en: '**Concert ticket sales**: When tickets for a popular concert go on sale, the
    website may limit the number of tickets each user can purchase at once to prevent
    the server from crashing due to a sudden surge in demand'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐会票销售**：当热门音乐会的票开始销售时，网站可能会限制每个用户一次可以购买的票数，以防止服务器因需求激增而崩溃'
- en: '**Electricity usage**: Some utility companies offer plans where customers pay
    different rates based on their electricity usage during peak and off-peak hours'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电力使用**：一些公用事业公司提供基于高峰时段和非高峰时段电力使用情况的不同收费计划的方案'
- en: '**Buffet line**: In a buffet, customers may be limited to taking only one plate
    of food at a time to ensure that everyone has a fair chance to eat and to prevent
    food wastage'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自助餐队列**：在自助餐中，为了确保每个人都有公平的机会进食并防止食物浪费，顾客可能一次只能取一份食物'
- en: 'We also have examples of pieces of software that help implement throttling:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有帮助实现速率限制的软件片段的示例。
- en: '`django-throttle-requests` ([https://github.com/sobotklp/django-throttle-requests](https://github.com/sobotklp/django-throttle-requests))
    is a framework for implementing application-specific rate-limiting middleware
    for Django projects'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-throttle-requests` ([https://github.com/sobotklp/django-throttle-requests](https://github.com/sobotklp/django-throttle-requests))
    是一个用于实现Django项目特定速率限制中间件的框架'
- en: Flask-Limiter ([https://flask-limiter.readthedocs.io/en/stable/](https://flask-limiter.readthedocs.io/en/stable/))
    provides rate-limiting features to Flask routes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-Limiter ([https://flask-limiter.readthedocs.io/en/stable/](https://flask-limiter.readthedocs.io/en/stable/))
    为Flask路由提供速率限制功能
- en: Use cases for the Throttling pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制模式的用例
- en: This pattern is recommended when you need to ensure your system continuously
    delivers the service as expected, when you need to optimize the cost of usage
    of the service, or when you need to handle bursts in activity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要确保你的系统持续提供预期的服务，当你需要优化服务的使用成本，或者当你需要处理活动高峰时，这种模式是推荐的。
- en: 'In practice, you may implement the following rules:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可以实施以下规则：
- en: Limit the number of total requests to an API as N/day (for example, N=1000)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API的总请求数限制为每天N次（例如，N=1000）
- en: Limit the number of requests to an API as N/day from a given IP address, or
    from a given country or region
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从给定的IP地址、国家或地区限制API的请求次数为每天N次
- en: Limit the number of reads or writes for authenticated users
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制认证用户的读写次数
- en: In addition to the rate-limiting cases, it can be used for *resource allocation*,
    ensuring fair distribution of resources among multiple clients.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速率限制的情况外，它还可以用于*资源分配*，确保在多个客户端之间公平分配资源。
- en: Implementing the Throttling pattern
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现速率限制模式
- en: Before diving into an implementation example, you need to know that there are
    several types of throttling, among which are Rate-Limit, IP-level Limit (based
    on a list of whitelisted IP addresses, for example), and Concurrent Connections
    Limit, to only cite those three. The first two are relatively easy to experiment
    with. We will focus on the first one here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现示例之前，你需要知道存在几种类型的速率限制，其中包括速率限制、基于白名单IP地址列表的IP级别限制（例如）和并发连接限制，仅举这三个为例。前两种相对容易实验。我们将在这里重点关注第一种。
- en: Let’s see an example of rate-limit-type throttling using a minimal web application
    developed using Flask and its Flask-Limiter extension.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Flask及其Flask-Limiter扩展开发的简单Web应用程序的速率限制类型速率限制的示例。
- en: 'We start with the imports we need for the example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从示例所需的导入开始：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As is usual with Flask, we set up the Flask application with the following
    two lines:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flask一样，我们使用以下两行设置Flask应用程序：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then define the Limiter instance; we create it by passing a key function,
    `get_remote_address` (which we imported), the application object, the default
    limits values, and other parameters, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义Limiter实例；我们通过传递一个键函数`get_remote_address`（我们已导入）、应用程序对象、默认限制值和其他参数来创建它，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Based on that, we can define a route for the `/limited` path, which will be
    rate-limited using the default limits, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以为`/limited`路径定义一个路由，它将使用默认限制进行速率限制，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also add the definition for a route for the `/more_limited` path. In this
    case, we decorate the function with `@limiter.limit("2/minute")` to ensure a rate
    limit of two requests per minute. The code is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`/more_limited`路径的路由定义。在这种情况下，我们使用`@limiter.limit("2/minute")`装饰器确保每分钟两个请求的速率限制。代码如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we add the snippet that is conventional for Flask applications:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了Flask应用程序中常用的片段：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test this example, run the file (`ch09/throttling_flaskapp.py`) using the
    `python ch09/throttling_flaskapp.py` command. You would get the usual output for
    a Flask application that is starting:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此示例，请使用`python ch09/throttling_flaskapp.py`命令运行文件。你会得到一个启动的Flask应用程序的常规输出：
- en: '![Figure 9.1 – throttling_flaskapp: Flask application example startup](img/B21896_09_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – throttling_flaskapp：Flask应用程序示例启动](img/B21896_09_1.jpg)'
- en: 'Figure 9.1 – throttling_flaskapp: Flask application example startup'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – throttling_flaskapp：Flask应用程序示例启动
- en: 'Then, if you point your browser to `http://127.0.0.1:5000/limited`, you will
    see the welcome content displayed on the page, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你将浏览器指向`http://127.0.0.1:5000/limited`，你将看到页面上的欢迎内容，如下所示：
- en: '![Figure 9.2 – Response to the /limited endpoint in the browser](img/B21896_09_2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 浏览器中/limited端点的响应](img/B21896_09_2.jpg)'
- en: Figure 9.2 – Response to the /limited endpoint in the browser
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 浏览器中/limited端点的响应
- en: 'It gets interesting if you keep hitting the **Refresh** button. The 10th time,
    the page content will change and show you a **Too Many Requests** error message,
    as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您继续点击**刷新**按钮，情况会变得有趣。第10次点击时，页面内容将改变并显示一个**请求过多**的错误消息，如下面的截图所示：
- en: '![Figure 9.3 – Too many requests on the /limited endpoint](img/B21896_09_3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 在/limited端点上的请求过多](img/B21896_09_3.jpg)'
- en: Figure 9.3 – Too many requests on the /limited endpoint
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 在/limited端点上的请求过多
- en: 'Let’s not stop here. Remember – there is a second route in the code, `/more_limited`,
    with a specific limit of two requests per minute. To test that second route, point
    your browser to `http://127.0.0.1:5000/more_limited`. You will see new welcome
    content displayed on the page, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要就此止步。记住——代码中还有第二条路由，即`/more_limited`，每分钟限制两个请求。为了测试第二条路由，将您的浏览器指向`http://127.0.0.1:5000/more_limited`。您将在页面上看到新的欢迎内容，如下所示：
- en: '![Figure 9.4 – Response to the /more_limited endpoint in the browser](img/B21896_09_4.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 浏览器中/more_limited端点的响应](img/B21896_09_4.jpg)'
- en: Figure 9.4 – Response to the /more_limited endpoint in the browser
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 浏览器中/more_limited端点的响应
- en: 'If we hit the **Refresh** button and do it more than twice in a window of 1
    minute, we get another **Two Many Requests** message, as shown in the following
    screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击**刷新**按钮，在1分钟内点击超过两次，我们将收到另一个**请求过多**的消息，如下面的截图所示：
- en: '![Figure 9.5 – Too many requests on the /more_limited endpoint](img/B21896_09_5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 在/more_limited端点上的请求过多](img/B21896_09_5.jpg)'
- en: Figure 9.5 – Too many requests on the /more_limited endpoint
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 在/more_limited端点上的请求过多
- en: 'Also, looking at the console where the Flask server is running, you will notice
    the mention of each HTTP request received and the status code of the response
    the application sent. It should look like the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，查看Flask服务器运行的控制台，您会注意到对每个接收到的HTTP请求和应用程序发送的响应状态码的提及。它应该看起来像下面的截图：
- en: '![Figure 9.6 – Flask server console: Responses to the HTTP requests](img/B21896_09_6.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – Flask服务器控制台：对HTTP请求的响应](img/B21896_09_6.jpg)'
- en: 'Figure 9.6 – Flask server console: Responses to the HTTP requests'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – Flask服务器控制台：对HTTP请求的响应
- en: There are many possibilities for rate-limit-type throttling in a Flask application
    using the Flask-Limiter extension, as you can see on the documentation page of
    the module. The reader can find more information on the documentation page on
    how to use different strategies and storage backends such as Redis for a specific
    implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Flask-Limiter扩展的Flask应用程序中，有许多速率限制类型节流的可能性，正如您可以在模块的文档页面中看到的那样。读者可以在文档页面上找到更多关于如何使用不同策略和存储后端（如Redis）进行特定实现的信息。
- en: The Retry pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试模式
- en: Retrying is an approach that is increasingly needed in the context of distributed
    systems. Think about microservices or cloud-based infrastructures where components
    collaborate with each other but are not developed or deployed/operated by the
    same teams and parties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统的背景下，重试是一种越来越需要的策略。想想微服务或基于云的基础设施，其中组件相互协作，但不是由同一团队和各方开发和部署/运营。
- en: In its daily operation, parts of a cloud-native application may experience what
    are called transient faults or failures, meaning some mini-issues that can look
    like bugs but are not due to your application itself; rather, they are due to
    some constraints outside of your control such as the networking or the external
    server/service performance. As a result, your application may malfunction (at
    least, that could be the perception of your users) or even hang in some places.
    The answer to the risk of such failures is to put in place some retry logic so
    that we pass through the issue by calling the service again, maybe immediately
    or after some wait time (such as a few seconds).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在其日常运营中，云原生应用程序的部分可能会遇到所谓的短暂故障或失败，这意味着一些看似错误但并非由于您的应用程序本身的问题；相反，它们是由于您无法控制的某些约束，如网络或外部服务器/服务的性能。因此，您的应用程序可能会出现故障（至少，这可能就是用户的感知）或在某些地方挂起。应对这种失败风险的答案是实施一些重试逻辑，这样我们就可以通过再次调用服务来通过问题，可能是立即或在等待一段时间（如几秒钟）之后。
- en: Real-world examples
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'There are examples of the Retry pattern (or analogies) in our daily life, such
    as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，有许多重试模式（或类比）的例子，如下所示：
- en: '**Making a phone call**: Imagine you’re trying to reach a friend on the phone,
    but the call doesn’t go through because their line is busy or there’s a network
    issue. Instead of giving up immediately, you retry dialing their number after
    a short delay.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打电话**：想象你正在尝试通过电话联系一个朋友，但由于他们的线路繁忙或存在网络问题，电话无法接通。你不会立即放弃，而是在短暂的延迟后重试拨打他们的号码。'
- en: '**Withdrawing money from an ATM**: Imagine you go to an ATM to withdraw cash,
    but due to a temporary issue such as network congestion or connectivity problems,
    the transaction fails, and the machine displays an error message. Instead of giving
    up on getting cash, you wait a moment and try the transaction again. This time,
    the transaction may go through successfully, allowing you to withdraw the money
    you need.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从ATM取款**：想象你前往ATM取现金，但由于网络拥塞或连接问题等暂时性问题，交易失败，机器显示错误信息。你不会放弃取款，而是稍作等待，再次尝试交易。这次，交易可能会成功，让你取出所需的现金。'
- en: 'There are also many tools or techniques that we can consider as examples in
    the software realm since they help implement the Retry pattern, such as the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，也有许多工具或技术可以被视为示例，因为它们有助于实现重试模式，例如以下内容：
- en: In Python, the Retrying library ([https://github.com/rholder/retrying](https://github.com/rholder/retrying))
    is available to simplify the task of adding retry behavior to our functions
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，Retrying库（[https://github.com/rholder/retrying](https://github.com/rholder/retrying)）可用于简化将重试行为添加到我们的函数中的任务
- en: The Pester library ([https://github.com/sethgrid/pester](https://github.com/sethgrid/pester))
    for Go developers
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go开发者的Pester库（[https://github.com/sethgrid/pester](https://github.com/sethgrid/pester)）
- en: Use cases for the Retry pattern
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试模式的用例
- en: This pattern is recommended to alleviate the impact of identified transient
    failures while communicating with an external component or service, due to network
    failure or server overload.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络故障或服务器过载，与外部组件或服务通信时，此模式建议用于减轻已识别的暂时性故障的影响。
- en: Note that the retrying approach is not recommended for handling failures such
    as internal exceptions caused by errors in the application logic itself. Also,
    we must analyze the response from the external service. If the application experiences
    frequent busy faults, it’s often a sign that the service being accessed has a
    scaling issue that should be addressed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重试方法不建议用于处理由应用程序逻辑本身错误引起的内部异常。此外，我们必须分析外部服务的响应。如果应用程序经常出现繁忙故障，这通常是一个迹象，表明被访问的服务存在需要解决的扩展问题。
- en: We can relate retrying to the microservices architecture, where services often
    communicate over the network. The Retry pattern ensures that transient failures
    don’t cause the entire system to fail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将重试与微服务架构联系起来，其中服务通常通过网络进行通信。重试模式确保暂时性故障不会导致整个系统失败。
- en: Another type of use case is *data synchronization*. When syncing data between
    two systems, retries can handle the temporary unavailability of one system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种用例是*数据同步*。当在两个系统之间同步数据时，重试可以处理一个系统的暂时不可用。
- en: Implementing the Retry pattern
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现重试模式
- en: In this example, we’ll implement the Retry pattern for a database connection.
    We’ll use a decorator to handle the retry mechanism.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将实现数据库连接的重试模式。我们将使用装饰器来处理重试机制。
- en: 'We start with the `import` statements for the example, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下示例的`import`语句开始：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then add configuration for logging, which will help for observability when
    using the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加配置以记录日志，这有助于在使用代码时的可观察性：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We add our function that will support the decorator to automatically retry
    the execution of the decorated function up to the number of attempts specified,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加我们的函数，该函数将支持装饰器自动重试被装饰函数的执行，直到达到指定的尝试次数，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we add the `connect_to_database()` function, which simulates a database
    connection. It is decorated by the `@retry` decorator. We want the decorator to
    automatically retry the connection up to three times if it fails:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加`connect_to_database()`函数，该函数模拟数据库连接。它被`@retry`装饰器装饰。我们希望装饰器在连接失败时自动重试连接，最多重试三次：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, to make it convenient to test our implementation, we add the following
    testing code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了方便测试我们的实现，我们添加以下测试代码：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To test the example, run the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试示例，请运行以下命令：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get an output like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下类似的输出：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, when a temporary database error occurs, a retry happens. Several retry attempts
    may occur, until three. Once three unsuccessful retry attempts have occurred,
    the outcome is the failure of the operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当临时数据库错误发生时，会进行重试。可能会发生几次重试，直到三次。一旦发生三次不成功的重试尝试，操作的结果就是失败。
- en: Overall, the Retry pattern is a viable way to handle this type of use case involved
    with distributed systems, and a few errors (four database errors in our example)
    may mean that there is a more permanent or problematic bug that should be fixed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，重试模式是处理涉及分布式系统的此类用例的有效方式，几个错误（例如我们示例中的四个数据库错误）可能意味着存在一个更永久或问题性的错误，应该修复。
- en: The Circuit Breaker pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: 'One approach to FT involves retries, as we have just seen. But, when a failure
    due to communication with an external component is likely to be long-lasting,
    using a retry mechanism can affect the responsiveness of the application. We might
    be wasting time and resources trying to repeat a request that’s likely to fail.
    This is where another pattern can be useful: the Circuit Breaker pattern.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现FT（故障转移）的一种方法涉及重试，正如我们刚才看到的。但是，当由于与外部组件通信导致的失败可能持续很长时间时，使用重试机制可能会影响应用程序的响应性。我们可能会浪费时间和资源尝试重复一个可能失败的请求。这就是另一个模式可以派上用场的地方：断路器模式。
- en: With the Circuit Breaker pattern, you wrap a fragile function call, or an integration
    point with an external service, in a special (circuit breaker) object, which monitors
    for failures. Once the failures reach a certain threshold, the circuit breaker
    trips and all subsequent calls to the circuit breaker return with an error, without
    the protected call being made at all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断路器模式，你将一个脆弱的函数调用或与外部服务的集成点包装在一个特殊的（断路器）对象中，该对象会监控失败。一旦失败达到某个阈值，断路器就会跳闸，所有后续的断路器调用都会返回错误，而受保护的调用根本不会执行。
- en: Real-world examples
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: In life, we can think of a water or electricity distribution circuit where a
    circuit breaker plays an important role.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在生活中，我们可以想到一个水或电力分配电路，其中断路器扮演着重要的角色。
- en: 'In software, a circuit breaker is used in the following examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，断路器在以下示例中使用：
- en: '**E-commerce checkout**: If the payment gateway is down, the circuit breaker
    can halt further payment attempts, preventing system overload'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子商务结账**：如果支付网关关闭，断路器可以停止进一步的支付尝试，防止系统过载'
- en: '**Rate-limited APIs**: When an API has reached its rate limit, a circuit breaker
    can stop additional requests to avoid penalties'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制的API**：当一个API达到其速率限制时，断路器可以停止额外的请求以避免处罚'
- en: Use cases for the Circuit Breaker pattern
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断路器模式的用例
- en: As already said, the Circuit Breaker pattern is recommended when you need a
    component from your system to be fault-tolerant to long-lasting failures when
    communicating with an external component, service, or resource. Next, we will
    understand how it addresses such use cases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你的系统需要与外部组件、服务或资源通信时，断路器模式在需要组件对长期失败具有容错能力时是推荐的。接下来，我们将了解它是如何解决这些用例的。
- en: Implementing the Circuit Breaker pattern
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现断路器模式
- en: Let’s say you want to use a circuit breaker on a flaky function, a function
    that is fragile, for example, due to the networking environment it depends on.
    We are going to use the `pybreaker` library ([https://pypi.org/project/pybreaker/](https://pypi.org/project/pybreaker/))
    to show an example of implementing the Circuit Breaker pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在一个不可靠的函数上使用断路器，一个由于它依赖的网络环境而脆弱的函数，例如。我们将使用`pybreaker`库（[https://pypi.org/project/pybreaker/](https://pypi.org/project/pybreaker/））来展示实现断路器模式的示例。
- en: 'Our implementation is an adaptation of a nice script I found in this repository:
    [https://github.com/veltra/pybreaker-playground](https://github.com/veltra/pybreaker-playground).
    Let’s go through the code.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现是对这个仓库中找到的一个很好的脚本的改编：[https://github.com/veltra/pybreaker-playground](https://github.com/veltra/pybreaker-playground)。让我们来看一下代码。
- en: 'We start with our imports, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入开始，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s define our circuit breaker to automatically open the circuit after five
    consecutive failures in that function. We need to create an instance of the `pybreaker.CircuitBreaker`
    class, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的断路器，在函数中连续五次失败后自动打开电路。我们需要创建一个`pybreaker.CircuitBreaker`类的实例，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we create our version of the function to simulate fragile calls. We use
    the decorator syntax to protect things, so the new function is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们版本的函数来模拟脆弱的调用。我们使用装饰器语法来保护这些操作，因此新的函数如下所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, here’s the main part of the code, with the `main()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是代码的主要部分，包括`main()`函数：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Calling this script by running the `python ch09/circuit_breaker.py` command
    produces the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`python ch09/circuit_breaker.py`命令来调用此脚本会产生以下输出：
- en: '![Figure 9.7 – Output of our program using a circuit breaker](img/B21896_09_7.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 使用断路器的程序输出](img/B21896_09_7.jpg)'
- en: Figure 9.7 – Output of our program using a circuit breaker
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 使用断路器的程序输出
- en: 'By closely looking at the output, we can see that the circuit breaker does
    its job as expected: when it is open, all `fragile_function()` calls fail immediately
    (since they raise the `CircuitBreakerError` exception) without any attempt to
    execute the intended operation. And, after a timeout of 5 seconds, the circuit
    breaker will allow the next call to go through. If that call succeeds, the circuit
    is closed; if it fails, the circuit is opened again until another timeout elapses.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细查看输出，我们可以看到断路器按预期工作：当它打开时，所有对`fragile_function()`的调用都会立即失败（因为它们会引发`CircuitBreakerError`异常），而不会尝试执行预期的操作。并且，在5秒的超时后，断路器将允许下一个调用通过。如果该调用成功，电路将关闭；如果失败，电路将再次打开，直到另一个超时结束。
- en: Other distributed systems patterns
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他分布式系统模式
- en: 'There are many more distributed systems patterns than the ones we covered here.
    Among the other patterns developers and architects can use are the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们这里提到的模式之外，还有许多其他分布式系统模式。开发者和架构师可以使用的其他模式包括以下内容：
- en: '**Command and Query Responsibility Segregation (CQRS)**: This pattern separates
    the responsibilities for reading and writing data, allowing for optimized data
    access and scalability by tailoring data models and operations to specific use
    cases'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令和查询责任分离（CQRS）**：此模式将读取和写入数据的责任分开，通过针对特定用例定制数据模型和操作，优化数据访问和可扩展性。'
- en: '**Two-Phase Commit**: This distributed transaction protocol ensures atomicity
    and consistency across multiple participating resources by coordinating a two-phase
    commit process, involving a *prepare* phase followed by a *commit* phase'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两阶段提交**：此分布式事务协议通过协调两阶段提交过程，确保多个参与资源之间的原子性和一致性，包括一个*准备*阶段和一个随后的*提交*阶段。'
- en: '**Saga**: A saga is a sequence of local transactions that together form a distributed
    transaction, providing a compensating mechanism to maintain consistency in the
    face of partial failures or aborted transactions'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叙事**：叙事是一系列本地事务的序列，这些事务共同构成一个分布式事务，提供补偿机制以在部分失败或事务中止的情况下保持一致性。'
- en: '**Sidecar**: The Sidecar pattern involves deploying additional helper services
    alongside primary services to enhance functionality, such as adding monitoring,
    logging, or security features without directly modifying the main application'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边车**：边车模式涉及在主要服务旁边部署额外的辅助服务以增强功能，例如添加监控、日志记录或安全功能，而无需直接修改主应用程序。'
- en: '**Service Registry**: This pattern centralizes the management and discovery
    of services within a distributed system, allowing services to dynamically register
    and discover each other, facilitating communication and scalability'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务注册表**：此模式集中管理分布式系统内的服务发现，允许服务动态注册和发现彼此，从而促进通信和可扩展性。'
- en: '**Bulkhead**: Inspired by ship design, the Bulkhead pattern partitions resources
    or components within a system to isolate failures and prevent cascading failures
    from impacting other parts of the system, thereby enhancing FT and resilience'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**舱壁**：受船舶设计启发，舱壁模式将系统内的资源或组件分区，以隔离故障并防止级联故障影响系统的其他部分，从而增强容错性和弹性。'
- en: Each of these patterns addresses specific challenges inherent in distributed
    systems, offering strategies and best practices for architects and developers
    to design robust and scalable solutions capable of operating in dynamic and unpredictable
    environments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式中的每一个都针对分布式系统固有的特定挑战，为架构师和开发者提供策略和最佳实践，以设计能够在动态和不可预测的环境中运行的健壮和可扩展的解决方案。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the intricacies of distributed systems patterns,
    focusing on the Throttling, Retry, and Circuit Breaker patterns. These patterns
    are essential for building robust, fault-tolerant, and efficient distributed systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了分布式系统模式的复杂性，重点关注节流、重试和断路器模式。这些模式对于构建健壮、容错和高效的分布式系统至关重要。
- en: The skills you’ve acquired in this chapter will significantly contribute to
    your ability to design and implement distributed systems that can handle transient
    failures, service interruptions, and high loads.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中获得的能力将显著提高你设计和实现能够处理短暂故障、服务中断和高负载的分布式系统的能力。
- en: The section about the Throttling pattern equipped you with the tools to manage
    service load and resource allocation effectively.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于节流模式的章节为你提供了有效管理服务负载和资源分配的工具。
- en: By understanding how to implement the Retry pattern, you’ve gained the skills
    to make your operations more reliable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解如何实现重试模式，你已经掌握了使你的操作更可靠的技能。
- en: And, finally, the Circuit Breaker pattern taught you how to build fault-tolerant
    systems that can gracefully handle failures.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，断路器模式教会了你如何构建能够优雅处理故障的容错系统。
- en: As we wrap up this chapter, it’s crucial to remember that these patterns are
    not isolated solutions but pieces of a larger puzzle. They often work best when
    combined and tailored to fit the specific needs and constraints of your system.
    The key takeaway is to understand the underlying principles so that you can adapt
    them to create a resilient and efficient distributed system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束本章时，记住这些模式不是孤立的解决方案，而是更大拼图的一部分。它们通常在结合并针对你系统的特定需求和限制进行调整时效果最佳。关键是要理解其背后的原则，这样你就可以根据需要调整它们，以创建一个有弹性和高效的分布式系统。
- en: Lastly, we briefly presented some other distributed systems patterns, which
    we cannot cover in this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了其他一些分布式系统模式，这些模式我们无法在本书中涵盖。
- en: In the next chapter, we will focus on patterns for testing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于测试模式。
