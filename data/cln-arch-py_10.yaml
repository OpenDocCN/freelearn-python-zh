- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Implementing Test Patterns with Clean Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用清洁架构实现测试模式
- en: In previous chapters, we’ve built a task management system by carefully implementing
    each layer of Clean Architecture, from pure domain entities to framework-independent
    interfaces. For many developers, testing can feel overwhelming, a necessary burden
    that grows increasingly complex as systems evolve. Clean Architecture offers a
    different perspective, providing a structured approach that makes testing both
    manageable and meaningful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过仔细实现清洁架构的每一层，从纯领域实体到框架无关的接口，构建了一个任务管理系统。对于许多开发者来说，测试可能感觉令人压倒，这是一个随着系统发展而日益复杂的必要负担。清洁架构提供了一个不同的视角，提供了一种结构化的方法，使测试变得可管理和有意义。
- en: Now that we’ve worked through all the layers of Clean Architecture, let’s step
    back and examine how this architectural approach transforms our testing practices.
    By respecting Clean Architecture’s boundaries and dependency rules, we create
    systems that are inherently testable. Each layer’s clear responsibilities and
    explicit interfaces guide us not just in what to test, but how to test effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了清洁架构的所有层，让我们退后一步，看看这种架构方法如何改变我们的测试实践。通过尊重清洁架构的边界和依赖规则，我们创建的系统天生就是可测试的。每一层的明确责任和显式接口不仅指导我们测试什么，还指导我们如何有效地测试。
- en: In this chapter, you’ll learn how Clean Architecture’s explicit boundaries enable
    comprehensive test coverage through focused unit and integration tests. Through
    hands-on examples, you’ll discover how Clean Architecture’s **separation of concerns**
    lets us verify system behavior thoroughly while keeping tests maintainable. We’ll
    see how well-defined interfaces and dependency rules lead naturally to test suites
    that serve as both verification tools and architectural guardrails.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解清洁架构的显式边界如何通过专注的单元和集成测试实现全面的测试覆盖率。通过实际示例，你会发现清洁架构的**关注点分离**如何让我们彻底验证系统行为，同时保持测试的可维护性。我们将看到定义良好的接口和依赖规则如何自然地导致既作为验证工具又作为架构护栏的测试套件。
- en: 'By the end of this chapter, you’ll be able to create test suites that are focused,
    maintainable, and effective at catching issues early. Turning testing from a burden
    into a powerful tool for maintaining architectural integrity. Along the way we’ll
    be examining the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建专注、可维护且能够早期捕捉问题的测试套件。将测试从负担转变为维护架构完整性的强大工具。在这个过程中，我们将探讨以下主题：
- en: Foundations of testing in Clean Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构中测试的基础
- en: 'Building testable components: a test-driven approach'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可测试组件：一种测试驱动的方法
- en: Testing across **architectural boundaries**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横跨**架构边界**的测试
- en: Advanced testing patterns for clean systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级测试模式，适用于清洁系统
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, most code examples in the chapter are
    only partially implemented. Complete versions of all examples can be found in
    the book’s accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分展示的代码示例均使用Python 3.13进行测试。为了简洁起见，本章中的大多数代码示例仅部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: Foundations of testing in Clean Architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构中测试的基础
- en: The carefully structured layers and explicit dependencies in Clean Architecture
    don’t just make our systems more maintainable, they fundamentally transform how
    we approach testing. Many teams, faced with complex codebases and unclear boundaries,
    fall back to end-to-end testing through tools like Selenium or headless browsers.
    While these tests can provide confidence that critical user workflows function,
    they’re often slow, brittle, and provide poor feedback when failures occur. Moreover,
    setting up comprehensive unit and integration tests in such systems can feel overwhelming.
    Where do you even start when everything is tightly coupled?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构中精心构建的层和显式依赖关系不仅使我们的系统更易于维护，而且从根本上改变了我们对待测试的方式。许多团队面对复杂的代码库和模糊的边界时，会退而求其次，通过Selenium或无头浏览器等工具进行端到端测试。虽然这些测试可以提供信心，确保关键用户工作流程正常工作，但它们通常速度慢、脆弱，在发生故障时提供反馈较差。此外，在这样系统中设置全面的单元和集成测试可能会感到令人压倒。当所有东西都紧密耦合时，你甚至从哪里开始？
- en: Clean Architecture offers a different perspective. Instead of relying primarily
    on end-to-end tests, we can build confidence in our system through focused, maintainable
    tests that respect architectural boundaries. Rather than fighting complex dependencies
    and setup, we find that our architectural boundaries provide natural guidance
    for building effective test suites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的架构提供了一个不同的视角。我们不必主要依赖端到端测试，而可以通过尊重架构边界的专注、可维护的测试来建立对系统的信心。而不是与复杂的依赖和设置作斗争，我们发现我们的架构边界为构建有效的测试套件提供了自然的指导。
- en: Testing is crucial for maintaining healthy software systems. Through testing,
    we verify that our code works as intended, catch regressions early, and ensure
    that our architectural boundaries remain intact. Clean Architecture’s explicit
    boundaries and dependency rules make it easier to write focused, maintainable
    tests at every level of our system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于维护健康的软件系统至关重要。通过测试，我们验证我们的代码按预期工作，及早捕捉回归问题，并确保我们的架构边界保持完整。清晰的架构和依赖规则使得我们能够在系统的每个层级编写专注且易于维护的测试。
- en: '![Figure 8.1: Testing pyramid depicting the ideal distribution of test types](img/B31577_08_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：测试金字塔，展示了理想测试类型的分布](img/B31577_08_01.png)'
- en: 'Figure 8.1: Testing pyramid depicting the ideal distribution of test types'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：测试金字塔，展示了理想测试类型的分布
- en: The testing pyramid pictured in *Figure 8.1* demonstrates the ideal distribution
    of test types in a well-designed system. The broad foundation consists of fast
    **unit tests** that verify individual components in isolation, providing rapid
    feedback during development. Moving upward, **integration tests** verify interactions
    between components while remaining reasonably quick to execute. At the top, a
    small number of end-to-end tests verify critical user workflows, though these
    tests typically run slower and provide less precise feedback when failures occur.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1* 中所示的测试金字塔展示了在设计良好的系统中测试类型的理想分布。宽阔的基础由快速**单元测试**组成，这些测试在开发过程中验证单个组件的隔离，提供快速的反馈。向上移动，**集成测试**验证组件之间的交互，同时执行速度仍然相对较快。在顶部，少量端到端测试验证关键用户工作流程，尽管这些测试通常运行较慢，在发生故障时提供的反馈也不够精确。'
- en: This architectural approach naturally enables optimal test distribution through
    its well-defined interfaces and component isolation. Our core business logic,
    isolated in the Domain and Application layers, is easily verified through focused
    unit tests without external dependencies. Interface adapters provide clear boundaries
    for integration tests, letting us verify component interactions without testing
    entire workflows. This architectural clarity means we can build confidence in
    our system primarily through fast, focused tests. While end-to-end testing through
    user interfaces has its place Clean Architecture enables us to build substantial
    confidence in our system through focused unit and integration tests alone.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法通过其定义良好的接口和组件隔离，自然地实现了最优的测试分布。我们的核心业务逻辑，在领域和应用层中隔离，可以通过专注的单元测试轻松验证，而无需外部依赖。接口适配器为集成测试提供了清晰的边界，使我们能够在不测试整个工作流程的情况下验证组件交互。这种架构的清晰性意味着我们可以主要通过快速、专注的测试来建立对系统的信心。虽然通过用户界面进行端到端测试有其位置，但清晰的架构使我们能够仅通过专注的单元和集成测试来建立对系统的信心。
- en: Throughout this chapter we’ll use `pytest`, Python’s standard testing framework,
    to demonstrate these testing patterns. By leveraging Clean Architecture’s boundaries,
    we’ll see how `pytest`'s straightforward approach helps us build comprehensive
    test coverage without complex testing frameworks or browser automation tools.
    While Clean Architecture’s testing benefits apply regardless of tooling choice,
    using a single, well-established framework lets us focus on architectural principles
    rather than testing syntax.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`pytest`，Python的标准测试框架，来展示这些测试模式。通过利用清晰的架构边界，我们将看到`pytest`的简单方法如何帮助我们构建全面的测试覆盖，而无需复杂的测试框架或浏览器自动化工具。尽管清晰的架构测试优势适用于任何工具选择，但使用单一、成熟的框架让我们能够专注于架构原则，而不是测试语法。
- en: Clean Architecture requires more initial setup than simpler approaches, involving
    additional interfaces and layer separation that might seem unnecessary for small
    applications. However, this upfront investment transforms testing from a complex
    technical challenge into straightforward verification. Tightly coupled alternatives
    might seem faster initially, but soon require coordinating databases and external
    services just to test basic functionality. The architectural discipline we’ve
    established creates systems that are inherently testable, allowing teams to build
    confidence through focused unit tests rather than slow, brittle end-to-end tests.
    Teams may adopt these patterns selectively, but understanding the testing benefits
    helps inform these architectural decisions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture比简单方法需要更多的初始设置，包括额外的接口和层分离，这可能对小应用程序来说似乎是不必要的。然而，这种前期投资将测试从复杂的技术挑战转变为直接的验证。紧密耦合的替代方案可能最初看起来更快，但很快就需要协调数据库和外部服务来测试基本功能。我们建立的架构纪律创造了本质上可测试的系统，使团队能够通过专注的单元测试而不是缓慢、脆弱的端到端测试来建立信心。团队可以选择性地采用这些模式，但了解测试的好处有助于指导这些架构决策。
- en: Tests as architectural feedback
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试作为架构反馈
- en: Tests are nothing more than clients of our code. If we find that our tests are
    difficult to write or require complex setup, this often signals that our production
    code needs improvement. Just as the Dependency Rule guides our production code
    organization, it similarly informs effective test design. When tests become awkward
    or brittle, this frequently indicates that we’ve violated architectural boundaries
    or mixed concerns that should remain separate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不过是代码的客户。如果我们发现测试难以编写或需要复杂的设置，这通常意味着我们的生产代码需要改进。正如依赖规则指导我们的生产代码组织一样，它同样为有效的测试设计提供了信息。当测试变得尴尬或脆弱时，这通常表明我们违反了架构边界或混合了应该保持分离的关注点。
- en: 'This architectural feedback loop is one of Clean Architecture’s most valuable
    testing benefits. The explicit boundaries and interfaces align naturally with
    various testing approaches, including **Test-Driven Development** (**TDD**). Whether
    you write tests first or after implementation, Clean Architecture’s layers guide
    us toward better designs: if writing a test feels awkward, it often reveals a
    needed architectural boundary. If test setup becomes complex, it suggests we’ve
    coupled concerns that should remain separate. These signals serve as early warnings,
    helping us identify and correct architectural violations before they become deeply
    embedded in our codebase.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构反馈循环是Clean Architecture最有价值的测试好处之一。明确的边界和接口自然地与各种测试方法相匹配，包括**测试驱动开发**（**TDD**）。无论你是先写测试还是后写实现，Clean
    Architecture的层都引导我们走向更好的设计：如果编写测试感觉尴尬，通常表明需要架构边界。如果测试设置变得复杂，这表明我们耦合了应该保持分离的关注点。这些信号作为早期警告，帮助我们识别和纠正架构违规，在它们在我们代码库中根深蒂固之前。
- en: For teams hesitant to adopt comprehensive unit testing due to setup complexity
    or unclear boundaries, Clean Architecture provides a clear path forward. Each
    layer defines explicit interfaces and dependencies, providing clear guidance on
    what should be tested and how to maintain isolation. Throughout the remainder
    of this chapter, we’ll demonstrate these benefits by implementing focused tests
    for each architectural layer of our task management system, showing how Clean
    Architecture’s boundaries naturally guide us toward maintainable test suites.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由于设置复杂或边界不明确而不愿采用全面单元测试的团队，Clean Architecture提供了一条清晰的路径。每一层定义了明确的接口和依赖关系，提供了关于应该测试什么以及如何保持隔离的明确指导。在本章的剩余部分，我们将通过为任务管理系统中的每个架构层实现专注的测试来展示这些好处，展示Clean
    Architecture的边界如何自然地引导我们走向可维护的测试套件。
- en: From testing complexity to clear boundaries
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从测试复杂性到清晰的边界
- en: Many developers struggle with testing codebases that lack clear architectural
    boundaries. In systems where business logic, persistence, and presentation concerns
    are tightly coupled, even simple tests become complex technical challenges. Consider
    a task entity that directly connects to databases and sends notifications on creation.
    Testing its basic properties requires setting up and managing these external dependencies.
    This coupling of concerns makes tests slow, brittle, and difficult to maintain.
    Teams frequently respond by minimizing unit and integration tests in favor of
    **end-to-end tests**, which while valuable, can’t provide the rapid feedback needed
    during development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都在为缺乏清晰架构边界的代码库进行测试时感到困扰。在业务逻辑、持久性和展示关注点紧密耦合的系统中，即使是简单的测试也变成了复杂的技术挑战。考虑一个直接连接到数据库并在创建时发送通知的任务实体。测试其基本属性需要设置和管理这些外部依赖。这种关注点的耦合使得测试变得缓慢、脆弱且难以维护。团队通常会通过减少单元和集成测试，转而进行**端到端测试**来做出回应，尽管端到端测试很有价值，但在开发过程中却无法提供所需的快速反馈。
- en: 'Clean Architecture transforms this landscape by establishing clear boundaries
    between components. Instead of tests that must coordinate multiple tangled concerns,
    we can focus on specific responsibilities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构通过在组件之间建立清晰的边界来改变这一景观。我们不再需要必须协调多个纠缠在一起的测试，而是可以专注于特定的职责：
- en: Domain entities and business rules can be tested in isolation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域实体和业务规则可以在隔离状态下进行测试
- en: Use case orchestration can be verified through explicit interfaces
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式接口可以验证用例编排
- en: Infrastructure concerns remain cleanly separated at system boundaries
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施问题在系统边界处保持清晰分离
- en: 'The layered structure enhances development workflows in practice. Each architectural
    boundary provides natural guidance for:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构在实际开发工作中增强了开发工作流程。每个架构边界都提供了自然的指导：
- en: Isolating bugs to specific components or interactions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误隔离到特定的组件或交互中
- en: Adding focused tests that capture edge cases
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加专注于捕获边缘情况的测试
- en: Building comprehensive coverage incrementally
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步构建全面的覆盖范围
- en: This clarity dramatically improves development workflows. When bugs are reported,
    this layered organization guides us directly to the appropriate testing scope.
    Domain logic issues can be reproduced in unit tests, while integration problems
    have clear boundaries to examine. This natural organization means our test coverage
    improves organically as we maintain and debug our system. Each resolved issue
    leads to focused tests that verify specific behaviors, gradually building a comprehensive
    test suite that catches edge cases before they reach production.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种清晰度显著提高了开发工作流程。当报告错误时，这种分层组织直接引导我们到适当的测试范围。领域逻辑问题可以在单元测试中重现，而集成问题有明确的边界可以检查。这种自然组织意味着随着我们维护和调试系统，我们的测试覆盖范围会自然地提高。每个已解决的问题都会导致针对特定行为的集中测试，逐步构建一个全面的测试套件，在它们达到生产之前捕捉边缘情况。
- en: In the following sections, we’ll explore concrete implementations of these testing
    patterns in our task management system. You’ll see how Clean Architecture’s boundaries
    make each type of test more focused and maintainable, starting with unit tests
    of our Domain layer and progressing through integration tests of our external
    interfaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨这些测试模式在我们任务管理系统中的具体实现。您将看到清洁架构的边界如何使每种类型的测试更加专注和易于维护，从我们的领域层单元测试开始，逐步过渡到我们外部接口的集成测试。
- en: 'Testing clean components: unit testing in practice'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试清洁组件：实践中的单元测试
- en: 'Let’s see how Clean Architecture transforms unit testing from theory into practice.
    Consider a simple test goal: verifying that new tasks default to medium priority.
    In a codebase not aligned to a Clean Architecture paradigm, many developers have
    encountered classes like this, where even simple domain logic becomes tangled
    with infrastructure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看清洁架构如何将单元测试从理论转化为实践。考虑一个简单的测试目标：验证新任务默认为中等优先级。在一个未与清洁架构范式对齐的代码库中，许多开发者都遇到过这样的类，其中简单的领域逻辑与基础设施纠缠在一起：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This tightly coupled code forces us into complex setup to test a simple business
    rule regarding our `Task` entity:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段紧密耦合的代码迫使我们进行复杂的设置来测试关于我们的`Task`实体的简单业务规则：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This test, while functional, exhibits several common problems. It requires
    complex setup involving databases and services just to verify a simple domain
    rule. When it fails, the cause could be anything:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试虽然功能正常，但表现出几个常见问题。它需要复杂的设置，包括数据库和服务，仅为了验证一个简单的领域规则。当它失败时，原因可能是任何东西：
- en: Was there a database connection issue?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在数据库连接问题？
- en: Did the notification service fail to initialize?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知服务是否未能初始化？
- en: Or was there actually an issue with our priority defaulting logic?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，实际上是我们优先级默认逻辑存在问题？
- en: This level of complexity in testing even basic properties highlights why many
    developers perceive testing as cumbersome and often *not worth the effort*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试甚至基本属性方面的这种复杂性突出了为什么许多开发者认为测试是繁琐的，并且通常*不值得付出努力*。
- en: 'Clean Architecture’s boundaries eliminate these issues by keeping our domain
    logic pure and focused. For code following a Clean Architecture approach we can
    test this same business rule with remarkable clarity:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture的边界通过保持我们的领域逻辑纯净和专注来消除这些问题。对于遵循Clean Architecture方法的代码，我们可以以显著清晰的方式测试这个相同的业务规则：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The difference is striking. By keeping our domain entities focused on business
    rules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异非常明显。通过保持我们的领域实体专注于业务规则：
- en: Our test verifies exactly one thing; new tasks default to medium priority
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的测试验证了确切的一件事；新任务默认为中等优先级
- en: Setup requires only the data needed for our test
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置只需要我们测试所需的数据
- en: If the test fails, there’s exactly one possible cause
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试失败，只有一个可能的原因
- en: The test runs instantly with no external dependencies
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试立即运行，没有外部依赖
- en: 'This clear separation of concerns demonstrates one of Clean Architecture’s
    key testing benefits: the ability to verify business rules with minimal setup
    and maximum clarity. Clean Architecture’s boundaries create a natural progression
    for building comprehensive test coverage. Throughout this section, we’ll implement
    focused, maintainable tests that verify behavior while respecting these architectural
    boundaries. We’ll start with the simplest case of testing domain entities and
    progressively work outward through our architectural layers.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的清晰分离展示了Clean Architecture的关键测试优势之一：以最小设置和最大清晰度验证业务规则。Clean Architecture的边界为构建全面的测试覆盖率提供了一个自然的进展。在本节中，我们将实现专注且可维护的测试，以验证行为同时尊重这些架构边界。我们将从测试领域实体的最简单情况开始，逐步向外扩展到我们的架构层。
- en: Testing domain entities
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试领域实体
- en: 'Before diving into specific tests, let’s establish a pattern that will serve
    us throughout our testing journey. The **Arrange-Act-Assert** (**AAA**) **pattern**,
    originally proposed by Bill Wake ([https://xp123.com/3a-arrange-act-assert/](https://xp123.com/3a-arrange-act-assert/)),
    provides a clear structure for organizing tests that aligns naturally with Clean
    Architecture’s boundaries:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入具体测试之前，让我们确立一个在整个测试过程中都会为我们服务的模式。由Bill Wake([https://xp123.com/3a-arrange-act-assert/](https://xp123.com/3a-arrange-act-assert/))最初提出的**
    Arrange-Act-Assert** (**AAA**) 模式，为组织与Clean Architecture边界自然对齐的测试提供了一个清晰的框架：
- en: '**Arrange**: set up the test conditions and test data'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arrange**：设置测试条件和测试数据'
- en: '**Act**: execute the behavior being tested'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Act**：执行正在被测试的行为'
- en: '**Assert**: verify the expected outcomes'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Assert**：验证预期的结果'
- en: 'This pattern becomes particularly elegant when testing domain entities because
    Clean Architecture isolates our core business logic from external concerns. Consider
    how we test our `Task` entity’s completion behavior:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试领域实体时，这个模式变得特别优雅，因为Clean Architecture将我们的核心业务逻辑与外部关注点隔离开。考虑我们如何测试`Task`实体的完成行为：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This test demonstrates the essence of domain entity testing in Clean Architecture.
    All we need to do is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试展示了Clean Architecture中领域实体测试的本质。我们只需要做的是：
- en: Set up an initial state (a new task with required attributes)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置初始状态（一个具有所需属性的新任务）
- en: Take an action (complete the task)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个动作（完成任务）
- en: Verify the final state (completion time was recorded)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证最终状态（记录了完成时间）
- en: 'The domain test’s clarity comes from Clean Architecture’s separation of concerns.
    We don’t need to:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 领域测试的清晰度来自Clean Architecture的关注点分离。我们不需要：
- en: Set up or manage database connections
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置或管理数据库连接
- en: Configure notification services
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置通知服务
- en: Handle authentication or authorization
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理身份验证或授权
- en: Manage external system state
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理外部系统状态
- en: 'We’re testing pure business logic: *when a task is completed, it should record
    when that happened*. This focus makes our tests fast, reliable and readable. If
    the test fails, there’s only one possible cause, our completion logic isn’t working
    correctly.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在测试纯净的业务逻辑：*当任务完成时，它应该记录何时发生*。这种关注点使我们的测试快速、可靠且易于阅读。如果测试失败，只有一个可能的原因，我们的完成逻辑没有正确工作。
- en: This focus on pure business rules is one of the key benefits Clean Architecture
    brings to testing. By isolating our domain logic from infrastructure concerns,
    we can verify behavior with simple, focused tests that serve as living documentation
    of our business rules. Next we will see how this clarity of testing continues
    as we move out from the inner Domain layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对纯业务规则的专注是Clean Architecture为测试带来的关键好处之一。通过将我们的领域逻辑从基础设施关注点中隔离出来，我们可以通过简单、专注的测试来验证行为，这些测试作为我们业务规则的活文档。接下来，我们将看到这种测试的清晰性是如何随着我们从内部域层向外扩展而持续存在的。
- en: Test double tools in Python
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的测试替身工具
- en: 'Before we work with our use case tests, let’s understand how Python helps us
    create **test doubles** which act as dependency replacements for the component
    under test. When testing code that has dependencies, we often need a way to replace
    real implementations (like databases or external services) with simulated versions
    that we can control. Python’s `unittest.mock` library, which is seamlessly integrated
    with `pytest`, provides powerful tools for creating these test doubles:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用用例测试之前，让我们了解Python如何帮助我们创建**测试替身**，这些测试替身作为测试组件的依赖替换。在测试具有依赖关系的代码时，我们通常需要一种方法来用我们可以控制的模拟版本替换真实实现（如数据库或外部服务）。与`pytest`无缝集成的Python的`unittest.mock`库提供了创建这些测试替身的有力工具：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These mocks serve two key purposes in testing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟在测试中起到两个关键作用：
- en: They let us control the behavior of dependencies (like ensuring a repository
    always returns a specific task)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们让我们控制依赖项的行为（例如，确保存储库始终返回特定的任务）
- en: They let us verify how our code interacts with those dependencies (like ensuring
    we called `save()` exactly once)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们让我们验证我们的代码如何与这些依赖项交互（例如，确保我们恰好调用了一次`save()`）
- en: Testing use case orchestration
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例编排
- en: As we move outward from the Domain layer, we naturally encounter dependencies
    on other components of our system. A task completion use case, for instance, needs
    both a repository to persist changes and a notification service to alert stakeholders.
    However, Clean Architecture’s emphasis on abstraction through interfaces transforms
    these dependencies from potential testing headaches into straightforward implementation
    details.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从域层向外扩展，我们自然会遇到对我们系统其他组件的依赖。例如，一个任务完成用例需要既有用于持久化更改的存储库，又有用于通知利益相关者的通知服务。然而，Clean
    Architecture通过接口进行抽象强调，将这些依赖从潜在的测试难题转变为直接的实现细节。
- en: Just as these abstractions let us swap a repository’s implementation from file-based
    storage to SQLite without changing any dependent code, they enable us to replace
    real implementations with test doubles during testing. Our use cases depend on
    abstract interfaces like `TaskRepository` and `NotificationPort`, not concrete
    implementations. This means we can provide mock implementations for testing without
    modifying our use case code at all. The use case neither knows nor cares whether
    it’s working with a real SQLite repository or a test double.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些抽象允许我们将存储库的实现从基于文件的存储切换到SQLite而无需更改任何依赖代码一样，它们使我们能够在测试期间用测试替身替换实际实现。我们的用例依赖于抽象接口，如`TaskRepository`和`NotificationPort`，而不是具体实现。这意味着我们可以在完全不修改用例代码的情况下为测试提供模拟实现。用例既不知道也不关心它是在与真实的SQLite存储库还是与测试替身一起工作。
- en: 'Let’s examine how we use mocks to test our use case in isolation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们如何使用模拟来独立测试我们的用例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Arrange phase demonstrates proper unit test isolation. We mock both the
    repository and notification service to ensure we’re testing the use case’s orchestration
    logic in isolation. This setup guarantees our test won’t be affected by database
    issues, network problems, or other external factors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安排阶段展示了适当的单元测试隔离。我们模拟了存储库和通知服务，以确保我们正在独立测试用例的编排逻辑。这种设置保证了我们的测试不会受到数据库问题、网络问题或其他外部因素的影响。
- en: 'The test flow verifies our use case’s orchestration responsibilities through
    distinct mock verifications:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试流程通过不同的模拟验证来验证我们的用例的编排责任：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how the test’s assertions focus on orchestration rather than business
    logic. We verify that our use case coordinates the correct sequence of operations
    while leaving the implementation details of those operations to our test doubles.
    This pattern scales naturally as our use cases grow more sophisticated. Whether
    coordinating multiple repositories, handling notifications, or managing transactions,
    Clean Architecture’s explicit interfaces let us verify complex workflows through
    focused tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试的断言如何专注于编排而不是业务逻辑。我们验证我们的用例协调正确的操作顺序，同时将那些操作的实现细节留给我们的测试替身。这种模式随着我们的用例变得更加复杂而自然扩展。无论是协调多个存储库、处理通知还是管理事务，Clean
    Architecture的显式接口让我们可以通过集中的测试来验证复杂的工作流程。
- en: In the next section, we’ll see how testing interface adapters introduce new
    patterns for verifying data transformations at our system’s boundaries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何测试接口适配器引入了在系统边界处验证数据转换的新模式。
- en: Testing interface adapters
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试接口适配器
- en: As we move to the Interface Adapters layer, our testing focus shifts to verifying
    proper translation between external formats and our application core. Controllers
    and presenters serve as these translators, and just as with our unit tests in
    previous layers, we want to mock anything external to this layer. We don’t want
    database connections, file systems, or even use case implementations to affect
    our tests of the translation logic. Clean Architecture’s explicit interfaces make
    this straightforward. We can mock our use cases and focus purely on verifying
    that our adapters properly transform data as it crosses our system’s boundaries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向接口适配器层时，我们的测试重点转向验证外部格式和我们的应用程序核心之间的正确转换。控制器和演示者充当这些翻译者，就像我们在之前层中的单元测试一样，我们希望模拟这一层之外的所有内容。我们不希望数据库连接、文件系统，甚至用例实现影响我们对转换逻辑的测试。Clean
    Architecture的显式接口使这一点变得简单。我们可以模拟我们的用例，并专注于验证适配器在跨越系统边界时是否正确转换数据。
- en: 'Let’s examine how we test a controller’s responsibility of converting external
    string IDs to the UUIDs our domain expects. When web or CLI clients call our system,
    they typically provide IDs as strings. Our domain, however, works with UUIDs internally.
    The controller must handle this translation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何测试控制器将外部字符串ID转换为我们的领域期望的UUID的责任。当Web或CLI客户端调用我们的系统时，他们通常会提供ID作为字符串。然而，我们的领域内部却使用UUID。控制器必须处理这种转换：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Arrange phase sets up our test scenario. We provide a task ID as a string
    (like a client would) and create a mock use case that’s configured to return a
    successful result. When creating our presenter mock, we use `spec=TaskPresenter`
    to create a *strict* mock that knows about our presenter’s interface:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 安排阶段设置我们的测试场景。我们提供一个任务ID作为字符串（就像客户端一样）并创建一个配置为返回成功结果的模拟用例。当创建我们的演示者模拟时，我们使用`spec=TaskPresenter`来创建一个*严格*的模拟，该模拟了解我们的演示者接口：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This extra **type safety** is particularly valuable in the Interface Adapters
    layer where maintaining correct interface boundaries is crucial. By using `spec`,
    we ensure our tests catch not just behavioral issues but also contract violations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的**类型安全**在接口适配器层特别有价值，因为维护正确的接口边界至关重要。通过使用`spec`，我们确保我们的测试不仅捕捉到行为问题，还捕捉到违反契约的问题。
- en: 'With our test doubles properly configured to enforce interface boundaries,
    we can verify our controller’s translation logic:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试替身正确配置以强制执行接口边界后，我们可以验证控制器的转换逻辑：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we call `handle_complete`, the controller should:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`handle_complete`时，控制器应该：
- en: Take the string task ID from the client
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从客户端获取字符串形式的任务ID
- en: Convert it to a `UUID`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为`UUID`
- en: Create a properly formatted request for the use case
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用例创建一个正确格式化的请求
- en: Pass this request to the use case’s `execute` method
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此请求传递给用例的`execute`方法
- en: 'Our assertions verify this flow by:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下断言验证此流程：
- en: Confirming the use case was called exactly once
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认用例被调用了一次
- en: Extracting the request that was passed to the use case
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取传递给用例的请求
- en: Verifying that the `task_id` in that request is now a `UUID`, not a string
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证该请求中的`task_id`现在是一个`UUID`，而不是一个字符串
- en: 'This test ensures the controller fulfills its core responsibility: translating
    external data formats into the types our domain expects. If the controller failed
    to convert the string identifier to a `UUID`, the test would fail when checking
    the type of `called_request.task_id`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试确保控制器履行其核心责任：将外部数据格式转换为领域期望的类型。如果控制器未能将字符串标识符转换为`UUID`，则在检查`called_request.task_id`的类型时测试将失败。
- en: 'Similarly, we can test presenters to ensure they format domain data appropriately
    for external consumption. Let’s focus on one specific responsibility: formatting
    task completion dates into human-readable strings for CLI. This seemingly simple
    transformation is a perfect example of an interface adapter’s role:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以测试展示者以确保它们适当地格式化领域数据以供外部消费。让我们专注于一个特定的责任：将任务完成日期格式化为人类可读的字符串以供CLI使用。这种看似简单的转换是接口适配器角色的完美示例：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This test demonstrates how Clean Architecture’s layered approach simplifies
    testing. Because our domain entities have no external dependencies, we can easily
    create and manipulate them in our tests. We don’t need to worry about how the
    completion time was set in practice. The business rules intrinsic to the `Task`
    entity will prevent any illegal states (like setting completion time on an uncompleted
    task). This isolation makes our presenter tests straightforward and reliable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试展示了Clean Architecture分层方法如何简化测试。由于我们的领域实体没有外部依赖，我们可以在测试中轻松创建和操作它们。我们不需要担心实际中完成时间是如何设置的。`Task`实体的内在业务规则将防止任何非法状态（如在一个未完成的任务上设置完成时间）。这种隔离使我们的展示者测试变得简单且可靠。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test flow demonstrates how Clean Architecture’s explicit boundaries make
    interface adapter testing straightforward. We focus purely on verifying data formatting
    without entangling persistence, business rules, or other concerns that our unit
    tests have already verified. Each adapter has a clear, single responsibility that
    we can test in isolation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试流程展示了Clean Architecture的显式边界如何使接口适配器测试变得简单直接。我们专注于验证数据格式化，而不涉及持久性、业务规则或其他我们单元测试已经验证的关注点。每个适配器都有一个明确且单一的责任，我们可以对其进行隔离测试。
- en: 'While testing individual formatting concerns is valuable, our presenters often
    need to handle multiple display aspects simultaneously. Let’s see how Clean Architecture’s
    separation of concerns helps us test comprehensive view model creation in a clear
    methodical manner:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试单个格式化关注点很有价值，但我们的展示者通常需要同时处理多个显示方面。让我们看看Clean Architecture的关注点分离如何帮助我们以清晰、系统的方法测试综合视图模型的创建：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This test verifies how our presenter transforms multiple aspects of domain state
    into display-friendly formats. Clean Architecture’s separation of concerns means
    we can verify all our presentation logic (status indicators, priority formatting,
    and completion information) without entangling business rules or infrastructure
    concerns.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试验证了我们的展示者如何将多个领域状态方面转换为便于显示的格式。Clean Architecture关注点的分离意味着我们可以验证所有我们的展示逻辑（状态指示器、优先级格式化和完成信息），而不会与业务规则或基础设施关注点纠缠。
- en: With these patterns established for testing individual layers, we can now explore
    how Clean Architecture helps us test interactions across architectural boundaries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为测试单个层建立这些模式，我们现在可以探索Clean Architecture如何帮助我们测试跨越架构边界的交互。
- en: Testing across architectural boundaries
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试跨越架构边界
- en: Because our unit tests thoroughly verify business rules and orchestration logic
    through explicit interfaces, our integration testing can be highly strategic.
    Where our unit tests used mocks to verify behavior of components in isolation,
    these integration tests confirm that our concrete implementations work correctly
    together. Rather than exhaustively testing every combination of components, we
    focus on key boundary crossings, particularly those involving infrastructure like
    persistence or external services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的单元测试通过显式接口彻底验证了业务规则和编排逻辑，我们的集成测试可以非常具有战略意义。我们的单元测试使用模拟来验证组件在隔离状态下的行为，而这些集成测试则确认我们的具体实现能够正确地一起工作。我们不是测试所有组件组合的每一种可能性，而是关注关键的边界跨越，特别是涉及持久性或外部服务的基础设施。
- en: Consider how this changes our testing approach. In our unit tests, we mocked
    repositories to verify that use cases correctly coordinated task creation and
    project assignment. Now we’ll test that our actual `FileTaskRepository` and `FileProjectRepository`
    implementations maintain these relationships when persisting to disk.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这如何改变我们的测试方法。在我们的单元测试中，我们模拟了仓库以验证用例正确协调任务创建和项目分配。现在我们将测试我们的实际`FileTaskRepository`和`FileProjectRepository`实现，在持久化到磁盘时是否维护这些关系。
- en: 'Let’s examine how to test our file system persistence boundary—one of the areas
    where integration testing provides value beyond our unit test coverage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何测试我们的文件系统持久化边界——这是集成测试提供价值超出单元测试覆盖范围的领域之一：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This test setup demonstrates a key integration point where we’re creating actual
    repositories that coordinate through file system storage. Our unit tests already
    verified the business rules using mocks, so this test focuses purely on verifying
    that our Infrastructure layer maintains these relationships correctly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试设置演示了一个关键的集成点，即我们创建实际的仓库，通过文件系统存储进行协调。我们的单元测试已经使用模拟验证了业务规则，因此这个测试纯粹关注于验证我们的基础设施层是否正确维护这些关系。
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The test verifies behavior we couldn’t capture in our unit tests:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试验证了我们在单元测试中无法捕捉到的行为：
- en: Projects can load their associated tasks from disk
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可以从磁盘加载其关联的任务
- en: Task–project relationships survive serialization
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务-项目关系在序列化后仍然存在
- en: This repository coordination becomes particularly important when dealing with
    **architectural guarantees** that span multiple operations. One such guarantee
    is our *inbox* project, which is a key infrastructure-level decision made in [*Chapter
    7*](Chapter_07.xhtml#_idTextAnchor168) to ensure all tasks have an organizing
    home.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理跨越多个操作的**架构保证**时，这种仓库协调变得尤为重要。其中一个保证是我们的*收件箱*项目，这是在[*第7章*](Chapter_07.xhtml#_idTextAnchor168)中做出的关键基础设施级决策，以确保所有任务都有一个组织性的家。
- en: 'Another crucial integration point is verifying that our `ProjectRepository`
    implementations uphold this inbox guarantee. While our unit tests verified the
    business rules around using the inbox (like preventing its deletion or completion),
    our integration tests need to verify that the Infrastructure layer properly maintains
    this special project’s existence:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键集成点是验证我们的`ProjectRepository`实现是否遵守这个收件箱保证。虽然我们的单元测试验证了围绕使用收件箱的业务规则（如防止其删除或完成），但我们的集成测试需要验证基础设施层正确维护这个特殊项目的存在：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This test verifies behavior that our unit tests couldn’t capture because they
    used mocked repositories. Our concrete repository implementation takes ownership
    of inbox initialization and persistence. By creating two separate repository instances
    pointing to the same data directory, we confirm that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试验证了由于使用了模拟仓库，我们的单元测试无法捕捉到的行为。我们的具体仓库实现负责收件箱的初始化和持久化。通过创建两个指向同一数据目录的独立仓库实例，我们确认：
- en: The repository automatically creates the inbox on first use
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库在首次使用时自动创建收件箱
- en: The inbox’s special nature (its type and ID) persists correctly
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收件箱的特殊性质（其类型和ID）正确持久化
- en: Subsequent repository instances recognize and maintain this same inbox
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续的仓库实例识别并维护这个相同的收件箱
- en: This focused integration test verifies a fundamental architectural guarantee
    that enables our task organization patterns. Rather than testing every possible
    *Inbox* operation, we verify the core infrastructure behavior that makes these
    operations possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个专注的集成测试验证了一个基本的架构保证，它使我们的任务组织模式成为可能。我们不是测试每个可能的*收件箱*操作，而是验证使这些操作成为可能的核心基础设施行为。
- en: 'Having verified our repository implementations and infrastructure guarantees,
    let’s examine how Clean Architecture enables focused integration testing at the
    use case level. Consider our task creation use case. While our unit tests verified
    its business logic using mocked repositories, we should confirm it works correctly
    with real persistence. Clean Architecture’s explicit boundaries let us do this
    strategically, testing real persistence while still mocking non-persistence concerns
    such as notifications:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证了我们的仓库实现和基础设施保证之后，让我们看看Clean Architecture如何使我们在用例级别进行专注的集成测试。考虑我们的任务创建用例。虽然我们的单元测试使用模拟仓库验证了其业务逻辑，但我们应确认它在使用真实持久化时能正确工作。Clean
    Architecture的明确边界让我们能够有策略地进行测试，测试真实持久化同时模拟非持久化关注点，如通知：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this test setup we use real repositories to verify persistence behavior while
    mocking notifications since they’re not relevant to this integration test.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试设置中，我们使用真实的存储库来验证持久性行为，同时模拟通知，因为它们与此集成测试不相关。
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This test verifies that our use case correctly orchestrates task creation with
    real persistence:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试验证我们的用例是否正确地与真实持久性一起编排任务创建：
- en: The task is properly saved to disk
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务已正确保存到磁盘
- en: The task gets assigned to the Inbox as expected
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如预期，任务被分配到收件箱
- en: We can retrieve the persisted task through the repository
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过存储库检索持久化的任务
- en: By keeping notifications mocked, we maintain test focus while still verifying
    critical persistence behavior. This strategic approach to integration testing,
    which involves testing real implementations of specific boundaries while mocking
    others, demonstrates how Clean Architecture helps us create comprehensive test
    coverage without unnecessary complexity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持通知模拟，我们保持测试的专注性，同时仍然验证关键持久性行为。这种涉及测试特定边界的实际实现（同时模拟其他边界）的战略集成测试方法，展示了清洁架构如何帮助我们创建全面的测试覆盖范围，而不增加不必要的复杂性。
- en: These integration tests demonstrate how Clean Architecture’s explicit boundaries
    enable focused, effective testing of multi-component concerns. Rather than relying
    on end-to-end tests that touch every system component, we can strategically test
    specific boundaries by verifying repository coordination, infrastructure-level
    guarantees, and use case persistence while ancillary concerns are mocked.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集成测试展示了清洁架构的明确边界如何使多组件关注点的专注、有效测试成为可能。我们不必依赖触及每个系统组件的端到端测试，而可以通过验证存储库协调、基础设施级别的保证和使用案例持久性来战略性地测试特定的边界，同时模拟辅助关注点。
- en: 'When implementing integration tests in your own Clean Architecture systems:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当在您的清洁架构系统中实现集成测试时：
- en: Let the architectural boundaries guide what needs integration testing
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让架构边界指导需要集成测试的内容
- en: Test real implementations only for the boundary being verified
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对正在验证的边界进行实际实现测试
- en: Trust your unit test coverage of business rules
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任你的业务规则单元测试覆盖率
- en: Keep each test focused on a specific integration concern
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每个测试都专注于特定的集成关注点
- en: In the next section, we’ll explore testing patterns that help maintain test
    clarity as systems grow more complex.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨有助于在系统变得更加复杂时保持测试清晰性的测试模式。
- en: Tools and patterns for test maintenance
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试维护的工具和模式
- en: While Clean Architecture’s boundaries help us write focused tests, maintaining
    a comprehensive test suite presents its own challenges. As our task management
    system grows, so do our tests. New business rules require additional test cases,
    infrastructure changes need updated verification, and simple modifications can
    affect multiple test files. Without careful organization, we risk spending more
    time managing tests than improving our system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“清洁架构”的边界有助于我们编写专注的测试，但维护一个全面的测试套件也带来了自己的挑战。随着我们的任务管理系统不断增长，我们的测试也在增加。新的业务规则需要额外的测试用例，基础设施变更需要更新验证，简单的修改可能会影响多个测试文件。如果没有仔细的组织，我们可能会花费更多的时间来管理测试，而不是改进我们的系统。
- en: When a test fails, we need to quickly understand what architectural boundary
    was violated. When business rules change, we should be able to update tests systematically
    rather than have to hunt through multiple files. When adding new test cases, we
    want to leverage existing test infrastructure rather than have to duplicate setup
    code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，我们需要快速了解哪个架构边界被违反。当业务规则发生变化时，我们应该能够系统地更新测试，而不是在多个文件中搜索。当添加新的测试用例时，我们希望利用现有的测试基础设施，而不是重复设置代码。
- en: 'Python’s testing ecosystem, particularly `pytest`, provides powerful tools
    that align naturally with Clean Architecture’s goals. We’ll explore how to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python的测试生态系统，特别是`pytest`，提供了与清洁架构目标自然对齐的强大工具。我们将探讨如何：
- en: Verify multiple scenarios while keeping test code clean and focused
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保持测试代码干净和专注的同时验证多个场景
- en: Organize test **fixtures** to respect architectural boundaries
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织测试**固定装置**以尊重架构边界
- en: Leverage testing tools that make maintenance easier
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用使维护更简单的测试工具
- en: Catch subtle issues that could violate our architectural integrity
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕捉可能违反我们架构完整性的微妙问题
- en: Through practical examples, we’ll see how these patterns help us maintain comprehensive
    test coverage without creating a maintenance burden, letting us verify more scenarios
    with less code while keeping our tests as clean as our architecture.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实际示例，我们将看到这些模式如何帮助我们在不增加维护负担的情况下保持全面的测试覆盖率，让我们用更少的代码验证更多场景，同时保持测试尽可能干净，与我们的架构保持一致。
- en: Structuring test files
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化测试文件
- en: 'Clean Architecture’s explicit boundaries provide natural organization for our
    test files. Whether your team chooses to organize tests by type (unit/integration)
    or keeps them together, the internal structure should mirror your application’s
    architecture. An example tests directory structure might resemble this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的明确边界为我们提供了测试文件的天然组织结构。无论您的团队选择按类型（单元/集成）组织测试还是将它们放在一起，内部结构应与您的应用程序架构保持一致。一个示例测试目录结构可能如下所示：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This organization reinforces Clean Architecture’s dependency rules through file
    system boundaries. Tests in `tests/domain` shouldn’t need to import anything from
    `application` or `interfaces`, while a test in `tests/interfaces` can work with
    components from all layers, just as their production counterparts do. This structural
    alignment also provides early warning of potential architectural violations. If
    we find ourselves wanting to import a repository into a domain entity test, the
    awkward import path signals that we’re likely violating Clean Architecture’s Dependency
    Rule.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式通过文件系统边界强化了清洁架构的依赖规则。`tests/domain` 中的测试不需要从 `application` 或 `interfaces`
    中导入任何内容，而 `tests/interfaces` 中的测试可以与所有层的组件一起工作，就像它们的实际生产对应物一样。这种结构对齐也提供了对潜在架构违规的早期警告。如果我们发现自己想要将存储库导入到领域实体测试中，尴尬的导入路径表明我们可能违反了清洁架构的依赖规则。
- en: Parameterized testing for comprehensive coverage
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化测试以实现全面覆盖
- en: When testing across architectural boundaries, we often need to verify similar
    behavior under different conditions. Consider our task creation use case. We need
    to test project assignment, priority setting, and deadline validation across multiple
    input combinations. Writing separate test methods for each scenario leads to duplicated
    code and harder maintenance. When business rules change, we need to update multiple
    tests rather than a single source of truth.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨越架构边界进行测试时，我们经常需要在不同的条件下验证类似的行为。考虑我们的任务创建用例。我们需要测试多个输入组合下的项目分配、优先级设置和截止日期验证。为每个场景编写单独的测试方法会导致代码重复且维护困难。当业务规则发生变化时，我们需要更新多个测试，而不是单一的真实来源。
- en: 'The `pytest` `parametrize` decorator transforms how we handle these scenarios.
    Rather than duplicate test code, we can define data variations that exercise our
    architectural boundaries:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 的 `parametrize` 装饰器改变了我们处理这些场景的方式。我们不必重复测试代码，而是可以定义数据变体来测试我们的架构边界：'
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then in the test method following the above `parametrize` decorator, the test
    will run once for each item in the parameters list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在上述 `parametrize` 装饰器之后的测试方法中，测试将针对参数列表中的每个项目运行一次：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This test demonstrates several key benefits of parameterized testing. The decorator
    injects each test case’s `request_data` and `expected_behavior` into our test
    method, where `request_data` represents input at our system’s edge and `expected_behavior`
    defines our expected domain rules. This separation lets us define our test scenarios
    declaratively while keeping the verification logic clean and focused.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试展示了参数化测试的几个关键好处。装饰器将每个测试用例的 `request_data` 和 `expected_behavior` 注入到我们的测试方法中，其中
    `request_data` 代表系统边缘的输入，而 `expected_behavior` 定义了我们的预期领域规则。这种分离让我们可以声明式地定义测试场景，同时保持验证逻辑干净且专注。
- en: 'The `ids` parameter makes test failures more meaningful: instead of `test_task_creation_scenarios[0]`
    failing, we see `test_task_creation_scenarios[basic-task]` failed, immediately
    highlighting which scenario needs attention.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ids` 参数使测试失败更有意义：不是 `test_task_creation_scenarios[0]` 失败，我们看到 `test_task_creation_scenarios[basic-task]`
    失败，立即突出显示哪个场景需要关注。'
- en: When using parameterized tests, it is best practice to group related scenarios
    and provide clear scenario identifiers. This approach keeps our test logic focused
    while our test data varies, helping us maintain comprehensive coverage without
    sacrificing test clarity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用参数化测试时，将相关场景分组并提供清晰的场景标识符是最佳实践。这种方法在测试数据变化的同时保持测试逻辑的专注，帮助我们在不牺牲测试清晰度的情况下保持全面的覆盖率。
- en: Having organized our test scenarios, let’s explore how `pytest`'s fixture system
    helps us manage test dependencies across architectural boundaries.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织好我们的测试场景后，让我们探讨`pytest`的固定装置系统如何帮助我们管理跨架构边界的测试依赖。
- en: Organizing test fixtures
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织测试固定装置
- en: 'Throughout our testing examples, we’ve used `pytest` fixtures to manage test
    dependencies, from providing clean task entities to configuring mock repositories.
    While these individual fixtures served our immediate testing needs, as test suites
    grow, managing test setup across architectural boundaries becomes increasingly
    complex. Each layer has its own setup needs: domain tests require clean entity
    instances, use case tests need properly configured repositories and services,
    and interface tests need formatted request data.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试示例中，我们使用了`pytest`固定装置来管理测试依赖，从提供干净的任务实体到配置模拟存储库。虽然这些单独的固定装置满足了我们的即时测试需求，但随着测试套件的增长，管理跨架构边界的测试设置变得越来越复杂。每一层都有自己的设置需求：领域测试需要干净的实体实例，用例测试需要正确配置的存储库和服务，而接口测试需要格式化的请求数据。
- en: 'The `pytest` fixture system, particularly paired with its `conftest.py` files,
    helps us scale this fixture pattern across our test hierarchy while maintaining
    Clean Architecture’s boundaries. By placing fixtures in the appropriate test directory,
    we ensure each test has access to exactly what it needs without excess dependencies:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`的固定装置系统，尤其是与它的`conftest.py`文件结合使用，帮助我们跨测试层次结构扩展这种固定装置模式，同时保持Clean Architecture的边界。通过将固定装置放置在适当的测试目录中，我们确保每个测试都能获得它确切需要的，而不需要额外的依赖：'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This organization naturally enforces Clean Architecture’s Dependency Rule through
    our test structure. A test needing both domain entities and repositories must
    live at the Application layer or higher, as it depends on both layers’ fixtures.
    Similarly, a test using only domain entities can be confident it’s not accidentally
    depending on infrastructure concerns.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织自然通过我们的测试结构强制执行Clean Architecture的依赖规则。需要同时使用领域实体和存储库的测试必须位于应用层或更高层，因为它依赖于这两层的固定装置。同样，仅使用领域实体的测试可以确信它没有意外地依赖于基础设施问题。
- en: 'The fixtures themselves respect our architectural boundaries:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置本身尊重我们的架构边界：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When using fixtures across architectural boundaries, structure them to match
    your production dependency injection. For example, to verify that our controller
    properly transforms external requests into use case operations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当在架构边界使用固定装置时，结构它们以匹配您的生产依赖注入。例如，为了验证我们的控制器是否正确地将外部请求转换为用例操作：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This fixture-based approach pays off in several practical ways:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于固定装置的方法在几个实际方面都有回报：
- en: Tests stay focused on behavior rather than setup. Our test verifies the controller’s
    responsibility without setup code cluttering the test method.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试保持关注行为而不是设置。我们的测试验证控制器责任，而不需要设置代码使测试方法杂乱。
- en: Common test configurations are reusable. The same `task_controller` fixture
    can support multiple controller test scenarios.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的测试配置是可重用的。同一个`task_controller`测试固定装置可以支持多个控制器测试场景。
- en: Dependencies are explicit. The test’s parameters clearly show what components
    we’re working with.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系是明确的。测试的参数清楚地显示了我们在处理哪些组件。
- en: Changes to component initialization only need updating in the fixture, not in
    every test.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件初始化的更改只需在固定装置中更新，而不需要在每个测试中更新。
- en: Next let’s examine how these patterns combine with testing tools to catch subtle
    architectural violations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考察这些模式如何与测试工具结合使用，以捕捉微妙的架构违规。
- en: Testing tools and techniques
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具和技术
- en: Even with well-organized tests and fixtures, certain testing scenarios present
    unique challenges. Some tests can pass in isolation but fail due to hidden temporal
    or state dependencies, while others may mask architectural violations that only
    surface under specific conditions. Let’s explore some practical tools that help
    maintain test reliability while respecting our architectural boundaries. From
    controlling time in our tests to exposing hidden state dependencies to managing
    test suite execution at scale, these tools help us catch subtle architectural
    violations before they become deeply embedded in our system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有组织良好的测试和固定装置，某些测试场景也面临着独特的挑战。一些测试在孤立的情况下可以通过，但由于隐藏的时间或状态依赖关系而失败，而其他测试可能掩盖了仅在特定条件下才会暴露的架构违规。让我们探讨一些实用的工具，这些工具有助于在尊重我们的架构边界的同时维护测试的可靠性。从控制测试中的时间到暴露隐藏的状态依赖关系，再到大规模管理测试套件执行，这些工具帮助我们捕捉到在系统深处根深蒂固的微妙架构违规。
- en: Managing time in tests
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试中的时间管理
- en: Testing deadline calculations or time-based notifications requires careful handling
    of time. In our task management system, we have several time-sensitive features.
    Tasks can become overdue, deadlines trigger notifications when they’re approaching,
    and completed tasks record their completion time. Testing these features without
    controlling time becomes problematic. Imagine testing that a task becomes overdue
    after its deadline. We’d either need to wait for actual time to pass (making tests
    slow and unreliable) or manipulate system time (potentially affecting other tests).
    Even worse, time-based tests might pass or fail depending on when they’re run
    during the day.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 测试截止日期计算或基于时间的通知需要仔细处理时间。在我们的任务管理系统中，我们有几个时间敏感的功能。任务可能会逾期，截止日期临近时触发通知，完成任务会记录完成时间。如果不控制时间来测试这些功能，就会变得有问题。想象一下测试一个任务在其截止日期后逾期的情况。我们可能需要等待实际时间的流逝（使测试变得缓慢且不可靠），或者操纵系统时间（可能影响其他测试）。更糟糕的是，基于时间的测试可能会根据它们在一天中的运行时间而通过或失败。
- en: 'The `freezegun` library solves these problems by letting us control time in
    our tests without modifying our domain logic. First, install the library:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`freezegun`库通过允许我们在测试中控制时间而不修改我们的领域逻辑来解决这些问题。首先，安装库：'
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `freezegun` library provides a context manager that lets us set a specific
    point in time for code running within its scope. Any code inside the `freeze_time():`
    block will see time as frozen at that moment, while code outside continues with
    normal time. This lets us create precise test scenarios while our domain entities
    continue working with real `datetime` objects:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`freezegun`库提供了一个上下文管理器，允许我们在其作用域内为代码运行设置特定的时间点。任何在`freeze_time():`块内的代码都将看到时间在那个时刻被冻结，而块外的代码将继续使用正常时间。这让我们能够在我们的领域实体继续使用真实的`datetime`对象的同时创建精确的测试场景：'
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this test arrangement, we freeze time at noon on January 14th to create
    our task with a due date 24 hours later. This gives us a precise initial state
    for testing deadline calculations. Our domain entities continue working with standard
    `datetime` objects, preserving Clean Architecture’s separation of concerns. Only
    the perception of *current time* is affected:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试安排中，我们在1月14日中午冻结时间，以创建一个24小时后到期的任务。这为我们测试截止日期计算提供了精确的初始状态。我们的领域实体继续使用标准的`datetime`对象，保持了Clean
    Architecture的关注点分离。只有对*当前时间*的感知受到影响：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Moving time forward one hour lets us verify that our deadline notification system
    correctly identifies tasks due within the warning threshold. The test runs instantly
    while simulating a real-world scenario that would otherwise take hours to validate.
    Our entities and use cases remain unaware that they’re operating in simulated
    time, maintaining clean architectural boundaries while enabling thorough testing
    of time-dependent behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间向前推进一小时，我们可以验证我们的截止日期通知系统是否正确地识别了在警告阈值内的任务。测试立即运行，同时模拟了一个在现实世界中需要数小时才能验证的场景。我们的实体和用例保持对它们在模拟时间中运行的无知，维护了清晰的架构边界，同时使彻底测试时间相关行为成为可能。
- en: This pattern keeps time-dependent logic in our domain while making it testable.
    Our entities and use cases work with real `datetime` objects, but our tests can
    verify their behavior at specific points in time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将时间相关的逻辑保留在我们的领域内，同时使其可测试。我们的实体和用例使用真实的`datetime`对象工作，但我们的测试可以验证它们在特定时间点的行为。
- en: Exposing state dependencies
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露状态依赖
- en: 'Tests that depend on hidden state or execution order can mask architectural
    violations, particularly around global state. In Clean Architecture, each component
    should be self-contained, with dependencies explicitly passed through interfaces.
    However, subtle global state can creep in. Consider our task management system’s
    notification service: it might maintain an internal queue of pending notifications
    that carries over between tests. A test verifying high-priority task notifications
    could pass when run alone but fail when run after a test that fills this queue.
    Or our project repository might cache task counts for performance, leading to
    tests that pass or fail depending on whether other tests have manipulated this
    cache.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于隐藏状态或执行顺序的测试可能会掩盖架构上的违规，尤其是在全局状态方面。在Clean Architecture中，每个组件应该是自包含的，依赖关系应通过接口显式传递。然而，微妙的全局状态可能会悄悄进入。以我们的任务管理系统中的通知服务为例：它可能维护一个内部队列，用于存储待处理的通知，这些通知可以在测试之间传递。一个验证高优先级任务通知的测试在单独运行时可能通过，但在运行填充此队列的测试之后可能会失败。或者，我们的项目仓库可能为了性能缓存任务数量，导致测试根据其他测试是否操作了这个缓存而通过或失败。
- en: 'These hidden state dependencies not only make tests unreliable but often indicate
    architectural violations where components maintaining state that should be explicit
    in our interfaces. It is best to expose these issues as soon as possible, so it
    is highly recommended to adopt the practice of running tests in random order.
    With `pytest` this can be accomplished by first installing `pytest-random-order`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些隐藏的状态依赖不仅使测试不可靠，而且通常表明存在架构违规，即维护应在我们接口中明确的状态的组件。最好尽可能早地暴露这些问题，因此强烈建议采用随机顺序运行测试的做法。使用
    `pytest` 可以通过首先安装 `pytest-random-order` 来实现：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then configure it to run on every test:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后配置它以在每次测试时运行：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When tests run in random order, hidden state dependencies surface quickly through
    test failures. The moment a test relies on global state or execution order; it
    will fail unpredictably. This is a clear signal that we need to investigate our
    architectural boundaries. When such a failure occurs, the plugin provides a seed
    value that lets you reproduce the exact test execution order:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试以随机顺序运行时，隐藏的状态依赖会通过测试失败迅速显现。一旦测试依赖于全局状态或执行顺序，它就会不可预测地失败。这是一个明确的信号，表明我们需要调查我们的架构边界。当发生此类失败时，插件会提供一个种子值，让您能够重现确切的测试执行顺序：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can then run the tests in the order specified by the seed as many times
    as needed in order to determine the root cause of the failure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要多次以种子指定的顺序运行测试，以确定失败的根本原因。
- en: Accelerating test execution
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速测试执行
- en: As your test catalog grows, execution time can become a significant concern.
    What started as a quick test suite now takes minutes to run. In our task management
    system, we’ve built comprehensive coverage across all layers including domain
    entities, use cases, interface adapters, and infrastructure. Running all these
    tests sequentially, especially those involving file system operations or time-based
    behaviors, can create noticeable delays in the development feedback loop.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的测试目录增长，执行时间可能成为一个重大问题。最初快速运行的测试套件现在需要几分钟才能运行。在我们的任务管理系统里，我们已经对所有层进行了全面的覆盖，包括领域实体、用例、接口适配器和基础设施。按顺序运行所有这些测试，尤其是涉及文件系统操作或基于时间的行为的测试，可能会在开发反馈循环中造成明显的延迟。
- en: 'Fast test execution is crucial for maintaining architectural integrity. Long-running
    test suites discourage frequent verification during development, increasing the
    risk that architectural violations might slip through. `pytest-xdist` provides
    tools to parallelize test execution while maintaining test integrity. First install
    the plugin with `pip`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的测试执行对于维护架构完整性至关重要。长时间运行的测试套件会阻碍开发过程中的频繁验证，增加了架构违规可能被忽视的风险。`pytest-xdist`
    提供了并行化测试执行的同时保持测试完整性的工具。首先使用 `pip` 安装插件：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Configure parallel execution in your `pytest.ini`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `pytest.ini` 文件中配置并行执行：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For any scenarios where tests cannot run in a single parallelized group (for
    instance, tests sharing known global state or resources), `pytest-xdist` provides
    several tools:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何无法在单个并行化组中运行的测试场景（例如，共享已知全局状态或资源的测试），`pytest-xdist` 提供了几个工具：
- en: Use `@pytest.mark.serial` to mark tests that must run sequentially
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@pytest.mark.serial` 标记必须按顺序运行的测试
- en: Configure resource scope with `@pytest.mark.resource_group('global-cache')`
    to ensure tests using the same resources run together
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@pytest.mark.resource_group('global-cache')` 配置资源范围，以确保使用相同资源的测试一起运行
- en: The `-n auto` flag automatically utilizes available CPU cores, though you can
    specify an exact number like `-n 4` if desired. This approach lets us maintain
    fast test execution while respecting the constraints of our architectural boundaries.
    Critical tests that verify our Clean Architecture principles run quickly enough
    to be part of every development cycle, helping catch architectural violations
    early.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n auto` 标志自动利用可用的 CPU 核心，尽管如果需要，您可以指定一个确切的数量，例如 `-n 4`。这种方法使我们能够保持快速的测试执行，同时尊重我们的架构边界约束。关键的测试，用于验证我们的清洁架构原则，运行得足够快，可以成为每个开发周期的组成部分，有助于早期发现架构违规。'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how Clean Architecture’s principles translate directly
    into effective testing practices. We learned how architectural boundaries naturally
    guide our testing strategy, making it clear what to test and how to structure
    those tests. Through our task management system, we saw how Clean Architecture
    enables focused testing without heavy reliance on end-to-end tests while keeping
    our system adaptable and sustainable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了清洁架构的原则如何直接转化为有效的测试实践。我们学习了如何通过架构边界自然引导我们的测试策略，明确测试的内容和如何构建这些测试。通过我们的任务管理系统，我们看到了清洁架构如何使我们能够专注于测试，而无需过度依赖端到端测试，同时保持我们的系统具有适应性和可持续性。
- en: 'We implemented several key testing patterns that demonstrate Clean Architecture’s
    benefits:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实施了几个关键的测试模式，展示了清洁架构的好处：
- en: Unit tests that leverage Clean Architecture’s natural boundaries for focused
    verification
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用清洁架构的自然边界进行专注验证的单元测试
- en: Integration tests that verify behavior across specific architectural layers
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证特定架构层之间行为的集成测试
- en: Tools and patterns for building maintainable test suites at scale
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可维护测试套件的工具和模式
- en: Most importantly, we saw how Clean Architecture’s careful attention to dependencies
    and interfaces makes our tests more focused and maintainable. By organizing our
    tests to respect architectural boundaries, from file structure to fixtures, we
    create test suites that grow gracefully with our systems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们看到了清洁架构对依赖和接口的细致关注如何使我们的测试更加专注和易于维护。通过组织我们的测试以尊重架构边界，从文件结构到测试夹具，我们创建了与我们的系统一起优雅增长的测试套件。
- en: In [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor218) we’ll explore how to apply
    Clean Architecture principles to web interface design, showing how our careful
    attention to architectural boundaries enables us to add a complete Flask-based
    web interface to our task management system with minimal changes to our core application.
    This practical demonstration will highlight how Clean Architecture’s separation
    of concerns allows us to maintain our existing CLI while seamlessly introducing
    new user interfaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](Chapter_09.xhtml#_idTextAnchor218)中，我们将探讨如何将清洁架构的原则应用于Web界面设计，展示我们如何通过关注架构边界来添加完整的基于Flask的Web界面到我们的任务管理系统，同时对核心应用程序进行最小改动。这个实际演示将突出清洁架构关注点分离如何使我们能够在维护现有CLI的同时无缝引入新的用户界面。
- en: Further reading
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Software Testing Guide* ([https://martinfowler.com/testing/](https://martinfowler.com/testing/)).
    Collects all the testing articles on Martin Fowler’s blog.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件测试指南* ([https://martinfowler.com/testing/](https://martinfowler.com/testing/)).
    收集了马丁·福勒博客上的所有测试文章。'
- en: '*Just Say No to More End-to-End Tests* ([https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)).
    A blog by Google’s testing team, arguing that an over-reliance on end-to-end tests
    can lead to increased complexity, flakiness, and delayed feedback in software
    development, advocating instead for a balanced approach that emphasizes unit and
    integration tests.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拒绝更多端到端测试* ([https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)).
    一篇由谷歌测试团队撰写的博客，论述过度依赖端到端测试可能导致软件开发中复杂性增加、易出错和反馈延迟，并提倡采取平衡的方法，强调单元测试和集成测试的重要性。'
- en: '*Python Testing with pytest* **(**[https://pytest.org/](https://pytest.org/)).
    The official `pytest` documentation, providing detailed information about the
    testing tools we’ve used throughout this chapter.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用pytest进行Python测试** ([https://pytest.org/](https://pytest.org/)). 本章所使用的测试工具的官方`pytest`文档，提供了关于测试工具的详细信息。'
- en: '*Test-Driven Development* ([https://www.oreilly.com/library/view/test-driven-development/0321146530/](https://www.oreilly.com/library/view/test-driven-development/0321146530/)).
    An essential guide to TDD by Kent Beck, one of its pioneers. This book provides
    a solid foundation for understanding how TDD can improve your software design
    and how it naturally aligns with architectural patterns like those found in Clean
    Architecture.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试驱动开发* ([https://www.oreilly.com/library/view/test-driven-development/0321146530/](https://www.oreilly.com/library/view/test-driven-development/0321146530/)).
    Kent Beck，TDD的先驱之一，所著的TDD指南。本书为理解TDD如何改进软件设计以及它如何与清洁架构等架构模式自然对齐提供了坚实的基础。'
