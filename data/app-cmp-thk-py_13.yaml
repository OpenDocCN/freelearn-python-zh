- en: '*Chapter 11*: Using Computational Thinking and Python in Simple Challenges'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：在简单挑战中使用计算思维和Python'
- en: In this chapter, we will take a look again at the computational thinking process
    and apply it to design algorithms that help us solve various scenarios and problems.
    As we wrap up *Section 2*, *Applying Python and Computational Thinking*, of this
    book, we will combine some of the knowledge about Python capabilities with the
    computational thinking process to solve these problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次审视计算思维过程，并将其应用于设计算法，帮助我们解决各种场景和问题。随着本书*第2节*，*应用Python和计算思维*的结束，我们将结合有关Python功能的一些知识与计算思维过程，解决这些问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining the problem and Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义问题和Python
- en: Decomposing the problem and using Python functionalities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解问题并使用Python功能
- en: Generalizing the problem and planning Python algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概括问题并规划Python算法
- en: Designing and testing the algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和测试算法
- en: By the end of this chapter, you will be able to design algorithms that best
    fit the scenarios presented. You will also be able to identify Python functions
    that best align with the problems presented and generalize your solutions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够设计最适合所呈现场景的算法。您还将能够确定最符合所呈现问题的Python函数，并概括您的解决方案。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to install the latest version of Python to run the code in this
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装最新版本的Python才能运行本章中的代码。
- en: 'The source code used in this chapter can be found in the GitHub repository
    here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的源代码可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter11)
- en: Defining the problem and Python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义问题和Python
- en: 'We are going to dive into our first scenario. You are launching a campaign
    for a product you''ve designed. You''re looking for investments that add up to
    $100,000 in pledges. You want to create an algorithm that saves information on
    the pledges made for you, while also providing information about the products
    each pledge provides. There are some things you need to identify before you write
    an algorithm:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨我们的第一个场景。您正在为您设计的产品发起一项活动。您正在寻找总额为100,000美元的承诺投资。您希望创建一个算法，保存有关为您制作的承诺的信息，同时提供有关每个承诺提供的产品的信息。在编写算法之前，您需要确定一些事项：
- en: '*How many types of pledges will you run in your campaign?*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您的活动中将运行多少种类型的承诺？*'
- en: '*Will there be a donation-only pledge?* *Do donations get anything at all,
    such as a sticker, electronic certificate, or other product swag?*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*是否会有仅捐款的承诺？* *捐款是否会得到任何东西，比如贴纸、电子证书或其他产品？*'
- en: '*What will each of the pledges give the person pledging?*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个承诺将给予承诺者什么？*'
- en: All of these questions will help us plan. But we also have to take into account
    other things, such as what we need from the algorithm. *Is it simply to list the
    number of pledges or will it also be used to check against an inventory or to
    create that inventory?* *Will it count down from a set number of pledges available
    for each level? Will it automatically update every time someone makes a pledge?*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都将帮助我们进行规划。但我们还必须考虑其他事项，比如我们从算法中需要什么。*它仅仅是列出承诺的数量，还是也将用于与库存进行核对或创建库存？*
    *它会从每个级别可用的一定数量的承诺中倒数吗？每次有人承诺时，它会自动更新吗？*
- en: As you know, when we are presented with a problem, it is critical that we identify
    what the problem really is. We need to set our parameters for the problem in order
    to provide a solution. In this section, we're going to want to answer a lot of
    these questions first. In order to do that, we need to decompose the problem and
    identify which functionalities in Python would help us solve this problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，当我们面对问题时，关键是要确定问题的实质。我们需要为问题设定参数，以便提供解决方案。在本节中，我们首先要回答很多这些问题。为了做到这一点，我们需要分解问题，并确定Python中哪些功能可以帮助我们解决这个问题。
- en: Decomposing the problem and using Python functionalities
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解问题并使用Python功能
- en: We can create an algorithm that is used to design those pledges. We'd be designing
    an algorithm that tells us how many items we need of each type based on a set
    number of pledges.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个用于设计这些承诺的算法。我们将设计一个算法，告诉我们根据一定数量的承诺需要每种类型的商品数量。
- en: 'For example, say we have three tiers of pledges and a donation-only pledge.
    For the highest tier, let''s call that **Tier 1**, you get the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有三个承诺层级和一个仅捐款的承诺。对于最高层，让我们称之为**层级1**，您将获得以下内容：
- en: Double the item you are selling at a 20% discount
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将出售的商品以20%的折扣翻倍
- en: An accessories bundle for the item, which includes four items
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品的配件捆绑包，包括四件商品
- en: A carrying case for the item and accessories
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品和配件的携带盒
- en: Access to a 1-year membership for the site
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站的1年会员资格
- en: 'The middle tier, or **Tier 2**, gets you the following items:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 中层，或**层级2**，将为您提供以下商品：
- en: The item you are selling at a 20% discount
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以20%的折扣出售的商品
- en: A carrying case for the item
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品的携带盒
- en: Access to a 6-month membership for the site
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站的6个月会员资格
- en: 'The lowest tier, or **Tier 3**, gets you the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最低层，或**层级3**，将为您提供以下商品：
- en: The item you are selling at a 20% discount
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以20%的折扣出售的商品
- en: A carrying case for the item
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品的携带盒
- en: Let's say we want an algorithm that will give us the number of items we'd need
    depending on how many pledges we allow for each tier. The **fourth tier**, which
    is donation only, would not affect our algorithm, since this algorithm would be
    used simply to determine how many of each item we'd need depending on the number
    of pledges.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个算法，根据我们允许每个层级的承诺数量，为我们提供我们需要的物品数量。**第四层**，即仅捐赠的层级，不会影响我们的算法，因为这个算法将仅用于确定我们需要的每种物品的数量，具体取决于承诺的数量。
- en: But things aren't as simple as just the numbers. Let's say that you need $100,000
    in pledges, as mentioned earlier in this chapter. Then you'd need to figure out
    how much you'd charge for the tiers and put a price point on them. You'd need
    to make enough pledges available to at least reach that goal of $100,000.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并不像数字那么简单。假设您需要$100,000的承诺，就像本章前面提到的那样。那么您需要计算出每个层级的收费，并为它们设定一个价格点。您需要提供足够的承诺，以至少达到$100,000的目标。
- en: 'You have identified the retail price of your item as $800\. Here are the costs
    for each of the items:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经确定您的物品的零售价格为$800。以下是每个物品的成本：
- en: $640 for the item itself (given a 20% discount, and only applicable to Tiers
    1, 2, and 3)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $640是物品本身的价格（给定20%的折扣，仅适用于第1、2和3层）
- en: $100 in accessories (Tier 1 only)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $100的配件（仅适用于第1层）
- en: $40 carrying case (applicable to Tiers 1, 2, and 3)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $40的携带箱（适用于第1、2和3层）
- en: Membership costs will be passed at $10 a month (let's say the original cost
    is $35 a month)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会员费用将以每月$10的价格传递（假设原始费用为每月$35）
- en: 'For Tier 1, the pledge would need to be a minimum of $1,540:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第1层，承诺需要至少$1,540：
- en: 640 × 2 = 1280
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 640 × 2 = 1280
- en: 12 × 10 = 120
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12 × 10 = 120
- en: 1280 + 120 + 100 + 40 = 1540
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1280 + 120 + 100 + 40 = 1540
- en: 'For Tier 2, the pledge would need to be a minimum of $740:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第2层，承诺需要至少$740：
- en: 640 + 40 = 680
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 640 + 40 = 680
- en: 6 × 10 = 60
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 × 10 = 60
- en: 680 + 60 = 740
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 680 + 60 = 740
- en: For Tier 3, the pledge would need to be a minimum of $680, that is, 640 + 40
    = 680.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三层，承诺需要至少$680，即640 + 40 = 680。
- en: 'Now we have to figure out how many of each tier would be available for purchase.
    But first, let''s round out some of these numbers: Tier 1 will be $1,600, Tier
    2 will be $800, and Tier 3 will be $700.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须弄清楚每个层级将有多少可供购买。但首先，让我们将一些这些数字四舍五入：第1层将是$1,600，第2层将是$800，第3层将是$700。
- en: We can write an algorithm to let us know how many pledges we need for each tier.
    But before we do, let's talk about Python and the functionalities that we could
    use. We can create the Tier-3 pledge first, making it a parent group. Then we
    can create two child classes, Tiers 1 and 2, that have slightly different characteristics
    and costs. The question we ask ourselves is whether we need to be that detailed
    on the algorithm or can we just add each tier's cost/value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个算法来让我们知道每个层级需要多少承诺。但在我们这样做之前，让我们谈谈Python和我们可以使用的功能。我们可以首先创建第三层的承诺，使其成为一个父组。然后我们可以创建两个子类，第1和第2层，它们具有略有不同的特征和成本。我们要问自己的问题是，我们是否需要在算法中详细说明，还是只需添加每个层级的成本/价值。
- en: That's a good question. And the answer is that it depends on what you need this
    algorithm for. If you're looking to do the early yet simple calculations and need
    an algorithm you can run every so often based on current sales/pledges, then you
    can create something simple with a dictionary or a function. But if you want to
    use the algorithm for multiple purposes or need to be able to adjust some costs
    later on, then you may want to code that into the algorithm with all the details.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题。答案是取决于您需要这个算法的用途。如果您只是想进行早期简单的计算，并且需要一个可以根据当前销售/承诺定期运行的算法，那么您可以创建一个简单的字典或函数。但是，如果您希望将算法用于多种目的，或者需要能够稍后调整一些成本，那么您可能希望将所有细节编码到算法中。
- en: '*Why would you need that?* Take some of the successful campaigns available.
    Oftentimes, the original pledges sell out for those campaigns. New pledge tiers
    then become available and you may want to adjust the price point of those tiers.
    For example, rather than a 20% discount on the item, the pledge may be for a 15%
    discount. Other changes may happen, such as selling swag instead of the accessories
    due to inventory limitations and so on.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*您为什么需要这个？*看一些成功的可用活动。通常，这些活动的原始承诺会售罄。然后新的承诺层会变得可用，您可能希望调整这些层的价格点。例如，承诺可能不再是物品的20%折扣，而是15%的折扣。其他变化可能发生，例如由于库存限制而出售装饰品而不是配件等。'
- en: The more detailed your algorithm is, the more you can do with it in the long
    run. But if you do not need all that information, then you may not want to spend
    as much time creating the algorithms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您的算法越详细，从长远来看，您可以做的事情就越多。但是，如果您不需要所有这些信息，那么您可能不希望花费太多时间创建算法。
- en: 'Let''s get to work on this algorithm. Take a look at the snippet shown as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理这个算法。看一下下面显示的片段：
- en: ch11_pledgesA.py
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ch11_pledgesA.py
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's take a look at some of the things we used in the preceding snippet. We
    had to import the `math` module so we could use the `math.ceil()` math function.
    We used this function in order to round the number of Tier-1 pledges needed up.
    That's because if we rounded down, we would not be able to cover the desired percentage.
    By doing this, we are finding the smallest integer we'll need to cover the percentage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们在前面片段中使用的一些东西。我们必须导入`math`模块，以便我们可以使用`math.ceil()`数学函数。我们使用这个函数来四舍五入所需的第1层承诺的数量。这是因为如果我们向下取整，我们将无法达到所需的百分比。通过这样做，我们找到了我们需要覆盖百分比的最小整数。
- en: In addition, we used the `%s` placeholders in our `print` statement to call
    our strings, then stated the strings to be used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在我们的`print`语句中使用了`%s`占位符来调用我们的字符串，然后说明要使用的字符串。
- en: 'When we run that program, this is what the output looks like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行该程序时，输出如下所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that our `print` statement uses the percentage entered by the user,
    in part to ensure that the information matches what was expected. For 45% of the
    funding to come from Tier-1 pledges, we''d need to sell at least 29 Tier-1 pledges.
    If we run the math just to verify that this is correct, we see that this information
    is true:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`print`语句使用了用户输入的百分比，部分是为了确保信息与预期相匹配。要想让45%的资金来自Tier-1承诺，我们至少需要出售29个Tier-1承诺。如果我们运行数学来验证这一点，我们会发现这个信息是正确的：
- en: '![](image/Formula_B15413_11_001.jpg)![](image/Formula_B15413_11_002.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_11_001.jpg)![](image/Formula_B15413_11_002.jpg)'
- en: As you can see, if we sell 29 Tier-1 pledges, we'll make slightly more than
    45% of 100,000.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果我们出售29个Tier-1承诺，我们将获得略多于100,000的45%。
- en: 'But let''s say that you also want the algorithm to tell you how many items
    you need based on the number of Tier-1 pledges. Let''s take a look at the adjusted
    algorithm:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设您还希望算法告诉您基于Tier-1承诺数量需要多少物品。让我们看一下调整后的算法：
- en: ch11_pledgesB
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ch11_pledgesB
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that I only added one more `print` statement. There are pros and cons
    to using this algorithm in this way. In this case, I'm only outputting the numbers
    for each of the tiers. I'm not saving how many items I need anywhere in the algorithm.
    If we want to do that for future reference, we'll need to adjust how we get that
    information and how we save it in the algorithm.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我只添加了一个`print`语句。以这种方式使用这个算法有利有弊。在这种情况下，我只输出每个层级的数字。我没有在算法中保存需要的物品数量。如果我们想要为将来的参考保存这些信息，我们需要调整如何获取这些信息以及如何在算法中保存它。
- en: 'For this algorithm, the output is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个算法，输出如下：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we got the information we wanted. We'll need `58` `items`, `29`
    `accessories kits`, `29` `carrying` `cases`, and `29` `year-long` `memberships`.
    Again, this would be helpful if we were doing a one-off thing or if we didn't
    expect any changes. But let's be clear, that's almost never the case. We'll want
    to make changes. We'll also need to know information based on Tier-2 and Tier-3
    selections. *So what can we do?*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们得到了想要的信息。我们将需要`58`个`物品`，`29`个`配件套件`，`29`个`携带箱`，以及`29`个`年度`的`会员资格`。同样，如果我们只做一次性的事情，或者我们不希望有任何变化，这将是有帮助的。但让我们明确一点，这几乎从来不是这种情况。我们将希望进行更改。我们还需要根据层级2和层级3的选择来了解信息。*那么我们能做什么呢？*
- en: 'First, we''ll want to save our numbers. So, we''ll need to add some variables
    for the items, the accessories kits, the carrying cases, and two variables for
    the memberships, one for the year-long and one for the 6-month-long memberships.
    We''ll also need to make a decision about how we want the rest of the pledges
    broken up. *Do we want the other percentage equally split between Tiers 2 and
    3?* *Do we want one-third of what''s left to be Tier 2 and two-thirds to be Tier
    3?* Let''s go with those numbers. Here''s where we stand now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要保存我们的数字。因此，我们需要为物品、配件套件、携带箱和两个会员资格添加一些变量，一个是年度的，一个是6个月的。我们还需要决定我们希望其余的承诺如何分配。*我们希望其他百分比在层级2和3之间平均分配吗？*
    *我们希望剩下的三分之一是层级2，剩下的三分之二是层级3吗？* 让我们选择这些数字。现在我们的情况是这样的：
- en: The Tier-1 percentage is chosen by the user as the program is run.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tier-1的百分比是由用户在程序运行时选择的。
- en: The Tier-2 percentage will be one-third of the remaining percentage.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tier-2的百分比将是剩余百分比的三分之一。
- en: Tier 3 will be two-thirds of the remaining percentage.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tier-3将是剩余百分比的三分之二。
- en: 'Let''s teach this to the algorithm. The following file contains the full, uninterrupted
    code. We added some text to explain certain sections, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们教给算法。以下文件包含完整的、不间断的代码。我们添加了一些文本来解释某些部分，如下所示：
- en: ch11_pledgesC.py
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ch11_pledgesC.py
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice in the following snippet we are adding some variables, such as `totalTier1`,
    `itemsTier1`, `accTier1`, and `cases1`. These variables will help us save the
    numbers of each tier ordered. We''ll do the same for Tiers 2 and 3:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在下面的片段中，我们添加了一些变量，如`totalTier1`、`itemsTier1`、`accTier1`和`cases1`。这些变量将帮助我们保存每个层级订购的数量。我们将对层级2和3做同样的事情：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While we haven''t printed the details yet for the number of total items or
    the total cases, we now have them saved into variables. This is what our output
    looks like now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还没有打印出总物品或总案例的详细信息，但现在我们已经将它们保存到变量中。现在我们的输出看起来是这样的：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We should note that we exceed our funding goal because we've always been rounding
    up. That is, rather than using $1,540 for Tier 1, we used $1,600\. For the percentage,
    we've been rounding up. All of these will add up to give us a total above $100,000\.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到，我们超过了我们的筹资目标，因为我们一直在四舍五入。也就是说，我们使用$1,540来代替Tier 1，我们使用$1,600。对于百分比，我们一直在四舍五入。所有这些加起来将使我们的总额超过100,000。
- en: 'Let''s extend the algorithm a little more. The following is only the new snippet
    from the algorithm we''ve already seen, which contains the total for the items
    we''ll need:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再扩展一下算法。以下只是我们已经看到的算法中的新片段，其中包含了我们需要的物品的总数：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we can now call those variables we added in our `print` function
    to get the counts we need for our inventory. We would not be able to get those
    details if we had not defined those items in our algorithm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在可以在我们的`print`函数中调用我们添加的那些变量，以获取我们库存所需的数量。如果我们没有在算法中定义这些项目，我们将无法获得这些详细信息。
- en: Also notice that in our previous snippet, some of the items have the exact same
    value. However, we still defined them with different variables. Take a look, for
    example, at `cases2 = totalTier2` and `sixMemb = totalTier2`. Although both have
    the same values, we want to identify them separately. And maybe that's not important
    now, but later on, maybe we'll run out of cases. Then we'd only want to change
    the value for the cases and not the 6-month memberships.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的片段中，还有一些项目具有完全相同的价值。然而，我们仍然用不同的变量定义了它们。例如，`cases2 = totalTier2`和`sixMemb
    = totalTier2`。尽管两者的值相同，但我们希望将它们分开识别。也许现在这并不重要，但以后也许我们会用完案例。那时我们只想改变案例的价值，而不是6个月的会员资格。
- en: 'Since they''re already split, we can change one without affecting the other.
    Let''s take a look at what the output looks like for the new `print` statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们已经分开，我们可以改变一个而不影响另一个。让我们看看新的`print`语句的输出是什么样的：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Looking at this, you may realize that you only get one carrying case but two
    items in Tier 1, which is why there's a different count for those. The accessories
    and year-long memberships only happen in Tier 1, so it makes sense that those
    two numbers are the same. The 6-month memberships are only for Tier 2, so that
    number matches the number of Tier-2 pledges.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这一点，你可能会意识到在第一层有一个携带箱，但有两个物品，这就是为什么这两个数字不同的原因。配件和一年的会员只发生在第一层，所以这两个数字相同是有道理的。6个月的会员只适用于第二层，所以这个数字与第二层的承诺数量相匹配。
- en: As we consider this problem further, we may realize that we may want to save
    information differently. Maybe rather than asking the user for the percentage
    of Tier-1 pledges they want, we could ask how many total items they have and then
    break down the tiers based on that. All of that is possible, so how we define
    the problem is critical. How we save the information or request input from the
    user is also just as important. Decomposing a problem is just part of the process
    of creating and designing the algorithms we need.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进一步考虑这个问题时，我们可能会意识到我们可能希望以不同的方式保存信息。也许我们不是问用户他们想要多少百分比的第一层承诺，而是问他们有多少总物品，然后根据这个来分解层。所有这些都是可能的，所以我们如何定义问题是至关重要的。我们如何保存信息或者从用户那里请求输入也同样重要。分解问题只是创建和设计我们需要的算法过程的一部分。
- en: In this section, we learned how to address problems with multiple solutions
    depending on our goals. As we define our problems, we are often also identifying
    the variables we'll need and determining what kinds of functions are most useful
    depending on what we'll want to get out of the algorithm. Unless we have a very
    simple and straightforward problem, the decomposition and definition of the problem
    are critical in order to successfully define an algorithm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学会了如何解决具有多种解决方案的问题，这取决于我们的目标。当我们定义问题时，我们通常也确定我们需要的变量，并确定根据算法的输出需要什么样的函数是最有用的。除非我们有一个非常简单和直接的问题，否则问题的分解和定义对于成功定义算法至关重要。
- en: Now let's take a look at generalizing the problem in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在下一节中看一下概括问题。
- en: Generalizing the problem and planning Python algorithms
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括问题和规划Python算法
- en: In the previous section, we were working with an algorithm designed for use
    in a funding campaign. The algorithm we looked at was problem-specific.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们正在使用一个专为资金筹集活动设计的算法。我们看到的算法是特定于问题的。
- en: Now let's try to generalize this problem and understand how we could potentially
    design a different algorithm. *Why would we need that?* Think of it as a template.
    If you run multiple funding campaigns for start-ups, you may want to create a
    general algorithm that you can then adapt based on the needs of each campaign
    rather than having to start each campaign over.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试概括这个问题，并了解我们如何可能设计一个不同的算法。*为什么我们需要那个？*把它看作一个模板。如果你为初创公司运行多个筹资活动，你可能希望创建一个通用算法，然后根据每个活动的需求进行调整，而不是每次都要重新开始每个活动。
- en: 'You would need to set up some clear parameters and make some decisions. In
    order to keep this scenario manageable for the book''s purposes, we''re going
    to limit our choices a bit:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要设定一些明确的参数并做出一些决定。为了使这种情况对本书的目的来说更容易处理，我们将限制一下我们的选择：
- en: Every campaign will have between 3 and 5 tiers of pledges, not including donation-only.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个活动将有3到5个承诺层，不包括仅捐赠。
- en: Every tier will ask for the items needed for each tier.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个层都会要求每个层所需的物品。
- en: Each tier option will have a set percentage built in.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个层选项都将有一个固定的百分比。
- en: If there are three tiers, Tier 1 will be 50% of pledges, Tier 2 will be 30%,
    and Tier 3 will be 20%. If there are four tiers, Tier 1 will be 40% of pledges,
    Tier 2 will be 30%, Tier 3 will be 20%, and Tier 4 will be 10%. If there are five
    tiers, Tier 1 will be 40% of pledges, Tier 2 will be 30%, Tier 3 will be 15%,
    Tier 4 will be 10%, and Tier 5 will be 5%.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有三个层，第一层将占承诺的50%，第二层将占30%，第三层将占20%。如果有四个层，第一层将占承诺的40%，第二层将占30%，第三层将占20%，第四层将占10%。如果有五个层，第一层将占承诺的40%，第二层将占30%，第三层将占15%，第四层将占10%，第五层将占5%。
- en: 'Take a look at the following diagram, which shows the breakdown of the tiers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表，显示了各层的分解情况：
- en: '![Figure 11.1 – Tier percentage breakdown'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 层百分比分解'
- en: '](image/Figure_11.1_B15413.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.1_B15413.jpg)'
- en: Figure 11.1 – Tier percentage breakdown
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 层百分比分解
- en: Because we are using one algorithm for many possible scenarios, we'll break
    down that algorithm piece by piece. The full algorithm can be found in the `ch11_pledgesTemplate.py`
    file on GitHub.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用一个算法来处理许多可能的情况，我们将逐步分解该算法。完整的算法可以在GitHub上的`ch11_pledgesTemplate.py`文件中找到。
- en: 'In this first snippet, we ask for the initial input, then save our percentages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个片段中，我们要求初始输入，然后保存我们的百分比：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, there are three conditions after we ask for input. Notice that
    we converted the input to an integer. This is important, otherwise the conditions
    will run but the `else` condition will also run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在我们要求输入后有三个条件。请注意，我们将输入转换为整数。这很重要，否则条件将运行，但`else`条件也将运行。
- en: The preceding snippet won't give us any output except for asking for that input.
    So, we'll show more output after our next snippet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段不会给我们任何输出，除了要求输入。因此，在我们的下一个片段之后，我们将展示更多的输出。
- en: 'Important Note:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Notice the use of comments in this code. Because of the length of the code,
    we'll be using comments in order to find spots in our code where we need to edit
    it. It is always a good idea to use comments in all code, but especially in lengthy
    code. Otherwise, finding the particular lines we want to change can be very tricky.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此代码中的注释的使用。由于代码的长度，我们将使用注释来找到需要编辑的代码部分。在所有代码中使用注释总是一个好主意，尤其是在冗长的代码中。否则，找到我们想要更改的特定行可能会非常棘手。
- en: 'Once we have the number of tiers, we''ll need to know the number of items in
    each tier. We''ll need to ask how many items are chosen for each tier. Let''s
    take a look at the continuation of the preceding code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了层级的数量，我们将需要知道每个层级中物品的数量。我们需要询问每个层级选择了多少物品。让我们看看前面代码的继续部分：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we're only showing the conditions for when the tiers are 3 or 4\.
    The code file will also have the information for the 5 tiers, but it follows what
    is shown in the preceding code. Notice that the algorithm asks for input for each
    of the tiers. This will be important when we need to work with numbers and percentages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只显示了层级为3或4时的条件。代码文件还将包含5个层级的信息，但它遵循了前面代码中显示的内容。请注意，该算法要求输入每个层级。当我们需要处理数字和百分比时，这将是重要的。
- en: In addition, we can include an `else` statement that allows us to ask the questions
    again if there is an error in the input. You can add these kinds of conditions
    to the existing template if you wish. For now, we're going to continue with the
    next pieces of information we'll need to get from the user, such as the price
    point for each tier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以包括一个`else`语句，如果输入中有错误，它允许我们再次提出问题。如果您愿意，可以将这些类型的条件添加到现有模板中。现在，我们将继续获取用户需要的下一部分信息，例如每个层级的价格点。
- en: 'Now let''s think back to what we could need. We''ll need price points for each
    tier, which will also be the input requests for a template kind of algorithm.
    Since each of those will be different for each campaign, we''ll need to leave
    that up to the user to enter. The input lines will look very similar to the previously
    shown snippets. Here is what it looks like for 3 tiers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回想一下我们可能需要什么。我们将需要每个层级的价格点，这也将是模板类型算法的输入请求。由于每个活动的价格点都会有所不同，我们需要让用户输入。输入行将看起来与先前显示的片段非常相似。以下是3个层级的情况：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, notice that we're using comments to separate each section of the code.
    As you can see, we are adding information about how much we are charging for each
    pledge level. The code then continues to do this for the number of tiers, 3, 4,
    or 5.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们使用注释来分隔代码的每个部分。您可以看到，我们正在添加有关每个承诺级别的收费信息。然后代码继续为3、4或5个层级执行此操作。
- en: As was previously discussed, you may also want to test for errors or provide
    an alternative to continue running the code after an error is added by the user.
    We are not addressing those errors in this code but they can certainly be added
    to improve the user experience with this algorithm. As you can see, we've started
    working on how to generalize this algorithm for multiple scenarios.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，您可能还想测试错误或提供在用户添加错误后继续运行代码的替代方法。我们在这段代码中没有处理这些错误，但可以添加以改善用户体验。您可以看到，我们已经开始研究如何将此算法推广到多种情况。
- en: In this case, we're generalizing for multiple uses. But we've used a lot of
    algorithms and seen a lot of scenarios in this book where the generalization of
    the patterns is much simpler. Generalization can be something as simple as writing
    an equation with one variable. Or it can be creating an algorithm for a number
    of circumstances and conditions. That's why it's important to identify what our
    problem is and what exactly we want to accomplish.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在为多种用途进行概括。但是在本书中，我们使用了许多算法并看到了许多情景，其中模式的概括要简单得多。概括可以是编写一个变量方程这样简单的事情。或者可以是为多种情况和条件创建算法。这就是为什么确定我们的问题是什么以及我们确切想要实现什么是很重要的。
- en: In this section, we looked at how and when to get input from the user. We also
    worked through defining variables in order to store the input and use it in our
    equations for the algorithm to output the necessary information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了如何何时从用户那里获取输入。我们还通过定义变量来存储输入并在我们的方程式中使用它，以便算法输出必要的信息。
- en: To complete the algorithm, we'll go to the next section, which is focused on
    the design and testing of the algorithm.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成算法，我们将进入下一部分，重点是设计和测试算法。
- en: Designing and testing the algorithm
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和测试算法
- en: 'In the previous section, we got a lot of input from the user because we were
    creating an algorithm that was used as a template for many campaigns. Now we need
    to use that input in a variety of ways. Here''s what we have so far:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们从用户那里得到了很多输入，因为我们正在创建一个用作许多活动模板的算法。现在我们需要以各种方式使用这些输入。到目前为止，我们已经有了这些：
- en: The number of tiers of pledges
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺层级的数量
- en: The percentage breakdown of the tiers
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同层级的百分比分布
- en: The number of items for each tier
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个层级的物品数量
- en: The cost of each tier
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个层级的成本
- en: Now we can do something with all that information. First, let's talk about what
    we could want. We could want to test how much we'd make selling a specific quantity
    of the tiers. We could also break down how many of each tier we'd need based on
    a funding goal, much as we did in the first part of this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用所有这些信息做一些事情。首先，让我们谈谈我们可能想要的东西。我们可能想测试出售特定数量的层级可以赚多少钱。我们还可以根据筹款目标来分解我们需要多少个每个层级，就像本章的第一部分所做的那样。
- en: '*What would be most helpful?* Well, that really depends on what you need. I''m
    going to say that I want the breakdown based on the funding goal. I want to know
    how many of each pledge type I will need to make available. So now I have to figure
    out how I''m going to get that information from the variables I''ve already defined.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么会最有帮助？* 嗯，这取决于你的需求。我要说的是，我想根据筹资目标来分解。我想知道我需要提供每种承诺类型的数量。所以现在我必须想办法从我已经定义的变量中获取这些信息。'
- en: 'We''ll need to have three conditions here as well. And because the variable
    and how many there are of each variable differs per tier type, we''ll need to
    make sure we''re accounting for that information. Let''s think about three tiers
    first. Given the funding goal, here are some of the outputs that can be helpful:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也需要在这里有三个条件。因为每个等级类型的变量和数量都不同，我们需要确保我们考虑到这些信息。首先让我们考虑三个等级。根据筹资目标，以下是一些有用的输出：
- en: The number of each tier of pledges to be made available
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要提供的每个等级的承诺数量
- en: The number of items per tier that will need to be in inventory
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个等级需要存货的物品数量
- en: '*So how do we figure that out?*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*那我们该如何计算呢？*'
- en: 'Let''s say that we had $50,000 as our funding goal and let''s assume that the
    Tier-1 cost is $500\. Then, we can take the following steps to find the number
    of Tier-1 pledges needed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的筹资目标是50,000美元，假设一级的成本是500美元。那么，我们可以采取以下步骤来找到需要的一级承诺数量：
- en: Multiply the funding goal by the percentage, that is, 50,000 × 0.50 = 25,000.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将筹资目标乘以百分比，即，50,000 × 0.50 = 25,000。
- en: Divide the resulting number by the cost of the pledge, that is, 25,000 ÷ 500
    = 50.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将得到的数字除以承诺的成本，即，25,000 ÷ 500 = 50。
- en: That means that we'll need to post 50 pledges for Tier 1\. Now let's assume
    that the user entered that there were `3` items in Tier 1\. Then, this means 50
    × 3 = 150 items.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要发布50个一级承诺。现在假设用户输入了一级有`3`个物品。那么，这意味着50 × 3 = 150个物品。
- en: 'Now let''s see that in our code. Remember, this is the same file as the previous
    snippets (`ch11_pledgesTemplate.py`). We''re continuing with the discussion using
    pieces of the code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的代码中看看。记住，这是与之前片段相同的文件（`ch11_pledgesTemplate.py`）。我们将继续讨论并使用代码的部分：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding snippet, we have a `print` function with the number of pledges
    for each tier, but they''re also saved as functions in our conditional statement.
    Notice that we''ll now have some output here. We''ll get the number of pledges
    we''ll need from this snippet, but not the number of items per tier. We''ll add
    that shortly. For now, here''s what that output looks like when we run the program:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们有一个`print`函数，其中包含每个等级的承诺数量，但它们也保存为我们条件语句中的函数。请注意，我们现在将在这里得到一些输出。我们将从这段代码中得到我们需要的承诺数量，但不是每个等级的物品数量。我们很快会添加这部分内容。现在，当我们运行程序时，输出看起来是这样的：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, we now know that we need to list 50 Tier-1 pledges at $500,
    38 Tier-2 pledges at $400, and 29 Tier-3 pledges at $350 to reach our funding
    goal. Now we have to figure out how many items we need for each tier given the
    number of items per tier provided. Here''s what that code will look like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在知道我们需要列出50个价值500美元的一级承诺，38个价值400美元的二级承诺，以及29个价值350美元的三级承诺，以达到我们的筹资目标。现在我们必须根据每个等级提供的物品数量来计算每个等级需要多少物品。代码如下：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, now we have another three math equations and a `print` statement
    that breaks down the information for us. We'll get the number of pledges for each
    tier as well as the number of items we'll need for each of the tiers. If you wanted
    even more information from this template, you could include pieces from the first
    example in this chapter, where we broke down the types of items per pledge. We'll
    leave that up to you as a challenge.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在我们有另外三个数学方程和一个`print`语句，为我们分解了信息。我们将得到每个等级的承诺数量，以及每个等级所需的物品数量。如果你想从这个模板中获得更多信息，你可以包括本章第一个示例中的一些内容，那里我们分解了每个承诺的物品类型。我们将把这个挑战留给你。
- en: 'For now, here''s what our final output would look like for three tiers and
    a funding goal of $50,000:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于三个等级和50,000美元的筹资目标，我们的最终输出如下：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we not only have the information we needed, but we also have
    variables set up to use if we need to adapt this information. Thinking back to
    previous chapters and notes that we've been discussing, let's try to determine
    how else we could now save the information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们不仅得到了我们需要的信息，而且还设置了变量，以便在需要时使用这些信息。回想一下我们之前讨论过的章节和笔记，让我们试着确定我们现在如何保存这些信息。
- en: The first thing that comes to mind is that we could create a dictionary that
    stores the information for us. If we did that, then we could recall the information
    we needed from that dictionary, such as the number of items for one tier, for
    example. We could also adjust the key-value pairs if we needed to without having
    to enter the entire thing all over again. Say our initial cost for Tier 1 was
    $500 but we now need it to be $600, yet the other tiers wouldn't change. Then
    we could just adjust that one value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先想到的是，我们可以创建一个字典来为我们存储信息。如果我们这样做，那么我们可以从那个字典中调用我们需要的信息，比如一个等级的物品数量。如果需要，我们还可以调整键值对，而不必重新输入整个内容。假设我们一开始的一级成本是500美元，但现在我们需要它是600美元，而其他等级不会改变。那么我们只需调整那一个值。
- en: This scenario would allow you to explore many of the functionalities of the
    Python programming language we've discussed. Take some time to study the code,
    then make some adjustments and try to use some of your knowledge to improve upon
    it based on different conditions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以让你探索我们讨论过的Python编程语言的许多功能。花些时间研究代码，然后进行一些调整，尝试根据不同的条件利用你的知识来改进它。
- en: Remember, we are always given problem situations that can be interpreted in
    different ways. It is up to us to write algorithms that meet our needs and the
    needs of our clients. Sometimes, we'll get clarification from our stakeholders
    directly. Other times, we'll have to ask for that clarification and/or make some
    of the assumptions ourselves. What is critical is that we design the algorithms
    and document our progress so that we can adjust, adapt, and change pieces of our
    work without having to start over if we don't get what we need.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们总是面临可以用不同方式解释的问题情况。我们需要编写满足我们自己和客户需求的算法。有时，我们会直接从利益相关者那里得到澄清。其他时候，我们需要要求澄清和/或自己做一些假设。关键是我们要设计算法并记录我们的进展，这样我们就可以在不得到所需内容时调整、适应和更改我们的工作部分，而不必重新开始。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went over the computational thinking process one more time
    by working through a more complex scenario and interpretations of that scenario.
    We learned how to decompose the problem provided, then identify the patterns,
    generalize them, and design the algorithms. We used some of what we've learned
    throughout the book to write an algorithm that provided the information we needed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过处理更复杂的情景和对该情景的解释，再次学习了计算思维过程。我们学会了如何分解所提供的问题，然后识别模式、概括它们，并设计算法。我们利用了书中学到的一些知识，编写了一个提供我们所需信息的算法。
- en: The computational thinking process helps us develop skills that make our algorithm
    planning much easier. By walking through that process, we learn more about what
    Python capabilities and functions may help us in particular scenarios. We also
    learned how to generalize patterns, sometimes in simple equations for a problem,
    but other times in creating algorithms that can help us in multiple scenarios
    without having to recreate them each time. As we got to learn more about Python,
    we got more comfortable with the computational thinking process in this last chapter
    of *Section 2*, *Applying Python and Computational Thinking*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算思维过程帮助我们培养技能，使我们的算法规划变得更容易。通过走过这个过程，我们更多地了解了Python的能力和函数在特定情况下如何帮助我们。我们还学会了如何概括模式，有时是为了解决问题而创建简单的方程，但有时是创建可以帮助我们在多种情况下的算法，而不必每次重新创建它们。随着我们对Python的了解越来越多，在*第2节*，*应用Python和计算思维*的最后一章中，我们对计算思维过程更加熟悉。
- en: In *Section 3*, *Data Processing, Analysis, and Applications Using Computational
    Thinking and Python*, we will move on to other capabilities of Python in order
    to deal with data processing, analysis, and applications using computational thinking
    elements. In the next chapter, we'll start to look at data and how we can use
    Python to analyze data, create visual representations, and write algorithms that
    work with experimental data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3节*，*使用计算思维和Python进行数据处理、分析和应用*中，我们将继续探讨Python的其他能力，以处理数据处理、分析和应用计算思维元素。在下一章中，我们将开始研究数据以及如何使用Python分析数据、创建可视化表示，并编写与实验数据配合的算法。
