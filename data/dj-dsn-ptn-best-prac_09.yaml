- en: Chapter 9. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。测试和调试
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Test-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Dos and don'ts of writing tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试的注意事项
- en: Mocking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Every programmer must have, at least, considered skipping writing tests. In
    Django, the default app layout has a `tests.py` module with some placeholder content.
    It is a reminder that tests are needed. However, we are often tempted to skip
    it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员至少都考虑过跳过编写测试。在Django中，默认的应用程序布局具有一个带有一些占位内容的`tests.py`模块。这是一个提醒，需要测试。然而，我们经常会有跳过它的诱惑。
- en: In Django, writing tests is quite similar to writing code. In fact, it is practically
    code. So, the process of writing tests might seem like doubling (or even more)
    the effort of coding. Sometimes, we are under so much time pressure that it might
    seem ridiculous to spend time writing tests when we are just trying to make things
    work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，编写测试与编写代码非常相似。实际上，它几乎就是代码。因此，编写测试的过程可能看起来像是编写代码的两倍（甚至更多）。有时，我们在时间上承受如此大的压力，以至于在试图让事情正常运行时，花时间编写测试似乎是荒谬的。
- en: However, eventually, it is pointless to skip tests if you ever want anyone else
    to use your code. Imagine that you invented an electric razor and tried to sell
    it to your friend saying that it worked well for you, but you haven't tested it
    properly. Being a good friend of yours he or she might agree, but imagine the
    horror if you told this to a stranger.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，如果您希望其他人使用您的代码，跳过测试是毫无意义的。想象一下，您发明了一种电动剃须刀，并试图向朋友出售，说它对您来说效果很好，但您没有进行适当的测试。作为您的好朋友，他或她可能会同意，但是想象一下，如果您告诉这个情况给一个陌生人，那将是多么可怕。
- en: Why write tests?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要编写测试？
- en: Tests in a software check whether it works as expected. Without tests, you might
    be able to say that your code works, but you will have no way to prove that it
    works correctly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中的测试检查它是否按预期工作。没有测试，您可能能够说您的代码有效，但您将无法证明它是否正确工作。
- en: Additionally, it is important to remember that it can be dangerous to omit unit
    testing in Python because of its duck-typing nature. Unlike languages such as
    Haskell, type checking cannot be strictly enforced at compile time. Unit tests,
    being run at runtime (although in a separate execution), are essential in Python
    development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要记住，在Python中省略单元测试可能是危险的，因为它具有鸭子类型的特性。与Haskell等语言不同，类型检查无法在编译时严格执行。在Python开发中，单元测试在运行时（尽管在单独的执行中）是必不可少的。
- en: Writing tests can be a humbling experience. The tests will point out your mistakes
    and you will get a chance to make an early course correction. In fact, there are
    some who advocate writing tests before the code itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试可能是一种令人谦卑的经历。测试将指出您的错误，并且您将有机会进行早期的调整。事实上，有些人主张在编写代码之前先编写测试。
- en: Test-driven development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven development (TDD)** is a form of software development where you
    first write the test, run the test (which would fail first), and then write the
    minimum code needed to make the test pass. This might sound counter-intuitive.
    Why do we need to write tests when we know that we have not written any code and
    we are certain that it will fail because of that?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发（TDD）**是一种软件开发形式，您首先编写测试，运行测试（最初会失败），然后编写使测试通过所需的最少代码。这可能听起来有违直觉。为什么我们需要在知道我们还没有编写任何代码并且确定它会因此失败时编写测试呢？'
- en: However, look again. We do eventually write the code that merely satisfies these
    tests. This means that these tests are not ordinary tests, they are more like
    specifications. They tell you what to expect. These tests or specifications will
    directly come from your client's user stories. You are writing just enough code
    to make it work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请再次看一看。我们最终确实会编写仅满足这些测试的代码。这意味着这些测试不是普通的测试，它们更像是规范。它们告诉你可以期待什么。这些测试或规范将直接来自您的客户的用户故事。您只需编写足够的代码使其正常工作。
- en: The process of test-driven development has many similarities to the scientific
    method, which is the basis of modern science. In the scientific method, it is
    important to frame the hypothesis first, gather data, and then conduct experiments
    that are repeatable and verifiable to prove or disprove your hypothesis.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发的过程与科学方法有许多相似之处，这是现代科学的基础。在科学方法中，重要的是首先提出假设，收集数据，然后进行可重复和可验证的实验来证明或证伪你的假设。
- en: My recommendation would be to try TDD once you are comfortable writing tests
    for your projects. Beginners might find it difficult to frame a test case that
    checks how the code should behave. For the same reasons, I wouldn't suggest TDD
    for exploratory programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，一旦您熟悉为项目编写测试，就尝试TDD。初学者可能会发现很难构建一个检查代码应该如何行为的测试用例。出于同样的原因，我不建议探索性编程使用TDD。
- en: Writing a test case
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: There are different kinds of tests. However, at the minimum, a programmers need
    to know unit tests since they have to be able to write them. Unittesting checks
    the smallest testable part of an application. Integrationtesting checks whether
    these parts work well with each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的测试。但是，至少程序员需要了解单元测试，因为他们必须能够编写它们。单元测试检查应用程序的最小可测试部分。集成测试检查这些部分是否与彼此良好地配合。
- en: 'The word unit is the key term here. Just test one unit at a time. Let''s take
    a look at a simple example of a test case:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键词是单元。一次只测试一个单元。让我们看一个简单的测试用例的例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a simple test that checks whether, when a user visits the root of our
    website's domain, they are correctly taken to the home page view. Like most good
    tests, it has a long and self-descriptive name. The test simply uses Django's
    `resolve()` function to match the view callable mapped to the "`/`" root location
    to the known view function by their names.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的测试，检查当用户访问我们网站域的根目录时，他们是否被正确地带到主页视图。像大多数好的测试一样，它有一个长而自描述的名称。该测试简单地使用Django的`resolve（）`函数将视图可调用匹配到“/”根位置的视图函数，通过它们的名称。
- en: It is more important to note what is not done in this test. We have not tried
    to retrieve the HTML contents of the page or check its status code. We have restricted
    ourselves to test just one unit, that is, the `resolve()` function, which maps
    the URL paths to view functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是要注意这个测试中没有做什么。我们没有尝试检索页面的HTML内容或检查其状态代码。我们限制自己只测试一个单元，即`resolve()`函数，它将URL路径映射到视图函数。
- en: 'Assuming that this test resides in, say, `app1` of your project, the test can
    be run with the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设此测试位于项目的`app1`中，可以使用以下命令运行测试：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command runs all the tests in the `app1` application or package. The default
    test runner will look for tests in all modules in this package matching the pattern
    `test*.py`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行`app1`应用程序或包中的所有测试。默认的测试运行程序将在此包中的所有模块中查找与模式`test*.py`匹配的测试。
- en: 'Django now uses the standard `unittest` module provided by Python rather than
    bundling its own. You can write a `testcase` class by subclassing from `django.test.TestCase`.
    This class typically has methods with the following naming convention:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Django现在使用Python提供的标准`unittest`模块，而不是捆绑自己的模块。您可以通过从`django.test.TestCase`继承来编写`testcase`类。该类通常具有以下命名约定的方法：
- en: '`test*`: Any method whose name starts with `test` will be executed as a test
    method. It takes no parameters and returns no values. Tests will be run in an
    alphabetical order.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test*`：任何以`test`开头的方法都将作为测试方法执行。它不带参数，也不返回任何值。测试将按字母顺序运行。'
- en: '`setUp` (optional): This method will be run before each test method. It can
    be used to create common objects or perform other initialization tasks that bring
    your test case to a known state.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUp`（可选）：此方法将在每个测试方法运行之前运行。它可用于创建公共对象或执行其他初始化任务，使测试用例处于已知状态。'
- en: '`tearDown` (optional): This method will be run after a test method, irrespective
    of whether the test passed or not. Clean-up tasks are usually performed here.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tearDown`（可选）：此方法将在测试方法之后运行，无论测试是否通过。通常在此执行清理任务。'
- en: A test case is a way to logically group test methods, all of which test a scenario.
    When all the test methods pass (that is, do not raise any exception), then the
    test case is considered passed. If any of them fail, then the test case fails.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例是逻辑上组织测试方法的一种方式，所有这些方法都测试一个场景。当所有测试方法都通过（即不引发任何异常）时，测试用例被视为通过。如果其中任何一个失败，则测试用例失败。
- en: The assert method
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assert方法
- en: Each test method usually invokes an `assert*()` method to check some expected
    outcome of the test. In our first example, we used `assertEqual()` to check whether
    the function name matches with the expected function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法通常调用`assert*()`方法来检查测试的某些预期结果。在我们的第一个示例中，我们使用`assertEqual()`来检查函数名称是否与预期函数匹配。
- en: Similar to `assertEqual()`, the Python 3 `unittest` library provides more than
    32 assert methods. It is further extended by Django by more than 19 framework-specific
    assert methods. You must choose the most appropriate method based on the end outcome
    that you are expecting so that you will get the most helpful error message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与`assertEqual()`类似，Python 3的`unittest`库提供了超过32个断言方法。Django通过超过19个特定于框架的断言方法进一步扩展了它。您必须根据您期望的最终结果选择最合适的方法，以便获得最有帮助的错误消息。
- en: 'Let''s see why by looking at an example `testcase` that has the following `setUp()`
    method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看具有以下`setUp()`方法的示例`testcase`来看看为什么：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our test is to assert that `l1` and `l2` are equal (and it should fail, given
    their values). Let''s take a look at several equivalent ways to accomplish this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试是断言`l1`和`l2`是否相等（鉴于它们的值，它应该失败）。让我们看看几种等效的方法来实现这一点：
- en: '| Test Assertion Statement | What Test Output Looks Like (unimportant lines
    omitted) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 测试断言语句 | 测试输出的外观（省略不重要的行） |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The first statement uses Python's built- in `assert` keyword. Notice that it
    throws the least helpful error. You cannot infer what values or types are in the
    `self.l1` and `self.l2` variables. This is primarily the reason why we need to
    use the `assert*()` methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句使用了Python内置的`assert`关键字。请注意，它抛出的错误最不有帮助。您无法推断出`self.l1`和`self.l2`变量中的值或类型。这主要是我们需要使用`assert*()`方法的原因。
- en: Next, the exception thrown by `assertEqual()` very helpfully tells you that
    you are comparing two lists and even tells you at which position they begin to
    differ. This is exactly similar to the exception thrown by the more specialized
    `assertListEqual()` function. This is because, as the documentation would tell
    you, if `assertEqual()` is given two lists for comparison, then it hands it over
    to `assertListEqual()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`assertEqual()`抛出的异常非常有帮助，它告诉您正在比较两个列表，甚至告诉您它们开始有差异的位置。这与更专门的`assertListEqual()`函数抛出的异常完全相同。这是因为，正如文档所告诉您的那样，如果`assertEqual()`给出两个列表进行比较，那么它会将其交给`assertListEqual()`。
- en: Despite this, as the last example proves, it is always better to use the most
    specific `assert*` method for your tests. Since the second argument is not a list,
    the error clearly tells you that a list was expected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如最后一个示例所证明的那样，对于测试来说，始终最好使用最具体的`assert*`方法。由于第二个参数不是列表，错误明确告诉您期望的是列表。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use the most specific `assert*` method in your tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用最具体的`assert*`方法。
- en: Therefore, you need to familiarize yourself with all the `assert` methods, and
    choose the most specific one to evaluate the result you expect. This also applies
    to when you are checking whether your application does not do things it is not
    supposed to do, that is, a negative test case. You can check for exceptions or
    warnings using `assertRaises` and `assertWarns` respectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要熟悉所有的`assert`方法，并选择最具体的方法来评估您期望的结果。这也适用于当您检查应用程序是否没有执行不应该执行的操作时，即负面测试用例。您可以分别使用`assertRaises`和`assertWarns`来检查异常或警告。
- en: Writing better test cases
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更好的测试用例
- en: We have already seen that the best test cases test a small unit of code at a
    time. They also need to be fast. A programmer needs to run tests at least once
    before every commit to the source control. Even a delay of a few seconds can tempt
    a programmer to skip running tests (which is not a good thing).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，最好的测试用例一次测试一小部分代码。它们还需要快速。程序员需要在每次提交到源代码控制之前至少运行一次测试。即使延迟几秒钟也可能会诱使程序员跳过运行测试（这不是一件好事）。
- en: 'Here are some qualities of a good test case (which is a subjective term, of
    course) in the form of an easy-to-remember mnemonic "**F.I.R.S.T**. class test
    case":'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个好的测试用例的一些特点（当然，这是一个主观的术语），以易于记忆的助记符“**F.I.R.S.T**”形式的类测试用例：
- en: '**Fast**: the faster the tests, the more often they are run. Ideally, your
    tests should complete in a few seconds.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快速**：测试越快，运行次数越多。理想情况下，您的测试应该在几秒钟内完成。'
- en: '**Independent**: Each test case must be independent of others and can be run
    in any order.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**独立**：每个测试用例必须独立于其他测试用例，并且可以以任何顺序运行。'
- en: '**Repeatable**: The results must be the same every time a test is run. Ideally,
    all random and varying factors must be controlled or set to known values before
    a test is run.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可重复**：结果在每次运行测试时必须相同。理想情况下，所有随机和变化因素都必须在运行测试之前得到控制或设置为已知值。'
- en: '**Small**: Test cases must be as short as possible for speed and ease of understanding.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**小型**：测试用例必须尽可能简短，以提高速度和易于理解。'
- en: '**Transparent**: Avoid tricky implementations or ambiguous test cases.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**透明**：避免棘手的实现或模糊的测试用例。'
- en: Additionally, make sure that your tests are automatic. Eliminate any manual
    steps, no matter how small. Automated tests are more likely to be a part of your
    team's workflow and easier to use for tooling purposes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保您的测试是自动的。消除任何手动步骤，无论多么小。自动化测试更有可能成为团队工作流程的一部分，并且更容易用于工具化目的。
- en: 'Perhaps, even more important are the don''ts to remember while writing test
    cases:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，编写测试用例时更重要的是要记住的一些不要做的事情：
- en: '**Do not (re)test the framework**: Django is well tested. Don''t check for
    URL lookup, template rendering, and other framework-related functionality.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要（重新）测试框架**：Django经过了充分的测试。不要检查URL查找、模板渲染和其他与框架相关的功能。'
- en: '**Do not test implementation details**: Test the interface and leave the minor
    implementation details. It makes it easier to refactor this later without breaking
    the tests.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要测试实现细节**：测试接口，留下较小的实现细节。这样以后重构会更容易，而不会破坏测试。'
- en: '**Test models most, templates least**: Templates should have the least business
    logic, and they change more often.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试模型最多，模板最少**：模板应该具有最少的业务逻辑，并且更改频率更高。'
- en: '**Avoid HTML output validation**: Test views use their context variable''s
    output rather than its HTML-rendered output.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免HTML输出验证**：测试视图使用其上下文变量的输出，而不是其HTML渲染的输出。'
- en: '**Avoid using the web test client in unit tests**: Web test clients invoke
    several components and are therefore, better suited for integration tests.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免在单元测试中使用Web测试客户端**：Web测试客户端调用多个组件，因此更适合集成测试。'
- en: '**Avoid interacting with external systems**: Mock them if possible. Database
    is an exception since test database is in-memory and quite fast.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免与外部系统交互**：如果可能的话，对其进行模拟。数据库是一个例外，因为测试数据库是内存中的，而且非常快。'
- en: Of course, you can (and should) break the rules where you have a good reason
    to (just like I did in my first example). Ultimately, the more creative you are
    at writing tests, the earlier you can catch bugs, and the better your application
    will be.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以（也应该）在有充分理由的情况下打破规则（就像我在我的第一个例子中所做的那样）。最终，您在编写测试时越有创意，就越早发现错误，您的应用程序就会越好。
- en: Mocking
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Most real-life projects have various interdependencies between components. While
    testing one component, the result must not be affected by the behavior of other
    components. For example, your application might call an external web service that
    might be unreliable in terms of network connection or slow to respond.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现实项目的各个组件之间存在各种相互依赖关系。在测试一个组件时，其结果不能受到其他组件行为的影响。例如，您的应用程序可能调用一个可能在网络连接方面不可靠或响应速度慢的外部网络服务。
- en: Mock objects imitate such dependencies by having the same interface, but they
    respond to method calls with canned responses. After using a mock object in a
    test, you can assert whether a certain method was called and verify that the expected
    interaction took place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象通过具有相同接口来模拟这些依赖关系，但它们会对方法调用做出预先设定的响应。在测试中使用模拟对象后，您可以断言是否调用了某个特定方法，并验证预期的交互是否发生。
- en: 'Take the example of the SuperHero profile eligibility test mentioned in *Pattern:
    Service objects* (see [Chapter 3](ch03.html "Chapter 3. Models"), *Models*). We
    are going to mock the call to the service object method in a test using the Python
    3 `unittest.mock` library:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以*模式：服务对象*（见[第3章](ch03.html "第3章. 模型")，*模型*）中提到的超级英雄资格测试为例。我们将使用Python 3的`unittest.mock`库在测试中模拟对服务对象方法的调用：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are using `patch()` as a context manager in a `with` statement. Since
    the profile model's `is_superhero()` method will call the `SuperHeroWebAPI.is_hero()`
    class method, we need to mock it inside the `models` module. We are also hard-coding
    the return value of this method to be `True`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`with`语句中使用`patch()`作为上下文管理器。由于配置文件模型的`is_superhero()`方法将调用`SuperHeroWebAPI.is_hero()`类方法，我们需要在`models`模块内对其进行模拟。我们还将硬编码此方法的返回值为`True`。
- en: The last two assertions check whether the method was called with the correct
    arguments and if `is_hero()` returned `True`, respectively. Since all methods
    of `SuperHeroWebAPI` class have been mocked, both the assertions will pass.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个断言检查方法是否使用正确的参数进行了调用，以及`is_hero()`是否返回了`True`。由于`SuperHeroWebAPI`类的所有方法都已被模拟，这两个断言都将通过。
- en: Mock objects come from a family called **Test Doubles**, which includes stubs,
    fakes, and so on. Like movie doubles who stand in for real actors, these test
    doubles are used in place of real objects while testing. While there are no clear
    lines drawn between them, Mock objects are objects that can test the behavior,
    and stubs are simply placeholder implementations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象来自一个称为**测试替身**的家族，其中包括存根、伪造等。就像电影替身代替真正的演员一样，这些测试替身在测试时代替真实对象使用。虽然它们之间没有明确的界限，但模拟对象是可以测试行为的对象，而存根只是占位符实现。
- en: Pattern – test fixtures and factories
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 测试固件和工厂
- en: '**Problem**: Testing a component requires the creation of various prerequisite
    objects before the test. Creating them explicitly in each test method gets repetitive.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：测试一个组件需要在测试之前创建各种先决对象。在每个测试方法中显式创建它们会变得重复。'
- en: '**Solution**: Utilize factories or fixtures to create the test data objects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：利用工厂或固件来创建测试数据对象。'
- en: Problem details
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题细节
- en: Before running each test, Django resets the database to its initial state, as
    it would be after running migrations. Most tests will need the creation of some
    initial objects to set the state. Rather than creating different initial objects
    for different scenarios, a common set of initial objects are usually created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个测试之前，Django会将数据库重置为其初始状态，就像运行迁移后的状态一样。大多数测试都需要创建一些初始对象来设置状态。通常情况下，不同的初始对象不会为不同的场景创建，而是通常创建一组通用的初始对象。
- en: This can quickly get unmanageable in a large test suite. The sheer variety of
    such initial objects can be hard to read and later understand. This leads to hard-to-find
    bugs in the test data itself!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型测试套件中，这可能很快变得难以管理。这些初始对象的种类繁多，很难阅读和理解。这会导致测试数据本身中难以找到的错误！
- en: Being such a common problem, there are several means to reduce the clutter and
    write clearer test cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个常见的问题，有几种方法可以减少混乱并编写更清晰的测试用例。
- en: Solution details
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案细节
- en: The first solution we will take a look at is what is given in the Django documentation
    itself—test fixtures. Here, a test fixture is a file that contains a set of data
    that can be imported into your database to bring it to a known state. Typically,
    they are YAML or JSON files previously exported from the same database when it
    had some data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下Django文档中提供的解决方案 - 测试固件。在这里，测试固件是一个包含一组数据的文件，可以导入到数据库中，使其达到已知状态。通常情况下，它们是从同一数据库中导出的YAML或JSON文件，当时数据库中有一些数据。
- en: 'For example, consider the following test case, which uses a test fixture:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下使用测试固件的测试用例：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before `setUp()` gets called in each test case, the specified fixture, posts
    gets loaded. Roughly speaking, the fixture would be searched for in the fixtures
    directory with certain known extensions, for example, `app/fixtures/posts.json`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试用例中调用`setUp()`之前，指定的固件`posts`会被加载。粗略地说，固件将在固件目录中搜索具有某些已知扩展名的文件，例如`app/fixtures/posts.json`。
- en: However, there are a number of problems with fixtures. Fixtures are static snapshots
    of the database. They are schema-dependent and have to be changed each time your
    models change. They also might need to be updated when your test-case assertions
    change. Updating a large fixture file manually, with multiple related objects,
    is no joke.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，固件存在许多问题。固件是数据库的静态快照。它们依赖于模式，并且每当模型更改时都必须更改。当测试用例的断言更改时，它们也可能需要更新。手动更新一个包含多个相关对象的大型固件文件并不是一件简单的事情。
- en: For all these reasons, many consider using fixtures as an anti-pattern. It is
    recommended that you use factories instead. A factory class creates objects of
    a particular class that can be used in tests. It is a DRY way of creating initial
    test objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，许多人认为使用固件是一种反模式。建议您改用工厂。工厂类创建特定类的对象，可以在测试中使用。这是一种DRY的方式来创建初始测试对象。
- en: 'Let''s use a model''s `objects.create` method to create a simple factory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模型的`objects.create`方法来创建一个简单的工厂：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compared to using fixtures, the initial object creation and the test cases are
    all in one place. Fixtures load static data as is into the database without calling
    model-defined `save()` methods. Since factory objects are dynamically generated,
    they are more likely to run through your application's custom validations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用固件相比，初始对象的创建和测试用例都在一个地方。固件将静态数据原样加载到数据库中，而不调用模型定义的`save()`方法。由于工厂对象是动态生成的，它们更有可能通过应用程序的自定义验证。
- en: However, there is a lot of boilerplate in writing such factory classes yourself.
    The `factory_boy` package, based on thoughtbot's `factory_girl`, provides a declarative
    syntax for creating object factories.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写这种工厂类本身存在很多样板代码。基于thoughtbot的`factory_girl`，`factory_boy`包提供了一个声明性的语法来创建对象工厂。
- en: 'Rewriting the previous code to use `factory_boy`, we get the following result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将先前的代码重写为使用`factory_boy`，我们得到以下结果：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how clear the `factory` class becomes when written in a declarative fashion.
    The attribute's values do not have to be static. You can have sequential, random,
    or computed attribute values. If you prefer to have more realistic placeholder
    data such as US addresses, then use the `django-faker` package.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在声明性方式下编写的`factory`类变得多么清晰。属性的值不必是静态的。您可以具有顺序、随机或计算的属性值。如果您希望使用更真实的占位符数据，例如美国地址，那么请使用`django-faker`包。
- en: In conclusion, I would recommend factories, especially `factory_boy`, for most
    projects that need initial test objects. One might still want to use fixtures
    for static data, such as lists of countries or t-shirt sizes, since they would
    rarely change.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我建议大多数需要初始测试对象的项目使用工厂，特别是`factory_boy`。尽管人们可能仍然希望使用固件来存储静态数据，例如国家列表或T恤尺寸，因为它们很少改变。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Dire Predictions**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**可怕的预测**'
- en: After the announcement of the impossible deadline, the entire team seemed to
    be suddenly out of time. They went from 4-week scrum sprints to 1-week sprints.
    Steve wiped every meeting off their calendars except "today's 30-minute catch-up
    with Steve." He preferred to have a one-on-one discussion if he needed to talk
    to someone at their desk.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布了不可能的最后期限之后，整个团队似乎突然没有时间了。他们从4周的Scrum冲刺变成了1周的冲刺。史蒂夫把他们日历上的每次会议都取消了，除了“今天与史蒂夫的30分钟补充会议”。如果他需要与某人交谈，他更喜欢一对一的讨论。
- en: At Madam O's insistence, the 30-minute meetings were held at a sound proof hall
    20 levels below the S.H.I.M. headquarters. On Monday, the team stood around a
    large circular table with a gray metallic surface like the rest of the room. Steve
    stood awkwardly in front of it and made a stiff waving gesture with an open palm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Madam O的坚持下，30分钟的会议在S.H.I.M.总部下面20层的隔音大厅举行。周一，团队站在一个灰色金属表面的大圆桌周围。史蒂夫笨拙地站在桌子前，用手掌做了一个僵硬的挥动手势。
- en: Even though everyone had seen the holographs come alive before, it never failed
    to amaze them each time. The disc almost segmented itself into hundreds of metallic
    squares and rose like miniature skyscrapers in a futuristic model city. It took
    them a second to realize that they were looking at a 3D bar chart.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个人都曾见过全息图像活跃起来，但每次看到它们都让他们惊叹不已。这个圆盘几乎分成了数百个金属方块，并像未来模型城市中的迷你摩天大楼一样升起。他们花了一秒钟才意识到他们正在看一个3D柱状图。
- en: '"Our burn-down chart seems to be showing signs of slowing down. I am guessing
    it is the outcome of our recent user tests, which is a good thing. But…" Steve''s
    face seemed to show the strain of trying to stifle a sneeze. He gingerly flicked
    his forefinger upwards in the air and the chart smoothly extended to the right.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “我们的燃尽图似乎显示出放缓的迹象。我猜这是我们最近用户测试的结果，这是一件好事。但是……”史蒂夫的脸上似乎带着压抑打喷嚏的表情。他小心翼翼地用食指在空中轻轻一弹，图表顺利地向右延伸。
- en: '"At this rate, projections indicate that we will miss the go-live by several
    days, at best. I did a bit of analysis and found several critical bugs late in
    our development. We can save a lot of time and effort if we can catch them early.
    I want to put your heads together and come up with some i..."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的速度，预测显示我们最好也要推迟上线几天。我做了一些分析，发现我们在开发的后期发现了一些关键的错误。如果我们能早点发现它们，我们就可以节省很多时间和精力。我想让你们集思广益，想出一些……”
- en: Steve clasped his mouth and let out a loud sneeze. The holograph interpreted
    this as a sign to zoom into a particularly uninteresting part of the graph. Steve
    cursed under his breath and turned it off. He borrowed a napkin and started noting
    down everyone's suggestions with an ordinary pen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫捂住嘴，打了一个响亮的喷嚏。全息图将这解释为放大图表中一个特别无聊的部分的迹象。史蒂夫咒骂着关掉了它。他借了一张餐巾纸，开始用普通的笔记下每个人的建议。
- en: One of the suggestions that Steve liked most was a coding checklist listing
    the most common bugs, such as forgetting to apply migrations. He also liked the
    idea of involving users earlier in the development process for feedback. He also
    noted down some unusual ideas, such as a Twitter handle for tweeting the status
    of the continuous integration server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫最喜欢的建议之一是编写一个编码清单，列出最常见的错误，比如忘记应用迁移。他还喜欢在开发过程中早期让用户参与并提供反馈的想法。他还记下了一些不寻常的想法，比如为连续集成服务器的状态发布推特。
- en: At the close of the meeting, Steve noticed that Evan was missing. "Where is
    Evan?" he asked. "No idea," said Brad looking confused, "he was here a minute
    ago."
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 会议结束时，史蒂夫注意到埃文不见了。“埃文在哪里？”他问。“不知道，”布拉德看起来很困惑地说，“刚才还在这。”
- en: Learning more about testing
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多关于测试
- en: Django's default test runner has improved a lot over the years. However, test
    runners such as `py.test` and `nose` are still superior in terms of functionality.
    They make your tests easier to write and run. Even better, they are compatible
    with your existing test cases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Django的默认测试运行器已经有了很大的改进。然而，像`py.test`和`nose`这样的测试运行器在功能上仍然更胜一筹。它们使你的测试更容易编写和运行。更好的是，它们与你现有的测试用例兼容。
- en: You might also be interested in knowing what percentage of your code is covered
    by tests. This is called **Code coverage** and `coverage.py` is a very popular
    tool for finding this out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也对知道你的代码有多少百分比是由测试覆盖的感兴趣。这被称为**代码覆盖**，`coverage.py`是一个非常流行的工具，可以找出这一点。
- en: Most projects today tend to use a lot of JavaScript functionality. Writing tests
    for them usually require a browser-like environment for execution. Selenium is
    a great browser automation tool for executing such tests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的大多数项目往往使用了大量的JavaScript功能。为它们编写测试通常需要一个类似浏览器的环境来执行。Selenium是一个用于执行此类测试的出色的浏览器自动化工具。
- en: While a detailed treatment of testing in Django is outside the scope of this
    book, I would strongly recommend that you learn more about it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本书的范围之外详细讨论Django中的测试，我强烈建议你了解更多关于它的知识。
- en: If nothing else, the two main takeaways I wanted to convey through this section
    are first, write tests, and second, once you are confident at writing them, practice
    TDD.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有别的，我想通过这一部分传达的两个主要观点是，首先，编写测试，其次，一旦你对编写测试有信心，就要练习TDD。
- en: Debugging
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Despite the most rigorous testing, the sad reality is, we still have to deal
    with bugs. Django tries its best to be as helpful as possible while reporting
    an error to help you in debugging. However, it takes a lot of skill to identify
    the root cause of the problem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进行了最严格的测试，悲哀的现实是，我们仍然不得不处理错误。Django尽最大努力在报告错误时提供帮助。然而，要识别问题的根本原因需要很多技巧。
- en: Thankfully, with the right set of tools and techniques, we can not only identify
    the bugs but also gain great insight into the runtime behavior of your code. Let's
    take a look at some of these tools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过正确的工具和技术，我们不仅可以识别错误，还可以深入了解代码的运行时行为。让我们来看看其中一些工具。
- en: Django debug page
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django调试页面
- en: 'If you have encountered any exception in development, that is, when `DEBUG=True`,
    then you would have already seen an error page similar to the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在开发中遇到任何异常，即`DEBUG=True`时，那么您可能已经看到了类似以下截图的错误页面：
- en: '![Django debug page](img/6644OS_09_01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Django调试页面](img/6644OS_09_01.jpg)'
- en: 'Since it comes up so frequently, most developers tend to miss the wealth of
    information in this page. Here are some places to take a look at:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它经常出现，大多数开发人员倾向于忽略此页面中的丰富信息。以下是一些要查看的地方：
- en: '**Exception details**: Obviously, you need to read what the exception tells
    you very carefully.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常详细信息**：显然，您需要非常仔细地阅读异常告诉您的内容。'
- en: '**Exception location**: This is where Python thinks where the error has occurred.
    In Django, this may or may not be where the root cause of the bug is.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常位置**：这是Python认为错误发生的位置。在Django中，这可能是错误的根本原因，也可能不是。'
- en: '**Traceback**: This was the call stack when the error occurred. The line that
    caused the error will be at the end. The nested calls that led to it will be above
    it. Don''t forget to click on the ''**Local vars**'' arrow to inspect the values
    of the variables at the time of the exception.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回溯**：这是错误发生时的调用堆栈。导致错误的行将在最后。导致它的嵌套调用将在其上方。不要忘记单击“**Local vars**”箭头以检查异常发生时变量的值。'
- en: '**Request information**: This is a table (not shown in the screenshot) that
    shows context variables, meta information, and project settings. Check for malformed
    input in the requests here.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求信息**：这是一个表格（未在截图中显示），显示上下文变量、元信息和项目设置。在此处检查请求中的格式错误。'
- en: A better debug page
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的调试页面
- en: 'Often, you may wish for more interactivity in the default Django error page.
    The `django-extensions` package ships with the fantastic Werkzeug debugger that
    provides exactly this feature. In the following screenshot of the same exception,
    notice a fully interactive Python interpreter available at each level of the call
    stack:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能希望在默认的Django错误页面中获得更多的交互性。`django-extensions`软件包附带了出色的Werkzeug调试器，提供了这个功能。在相同异常的以下截图中，请注意在调用堆栈的每个级别上都有一个完全交互式的Python解释器：
- en: '![A better debug page](img/6644OS_09_02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![更好的调试页面](img/6644OS_09_02.jpg)'
- en: 'To enable this, in addition to adding `django_extensions` to your `INSTALLED_APPS`,
    you will need to run your test server as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，除了将`django_extensions`添加到您的`INSTALLED_APPS`中，您还需要按照以下方式运行测试服务器：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Despite the reduced debugging information, I find the Werkzeug debugger to be
    more useful than the default error page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调试信息减少了，但我发现Werkzeug调试器比默认错误页面更有用。
- en: The print function
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印函数
- en: Sprinkling `print()` functions all over the code for debugging might sound primitive,
    but it has been the preferred technique for many programmers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中到处添加`print()`函数进行调试可能听起来很原始，但对许多程序员来说，这是首选的技术。
- en: Typically, the `print()` functions are added before the line where the exception
    has occurred. It can be used to print the state of variables in various lines
    leading to the exception. You can trace the execution path by printing something
    when a certain line is reached.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在发生异常的行之前添加`print()`函数。它可以用于打印导致异常的各行中变量的状态。您可以通过在达到某一行时打印某些内容来跟踪执行路径。
- en: In development, the print output usually appears in the console window where
    the test server is running. Whereas in production, these print outputs might end
    up in your server log file where they would add a runtime overhead.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，打印输出通常会出现在运行测试服务器的控制台窗口中。而在生产中，这些打印输出可能会出现在服务器日志文件中，从而增加运行时开销。
- en: In any case, it is not a good debugging technique to use in production. Even
    if you do, the print functions that are added for debugging should be removed
    from being committed to your source control.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在生产中使用它都不是一个好的调试技术。即使您这样做，也应该从提交到源代码控制中的`print`函数中删除。
- en: Logging
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'The main reason for including the previous section was to say—You should replace
    the `print()` functions with calls to logging functions in Python''s `logging`
    module. Logging has several advantages over printing: it has a timestamp, a clearly
    marked level of urgency (for example, INFO, DEBUG), and you don''t have to remove
    them from your code later.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 包括前一部分的主要原因是说 - 您应该用Python的`logging`模块中的日志函数来替换`print()`函数。日志记录比打印有几个优点：它具有时间戳，明确定义的紧急程度（例如，INFO，DEBUG），而且您以后不必从代码中删除它们。
- en: Logging is fundamental to professional web development. Several applications
    in your production stack, like web servers and databases, already use logs. Debugging
    might take you to all these logs to retrace the events that lead to a bug. It
    is only appropriate that your application follows the same best practice and adopts
    logging for errors, warnings, and informational messages.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录对于专业的Web开发至关重要。您的生产堆栈中的几个应用程序，如Web服务器和数据库，已经使用日志。调试可能会带您到所有这些日志，以追溯导致错误的事件。您的应用程序遵循相同的最佳实践并采用日志记录以记录错误、警告和信息消息是合适的。
- en: Unlike the common perception, using a logger does not involve too much work.
    Sure, the setup is slightly involved but it is merely a one-time effort for your
    entire project. Even more, most project templates (for example, the `edge` template)
    already do this for you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与普遍看法不同，使用记录器并不涉及太多工作。当然，设置稍微复杂，但这仅仅是对整个项目的一次性努力。而且，大多数项目模板（例如`edge`模板）已经为您做到了这一点。
- en: 'Once you have configured the `LOGGING` variable in `settings.py`, adding a
    logger to your existing code is quite easy, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在`settings.py`中配置了`LOGGING`变量，像这样向现有代码添加记录器就非常容易：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `logging` module provides various levels of logged messages so that you
    can easily filter out less urgent messages. The log output can be also formatted
    in various ways and routed to many places, such as standard output or log files.
    Read the documentation of Python's `logging` module to learn more.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块提供了各种级别的日志消息，以便您可以轻松过滤掉不太紧急的消息。日志输出也可以以各种方式格式化，并路由到许多位置，例如标准输出或日志文件。阅读Python的`logging`模块文档以了解更多信息。'
- en: The Django Debug Toolbar
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django Debug Toolbar
- en: The Django Debug Toolbar is an indispensable tool not just for debugging but
    also for tracking detailed information about each request and response. Rather
    than appearing only during exceptions, the toolbar is always present in your rendered
    page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar不仅是调试的必不可少的工具，还可以跟踪每个请求和响应的详细信息。工具栏不仅在异常发生时出现，而且始终出现在呈现的页面中。
- en: 'Initially, it appears as a clickable graphic on the right-hand side of your
    browser window. On clicking, a toolbar appears as a dark semi-transparent sidebar
    with several headers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，它会出现在浏览器窗口右侧的可点击图形上。单击后，工具栏将作为一个深色半透明的侧边栏出现，并带有几个标题：
- en: '![The Django Debug Toolbar](img/6644OS_09_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Django Debug Toolbar](img/6644OS_09_03.jpg)'
- en: Each header is filled with detailed information about the page from the number
    of SQL queries executed to the templates that we use to render the page. Since
    the toolbar disappears when `DEBUG` is set to False, it is pretty much restricted
    to being a development tool.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标题都包含有关页面的详细信息，从执行的SQL查询数量到用于呈现页面的模板。由于当`DEBUG`设置为False时，工具栏会消失，因此它基本上只能作为开发工具使用。
- en: The Python debugger pdb
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python调试器pdb
- en: While debugging, you might need to stop a Django application in the middle of
    execution to examine its state. A simple way to achieve this is to raise an exception
    with a simple `assert False` line in the required place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，您可能需要在Django应用程序执行中间停止以检查其状态。实现这一点的简单方法是在所需位置使用简单的`assert False`行引发异常。
- en: 'What if you wanted to continue the execution step by step from that line? This
    is possible with the use of an interactive debugger such as Python''s `pdb`. Simply
    insert the following line wherever you want the execution to stop and switch to
    `pdb`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要从那一行开始逐步执行，可以使用交互式调试器，例如Python的`pdb`。只需在想要停止执行的位置插入以下行并切换到`pdb`：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you enter `pdb`, you will see a command-line interface in your console
    window with a `(Pdb)` prompt. At the same time, your browser window will not display
    anything as the request has not finished processing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入`pdb`，您将在控制台窗口中看到一个命令行界面，带有`(Pdb)`提示。与此同时，您的浏览器窗口不会显示任何内容，因为请求尚未完成处理。
- en: The pdb command-line interface is extremely powerful. It allows you to go through
    the code line by line, examine the variables by printing them, or execute arbitrary
    code that can even change the running state. The interface is quite similar to
    GDB, the GNU debugger.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: pdb命令行界面非常强大。它允许您逐行查看代码，通过打印它们来检查变量，或执行甚至可以更改运行状态的任意代码。该界面与GNU调试器GDB非常相似。
- en: Other debuggers
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他调试器
- en: 'There are several drop-in replacements for `pdb`. They usually have a better
    interface. Some of the console-based debuggers are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可替换`pdb`的工具。它们通常具有更好的界面。以下是一些基于控制台的调试器：
- en: '`ipdb`: Like IPython, this has autocomplete, syntax-colored code, and so on.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipdb`：像IPython一样，它具有自动完成、语法着色的代码等。'
- en: '`pudb`: Like old Turbo C IDEs, this shows the code and variables side by side.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb`：像旧的Turbo C IDE一样，它将代码和变量并排显示。'
- en: '`IPython`: This is not a debugger. You can get a full IPython shell anywhere
    in your code by adding the `from IPython import embed; embed()`line.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPython`：这不是一个调试器。您可以通过添加`from IPython import embed; embed()`行在代码中的任何位置获取完整的IPython
    shell。'
- en: 'PuDB is my preferred replacement for pdb. It is so intuitive that even beginners
    can easily use this interface. Like pdb, just insert the following code to break
    the execution of the program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PuDB是我首选的pdb替代品。它非常直观，即使是初学者也可以轻松使用这个界面。与pdb一样，只需插入以下代码来中断程序的执行：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When this line is executed, a full-screen debugger is launched, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此行时，将启动全屏调试器，如下所示：
- en: '![Other debuggers](img/6644OS_09_04.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![其他调试器](img/6644OS_09_04.jpg)'
- en: Press the `?` key to get help on the complete list of keys that you can use.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`?`键以获取有关可以使用的完整键列表的帮助。
- en: Additionally, there are several graphical debuggers, some of which are standalone,
    such as `winpdb` and others, which are integrated to the IDE, such as PyCharm,
    PyDev, and Komodo. I would recommend that you try several of them until you find
    the one that suits your workflow.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有几种图形调试器，其中一些是独立的，例如`winpdb`，另一些是集成到IDE中的，例如PyCharm，PyDev和Komodo。我建议您尝试其中几种，直到找到适合您工作流程的调试器。
- en: Debugging Django templates
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Django模板
- en: Projects can have very complicated logic in their templates. Subtle bugs while
    creating a template can lead to hard-to-find bugs. We need to set `TEMPLATE_DEBUG`
    to `True` (in addition to `DEBUG`) in `settings.py` so that Django shows a better
    error page when there is an error in your templates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的模板中可能有非常复杂的逻辑。在创建模板时出现细微错误可能导致难以找到的错误。我们需要在`settings.py`中将`TEMPLATE_DEBUG`设置为`True`（除了`DEBUG`），以便Django在模板出现错误时显示更好的错误页面。
- en: 'There are several crude ways to debug templates, such as inserting the variable
    of interest, such as `{{ variable }}`, or if you want to dump all the variables,
    use the built-in `debug` tag like this (inside a conveniently clickable text area):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种粗糙的调试模板的方法，例如插入感兴趣的变量，如`{{ variable }}`，或者如果要转储所有变量，可以使用内置的`debug`标签，如下所示（在一个方便的可点击文本区域内）：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A better option is use the Django Debug Toolbar mentioned earlier. It not only
    tells you the values of the context variables but also shows the inheritance tree
    of your templates.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是使用前面提到的Django Debug Toolbar。它不仅告诉您上下文变量的值，还显示模板的继承树。
- en: However, you might want to pause in the middle of a template to inspect the
    state (say, inside a loop). A debugger would be perfect for such cases. In fact,
    it is possible to use any one of the aforementioned Python debuggers for your
    templates using custom template tags.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能希望在模板的中间暂停以检查状态（比如在循环内）。调试器对于这种情况非常完美。事实上，可以使用前面提到的任何一个Python调试器来为您的模板使用自定义模板标签。
- en: 'Here is a simple implementation of such a template tag. Create the following
    file inside a `templatetag` package directory:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模板标签的实现。在`templatetag`包目录下创建以下文件：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In your template, load the template tag library, insert the `pdb` tag wherever
    you need the execution to pause, and enter the debugger:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的模板中，加载模板标签库，将`pdb`标签插入到需要执行暂停的地方，并进入调试器：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Within the debugger, you can examine anything, including the context variables
    using the `context` dictionary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中，您可以检查任何东西，包括使用`context`字典的上下文变量：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need more such template tags for debugging and introspection, then I
    would recommend that you check out the `django-template-debug` package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多类似的模板标签用于调试和内省，我建议您查看`django-template-debug`包。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the motivations and concepts behind testing in
    Django. We also found the various best practices to be followed while writing
    a test case. In the section on debugging, we got familiar with the various debugging
    tools and techniques to find bugs in Django code and templates.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了Django中测试的动机和概念。我们还发现了编写测试用例时应遵循的各种最佳实践。在调试部分，我们熟悉了在Django代码和模板中查找错误的各种调试工具和技术。
- en: In the next chapter, we will get one step closer to production code by understanding
    the various security issues and how to reduce threats from various kinds of malicious
    attacks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过了解各种安全问题以及如何减少各种恶意攻击威胁，使代码更接近生产代码。
