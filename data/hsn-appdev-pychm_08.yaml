- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building a Dynamic Web Application with Flask
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask 构建动态网络应用
- en: I am fortunate enough to have been around the field of web development since
    its inception. I was a software engineer before there was a World Wide Web, at
    least one used by the general public. I remember the first time someone asked
    me to build a web application. I had to ask what it was. The guy told me, and
    I remember thinking “Well that’s dumb! Why wouldn’t people just use CompuServe
    or **America Online** (**AOL**) for that?” I thought the internet was going to
    be, at best, a fad. It was complicated, loaded with jargon, the UI was terrible
    compared with online services of the day, and it all just seemed kind of janky.
    I guess I was wrong.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我很幸运，自从网络开发的诞生以来，我就一直在这个领域。在万维网出现之前，至少是公众使用的万维网，我就是一名软件工程师。我记得第一次有人让我构建一个网络应用。我不得不问这是什么。那个人告诉我，我记得当时在想，“嗯，这很愚蠢！为什么人们不用
    CompuServe 或 **美国在线**（**AOL**）来做这件事呢？”我认为互联网最多只会是一个时尚。它很复杂，充满了术语，与当时的在线服务相比，用户界面很糟糕，而且一切看起来都很粗糙。我想我错了。
- en: Once I figured that out, I learned HTML and JavaScript. CSS wasn’t even a thing
    yet. It wasn’t long before I hit a wall with HTML’s capabilities. As you well
    know, HTML isn’t a programming language. It is a content markup language that
    controls the presentation of static content. The earliest version of JavaScript
    wasn’t very useful. You could validate forms. That’s about it. Dynamic content
    generation with JavaScript wasn’t a feature until HTML 3 came out.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我明白了这一点，我就学习了 HTML 和 JavaScript。CSS 还没有出现。不久我就遇到了 HTML 功能的瓶颈。正如你所知，HTML 不是一个编程语言。它是一种内容标记语言，用于控制静态内容的呈现。JavaScript
    的最早版本并不太有用。你可以验证表单。就这些了。在 HTML 3 出现之前，使用 JavaScript 生成动态内容并不是一个功能。
- en: Like I said, I hit a wall. I needed to take user interaction data from the browser
    and use it to interact with a database, generate files, and more. With HTML and
    JavaScript, this simply wasn’t possible. I needed a backend language. Initially,
    that was the C language. Even that was limited. You had to write modules in C
    that could interoperate with the Apache web server using an interface called the
    **common gateway** **interface** (**CGI**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的一样，我遇到了瓶颈。我需要从浏览器中获取用户交互数据，并使用它来与数据库交互、生成文件等等。使用 HTML 和 JavaScript，这根本不可能。我需要一个后端语言。最初，那就是
    C 语言。即使是那也有限制。你必须用 C 语言编写模块，这些模块可以通过一个名为 **公共网关接口**（**CGI**）的接口与 Apache 网络服务器交互。
- en: So that was it for the first few years. Writing dynamic web applications was
    hard, and nothing like the capabilities of today. New languages and paradigms
    emerged to make the practice of web development more accessible. My first good
    experience was with a product called `.cfml` extension and process those files
    differently than normal HTML files. I was able to access an Oracle database very
    easily and, coupled with a lot of long nights and the creativity of my youth,
    I created some graphics pipeline software that garnered my employer a software
    patent.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的几年里，就是这样了。编写动态网络应用很困难，远远达不到今天的能力。新的语言和范式出现，使得网络开发的实践更加容易。我第一次良好的体验是与一个名为
    `.cfml` 扩展的产品有关，它以不同于普通 HTML 文件的方式处理这些文件。我能够非常容易地访问 Oracle 数据库，并且，结合许多漫长的夜晚和我的青春期的创造力，我创建了一些图形管道软件，这为我的雇主赢得了软件专利。
- en: 'CFML was part of a growing trend. The same technology was employed by lots
    of other nascent companies and stacks, including the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: CFML 是一个增长趋势的一部分。许多其他新兴公司和堆栈也采用了同样的技术，包括以下这些：
- en: Microsoft created **Active Server Pages** (**ASP Classic**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft 创建了 **活动服务器页面**（**ASP Classic**）
- en: Sun Microsystems introduced **Java Server** **Pages** (**JSP**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sun Microsystems 推出了 **Java 服务器页面**（**JSP**）
- en: '**Hypertext** **Preprocessor** (**PHP**)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本预处理器**（**PHP**）'
- en: The **National Center for Supercomputing Applications** (**NCSA)** created **Server
    -side Includes** (**SSIs**), which were not as feature-rich as the others in this
    list, but nevertheless existed as a way to generate dynamic content
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国家超级计算应用中心**（**NCSA**）创建了 **服务器端包含**（**SSIs**），虽然它的功能不如列表中的其他产品丰富，但仍然作为一种生成动态内容的方式存在。'
- en: 'In this chapter, we’re going to take a quantum leap forward and look at a more
    modern framework for creating dynamic content, which is generated on the server
    side rather than the client side within the browser. Specifically, we’ll be looking
    at a framework called **Flask**, a popular, unopinionated solution for creating
    web applications in Python. By the end of this chapter, you will understand the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将迈出巨大的步伐，探讨一个更现代的用于创建动态内容的框架，这个框架是在服务器端而不是在浏览器客户端内部生成的。具体来说，我们将探讨一个名为**Flask**的框架，这是一个流行的、无偏见的Python网络应用程序创建解决方案。到本章结束时，你将理解以下内容：
- en: The basics of web development such as **client-server architecture**, and the
    stateless **request-response model** employed by the web
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络开发的基础，例如**客户端-服务器架构**，以及网络使用的无状态**请求-响应模型**。
- en: What Flask is, and how it compares to other Python frameworks for web development
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask是什么，以及它与其他Python网络开发框架相比如何
- en: How to create a Flask application in PyCharm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在PyCharm中创建Flask应用程序。
- en: How to work with **Jinja2** templates in PyCharm, which are used to serve dynamic
    content mixed with regular HTML markup, CSS styling, and JavaScript interactivity
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在PyCharm中使用**Jinja2**模板，这些模板用于提供动态内容，与常规HTML标记、CSS样式和JavaScript交互性混合。
- en: How to create a RESTful API endpoint that returns data in JSON format rather
    than content
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个返回JSON格式数据的RESTful API端点，而不是内容。
- en: How to use PyCharm’s HTTP Requests feature to test your API
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PyCharm的HTTP请求功能测试你的API
- en: Bear in mind, this chapter isn’t meant to be a tutorial on Flask. It is a tutorial
    on how to use PyCharm to work with Flask. If you’re looking for a full tutorial
    on Flask, visit my website at [https://www.maddevskilz.com](https://www.maddevskilz.com).
    There are several expanded tutorials on Flask that go into a deep dive and entail
    building entire projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本章的目的不是提供一个Flask教程。它是一个关于如何使用PyCharm与Flask一起工作的教程。如果你正在寻找一个完整的Flask教程，请访问我的网站[https://www.maddevskilz.com](https://www.maddevskilz.com)。那里有几个扩展的Flask教程，深入探讨了构建整个项目。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章的学习，以及本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will use `pip` and `virtualenv`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了`pip`和`virtualenv`。当你安装Python在Windows上时，这些会自动安装，macOS系统上通常也包含它们。如果你使用Linux，你需要单独安装包管理器，如`pip`，以及虚拟环境工具，如`virtualenv`。我们的示例将使用`pip`和`virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*, in case
    you are jumping into the middle of the book.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的PyCharm。安装已在[*第二章*](B19644_02.xhtml#_idTextAnchor028)*，安装和配置*中介绍，以防你在本书的中间部分开始阅读。
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书提供的示例源代码来自GitHub。我们已经在[*第二章*](B19644_02.xhtml#_idTextAnchor028)*，安装和配置*中介绍了如何克隆代码。你可以在这个章节找到相关的代码：[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-08)。
- en: Web basics – client-server architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络基础 - 客户端-服务器架构
- en: When I began my career in IT back in 1991, I worked for a company called **Electronic
    Data Systems** (**EDS**). It was a different era. Back then, any serious computing
    was performed by monolithic systems called **mainframes**. Imagine a mainframe
    computer as an incredibly powerful and large-scale computer that existed before
    the era of personal computers and smartphones. It was like a supercomputer, capable
    of handling massive amounts of data and performing complex computations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在1991年开始我的IT职业生涯时，我在一家名为**电子数据系统**（**EDS**）的公司工作。那是一个不同的时代。当时，任何严肃的计算机操作都是由被称为**大型机**的单一系统完成的。想象一下，大型机计算机就像在个人电脑和智能手机时代之前存在的极其强大和大规模的计算机。它就像一台超级计算机，能够处理大量数据并执行复杂的计算。
- en: Mainframe computers were typically housed in specially designed rooms or data
    centers because they required a lot of space and specialized power and cooling
    systems to function properly. The typical mainframe was usually about the size
    of a minivan while its separate **Power Distribution Unit** (**PDU**) was roughly
    twice the size of a typical clothes dryer. The **Direct Access Storage Device**
    (**DASD**) was in yet another similarly large rectangular metal box. Connecting
    these various components were heavy cables about the diameter of a spent paper
    towel roll. Models from IBM’s Z14 series weighed between 2,500 and 4,000 kg (5,500
    and 8,800 lbs).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大型机通常被安置在特别设计的房间或数据中心，因为它们需要大量的空间和专业的电源和冷却系统才能正常工作。典型的大型机通常大约有微型货车的尺寸，而其独立的**电源分配单元**（**PDU**）的尺寸大约是典型洗衣机的两倍。**直接访问存储设备**（**DASD**）位于另一个同样大小的长方形金属箱中。连接这些各种组件的是直径大约与用过的纸巾卷相似的粗电缆。IBM
    Z14系列型号的重量在2,500至4,000公斤（5,500至8,800磅）之间。
- en: In the past, mainframe computers were commonly used by large organizations,
    such as banks, government agencies, universities, and large corporations. They
    were responsible for processing and managing huge volumes of data, running critical
    business applications, and supporting the operations of entire enterprises. In
    my case, I worked with the IBM mainframe systems responsible for running the automotive
    assembly line operations for **General Motors** (**GM**), among others.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，大型机通常被大型组织，如银行、政府机构、大学和大型企业所使用。它们负责处理和管理大量数据，运行关键业务应用程序，并支持整个企业的运营。在我的情况下，我与负责运行**通用汽车**（**GM**）等公司的汽车装配线操作的IBM大型机系统一起工作。
- en: Mainframes were known for their reliability, security, and high-performance
    capabilities. They could handle multiple tasks simultaneously and provide fast
    response times, even when dealing with extensive workloads. People would access
    mainframes through terminals or other connected devices to perform tasks or retrieve
    information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大型机以其可靠性、安全性和高性能能力而闻名。它们能够同时处理多个任务并提供快速响应时间，即使在处理大量工作时也是如此。人们通过终端或其他连接设备访问大型机以执行任务或检索信息。
- en: With the advancement of technology and the emergence of personal computers,
    the role of mainframes has evolved. While they still play a vital role in certain
    industries, many of the computing tasks that were once exclusive to mainframes
    are now handled by distributed systems, relatively cheap rack-mounted Intel and
    IBM Power-based systems, cloud computing, and smaller devices such as laptops
    and smartphones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步和个人电脑的出现，大型机的角色已经发生了演变。虽然它们在特定行业中仍然发挥着至关重要的作用，但许多曾经仅限于大型机的计算任务现在由分布式系统、相对便宜的机架式Intel和IBM
    Power系统、云计算以及笔记本电脑和智能手机等小型设备来处理。
- en: Mainframes were, and I suppose still are, very expensive to own and operate.
    Not only was the hardware expensive but it also generally took a team of expert
    computer operators and maintainers to keep the system running. The cost was out
    of reach for all but the largest corporations and universities. Smaller companies
    and even smaller nations had to buy time on other people’s mainframes to gain
    access to computing at scale. This, in fact, was the service rendered by EDS.
    We had acres of space in several very large data centers located throughout the
    world, and we sold time and provided services to nearly all of the Fortune 500
    companies. The cost eventually, along with the implications of Moore’s Law, led
    to the downfall of the mainframe.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 主机计算机，我想现在仍然是，拥有和运营成本非常高。不仅硬件昂贵，而且通常需要一支由专家计算机操作员和维护人员组成的团队来保持系统运行。这种成本对于除了最大型的公司和大学之外的所有人来说都是难以承受的。较小的公司和甚至更小的国家不得不在其他人的主机上购买时间，以获得大规模计算的机会。实际上，这就是EDS提供的服务。我们在全球几个大型数据中心拥有大片空间，并向几乎所有的《财富》500强公司出售时间和提供服务。最终，成本以及摩尔定律的影响导致了主机的衰落。
- en: '**Moore’s Law** is an observation and projection made by Gordon Moore, the
    co-founder of Intel Corporation, in 1965\. It states that the number of transistors
    on a microchip doubles approximately every two years, leading to a significant
    increase in computing power and performance while reducing the cost of electronic
    devices.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**摩尔定律**是由英特尔公司联合创始人戈登·摩尔在1965年提出的一个观察和预测。它指出，微芯片上的晶体管数量大约每两年翻一番，导致计算能力和性能显著提高，同时降低了电子设备成本。'
- en: Moore originally noted that this exponential growth in transistor density had
    been occurring since the invention of the integrated circuit, and he predicted
    that it would continue for the foreseeable future. Over the years, Moore’s Law
    has held remarkably true, with advancements in semiconductor manufacturing technology
    allowing for increasingly smaller transistors and more complex integrated circuits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔最初指出，这种晶体管密度的指数增长自集成电路发明以来一直在发生，并且他预测这种增长在未来可预见的时期内将继续。多年来，摩尔定律表现得非常准确，半导体制造技术的进步使得晶体管越来越小，集成电路越来越复杂。
- en: The doubling of transistor density every two years has had profound implications
    for the field of computing. It has enabled the development of more powerful and
    efficient computers, with increased processing speed, memory capacity, and storage
    capabilities. As more transistors can be packed onto a chip, the overall performance
    of electronic devices has improved while their physical size has decreased.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每两年晶体管密度的翻倍对计算领域产生了深远的影响。它使得更强大、更高效的计算机的发展成为可能，提高了处理速度、内存容量和存储能力。随着可以在芯片上装入更多晶体管，电子设备的整体性能得到提升，而其物理尺寸却减小了。
- en: 'As computers became smaller, and chip architectures such as **Reduced Instruction
    Set Computing** (**RISC**) and eventually Intel’s x86 architecture appeared, a
    new model of computing emerged: **client-server**.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着计算机变得越来越小，以及**精简指令集计算**（**RISC**）和最终英特尔x86架构的出现，一种新的计算模式出现了：**客户-服务器**。
- en: Mainframes were centralized and accessed using “dumb” terminals. These terminals
    had no compute capability, no storage, and only enough memory to maintain a communications
    buffer to send whatever you typed on the keyboard to the mainframe for processing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主机计算机是集中的，并通过“哑”终端进行访问。这些终端没有计算能力，没有存储，只有足够的内存来维护一个通信缓冲区，以便将您在键盘上输入的内容发送到主机进行处理。
- en: Client-server architecture shifted some of the compute, storage, and memory
    to a local client, which was usually a PC. The client was connected via a **local
    area network** (**LAN**) to a server, which was generally more powerful than a
    PC and capable of running enterprise-grade computing loads. You typically had
    client software, which was composed of a desktop user interface running on the
    PC’s operating system. The client software interfaced with centralized software
    running on the server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 客户-服务器架构将一些计算、存储和内存转移到本地客户端，这通常是一个PC。客户端通过**局域网**（**LAN**）连接到服务器，服务器通常比PC更强大，能够运行企业级计算负载。通常，您会有客户端软件，它由在PC操作系统上运行的桌面用户界面组成。客户端软件与服务器上运行的集中式软件进行交互。
- en: 'Besides client and server hardware, one final piece came into existence around
    the same time: a standardized network protocol known as **Transmission Control
    Protocol/Internet Protocol** (**TCP/IP**). I was in college before TCP/IP and
    in order to interact with the University of Oklahoma’s mainframe, I had to keep
    a stack of floppy disks on hand that held an odd, mismatched collection of communication
    protocols. Some systems used a protocol called **Kernel for Efficient, Remote,
    and Multiple Computer Interactions** (**KERMIT**). I also had disks for *XMODEM*,
    *YMODEM*, and *ZMODEM*. Depending on which type of computer I wanted to access,
    I had to employ a different protocol. TCP/IP changed all that with a standard
    set of protocols supported by everything from mainframes and PCs to modern smartphones
    and internet-connected toasters.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端和服务器硬件外，大约在同一时间出现了一个最终组件：一个称为**传输控制协议/互联网协议**（**TCP/IP**）的标准网络协议。在我上大学之前，还没有TCP/IP，为了与俄克拉荷马大学的巨型机交互，我必须随身携带一叠软盘，里面装有奇异的、不匹配的通信协议集合。一些系统使用名为**高效、远程和多个计算机交互内核**（**KERMIT**）的协议。我还有用于*XMODEM*、*YMODEM*和*ZMODEM*的磁盘。根据我想访问哪种类型的计算机，我必须使用不同的协议。TCP/IP通过一套标准协议改变了这一切，这些协议被从主机和PC到现代智能手机和互联网连接的烤面包机等所有设备所支持。
- en: 'If this sounds like the internet to you, you’d be right – but with a few caveats:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来像是互联网，你就对了——但有一些注意事项：
- en: The client server was very slow, and often not even full duplex, meaning data
    could only flow in one direction at a time.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端/服务器非常慢，而且通常甚至不是全双工的，这意味着数据只能一次单向流动。
- en: Most client programs did not have a real GUI and didn’t support mouse interactions.
    They were known as “green screen” interfaces because they were rendered using
    textual menus on monochrome screens that were often green. Later thick-client
    applications had real GUIs usually written in Java, Visual Basic, C++, or Delphi.
    They were called thick because the size of the program was large enough that downloading
    the GUI could take many hours over a typical connection. This sits in stark contrast
    to a typical web application running on the modern internet.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数客户端程序没有真正的GUI，也不支持鼠标交互。它们被称为“绿色屏幕”界面，因为它们使用文本菜单在通常是绿色的单色屏幕上渲染。后来，厚客户端应用程序具有真正的GUI，通常是用Java、Visual
    Basic、C++或Delphi编写的。它们被称为厚客户端，因为程序的大小足够大，以至于通过典型的连接下载GUI可能需要数小时。这与在现代互联网上运行的典型网络应用程序形成鲜明对比。
- en: The client software was always designed around a specialized set of use cases.
    In contrast, web browsers today, which comprise the client, can be used to run
    any kind of software from general word processing applications to specific lines
    of business applications.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端软件始终围绕一组特定的用例进行设计。相比之下，今天的网络浏览器，作为客户端，可以运行任何类型的软件，从通用的文字处理应用程序到特定的业务线应用程序。
- en: The web is the natural evolution in client server architecture. Lightweight
    client software, the web browser, connects to a centralized server where the bulk
    of the real work is handled using universally accepted networking protocols.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是客户端/服务器架构的自然演变。轻量级的客户端软件，即网页浏览器，连接到一个集中式服务器，在那里使用普遍接受的网络协议处理大部分实际工作。
- en: Exploring the request-response mechanism in HTTP – how clients and servers communicate
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索HTTP中的请求-响应机制——客户端和服务器如何通信
- en: 'One of the great accomplishments of the 1980s, besides CFC-laden hairspray,
    was the development of a universal set of networking protocols known as TCP/IP.
    In case you are new to this, the correct way to pronounce this is as letters:
    *tea sea pea eye pea*. The slash is silent, just like it is with ninjas.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪80年代的一项伟大成就，除了含有CFC的喷雾剂外，就是开发了一套通用的网络协议，称为TCP/IP。如果你对此还不太熟悉，正确的发音方式是作为字母：*tea
    sea pea eye pea*。斜杠是沉默的，就像忍者一样。
- en: It took a while for it to be universally adopted, but ultimately it was, and
    the protocols of TCP/IP form the basis of the modern web. While there are many
    useful protocols serving a myriad of functions, I want to focus your attention
    on the **Hypertext Transfer Protocol** (**HTTP**). You can go ahead and include
    the secure counterpart, *HTTPS*, where the *S* stands for *secure*. They effectively
    work the same way, except that HTTPS is encrypted.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它花了很长时间才被普遍采用，但最终它确实被采用了，TCP/IP协议构成了现代网络的基础。尽管有许多有用的协议服务于无数的功能，但我想要将你的注意力集中在**超文本传输协议**（**HTTP**）上。你可以继续包括其安全的对应版本，*HTTPS*，其中*S*代表*安全*。它们有效地以相同的方式工作，只是HTTPS是加密的。
- en: The request-response mechanism entails a chain of events that describes a conversation
    that happens between the web browser or client, and the web server. You can watch
    this conversation unfold in *Figure 8**.1*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应机制涉及一系列事件，描述了在网页浏览器或客户端与Web服务器之间发生的对话。你可以在*图8.1*中观察这个对话的展开。
- en: '![Figure 8.1: The request-response mechanism in HTTP conveys a request from
    a browser to the server, which computes a response and sends it back to the browser](img/B19644_08_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：HTTP中的请求-响应机制将浏览器对服务器的请求传递过去，服务器计算响应并将其发送回浏览器](img/B19644_08_01.jpg)'
- en: 'Figure 8.1: The request-response mechanism in HTTP conveys a request from a
    browser to the server, which computes a response and sends it back to the browser'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：HTTP中的请求-响应机制将浏览器对服务器的请求传递过去，服务器计算响应并将其发送回浏览器
- en: 'The request-response mechanism used by HTTP is the fundamental communication
    pattern between clients, such as web browsers or mobile applications, and servers
    on the World Wide Web. It works like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP使用的请求-响应机制是客户端（如网页浏览器或移动应用程序）与万维网上的服务器之间的基本通信模式。它的工作方式如下：
- en: '`GET`, `POST`, `PUT`, or `DELETE`, which indicates the desired action to be
    performed on the server’s resources, along with additional headers and, in some
    cases, a request body that carries data.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT`或`DELETE`，这表示要在服务器资源上执行的操作，以及额外的头信息，在某些情况下，还包括携带数据的请求体。'
- en: '**The request is received by the server**: Upon receiving the request, the
    server processes the information provided in the request. This may involve accessing
    databases, performing calculations, or executing other server-side operations
    based on the nature of the request. The simplest request is one for an HTML document,
    or other file that is simply returned.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器接收请求**：在收到请求后，服务器处理请求中提供的信息。这可能涉及访问数据库、执行计算或根据请求的性质执行其他服务器端操作。最简单的请求是请求一个HTML文档或其他简单返回的文件。'
- en: '**The server generates a response and sends it back to the user**: After processing
    the request, the server generates an HTTP response. The response contains an appropriate
    status code indicating the outcome of the request. For example, a request that
    is successful bears a status code in the response header of 200\. If you request
    a resource on the server that isn’t there, you’ll get a 404 code signaling the
    resource was not found. The response header also includes additional fields providing
    more information and a response body that contains the requested data or any relevant
    information.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器生成响应并发送给用户**：在处理请求后，服务器生成一个HTTP响应。响应包含一个适当的状态码，指示请求的结果。例如，成功的请求在响应头中带有状态码200。如果你请求的服务器上的资源不存在，你会得到一个404代码，表示资源未找到。响应头还包括提供更多信息的一些附加字段，以及包含请求的数据或任何相关信息的响应体。'
- en: '**The browser receives the response data**: The client receives the HTTP response
    from the server and processes the information contained within it. This could
    involve rendering HTML content, processing data, or performing other actions based
    on the response.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**浏览器接收响应数据**：客户端从服务器接收HTTP响应并处理其中包含的信息。这可能涉及渲染HTML内容、处理数据或根据响应执行其他操作。'
- en: '**Request-response cycle is complete**: With the response received, the request-response
    cycle is complete. The client may choose to send additional requests to the server
    to perform further interactions, or the process may end.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求-响应周期完成**：收到响应后，请求-响应周期即完成。客户端可以选择向服务器发送额外的请求以执行进一步交互，或者过程可能结束。'
- en: This request-response mechanism forms the basis of how information is exchanged
    between clients and servers over HTTP. It allows clients to request resources
    or perform actions on the server, and the server responds with the corresponding
    results or necessary information. This cycle enables the dynamic and interactive
    nature of web applications and services.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种请求-响应机制是客户端和服务器之间通过HTTP交换信息的基础。它允许客户端请求资源或对服务器执行操作，服务器则以相应的结果或必要的信息进行响应。这个周期使得Web应用程序和服务具有动态和交互的特性。
- en: One thing to remember is that HTTP is stateless. This means that every request-response
    cycle is discrete. There is no native way in HTTP to share or retain data between
    requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是HTTP是无状态的。这意味着每个请求-响应周期都是独立的。在HTTP中没有原生的方法在请求之间共享或保留数据。
- en: What is Flask?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Flask？
- en: 'Flask is an unopinionated framework for working with the request-response mechanism
    found in HTTP. It does one thing and only one thing: it helps you receive requests
    into a simple Python object structure, then craft responses using Python code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个无观点的框架，用于处理HTTP中发现的请求响应机制。它只做一件事，而且只做一件事：它帮助你将请求接收到一个简单的Python对象结构中，然后使用Python代码构建响应。
- en: Let’s go back to the word *unopinionated*. By this, I mean Flask by design only
    handles the request-response cycle. I realize I said that already, but it bears
    repeating. When you compare Flask to its virtual antithesis, which is Django,
    the difference is stark.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到“无观点”这个词。我的意思是，Flask设计上只处理请求响应周期。我意识到我已经说过这一点了，但值得重复。当你将Flask与其虚拟对立面Django进行比较时，差异是明显的。
- en: Django is extremely opinionated about how you create your web application. Django
    dictates the file structure, the application patterns, and the database to be
    used. It features its own object relational mapper, its own request response mechanism,
    and its own set of coding conventions. In short, Django will dictate your stack
    and most of the architectural details for your project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Django对如何创建你的Web应用有着非常强烈的观点。Django决定了文件结构、应用程序模式和要使用的数据库。它拥有自己的对象关系映射器、自己的请求响应机制以及自己的一套编码规范。简而言之，Django将决定你的技术栈以及你项目的多数架构细节。
- en: Flask proffers some suggestions, but they are not set in stone, and you don’t
    have to use them if you don’t want to. A few years ago, I re-wrote my company’s
    flagship software product, Visual Storage Intelligence (see [https://www.visualstorageintelligence.com](https://www.visualstorageintelligence.com))
    as a Flask application strictly because it is unopinionated. I consider myself
    an expert at selecting the best stack given my knowledge, experience, and understanding
    of my company’s business requirements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了一些建议，但这些并不是固定不变的，如果你不想使用，也可以不用。几年前，我重新编写了我公司旗舰软件产品Visual Storage Intelligence（见[https://www.visualstorageintelligence.com](https://www.visualstorageintelligence.com)）作为一个Flask应用，严格是因为它没有观点。我认为自己在根据我的知识、经验和对我公司业务需求的理解来选择最佳技术栈方面是一个专家。
- en: For example, I pretty much never use an ORM. I have deep expertise in SQL and
    relational database systems. I can write and tune queries, stored procedures,
    and views to build a fast, responsive web application in a variety of commercial
    and open source databases. An ORM is designed to take all that out of your hands
    and give you a layer of abstraction above the database so a developer need only
    deal with objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我几乎从不使用ORM。我对SQL和关系型数据库系统有深入的了解。我能够编写和调整查询、存储过程和视图，以在各种商业和开源数据库中构建快速、响应灵敏的Web应用。ORM的设计目的是从你的手中拿走所有这些，并在数据库之上提供一个抽象层，这样开发者只需处理对象即可。
- en: An ORM is effectively a black box. Most developers don’t know how it works or
    how to improve the performance of the queries the ORM generates. To me, it’s just
    overhead. Personally, I would rather build and tweak those guts myself. Incidentally,
    if any of these database-related terms are mystifying to you, stay tuned. I’ll
    talk a lot more about databases in *Chapter 11**, Understanding Database Management*
    *with PyCharm*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ORM实际上是一个黑盒。大多数开发者不知道它是如何工作的，也不知道如何提高ORM生成的查询性能。对我来说，它只是额外的开销。我个人更愿意自己构建和调整这些内部结构。顺便说一句，如果这些数据库相关的术语让你感到困惑，请保持关注。我将在第11章*理解数据库管理*中详细讨论数据库。
- en: The point is, Flask doesn’t care how I interact with my database. It doesn’t
    care about how I structure my application, and it doesn’t care what my stack looks
    like. It only does two things, and one of them is optional.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，Flask不关心我如何与数据库交互。它不关心我如何构建我的应用程序，也不关心我的技术栈看起来如何。它只做两件事，其中之一是可选的。
- en: Request-response handling and routing with Werkzeug
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Werkzeug处理请求响应和路由
- en: The first thing Flask does for us is to make dealing with the request-response
    mechanism in HTTP very easy. Strictly speaking, an inbound request is binary in
    nature. As developers, we would really rather deal with text-like object abstractions
    of binary structures. Dealing with binary anything directly is soooo 1939\. Thankfully,
    there is a Python library that handles this called Werkzeug.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Flask为我们做的第一件事是使处理HTTP中的请求响应机制变得非常简单。严格来说，一个传入的请求在本质上来说是二进制的。作为开发者，我们更愿意处理类似于文本的对象抽象的二进制结构。直接处理任何二进制内容都是非常过时的。幸运的是，有一个名为Werkzeug的Python库可以处理这个问题。
- en: The library’s name, “Werkzeug," is derived from the German language, where it
    translates to “tool” or “instrument.” The Flask framework, including its underlying
    utility library, Werkzeug, was originally developed by Armin Ronacher, a German
    software developer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆的名字“Werkzeug”源自德语，其意为“工具”或“仪器”。Flask框架及其底层实用库Werkzeug最初由德国软件开发者Armin Ronacher开发。
- en: The name “Werkzeug” was chosen to reflect the nature of the library as a versatile
    and powerful toolset for building web applications. Just as a craftsperson relies
    on a set of tools to create and shape their work, developers can leverage Werkzeug
    to handle various aspects of web development, such as routing, request handling,
    and HTTP utilities. Flask builds on top of Werkzeug; it adds additional abstractions
    and features to provide a lightweight and user-friendly web framework.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“Werkzeug”这个名字是为了反映该库作为构建Web应用程序的多功能和强大的工具集的本质。正如工匠依赖一套工具来创造和塑造他们的作品一样，开发者可以利用Werkzeug来处理Web开发的各个方面，如路由、请求处理和HTTP实用工具。Flask建立在Werkzeug之上；它添加了额外的抽象和功能，以提供一个轻量级且用户友好的Web框架。
- en: 'Flask uses Werkzeug’s functionalities to handle the low-level details of HTTP
    requests and responses, allowing developers to focus on building web applications
    quickly and efficiently. The effect is the ability to create web applications
    as simple as you would create any other Python application: you create functions
    to handle an incoming HTTP request, which returns a properly formatted HTTP response.
    If you can write a function in Python, you can create a web application.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Flask使用Werkzeug的功能来处理HTTP请求和响应的低级细节，使开发者能够快速高效地构建Web应用程序。结果是能够创建像创建任何其他Python应用程序一样简单的Web应用程序：您创建函数来处理传入的HTTP请求，它返回一个格式正确的HTTP响应。如果您能在Python中编写一个函数，您就可以创建一个Web应用程序。
- en: 'The implementation in Flask looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Flask中的实现如下所示：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this is a simple Python function that takes no arguments and
    returns a string. The only thing odd about it is the decoration above the function
    definition. We’ll learn a lot more about this later. For now, understand that
    this decoration matches a route on your application’s URL. You are used to typing
    in a URL with the usual syntax of [https://www.maddevskilz.com/](https://www.maddevskilz.com/),
    which would take you to the root document of the website at that address. In the
    preceding code block, our function would answer any web request made to [https://www.maddevskilz.com/hello](https://www.maddevskilz.com/hello)
    with the string `''Hello, World!''`. Naturally, you’ll learn to do more than deal
    with a simple request like this, but my point remains: if you can create a function
    in Python, you can write a web application!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的Python函数，它不接受任何参数并返回一个字符串。这个函数唯一奇怪的地方是函数定义上方的装饰。我们稍后会学到更多关于这个装饰的内容。现在，请理解这个装饰与您应用程序URL上的一个路由相匹配。您习惯于输入一个带有常规语法的URL，例如[https://www.maddevskilz.com/](https://www.maddevskilz.com/)，这将带您访问该地址的网站根文档。在前面的代码块中，我们的函数将响应任何对[https://www.maddevskilz.com/hello](https://www.maddevskilz.com/hello)的Web请求，并返回字符串`'Hello,
    World!'`。自然地，您将学会处理比这更复杂的请求，但我的观点是：如果您能在Python中创建一个函数，您就可以编写一个Web应用程序！
- en: Using this feature of Flask is non-negotiable. If you don’t want to use this
    abstraction of Werkzeug, then you don’t want to use Flask. Flask is, again, unopinionated,
    meaning this is really the only thing it “cares” about. We’ll see a contrast in
    [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298)*, Building a Web Application
    in Django*. Django is highly opinionated. It wants you to use its pre-defined
    stack. Flask doesn’t care. It does, however, make one strong suggestion that you
    can safely ignore if you’d like.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask的这个特性是不可避免的。如果您不想使用Werkzeug的这个抽象，那么您就不想使用Flask。Flask再次是中立的，这意味着这真的是它“关心”的唯一事情。我们将在[*第12章*](B19644_12.xhtml#_idTextAnchor298)*，使用Django构建Web应用程序*中看到对比。Django非常具有意见。它希望您使用其预定义的堆栈。Flask不在乎。然而，它确实提出了一个强烈的建议，如果您愿意，可以安全地忽略。
- en: Templating with Jinja2
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jinja2进行模板化
- en: 'Flask does come with a default suggestion regarding a templating library called
    Jinja2\. When you install Flask, you get Jinja2 as a dependency. Templating systems
    are designed to allow you to inject content into a markup document. Here is an
    example of a Jinja2 script that generates some items in an unordered list on an
    HTML page:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Flask确实提供了一个关于默认模板库Jinja2的建议。当您安装Flask时，您会得到Jinja2作为依赖项。模板化系统旨在允许您将内容注入到一个标记文档中。以下是一个Jinja2脚本的示例，它在HTML页面上生成一个无序列表中的某些项：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The template is just a string that contains some special characters indicating
    where Python-like code is to be executed. This is how all templating languages
    work, from classic ASP to JSP to PHP. The Flask process gets the request from
    the web server. It parses the request, and here we’re rendering the response with
    our template. The template itself is a markup fragment. A variable called `template_str`
    is created and set to an empty string. Remember, this isn’t Python code, it’s
    Python-like code because it exists within the context of markup. The single quotes
    are escaped by single quotes, meaning [PRE2] is interpreted as a single quote
    in the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模板只是一个包含一些特殊字符的字符串，这些字符指示Python-like代码的执行位置。所有模板语言都是这样工作的，从经典的ASP到JSP再到PHP。Flask进程从Web服务器获取请求。它解析请求，在这里我们使用模板来渲染响应。模板本身是一个标记片段。创建了一个名为`template_str`的变量，并将其设置为空字符串。记住，这不是Python代码，它是Python-like代码，因为它存在于标记的上下文中。单引号被单引号转义，这意味着[PRE2]在代码中被解释为单引号。
- en: As you can see, we have a `for` loop iterating over some list called `items`,
    which will be passed into the template as data. The code in the template is delineated
    with `{%` and `%}`. Each `<li>` has an expression bound in double curly braces.
    In this case, the expression is just the iterating variable item defined with
    the loop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个`for`循环遍历一个名为`items`的列表，这个列表将被作为数据传递到模板中。模板中的代码用`{%`和`%}`来界定。每个`<li>`都有一个用双大括号绑定的表达式。在这种情况下，表达式只是循环中定义的迭代变量item。
- en: 'In my example, the template string is defined in the code, but in real life,
    the template is usually in a file since that is much easier to maintain. Next,
    we create the `template` object and pass the `template` string into the template
    constructor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，模板字符串是在代码中定义的，但在现实生活中，模板通常在文件中，因为这样更容易维护。接下来，我们创建`template`对象，并将`template`字符串传递给模板构造函数：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we’re back to being in plain Python code. We’ll make a list called `items`
    and populate it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到了普通的Python代码。我们将创建一个名为`items`的列表并填充它：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we render `template`, which produces a new string set to a variable called
    `output`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们渲染`template`，它生成一个新的字符串，并将其赋值给一个名为`output`的变量：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here we are printing the output, but in the context of a Flask application,
    the output would be returned as the response:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在打印输出，但在Flask应用程序的上下文中，输出将作为响应返回：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Jijna2 has a robust set of language features common to most good templating
    systems. Remember though that Flask bills itself as *unopinionated*. You don’t
    have to use Jinja2\. There are other templating libraries out there, or you can
    forgo the use of a template system entirely. In my company’s product, *Visual
    Storage Intelligence*, I used Jinja2 for version 4 of the product. At the time,
    I didn’t know Python very well and was used to Microsoft’s MVC template for C#
    web applications. I limited my learning curve to meet my deadline. Jinja2 is not
    difficult to learn at all. It is mostly HTML with some extra syntax. In version
    5 of the product, I went back and replaced the UI layer of the application with
    a React frontend. This didn’t require any changes to the Flask application beyond
    deleting the templates that I no longer used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Jijna2拥有一套强大的语言特性，这些特性在大多数优秀的模板系统中都很常见。但请记住，Flask自称为*无偏见*。你不必使用Jinja2。还有其他模板库可供选择，或者你可以完全放弃使用模板系统。在我公司的产品*Visual
    Storage Intelligence*中，我使用了Jinja2来构建产品的第4版本。当时，我对Python不太熟悉，并且习惯了Microsoft的C#
    Web应用的MVC模板。我将我的学习曲线限制在满足截止日期的范围内。Jinja2并不难学。它主要是HTML，附带一些额外的语法。在产品的第5版本中，我回过头来用React前端替换了应用程序的UI层。这并不需要对Flask应用程序进行任何更改，除了删除我不再使用的模板。
- en: Reminder – this isn’t a book on Flask
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下——这不是一本关于Flask的书
- en: I’ve spent some time going over the high-level basics of Flask in case you are
    encountering this as a web development novice. While it may appear that I’m about
    to teach you Flask, I only intend to cover the features of Flask development as
    they relate to PyCharm. While we will be building a project, I won’t be doing
    any really deep dives on how and why the code is what it is.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一些时间回顾了Flask的高级基础知识，以防你是作为一个Web开发新手遇到这个问题。虽然看起来我好像要教你Flask，但我只想介绍与PyCharm相关的Flask开发功能。虽然我们将要构建一个项目，但我不会深入探讨代码是如何和为什么是这样的。
- en: As such, if you are indeed a novice and you are intrigued by the intentionally
    tacit coverage of Flask I’m providing here and you’d like a proper tutorial, I
    will include more in-depth resources in the *Further reading* section at the end
    of this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你确实是一个新手，并且你对我在这里提供的 Flask 的有意隐晦覆盖感到好奇，并且想要一个合适的教程，我将在本章末尾的 *进一步阅读* 部分包含更多深入的资源。
- en: A note on naming files and folders
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于文件和文件夹命名的注意事项
- en: Before we get further into creating the next project, I want to give you some
    advice based on a principle I always point out to my students. `%20` to be considered
    valid. Web servers automatically handle this encoding, but manually encoding spaces
    can lead to readability issues in URLs, and it can cause issues when trying to
    run your projects on your local computer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步创建下一个项目之前，我想根据我总是向我的学生指出的一个原则给你一些建议。`%20` 应该被认为是有效的。Web 服务器自动处理这种编码，但手动编码空格可能会导致
    URL 中的可读性问题，并且在尝试在你的本地计算机上运行你的项目时可能会引起问题。
- en: In a web project, most of your project paths will become URLs at some point.
    This can happen even when your project isn’t even intended for the web. To add
    to the problem, different operating systems treat characters differently in their
    filesystems. Windows filenames are case insensitive. If you name your file or
    folder `MyProject`, and then try to create a folder called `myproject`, you’ll
    get a collision since the folder already exists, despite the difference in upper
    and lowercase letters in the name. On Linux and macOS, file and folder names are
    case sensitive. It is totally fine to have `MyProject` and `myproject` together
    in the same folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Web 项目中，你的大多数项目路径最终都会成为 URL。即使你的项目根本不是为 Web 设计的，这也可能发生。更糟糕的是，不同的操作系统在它们的文件系统中以不同的方式处理字符。Windows
    的文件名不区分大小写。如果你将文件或文件夹命名为 `MyProject`，然后尝试创建一个名为 `myproject` 的文件夹，你会因为文件夹已经存在而遇到冲突，尽管名称中的大小写字母不同。在
    Linux 和 macOS 上，文件和文件夹名称是区分大小写的。在同一个文件夹中同时拥有 `MyProject` 和 `myproject` 是完全可以的。
- en: My suggestion in all of this is to pick a standard you like and use it. For
    Python projects, the most common convention is to name your files with `MyProject`.
    Instead, you would call it `my_project`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，我的建议是选择一个你喜欢的标准并使用它。对于 Python 项目来说，最常用的约定是将你的文件命名为 `MyProject`。相反，你会称其为
    `my_project`。
- en: With that said, most of my projects in this book are named with the PyCharm
    defaults, which are often rendered in camel or Pascal case. In these case standards,
    typically employed by Java and C# developers, spaces are omitted and the boundary
    between words is emphasized using capital letters. `myProject` and `MyProject`
    would be an example of camel and Pascal case respectively. I suspect the use of
    camel case in the project name defaults probably comes from the fact that PyCharm’s
    ancestry is a Java IDE. Other strategies exist for eliminating spaces in code
    files. Kebab case is common in JavaScript development and uses dashes instead
    of underscores. `MyProject` becomes `my-project`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这本书中的大多数项目都是以 PyCharm 的默认命名方式命名的，这些通常以驼峰式或帕斯卡式表示。在这些通常由 Java 和 C# 开发者采用的案例标准中，省略了空格，并且使用大写字母强调单词之间的边界。`myProject`
    和 `MyProject` 分别是驼峰式和帕斯卡式的例子。我怀疑项目名称默认使用驼峰式可能是因为 PyCharm 的根源是一个 Java IDE。还有其他策略可以消除代码文件中的空格。在
    JavaScript 开发中常见的 Kebab 式使用破折号而不是下划线。`MyProject` 变为 `my-project`。
- en: I heartily recommend breaking any habit of using spaces in any of your folder
    or file names in your coding practice. This includes any upstream folders such
    as your operating system’s home folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在编码实践中避免在任何文件夹或文件名中使用空格。这包括任何上游文件夹，例如你的操作系统的家目录。
- en: Creating a Flask application in PyCharm Professional
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PyCharm Professional 中创建 Flask 应用程序
- en: The tooling for Flask is a feature found only in the Professional edition of
    PyCharm. Naturally, you can make a Flask app in the free version of PyCharm, but
    you’ll be on your own in terms of creating the files and setting up run profiles,
    special debugging, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 的工具仅存在于 PyCharm 专业版的特性中。当然，你可以在 PyCharm 的免费版本中创建 Flask 应用，但在创建文件、设置运行配置、特殊调试等方面，你将完全独立。
- en: To create a Flask App in PyCharm, just select **File** | **New Project** and
    select the **Flask** template, as shown in *Figure 8**.2*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PyCharm 中创建 Flask 应用，只需选择 **文件** | **新建项目**，然后选择 **Flask** 模板，如图 8* 所示。2*。
- en: '![Figure 8.2: To create a new Flask project in PyCharm Professional, choose
    the template from the New Project dialog](img/B19644_08_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：在PyCharm Professional中创建新的Flask项目，从新建项目对话框中选择模板](img/B19644_08_02.jpg)'
- en: 'Figure 8.2: To create a new Flask project in PyCharm Professional, choose the
    template from the New Project dialog'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：在PyCharm Professional中创建新的Flask项目，从新建项目对话框中选择模板
- en: 'I’ve numbered the most important parts in *Figure 8**.2*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*图8.2*中标记了最重要的部分：
- en: In the **New Project** dialog of PyCharm Professional, you’ll find a template
    for **Flask** projects.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm Professional的**新建项目**对话框中，你可以找到一个**Flask**项目的模板。
- en: This part is no different than any project we’ve done so far. Fill in the location
    for the project.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一部分与我们迄今为止所做过的任何项目都没有不同。填写项目的位置。
- en: Create your virtual environment. Once everything is filled in, PyCharm creates
    and activates the virtual environment and installs Flask and its dependencies.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的虚拟环境。一旦填写完毕，PyCharm将创建并激活虚拟环境，并安装Flask及其依赖项。
- en: This section is unique to Flask projects. I mentioned that Flask encourages
    the use of the Jinja2 templating engine. You can choose to leave it out and PyCharm
    will take care of that for you. There is also a setting for the folder you want
    to use for your Jinja2 templates. We’re going to keep the defaults and I recommend
    if you are going to use Jinja2 templates that you leave the settings as they are
    because that is where most developers will expect them.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一部分是Flask项目的独特之处。我提到Flask鼓励使用Jinja2模板引擎。你可以选择不使用它，PyCharm会为你处理。还有一个设置用于你想要使用的Jinja2模板文件夹。我们将保持默认设置，如果你打算使用Jinja2模板，我建议你保持设置不变，因为这是大多数开发者预期它们所在的位置。
- en: Once you have everything filled in, click the **Create** button at the bottom
    of the dialog and PyCharm will set up your project for you, including the creation
    of some starter code, as seen in *Figure 8**.3*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦填写完毕，点击对话框底部的**创建**按钮，PyCharm将为你设置项目，包括创建一些起始代码，如*图8.3*所示。
- en: '![Figure 8.3: PyCharm generates your Flask project automatically](img/B19644_08_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：PyCharm自动生成你的Flask项目](img/B19644_08_03.jpg)'
- en: 'Figure 8.3: PyCharm generates your Flask project automatically'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：PyCharm自动生成你的Flask项目
- en: At position `Hello World` idiom from earlier, except this one is responding
    to the root route of your web application. At the top, we import Flask, then we
    instantiate Flask as the `app` variable. Now that you know that, the decoration
    for the route on *line 6* makes more sense; `app.route` is simply coming from
    the `app` instance of Flask.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`Hello World`习语位置，除了这个是响应你的Web应用程序的根路由。在顶部，我们导入Flask，然后我们将Flask实例化为`app`变量。现在你知道了这一点，*第6行*上的装饰对路由更有意义；`app.route`只是来自Flask的`app`实例。
- en: All this code is contained in `app.py` at position **(2)** of *Figure 8**.3*.
    The name isn’t a requirement, and you can change it if you’d like. You can also
    see, at position **(3)**, that PyCharm has generated two folders for Jinja2 templates
    and static files such as your images, CSS, and JavaScript files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都包含在`app.py`文件中，位于*图8.3*的**（2）**位置。名称不是必需的，如果你愿意的话可以更改它。你还可以看到，在**（3）**位置，PyCharm已经为Jinja2模板和静态文件（如你的图片、CSS和JavaScript文件）生成了两个文件夹。
- en: Creating a dynamic web application
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态Web应用程序
- en: The `Hello World` program generated by PyCharm is a good starting point for
    new applications. It provides you with some nice cognitive prompting in case it’s
    been a while since you created the Flask application from scratch. Naturally,
    we’ll be wanting to replace `Hello World` with something a tad more useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm生成的`Hello World`程序是新建应用程序的好起点。它为你提供了一些认知提示，以防你很久没有从头创建Flask应用程序。自然地，我们希望用稍微更有用的东西来替换`Hello
    World`。
- en: Let’s create a very simple application for cataloging new Python libraries!
    This kind of project is usually done with a database, but it doesn’t have to be.
    Our app is going to hold a list of Python libraries along with their description
    and a rating from 1-5 on how useful we think they are. To accomplish the database
    part, we’re going to simply use an in-memory array of lists. Using this approach
    prevents the need to do a deep dive on the database features of PyCharm, which
    isn’t coming until [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266)*, Understanding
    Database Management with PyCharm*. We’ll also exercise every excuse to cover some
    features we’ve covered earlier in a practical setting, such as using the HTML
    features from the last chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于编目新Python库的非常简单的应用程序！这类项目通常使用数据库，但不必如此。我们的应用程序将包含Python库列表及其描述，以及我们认为它们有多有用的1-5评级。为了完成数据库部分，我们将简单地使用内存中的列表数组。采用这种方法可以避免深入研究PyCharm的数据库功能，这些功能将在[*第11章*](B19644_11.xhtml#_idTextAnchor266)中介绍，即《使用PyCharm理解数据库管理》。我们还将利用每一个机会来实际应用我们之前介绍的一些功能，例如使用上一章中的HTML功能。
- en: Setting up the static parts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置静态部分
- en: The easiest place to start when building a web application is to get the static
    parts working. I’m talking about the non-dynamic parts of the application such
    as the `index.html` page with its basic structure, any CSS, images, and JavaScript
    we might need.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用程序时，最简单的起点是让静态部分工作。我指的是应用程序的非动态部分，例如具有基本结构的`index.html`页面，以及我们可能需要的任何CSS、图像和JavaScript。
- en: Start off by right-clicking in the `Templates` folder and creating a new file
    called `index.html`. This is going to be a Jinja2 template, so it belongs in the
    `Templates` folder rather than the `static` folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Templates`文件夹中右键单击并创建一个名为`index.html`的新文件。这是一个Jinja2模板，因此它应该放在`Templates`文件夹而不是`static`文件夹中。
- en: "![Figure 8.4: Right-click\uFEFFing the Templates folder and creat\uFEFFing\
    \ a new HTML file](img/B19644_08_04.jpg)"
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：右键单击模板文件夹并创建一个新的HTML文件](img/B19644_08_04.jpg)'
- en: 'Figure 8.4: Right-clicking the Templates folder and creating a new HTML file'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：右键单击模板文件夹并创建一个新的HTML文件
- en: Note that we created a plain HTML file. There is no special file type for a
    Jinja2 file. The file is created using the Emmet templating system we covered
    in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172)*, Web Development with JavaScript*,
    *HTML, and CSS*. As you hopefully remember, `title` attribute in the HTML file,
    allowing you to fill in that blank spot in the HTML template. You can see mine
    in *Figure 8**.5*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个普通的HTML文件。Jinja2文件没有特殊的文件类型。该文件是使用我们在[*第7章*](B19644_07.xhtml#_idTextAnchor172)中介绍的Emmet模板系统创建的，即《使用JavaScript、HTML和CSS进行Web开发》。希望您还记得，HTML文件中的`title`属性允许您填写HTML模板中的空白部分。您可以在*图8**.5*中看到我的示例。
- en: '![Figure 8.5: The HTML creation template puts your cursor in the title tag
    so you can fill in that part of the page](img/B19644_08_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：HTML创建模板将光标置于标题标签中，以便您填写页面该部分的内容](img/B19644_08_05.jpg)'
- en: 'Figure 8.5: The HTML creation template puts your cursor in the title tag so
    you can fill in that part of the page'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：HTML创建模板将光标置于标题标签中，以便您填写页面该部分的内容
- en: 'Next, let’s modify the contents of the `<head>` tag like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们像这样修改`<head>`标签的内容：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This brings in the bootstrap CSS and JavaScript libraries from a **content delivery
    network** (**CDN**). If you don’t want to type all that in, you can copy the code
    from the book’s repository code, or you can go to [https://getbootstrap.com](https://getbootstrap.com)
    and find the latest in the **Getting Started** section of their site, which usually
    includes copyable links to their CDN.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入来自**内容分发网络**（**CDN**）的bootstrap CSS和JavaScript库。如果您不想手动输入所有这些内容，您可以从书籍的代码库中复制代码，或者您可以去[https://getbootstrap.com](https://getbootstrap.com)，并在他们网站的**入门**部分找到最新版本，通常包括可复制的CDN链接。
- en: We’re using the CDN so we don’t need to keep these common files in our project.
    Besides, CDNs usually serve these kinds of files faster than will your own web
    server once you move your amazing app into production.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CDN，因此不需要在我们的项目中保留这些常用文件。此外，一旦您的惊人应用程序投入生产，CDN通常比您的Web服务器更快地提供这些类型的文件。
- en: 'Next, change the contents of the `<body>` tag to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`<body>`标签的内容更改为以下内容：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we’re going to use the Emmet feature we learned about in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172)*,
    Web Development with JavaScript, HTML, and CSS,* to generate an HTML table header.
    Type this Emmet code into the editor on a new line just below the `<``h2>` tag:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们在[*第7章*](B19644_07.xhtml#_idTextAnchor172)*，使用JavaScript、HTML和CSS进行Web开发*中学习到的Emmet功能来生成HTML表格标题。在新的一行中，在`<h2>`标签下方输入以下Emmet代码：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This abbreviation will generate a table, followed by a `thead` tag, with one
    table row (`tr`) and four table head fields (`th*4`). Press *Tab* to expand the
    abbreviation. PyCharm’s Emmet plugin will generate your code and take you straight
    to the contents of the `th` tags, as shown in *Figure 8**.6*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缩写将生成一个表格，后面跟着一个`thead`标签，包含一个表格行(`tr`)和四个表头字段(`th*4`)。按*Tab*键展开缩写。PyCharm的Emmet插件将生成您的代码，并直接带您到`th`标签的内容，如图*图8**.6*所示。
- en: '![Figure 8.6: Emmet expands the code into all the code you need for the table
    header](img/B19644_08_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：Emmet将代码扩展为表头所需的所有代码](img/B19644_08_06.jpg)'
- en: 'Figure 8.6: Emmet expands the code into all the code you need for the table
    header'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：Emmet将代码扩展为表头所需的所有代码
- en: Once Emmet has expanded your code, you’ll see the prompts inside the `th` tags
    allowing you to edit the content, as shown in *Figure 8**.7*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Emmet扩展了您的代码，您将看到`th`标签内的提示，允许您编辑内容，如图*图8**.7*所示。
- en: '![Figure 8.7: Emmet expands the shorthand in line 15 in Figure 8.6 to what
    we see here](img/B19644_08_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：Emmet将图8.6中的第15行缩写扩展为我们看到的内容](img/B19644_08_07.jpg)'
- en: 'Figure 8.7: Emmet expands the shorthand in line 15 in Figure 8.6 to what we
    see here'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Emmet将图8.6中的第15行缩写扩展为我们看到的内容
- en: Traditionally, you’d use **Tab** to move between the fields, but in PyCharm,
    the *Tab* key is bound to the action that expands Emmet, as we just saw. You can’t
    use *Tab* to navigate as you’d expect if you’re coming from a different Emmet-enabled
    editor. Instead, you’ll need to find out what the shortcut is on your system since
    this will depend on which keyboard shortcut layout you configured when you installed
    PyCharm. I chose the Windows layout, so for me, moving between the fields is done
    using *Alt + Shift + ]*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，您会使用**Tab**键在字段之间移动，但在PyCharm中，*Tab*键被绑定到扩展Emmet的动作，正如我们刚才看到的。如果您来自不同的Emmet启用编辑器，您可能无法像预期的那样使用*Tab*键进行导航。相反，您需要找出您系统上的快捷键，因为这将取决于您在安装PyCharm时配置的键盘快捷键布局。我选择了Windows布局，因此对我而言，在字段之间移动是使用*Alt
    + Shift + ]*完成的。
- en: Inside the first `th` tag, type `Library Name`. Then use *Alt + Shift + ]* to
    move to the next field and change it to `Description`. The third field will be
    called `Rating` and the fourth is titled `URL`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`th`标签内，输入`图书馆名称`。然后使用*Alt + Shift + ]*键移动到下一个字段，并将其更改为`描述`。第三个字段将被称为`评分`，第四个字段标题为`URL`。
- en: If *Alt + Shift + ]* doesn’t do it for you, let’s find out what will. Go into
    PyCharm’s settings and find the **Keymap** settings as shown in *Figure 8**.8*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*Alt + Shift + ]*对您不起作用，让我们找出什么会起作用。进入PyCharm的设置，并找到如图*图8**.8*所示的**键映射**设置。
- en: I’ve typed `Emmet` into the search box and I can see that my **Navigate > Next
    / Previous Emmet Edit Point** settings are **Alt + Shift + ]** and **Alt + Shift
    + [,** respectively. If yours are different, you’ll see what they are here, and
    as we’ve learned, you can change them to anything you’d like so long as the change
    doesn’t conflict with something else.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在搜索框中输入了`Emmet`，可以看到我的**导航 > 下一个/上一个Emmet编辑点**设置是**Alt + Shift + ]**和**Alt
    + Shift + [**，分别。如果您的不同，您将在这里看到它们，并且正如我们所学的，您可以将其更改为您想要的任何内容，只要更改不与另一项冲突。
- en: '![Figure 8.8: Your Emmet navigation settings are found and set here in Settings](img/B19644_08_08.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：您的Emmet导航设置在设置中找到并设置此处](img/B19644_08_08.jpg)'
- en: 'Figure 8.8: Your Emmet navigation settings are found and set here in Settings'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：您的Emmet导航设置在设置中找到并设置此处
- en: 'At this stage, your HTML `table` code should look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您的HTML `table`代码应该看起来像这样：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s add one more thing to the `table` code. Put this below the `</thead>`
    closure but before the `</``table>` closure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`table`代码中添加另一项内容。在`</thead>`闭合之后但在`</table>`闭合之前输入以下内容：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If your code got messy, use PyCharm’s reformat code feature to clean things
    up. This is usually *Ctrl + Alt + L*, or *Cmd + Opt + L* on a Mac.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码变得混乱，请使用PyCharm的代码重排功能来整理。这通常是*Ctrl + Alt + L*，或者在Mac上为*Cmd + Opt + L*。
- en: We have a basic web page laid out. Before we make it dynamic, let’s create a
    run configuration for the app so we can preview our handiwork.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经布局了一个基本的网页。在我们使其动态之前，让我们为应用程序创建一个运行配置，这样我们就可以预览我们的作品。
- en: Running the Flask app
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Flask应用
- en: When we created our project, PyCharm created a Flask run configuration for us.
    Let’s take a look at it so we can understand how the app will be run by PyCharm.
    Click the **Run configuration** dropdown and click **Edit Configurations…**, as
    seen in *Figure 8**.9*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建项目时，PyCharm为我们创建了一个Flask运行配置。让我们看看它，以便了解PyCharm将如何运行该应用。点击**运行配置**下拉菜单，然后点击**编辑配置…**，如图8**.9**所示。
- en: "![Figure 8.9: Edit\uFEFFing the run configurations so we can see what they’re\
    \ made of](img/B19644_08_09.jpg)"
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：编辑运行配置以查看其构成](img/B19644_08_09.jpg)'
- en: 'Figure 8.9: Editing the run configurations so we can see what they’re made
    of'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：编辑运行配置以查看其构成
- en: The settings look like those shown in *Figure 8**.10*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 设置看起来像图8**.10**中所示。
- en: '![Figure 8.10: Flask run configuration generated by PyCharm](img/B19644_08_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10：PyCharm生成的Flask运行配置](img/B19644_08_10.jpg)'
- en: 'Figure 8.10: Flask run configuration generated by PyCharm'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：PyCharm生成的Flask运行配置
- en: Most of these settings will be familiar now, so only a few are marked.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数设置都很熟悉了，所以只有少数被标记。
- en: 'There are a couple of ways to run a Flask app. The easiest is to just run the
    `app.py` file, which is the `dunder-main` line that runs the app, this works just
    fine. Recall the code at the bottom of `app.py`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Flask应用有几种方法。最简单的方法是直接运行`app.py`文件，这是运行应用的`dunder-main`行，这完全没问题。回想一下`app.py`底部的代码：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can also run it using the module name, but let’s stick with what PyCharm
    generated for now.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用模块名来运行它，但现在让我们先使用PyCharm生成的配置。
- en: At position `FLASK_DEBUG` environment variable gets its own checkbox. When you
    check this box, it puts the dedicated Flask development server into debug mode,
    which yields several benefits. The greatest of these is that the app server will
    restart whenever you change the code. This saves you from having to remember to
    stop and restart the server every time you make a change. Generally speaking,
    you want this box checked. Above the check is a commonly used `FLASK_ENV` environment
    variable that is also passed to the running app. It defaults to `development`.
    You can use this environment variable to turn on and off certain behaviors in
    your app, including setting log detail levels.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FLASK_DEBUG`环境变量位置，它有自己的复选框。当你勾选这个框时，它将专用的Flask开发服务器置于调试模式，这带来了一些好处。其中最大的好处是，每当您更改代码时，应用服务器都会重新启动。这让您不必每次更改时都记得停止和重新启动服务器。一般来说，您希望勾选这个框。勾选框上方是常用的`FLASK_ENV`环境变量，它也被传递给运行的应用。它默认为`development`。您可以使用这个环境变量在您的应用中打开和关闭某些行为，包括设置日志详细级别。
- en: The two `PYTHONPATH` checkboxes at position `PYTHONPATH` folder, which prevents
    you from getting an error stating Python can’t find your application. You want
    these checked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PYTHONPATH`文件夹位置的两个`PYTHONPATH`复选框，这可以防止您收到Python找不到您的应用的错误。您希望勾选这些。
- en: Note that with all these checkboxes, PyCharm gives you the ability to set common
    environment variables that are passed into the running app. This is nice, because
    setting them at the OS level is extra work that we often forget, and changing
    environment variables often doesn’t work as well as it should depending on your
    operating system. When you use environment variables at the OS level, you generally
    need to either reboot or log out and log back in to make sure the new values are
    active. PyCharm injects variables directly into the running development server,
    which saves a lot of time and frustration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，PyCharm提供了设置传递给运行应用中的常见环境变量的能力，这些复选框正是如此。这很好，因为在操作系统级别设置它们是额外的工作，我们经常忘记，而且根据您的操作系统，更改环境变量可能不会像预期的那样有效。当您在操作系统级别使用环境变量时，通常需要重新启动或注销并重新登录，以确保新值生效。PyCharm直接将变量注入到运行的开发服务器中，这节省了大量的时间和挫折。
- en: Click **OK** to close the run configuration dialog.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**关闭运行配置对话框。
- en: 'Before we fire it up, we need to make a code change to `app.py`. We need to
    alter our `Hello World` code to load and display our template. The altered code
    looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动之前，我们需要对`app.py`进行代码更改。我们需要修改我们的`Hello World`代码以加载并显示模板。修改后的代码如下：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, I’ve added an import for the `render_template` method from Flask. We’ll
    use this to, you guessed it, render our Jinja2 HTML template.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我添加了对Flask中的`render_template`方法的导入。我们将使用它来渲染我们的Jinja2 HTML模板。
- en: 'Next, I’ve added some code to the route decorator. Previously, we had `@app.route(''/'')`,
    which defines the `root` route for our site that will be handed by our `root`
    function. I’ve added a second argument, `methods=["GET"]`. Flask allows you to
    lock a route to one or more of the HTTP request methods I described earlier in
    the chapter. Locking Flask application endpoints to a particular HTTP method,
    such as `GET` or `POST`, is a fundamental practice in web development for several
    important reasons:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我在路由装饰器中添加了一些代码。之前我们有 `@app.route('/')`，它定义了我们的网站 `root` 路由，该路由将由我们的 `root`
    函数处理。我添加了一个第二个参数，`methods=["GET"]`。Flask 允许你将路由锁定到之前章节中描述的 HTTP 请求方法之一或多个。将 Flask
    应用程序端点锁定到特定的 HTTP 方法，如 `GET` 或 `POST`，是 Web 开发中的基本实践，有以下几个重要原因：
- en: '**Security**: Different HTTP methods have different purposes and security implications.
    For example, GET requests are typically used for retrieving data, and they should
    not have any side effects on the server. In contrast, POST requests are used for
    submitting data to the server, and they can have side effects, such as creating,
    updating, or deleting resources. By restricting endpoints to specific HTTP methods,
    you can prevent unintended or malicious actions. This is known as “method-based
    access control.”'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：不同的 HTTP 方法有不同的用途和安全影响。例如，GET 请求通常用于检索数据，它们不应在服务器上产生任何副作用。相比之下，POST
    请求用于向服务器提交数据，它们可以产生副作用，如创建、更新或删除资源。通过将端点限制到特定的 HTTP 方法，你可以防止意外的或恶意的行为。这被称为“基于方法的访问控制”。'
- en: '**Predictability**: Locking endpoints to specific HTTP methods makes your API
    or web application more predictable and self-documenting. Other developers (or
    even your future self) will have a clearer understanding of how to interact with
    your application. For example, if an endpoint is designed for GET requests, it’s
    clear that it’s meant for data retrieval.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：将端点锁定到特定的 HTTP 方法可以使你的 API 或 Web 应用程序更加可预测和自文档化。其他开发者（甚至你未来的自己）将更清楚地了解如何与你的应用程序交互。例如，如果一个端点是为
    GET 请求设计的，那么它显然是用来检索数据的。'
- en: '**Consistency**: Consistency in your API design can improve the user experience
    and reduce confusion. When users or clients know that a specific HTTP method is
    expected for an endpoint, they are less likely to make incorrect requests.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：API 设计的一致性可以提高用户体验并减少困惑。当用户或客户端知道特定端点期望特定的 HTTP 方法时，他们不太可能发出错误的请求。'
- en: '**Preventing accidents**: Accidental misuse of an endpoint can lead to unintended
    consequences. By restricting the allowed HTTP methods, you reduce the chances
    of UI developers making mistakes, such as trying to delete data with a GET request.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止意外**：端点的意外误用可能导致意外的后果。通过限制允许的 HTTP 方法，你可以减少 UI 开发者犯错误的机会，例如尝试使用 GET 请求删除数据。'
- en: '**Framework support**: Flask, along with many other web frameworks, provides
    built-in support for routing requests based on HTTP methods. This makes it easier
    to implement method-based access control, as you can define separate routes and
    handlers for each HTTP method.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架支持**：Flask 与许多其他 Web 框架一样，提供了基于 HTTP 方法的内置路由请求支持。这使得实现基于方法的访问控制变得更容易，因为你可以为每个
    HTTP 方法定义单独的路由和处理程序。'
- en: If you look closely, the argument we’re passing is an array. You can pass one
    or more methods allowing one route to handle one or several methods differently.
    Here, we’re locking the `root` route function to the HTTP GET method, which is
    what your browser issues when you visit a site.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，我们传递的参数是一个数组。你可以传递一个或多个方法，允许一个路由以不同的方式处理一个或多个方法。在这里，我们将 `root` 路由函数锁定到
    HTTP GET 方法，这是当你访问网站时浏览器发出的请求。
- en: Next, we’ve added Flask’s `render_template` method to our import. I changed
    the name of the function from `hello_world` to `root`, then I changed the return
    from the `'Hello World'` string to the result of the `render_template` function
    that takes the filename of a template. Flask knows to find `index.html` in the
    `Templates` folder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 Flask 的 `render_template` 方法添加到了我们的导入中。我将函数的名称从 `hello_world` 改为 `root`，然后将返回值从
    `'Hello World'` 字符串改为 `render_template` 函数的结果，该函数接受模板的文件名。Flask 会知道在 `Templates`
    文件夹中查找 `index.html`。
- en: Now we’re ready to try it out. Make sure your Flask app is selected in the run
    configuration dropdown and click the green **Run** button. The **Run** tab will
    appear at the bottom of the PyCharm screen. Mine appears as shown in *Figure 8**.11*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备尝试一下。确保你的 Flask 应用程序在运行配置下拉菜单中被选中，然后点击绿色的 **运行** 按钮。**运行** 选项卡将出现在 PyCharm
    屏幕的底部。我的看起来如图 **8**.11 所示。
- en: '![Figure 8.11: The Run window for our Flask app](img/B19644_08_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：我们的Flask应用的运行窗口](img/B19644_08_11.jpg)'
- en: 'Figure 8.11: The Run window for our Flask app'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：我们的Flask应用的运行窗口
- en: There are a couple of remarkable elements to point out. The first is the big
    red warning message. I know, it’s gray for you, but you’ll see it the first time
    you try this out. We’re running our app using Flask’s built-in development web
    server. Please don’t use this in production. Instead, you need to use a production-quality
    app server such as Green Unicorn. This falls outside the scope of developing with
    PyCharm, but it is such a huge mistake to deploy your app using the built-in server
    that I felt it needed to point out and justify this warning being in big red letters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得注意的元素。第一个是那个大红色的警告信息。我知道，对你来说它是灰色的，但当你第一次尝试时你会看到它。我们正在使用Flask内置的开发网络服务器运行我们的应用。请不要在生产环境中使用它。相反，你需要使用一个生产质量的网络应用服务器，例如Green
    Unicorn。这超出了使用PyCharm进行开发的范围，但使用内置服务器部署你的应用是一个如此巨大的错误，我觉得有必要指出并解释为什么这个警告要以大红色字母的形式出现。
- en: Second, it tells you the app is running at `http://127.0.0.1:5000`. The address
    is listed as a hyperlink, which you can click to open your browser. I have mine
    open in *Figure 8**.12*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它告诉你应用正在`http://127.0.0.1:5000`上运行。地址被列为超链接，你可以点击它来打开浏览器。我的浏览器在*图8.12*中打开。
- en: '![Figure 8.12: It worked, but 1991 just called on the phone and they want their
    web design back](img/B19644_08_12.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：它工作了，但1991年刚打电话来说他们想要他们的网页设计](img/B19644_08_12.jpg)'
- en: 'Figure 8.12: It worked, but 1991 just called on the phone and they want their
    web design back'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：它工作了，但1991年刚打电话来说他们想要他们的网页设计
- en: It is awfully ugly, isn’t it? We went to the trouble of adding Bootstrap, the
    least we can do is use it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是太难看了，不是吗？我们费了这么大的劲添加了Bootstrap，至少应该用上它。
- en: Let’s make it look a little better
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们让它看起来好一点
- en: The page doesn’t have much happening in terms of design, and while we won’t
    be building some amazing user experience that might land you a design job at Apple,
    we can at least make this a little more presentable by adding some Bootstrap classes.
    We’ll be doing this within the `body` tag inside our Jinja2 template, `index.html`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，页面并没有太多动作，虽然我们不会构建一些可能让你在苹果公司得到设计工作的惊人用户体验，但我们可以通过添加一些Bootstrap类至少让这个页面看起来更整洁。我们将在Jinja2模板`index.html`内的`body`标签内完成这项工作。
- en: First, let’s set up Bootstrap’s layout grid. This allows us to create apps that
    gracefully adjust to any size screen from the tiniest phone browser to the largest
    8K display.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置Bootstrap的布局网格。这允许我们创建能够优雅地适应任何尺寸屏幕的应用，从小型手机浏览器到最大的8K显示器。
- en: 'Add this code just inside the `body` tag. When you’re done, it should bump
    up against the `table` code we created earlier:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`body`标签内。完成后，它应该紧挨着我们之前创建的`table`代码：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we’ve added a `div` marked with the `container-fluid` class. This is going
    to give us some much-needed layout and padding so our content doesn’t slam up
    against the edges of the browser window. I’ve also set this to take up the full
    height available in the browser window in anticipation of there being many useful
    libraries in our table. I did this with Bootstrap’s `h-100` class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个标记为`container-fluid`类的`div`。这将为我们提供一些急需的布局和填充，以便我们的内容不会紧贴浏览器窗口的边缘。我还将其设置为占据浏览器窗口中可用的全部高度，预计我们的表格中会有许多有用的库。我是用Bootstrap的`h-100`类做到这一点的。
- en: After that, I added a `div` to act as a row followed by one acting as a column.
    I’ve set the class on the column to `col-12`, which in Bootstrap means it should
    take up the full width of the browser window with appropriate margins and padding
    defined by the `container-fluid` class in the ancestral `div` tag we added earlier.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我添加了一个`div`作为行，然后又添加了一个作为列。我已经将列的类设置为`col-12`，在Bootstrap中这意味着它应该占据浏览器窗口的全宽，并带有适当的边距和填充，这些由我们之前添加的祖先`div`标签中的`container-fluid`类定义。
- en: The next three tags are just content additions – some labeling that explains
    what the user is seeing using `H1` and `H2` tags followed by a horizontal rule.
    I added a CSS class to flip the letter R so it is reminiscent of a popular, yet
    presently bankrupt toy shop in the US. One more icon from my childhood has bitten
    the dust. Bear in mind, we haven’t created this CSS class yet. We’ll do that in
    just a minute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个标签只是内容添加——一些使用`H1`和`H2`标签进行标注，解释用户看到的内容，然后是一个水平线。我添加了一个CSS类来翻转字母R，使其让人联想到美国一家流行但现已破产的玩具店。我童年的另一个图标已经灰飞烟灭。请注意，我们还没有创建这个CSS类。我们将在下一分钟内完成。
- en: 'Let’s add the Bootstrap `.table` class to the table. Change your `table` code
    by adding `class="table"`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在表格上添加Bootstrap的`.table`类。通过添加`class="table"`来更改你的`table`代码：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will fix up the spacing in and around the table so everything isn’t squished
    together.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以调整表格及其周围的间距，使所有内容不会挤在一起。
- en: 'To close all this out, we need to add all the necessary closing tags after
    our table is closed. That’s just three nested `div` closures:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一切，我们需要在表格关闭后添加所有必要的关闭标签。这只需要三个嵌套的`div`关闭标签：
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first closes the column, the second closes the row, and the third closes
    the container. The last step is to add some CSS.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关闭列，第二个关闭行，第三个关闭容器。最后一步是添加一些CSS。
- en: Adding some CSS
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一些CSS
- en: 'Right-click the `static` folder and create a new CSS file called `index.css`.
    Add the following code to the file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`static`文件夹，创建一个名为`index.css`的新CSS文件。将以下代码添加到文件中：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this CSS file, we’re adding some extra margin around the page and setting
    the height to 100% so we don’t wind up with a stubby little page that is fully
    dependent on how much content is in our table.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个CSS文件中，我们添加了一些额外的页边距，并将高度设置为100%，这样我们就不会得到一个又短又小的页面，这个页面完全依赖于我们表格中的内容量。
- en: I added a `flipped-letter` class in `index.css` to flip the letter R in our
    imaginary site’s title. We’re going to be displaying a rating for each library.
    I thought, instead of just a boring old number, we’d put some stars in there.
    Not just any stars – gold stars! So, there’s a class for that, which I called
    `.gold-star`. If you’re new to CSS, the leading dot is significant. It flags the
    rest, `gold-star` as a custom class. In CSS, a class has nothing to do with object-oriented
    development, so if you’ve learned some Java or other class based language, the
    word *class* is not related to the concepts from those languages. You’ll see in
    a minute when the class is used within the HTML, the dot will be absent. This
    is not an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`index.css`中添加了一个`flipped-letter`类来翻转我们想象中的网站标题中的字母R。我们将为每个图书馆显示一个评分。我想，与其只显示一个无聊的数字，不如放一些星星进去。不仅仅是任何星星——是金色星星！所以，有一个类，我称之为`.gold-star`。如果你对CSS不熟悉，前面的点很重要。它标记了后面的`gold-star`作为一个自定义类。在CSS中，类与面向对象开发无关，所以如果你学过一些Java或其他基于类的语言，那么“类”这个词与那些语言中的概念无关。你很快就会看到，当类在HTML中使用时，点将不存在。这不是一个错误。
- en: 'Now that we have a CSS file in the `static` folder, we need to reference it
    in the HTML file. Since it is in the static folder, which has special meaning
    in a Flask app, our code is a little different than a straight CSS reference like
    those we saw earlier with plain HTML. Add this line of code inside your `head`
    tag:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`static`文件夹中有一个CSS文件了，我们需要在HTML文件中引用它。由于它位于具有特殊意义的静态文件夹中，我们的代码与之前我们看到的纯HTML中的直接CSS引用略有不同。在你的`head`标签内添加以下代码行：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the Jinja2 expression that resolves the location of the static folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Jinja2表达式解析了静态文件夹的位置。
- en: I mentioned a moment ago that I want to use stars to show my ratings. I don’t
    really want to use graphics for this. Instead, I’d rather use a font, specifically
    **Font Awesome**. Font Awesome is essentially agigantic web font that, instead
    of containing alphabetical characters, contains hundreds of useful graphical icons
    useful for making modern UI and website designs. For more information on Font
    Awesome, see [https://www.fontawesome.com](https://www.fontawesome.com).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才提到我想用星星来显示我的评分。我并不想真正使用图形。相反，我更愿意使用一个字体，特别是**Font Awesome**。Font Awesome基本上是一个巨大的网络字体，它不包含字母字符，而是包含数百个有用的图形图标，这些图标对于制作现代UI和网站设计非常有用。有关Font
    Awesome的更多信息，请参阅[https://www.fontawesome.com](https://www.fontawesome.com)。
- en: Rather than include Font Awesome in our project, which of course is an option,
    I’m going to link to a version of it hosted on a **content delivery network**
    (**CDN**). CDNs are a desirable way to host content because they are designed
    to serve static content with great speed. They do this not only through normal
    server optimizations but also by strategically positioning servers all over the
    world. When your page loads static content from a CDN, the request for that content
    is routed to the closest server. Your users in India will reach a CDN server in
    India, while users in Kansas (the middle of the United States) will be served
    the content from a server much closer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将 Font Awesome 包含在我们的项目中，当然这是一个选项，我将链接到一个托管在 **内容分发网络**（**CDN**）上的 Font Awesome
    版本。CDN 是托管内容的一种理想方式，因为它们被设计用来以极快的速度提供静态内容。它们不仅通过正常的服务器优化来实现这一点，而且还通过在全球范围内战略性地放置服务器来实现。当你的页面从
    CDN 加载静态内容时，对该内容的请求会被路由到最近的服务器。印度的用户将连接到印度的 CDN 服务器，而堪萨斯州（美国中部）的用户将从更近的服务器获取内容。
- en: 'Font Awesome lists its CDN links on its website. I’m going to use a link I
    have copied from the Font Awesome website and add this to the `head` tag of our
    page. Since this is coming from a CDN instead of the static folder, I don’t need
    any Jinja2 voodoo magic to resolve it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 在其网站上列出了其 CDN 链接。我将使用我从 Font Awesome 网站复制的链接，并将其添加到我们页面的 `head`
    标签中。由于这是从 CDN 而不是静态文件夹中获取的，所以我不需要任何 Jinja2 的魔法来解析它：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Things should be looking much better! I’ll hold off on the revealing screenshot
    until we’ve added the dynamic content. I don’t want to spoil the big reveal! Don’t
    forget, you can check the final code in the chapter’s repository folder cloned
    from GitHub.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 页面看起来应该好多了！我会在我们添加了动态内容后再发布截图。我不想破坏这个大揭秘！别忘了，你可以在从 GitHub 克隆的章节存储库文件夹中检查最终的代码。
- en: Making the page dynamic
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使页面动态化
- en: We’ve created a Flask app and gotten a template working. Let’s add dynamism
    to the page using Flask and Jinja2\. We’re going to simulate a database using
    a list of `dicts` with fields that correspond to the fields we’ve put in our table.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 Flask 应用并使一个模板工作。让我们使用 Flask 和 Jinja2 为页面添加动态性。我们将使用一个与我们在表中放置的字段相对应的字段列表的
    `dicts` 来模拟数据库。
- en: 'Switch to the `app.py` file and find this line, which should be near line number
    3:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `app.py` 文件，找到这条线，它应该接近第 3 行：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This line, which was generated by PyCharm when we created the project, creates
    an instance of Flask and assigns that instance to a variable called `app`. We’ll
    begin adding new code below this line. Let’s start by creating a global variable
    to hold our data:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是由 PyCharm 在我们创建项目时生成的，它创建了一个 Flask 实例，并将其分配给一个名为 `app` 的变量。我们将在这一行下面开始添加新的代码。让我们先创建一个全局变量来保存我们的数据：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In general, global variables, especially in a large program, are to be avoided.
    In this case, we’re using the global variable to simulate a database connection,
    which is generally an exception to the rule.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，全局变量，尤其是在大型程序中，应该避免使用。在这种情况下，我们使用全局变量来模拟数据库连接，这通常是规则的例外。
- en: Here, we’re adding a few records to our fake database. If you’re a fan of Jinja2,
    please don’t hate me. I rated it a 3 in the content just to have some visual difference
    between the two sample records.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在向我们的模拟数据库添加一些记录。如果你是 Jinja2 的粉丝，请不要恨我。我在内容中给它评了 3 分，只是为了在两个样本记录之间有一些视觉差异。
- en: 'There’s just one more change. Add a second parameter to the `render_template`
    call:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 只需再做一个修改。将第二个参数添加到 `render_template` 调用中：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `render_template` method is a **variadic function**. You can pass as many
    parameters into it as you’d like. Jinja2 will be able to render the passed data
    in the template. Here, we’re just adding one data variable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_template` 方法是一个 **可变参数函数**。你可以传递尽可能多的参数给它。Jinja2 将能够在模板中渲染传递的数据。在这里，我们只是添加了一个数据变量。'
- en: 'We’re done with `app.py`! The final code looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `app.py`！最终的代码如下所示：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we’re passing some data into the template, we need to go back and
    modify the `index.html` template to render the data. You need to change the contents
    of the `tbody` tag to this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一些数据传递到模板中，我们需要回到并修改 `index.html` 模板以渲染数据。你需要将 `tbody` 标签的内容更改为以下内容：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `{%` and `{{` markers in the template are marking out places where logic
    and content take place. Here, we are checking the length of the array. If it is
    greater than zero, we’re rendering table rows using the contents of the array.
    Further down, there’s an `else` that will render what we have now, which is a
    single row stating there is no data:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的`{%`和`{{`标记表示逻辑和内容发生的地方。在这里，我们正在检查数组的长度。如果它大于零，我们将使用数组的内容渲染表格行。向下还有`else`，它将渲染我们现在有的内容，即表示没有数据的单行：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we are looping through the `library_data` list and generating
    a table row (`tr`). The table row is then supplied with columns. The `{{ }}` placeholders
    denote where contents from the `dict` from the current list iteration should be
    placed. The first column shows the contents of `data.python_library`. The second
    shows the description.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在遍历`library_data`列表并生成一个表格行（`tr`）。然后为表格行提供列。`{{ }}`占位符表示当前列表迭代中`dict`的内容应该放置的位置。第一列显示`data.python_library`的内容。第二列显示描述。
- en: The third is where we add some razzle-dazzle! We add a code block that loops
    using a range to generate stars in that column. If the rating is 3, the loop runs
    3 times and we get 3 stars!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第三处是我们添加一些炫酷的东西！我们添加一个代码块，使用range循环来生成该列中的星星。如果评分是3，循环运行3次，我们得到3颗星星！
- en: For the URL, I used the value of `data.url` as the `href` attribute on a hyperlink.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于URL，我使用了`data.url`的值作为超链接的`href`属性。
- en: 'That just leaves the `else` statement I told you about:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下我之前提到的`else`语句：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To summarize, if we pass in an array with zero elements, Jinja2 will render
    the row we had before, which states there is no data. If there’s data in the array,
    Jinja2 loops over the array and generates a table row for each row in the data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果我们传递一个包含零个元素的数组，Jinja2将渲染我们之前的行，表示没有数据。如果数组中有数据，Jinja2将遍历数组并为数据中的每一行生成一个表格行。
- en: Run the project and direct your browser to `http://localhost:5000`. You’ll see
    a table rendered with two records, as seen in *Figure 8**.13*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并将浏览器指向`http://localhost:5000`。你会看到一个渲染了两个记录的表格，如图*图8**.13*所示。
- en: "![Figure 8.13: The big reveal! Our page is now dynamic\uFEFF](img/B19644_08_13.jpg)"
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：大揭秘！我们的页面现在是动态的](img/B19644_08_13.jpg)'
- en: 'Figure 8.13: The big reveal! Our page is now dynamic'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：大揭秘！我们的页面现在是动态的
- en: Let’s pause for a moment and take stock of how PyCharm has helped us.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，评估PyCharm是如何帮助我们。
- en: Editor enhancements for working with Flask and Jinja2
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于与Flask和Jinja2一起工作的编辑器增强功能
- en: You’ve been getting a lot of help during this exercise. If you don’t believe
    me, try repeating this exercise with Vim or Notepad! By now, you’re becoming accustomed
    to how much PyCharm takes off your plate in terms of lightening your cognitive
    load, and physically handling a lot of typing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你已经得到了很多帮助。如果你不相信我，试着用Vim或Notepad重复这个练习！到现在为止，你已经开始习惯PyCharm如何减轻你的认知负担，以及物理上处理大量的输入。
- en: 'You might not have even noticed the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能甚至没有注意到以下内容：
- en: The HTML editing features, such as syntax highlighting, automatic tag closures,
    and color-coded indicators for your nested opening and closing tags in the markup.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML编辑功能，如语法高亮、自动关闭标签和标记中嵌套的打开和关闭标签的颜色编码指示器。
- en: We used Emmet to generate some of our markups.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了Emmet来生成一些我们的标记。
- en: PyCharm understands Jinja2 syntax and the inspection doesn’t freak out when
    you start putting curly braces everywhere.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm理解Jinja2语法，并且当你开始到处放置大括号时，检查不会让你感到恐慌。
- en: In fact, it auto-closes the curly braces for both `{{ expressions }}` and `{%
    code` `blocks %}`.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，它会自动关闭`{{ 表达式 }}`和`{% code` `blocks %}`的大括号。
- en: If you made any mistakes along the way, you might have noticed that PyCharm’s
    inspections and suggestions clearly understand how to use Flask. It’s not simple
    introspective auto-completion. PyCharm will give you specific assistance tailored
    to Flask development.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在这个过程中犯了任何错误，你可能已经注意到PyCharm的检查和建议清楚地理解如何使用Flask。这不是简单的内省自动完成。PyCharm将为你提供针对Flask开发的特定帮助。
- en: 'Let’s look at a few features that are not so obvious:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些不那么明显的功能：
- en: Switch to `app.py`, put your cursor inside the template filename (`index.html`),
    then press *Ctrl* / *Cmd* + *B*. This activates the `library_data` variable in
    the template and press *Ctrl* / *Cmd* + *B*, it will take you to the render template
    call, which passes that variable into Jinja2.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到`app.py`，将光标放在模板文件名（`index.html`）内，然后按*Ctrl* / *Cmd* + *B*。这将在模板中激活`library_data`变量，然后按*Ctrl*
    / *Cmd* + *B*，它将带你到渲染模板的调用，该调用将变量传递给Jinja2。
- en: It shouldn’t surprise you that the debugger works in `app.py`. It also works
    in the Jinja2 template within the code blocks. Place a breakpoint in the `for`
    loop in the Jinja2 template, `index.html`. Start your app with `debug`, and the
    debugger will stop on the loop. You can use the same step-through capabilities
    as with anything else you are debugging. You can inspect template variables just
    as you would variables in a normal Python script. Considering Jinja2 is effectively
    a meta-language, completely distinct from Python, and specialized in what it can
    do, this is quite remarkable.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`app.py`中调试器工作并不令人惊讶。它同样也适用于代码块内的Jinja2模板。在Jinja2模板的`index.html`中的`for`循环处设置一个断点，使用`debug`启动你的应用，调试器将在循环处停止。你可以使用与调试其他任何内容相同的单步执行功能。你可以检查模板变量，就像检查正常Python脚本中的变量一样。考虑到Jinja2实际上是一种元语言，与Python完全不同，并且专注于它能做什么，这相当令人瞩目。
- en: If you made any mistakes, Werkzeug has a nifty error page with links to your
    stack trace, which includes a trace of your template. PyCharm captures this information
    and displays it, complete with hyperlinks in the **Run** window. The hyperlinks
    take you to the code in PyCharm rather than just displaying it as Werkzeug does
    in the browser window.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你犯了任何错误，Werkzeug有一个很棒的错误页面，其中包含指向你的堆栈跟踪的链接，其中包括你的模板跟踪。PyCharm捕获这些信息并在**运行**窗口中显示，包括超链接。这些超链接将带你到PyCharm中的代码，而不仅仅是像Werkzeug在浏览器窗口中那样显示它。
- en: You’ll see the same level of support for popular Flask plugins as you do for
    Jinja2\. Flask is designed to be extensible. There is a plethora of plugins to
    make your life easier in many areas of web development, from REST API development
    to database ORMs to session handling and authentication. You’ll find PyCharm guiding
    you through development in any Flask development scenario in which you find yourself.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现对流行的Flask插件的支持与对Jinja2的支持相同。Flask被设计成可扩展的。有许多插件可以帮助你在许多Web开发领域更轻松地工作，从REST
    API开发到数据库ORM，再到会话处理和身份验证。你会在任何你遇到的Flask开发场景中找到PyCharm的引导。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I’ve pointed out a few times now that this chapter is a poor tutorial on Flask.
    We just barely scratched the surface of what Flask can do, but we covered all
    the ways PyCharm can help you with Flask development and it is one of the few
    IDEs that provides the level of help and tooling we’ve seen as we developed this
    simple project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次指出，这一章是关于Flask的一个糟糕的教程。我们只是刚刚触及了Flask能做什么的表面，但我们涵盖了PyCharm如何帮助你进行Flask开发的全部方法，并且它是少数几个在开发这个简单项目时提供我们所见到的帮助和工具水平的IDE之一。
- en: For starters, Flask provides an easy way to generate a project structure and
    starter code for a Flask project. Like any other project, PyCharm sets up your
    virtual environment and gives you some starter code. When we use the Flask template
    in PyCharm Professional, PyCharm also installs your project dependencies for you
    and sets up a specialized run configuration for your project.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Flask提供了一个简单的方法来生成Flask项目的项目结构和起始代码。就像任何其他项目一样，PyCharm会设置你的虚拟环境，并为你提供一些起始代码。当我们使用PyCharm
    Professional中的Flask模板时，PyCharm也会为你安装项目依赖，并为你的项目设置一个专门的运行配置。
- en: Once you get into editing your project, you find all the features we’ve covered
    in earlier chapters coming together. The HTML, CSS, and JavaScript-related features
    work not only with normal HTML projects but also with the Jinja2 templating language
    native to Flask. We get Flask-specific inspections, code hints, and documentation
    not just for Flask but also for the extended Flask ecosystem.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始编辑你的项目，你会发现我们在前面章节中介绍的所有功能都汇集在一起。HTML、CSS和JavaScript相关功能不仅与普通HTML项目兼容，还与Flask本地的Jinja2模板语言兼容。我们不仅获得了针对Flask的特定检查、代码提示和文档，还获得了针对扩展Flask生态系统的文档。
- en: We even found we can debug Jinja2 templates as if they were actually Python
    code! Combine that with some very nice navigational enhancements to help you move
    between presentation logic and backend logic and you’ve got an unbeatable combination
    of power and functionality at your fingertips as a Flask developer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至发现我们可以像调试实际的 Python 代码一样调试 Jinja2 模板！结合一些非常棒的导航增强功能，帮助你在这两种逻辑之间切换——前端逻辑和后端逻辑——作为
    Flask 开发者，你将手握一种无与伦比的力量和功能组合。
- en: 'Flask isn’t the only game in town. Newer development models have become popular
    over the last few years: specifically **single-page apps** (**SPAs**) combined
    with pure RESTful APIs on the backend. The next chapter focuses on a fast, modern
    approach to building RESTful APIs using a framework called FastAPI.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 并非市场上唯一的游戏。在过去的几年中，一些新的开发模型变得流行：特别是**单页应用**（**SPAs**）与后端纯 RESTful API
    的结合。下一章将重点介绍使用名为 FastAPI 的框架构建 RESTful API 的快速、现代方法。
- en: As you will see, FastAPI bears some resemblence to Flask but with some important
    differences. Flask uses a worker model to serve content or data while FastAPI
    works a little more like NodeJS, which uses an asychronous programming model.
    FastAPI tends to focus solely on creating RESTful APIs and lacks the templating
    utilities found in Flask.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，FastAPI 与 Flask 有一些相似之处，但也有一些重要的区别。Flask 使用工作模型来服务内容或数据，而 FastAPI 则更像
    NodeJS，它使用异步编程模型。FastAPI 更倾向于专注于仅创建 RESTful API，而 Flask 中则缺少这些模板工具。
- en: Further reading
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
    The site allows me to list newer resources as they become available. The following
    resources will also be useful:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看该书的配套网站 [https://www.pycharm-book.com](https://www.pycharm-book.com)。该网站允许我列出可用的最新资源。以下资源也将非常有用：
- en: 'Gaspar, D., & Stouffer, J. (2018). *Mastering Flask Web Development: Build
    Enterprise-grade, Scalable Python Web Applications*. Packt Publishing Ltd.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gaspar, D.，& Stouffer, J. (2018). 《精通 Flask 网络开发：构建企业级、可扩展的 Python 网络应用》。Packt
    Publishing Ltd.
- en: 'Van Horn II, B. (2019). *Building RESTful APIs with Flask*. LinkedIn Learning:
    [https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4](https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-fl).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Van Horn II, B. (2019). 《使用 Flask 构建 RESTful API》。LinkedIn Learning：[https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-flask-4](https://www.linkedin.com/learning/building-restful-apis-with-flask/restful-apis-with-python-3-and-fl)。
- en: 'Van Horn II, B. (2021). MongoDB for Python Developers. MadDevSkilz.com. [https://www.maddevskilz.com/courses/mongodb-for-python-developers](https://www.maddevskilz.com/courses/mongodb-for-python-developers).
    Note: Despite the title, this is a short tutorial on creating a Flask application
    that uses MongoDB. It is very similar to, and newer than, my LinkedIn course.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Van Horn II, B. (2021). 《Python 开发者用 MongoDB》。MadDevSkilz.com。[https://www.maddevskilz.com/courses/mongodb-for-python-developers](https://www.maddevskilz.com/courses/mongodb-for-python-developers)。注意：尽管标题如此，这是一篇关于创建使用
    MongoDB 的 Flask 应用的简短教程。它与我 LinkedIn 上的课程非常相似，而且更新更早。
