- en: Robotics 101
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人101
- en: Hello world! As soon as we say the word robot, thoughts of science fiction start
    to surround us. We may recall the cartoon serial *The Jetsons* or think of the
    movie *Terminator*. But, as a matter of fact, robots as a species do not belong
    to science fiction anymore. They are as real as they can get. Look around you
    and point out any object; it probably wouldn't have been made without a robot.
    The modern era has been shaped by robots.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！一提到机器人这个词，科幻小说的思绪就会围绕着我们。我们可能会回想起卡通系列《杰森一家》或者想到电影《终结者》。但事实上，作为物种，机器人已经不再属于科幻小说了。它们是如此真实。看看你周围，指出任何物体；它可能没有机器人的参与就不会被制造出来。现代时代是由机器人塑造的。
- en: But then, you can also take a step back and think, wait a minute, aren't the
    things he is talking about called machines and not robots? Well, yes, you are
    very correct, yet very mistaken at the same time. It is cartoons and science fiction
    that have imparted an image of a human-like robot that is called a **robot**.
    But robots are much more than that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后，你也可以退一步思考，等等，他所说的东西不是机器而不是机器人吗？嗯，是的，你非常正确，但同时也非常错误。是卡通和科幻小说赋予了类似人类的机器人一个被称为**机器人**的形象。但机器人远不止如此。
- en: Unfortunately, we do not have a concrete, universally agreed definition of robots,
    but, as I like to say, *Any machine capable of performing physical as well as
    intellectual tasks can be called a robot.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们没有一个具体、普遍认同的机器人定义，但正如我经常说的，*任何能够执行物理和智力任务的机器都可以被称为机器人*。
- en: Now, you may say that, according to my definition, even an automatic washing
    machine can be called a robot. Well, technically, yes, and why should we not call
    it a robot? Think of the things it is doing for you and what kind of automation
    has been adapted over the years. After you feed in the type of cloth it automatically
    washes, rinses, and dries as you would have done yourself in the 19th century.
    The point I am trying to make is that there is a huge variation of robots that
    we can think of, which can radically change the way we live. We need to think
    with a wider perspective—not just limit robot to look as a human adaption in form
    of humanoid robots.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会说，根据我的定义，即使是自动洗衣机也可以被称为机器人。从技术上讲，是的，那么我们为什么不称它为机器人呢？想想它为你做了什么，以及这些年来采用了什么样的自动化。在你输入了布料类型后，它会自动洗涤、漂洗和烘干，就像你在19世纪会做的那样。我试图说明的是，我们可以想到的机器人种类繁多，这可能会彻底改变我们的生活方式。我们需要以更广阔的视角来思考——不仅仅将机器人限制在类人形机器人的形式上。
- en: 'We live in the golden era of robotics and automation in which the development
    of new products is as simple as it can get. What a decade back might have taken
    a team of engineers, can now be done by a person sitting in bedroom in just a
    few minutes, thanks to the open source world. At the very same time, there is
    hardware horsepower available to you by which you can literally build a super
    computer in your own home with just a few hundred dollars. We are surrounded by
    problems, some simple and others complex, which are waiting to be solved. The
    only missing chain in the whole process is you: an innovative mind that has the
    capability to exploit these technologies to solve the world''s problems.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处于机器人自动化领域的黄金时代，新产品的开发变得前所未有的简单。十年前可能需要一支工程师团队完成的工作，现在一个人坐在卧室里几分钟就能完成，这要归功于开源世界。与此同时，你能够获得硬件算力，你实际上可以用几百美元在家构建一台超级计算机。我们周围充满了问题，有些简单，有些复杂，都在等待被解决。整个过程中唯一缺失的环节就是你：一个有能力利用这些技术来解决世界问题的创新思维。
- en: To make your mind capable of doing so, we will be starting of by understanding
    the roots and the basics of robotics. The goal of this book is not only to make
    the projects that are mentioned in the book but to make you understand how to
    exploit the resources to build your dream projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的思维能够做到这一点，我们将从理解机器人的根源和基础知识开始。这本书的目标不仅是制作书中提到的项目，还要让你了解如何利用资源来构建你的梦想项目。
- en: 'Finally, I would like to congratulate you on entering this amazing and futuristic
    field at the correct time. I always tell my students a rule, which I would like
    to share with you as well:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想祝贺你们在正确的时间进入这个令人惊叹且充满未来的领域。我总是告诉我的学生一条规则，我也想与你们分享：
- en: First is a scientist
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一是科学家
- en: Second is a researcher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二是研究员
- en: Third is an engineer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三是工程师
- en: Fourth is a technician
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四是技术人员
- en: Last is a mechanic
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是机械师
- en: What it means is that the earlier in the life cycle you enter any field, the
    higher in the hierarchy you can get. The later you come, the harder it is to climb
    to the top.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你越早进入任何领域，你就能在等级上爬得越高。来得越晚，爬到顶部的难度就越大。
- en: 'Enough talking—now let''s get straight to business! We will cover the following
    topics in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 足够说了——现在让我们直接进入正题！在本章中，我们将涵盖以下主题：
- en: The hardware arsenal
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件装备
- en: Setting up Raspberry Pi
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置树莓派
- en: Programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程
- en: Playing with voltage
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转电压
- en: The hardware arsenal
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件装备
- en: 'Talking of robots, there are a few basic tangible components that they are
    made up of, which are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到机器人，它们由一些基本的有形组件组成，以下是一些：
- en: Computing Unit
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单元
- en: Sensors
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器
- en: Actuators
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器
- en: Chassis
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底盘
- en: Power source
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源
- en: Firstly, we will be discussing the microcontroller and, during the course of
    book, we will be discussing the rest of the tangible components in detail as and
    when required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论微控制器，在本书的其余部分，我们将根据需要详细讨论其他有形组件。
- en: Whenever you have been to buy a laptop or a computer, you must have heard the
    word microprocessor. This is the primary unit that has to make all the decisions.
    I call it the *king*, but what is a king without an empire? For the king to work,
    he needs some subordinates that can do the things for him, the same way in which
    the microprocessor needs a few subordinates such as RAM, storage, I/O devices,
    and so on. Now, the problem is that when we put in all these things the overall
    unit gets expensive and bulky. But, as we know, subsequently weight and size are
    very important factors when it comes to robots, so we cannot afford to have a
    big bulky piece of system running a robot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你去买笔记本电脑或电脑时，你一定听说过微处理器这个词。这是必须做出所有决策的主要单元。我称它为“国王”，但国王没有帝国又算什么？为了让国王工作，他需要一些下属来为他做事，就像微处理器需要一些下属，如RAM、存储、I/O设备等。现在的问题是，当我们把这些东西放在一起时，整体单元会变得昂贵且庞大。但正如我们所知，重量和尺寸在机器人领域是非常重要的因素，所以我们不能承受一个庞大的系统来运行机器人。
- en: Hence, we made something called a SoC. Now, this is a one man show as this small
    chip, has all the necessary systems for it to work inside that small little chipset
    itself. So, now you don't need to add RAM or storage or any other thing for it
    to work. These small microcontrollers can get really powerful but a downside is,
    once a manufacturer has made an SoC, thereafter no changes can be done to it.
    The size of storage, RAM, or the I/O cannot be changed. But we generally can live
    with these limitations as when programming the robots, you might not be using
    the entire juice of the microcontroller until the time you are running some serious
    artificial intelligence or machine-learning code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们制造了一种叫做SoC的东西。现在，这是一个一个人的表演，因为这个小小的芯片本身就有所有必要的系统来在它的小芯片组内工作。所以，现在你不需要添加RAM、存储或其他任何东西来让它工作。这些小型的微控制器可以非常强大，但缺点是，一旦制造商制造了SoC，之后就不能对其进行任何更改。存储器的大小、RAM或I/O无法更改。但我们在编程机器人时通常可以接受这些限制，因为在你运行一些严肃的人工智能或机器学习代码之前，你可能不会使用微控制器的全部功能。
- en: One such great piece of hardware is Raspberry Pi. Yes, it sounds very tasty,
    but there is so much more to it. This is a super small yet extremely powerful
    microcontroller. It is often referred to as a prototyping board because of the
    fact that it is used by roboticists everywhere to bring out their ideas and to
    make them a reality in a quick time span. It is available all across the globe
    and is extremely cheap. You can literally stream HD movies, surf the internet,
    and do much more on just a $10 device. I can't think of something as ludicrous
    as this. It is fairly easy to use and you can use Python to program it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派就是这样一件出色的硬件。是的，它听起来非常美味，但它的用途远不止于此。这是一个超级小巧但功能极其强大的微控制器。它通常被称为原型板，因为它被世界各地的机器人学家用来实现他们的想法，并在短时间内将它们变为现实。它在全球范围内都有售，而且非常便宜。你可以在仅10美元的设备上播放高清电影、上网，还能做更多的事情。我想不出有什么比这更荒谬的事情了。它使用起来相当简单，你可以用Python来编程它。
- en: So, basically, it ticks all our boxes. This will be the primary weapon we will
    be using throughout the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，基本上，它满足了我们的所有要求。这将是我们在整本书中使用的首要武器。
- en: 'So let me introduce you to Raspberry Pi! This is what it looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我来向您介绍树莓派！这就是它的样子：
- en: '![](img/a0b482f0-c349-48ca-973a-190a05d01fb0.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0b482f0-c349-48ca-973a-190a05d01fb0.png)'
- en: 'There are various models of Raspberry Pi available on the market. But we will
    be using Raspberry Pi Zero W; this will cost you around $10 and it is easier to
    purchase than a Big Mac burger. Do make sure you buy the Raspberry Pi Zero with
    a W, which supposedly stands for wireless capabilities such as Wi-Fi and Bluetooth.
    There are a few more things that you will have to order or arrange for it to work.
    Here is a list of items:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多种树莓派型号可供选择。但我们将使用树莓派Zero W；这大概需要花费您10美元，而且比巨无霸汉堡更容易购买。请确保您购买的是带有W的树莓派Zero，W代表无线功能，如Wi-Fi和蓝牙。还有一些其他事情您需要订购或安排以使其工作。以下是需要准备的项目列表：
- en: Micro USB to standard USB adapter
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB转标准USB适配器
- en: Keyboard
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘
- en: Mouse
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标
- en: Micro SD memory card, 16 or 32 GB
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro SD存储卡，16或32 GB
- en: Micro SD card reader
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro SD卡读卡器
- en: Micro USB power adapter (2 amp or more)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微型USB电源适配器（2安培或以上）
- en: Micro HDMI to HDMI port
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro HDMI转HDMI端口
- en: Breadboard
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: Bunch of jumper wires (male to male, male to female, and female to female)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堆跳线（公对公、公对母和母对母）
- en: 3V LEDs
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3V LED灯
- en: '![](img/1ef2195d-b8fc-47c6-a201-a77c7bfd7a76.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ef2195d-b8fc-47c6-a201-a77c7bfd7a76.png)'
- en: As you will instantly make out from the image, there is a micro HDMI port onboard,
    over which you can hook up your HD monitor or a TV screen. Second there is a micro
    SD card slot. This will be the primary storage device for this computer. Other
    than that, you will also find two USB sockets and a camera bus. You may think
    this is it, but the best is yet to come. Raspberry Pi has something called **GPIO**,
    which stands for **general purpose input/output**. These are disguised as small
    40 through-hole ports on one corner of the Raspberry Pi; this is what makes it
    super special.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从图片中您会立刻看出，板上有微型HDMI端口，您可以通过它连接高清显示器或电视屏幕。其次是微型SD卡槽。这将作为该电脑的主要存储设备。除此之外，您还会找到两个USB端口和一个摄像头总线。您可能会认为这就结束了，但最好的还在后面。树莓派有一种叫做**GPIO**的东西，代表**通用输入/输出**。这些隐藏在树莓派一角的小型40针通孔端口上；这就是它特别的地方。
- en: Now, conventionally you would attach things to your computer that are compatible
    with it. So, hooking up a mouse, keyboard or a joystick is as easy as inserting
    a USB port, but what if you need to connect your computer to your light bulbs
    or your air-conditioner? Exactly, you can't. That's where GPIO comes in to save
    the day. These are pins which are very useful when it comes to robotics, as these
    can be used to connect various components such as sensors/motors. The beauty of
    these pins is that they can be used as either input or output based on what we
    program them for. So, as we will later see, each of these pins can be defined
    in the program to be either input or output based on our needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照惯例，您会将与电脑兼容的设备连接到电脑上。因此，连接鼠标、键盘或游戏手柄就像插入USB端口一样简单，但您需要将电脑连接到灯泡或空调怎么办？没错，您不能。这就是GPIO发挥作用的时候。这些引脚在机器人技术中非常有用，因为它们可以用来连接各种组件，如传感器/电机。这些引脚的美丽之处在于，根据我们为其编程的方式，它们可以用作输入或输出。因此，正如我们稍后将会看到的，每个引脚都可以根据我们的需求在程序中定义为输入或输出。
- en: 'Now, out of these 40 pins, 26 are GPIO. The rest of the pins are generic power
    or ground ports. There are two more ports called **ID EEPROM** which at this point
    of time we do not require:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这40个引脚中，有26个是GPIO。其余的引脚是通用的电源或地端口。还有两个称为**ID EEPROM**的端口，在这个阶段我们不需要它们：
- en: '![](img/40b46d85-543e-4c57-9314-796e12d6ca43.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40b46d85-543e-4c57-9314-796e12d6ca43.png)'
- en: 'As you can see, Raspberry Pi is capable of giving us two types of power supply:
    3.3V and 5V. These basically cater for most of our purposes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，树莓派可以为我们提供两种类型的电源供应：3.3V和5V。这些基本上满足了我们的大部分需求。
- en: Setting up Raspberry Pi
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置树莓派
- en: We will talk about the GPIO and other things to do with Raspberry Pi in a while.
    Firstly, we will understand how to set up this board for the first time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论GPIO以及与树莓派相关的事项。首先，我们将了解如何首次设置这块板。
- en: The first thing you need to do is to make sure that the operating system of
    Raspberry Pi is ready. I am assuming that you are using a Windows PC, but if you
    are doing it on another OS as well, then there will not be much of a difference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要确保树莓派的操作系统已准备就绪。我假设您正在使用Windows PC，但如果您在其他操作系统上操作，那么差别不会很大。
- en: 'To install the OS, start your PC and follow these steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装操作系统，启动您的PC并按照以下步骤操作：
- en: Go to [www.raspberrypi.org](http://www.raspberrypi.org) and click on DOWNLOADS
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[www.raspberrypi.org](http://www.raspberrypi.org)并点击下载
- en: 'Now click on RASPBIAN, you will see the following two options:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 RASPBIAN，你会看到以下两个选项：
- en: RASPBIAN STRETCH WITH DESKTOP
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RASPBIAN STRETCH WITH DESKTOP
- en: RASPBIAN STRETCH LITE
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RASPBIAN STRETCH LITE
- en: We will be downloading RASPBIAN STRETCH WITH DESKTOP; this will give us the
    GUI interface for Raspberry Pi
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将下载带有桌面的 RASPBIAN STRETCH；这将为我们提供树莓派的图形用户界面。
- en: After downloading, unzip the package into a folder
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，将包解压到一个文件夹中。
- en: Now we need to copy it to the memory card of Raspberry Pi. The memory card over
    which you need to copy must be formatted by low level formatting. There are basically
    two types of formatting. one which simply erases the index the other one which
    we know as low level formatting is the one in which we remove all the data from
    both the index and their physical memory location. There would be a button to
    toggle a low level format. Make sure it is clicked before you format your memory
    card for this function.  I would recommend using the SD card formatter by [www.sdcard.org](http://www.sdcard.org).
    Now open the formatter and you simply have to format it using the 32 KB option.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将其复制到树莓派的内存卡上。你需要复制的内存卡必须通过低级格式化进行格式化。主要有两种格式化类型。一种只是删除索引，另一种我们称之为低级格式化，这种格式化会从索引和它们的物理内存位置中删除所有数据。会有一个按钮来切换低级格式化。确保在格式化内存卡进行此功能之前点击它。我建议使用
    [www.sdcard.org](http://www.sdcard.org) 的 SD 卡格式化工具。现在打开格式化工具，你只需使用 32 KB 选项进行格式化即可。
- en: 'Find more details and more up-to-date information here: [https://www.raspberrypi.org/documentation/installation/installing-images/README.md](https://www.raspberrypi.org/documentation/installation/installing-images/README.md).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里找到更多详细信息和新信息：[https://www.raspberrypi.org/documentation/installation/installing-images/README.md](https://www.raspberrypi.org/documentation/installation/installing-images/README.md)。
- en: Once done, you have to copy the image onto the SD card. The easiest way to do
    that is by using WinDisk Imager. You can download it online without any problems.
    Then simply select the image and the location on your SD card and start copying
    the image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你必须将镜像复制到 SD 卡上。最简单的方法是使用 WinDisk Imager。你可以在网上无任何问题地下载它。然后只需选择镜像和 SD 卡上的位置，然后开始复制镜像。
- en: This could take a few minutes. After it is done, your SD will be ready. Plug
    it into Raspberry Pi and we will be ready to power it up. But before you power
    it up, plug in your monitor using the Micro HDMI to HDMI wire, connect the keyboard
    and mouse to Raspberry Pi using the Micro USB, and power it up by using the Micro
    USB adapter to standard USB adapter. Now, use the other USB port on Raspberry
    Pi to power it up using the micro USB power adapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几分钟。完成后，你的 SD 卡就准备好了。将其插入树莓派，我们就可以准备供电了。但在供电之前，请使用 Micro HDMI 到 HDMI 线连接显示器，使用
    Micro USB 线将键盘和鼠标连接到树莓派，并使用 Micro USB 到标准 USB 适配器供电。现在，使用树莓派的另一个 USB 端口，通过 micro
    USB 供电适配器供电。
- en: Once you start it up, you will see a boot-up screen and within a few seconds
    you will be able to see the desktop. So, finally, our Raspberry Pi is up and running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，你将看到启动屏幕，几秒钟后你将能够看到桌面。所以，最终，我们的树莓派已经启动并运行。
- en: Go ahead and explore a few options, surf the internet, look at some cat videos
    on YouTube, and get yourself familiar with this mighty device.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，探索一些选项，上网冲浪，在 YouTube 上看看一些猫咪视频，让自己熟悉这个强大的设备。
- en: By now, you must already be appreciating the power of Raspberry Pi. It may be
    slightly slower than your average computer. But, come on, this thing costs just
    $10!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你一定已经欣赏到了树莓派的强大功能。它可能比你的普通电脑稍慢一些。但是，看在它只需 10 美元的份上，不是吗！
- en: Let's program
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始编程。
- en: In this chapter, we will get you familiar with Python and how you can use the
    GPIOs on this device. To do this, go ahead and click on the Raspberry icon in
    the top left-hand corner. You will see the Python console 3.0\. There could be
    an older version of Python as well. We will be using the newer version in this
    book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将让你熟悉 Python 以及如何使用此设备上的 GPIO。为此，请点击左上角的树莓派图标。你会看到 Python 控制台 3.0。可能还有更旧的
    Python 版本。在这本书中，我们将使用较新版本。
- en: Once the window opens, you will see the playground where you would be doing
    the coding. So now we are ready to write the first code for Python Robotics. Now
    let's see how it's done.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口打开后，你会看到编码的游乐场。所以现在我们准备好编写 Python 机器人的第一段代码了。现在让我们看看它是如何完成的。
- en: 'The first thing we will write is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要写的第一件事是：
- en: '![](img/5ee664a7-351f-4b9c-bbca-c5557b1e4b10.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ee664a7-351f-4b9c-bbca-c5557b1e4b10.png)'
- en: Almost all of the time when we start writing a program, we will start by writing
    the preceding line. Now, before we understand what it does, we need to understand
    libraries. Often while we are writing code, we will have to write the code again
    and again in multiple places. This takes a lot of time and certainly is not cool!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每次我们开始编写程序时，我们都会从编写前面的行开始。现在，在我们理解它做什么之前，我们需要了解库。在编写代码时，我们经常需要在多个地方重复编写相同的代码。这花费了很多时间，当然也不酷！
- en: So, to solve this problem, we created functions. A function is a miniature program
    that we might think would be used over and over again. In this miniature program
    itself, we also mention what it would be called.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们创建了函数。一个函数可能是一个我们可能会反复使用的迷你程序。在这个迷你程序本身中，我们也提到了它的调用方式。
- en: Let's say that there is a code in which we need to multiply two numbers again
    and again. So, what we do is we write the code once and make it a function. We
    also name this function `Multiply`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个代码，我们需要反复乘以两个数字。所以我们做的是，我们只编写一次代码，并将其制作成一个函数。我们还把这个函数命名为`Multiply`。
- en: So now, whenever we need to multiply two numbers, we don't have to write its
    code again; rather, we simply have to call the function to do it for us instead
    of writing the code to multiply. The problem is, how do we tell which number has
    to be multiplied?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们需要乘以两个数字时，我们不必再次编写它的代码；相反，我们只需调用函数来为我们执行，而不是编写乘法的代码。问题是，我们如何知道哪个数字需要相乘？
- en: There is a solution to that as well. As you might see later, whenever a function
    is called we put opening and closing brackets after it, such as `multiply()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题也有解决方案。正如你可能会看到的，每次调用函数时，我们都会在它后面放一对开括号和闭括号，例如`multiply()`。
- en: If the brackets are empty that means no user input has been given. If, for example,
    we have to multiply `2` and `3` we simply write `Multiply(2,3)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果括号是空的，这意味着没有提供用户输入。例如，如果我们需要乘以`2`和`3`，我们只需编写`Multiply(2,3)`。
- en: We are giving the input as `2` and `3`. The position of the input in the brackets
    is also important as the position in the brackets will define where in the program
    it will go.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入设置为`2`和`3`。输入在括号中的位置也很重要，因为括号中的位置将定义它在程序中的位置。
- en: 'Now, let''s say you make functions such as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你创建了以下函数：
- en: Add
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加
- en: Subtract
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减
- en: Multiply
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘
- en: Divide
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除
- en: Say you stack them together. Then the pile of functions grouped together will
    be called a library. These libraries can have hundreds of functions. There are
    some functions which are already in the Python language so that the job is made
    simpler for the programmers. Others can be defined as open source or developed
    by you at your convenience.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你把它们堆叠在一起。那么这些组合在一起的函数堆栈将被称为库。这些库可以有数百个函数。有些函数已经包含在Python语言中，这样就可以简化程序员的任务。其他可以定义为开源或根据您的方便开发。
- en: Now, getting back to the point. We are calling the library `RPi.GPIO`; this
    is a library defined by Raspberry Pi. This will have functions that will make
    your life easier when it comes to programming Raspberry Pi. So, in the program,
    once we call the library, all the functions are at your disposal and ready to
    be used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到正题。我们正在调用库`RPi.GPIO`；这是一个由树莓派定义的库。这个库将包含一些函数，这些函数可以让您在编程树莓派时生活更轻松。因此，在程序中，一旦我们调用库，所有函数都可供您使用，随时可以使用。
- en: In the next line, we write `Import.time`. As you must have guessed, this is
    used to import a library time. What it does we will learn shortly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们编写`Import.time`。正如你可能已经猜到的，这是用来导入时间库的。我们将在稍后了解它做什么。
- en: 'The next line of code would be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码如下：
- en: '![](img/04d103ee-4ac2-428e-b240-2ca07db3a80c.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04d103ee-4ac2-428e-b240-2ca07db3a80c.png)'
- en: Before we understand what it does, let's learn a bit more about GPIOs. These
    pins are hard numbered according to their physical positions in Raspberry Pi.
    However, we can change the numbering of the pins in the software for our understanding
    and convenience. But in this code, we will not be playing around with this and
    will set it do the default set by Broadcom, which is the manufacturer of the microcontroller
    of Raspberry Pi.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解它做什么之前，让我们先了解一下GPIOs。这些引脚根据它们在树莓派中的物理位置进行硬编码。然而，我们可以为了我们的理解和方便在软件中更改引脚的编号。但在本代码中，我们不会玩弄这个，并将它设置为Broadcom默认设置，Broadcom是树莓派微控制器的制造商。
- en: This line uses a function of the `RPi.GPIO` library called `setmode`. What this
    function does is that it sets the pin configuration of the `setmode` to (`GPIO.BCM`)—`BCM`
    is further a function of `GPIO`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用了`RPi.GPIO`库中的一个名为`setmode`的函数。这个函数的作用是将`setmode`的引脚配置设置为(`GPIO.BCM`)——`BCM`是`GPIO`的一个函数。
- en: 'Now we can use the base pin configuration. Further to this, a specialty of
    the GPIO pins is that it can be used both as input and output. But the only condition
    is that we have to specify whether it has to be used as input or output in the
    program itself. It cannot do both functions at the same time. Here is how it is
    done:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用基本的引脚配置。此外，GPIO引脚的一个特点是它们既可以作为输入使用，也可以作为输出使用。但唯一条件是我们必须在程序中指定它是要作为输入还是输出使用。它不能同时执行这两个功能。下面是如何实现的：
- en: '![](img/8fc5f7fb-b56d-404c-b9e5-6f38d322e7af.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fc5f7fb-b56d-404c-b9e5-6f38d322e7af.png)'
- en: 'The next line of code will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码将是以下内容：
- en: '![](img/ca124df5-bb63-41f3-9ec2-79831c3de69d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca124df5-bb63-41f3-9ec2-79831c3de69d.png)'
- en: Again, we are using a function of the library `GPIO` called `output`. What this
    does is that it sets up a specific pin of the board in a state which we want.
    So, here we have mentioned that the pin number `23` has to be set high. Just for
    the sake of clarity, high means on and low means off.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在使用库`GPIO`中的一个名为`output`的函数。这个函数的作用是设置板上的特定引脚到我们想要的状态。所以，在这里我们提到引脚号`23`需要设置为高电平。为了清晰起见，高电平表示开启，低电平表示关闭。
- en: 'The next line of code will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码将是以下内容：
- en: '![](img/fa89f23f-8885-4930-904a-fc5963aabb32.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa89f23f-8885-4930-904a-fc5963aabb32.png)'
- en: In this line, we are using a function from the library time. The function sleep
    basically freezes the state of all the GPIO pins. So, for example, if the pin
    `23` is high then it will remain high until the `time` the function `sleep` is
    executed. In the function `sleep`, we have defined the value as `3` seconds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们使用了来自`time`库的函数。`sleep`函数基本上冻结了所有GPIO引脚的状态。例如，如果引脚`23`处于高电平，那么它将保持高电平状态，直到`sleep`函数执行。在`sleep`函数中，我们定义的值是`3`秒。
- en: Hence, for 3 seconds, the pin state of Raspberry Pi will remain as it was before
    this line of code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在3秒钟内，树莓派的引脚状态将保持在这条代码之前的状态。
- en: 'Finally, the last line of the code will be:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码的最后一行将是：
- en: '![](img/9bdfa216-7f84-4710-b216-5d5255de8cc0.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bdfa216-7f84-4710-b216-5d5255de8cc0.png)'
- en: This will be a common sight after every program. This function of the GPIO library
    will reset the state of every pin that has been used in the program—the state
    of all the pins will be low. Remember, it will only affect the pins that are used
    in the program and not any other pins. So, for example, we have used the pin `23`
    in the program, so it will only affect pin `23` and not any other pin in Raspberry
    Pi.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是每个程序之后的常见场景。GPIO库的这个函数将重置程序中使用的每个引脚的状态——所有引脚的状态都将变为低电平。记住，它只会影响程序中使用的引脚，而不会影响其他引脚。例如，我们在程序中使用了引脚`23`，所以它只会影响引脚`23`，而不会影响树莓派上的其他任何引脚。
- en: 'Finally, your program will look something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你的程序看起来可能像这样：
- en: '![](img/52d7dbc0-17c5-4852-ab00-a6ad17c14f6d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52d7dbc0-17c5-4852-ab00-a6ad17c14f6d.png)'
- en: Now, one thing that you must remember is that whatever code we are writing will
    be executed one line after the other. So, let's say we keep `import RPI.GPIO as
    GPIO` at the bottom, then the whole program will not work. Why? Because as soon
    as it goes to `GPIO.setmode(GPIO.BCM)` it will not understand what `GPIO` is,
    neither will it understand what `setmode` is. Hence, we always import the libraries
    as soon as we start writing the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件事你必须记住，我们正在编写的代码将逐行执行。所以，如果我们把`import RPI.GPIO as GPIO`放在底部，整个程序将不会工作。为什么？因为一旦执行到`GPIO.setmode(GPIO.BCM)`，它将不理解`GPIO`是什么，也不会理解`setmode`是什么。因此，我们总是在开始编写代码时导入库。
- en: 'Now, working on the same concept, it will execute the program in the following
    way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于同样的概念，它将以以下方式执行程序：
- en: '`GPIO.out(23,GPIO.High)`: It will turn pin `23` high/on'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO.out(23,GPIO.High)`: 它将使引脚`23`处于高电平/开启状态'
- en: '`time.sleep(3)`: It will wait for 3 seconds while pin is still high'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.sleep(3)`: 当引脚仍然处于高电平时，它将等待3秒钟'
- en: '`GPIO.cleanup()`: Finally, it will set the state of the pin `23` to low'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO.cleanup()`: 最后，它将引脚`23`的状态设置为低电平'
- en: Now, to see whether the program is working, let's attach some hardware to check
    whether what we have written is actually happening.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查程序是否正常工作，让我们连接一些硬件来检查我们所写的是否真的发生了。
- en: I am assuming that readers are already aware of how breadboard is used. If you
    are not familiar with it, just go ahead and google it. It will take 5 minutes
    to understand. It is super easy and will come in handy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设读者已经了解面包板的使用方法。如果你不熟悉它，只需继续前进并谷歌一下。理解它只需要5分钟，非常简单，而且会很有用。
- en: Now go ahead and connect the LED on breadboard, then connect the ground of the
    LED to the ground pin in Raspberry Pi, and set the positive/VCC to pin number
    `23` (refer the pin diagram).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续连接面包板上的LED，然后将LED的接地连接到树莓派的接地引脚，并将正极/VCC连接到引脚号`23`（参考引脚图）。
- en: 'You can also refer to the following diagram:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以参考以下图表：
- en: '![](img/a489f447-7e48-4843-a88e-aee2c71abb39.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a489f447-7e48-4843-a88e-aee2c71abb39.png)'
- en: Once you are done, go ahead run the code and see what happens!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，继续运行代码并看看会发生什么！
- en: 'The LED will glow for 3 seconds and then turn back off again, exactly as we
    expected it to do. Now let''s just play around with the code and do a slight modification.
    This time, we will add a few more lines marked in bold:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: LED将亮3秒，然后再次关闭，正如我们预期的那样。现在让我们只是稍微修改一下代码。这次，我们将添加一些用粗体标记的行：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before understanding what's inside the code, you will notice that not every
    line is aligned, they have been intended. What does this mean ?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解代码内部的内容之前，你会注意到并不是每一行都对齐，它们是有意为之的。这意味着什么？
- en: A line indented together with other lines of code is called a block. So for
    example if you have a statement such as
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他代码行缩进在一起的行称为代码块。例如，如果你有一个如下所示的语句
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now in this line lets see how the code will run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这一行代码是如何运行的。
- en: A while true loop would run, this will run the code that is inside it i.e.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`while true`循环将会运行，这将运行它内部的代码，即：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thereafter the code `for I in range (3):` would run. It will run the code inside
    the for loop until the value of `I` is in range, Hence the code below would run.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，代码`for I in range (3):`将会运行。它将运行for循环内的代码，直到`I`的值在范围内，因此下面的代码将会运行。
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above code can be referred to a block of code, which is inside the `for`
    loop. The block of code can be made by indenting the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以参考一个位于`for`循环内部的代码块。可以通过缩进代码来创建代码块。
- en: 'Now, let''s see what it does. `While True` is a loop, it will run the `for`
    loop inside it again and again until the time the condition is not false. The
    condition we are using here is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它会做什么。`While True`是一个循环，它将反复运行它内部的`for`循环，直到条件不为假。我们在这里使用的条件是：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The maximum range is `3` and every time the statement runs it increments the
    value of the `i` by `+1`. So it basically acts as a counter. Let's see what the
    program will actually do.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最大范围是`3`，每次执行该语句时，都会将`i`的值增加`+1`。所以它基本上充当一个计数器。让我们看看程序实际上会做什么。
- en: It will check for the value of `i` and increment it by `1` thereafter. As the
    code progresses, it will glow the LED high for 0.5 seconds and then shut it off
    for 0.5 seconds. And then it will wait for 1 second. This will repeat until the
    while loop is false, as in the value of `i` becomes greater than `3` where it
    would get out of the program and terminate. Run the program and see if it actually
    happens.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它将检查`i`的值，并将其增加`1`。随着代码的执行，它将LED高亮0.5秒，然后关闭0.5秒。然后它将等待1秒。这将重复，直到while循环为假，即`i`的值大于`3`，此时它会退出程序并终止。运行程序并看看是否真的发生了。
- en: By now, you understand how easy the programming is in Raspberry Pi. To go a
    step further, we will make another program and make some changes to the hardware.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解了在树莓派上编程是多么简单。为了更进一步，我们将创建另一个程序并对硬件进行一些更改。
- en: We will be connecting five more LEDs from pin numbers 7 through to 12\. We will
    make them switch on and off in a pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从7号引脚连接到12号引脚的五个更多LED。我们将使它们按照一定模式开关。
- en: 'Once connected, we will write the code as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 连接完成后，我们将按照以下方式编写代码：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the code is fairly simple. Let''s see what it means:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码相当简单。让我们看看它的含义：
- en: '![](img/6019e3ef-2d79-43cc-9116-b0ae31bcfd98.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6019e3ef-2d79-43cc-9116-b0ae31bcfd98.png)'
- en: Before I tell you something more about the code, let's go ahead and run it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告诉你更多关于代码的信息之前，让我们先运行它。
- en: When you run it, you will understand that as per the statement it is addressing
    the pins one by one and switching them to high after every 1 second.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会理解按照语句，它正在逐个处理引脚，并在每1秒后将它们切换到高电平。
- en: Playing with voltage
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转电压
- en: So far so good! But did you notice one thing? We have been using Raspberry Pi
    as a switch—simply switching the various components on and off. But what if we
    need to vary the intensity of the LEDs that we have just programmed? Is it possible? The
    answer is no. But we can still get it done somehow!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！但你注意到一件事吗？我们一直在使用树莓派作为开关——简单地打开和关闭各种组件。但如果我们需要调整我们刚刚编程的LED的亮度呢？这是可能的吗？答案是：不可能。但我们仍然可以设法做到！
- en: Let's see how. Computers work in binary which means that they can represent
    either `0` or `1`. This is because of the fact that the primary computing unit
    in any system is based on a transistor which can either be on or off representing
    `0` or `1`. So, if we see this technically, computers are only capable of switching
    due to the binary architecture. However, there is a trick. This trick is called
    **pulse width modulation** (**PWM**).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何实现的。计算机以二进制方式工作，这意味着它们可以表示`0`或`1`。这是因为任何系统中的主要计算单元都是基于晶体管，晶体管可以是开启的或关闭的，分别代表`0`或`1`。所以，如果我们从技术上看待这个问题，计算机只能因为二进制架构而切换。然而，有一个技巧。这个技巧被称为**脉冲宽度调制**（**PWM**）。
- en: 'Now, before I explain any of it in detail, let''s go ahead plug in an LED on
    pin number `18`, then copy this code into Raspberry Pi and run it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我详细解释任何内容之前，我们先在`18`号引脚上插入一个LED，然后将此代码复制到树莓派上并运行：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What did you notice? The LED will be blinking at once a second. Now let's tweak
    it a bit and change the `PWM(18,1)` to `PWM(18,5)`. Let's run and see what happens.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？LED现在每秒闪烁一次。现在让我们稍作调整，将`PWM(18,1)`改为`PWM(18,5)`。让我们运行并看看会发生什么。
- en: You will have noticed that it is now blinking five times in a second. So the
    number `5` is basically representing the frequency as the LED is now flickering
    five times in a second. Now, again, rewrite the code and increase `5` to `50`.
    Once you increase it to `50`, it switches the LED on and off 50 times in a second
    or at 50 Hertz. So, it appears to you as if it is always on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到现在它每秒闪烁五次。所以数字`5`基本上代表了频率，因为LED现在每秒闪烁五次。现在，再次重写代码并将`5`增加到`50`。一旦增加到`50`，LED每秒开关50次，即50赫兹。所以，它看起来像是始终开启的。
- en: Now comes the interesting part. Go over to your code and change `duty_cycle
    = 50` to `duty_cycle = 10`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。回到你的代码，将`duty_cycle = 50`改为`duty_cycle = 10`。
- en: What did you notice? You must have seen that the LED is now glowing way lower
    in intensity. In fact, it will be half of what it originally was.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？你必须已经看到LED现在发光的强度大大降低。实际上，它将是原来的二分之一。
- en: 'Let''s see what is actually happening:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际上发生了什么：
- en: '![](img/d096bb71-0cd9-4ef1-b876-e4dea3f58085.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d096bb71-0cd9-4ef1-b876-e4dea3f58085.png)'
- en: 'As you can make out from the diagram, the function is basically creating a
    pulse, the characteristics of which we are changing. The first characteristic
    is the frequency, the pulses generated in a second. In the code line `pwm= GPIO.PWM(18,1)` ,
    we are basically telling the microcontroller to generate one pulse every second
    on pin number `1`. In the second line, duty cycle is a percent value. It determines
    for how much percent of the time the pulse will be high. For the rest of the time
    of the pulse the output of the pin will be off. So, for the following code, the
    below bulleted points would be the characteristics:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，该函数基本上是在创建一个脉冲，我们正在改变其特性。第一个特性是频率，即每秒产生的脉冲数。在代码行`pwm= GPIO.PWM(18,1)`中，我们基本上是在告诉微控制器在`1`号引脚上每秒产生一个脉冲。在第二行中，占空比是一个百分比值。它决定了脉冲高电平的时间占多少百分比。在脉冲的其余时间内，引脚的输出将是关闭的。因此，对于以下代码，以下要点将是特性：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Time/width of every pulse is 1 second
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个脉冲的时间/宽度是1秒
- en: Percent of time it would on is 50%
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开启的时间百分比是50%
- en: Percent of time it would be off is 50%
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭的时间百分比是50%
- en: Time it would be on is 0.5 seconds
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开启的时间是0.5秒
- en: Time it would be off is 0.5 seconds
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭的时间是0.5秒
- en: When we increase the frequency more than 50 hertz then it is very hard for the
    human eye to make out if it is actually switching on or off. Theoretically, for
    50% of the time the pin will remain high, and for the rest of the time it will
    be low. So, if we take an average then we can easily say that the overall voltage
    would be half of the original. Using this method, we can modulate the voltage
    output of any pin as per our requirements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将频率增加到超过50赫兹时，人眼很难分辨出它实际上是开启还是关闭。理论上，50%的时间引脚将保持高电平，其余时间将保持低电平。因此，如果我们取平均值，我们就可以轻松地说整体电压将是原始电压的一半。使用这种方法，我们可以根据我们的需求调节任何引脚的电压输出。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now you must have understood how the GPIOs can be used as output and how, by
    applying conditions, we can change their behaviors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经理解了如何将GPIO用作输出，以及通过应用条件如何改变它们的行为。
- en: In the next chapter, we will understand how these pins can be used as input
    as well. So come back, and see you there!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解这些引脚也可以用作输入。所以请回来，我们那里见！
