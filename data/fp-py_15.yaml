- en: Chapter 15. A Functional Approach to Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。面向Web服务的功能性方法
- en: We'll step away from Exploratory Data Analysis and look closely at web servers
    and web services. These are, to an extent, a cascade of functions. We can apply
    a number of functional design patterns to the problem of presenting web content.
    Our goal is to look at ways in which we can approach **Representational State
    Transfer** (**REST**). We want to build RESTful web services using functional
    design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将远离探索性数据分析，而是仔细研究Web服务器和Web服务。在某种程度上，这些都是一系列函数。我们可以将许多函数设计模式应用于呈现Web内容的问题上。我们的目标是探索我们可以使用**表述状态转移**（**REST**）的方式。我们希望使用函数设计模式构建RESTful
    Web服务。
- en: We don't need to invent yet another Python web framework; there are plenty of
    frameworks to choose from. We'll avoid creating a large, general-purpose solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要再发明另一个Python Web框架；有很多框架可供选择。我们将避免创建一个庞大的通用解决方案。
- en: We don't want to select among the available frameworks, either. There are many,
    each with a distinct set of features and advantages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在可用的框架中进行选择。每个框架都有不同的特性和优势。
- en: We'll present some principles that can be applied to most of the available frameworks.
    We should be able to leverage functional design patterns for presenting web content.
    This will allow us to build web-based applications that have the advantages of
    a functional design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提出一些可以应用于大多数可用框架的原则。我们应该能够利用功能设计模式来呈现Web内容。这将使我们能够构建具有功能设计优势的基于Web的应用程序。
- en: For example, when we look at extremely large datasets, or extremely complex
    datasets, we might want a web service which supports subsetting or searching.
    We might want a web site which can download subsets in a variety of formats. In
    this case, we might need to use functional designs to create RESTful web services
    to support these more sophisticated requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们查看极大的数据集或极复杂的数据集时，我们可能需要一个支持子集或搜索的Web服务。我们可能需要一个能够以各种格式下载子集的网站。在这种情况下，我们可能需要使用功能设计来创建支持这些更复杂要求的RESTful
    Web服务。
- en: The most complex web applications often have stateful sessions that make the
    site easier to use. The session information is updated with data provided via
    HTML forms or fetched from databases, or recalled from caches of previous interactions.
    While the overall interaction involves state changes, the application programming
    can be largely functional. Some of the application functions can be non-strict
    in their use of request data, cache data, and database objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的Web应用程序通常具有使网站更易于使用的有状态会话。会话信息通过HTML表单提供的数据更新，或者从数据库中获取，或者从以前的交互的缓存中获取。虽然整体交互涉及状态更改，但应用程序编程可以在很大程度上是功能性的。一些应用程序函数在使用请求数据、缓存数据和数据库对象时可能是非严格的。
- en: 'In order to avoid details of a specific web framework, we''ll focus on the
    **Web Server Gateway Interface** (**WSGI**) design pattern. This will allow us
    to implement a simple web server. A great deal of information is present at the
    following link:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免特定Web框架的细节，我们将专注于**Web服务器网关接口**（**WSGI**）设计模式。这将使我们能够实现一个简单的Web服务器。以下链接提供了大量信息：
- en: '[http://wsgi.readthedocs.org/en/latest/](http://wsgi.readthedocs.org/en/latest/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wsgi.readthedocs.org/en/latest/](http://wsgi.readthedocs.org/en/latest/)'
- en: Some important background of WSGI can be found at
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WSGI的一些重要背景信息可以在以下链接找到：
- en: '[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/)'
- en: We'll start by looking at the HTTP protocol. From there, we can consider servers
    such as Apache httpd to implement this protocol and see how `mod_wsgi` becomes
    a sensible extension to a base server. With this background, we can look at the
    functional nature of WSGI and how we can leverage functional design to implement
    sophisticated web search and retrieval tools.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从HTTP协议开始。然后，我们可以考虑诸如Apache httpd之类的服务器来实现此协议，并了解`mod_wsgi`如何成为基本服务器的合理扩展。有了这些背景，我们可以看看WSGI的功能性质以及如何利用功能设计来实现复杂的Web搜索和检索工具。
- en: The HTTP request-response model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求-响应模型
- en: 'The essential HTTP protocol is, ideally, stateless. A user agent or client
    can take a functional view of the protocol. We can build a client using the `http.client`
    or `urllib` library. An HTTP user agent essentially executes something similar
    to the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的HTTP协议理想上是无状态的。用户代理或客户端可以从功能性的角度看待协议。我们可以使用`http.client`或`urllib`库构建客户端。HTTP用户代理基本上执行类似于以下内容的操作：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A program like **wget** or **curl** does this at the command line; the URL is
    taken from the arguments. A browser does this in response to the user pointing
    and clicking; the URL is taken from the user's actions, in particular, the action
    of clicking on linked text or images.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像**wget**或**curl**这样的程序在命令行上执行此操作；URL是从参数中获取的。浏览器响应用户的指向和点击执行此操作；URL是从用户的操作中获取的，特别是点击链接文本或图像的操作。
- en: The practical considerations of the internetworking protocols, however, lead
    to some implementation details which are stateful. Some of the HTTP status codes
    indicate that an additional action on the part of the user agent is required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，互联网协议的实际考虑导致了一些有状态的实现细节。一些HTTP状态代码表明用户代理需要额外的操作。
- en: Many status codes in the 3xx range indicate that the requested resource has
    been moved. The user agent is then required to request a new location based on
    information sent in the `Location` header. The 401 status code indicates that
    authentication is required; the user agent can respond with an authorization header
    that contains credentials for access to the server. The `urllib` library implementation
    handles this stateful overhead. The `http.client` library doesn't automatically
    follow 3xx redirect status codes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx范围内的许多状态代码表示所请求的资源已经移动。然后，用户代理需要根据`Location`头部中发送的信息请求新的位置。401状态代码表示需要进行身份验证；用户代理可以响应一个包含访问服务器的凭据的授权头部。`urllib`库的实现处理这种有状态的开销。`http.client`库不会自动遐射3xx重定向状态代码。
- en: The techniques for a user agent to handle 3xx and 401 codes aren't deeply stateful.
    A simple recursion can be used. If the status doesn't indicate a redirection,
    it is the base case, and the function has a result. If redirection is required,
    the function can be called recursively with the redirected address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理处理3xx和401代码的技术并不是深度有状态的。可以使用简单的递归。如果状态不表示重定向，那么它是基本情况，函数有一个结果。如果需要重定向，可以使用重定向地址递归调用函数。
- en: 'Looking at the other end of the protocol, a static content server should also
    be stateless. There are two layers to the HTTP protocol: the TCP/IP socket machinery
    and a higher layer HTTP structure that depends on the lower level sockets. The
    lower level details are handled by the `scoketserver` library. The Python `http.server`
    library is one of the libraries that provide a higher level implementation.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议的另一端，静态内容服务器也应该是无状态的。HTTP协议有两个层次：TCP/IP套接字机制和依赖于较低级别套接字的更高级别的HTTP结构。较低级别的细节由`scoketserver`库处理。Python的`http.server`库是提供更高级别实现的库之一。
- en: 'We can use the `http.server` library as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`http.server`库如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We created a server object, and assigned it to the `httpd` variable. We provided
    the address and port number to which we'll listen for connection requests. The
    TCP/IP protocol will spawn a connection on a separate port. The HTTP protocol
    will read the request from this other port and create an instance of the handler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个服务器对象，并将其分配给`httpd`变量。我们提供了地址和端口号，以便监听连接请求。TCP/IP协议将在一个单独的端口上生成一个连接。HTTP协议将从这个其他端口读取请求并创建一个处理程序的实例。
- en: In this example, we provided `SimpleHTTPRequestHandler` as the class to instantiate
    with each request. This class must implement a minimal interface, which will send
    headers and then send the body of the response to the client. This particular
    class will serve files from the local directory. If we wish to customize this,
    we can create a subclass, which implements methods such as `do_GET()` and `do_POST()`
    to alter the behavior.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了`SimpleHTTPRequestHandler`作为每个请求实例化的类。这个类必须实现一个最小的接口，它将发送头部，然后将响应的主体发送给客户端。这个特定的类将从本地目录中提供文件。如果我们希望自定义这个，我们可以创建一个子类，实现`do_GET()`和`do_POST()`等方法来改变行为。
- en: Often, we use the `serve_forever()` method instead of writing our own loop.
    We've shown the loop here to clarify that the server must, generally, be crashed.
    If we want to close the server down politely, we'll require some way in which
    we can change the value of the `shutdown` variable. The *Ctrl + C* signal, for
    example, is commonly used for this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`serve_forever()`方法而不是编写自己的循环。我们在这里展示循环是为了澄清服务器通常必须崩溃。如果我们想要礼貌地关闭服务器，我们将需要一些方法来改变`shutdown`变量的值。例如，*Ctrl
    + C*信号通常用于这个目的。
- en: Injecting a state via cookies
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过cookie注入状态
- en: The addition of cookies changes the overall relationship between a client and
    server to become stateful. Interestingly, it involves no change to the HTTP protocol
    itself. The state information is communicated via headers on the request and the
    reply. The user agent will send cookies in request headers that match the host
    and path. The server will send cookies to the user agent in response headers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 添加cookie改变了客户端和服务器之间的整体关系，使其变得有状态。有趣的是，这并没有改变HTTP协议本身。状态信息通过请求和回复的头部进行通信。用户代理将在请求头中发送与主机和路径匹配的cookie。服务器将在响应头中向用户代理发送cookie。
- en: The user agent or browser must, therefore, retain a cache of cookie values and
    include appropriate cookies in each request. The web server must accept cookies
    in the request header and send cookies in the response header. The web server
    doesn't need to cache cookies. A server merely uses cookies as additional arguments
    in a request and additional details in a response.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户代理或浏览器必须保留cookie值的缓存，并在每个请求中包含适当的cookie。Web服务器必须接受请求头中的cookie，并在响应头中发送cookie。Web服务器不需要缓存cookie。服务器仅仅将cookie作为请求中的附加参数和响应中的附加细节。
- en: While a cookie can, in principle, contain almost anything, the use of cookies
    has rapidly evolved to contain just an identifier for a session state object.
    The server can then use the cookie information to locate session state in some
    kind of persistent storage. This means the server can also update the session
    state based on user agent requests. It also means the server can discard sessions
    which are old.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然cookie原则上可以包含几乎任何内容，但是cookie的使用已经迅速发展为仅包含会话状态对象的标识符。服务器可以使用cookie信息来定位某种持久存储中的会话状态。这意味着服务器还可以根据用户代理请求更新会话状态。这也意味着服务器可以丢弃旧的会话。
- en: The concept of a "session" exists outside the HTTP protocol. It is commonly
    defined as a series of requests with the same session cookie. When an initial
    request is made, no cookie is available, and a new session is created. Every subsequent
    request would include the cookie. The cookie would identify the session state
    object on the server; this object would have the information required by the server
    to provide consistent web content gracefully.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “会话”的概念存在于HTTP协议之外。它通常被定义为具有相同会话cookie的一系列请求。当进行初始请求时，没有cookie可用，会创建一个新的会话。随后的每个请求都将包括该cookie。该cookie将标识服务器上的会话状态对象；该对象将具有服务器提供一致的Web内容所需的信息。
- en: The REST approach to web services, however, does not rely on cookies. Each REST
    request is distinct and does not fit into an overall session framework. This makes
    it less "user-friendly" than an interactive site that uses cookies to simplify
    a user's interactions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST方法对Web服务不依赖于cookie。每个REST请求都是独立的，不适用于整体会话框架。这使得它比使用cookie简化用户交互的交互式站点不那么“用户友好”。
- en: This also means that each individual REST request is, in principle, separately
    authenticated. In many cases, a simple token is generated by the server to avoid
    the client sending more complex credentials with every request. This leads to
    having the REST traffic secured using **Secured Socket Layer** (**SSL**) protocols;
    the `https` scheme is then used instead of `http`. We'll call both schemes HTTP
    throughout this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着每个单独的REST请求原则上是单独进行身份验证的。在许多情况下，服务器会生成一个简单的令牌，以避免客户端在每个请求中发送更复杂的凭据。这导致REST流量使用**安全套接字层**（**SSL**）协议进行安全处理；然后使用`https`方案而不是`http`。在本章中，我们将统称这两种方案为HTTP。
- en: Considering a server with a functional design
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑具有功能设计的服务器
- en: 'One core idea behind HTTP is that the daemon''s response is a function of the
    request. Conceptually, a web service should have a top-level implementation that
    can be summarized as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的一个核心理念是守护程序的响应是请求的函数。从概念上讲，一个Web服务应该有一个可以总结如下的顶层实现：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, this is impractical. It turns out that an HTTP request isn't a simple,
    monolithic data structure. It actually has some required parts and some optional
    parts. A request may have headers, there's a method and a path, and there may
    be attachments. The attachments may include forms or uploaded files or both.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是不切实际的。事实证明，HTTP请求并不是一个简单的、整体的数据结构。它实际上有一些必需的部分和一些可选的部分。一个请求可能有头部，有一个方法和一个路径，还可能有附件。附件可能包括表单或上传的文件或两者都有。
- en: To make things more complex, a browser's form data can be sent as a query string
    in the path of a `GET` request. Alternatively, it can be sent as an attachment
    to a `POST` request. While there's a possibility for confusion, most web application
    frameworks will create HTML form tags that provide their data via a "`method=POST`"
    statement in the `<form>` tag; the form data will then be an attachment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让事情变得更加复杂的是，浏览器的表单数据可以作为一个查询字符串发送到`GET`请求的路径中。或者，它可以作为`POST`请求的附件发送。虽然存在混淆的可能性，但大多数Web应用程序框架将创建HTML表单标签，通过`<form>`标签中的"`method=POST`"语句提供它们的数据；然后表单数据将成为一个附件。
- en: Looking more deeply into the functional view
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更深入地观察功能视图
- en: 'Both HTTP response and request have headers and a body. The request can have
    some attached form data. Therefore, we can think of a web server like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应和请求都有头部和正文。请求可以有一些附加的表单数据。因此，我们可以将Web服务器看作是这样的：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The request headers may include cookie values, which can be seen as adding yet
    more arguments. Additionally, a web server is often dependent on the OS environment
    in which it's running. This OS environment data can be considered as yet more
    arguments being provided as part of the request.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头可能包括cookie值，这可以被视为添加更多参数。此外，Web服务器通常依赖于其运行的操作系统环境。这个操作系统环境数据可以被视为作为请求的一部分提供的更多参数。
- en: There's a large but reasonably well defined spectrum of content. The **Multipurpose
    Internet Mail Extension** (**MIME**) types define the kinds of content that a
    web service might return. This can include plain text, HTML, JSON, XML, or any
    of the wide variety of non-text media that a website might serve.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 内容有一个大而相当明确定义的范围。**多用途互联网邮件扩展**（**MIME**）类型定义了Web服务可能返回的内容类型。这可以包括纯文本、HTML、JSON、XML，或者网站可能提供的各种非文本媒体。
- en: As we look more closely at the processing required to build a response to an
    HTTP request, we'll see some common features that we'd like to reuse. This idea
    of reusable elements is what leads to the creation of web service frameworks that
    fill a spectrum from simple to sophisticated. The ways that functional designs
    allow us to reuse functions indicate that the functional approach seems very appropriate
    to build web services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更仔细地观察构建对HTTP请求的响应所需的处理时，我们会看到一些我们想要重用的共同特征。可重用元素的这一理念导致了从简单到复杂的Web服务框架的创建。功能设计允许我们重用函数的方式表明，功能方法似乎非常适合构建Web服务。
- en: 'We''ll look at functional design of web services by examining how we can create
    a pipeline of the various elements of a service response. We''ll do this by nesting
    the functions for request processing so that inner elements are free from the
    generic overheads, which are provided by outer elements. This also allows the
    outer elements to act as filters: invalid requests can yield error responses,
    allowing the inner function to focus narrowly on the application processing.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过嵌套请求处理的各种元素来创建服务响应的管道，来研究Web服务的功能设计。我们将通过嵌套请求处理的各种元素来创建服务响应的管道，这样内部元素就可以摆脱外部元素提供的通用开销。这也允许外部元素充当过滤器：无效的请求可以产生错误响应，从而使内部函数可以专注于应用程序处理。
- en: Nesting the services
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套服务
- en: 'We can look at web request handling as a number of nested contexts. An outer
    context, for example, might cover session management: examining the request to
    determine if this is another request in an existing session or a new session.
    An inner context might provide tokens used for form processing that can detect
    **Cross-Site Request Forgeries** (**CSRF**). Another context might handle user
    authentication within a session.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Web请求处理视为许多嵌套上下文。例如，外部上下文可能涵盖会话管理：检查请求以确定这是现有会话中的另一个请求还是新会话。内部上下文可能提供用于表单处理的令牌，可以检测**跨站点请求伪造**（**CSRF**）。另一个上下文可能处理会话中的用户身份验证。
- en: 'A conceptual view of the functions explained previously is something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 先前解释的函数的概念视图大致如下：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The idea here is that each function can build on the results of the previous
    function. Each function either enriches the request or rejects it because it's
    invalid. The `session` function, for example, can use headers to determine if
    this is an existing session or a new session. The `csrf` function will examine
    form input to ensure that proper tokens were used. The CSRF handling requires
    a valid session. The `authentication` function can return an error response for
    a session that lacks valid credentials; it can enrich the request with user information
    when valid credentials are present.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是每个函数都可以建立在前一个函数的结果之上。每个函数要么丰富请求，要么拒绝请求，因为它是无效的。例如，`session`函数可以使用标头来确定这是一个现有会话还是一个新会话。`csrf`函数将检查表单输入，以确保使用了正确的令牌。CSRF处理需要一个有效的会话。`authentication`函数可以为缺乏有效凭据的会话返回错误响应；当存在有效凭据时，它可以丰富请求的用户信息。
- en: The `content` function is free from worrying about sessions, forgeries, and
    non-authenticated users. It can focus on parsing the path to determine what kind
    of content should be provided. In a more complex application, the `content` function
    may include a rather complex mapping from path elements to functions that determine
    the appropriate content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`函数不必担心会话、伪造和非经过身份验证的用户。它可以专注于解析路径，以确定应提供什么类型的内容。在更复杂的应用程序中，`content`函数可能包括从路径元素到确定适当内容的函数的相当复杂的映射。'
- en: The nested function view, however, still isn't quite right. The problem is that
    each nested context may also need to tweak the response instead of or in addition
    to tweaking the request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，嵌套函数视图仍然不太对。问题在于每个嵌套上下文可能还需要调整响应，而不是或者除了调整请求之外。
- en: 'We really want something more like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的希望更像这样：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This concept points toward a functional design for creating web content via
    a nested collection of functions that provide enriched input or enriched output
    or both. With a little bit of cleverness, we should be able to define a simple,
    standard interface that various functions can use. Once we've standardized an
    interface, we can combine functions in different ways and add features. We should
    be able to meet our functional programming objectives of having succinct and expressive
    programs that provide web content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念指向了通过一系列嵌套的函数来创建丰富输入或丰富输出或两者的功能设计。通过一点巧妙，我们应该能够定义一个简单的标准接口，各种函数可以使用。一旦我们标准化了接口，我们就可以以不同的方式组合函数并添加功能。我们应该能够满足我们的函数式编程目标，编写简洁而富有表现力的程序，提供Web内容。
- en: The WSGI standard
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WSGI标准
- en: The **Web Server Gateway Interface** (**WSGI**) defines a relatively simple,
    standardized design pattern for creating a response to a web request. The Python
    library's `wsgiref` package includes a reference implementation of WSGI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务器网关接口**（**WSGI**）为创建对Web请求的响应定义了一个相对简单的标准化设计模式。Python库的`wsgiref`包包括了WSGI的一个参考实现。'
- en: 'Each WSGI "application" has the same interface:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个WSGI“应用程序”都具有相同的接口：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `environ` is a dictionary that contains all of the arguments of the request
    in a single, uniform structure. The headers, the request method, the path, any
    attachments for forms or file uploads will all be in the environment. In addition
    to this, the OS-level context is also provided along with a few items that are
    part of WSGI request handling.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`environ`是一个包含请求参数的字典，具有统一的结构。标头、请求方法、路径、表单或文件上传的任何附件都将在环境中。除此之外，还提供了操作系统级别的上下文以及一些属于WSGI请求处理的项目。'
- en: The `start_response` is a function that must be used to send the status and
    headers of a response. The portion of a WSGI server that has final responsibility
    for building the response will use a `start_response` function to send the headers
    and the status as well as to build the response text. For some applications, this
    function might need to be wrapped with a higher-order function so that additional
    headers can be added to the response.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_response`是一个必须用于发送响应状态和标头的函数。负责构建响应的WSGI服务器的部分将使用`start_response`函数来发送标头和状态，以及构建响应文本。对于某些应用程序，可能需要使用高阶函数包装此函数，以便向响应添加额外的标头。'
- en: The return value is a sequence of strings or string-like file wrappers that
    will be returned to the user agent. If an HTML template tool is used, then the
    sequence may have a single item. In some cases, like the **Jinja2** templates,
    the template can be rendered lazily as a sequence of text chunks, interleaving
    template filling with downloading to the user agent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是一个字符串序列或类似字符串的文件包装器，将返回给用户代理。如果使用HTML模板工具，则序列可能只有一个项目。在某些情况下，比如**Jinja2**模板，模板可以作为文本块序列进行延迟渲染，将模板填充与向用户代理下载交错进行。
- en: Due to the way they nest, WSGI applications can also be viewed as a chain. Each
    application will either return an error or will hand the request to another application
    that will determine the result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的嵌套方式，WSGI应用程序也可以被视为一个链。每个应用程序要么返回错误，要么将请求交给另一个应用程序来确定结果。
- en: 'Here''s a very simple routing application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的路由应用程序：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This app will use the `wsgiref.util.shift_path_info()` function to tweak the
    environment. This does a "head/tail split" on the items in the request path, available
    in the `environ['PATH_INFO']` dictionary. The head of the path—up to the first
    "split`"`—will be moved into the `SCRIPT_NAME` item in the environment; the `PATH_INFO`
    item will be updated to have the tail of the path. The returned value will also
    be the head of the path. In the case where there's no path to parse, the return
    value is `None` and no environment updates are made.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将使用`wsgiref.util.shift_path_info()`函数来调整环境。这将对请求路径中的项目进行“头/尾拆分”，可在`environ['PATH_INFO']`字典中找到。路径的头部——直到第一个“拆分`”——将被移动到环境中的`SCRIPT_NAME`项目中；`PATH_INFO`项目将被更新为路径的尾部。返回值也将是路径的头部。在没有要解析的路径的情况下，返回值是`None`，不会进行环境更新。
- en: The `routing()` function uses the first item on the path to locate an application
    in the `SCRIPT_MAP` dictionary. We use the `SCRIPT_MAP['']` dictionary as a default
    in case the requested path doesn't fit the mapping. This seems a little better
    than an HTTP `404 NOT FOUND` error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`routing()`函数使用路径上的第一项来定位`SCRIPT_MAP`字典中的应用程序。我们使用`SCRIPT_MAP['''']`字典作为默认值，以防所请求的路径不符合映射。这似乎比HTTP
    `404 NOT FOUND`错误好一点。'
- en: This WSGI application is a function that chooses between a number of other functions.
    It's a higher-order function, since it evaluates functions defined in a data structure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WSGI应用程序是一个选择多个其他函数的函数。它是一个高阶函数，因为它评估数据结构中定义的函数。
- en: It's easy to see how a framework could generalize the path-matching process
    using regular expressions. We can imagine configuring the `routing()` function
    with a sequence of Regular Expression's (REs) and WSGI applications instead of
    a mapping from a string to the WSGI application. The enhanced `routing()` function
    application would evaluate each RE looking for a match. In the case of a match,
    any `match.groups()` function could be used to update the environment before calling
    the requested application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，一个框架可以使用正则表达式来概括路径匹配过程。我们可以想象使用一系列正则表达式（REs）和WSGI应用程序来配置`routing()`函数，而不是从字符串到WSGI应用程序的映射。增强的`routing()`函数应用程序将评估每个RE以寻找匹配项。在匹配的情况下，可以使用任何`match.groups()`函数来在调用请求的应用程序之前更新环境。
- en: Throwing exceptions during WSGI processing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WSGI处理过程中抛出异常
- en: One central feature of WSGI applications is that each stage along the chain
    is responsible for filtering the requests. The idea is to reject faulty requests
    as early in the processing as possible. Python's exception handling makes this
    particularly simple.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI应用程序的一个中心特点是，沿着链的每个阶段都负责过滤请求。其想法是尽可能早地拒绝有错误的请求。Python的异常处理使得这变得特别简单。
- en: 'We can define a WSGI application that provides static content as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个WSGI应用程序，提供静态内容如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we simply tried to open the requested path as a text file. There
    are two common reasons why we can''t open a given file, both of which are handled
    as exceptions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是尝试打开所请求的路径作为文本文件。我们无法打开给定文件的两个常见原因，这两种情况都作为异常处理：
- en: If the file is a directory, we'll use a different application to present directory
    contents
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件是一个目录，我们将使用不同的应用程序来呈现目录内容
- en: If the file is simply not found, we'll return an HTTP 404 NOT FOUND response
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件根本找不到，我们将返回一个HTTP 404 NOT FOUND响应
- en: Any other exceptions raised by this WSGI application will not be caught. The
    application that invoked this should be designed with some generic error response
    capability. If it doesn't handle the exceptions, a generic WSGI failure response
    will be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此WSGI应用程序引发的任何其他异常都不会被捕获。调用此应用程序的应用程序应设计有一些通用的错误响应能力。如果它不处理异常，将使用通用的WSGI失败响应。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our processing involves a strict ordering of operations. We must read the entire
    file so that we can create a proper HTTP `Content-Length` header.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理涉及严格的操作顺序。我们必须读取整个文件，以便我们可以创建一个适当的HTTP `Content-Length`头。
- en: Further, we must provide the content as bytes. This means that the Python strings
    must be properly encoded and we must provide the encoding information to the user
    agent. Even the error message, `repr(e)`, is properly encoded before being downloaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须以字节形式提供内容。这意味着Python字符串必须被正确编码，并且我们必须向用户代理提供编码信息。甚至错误消息`repr(e)`在下载之前也要被正确编码。
- en: Pragmatic WSGI applications
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 务实的WSGI应用程序
- en: The intent of the WSGI standard is not to define a complete web framework; the
    intent is to define a minimum set of standards that allow flexible interoperability
    of web-related processing. A framework can take a wildly different approach than
    an internal architecture to provide web services. However, its outermost interface
    should be compatible with WSGI so that it can be used in a variety of contexts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准的目的不是定义一个完整的Web框架；目的是定义一组最低限度的标准，允许Web相关处理的灵活互操作。一个框架可以采用与内部架构完全不同的方法来提供Web服务。但是，它的最外层接口应与WSGI兼容，以便可以在各种上下文中使用。
- en: Web servers such as **Apache httpd** and **Nginx** have adapters, which provide
    a WSGI-compatible interface from the web server to Python applications. For more
    information on WSGI implementations, visit
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如**Apache httpd**和**Nginx**之类的Web服务器有适配器，它们提供了从Web服务器到Python应用程序的WSGI兼容接口。有关WSGI实现的更多信息，请访问
- en: '[https://wiki.python.org/moin/WSGIImplementations](https://wiki.python.org/moin/WSGIImplementations).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.python.org/moin/WSGIImplementations](https://wiki.python.org/moin/WSGIImplementations)。'
- en: Embedding our applications in a larger server allows us to have a tidy separation
    of concerns. We can use Apache httpd to serve completely static content, such
    as `.css`, `.js`, and image files. For HTML pages, though, we can use Apache's
    `mod_wsgi` interface to hand off requests to a separate Python process, which
    handles only the interesting HTML portions of the web content.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序嵌入到一个更大的服务器中，可以让我们有一个整洁的关注分离。我们可以使用Apache httpd来提供完全静态的内容，比如.css、.js和图像文件。但是对于HTML页面，我们可以使用Apache的“mod_wsgi”接口将请求转交给一个单独的Python进程，该进程只处理网页内容的有趣部分。
- en: This means that we must either create a separate media server, or define our
    website to have two sets of paths. If we take the second approach, some paths
    will have the completely static content and can be handled by Apache httpd. Other
    paths will have dynamic content, which will be handled by Python.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须要么创建一个单独的媒体服务器，要么定义我们的网站有两组路径。如果我们采取第二种方法，一些路径将有完全静态的内容，可以由Apache httpd处理。其他路径将有动态内容，将由Python处理。
- en: When working with WSGI functions, it's important to note that we can't modify
    or extend the WSGI interface in any way. For example, it seems like a good idea
    to provide an additional parameter with a sequence of functions that define the
    chain of processing. Each stage would pop the first item from the list as the
    next step in the processing. An additional parameter like this might be typical
    for functional design, but the change in the interface defeats the purpose of
    WSGI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用WSGI函数时，重要的是要注意我们不能以任何方式修改或扩展WSGI接口。例如，提供一个附加参数，其中包含定义处理链的函数序列，似乎是一个好主意。每个阶段都会从列表中弹出第一个项目作为处理的下一步。这样的附加参数可能是函数设计的典型，但接口的改变违背了WSGI的目的。
- en: A consequence of the WSGI definition is that configuration is either done with
    global variables, the request environment, or with a function, which fetches some
    global configuration objects from a cache. Using module-level globals works for
    small examples. For more complex applications, a configuration cache might be
    required. It might also be sensible to have a WSGI app, which merely updates the
    `environ` dictionary with configuration parameters and passes control to another
    WSGI application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI定义的一个后果是配置要么使用全局变量，要么使用请求环境，要么使用一个函数，该函数从缓存中获取一些全局配置对象。使用模块级全局变量适用于小例子。对于更复杂的应用程序，可能需要一个配置缓存。可能还有必要有一个WSGI应用程序，它仅仅更新“environ”字典中的配置参数，并将控制权传递给另一个WSGI应用程序。
- en: Defining web services as functions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将web服务定义为函数
- en: We'll look at a RESTful web service, which can "slice and dice" a source of
    data and provide downloads as JSON, XML, or CSV files. We'll provide an overall
    WSGI-compatible wrapper but the functions which do the "real work" of the application
    won't be narrowly constrained to fit the WSGI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个RESTful web服务，它可以“切割和切块”数据源，并提供JSON、XML或CSV文件的下载。我们将提供一个整体的WSGI兼容包装器，但是应用程序的“真正工作”的函数不会被狭窄地限制在WSGI中。
- en: 'We''ll use a simple dataset with four subcollections: the Anscombe Quartet.
    We looked at ways to read and parse this data in Chapter 3, *Functions, Iterators,
    and Generators*". It''s a small set of data but it can be used to show the principles
    of a RESTful web service.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的数据集，其中包括四个子集合：安斯康姆四重奏。我们在第3章“函数、迭代器和生成器”中讨论了读取和解析这些数据的方法。这是一个小数据集，但可以用来展示RESTful
    web服务的原则。
- en: 'We''ll split our application into two tiers: a web tier, which will be a simple
    WSGI application, and the rest of the processing, which will be more typical functional
    programming. We''ll look at the web tier first so that we can focus on a functional
    approach to provide meaningful results.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的应用程序分成两个层次：一个是web层，它将是一个简单的WSGI应用程序，另一个是其余的处理，它将是更典型的函数式编程。我们首先看看web层，这样我们就可以专注于提供有意义的结果的函数式方法。
- en: 'We need to provide two pieces of information to the web service:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向web服务提供两个信息：
- en: The quartet that we want—this is a "slice and dice" operation. For this example,
    it's mostly just a "slice".
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要的四重奏——这是一个“切割和切块”的操作。在这个例子中，它主要是一个“切片”。
- en: The output format we want.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要的输出格式。
- en: The data selection is commonly done via the request path. We can request "`/anscombe/I/`"
    or "`/anscombe/II/`" to pick specific datasets from the quartet. The idea is that
    a URL defines a resource, and there's no good reason for the URL to ever change.
    In this case, the dataset selectors aren't dependent on dates, or some organizational
    approval status or other external factors. The URL is timeless and absolute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据选择通常通过请求路径完成。我们可以请求“/anscombe/I/”或“/anscombe/II/”来从四重奏中选择特定的数据集。这个想法是URL定义了一个资源，而且没有好的理由让URL发生变化。在这种情况下，数据集选择器不依赖于日期，或者一些组织批准状态或其他外部因素。URL是永恒和绝对的。
- en: The output format is not a first class part of the URL. It's just a serialization
    format—not the data itself. In some cases, the format is requested via the HTTP
    `Accept` header. This is hard to use from a browser but easy to use from an application
    using a RESTful API. When extracting data from the browser, a query string is
    commonly used to specify the output format. We'll use the "`?form=json`" method
    at the end of the path to specify the JSON output format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式不是URL的一部分。它只是一个序列化格式，而不是数据本身。在某些情况下，格式是通过HTTP“接受”头请求的。这在浏览器中很难使用，但在使用RESTful
    API的应用程序中很容易使用。从浏览器中提取数据时，通常使用查询字符串来指定输出格式。我们将在路径的末尾使用“?form=json”方法来指定JSON输出格式。
- en: 'A URL we can use will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的URL看起来像这样：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This would request a CSV download of the third dataset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将请求第三个数据集的CSV下载。
- en: Creating the WSGI application
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建WSGI应用程序
- en: 'First, we''ll use a simple URL pattern-matching expression to define the one
    and only routing in our application. In a larger or more complex application,
    we might have more than one such patterns:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用一个简单的URL模式匹配表达式来定义我们应用程序中唯一的路由。在一个更大或更复杂的应用程序中，我们可能会有多个这样的模式：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This pattern allows us to define an overall "script" in the WSGI sense at the
    top level of the path. In this case, the script is "anscombe". We'll take the
    next level of the path as a dataset to select from the Anscombe Quartet. The dataset
    value should be one of `I`, `II`, `III`, or `IV`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许我们在路径的顶层定义一个整体的WSGI意义上的“脚本”。在这种情况下，脚本是“anscombe”。我们将路径的下一个级别作为要从Anscombe
    Quartet中选择的数据集。数据集值应该是`I`、`II`、`III`或`IV`中的一个。
- en: 'We used a named parameter for the selection criteria. In many cases, RESTful
    APIs are described using a syntax, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对选择条件使用了一个命名参数。在许多情况下，RESTful API使用以下语法进行描述：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We translated this idealized pattern into a proper, regular expression, and
    preserved the name of the dataset selector in the path.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种理想化的模式转化为一个适当的正则表达式，并在路径中保留了数据集选择器的名称。
- en: 'Here''s the kind of unit test that demonstrates how this pattern works:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是演示这种模式如何工作的单元测试的一种类型：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can include the three previously mentioned examples as part of the overall
    doctest using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将三个先前提到的示例包含在整个doctest中：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will ensure that our routing works as expected. It's important to be able
    to test this separately from the rest of the WSGI application. Testing a complete
    web server means starting the server process and then trying to connect with a
    browser or a test tool, such as Postman or Selenium. Visit [http://www.getpostman.com](http://www.getpostman.com)
    or [http://www.seleniumhq.org](http://www.seleniumhq.org) to get more information
    on the usage of Postman and Selenium. We prefer to test each feature in isolation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们的路由按预期工作。能够从WSGI应用程序的其余部分单独测试这一点非常重要。测试完整的Web服务器意味着启动服务器进程，然后尝试使用浏览器或测试工具（如Postman或Selenium）进行连接。访问[http://www.getpostman.com](http://www.getpostman.com)或[http://www.seleniumhq.org](http://www.seleniumhq.org)以获取有关Postman和Selenium用法的更多信息。我们更喜欢单独测试每个功能。
- en: 'Here''s the overall WSGI application, with two lines of command highlighted:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是整个WSGI应用程序，其中突出显示了两行命令：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This application will extract two pieces of information from the request: the
    `PATH_INFO` and the `QUERY_STRING` methods. The `PATH_INFO` request will define
    which set to extract. The `QUERY_STRING` request will specify an output format.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将从请求中提取两个信息：`PATH_INFO`和`QUERY_STRING`方法。`PATH_INFO`请求将定义要提取的集合。`QUERY_STRING`请求将指定输出格式。
- en: The application processing is broken into three functions. A `raw_data()` function
    reads the raw data from a file. The result is a dictionary with lists of `Pair`
    objects. The `anscombe_filter()` function accepts a selection string and the dictionary
    of raw data and returns a single list of `Pair` objects. The list of pairs is
    then serialized into bytes by the `serialize()` function. The serializer is expected
    to produce bytes, which can then be packaged with an appropriate header and returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序处理分为三个函数。`raw_data()`函数从文件中读取原始数据。结果是一个带有`Pair`对象列表的字典。`anscombe_filter()`函数接受选择字符串和原始数据的字典，并返回一个`Pair`对象的列表。然后，将成对的列表通过`serialize()`函数序列化为字节。序列化器应该生成字节，然后可以与适当的头部打包并返回。
- en: We elected to produce an HTTP `Content-Length` header. This isn't required,
    but it's polite for large downloads Because we decided to emit this header, we
    are forced to materialize the results of the serialization so that we can count
    the bytes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择生成一个HTTP“Content-Length”头。这并不是必需的，但对于大型下载来说是礼貌的。因为我们决定发出这个头部，我们被迫实现序列化的结果，以便我们可以计算字节数。
- en: If we elected to omit the `Content-Length` header, we could change the structure
    of this application dramatically. Each serializer could be changed to a generator
    function, which would yield bytes as they are produced. For large datasets, this
    can be a helpful optimization. For the user watching a download, however, it might
    not be so pleasant because the browser can't display how much of the download
    is complete.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择省略“Content-Length”头部，我们可以大幅改变此应用程序的结构。每个序列化器可以更改为生成器函数，该函数将按照生成的顺序产生字节。对于大型数据集，这可能是一个有用的优化。但是，对于观看下载的用户来说，这可能并不那么愉快，因为浏览器无法显示下载的完成进度。
- en: All errors are treated as a `404 NOT FOUND` error. This could be misleading,
    since a number of individual things might go wrong. A more sophisticated error
    handling would provide more `try:/except:` blocks to provide more informative
    feedback.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有错误都被视为`404 NOT FOUND`错误。这可能会产生误导，因为可能会出现许多个别问题。更复杂的错误处理将提供更多的`try:/except:`块，以提供更多信息反馈。
- en: For debugging purposes, we've provided a Python stack trace in the resulting
    web page. Outside the context of debugging, this is a very bad idea. Feedback
    from an API should be just enough to fix the request and nothing more. A stack
    trace provides too much information to potentially malicious users.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，我们在生成的网页中提供了一个Python堆栈跟踪。在调试的上下文之外，这是一个非常糟糕的主意。来自API的反馈应该足够修复请求，什么都不多。堆栈跟踪为潜在的恶意用户提供了太多信息。
- en: Getting raw data
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取原始数据
- en: 'The `raw_data()` function is largely copied from [Chapter 3](ch03.html "Chapter 3. Functions,
    Iterators, and Generators"), *Functions, Iterators, and Generators*. We included
    some important changes. Here''s what we''re using for this application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw_data()`函数在很大程度上是从[第3章](ch03.html "第3章。函数，迭代器和生成器")*函数，迭代器和生成器*中复制的。我们包含了一些重要的更改。以下是我们用于此应用程序的内容：'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We opened the local data file, and applied a simple `row_iter()` function to
    return each line of the file parsed into a row of separate files. We applied the
    `head_map_filter()` function to remove the heading from the file. The result created
    a tuple-of-tuple structure with all of the data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了本地数据文件，并应用了一个简单的`row_iter()`函数，以将文件的每一行解析为一个单独的行。我们应用了`head_map_filter()`函数来从文件中删除标题。结果创建了一个包含所有数据的元组结构。
- en: We transformed the tuple-of-tuple into a more useful `dict()` function by selecting
    particular series from the source data. Each series will be a pair of columns.
    For series `"I`,`"` it's columns 0 and 1\. For series `"II`,`"` it's columns 2
    and 3.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从源数据中选择特定系列，将元组转换为更有用的`dict()`函数。每个系列将是一对列。对于系列`"I`,`"`，它是列0和1。对于系列`"II`,`"`，它是列2和3。
- en: We used the `dict()` function with a generator expression for consistency with
    the `list()` and `tuple()` functions. While it's not essential, it's sometimes
    helpful to see the similarities with these three data structures and their use
    of generator expressions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dict()`函数与生成器表达式保持一致，与`list()`和`tuple()`函数一样。虽然这并非必要，但有时看到这三种数据结构及其使用生成器表达式的相似之处是有帮助的。
- en: The `series()` function creates the individual `Pair` objects for each *x*,*y*
    pair in the dataset. In retrospect, we can see the the output value after modifying
    this function so that the resulting `namedtuple` class is an argument to this
    function, not an implicit feature of the function. We'd prefer to see the `series(id_num,Pair,data)`
    method to see where the `Pair` objects are created. This extension requires rewriting
    some of the examples in [Chapter 3](ch03.html "Chapter 3. Functions, Iterators,
    and Generators"), *Functions, Iterators, and Generators*. We'll leave that as
    an exercise for the reader.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`series()`函数为数据集中的每个*x*，*y*对创建了单独的`Pair`对象。回顾一下，我们可以看到修改这个函数后的输出值，使得生成的`namedtuple`类是这个函数的参数，而不是函数的隐式特性。我们更希望看到`series(id_num,Pair,data)`方法，以查看`Pair`对象是如何创建的。这个扩展需要重写[第3章](ch03.html
    "第3章。函数、迭代器和生成器")中的一些示例，*函数、迭代器和生成器*。我们将把这留给读者作为练习。'
- en: The important change here is that we're showing the formal `doctest` test case.
    As we noted earlier, web applications—as a whole—are difficult to test. The web
    server must be started and then a web client must be used to run the test cases.
    Problems then have to be resolved by reading the web log, which can be difficult
    unless complete tracebacks are displayed. It's much better to debug as much of
    the web application as possible using ordinary `doctest` and `unittest` testing
    techniques.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要变化是，我们展示了正式的`doctest`测试用例。正如我们之前指出的，作为一个整体，Web应用程序很难测试。必须启动Web服务器，然后必须使用Web客户端来运行测试用例。然后必须通过阅读Web日志来解决问题，这可能很困难，除非显示完整的回溯。最好尽可能多地使用普通的`doctest`和`unittest`测试技术来调试Web应用程序。
- en: Applying a filter
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用过滤器
- en: 'In this application, we''re using a very simple filter. The entire filter process
    is embodied in the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用了一个非常简单的过滤器。整个过滤过程体现在下面的函数中：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We made this trivial expression into a function for three reasons:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个微不足道的表达式转换成一个函数有三个原因：
- en: The functional notation is slightly more consistent and a bit more flexible
    than the subscript expression
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表示法略微更一致，比下标表达式更灵活
- en: We can easily expand the filtering to do more
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以很容易地扩展过滤功能
- en: We can include separate unit tests in the docstring for this function
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在此函数的文档字符串中包含单独的单元测试
- en: While a simple lambda would work, it wouldn't be quite as convenient to test.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的lambda可以工作，但测试起来可能不太方便。
- en: For error handling, we've done exactly nothing. We've focused on what's sometimes
    called the "happy path:" an ideal sequence of events. Any problems that arise
    in this function will raise an exception. The WSGI wrapper function should catch
    all exceptions and return an appropriate status message and error response content.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，我们什么也没做。我们专注于有时被称为“快乐路径”的内容：理想的事件序列。在这个函数中出现的任何问题都将引发异常。WSGI包装函数应该捕获所有异常并返回适当的状态消息和错误响应内容。
- en: 'For example, it''s possible that the `set_id` method will be wrong in some
    way. Rather than obsess over all the ways it could be wrong, we''ll simply allow
    Python to throw an exception. Indeed, this function follows the Python I advice
    that, "it''s better to seek forgiveness than to ask permission." This advice is
    materialized in code by avoiding "permission-seeking": there are no preparatory
    `if` statements that seek to qualify the arguments as valid. There is only "forgiveness"
    handling: an exception will be raised and handled in the WSGI wrapper. This essential
    advice applies to the preceding raw data and the serialization that we will see
    now.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`set_id`方法可能在某些方面是错误的。与其过分关注它可能出错的所有方式，我们宁愿让Python抛出异常。事实上，这个函数遵循了Python
    I的建议，“最好是寻求宽恕，而不是征求许可”。这个建议在代码中体现为避免“征求许可”：没有寻求将参数限定为有效的准备性`if`语句。只有“宽恕”处理：异常将被引发并在WSGI包装函数中处理。这个基本建议适用于前面的原始数据和我们现在将看到的序列化。
- en: Serializing the results
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化结果
- en: 'Serialization is the conversion of Python data into a stream of bytes, suitable
    for transmission. Each format is best described by a simple function that serializes
    just that one format. A top-level generic serializer can then pick from a list
    of specific serializers. The picking of serializers leads to the following collection
    of functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将Python数据转换为适合传输的字节流的过程。每种格式最好由一个简单的函数来描述，该函数只序列化这一种格式。然后，顶层通用序列化程序可以从特定序列化程序列表中进行选择。序列化程序的选择导致以下一系列函数：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The overall `serialize()` function locates a specific serializer and a specific
    MIME type that must be used in the response to characterize the results. It then
    calls one of the specific serializers. We've also shown a `doctest` test case
    here. We didn't patiently test each serializer, since showing that one works seems
    adequate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 整体`serialize()`函数找到必须在响应中使用的特定序列化程序和特定MIME类型。然后调用其中一个特定的序列化程序。我们还在这里展示了一个`doctest`测试用例。我们没有耐心测试每个序列化程序，因为显示一个工作似乎就足够了。
- en: 'We''ll look at the serializers separately. What we''ll see is that the serializers
    fall into two groups: those that produce strings and those that produce bytes.
    A serializer that produces a string will need to have the string encoded as bytes.
    A serializer that produces bytes doesn''t need any further work.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看序列化器。我们将看到序列化器分为两组：产生字符串的序列化器和产生字节的序列化器。产生字符串的序列化器将需要将字符串编码为字节。产生字节的序列化器不需要进一步处理。
- en: 'For the serializers, which produce strings, we need to do some function composition
    with a standard convert-to-bytes. We can do functional composition using a decorator.
    Here''s how we can standardize the conversion to bytes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成字符串的序列化器，我们需要使用标准的转换为字节的函数组合。我们可以使用装饰器进行函数组合。以下是我们如何将转换为字节标准化：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've created a small decorator named `@to_bytes`. This will evaluate the given
    function and then encode the results using UTF-8 to get bytes. We'll show how
    this is used with JSON, CSV, and HTML serializers. The XML serializer produces
    bytes directly and doesn't need to be composed with this additional function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`@to_bytes`的小装饰器。这将评估给定的函数，然后使用UTF-8对结果进行编码以获得字节。我们将展示如何将其与JSON、CSV和HTML序列化器一起使用。XML序列化器直接产生字节，不需要与此额外函数组合。
- en: 'We could also do the functional composition in the initialization of the `serializers`
    mapping. Instead of decorating the function definition, we could decorate the
    reference to the function object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`serializers`映射的初始化中进行函数组合。我们可以装饰函数定义的引用，而不是装饰函数对象的引用。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Though this is possible, this doesn't seem to be helpful. The distinction between
    serializers that produce strings and those that produce bytes isn't an important
    part of the configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是可能的，但这似乎并不有用。产生字符串和产生字节的序列化器之间的区别并不是配置的重要部分。
- en: Serializing data into the JSON or CSV format
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据序列化为JSON或CSV格式
- en: The JSON and CSV serializers are similar functions because both rely on Python's
    libraries to serialize. The libraries are inherently imperative, so the function
    bodies are strict sequences of statements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和CSV序列化器是类似的函数，因为两者都依赖于Python的库进行序列化。这些库本质上是命令式的，因此函数体是严格的语句序列。
- en: 'Here''s the JSON serializer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JSON序列化器：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We created a list of dictionaries structure and used the `json.dumps()` function
    to create a string representation. The JSON module requires a materialized `list`
    object; we can't provide a lazy generator function. The `sort_keys=True` argument
    value is essential for unit testing. However, it's not required for the application
    and represents a bit of overhead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个字典结构的列表，并使用`json.dumps()`函数创建了一个字符串表示。JSON模块需要一个具体化的`list`对象；我们不能提供一个惰性生成器函数。`sort_keys=True`参数值对于单元测试是必不可少的。但对于应用程序并不是必需的，而且代表了一些额外的开销。
- en: 'Here''s the CSV serializer:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CSV序列化器：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The CSV module's readers and writers are a mixture of imperative and functional
    elements. We must create the writer, and properly create headings in a strict
    sequence. We've used the `_fields` attribute of the `Pair` namedtuple to determine
    the column headings for the writer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CSV模块的读取器和写入器是命令式和函数式元素的混合。我们必须创建写入器，并严格按顺序创建标题。我们使用了`Pair`命名元组的`_fields`属性来确定写入器的列标题。
- en: The `writerows()` method of the writer will accept a lazy generator function.
    In this case, we used the `_asdict()` method of each `Pair` object to return a
    dictionary suitable for use with the CSV writer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器的`writerows()`方法将接受一个惰性生成器函数。在这种情况下，我们使用了每个`Pair`对象的`_asdict()`方法返回适用于CSV写入器的字典。
- en: Serializing data into XML
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据序列化为XML
- en: We'll look at one approach to XML serialization using the built-in libraries.
    This will build a document from individual tags. A common alternative approach
    is to use Python introspection to examine and map Python objects and class names
    to XML tags and attributes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用内置库来看一种XML序列化的方法。这将从单个标签构建文档。一个常见的替代方法是使用Python内省来检查和映射Python对象和类名到XML标签和属性。
- en: 'Here''s our XML serialization:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的XML序列化：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We created a top-level element, `<series>`, and placed `<row>` subelements underneath
    that top element. Within each `<row>` subelement, we've created `<x>` and `<y>`
    tags and assigned text content to each tag.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个顶级元素`<series>`，并将`<row>`子元素放在该顶级元素下面。在每个`<row>`子元素中，我们创建了`<x>`和`<y>`标签，并为每个标签分配了文本内容。
- en: The interface for building an XML document using the ElementTree library tends
    to be heavily imperative. This makes it a poor fit for an otherwise functional
    design. In addition to the imperative style, note that we haven't created a DTD
    or XSD. We have not properly assigned a namespace to our tags. We also omitted
    the `<?xml version=""1.0""?>` processing instruction that is generally the first
    item in an XML document.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ElementTree库构建XML文档的接口往往是非常命令式的。这使得它不适合于否则功能设计。除了命令式风格之外，注意我们没有创建DTD或XSD。我们没有为标签正确分配命名空间。我们还省略了通常是XML文档中的第一项的`<?xml
    version=""1.0""?>`处理指令。
- en: A more sophisticated serialization library would be helpful. There are many
    to choose from. Visit [https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)
    for a list of alternatives.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的序列化库将是有帮助的。有许多选择。访问[https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)获取备选列表。
- en: Serializing data into HTML
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据序列化为HTML
- en: 'In our final example of serialization, we''ll look at the complexity of creating
    an HTML document. The complexity arises because in HTML, we''re expected to provide
    an entire web page with some context information. Here''s one way to tackle this
    HTML problem:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一个序列化示例中，我们将看到创建HTML文档的复杂性。复杂性的原因是在HTML中，我们需要提供一个带有一些上下文信息的整个网页。以下是解决这个HTML问题的一种方法：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our serialization function has two parts. The first part is a `string.Template()`
    function that contains the essential HTML page. It has two placeholders where
    data can be inserted into the template. The `${title}` method shows where title
    information can be inserted and the `${rows}` method shows where the data rows
    can be inserted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的序列化函数有两个部分。第一部分是一个`string.Template()`函数，其中包含了基本的HTML页面。它有两个占位符，可以将数据插入模板中。`${title}`方法显示了标题信息可以插入的位置，`${rows}`方法显示了数据行可以插入的位置。
- en: The function creates individual data rows using a simple format string. These
    are joined into a longer string, which is then substituted into the template.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用简单的格式字符串创建单独的数据行。然后将它们连接成一个较长的字符串，然后替换到模板中。
- en: While workable for simple cases like the preceding example, this isn't ideal
    for more complex result sets. There are a number of more sophisticated template
    tools to create HTML pages. A number of these include the ability to embed the
    looping in the template, separate from the function that initializes serialization.
    Visit [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)
    for a list of alternatives.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于像前面的例子这样简单的情况来说是可行的，但对于更复杂的结果集来说并不理想。有许多更复杂的模板工具可以创建HTML页面。其中一些包括在模板中嵌入循环的能力，与初始化序列化的功能分开。访问[https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)获取备选列表。
- en: Tracking usage
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪使用情况
- en: Many publicly available APIs require the use of an "API Key". The supplier of
    the API requests you to sign up and provide an email address or other contact
    information. In exchange for this, they provide an API Key which activates the
    API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公开可用的API需要使用"API密钥"。API的供应商要求您注册并提供电子邮件地址或其他联系信息。作为交换，他们提供一个激活API的API密钥。
- en: The API Key is used to authenticate access. It may also be used to authorize
    specific features. Finally, it's also used to track usage. This may include throttling
    requests if an API Key is used too often in a given time period.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥用于验证访问。它也可以用于授权特定功能。最后，它还用于跟踪使用情况。这可能包括在给定时间段内过于频繁地使用API密钥时限制请求。
- en: The variations in the business models are numerous. For example, use of the
    API Key is a billable event and charges are incurred. For other businesses, traffic
    must reach some threshold before payments are required.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 商业模式的变化是多种多样的。例如，使用API密钥是一个计费事件，会产生费用。对于其他企业来说，流量必须达到一定阈值才需要付款。
- en: What's important is non-repudiation of the use of the API. This, in turn, means
    creating API Keys that can act as a user's authentication credentials. The key
    must be difficult to forge and relatively easy to verify.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是对API的使用进行不可否认。这反过来意味着创建可以作为用户身份验证凭据的API密钥。密钥必须难以伪造，相对容易验证。
- en: 'One easy way to create API Keys is to use a cryptographic random number to
    generate a difficult-to-predict key string. A small function, like the following,
    should be good enough:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API密钥的一种简单方法是使用加密随机数来生成难以预测的密钥字符串。像下面这样的一个小函数应该足够好：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used the `random.SystemRandom` class as the class for our secure random
    number generator. This will seed the generator with the `os.urandom()` bytes,
    which assures a reliably unpredictable seed value. We've created this object separately
    so that it can be reused each time a key is requested. Best practice is to get
    a number of keys from a generator using a single random seed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`random.SystemRandom`类作为我们安全随机数生成器的类。这将使用`os.urandom()`字节来初始化生成器，确保了一个可靠的不可预测的种子值。我们单独创建了这个对象，以便每次请求密钥时都可以重复使用。最佳做法是使用单个随机种子从生成器获取多个密钥。
- en: Given some random bytes, we used a base 64 encoding to create a sequence of
    characters. Using a multiple of three in the initial sequence of random bytes,
    we'll avoid any trailing "`=`" signs in the base 64 encoding. We've used the URL
    safe base 64 encoding, which won't include the "`/`" or "`+`" characters in the
    resulting string, characters that might be confusing if used as part of a URL
    or query string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一些随机字节，我们使用了base 64编码来创建一系列字符。在初始随机字节序列中使用三的倍数，可以避免在base 64编码中出现任何尾随的"`=`"符号。我们使用了URL安全的base
    64编码，这不会在结果字符串中包含"`/`"或"`+`"字符，如果作为URL或查询字符串的一部分使用可能会引起混淆。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The more elaborate methods won't lead to more random data. The use of `random.SystemRandom`
    assures that no one can counterfeit a key assigned to another user. We're using
    *18×8* random bits, giving us a large number of random keys.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的方法不会导致更多的随机数据。使用`random.SystemRandom`可以确保没有人可以伪造分配给另一个用户的密钥。我们使用了*18×8*个随机位，给我们大量的随机密钥。
- en: 'How many random keys? Take a look at the following command and its output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少随机密钥？看一下以下命令及其输出：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The odds of someone successfully forging a duplicate of someone else's key are
    small.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 成功伪造其他人的密钥的几率很小。
- en: Another choice is to use `uuid.uuid4()` to create a random **Universally Unique
    Identifier** (**UUID**). This will be a 36-character string that has 32 hex digits
    and four "-" punctuation marks. A random UUID is also difficult to forge. A UUID
    that includes data such as username or host IP address is a bad idea because this
    encodes information, which can be decoded and used to forge a key. The reason
    for using a cryptographic random number generator is to avoid encoding any information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`uuid.uuid4()`来创建一个随机的**通用唯一标识符**（**UUID**）。这将是一个36个字符的字符串，其中包含32个十六进制数字和四个"-"标点符号。随机UUID也难以伪造。包含用户名或主机IP地址等数据的UUID是一个坏主意，因为这会编码信息，可以被解码并用于伪造密钥。使用加密随机数生成器的原因是避免编码任何信息。
- en: The RESTful web server will then need a small database with the valid keys and
    perhaps some client contact information. If an API request includes a key that's
    in the database, the associated user is responsible for the request. If the API
    request doesn't include a known key, the request can be rejected with a simple
    `401 UNAUTHORIZED` response. Since the key itself is a 24-character string, the
    database will be rather small and can easily be cached in memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务器然后将需要一个带有有效密钥和可能一些客户联系信息的小型数据库。如果API请求包括数据库中的密钥，相关用户将负责该请求。如果API请求不包括已知密钥，则可以用简单的`401未经授权`响应拒绝该请求。由于密钥本身是一个24个字符的字符串，数据库将非常小，并且可以很容易地缓存在内存中。
- en: Ordinary log-scraping might be sufficient to show the usage for a given key.
    A more sophisticated application might record API requests in a separate logfile
    or database to simplify analysis.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的日志抓取可能足以显示给定密钥的使用情况。更复杂的应用程序可能会将API请求记录在单独的日志文件或数据库中，以简化分析。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at ways in which we can apply functional design to
    the problem of serving content with REST-based web services. We looked at the
    ways that the WSGI standard leads to somewhat functional overall applications.
    We also looked at how we can embed a more functional design into a WSGI context
    by extracting elements from the request for use by our application functions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将功能设计应用于使用基于REST的Web服务提供内容的问题。我们看了一下WSGI标准导致了总体上有点功能性的应用程序的方式。我们还看了一下如何通过从请求中提取元素来将更功能性的设计嵌入到WSGI上下文中，以供我们的应用程序函数使用。
- en: 'For simple services, the problem often decomposes down into three distinct
    operations: getting the data, searching or filtering, and then serializing the
    results. We tackled this with three functions: `raw_data()`, `anscombe_filter()`,
    and `serialize()`. We wrapped these functions in a simple WSGI-compatible application
    to divorce the web services from the "real" processing around extracting and filtering
    the data.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的服务，问题通常可以分解为三个不同的操作：获取数据，搜索或过滤，然后序列化结果。我们用三个函数解决了这个问题：`raw_data()`，`anscombe_filter()`和`serialize()`。我们将这些函数封装在一个简单的WSGI兼容应用程序中，以将Web服务与围绕提取和过滤数据的“真实”处理分离。
- en: We also looked at the way that web services functions can focus on the "happy
    path" and assume that all of the inputs are valid. If inputs are invalid, the
    ordinary Python exception handling will raise exceptions. The WSGI wrapper function
    will catch the errors and return appropriate status codes and error content.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了Web服务函数可以专注于“快乐路径”，并假设所有输入都是有效的方式。如果输入无效，普通的Python异常处理将引发异常。WSGI包装函数将捕获错误并返回适当的状态代码和错误内容。
- en: We avoided looking at more complex problems associated with uploading data or
    accepting data from forms to update a persistent data store. These are not significantly
    more complex than getting data and serializing the results. They are already solved
    in a better manner.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免了与上传数据或接受来自表单的数据以更新持久数据存储相关的更复杂的问题。这些问题与获取数据和序列化结果并没有显著的复杂性。它们已经以更好的方式得到解决。
- en: For simple queries and data sharing, a small web service application can be
    helpful. We can apply functional design patterns and assure that the website code
    is succinct and expressive. For more complex web applications, we should consider
    using a framework that handles the details properly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的查询和数据共享，小型Web服务应用程序可能会有所帮助。我们可以应用功能设计模式，并确保网站代码简洁而富有表现力。对于更复杂的Web应用程序，我们应考虑使用一个能够正确处理细节的框架。
- en: In the next chapter, we'll look at a few optimization techniques that are available
    to us. We'll expand on the `@lru_cache` decorator from [Chapter 10](ch10.html
    "Chapter 10. The Functools Module"), *The Functools Module*. We'll also look at
    some other optimization techniques that were presented in [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一些可用于我们的优化技术。我们将扩展来自[第10章](ch10.html "第10章。Functools模块")*Functools模块*的`@lru_cache`装饰器。我们还将研究一些其他优化技术，这些技术在[第6章](ch06.html
    "第6章。递归和归约")*递归和归约*中提出。
