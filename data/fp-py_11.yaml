- en: Chapter 11. Decorator Design Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。装饰器设计技术
- en: 'Python offers us many ways to create higher-order functions. In [Chapter 5](ch05.html
    "Chapter 5. Higher-order Functions"), *Higher-order Functions*, we looked at two
    techniques: defining a function which accepts a function as an argument and defining
    a subclass of `Callable` which is either initialized with a function or called
    with a function as an argument.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了许多创建高阶函数的方法。在[第5章](ch05.html "第5章。高阶函数")中，*高阶函数*，我们探讨了两种技术：定义一个接受函数作为参数的函数，以及定义`Callable`的子类，该子类可以初始化为一个函数或者使用函数作为参数调用。
- en: In this chapter, we'll look at using a decorator to build a function based on
    another function. We'll also look at two functions from the `functools` module,
    the `update_wrapper()` and `wraps()` functions, that can help us build decorators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用装饰器基于另一个函数构建函数。我们还将研究`functools`模块中的两个函数`update_wrapper()`和`wraps()`，这些函数可以帮助我们构建装饰器。
- en: One of the benefits of decorated functions is that we can create composite functions.
    These are single functions that embody functionality from several sources. A composite
    function, ![Decorator Design Techniques](graphics/B03652_11_01.jpg), can be somewhat
    more expressive of a complex algorithm than ![Decorator Design Techniques](graphics/B03652_11_02.jpg).
    It's often helpful to have a number of syntax alternatives for expressing complex
    processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰函数的好处之一是我们可以创建复合函数。这些是单个函数，包含来自多个来源的功能。复合函数，![装饰器设计技术](graphics/B03652_11_01.jpg)，可能比![装饰器设计技术](graphics/B03652_11_02.jpg)更能表达复杂算法。对于表达复杂处理，有多种语法替代方式通常是有帮助的。
- en: Decorators as higher-order functions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器作为高阶函数
- en: The core idea of a decorator is to transform some original function into another
    form. A decorator creates a kind of composite function based on the decorator
    and the original function being decorated.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的核心思想是将一些原始函数转换为另一种形式。装饰器创建了一种基于装饰器和被装饰的原始函数的复合函数。
- en: 'A decorator function can be used in one of the two following ways:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数可以用以下两种方式之一使用：
- en: 'As a prefix that creates a new function with the same name as the base function
    as follows:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个前缀，创建一个与基本函数同名的新函数，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As an explicit operation that returns a new function, possibly with a new name:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个显式操作，返回一个新的函数，可能有一个新的名称：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These are two different syntaxes for the same operation. The prefix notation
    has the advantages of being tidy and succinct. The prefix location is more visible
    to some readers. The suffix notation is explicit and slightly more flexible. While
    the prefix notation is common, there is one reason for using the suffix notation:
    we might not want the resulting function to replace the original function. We
    might want to execute the following command that allows us to use both the decorated
    and the undecorated functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相同操作的两种不同语法。前缀表示法的优点是整洁和简洁。对于某些读者来说，前缀位置更加可见。后缀表示法是显式的，稍微更加灵活。虽然前缀表示法很常见，但使用后缀表示法的一个原因是：我们可能不希望结果函数替换原始函数。我们可能希望执行以下命令，允许我们同时使用装饰和未装饰的函数：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Python functions are first-class objects. A function that accepts a function
    as an argument and returns a function as the result is clearly a built-in feature
    of the language. The open question then is how do we update or adjust the internal
    code structure of a function?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数是一等对象。接受函数作为参数并返回函数作为结果的函数显然是语言的内置特性。那么，我们如何更新或调整函数的内部代码结构呢？
- en: The answer is we don't.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们不需要。
- en: 'Rather than messing about on the inside of the code, it''s much cleaner to
    define a new function that wraps the original function. We have two tiers of higher-order
    functions involved in defining a decorator as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在代码内部胡乱搞，不如定义一个包装原始函数的新函数更清晰。在定义装饰器时，我们涉及两个高阶函数层次：
- en: The decorator function applies a wrapper to a base function and returns the
    new wrapper. This function can do some one-time only evaluation as part of building
    the decorated function.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器函数将包装器应用于基本函数，并返回新的包装器。此函数可以作为构建装饰函数的一次性评估。
- en: The wrapper function can (and usually does) evaluate the base function. This
    function will be evaluated every time the decorated function is evaluated.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装函数可以（通常会）评估基本函数。每次评估装饰函数时，都会评估此函数。
- en: 'Here''s an example of a simple decorator:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单装饰器的例子：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We almost always want to use the `functools.wraps()` function to assure that
    the decorated function retains the attributes of the original function. Copying
    the `__name__`, and `__doc__` attributes, for example, assures that the resulting
    decorated function has the name and docstring of the original function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是希望使用`functools.wraps()`函数来确保装饰的函数保留原始函数的属性。例如，复制`__name__`和`__doc__`属性可以确保结果装饰的函数具有原始函数的名称和文档字符串。
- en: The resulting composite function, called `null_wrapper()` function in the definition
    of the decorator, is also a kind of higher-order function that combines the original
    function, the `function()` function, in an expression that preserves the `None`
    values. The original function is not an explicit argument; it is a free variable
    that will get its value from the context in which the `wrapper()` function is
    defined.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所得到的复合函数，在装饰器的定义中称为`null_wrapper()`函数，也是一种高阶函数，它将原始函数`function()`函数与一个保留`None`值的表达式相结合。原始函数不是一个显式参数；它是一个自由变量，将从定义`wrapper()`函数的上下文中获取其值。
- en: 'The decorator function''s return value will return the newly minted function.
    It''s important that decorators only return functions, and not attempt any processing
    of data. Decorators are meta-programming: a code that creates a code. The `wrapper()`
    function, however, will be used to process the real data.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数的返回值将返回新创建的函数。装饰器只返回函数，不会尝试处理任何数据。装饰器是元编程：创建代码的代码。然而，`wrapper()`函数将用于处理真实的数据。
- en: 'We can apply our `@nullable` decorator to create a composite function as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用我们的`@nullable`装饰器来创建一个复合函数，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now have a function, `nlog()`, which is a null-aware version of the `math.log()`
    function. We can use our composite, `nlog()` function, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个函数`nlog()`，它是`math.log()`函数的空值感知版本。我们可以使用我们的复合函数`nlog()`，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've applied the function to a collection of data values. The `None` value
    politely leads to a `None` result. There was no exception processing involved.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将函数应用于一组数据值。`None`值礼貌地导致`None`结果。没有涉及异常处理。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example isn't really suitable for unit testing. We'll need to round the
    values for testing purposes. For this, we'll need a null-aware `round()` function
    too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不适合进行单元测试。我们需要对值进行四舍五入以进行测试。为此，我们还需要一个空值感知的`round()`函数。
- en: 'Here''s how we can create a null-aware rounding function using decorator notation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用装饰符表示法创建空值感知舍入函数的方法：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function is a partial application of the `round()` function, wrapped to
    be null-aware. In some respects, this is a relatively sophisticated bit of functional
    programming that's readily available to Python programmers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`round()`函数的部分应用，包装成空值感知。在某些方面，这是一种相对复杂的函数式编程，对Python程序员来说是很容易使用的。
- en: 'We could also create the null-aware rounding function using the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下方法创建空值感知的四舍五入函数：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This has the same effect, at some cost in clarity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有相同的效果，但在清晰度方面有一些成本。
- en: 'We can use this `round4()` function to create a better test case for our `nlog()`
    function as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`round4()`函数来创建一个更好的测试用例，用于我们的`nlog()`函数，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This result will be independent of any platform considerations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果将独立于任何平台考虑。
- en: This decorator makes an assumption that the decorated function is unary. We
    would need to revisit this design to create a more general-purpose null-aware
    decorator that works with arbitrary collections of arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器假设被装饰的函数是一元的。我们需要重新审视这个设计，以创建一个更通用的空值感知装饰器，可以处理任意集合的参数。
- en: In [Chapter 14](ch14.html "Chapter 14. The PyMonad Library"), *The PyMonad Library*,
    we'll look at an alternative approach to this problem of tolerating the `None`
    values. The `PyMonad` library defines a `Maybe` class of objects which may have
    a proper value or may be the `None` value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.html "第14章。PyMonad库")中，*PyMonad库*，我们将看一种容忍`None`值的问题的替代方法。`PyMonad`库定义了一个`Maybe`对象类，它可能有一个适当的值，也可能是`None`值。
- en: Using functool's update_wrapper() functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用functool的update_wrapper()函数
- en: The `@wraps` decorator applies the `update_wrapper()` function to preserve a
    few attributes of a wrapped function. In general, this does everything we need
    by default. This function copies a specific list of attributes from the original
    function to the resulting function created by a decorator. What's the specific
    list of attributes? It's defined by a module global.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@wraps`装饰器应用`update_wrapper()`函数以保留包装函数的一些属性。一般来说，这默认情况下就做了我们需要的一切。这个函数将一些特定的属性从原始函数复制到装饰器创建的结果函数中。具体的属性列表是什么？它由一个模块全局变量定义。'
- en: 'The `update_wrapper()` function relies on a module global variable to determine
    what attributes to preserve. The `WRAPPER_ASSIGNMENTS` variable defines the attributes
    that are copied by default. The default value is this list of attributes to copy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_wrapper()`函数依赖于一个模块全局变量来确定要保留哪些属性。`WRAPPER_ASSIGNMENTS`变量定义了默认情况下要复制的属性。默认值是要复制的属性列表：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's difficult to make meaningful modifications to this list. In order to copy
    additional attributes, we have to assure that our functions are defined with these
    additional attributes. This is challenging, since the internals of the `def` statement
    aren't open to simple modification or change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个列表进行有意义的修改是困难的。为了复制额外的属性，我们必须确保我们的函数是用这些额外的属性定义的。这是具有挑战性的，因为`def`语句的内部不容易进行简单的修改或更改。
- en: Because we can't easily fold in new attributes, it's difficult to locate reasons
    to modify or extend the way the wrapping works on a function. It's mostly interesting
    to use this variable as a piece of reference information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不能轻松地合并新的属性，所以很难找到修改或扩展包装函数工作方式的原因。将这个变量作为参考信息大多是有趣的。
- en: If we're going to use the `callable` objects, then we might have a class that
    provides some additional attributes as part of the definition. We could then have
    a situation where a decorator might need to copy these additional attributes from
    the original wrapped `callable` object to the wrapping function being created.
    However, it seems simpler to make these kinds of changes in the class definition
    itself, rather than exploit tricky decorator techniques.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用`callable`对象，那么我们可能会有一个类，它在定义中提供了一些额外的属性。然后我们可能会遇到这样一种情况，装饰器可能需要将这些额外的属性从原始的被包装的`callable`对象复制到正在创建的包装函数中。然而，似乎更简单的是在类定义本身中进行这些更改，而不是利用棘手的装饰器技术。
- en: While there's a lot of flexibility available, much of it isn't helpful for ordinary
    application development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多灵活性可用，但大部分对于普通应用程序开发并不有用。
- en: Cross-cutting concerns
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横切关注点
- en: One general principle behind decorators is to allow us to build a composite
    function from the decorator and the original function to which the decorator is
    applied. The idea is to have a library of common decorators that can provide implementations
    for common concerns.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器背后的一个一般原则是允许我们从应用装饰器的原始函数和装饰器构建一个复合函数。这个想法是有一个常见装饰器库，可以为常见关注点提供实现。
- en: We often call these cross-cutting concerns because they apply across several
    functions. These are the sorts of things that we would like to design once via
    a decorator and have them applied in relevant classes throughout an application
    or a framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常称这些横切关注，因为它们适用于几个函数。这些是我们希望通过装饰器设计一次并在应用程序或框架中的相关类中应用的事物。
- en: 'Concerns that are often centralized as described previously include the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常集中描述的关注点包括以下内容：
- en: Logging
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Auditing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: Security
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Handling incomplete data
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不完整的数据
- en: A `logging` decorator, for example, might write standardized messages to the
    application's logfile. An audit decorator might write details surrounding a database
    update. A security decorator might check some runtime context to be sure that
    the login user has the necessary permissions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`logging`装饰器可能会向应用程序的日志文件写入标准化消息。审计装饰器可能会写入围绕数据库更新的详细信息。安全装饰器可能会检查一些运行时上下文，以确保登录用户具有必要的权限。
- en: Our example of a *null-aware* wrapper for a function is a cross-cutting concern.
    In this case, we'd like to have a number of functions handle the `None` values
    by returning the `None` values instead of raising an exception. In applications
    where data is incomplete, we may have a need to process rows in a simple, uniform
    way without having to write lots of distracting `if` statements to handle missing
    values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一个示例是对函数的*空值感知*包装器是一个横切关注。在这种情况下，我们希望有许多函数处理`None`值，而不是引发异常返回`None`值。在数据不完整的应用程序中，我们可能需要以简单、统一的方式处理行，而不必编写大量分散注意力的`if`语句来处理缺失值。
- en: Composite design
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合设计
- en: 'The common mathematical notation for a composite function looks as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 复合函数的常见数学表示如下：
- en: '![Composite design](graphics/B03652_11_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![组合设计](graphics/B03652_11_03.jpg)'
- en: The idea is that we can define a new function, ![Composite design](graphics/B03652_11_01.jpg),
    that combines two other functions, ![Composite design](graphics/B03652_11_04.jpg)and
    ![Composite design](graphics/B03652_11_05.jpg).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是我们可以定义一个新函数，![组合设计](graphics/B03652_11_01.jpg)，它结合了另外两个函数，![组合设计](graphics/B03652_11_04.jpg)和![组合设计](graphics/B03652_11_05.jpg)。
- en: 'Python''s multiple-line definition of the form is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python的多行定义形式如下：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is vaguely equivalent to ![Composite design](graphics/B03652_11_01.jpg).
    The equivalence isn't very precise because the `@f` decorator isn't the same as
    the mathematical abstraction of composing ![Composite design](graphics/B03652_11_04.jpg)
    and ![Composite design](graphics/B03652_11_05.jpg). For the purposes of discussing
    function composition, we'll ignore the implementation disconnect between the abstraction
    of ![Composite design](graphics/B03652_11_04.jpg) and the `@f` decorator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上相当于![组合设计](graphics/B03652_11_01.jpg)。等价性并不是非常精确，因为`@f`装饰器与组合![组合设计](graphics/B03652_11_04.jpg)和![组合设计](graphics/B03652_11_05.jpg)的数学抽象不同。在讨论函数组合的目的时，我们将忽略![组合设计](graphics/B03652_11_04.jpg)的抽象和`@f`装饰器之间的实现断开连接。
- en: 'Because decorators wrap another function, Python offers a slightly more generalized
    composition. We can think of Python design as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为装饰器包装另一个函数，Python提供了一个稍微更一般化的组合。我们可以将Python设计思考如下：
- en: '![Composite design](graphics/B03652_11_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![组合设计](graphics/B03652_11_06.jpg)'
- en: A decorator applied to some application function, ![Composite design](graphics/B03652_11_05.jpg),
    will include a wrapper function. One portion of the wrapper, ![Composite design](graphics/B03652_11_07.jpg),
    applies before the wrapped function and the other portion, ![Composite design](graphics/B03652_11_08.jpg),
    applies after the wrapped function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器应用于某些应用程序函数，![组合设计](graphics/B03652_11_05.jpg)，将包括一个包装器函数。包装器的一部分，![组合设计](graphics/B03652_11_07.jpg)，应用于包装函数之前，另一部分，![组合设计](graphics/B03652_11_08.jpg)，应用于包装函数之后。
- en: '`The Wrapper()` function often looks as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wrapper()`函数通常如下所示：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Details will vary, and vary widely. There are many clever things that can be
    done within this general framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 细节会有所不同，而且差异很大。在这个一般框架内可以做很多聪明的事情。
- en: A great deal of functional programming amounts to ![Composite design](graphics/B03652_11_02.jpg)
    kinds of constructs. We often spell these functions out because there's no real
    benefit from summarizing the function into a composite, ![Composite design](graphics/B03652_11_01.jpg).
    In some cases, however, we might want to use a composite function with a higher-order
    function like `map()`, `filter(),` or `reduce()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的函数式编程归结为![组合设计](graphics/B03652_11_02.jpg)种类的构造。我们经常拼写这些函数，因为将函数总结为一个组合，![组合设计](graphics/B03652_11_01.jpg)，并没有真正的好处。然而，在某些情况下，我们可能希望使用一个高阶函数，比如`map()`、`filter()`或`reduce()`来使用一个复合函数。
- en: 'We can always resort to the `map(f, map(g, x))` method. It might be more clear,
    however, to use the `map(f_g, x)` method to apply a composite to a collection.
    It''s important to note that there''s no inherent performance advantage to either
    technique. The `map()` function is lazy: with two `map()` functions, one item
    will be taken from `x`, processed by the `g()` function, and then processed by
    the `f()` function. With a single `map()` function, an item will be taken from
    `x` and then processed by the `f_g()` composite function.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以使用`map(f, map(g, x))`方法。然而，使用`map(f_g, x)`方法来应用一个复合到一个集合可能更清晰。重要的是要注意，这两种技术都没有固有的性能优势。`map()`函数是惰性的：使用两个`map()`函数，一个项目将从`x`中取出，由`g()`函数处理，然后由`f()`函数处理。使用单个`map()`函数，一个项目将从`x`中取出，然后由`f_g()`复合函数处理。
- en: In [Chapter 14](ch14.html "Chapter 14. The PyMonad Library"), *The PyMonad Library*,
    we'll look at an alternative approach to this problem of creating composite functions
    from individual curried functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.html "第14章。PyMonad库")中，*PyMonad库*，我们将看看从单独的柯里化函数创建复合函数的另一种方法。
- en: Preprocessing bad data
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理坏数据
- en: One cross-cutting concern in some exploratory data analysis applications is
    how to handle numeric values that are missing or cannot be parsed. We often have
    a mixture of `float`, `int`, and `Decimal` currency values that we'd like to process
    with some consistency.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些探索性数据分析应用中的一个横切关注点是如何处理丢失或无法解析的数值。我们经常有一些`float`、`int`和`Decimal`货币值的混合，我们希望以一定的一致性处理它们。
- en: 'In other contexts, we have *not applicable* or *not available* data values
    that shouldn''t interfere with the main thread of the calculation. It''s often
    handy to allow the `Not Applicable` values to pass through an expression without
    raising an exception. We''ll focus on three bad-data conversion functions: `bd_int()`,
    `bd_float(),` and `bd_decimal()`. The composite feature we''re adding will be
    defined before the built-in conversion function.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情境中，我们有*不适用*或*不可用*的数据值，不应干扰计算的主线。允许`Not Applicable`值在不引发异常的情况下通过表达式通常很方便。我们将专注于三个坏数据转换函数：`bd_int()`、`bd_float()`和`bd_decimal()`。我们要添加的复合特性将在内置转换函数之前定义。
- en: 'Here''s a simple bad-data decorator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的坏数据装饰器：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function wraps a given conversion function to try a second conversion in
    the event the first conversion involved bad data. In the case of preserving the
    `None` values as a `Not Applicable` code, the exception handling would simply
    return the `None` value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包装了一个给定的转换函数，以尝试在第一次转换涉及坏数据时进行第二次转换。在保留`None`值作为`Not Applicable`代码的情况下，异常处理将简单地返回`None`值。
- en: In this case, we've provided Python `*args` and `**kw` parameters. This assures
    that the wrapped functions can have additional argument values provided.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了Python的`*args`和`**kw`参数。这确保了包装函数可以提供额外的参数值。
- en: 'We can use this wrapper as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个包装器如下：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a suite of functions that can do conversions of good data as
    well as a limited amount of data cleansing to handle specific kinds of bad data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一套函数，可以对良好的数据进行转换，同时也可以进行有限的数据清洗，以处理特定类型的坏数据。
- en: 'Following are some examples of using the `bd_int()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`bd_int()`函数的一些示例：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've applied the `bd_int()` function to a string that converted neatly and
    a string with the specific type of punctuation that we'll tolerate. We've also
    shown that we can provide additional parameters to each of these conversion functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`bd_int()`函数应用于一个字符串，它转换得很整洁，还有一个带有特定类型标点符号的字符串，我们将容忍它。我们还表明我们可以为每个转换函数提供额外的参数。
- en: We might like to have a more flexible decorator. One feature that we might like
    to add is the ability to handle a variety of data scrubbing alternatives. Simple`,`
    removal isn't always what we need. We may also need to remove `$`, or `°` symbols,
    too. We'll look at more sophisticated, parameterized decorators in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有一个更灵活的装饰器。我们可能希望添加的一个功能是处理各种数据清洗的能力。简单的`,`移除并不总是我们需要的。我们可能还需要移除`$`或`°`符号。我们将在下一节中看到更复杂的、带参数的装饰器。
- en: Adding a parameter to a decorator
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向装饰器添加参数
- en: A common requirement is to customize a decorator with additional parameters.
    Rather than simply creating a composite ![Adding a parameter to a decorator](graphics/B03652_11_01.jpg),
    we're doing something a bit more complex. We're creating ![Adding a parameter
    to a decorator](graphics/B03652_11_09.jpg). We've applied a parameter, *c*, as
    part of creating the wrapper. This parameterized composite,![Adding a parameter
    to a decorator](graphics/B03652_11_10.jpg), can then be used with the actual data,
    *x*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的要求是使用额外的参数自定义装饰器。我们不仅仅是创建一个复合的![向装饰器添加参数](graphics/B03652_11_01.jpg)，我们做的事情要复杂一些。我们正在创建![向装饰器添加参数](graphics/B03652_11_09.jpg)。我们应用了一个参数，*c*，作为创建包装器的一部分。这个参数化的复合物，![向装饰器添加参数](graphics/B03652_11_10.jpg)，然后可以与实际数据*x*一起使用。
- en: 'In Python syntax, we can write it as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python语法中，我们可以写成如下形式：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will provide a parameterized `deco(arg)` function to the base function
    definition.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为基本函数定义提供一个参数化的`deco(arg)`函数。
- en: 'The effect is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 效果如下：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve done three things and they are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了三件事，它们如下：
- en: Define a function, `func.`
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数`func.`
- en: Apply the abstract decorator, `deco()`, to its arguments to create a concrete
    decorator, `deco(arg).`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将抽象装饰器`deco()`应用于其参数，以创建一个具体的装饰器`deco(arg).`
- en: Apply the concrete decorator, `deco(arg)`, to the base function to create the
    decorated version of the function, `deco(arg)(func).`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具体的装饰器`deco(arg)`应用于基本函数，以创建函数的装饰版本`deco(arg)(func).`
- en: 'A decorator with arguments involves indirect construction of the final function.
    We seem to have moved beyond merely higher-order functions into something even
    more abstract: higher-order functions that create higher-order functions.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 带有参数的装饰器涉及间接构建最终函数。我们似乎已经超越了仅仅是高阶函数，进入了更抽象的领域：创建高阶函数的高阶函数。
- en: 'We can expand our *bad-data* aware decorator to create a slightly more flexible
    conversion. We''ll define a decorator that can accept parameters of characters
    to remove. Following is a parameterized decorator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的*bad-data*感知装饰器，以创建一个稍微更灵活的转换。我们将定义一个可以接受要移除的字符参数的装饰器。以下是一个带参数的装饰器：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A parameterized decorator has three parts and they are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带参数的装饰器有三个部分，它们如下：
- en: The overall decorator. This defines and returns the abstract decorator. In this
    case, the `cr_decorator` is an abstract decorator. This has a free variable, `char_list`,
    that comes from the initial decorator.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体装饰器。这定义并返回抽象装饰器。在这种情况下，`cr_decorator`是一个抽象装饰器。它有一个自由变量`char_list`，来自初始装饰器。
- en: The abstract decorator. In this case, the `cr_decorator` decorator will have
    its free variable, `char_list`, bound so that it can be applied to a function.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象装饰器。在这种情况下，`cr_decorator` 装饰器将绑定其自由变量 `char_list`，以便可以应用到一个函数。
- en: The decorating wrapper. In this example, the `wrap_char_remove` function will
    replace the wrapped function. Because of the `@wraps` decorator, the `__name__`
    (and other attributes) will be replaced with the name of the function being wrapped.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰包装器。在这个例子中，`wrap_char_remove` 函数将替换被包装的函数。由于 `@wraps` 装饰器，`__name__`（和其他属性）将被替换为被包装的函数的名称。
- en: 'We can use this decorator to create conversion functions as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个装饰器来创建转换函数，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've used our decorator to wrap a `currency()` function. The essential feature
    of the `currency()` function is a reference to the `decimal.Decimal` constructor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用我们的装饰器来包装一个 `currency()` 函数。`currency()` 函数的基本特征是对 `decimal.Decimal` 构造函数的引用。
- en: 'This `currency()` function will now handle some variant data formats:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `currency()` 函数现在将处理一些变体数据格式：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now process input data using a relatively simple `map(currency, row)`
    method to convert source data from strings to usable `Decimal` values. The `try:/except:`
    error-handling has been isolated to a function that we've used to build a composite
    conversion function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用相对简单的 `map(currency, row)` 方法来处理输入数据，将源数据从字符串转换为可用的 `Decimal` 值。`try:/except:`
    错误处理已经被隔离到一个函数中，我们用它来构建一个复合转换函数。
- en: We can use a similar design to create Null-tolerant functions. These functions
    would use a similar `try:/except:` wrapper, but would simply return the `None`
    values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的设计来创建空值容忍函数。这些函数将使用类似的 `try:/except:` 包装器，但只会返回 `None` 值。
- en: Implementing more complex descriptors
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现更复杂的描述符
- en: 'We can easily write the following commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地编写以下命令：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's nothing in Python to stop us. This has a meaning somewhat like ![Implementing
    more complex descriptors](graphics/B03652_11_11.jpg). However, the name is merely
    ![Implementing more complex descriptors](graphics/B03652_11_12.jpg). Because of
    this potential confusion, we need to be cautious when creating functions that
    involve deeply nested descriptors. If our intent is simply to handle some cross-cutting
    concerns, then each decorator can handle a concern without creating much confusion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中没有任何阻止我们的东西。这有一些类似于 ![实现更复杂的描述符](graphics/B03652_11_11.jpg)。然而，名称仅仅是
    ![实现更复杂的描述符](graphics/B03652_11_12.jpg)。因此，当创建涉及深度嵌套描述符的函数时，我们需要谨慎。如果我们的意图只是处理一些横切关注，那么每个装饰器可以处理一个关注而不会造成太多混乱。
- en: 'If, on the other hand, we''re using a decoration to create a composite function,
    it might also be better to use the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用装饰来创建一个复合函数，那么使用以下命令可能更好：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This clarifies as to what precisely is going on. Decorator functions don't correspond
    precisely with the mathematical abstraction of functions being composed. The decorator
    function actually contains a wrapper function that will contain the function being
    composed. This distinction between a function and a decorator that creates a composite
    from the function can become a problem when trying to understand an application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这澄清了正在发生的事情。装饰器函数并不完全对应于函数被组合的数学抽象。装饰器函数实际上包含一个包装器函数，该包装器函数将包含被组合的函数。当尝试理解应用程序时，函数和创建函数组合的装饰器之间的区别可能会成为一个问题。
- en: As with other aspects of functional programming, a succinct and expressive program
    is the goal. Decorators who are expressive are welcome. Writing an über-meta-super-callable
    that can do everything in the application with only minor customizations may be
    succinct, but it's rarely expressive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数式编程的其他方面一样，简洁和表达力是目标。具有表达力的装饰器是受欢迎的。编写一个可以在应用程序中完成所有事情的超级可调用函数，只需要进行轻微的定制，可能是简洁的，但很少是表达性的。
- en: Recognizing design limitations
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别设计限制
- en: 'In the case of our data cleanup, the simplistic removal of stray characters
    may not be sufficient. When working with the geolocation data, we may have a wide
    variety of input formats that include simple degrees (`37.549016197`), degrees
    and minutes (`37° 32.94097′`), and degrees-minutes-seconds (`37° 32′ 56.46″`).
    Of course, there can be even more subtle cleaning problems: some devices will
    create an output with the Unicode U+00BA character, `º`, instead of the similar-looking
    degree character, `°`, which is U+00B0.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据清理的情况下，简单地去除杂散字符可能是不够的。在处理地理位置数据时，我们可能会有各种各样的输入格式，包括简单的度数（`37.549016197`），度和分钟（`37°
    32.94097′`），以及度-分-秒（`37° 32′ 56.46″`）。当然，还可能存在更微妙的清理问题：一些设备会创建一个带有 Unicode U+00BA
    字符 `º` 的输出，而不是类似的度字符 `°`，它是 U+00B0。
- en: For this reason, it is often necessary to provide a separate cleansing function
    that's bundled in with the conversion function. This function will handle the
    more sophisticated conversions required by inputs that are as wildly inconsistent
    in format as latitudes and longitudes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常需要提供一个单独的清理函数，与转换函数捆绑在一起。这个函数将处理输入格式非常不一致的输入所需的更复杂的转换，比如纬度和经度。
- en: How can we implement this? We have a number of choices. Simple higher-order
    functions are a good choice. A decorator, on the other hand, doesn't work out
    terribly well. We'll look at a decorator-based design to see that there are limitations
    to what makes sense in a decorator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个？我们有很多选择。简单的高阶函数是一个不错的选择。另一方面，装饰器并不是一个很好的选择。我们将看一个基于装饰器的设计，以了解装饰器的合理性有限制。
- en: 'The requirements have two orthogonal design considerations and they are as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要求有两个正交设计考虑，它们如下：
- en: The output conversion (`int`, `float`, `Decimal`)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出转换（`int`，`float`，`Decimal`）
- en: The input cleaning (clean stray characters, reformat coordinates)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入清理（清除杂散字符，重新格式化坐标）
- en: Ideally, one of these aspects is an essential function that gets wrapped and
    the other aspect is something that's included via a wrapper. The choice of essence
    versus wrap isn't clear. One of the reasons it isn't clear is that our previous
    examples are a bit more complex than a simple two-part composite.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，其中一个方面是一个被包装的基本函数，另一个方面是通过包装器包含的内容。本质与包装的选择并不清晰。其中一个原因是我们之前的例子比简单的两部分组合要复杂一些。
- en: 'In the previous examples, we were actually creating a three-part composite:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们实际上创建了一个三部分的组合：
- en: The output conversion (`int`, `float`, `Decimal`)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出转换（`int`，`float`，`Decimal`）
- en: The input cleansing—either a simple replace or a more complex multiple-character
    replacement
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入清洁——可以是简单的替换，也可以是更复杂的多字符替换
- en: The function which attempted the conversion, did the cleansing as a response
    to an exception, and attempted the conversion again
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试转换的函数，作为对异常的响应进行清洁，并再次尝试转换
- en: The third part – attempting the conversion and retrying – is the actual wrapper
    that also forms a part of the composite function. As we noted previously, a wrapper
    contains a before phase and an after phase, which we've called ![Recognizing design
    limitations](graphics/B03652_11_07.jpg) and ![Recognizing design limitations](graphics/B03652_11_08.jpg),
    respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分——尝试转换和重试——实际上是包装器，也是组合函数的一部分。正如我们之前提到的，包装器包含一个前阶段和一个后阶段，我们分别称之为![识别设计限制](graphics/B03652_11_07.jpg)和![识别设计限制](graphics/B03652_11_08.jpg)。
- en: 'We want to use this wrapper to create a composite of two additional functions.
    We have two choices for the syntax. We could include the cleansing function as
    an argument to the decorator on the conversion as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用这个包装器来创建两个额外函数的组合。对于语法，我们有两种选择。我们可以将清洁函数作为装饰器的参数包含在转换中，如下所示：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or, we could include the conversion function as an argument to the decorator
    for a cleansing function as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将转换函数作为清洁函数的装饰器的参数包含如下：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, we can choose the `@then_convert(converter)` style decorator because
    we're relying—for the most part—on the built-in conversions. Our point is to show
    that the choice is not crystal clear.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以选择`@then_convert(converter)`样式的装饰器，因为我们在很大程度上依赖于内置转换。我们的观点是要表明选择并不是非常清晰的。
- en: 'The decorator looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器如下所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've defined a three-layer decorator. At the heart is the `cc_wrapper()` function
    that applies the `convert_function` function. If this fails, then it uses a `clean_function`
    function and then tries the `convert_function` function again. This function is
    wrapped around the `clean_function` function by the `then_convert_decorator()`
    concrete decorator function. The concrete decorator has the `convert_function`
    function as a free variable. The concrete decorator is created by the decorator
    interface, `then_convert()`, which is customized by a conversion function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个三层装饰器。核心是`cc_wrapper()`函数，应用`convert_function`函数。如果失败，它会使用`clean_function`函数，然后再次尝试`convert_function`函数。这个函数被`then_convert_decorator()`具体装饰器函数包裹在`clean_function`函数周围。具体装饰器具有`convert_function`函数作为自由变量。具体装饰器由装饰器接口`then_convert()`创建，该接口由转换函数定制。
- en: 'We can now build a slightly more flexible cleanse and convert function as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个稍微更灵活的清洁和转换函数，如下所示：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The integer conversion is a decorator applied to the given cleansing function.
    In this case, the cleansing function removes `$` and `,` characters. The integer
    conversion is wrapped around this cleansing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 整数转换是应用于给定清洁函数的装饰器。在这种情况下，清洁函数移除了`$`和`,`字符。整数转换包裹在这个清洁函数周围。
- en: 'We can use the integer conversion as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用整数转换：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While this can encapsulate some sophisticated cleansing and converting into
    a very tidy package, the results are potentially confusing. The name of the function
    is the name of the core cleansing algorithm; the other function's contribution
    to the composite is lost.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以将一些复杂的清洁和转换封装成一个非常整洁的包，但结果可能令人困惑。函数的名称是核心清洁算法的名称；另一个函数对组合的贡献被忽略了。
- en: 'As an alternative, we can use the integer conversion as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，我们可以如下使用整数转换：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will allow us to provide a new name to the decorated cleaning function.
    This solves the naming problem, but the construction of the final function via
    the `then_convert(int)(drop_punct)` method is rather opaque.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们为装饰的清洁函数提供一个新的名称。这解决了命名问题，但是通过`then_convert(int)(drop_punct)`方法构建最终函数的过程相当不透明。
- en: It seems like we've reached the edge of the envelope here. The decorator model
    isn't ideal for this kind of design. Generally, decorators work well when we have
    a number of relatively simple and fixed aspects that we want to include with a
    given function (or a class). Decorators are also important when these additional
    aspects can be looked at as an infrastructure or a support, and not something
    essential to the meaning of the application code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经触及了边界。装饰器模式并不适合这种设计。一般来说，当我们有一些相对简单和固定的方面要与给定的函数（或类）一起包含时，装饰器的效果很好。当这些额外的方面可以被看作是基础设施或支持，而不是应用代码含义的重要部分时，装饰器也很重要。
- en: For something that involves multiple orthogonal dimensions, we might want to
    result to the `Callables` function with various kinds of plugin strategy objects.
    This might provide something more palatable. We might want to look closely at
    creating higher-order functions. We can then create partial functions with various
    combinations of parameters for the higher-order functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及多个正交维度的事物，我们可能希望使用各种插件策略对象的`Callables`函数。这可能提供更可接受的东西。我们可能需要仔细研究创建高阶函数。然后，我们可以为高阶函数的各种参数组合创建部分函数。
- en: The typical examples of logging or security testing can be considered as the
    kind of background processing that isn't specific to the problem domain. When
    we have processing that is as ubiquitous as the air that surrounds us, then a
    decorator might be more appropriate.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的日志记录或安全测试示例可以被视为与问题域无关的后台处理类型。当我们的处理与我们周围的空气一样普遍时，那么装饰器可能更合适。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve looked at two kinds of decorators: the simple decorator
    with no arguments and parameterized decorators. We''ve seen how decorators involve
    an indirect composition between functions: the decorator wraps a function (defined
    inside the decorator) around another function.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了两种类型的装饰器：没有参数的简单装饰器和带参数的装饰器。我们看到装饰器涉及函数之间的间接组合：装饰器将一个函数（在装饰器内部定义）包裹在另一个函数周围。
- en: Using the `functools.wraps()` decorator assures that our decorators will properly
    copy attributes from the function being wrapped. This should be a piece of every
    decorator we write.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`functools.wraps()`装饰器可以确保我们的装饰器能够正确地从被包装的函数中复制属性。这应该是我们编写的每个装饰器的一部分。
- en: In the next chapter, we'll look at the multiprocessing and multithreading techniques
    that are available to us. These packages become particularly helpful in a functional
    programming context. When we eliminate a complex shared state and design around
    nonstrict processing, we can leverage parallelism to improve the performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下可用于我们的多进程和多线程技术。这些包在函数式编程环境中特别有帮助。当我们消除复杂的共享状态并设计非严格处理时，我们可以利用并行性来提高性能。
