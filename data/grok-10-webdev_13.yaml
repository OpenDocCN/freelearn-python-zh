- en: Chapter 12. Grokkers, Martian, and Agile Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Grokkers，火星和敏捷配置
- en: 'Agility is very important in Grok, and having to do less configuration to get
    an application running is the key to being **agile**. In Grok parlance, a **grokker**
    is a piece of code that allows developers to use framework functionality by making
    declarations in the code instead of using ZCML configuration files. In this chapter,
    we introduce **Martian** the library that is used to create grokkers and demonstrate
    how to create a simple one for our application. Among the subjects that we will
    cover are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷性在Grok中非常重要，并且为了使应用程序运行而需要做更少的配置是**敏捷**的关键。在Grok术语中，**grokker**是一段代码，允许开发者通过在代码中声明而不是使用ZCML配置文件来使用框架功能。在本章中，我们介绍了用于创建grokkers的库**火星**，并演示了如何为我们自己的应用程序创建一个简单的grokker。我们将涵盖的主题包括：
- en: What Martian is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是火星
- en: Why it is needed and how Grok uses it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要它以及Grok如何使用它
- en: What a grokker is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是grokker
- en: How to create a grokker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个grokker
- en: Agile configuration
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷配置
- en: As we explained at the very beginning of this book, when we use the Zope Toolkit
    without Grok, we must use ZCML to configure everything. This means that we have
    to add ZCML directives for every view, viewlet, adapter, subscriber, and annotation
    in our code. That's quite a lot of markup there, all of which has to be maintained
    along with the code. Agility is not the first thing that comes to mind when we
    think about this.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书一开始所解释的，当我们不使用Grok而使用Zope Toolkit时，我们必须使用ZCML来配置一切。这意味着我们必须为代码中的每个视图、视图组件、适配器、订阅者和注释添加ZCML指令。这里有很多标记，所有这些都必须与代码一起维护。当我们想到这一点时，敏捷性并不是首先想到的。
- en: Grok's developers knew from experience that the Zope Toolkit and the **Zope
    Component Architecture** (**ZCA**) enable developers to create advanced object-oriented
    systems. This power comes at the cost of a raised barrier of entry for new developers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Grok的开发者从经验中知道，Zope Toolkit和**Zope组件架构**（**ZCA**）使开发者能够创建高级面向对象系统。这种力量是以新开发者进入门槛提高为代价的。
- en: Another thing that proved to be a problem for Zope Toolkit adoption, is its
    emphasis on explicit configuration. ZCML allows developers to be very explicit
    and flexible in their application configuration, but it requires separate files
    for configuration, and takes more time to create, maintain, and understand. You
    simply need more time to understand an application because you have to take a
    look at the different pieces of code and then consult the ZCML files to see how
    they are connected with each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个证明是Zope Toolkit采用问题的是，它对显式配置的强调。ZCML允许开发者在其应用程序配置中非常明确和灵活，但它需要为配置单独的文件，并且需要更多的时间来创建、维护和理解。你只需要更多的时间来理解一个应用程序，因为你必须查看不同的代码片段，然后查阅ZCML文件以了解它们是如何相互关联的。
- en: Grok was designed in such a way that, if the developer follows certain conventions
    in his code, there is no need for configuration files. Instead, Grok analyzes
    the Python code for the use of these conventions, and then 'groks' them. Behind
    the scenes, everything is connected just as it would be if the configuration was
    written with ZCML, but the developer doesn't even need to think about that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Grok被设计成这样的方式，如果开发者在其代码中遵循某些约定，则不需要配置文件。相反，Grok分析Python代码以使用这些约定，然后“理解”它们。幕后，一切连接正如如果配置是用ZCML编写的，但开发者甚至不需要考虑这一点。
- en: As a result of this process, known as 'grokking', the code for a Grok application
    is clean and uniform. The entire configuration is in the code, in the form of
    directives and components, so it's easier to follow, and more fun to develop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个过程被称为“理解”，因此Grok应用程序的代码干净且统一。整个配置都在代码中，以指令和组件的形式存在，因此更容易遵循，开发起来更有趣。
- en: Grok is definitely more agile than the Zope Toolkit alone, but it's not a subset
    or a 'stripped down' version of it. All of the power of the Zope Toolkit is available
    to the developer. Even explicit configuration can be used with ZCML when it's
    needed, as we saw when we configured the SMTP mailer, in the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Grok确实比单独的Zope Toolkit更敏捷，但它不是它的子集或“简化版”。Zope Toolkit的所有功能都对开发者可用。甚至在需要时，可以使用ZCML进行显式配置，就像我们在上一章配置SMTP邮件器时所看到的那样。
- en: The Martian library
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火星库
- en: The part of Grok that does the code 'grokking' has been extracted into a standalone
    library called Martian. This library provides a framework that allows configuration
    to be expressed in Python code, in the form of declarative statements. The idea
    is that, often, the structure of a piece of code can be examined and most of the
    configuration steps that it requires are deduced from this. Martian takes this
    a step further by using directives to annotate the code, making configuration
    requirements even more obvious.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 中执行代码 'grokking' 的部分已被提取到一个名为 Martian 的独立库中。这个库提供了一个框架，允许以 Python 代码的形式表达配置，形式为声明性语句。想法是，通常，可以检查代码的结构，并且大多数它所需的配置步骤都可以从这个结构中推断出来。火星人通过使用指令来注释代码，使配置要求更加明显。
- en: Martian is published as a standalone library because even though, it's a key
    part of Grok, it can be very useful for adding declarative configuration to any
    kind of framework. For example, `repoze.bfg` ([http://bfg.repoze.org](http://bfg.repoze.org)),
    a minimalist web framework based on Zope concepts, uses Martian to optionally
    allow the view configuration without ZCML.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Martian 被发布为一个独立库，因为尽管它是 Grok 的关键部分，但它可以为任何类型的框架添加声明性配置。例如，`repoze.bfg`（[http://bfg.repoze.org](http://bfg.repoze.org)），一个基于
    Zope 概念的最小化 Web 框架，使用 Martian 可选地允许在没有 ZCML 的情况下进行视图配置。
- en: At program startup time, Martian reads the Python code in a module and analyzes
    all of the classes to see if they belong to a 'grokked' base class (or a subclass
    of one). If they do, Martian retrieves information from the class registration
    and any of the directives that it may contain. This information is then used to
    perform component registrations in the ZCA registry, much like the ZCML machinery
    does. This process is called 'grokking' and as you see, allows for quick registration
    of plugins within the framework. Grokkers allow us to write "agility" and "Zope
    Toolkit" in the same sentence again, without being ironic about it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序启动时，火星人读取模块中的 Python 代码并分析所有类，以查看它们是否属于一个 'grokked' 基类（或其子类）。如果是，火星人将从类注册信息中检索信息以及其中可能包含的任何指令。然后，这些信息被用于在
    ZCA 注册表中执行组件注册，这与 ZCML 机制类似。这个过程被称为 'grokking'，正如你所见，它允许在框架内快速注册插件。Grokkers 允许我们再次在同一个句子中写出
    "agility" 和 "Zope Toolkit"，而无需带有讽刺意味。
- en: Understanding grokkers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 grokkers
- en: A grokker is a package that includes a base class to be grokked, a series of
    directives for configuring that class, and the actual code that performs the registration
    process using Martian.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Grokker 是一个包含要 grokked 的基类、一系列配置该类的指令以及使用 Martian 执行注册过程的实际代码的包。
- en: 'Let''s take a look at a regular Grok view definition:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个常规的 Grok 视图定义：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, `grok.View` is a grokked class, which means that, when the "Grok
    time" comes at program startup, it will be found by Martian, 'grokked', and registered
    with the ZCA. The `grok.context` and `grok.template` declarations are the configuration
    directives available for this class. The actual 'grokking' is done by a piece
    of code associated with the grokked class, which registers a named adapter with
    the ZCA registry for the interface that is passed in the `grok.context` directive.
    The registration is done by using the class name to name the view, and whatever
    string value is passed as a parameter to the `grok.template` directive is used
    to name the associated template.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`grok.View` 是一个已 grokked 的类，这意味着在程序启动时的 "Grok 时间" 来临时，它将被火星人找到，'grokked'
    并注册到 ZCA。`grok.context` 和 `grok.template` 声明是该类可用的配置指令。实际的 'grokking' 是通过与已 grokked
    类关联的一段代码来完成的，该代码将一个命名适配器注册到 ZCA 注册表中，该适配器是通过 `grok.context` 指令传入的接口。注册是通过使用类名来命名视图，以及将作为
    `grok.template` 指令参数传递的任何字符串值来命名相关模板来完成的。
- en: That's all that grokking means, so if we have the three required parts, we can
    easily make our own grokkers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 grokking 的全部意义，所以如果我们有三个必需的部分，我们就可以轻松地制作出自己的 grokkers。
- en: The grokked class
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已 grokked 的类
- en: 'Any class can be grokked; there are no special requirements. This makes it
    easy for a developer to get started, and is a lot less confusing to work with.
    Imagine that we have some `Mailer` class that we want to grok. It can be as simple
    as this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以被 grokked；没有特殊要求。这使得开发者更容易开始，并且与它们一起工作要少得多。想象一下，我们有一些 `Mailer` 类想要 grok。它可以像这样简单：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, it could be as complex as needed, but the point is that it doesn't
    need to be.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它可以像需要的那样复杂，但重点是它不需要那么复杂。
- en: The directives
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: Once we have a class that we want to grok, we define the directives that we
    may need for configuring it. Again, there's nothing required of us here. We could
    perhaps perform our configuration without the need for directives, but most of
    the time we may need a couple of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个想要解析的类，我们就定义可能需要的指令来配置它。再次强调，这里没有强制要求。我们可能不需要指令就能完成配置，但大多数情况下我们可能需要几个指令。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Directives do need to inherit from the `martian.Directive` subclass. Also, they
    need to at least specify a scope, and probably a default value as well. Here,
    we defined two directives `hostname` and `port`, which will be used to configure
    the mailer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指令确实需要继承自`martian.Directive`子类。此外，它们至少需要指定一个作用域，可能还需要一个默认值。在这里，我们定义了两个指令`hostname`和`port`，这些指令将被用来配置邮件发送器。
- en: The class grokker
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类grokker
- en: The final piece of our grokker is the one that does the actual registration,
    and it comes in the form of a class that inherits from `martian.ClassGrokker:`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们grokker的最后一部分是执行实际注册的部分，它以继承自`martian.ClassGrokker`的类的形式出现：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The grokker class connects the grokked class with its directives, and does the
    grokking, or registration. It has to include an `execute` method that will take
    care of any configuration actions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: grokker类将解析的类与其指令连接起来，并执行解析或注册。它必须包含一个`execute`方法，该方法将负责任何配置操作。
- en: The `martian.component` directive connects the grokker with the class to be
    grokked, in this case, `Mailer`. The directive `martian.directive` is used to
    associate the various directives that we defined earlier with this grokker.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`martian.component`指令将grokker与要解析的类（在这种情况下为`Mailer`）连接起来。`martian.directive`指令用于将我们之前定义的各种指令与这个grokker关联起来。'
- en: Finally, the `execute` method takes the base class and the directive values
    declared in the code that uses the grokker, and performs the final registration.
    Note that the `register_mailer` method (which would actually do the work here)
    is not present in the preceding code, because all we want to show here is the
    structure of a grokker.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`execute`方法接收基类和代码中声明的指令值，并执行最终的注册。请注意，`register_mailer`方法（实际上在这里执行工作）在前面代码中不存在，因为我们只想展示grokker的结构。
- en: The only ZCML you'll ever need
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你将永远需要的唯一ZCML
- en: Once the grokker is available, it has to be configured to be initialized and
    used, by the Grok registration machinery at startup time. To do that, we have
    to use a bit of ZCML in a file named `meta.zcml:`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦grokker可用，它必须在启动时由Grok注册机制进行配置以初始化和使用。为此，我们必须在名为`meta.zcml`的文件中使用一些ZCML：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If our `MailGrokker` class is inside the `meta.py` file, it will be initialized
    by the Grok machinery.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`MailGrokker`类位于`meta.py`文件中，它将由Grok机制初始化。
- en: Creating our own grokker for zope.sendmail configuration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为zope.sendmail配置创建我们自己的grokker
- en: Now that we know how a grokker is structured, let's create one for the SMTP
    mailer from the `zope.sendmail` that we used in the section about adding e-mail
    notifications (in Chapter 11) to our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了grokker的结构，让我们创建一个用于SMTP邮件发送器的grokker，这个SMTP邮件发送器是我们之前在第11章关于添加电子邮件通知的部分所使用的。
- en: What we want is to have a simple `MailGrokker` class declaration with `hostname,
    port, username, password`, and `delivery type` directives. This will allow us
    to avoid using ZCML to configure the mailer, as we were required to do in the
    previous section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一个简单的`MailGrokker`类声明，包含`hostname`、`port`、`username`、`password`和`delivery
    type`指令。这将使我们能够避免使用ZCML来配置邮件发送器，正如我们在上一节所要求的那样。
- en: We'll have to create a new package, so that our grokker is independent of the
    `todo_plus` code and can be used freely elsewhere.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的包，这样我们的grokker就可以独立于`todo_plus`代码，并且可以在其他地方自由使用。
- en: Creating the package
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包
- en: We performed these steps in the *Creating the new package* section of Chapter
    11\. If you have any doubts, please refer to that section for details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第11章的*创建新包*部分执行了这些步骤。如果您有任何疑问，请参阅该部分以获取详细信息。
- en: 'To create the package, go into the `src` directory of our main `todo` application,
    and type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包，请进入我们主要`todo`应用的`src`目录，并输入：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create a `mailgrokker` directory. Now, navigate to this directory
    and add `grok, martian`, and the `zope.sendmail` package to the `install_requires`
    declaration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`mailgrokker`目录。现在，导航到这个目录，并将`grok`、`martian`以及`zope.sendmail`包添加到`install_requires`声明中：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this way, we make sure that the required packages are present, once `mailgrokker`
    is installed. We also have to add our new `mailgrokker` package to the main `buildout.cfg`
    file at the top level of our project, immediately under `todo_plus`. Do this in
    both the eggs and the develop sections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保在安装`mailgrokker`后，所需的包是存在的。我们还必须将我们的新`mailgrokker`包添加到项目顶层的主`buildout.cfg`文件中，紧接在`todo_plus`下面。在egg和develop部分都这样做。
- en: Writing our grokker
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的解析器
- en: 'First, we''ll add a `configure.zcml` file, which is just like the one in the
    `todo_plus` package. In fact, we can copy it from there:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个`configure.zcml`文件，它就像`todo_plus`包中的那个一样。实际上，我们可以从那里复制它：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our grokked class will be inside the `component.py` file. Here, we are using
    only one base class, but a grokker project could include several base classes,
    and by convention they are defined here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析的类将位于`component.py`文件中。在这里，我们只使用一个基类，但一个解析器项目可以包含多个基类，并且按照惯例，它们在这里定义：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just a simple base class with no methods. The `grok.baseclass` directive
    is used to mark it as a base class, although this is not mandatory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有方法的简单基类。使用`grok.baseclass`指令将其标记为基类，尽管这不是强制性的。
- en: The configuration directives are stored in a file named `directives.py:`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 配置指令存储在一个名为`directives.py`的文件中。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is very straightforward. We just define all of the directives that we need,
    and then add a `martian.CLASS` scope. Each directive has its own default value,
    depending on its purpose. The intent of each directive should be obvious just
    by looking at the code, except perhaps for the `delivery` directive. This directive
    is needed because `zope.sendmail` includes two different delivery mechanisms `direct`
    and `queued`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。我们只需定义我们需要的所有指令，然后添加一个`martian.CLASS`作用域。每个指令都有自己的默认值，这取决于其目的。通过查看代码，每个指令的意图应该是显而易见的，除了`delivery`指令。这个指令是必需的，因为`zope.sendmail`包括两种不同的交付机制`direct`和`queued`。
- en: Now comes the main grokker class, which we will add to the `meta.py` file. First,
    are the `import` statements. Note that here we import `martian` as well as `GrokError`,
    which is an exception that we can throw if the grokking fails. We also import
    everything that we are going to use from the `zope.sendmail` library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主要的解析器类，我们将将其添加到`meta.py`文件中。首先，是`import`语句。注意这里我们导入了`martian`以及`GrokError`，这是一个异常，如果解析失败，我们可以抛出它。我们还导入了我们将从`zope.sendmail`库中使用的所有内容。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `register_mailer` function creates a `zope.sendmail` SMTP mailer object,
    and registers it as a named utility for `IMailer`, with the name taken from the
    `name` directive. Note the use of the `getGlobalSiteManager` function, which is
    really a fancy name for getting the component registry. We use the `registerUtility`
    function of the registry to add our newly created `SMTPMailer` instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`register_mailer`函数创建一个`zope.sendmail` SMTP 邮件发送对象，并将其注册为名为`IMailer`的命名实用工具，名称来自`name`指令。注意使用`getGlobalSiteManager`函数，这实际上是一个获取组件注册表的华丽名称。我们使用注册表的`registerUtility`函数添加我们新创建的`SMTPMailer`实例。'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Continuing with the `register_mailer` code, we now use the selected delivery
    mechanism, which was passed as a parameter, to decide if we should initialize
    a `DirectMailDelivery` instance or a `QueuedMailDelivery` instance. Either way,
    we register the result as a utility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`register_mailer`代码，我们现在使用传递的参数选定的交付机制来决定是否初始化一个`DirectMailDelivery`实例或一个`QueuedMailDelivery`实例。无论哪种方式，我们都将结果注册为一个实用工具。
- en: In the case of a `queue` delivery mechanism, a thread that will take care of
    sending e-mail separately from the main application code is started.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`queue`交付机制的情况下，一个将负责从主应用程序代码中单独发送电子邮件的线程被启动。
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `MailGrokker` class declares all of the directives that we added to the
    `directives` module, and associates itself with the `Mailer` class that it will
    grok. It then defines the `execute` method that will call the `register_mailer`
    function to perform the required `zope.sendmail` registrations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailGrokker`类声明了添加到`directives`模块的所有指令，并将其与它将要解析的`Mailer`类关联起来。然后它定义了`execute`方法，该方法将调用`register_mailer`函数以执行所需的`zope.sendmail`注册。'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference between the above code and the code that we showed earlier
    is that instead of calling the `register_mailer` function directly, we wrap it
    inside a `config.action` object. This is done so that Grok can perform the registrations
    in an arbitrary order after the code is loaded, instead of doing that as it initializes
    each package. This prevents any configuration conflicts, and allows us to be specific
    about the registration conditions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们之前展示的代码的唯一区别是，我们不是直接调用`register_mailer`函数，而是将其包裹在`config.action`对象中。这样做是为了让Grok在代码加载后以任意顺序执行注册，而不是在初始化每个包时执行。这防止了任何配置冲突，并允许我们具体指定注册条件。
- en: For example, the `discriminator` parameter, which could be empty, is, in this
    case, a tuple containing the string `utility`, the interface `IMailer`, and the
    value of the `name` directive. If any other grokker package uses this same discriminator,
    Grok will signal a conflict error condition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`discriminator`参数，可能是空的，在这种情况下，是一个包含字符串`utility`、接口`IMailer`和`name`指令值的元组。如果任何其他grokker包使用这个相同的判别器，Grok将发出冲突错误条件。
- en: The `order` parameter of the `action` is used to dictate the order in which
    the actions are called, although here it was added for demonstration purposes
    only. The `callable` parameter is the function that will perform the registration,
    and the `args` parameter contains the parameters that will be passed to it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`的`order`参数用于指定调用动作的顺序，尽管这里只是添加了用于演示的目的。`callable`参数是执行注册的函数，而`args`参数包含传递给它的参数。'
- en: 'We now have our grokker in the `meta` module, and need to tell Grok to find
    it here, which we do by adding the small `meta.zcml` file discussed earlier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`meta`模块中有了我们的grokker，需要告诉Grok在这里找到它，我们通过添加之前讨论过的小的`meta.zcml`文件来完成：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, edit the existing `__init__.py` file, which is inside `src/mailgrokker/mailgrokker`
    directory, to look like the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑现有的`__init__.py`文件，该文件位于`src/mailgrokker/mailgrokker`目录中，使其看起来像以下代码：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will allow us to use the directives simply by importing the main `mailgrokker`
    module, much in the way that `grok.*` directives work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们通过导入主要的`mailgrokker`模块来简单地使用指令，就像`grok.*`指令那样工作。
- en: Using mailgrokker
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mailgrokker
- en: 'Now that we are done with our grokker, the only thing that is missing is to
    show how it would be used inside an application. We will add it to the `todo_plus`
    package. Insert the following lines at the bottom of that file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的grokker，唯一缺少的是展示如何在应用程序中使用它。我们将将其添加到`todo_plus`包中。在该文件的底部插入以下行：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Obviously, you should substitute the values shown here with the real values
    of your `smtp` server. You might also want to eliminate the mailer configuration
    that we placed in the `configure.zcml` file, earlier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你应该用你的`smtp`服务器的实际值替换这里显示的值。你可能还想删除我们在之前的`configure.zcml`文件中放置的邮件发送器配置。
- en: Done. We have now created a small grokker package that can be used in any of
    our applications in order to easily configure e-mail submissions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。我们现在创建了一个小的grokker包，可以在我们的任何应用程序中使用，以便轻松配置电子邮件提交。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned about the Martian library and how it enables Grok
    to be an agile framework. We are now ready to discuss how to debug our applications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Martian库以及它是如何使Grok成为一个敏捷框架的。我们现在准备好讨论如何调试我们的应用程序。
