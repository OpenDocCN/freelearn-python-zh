- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Connecting to the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到云
- en: It seems that nearly every application needs to talk to the outside world sooner
    or later, and your ABQ Data Entry application is no exception. You've received
    some new feature requests that will require some interactions with remote servers
    and services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎几乎每个应用程序迟早都需要与外部世界进行通信，你的ABQ数据录入应用程序也不例外。你已经收到了一些新的功能请求，这些请求将需要与远程服务器和服务进行交互。
- en: First, the quality assurance division is doing a study of how local weather
    conditions are impacting the environmental data in each lab; they've requested
    a way to download and store local weather data in the database on demand. The
    second request is from your manager, who is still required to upload daily CSV
    files to the central corporate servers. She would like this process streamlined
    and available at a mouse click.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，质量保证部门正在研究当地天气条件如何影响每个实验室的环境数据；他们请求一种按需下载和存储本地天气数据到数据库的方法。第二个请求来自你的经理，她仍然需要每天上传CSV文件到中央企业服务器。她希望这个过程简化并可通过鼠标点击实现。
- en: 'In this chapter, you will learn to interface with the cloud in the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题，以与云进行接口：
- en: In *HTTP using urllib*, you'll connect to web services and download data using
    `urllib`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用urllib的HTTP*中，你将使用`urllib`连接到网络服务并下载数据。
- en: In *RESTful HTTP using requests*, you'll learn to interact with REST services
    using the `requests` library.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用requests的RESTful HTTP*中，你将学习如何使用`requests`库与REST服务进行交互。
- en: In *SFTP using paramiko*, you'll upload files over SSH using `paramiko`.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用paramiko的SFTP*中，你将使用`paramiko`通过SSH上传文件。
- en: HTTP using urllib
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用urllib的HTTP
- en: Every time you open a website in your browser, you're using the Hypertext Transfer
    Protocol, or HTTP. HTTP was created over 30 years ago as a way for web browsers
    to download HTML documents, but has evolved into one of the most popular client-server
    communication protocols for any number of purposes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在浏览器中打开一个网站，你都在使用超文本传输协议，即HTTP。HTTP是在30多年前被创建的，作为一种让网页浏览器下载HTML文档的方式，但它已经演变成为适用于各种目的的最受欢迎的客户端-服务器通信协议之一。
- en: Not only do we use it in the browser to view everything from plain text to streaming
    video across the internet, but applications can also use it to transfer data,
    initiate remote procedures, or distribute computing tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅在使用浏览器查看从纯文本到通过互联网流式传输的视频时使用它，应用程序还可以使用它来传输数据、启动远程过程或分配计算任务。
- en: HTTP transaction fundamentals
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP事务基础
- en: 'A basic HTTP transaction between a client and server goes like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间基本HTTP事务是这样的：
- en: 'First, the client creates a **request**, which it will send to the server.
    The request contains the following:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，客户端创建一个**请求**，它将发送到服务器。请求包含以下内容：
- en: A **URL**, which specifies the host, port, and path to which the request is
    being made.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**URL**，它指定了请求的目标主机、端口和路径。
- en: A **method**, also known as a verb, which tells the server what operation the
    client is requesting. The most common methods are `GET`, for retrieving data,
    and `POST`, for submitting data.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**方法**，也称为动词，它告诉服务器客户端请求的操作。最常见的方法是`GET`，用于检索数据，以及`POST`，用于提交数据。
- en: A **header**, which includes metadata in key-value pairs; for example, the type
    of content being submitted, how the content is encoded, or authorization tokens.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**头部**，它包括键值对中的元数据；例如，提交的内容类型、内容的编码方式或授权令牌。
- en: Finally, the request may have a **payload**, which would contain the data being
    submitted to a server; for example, a file being uploaded, or a set of key-value
    pairs from a form.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，请求可能有一个**有效载荷**，它将包含提交给服务器的数据；例如，上传的文件或来自表单的一组键值对。
- en: 'When the server receives the request, it returns a **response**. The response
    contains the following:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器接收到请求时，它会返回一个**响应**。响应包含以下内容：
- en: A **header** containing metadata such as the size or content type of the response.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含元数据，如响应大小或内容类型的**头部**。
- en: A **payload** containing the actual content of the response, such as HTML, XML,
    JSON, or binary data.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含响应实际内容的**有效载荷**，例如HTML、XML、JSON或二进制数据。
- en: In a web browser, these interactions take place in the background, but our application
    code will deal directly with request and response objects in order to talk to
    remote HTTP servers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中，这些交互在后台进行，但我们的应用程序代码将直接处理请求和响应对象，以便与远程HTTP服务器进行通信。
- en: HTTP status codes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: 'Every HTTP request includes a **status code** in its header, which is a 3-digit
    number indicating the disposition of the request. The codes, defined in the HTTP
    standard, are organized as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求在其头部中都会包含一个**状态码**，它是一个3位数，表示请求的处理状态。这些代码在HTTP标准中定义，并按以下方式组织：
- en: 1XX status codes are informational messages sent during the processing of the
    request.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1XX 状态码是在请求处理过程中发送的信息性消息。
- en: 2XX status codes indicate a successful request; for example, 200 is the most
    common response, indicating the request was successful.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2XX 状态码表示请求成功；例如，200是最常见的响应，表示请求成功。
- en: 3XX status codes indicate a redirection. For example, a 301 is used to redirect
    the client to a new URL, and 304 indicates that the content hasn't been modified
    since it was last downloaded (redirecting the client to its cache).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3XX 状态码表示重定向。例如，301用于将客户端重定向到新的URL，而304表示内容自上次下载以来未修改（将客户端重定向到其缓存）。
- en: 4XX status codes indicate an error in the client's request. For example, a 403
    error indicates a forbidden request (such as a request to secure documents without
    authentication), while the well-known 404 error indicates that a non-existent
    document was requested.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4XX 状态码表示客户端请求中的错误。例如，403错误表示禁止请求（例如未经身份验证请求受保护文档），而众所周知的404错误表示请求了不存在的文档。
- en: 5XX status codes indicate an error on the server's side, such as the generic
    500 error issued when the server encounters a bug in the web service.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5XX 状态码表示服务器端发生错误，例如当服务器在Web服务中遇到错误时发出的通用500错误。
- en: While web browser users typically only encounter the 4XX and 5XX errors, you
    will encounter a few different status codes as you work directly with HTTP through
    `urllib`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网络浏览器用户通常只会遇到4XX和5XX错误，但当你直接通过 `urllib` 与HTTP交互时，你会遇到一些不同的状态码。
- en: Basic downloading with urllib.request
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `urllib.request` 进行基本下载
- en: The `urllib.request` module is a Python module for implementing HTTP interactions.
    It contains a number of functions and classes for generating requests, the most
    basic of which is the `urlopen()` function. This function can create a `GET` or
    `POST` request, send it to a remote server, and return an object containing the
    server's response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.request` 模块是Python模块，用于实现HTTP交互。它包含了一系列用于生成请求的函数和类，其中最基本的是 `urlopen()`
    函数。此函数可以创建一个 `GET` 或 `POST` 请求，将其发送到远程服务器，并返回一个包含服务器响应的对象。'
- en: 'Let''s explore how `urllib` works; open a Python shell and execute the following
    commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `urllib` 是如何工作的；打开Python壳并执行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `urlopen()` function takes, at a minimum, a URL string. By default, it makes
    a `GET` request to the URL and returns an object that wraps the response received
    from the server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()` 函数至少需要一个URL字符串。默认情况下，它会对URL发起一个 `GET` 请求，并返回一个封装从服务器接收到的响应的对象。'
- en: 'This response object exposes metadata or content received from the server,
    which we can use in our application. Much of the response''s metadata is found
    in the header, which we can extract using its `getheader()` method, like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应对象公开了从服务器接收到的元数据或内容，我们可以在我们的应用程序中使用这些信息。响应的大部分元数据都位于头部中，我们可以使用其 `getheader()`
    方法来提取，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getheader()` method requires a key name, and returns the value of that
    key if it is found in the header. If the key isn't found, it returns `None`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`getheader()` 方法需要一个键名，如果该键名在头部中找到，则返回其值。如果找不到该键名，则返回 `None`。'
- en: 'We can also extract the status code and a text explanation of the code using
    the `status` and `reason` attributes, like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `status` 和 `reason` 属性提取状态码和代码的文本说明，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that a `200` status means a successful request. The `OK` string is
    just a more human-readable form of the status code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`200` 状态码表示请求成功。`OK` 字符串只是状态码的更易读形式。
- en: 'The payload of the response object can be retrieved using an interface similar
    to a file handle; for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象的负载可以通过类似于文件句柄的接口来检索；例如：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like a file handle, the response can only be read once, using the `read()`
    method; unlike a file handle, it can't be "rewound" using `seek()`, so it's important
    to save the response data in another variable if it needs to be accessed more
    than once. Note that the output of `response.read()` is a bytes object, which
    should be cast or decoded into an appropriate object depending on the content
    downloaded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文件句柄一样，响应只能使用`read()`方法读取一次；与文件句柄不同，它不能使用`seek()`进行“回滚”，因此如果需要多次访问响应数据，则非常重要地将响应数据保存在另一个变量中。请注意，`response.read()`的输出是一个`bytes`对象，根据下载的内容，应该将其转换为适当的对象或解码。
- en: 'In this case, we know from the `Content-Type` header that the content is a
    UTF-8 string, so we should convert it to `str` using `decode()`, like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道从`Content-Type`头信息中，内容是UTF-8字符串，因此我们应该使用`decode()`将其转换为`str`，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generating POST requests
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成POST请求
- en: 'The `urlopen()` function can also generate `POST` requests. To do this, we
    just need to include a `data` argument, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()`函数还可以生成`POST`请求。为此，我们只需要包含一个`data`参数，如下所示：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `data` value needs to be a URL-encoded `bytes` object. A URL-encoded data
    string consists of key-value pairs separated by ampersand (`&`) symbols, with
    certain reserved characters encoded to URL-safe alternatives (for example, the
    space character is `%20`, or sometimes just `+`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`值需要是一个URL编码的`bytes`对象。一个URL编码的数据字符串由用`&`符号分隔的键值对组成，某些保留字符被编码为URL安全的替代字符（例如，空格字符是`%20`，有时也可以是`+`）。'
- en: 'A string like this can be created by hand, but it''s easier to use the `urlencode()`
    function provided by the `urllib.parse` module, as demonstrated here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的字符串可以手动创建，但使用`urllib.parse`模块提供的`urlencode()`函数会更简单，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the `data` argument must be `bytes`, not a string, so `encode()` must
    be called on the URL-encoded string before `urlopen()` will accept it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`data`参数必须是`bytes`类型，而不是字符串，因此在`urlopen()`接受之前，必须在URL编码的字符串上调用`encode()`。
- en: Downloading weather data to ABQ Data Entry
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将天气数据下载到ABQ数据录入
- en: Let's try downloading the weather data needed for our application. The site
    we'll be using is [http://weather.gov](http://weather.gov), which provides weather
    data within the United States. The actual URL we'll be downloading is [https://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml),
    where `STATION` is replaced by the call-sign of the local weather station. In
    the case of ABQ, we'll be using `KBMG`, located in Bloomington, Indiana.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试下载我们应用程序所需的天气数据。我们将使用的是[http://weather.gov](http://weather.gov)，该网站提供美国国内的天气数据。我们将下载的实际URL是[https://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml)，其中`STATION`被替换为当地气象站的呼号。对于ABQ，我们将使用位于印第安纳州布卢明顿的`KBMG`。
- en: The QA team wants you to record the temperature (in degrees Celsius), relative
    humidity, air pressure (in millibars), and sky conditions (a string, like "overcast"
    or "fair"). They also need the date and time at which the weather was observed
    by the station.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: QA团队希望您记录温度（以摄氏度为单位）、相对湿度、气压（以毫巴为单位）和天空状况（字符串，如“多云”或“晴朗”）。他们还需要气象站观测天气的日期和时间。
- en: Creating a weather data model
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建天气数据模型
- en: While it would be simple enough to put `urlopen()` calls in an `Application`
    class callback, it's more consistent with our MVC design to wrap our interactions
    with the weather data service in a model class. Our model class will be responsible
    for acquiring the weather data from the web service and translating it into a
    format our other components can use easily.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将`urlopen()`调用放在`Application`类回调中可能足够简单，但与我们的MVC设计更一致的是，将我们与天气数据服务的交互封装在一个模型类中。我们的模型类将负责从网络服务获取天气数据并将其转换为其他组件可以轻松使用的格式。
- en: 'Open the `models.py` file and let''s begin by importing `urlopen()`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`models.py`文件，让我们首先导入`urlopen()`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, at the end of the file, let''s start a new model class to wrap our data
    download:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文件末尾，让我们开始一个新的模型类来封装我们的数据下载：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our initializer will take a `station` string as an argument and use it with
    the base URL value to build the download URL for the weather data. By making the
    `station` value a variable, we can set the station in the user's configuration
    file, allowing users at other ABQ facilities to use the feature as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始化器将接受一个`station`字符串作为参数，并使用它与基本URL值构建天气数据的下载URL。通过将`station`值设置为变量，我们可以在用户的配置文件中设置站点，允许其他ABQ设施的用户使用此功能。
- en: 'Now, let''s begin writing a public method for this class to retrieve the weather
    data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始为这个类编写一个公共方法来检索天气数据：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start the method by sending a GET request to the model's URL and retrieve
    a response. Note that this may raise an exception (for example, if the site can't
    be reached for some reason), which code calling this method will need to handle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向模型的URL发送GET请求并检索响应来开始这个方法。请注意，这可能会引发异常（例如，如果由于某种原因无法访问该网站），调用此方法的代码需要处理这个异常。
- en: 'Assuming things went okay, we just need to parse out the data in this response
    and put it into a form that the `Application` class can pass to the SQL model.
    To determine how we''ll handle the response, let''s go back to the Python shell
    and examine the data there:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，我们只需要解析这个响应中的数据，并将其放入`Application`类可以传递给SQL模型的形式。为了确定我们将如何处理这个响应，让我们回到Python
    shell中检查那里的数据：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the URL indicated, the payload of the response is an XML document, most
    of which we won''t need. After some searching, though, you should be able to locate
    the fields we need, shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如URL所示，响应的有效负载是一个XML文档，其中大部分我们不需要。然而，经过一些搜索后，你应该能够找到我们需要的字段，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Good, the data we need is there, so we just need to extract it from the XML
    string into a format our application can use. Let's take a moment to learn about
    parsing XML data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们需要的数据就在那里，所以我们只需要将其从XML字符串中提取出来，转换成我们应用程序可以使用的形式。让我们花点时间来学习如何解析XML数据。
- en: Parsing the XML weather data
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析XML天气数据
- en: The Python standard library contains an `xml` package, which consists of several
    sub-modules for parsing or creating XML data. Of these, the `xml.etree.ElementTree`
    sub-module is a simple, lightweight parser that should meet our needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库包含一个`xml`包，它由几个用于解析或创建XML数据的子模块组成。在这些子模块中，`xml.etree.ElementTree`子模块是一个简单、轻量级的解析器，应该能满足我们的需求。
- en: 'Let''s import `ElementTree` into our `models.py` file as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`ElementTree`导入到我们的`models.py`文件中，如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, back at the end of our `get_weather_data()` method, we''ll parse the XML
    data in our response object as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`get_weather_data()`方法的末尾，我们将按照以下方式解析响应对象中的XML数据：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `fromstring()` method takes an XML string and returns an `Element` object.
    To get at the data we need, we'll first need to understand what an `Element` object
    represents, and how to work with it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromstring()` 方法接受一个XML字符串并返回一个`Element`对象。为了获取我们需要的数据，我们首先需要了解`Element`对象代表什么，以及如何与之交互。'
- en: XML is a hierarchical representation of data; an element represents a node in
    this hierarchy. An element begins with a tag, which is a text string inside angle
    brackets. Each tag has a matching closing tag, which is just the tag with a forward-slash
    prefixed to the tag name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: XML是数据的分层表示；一个元素代表这个层次结构中的一个节点。元素以一个标签开始，这是一个位于尖括号内的文本字符串。每个标签都有一个匹配的闭标签，它只是在标签名前加上一个前导斜杠。
- en: Between the opening and closing tags, an element may have other child elements
    or it may have text. An element can also have attributes, which are key-value
    pairs placed inside the angle brackets of the opening tag, just after the tag
    name.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在开标签和闭标签之间，一个元素可能包含其他子元素，或者它可能包含文本。元素还可以有属性，这些属性是放置在开标签的尖括号内的键值对，紧随标签名之后。
- en: 'Take a look at the following example of XML:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下XML的示例：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example is an (incomplete) XML description of the solar system. The root
    element has a tag of `<star_system>` with an attribute of `starname`. Under this
    root element, we have four `<planet>` elements and a `<dwarf_planet>` element,
    each of which contains a text node with the planet's name. Some of the planet
    nodes also have child `<moon>` nodes, each containing a text node with the moon's
    name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是一个（不完整）的太阳系XML描述。根元素有一个`<star_system>`标签和一个`starname`属性。在这个根元素下，我们有四个`<planet>`元素和一个`<dwarf_planet>`元素，每个元素都包含一个表示行星名称的文本节点。一些行星节点还有子`<moon>`节点，每个节点都包含一个表示月球名称的文本节点。
- en: Arguably, this data could have been structured differently; for example, planet
    names could have been in a child `<name>` node inside the planet elements, or
    listed as an attribute of the `<planet>` tag. While XML *syntax* is well-defined,
    the actual *structure* of an XML document is up to its creator, so fully parsing
    XML data requires a knowledge of the way the data is laid out in the document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这些数据可以有不同的结构；例如，行星名称可以在行星元素内部的子`<name>`节点中，或者作为`<planet>`标签的属性列出。虽然XML的*语法*定义良好，但XML文档的实际*结构*由其创建者决定，因此完全解析XML数据需要了解数据在文档中的布局方式。
- en: If you look at the XML weather data that we downloaded in the shell earlier,
    you'll notice it's a fairly shallow hierarchy. Under the `<current_observations>`
    node, there are a number of child elements whose tags represent specific data
    fields like temperature, humidity, wind chill, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们在shell中之前下载的XML天气数据，你会注意到它是一个相当浅的层次结构。在`<current_observations>`节点下，有许多子元素，其标签代表特定的数据字段，如温度、湿度、风寒等等。
- en: 'To access and extract these child elements, the `Element` object offers us
    the following variety of methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问和提取这些子元素，`Element`对象为我们提供了以下各种方法：
- en: '| Method | Returns |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回值 |'
- en: '| `iter()` | An iterator of all child nodes (recursively) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `iter()` | 所有子节点的迭代器（递归）|'
- en: '| `find(tag)` | The first element matching the given tag |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `find(tag)` | 匹配给定标签的第一个元素 |'
- en: '| `findall(tag)` | A list of elements matching the given tag |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `findall(tag)` | 匹配给定标签的元素列表 |'
- en: '| `getchildren()` | A list of the immediate child nodes |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `getchildren()` | 立即子节点列表 |'
- en: '| `iterfind(tag)` | An iterator of all child nodes matching the given tag (recursive)
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `iterfind(tag)` | 所有匹配给定标签的子节点的迭代器（递归）|'
- en: 'When we downloaded the XML data earlier, we identified five tags containing
    the data we want to extract from this document: `<observation_time_rfc822>`, `<weather>`,
    `<temp_c>`, `<relative_humidity>`, and `<pressure_mb>`. We''ll want our function
    to return a Python dictionary containing each of these tags as keys.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前下载XML数据时，我们确定了五个包含我们想要从该文档中提取的数据的标签：`<observation_time_rfc822>`、`<weather>`、`<temp_c>`、`<relative_humidity>`和`<pressure_mb>`。我们希望我们的函数返回一个包含每个这些标签作为键的Python字典。
- en: 'So, inside `get_weather_data()`, let''s create a dictionary containing the
    tags we want, like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`get_weather_data()`内部，让我们创建一个包含我们想要的标签的字典，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s get the values from the `Element` object and add them to the dictionary:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`Element`对象中获取值并将它们添加到字典中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For each of our tag names, we're going to use the `find()` method to try to
    locate the element with a matching tag in `xmlroot`. This particular XML document
    does not use duplicate tags (since it would make no sense for a single observation
    to have multiple times, temperature values, humidity values, and so on), so the
    first instance of any tag should be the only one. If the tag is matched, we'll
    get back an `Element` object of the matched node; if not, we get back `None`,
    so we need to make sure `element` is not `None` before trying to access its `text`
    attribute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的标签名，我们将使用`find()`方法尝试在`xmlroot`中定位匹配的元素。这个特定的XML文档不使用重复的标签（因为单个观测值多次出现，温度值、湿度值等等都没有意义），所以任何标签的第一个实例应该是唯一的。如果标签匹配，我们将返回匹配节点的`Element`对象；如果没有匹配，我们将返回`None`，所以在尝试访问其`text`属性之前，我们需要确保`element`不是`None`。
- en: Once we've done that for all the tags, we can finish the function by returning
    the dictionary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有标签后，我们可以通过返回字典来完成函数。
- en: 'You can test this function in the Python shell; from a command line, navigate
    to the `ABQ_Data_Entry` directory and start a Python shell. Then enter these commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python shell中测试这个函数；从命令行，导航到`ABQ_Data_Entry`目录并启动Python shell。然后输入以下命令：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should get back a dictionary with the current weather conditions in Bloomington,
    Indiana.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到一个包含印第安纳州布卢明顿当前天气状况的字典。
- en: You can find the station codes for other cities inside the U.S. at [http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/)找到美国其他城市的站码。
- en: Now that we have our weather data model, we just need to build the table for
    storing the data and the interface for triggering the operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的天气数据模型，我们只需要构建存储数据的表和触发操作的接口。
- en: Implementing weather data storage
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现天气数据存储
- en: To store our weather data, we'll start by creating a table in the ABQ database
    to hold the individual observation data, then build a `SQLModel` method to store
    the retrieved data in it. We don't need to worry about writing code to retrieve
    data back from the database, since our laboratory's QA team has their own reporting
    tools that they'll use to access it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的天气数据，我们首先将在ABQ数据库中创建一个表来保存单个观测数据，然后构建一个`SQLModel`方法来存储检索到的数据。我们不需要担心编写从数据库中检索数据的代码，因为我们的实验室的QA团队有自己的报告工具，他们将使用这些工具来访问它。
- en: Creating the SQL table
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建SQL表
- en: 'Under the application''s `sql` folder, open the `create_db.sql` file, and add
    a new `CREATE TABLE` statement as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的 `sql` 文件夹下，打开 `create_db.sql` 文件，并添加一个新的 `CREATE TABLE` 语句，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this table, we're using the `TIMESTAMP` data type on the record as a primary
    key; there's no point in saving the same timestamped observation twice, so this
    makes an adequate primary key. The `(0)` size after the `TIMESTAMP` data type
    indicates how many decimal places we need for the seconds measurement. Since these
    measurements are taken approximately hourly, and we only need one every four hours
    or so (when the lab checks are done), we don't need fractions of seconds in our
    timestamp.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，我们使用记录上的 `TIMESTAMP` 数据类型作为主键；保存相同的带时间戳的观察结果两次是没有意义的，因此这足以成为一个合适的主键。`TIMESTAMP`
    数据类型后面的 `(0)` 大小表示我们需要多少小数位来进行秒的测量。由于这些测量大约每小时进行一次，而我们只需要大约每四小时一次（当实验室检查完成时），我们不需要在时间戳中包含秒的小数部分。
- en: Notice that we're saving the time zone; always store time zone data with timestamps
    when it's available! It may not seem necessary, especially when your application
    will be run in a workplace that will never change time zones, but there are many
    edge cases such as daylight savings time changes, where the lack of a time zone
    can create major problems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在保存时区；当可用时，始终将时区数据与时间戳一起存储！这可能看起来并不必要，尤其是当你的应用程序将在永远不会更改时区的办公场所运行时，但存在许多边缘情况，例如夏令时变更，时区的缺失可能会造成重大问题。
- en: Run this `CREATE` query in your database to build the table, and let's move
    on to creating our `SQLModel` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的数据库中运行这个 `CREATE` 查询来构建表，然后让我们继续创建我们的 `SQLModel` 方法。
- en: Implementing the SQLModel.add_weather_data() method
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 SQLModel.add_weather_data() 方法
- en: 'Over in `models.py`, let''s add a new method to the `SQLModel` class called
    `add_weather_data()`, which takes a dictionary as its only argument. Start this
    method by creating an `INSERT` query as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models.py` 中，让我们向 `SQLModel` 类添加一个新的方法，称为 `add_weather_data()`，它只接受一个字典作为其唯一参数。从这个方法开始创建一个
    `INSERT` 查询，如下所示：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a straightforward parameterized `INSERT` query using variable names
    that match the dictionary keys which the `get_local_weather()` function extracts
    from the XML data. We should only need to pass this query and the `data` dictionary
    into our `query()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的参数化 `INSERT` 查询，使用与 `get_local_weather()` 函数从 XML 数据中提取的字典键匹配的变量名。我们只需要将这个查询和
    `data` 字典传递到我们的 `query()` 方法中。
- en: There is one problem, however; if we get a duplicate timestamp, our query will
    fail due to a duplicate primary key. We could do another query to check first,
    but that would be slightly redundant, since PostgreSQL itself checks for duplicate
    keys before inserting a new row.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题；如果我们得到一个重复的时间戳，我们的查询将因为重复的主键而失败。我们可以在查询之前再进行一次查询来检查，但这会稍微有些多余，因为 PostgreSQL
    本身会在插入新行之前检查重复的键。
- en: When it detects such an error, `psycopg2` raises an `IntegrityError` exception,
    so we can just catch this exception and, if it gets raised, do nothing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当它检测到此类错误时，`psycopg2` 会引发 `IntegrityError` 异常，因此我们只需捕获这个异常，如果它被引发，就什么也不做。
- en: 'To do this, we''ll wrap our `query()` call in the `try`/`except` block, like
    so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将像这样将我们的 `query()` 调用包装在 `try`/`except` 块中：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, our data entry staff can call this method as often as they wish, but it
    will only save a record when there is a fresh observation to save.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据录入人员可以随时调用此方法，但它只会保存有新鲜观测记录时。
- en: Updating the SettingsModel class
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 SettingsModel 类
- en: 'Before leaving `models.py`, we will need to add a new application setting to
    store the preferred weather station. Add the following new entry in the `SettingsModel.fields`
    dictionary:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开 `models.py` 之前，我们需要添加一个新的应用程序设置来存储首选的天气站。在 `SettingsModel.fields` 字典中添加以下新条目：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We won't add a GUI to change this setting, since users won't need to update
    it. It'll be up to us, or the system admin at other lab sites, to make sure this
    is properly set on each workstation by editing the `abq_settings.json` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会添加一个 GUI 来更改此设置，因为用户不需要更新它。这将取决于我们，或者在其他实验室站点上的系统管理员，通过编辑 `abq_settings.json`
    文件来确保每个工作站都正确设置。
- en: Adding the GUI elements for weather download
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加天气下载的 GUI 元素
- en: The `Application` object now needs to connect the weather download method from
    `WeatherDataModel` to the database method in `SQLModel` with an appropriate callback
    method that the main menu classes can call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 对象现在需要将 `WeatherDataModel` 中的天气下载方法连接到 `SQLModel` 中的数据库方法，使用一个适当的回调方法，这样主菜单类就可以调用它。'
- en: 'Open `application.py` and start a new method in the `Application` class called
    `_update_weather_data()`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `application.py` 文件，并在 `Application` 类中启动一个新的方法，命名为 `_update_weather_data()`：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method begins by creating a `WeatherDataModel` instance using the `weather_station`
    value pulled from the `settings` dictionary. Then, it attempts to call `get_weather_data()`
    inside a `try` block.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先使用从 `settings` 字典中拉取的 `weather_station` 值创建一个 `WeatherDataModel` 实例。然后，它尝试在
    `try` 块中调用 `get_weather_data()`。
- en: 'Recall that in an error scenario, `urlopen()` can raise any number of exceptions,
    depending on what went wrong with the HTTP transaction. There isn''t really anything
    the application can do to handle such exceptions other than informing the user
    and exiting the method. Therefore, we''ll catch the generic `Exception` and display
    the text in a `messagebox` dialogbox, like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在错误场景中，`urlopen()` 可能会引发任何数量的异常，具体取决于 HTTP 事务中出了什么问题。应用程序实际上无法做任何事情来处理这些异常，除了通知用户并退出方法。因此，我们将捕获通用的
    `Exception` 并在 `messagebox` 对话框中显示文本，如下所示：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the event that `get_local_weather()` succeeds, we simply need to pass the
    data on to our model method. We can add this in an `else` clause:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `get_local_weather()` 成功，我们只需将数据传递给我们的模型方法。我们可以在 `else` 子句中添加此内容：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to saving the data, we've notified the user in the status bar that
    the weather was updated and displayed the timestamp of the update.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保存数据外，我们还在状态栏通知用户天气已更新，并显示了更新时间戳。
- en: 'With the callback method done, let''s add it to our callbacks dictionary:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法完成后，让我们将其添加到我们的回调字典中：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we can add a `command` item for the callback in the main menu. In keeping
    with the main menu guidelines we learned in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*, we should consider an appropriate sub-menu for the command. On
    Windows, functionality like this goes in the `Tools` menu, and since neither the
    Gnome nor macOS guidelines seem to indicate a more appropriate location, we'll
    implement a `Tools` menu in the `LinuxMainMenu` and `MacOsMainMenu` classes to
    hold this command, just to be consistent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在主菜单中添加一个 `command` 项目作为回调。根据我们在第 10 章“保持跨平台兼容性”中学到的主菜单指南，我们应该考虑为该命令提供一个合适的子菜单。在
    Windows 上，此类功能位于 `Tools` 菜单中，由于 Gnome 和 macOS 指南似乎没有指示更合适的位置，我们将在 `LinuxMainMenu`
    和 `MacOsMainMenu` 类中实现一个 `Tools` 菜单来保持一致性，以包含此命令。
- en: 'Open `mainmenu.py`, and starting in the generic menu class, let''s add a private
    method that will add the `command` item:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `mainmenu.py` 文件，从通用的菜单类开始，让我们添加一个私有方法，该方法将添加 `command` 项目：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, in each menu class''s initializer, we''ll create a `Tools` menu and add
    the command to it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在每个菜单类的初始化器中，我们将创建一个 `Tools` 菜单并将其添加到其中：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add this same code to the macOS and Linux menu classes'' initializers. In the
    `WindowsMainMenu` class''s initializer, you only need to add the second line,
    since the `Tools` menu already exists. After updating the menus, you can run the
    application and try the new command from the `Tools` menu. If all went well, you
    should see an indication in the status bar as shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将此相同代码添加到 macOS 和 Linux 菜单类的初始化器中。在 `WindowsMainMenu` 类的初始化器中，您只需添加第二行，因为 `Tools`
    菜单已经存在。更新菜单后，您可以运行应用程序并尝试从 `Tools` 菜单中的新命令。如果一切顺利，您应该在状态栏中看到以下截图所示：
- en: '![Figure 13.1: Success downloading the weather data.](img/B17578_13_01.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：成功下载天气数据。](img/B17578_13_01.png)'
- en: 'Figure 13.1: Success downloading the weather data'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：成功下载天气数据
- en: 'You should also connect to the database with your PostgreSQL client and check
    that the table contains some weather data now by executing the following SQL command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该使用您的 PostgreSQL 客户端连接到数据库，并执行以下 SQL 命令来检查表中是否包含一些天气数据：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That SQL statement should return output similar to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该 SQL 语句应该返回类似于以下内容的输出：
- en: '| datetime | temperature | rel_hum | pressure | conditions |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 日期时间 | 温度 | 相对湿度 | 压力 | 条件 |'
- en: '| 2021-08-12 18:53:00-05 | 26.10 | 74.00 | 1013.70 | Fair |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 2021-08-12 18:53:00-05 | 26.10 | 74.00 | 1013.70 | 晴朗 |'
- en: As you've seen, `urllib` is fairly simple to work with for downloading files
    from the web; most of the work involves parsing the downloaded file and utilizing
    it in the application. However, not all web transactions are as simple as a single
    `GET` or `POST` request. In the next section, we'll look at a more powerful tool
    for HTTP interactions, `requests`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`urllib`在从网络下载文件方面相对简单易用；大部分工作涉及解析下载的文件并在应用程序中使用它。然而，并非所有Web事务都像单个`GET`或`POST`请求那样简单。在下一节中，我们将探讨一个更强大的HTTP交互工具，`requests`。
- en: RESTful HTTP using requests
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求的RESTful HTTP
- en: You've been asked by your manager to create a function in your program that
    will allow her to upload a CSV extract of the daily data to ABQ's corporate web
    services, which uses an authenticated REST API. **REST** stands for **REpresentational
    State Transfer** and refers to an approach to web services that is built around
    advanced HTTP semantics to provide a more code-friendly interface. Services designed
    around the REST concept are described as **RESTful**. Let's take a deeper look
    at how REST interactions work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您的经理要求您在程序中创建一个函数，以便她可以将每日数据的CSV提取上传到ABQ的企业Web服务，该服务使用经过身份验证的REST API。**REST**代表**表征状态转移**，它指的是一种围绕高级HTTP语义构建的Web服务方法，以提供更符合代码的接口。围绕REST概念设计的服务被称为**RESTful**。让我们更深入地了解REST交互是如何工作的。
- en: Understanding RESTful web services
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解RESTful Web服务
- en: A RESTful service is built around the idea of accessing **resources**. A resource
    is typically a data record or file, though it could also be something like a remote
    procedure or hardware interface. We access resources via **endpoints**, which
    are URLs that represent a particular resource.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务围绕访问**资源**的概念构建。资源通常是数据记录或文件，尽管它也可能是远程过程或硬件接口之类的其他东西。我们通过**端点**访问资源，端点是表示特定资源的URL。
- en: We have seen that web servers typically allow you to fetch data using `GET`
    and submit data using `POST`. REST APIs, however, employ additional HTTP methods
    like `DELETE`, `PUT`, and `PATCH` to indicate different operations. Depending
    on which method we use when requesting an endpoint, we can perform different actions
    on the resource.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Web服务器通常允许您使用`GET`方法获取数据，使用`POST`方法提交数据。然而，REST API使用额外的HTTP方法，如`DELETE`、`PUT`和`PATCH`来指示不同的操作。根据我们在请求端点时使用的方法，我们可以在资源上执行不同的操作。
- en: 'While implementations of REST services vary, the following table shows the
    generally-agreed-upon functions of HTTP methods by a typical API:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管REST服务的实现方式各异，以下表格显示了典型API中HTTP方法的一般公认功能：
- en: '| Method | Function |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 功能 |'
- en: '| `GET` | Retrieve a resource |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取资源|'
- en: '| `HEAD` | Retrieve only metadata (headers) about a resource |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 仅检索资源的元数据（头部）|'
- en: '| `POST` | Create or update a resource based on the submitted data |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 根据提交的数据创建或更新资源|'
- en: '| `PUT` | Upload a resource as-is (typically for files) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 以原样上传资源（通常用于文件）|'
- en: '| `PATCH` | Update an existing resource with partial data (rarely implemented)
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 使用部分数据更新现有资源（很少实现）|'
- en: '| `DELETE` | Delete a resource |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源|'
- en: In addition to a more robust set of methods, REST services also exchange data
    in a way that is more code-friendly. While browser-oriented services accept data
    in URL-encoded strings and return HTML documents, RESTful services may accept
    requests and return responses in formats like JSON or XML. In some cases, clients
    can even request the data format to be returned.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更健壮的方法集之外，REST服务还以更符合代码的方式交换数据。虽然以浏览器为导向的服务接受URL编码的字符串数据并返回HTML文档，但RESTful服务可以接受请求并以JSON或XML等格式返回响应。在某些情况下，客户端甚至可以请求返回的数据格式。
- en: It's critical to understand that, while some standards for RESTful services
    exist, the organization and behavior of REST sites (including their precise responses
    to different methods) vary widely. In order to interact with a REST API, you will
    need to consult its specific documentation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要，尽管存在一些RESTful服务的标准，但REST站点（包括它们对不同方法的精确响应）的组织和行为差异很大。为了与REST API交互，您需要查阅其具体文档。
- en: The Python requests library
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的requests库
- en: As we saw in the first section of this chapter, `urllib` is fairly simple to
    use for basic `GET` and `POST` requests, and being in the standard library makes
    it a good choice when that's all we require. However, more complex HTTP interactions
    involving authentication, file uploads, or additional HTTP methods can be frustrating
    and complicated using `urllib` alone. To get this done, we'll turn to the third-party
    `requests` library. This library is highly recommended by the Python community
    for any serious work involving HTTP. As you'll see, `requests` removes many of
    the rough edges and outdated assumptions left in `urllib`, providing convenient
    classes and wrapper functions for more modern HTTP transactions like REST. Complete
    documentation on `requests` can be found at [https://docs.python-requests.org](https://docs.python-requests.org),
    but the next section will cover most of what you need to know to use it effectively.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一节中看到的，`urllib` 对于基本的 `GET` 和 `POST` 请求来说相当简单易用，并且作为标准库的一部分，当我们的需求仅限于此时，它是一个很好的选择。然而，涉及身份验证、文件上传或附加
    HTTP 方法的更复杂 HTTP 交互，仅使用 `urllib` 可能会令人沮丧且复杂。为了完成这项工作，我们将转向第三方 `requests` 库。这个库被
    Python 社区高度推荐，用于任何涉及 HTTP 的严肃工作。正如您将看到的，`requests` 去除了 `urllib` 中留下的许多粗糙边缘和过时的假设，为更现代的
    HTTP 事务（如 REST）提供了方便的类和包装函数。`requests` 的完整文档可以在 [https://docs.python-requests.org](https://docs.python-requests.org)
    找到，但下一节将涵盖您需要了解的大部分内容，以便有效地使用它。
- en: Installing and using requests
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用 requests
- en: The `requests` package is written in pure Python, so installing it with `pip`
    requires no compiling or binary downloads. Simply type `pip install --user requests`
    in the terminal and it will be added to your system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests` 包是用纯 Python 编写的，因此使用 `pip` 安装它不需要编译或二进制下载。只需在终端中输入 `pip install
    --user requests` 即可，它将被添加到您的系统中。'
- en: 'Let''s check out how `requests` works in the Python shell; open a shell and
    enter the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `requests` 在 Python 命令行中的工作方式；打开一个命令行窗口并输入以下内容：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `requests.request()` function requires, at a minimum, an HTTP method and
    a URL. Just like `urlopen()`, it constructs the appropriate request packet, sends
    it to the URL, and returns an object representing the server's response. Here,
    we're making a `GET` request to this author's website.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests.request()` 函数至少需要 HTTP 方法和一个 URL。就像 `urlopen()` 一样，它构建适当的请求包，将其发送到
    URL，并返回一个表示服务器响应的对象。在这里，我们正在向这位作者的网站发送一个 `GET` 请求。'
- en: 'In addition to the `request()` function, `requests` has shortcut functions
    that correspond to the most common HTTP methods. Thus, the same request can be
    made as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `request()` 函数外，`requests` 还提供了对应于最常见 HTTP 方法的快捷函数。因此，相同的请求可以如下进行：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `get()` method requires only the URL and performs a `GET` request. Likewise,
    the `post()`, `put()`, `patch()`, `delete()`, and `head()` functions send requests
    using the corresponding HTTP method. All of these request functions take additional
    optional arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 方法只需要 URL 并执行 `GET` 请求。同样，`post()`、`put()`、`patch()`、`delete()` 和 `head()`
    函数使用相应的 HTTP 方法发送请求。所有这些请求函数都接受额外的可选参数。'
- en: 'For example, we can send data with a `POST` request as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过以下方式使用 `POST` 请求发送数据：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that, unlike `urlopen()`, we can use a Python dictionary directly as
    a `data` argument; `requests` does the job of converting it to the proper URL-encoded
    `bytes` object for us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `urlopen()` 不同，我们可以直接使用 Python 字典作为 `data` 参数；`requests` 会为我们将其转换为适当的 URL
    编码 `bytes` 对象。
- en: 'Some of the more common arguments used with request functions are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求函数一起使用的某些更常见的参数如下：
- en: '| Argument | Purpose |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 用途 |'
- en: '| `params` | Like `data`, but added to the query string rather than the payload
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `params` | 与 `data` 类似，但添加到查询字符串而不是有效负载中 |'
- en: '| `json` | JSON data to include in the payload |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 要包含在有效负载中的 JSON 数据 |'
- en: '| `headers` | A dictionary of header data to use for the request |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `headers` | 要用于请求的头部数据字典 |'
- en: '| `files` | A dictionary of `{fieldnames: file_objects}` to send as a multipart
    form data request |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `files` | 要作为多部分表单数据请求发送的 `{字段名: 文件对象}` 字典 |'
- en: '| `auth` | Username and password tuple to use for basic HTTP digest authentication
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `auth` | 用于基本 HTTP 摘要身份验证的用户名和密码元组 |'
- en: Note that the `auth` argument here only works to authenticate against HTTP digest
    authentication; this is an older method of authentication that is implemented
    at the web server level rather than in the actual web application, and it's rarely
    used on modern websites. To work with modern authentication systems, we need to
    understand the use of sessions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的`auth`参数仅用于对HTTP摘要认证进行认证；这是一种较老的认证方法，它在网络服务器级别实现，而不是在实际的Web应用程序中实现，并且在现代网站上很少使用。要与现代认证系统协同工作，我们需要了解会话的使用。
- en: Interacting with authenticated sites using Session
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Session与认证网站交互
- en: HTTP is a **stateless** protocol, meaning that each HTTP request stands on its
    own and is not connected to any other requests, even between the same client and
    server. Although it may seem like you are "connected" to your social media or
    banking website when you log in, in reality there is no underlying ongoing connection
    between you and the server, only a series of unrelated requests and responses.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个**无状态**协议，这意味着每个HTTP请求都是独立的，并且不与其他请求连接，即使在同一客户端和服务器之间也是如此。尽管您在登录时可能感觉像是“连接”到了您的社交媒体或银行网站，但实际上，您和服务器之间没有持续的底层连接，只有一系列无关的请求和响应。
- en: How, then, do such sites manage to keep your interactions secure?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些网站是如何保持您的交互安全的？
- en: On modern sites, this is typically done using either a **session cookie** or
    **authentication token**. In both of these approaches, when the client authenticates
    to the server, the server returns a piece of data that the client can include
    with future requests to identify itself as the same entity that successfully authenticated.
    In this way, both client and server can simulate a stateful connection by associating
    the requests and responses between them into a session.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网站上，这通常是通过使用**会话cookie**或**认证令牌**来完成的。在这两种方法中，当客户端向服务器进行认证时，服务器会返回一个数据片段，客户端可以将其包含在未来的请求中，以标识自己为成功认证的同一实体。通过这种方式，客户端和服务器都可以通过将它们之间的请求和响应关联到会话中，来模拟一个有状态的连接。
- en: The differences between session cookies and authentication tokens are immaterial
    for us on the client side; just know that both require us to store something from
    the server after authentication and provide it with each future request.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端来说，会话cookie和认证令牌之间的区别无关紧要；只需知道两者都需要我们在认证后从服务器存储某些信息，并在未来的每个请求中提供这些信息。
- en: 'The `requests` module makes this kind of interaction simple by providing the
    `Session` class. A `Session` object persists settings, cookies, and tokens across
    multiple requests, allowing you to interact with services that require authentication
    or special client settings. To create a `Session` object, use the `requests.session()`
    factory function as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`模块通过提供`Session`类使这种交互变得简单。`Session`对象在多个请求之间持续设置、cookie和令牌，允许您与需要认证或特殊客户端设置的服务进行交互。要创建一个`Session`对象，使用以下`requests.session()`工厂函数：'
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can call request methods like `get()`, `post()`, and others on our
    `Session` object, for example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的`Session`对象上调用请求方法，例如`get()`、`post()`等：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Token and cookie handling like this happens in the background, without any explicit
    action from us. Cookies are stored in a `CookieJar` object in the `Session` object's
    `cookies` property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的令牌和cookie处理是在后台发生的，不需要我们采取任何明确的行动。Cookies存储在`Session`对象的`cookies`属性中的`CookieJar`对象中。
- en: 'We can also set configuration options on our `Session` object that will persist
    across requests; for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在我们的`Session`对象上设置将在请求之间持续存在的配置选项；例如：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we've set the user-agent string to `Mozilla`, which will then
    be used for all requests made from this `Session` object. We also set a default
    URL parameter using the `params` attribute; thus, the actual URL that was requested
    was `http://example.com?uid=12345`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将用户代理字符串设置为`Mozilla`，这将随后用于从这个`Session`对象发出的所有请求。我们还使用`params`属性设置了一个默认URL参数；因此，实际请求的URL是`http://example.com?uid=12345`。
- en: The requests.Response object
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requests.Response对象
- en: All the request functions and methods in `requests` return a `Response` object.
    These `Response` objects are not the same as those returned by `urlopen()`; they
    contain all the same data, but in a slightly different (and generally more convenient)
    form. In addition, they have some helpful methods that make quick work of translating
    their contents.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests` 中的所有请求函数和方法都返回一个 `Response` 对象。这些 `Response` 对象与 `urlopen()` 返回的对象不同；它们包含所有相同的数据，但形式略有不同（通常更方便）。此外，它们还有一些有助于快速处理其内容的方法。'
- en: 'For example, the response headers are already translated into a Python dictionary
    for us, as demonstrated here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，响应头已经为我们翻译成了 Python 字典，如下所示：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Another difference from `urllib` is that `requests` does not automatically raise
    an exception on HTTP errors. However, the `.raise_for_status()` response method
    can be called to do so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `urllib` 的另一个区别是，`requests` 在 HTTP 错误上不会自动引发异常。但是，可以通过调用 `.raise_for_status()`
    响应方法来这样做。
- en: 'For example, let''s make a request to a URL that will give an HTTP `404` error:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向一个将返回 HTTP `404` 错误的 URL 发送请求：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This gives us the option of dealing with HTTP errors using exception handling
    or more traditional flow control logic if we prefer, or to defer our exception
    handling to a more convenient moment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们使用异常处理或更传统的流程控制逻辑来处理 HTTP 错误的选择，或者将异常处理推迟到更方便的时刻。
- en: Implementing a REST backend
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现REST后端
- en: To start implementing our interactions with the ABQ corporate REST server, we
    need to figure out what kind of requests we're going to send. We've been provided
    with some documentation from the corporate office that describes how to interact
    with the REST API.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现与 ABQ 企业 REST 服务器的交互，我们需要弄清楚我们将发送什么类型的请求。我们已从企业办公室获得了一些文档，描述了如何与 REST API
    交互。
- en: 'The API documentation tells us the following things:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档告诉我们以下内容：
- en: Before accessing any other endpoints, we'll need to obtain an authentication
    token. We do this by submitting a `POST` request to the `/auth` endpoint. The
    payload of the `POST` request should include `username` and `password` as URL-encoded
    data. If our credentials fail, we'll get an HTTP 401 error. If we don't have a
    token, any other requests will fail with an HTTP 403 error.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问任何其他端点之前，我们需要获取一个身份验证令牌。我们通过向 `/auth` 端点提交 `POST` 请求来完成此操作。`POST` 请求的有效负载应包括作为
    URL 编码数据的 `username` 和 `password`。如果我们的凭证失败，我们将收到 HTTP 401 错误。如果我们没有令牌，任何其他请求都将因
    HTTP 403 错误而失败。
- en: 'Once we have a token, we can work with files using the `/files` endpoint:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了令牌，我们就可以使用 `/files` 端点来处理文件：
- en: We can upload files using a `PUT` request. The file is uploaded as multipart
    form data specified in a parameter called `file`.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `PUT` 请求上传文件。文件作为名为 `file` 的参数指定的多部分表单数据上传。
- en: We can retrieve a file by sending a `GET` request in the form of `/files/FILENAME`,
    where `FILENAME` is the name of the file.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过发送形式为 `/files/FILENAME` 的 `GET` 请求来检索一个文件，其中 `FILENAME` 是文件的名称。
- en: Alternatively, we can retrieve only metadata about a file by sending a `HEAD`
    request to `/files/FILENAME`.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以通过向 `/files/FILENAME` 发送 `HEAD` 请求来仅检索文件的元数据。
- en: All HTTP errors are accompanied by a JSON payload that includes the status code
    and a message indicating what caused the error.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 HTTP 错误都伴随着包含状态码和指示错误原因的消息的 JSON 有效负载。
- en: An example script, `sample_rest_service.py`, is included with the example code
    for this book that replicates the functionality of the ABQ Corporate REST services.
    To use it, you'll need to install the `flask` library using the command `pip install
    -u flask`, then run the command `python sample_rest_service.py` at a terminal
    prompt.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 包含示例代码的这本书中包含了一个名为 `sample_rest_service.py` 的示例脚本，它复制了 ABQ 企业 REST 服务的功能。要使用它，您需要使用命令
    `pip install -u flask` 安装 `flask` 库，然后在终端提示符下运行命令 `python sample_rest_service.py`。
- en: 'Once again, in keeping with our MVC design, we''re going to implement a model
    that encapsulates all these interactions. We''ll begin in `models.py` by importing
    the `requests` library like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，遵循我们的 MVC 设计，我们将实现一个封装所有这些交互的模型。我们将在 `models.py` 中开始，导入 `requests` 库，如下所示：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, at the end of the file, let''s start a new model class, `CorporateRestModel`,
    for the REST site:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文件末尾，让我们开始一个新的模型类，`CorporateRestModel`，用于 REST 网站：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The class initializer takes a `base_url` argument defining the base URL of the
    REST service we want to contact. It then uses this URL to construct the endpoint
    URLs for upload, authentication, and file retrieval. Finally, since we're going
    to need to store authentication tokens, we create a session object for each method
    to use.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类初始化器接受一个`base_url`参数，用于定义我们想要联系的基础REST服务的URL。然后使用此URL来构造上传、认证和文件检索的端点URL。最后，由于我们需要存储认证令牌，我们为每个方法创建一个会话对象。
- en: We could have just specified the `base_url` as a class attribute like we did
    with the `WeatherDataModel`; however, to enable us to test this class against
    the test service, or to accommodate the possibility of a change to the corporate
    servers, we'll store this value in the user's settings so it can be easily swapped
    out.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将`base_url`指定为一个类属性，就像我们在`WeatherDataModel`中做的那样；然而，为了使我们能够测试此类与测试服务，或者为了适应公司服务器可能发生的变化，我们将此值存储在用户的设置中，以便可以轻松替换。
- en: 'Before we go on, let''s add a setting to our `SettingsModel` for the REST base
    URL:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们为我们的`SettingsModel`添加一个用于REST基础URL的设置：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The default value of `http://localhost:8000` is the base URL of the example
    server provided for testing; in production, this setting can be altered by technical
    support for each user by editing their `abq_settings.json` file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值`http://localhost:8000`是提供的示例服务器的基础URL，用于测试；在生产环境中，此设置可以通过编辑每个用户的`abq_settings.json`文件由技术支持进行更改。
- en: 'Now, back in our `CorporateRestModel` class, we need to implement four methods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`CorporateRestModel`类中，我们需要实现四个方法：
- en: An `authenticate()` method to send credentials via a `POST` request to the `/auth`
    endpoint.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`authenticate()`方法，通过`POST`请求将凭据发送到`/auth`端点。
- en: An `upload_file()` method to send a file via a `PUT` request to the `/files`
    endpoint.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`upload_file()`方法，通过`PUT`请求将文件发送到`/files`端点。
- en: A `check_file()` method to retrieve only metadata from the `/files` endpoint.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`check_file()`方法，用于从`/files`端点检索仅包含元数据。
- en: A `get_file()` method to download a file from the `/files` endpoint.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`get_file()`方法，用于从`/files`端点下载文件。
- en: Let's get started!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The authenticate() method
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`authenticate()`方法'
- en: 'Since we can''t do anything else without an authentication token, let''s start
    with the `authenticate()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有认证令牌我们无法做任何事情，让我们从`authenticate()`方法开始：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This method will take a username and password and post them to the `auth_url`
    using our model''s `Session` object. The session will automatically store the
    token we receive if we''re successful. Recall that the server will return an HTTP
    401 error if we provide invalid credentials; we could simply check the status
    code of the response and return `True` or `False` from this method. However, since
    there are a variety of other ways that a call to a remote HTTP server can fail
    (for example, a problem on the server might result in a 500 error), it would be
    better if we could report back to the calling code some more detailed information
    about the failure. We could do this by calling the `Response` object''s `raise_for_status()`
    method to send an `HTTPError` exception back to the calling code. That might give
    us an error dialog like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将接受用户名和密码，并使用我们模型的`Session`对象将它们发布到`auth_url`。如果成功，会话将自动存储我们收到的令牌。回想一下，如果提供无效的凭据，服务器将返回HTTP
    401错误；我们可以简单地检查响应的状态码，并从该方法返回`True`或`False`。然而，由于远程HTTP服务器调用失败有多种方式（例如，服务器上的问题可能导致500错误），如果能向调用代码报告更多关于失败详细信息的反馈会更好。我们可以通过调用`Response`对象的`raise_for_status()`方法来实现，这将向调用代码发送`HTTPError`异常。这可能会给我们一个像这样的错误对话框：
- en: '![Figure 13.2: An ugly 401 error](img/B17578_13_02.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：一个丑陋的401错误](img/B17578_13_02.png)'
- en: 'Figure 13.2: An ugly 401 error'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：一个丑陋的401错误
- en: Of course, we can, and should, do a bit better. Most users won't know what an
    HTTP 401 error means.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以，也应该做得更好。大多数用户不会知道HTTP 401错误是什么意思。
- en: 'Remember from the API specification that the server also returns a JSON object
    with the error that contains a more meaningful message about the failure. We can
    write a static method for our model that will handle an `HTTPError` and convert
    it to an exception with a more human-friendly message. Add this method to the
    model:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从API规范中记住，服务器还会返回一个包含更具有意义错误信息的JSON对象。我们可以为我们的模型编写一个静态方法来处理`HTTPError`并将其转换为带有更人性化的信息的异常。将此方法添加到模型中：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method accepts a `Response` object, then calls its `raise_for_status()`
    method. If the status was a success (200), then nothing will happen and the method
    returns. If it raises an `HTTPError`, however, we'll extract the `message` value
    from the `Response` object's JSON payload and raise a new `Exception` error using
    that message.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个`Response`对象，然后调用其`raise_for_status()`方法。如果状态码是成功（200），则不会发生任何事情，该方法返回。然而，如果抛出`HTTPError`，我们将从`Response`对象的JSON有效负载中提取`message`值，并使用该消息抛出一个新的`Exception`错误。
- en: 'Back in `authenticate()`, let''s end the method by passing the response to
    this static method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`authenticate()`中，让我们通过传递响应到此静态方法来结束该方法：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now a failed login looks more like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在失败的登录看起来更像是这样：
- en: '![Figure 13.3: A much nicer failure message](img/B17578_13_03.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：一个更友好的错误信息](img/B17578_13_03.png)'
- en: 'Figure 13.3: A much nicer failure message'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：一个更友好的错误信息
- en: If no exception is raised, we don't need to do anything else. The session has
    the token and we can proceed to other operations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，我们不需要做任何事情。会话中已经有了令牌，我们可以继续进行其他操作。
- en: The upload_file() method
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`upload_file()`方法'
- en: 'Our next method will implement actually uploading a file. Remember from the
    API documentation that this requires a `PUT` request to the `/files` endpoint.
    The method looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个要实现的方法是实际上传文件。记住，根据API文档，这需要向`/files`端点发送`PUT`请求。该方法看起来如下：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To send a file using `requests`, we have to actually open it and retrieve a
    file handle, then place the file handle in a dictionary, which we pass to the
    request method's `files` argument. Multiple files can be sent if each one receives
    a different key in the dictionary; our API only allows one file at a time, however,
    and it must have a key of `file`. Once again, we finish the method by checking
    the response for an error code with our `_raise_for_status()` method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`requests`发送文件，我们必须实际打开它并获取一个文件句柄，然后将文件句柄放入一个字典中，并将其传递给请求方法的`files`参数。如果每个文件在字典中都有一个不同的键，则可以发送多个文件；然而，我们的API一次只允许发送一个文件，并且它必须有一个键为`file`。再次提醒，我们通过检查响应的错误码来结束方法，使用我们的`_raise_for_status()`方法。
- en: Notice we open the file in binary-read mode (`rb`). The `requests` documentation
    recommends this, as it ensures the correct `Content-length` value will be calculated
    for the request header.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们以二进制读取模式（`rb`）打开文件。`requests`文档建议这样做，因为它确保请求头将计算正确的`Content-length`值。
- en: The check_file() method
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`check_file()`方法'
- en: The next method we need is the `check_file()` method, which will retrieve header
    information about a file on the server without actually downloading it. The API
    documentation tells us that we can get metadata about the file by sending a `HEAD`
    request to the `files/FILENAME` endpoint, where `FILENAME` is the name of the
    file we want information about. `HEAD` requests are useful when dealing with slow
    connections or large files, as they allow us to find out information about the
    file (for example, its size or whether it exists or not) without actually downloading
    the entire file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个方法是`check_file()`方法，它将检索服务器上文件的头部信息，而无需实际下载它。API文档告诉我们，通过向`files/FILENAME`端点发送`HEAD`请求，我们可以获取文件的元数据，其中`FILENAME`是我们想要获取信息的文件名。`HEAD`请求在处理慢速连接或大文件时很有用，因为它们允许我们找到有关文件的信息（例如，其大小或是否存在），而无需实际下载整个文件。
- en: 'Let''s implement this method like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样实现这个方法：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For our purposes, we are mostly interested in whether files on the server exist
    or not, so we're going to return a Boolean value from this method depending on
    whether we get a status 200 (success) or 404 (file not found). Of course, other
    things can go wrong with the request too, so we'll also pass the response to our
    `_raise_for_status()` method if it has a different status code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们主要关心服务器上的文件是否存在，因此我们将根据是否收到状态码200（成功）或404（文件未找到）从该方法返回一个布尔值。当然，请求也可能出现其他问题，所以如果状态码不同，我们也会将响应传递给我们的`_raise_for_status()`方法。
- en: The get_file() method
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`get_file()`方法'
- en: 'The last method we''ll implement is the `get_file()` method, for downloading
    file data. Add the following method to `CorporateRestModel`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的最后一个方法是`get_file()`方法，用于下载文件数据。将以下方法添加到`CorporateRestModel`中：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unlike other endpoints in this API, a `GET` request to the `/files` endpoint
    does *not* return JSON, but rather the contents of the file. We can retrieve these
    contents from the `Response` object's `text` attribute, which we're returning
    from the method. It will be up to the code that calls this method to do something
    suitable with the content returned from the method. We'll do this in our `Application`
    class, where we'll save the downloaded content to a file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与此API中的其他端点不同，对`/files`端点的`GET`请求**不**返回JSON，而是返回文件的正文。我们可以从`Response`对象的`text`属性中检索这些内容，这是我们方法返回的。这将取决于调用此方法的代码如何处理方法返回的内容。我们将在`Application`类中这样做，我们将保存下载的内容到文件中。
- en: As our model is now complete, let's head over to the `Application` class to
    begin working on the front end.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模型现在已经完成，让我们转到`Application`类，开始处理前端工作。
- en: Integrating REST upload into the application
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将REST上传集成到应用程序中
- en: 'After discussions with your manager, who is responsible for performing the
    REST upload, you determine that the workflow for the REST upload operation needs
    to go something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在与负责执行REST上传的经理讨论后，你确定REST上传操作的流程需要类似于以下内容：
- en: When a REST upload is run from the GUI, it should first check if there is any
    data in the database for that day, and abort if there is not. It looks bad on
    your manager if they upload empty files!
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从GUI运行REST上传时，它应该首先检查数据库中是否有当天的数据，如果没有，则终止操作。如果上传了空文件，这会让你的经理看起来很糟糕！
- en: If there is data, it should create a CSV extract of the day's data using the
    original naming format that was used before the facility went to SQL storage,
    since this is the filename format expected by ABQ Corporate.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有数据，它应该使用在设施转向SQL存储之前使用的原始命名格式创建当天的CSV数据提取，因为这是ABQ公司期望的文件名格式。
- en: Next, it should prompt for authentication credentials for the REST API.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，它应该提示输入REST API的认证凭证。
- en: After that, the program should check if a file has already been uploaded for
    that day's data. If not, go ahead and upload the file.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，程序应该检查当天数据是否已经上传了文件。如果没有，请上传文件。
- en: If there is a file (sometimes she forgets and uploads twice), the program should
    prompt whether the file should be overwritten or not.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有文件（有时她忘记并上传两次），程序应该提示是否应该覆盖文件。
- en: In the event we're not overwriting the file, there should be an option to download
    the file from the server so it can be manually compared with the data in SQL.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有覆盖文件，应该有一个选项从服务器下载文件，以便可以手动与SQL中的数据进行比较。
- en: Let's begin implementing this code!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现这段代码！
- en: Creating a CSV extract
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建CSV提取
- en: Before we can upload anything, we need to implement a way to create a CSV extract
    of the daily data. This will be used by more than one function, so we'll implement
    it as a separate method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以上传任何内容之前，我们需要实现创建每日数据CSV提取的方法。这将被多个函数使用，因此我们将将其实现为一个单独的方法。
- en: 'Start a new private method in `Application` called `_create_csv_extract()`,
    like so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application`类中开始一个新的私有方法，命名为`_create_csv_extract()`，如下所示：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The method begins by creating a new instance of our `CSVModel` class; even though
    we're no longer storing our data in the CSV files, we can still use the model
    to export a CSV file. We are not passing in any arguments, just using the default
    file path of the file. Next, we call the `get_all_records()` method of the application's
    `SQLModel` instance. Remember that our `SQLModel.get_all_records()` method returns
    a list of all records for the current day by default. Since your boss doesn't
    want to upload empty files, we'll raise an exception if there are no records to
    build a CSV with. Our calling code can catch that and display the appropriate
    warning. If there are records to save, the method iterates through them, saving
    each one to the CSV, then returns the `CSVModel` object's `file` attribute (that
    is, a `Path` object pointing to the saved file).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先创建我们`CSVModel`类的新实例；尽管我们不再将数据存储在CSV文件中，但我们仍然可以使用该模型导出CSV文件。我们没有传递任何参数，只是使用文件的默认文件路径。接下来，我们调用应用程序`SQLModel`实例的`get_all_records()`方法。记住，我们的`SQLModel.get_all_records()`方法默认返回当前日期的所有记录列表。由于你的老板不希望上传空文件，如果没有记录来构建CSV，我们将引发异常。我们的调用代码可以捕获这个异常并显示适当的警告。如果有记录要保存，该方法将遍历它们，将每个记录保存到CSV中，然后返回`CSVModel`对象的`file`属性（即指向已保存文件的`Path`对象）。我们的调用代码将负责对从方法返回的内容进行适当的处理。我们将在`Application`类中这样做，我们将保存下载的内容到文件中。
- en: Creating the upload callback
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建上传回调
- en: 'Now that we have a way to create a CSV extract file, we can write the actual
    callback method as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建CSV提取文件的方法，我们可以编写实际的回调方法如下所示：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To begin, we attempt to create a CSV extract file; if we get any exceptions
    (for example, the "No records" exception we created, or perhaps a database issue)
    we'll display an error message and exit the method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试创建一个CSV提取文件；如果我们遇到任何异常（例如，我们创建的“没有记录”异常，或者可能是数据库问题），我们将显示错误消息并退出方法。
- en: 'If we''ve created a CSV file successfully, our next step is to authenticate
    to the REST API. To do that, we need to get a username and password from the user.
    Fortunately, we have the perfect class for this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功创建了CSV文件，我们的下一步是对REST API进行身份验证。为此，我们需要从用户那里获取用户名和密码。幸运的是，我们有完美的类来完成这个任务：
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our `LoginDialog` class serves us well here. Unlike with our database login,
    we're not going to run this in an endless loop; if the password is wrong, we will
    just return from the function and the user can rerun the command if need be. Recall
    that dialog's `result` attribute will be `None` if the user clicks `Cancel`, so
    we'll just exit the callback method in that case.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`LoginDialog`类在这里为我们提供了很好的服务。与数据库登录不同，我们不会无限循环地运行这个；如果密码错误，我们将直接从函数返回，用户如果需要可以重新运行命令。回想一下，如果用户点击了“取消”，那么对话框的`result`属性将是`None`，所以在这种情况下，我们将直接退出回调方法。
- en: 'Now that we have credentials and a filename, we can try to authenticate to
    the server:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了凭据和文件名，我们可以尝试对服务器进行身份验证：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We begin by creating a `CorporateRestModel` instance based on the user's `abq_rest_url`
    setting, then passing our credentials to its `authenticate()` method. Recall that
    in the event of an HTTP problem (including invalid credentials), our model will
    raise an `Exception` with a human-friendly message, so we can simply display that
    in a message box and exit the callback.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先基于用户的`abq_rest_url`设置创建一个`CorporateRestModel`实例，然后将我们的凭据传递给其`authenticate()`方法。回想一下，在出现HTTP问题（包括无效凭据）的情况下，我们的模型将抛出一个带有友好信息的`Exception`，因此我们可以简单地在一个消息框中显示它并退出回调。
- en: 'Our next step is to check if a file for today''s date already exists on the
    server. We''ll do that using our model''s `check_file()` method, like so:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是检查服务器上是否已经存在今天日期的文件。我们将使用我们模型的`check_file()`方法来完成，如下所示：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Remember that `check_file()` will return a Boolean value indicating if the file
    exists on the server or not, or it might raise an exception if some other HTTP
    issue arises. As before, in the event of an error we'll just show a dialog and
    exit the function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`check_file()`将返回一个布尔值，表示文件是否存在于服务器上，或者如果出现其他HTTP问题，可能会抛出异常。和之前一样，在出现错误的情况下，我们将显示对话框并退出函数。
- en: 'If the file already exists, we need to determine what the user wants to do
    about it; first, whether they want to just overwrite it, and if not, whether they
    want to download it. We can do that using some message boxes, like so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在，我们需要确定用户对此的处理意愿；首先，他们是否只想覆盖它，如果不是，是否想要下载它。我们可以通过一些消息框来实现，如下所示：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Remember from *Chapter 7*, *Creating Menus with Menu and Tkinter Dialogs*, that
    `askyesno()` returns a Boolean value depending on whether the user clicks **Yes**
    or **No**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 记住来自*第7章*，*使用菜单和Tkinter对话框创建菜单*，`askyesno()`函数返回一个布尔值，取决于用户是否点击了**是**或**否**。
- en: 'If the user wants to download the file, we can do that using our model, like
    so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要下载文件，我们可以使用我们的模型来完成，如下所示：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we first retrieve the filename the user wants to save the downloaded file
    to using a `filedialog` function. If they cancel the dialog, we'll just exit the
    function doing nothing. Otherwise, we attempt to download the file using our model's
    `get_file()` method. As before, if it fails we display the error and exit. If
    it succeeds, we'll open a new UTF-8 file and save the data to it. Finally, we
    display a success dialog once the file is written. The final `return` statement
    exits the method whether or not the user decides to download the file; since at
    this point, they've opted not to overwrite the file in either case.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用`filedialog`函数检索用户想要保存下载文件的文件名。如果他们取消对话框，我们将直接退出函数而不做任何操作。否则，我们尝试使用我们模型的`get_file()`方法下载文件。和之前一样，如果失败，我们将显示错误并退出。如果成功，我们将打开一个新的UTF-8文件并将数据保存到其中。最后，在文件写入后，我们将显示一个成功对话框。最后的`return`语句将根据用户是否决定下载文件退出方法；因为在这个时候，他们已经选择在两种情况下都不覆盖文件。
- en: 'If they have opted to overwrite the file, our method continues outside that
    `if` block as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们选择了覆盖文件，我们的方法将继续在`if`块外部执行，如下所示：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: At this point, if the method has not yet returned due to an error or user selection,
    we can go ahead and upload the file. This is done using our model's `upload_file()`
    method. We'll either get a success dialog or an error dialog depending on whether
    the operation succeeds or fails. In either case, our method is finished at this
    point.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果由于错误或用户选择而导致方法尚未返回，我们可以继续上传文件。这是通过我们模型的`upload_file()`方法完成的。我们将根据操作是否成功获得成功对话框或错误对话框。在任何情况下，我们的方法都到此结束。
- en: Finishing up
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成工作
- en: 'The last thing we need to do is add a menu option for running the REST upload.
    First, add the method to the `Application` class''s event callbacks as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是添加一个用于运行REST上传的菜单选项。首先，将方法添加到`Application`类的回调事件中，如下所示：
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, let''s add the command item to our main menu. We''ll start by adding
    a method to create the REST upload entry in the menu, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将命令项添加到我们的主菜单中。我们将首先添加一个创建菜单中REST上传条目的方法，如下所示：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we''ll need to add a call to this method in the `GenericMainMenu` class
    initializer and each of the platform-specific menus; in each case, it should look
    like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`GenericMainMenu`类的初始化器和每个平台特定的菜单中添加对这个方法的调用；在每种情况下，它应该看起来像这样：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, run the application and let's try it out. To make it work, you'll need
    to have at least one record saved in the database, and you'll need to start up
    the `sample_rest_service.py` script from the example code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并尝试一下。为了使其工作，你至少需要在数据库中保存一条记录，并且需要从示例代码中启动`sample_rest_service.py`脚本。
- en: 'If all goes well, you should get a dialog like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到一个类似的对话框：
- en: '![](img/B17578_13_04.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：示例代码中的SFTP使用](img/B17578_13_04.png)'
- en: 'Figure 13.4: A successful upload to the REST server'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：成功上传到REST服务器
- en: 'Your server should also have printed some output to the terminal similar to
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器也应该在终端打印出类似以下内容的输出：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice the `POST`, `HEAD`, and `PUT` requests, as well as the filename of the
    CSV file in the payload of `PUT`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`POST`、`HEAD`和`PUT`请求，以及`PUT`的有效负载中的CSV文件名。
- en: 'You can also run the upload a second time, in which case you should get the
    dialogs asking if you want to overwrite the file, and then if you want to download
    it, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以再次运行上传，在这种情况下，你应该会看到对话框询问你是否要覆盖文件，然后是否要下载它，如下所示：
- en: '![Figure 13.5: Download dialog](img/B17578_13_05.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：下载对话框](img/B17578_13_05.png)'
- en: 'Figure 13.5: Download dialog'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：下载对话框
- en: That completes the functionality we needed for this application. Good job!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们为这个应用程序所需的功能。做得好！
- en: SFTP using paramiko
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用paramiko的SFTP
- en: While custom-written RESTful web APIs may be common with large companies and
    third-party services, our programs are often called upon to exchange files or
    data with servers using standard communication protocols. In the Linux and Unix
    world, the secure shell or SSH protocol has long been the de-facto standard for
    communication between systems. Most implementations of SSH include SFTP (**Secure
    File Transfer Protocol**), an encrypted replacement for the archaic FTP service.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义编写的RESTful Web API在大型公司和第三方服务中很常见，但我们的程序通常需要使用标准通信协议与服务器交换文件或数据。在Linux和Unix世界中，安全外壳或SSH协议长期以来一直是系统间通信的事实标准。大多数SSH实现包括SFTP（**安全文件传输协议**），它是过时的FTP服务的加密替代品。
- en: In addition to uploading the CSV extract to the corporate REST service, your
    manager has to upload a second copy to a remote server using SFTP. The user workflow
    needs to be the same, though there is a requirement to upload the file into a
    particular directory on the server. You need to implement this upload in your
    application just as you did for the REST service.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将CSV提取上传到企业REST服务之外，你的经理还需要使用SFTP将第二个副本上传到远程服务器。用户工作流程需要保持一致，尽管有一个要求将文件上传到服务器上的特定目录。你需要在应用程序中实现这个上传，就像你为REST服务所做的那样。
- en: Setting up SSH services for testing
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置SSH服务以进行测试
- en: 'In order to test the SFTP features we''re going to code in our application,
    we need to have an SSH server available to us. If you don''t have access to a
    device that runs SSH, you can easily install it on your own workstation, depending
    on your operating system:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们将在应用程序中编写的SFTP功能，我们需要有一个可供我们使用的SSH服务器。如果你没有运行SSH的设备，你可以根据你的操作系统轻松地在自己的工作站上安装它：
- en: On macOS, SSH is preinstalled but needs to be enabled. You can enable it from
    the **Sharing** page in **System Preferences**.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上，SSH是预安装的，但需要启用。您可以从**系统偏好设置**中的**共享**页面启用它。
- en: On most Linux distributions, you can find SSH in your package manager as `ssh`,
    `ssh-server`, or `openssh` if it's not already installed. Most distributions will
    enable the server by default after installation.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数 Linux 发行版中，您可以在包管理器中找到 SSH，作为 `ssh`、`ssh-server` 或 `openssh`（如果尚未安装）。大多数发行版在安装后默认启用服务器。
- en: On Windows 10 and above, you can install OpenSSH server using the **Optional
    Features** tool under **Settings** | **Apps** | **Apps & features**. Once installed,
    start the service by opening the **Services** app, selecting **OpenSSH** **server**,
    and clicking **Start the service**.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 10 及更高版本中，您可以通过在 **设置** | **应用** | **应用和功能** 下的 **可选功能** 工具安装 OpenSSH
    服务器。安装完成后，通过打开 **服务** 应用，选择 **OpenSSH** **服务器**，然后点击 **启动服务** 来启动服务。
- en: Once the service is installed and running, you can connect to your computer
    using an SSH client like OpenSSH Client, and log in using a local username and
    password. You can use your normal user account, but since our application will
    be creating directories and copying files under the home directory of whatever
    user you use to connect to SSH, you may also wish to create a test user account
    for login so that the application does not accidentally overwrite any of your
    files.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务安装并运行，您可以使用类似 OpenSSH 客户端这样的 SSH 客户端连接到您的计算机，并使用本地用户名和密码登录。您可以使用您的普通用户账户，但由于我们的应用程序将在您用于连接
    SSH 的任何用户的家目录下创建目录和复制文件，您可能还希望创建一个测试用户账户以供登录，这样应用程序就不会意外覆盖您的任何文件。
- en: Installing and using paramiko
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和使用 paramiko
- en: 'Although the standard library offers nothing in the way of SSH or SFTP support,
    the third-party `paramiko` library provides a full suite of tools for working
    with both. Install `paramiko` from PyPI using the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准库在 SSH 或 SFTP 支持方面没有提供任何功能，但第三方 `paramiko` 库提供了用于处理两者的完整工具集。使用以下命令从 PyPI
    安装 `paramiko`：
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`paramiko` is pure Python, so it should not require compilation or additional
    programs to be installed. You can learn more about `paramiko` on its website,
    [https://www.paramiko.org](https://www.paramiko.org).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`paramiko` 是纯 Python 编写的，因此它不需要编译或安装额外的程序。您可以在其网站上了解更多关于 `paramiko` 的信息，[https://www.paramiko.org](https://www.paramiko.org)。'
- en: Using paramiko
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 paramiko
- en: 'The main class we''ll work with in `paramiko` is the `SSHClient` class, through
    which we''ll connect and interact with remote servers. Open a Python shell and
    let''s create one like so:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `paramiko` 中，我们将主要使用 `SSHClient` 类，通过它我们将连接并与远程服务器交互。打开一个 Python 命令行界面，并创建一个如下所示的实例：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before we can connect to any servers with the object, we need to configure
    its key management policy. As part of the secure design of SSH, SSH clients exchange
    encryption keys with the server the first time they connect; thus, when connecting
    to a new server for the first time with an SSH client, you''ll likely see a message
    like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用该对象连接到任何服务器之前，我们需要配置其密钥管理策略。作为 SSH 安全设计的一部分，SSH 客户端在第一次连接时会与服务器交换加密密钥；因此，当您第一次使用
    SSH 客户端连接到新服务器时，您可能会看到如下消息：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you choose to continue, the server's key (or **fingerprint**) will be stored
    with the hostname in a file usually called `known_hosts`. When connecting to the
    server again, SSH consults the known hosts list to verify that we're connecting
    to the same server. If the keys differ, the connection will fail.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择继续，服务器的密钥（或**指纹**）将与主机名一起存储在通常称为 `known_hosts` 的文件中。当再次连接到服务器时，SSH 会咨询已知主机列表以验证我们是否连接到同一服务器。如果密钥不同，连接将失败。
- en: 'So, the first thing we need to do is load any available key store that we have;
    if your SSH keys are stored in a standard location, calling the `load_system_host_keys()`
    method will suffice:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要加载我们拥有的任何可用密钥存储；如果您的 SSH 密钥存储在标准位置，调用 `load_system_host_keys()` 方法就足够了：
- en: '[PRE61]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can also specify a known hosts file explicitly using the `load_host_keys()`
    method, like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `load_host_keys()` 方法显式指定已知主机文件，如下所示：
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A prompt for adding an unknown host to the known hosts list may be OK for an
    interactive client, but within a programming library it is obviously not so practical.
    Instead, we need to set a policy of what the `SSHClient` object will do when we
    try to connect to an unknown host. By default, it will simply fail, but we can
    force it to automatically trust new hosts using the `set_missing_host_key_policy()`,
    like so:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交互式客户端，将未知主机添加到已知主机列表的提示可能是可以接受的，但在编程库中显然不太实用。相反，我们需要设置一个策略，以确定当尝试连接到未知主机时
    `SSHClient` 对象将执行什么操作。默认情况下，它将简单地失败，但我们可以通过使用 `set_missing_host_key_policy()`
    强制它自动信任新主机，如下所示：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here we've set the policy to an instance of `AutoAddPolicy`, which means any
    new host keys will automatically be trusted. `paramiko` also provides a `RejectPolicy`
    class (which is the default) that automatically rejects all new keys, and for
    advanced use cases we can define our own policy class for more nuanced behaviors.
    We're using `AutoAddPolicy` for convenience in this case; in a real-world, secure
    environment you should leave the default `RejectPolicy` setting and manage the
    `known_hosts` list outside the script.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将策略设置为 `AutoAddPolicy` 的实例，这意味着任何新的主机密钥都将自动被信任。`paramiko` 还提供了一个 `RejectPolicy`
    类（这是默认设置），它会自动拒绝所有新的密钥，并且对于更高级的使用场景，我们可以定义自己的策略类以实现更细微的行为。在这种情况下，我们使用 `AutoAddPolicy`
    以方便起见；在实际的、安全的环境中，您应该保留默认的 `RejectPolicy` 设置，并在脚本外部管理 `known_hosts` 列表。
- en: You can add servers to your `known_hosts` file simply by logging into them using
    **OpenSSH** Client and choosing `yes` when prompted to add the key, or by retrieving
    the key using the `ssh-keyscan` command included with OpenSSH Client and adding
    them to the file manually.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 **OpenSSH** 客户端登录到服务器并在提示添加密钥时选择 `yes`，或者通过使用 OpenSSH 客户端中包含的 `ssh-keyscan`
    命令检索密钥并将它们手动添加到文件中，简单地将在您的 `known_hosts` 文件中添加服务器。
- en: 'Once we''ve settled the issue of key management, we can connect to a host.
    This is done using the `connect()` method, like so:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决了密钥管理问题，我们就可以连接到主机。这是通过使用 `connect()` 方法完成的，如下所示：
- en: '[PRE64]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In addition to taking a hostname or IP address as a positional argument, `connect()`
    accepts a number of keyword arguments, including:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受一个主机名或 IP 地址作为位置参数外，`connect()` 还接受多个关键字参数，包括：
- en: '| Argument | Default | Description |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 默认值 | 描述 |'
- en: '| `username` | Local username | Username to use for authentication. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `username` | 本地用户名 | 用于身份验证的用户名。 |'
- en: '| `password` | `None` | Password for authentication. If blank, `SSHClient`
    will attempt key-based authentication. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `password` | `None` | 身份验证密码。如果为空，`SSHClient` 将尝试基于密钥的身份验证。 |'
- en: '| `port` | `22` | TCP port to connect to. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `port` | `22` | 连接到的 TCP 端口。 |'
- en: '| `pkey` | `None` | A private key string to use for authentication. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `pkey` | `None` | 用于身份验证的私钥字符串。 |'
- en: '| `key_file` | `None` | A file containing private keys or certificates for
    authentication. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `key_file` | `None` | 包含用于身份验证的私钥或证书的文件。 |'
- en: '| `compress` | `False` | Enable or disable compression of transmitted data.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `compress` | `False` | 启用或禁用传输数据的压缩。 |'
- en: '| `timeout` | `None` | A timeout in seconds before giving up on the connection.
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `timeout` | `None` | 在放弃连接之前等待的秒数。 |'
- en: Inspecting our connection
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查我们的连接
- en: Once connected to a server, our code might need to get some information about
    the connection. This can be done by accessing the `Transport` object associated
    with the client. This object represents the connection and contains a number of
    methods and attributes to set or retrieve information about it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到服务器后，我们的代码可能需要获取有关连接的一些信息。这可以通过访问与客户端关联的 `Transport` 对象来完成。此对象表示连接，并包含设置或检索有关连接信息的方法和属性。
- en: 'We can retrieve the `Transport` object using the `get_transport()` method of
    the `SSHClient`, like so:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `SSHClient` 的 `get_transport()` 方法检索 `Transport` 对象，如下所示：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we can inspect our connection in various ways, for example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以各种方式检查我们的连接，例如：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: These properties can be particularly useful in situations where the user is
    connecting using default values detected from the environment.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性在用户使用从环境中检测到的默认值进行连接的情况下尤其有用。
- en: Using SFTP
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SFTP
- en: 'Now that we''ve established an SSH connection to a server, we can begin using
    SFTP. To do this, we''ll create an instance of `SFTPClient` using the `open_sftp()`
    method, like so:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立到服务器的 SSH 连接，我们可以开始使用 SFTP。为此，我们将使用 `open_sftp()` 方法创建 `SFTPClient`
    实例，如下所示：
- en: '[PRE67]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use the methods of the `SFTPClient` object to execute various file management
    commands on the remote server over SFTP. Some of the more useful of these are
    shown in the following table:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `SFTPClient` 对象的方法在远程服务器上通过 SFTP 执行各种文件管理命令。以下表格中展示了其中一些更有用的命令：
- en: '| Method | Arguments | Description |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 描述 |'
- en: '| `chdir()` | `path` | Set the current working directory. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `chdir()` | `path` | 设置当前工作目录。 |'
- en: '| `getcwd()` | None | Return the path of the current working directory. Note
    that it returns `None` if the directory was not set with `chdir()`. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `getcwd()` | None | 返回当前工作目录的路径。注意，如果目录未使用 `chdir()` 设置，则返回 `None`。 |'
- en: '| `listdir()` | `path` (optional) | Return a list of the files and directories
    in `path`, or in the current working directory if not specified. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `listdir()` | `path`（可选）| 返回`path`路径上的文件和目录列表，如果没有指定，则在当前工作目录返回。|'
- en: '| `mkdir()` | `path` | Create a directory on the server at `path`. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `mkdir()` | `path` | 在服务器上的`path`路径创建一个目录。|'
- en: '| `rmdir()` | `path` | Remove the directory from the server described by `path`.
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `rmdir()` | `path` | 从服务器上描述的`path`路径删除目录。|'
- en: '| `get()` | `remotepath`, `localpath` | Download the file on the server at
    `remotepath` and save it to the client at `localpath`. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | `remotepath`, `localpath` | 从服务器上的`remotepath`下载文件并将其保存到客户端的`localpath`。|'
- en: '| `put()` | `localpath`, `remotepath` | Upload the file on the client at `localpath`
    and save it on the server at `remotepath`. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `put()` | `localpath`, `remotepath` | 将客户端上的文件从`localpath`上传并保存到服务器上的`remotepath`。|'
- en: '| `stat()` | `path` | Return an object containing information about the file
    or directory at `path`. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `stat()` | `path` | 返回一个包含`path`路径上的文件或目录信息的对象。|'
- en: '| `remove()` | `path` | Remove the file from the server described by `path`.
    Does not work if `path` is a directory (use `rmdir()` instead). |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `remove()` | `path` | 从服务器上描述的`path`路径删除文件。如果`path`是目录，则不起作用（请使用`rmdir()`代替）。|'
- en: '| `close()` | None | Close the SFTP connection. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `close()` | None | 关闭SFTP连接。|'
- en: 'For example, suppose we need to create a folder called `Bananas` in the `Fruit`
    directory on our server, and upload a file called `cavendish.ban` from `/home/alanm/bananas/`
    to the new directory on the server. That exchange would look like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要在我们的服务器上的`Fruit`目录中创建一个名为`Bananas`的文件夹，并将名为`cavendish.ban`的文件从`/home/alanm/bananas/`上传到服务器上的新目录。这个交换过程看起来是这样的：
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that, in the destination path of the `put()` call, we did not include
    the `Fruit` directory. That's because it's our current working directory, so our
    remote paths are understood to be relative to it.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`put()`调用的目标路径中，我们没有包含`Fruit`目录。这是因为它是我们的当前工作目录，所以我们的远程路径被认为是相对于它的。
- en: Let's see if we can use our understanding of `paramiko` and SFTP to implement
    an SFTP upload in ABQ Data Entry.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否利用我们对`paramiko`和SFTP的理解来实现ABQ数据录入中的SFTP上传。
- en: Implementing an SFTP model
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现SFTP模型
- en: As we did with our REST upload, we'll begin by encapsulating our interactions
    with the SFTP server in a model class.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在REST上传中所做的那样，我们将首先在模型类中封装与SFTP服务器的交互。
- en: 'Open `models.py` and we''ll begin by importing `paramiko`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`models.py`，我们首先导入`paramiko`：
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s begin our model class:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的模型类：
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Our class initializer will take a hostname for the server and optionally a port
    number. SSH typically runs on port `22`, though it's not uncommon for system administrators
    to run it on another port for security reasons, so it's good to provide this as
    an option.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的初始化器将接受一个服务器的主机名，以及可选的端口号。SSH通常在端口`22`上运行，尽管出于安全原因，系统管理员在另一个端口上运行它的情况并不少见，所以提供这个选项是好的。
- en: 'Next, we''ll continue our initializer by configuring our `SSHClient` object:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续初始化器，通过配置我们的`SSHClient`对象：
- en: '[PRE71]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After creating our client instance and saving it to an instance property, we're
    configuring it to automatically add new host keys. Finally, we load in the known
    hosts from the default system location.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建客户端实例并将其保存到实例属性后，我们将其配置为自动添加新的宿主密钥。最后，我们从默认的系统位置加载已知的宿主。
- en: In a secure production environment, you may want to leave this policy at the
    default `RestrictPolicy` setting and manage the known hosts list outside of your
    application. Note, however, that the `AutoAddPolicy` only impacts connections
    to *new hosts*; if `SSHClient` receives an invalid fingerprint when connecting
    to a known host, it will still raise an exception.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个安全的生成环境中，你可能希望将此策略保留为默认的`RestrictPolicy`设置，并在应用程序外部管理已知的宿主列表。请注意，`AutoAddPolicy`仅影响对*新宿主*的连接；如果`SSHClient`在连接到已知宿主时收到无效的指纹，它仍然会引发异常。
- en: 'That takes care of our initializer, so let''s create an `authenticate()` method
    to establish a connection to the server:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理好了初始化器，接下来我们创建一个`authenticate()`方法来建立与服务器的连接：
- en: '[PRE72]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This method will take a `username` and `password` and use them to establish
    a connection using the `connect()` method. If authentication fails, `paramiko`
    will raise an `AuthenticationException`. We could simply allow this to pass back
    to the calling code, but as we did with our REST model, we're cleaning it up a
    little so that our `Application` object can display a more user-friendly message.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将接受一个`username`和`password`，并使用它们通过`connect()`方法建立连接。如果认证失败，`paramiko`将引发一个`AuthenticationException`。我们可以简单地允许这个异常传递回调用代码，但就像我们在REST模型中所做的那样，我们对其进行了一些清理，以便我们的`Application`对象可以显示一个更友好的消息。
- en: 'As with our `RESTModel`, we''re going to create three more methods: one to
    upload a file, one to download a file, and one to check if a file exists on the
    server. Because all of these require that we''re connected and authenticated,
    though, it would be handy to have another method that raises an exception if we''re
    not.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`RESTModel`一样，我们将创建另外三个方法：一个用于上传文件，一个用于下载文件，还有一个用于检查服务器上是否存在文件。尽管所有这些都需要我们连接并验证身份，但如果我们没有连接，有一个引发异常的方法会很有用。
- en: 'We''ll create a private method for this called `_check_auth()`, like so:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个操作创建一个名为`_check_auth()`的私有方法，如下所示：
- en: '[PRE73]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you saw in the previous section, our connection's active and authenticated
    statuses can be retrieved from its `Transport` object; so, this method retrieves
    the transport, then raises an exception if it's not both active and authenticated.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中看到的，我们可以从其`Transport`对象中检索连接的活跃和认证状态；因此，这个方法检索传输对象，然后如果它既不活跃也不认证，就引发一个异常。
- en: 'To see how we''ll use this, let''s create our `get_file()` method first:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们将如何使用它，让我们首先创建我们的`get_file()`方法：
- en: '[PRE74]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This method will take a remote path and a local path and copy the file down
    from the remote path to the local one. Note that we start with a call to `_check_auth()`
    to ensure that we're properly connected to the server. Then we create our SFTP
    client and run the `get()` method. That's all there is to it!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将接受一个远程路径和一个本地路径，并将文件从远程路径复制到本地路径。注意，我们首先调用`_check_auth()`以确保我们已经正确连接到服务器。然后我们创建我们的SFTP客户端并运行`get()`方法。这就是全部内容！
- en: When creating a command or function that copies or moves data, it's a long-standing
    convention to put your arguments in the order `(SOURCE, DESTINATION)`. Mixing
    this up may rightly earn you the extreme displeasure of your users or fellow developers.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个复制或移动数据的命令或函数时，一个长期以来的惯例是将你的参数按照`(SOURCE, DESTINATION)`的顺序排列。搞混这一点可能会让你用户或同行开发者极度不悦。
- en: Uploading files
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传文件
- en: Creating an upload method will be slightly more complex. Unlike the REST client,
    which was working with a single endpoint, the SFTP server has a filesystem structure
    and we have the possibility of uploading to a subdirectory on the server. If we
    try to upload a file to a directory that doesn't exist, `paramiko` will raise
    an exception.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个上传方法将稍微复杂一些。与只处理单个端点的REST客户端不同，SFTP服务器有一个文件系统结构，我们有可能上传到服务器上的子目录。如果我们尝试将文件上传到不存在的目录，`paramiko`将引发一个异常。
- en: So, before we upload a file, we'll need to connect to the server and make sure
    all the directories in the destination path are there first. If any of them are
    not, we'll need to create that directory.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们上传文件之前，我们需要连接到服务器并确保目标路径中的所有目录都存在。如果其中任何一个不存在，我们需要创建那个目录。
- en: 'We''ll begin our method as before by checking the connection and creating an
    SFTPClient instance:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像以前一样开始我们的方法，检查连接并创建一个SFTPClient实例：
- en: '[PRE75]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, we''ll check the directories:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查目录：
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Our `remote_path` will likely be a string, so the first thing we do is convert
    it to a `pathlib.Path` object for easier manipulation. `remote_path.parent.parts`
    gives us a list of all the directories that contain the file, in order from the
    topmost to the bottom-most. For example, if the `remote_path` value was `Food/Fruit/Bananas/cavendish.ban`,
    this attribute would give us the list `['Food', 'Fruit', 'Bananas']`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`remote_path`可能是一个字符串，所以我们首先将其转换为`pathlib.Path`对象，以便更容易地操作。`remote_path.parent.parts`给我们一个包含文件的目录列表，从最高层到最低层。例如，如果`remote_path`的值是`Food/Fruit/Bananas/cavendish.ban`，这个属性会给我们列表`['Food',
    'Fruit', 'Bananas']`。
- en: Once we have that list, we iterate through it, checking to see if the directory
    is in the contents of the current working directory. If not, we create it. Once
    we know that the directory exists, we change the current working directory to
    it and repeat with the next directory in the list.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个列表，我们就遍历它，检查目录是否在当前工作目录的内容中。如果不是，我们就创建它。一旦我们知道目录存在，我们就将当前工作目录更改为它，并重复对列表中的下一个目录进行操作。
- en: 'Once the directory structure is established, we can upload the actual file:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了目录结构，我们就可以上传实际的文件：
- en: '[PRE77]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `put()` method takes our local path to the file and the remote path where
    we want to copy it. Note, however, that we're only using the `name` portion of
    the remote path; that's because the `for` loop that iterated over our directories
    has left our current working directory at the proper parent directory where the
    file needs to be put. Thus, we should just pass the file's name as a destination.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`put()` 方法接收我们本地文件的路径以及我们想要复制到的远程路径。注意，然而，我们只使用远程路径的 `name` 部分；这是因为遍历我们的目录的
    `for` 循环已经将当前工作目录留在了文件需要放置的正确父目录中。因此，我们只需将文件名作为目标传递即可。'
- en: Checking a file's existence
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查文件是否存在
- en: The last method we need is one that checks for a file's existence on the server.
    For this, we'll rely on the `stat()` method. The `stat()` method of `SFTPClient`
    can be used to fetch metadata about a file on the server, such as size and modification
    time. We don't need that information, but one useful side effect of `stat()` is
    that it raises a `FileNotFoundError` if passed a path that doesn't exist.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个方法是检查服务器上文件的存在。为此，我们将依赖于 `stat()` 方法。`SFTPClient` 的 `stat()` 方法可以用来获取服务器上文件的相关元数据，如大小和修改时间。我们不需要这些信息，但
    `stat()` 的一个有用的副作用是，如果传递了一个不存在的路径，它会引发 `FileNotFoundError`。
- en: 'We can use that in our method, as shown here:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的方法中使用它，如下所示：
- en: '[PRE78]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As with the other methods, this one begins by checking for authentication, then
    creating our `SFTPClient` object. Then, it attempts to `stat()` the file at `remote_path`.
    If a `FileNotFoundError` is raised, we return `False`. Otherwise, we return `True`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他方法一样，这个方法首先检查身份验证，然后创建我们的 `SFTPClient` 对象。然后，它尝试对 `remote_path` 上的文件进行 `stat()`。如果引发
    `FileNotFoundError`，我们返回 `False`。否则，我们返回 `True`。
- en: 'This completes our `SFTPModel`, at least for the operation our application
    needs to perform; but before we leave `models.py`, jump up to the `SettingsModel`
    class and let''s add a few SFTP-related settings:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的 `SFTPModel`，至少对于我们的应用程序需要执行的操作来说是这样；但在离开 `models.py` 之前，跳转到 `SettingsModel`
    类，让我们添加一些与 SFTP 相关的设置：
- en: '[PRE79]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These settings define the host and port of the server, as well as the subdirectory
    path on the server where our files will need to be uploaded. With these added,
    we're ready to work on the GUI side.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置定义了服务器的地址和端口，以及我们的文件需要上传到服务器上的子目录路径。添加这些设置后，我们就可以在 GUI 界面方面开始工作了。
- en: Using SFTPModel in our application
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用 SFTPModel
- en: 'The SFTP upload process we need to implement is identical to the REST upload
    process: we need to authenticate to the server, then check to see if the file
    already exists. If it does, we ask the user if they want to overwrite it. If not,
    we offer to download the file for their inspection.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的 SFTP 上传过程与 REST 上传过程相同：我们需要对服务器进行身份验证，然后检查文件是否已存在。如果存在，我们询问用户是否要覆盖它。如果不，我们提供下载文件供他们检查。
- en: 'Let''s begin this method in `Application`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Application` 中开始这个方法：
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Just as before, we begin by attempting to create a CSV file from the day's data;
    if we get an exception, we'll display it and exit.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们首先尝试从当天的数据创建 CSV 文件；如果出现异常，我们将显示它并退出。
- en: 'Now, we''ll authenticate:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行身份验证：
- en: '[PRE81]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Again, just like before, we request a username and password from the user using
    our `LoginDialog`, simply adjusting the label text for SFTP. Then we create our
    `SFTPModel` instance using the host and port values from the `settings` object
    and attempt to authenticate. Any authentication errors will be displayed in a
    message box.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，就像之前一样，我们使用我们的 `LoginDialog` 从用户那里请求用户名和密码，只是简单地调整了 SFTP 的标签文本。然后，我们使用 `settings`
    对象中的主机和端口值创建我们的 `SFTPModel` 实例，并尝试进行身份验证。任何身份验证错误都会在消息框中显示。
- en: 'Next, we need to check the destination path to see if it exists:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查目标路径是否已存在：
- en: '[PRE82]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This time, we need to construct a complete destination path by combining the
    `abq_sftp_path` value from `settings` with the generated CSV filename. Notice
    that we're building the path using string formatting rather than with a `Path`
    object. That's because `Path` will join path components using the path separator
    character (forward-slash or backslash) used on our *local* system. The path we're
    creating needs to be compatible with the *remote* filesystem. Fortunately, `paramiko`
    will use forward-slashes (Unix-style path separators) regardless of whether the
    remote server uses Windows or a Unix-like system. For that reason, we're explicitly
    formatting our paths using forward-slashes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要通过将 `settings` 中的 `abq_sftp_path` 值与生成的 CSV 文件名组合来构造完整的目标路径。请注意，我们正在使用字符串格式化而不是使用
    `Path` 对象来构建路径。这是因为 `Path` 将使用我们本地系统上的路径分隔符字符（正斜杠或反斜杠）来连接路径组件。我们创建的路径需要与远程文件系统兼容。幸运的是，`paramiko`
    不论远程服务器使用的是 Windows 还是类 Unix 系统，都会使用正斜杠（Unix 风格的路径分隔符）。因此，我们明确使用正斜杠来格式化我们的路径。
- en: 'If the file exists, we need to ask the user what to do next:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已存在，我们需要询问用户下一步要做什么：
- en: '[PRE83]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Once again, this is identical to our REST-based code, except that we need to
    remember we're dealing with paths, not just filenames. Thus, we've used `destination_path`
    where we previously used `csvfile.name`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们的基于 REST 的代码相同，只是我们需要记住我们处理的是路径，而不仅仅是文件名。因此，我们在之前使用 `csvfile.name`
    的地方使用了 `destination_path`。
- en: 'If the method has not yet returned at this point, we can go ahead and attempt
    to upload our file:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到这一点方法还没有返回，我们可以尝试上传我们的文件：
- en: '[PRE84]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: That finishes up our SFTP upload callback.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的 SFTP 上传回调。
- en: Some readers might wonder why our model checks its authenticated status for
    each call, when our callback method only runs its operations after it has successfully
    authenticated. First, this is a defensive programming move. We don't know how
    our model class may be used in the future, and the model can't always count on
    well-behaved views and controllers ensuring authentication before other operations.
    Secondly, it's because, unlike HTTP, SSH is a **stateful** protocol. That means
    there is an active session created when we connect which must be maintained for
    any operations to be done. If this session is interrupted (say, by a temporary
    network outage, or a laptop user switching networks) between authentication and
    subsequent operations, those operations would fail and we'd need to start over
    again. Thus, when working with stateful protocols, it's a good idea to check connection
    and authentication status before individual operations.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想知道，为什么我们的模型在每次调用时都会检查其认证状态，尽管我们的回调方法只在成功认证后执行操作。首先，这是一个防御性编程的举动。我们不知道我们的模型类将来可能如何被使用，模型也不能总是依赖表现良好的视图和控制层在执行其他操作之前确保认证。其次，这是因为与
    HTTP 不同，SSH 是一个**有状态的**协议。这意味着当我们连接时，会创建一个活动会话，必须保持该会话以执行任何操作。如果在认证和后续操作之间会话被中断（例如，由于临时网络中断或笔记本电脑用户切换网络），那些操作将失败，我们需要重新开始。因此，当与有状态的协议一起工作时，在执行单个操作之前检查连接和认证状态是一个好主意。
- en: Finishing up
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成操作
- en: 'All that remains to do now is to add the new feature to our menu. Back in `Application.__init__()`,
    add the callback to our `event_callbacks` dictionary:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是将新功能添加到我们的菜单中。回到 `Application.__init__()`，将回调添加到我们的 `event_callbacks`
    字典中：
- en: '[PRE85]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, head over to `mainmenu.py` and add a new private method to `GenericMainMenu`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `mainmenu.py` 文件，并在 `GenericMainMenu` 类中添加一个新的私有方法：
- en: '[PRE86]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, in each menu subclass, add the entry to the `Tools` menu, like so:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个菜单子类中，将条目添加到 `Tools` 菜单中，如下所示：
- en: '[PRE87]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Our new upload feature is now complete! Make sure SSH is running on your system,
    launch ABQ Data Entry, make sure there''s at least one record saved for the day,
    and run the upload from the **Tools** menu. You should see a success dialog like
    this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新上传功能现在已完成！确保您的系统上正在运行 SSH，启动 ABQ 数据录入，确保至少保存了一条当天的记录，然后从 **工具** 菜单中运行上传。你应该会看到一个成功对话框，如下所示：
- en: '![Figure 13.6: Success dialog for SFTP upload](img/B17578_13_06.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6：SFTP 上传成功对话框](img/B17578_13_06.png)'
- en: 'Figure 13.6: Success dialog for SFTP upload'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：SFTP 上传成功对话框
- en: 'Run the feature a second time, and you should get your warning dialog, like
    this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行该功能，你应该会看到警告对话框，如下所示：
- en: '![Figure 13.7: Overwrite dialog for SFTP upload](img/B17578_13_07.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7：SFTP 上传覆盖对话框](img/B17578_13_07.png)'
- en: 'Figure 13.7: Overwrite dialog for SFTP upload'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：SFTP 上传覆盖对话框
- en: Follow through and make sure you can download the file. Excellent work!
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 继续努力，确保你能下载该文件。做得很好！
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reached out to the cloud using the network protocols HTTP
    and SSH. You learned how to download data over HTTP using `urllib`, and how to
    parse XML data structures using the `ElementTree` module. You also discovered
    an alternative way to interact with HTTP using the `requests` library and learned
    the basics of interacting with a REST API. You learned to work with HTTP interactions
    that required authentications and session cookies, and uploaded a file. Finally,
    you learned how to transfer and manage remote files over SSH with SFTP services
    using the `paramiko` library.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用网络协议HTTP和SSH连接到了云端。你学习了如何使用`urllib`通过HTTP下载数据，以及如何使用`ElementTree`模块解析XML数据结构。你还发现了一种使用`requests`库与HTTP交互的替代方法，并学习了与REST
    API交互的基础知识。你学习了如何处理需要身份验证和会话cookie的HTTP交互，并上传了一个文件。最后，你学习了如何使用`paramiko`库通过SFTP服务在SSH上传输和管理远程文件。
- en: In the next chapter, we'll stop long-running processes from freezing up our
    application and improve our application's performance by learning about asynchronous
    programming. We'll learn to manipulate the Tkinter event loop for better responsiveness
    as well as advanced asynchronous programming using Python's `threading` library.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过异步编程来阻止长时间运行的过程冻结我们的应用程序，并提高应用程序的性能。我们将学习如何操作Tkinter事件循环以获得更好的响应性，以及使用Python的`threading`库进行高级异步编程。
