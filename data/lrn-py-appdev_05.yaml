- en: Chapter 5. Unit Testing and Refactoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。单元测试和重构
- en: Here is a quick recap of what you have learned so far. You developed a command-line
    application using the OOP approach, and then learned techniques to make your code
    robust by handling exceptions. You modularized the code, prepared a distribution,
    and released it to a broader audience. Finally, you learned about coding standards
    and documentation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对你迄今为止所学内容的快速回顾。你使用面向对象的方法开发了一个命令行应用程序，然后学习了通过处理异常来使代码健壮的技术。你将代码模块化，准备分发，并将其发布给更广泛的受众。最后，你学习了编码标准和文档。
- en: 'So far, we have not paid much attention to testing the application. We relied
    solely on manual testing, where some features were tested by playing the game.
    The task of manual testing becomes increasingly difficult with the complexity
    of the application. Soon you will be overwhelmed, and the bugs will start to creep
    in. While manual testing may not be avoided completely, we need an automated way
    to make sure the features work as expected. In this chapter, you will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有过多关注应用程序的测试。我们完全依赖手动测试，其中一些功能是通过玩游戏来测试的。随着应用程序的复杂性增加，手动测试的任务变得越来越困难。很快你就会感到不堪重负，错误就会开始出现。虽然可能无法完全避免手动测试，但我们需要一个自动化的方式来确保功能按预期工作。在本章中，你将执行以下操作：
- en: Learn about unittest, the unit testing framework in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python中的单元测试框架unittest
- en: Write some unit tests for our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序编写一些单元测试
- en: See how to use the mock library in unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何在单元测试中使用模拟库
- en: Learn how to measure the effectiveness of unit tests (code coverage)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何衡量单元测试的有效性（代码覆盖率）
- en: Understand what is code refactoring, why, when, and how to do it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码重构是什么，为什么，何时以及如何进行
- en: Come back to the unit testing discussion after doing some code refactoring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行一些代码重构后，回到单元测试的讨论
- en: This is how the chapter is organized
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是本章的组织方式
- en: The chapter starts with a game scenario, where a bug slips through to production
    and stays hidden until a user discovers it. This scenario underlines the need
    for automated testing, and then leads into a discussion on unit testing framework
    in Python. You will be introduced to the unittest framework and the mock library
    in Python. The chapter will demonstrate the use of these libraries by writing
    a few unit tests for our project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从一个游戏场景开始，其中有一个错误通过了生产环境并一直隐藏，直到用户发现它。这个场景强调了自动化测试的需要，然后引出了对Python中单元测试框架的讨论。你将介绍Python中的unittest框架和mock库。本章将通过为我们的项目编写一些单元测试来演示这些库的使用。
- en: Moving ahead, it shows an example where it is difficult to write a unit test
    without refactoring the code first (see *Refactoring preamble*). This is where
    we take a detour, learn the basics of refactoring, refactor the code, and then
    develop the last unit test.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它展示了在没有先重构代码的情况下难以编写单元测试的例子（参见*重构前言*）。这就是我们绕道而行，学习重构的基本知识，重构代码，然后开发最后一个单元测试的地方。
- en: Important housekeeping notes
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的注意事项
- en: These notes will be useful in case you haven't read the earlier chapters. Otherwise,
    just move on to the next heading. Like every other chapter, this one has its own
    set of Python source files. The source code can be downloaded from the *Packt
    Publishing* website. Just follow the instructions mentioned in this book's *Preface*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读前面的章节，这些笔记将很有用。否则，请继续阅读下一部分。像其他每个章节一样，这一章也有它自己的Python源代码文件。源代码可以从*Packt
    Publishing*网站下载。只需遵循本书*前言*中提到的说明。
- en: This is the last chapter that depends on the code developed in the earlier chapters.
    Starting with [Chapter 6](ch06.html "Chapter 6. Design Patterns"), *Design Patterns*,
    we will have independent, simplified examples to demonstrate various concepts.
    That said, everything will be tied back to the same high fantasy theme.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章，它依赖于前面章节中开发的代码。从[第6章](ch06.html "第6章。设计模式")*设计模式*开始，我们将有独立、简化的例子来展示各种概念。话虽如此，所有这些都会与同一个高幻想主题联系起来。
- en: Why test?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么进行测试？
- en: Did you play the game developed so far? If not, just try playing it once. During
    the combat with the enemy, the following can be observed. For each attack, either
    Sir Foo or the enemy sustains injuries. This is indicated by the reduced hit points.
    For example, in the sample game output shown next, `Sir Foo` gets hit in the first
    attack turn, whereas the enemy is injured in the next two attack turns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你玩过到目前为止开发的游戏吗？如果没有，就试玩一次。在与敌人的战斗中，可以观察到以下情况。对于每次攻击，Sir Foo 或敌人都会受到伤害。这通过减少生命值来表示。例如，在下面的示例游戏输出中，Sir
    Foo 在第一次攻击回合中被击中，而敌人则在接下来的两个攻击回合中受伤。
- en: '![Why test?](img/B05034_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要测试？](img/B05034_05_01.jpg)'
- en: A new feature was requested
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求了一个新功能
- en: '| *A user requested an enhancement to the combat scenario:**"During combat,
    the program asks whether you want to continue attacking the enemy. In each attack
    move, one of the warriors, the player or the enemy, gets injured. Can you make
    it more interesting? What if both the warriors escape unhurt sometimes?"* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| *用户请求增强战斗场景："在战斗中，程序会询问你是否想继续攻击敌人。在每次攻击移动中，战士、玩家或敌人中的一位会受到伤害。你能让它更有趣吗？有时两位战士都能毫发无损地逃脱呢？"*
    |'
- en: '![A new feature was requested](img/B05034_05_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![请求了一个新功能](img/B05034_05_02.jpg)'
- en: '| *It will benefit you as well Sir Foo! We will go ahead and implement this
    minor enhancement. Despite Sir Foo''s stiff opposition, you rushed to implement
    this new feature.* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *这对Sir Foo也有好处！我们将继续实施这个小的增强功能。尽管Sir Foo强烈反对，你还是匆忙实现了这个新功能。* |'
- en: You implemented this feature
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你实现了这个功能
- en: Recall that the `gameutils.weighted_random_selection` function randomly selects
    an element from `weighted_list`. The list is populated such that, for approximately
    30% of the time, the unique identifier of `obj1` gets selected, and for the rest
    of the time, the unique identifier representing `obj2` gets chosen. Put another
    way, the chance of Sir Foo (`obj1`) getting injured is approximately 30%, and
    that of the enemy (`obj2`) is nearly 70%.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`gameutils.weighted_random_selection` 函数会从 `weighted_list` 中随机选择一个元素。列表被填充得使得大约30%的时间，`obj1`
    的唯一标识符被选中，而在其余时间，代表 `obj2` 的唯一标识符被选择。换句话说，Sir Foo (`obj1`) 受伤的概率大约是30%，而敌人的 (`obj2`)
    概率接近70%。
- en: 'To add the likelihood that no one gets hurt, you changed the composition of
    `weighted_list` by adding a new element, `None`. The new chances of injury to
    the warriors are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加没有人受伤的可能性，你通过添加一个新元素 `None` 来更改 `weighted_list` 的组成。战士受伤的新概率如下：
- en: The chances of the enemy (`obj2`) getting hurt are ~ 60%
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人 (`obj2`) 受伤的概率约为60%
- en: The chances of Sir Foo (`obj1`) getting hurt are ~30%
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sir Foo (`obj1`) 受伤的概率约为30%
- en: Both escaping unhurt (`None`) are ~ 10%
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都毫发无损（`None`）的概率约为10%
- en: 'The following is the `weighted_random_selection` function before and after
    the aforementioned change:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述更改前后的 `weighted_random_selection` 函数：
- en: '![You implemented this feature](img/B05034_05_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![你实现了这个功能](img/B05034_05_03.jpg)'
- en: That was easy, wasn't it? You played the game once to make sure nothing is broken.
    It looked all fine. Without any delay, you released a new version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？你玩了一次游戏以确保没有出错。看起来一切正常。没有延迟，你发布了新版本。
- en: But something wasn't right...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但有些不对劲...
- en: However, soon after release, user complaints started pouring in. This was unexpected.
    Your commit introduced a new bug!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，发布后不久，用户投诉开始涌入。这是意料之外的。你的提交引入了一个新的错误！
- en: '![But something wasn''t right...](img/B05034_05_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![但有些不对劲...](img/B05034_05_04.jpg)'
- en: '| *Calm down Sir Foo! You are still in war mode! Relax and take a deep breath.
    We will address this issue soon.* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| *冷静下来，Sir Foo！你还在战争模式中！放松并深呼吸。我们很快就会解决这个问题。* |'
- en: 'So what went wrong? There is no problem with the function you wrote. It is
    behaving as intended. However, you forgot to make some changes to the code that
    calls `weighted_random_selection`. As a result, the following uncaught exception
    is seen:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么出了什么问题呢？你写的函数没有问题。它正按预期运行。然而，你忘记对调用 `weighted_random_selection` 的代码做一些更改。结果，出现了以下未捕获的异常：
- en: '![But something wasn''t right...](img/B05034_05_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![但有些不对劲...](img/B05034_05_05.jpg)'
- en: 'The error traceback points to the `AbstractGameUnit.attack` method. This method
    calls the `weighted_random_selection` function to randomly select an injured unit.
    The problem occurs when `injured_unit` is `None`. The trouble-causing line of
    code is shown in the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 错误跟踪信息指向 `AbstractGameUnit.attack` 方法。该方法调用 `weighted_random_selection` 函数随机选择一个受伤的单位。当
    `injured_unit` 为 `None` 时，问题就出现了。导致问题的代码行在下面的代码片段中显示：
- en: '![But something wasn''t right...](img/B05034_05_46.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![但似乎有些不对劲...](img/B05034_05_46.jpg)'
- en: It required thorough testing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这需要彻底的测试
- en: You had done basic testing by running the game once. But then why didn't you
    notice this problem? The chances that the function returns `None` are slim. For
    example, for every 10 calls to the function `weighted_random_selection`, the value
    `None` would be on average returned only once. In this case, the testing you did
    was not enough to reproduce the problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过运行游戏一次进行了基本的测试。但为什么你没有注意到这个问题呢？函数返回 `None` 的可能性很小。例如，对于 `weighted_random_selection`
    函数的每次调用，平均只有一次会返回值 `None`。在这种情况下，你所进行的测试不足以重现问题。
- en: This is just one of the scenarios where thorough testing is required. At the
    same time, it is prone to human error because of the random nature of the output.
    If you had some automated means to test this functionality, the bug could have
    been easily avoided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是需要彻底测试的场景之一。同时，由于输出的随机性，它也容易受到人为错误的影响。如果你有一些自动化的方式来测试这个功能，那么这个错误就可以轻松避免。
- en: So let's learn how to create automated tests in Python using the unittest framework.
    After you know how to write a unit test, we will come back and write a unit test
    for the `weighted_random_selection` function that was discussed here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们学习如何使用 unittest 框架在 Python 中创建自动化测试。在你学会编写单元测试之后，我们将回来编写一个针对这里讨论的 `weighted_random_selection`
    函数的单元测试。
- en: Unit testing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In unit testing, you tinker with a code fragment within the application. The
    main task is to verify that this piece of code continues to work as expected throughout
    the life of the application. This is accomplished by writing a test for that functionality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你会在应用程序中调整一小段代码。主要任务是验证这段代码在整个应用程序的生命周期中是否继续按预期工作。这是通过编写针对该功能的测试来实现的。
- en: A unit test can be better explained with an example. Consider a trivial function
    that returns the sum of two numbers. In a unit test, you invoke this function
    by passing two numbers as arguments, and then verify the value returned by the
    function is indeed the sum of the given numbers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以通过一个例子更好地解释。考虑一个简单的函数，它返回两个数字的和。在单元测试中，你通过传递两个数字作为参数来调用这个函数，然后验证函数返回的值确实是给定数字的和。
- en: There are many frameworks available for writing unit tests. The examples in
    this chapter will be based on the built-in unit testing framework called unittest.
    See the heading *Other unit testing tools*, which gives a very short overview
    of alternative unit testing tools and frameworks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多框架可用于编写单元测试。本章中的示例将基于内置的单元测试框架，称为 unittest。请参阅标题 *其他单元测试工具*，它提供了一个关于替代单元测试工具和框架的简要概述。
- en: Python unittest framework
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python unittest 框架
- en: The `unittest` module provides the functionality to automate tests. Before we
    implement any tests for our application, let's first start with the terminology.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块提供了自动化测试的功能。在我们为应用程序实现任何测试之前，让我们首先从术语开始。'
- en: Basic terminology
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本术语
- en: '**Test case**: When you write a unit test, it is referred to as a test case.
    `TestCase` is the superclass for creating different test cases.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：当你编写单元测试时，它被称为测试用例。`TestCase` 是创建不同测试用例的基类。'
- en: '**Test suite**: When you group together various test cases, it becomes a test
    suite. A test suite may also represent a collection of other test suites. `unittest.TestSuite`
    provides a superclass for creating a suite. The `TestSuite` does not define any
    unit tests, but it just accumulates the tests or other test suites. This is a
    major difference between `TestSuite` and `TestCase`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：当你将各种测试用例组合在一起时，它就变成了一个测试套件。一个测试套件也可能代表其他测试套件的集合。`unittest.TestSuite`
    提供了一个创建套件的基类。`TestSuite` 并没有定义任何单元测试，它只是累积测试或其他测试套件。这是 `TestSuite` 和 `TestCase`
    之间的一个主要区别。'
- en: '**Test fixtures**: These are preparatory methods for the smooth running of
    the unit tests. For example, `TestCase.setUp` is called just before executing
    a test case. It can be used to feed the required data to the test cases. Similarly,
    `TestCase.tearDown` method is called immediately after the test execution. Such
    methods could be used in combination, for instance to start and stop a service
    consumed by a unit test.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试固定装置**：这些是为单元测试顺利运行而做的准备工作。例如，`TestCase.setUp`在执行测试用例之前被调用。它可以用来向测试用例提供所需的数据。同样，`TestCase.tearDown`方法在测试执行后立即被调用。这些方法可以组合使用，例如启动和停止单元测试所消耗的服务。'
- en: '**Test runner**: The runner helps execute a test case or a test suite. It also
    provides a way to represent the results after running the tests. For example,
    the results can be displayed on the command line or in some graphical form. The
    basic implementation is provided by the `unittest.TextTestRunner` class.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：运行器帮助执行测试用例或测试套件。它还提供了一种表示测试结果的方式。例如，结果可以在命令行或某种图形形式中显示。基本实现由`unittest.TextTestRunner`类提供。'
- en: Creating tests with unittest.TestCase
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用unittest.TestCase创建测试
- en: 'To understand the basics of constructing and running the tests, let''s write
    a trivial program. Observe the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解构建和运行测试的基本知识，让我们编写一个简单的程序。观察以下代码：
- en: '![Creating tests with unittest.TestCase](img/B05034_05_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用unittest.TestCase创建测试](img/B05034_05_06.jpg)'
- en: As mentioned earlier, the `setUp` and `tearDown` methods are known as fixtures.
    `MyUnitTests.setUp()` is called before executing each test. This allows the initialization
    of some common variables before the test gets executed. The `MyUnitTests.tearDown()`
    method is called after every test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`setUp`和`tearDown`方法被称为固定装置。`MyUnitTests.setUp()`在执行每个测试之前被调用。这允许在测试执行之前初始化一些公共变量。`MyUnitTests.tearDown()`方法在每次测试之后被调用。
- en: 'When the `unittest.main()` program is invoked, the tests defined in the `MyUnitTests`
    class are run one after the other. This program can also accept a test runner
    as an optional argument (not used in this example). By default, the program loads
    and runs only the methods that have names starting with `test`. In the `MyUnitTests`
    class, the tests defined in the `test_1` and `test_2` methods will be executed
    as shown in the following command-line output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`unittest.main()`程序时，`MyUnitTests`类中定义的测试将依次运行。此程序还可以接受一个测试运行器作为可选参数（在此示例中未使用）。默认情况下，程序仅加载和运行名称以`test`开头的所有方法。在`MyUnitTests`类中，`test_1`和`test_2`方法中定义的测试将按以下命令行输出所示执行：
- en: '![Creating tests with unittest.TestCase](img/B05034_05_07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用unittest.TestCase创建测试](img/B05034_05_07.jpg)'
- en: 'Now that we know how the test cases are executed, let''s review one of the
    methods, which is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了测试用例是如何执行的，让我们回顾一下其中一个方法，如下所示：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `assertEqual` method is a built-in method of the `TestCase` class. It essentially
    checks whether the two input arguments are equal, otherwise an assertion error
    is raised. The test illustrated in the preceding code fragment will pass. Let''s
    review a test that would fail:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEqual`方法是`TestCase`类的一个内置方法。它本质上检查两个输入参数是否相等，如果不相等，则抛出断言错误。前面代码片段中展示的测试将通过。让我们回顾一个将失败的测试：'
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Obviously, `1+1 != 3`, so we would expect the test to fail, as shown in the
    following command-line output. For a failed test, it also prints the letter `F`
    in the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`1+1 != 3`，所以我们预计测试将失败，如下所示命令行输出。对于失败的测试，它还会在输出中打印字母`F`：
- en: '![Creating tests with unittest.TestCase](img/B05034_05_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用unittest.TestCase创建测试](img/B05034_05_08.jpg)'
- en: Similarly, the `unittest.TestCase` class defines a bunch of convenient methods.
    For example, the `assertTrue` and `assertFalse` methods verify a condition. Another
    method, `assertRaises`, is used to check whether a certain exception is raised
    by the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`unittest.TestCase`类定义了一系列方便的方法。例如，`assertTrue`和`assertFalse`方法用于验证一个条件。另一个方法`assertRaises`用于检查代码是否抛出了特定的异常。
- en: Controlling test execution
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制测试执行
- en: 'Is there a way to run only selected test cases? One way is to use Python **decorators**
    for the tests you want to ignore. Let''s add this decorator to both the test cases
    from the previous example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有只运行选定测试用例的方法？一种方法是为要忽略的测试使用Python **装饰器**。让我们将此装饰器添加到上一个示例中的两个测试用例中：
- en: '![Controlling test execution](img/B05034_05_09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![控制测试执行](img/B05034_05_09.jpg)'
- en: 'Essentially, none of the test cases would be run. The output, after running
    the code, indicates that these tests have been skipped. For each skipped test,
    it prints `s` in the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，没有任何测试用例会被运行。代码运行后的输出表明这些测试已被跳过。对于每个跳过的测试，它会在输出中打印`s`：
- en: '![Controlling test execution](img/B05034_05_10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![控制测试执行](img/B05034_05_10.jpg)'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'There are two more decorators not covered here, namely `skipIf` and `skipUnless`.
    These decorators are used for the condition-based skipping of the test. See the
    following documentation page for details: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个没有涵盖的装饰器，即`skipIf`和`skipUnless`。这些装饰器用于基于条件的跳过测试。有关详细信息，请参阅以下文档页面：[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: 'Sometimes, you do expect a few test cases to fail. For example, a test may
    fail due to a difference between a development versus a production environment,
    or due to the presence or absence of expected database content. Such expected
    failures can be tagged with another decorator. We know that `test_2` fails, so
    let''s add the decorator for this test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你确实期望一些测试用例失败。例如，一个测试可能因为开发环境和生产环境之间的差异而失败，或者因为期望的数据库内容的缺失或存在而失败。这种预期的失败可以用另一个装饰器标记。我们知道`test_2`失败了，所以让我们为这个测试添加装饰器：
- en: '![Controlling test execution](img/B05034_05_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![控制测试执行](img/B05034_05_11.jpg)'
- en: 'For each anticipated failure, it prints `x` in the output. At the end, it summarizes
    how many tests were expected to fail:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个预期的失败，它会在输出中打印`x`。最后，它会总结出预期失败的测试数量：
- en: '![Controlling test execution](img/B05034_05_12.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![控制测试执行](img/B05034_05_12.jpg)'
- en: Using unittest.TestSuite
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用unittest.TestSuite
- en: Refer to the `testsuitedemo.py` file in the supporting code bundle for this
    chapter. The module contains two classes, namely `MyUnitTestA` and `MyUnitTestB`.
    Each of these inherit from `unittest.TestCase`, and define some trivial methods
    as unit tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章支持代码包中的`testsuitedemo.py`文件。该模块包含两个类，即`MyUnitTestA`和`MyUnitTestB`。这些类都继承自`unittest.TestCase`，并定义了一些简单的作为单元测试的方法。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy!* we created a separate module for each class. Here, the `testsuitedemo.py`
    module contains two classes. As an exercise, you can put these classes in separate
    modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。模块化、打包、部署！")中，*模块化、打包、部署*，我们为每个类创建了一个独立的模块。在这里，`testsuitedemo.py`模块包含两个类。作为一个练习，你可以将这些类放入单独的模块中。
- en: 'The following code snippets show these classes. For compactness, the code comments
    are omitted here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了这些类。为了简洁，这里省略了代码注释：
- en: '![Using unittest.TestSuite](img/B05034_05_13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用unittest.TestSuite](img/B05034_05_13.jpg)'
- en: 'The `makeSuite` function of the `unittest` module can be used to create an
    instance of `TestSuite`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块的`makeSuite`函数可以用来创建`TestSuite`的实例：'
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding line of code will construct a test suite using all the unit tests
    defined in the `MyUnitTestA` class. Only the method names starting with `test*`
    are added to the test suite. In this example, these methods are `test_a2` and
    `test_a1`. The third method, `not_called_by_default`, will not be automatically
    considered as a unit test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将构建一个测试套件，使用在`MyUnitTestA`类中定义的所有单元测试。只有以`test*`开头的方法名会被添加到测试套件中。在这个例子中，这些方法是`test_a2`和`test_a1`。第三个方法`not_called_by_default`将不会自动被视为单元测试。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Non-test methods (such as `not_called_by_default` in this example), are often
    useful for sharing code between the tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 非测试方法（例如本例中的`not_called_by_default`），通常在测试之间共享代码时很有用。
- en: 'Let''s see how to include such methods in the test suite. The code snippet
    that follows shows a function `suite()` defined in this module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将这些方法包含在测试套件中。下面的代码片段显示了在这个模块中定义的函数`suite()`：
- en: '![Using unittest.TestSuite](img/B05034_05_14.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用unittest.TestSuite](img/B05034_05_14.jpg)'
- en: 'Let''s review the preceding code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码片段：
- en: This function creates two instances of `TestSuite`, namely `suite_a` and `suite_b`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数创建了两个`TestSuite`实例，即`suite_a`和`suite_b`。
- en: The `MyUnitTest.not_called_by_default` method is added as a test case in the
    test suite using the `addTest` method.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`addTest`方法，将`MyUnitTest.not_called_by_default`方法添加到测试套件中作为测试用例。
- en: The function returns a new `TestSuite` object. It takes a Python tuple as an
    argument. In this example, the tuple includes the two instances of `TestSuite`
    created before.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数返回一个新的`TestSuite`对象。它接受一个Python元组作为参数。在这个例子中，元组包括之前创建的两个`TestSuite`实例。
- en: 'The last part of this module is the execution code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块的最后部分是执行代码：
- en: '![Using unittest.TestSuite](img/B05034_05_15.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用 unittest.TestSuite](img/B05034_05_15.jpg)'
- en: 'Running the `testsuitedemo.py` module produces the following output. Observe
    that it has also executed the test defined in `MyUnitTestB.not_called_by_default`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `testsuitedemo.py` 模块会产生以下输出。注意，它还执行了在 `MyUnitTestB.not_called_by_default`
    中定义的测试：
- en: '![Using unittest.TestSuite](img/B05034_05_16.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![使用 unittest.TestSuite](img/B05034_05_16.jpg)'
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Test suites are also very convenient for grouping test cases, depending on their
    runtime. For example, you can group together fast-running tests and slow-running
    tests, and give the test runner script a command-line option to choose which one
    to run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件也非常方便地根据它们的运行时间对测试用例进行分组。例如，您可以一起分组快速运行的测试和慢速运行的测试，并为测试运行脚本提供一个命令行选项来选择运行哪一个。
- en: Writing unit tests for the application
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写应用程序的单元测试
- en: It is time to write some unit tests for the application. We will make a new
    subclass of `unittest.TestCase` to hold all the unit tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为应用程序编写一些单元测试了。我们将创建一个新的 `unittest.TestCase` 子类来存放所有的单元测试。
- en: Setting up a test package
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试包
- en: 'As a first step, let''s create a new package for holding the test cases. Create
    a new directory called `test` at the same level where you have the rest of the
    code. Next, create two new files inside this `test` directory, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建一个新的包来存放测试用例。在您其余代码所在的同一级别创建一个名为 `test` 的新目录。接下来，在这个 `test` 目录内创建两个新文件，如下所示：
- en: '![Setting up a test package](img/B05034_05_47_testdir_structure.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![设置测试包](img/B05034_05_47_testdir_structure.jpg)'
- en: The `test_wargame.py` module is where new unit tests will be created. To recognize
    the directory as a Python package, add an empty `__init__.py` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_wargame.py` 模块是创建新单元测试的地方。为了将目录识别为 Python 包，添加一个空的 `__init__.py` 文件。'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you haven't already, read [Chapter 3](ch03.html "Chapter 3. Modularize, Package,
    Deploy!"), *Modularize, Package, Deploy!* for details on creating a Python package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有阅读，请阅读 [第 3 章](ch03.html "第 3 章。模块化、打包、部署！")，*模块化、打包、部署！* 了解创建 Python
    包的详细信息。
- en: Creating a new class for unit testing
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于单元测试的新类
- en: The `test_wargame.py` file can also be found in the supporting code. It has
    all the code to be discussed next. In the following discussion, it is assumed
    that you will code from scratch to an empty file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_wargame.py` 文件也可以在支持代码中找到。它包含了接下来要讨论的所有代码。在接下来的讨论中，假设您将从空文件从头开始编写代码。'
- en: 'Create a new subclass of `unittest.TestCase`, and call it `TestWarGame` or
    any name you like. The class is shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `unittest.TestCase` 子类，并将其命名为 `TestWarGame` 或您喜欢的任何名称。类定义如下所示：
- en: '![Creating a new class for unit testing](img/B05034_05_17.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于单元测试的新类](img/B05034_05_17.jpg)'
- en: 'We start by making the necessary imports. Recall that the `setUp()` fixture
    is called immediately before running the unit tests. Inside `setUp`, instances
    of the `Knight` and `OrcRider` classes are created, and are then used in the unit
    test we are about to write: `test_injured_unit_selection`. As seen before, the
    call to `unittest.main()` will automatically execute methods whose names start
    with `test`. In this example, it will run `test_injured_unit_selection()`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先进行必要的导入。回想一下，`setUp()` 修复程序在运行单元测试之前立即被调用。在 `setUp` 中，创建了 `Knight` 和 `OrcRider`
    类的实例，然后它们被用于我们即将编写的单元测试 `test_injured_unit_selection` 中：如之前所见，对 `unittest.main()`
    的调用将自动执行以 `test` 开头的方法名。在这个例子中，它将运行 `test_injured_unit_selection()`。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can write the same code without using fixtures as well. Simply create the
    required instances inside the test you are writing. As you will see next, the
    `test_injured_unit_selection()` unit test uses the objects created in `setUp()`.
    Alternatively, you can create those instances locally, inside the test, like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以不使用修复程序编写相同的代码。只需在您编写的测试中创建所需的实例。如您接下来将看到的，`test_injured_unit_selection()`
    单元测试使用了在 `setUp()` 中创建的对象。或者，您可以在测试中本地创建这些实例，如下所示：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First unit test – Injured unit selection
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个单元测试 – 受伤单位选择
- en: Let's go back to the scenario we discussed under the section *Why test?* Recall
    that you changed the behavior of the `weighted_random_selection` function so that
    it can also return `None` (nobody injured). This new feature broke the program,
    and the application terminated because of an uncaught exception.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到在 *为什么测试？* 部分讨论的场景。记得您修改了 `weighted_random_selection` 函数的行为，使其也可以返回 `None`（没有人受伤）。这个新功能破坏了程序，并且由于未捕获的异常，应用程序终止。
- en: 'The test we are about to write will verify the original behavior of this function.
    The original behavior was to select either Sir Foo (the `Knight` instance) or
    the enemy (the `OrcRider` instance) as the injured unit. The unit test we are
    about to write will verify exactly that. Observe the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写的测试将验证这个函数的原始行为。原始行为是选择Sir Foo（`Knight`实例）或敌人（`OrcRider`实例）作为受伤的单位。我们即将编写的单元测试将验证这一点。观察以下代码：
- en: '![First unit test – Injured unit selection](img/B05034_05_18.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![第一次单元测试 – 受伤单位选择](img/B05034_05_18.jpg)'
- en: With this preceding function, the chance of `self.enemy` getting injured is
    approximately 70%, and that of `self.knight` (Sir Foo) is nearly 30%. The top-level
    `for` loop just ensures it is called `100` times to account for the random nature
    of the function return value. `TestCase.assertInstance()` raises an assertion
    error if `injured_unit` is not an instance of `Knight` or `OrcRider`. Let's run
    this test now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个先前的函数，`self.enemy`受伤的概率大约是70%，而`self.knight`（Sir Foo）的概率接近30%。顶层的`for`循环只是确保它被调用`100`次，以考虑到函数返回值的随机性。如果`injured_unit`不是`Knight`或`OrcRider`的实例，`TestCase.assertInstance()`将引发断言错误。现在让我们运行这个测试。
- en: Running the first unit test
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行第一个单元测试
- en: 'In a terminal window, run this test from the top-level `wargame` directory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中，从顶层`wargame`目录运行此测试：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`-m` is a built-in command line option in Python. It allows you to run a library
    module as a script. In this case, it will run the `unittest` module as a script.
    The argument `test.test_wargame` represents the file `test/test_wargame.py`. The
    `unittest` script will run the tests defined in this module.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`是Python的一个内置命令行选项。它允许你将一个库模块作为脚本运行。在这种情况下，它将运行`unittest`模块作为脚本。参数`test.test_wargame`代表文件`test/test_wargame.py`。`unittest`脚本将运行该模块中定义的测试。'
- en: 'If the old behavior of `weighted_random_selection` is left unchanged, the test
    will pass. However, if you implement the new behavior where the function could
    also return `None`, it will fail by raising an `AssertionError`, as shown next:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`weighted_random_selection`的旧行为保持不变，测试将通过。但是，如果你实现了新行为，其中函数也可以返回`None`，它将通过引发`AssertionError`而失败，如下所示：
- en: '![Running the first unit test](img/B05034_05_19.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![运行第一个单元测试](img/B05034_05_19.jpg)'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is no need to run the `for` loop `100` times. Just make sure to call the
    function at least 10 times. As an exercise, update the test to verify further
    details. For example, verify that the function returns the `Knight` instance approximately
    30% of the time, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要运行`for`循环`100`次。只需确保至少调用该函数`10`次。作为一个练习，更新测试以验证更多细节。例如，验证函数大约30%的时间返回`Knight`实例，等等。
- en: Second unit test – Acquiring the hut
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二次单元测试 – 获得小屋
- en: 'Let''s pick another functionality for testing. This time, it is a method from
    the `Hut` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择另一个功能进行测试。这次，它来自`Hut`类的一个方法：
- en: '![Second unit test – Acquiring the hut](img/B05034_05_20.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![第二次单元测试 – 获得小屋](img/B05034_05_20.jpg)'
- en: 'In this method, what do you think we can test? The method serves the following
    purposes: (a) It updates the occupant information, and (b) It sets the `is_acquired`
    flag to `True`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，你认为我们可以测试什么？该方法有以下用途：(a) 更新占用信息，(b) 将`is_acquired`标志设置为`True`。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Redesign exercise**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新设计练习**：'
- en: In this application, we assume everything from the context of the player. For
    example, the `is_acquired` flag of the `Hut` instance is from the point of view
    of the player. If it is set to `True`, it means the hut is acquired by the player
    and not the enemy. This is already prone to bugs. Imagine an `OrcRider` instance
    calling this method! You can add assertions to make sure it accepts only the `Knight`
    instance. As an exercise, remove the dependence on the `is_acquired` flag from
    the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们假设所有内容都是从玩家的上下文出发的。例如，`Hut`实例的`is_acquired`标志是从玩家的角度出发的。如果它被设置为`True`，这意味着小屋被玩家获得，而不是敌人。这已经容易产生错误。想象一下一个`OrcRider`实例调用这个方法！你可以添加断言来确保它只接受`Knight`实例。作为一个练习，从代码中移除对`is_acquired`标志的依赖。
- en: When writing a test, we will ensure that the new occupant is the same object
    as the one passed as an argument to the method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，我们将确保新占用者与作为方法参数传递的对象是相同的。
- en: '![Second unit test – Acquiring the hut](img/B05034_05_21.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![第二次单元测试 – 获得小屋](img/B05034_05_21.jpg)'
- en: '| *Good question Sir Foo. Why write this test if the method is already working
    fine? Keep in mind the scenario we discussed earlier. An intentional change in
    the functionality caused us so much trouble. Why wait for such a bug to show up?**Today,
    this code is behaving as expected. The unit test is meant for tomorrow. Imagine
    multiple developers contributing to this application. As a result, more code would
    get added, and someone may inadvertently introduce code that will break the intended
    functionality of this method. In such a scenario, how do you ensure that the fundamental
    behavior remains unchanged? A unit test will notice such changes.**A future requirement
    might even change the fundamental behavior of the method. This was illustrated
    in the scenario under the heading **Why Test?** When that happens, the unit test
    you wrote would obviously fail. You do expect it to fail now, and that would make
    it imperative to update the test to match the new requirement.**In short, a unit
    test will make sure that accidental changes to the code are captured right away,
    and don''t become your nightmare, such as when someone reports a bug and you learn
    the hard way that it was caused by a silly mistake in the code you wrote a few
    months ago.* |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| *Sir Foo，这是个好问题。为什么还要写这个测试，如果方法已经运行得很好了？记住我们之前讨论的场景。功能上的有意改变给我们带来了很多麻烦。为什么要等到这样的错误出现呢？**今天，这段代码的表现符合预期。单元测试是为了明天准备的。想象一下，多个开发者共同贡献这个应用程序。结果，代码会越来越多，有人可能会无意中引入会破坏此方法预期功能的代码。在这种情况下，你如何确保基本行为保持不变？单元测试会注意到这样的变化。**未来的需求甚至可能会改变方法的基本行为。这在**为什么测试？**标题下的场景中得到了说明。当这种情况发生时，你编写的单元测试显然会失败。你确实期望它失败，这将迫使你更新测试以匹配新的要求。**简而言之，单元测试将确保代码的意外更改立即被捕获，而不会成为你的噩梦，比如当有人报告了一个错误，而你艰难地发现它是由你几个月前写的代码中的一个小错误引起的。**
    |'
- en: 'Let''s write a new method in the same class, `TestWarGame`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一个类`TestWarGame`中编写一个新的方法：
- en: '![Second unit test – Acquiring the hut](img/B05034_05_22.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![第二个单元测试 – 占领小屋](img/B05034_05_22.jpg)'
- en: In the preceding code, we first create an instance of `Hut`. In the second line,
    this hut is acquired by `self.knight`. The `TestCase.assertIs` checks whether
    the object representing the hut's occupant is the same as `self.knight`, otherwise
    an `AssertionError` is raised.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个`Hut`的实例。在第二行，这个小屋被`self.knight`获得。`TestCase.assertIs`检查代表小屋占用者的对象是否与`self.knight`相同，否则会引发`AssertionError`。
- en: Running only the second test
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅运行第二个测试
- en: 'If we execute the following command, it would run all the tests defined in
    the `test_wargame.py` module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行以下命令，它将运行`test_wargame.py`模块中定义的所有测试：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What if you just want to run `test_acquire_hut`? Assuming you are already inside
    the `wargame` directory, here is a command to accomplish this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想运行`test_acquire_hut`怎么办？假设你已经处于`wargame`目录中，以下是一个完成此任务的命令：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command-line argument can be read as `package_name.module_name.class_name.method_name`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行参数可以读作`package_name.module_name.class_name.method_name`。
- en: 'The output after running this test is shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试后的输出如下所示：
- en: '![Running only the second test](img/B05034_05_23.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![仅运行第二个测试](img/B05034_05_23.jpg)'
- en: Creating individual test modules
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单独的测试模块
- en: The last unit test we wrote was meant for testing the functionality in the `Hut`
    class. We created this as a method of the `TestWarGame` class in the `test_wargame.py`
    module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的最后一个单元测试是为了测试`Hut`类中的功能。我们在`test_wargame.py`模块中将这个作为`TestWarGame`类的一个方法创建。
- en: Do we have to put all the tests for the application inside a single module?
    No! You can, optionally, create individual test modules for each class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否必须将应用程序的所有测试都放在一个模块中？不！你可以选择为每个类创建单独的测试模块。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For large applications, it is often convenient to have separate test modules
    at the class level or the package level. Choose a strategy that best suits your
    project. If it makes sense, you can also create a test class that clubs together
    some common functionality in your application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，在类级别或包级别拥有单独的测试模块通常很方便。选择最适合你项目的策略。如果合理，你还可以创建一个测试类，将应用程序中的一些常用功能组合在一起。
- en: 'Let''s rework the previous example. We will create a new module, `test_hut.py`,
    as a home for a new class, `TestHut`. The source code is also available in the
    supplementary material for this chapter—see `wargame/test/test_hut.py`. Next,
    we will move the `TestWarGame.test_acquire_hut` method into this class. This is
    shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新整理之前的例子。我们将创建一个新的模块`test_hut.py`，作为新类`TestHut`的家园。源代码也包含在本章的补充材料中——见`wargame/test/test_hut.py`。接下来，我们将`TestWarGame.test_acquire_hut`方法移动到这个类中。如下所示：
- en: '![Creating individual test modules](img/B05034_05_24.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![创建单个测试模块](img/B05034_05_24.jpg)'
- en: 'The syntax to execute the unit test is similar to the one used before:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单元测试的语法与之前使用的类似：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Batch executing unit tests
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量执行单元测试
- en: 'If your test directory contains multiple test modules, how do you run all the
    tests at once inside the directory? One option is to write a script listing commands
    to execute the unit tests one after the other. The `unittest` module, however,
    provides a discover option to batch execute the tests on the command line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试目录包含多个测试模块，你如何在目录内一次性运行所有测试？一个选项是编写一个脚本，列出执行单元测试的命令。然而，`unittest`模块提供了一个发现选项，可以在命令行上批量执行测试：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following command-line output shows the batch execution of two test modules
    inside the `test` directory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行输出显示了在`test`目录内批量执行的两个测试模块：
- en: '![Batch executing unit tests](img/B05034_05_25.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![批量执行单元测试](img/B05034_05_25.jpg)'
- en: Unit tests using mock library
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟库的单元测试
- en: The two tests we wrote earlier were pretty straightforward to implement. Often,
    it is not trivial to write a test for verifying the functionality. The reasons
    could vary. In some scenarios, the code is required to be refactored in order
    to access the functionality you would like to test. In another scenario, the code
    might have dependencies that require you to write a lot more code than necessary.
    It is also possible that the functionality to be tested needs time consuming preparatory
    work such as crunching some numbers. This adds to the total test execution time.
    We will now learn how to write a unit test in such situations using the mock library.
    Before working on the actual code, let's understand what functionality this library
    provides.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的两个测试相对简单易行。通常，编写一个用于验证功能的测试并非易事。原因可能多种多样。在某些情况下，代码可能需要重构，以便访问你想要测试的功能。在另一种情况下，代码可能存在依赖关系，这要求你编写比必要更多的代码。此外，要测试的功能可能需要进行耗时的准备工作，例如处理一些数字。这会增加总的测试执行时间。现在，我们将学习如何使用模拟库在这种情况下编写单元测试。在实际编写代码之前，让我们了解这个库提供了哪些功能。
- en: Quick introduction to mock
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟快速入门
- en: The mock library provides a flexible way to create dummy objects that can be
    used to replace some parts in the program that you are testing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟库提供了一种灵活的方式来创建虚拟对象，这些对象可以用来替换你正在测试的程序中的一些部分。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Mock is available in the Python standard library ( v3.3 onwards) as `unittest.mock`.
    If you are using a prior distribution, install it using this command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟库从Python标准库（v3.3及以后版本）中可用，作为`unittest.mock`。如果你使用的是早期版本，请使用以下命令安装：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Visit [https://pypi.python.org/pypi/mock](https://pypi.python.org/pypi/mock)
    for further information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://pypi.python.org/pypi/mock](https://pypi.python.org/pypi/mock) 获取更多信息。
- en: 'With a mock object, you can focus on the main functionality to be tested without
    worrying much about the things on which this functionality depends. It provides
    a way to decouple the supporting chunks of code from the functionality being tested.
    This can be better explained with an example. Refer to the following cartoon:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象，你可以专注于要测试的主要功能，而不必过多担心这个功能所依赖的事物。它提供了一种方法，将支持代码块与正在测试的功能解耦。这可以通过一个例子更好地解释。参考以下卡通：
- en: '![Quick introduction to mock](img/B05034_05_26.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![模拟快速入门](img/B05034_05_26.jpg)'
- en: Imagine you are writing a unit test for a function called `compute()` that does
    a lot of scientific computations. Within this function, you are calling other
    supporting functions that process some data. This is a time-consuming operation.
    If you know what information is being provided by the supporting functions, you
    can define their behavior using mock objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个名为`compute()`的函数的单元测试，该函数执行大量的科学计算。在这个函数内部，你调用其他支持函数来处理一些数据。这是一个耗时的操作。如果你知道支持函数提供的信息，你可以使用模拟对象来定义它们的行为。
- en: Let's mock!
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们进行模拟！
- en: 'It''s time for some action. Open your Python interpreter, and start writing
    the following code. It is assumed that the mock module is already available. If
    it isn''t, install it using pip, as suggested earlier. First, import the `Mock`
    class as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候采取一些行动了。打开你的 Python 解释器，并开始编写以下代码。假设 mock 模块已经可用。如果它不可用，请使用前面建议的方式使用 pip
    安装。首先，按照以下方式导入 `Mock` 类：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, create a `Mock` object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `Mock` 对象：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The object type and its unique ID can be found as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型及其唯一 ID 可以通过以下方式找到：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Moving on, type the following code in the Python interpreter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，在 Python 解释器中输入以下代码：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Let''s mock!](img/B05034_05_27.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![让我们模拟！](img/B05034_05_27.jpg)'
- en: '| *Good observation! Apologies for using your name here...that was unintentional.
    In the developer world, people just love your name! So the question is, would
    it really give an attribute error? Try it yourself!* |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| *良好的观察！对于在这里使用你的名字表示歉意……这是无意的。在开发者世界中，人们非常喜欢你的名字！所以问题是，它真的会引发属性错误吗？自己试试看！*
    |'
- en: 'Executing this last line of code will print an output similar to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最后一行代码将打印出类似于以下内容的输出：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the interesting part! It did not complain about the missing attribute;
    instead, it created a new mock object. You can access any arbitrary attribute
    of this object as if it was already defined. It will create and return a new `Mock`
    object representing that attribute. Here, `foo` is also called a child mock of
    `mockObj`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有趣的部分！它没有抱怨缺少属性；相反，它创建了一个新的模拟对象。你可以像它已经定义一样访问这个对象的任何任意属性。它将创建并返回一个代表该属性的新
    `Mock` 对象。在这里，`foo` 也被称为 `mockObj` 的子模拟。
- en: 'Let''s see how to make use of this feature. `Mock.mock_calls` can be used to
    track all the calls of a mock object along with its child mocks. The results are
    returned as a Python list. Write the following line of code in the Python interpreter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用这个功能。`Mock.mock_calls` 可以用来跟踪模拟对象及其子模拟的所有调用。结果以 Python 列表的形式返回。在 Python
    解释器中编写以下代码行：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, it returns an empty Python list, as we have not called the `mockObj` or
    its child mocks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它返回一个空 Python 列表，因为我们还没有调用 `mockObj` 或其子模拟。
- en: 'Next, let''s see how this list gets populated. The `Mock` objects are callable.
    Write the following code to call `mockObj.foo`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个列表是如何被填充的。`Mock` 对象是可调用的。编写以下代码来调用 `mockObj.foo`：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will create and call another new child mock like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建并调用另一个新的子模拟，如下所示：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s invoke `mockObj.mock_calls` one more time:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次调用 `mockObj.mock_calls`：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The returned list now contains two objects, namely `call.foo()` and `call.foo2()`.
    These are the helper objects provided by `unittest.mock.call`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的列表现在包含两个对象，即 `call.foo()` 和 `call.foo2()`。这些都是 `unittest.mock.call` 提供的辅助对象。
- en: How do we use this information? When you write a unit test, you can use this
    list to make assertions on which objects are invoked and in what order. To understand
    this concept better, we will write a simple unit test in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这些信息？当你编写单元测试时，你可以使用这个列表来断言哪些对象被调用以及它们的调用顺序。为了更好地理解这个概念，我们将在下一节编写一个简单的单元测试。
- en: Using Mock objects in a unit test
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试中使用 Mock 对象
- en: 'Let''s write a unit test for the compute method of a class, `MyClassA`. The
    class is shown next. You can also download the `wargame/test/mockdemo.py` file
    from the supporting code bundle:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为类 `MyClassA` 的 `compute` 方法编写一个单元测试。类定义如下。你还可以从支持代码包中下载 `wargame/test/mockdemo.py`
    文件：
- en: '![Using Mock objects in a unit test](img/B05034_05_28.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![在单元测试中使用 Mock 对象](img/B05034_05_28.jpg)'
- en: This is a trivial example. The `compute` method depends on the values returned
    by two methods, `foo` and `foo2`. It uses these values to compute and return the
    result. In this example, the methods `foo` and `foo2` are simple.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子。`compute` 方法依赖于两个方法返回的值，即 `foo` 和 `foo2`。它使用这些值来计算并返回结果。在这个例子中，`foo`
    和 `foo2` 方法很简单。
- en: Imagine a scenario where the aforementioned methods perform tasks that take
    a very long time. Now, to write a unit test that verifies the functionality of
    the `compute` method, you would need to check the final value of `result`. Naturally,
    it would take a long time to finish because of the time spent in `foo` and `foo2`.
    If you know the expected outcome of these methods, you can simply replace them
    with `Mock` objects in the test. We can do this because `foo` and `foo2` are assumed
    to be the supporting functions, and the main functionality to be tested is the
    value of result.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，上述方法执行的任务需要非常长的时间。现在，要编写一个验证`compute`方法功能的单元测试，你需要检查`result`的最终值。由于在`foo`和`foo2`中花费的时间，这自然会花费很长时间。如果你知道这些方法的预期结果，你可以在测试中简单地用`Mock`对象替换它们。我们可以这样做，因为假设`foo`和`foo2`是辅助函数，而要测试的主要功能是结果值。
- en: The `Mock` objects would behave as if they are the original methods, and return
    the output you need. But in reality, we bypass the time consuming computations.
    In this illustration, we already know that `foo` is expected to return a value
    of `100`. The return value of the `foo2` method depends on the input argument
    `x`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象将表现得像它们是原始方法一样，并返回所需的输出。但在现实中，我们绕过了耗时的计算。在此说明中，我们已经知道`foo`预期返回值为`100`。`foo2`方法的返回值取决于输入参数`x`。'
- en: 'Looking at the compute method, we can easily deduce that the return value of
    `foo2` would be `100 + 200 = 300`. So let''s write a unit test that mocks these
    method calls. The code is shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看compute方法，我们可以轻松推断出`foo2`的返回值将是`100 + 200 = 300`。因此，让我们编写一个单元测试来模拟这些方法调用。代码如下：
- en: '![Using Mock objects in a unit test](img/B05034_05_29.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![在单元测试中使用Mock对象](img/B05034_05_29.jpg)'
- en: Let's review the method in the preceding code snippet
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾前面代码片段中的方法
- en: The `a.foo` and `a.foo2` methods are now represented by new `Mock` objects,
    `mockObj.foo` and `mockObj.foo2`, respectively. Inside `a.compute()`, the `self.foo()`
    and `self.foo2()` calls are now mocked with these new objects.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.foo`和`a.foo2`方法现在分别由新的`Mock`对象`mockObj.foo`和`mockObj.foo2`表示。在`a.compute()`内部，`self.foo()`和`self.foo2()`调用现在被这些新对象模拟。'
- en: The test verifies the value of the parameter result. This is done by calling
    `TestCase.assertEqual`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试通过调用`TestCase.assertEqual`验证参数result的值。
- en: The test also verifies which objects are called and the order in which they
    are called. As seen before, `test_call_list` is used to track all the calls to
    `mockObj` and its child mocks. This list is compared with some reference list
    that stores the expected calling order of the objects. In this example, `reference_call_list`
    stores this information. It expects the `foo` and `foo2` methods be called in
    that order. In future, if someone tweaks this order in `MyClassA.compute`, this
    test would help catch the change.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试还验证了被调用的对象以及它们的调用顺序。如前所述，`test_call_list`用于跟踪对`mockObj`及其子模拟的所有调用。此列表与存储对象预期调用顺序的参考列表进行比较。在此示例中，`reference_call_list`存储此信息。它期望`foo`和`foo2`方法按此顺序调用。在未来，如果有人更改`MyClassA.compute`中的此顺序，这个测试将有助于捕捉到变化。
- en: Note
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The MagicMock class**:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**The MagicMock class**:'
- en: '`MagicMock` is a subclass of `Mock`. It essentially provides all the functionality
    that you would expect from a `Mock` class. Additionally, it provides default implementation
    for many of the magic methods in Python. A magic method is a special method whose
    name has double underscores as both prefix and suffix. Some examples of magic
    methods include `__init__` , `__iter__`, `__len__`, and so on. In the illustrations,
    you can use `MagicMock` instead of the `Mock` class. For further details, go to
    the following page: [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MagicMock`是`Mock`的子类。它本质上提供了你从`Mock`类期望的所有功能。此外，它为Python中的许多魔术方法提供了默认实现。魔术方法是一种具有双下划线作为前缀和后缀名称的特殊方法。魔术方法的示例包括`__init__`、`__iter__`、`__len__`等。在说明中，你可以使用`MagicMock`而不是`Mock`类。有关更多详细信息，请参阅以下页面：[https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)。'
- en: Working with patches
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用补丁
- en: Under the previous heading, we covered some basics of the `Mock` class. The
    mock library provides another important functionality in the form of patch decorators.
    Patching is a mechanism that allows you to change the behavior of an object temporarily
    within a test. This is a broad topic. In this book, we will limit our discussion
    to creating patches using `unittest.mock.patch`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个标题下，我们介绍了`Mock`类的一些基础知识。mock库以补丁装饰器形式提供了另一个重要的功能。补丁是一种机制，允许您在测试中临时更改对象的行为。这是一个广泛的话题。在这本书中，我们将限制我们的讨论范围，仅限于使用`unittest.mock.patch`创建补丁。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Patches can be invoked in four different ways, namely `patch`, `patch.object`
    , `patch.dict`, and `patch.multiple`. For further information, see the documentation
    at [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁可以通过四种不同的方式调用，即`patch`、`patch.object`、`patch.dict`和`patch.multiple`。有关更多信息，请参阅[https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)上的文档。
- en: 'The `patch` decorator function takes `target` as the required argument, followed
    by a long list of optional arguments. Only one of the optional arguments (`new`)
    is shown here. Refer to the unittest documentation for information on other optional
    arguments:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch`装饰器函数将`target`作为必需参数，后面跟着一系列可选参数。这里只显示了其中一个可选参数（`new`）。有关其他可选参数的信息，请参阅unittest文档：'
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding function, the `target` argument is the thing you would like
    to patch. It can be any function, class method, or an object.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的函数中，`target`参数是你想要补丁的东西。它可以是一个函数、类方法或一个对象。
- en: The `target` is imported, and should be represented by a string, which resembles
    a typical `import` statement (without the keyword `import`).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`被导入，应该用一个字符串表示，类似于典型的`import`语句（没有`import`关键字）。'
- en: 'For example, if you want to patch a method inside a test case, the `target`
    should be represented like so: `pkg.module.myclass.mymethod`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果您想在测试用例中补丁一个方法，则`target`应表示为：`pkg.module.myclass.mymethod`。
- en: 'If this method is in the same file where you are creating the patch (for example,
    the method and its test are in the same Python file), then `target` should be
    written as: `__main__.myclass.mymethod`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果此方法与您创建补丁的文件相同（例如，方法和其测试在同一Python文件中），则`target`应写作：`__main__.myclass.mymethod`。
- en: 'Among the optional arguments, we will only discuss and use `new`. The `new`
    argument tells which object would replace the `target`. It can be any class or
    a `Mock` object. This can be better understood with an example. See the following
    line of code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选参数中，我们只将讨论和使用`new`。`new`参数告诉哪个对象将替换`target`。它可以是一个类或一个`Mock`对象。这可以通过一个例子更好地理解。请参见以下代码行：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first argument is `target`. It is a method `foo` of `MyClassA`, whose behavior
    needs to be changed temporarily within a test. Put another way, this is the method
    (or `target`) that needs to be patched. The `new` argument specifies the object
    that would replace this method. In other words, the `target` is patched with the
    `new` object. If you do not specify the `new` argument, the `target` would be
    automatically patched with a `MagicMock` object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`target`。它是`MyClassA`类的一个方法`foo`，其行为需要在测试中临时更改。换句话说，这就是需要补丁的方法（或`target`）。`new`参数指定了将替换此方法的对象。换句话说，`target`通过`new`对象进行补丁。如果您不指定`new`参数，则`target`将自动使用`MagicMock`对象进行补丁。
- en: Using patch in a unit test
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单元测试中使用补丁
- en: 'To demonstrate the use of a `patch` decorator, we will use the example discussed
    under the heading *Using Mock objects in a unit test*. Before reading the following
    discussion, review the `MyClassA.compute` method. It was illustrated in the aforementioned
    heading, and the code can also be found in the file `wargame/test/mockdemo.py`.
    The following is a unit test written for `MyClassA.compute` using patch:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`patch`装饰器的使用，我们将使用在标题*在单元测试中使用Mock对象*下讨论的例子。在阅读以下讨论之前，请回顾`MyClassA.compute`方法。它在上文标题中已说明，代码也可以在文件`wargame/test/mockdemo.py`中找到。以下是为`MyClassA.compute`编写的使用补丁的单元测试：
- en: '![Using patch in a unit test](img/B05034_05_38.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![在单元测试中使用补丁](img/B05034_05_38.jpg)'
- en: 'In the preceding unit test:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的单元测试中：
- en: '`patch` is a context processor invoked using the with statement.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`是一个使用with语句调用的上下文处理器。'
- en: The `with` keyword cleans up the resources used after the code execution.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`关键字在代码执行后清理使用的资源。'
- en: The method `MyClassA.foo` gets replaced with a `Mock` object created by the
    optional argument new.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyClassA.foo`方法被用可选参数`new`创建的`Mock`对象替换。'
- en: In other words, the call `self.foo()` in `MyClassA.compute()` is replaced with
    `return_value` of this `Mock` object. At runtime, the expression `x = self.foo()`
    becomes `x = 500` without actually invoking the method foo.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换句话说，`MyClassA.compute`中的`self.foo()`调用被替换为这个`Mock`对象的`return_value`。在运行时，表达式`x
    = self.foo()`变成了`x = 500`，而不实际调用foo方法。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Would the test in the earlier illustration pass? For that, review the code in
    the `MyClassA.compute` method. The `Mock` object created by the `new` argument
    returns a value of `500`. In the unit test, if the result is not `400`, it raises
    an assertion error. So, this test is expected to fail.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前示例中的测试会通过吗？为此，请回顾`MyClassA.compute`方法中的代码。由`new`参数创建的`Mock`对象返回值为`500`。在单元测试中，如果结果不是`400`，则会引发断言错误。因此，这个测试预期会失败。
- en: 'What happens if you do not specify the `new` argument? As mentioned earlier,
    `target` would automatically get replaced with a new `MagicMock` object. Here
    is another way you can write the same test. As an exercise, run this test, and
    print `foo_patch.__class__` to find out which class it belongs to:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定`new`参数会发生什么？如前所述，`target`会自动被替换为一个新的`MagicMock`对象。这里还有另一种编写相同测试的方法。作为一个练习，运行这个测试，并打印`foo_patch.__class__`以找出它属于哪个类：
- en: '![Using patch in a unit test](img/B05034_05_39.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![使用单元测试中的 patch](img/B05034_05_39.jpg)'
- en: With this introduction to the mock library, let's write a unit test for a method
    in our application using the `patch` decorator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在对模拟库的介绍之后，让我们使用`patch`装饰器为我们的应用程序中的某个方法编写一个单元测试。
- en: Third unit test – The play method
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三个单元测试 – 游戏方法
- en: 'In this section, we will use the mock library to write a unit test for `AttackOfTheOrcs.play`.
    Let''s review the method first. You can also find the source code in the `wargame/attackoftheorcs.py`
    file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用模拟库为`AttackOfTheOrcs.play`编写一个单元测试。让我们首先回顾一下这个方法。你还可以在`wargame/attackoftheorcs.py`文件中找到源代码：
- en: '![Third unit test – The play method](img/B05034_05_40.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![第三个单元测试 – 游戏方法](img/B05034_05_40.jpg)'
- en: This preceding method does many things. It starts by creating some necessary
    objects such as the player and huts. Then the program runs until all the huts
    are acquired by the player or the player loses the combat. Observe the code closely.
    It depends on a user input for selecting a hut. This is not the only user input
    it needs. The call to the `Knight.acquire_hut` method would again ask the user
    whether to continue the attack.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的游戏方法做了很多事情。它首先创建一些必要的对象，例如玩家和小屋。然后程序运行，直到玩家占领所有小屋或玩家在战斗中失败。仔细观察代码。它依赖于用户输入来选择小屋。这并不是它需要的唯一用户输入。对`Knight.acquire_hut`方法的调用会再次询问用户是否继续攻击。
- en: 'In an automated test, you cannot expect someone to enter the hut number, and
    other inputs to continue the execution. So how do we write a unit test for this
    method? This is where we can use `patch` decorators to mimic the user input:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试中，你不能期望有人输入小屋编号和其他输入以继续执行。那么我们如何为这个方法编写单元测试呢？这就是我们可以使用`patch`装饰器来模拟用户输入的地方：
- en: '![Third unit test – The play method](img/B05034_05_48.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![第三个单元测试 – 游戏方法](img/B05034_05_48.jpg)'
- en: 'What should we test here? We should test the overall functioning of the method.
    There are a couple of thing to test here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里应该测试什么？我们应该测试该方法的整体功能。这里有几个需要测试的事项：
- en: The winning or losing criterion. The player is declared a winner when all the
    huts are acquired.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利或失败的标准。当所有小屋都被占领时，玩家被宣布为胜利者。
- en: For this to happen, the player must also be in good health, meaning the value
    of `player.health_meter` should be greater than zero.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现这一点，玩家也必须处于良好的健康状况，这意味着`player.health_meter`的值应该大于零。
- en: Thus, the winner is declared only when both these conditions are true. Similarly,
    there will be a losing criterion that you can easily determine. For precise control,
    you should also write separate unit tests for individual methods invoked within
    the `play` method. For example, there should be a separate test to verify the
    working of `Knight.acquire_huts`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有在这两个条件都为真时才会宣布胜利者。同样，也将会有一个容易确定的失败标准。为了精确控制，你还应该为`play`方法中调用的单个方法编写单独的单元测试。例如，应该有一个单独的测试来验证`Knight.acquire_huts`的工作情况。
- en: 'Let''s write a test to verify the overall functionality. This test will use
    `patch` to handle the user input. As before, you can find this test in the `wargame/test/test_wargame.py`
    module. The following code snippet shows the `TestWarGame.test_play` method in
    this module. At the beginning of the module, the mock library is imported like
    so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试来验证整体功能。这个测试将使用`patch`来处理用户输入。和之前一样，你可以在这个模块`wargame/test/test_wargame.py`中找到这个测试。以下代码片段显示了该模块中的`TestWarGame.test_play`方法。在模块的开始部分，像这样导入mock库：
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The rest of the code in this module will not be discussed here. Review the
    aforementioned file for further details:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块中剩余的代码将在此不讨论。请查看上述文件以获取更多详细信息：
- en: '![Third unit test – The play method](img/B05034_05_41.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![第三单元测试 – 演练方法](img/B05034_05_41.jpg)'
- en: The important part in the preceding code is `mock.patch`. Our first goal is
    to make sure that the user input is properly handled. Recall that in Python 3,
    the user input is handled by the built-in function `input()`. So, we need to patch
    this function with something that would simulate the user input. In other words,
    replace the `builtins.input` function with the handling function represented by
    the `new` argument.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的重要部分是`mock.patch`。我们的第一个目标是确保用户输入得到适当的处理。回想一下，在Python 3中，用户输入由内置函数`input()`处理。因此，我们需要用模拟用户输入的东西来修补这个函数。换句话说，用`new`参数表示的处理函数替换`builtins.input`函数。
- en: The `self.hut_selection_counter` attribute is used as a simple counter to simulate
    the user input. The rest of the code implements the logic to verify that the winning
    and losing criteria are honored. The `acquired_hut_list` is generated using list
    comprehension. More on list comprehension later when we talk about the performance
    improvements. The `all` function returns `True` if all the list elements are `True`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.hut_selection_counter`属性被用作一个简单的计数器来模拟用户输入。其余的代码实现了验证获胜和失败标准的逻辑。`acquired_hut_list`使用列表推导生成。关于列表推导的更多内容，我们将在讨论性能改进时再谈。`all`函数在所有列表元素都是`True`时返回`True`。'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using Python 2.7.9, try replacing `builtins.input` with `__builtin__.raw_input`.
    However, this technique does not seem to work well, as it will still prompt you
    while running the test! With Python 3.5, this is not a problem. As said elsewhere,
    before Python 3.3, mock was not a built-in module (`unittest.mock`). So for Python
    2.7.9, you may need to install mock as `pip install mock`, and make appropriate
    changes to the `import` statement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用Python 2.7.9，尝试将`builtins.input`替换为`__builtin__.raw_input`。然而，这种方法似乎效果不佳，因为在运行测试时仍然会提示你！在Python
    3.5中，这不是问题。正如之前所说，在Python 3.3之前，mock不是一个内置模块（`unittest.mock`）。因此，对于Python 2.7.9，你可能需要安装mock作为`pip
    install mock`，并对`import`语句进行适当的修改。
- en: 'Next, we will review the `user_input_processor` that patches the built-in `input`
    function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾`user_input_processor`，它用于修补内置的`input`函数：
- en: '![Third unit test – The play method](img/B05034_05_42.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![第三单元测试 – 演练方法](img/B05034_05_42.jpg)'
- en: 'It takes user `prompt` as an argument, and returns an answer (user input) to
    that prompt. For example, when prompted to enter the hut number, it increments
    `self.hut_selection_counter` by `1`, and returns the updated value. This attribute
    is initialized to `0` in the `test_play` method. To better understand this code,
    add some `print` statements to these two methods, and execute the test as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它将用户`prompt`作为参数，并返回对该提示的答案（用户输入）。例如，当提示输入小屋编号时，它会将`self.hut_selection_counter`增加`1`，并返回更新后的值。这个属性在`test_play`方法中被初始化为`0`。为了更好地理解这段代码，向这两个方法添加一些`print`语句，并按照以下方式执行测试：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output on executing the test is shown in the following screenshot. Notice
    that it does not print the user prompts such as Continue attack?(y/n) in the command-line
    output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试时的输出如下所示。注意，它不会在命令行输出中打印用户提示，如继续攻击？（y/n）：
- en: '![Third unit test – The play method](img/B05034_05_43.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![第三单元测试 – 演练方法](img/B05034_05_43.jpg)'
- en: Is your code covered?
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的代码是否被覆盖了？
- en: 'Is there a way to check how well you are doing as far as testing is concerned?
    How much code is covered by the unit tests? For this, you need a Python package
    called `coverage`. It can be installed using pip as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以检查你在测试方面的表现如何？单元测试覆盖了多少代码？为此，你需要一个名为`coverage`的Python包。它可以按照以下方式使用pip安装：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding command creates an executable called `coverage` at the same location
    as your Python installation. In Linux, if Python 3 is installed in `/usr/bin/`,
    `coverage` will be available at the same location as `/use/bin/coverage`. In Windows
    OS, it will be available in the `Scripts` directory, at the same location as `pip.exe`.
    Run the `coverage` command as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在Python安装的同一位置创建了一个名为`coverage`的可执行文件。在Linux中，如果Python 3安装在`/usr/bin/`，则`coverage`将在与`/use/bin/coverage`相同的路径下可用。在Windows操作系统上，它将在`Scripts`目录中可用，与`pip.exe`在同一位置。按照以下方式运行`coverage`命令：
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command is a combination of two commands separated by `&&` and executed
    one after the other. The first command runs the tests: `coverage run -m test.test_wargame`.
    This is similar to how we run the unit tests. The `run` option runs a Python program,
    and measures the code execution. As noted before, the `-m` option instructs `coverage`
    to consider the next argument as an importable Python module instead of treating
    it as a script. This is why we specify the next argument as `test.test_wargame`
    (just like an `import` statement) instead of writing `test/test_wargame.py`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令是两个命令的组合，由`&&`分隔，依次执行。第一个命令运行测试：`coverage run -m test.test_wargame`。这与我们运行单元测试的方式相似。`run`选项运行Python程序，并测量代码执行。如前所述，`-m`选项指示`coverage`将下一个参数视为可导入的Python模块，而不是将其视为脚本。这就是为什么我们指定下一个参数为`test.test_wargame`（就像一个`import`语句）而不是编写`test/test_wargame.py`。
- en: 'The second command, `coverage report`, generates the report indicating the
    test coverage. Here is how the coverage report is presented after running this
    command. For ease of illustration, the output pertaining to the execution of the
    test cases (the first command) is not shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令，`coverage report`，会生成显示测试覆盖率的报告。以下是运行此命令后覆盖报告的呈现方式。为了便于说明，以下截图未显示与测试用例执行（第一个命令）相关的输出：
- en: '![Is your code covered?](img/B05034_05_44.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![你的代码是否被覆盖？](img/B05034_05_44.jpg)'
- en: To see a different coverage report, try disabling some tests in `test_wargame.py`,
    and rerun the `coverage` command noted earlier.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看不同的覆盖率报告，尝试在`test_wargame.py`中禁用一些测试，然后重新运行前面提到的`coverage`命令。
- en: Resolving import errors, if any
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决导入错误（如果有）
- en: 'Read this section only if you encounter any import errors while executing the
    coverage. If you run `coverage` as instructed, you are unlikely to encounter any
    import errors such as no module named `knight`. In other words, run the test from
    the top-level directory `wargame`, and make sure to run it as a module (the `-m`
    option) instead of a script. If you run `coverage` in the following way, you would
    likely see import errors:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在执行覆盖率时遇到任何导入错误时，才阅读本节。如果您按照说明运行`coverage`，不太可能遇到没有名为`knight`的模块之类的导入错误。换句话说，从顶级目录`wargame`运行测试，并确保以模块（`-m`选项）而不是脚本的方式运行。如果您以以下方式运行`coverage`，可能会看到导入错误：
- en: '[PRE25]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding case, it is unable to find the right `PATH` for the modules
    from the `wargame` directory. Make sure that both `wargame` and `test` directories
    are in your `sys.path`. One quick and dirty hack is to add the following code
    to `test_wargame.py`. Assuming you are running coverage from within the `test`
    directory, add the following code before the `import` statements, such as `from
    knight import Knight`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，它无法从`wargame`目录中找到模块的正确`PATH`。请确保`wargame`和`test`目录都在您的`sys.path`中。一个快速且简单的解决方案是将以下代码添加到`test_wargame.py`中。假设您在`test`目录内运行覆盖率，请在`from
    knight import Knight`等导入语句之前添加以下代码：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Other unit testing tools
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他单元测试工具
- en: In this chapter, we have exclusively used the built-in `unittest` framework
    for writing the tests. There are several other tools available for unit testing
    that were not discussed. The purpose of this section is only to introduce you
    to the other unit testing tools available out there besides the built-in `unittest`
    module. For instance, there are tools such as nose or pytest that make it easier
    to write the unit tests to a large extent. Let's briefly review some of these
    unit testing tools.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专门使用了内置的`unittest`框架来编写测试。还有其他一些单元测试工具未被讨论。本节的目的仅在于向您介绍除了内置的`unittest`模块之外的其他单元测试工具。例如，有如nose或pytest之类的工具，在很大程度上简化了单元测试的编写。让我们简要回顾一些这些单元测试工具。
- en: Doctest
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest
- en: 'This is a built-in module, which looks for text that resembles Python code
    written in an interpreter. Here is a trivial example that shows a docstring with
    an example usage of the function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内置模块，它寻找类似于在解释器中编写的Python代码的文本。以下是一个简单的示例，展示了带有函数示例用法的文档字符串：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Doctest** identifies such code, and runs it to check if it really does what
    it says. This is quite an effective way to verify the correctness of the code
    examples you write in the documentation and/or in the docstrings. While this is
    very useful, it is worth noting here that the extensive code samples in the docstring
    could be distracting. See [https://docs.python.org/3/library/doctest.html#module-doctest](https://docs.python.org/3/library/doctest.html#module-doctest)
    for further details.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**Doctest**识别这样的代码，并运行它以检查它是否真的做了它所说的。这是一种非常有效的方式来验证你在文档和/或文档字符串中编写的代码示例的正确性。虽然这非常有用，但在这里值得注意，文档字符串中的大量代码示例可能会分散注意力。有关更多详细信息，请参阅[https://docs.python.org/3/library/doctest.html#module-doctest](https://docs.python.org/3/library/doctest.html#module-doctest)。'
- en: Nose
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nose
- en: 'Nose is a popular third-party tool that simplifies writing and running unit
    tests. Install it using pip as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Nose是一个流行的第三方工具，它简化了单元测试的编写和运行。使用以下方式安装：
- en: '[PRE28]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nose extends `unittest`. One of the advantages of using this tool is it doesn''t
    require you to write tests as inherited class methods of `unittest.TestCase`.
    You can even write tests as separate functions. Let''s write a simple test, and
    run it with `nosetests`. Create the following function in a file called `test_nose.py`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Nose扩展了`unittest`。使用这个工具的一个优点是它不需要你将测试编写为`unittest.TestCase`的继承类方法。你甚至可以将测试编写为单独的函数。让我们编写一个简单的测试，并用`nosetests`运行它。在名为`test_nose.py`的文件中创建以下函数：
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run this test from the command line as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下命令行运行此测试：
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s all. It will run the test. Obviously, this test will pass. As can be
    seen, we did not need to put the test inside the subclass of `unittest.TestCase`.
    The function name needs to contain `test` or `Test`, since we are using the default
    nose configuration. Try renaming the function so that it does not have the word
    `test`. For example, name it `foo_a`. If you run `nosetests` again, it will exclude
    this function. To consider function names that do not have the word `test`, use
    the command-line option `--tests` like so:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了。它将运行测试。显然，这个测试将会通过。正如所见，我们不需要将测试放在`unittest.TestCase`的子类中。函数名需要包含`test`或`Test`，因为我们正在使用默认的nose配置。尝试重命名函数，使其不包含单词`test`。例如，命名为`foo_a`。如果你再次运行`nosetests`，它将排除这个函数。要考虑不包含单词`test`的函数名，使用命令行选项`--tests`，如下所示：
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See [https://nose.readthedocs.org](https://nose.readthedocs.org) to learn how
    to use nose effectively.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://nose.readthedocs.org](https://nose.readthedocs.org)了解如何有效地使用nose。
- en: Pytest
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pytest
- en: 'Pytest is yet another popular tool that simplifies writing unit tests. It can
    be installed using `pip` as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest是另一个流行的工具，它简化了单元测试的编写。可以使用以下方式使用`pip`安装：
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can run the same test we wrote for nose. Let''s save the following code
    in a file, `test_pytest.py`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行我们为nose编写的相同测试。让我们将以下代码保存到文件中，命名为`test_pytest.py`：
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the preceding test from the command line as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下命令行运行前面的测试：
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See [http://pytest.org/](http://pytest.org/) to find out more about this tool.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://pytest.org/](http://pytest.org/)了解更多关于这个工具的信息。
- en: Refactoring preamble
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构前缀
- en: Let's write one more unit test for the game. This time we will focus our attention
    on the main class `AttackOfTheOrcs`. When the `play` method is called, the first
    thing it does is to randomly occupy the five huts. We will write a test to verify
    that there are exactly five huts. Another thing to test is that the hut occupant
    must be an instance of the class `AbstractGameUnit`, or should be of the type
    `None`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为游戏编写另一个单元测试。这次我们将关注主类`AttackOfTheOrcs`。当调用`play`方法时，它首先随机占领五个小屋。我们将编写一个测试来验证恰好有五个小屋。另一件要测试的事情是，小屋的居住者必须是`AbstractGameUnit`类的实例，或者应该是`None`类型。
- en: The `_occupy_hut` method has the related code. But this necessitates writing
    a test for a non-public method (or call it protected or private).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`_occupy_hut`方法有相关的代码。但这需要编写一个针对非公共方法的测试（或者称之为受保护的或私有的）。'
- en: '![Refactoring preamble](img/B05034_05_30.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![重构前缀](img/B05034_05_30.jpg)'
- en: '| *What you say is right! Although Python does not restrict you from calling
    methods that start with an underscore, we should be nice to others, and try to
    avoid calling such methods.* |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对！虽然Python没有限制你调用以下划线开头的函数，但我们应该对他人友好，并尽量避免调用这样的函数。* |'
- en: 'So how do we handle this situation? Here is a list of the available options:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理这种情况？以下是一个可用的选项列表：
- en: In the test, create an instance of `AttackOfThOrcs`, and directly call the protected
    method.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中，创建一个`AttackOfThOrcs`的实例，并直接调用受保护的方法。
- en: Transform this method into a `public` method (remove the underscore prefix from
    the name).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法转换为`public`方法（从名称中移除下划线前缀）。
- en: Call the `play` method, which then calls `_occupy_huts`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`play`方法，然后它将调用`_occupy_huts`。
- en: Refactor the `play` method, and wrap the `_occupy_huts` into a `public` method
    that could be tested.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构`play`方法，并将`_occupy_huts`包装成一个可测试的`public`方法。
- en: We already have a moral conflict with the first option, as `_occupy_huts` is
    a non-public method. The second option suggests turning it into a `public` method.
    That is possible, but if this method is not supposed to be called from outside
    for any reason, we should avoid such a change. We will keep this option in mind,
    and look for some other alternative.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经与第一个选项产生了道德冲突，因为`_occupy_huts`是一个非公共方法。第二个选项建议将其转换为`public`方法。这是可能的，但如果出于任何原因这个方法不应该从外部调用，我们应该避免这种改变。我们将记住这个选项，并寻找其他替代方案。
- en: The third option needs to call the `play` method. We have already done that
    in the last example using the patch decorator. Although possible, it is inefficient
    to run a large block of code for testing a small functionality. Let's leave that
    option aside for now. The fourth option suggests refactoring the code. Let's discuss
    it further.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项需要调用`play`方法。我们已经在上一个例子中使用patch装饰器做到了这一点。虽然可行，但为了测试一个小功能而运行一大块代码是不高效的。让我们暂时不考虑这个选项。第四个选项建议重构代码。让我们进一步讨论。
- en: Tip
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the simple application that we have developed, there is no harm in changing
    `_occupy_huts` to a `public` method! We could simply rename it `occupy_huts` (no
    underscore prefix), then update the calling code, and happily write a test! In
    fact, renaming is also a form of refactoring that will be covered next. In the
    real world, however, you may not have the luxury to transform a protected method
    to a public one. Keeping this situation in mind, we will refactor the code to
    illustrate one way of making the code test friendly.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发的简单应用程序中，将`_occupy_huts`更改为`public`方法没有坏处！我们可以简单地将其重命名为`occupy_huts`（没有下划线前缀），然后更新调用代码，并愉快地编写测试！实际上，重命名也是一种将要介绍的重构形式。然而，在现实世界中，你可能没有将受保护的方法转换为公共方法的奢侈。考虑到这种情况，我们将重构代码以展示一种使代码易于测试的方法。
- en: Take a detour – Refactor for testability
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转弯——重构以提高可测试性
- en: Step 4 in the previous section needs us to refactor the play method before writing
    the test. This refactoring will improve our ability to write cleaner tests. So
    what is refactoring? How is it performed? The good news is that you have already
    done a form of refactoring in [Chapter 1](ch01.html "Chapter 1. Developing Simple
    Applications"), *Developing Simple Applications* while transforming the initial
    command-line script into a set of functions. Let's take a detour and learn some
    refactoring techniques. We will then come back with the refactored code, and develop
    the final unit test for our application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的第4步需要我们在编写测试之前重构`play`方法。这种重构将提高我们编写更干净测试的能力。那么，什么是重构？它是如何执行的？好消息是，你在[第1章](ch01.html
    "第1章。开发简单应用程序") *开发简单应用程序* 中已经进行了一种形式的重构，将初始的命令行脚本转换成一系列函数。让我们暂时偏离一下，学习一些重构技术。然后我们将带着重构后的代码回来，为我们的应用程序开发最终的单元测试。
- en: Refactoring
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: You have already come across the word refactoring in earlier chapters, and might
    have wondered what it means. An explanation is in order.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在前面的章节中遇到了“重构”这个词，可能想知道它的意思。现在需要对此进行解释。
- en: Just look around. Peep inside your closet or open your desk drawer. On day one,
    everything looks tidy and manageable. The drawer is meant to store all your important
    financial documents. Things begin to accumulate over time, and the drawer is now
    stuffed with not just with financial documents, but anything varying from scribbled
    notes, office documents, to greeting cards. Very soon, you cannot find that important
    document you need right now. You spend a lot of time digging out what you need.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 只需四处看看。窥视你的衣柜或打开你的办公桌抽屉。第一天，一切看起来都很整洁且易于管理。抽屉原本是用来存放所有重要的财务文件的。随着时间的推移，东西开始积累，抽屉里现在不仅装满了财务文件，还有各种各样的事物，从潦草的笔记、办公文件到贺卡。很快，你就找不到你现在需要的那个重要文件。你花了大量时间去挖掘你需要的东西。
- en: 'The golden moment finally arrives. You begin the cleanup operation! Several
    things are found to be useless, and are thrown away. A few other things are still
    useful, such as tickets to a football game next week. You move this stuff to a
    different drawer where it really belongs. You also find several papers laying
    around belonging to a single category: house maintenance bills. You put these
    papers together inside a single folder. Finally, with all this rearrangement and
    cleanup, your drawer breathes the new day one!'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 金色时刻终于到来。你开始清理操作！发现了一些无用的东西，被扔掉了。还有一些其他的东西仍然有用，比如下周的足球比赛门票。你把这些东西移到另一个抽屉里，那里才是它们真正属于的地方。你还发现了几张属于同一类别的纸张：房屋维护账单。你把这些纸张整理在一起，放在一个单独的文件夹里。最后，通过所有的重新排列和清理，你的抽屉迎来了新的一天！
- en: What is refactoring?
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是重构？
- en: Refactoring is something very similar to your desk drawer. The application code
    is analogous to the drawer filled with documents. As the code evolves, both the
    good and bad stuff creeps in. From outside, the behavior of the drawer remains
    the same. You can still put documents (code) in it, and business goes on as usual.
    In the absence of refactoring, someday it reaches a tipping point, and becomes
    non-accommodating to new documents.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 重构与你的桌面抽屉非常相似。应用程序代码就像是抽屉里装满了文件。随着代码的演变，好的和坏的东西都会慢慢渗入。从外面看，抽屉的行为保持不变。你仍然可以往里面放文件（代码），业务照常进行。如果没有重构，总有一天会达到一个临界点，变得无法容纳新的文件。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: With refactoring, you make internal changes to your code without affecting its
    external behavior.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构，你可以在不影响代码外部行为的情况下对代码进行内部更改。
- en: Why refactor?
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么重构？
- en: The short answer is, do it if you wish your code a long and healthy life! Timely
    refactoring is important to keep the code maintainable and extensible. You could
    rather spend more time working on a cool new feature than burning the midnight
    oil to fix a petty issue—a bug that could have been fixed within minutes had the
    code been properly maintained.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，如果你希望你的代码拥有长久和健康的生活！及时的重构对于保持代码的可维护性和可扩展性非常重要。你宁愿花更多的时间开发一个酷炫的新功能，也不愿熬夜去修复一个微不足道的问题——一个本可以在几分钟内修复的bug，如果代码得到了适当的维护。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Refactoring should be more of a habit than an obligation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 重构应该更多的是一种习惯，而不是一种义务。
- en: When to refactor?
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时进行重构？
- en: So when do we refactor the code? You have to seek the optimal balance. If you
    realize it too late in the development life cycle, it affects productivity, as
    you would need to spend a considerable amount of time doing the code cleanup.
    Many times, the project deadline makes you turn your back on refactoring. Unfortunately,
    the user-visible part of the software wins over the internal cleanup. You only
    think of the immediate deliverable, and overlook the fact that refactoring will
    only help you deliver the product faster.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们何时重构代码？你必须寻求最佳平衡。如果你在开发周期中意识到太晚，它会影响生产力，因为你需要花费相当多的时间进行代码清理。很多时候，项目截止日期会让你放弃重构。不幸的是，软件的用户可见部分胜过了内部的清理。你只考虑了立即的可交付成果，而忽略了重构只会帮助你更快地交付产品的这一事实。
- en: One strategy is to review the code at fixed intervals, and allocate some time
    for refactoring. If you are following a **Scrum** methodology, you can devote
    a sprint to some smaller refactoring projects. Such maintenance sprint will pay
    off in the long run. If you are staring at a big legacy code that needs immediate
    refactoring for survival, the required changes could be disruptive. In such situations,
    consider breaking it down into smaller problems, and use the other strategy discussed
    in the next paragraph.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是定期审查代码，并留出一些时间进行重构。如果你遵循**Scrum**方法论，你可以将一个冲刺时间用于一些较小的重构项目。这种维护冲刺从长远来看会带来回报。如果你面对的是需要立即重构以生存的大规模遗留代码，所需的变化可能会造成破坏。在这种情况下，考虑将其分解成更小的问题，并使用下一段中讨论的另一种策略。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '**Agile development methodology**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷开发方法论**'
- en: 'This is often tied to a set of non-traditional software development methods
    for managing a project. In this method, you define targets achievable in a short
    time duration. There are regular checkpoints known as sprints or iterations. The
    end of a sprint should result in an incremental and releasable version of the
    product. This is useful in complex projects, where it is tough to plan the complete
    project, or predict what to expect next because of the dynamic nature of the project.
    The methodology adopts an incremental and iterative approach to handle this task.
    For further reading, see the following wiki page: [https://en.wikipedia.org/wiki/Agile_software_development](https://en.wikipedia.org/wiki/Agile_software_development).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常与一套非传统的软件开发方法相关联，用于管理项目。在这个方法中，你定义在短时间内可实现的短期目标。有定期的检查点，称为冲刺或迭代。冲刺的结束应该产生一个增量且可发布的版本。这在复杂项目中很有用，因为很难规划整个项目，或者由于项目的动态性质，很难预测接下来会发生什么。该方法采用增量迭代的方法来处理这项任务。有关进一步阅读，请参阅以下维基页面：[https://en.wikipedia.org/wiki/Agile_software_development](https://en.wikipedia.org/wiki/Agile_software_development)。
- en: '**Scrum**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scrum**'
- en: 'It is a product development methodology. It is a framework based on the agile
    development methodology for managing complex systems. It implements an incremental
    and iterative (sprints) strategy for product development. The following is the
    link to the wiki for further details: [https://en.wikipedia.org/wiki/Scrum_(software_development)](https://en.wikipedia.org/wiki/Scrum_(software_development)).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个产品开发方法。它是一个基于敏捷开发方法的框架，用于管理复杂系统。它实现了产品开发的增量迭代（冲刺）策略。以下链接是有关详细信息的维基页面：[https://en.wikipedia.org/wiki/Scrum_(software_development)](https://en.wikipedia.org/wiki/Scrum_(software_development))。
- en: Another strategy is to take up the refactoring task immediately after a major
    release. The customers just got what they were asking for. In the absence of any
    show-stopper bugs, you would typically find some free work cycles during this
    period. It is a good time for the next release planning and working on code refactoring
    tasks. This will vary from project to project. It depends on how actively the
    application is being developed, its size, architecture, and so on.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是在主要发布后立即进行重构任务。客户刚刚得到了他们所要求的东西。在没有任何阻止性错误的情况下，你通常会在这个期间找到一些空闲的工作周期。这是进行下一版发布规划和代码重构任务的好时机。这会因项目而异。它取决于应用程序的开发活跃度、大小、架构等因素。
- en: How to refactor?
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行重构？
- en: Now that we have seen what refactoring means, let's see how to do it. The first
    task is to identify the piece of trouble-making code, and then restructure it.
    The restructuring should not affect the external behavior of the code. At the
    same time, it should help make the developer's life easy by simplifying the internal
    machinery (the code). We will discuss some of the most commonly performed refactoring
    operations. To help understand these operations, we will use the UML-like representative
    blocks wherever appropriate.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了重构的含义，让我们看看如何进行它。首先的任务是识别那些制造麻烦的代码片段，然后对其进行重构。重构不应该影响代码的外部行为。同时，它应该通过简化内部机制（代码）来帮助开发者更容易地工作。我们将讨论一些最常见的重构操作。为了帮助理解这些操作，我们将在适当的地方使用类似UML的代表性块。
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Unified Modeling Language** (**UML**) representation. See [http://www.uml.org](http://www.uml.org).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言**（**UML**）表示。请参阅[http://www.uml.org](http://www.uml.org)。'
- en: Renaming
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名
- en: Imagine a developer introducing a new feature in the game *Attack of the Orcs*.
    Each hut has a secret box. Whenever a unit acquires a hut, the contents of the
    box are revealed to the new owner as a print statement. This developer has introduced
    a new method called `showStuff()` in the class `Hut`. However, the name used here
    is not intuitive. It is not clear whether it shows what is inside the box, or
    whether it gives some information about some other stuff in the hut. Renaming
    such methods is one of the simplest forms of code refactoring. You could rename
    it to something verbose, such as `show_box_contents` or `reveal_box_contents`.
    However, make sure you perform the renaming task thoroughly by renaming all the
    method calls as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位开发者在一个名为 *Orcs的攻击* 的游戏中引入了一个新功能。每个小屋都有一个秘密的盒子。每当一个单位获得小屋时，盒子的内容就会以打印语句的形式向新主人展示。这位开发者已经在
    `Hut` 类中引入了一个名为 `showStuff()` 的新方法。然而，这里使用的名称并不直观。不清楚它是显示盒子里的东西，还是提供了关于小屋中其他东西的一些信息。重命名这样的方法是代码重构最简单的形式之一。你可以将其重命名为更详细的名称，例如
    `show_box_contents` 或 `reveal_box_contents`。但是，确保你彻底执行重命名任务，包括重命名所有方法调用。
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Coding standards**:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码规范**：'
- en: This example brings forward an interesting topic, the Python coding standards.
    In case you have jumped straight to this chapter, read [Chapter 4](ch04.html "Chapter 4. Documentation
    and Best Practices"), *Documentation and Best Practices* that talks about the
    coding standards! These standards basically provide a coding style guide for Python
    programmers. Following these standards and defining your own guidelines for the
    project would help reduce such renaming tasks.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子提出了一个有趣的话题，Python编码规范。如果你直接跳到了这一章，请阅读[第4章](ch04.html "第4章. 文档和最佳实践") *文档和最佳实践*，它讨论了编码规范！这些规范基本上为Python程序员提供了一个编码风格指南。遵循这些规范并为项目定义自己的指南将有助于减少这样的重命名任务。
- en: Extracting
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取
- en: 'In [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications* we had a single script representing the game. We identified
    pieces of code that could be written as individual functions. The name of each
    function was chosen such that it represented what the function body was supposed
    to do. This is shown in the following code snippets:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 开发简单应用程序") *开发简单应用程序* 中，我们有一个代表游戏的单个脚本。我们识别出可以写成单独函数的代码片段。每个函数的名称都是根据函数体应该执行的操作来选择的。这在上面的代码片段中显示：
- en: '![Extracting](img/B05034_05_31.jpg)![Extracting](img/B05034_05_32.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![提取](img/B05034_05_31.jpg)![提取](img/B05034_05_32.jpg)'
- en: This refactoring operation is called function extraction. Likewise, you can
    group together relevant code fragments to extract a method within a class or extract
    a new class.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构操作被称为函数提取。同样，你可以将相关的代码片段组合在一起，在类中提取一个方法或提取一个新的类。
- en: Moving
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动
- en: In [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy!* we did yet another type of refactoring operation. Can you guess
    what it was? The application code was contained within a single file. We modularized
    it by moving each class to its own file, and updating the referenced code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 模块化、打包、部署！") *模块化、打包、部署!* 中，我们又进行了一种类型重构操作。你能猜到是什么吗？应用程序代码包含在一个单独的文件中。我们通过将每个类移动到自己的文件中，并更新引用的代码来对其进行模块化。
- en: Imagine you have a method of Class A, which is used mostly by various features
    in Class B. Depending on the nature of the problem, see if this method better
    fits in Class B than in the existing Class A. If it does, moving this method to
    Class B could be an option.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个类A的方法，这个方法主要被类B的各种功能使用。根据问题的性质，看看这个方法是否更适合在类B中而不是现有的类A中。如果是这样，将这个方法移动到类B中可能是一个选择。
- en: Pushing down
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向下推
- en: There is a new feature request. This time it is coming from Sir Foo!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新的功能请求。这次它来自Sir Foo！
- en: '![Pushing down](img/B05034_05_33.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![向下推](img/B05034_05_33.jpg)'
- en: 'The `Knight` and `OrcRider` are mounted units riding a horse and a wild boar-like
    creature respectively. You introduced a new method, `unmount`, in the superclass
    `AbstractGameUnit`. It gives them the ability to get off the animal they are riding:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knight` 和 `OrcRider` 分别是骑马和类似野猪的单位的骑乘单位。你在超类 `AbstractGameUnit` 中引入了一个新的方法
    `unmount`，它赋予它们从骑乘的动物上下来的能力：'
- en: '![Pushing down](img/B05034_05_34.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![向下推](img/B05034_05_34.jpg)'
- en: 'However, you have now introduced several other imaginary characters in the
    game. For a majority of the characters, the method has become irrelevant. Now
    it makes sense to push down the `unmount` method in the inheritance hierarchy
    to the subclasses where it is relevant. This is shown in the diagram that follows.
    The `unmount` method is moved to the subclasses `Knight` and `OrcRider`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你现在已经在游戏中引入了几个其他的虚构角色。对于大多数角色来说，这种方法已经变得不相关了。现在将`unmount`方法推到继承层次结构中的子类中，使其相关，是有意义的。这在下图中有所展示。`unmount`方法被移动到子类`Knight`和`OrcRider`中：
- en: '![Pushing down](img/B05034_05_35.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![向下移动](img/B05034_05_35.jpg)'
- en: Tip
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While pulling up (see the next heading) or pushing down type of refactoring
    simplifies things, it may not always serve its purpose. The `unmount` method was
    intended just as an illustration. The horse is associated with movement. One option
    is to define a move behavior here. For example, move using a horse, move using
    a wild boar, and so on. Another alternative is to define the unit types as mounted
    or unmounted. Refer to [Chapter 6](ch06.html "Chapter 6. Design Patterns"), *Design
    Patterns* on design patterns, which shows an elegant way to handle a similar situation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当向上拉（见下一标题）或向下推类型重构简化了事情，但它可能并不总是达到其目的。`unmount`方法只是作为一个示例。马与运动相关联。一个选项是在这里定义一个移动行为。例如，用马移动，用野猪移动，等等。另一个替代方案是定义单元类型为骑乘或未骑乘。参考[第6章](ch06.html
    "第6章。设计模式")，《设计模式》，它展示了处理类似情况的一种优雅方式。
- en: Pulling up
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向上拉
- en: It is the opposite of pushing down, where we use the inheritance principle.
    A subclass defines some functionality. The exact same method is defined in other
    subclasses. This method can be pulled up and defined in the superclass to make
    it available to all the subclasses.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与向下推相反的操作，我们使用继承原则。一个子类定义了一些功能。完全相同的方法在其他子类中定义。这个方法可以被拉上来并在超类中定义，使其对所有子类可用。
- en: Refactoring tools for Python
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python的重构工具
- en: 'There are tools that automate certain types of refactoring. For example, if
    you want to rename a method, the tool will rename it, and automatically update
    all the references to the method in the code. Here is a partial list of such tools:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以自动化某些类型重构。例如，如果你想重命名一个方法，该工具将重命名它，并自动更新代码中对该方法的全部引用。以下是一些此类工具的部分列表：
- en: '**Use a Python IDE**: Assuming you are using an IDE for Python application
    development, the most convenient option is to use the built-in features of the
    IDE to refactor the code. IDEs such as PyCharm provide a menu item for refactoring,
    and support the most frequently performed refactoring operations, like the ones
    discussed in previous sections.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Python IDE**：假设你正在使用IDE进行Python应用程序开发，最方便的选项是使用IDE内置的功能来重构代码。例如，PyCharm提供了重构的菜单项，并支持最常执行的重构操作，如前几节中讨论的。'
- en: '**Rope**: Rope is an open source library for refactoring Python code. If you
    are a fan of editors such as vim or emacs, plugins are available to integrate
    the refactoring feature in the editor. The library can be installed using pip.
    For more information, see the GitHub page [https://github.com/python-rope](https://github.com/python-rope).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绳索**：Rope是一个开源库，用于重构Python代码。如果你是vim或emacs等编辑器的粉丝，可以安装插件以在编辑器中集成重构功能。可以使用pip安装此库。有关更多信息，请参阅GitHub页面[https://github.com/python-rope](https://github.com/python-rope)。'
- en: '**Bicycle repair man**: This is another refactoring tool available for Python.
    The library can be installed using pip. Visit [https://pypi.python.org/pypi/bicyclerepair](https://pypi.python.org/pypi/bicyclerepair)
    for more information.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自行车修理工**：这是Python可用的另一个重构工具。可以使用pip安装此库。有关更多信息，请访问[https://pypi.python.org/pypi/bicyclerepair](https://pypi.python.org/pypi/bicyclerepair)。'
- en: Unit testing revisited
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试回顾
- en: Here is a quick recap of where we left the discussion on unit testing. The intention
    was to write a unit test for the functionality found in the non-public method,
    `AttackOfTheOrcs._occupy_huts`. One straightforward option was to call this method
    directly from the unit test. However, calling a non-public method is not considered
    best practice, so we started looking for alternatives. Another option was to refactor
    `AttackOfTheOrcs.play`, and use an extracted `public` method in the unit test.
    At this point, we took a detour from unit testing and learned the basics of refactoring.
    Now it is time to refactor `AttackOfTheOrcs.play` using the techniques we have
    just learned.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们之前关于单元测试讨论的快速回顾。我们的意图是为在非公共方法`AttackOfTheOrcs._occupy_huts`中找到的功能编写单元测试。一个直接的选择是从单元测试中直接调用此方法。然而，调用非公共方法不被认为是最佳实践，所以我们开始寻找替代方案。另一个选择是重构`AttackOfTheOrcs.play`，并在单元测试中使用提取的`public`方法。在这个时候，我们偏离了单元测试，学习了重构的基础。现在是我们使用刚刚学到的技术重构`AttackOfTheOrcs.play`的时候了。
- en: Refactoring for testability
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构以提高可测试性
- en: 'The source code for the game *Attack of the Orcs* gives enough opportunity
    for refactoring. The `play` method is shown next. The code comments are omitted
    for the sake of illustration:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏源代码《奥克之攻》提供了足够的重构机会。下面的代码展示了`play`方法。为了说明，省略了代码注释：
- en: '![Refactoring for testability](img/B05034_05_36.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![重构以提高可测试性](img/B05034_05_36.jpg)'
- en: 'The first part of the preceding code does some preparatory work to create the
    objects needed. It creates the `Knight` and the `Hut` instances, along with the
    objects that represent the hut occupants. Additionally, it prints some information
    on the game. As an initial refactoring, we will extract a new `public` method,
    as shown here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的前一部分做一些准备工作以创建所需的对象。它创建了`Knight`和`Hut`实例，以及代表小屋居住者的对象。此外，它还在游戏中打印了一些信息。作为一个初步的重构，我们将提取一个新的`public`方法，如下所示：
- en: '![Refactoring for testability](img/B05034_05_37.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![重构以提高可测试性](img/B05034_05_37.jpg)'
- en: The new method primarily improves code readability, and also makes it simpler
    to write a test.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法主要提高了代码的可读性，并简化了编写测试的难度。
- en: Tip
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As noted in the *Refactoring preamble* section, this is a toy problem. The refactoring
    strategy used here is to extract a new method for improved readability and testability.
    You could refactor this by some other means as well. For example, the setup code
    creates things such as the player and huts. May be you should also rename `_occupy_huts`
    to `create_huts`? Choices may vary, and so do the refactoring strategies. More
    than answering the question what is the best strategy to refactor here, this section
    mainly serves as an example of how refactoring could help simplify the task of
    writing a unit test.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*重构前言*章节所述，这是一个玩具问题。这里使用的重构策略是提取一个新的方法以提高可读性和可测试性。你也可以用其他方式重构。例如，设置代码创建了诸如玩家和小屋之类的对象。也许你应该也将`_occupy_huts`重命名为`create_huts`？选择可能各不相同，重构策略也是如此。本节不仅回答了在这里重构的最佳策略是什么的问题，而且主要作为一个示例，说明重构如何帮助简化编写单元测试的任务。
- en: This basic refactoring of the `play` method will enable writing a unit test
    for the `setup_game_scenario` method, which in turn, will help test the functionality
    in `_occupy_huts`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对`play`方法的基本重构将使得编写`setup_game_scenario`方法的单元测试成为可能，这反过来又有助于测试`_occupy_huts`中的功能。
- en: Fourth unit test – setup_game_scenario
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四个单元测试 – setup_game_scenario
- en: 'As discussed in the *Refactoring preamble* section, this test will verify the
    following things: (a) there are exactly five huts, and (b) the hut occupant is
    an instance of `AbstractGameUnit`, or of the type `None`.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*重构前言*章节所述，此测试将验证以下事项：(a)恰好有五个小屋，(b)小屋居住者是一个`AbstractGameUnit`的实例，或者是一个`None`类型的实例。
- en: 'This test is shown next. You can also find this test in the supporting code
    along with the other tests. See the `wargame/test/test_wargame.py` file. The code
    comments should make it self-explanatory:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试展示了这一点。你还可以在支持代码中找到这个测试以及其他测试。请参阅`wargame/test/test_wargame.py`文件。代码注释应该能够使代码自解释：
- en: '![Fourth unit test – setup_game_scenario](img/B05034_05_45.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![第四个单元测试 – setup_game_scenario](img/B05034_05_45.jpg)'
- en: 'Run the preceding unit test as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行前面的单元测试：
- en: '[PRE35]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Exercise
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Some exercises have already been suggested in various sections of this chapter.
    Try those exercises. For example, split the unit tests so that you have separate
    modules for testing functionality from different classes. Add more unit tests
    to improve the code coverage. Also, try running `nosetests` on the tests that
    we have already written.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各个部分已经提出了一些练习。尝试这些练习。例如，将单元测试拆分，以便你有单独的模块来测试不同类别的功能。添加更多单元测试以提高代码覆盖率。此外，尝试运行`nosetests`来测试我们已编写的测试。
- en: Refactoring and redesign exercise
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构和重新设计练习
- en: There are several low-hanging fruits for refactoring! Review the `AttackOfTheOrcs._occupy_huts`
    method. It creates hut objects, and puts an occupant in each of them. As the first
    step, you can rename it `create_huts`. The code in this method could be better
    written. It uses `if...else` conditions to decide which occupant to create. Although
    it works in this simple application, if you add other types of occupant (elves,
    dwarfs, wizards, and so on) it will become a maintenance headache.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构方面有几个低垂的果实！请审查`AttackOfTheOrcs._occupy_huts`方法。它创建了小屋对象，并将一个居住者在每个小屋中。作为第一步，你可以将其重命名为`create_huts`。这个方法中的代码可以写得更好。它使用`if...else`条件来决定创建哪个居住者。尽管在这个简单的应用中它可行，但如果添加其他类型的居住者（精灵、矮人、巫师等等），它将变成一个维护的头疼问题。
- en: 'What could we do here? One strategy is to let the `Hut` class manage the creation
    of the `occupant` object. The hut could ask a factory to randomly create an occupant.
    You will learn about the factory pattern in [Chapter 6](ch06.html "Chapter 6. Design
    Patterns"), *Design Patterns*. Since we are looking at this as a refactoring problem,
    you could try the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里能做什么？一种策略是让`Hut`类管理`occupant`对象的创建。小屋可以要求工厂随机创建一个居住者。你将在[第6章](ch06.html
    "第6章。设计模式")*设计模式*中学习关于工厂模式的内容。由于我们将这个问题视为一个重构问题，你可以尝试以下方法：
- en: Change the signature of `Hut.__init__` so that you can optionally specify the
    `occupant`.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`Hut.__init__`的签名，以便你可以选择指定`occupant`。
- en: Inside the `Hut` class, create an `occupant` (if not already available) by calling
    a new utility function, `create_unit`. You will need to write this new utility
    function (the solution is not provided). The function should not be a method of
    the class `Hut`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Hut`类内部，通过调用一个新的实用函数`create_unit`来创建一个`occupant`（如果尚未创建）。你需要编写这个新的实用函数（解决方案未提供）。这个函数不应是`Hut`类的一个方法。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The chapter started by emphasizing the need for testing. It introduced you to
    the unit testing framework in Python. You learned how to write and execute unit
    tests. The next topic served as an introduction to Python mock library. The chapter
    demonstrated the use of `Mock` objects in unit tests. Next, it showed an example
    where it was difficult to write a unit test without refactoring the code first.
    At this point, you learned the basics of refactoring, refactored the code, and
    then developed a unit test for this example.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章开始强调了测试的需要。它介绍了Python中的单元测试框架。你学习了如何编写和执行单元测试。下一个主题是Python模拟库的介绍。章节展示了在单元测试中使用`Mock`对象。接下来，它展示了在没有先重构代码的情况下难以编写单元测试的例子。在这个时候，你学习了重构的基本知识，重构了代码，然后为这个例子开发了一个单元测试。
- en: During development, you often encounter a recurring problem. Often, a general
    solution (or a recipe) exists that works for this problem. This is often referred
    to as a design pattern. In the next chapter, we will review a few commonly used
    design patterns in Python.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你经常会遇到一个反复出现的问题。通常，存在一个通用的解决方案（或配方）适用于这个问题。这通常被称为设计模式。在下一章中，我们将回顾Python中一些常用的设计模式。
