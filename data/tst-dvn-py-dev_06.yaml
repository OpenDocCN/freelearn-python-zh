- en: Chapter 6. Maintaining Your Test Suite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 维护您的测试套件
- en: If we do TDD regularly, we can easily end up with a large test suite containing
    thousands of tests. This is great—it gives us a lot of confidence to boldly go
    in and add new features without worrying about breaking old features. However,
    it is crucial that we make test maintenance easy, otherwise we will soon be in
    a mess just managing the tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定期进行TDD，我们可能会很容易地拥有一个包含数千个测试的大测试套件。这很好——它给了我们很大的信心，大胆地添加新功能而不用担心破坏旧功能。然而，我们使测试维护变得容易是至关重要的，否则我们很快就会陷入仅仅管理测试的混乱之中。
- en: Tests that are not written to be maintained will soon bring about a number of
    headaches. Tests that are strewn all over the filesystem will make it impossible
    to locate specific tests. Tests that are difficult to read will be hard to understand
    and fix when the tests need to be changed due to changes in functionality. Long,
    poorly written tests will pose the same challenges that poor production quality
    code does. And brittle tests will ensure that even small changes will break a
    large number of tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编写为维护的测试很快就会带来许多头疼问题。散布在文件系统中的测试将使得定位特定测试变得不可能。难以阅读的测试在测试需要因功能更改而更改时，理解和修复将变得困难。长而编写不佳的测试将带来与低质量生产代码相同的问题。脆弱的测试将确保即使是微小的更改也会破坏大量测试。
- en: Remember that test code is still code. And just like any production code, we
    must do our best to keep it readable, maintainable, and easy to change. It is
    easy for us to fall into the trap of hacking out test cases and then forgetting
    about them. A year later, we find that maintaining the tests is a huge headache,
    and it is more difficult to add new features than it was before.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试代码仍然是代码。就像任何生产代码一样，我们必须尽力保持其可读性、可维护性和易于更改。我们很容易陷入编写测试用例后忘记它们的陷阱。一年后，我们发现维护测试是一个巨大的头疼问题，添加新功能比以前更困难。
- en: Goals of test maintenance
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试维护的目标
- en: 'As we have seen throughout this book, unit tests serve a number of different
    purposes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中看到的那样，单元测试服务于多种不同的目的：
- en: '**Serve as a test suite**: This is the most obvious goal of unit tests. A comprehensive
    test suite reduces the number of bugs that can escape into production.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为测试套件**：这是单元测试最明显的目标。一个全面的测试套件可以减少可能逃逸到生产环境的错误数量。'
- en: '**Serve as documentation**: When we are trying to understand what a class or
    method is trying to do, it is useful to take a look at the test suite. A well-written
    test suite will illustrate how the piece of code is supposed to behave.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为文档**：当我们试图了解一个类或方法试图做什么时，查看测试套件是有用的。一个编写良好的测试套件将说明代码片段应该如何表现。'
- en: '**Serve as a safety net**: This frees us from pressure when we refactor or
    clean up the code.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为安全网**：这使我们重构或清理代码时的压力得以释放。'
- en: '**Illustrate the design**: Using mocks, we can depict the interactions between
    different classes or modules.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示设计**：使用模拟，我们可以描绘不同类或模块之间的交互。'
- en: The goal of a well-written suite of unit tests is to enable these purposes as
    well as possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一套编写良好的单元测试的目标是尽可能实现以下目的。
- en: 'For example, if we want to understand what a method does, then we need to work
    out the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想了解一个方法的作用，那么我们需要考虑以下问题：
- en: Can we locate its unit test suite easily?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否轻松地找到它的单元测试套件？
- en: Once located, is it easy to understand the tests and what they are testing for?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦找到，理解测试及其测试内容是否容易？
- en: Can we understand how this method interacts with other classes?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否理解这个方法如何与其他类交互？
- en: Once we understand what the method does, then is it easy to refactor it? Does
    making small refactorings break all the tests?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们了解了方法的作用，那么重构它是否容易？进行小的重构是否会破坏所有测试？
- en: Is it easy to identify which tests have broken due to our refactoring and which
    failures are bugs in the refactoring?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否容易识别由于我们的重构而失败的测试，以及哪些失败是重构中的错误？
- en: If we need to make changes in the test case due to the refactoring, then how
    difficult is it to understand the test and make the required change?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果因为重构需要修改测试用例，那么理解测试并做出所需更改有多困难？
- en: Any large, long-term project will involve answering all these questions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大型、长期项目都将涉及回答所有这些问题。
- en: Our goal in this chapter is to look at ways to make it easier to perform the
    preceding activities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中的目标是探讨使执行上述活动更容易的方法。
- en: Organizing tests
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试
- en: 'The first step in easing test maintenance is to have a systematic way of organizing
    tests. When we are implementing a new feature, we need to be able to quickly and
    easily locate the existing test code for a given method or class. There are three
    steps to making this easy. We have to decide:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简化测试维护的第一步是有一个系统化的测试组织方式。当我们实现一个新功能时，我们需要能够快速轻松地找到给定方法或类的现有测试代码。为此，有三个步骤。我们必须决定：
- en: Where the files are stored on the filesystem
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件在文件系统中的存储位置
- en: What the files are called
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件被称为什么
- en: The names of the test classes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类的名称
- en: Filesystem layout
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统布局
- en: 'The main consideration in deciding where to place our test code is the ease
    with which we can locate the tests for a specific class or module. Apart from
    this, there are two other considerations to keep in mind:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将我们的测试代码放在哪里的主要考虑因素是，我们能够多容易地找到特定类或模块的测试。除此之外，还有两个其他考虑因素要记住：
- en: How will this module be packaged and distributed?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模块将如何打包和分发？
- en: How will this code be put into production?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码将如何投入生产？
- en: For the first consideration, we have to keep in mind that we will want to distribute
    unit tests along with the main code. For code that goes into production, we might
    not always want tests to be deployed, so we would be looking at a way to separate
    the code and tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个考虑因素，我们必须记住，我们希望将单元测试与主代码一起分发。对于投入生产的代码，我们可能并不总是希望部署测试，因此我们正在寻找一种将代码和测试分离的方法。
- en: Given all these considerations, there are two popular ways of laying out the
    test code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，有两种流行的测试代码布局方式。
- en: 'In the first pattern, the test code is placed as a submodule of the main code
    like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种模式中，测试代码被放置在主代码的子模块中，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This allows us to package up both the module and the tests by just zipping up
    the module directory and putting it in an `egg` file. The whole package is self-contained
    and can be used directly. The module is accessed using an `import module` statement,
    and the tests are accessed by using `import module.tests`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过仅压缩模块目录并将其放入`egg`文件中来打包模块和测试。整个包是自包含的，可以直接使用。模块通过`import module`语句访问，测试通过使用`import
    module.tests`访问。
- en: Running the tests also requires no configuration, as the tests can access the
    classes in the test code with relative imports such as `from ..file import class`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试也不需要配置，因为测试可以通过相对导入（如`from ..file import class`）访问测试代码中的类。
- en: This pattern is excellent for standalone modules that will be packaged in `egg`
    files and distributed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常适合将独立模块打包成`egg`文件并分发。
- en: 'The other pattern is to keep tests in a separate folder hierarchy altogether.
    The file layout will be something like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模式是将测试保留在完全独立的文件夹层次结构中。文件布局可能如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding pattern is suitable for situations where there is a need to separate
    out the tests from the code. This could be because we are making a product and
    don't want to send tests to our customers, or it could be because we don't want
    to deploy tests to the production servers. This pattern is suitable because it
    is easy to zip up the module alone into an `egg` file and deploy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模式适用于需要将测试从代码中分离出来的情况。这可能是因为我们正在制作一个产品，不希望向客户发送测试，或者可能是因为我们不希望将测试部署到生产服务器。这种模式适合，因为它很容易将模块单独压缩成`egg`文件并部署。
- en: 'The downside of the pattern is that if the project involves many modules, then
    it can be troublesome to separate out tests for the different modules. One pattern
    is to use different roots for each directory, as shown in the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点是，如果项目涉及许多模块，那么分离不同模块的测试可能会很麻烦。一种模式是使用每个目录的不同根，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding pattern is commonly seen in languages such as Java, but it is
    overall quite cumbersome and verbose. However, it could be a solution for specific
    needs like the ones mentioned previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模式在Java等语言中很常见，但总体来说相当繁琐且冗长。然而，它可能是解决前面提到的特定需求的一种解决方案。
- en: 'Two patterns we definitely *don''t* want to do are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对不想做的两种模式如下：
- en: Place the tests in the same file as the code
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试放在与代码相同的文件中
- en: Place the test files in the same directory as the code
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试文件放在与代码相同的目录中
- en: Placing tests in the same file as code is okay for single file scripts, but
    it is messy for anything bigger than that. The problem is that if the file is
    long, then it becomes very difficult to navigate the file. And since tests often
    need to import other classes, it pollutes the namespace. It also increases the
    chances for circular imports. Finally, it makes it difficult to execute all the
    tests at once because the test runners look for patterns in the filename.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试放在与代码相同的文件中对于单文件脚本来说是可行的，但对于更大的项目来说则显得杂乱无章。问题是如果文件很长，那么在文件中导航就变得非常困难。而且由于测试通常需要导入其他类，这会污染命名空间。它还增加了循环导入的可能性。最后，由于测试运行器会在文件名中寻找模式，这使得一次性执行所有测试变得困难。
- en: As for placing files in the same directory, it once again messes up the module,
    making it difficult to find files in the directory. It doesn't have any specific
    advantages apart from not having to create a separate tests directory. Avoid this
    pattern and create a submodule instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 至于将文件放在同一个目录中，这又一次打乱了模块，使得在目录中查找文件变得困难。除了不需要创建单独的测试目录之外，它没有任何特定的优势。避免这种模式，而是创建一个子模块。
- en: Naming conventions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: The next step is to decide on a naming convention for test files, test classes,
    and test methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定测试文件、测试类和测试方法的命名约定。
- en: For test files, it is best to go with the `test_` prefix for the file. For example,
    a file called `file1.py` will have its tests in `test_file1.py`. This makes it
    easy for us to locate the corresponding test code when we are looking at some
    production code. Having the `test_` prefix is preferable because this is the default
    pattern that is searched by most test runners. If we use some other prefix, or
    use a suffix like `file1_test.py`, then most probably we will have to pass additional
    configuration into the test runner to find and execute the tests. This extra configuration
    is easily avoidable by just sticking to the default convention that is expected
    from most of the commonly used tools.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试文件，最好使用`test_`前缀。例如，名为`file1.py`的文件将会有其测试在`test_file1.py`中。这使得我们在查看生产代码时能够轻松地找到相应的测试代码。使用`test_`前缀是首选的，因为这是大多数测试运行器搜索的默认模式。如果我们使用其他前缀，或者使用后缀如`file1_test.py`，那么我们很可能需要将额外的配置传递给测试运行器以找到和执行测试。通过坚持大多数常用工具期望的默认约定，我们可以轻松避免这种额外的配置。
- en: 'For example, we can run the tests with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下命令来运行测试：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But if we were to name our tests with a suffix of `_test`, then we have to
    use the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想要用后缀`_test`来命名我们的测试，那么我们必须使用以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It works, but it is just extra configuration that can be avoided. We should
    use this only if we have a legacy naming convention that needs to be preserved.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它是可行的，但这只是可以避免的额外配置。我们只有在需要保留旧命名约定的情况下才应该使用它。
- en: What about test classes and test methods? The `unittest` module looks at all
    classes that inherit from `unittest.TestCase`. So, the class name does not matter.
    However, other test runners such as `nose2` also pick up test classes based on
    the name of the class. The default pattern is to search for classes that end with
    `Test`. It therefore makes sense to name all the test classes to end with `Test`.
    It is also descriptive, so there really is no good reason to do anything else.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于测试类和测试方法呢？`unittest`模块会查看所有继承自`unittest.TestCase`的类。因此，类的名称并不重要。然而，其他测试运行器，如`nose2`，也会根据类的名称来选择测试类。默认模式是搜索以`Test`结尾的类。因此，将所有测试类命名为以`Test`结尾是有意义的。这也很有描述性，所以实际上没有很好的理由去做其他的事情。
- en: Similarly, test methods should start with `test`. This is the default pattern
    that test runners search for, and once again it makes sense to just stick to this
    convention. Methods that do not start with `test` can be used as helper methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，测试方法应该以`test`开头。这是测试运行器搜索的默认模式，因此坚持这个约定是有意义的。不以`test`开头的方法可以用作辅助方法。
- en: Test suite grouping
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试套件分组
- en: Finally, we come to the question of what a class should contain—should one test
    class contain tests for a target class, or should we store all the tests for a
    method in a test class? Here, it is more a question of personal preference. Neither
    is objectively better or worse, it just depends on which is more readable. My
    personal preference is to use both patterns within a single codebase, depending
    on how many tests there are and which pattern makes it easier to find the tests
    that I am looking for. In general, if there are a lot of tests for a single method,
    then I would refactor them into a separate test class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了一个关于一个类应该包含什么的问题——一个测试类是否应该包含目标类的测试，或者我们应该将所有方法的测试都存储在一个测试类中？在这里，这更多的是一个个人偏好的问题。两者在客观上没有好坏之分，只是取决于哪个更易读。我个人的偏好是在单个代码库中使用这两种模式，根据测试的数量和哪种模式更容易找到我正在寻找的测试。一般来说，如果一个方法有很多测试，那么我会将它们重构到一个单独的测试类中。
- en: Making tests readable
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试可读
- en: In the previous section, we looked at the rather mundane issue of file layout
    and naming conventions. We are now going to take a look at the ways we can improve
    the test cases themselves.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了相对平凡的问题，即文件布局和命名约定。我们现在将探讨我们可以改进测试用例本身的方法。
- en: Our first goal is to make it easier to understand the tests themselves. There
    is nothing worse than locating a test case and then having a hard time figuring
    out what the test is trying to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是使理解测试本身变得更简单。没有什么比找到测试用例然后很难弄清楚测试试图做什么更糟糕的了。
- en: I'm sure I will not be the first to confess that there have been multiple occasions
    where I have returned to a test that I myself wrote a year back, and struggled
    to understand what I was trying to do.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我不会是第一个承认自己多次回到一年前自己写的测试，并努力理解自己当时试图做什么的人。
- en: This is an area that is often ignored because when we write the test, it seems
    perfectly obvious what the test does. We will need to put ourselves in the shoes
    of someone who is looking at the test for the first time or after a couple of
    years and trying to understand the test without having the contextual knowledge
    that we had while writing the test. This is a recurring problem when working on
    large codebases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个被忽视的领域，因为当我们编写测试时，似乎很明显测试在做什么。我们需要设身处地地想象自己是一个第一次或几年后查看测试的人，试图在没有我们编写测试时的上下文知识的情况下理解测试。这是在处理大型代码库时经常出现的问题。
- en: Using docstrings
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文档字符串
- en: The first line of defense for an unreadable test is to use a docstring. **Docstrings**
    are a great feature of Python because they are available at runtime. Test runners
    typically pick up a docstring and display it during test errors and failures,
    making it easy to see what is failing from the test report itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个难以阅读的测试，第一道防线是使用文档字符串。**文档字符串**是Python的一个伟大特性，因为它们在运行时可用。测试运行器通常会拾取文档字符串，并在测试错误和失败时显示它们，这使得从测试报告中直接看到失败内容变得容易。
- en: 'Some people will say that a well-written test has no need for additional explanation.
    In fact, we said something similar in [Chapter 3](ch03.html "Chapter 3. Code Smells
    and Refactoring"), *Code Smells and Refactoring* when we discussed the value of
    comments. To repeat what we said there: there is no value in comments that explain
    what is going on, but there is value in comments that explain why we have implemented
    the code as we have. The same principle applies to docstrings as well.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会说，一份写得好的测试不需要额外的解释。实际上，我们在[第3章](ch03.html "第3章。代码异味和重构")*代码异味和重构*中讨论注释的价值时，也说过类似的话。为了重复我们当时的话：解释正在发生什么的注释没有价值，但解释为什么我们以这种方式实现代码的注释是有价值的。同样的原则也适用于文档字符串。
- en: 'For example, take a look at the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下代码：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the `get_closing_price_list` method from the `TimeSeries` class that
    we refactored in [Chapter 3](ch03.html "Chapter 3. Code Smells and Refactoring"),
    *Code Smells and Refactoring*. The following is a test for that method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`TimeSeries`类的`get_closing_price_list`方法，我们在[第3章](ch03.html "第3章。代码异味和重构")*代码异味和重构*中对其进行了重构。以下是对该方法的测试：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This test checks that an empty list is returned when the date passed is before
    the start of the timeseries. This is quite clear from the test. But why does it
    return an empty list instead of, say, throwing an exception? A docstring provides
    a good place to explain this design decision, as shown in the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试检查，如果传递的日期早于时间序列的开始，则返回空列表。从测试中可以清楚地看出这一点。但为什么它返回空列表而不是抛出异常呢？文档字符串是解释这种设计决策的好地方，如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using fixtures
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定装置
- en: Having looked at docstrings, we can now turn our attention to the tests themselves.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看文档字符串后，我们现在可以将注意力转向测试本身。
- en: If we look at the general structure of unit tests, they generally follow the
    Arrange-Act-Assert structure. Of these, the Act section is usually only a couple
    of lines and the Assert section is also a few lines at most. By far the biggest
    part of the test is in the Arrange section. For more complex tests, where a specific
    scenario might take many lines to set up, the Arrange section could easily be
    75 percent to 80 percent of the whole test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看单元测试的一般结构，它们通常遵循安排-行动-断言的结构。在这些中，行动部分通常只有几行，断言部分最多也只有几行。到目前为止，测试的最大部分是在安排部分。对于更复杂的测试，其中特定场景可能需要多行来设置，安排部分可能占整个测试的75%到80%。
- en: 'One way of avoiding repetitive code is to move it all into the appropriate
    `setUp` and `tearDown` methods. As we saw in [Chapter 2](ch02.html "Chapter 2. Red-Green-Refactor
    – The TDD Cycle"), *Red-Green-Refactor – The TDD Cycle*, `unittest` provides three
    levels of setup and teardown methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 避免重复代码的一种方法是将所有内容都移动到适当的`setUp`和`tearDown`方法中。正如我们在[第2章](ch02.html "第2章。红-绿-重构
    – TDD循环")中看到的，“红-绿-重构 – TDD循环”，`unittest`提供了三个级别的设置和清理方法：
- en: '`setUp` and `tearDown` that are run before and after each test'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试之前和之后运行的`setUp`和`tearDown`
- en: '`setUpClass` and `tearDownClass` that are run before and after each test class'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试类之前和之后运行的`setUpClass`和`tearDownClass`
- en: '`setUpModule` and `tearDownModule` that are run before and after each test
    file'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试文件之前和之后运行的`setUpModule`和`tearDownModule`
- en: 'This method of setting up the data for a test is called a **fixture**. Using
    fixtures is a good idea to reduce common code duplication between tests. However,
    there are some downsides to be aware of:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种为测试设置数据的方法被称为**固定装置**。使用固定装置可以减少测试之间的代码重复，这是一个好主意。然而，也有一些需要注意的缺点：
- en: Sometimes, there is a lot of setup to be done, but each of the tests only use
    a small part of the overall fixture. In this case, it can be confusing for a new
    developer to figure out which part of the fixture is used by each test.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，需要做很多设置，但每个测试只使用整体固定装置的一小部分。在这种情况下，对于新开发者来说，弄清楚每个测试使用固定装置的哪一部分可能会很困惑。
- en: We have to be careful when using class- and module-level fixtures. Because the
    fixture is shared between multiple tests, we have to be careful that we don't
    change the state of the fixture. If we do, then there is the possibility that
    the result of one test could alter the fixture state for the next. This could
    lead to very strange bugs when tests are executed in a different order.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类和模块级别的固定装置时，我们必须小心。因为固定装置在多个测试之间共享，我们必须小心不要改变固定装置的状态。如果我们这样做，那么一个测试的结果可能会改变下一个测试的固定装置状态。这可能导致在执行顺序不同时出现非常奇怪的错误。
- en: 'One thing to be aware of is that if the `setUp` method throws an exception,
    then the `tearDown` method is not called. Take the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，如果`setUp`方法抛出异常，则不会调用`tearDown`方法。以下是一个示例：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If an exception is raised in the `connect_to_server` call, then the `tearDown`
    method will not be called. This will leave the connection to the database hanging
    open. When `setUp` is called for the next test, the first line might fail (because
    the connection is already open), causing all the other tests to fail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`connect_to_server`调用中抛出异常，则不会调用`tearDown`方法。这将导致数据库连接保持打开状态。当为下一个测试调用`setUp`时，第一行可能会失败（因为连接已经打开），导致所有其他测试失败。
- en: 'To avoid this situation, the `unittest` module provides the `addCleanup` method.
    This method takes a callback function, which is called no matter whether the setup
    passed or failed, as shown in the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，`unittest`模块提供了`addCleanup`方法。此方法接受一个回调函数，无论设置是否通过都会调用，如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this structure, how execution will flow is given as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，执行流程如下：
- en: If the database call failed, then no cleanup will be performed
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据库调用失败，则不会执行清理操作
- en: If the database call succeeded but the server call failed, then `disconnect_database`
    will be called during cleanup
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据库调用成功了但服务器调用失败了，那么在清理过程中将调用`disconnect_database`。
- en: If both calls succeeded, then both `disconnect_database` and `disconnect_server`
    will be called during cleanup
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个调用都成功了，那么在清理过程中将调用`disconnect_database`和`disconnect_server`。
- en: When would we use `addCleanup` versus `tearDown`? In general, when accessing
    resources that must be closed, `addCleanup` is the way to go. `tearDown` is a
    good place to put other types of cleanup, or in cases where `setUp` cannot throw
    an exception.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在什么时候使用`addCleanup`而不是`tearDown`？一般来说，当我们访问必须关闭的资源时，`addCleanup`是最佳选择。`tearDown`是一个放置其他类型清理的好地方，或者在`setUp`无法抛出异常的情况下。
- en: Fixtures and patching
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定和打补丁
- en: 'There is one complication in using patched mocks along with fixtures. Take
    a look at the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用打补丁的模拟和固定一起使用时，有一个复杂的问题。看看以下代码：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is one of the tests for the `EmailAction` class that we looked at earlier.
    The `patch` decorator is used at a class level to patch the `smtplib.SMTP` class
    and pass the mock as a parameter to all the test cases. Because of the way the
    patch decorator works, it only passes the mock to the test case methods, which
    means that we cannot access it in our `setUp` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前我们查看的`EmailAction`类的一个测试。在类级别使用`patch`装饰器来打补丁`smtplib.SMTP`类，并将模拟对象作为参数传递给所有测试用例。由于`patch`装饰器的工作方式，它只将模拟对象传递给测试用例方法，这意味着我们无法在`setUp`方法中访问它。
- en: If we look at this test, it uses the `mock_smtp` object, which is derived from
    `mock_smtp_class`. The line that gets the `mock_smtp` object can be moved into
    the `setUp` method, if only we could access `mock_smtp_class` over there. Is there
    a way by which we can apply the patch in the `setUp` method so that we can do
    some common setup with the mock?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看这个测试，它使用了从`mock_smtp_class`派生的`mock_smtp`对象。获取`mock_smtp`对象的行可以移动到`setUp`方法中，如果我们能访问到`mock_smtp_class`的话。有没有一种方法可以在`setUp`方法中应用补丁，这样我们就可以做一些常见的设置了？
- en: 'Fortunately, the `unittest` module gives us the tools to do just this. Instead
    of using the decorator syntax for patching, we will use the regular object syntax
    like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`unittest`模块为我们提供了完成这项任务的工具。我们不会使用装饰器语法来打补丁，而是会使用以下类似的常规对象语法：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What we are doing here is passing the object to be patched—in this case `smtplib.SMTP`—to
    the `patch` function. This returns a patcher object with two methods: `start`
    and `stop`. When we call the `start` method, the patch is applied, and when we
    call the `stop` method, the patch is removed.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将需要打补丁的对象——在这种情况下是`smtplib.SMTP`——传递给`patch`函数。这返回一个具有两个方法：`start`和`stop`的补丁器对象。当我们调用`start`方法时，补丁被应用，当我们调用`stop`方法时，补丁被移除。
- en: We set the `patcher.stop` method to be executed during the test cleanup phase
    by passing it to the `addCleanup` function. We then start the patch. The `start`
    method returns the mock object, which we use for the rest of the setup.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将其传递给`addCleanup`函数来设置`patcher.stop`方法在测试清理阶段执行。然后我们开始打补丁。`start`方法返回模拟对象，我们将其用于剩余的设置。
- en: 'With this setup, we can use `self.mock_smtp` directly in our tests, without
    having to get it from `mock_smtp_class` in every test. The test would now look
    like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以在测试中直接使用`self.mock_smtp`，而无需在每次测试中都从`mock_smtp_class`获取它。现在的测试看起来如下：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compare this test with the one earlier in this section. Since we are not using
    the decorator patch syntax, we no longer need the extra parameter. We also don't
    need to derive `mock_smtp` from `mock_smtp_class` in every test. Instead, all
    that work is done in `setUp`. The test can then access `self.mock_smtp` and use
    it directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个测试与这一节中较早的测试进行比较。由于我们不再使用装饰器补丁语法，我们不再需要额外的参数。我们也不需要在每个测试中都从`mock_smtp_class`派生`mock_smtp`。相反，所有这些工作都在`setUp`中完成。然后测试可以访问`self.mock_smtp`并直接使用它。
- en: Using a custom test case class hierarchy
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义测试用例类层次结构
- en: 'One more way of reducing code duplication is to create our own test class hierarchy.
    For example, if a helper method is used often in many test classes, then we can
    pull it up to a higher class and inherit test classes from that instead. The following
    is an example to make the concept clearer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 减少代码重复的另一种方法是我们创建自己的测试类层次结构。例如，如果一个辅助方法在许多测试类中经常被使用，那么我们可以将它提升到更高一级的类中，并从该类继承测试类。以下是一个使概念更清晰的示例：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we create a class called `MyTestCase` that inherits from `unittest.TestCase`,
    and we put in some helper methods in this class. The actual test classes inherit
    from `MyTestCase` and can access the helper methods that are in the parent class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`MyTestCase`的类，它继承自`unittest.TestCase`，并在该类中放入了一些辅助方法。实际的测试类继承自`MyTestCase`，可以访问父类中的辅助方法。
- en: Using this technique, we can take common groups of helper methods and put them
    into reusable parent classes. The hierarchy need not be only one level deep; sometimes,
    we might create further subclasses for specific areas of the application that
    we are testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以将常见的辅助方法组合放入可重用的父类中。层次结构不必只有一层深；有时，我们可能需要为测试的具体应用区域创建更进一步的子类。
- en: Writing tests closer to the domain
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在领域附近编写测试
- en: The other way to make tests easier to read is to write tests in terms of the
    domain language instead of just the generic functions provided by `unittest`.
    In this section, we look at some ways to do this.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使测试更容易阅读的另一种方法是使用领域语言编写测试，而不是仅仅使用`unittest`提供的通用函数。在本节中，我们将探讨一些实现这一目标的方法。
- en: Writing helper methods
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写辅助方法
- en: 'The first technique is to write helper methods. We employed this technique
    earlier in this book. The following are some tests that don''t use a helper method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术是编写辅助方法。我们在本书中较早地使用了这种方法。以下是一些没有使用辅助方法的测试用例：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While the tests are short, it isn''t really clear what is happening in the
    tests. Let''s move some of that code into a helper method, as shown in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试用例很短，但测试中实际发生的事情并不清晰。让我们将其中一些代码移动到辅助方法中，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following are the same two tests using the new helper method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用新辅助方法编写的相同两个测试用例：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the tests are a lot clearer now. This is because the helper method
    clearly expresses the intent of the calculation, making it easy for a new developer
    to correlate the steps in the test case with their mental model of the requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，测试现在清晰多了。这是因为辅助方法清楚地表达了计算的意图，使得新开发者能够将测试用例中的步骤与他们对需求的心理模型相对应。
- en: Writing better asserts
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更好的断言
- en: 'An easy way to enhance test readability is to write our own assert methods
    that are higher level than the generic asserts provided by `unittest`. For example,
    suppose we wanted to write a test to verify the price history of a stock. The
    following is how such a test might look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 提高测试可读性的简单方法是编写我们自己的断言方法，这些方法比`unittest`提供的通用断言级别更高。例如，假设我们想要编写一个测试来验证股票的价格历史。以下是这样测试可能看起来：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, another way to write the test is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写测试的另一种方式如下：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we have created our own base test class and with a
    custom assert method. The test case inherits from this base test class and uses
    the assert in the test.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了自己的基测试类和一个自定义的断言方法。测试用例继承自这个基测试类，并在测试中使用这个断言。
- en: The implementation of the `assert_has_price_history` method gives an idea of
    how simple it is to write our own assert methods. All we have to do is to implement
    our assertion logic, and raise `self.failureException` whenever the assert should
    signal a test failure. `self.failureException` is an attribute of `unittest.TestCase`,
    and it is usually set to the `AssertionError` exception. We could raise `AssertionError`
    ourselves, but the `unittest` module allows us to configure using a different
    exception, so it is best to raise `self.failureException`, which is always set
    to the correct value to be used.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_has_price_history`方法的实现给出了一种如何简单编写我们自己的断言方法的思路。我们只需实现我们的断言逻辑，并在断言应该表示测试失败时引发`self.failureException`。`self.failureException`是`unittest.TestCase`的一个属性，通常设置为`AssertionError`异常。我们可以自己引发`AssertionError`，但`unittest`模块允许我们使用不同的异常进行配置，因此最好引发`self.failureException`，它总是设置为正确的值用于使用。'
- en: When the same sequence of asserts is made again and again in multiple tests,
    we should see whether there is an opportunity to replace the calls to the built-in
    asserts with a higher level assert that more clearly expresses the intent that
    we want to convey.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多个测试中反复使用相同的断言序列时，我们应该看看是否有机会用更清晰地表达我们意图的高级断言来替换内置断言的调用。
- en: Using custom equality checkers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义的相等性检查器
- en: 'A cool feature of the `assertEqual` method is the way it gives custom failure
    messages depending on the type of object being compared. If we try to assert two
    integers, the following is what we get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEqual` 方法的酷特性是它根据被比较的对象类型给出自定义的失败消息。如果我们尝试断言两个整数，我们会得到以下结果：'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the other hand, asserting lists gives us another message showing the difference
    in the expected and actual lists, as shown in the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，断言列表会给我们另一个消息，显示预期列表和实际列表之间的差异，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Under the hood, `assertEqual` delegates to a different function depending on
    the type of object being compared. This is how we get specific and relevant equality
    checks for most common built-in data structures such as strings, sequences, lists,
    tuples, sets, and dicts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`assertEqual` 根据被比较的对象类型委托给不同的函数。这就是我们如何为大多数常见的内置数据结构（如字符串、序列、列表、元组、集合和字典）获得具体和相关的相等性检查。
- en: 'Fortunately, this flexible system is open to use by developers, which means
    we can add our own equality checkers for our application objects. The following
    is a default scenario where we try to compare two `Stock` objects:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个灵活的系统对开发者开放，这意味着我们可以为我们的应用程序对象添加自己的相等性检查器。以下是我们尝试比较两个 `Stock` 对象的默认场景：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The assertion fails because although both objects contain the same data, they
    are still different objects in memory. Now let''s try to register our own equality
    function for the `Stock` class that just compares the symbol to identify equality
    between `Stock` objects. All we have to do is to register our checker using the
    `addTypeEqualityFunc` method like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 断言失败，因为尽管两个对象包含相同的数据，但在内存中它们仍然是不同的对象。现在让我们尝试为 `Stock` 类注册我们自己的相等性函数，该函数仅比较符号以识别
    `Stock` 对象之间的相等性。我们只需使用 `addTypeEqualityFunc` 方法注册我们的检查器，如下所示：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The equality checker takes three parameters: the first object, the second object,
    and the optional message that the user passed to `assertEqual`. Once we register
    the function like this, we can call `assertEqual` passing in two `Stock` objects
    and `assertEqual` will delegate the comparison to the function that we registered.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 检查相等性的函数接受三个参数：第一个对象、第二个对象以及用户传递给 `assertEqual` 的可选消息。一旦我们以这种方式注册了函数，我们就可以调用
    `assertEqual` 并传入两个 `Stock` 对象，`assertEqual` 将将比较委托给我们所注册的函数。
- en: 'Using equality functions this way is a nice way to assert application domain
    objects in the unit test code. This method has two limitations though:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用相等性函数是断言单元测试代码中应用域对象的一种好方法。尽管如此，这种方法有两个限制：
- en: We have to use the same comparison function for a given type. There is no way
    to use one comparison function in some tests and another comparison function in
    other tests.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须为给定类型使用相同的比较函数。我们无法在某些测试中使用一个比较函数，而在其他测试中使用另一个比较函数。
- en: Both parameters to `assertEqual` have to be objects of that type. There is no
    way we can pass in two objects of differing types.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual` 的两个参数都必须是该类型的对象。我们无法传入不同类型的两个对象。'
- en: Both these limitations can be overcome using matchers, which is what we will
    now turn our attention to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个限制都可以通过使用匹配器来克服，这就是我们现在将注意力转向的地方。
- en: Using matchers
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用匹配器
- en: 'A third way to make asserts more readable is to create custom matcher objects
    to make comparisons more readable during assertions. We saw a glimpse of using
    matchers while writing tests for the `EmailAction` class earlier. The following
    is a look at that matcher again:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使断言更易读的第三种方法是创建自定义匹配器对象，以便在断言期间使比较更易读。我们在之前为 `EmailAction` 类编写测试时看到了使用匹配器的一瞥。以下是对该匹配器再次的查看：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A matcher can be any class that implements the `__eq__` method. The method will
    take the actual object as a parameter and the method can implement any comparison
    logic required. Using this method, we can directly compare domain objects in the
    assertion without cluttering it with a number of separate asserts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器可以是任何实现了 `__eq__` 方法的类。该方法将实际对象作为参数，并且该方法可以实现所需的任何比较逻辑。使用这种方法，我们可以在断言中直接比较域对象，而无需用多个单独的断言来杂乱无章。
- en: 'The matcher does not need to compare complete domain objects. We can compare
    only the attributes that we are interested in. In fact, we can create different
    matchers to match against specific subsets of objects. For example, we might create
    an `AlertMessageMatcher` like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器不需要比较完整的域对象。我们可以仅比较我们感兴趣的属性。实际上，我们可以创建不同的匹配器来匹配特定的对象子集。例如，我们可能会创建一个 `AlertMessageMatcher`，如下所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This matcher will only match alert messages that have the given subject, while
    taking the other parameters from the expected object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配器只会匹配具有给定主题的警报消息，同时从预期对象中获取其他参数。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked a little more in detail at the important but often
    overlooked topic of keeping tests maintainable. You looked at the importance of
    having a consistent test file layout scheme and the pros and cons of various alternatives.
    You looked at naming tests and grouping tests, before moving to the topic of making
    tests easier to understand. Some of the strategies that we discussed were using
    docstrings, creating custom test class hierarchies, and utilizing fixtures. Finally,
    you looked at making code more readable by using helper functions, custom asserts,
    equality functions, and writing custom matchers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你更详细地探讨了保持测试可维护性的重要但常被忽视的主题。你研究了保持一致的测试文件布局方案的重要性以及各种替代方案的优缺点。你研究了测试的命名和分组，然后转向使测试更容易理解的主题。我们讨论的一些策略包括使用文档字符串、创建自定义测试类层次结构和利用固定装置。最后，你研究了通过使用辅助函数、自定义断言、等价函数和编写自定义匹配器来使代码更易于阅读。
- en: In the next chapter, you will look at incorporating tests in your documentation
    using the `doctest` module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用`doctest`模块将测试纳入你的文档中。
