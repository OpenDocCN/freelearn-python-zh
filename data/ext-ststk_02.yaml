- en: Chapter 2. Writing Execution Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。编写执行模块
- en: Execution modules form the backbone of the workload that Salt performs. They're
    also easy to write, and the techniques used in writing them form the foundation
    for writing every other type of Salt module. With a solid understanding of how
    execution modules work, the functionality of other module types will also be opened
    up.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模块构成了Salt执行的工作负载的骨干。它们也易于编写，编写它们的技巧是编写其他所有类型Salt模块的基础。对执行模块的工作原理有扎实的理解后，其他模块类型的功能也将被打开。
- en: 'In this chapter, we''ll talk about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论：
- en: The basics of writing Salt modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Salt模块的基本知识
- en: Making use of Salt built-ins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Salt内置功能
- en: Using good practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用良好实践
- en: Troubleshooting execution modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行模块的故障排除
- en: Writing Salt modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Salt模块
- en: There are a few items that are consistent across all Salt modules. These pieces
    generally work the same way across all module types, though there are a handful
    of places where you can expect at least a little deviation. We'll cover those
    in other chapters as we get to them. For now, let's talk about the things that
    are generally the same.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有Salt模块中，有一些项目是一致的。这些组件在所有模块类型中通常以相同的方式工作，尽管在少数地方你可以期望至少有一点偏差。我们将在其他章节中介绍这些偏差。现在，让我们谈谈那些通常相同的事情。
- en: Hidden objects
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏对象
- en: It has long been common for programmers to preface functions, variables, and
    the like with an underscore, if they are only intended to be used internally in
    the same module. In many languages, objects that are used like this are said to
    be **private objects**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，程序员就习惯于在函数、变量等前面加上下划线，如果它们只打算在同一个模块内部使用。在许多语言中，这样使用的对象被称为**私有对象**。
- en: Some environments enforce private behavior by not allowing external code to
    reference those things directly. Other environments allow it, but its use is discouraged.
    Salt modules fall into the list of environments that enforce private function
    behavior; if a function inside a Salt module begins with an underscore, it will
    not even be exposed to other modules that try to call it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些环境通过不允许外部代码直接引用这些内容来强制执行私有行为。其他环境允许这样做，但使用是不被鼓励的。Salt模块属于强制执行私有函数行为的列表；如果一个Salt模块中的函数以下划线开头，它甚至不会被暴露给尝试调用它的其他模块。
- en: In Python, there is a special type of object whose name begins and ends with
    two underscores. These "magic methods" are nicknamed **dunder** (meaning double
    underscore). How Python normally treats them is beyond the scope of this book,
    but it is important to know that Salt adds some of its own. Some are built-ins,
    which are generally available in (almost) all module types, whereas others are
    user-defined objects that Salt will apply special treatment to.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，存在一种特殊的对象，其名称以两个下划线开头和结尾。这些被称为“魔法方法”（magic methods）的东西被昵称为**dunder**（意为双下划线）。Python通常如何处理它们超出了本书的范围，但重要的是要知道Salt添加了一些自己的。其中一些是内置的，通常在（几乎）所有模块类型中都可以使用，而另一些则是用户定义的对象，Salt会对它们进行特殊处理。
- en: The __virtual__() function
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __virtual__()函数
- en: This is a function that can appear in any module. If there is no `__virtual__()`
    function, then the module will always be available on every system. If that module
    is present, then its job is to determine whether the requirements for that module
    are met. These requirements could be any number of things from configuration settings
    to package dependencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以出现在任何模块中的函数。如果没有`__virtual__()`函数，那么该模块将始终在每个系统上可用。如果该模块存在，那么它的任务是确定该模块的要求是否得到满足。这些要求可能包括配置设置到软件包依赖的任何数量。
- en: If the requirements are not met, then the `__virtual__()` function will return
    `False`. In more recent versions of Salt, it is possible to instead return a tuple
    containing both the `False` value and a reason why the module cannot be loaded.
    If they are met, then there are two types of value that it can return. This is
    where things get just a tad tricky.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求没有得到满足，那么`__virtual__()`函数将返回`False`。在Salt的较新版本中，可以返回一个包含`False`值和无法加载模块的原因的元组。如果它们得到满足，那么它可以返回两种类型的值。这里事情变得有点棘手。
- en: 'Let''s say that the module that we are working on is located at `salt/modules/mymodule.py`.
    If the requirements are met, and the module is to be referred to as `mymodule`,
    then the `__virtual__()` function will return `True`. Assuming there is also a
    function in that module called `test()`, it would be called using the following
    command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发的模块位于 `salt/modules/mymodule.py`。如果满足要求，并且该模块将被引用为 `mymodule`，那么 `__virtual__()`
    函数将返回 `True`。假设该模块中还有一个名为 `test()` 的函数，它将使用以下命令调用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the requirements are met, but this module is to be referred to as `testmodule`,
    then the `__virtual__()` function will return the string `testmodule` instead.
    However, instead of returning that string directly, you should define it before
    all of the functions using the `__virtualname__` variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足要求，但此模块将被引用为 `testmodule`，那么 `__virtual__()` 函数将返回字符串 `testmodule`。然而，而不是直接返回该字符串，你应该在所有函数之前使用
    `__virtualname__` 变量定义它。
- en: 'Let''s go ahead and start writing a module, using the `__virtual__()` function
    and `__virtualname__` variable. We won''t check for any requirements yet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一个模块，使用 `__virtual__()` 函数和 `__virtualname__` 变量。我们目前不会检查任何要求：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Formatting your code
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码格式化
- en: Before we get any further, I want to point out some important things that you
    should be aware of now, so that you don't get into any bad habits that need to
    be fixed later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，我想指出一些你应该现在就注意的重要事项，这样你就不会养成需要以后改正的坏习惯。
- en: The module starts off with a special kind of comment called a `docstring`. In
    Salt, this begins and ends with three single quotes, all on one line, by themselves.
    Do not use double quotes. Do not put text on the same line as the quotes. All
    public functions must also include a `docstring`, with the same rules. These `docstrings`
    are used internally by Salt, to provide help text to functions such as `sys.doc`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模块以一种特殊的注释开始，称为 `docstring`。在 Salt 中，它以三行单引号开始和结束，所有引号都在一行上，单独成行。不要使用双引号。不要将文本放在引号所在的同一行上。所有公共函数也必须包含
    `docstring`，遵循相同的规则。这些 `docstrings` 由 Salt 内部使用，为 `sys.doc` 等函数提供帮助文本。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that these guidelines are specific to Salt; Python itself follows
    a different style. Check *Understanding the Salt style guide* in *Appendix B*
    for more information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些指南是针对 Salt 的；Python 本身遵循不同的风格。有关更多信息，请参阅附录 B 中的 *Understanding the Salt
    style guide*。
- en: Take note that the `docstring` for the `ping()` function includes a `CLI Example`.
    You should always include just enough information to make it clear what the function
    is meant to do, and at least one (or more, as warranted) command-line examples
    that demonstrate how to use that function. Private functions do not include a
    `CLI Example`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ping()` 函数的 `docstring` 包含一个 `CLI Example`。你应该总是包含足够的信息，以便清楚地了解函数的用途，并且至少包含一个（或更多，根据需要）命令行示例，以演示如何使用该函数。私有函数不包括
    `CLI Example`。
- en: You should always include two blank lines between any imports and variable declarations
    at the top and the functions below, and between all functions. There should be
    no whitespace at the end of the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在顶部和下面的函数之间，以及所有函数之间，始终包含两个空行，任何导入和变量声明之间也应如此。文件末尾不应有空格。
- en: Virtual modules
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟模块
- en: The primary motivation behind the `__virtual__()` function is not just to rename
    modules. Using this function allows Salt to not only detect certain pieces of
    information about the system but also use them to appropriately load specific
    modules to make certain tasks more generic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`__virtual__()` 函数的主要动机不仅仅是重命名模块。使用此函数允许 Salt 不仅检测有关系统的某些信息，而且还可以使用这些信息适当地加载特定模块，使某些任务更加通用。'
- en: '[Chapter 1](part0015_split_000.html#E9OE1-d9976ffc65994572ad672a3ef48f1135
    "Chapter 1. Starting with the Basics"), *Starting with the Basics*, mentioned
    some of these examples. `salt/modules/aptpkg.py` contains a number of tests to
    determine whether it is running on a Debian-like operating system that uses the
    `apt` suite of tools to perform package management. There are similar tests in
    `salt/modules/yumpkg.py`, `salt/modules/pacman.py`, `salt/modules/solarispkg.py`,
    and a number of others. If all of the tests pass for any of those modules, then
    it will be loaded as the `pkg` module.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](part0015_split_000.html#E9OE1-d9976ffc65994572ad672a3ef48f1135 "第一章。从基础开始")，*从基础开始*，提到了这些例子中的一些。`salt/modules/aptpkg.py`
    包含了多个测试，以确定它是否运行在类似 Debian 的操作系统上，该操作系统使用 `apt` 工具集进行软件包管理。`salt/modules/yumpkg.py`、`salt/modules/pacman.py`、`salt/modules/solarispkg.py`
    以及其他一些模块中也有类似的测试。如果这些模块中的任何一个都通过了所有测试，那么它将被加载为 `pkg` 模块。'
- en: If you are building a set of modules like this, it is important to remember
    that they should all perform as similarly as possible. For instance, all of the
    `pkg` modules contain a function called `install()`. Every single `install()`
    function accepts the same arguments, performs the same task (as appropriate for
    that platform), and then returns data in exactly the same format.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建这样的模块集，重要的是要记住，它们应该尽可能相似。例如，所有的 `pkg` 模块都包含一个名为 `install()` 的函数。每个 `install()`
    函数都接受相同的参数，执行相同的任务（适用于该平台），然后以完全相同的格式返回数据。
- en: There may be situations where one function is appropriate for one platform,
    but not another. For example, `salt/modules/aptpkg.py` contains a function called
    `autoremove()`, which calls out to `apt-get autoremove`. There is no such functionality
    in `yum`, so that function does not exist in `salt/modules/yumpkg.py`. If there
    were, then that function would be expected to behave the same way between both
    files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在这样的情况，某个函数适用于一个平台，但不适用于另一个平台。例如，`salt/modules/aptpkg.py` 包含一个名为 `autoremove()`
    的函数，它调用 `apt-get autoremove`。在 `yum` 中没有这样的功能，因此 `salt/modules/yumpkg.py` 中不存在该函数。如果存在，那么这个函数在两个文件中应该以相同的方式表现。
- en: Using the salt.utils library
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 salt.utils 库
- en: The preceding module will always run, because it doesn't check for requirements
    on the system. Let's go ahead and add some checking now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个模块总是会运行，因为它不会检查系统上的需求。现在让我们继续添加一些检查。
- en: There is an extensive set of tools available to import inside the `salt/utils/`
    directory. A large number of them live directly under the `salt.utils` namespace,
    including a very commonly used function called `salt.utils.which()`. When given
    the name of a command, this function will report the location of that command,
    if it exists on the system. If it does not exist, then it will return `False`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `salt/utils/` 目录内有一套丰富的工具可用于导入。其中许多直接位于 `salt.utils` 命名空间下，包括一个非常常用的函数 `salt.utils.which()`。当给出命令名时，此函数将报告该命令在系统上的位置。如果不存在，则返回
    `False`。
- en: 'Let''s go ahead and rework the `__virtual__()` function to look for a command
    called `mysql`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新设计 `__virtual__()` 函数，以查找名为 `mysql` 的命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `salt.utils` libraries ship with Salt, but you need to explicitly import
    them. It is common for Python coders to import only parts of functions. You may
    find it tempting to use the following import line instead:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`salt.utils` 库与 Salt 一起提供，但您需要显式导入它们。对于 Python 开发者来说，只导入函数的一部分是很常见的。您可能会发现使用以下导入行很有吸引力：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And then use the following line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下行：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although not expressly forbidden in Salt, this is discouraged except when necessary.
    Although it may require more typing, especially if you use a particular function
    several times in a particular module, doing so makes it easier to tell at a glance
    which module a particular function came from.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Salt 中没有明确禁止，但除非必要，否则不建议这样做。虽然这可能会需要更多的输入，尤其是如果您在特定模块中多次使用特定函数，这样做可以更容易地一眼看出特定函数来自哪个模块。
- en: Cross-calling with the __salt__ dictionary
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 __salt__ 字典进行跨调用
- en: 'There are times when it is helpful to be able to call out to another function
    in another module. For instance, calling external shell commands is a pretty important
    part of Salt. It''s so important in fact that it was standardized in the `cmd`
    module. The most common command for issuing shell commands is `cmd.run`. The following
    Salt command demonstrates using `cmd.run` on a Windows Minion:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，能够调用另一个模块中的另一个函数是有帮助的。例如，调用外部shell命令是Salt的一个重要部分。实际上，它如此重要，以至于在`cmd`模块中进行了标准化。最常用的发布shell命令的命令是`cmd.run`。以下Salt命令演示了在Windows
    Minion上使用`cmd.run`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you had a need for your execution module to obtain the output from such
    a command, you would use the following Python:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要你的执行模块从这样的命令中获取输出，你会使用以下Python代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `__salt__` object is a dictionary, which contains references to all of the
    available functions on that Minion. If a module exists, but its `__virtual__()`
    function returns `False`, then it will not appear in this list. As a function
    reference, it requires parentheses at the end, with any arguments inside.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`__salt__`对象是一个字典，其中包含对该Minion上所有可用函数的引用。如果一个模块存在，但它的`__virtual__()`函数返回`False`，那么它将不会出现在这个列表中。作为一个函数引用，它需要在末尾使用括号，并在括号内放置任何参数。'
- en: 'Let''s go ahead and create a function that tells us whether or not the `sshd`
    daemon is running on a Linux system, and listening to a port:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，告诉我们`sshd`守护进程是否在Linux系统上运行，并且监听某个端口：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `sshd` is running and listening on a port, the output of the `netstat -tulpn
    | grep sshd` command should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sshd`正在运行并监听某个端口，`netstat -tulpn | grep sshd`命令的输出应该看起来像这样：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `mysqld` is running, and listening either on IPv4 or IPv6 (or both), then
    this function will return `True`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mysqld`正在运行，并且监听IPv4或IPv6（或两者），那么这个函数将返回`True`。
- en: 'This function is far from perfect. There are a number of factors that may cause
    this command to return a false positive. For instance, let''s say you were looking
    for `sshd` instead of `mysqld`. And say you were a fan of American football, and
    had written your own high-definition football video-streaming service that you
    called `passhd`. This may be unlikely, but it''s certainly not impossible. And
    it brings up an important point: when dealing with data received either from users
    or from computers, **trust but verify**. In fact, you should always assume that
    somebody is going to try to do something bad, and you should watch for ways to
    keep them from doing so.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数远非完美。有许多因素可能导致这个命令返回一个假阳性。例如，假设你正在寻找`sshd`而不是`mysqld`。再假设你是一位美式足球迷，并且自己编写了一个高清足球视频流服务，你称之为`passhd`。这可能不太可能，但绝对不是不可能的。这提出了一个重要观点：在处理从用户或计算机接收到的数据时，**要信任但也要验证**。实际上，你应该始终假设有人会试图做坏事，你应该寻找阻止他们这样做的方法。
- en: Getting configuration parameters
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取配置参数
- en: 'Whereas some software can be accessed without any special configuration, there
    is plenty that does require some information to be set up. There are four places
    that an execution module can get its configuration from: the Minion configuration
    file, grain data, pillar data, and the master configuration file.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些软件可以在没有任何特殊配置的情况下访问，但还有很多软件需要设置一些信息。执行模块可以从四个地方获取其配置：Minion配置文件、grain数据、pillar数据和主配置文件。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is one of those places where Salt built-ins behave differently. Grain and
    pillar data are available to execution and state modules, but not to other types
    of module. This is because grain and pillar data is specific to the Minion running
    the module. Runners, for instance, cannot access this data, because runners are
    used on the Master; not directly on Minions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Salt内置函数行为不同的地方之一。Grain和pillar数据对执行和状态模块可用，但对其他类型的模块不可用。这是因为grain和pillar数据是特定于运行模块的Minion的。例如，Runners无法访问这些数据，因为Runners是在Master上使用的，而不是直接在Minions上。
- en: The first place we can look for configuration is from the `__opts__` dictionary.
    When working in modules that execute on a Minion, this dictionary will contain
    a copy of the data from the Minion configuration file. It may also contain some
    information that Salt generates on its own during runtime. When accessed from
    modules that execute on the Master, this data will come from the master configuration
    file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查找配置的第一个地方是`__opts__`字典。当在Minion上执行模块工作时，这个字典将包含来自Minion配置文件的数据副本。它还可能包含一些Salt在运行时自己生成的一些信息。当从在Master上执行的模块访问时，这些数据将来自主配置文件。
- en: 'It is also possible to set configuration values inside grain or pillar data.
    This information is accessed using the `__grains__` and `__pillar__` dictionaries,
    respectively. The following example shows different configuration values being
    pulled from each of these locations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 grain 或 pillar 数据中设置配置值。这些信息分别通过 `__grains__` 和 `__pillar__` 字典访问。以下示例显示了从这些位置拉取的不同配置值：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since those values may not actually exist, it is better to use Python''s `dict.get()`
    method, and supply a default:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些值可能实际上不存在，最好使用 Python 的 `dict.get()` 方法，并提供一个默认值：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last place we can store configuration data is inside the master configuration
    file. All of the Master's configuration can be stored inside a pillar dictionary
    called `master`. By default, this is not made available to Minions. However, it
    can be turned on by setting `pillar_opts` to `True` in the `master` configuration
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以存储配置数据的最后一个地方是在主配置文件中。Master 的所有配置都可以存储在一个名为 `master` 的 pillar 字典中。默认情况下，这不会对
    Minions 可用。但是，可以通过在 `master` 配置文件中将 `pillar_opts` 设置为 `True` 来启用它。
- en: 'Once `pillar_opts` is turned on, you can use commands like this to access a
    value in the `master` configuration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `pillar_opts` 被启用，你可以使用如下命令访问 `master` 配置中的值：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, it is possible to ask Salt to search each of these locations, in turn,
    for a specific variable. This can be very valuable when you don't care which component
    carries the information that you need, so long as you can get it from somewhere.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以让 Salt 依次在每个位置搜索特定的变量。当你不在乎哪个组件携带你需要的信息，只要你能从某个地方获取它时，这非常有价值。
- en: 'In order to search each of these areas, cross-call to the `config.get()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索这些区域，需要跨调用 `config.get()` 函数：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will search for the configuration parameter in the following order:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按以下顺序搜索配置参数：
- en: '`__opts__` (on the Minion).'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__opts__`（在 Minion 上）。'
- en: '`__grains__`.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__grains__`。'
- en: '`__pillar__`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__pillar__`。'
- en: '`__opts__` (on the Master).'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__opts__`（在 Master 上）。'
- en: Keep in mind that when using `config.get()`, the first value found will be used.
    If the value that you are looking for is defined in both `__grains__` and `__pillar__`,
    then the value in `__grains__` will be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当使用 `config.get()` 时，将使用找到的第一个值。如果你要查找的值在 `__grains__` 和 `__pillar__` 中都定义了，那么将使用
    `__grains__` 中的值。
- en: Another advantage of using `config.get()` is that this function will automatically
    resolve data that is referred to using `sdb://` URIs. When accessing those dictionaries
    directly, any `sdb://` URIs will need to be handled manually. Writing and using
    SDB modules will be covered in [Chapter 3](part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135
    "Chapter 3. Extending Salt Configuration"), *Extending Salt Configuration*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `config.get()` 的另一个优点是，此函数将自动解析使用 `sdb://` URI 引用的数据。当直接访问这些字典时，任何 `sdb://`
    URI 都需要手动处理。编写和使用 SDB 模块将在 [第 3 章](part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135
    "第 3 章。扩展 Salt 配置")，*扩展 Salt 配置* 中介绍。
- en: 'Let''s go ahead and set up a module that obtains configuration data and uses
    it to make a connection to a service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置一个模块，该模块获取配置数据并使用它来连接到服务：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This execution module will run on the Minion, but it can connect to any MySQL
    database using configuration defined in any of the four configuration areas. However,
    this function is pretty limited. If the `MySQLdb` driver is not installed, then
    errors will appear in the Minion's log files when it starts up. If you need to
    perform other types of query, you will need to grab the configuration values each
    time. Let's solve each of these problems in turn.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此执行模块将在 Minion 上运行，但它可以使用在四个配置区域中定义的任何配置连接到任何 MySQL 数据库。然而，这个功能相当有限。如果 `MySQLdb`
    驱动未安装，那么在 Minion 启动时日志文件中会出现错误。如果你需要执行其他类型的查询，你将需要每次都获取配置值。让我们依次解决这些问题。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Did you notice that we used a variable called `db_` instead of `db`? In Python,
    it is considered better practice to use variable names that are at least three
    characters long. Salt also considers this to be a requirement. A very common means
    of accomplishing this for variables that would normally be shorter is to append
    one or two underscores to the end of the variable name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们使用了名为 `db_` 的变量而不是 `db` 吗？在 Python 中，被认为更好的做法是使用至少三个字符长的变量名。Salt 也认为这是必需的。对于通常较短的变量，在变量名末尾附加一个或两个下划线是一个非常常见的实现方式。
- en: Handling imports
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理导入
- en: A number of Salt modules require third-party Python libraries to be installed.
    If any of those libraries aren't installed, then the `__virtual__()` function
    should return `False`. But how do you know beforehand whether or not the libraries
    can be imported?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Salt模块需要安装第三方Python库。如果其中任何一个库没有安装，那么`__virtual__()`函数应该返回`False`。但你是如何事先知道这些库是否可以导入的呢？
- en: 'A very common trick in a Salt module involves attempting to import libraries,
    and then recording whether or not the import succeeded. This is often accomplished
    using a variable with a name like `HAS_LIBS`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Salt模块中，一个非常常见的技巧是尝试导入库，并记录导入是否成功。这通常是通过一个名为`HAS_LIBS`的变量来完成的：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, Python will attempt to import `MySQLdb`. If it succeeds, then
    it will set `HAS_LIBS` to `True`. Otherwise, it will set it to `False`. And because
    this directly correlates to the value that needs to be returned from the `__virtual__()`
    function, we can just return it as it is, so long as we''re not changing `__virtualname__`.
    If we were, then the function would look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python将尝试导入`MySQLdb`。如果成功，则将`HAS_LIBS`设置为`True`。否则，将其设置为`False`。由于这直接关联到`__virtual__()`函数需要返回的值，我们只需将其原样返回即可，只要我们不更改`__virtualname__`。如果我们更改了，那么函数将看起来像这样：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reusing code
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重用
- en: There's still the matter of eliminating redundant code between different functions
    in the same module. In the case of modules that use connection objects (such as
    a database cursor, or a cloud provider authentication) throughout the code, specific
    functions are often set aside to gather configuration, and establish a connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在消除同一模块中不同函数之间冗余代码的问题。在代码中使用连接对象（如数据库游标或云提供商身份验证）的模块中，通常会有特定的函数被留出以收集配置和建立连接。
- en: 'A very common name for these in-cloud modules is `_get_conn()`, so let''s go
    with that in our example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些云模块的一个非常常见的名称是`_get_conn()`，所以让我们在我们的例子中使用它：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This greatly simplifies our code, by turning a large chunk of lines in every
    function into a single line. Of course, this can be taken quite a bit further.
    The actual `salt/modules/mysql.py` module that ships with Salt uses a function
    called `_connect()` instead of `_get_conn()`, and it also has `cur.execute()`
    abstracted out into its own `_execute()` function. You can see these at Salt''s
    GitHub page:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大简化了我们的代码，通过将每个函数中的大量行转换为单行。当然，这可以进一步扩展。实际上，与Salt一起提供的`salt/modules/mysql.py`模块使用了一个名为`_connect()`的函数而不是`_get_conn()`，并且它还将`cur.execute()`抽象到它自己的`_execute()`函数中。你可以在Salt的GitHub页面上看到这些：
- en: '[https://github.com/saltstack/salt](https://github.com/saltstack/salt)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/saltstack/salt](https://github.com/saltstack/salt)'
- en: Logging messages
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志消息
- en: Very often, you will perform an operation that requires some kind of message
    to be logged somewhere. This is especially common when writing new code; it's
    nice to be able to log debugging information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，你会执行需要记录某种消息的操作。当编写新代码时，这尤其常见；能够记录调试信息是非常好的。
- en: 'Salt has a logging system built in, based on Python''s own `logging` library.
    To turn it on, there are two lines that you''ll need to add toward the top of
    your module:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Salt内置了一个基于Python自己的`logging`库的日志系统。要启用它，你需要在模块顶部添加两行：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With these in place, you can log messages using a command like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些设置到位后，你可以使用如下命令来记录日志：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are five levels of logging that are typically used in Salt:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Salt中通常使用五个级别的日志记录：
- en: '`log.info()`: Information at this level is something that is considered to
    be important to all users. It doesn''t mean anything is wrong, but like all log
    messages, its output will be sent to `STDERR` instead of `STDOUT` (so long as
    Salt is running in the foreground, and not configured to log elsewhere).'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log.info()`: 此级别的信息被认为是所有用户都认为重要的事情。这并不意味着有任何错误发生，但像所有日志消息一样，其输出将被发送到`STDERR`而不是`STDOUT`（只要Salt在前台运行，并且没有配置到其他地方进行日志记录）。'
- en: '`log.warn()`: A message logged from here should indicate to the user that something
    is not happening as it should be. However, it is not so broken as to stop the
    code from running.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log.warn()`: 从这里记录的消息应该向用户表明某些事情没有按预期进行。然而，它并没有到足以停止代码运行的程度。'
- en: '`log.error()`: This denotes that something has gone wrong, and Salt is unable
    to continue until it is fixed.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log.error()`: 这表示出了问题，Salt无法继续运行直到问题得到修复。'
- en: '`log.debug()`: This is not only information that is useful for determining
    what the program is thinking but is also intended to be useful to regular users
    of the program for things like troubleshooting.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log.debug()`: 这不仅是有助于确定程序思考什么的信息，而且也是为了使程序的用户（如故障排除）有用。'
- en: '`log.trace()`: This is similar to a debug message, but the information here
    is more likely to be useful only to developers.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log.trace()`: 这与调试消息类似，但这里的信息更有可能只对开发者有用。'
- en: 'For now, we''ll add a `log.trace()` to our `_get_conn()` function, which lets
    us know when we successfully connect to the database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `_get_conn()` 函数中添加一个 `log.trace()`，这样我们就可以知道何时成功连接到数据库：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are certain places where it is tempting to use log messages, but they
    should be avoided. Specifically, log messages may be used in any function, except
    for `__virtual__()`. Log messages used outside of functions, and in the `__virtual__()`
    function, make for messy log files that are a pain to read and navigate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些地方可能会诱使人们使用日志消息，但应该避免这样做。具体来说，日志消息可以在任何函数中使用，除了 `__virtual__()`。在函数外部以及 `__virtual__()`
    函数中使用的日志消息会生成混乱的日志文件，难以阅读和导航。
- en: Using the __func_alias__ dictionary
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 __func_alias__ 字典
- en: There are a handful of words that are reserved in Python. Unfortunately, some
    of these words are also very useful for things like function names. For instance,
    many modules have a function whose job is to list data relevant to that module,
    and it seems natural to call such a function `list()`. But that would conflict
    with Python's `list` built-in. This poses a problem, since function names are
    directly exposed to the Salt command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中有一些保留字。不幸的是，其中一些词对于像函数名这样的用途也非常有用。例如，许多模块都有一个函数，其任务是列出与该模块相关的数据，因此将这样的函数命名为
    `list()` 似乎是自然的。但这会与 Python 的内置 `list` 冲突。这会引发问题，因为函数名直接暴露在 Salt 命令中。
- en: 'A workaround is available for this. A `__func_alias__` dictionary may be declared
    at the top of a module, which creates a map between aliases used from the command
    line and the actual name of the function. For instance:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题有一个解决方案。可以在模块顶部声明一个 `__func_alias__` 字典，它将在命令行中使用的别名与函数的实际名称之间创建一个映射。例如：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this in place, the `list_` function will be called as `mysqltest.list`
    (as in the `CLI Example`) instead of `mysqltest.list_`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，`list_` 函数将被调用为 `mysqltest.list`（如 CLI 示例所示），而不是 `mysqltest.list_`。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Why did we call the variable `type_` instead of `type`? Because `type` is a
    Python built-in. But since this function only has one argument, it's not expected
    that users will need to use `type_=<something>` as part of their Salt command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用变量 `type_` 而不是 `type`？因为 `type` 是 Python 的内置函数。但因为这个函数只有一个参数，所以预计用户不需要在
    Salt 命令中使用 `type_=<something>`。
- en: Validating data
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证数据
- en: From that last piece of code, a number of readers at this point probably have
    warning bells going off in their heads. It allows for a very common type of security
    vulnerability called an injection attack. Because the function does not perform
    any sort of validation on the `type_` variable, it is possible for users to pass
    in code that can cause destruction, or obtain data that they shouldn't have.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一部分代码来看，此时可能有许多读者脑海中响起了警钟。它允许一种非常常见的安全漏洞，称为注入攻击。因为这个函数没有对 `type_` 变量进行任何形式的验证，用户可以传递可能导致破坏或获取他们不应拥有的数据的代码。
- en: 'One might think that this isn''t necessarily a problem in Salt, because in
    a number of environments, only trusted users should have access. However, because
    Salt can be used by a wide range of user types, who may be intended to only have
    limited access, there are a number of scenarios where an injection attack can
    be devastating. Imagine a user running the following Salt command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会认为在 Salt 中这并不是一个必然的问题，因为在许多环境中，只有受信任的用户应该有权访问。然而，由于 Salt 可以被各种用户类型使用，他们可能只被授权有限访问，因此存在许多场景，注入攻击可能会造成灾难性的后果。想象一下，一个用户正在运行以下
    Salt 命令：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is often easy to fix, by adding some simple checking to any user input
    (remember: **trust but verify**):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常很容易修复，只需在用户输入中添加一些简单的检查（记住：**信任但验证**）：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, we've declared which types are valid before allowing them to be
    passed in to the SQL query. Even a single bad character will cause Salt to refuse
    to complete the command. This kind of data validation is often better, because
    it doesn't try to modify the input data to make it safe to run. Doing so is referred
    to as *validating user input*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在允许它们传递到 SQL 查询之前已经声明了哪些类型是有效的。即使是一个坏字符也会导致 Salt 拒绝完成命令。这种类型的数据验证通常更好，因为它不试图修改输入数据以使其安全运行。这样做被称为
    *验证用户输入*。
- en: 'We''ve added in another piece of code as well: a Salt exception. There are
    a number of these available in the `salt.exceptions` library, but `CommandExecutionError`
    is one that you may find yourself using quite a bit when validating data.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了另一段代码：一个 Salt 异常。`salt.exceptions` 库中有许多这样的异常，但 `CommandExecutionError`
    是你在验证数据时可能会经常使用的一个。
- en: Formatting strings
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'A quick note on string formatting: Older Python developers may have noticed
    that we opted to use `str.format()` instead of the older `printf`-style string
    handling. The following two lines of code do the same thing in Python:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串格式化的一点说明：较老的 Python 开发者可能已经注意到，我们选择使用 `str.format()` 而不是旧的 `printf` 风格的字符串处理。以下两行代码在
    Python 中做的是同样的事情：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: String formatting using `str.format()` is just a little faster in Python, and
    is required in Salt except for in places where it doesn't make sense.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `str.format()` 进行字符串格式化在 Python 中稍微快一点，但在 Salt 中除了不合适的地方外都是必需的。
- en: 'Don''t be tempted to use the following shortcut available in Python 2.7.x:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被 Python 2.7.x 中可用的以下快捷方式所诱惑：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because Salt still needs to run on Python 2.6, which doesn't support using `{}`
    instead of `{0}`, this will cause problems for users on older platforms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Salt 仍然需要在 Python 2.6 上运行，而 Python 2.6 不支持使用 `{}` 代替 `{0}`，这将为旧平台上的用户带来问题。
- en: The final module
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个模块
- en: 'When we put all of the preceding code together, we end up with the following
    module:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有前面的代码放在一起时，我们最终得到以下模块：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Troubleshooting execution modules
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试执行模块
- en: As with any programming, the more time you spend writing execution modules,
    the more likely you are to encounter issues. Let's take a moment to talk about
    how to troubleshoot and debug your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何编程一样，你花在编写执行模块上的时间越多，你遇到问题的可能性就越大。让我们花点时间来谈谈如何调试和调试你的代码。
- en: Using salt-call
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 salt-call
- en: The `salt-call` command has always been a valuable tool for testing and troubleshooting
    code. Without it, you would need to restart the `salt-minion` service each time
    you wanted to test new code; believe me, that gets old fast.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`salt-call` 命令始终是测试和调试代码的有价值工具。没有它，每次你想测试新代码时，都需要重新启动 `salt-minion` 服务；相信我，这很快就会变得很无聊。'
- en: 'Because `salt-call` doesn''t start up a service, it will always run the latest
    copy of the Salt code. It does do most of the things that the `salt-minion` service
    does: it loads grains, connects to the Master (unless told not to) to obtain pillar
    data, goes through the loader process to decide which modules to load, and then
    performs the requested command. Pretty much the only thing it doesn''t do is keep
    running.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `salt-call` 不会启动服务，它将始终运行 Salt 代码的最新副本。它确实做了 `salt-minion` 服务的大部分工作：加载粒度、连接到
    Master（除非被告知不要连接）以获取 pillar 数据、通过加载器过程决定要加载哪些模块，然后执行请求的命令。几乎唯一不做的就是保持运行。
- en: 'Using `salt-call` to issue a command is also the same as using the `salt` command,
    except that a target is not required (because the target is the Minion that `salt-call`
    is running on):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `salt-call` 发送命令与使用 `salt` 命令相同，只是不需要指定目标（因为目标是 `salt-call` 运行的 Minion）：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You may notice that even though you're issuing `salt-call` commands on the same
    machine that will be performing the execution, it tends to run a little slower.
    There are two reasons for this. First of all, you are still basically starting
    up the `salt-minion` service each time, without actually keeping it running. That
    means that detecting grains, loading modules, and so on will have to happen each
    time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，尽管你正在同一台机器上发出 `salt-call` 命令，该机器将执行操作，但它通常会运行得慢一点。这有两个原因。首先，你仍然基本上每次都在启动
    `salt-minion` 服务，而没有真正让它保持运行。这意味着检测粒度、加载模块等操作将不得不每次都进行。
- en: 'To get a feel for how much time this really takes, try comparing execution
    times both with and without grain detection:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这实际上需要多少时间，尝试比较带有和不带有粒度检测的执行时间：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Of course, if you''re testing a module that makes use of grains, this is not
    an acceptable strategy. The second thing that slows down commands is having to
    connect to the Master. This doesn''t take nearly as much time as grain detection,
    but it does take a hit:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你正在测试一个使用grains的模块，这不是一个可接受的战略。命令运行速度减慢的第二件事是必须连接到Master。这并不像grain检测那样耗时，但它确实会减慢速度：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--local` flag doesn't just tell `salt-call` not to talk to the Master.
    It actually tells `salt-call` to use itself as the Master (meaning, operate in
    local mode). If your module makes use of pillars or other resources on the Master,
    then you can just serve them locally instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`--local`标志不仅告诉`salt-call`不要与Master通信。实际上，它告诉`salt-call`使用自身作为Master（这意味着，以本地模式运行）。如果你的模块使用了Master上的pillar或其他资源，那么你只需在本地提供服务即可。'
- en: 'Any configuration in the master configuration file that you need can be copied
    directly to the `Minion` file. If you''re just using the defaults, you don''t
    even need to do that: just copy the necessary files from the Master to the Minion:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 主机配置文件中你需要配置的任何内容都可以直接复制到`Minion`文件中。如果你只是使用默认设置，你甚至不需要这样做：只需从Master复制必要的文件到Minion：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once everything is in place, go ahead and fire up `salt-call` with the `--local`
    flag and get to troubleshooting.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，使用`--local`标志启动`salt-call`并开始故障排除。
- en: <function> is not available
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <function>不可用
- en: 'When I''m writing a new module, one of the first problems I have is getting
    the module to show up. Quite often this is because of obviously bad code, such
    as a typo. For instance, if we were to change our import from `salt.utils` to
    `salt.util`, our module would fail to load:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写一个新的模块时，我遇到的第一大问题通常是让模块显示出来。这通常是因为代码明显有问题，比如打字错误。例如，如果我们把导入从`salt.utils`改为`salt.util`，我们的模块将无法加载：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In cases like this, we can find the problem by running `salt-call` in `debug`
    mode:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过以`debug`模式运行`salt-call`来找到问题：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another possibility is that there is a problem with the `__virtual__()` function.
    This is the one time I would recommend adding log messages to that function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能是`__virtual__()`函数存在问题。这是我唯一一次建议向该函数添加日志消息的情况：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, make sure you pull them out before you ever get into production, or
    you're going to have some very unhappy users sooner or later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确保在生产之前将它们移除，否则你迟早会有一批非常不满意的用户。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载本书的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: 'You can download the code files by following these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the SUPPORT tab at the top.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的SUPPORT标签上。
- en: Click on Code Downloads & Errata.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击代码下载与勘误表。
- en: Enter the name of the book in the Search box.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在搜索框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择你购买这本书的地方。
- en: Click on Code Download.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击代码下载。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的软件解压或提取文件夹：
- en: WinRAR/7-Zip for Windows
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR/7-Zip for Windows
- en: Zipeg/iZip/UnRarX for Mac
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg/iZip/UnRarX for Mac
- en: 7-Zip/PeaZip for Linux
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip/PeaZip for Linux
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Learning how to write execution modules creates an excellent foundation for
    writing other Salt modules. Salt contains a number of built-ins, many of which
    are available across all module types. A number of libraries also ship with Salt
    inside the `salt/utils/` directory. And troubleshooting Salt modules is easiest
    when using the `salt-call` command, particularly in local mode.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何编写执行模块为编写其他Salt模块奠定了良好的基础。Salt包含了许多内置功能，其中许多功能适用于所有模块类型。一些库也随Salt一起打包在`salt/utils/`目录中。使用`salt-call`命令（尤其是在本地模式下）进行故障排除时，Salt模块的调试最为容易。
- en: Next up, we'll talk about various types of Salt module that can be used to handle
    configuration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论可以用来处理配置的各种类型的 Salt 模块。
