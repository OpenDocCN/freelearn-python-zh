- en: Chapter 1. Principles of Software Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。软件架构原则
- en: This is a book on Python. At the same time, it is a book about software architecture
    and its various attributes, which are involved in a software development life
    cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于Python的书。与此同时，它也是一本关于软件架构及其在软件开发生命周期中涉及的各种属性的书。
- en: In order for you to understand and combine both aspects together, which is essential
    to get maximum value from this book, it is important to grasp the fundamentals
    of software architecture, the themes and concepts related to it, and the various
    quality attributes of software architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你理解并结合这两个方面，这对于从本书中获得最大价值是至关重要的，重要的是要掌握软件架构的基本原理，与之相关的主题和概念，以及软件架构的各种质量属性。
- en: A number of software engineers, taking on senior roles in their organizations,
    often get very different interpretations of the definitions of software design
    and architecture, and the roles they play in building testable, maintainable,
    scalable, secure, and functional software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件工程师在组织中担任高级角色时，经常对软件设计和架构的定义以及它们在构建可测试、可维护、可扩展、安全和功能性软件中的作用有着非常不同的解释。
- en: Though there is a lot of literature in the field, which is available both in
    conventional book forms and on the Internet, very often, the practitioners among
    us get a confusing picture of these very important concepts. This is often due
    to the pressures involved in *learning the technology* rather than learning the
    fundamental design and architectural principles underlying the use of technology
    in building systems. This is a common practice in software development organizations,
    where the pressures of delivering working code often overpowers and eclipses everything
    else.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该领域有大量的文献，无论是传统的书籍形式还是互联网上，但我们中的从业者往往对这些非常重要的概念产生混淆的印象。这往往是由于*学习技术*而不是学习技术在构建系统中的基本设计和架构原则方面所带来的压力。这在软件开发组织中是一种常见做法，其中交付可工作的代码的压力往往压倒和掩盖了其他一切。
- en: A book such as this one, strives to transcend the middle path in bridging the
    rather esoteric aspects of software development related to its architectural quality
    attributes to the mundane details of building software using programming languages,
    libraries, and frameworks—in this case, using Python and its developer ecosystem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像本书这样的一本书，努力超越中间路径，将软件开发中与其架构质量属性相关的颇为晦涩的方面与使用编程语言、库和框架构建软件的平凡细节联系起来——在本例中，使用Python及其开发者生态系统。
- en: The role of this introductory chapter is to demystify these concepts, and explain
    them in very clear terms to the reader so as to prepare him for the path towards
    understanding the rest of this book. Hopefully, by the end of this book, the concepts
    and their practical details would represent a coherent body of knowledge to the
    reader.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开场章节的作用是揭开这些概念的神秘面纱，并以非常清晰的方式向读者解释，为他准备好理解本书其余部分的内容。希望到本书结束时，这些概念及其实际细节将对读者构成一个连贯的知识体系。
- en: 'We will then get started on this path without any further ado, roughly fitting
    this chapter into the following sections:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即开始这条道路，将这一章大致分为以下几个部分：
- en: Defining Software Architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义软件架构
- en: Software Architecture versus design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构与设计
- en: Aspects of Software Architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构的方面
- en: Characteristics of Software Architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构的特点
- en: Why is Software Architecture important?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么软件架构很重要？
- en: System versus Enterprise Architecture
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统与企业架构
- en: Architectural quality attributes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构质量属性
- en: Modifiability
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可修改性
- en: Testability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Scalability/performance
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性/性能
- en: Security
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Deployability
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可部署性
- en: Defining Software Architecture
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义软件架构
- en: 'There are various definitions of software architecture in the literature concerning
    the topic. A simple definition is given as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的文献中有各种各样的软件架构定义。一个简单的定义如下：
- en: '**software architecture** is a description of the subsystems or components
    of a software system, and the relationships between them.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件架构**是对软件系统的子系统或组件以及它们之间的关系的描述。'
- en: 'The following is a more formal definition, from the **Recommended Practice
    for Architectural Description of Software-Intensive Systems** (**IEEE**) technology:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自**IEEE**技术的**软件密集型系统架构描述的推荐实践**的更正式定义：
- en: '*"Architecture is the fundamental organization of a system embodied in its
    components, their relationships to each other, and to the environment, and the
    principles guiding its design and evolution."*'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “架构是一个系统在其组件中体现的基本组织，它们相互之间的关系，以及与环境的关系，以及指导其设计和演变的原则。”
- en: It is possible to get an umpteen number of such definitions of software architecture
    if one spends some time searching on the Web. The wordings might differ, but all
    the definitions refer to some core, fundamental aspects underlying software architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果花一些时间在网上搜索，可能会找到无数关于软件架构的定义。措辞可能不同，但所有的定义都指的是软件架构的一些核心、基本方面。
- en: Software Architecture versus design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构与设计
- en: In the experience of the author, this question of the software architecture
    of a system versus its design seems to pop up quite often, in both online as well
    as offline forums. Hence, let us take a moment to understand this aspect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的经验中，系统的软件架构与其设计的问题似乎经常出现在在线和离线论坛中。因此，让我们花一点时间来理解这一方面。
- en: 'Though both terms sometimes are often used interchangeably, the rough distinction
    of architecture versus design can be summarized as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个术语有时可以互换使用，但架构与设计的粗略区别可以总结如下：
- en: Architecture is involved with the higher level of description structures and
    interactions in a system. It is concerned with those questions that entail decision
    making about the *skeleton* of the system, involving not only its functional but
    also its organizational, technical, business, and quality attributes.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构涉及系统中的描述结构和交互的更高层次。它涉及那些需要对系统的*骨架*做出决策的问题，不仅涉及其功能，还涉及其组织、技术、业务和质量属性。
- en: 'Design is all about the organization of parts or components of the system and
    the subsystems involved in making the system. The problems here are typically
    closer to the code or modules in question, such as these:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计是关于系统的部分或组件的组织以及涉及制作系统的子系统。这里的问题通常更接近于代码或相关模块，比如：
- en: What modules to split code into? How to organize them?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码分割成哪些模块？如何组织它们？
- en: Which classes (or modules) to assign the different functionalities to?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同的功能分配给哪些类（或模块）？
- en: Which design pattern should I use for class "C"?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该为类“C”使用哪种设计模式？
- en: How do my objects interact at runtime? What are the messages passed, and how
    to organize the interaction?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的对象在运行时如何交互？传递了哪些消息，如何组织这种交互？
- en: software architecture is about the design of the entire system, whereas, software
    design is mostly about the details, typically at the implementation level of the
    various subsystems and components that make up those subsystems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构是关于整个系统的设计，而软件设计大多是关于细节，通常是关于构成这些子系统的各种子系统和组件的实现级别。
- en: In other words, the word *design* comes up in both contexts, however, with the
    distinction that the former is at a much higher abstraction and at a larger scope
    than the latter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*设计*这个词在两种情境中都出现了，不过前者的抽象程度和范围要比后者高得多。
- en: There is a rich body of knowledge available for both software architecture and
    design, namely, **architectural patterns and design patterns** respectively. We
    will discuss both these topics in later chapters of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件架构和设计，即**架构模式和设计模式**，都有丰富的知识体系可供参考。我们将在本书的后续章节中讨论这两个主题。
- en: Aspects of Software Architecture
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构的特点
- en: 'In both the formal IEEE definition and the rather informal definition given
    earlier, we find some common, recurring themes. It is important to understand
    them in order to take our discussion on software architecture further:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式的IEEE定义和之前给出的相当不正式的定义中，我们发现了一些共同的、反复出现的主题。为了进一步讨论软件架构，理解它们是很重要的：
- en: '**System**: A system is a collection of components organized in specific ways
    to achieve a specific functionality. A software system is a collection of such
    software components. A system can often be subgrouped into subsystems.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：系统是以特定方式组织的组件集合，以实现特定的功能。软件系统是这种软件组件的集合。系统通常可以分为子系统。'
- en: '**Structure**: A structure is a set of elements that are grouped or organized
    together according to a guiding rule or principle. The elements can be software
    or hardware systems. A software architecture can exhibit various levels of structures
    depending on the observer''s context.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：结构是根据指导原则或原则组合或组织在一起的一组元素。这些元素可以是软件或硬件系统。根据观察者的情境，软件架构可以展示不同级别的结构。'
- en: '**Environment**: The context or circumstances in which a software system is
    built, which has a direct influence on its architecture. Such contexts can be
    technical, business, professional, operational, and so on.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：软件系统构建的上下文或环境，对其架构有直接影响。这些上下文可以是技术、业务、专业、运营等。'
- en: '**Stakeholder**: Anyone, a person or groups of persons, who has an interest
    or concern in the system and its success. Examples of stakeholders are the architect,
    development team, customer, project manager, marketing team, and others.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利益相关者**：任何对系统及其成功感兴趣或关注的人或人群。利益相关者的例子包括架构师、开发团队、客户、项目经理、营销团队等。'
- en: Now that you have understood some of the core aspects of software architecture,
    let us briefly list some of its characteristics.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了软件架构的一些核心方面，让我们简要列出一些其特点。
- en: Characteristics of Software Architecture
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的特点
- en: All software architectures exhibit a common set of characteristics. Let us look
    at some of the most important ones here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件架构都具有一组共同的特征。让我们在这里看一些最重要的特征。
- en: An architecture defines a structure
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构定义了一个结构
- en: An architecture of a system is best represented as structural details of the
    system. It is a common practice for practitioners to draw the system architecture
    as a structural component or class diagram in order to represent the relationships
    between the subsystems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的架构最好表示为系统的结构细节。实践者通常会将系统架构绘制为结构组件或类图，以表示子系统之间的关系。
- en: 'For example, the following architecture diagram describes the backend of an
    application that reads from a tiered database system, which is loaded using an
    ETL process:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下架构图描述了一个应用程序的后端，该应用程序从分层数据库系统中读取数据，使用ETL过程加载：
- en: '![An architecture defines a structure](../Images/image00365.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![架构定义了一个结构](../Images/image00365.jpeg)'
- en: Example Architecture diagram showing system structure
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例架构图显示系统结构
- en: Structures provide insight into architectures, and provide a unique perspective
    to analyze the architecture with respect to its quality attributes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结构提供了对架构的洞察，并为分析架构提供了独特的视角，以便考虑其质量属性。
- en: 'Some examples are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: The runtime structures, in terms of the objects created at runtime, and how
    they interact often determine the deployment architecture. The deployment architecture
    is strongly connected to the quality attributes of scalability, performance, security,
    and interoperability.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时结构，即运行时创建的对象以及它们的交互，通常决定了部署架构。部署架构与可伸缩性、性能、安全性和互操作性等质量属性密切相关。
- en: 'The module structures, in terms of how the code is broken down and organized
    into modules and packages for task breakdown, often has a direct bearing on the
    maintainability and modifiability (extensibility) of a system. This is explained
    as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块结构，即代码如何分解和组织成模块和包以进行任务分解，通常直接影响系统的可维护性和可修改性（可扩展性）。解释如下：
- en: Code which is organized with a view to extensibility would often keep the parent
    classes in separate well-defined packages with proper documentation and configuration,
    which are then easily extensible by external modules, without the need to resolve
    too many dependencies.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的组织方式旨在可扩展性，通常会将父类放在单独定义良好的包中，并配有适当的文档和配置，这样外部模块就可以轻松地进行扩展，而无需解决太多的依赖关系。
- en: Code which is dependent on external or third-party developers (libraries, frameworks,
    and the like) would often provide setup or deployment steps, which manually or
    automatically pull in these dependencies from external sources. Such code would
    also provide documentation (README, INSTALL, and so on) which clearly document
    these steps.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于外部或第三方开发人员（库、框架等）的代码通常会提供设置或部署步骤，手动或自动地从外部来源获取这些依赖项。这样的代码还会提供文档（README、INSTALL等），清楚地记录这些步骤。
- en: An architecture picks a core set of elements
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构选择了一组核心元素
- en: A well-defined architecture clearly captures only the core set of structural
    elements required to build the core functionality of the system, and which have
    a lasting effect on the system. It does not set out to document everything about
    every component of the system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 良好定义的架构清楚地捕捉了构建系统核心功能所需的一组核心结构元素，并对系统产生持久影响。它并不打算记录系统的每个组件的所有内容。
- en: 'For example, an architect describing the architecture of a user interacting
    with a web server for browsing web pages—a typical client/server architecture—would
    focus mainly on two components: the user''s browser (client) and the remote web
    server (server), which form the core elements of the system.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，描述用户与用于浏览网页的Web服务器进行交互的架构师（典型的客户端/服务器架构）主要关注两个组件：用户的浏览器（客户端）和远程Web服务器（服务器），它们构成了系统的核心元素。
- en: The system may have other components such as multiple caching proxies in the
    path from the server to the client, or a remote cache on the server which speeds
    up web page delivery. However, this is not the focus of the architecture description.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可能有其他组件，例如从服务器到客户端的路径上有多个缓存代理，或者服务器上有一个远程缓存，可以加快网页传送速度。然而，这不是架构描述的重点。
- en: An architecture captures early design decisions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构捕捉早期设计决策
- en: This is a corollary to the characteristics described previously. The decisions
    that help an architect to focus on some core elements of the system (and their
    interactions) are a result of the early design decisions about a system. Thus,
    these decisions play a major role in further development of the system due to
    their initial weight.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前描述的特征的必然结果。帮助架构师专注于系统的一些核心元素（及其相互作用）的决策是对系统的早期设计决策的结果。因此，这些决策由于其初始权重在系统的进一步发展中起着重要作用。
- en: 'For example, an architect may make the following early design decisions after
    careful analysis of the requirements for a system:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，架构师可能在仔细分析系统需求后做出以下早期设计决策：
- en: The system will be deployed only on Linux 64-bit servers, since this satisfies
    the client requirement and performance constraints
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将仅部署在Linux 64位服务器上，因为这满足了客户的要求和性能约束。
- en: The system will use HTTP as the protocol for implementing backend APIs
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将使用HTTP作为实现后端API的协议
- en: The system will try to use HTTPS for APIs that transfer sensitive data from
    the backend to frontend using encryption certificates of 2,048 bits or higher
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将尝试使用HTTPS来传输从后端到前端的敏感数据的API，使用2048位或更高的加密证书
- en: The programming language for the system would be Python for the backend, and
    Python or Ruby for the frontend
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的编程语言将是Python用于后端，Python或Ruby用于前端
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first decision freezes the deployment choices of the system to a large extent
    to a specific OS and system architecture. The next two decisions have a lot of
    weight in implementing the backend APIs. The last decision freezes the programming
    language choices for the system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个决定在很大程度上冻结了系统的部署选择，限定了特定操作系统和系统架构。接下来的两个决定在实现后端API方面具有很大的影响。最后一个决定冻结了系统的编程语言选择。
- en: Early design decisions need to be arrived at after careful analysis of the requirements
    and matching them with the constraints – such as organizational, technical, people,
    and time constraints.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的设计决策需要在仔细分析需求并将其与约束进行匹配后做出，例如组织、技术、人员和时间约束。
- en: An architecture manages stakeholder requirements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构管理利益相关者的需求
- en: 'A system is designed and built, ultimately, at the behest of its stakeholders.
    However, it is not possible to address each stakeholder requirement to its fullest
    due to an often contradictory nature of such requirements. Following are some
    examples:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的设计和构建最终是为了满足利益相关者的要求。然而，由于这些要求往往是矛盾的，因此不可能完全满足每个利益相关者的要求。以下是一些例子：
- en: The marketing team is concerned with having a full-featured software application,
    whereas, the developer team is concerned with *feature creep* and performance
    issues when adding a lot of features.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场团队关心拥有功能齐全的软件应用程序，而开发团队关心在添加许多功能时的*功能蔓延*和性能问题。
- en: The system architect is concerned with using the latest technology to scale
    out his deployments to the cloud, while the project manager is concerned about
    the impact such technology deployments will have on his budget. The end user is
    concerned about correct functionality, performance, security, usability, and reliability,
    while the development organization (architect, development team, and managers)
    is concerned with delivering all these qualities while keeping the project on
    schedule and within budget.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构师关注使用最新技术将其部署扩展到云端，而项目经理关注这种技术部署对其预算的影响。最终用户关注正确的功能、性能、安全性、可用性和可靠性，而开发组织（架构师、开发团队和经理）关注在保持项目进度和预算范围内交付所有这些质量的同时。
- en: A good architecture tries its best to balance out these requirements by making
    trade-offs, and delivering a system with good quality attributes while keeping
    the people and resource costs under limits.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的架构尽力平衡这些要求，通过权衡，提供具有良好质量属性的系统，同时保持人力和资源成本在限制范围内。
- en: An architecture also provides a common language among the stakeholders, which
    allows them to communicate efficiently via expressing these constraints, and helping
    the architect zero-in towards an architecture that best captures these requirements
    and their trade-offs.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构还为利益相关者提供了一个共同的语言，使他们能够通过表达这些约束来有效地进行沟通，并帮助架构师朝着最能满足这些要求和它们的权衡的架构前进。
- en: An architecture influences the organizational structure
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构影响组织结构
- en: The system structures an architecture describes quite often have a direct mapping
    to the structure of the teams that build those systems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统结构描述的架构往往直接映射到构建这些系统的团队的结构。
- en: For example, an architecture may have a data access layer which describes a
    set of services that read and write large sets of data—it is natural that such
    a system gets functionally assigned to the database team, which already has the
    required skill sets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个架构可能有一个数据访问层，描述了一组读写大量数据的服务——这样的系统自然会被分配给数据库团队，他们已经具备所需的技能。
- en: 'Since the architecture of a system is its best description of the top-down
    structures, it is also often used as the basis for the task-breakdown structures.
    Thus, software architecture has often a direct bearing on the organizational structures
    that build it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统的架构是对自上而下结构的最佳描述，因此它经常被用作任务分解结构的基础。因此，软件架构往往直接影响构建它的组织结构：
- en: '![An architecture influences the organizational structure](../Images/image00366.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![架构影响组织结构](../Images/image00366.jpeg)'
- en: System architecture for a search web application
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索Web应用程序的系统架构
- en: 'The following diagram shows the mapping to the team structure which would be
    building this application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了构建此应用程序的团队结构的映射：
- en: '![An architecture influences the organizational structure](../Images/image00367.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![架构影响组织结构](../Images/image00367.jpeg)'
- en: An architecture is influenced by its environment
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构受其环境的影响
- en: 'An environment imposes outside constraints or limits within which an architecture
    must function. In the literature, these are often called *architecture in context*
    [Ref: Bass, Kazman]. Some examples are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 环境对架构必须运行的外部约束或限制。在文献中，这些通常被称为*上下文中的架构* [参考：Bass，Kazman]。以下是一些例子：
- en: '**Quality attribute requirements**: In modern day web applications, it is very
    common to specify the scalability and availability requirements of the application
    as an early technical constraint, and capture it in the architecture. This is
    an example of a technical context from a business perspective.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量属性要求**：在现代Web应用程序中，很常见地将应用程序的可扩展性和可用性要求作为早期的技术约束，并在架构中加以捕捉。这是从业务角度看的技术背景的一个例子。'
- en: '**Standards conformance**: In some organizations where there is often a large
    set of governing standards for software, especially those in the banking, insurance,
    and health-care domains, these get added to the early constraints of the architecture.
    This is an example of an external technical context.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准符合**：在一些组织中，软件通常有一大套管理标准，特别是在银行、保险和医疗保健领域，这些标准被添加到架构的早期约束中。这是一个外部技术背景的例子。'
- en: '**Organizational constraints**: It is common to see that organizations which
    either have an experience with a certain architectural style or a set of teams
    operating with certain programming environments which impose such a style (J2EE
    is a good example), prefer to adopt similar architectures for future projects
    as a way to reduce costs and ensure productivity due to current investments in
    such architectures and related skills. This is an example of an internal business
    context.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织约束**：通常可以看到，那些具有某种架构风格经验或一组团队在某些编程环境中操作的组织（J2EE是一个很好的例子），更倾向于采用类似的架构来减少成本，并确保由于当前对这些架构和相关技能的投资而提高生产力。这是一个内部业务背景的例子。'
- en: '**Professional context**: An architect''s set of choices for a system''s architecture,
    aside from these outside contexts, is mostly shaped from his set of unique experiences.
    It is common for an architect to continue using a set of architectural choices
    that he has had the most success with in his past for new projects.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专业背景**：除了这些外部背景之外，架构师对系统架构的选择大多是根据他独特经验的选择。架构师通常会继续在新项目中使用他过去取得最大成功的一套架构选择。'
- en: Architecture choices also arise from one's own education and professional training,
    and also from the influence of one's professional peers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 架构选择也源自个人的教育和专业培训，以及来自专业同行的影响。
- en: An architecture documents the system
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构记录了系统
- en: Every system has an architecture, whether it is officially documented or not.
    However, properly documented architectures can function as an effective documentation
    for the system. Since an architecture captures the system's initial requirements,
    constraints, and stakeholder trade-offs, it is a good practice to document it
    properly. The documentation can be used as a basis for training later on. It also
    helps in continued stakeholder communication, and for subsequent iterations on
    the architecture based on changing requirements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有一个架构，无论它是否被正式记录。然而，适当记录的架构可以作为系统的有效文档。由于架构捕获了系统的初始需求、约束和利益相关者的权衡，适当记录它是一个很好的做法。文档可以作为后续培训的基础。它还有助于持续的利益相关者沟通，并根据不断变化的需求进行架构的后续迭代。
- en: The simplest way to document an architecture is to create diagrams for the different
    aspects of the system and organizational architecture such as Component Architecture,
    Deployment Architecture, Communication Architecture, and the Team or Enterprise
    Architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记录架构的最简单方法是为系统的不同方面和组织架构创建图表，例如组件架构、部署架构、通信架构以及团队或企业架构。
- en: Other data that can be captured early include the system requirements, constraints,
    early design decisions, and rationale for those decisions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以早期捕获的其他数据包括系统需求、约束、早期设计决策以及这些决策的基本原理。
- en: An architecture often conforms to a pattern
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构通常符合一种模式
- en: Most architectures conform to certain set of styles which have had a lot of
    success in practice. These are referred to as architectural patterns. Examples
    of such patterns are Client-Server, Pipes and Filters, Data-based architectures,
    and others. When an architect chooses an existing pattern, he gets to refer to
    and reuse a lot of existing use cases and examples related to such patterns. In
    modern day architectures, the job of the architect comes down to mixing and matching
    existing sets of such readily available patterns to solve the problem at hand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数架构符合一定的在实践中取得了很大成功的风格。这些被称为架构模式。此类模式的示例包括客户端-服务器、管道和过滤器、基于数据的架构等。当架构师选择现有模式时，他可以参考和重用许多与这些模式相关的现有用例和示例。在现代架构中，架构师的工作归结为混合和匹配现有的这些可用模式集来解决手头的问题。
- en: 'For example, the following diagram shows an example of a client-server architecture:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图表显示了客户端-服务器架构的示例：
- en: '![An architecture often conforms to a pattern](../Images/image00368.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![架构通常符合一种模式](../Images/image00368.jpeg)'
- en: Example of Client-Server Architecture
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构示例
- en: 'And the following diagram describes another common architecture pattern, namely,
    the Pipes and Filters architecture for processing streams of data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了另一种常见的架构模式，即管道和过滤器架构，用于处理数据流：
- en: '![An architecture often conforms to a pattern](../Images/image00369.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![架构通常符合一种模式](../Images/image00369.jpeg)'
- en: Example of Pipe and Filters Architecture
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和过滤器架构示例
- en: We will see examples of architectural patterns later in this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面看到架构模式的示例。
- en: Importance of Software Architecture
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的重要性
- en: So far, we have discussed the fundamental principles of software architecture,
    and also seen some of its characteristics. These sections, of course, assumed
    that software architecture is important, and is a critical step of the software
    development process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了软件架构的基本原则，并且也看到了一些特征。当然，这些部分假定了软件架构是重要的，并且是软件开发过程中的关键步骤。
- en: 'It is time to play devil''s advocate, and look back at software architecture
    and ask some existential questions about it as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候扮演魔鬼的辩护人，回顾软件架构并提出一些关于它的存在性问题，如下所示：
- en: Why Software Architecture?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么软件架构？
- en: Why is Software Architecture important?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么软件架构很重要？
- en: Why not build a system without a formal Software Architecture?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不建立一个没有正式软件架构的系统？
- en: 'Let us take a look at the critical insights that software architecture provides,
    which would otherwise be missing from an informal software development process.
    We are only focusing on the technical or developmental aspects of the system in
    the following table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看软件架构提供的关键见解，这些见解在非正式的软件开发过程中将会缺失。我们只关注以下表中系统的技术或开发方面：
- en: '| Aspect | Insight/Impact | Examples |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 方面 | 洞察/影响 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Architecture selects quality attributes to be optimized for a system. | Aspects
    such as scalability, availability, modifiability, security, and so on of a system
    depend on early decisions and trade-offs while selecting an architecture. You
    often trade one attribute in favor of another. | A system that is optimized for
    scalability must be developed using a decentralized architecture where elements
    are not tightly coupled. For example: microservices, brokers. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 架构选择要为系统优化的质量属性。 | 诸如可伸缩性、可用性、可修改性、安全性等系统方面取决于在选择架构时的早期决策和权衡。通常你会在一个属性和另一个属性之间进行权衡。
    | 一个优化了可伸缩性的系统必须使用分散式架构来开发，其中元素之间没有紧密耦合。例如：微服务、代理。 |'
- en: '| Architecture facilitates early prototyping. | Defining an architecture allows
    the development organization to try and build early prototypes, which gives valuable
    insights into how the system would behave without having to build the complete
    system top down. | Many organizations build out quick prototypes of services—typically,
    by building only the external APIs of these services and mocking the rest of the
    behavior. This allows for early integration tests and figuring out interaction
    issues in the architecture early on. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 架构有助于早期原型设计。 | 定义架构允许开发组织尝试并构建早期原型，这可以为系统的行为提供宝贵的见解，而无需自上而下地构建完整的系统。 | 许多组织快速构建服务的原型——通常是仅构建这些服务的外部API并模拟其余行为。这允许进行早期集成测试，并及早解决架构中的交互问题。
    |'
- en: '| Architecture allows a system to be built component-wise. | Having a well-defined
    architecture allows to reuse and assemble the existing, readily available components
    to achieve the functionality without having to implement everything from scratch.
    | Libraries or frameworks which provide ready-to-use building blocks for services.For
    example: web application frameworks such as Django/RoR, and task distribution
    frameworks such as Celery. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 架构允许系统逐个构建组件。| 有一个明确定义的架构可以重复使用和组装现有的、现成的组件，以实现功能，而不必从头开始实现所有内容。| 提供服务的现成构件的库或框架。例如：Django/RoR等Web应用框架，以及Celery等任务分发框架。'
- en: '| Architecture helps to manage changes to the system. | An architecture allows
    the architect to scope out changes to the system in terms of components that are
    affected and those which are not. This helps to keep system changes to a minimum
    when implementing new features, performance fixes, and so on. | A performance
    fix for database reads to a system would need changes only to the DB and Data
    Access Layer (DAL) if the architecture is implemented correctly. It need not touch
    the application code at all. For example, this is how most modern web frameworks
    are built. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 架构有助于管理系统的变更。| 架构允许架构师以受影响的组件和未受影响的组件来界定系统的变更。这有助于在实现新功能、性能修复等时将系统变更最小化。例如，如果架构实施正确，对系统的数据库读取进行性能修复只需要对数据库和数据访问层（DAL）进行更改，根本不需要触及应用程序代码。例如，这就是大多数现代Web框架的构建方式。'
- en: There are a number of other aspects which are related to the business context
    of a system, which architecture provides valuable insights to. However, since
    this is a book mostly on the technical aspects of software architecture, we have
    limited our discussion to the ones given in the preceding table.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些与系统的业务背景相关的其他方面，架构为此提供了宝贵的见解。然而，由于这本书主要讨论软件架构的技术方面，我们将讨论限制在前表中给出的内容。
- en: 'Now, let us take on the second question:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨第二个问题：
- en: '**Why not build a system without a formal software architecture?**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么不建立一个没有正式软件架构的系统呢？**'
- en: 'If you''ve been following the arguments so far thoroughly, it is not very difficult
    to see the answer for it. It can, however, be summarized in the following few
    statements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您迄今为止一直在认真地跟随这些论点，那么很容易看出答案。然而，可以总结为以下几个陈述：
- en: Every system *has* an architecture, whether it is documented or not
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个系统都有一个架构，无论是否有文档记录
- en: Documenting an architecture makes it formal, allowing it to be shared among
    stakeholders, making change management and iterative development possible
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录架构使其正式化，使其能够在利益相关者之间共享，从而使变更管理和迭代开发成为可能
- en: All the other benefits and characteristics of Software Architecture are ready
    to be taken advantage of when you have a formal architecture defined and documented
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有一个明确定义和记录的正式架构时，所有其他软件架构的好处和特征都可以被利用
- en: You may be still able to work and build a functional system without a formal
    architecture, but it would not produce a system which is extensible and modifiable,
    and would most likely produce a system with a set of quality attributes quite
    far away from the original requirements
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能仍然能够在没有正式架构的情况下工作和构建一个功能性的系统，但这不会产生一个可扩展和可修改的系统，很可能会产生一个与原始要求相去甚远的一组质量属性的系统
- en: System versus enterprise architecture
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统与企业架构
- en: 'You may have heard the term *architect* used in a few contexts. The following
    job *roles* or *titles* are pretty common in the software industry for architects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过*架构师*这个术语。在软件行业中，以下*角色*或*头衔*对架构师来说是相当常见的：
- en: The Technical architect
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术架构师
- en: The Security architect
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全架构师
- en: The Information architect
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息架构师
- en: The Infrastructure architect
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础架构架构师
- en: 'You also may have heard the term *System architect*, perhaps the term *Enterprise
    architect*, and maybe, *Solution architect* also. The interesting question is:
    *What do these people do?*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也听说过*系统架构师*这个术语，也许还有*企业架构师*，也可能是*解决方案架构师*。有趣的问题是：*这些人做什么？*
- en: Let us try and find the answer to this question.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着找到这个问题的答案。
- en: 'An Enterprise architect looks at the overall business and organizational strategies
    for an organization, and applies architecture principles and practices to guide
    the organization through the business, information, process, and technology changes
    necessary to execute their strategies. The Enterprise architect usually has a
    higher strategy focus and a lower technology focus. The other architect roles
    take care of their own subsystems and processes. For example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 企业架构师审视组织的整体业务和组织战略，并应用架构原则和实践指导组织通过业务、信息、流程和技术变化，以执行他们的战略。企业架构师通常更关注战略，而较少关注技术。其他架构师角色负责自己的子系统和流程。例如：
- en: '**The Technical architect**: The Technical architect is concerned with the
    core technology (hardware/software/network) used in an organization. A Security
    architect creates or tunes the security strategy used in applications to fit the
    organization''s information security goals. An Information architect comes up
    with architectural solutions to make information available to/from applications
    in a way that facilitates the organization''s business goals.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术架构师**：技术架构师关注组织中使用的核心技术（硬件/软件/网络）。安全架构师创建或调整应用程序中使用的安全策略，以适应组织的信息安全目标。信息架构师提出架构解决方案，使信息能够以有利于组织业务目标的方式在应用程序之间可用。'
- en: These specific architectural roles are all concerned with their own systems
    and subsystems. So, each of these roles is a System architect role.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定的建筑角色都关注自己的系统和子系统。因此，这些角色中的每一个都是系统架构师角色。
- en: These architects help the Enterprise architect to understand the smaller picture
    of each of the business domain they are responsible for, which helps the Enterprise
    architect to get information that will aid him in formulating business and organizational
    strategies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些架构师帮助企业架构师了解他们负责的每个业务领域的细节，这有助于企业架构师获取有助于制定业务和组织战略的信息。
- en: '**The System architect**: A System architect usually has a higher technology
    focus and a lower strategy focus. It is a practice in some service-oriented software
    organizations to have a Solution architect, who combines the different systems
    to create a solution for a specific client. In such cases, the different architect
    roles are often combined into one, depending on the size of the organization,
    and the specific time and cost requirements of the project.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统架构师**：系统架构师通常更注重技术，较少关注战略。在一些面向服务的软件组织中，通常会有解决方案架构师，他将不同的系统结合起来为特定客户创建解决方案。在这种情况下，不同的架构师角色通常会根据组织的规模以及项目的特定时间和成本要求进行合并。'
- en: '**The Solution architect**: A Solution architect typically straddles the middle
    position when it comes to strategy versus technology focus and organizational
    versus project scope.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案架构师**：解决方案架构师通常处于战略与技术关注以及组织与项目范围之间的中间位置。'
- en: 'The following schematic diagram depicts the different layers in an organization–**Technology**,
    **Application**, **Data**, **People**, **Process**, and **Business**, and makes
    the focus area of the architect roles very clear:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示意图描述了组织中不同层次的**技术**、**应用**、**数据**、**人员**、**流程**和**业务**，并清晰地展示了架构师角色的关注领域：
- en: '![System versus enterprise architecture](../Images/image00370.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![系统与企业架构](../Images/image00370.jpeg)'
- en: Enterprise versus System architects
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 企业与系统架构师
- en: Let's discuss the preceding diagram a bit to understand the picture it lays
    out.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微讨论一下前面的图表，以了解它所呈现的情况。
- en: The System architect is pictured on the bottom-left side of the diagram, looking
    at the system components of the enterprise. His focus is on the applications that
    power the enterprise, their data, and the hardware and software stack powering
    the applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构师位于图表的左下方，关注企业的系统组件。他的关注点是驱动企业的应用程序、它们的数据以及驱动应用程序的硬件和软件堆栈。
- en: The Enterprise architect, on the other hand, is pictured on the top, having
    a top-down view of the enterprise including the business goals and the people,
    and not just the underlying systems that power the organization. The vertical
    stack of business processes connect the technical components that power the organization
    with its people and business components. These processes are defined by the Enterprise
    architect in discussion with the other stakeholders.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，企业架构师位于顶部，从顶层视角看待企业，包括业务目标和人员，而不仅仅是支撑组织的基础系统。业务流程的垂直堆栈将支撑组织的技术组件与其人员和业务组件连接起来。这些流程是由企业架构师与其他利益相关者讨论定义的。
- en: 'Now that you have understood the picture behind Enterprise and System architecture,
    let us take a look at some formal definitions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了企业和系统架构背后的图景，让我们来看一些正式的定义：
- en: '*"Enterprise Architecture is a conceptual blueprint that defines the structure
    and behavior of an organization. It determines how the organization''s structure,
    processes, personnel and flow of information is aligned to its core goals to efficiently
    achieve its current and future objectives."*'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"企业架构是定义组织结构和行为的概念蓝图。它确定了组织结构、流程、人员和信息流如何与其核心目标对齐，以有效实现当前和未来的目标。"*'
- en: '>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '"A system architecture is the fundamental organization of a system, represented
    by its structural and behavioral views. The structure is determined by the components
    of the system and the behavior by the relationships between them and their interaction
    with external systems."'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"系统架构是系统的基本组织，由其结构和行为视图表示。结构由系统的组件确定，行为由它们之间的关系以及与外部系统的互动确定。"'
- en: An Enterprise architect is concerned with how the different elements in an organization
    and their interplay is tuned towards achieving the goals of the organization in
    an efficient manner. In this work, he needs the support of not just the technical
    architects in the organization, but also people managing the organization, such
    as project managers and human resource professionals.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 企业架构师关注的是组织中不同元素及其相互作用如何调整以有效实现组织目标。在这项工作中，他不仅需要组织中的技术架构师的支持，还需要项目经理和人力资源专业人员等组织管理人员的支持。
- en: A Systems architect, on the other hand, is worried about how the core system
    architecture maps to the software and hardware architecture, and the various details
    of human interactions with the components in the system. His concern never arises
    above the boundaries defined by the system and its interactions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，系统架构师关注核心系统架构如何映射到软件和硬件架构，以及人与系统组件的各种细节交互。他的关注点永远不会超出系统及其交互所定义的范围。
- en: 'The following diagram depicts the different focus areas and scopes of the different
    architect roles that we''ve discussed so far:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了我们迄今讨论的不同架构师角色的不同关注领域和范围：
- en: '![System versus enterprise architecture](../Images/image00371.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![系统与企业架构](../Images/image00371.jpeg)'
- en: Scope and focus of various architect roles in a software organization
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组织中各种架构师角色的范围和重点
- en: Architectural quality attributes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构质量属性
- en: Let us now focus on an aspect which forms the main topic for the rest of this
    book–Architectural Quality Attributes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们关注本书其余部分的主题——架构质量属性。
- en: In a previous section, we discussed how an architecture balances and optimizes
    stakeholder requirements. We also saw some examples of contradicting stakeholder
    requirements, which an architect seeks to balance, by choosing an architecture
    which does the necessary trade-offs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了架构如何平衡和优化利益相关者的需求。我们还看到了一些相互矛盾的利益相关者需求的例子，架构师通过选择必要的权衡来平衡这些需求。
- en: 'The term **quality attribute** has been used to loosely define some of these
    aspects that an architecture makes trade-offs for. It is now the time to formally
    define what an Architectural Quality Attribute is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**质量属性**已被用来宽泛地定义架构为之做出权衡的一些方面。现在是正式定义什么是架构质量属性的时候了：
- en: '*"A quality attribute is a measurable and testable property of a system which
    can be used to evaluate the performance of a system within its prescribed environment
    with respect to its non-functional aspects"*'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"质量属性是系统的可度量和可测试的属性，可用于评估系统在其规定环境中相对于其非功能方面的性能"*'
- en: 'There are a number of aspects that fit this general definition of an architectural
    quality attribute. However, for the rest of this book, we will be focusing on
    the following quality attributes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方面符合架构质量属性的一般定义。然而，在本书的其余部分，我们将专注于以下质量属性：
- en: Modifiability
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可修改性
- en: Testability
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Scalability and performance
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性和性能
- en: Availability
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Security
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Deployability
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可部署性
- en: Modifiability
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可修改性
- en: Many studies show that about 80% of the cost of a typical software system occurs
    after the initial development and deployment. This shows how important modifiability
    is to a system's initial architecture.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究表明，典型软件系统的成本约80%发生在初始开发和部署之后。这显示了可修改性对系统初始架构的重要性。
- en: Modifiability can be defined as the ease with which changes can be made to a
    system, and the flexibility at which the system adjusts to the changes. It is
    an important quality attribute, as almost every software system changes over its
    lifetime—to fix issues, for adding new features, for performance improvements,
    and so on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改性可以定义为对系统进行更改的容易程度，以及系统调整到变化的灵活性。这是一个重要的质量属性，因为几乎每个软件系统在其生命周期中都会发生变化——修复问题，添加新功能，进行性能改进等。
- en: 'From an architect''s perspective, the interest in modifiability is about the
    following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构师的角度来看，对可修改性的兴趣在于以下方面：
- en: '**Difficulty**: The ease with which changes can be made to a system'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难度**：对系统进行更改的容易程度'
- en: '**Cost**: In terms of time and resources required to make the changes'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：对进行更改所需的时间和资源而言'
- en: '**Risks**: Any risk associated with making changes to the system'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险**：与对系统进行更改相关的任何风险'
- en: Now, what kind of changes are we talking about here? Is it changes to code,
    changes to deployment, or changes to the entire architecture?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这里谈论的是什么样的变化？是对代码的改动，对部署的改动，还是对整个架构的改动？
- en: 'The answer is: it can be at *any* level.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：它可以在*任何*级别。
- en: 'From an architecture perspective, these changes can be captured at generally
    the following three levels:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构的角度来看，这些变化通常可以在以下三个级别进行捕捉：
- en: '**Local**: A local change only affects a specific element. The element can
    be a piece of code such as a function, a class, a module, or a configuration element
    such as an XML or JSON file. The change *does not cascade* to any neighboring
    element or to the rest of the system. Local changes are the easiest to make, and
    the least risky of all. The changes can be usually quickly validated with local
    unit tests.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本地**：本地变化只影响特定元素。该元素可以是代码的一部分，如函数、类、模块，或者是配置元素，如XML或JSON文件。变化*不会级联*到任何相邻元素或系统的其余部分。本地变化是最容易进行的，也是最不冒险的。这些变化通常可以通过本地单元测试快速验证。'
- en: '**Non-local**: These changes involve more than one element. The examples are
    as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非本地**：这些变化涉及多个元素。以下是一些例子：'
- en: Modifying a database schema, which then needs to cascade into the model class
    representing that schema in the application code.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数据库模式，然后需要在应用程序代码中表示该模式的模型类中进行级联。
- en: Adding a new configuration parameter in a JSON file, which then needs to be
    processed by the parser parsing the file and/or the application(s) using the parameter.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JSON文件中添加一个新的配置参数，然后需要由解析器解析文件和/或使用参数的应用程序进行处理。
- en: Non-local changes are more difficult to make than local changes, require careful
    analysis, and wherever possible, integration tests to avoid code regressions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 非本地变化比本地变化更难进行，需要仔细分析，并在可能的情况下进行集成测试，以避免代码回归。
- en: '**Global**: These changes either involve architectural changes from top down,
    or changes to elements at the global level, which cascade down to a significant
    part of the software system. The examples are as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全局**：这些变化要么涉及自顶向下的架构变化，要么涉及全局级别的元素变化，这些变化会级联到软件系统的重要部分。以下是一些例子：'
- en: Changing a system's architecture from RESTful to messaging (SOAP, XML-RPC, and
    others) based web services
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统架构从RESTful更改为基于消息传递（SOAP、XML-RPC等）的Web服务
- en: Changing a web application controller from Django to an Angular-js based component
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Web应用程序控制器从Django更改为基于Angular-js的组件
- en: A performance change requirement which needs all data to be preloaded at the
    frontend to avoid any inline model API calls for an online news application
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能变化要求所有数据在前端预加载，以避免在线新闻应用程序中的任何内联模型API调用
- en: These changes are the riskiest, and also the costliest, in terms of resources,
    time and money. An architect needs to carefully vet the different scenarios that
    may arise from the change, and get his team to model them via integration tests.
    Mocks can be very useful in these kinds of large-scale changes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化是最具风险的，也是最昂贵的，涉及资源、时间和金钱。架构师需要仔细审查变化可能带来的不同情景，并让他的团队通过集成测试对其进行建模。在这类大规模变化中，模拟可以非常有用。
- en: 'The following table shows the relation between **Cost** and **Risk** for the
    different levels of system modifiability:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了不同系统可修改性水平的**成本**和**风险**之间的关系：
- en: '| Level | Cost | Risk |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 等级 | 成本 | 风险 |'
- en: '| --- | --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Local | Low | Low |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 本地 | 低 | 低 |'
- en: '| Non-local | Medium | Medium |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 非本地 | 中 | 中 |'
- en: '| Global | High | High |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 全局 | 高 | 高 |'
- en: 'Modifiability at the code level is also directly related to its readability:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码级别的可修改性也与其可读性直接相关：
- en: '*"The more readable a code is the more modifiable it is. Modifiability of a
    code goes down in proportion to its readability."*'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “代码越可读，就越容易修改。代码的可修改性与其可读性成反比。”
- en: The modifiability aspect is also related to the maintainability of the code.
    A code module which has its elements very tightly coupled would yield to modification
    much lesser than a module which has a loosely coupled elements—this is the **Coupling**
    aspect of modifiability.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改性方面也与代码的可维护性相关。代码模块中元素耦合度非常紧密的话，修改的可能性就会比元素耦合度较松的模块小得多——这就是可修改性的**耦合**方面。
- en: Similarly, a class or module which does not define its role and responsibilities
    clearly would be more difficult to modify than another one which has well-defined
    responsibility and functionality. This aspect is called **Cohesion** of a software
    module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个类或模块如果没有清晰地定义其角色和责任，就会比另一个定义了明确责任和功能的类或模块更难修改。这个方面被称为软件模块的**内聚性**。
- en: 'The following table shows the relation between **Cohesion**, **Coupling,**
    and **Modifiability** for an imaginary Module A. Assume that the coupling is from
    this module to another Module B:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了假设模块A的**内聚性**、**耦合**和**可修改性**之间的关系。假设耦合是从这个模块到另一个模块B：
- en: '| Cohesion | Coupling | Modifiability |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 内聚性 | 耦合 | 可修改性 |'
- en: '| --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Low | High | Low |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 高 | 低 |'
- en: '| Low | Low | Medium |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 低 | 中 |'
- en: '| High | High | Medium |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 高 | 高 | 中 |'
- en: '| High | Low | High |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 高 | 低 | 高 |'
- en: It is pretty clear from the preceding table that having higher Cohesion and
    lower Coupling is the best scenario for the modifiability of a code module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表格可以清楚地看出，内聚性更高，耦合更低是代码模块可修改性的最佳情况。
- en: 'Other factors that affect modifiability are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 影响可修改性的其他因素如下：
- en: '**Size of a module (number of lines of code)**: Modifiability decreases when
    size increases.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块的大小（代码行数）**：大小增加时，可修改性减少。'
- en: '**Number of team members working on a module**: Generally, a module becomes
    less modifiable when a larger number of team members work on the module due to
    the complexities in merging and maintaining a uniform code base.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在模块上工作的团队成员数量**：通常，当更多的团队成员在模块上工作时，模块变得不太可修改，因为合并和维护统一的代码基础变得更加复杂。'
- en: '**External third-party dependencies of a module**: The larger the number of
    external third-party dependencies, the more difficult it is to modify the module.
    This can be thought of as an extension of the coupling aspect of a module.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块的外部第三方依赖**：外部第三方依赖的数量越多，修改模块就越困难。这可以被视为模块耦合方面的延伸。'
- en: '**Wrong use of the module API**: If there are other modules which make use
    of the private data of a module rather than (correctly) using its public API,
    it is more difficult to modify the module. It is important to ensure proper usage
    standards of modules in your organization to avoid such scenarios. This can be
    thought of as an extreme case of tight **Coupling**.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误使用模块API**：如果有其他模块使用模块的私有数据而不是（正确地）使用其公共API，那么修改模块就会更加困难。在组织中确保模块的正确使用标准以避免这种情况非常重要。这可以被视为紧密**耦合**的极端情况。'
- en: Testability
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性
- en: Testability refers to how much a software system is amenable to demonstrating
    its faults through testing. Testability can also be thought of as how much a software
    system *hides* its faults from end users and system integration tests—the more
    testable a system is, the less it is able to hide its faults.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性指的是软件系统通过测试展示其故障的程度。可测试性也可以被视为软件系统*隐藏*其故障程度的程度——系统越可测试，就越难以隐藏其故障。
- en: Testability is also related to how predictable a software system's behavior
    is. The more predictable a system, the more it allows for repeatable tests, and
    for developing standard test suites based on a set of input data or criteria.
    Unpredictable systems are much less amenable to any kind of testing, or, in the
    extreme case, not testable at all.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性也与软件系统行为的可预测性相关。系统越可预测，就越允许可重复的测试，并且可以基于一组输入数据或标准开发标准测试套件。不可预测的系统很难进行任何形式的测试，或者在极端情况下根本无法测试。
- en: In software testing, you try to control a system's behavior by, typically, sending
    it a set of known inputs, and then observing the system for a set of known outputs.
    Both of these combine to form a testcase. A test suite or test harness, typically,
    consists of many such test cases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试中，通常通过发送一组已知输入来控制系统的行为，然后观察系统的一组已知输出。这两者结合起来形成一个测试用例。一个测试套件或测试工具通常包括许多这样的测试用例。
- en: 'Test assertions are the techniques that are used to fail a test case when the
    output of the element under the test does not match the expected output for the
    given input. These assertions are usually manually coded at specific steps in
    the test execution stage to check the data values at different steps of the testcase:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 测试断言是用于在测试用例的输出与给定输入的预期输出不匹配时使测试用例失败的技术。这些断言通常在测试执行阶段的特定步骤手动编码，以检查测试用例的不同步骤的数据值：
- en: '![Testability](../Images/image00372.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![可测试性](../Images/image00372.jpeg)'
- en: Representative flowchart of a simple unit test case for function f('X') = 'Y'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 简单单元测试用例函数f('X') = 'Y'的代表性流程图
- en: The preceding diagram shows an example of a representative flowchart for a testable
    function **"f"** for a sample input "**X**" with expected output "**Y**".
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一个代表性流程图的例子，用于可测试函数**“f”**，输入为**“X”**，预期输出为**“Y”**。
- en: In order to recreate the session or state at the time of a failure, the *record*/*playback*
    strategy is often used. This employs specialized software (such as Selenium),
    which records all user actions that led to a specific fault, and saves it as a
    testcase. The test is reproduced by replaying the testcase using the same software
    which tries to simulate the same testcase; this is done by repeating the same
    set and order of UI actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在故障发生时重新创建会话或状态，通常使用*记录*/*回放*策略。这使用专门的软件（如Selenium），记录导致特定故障的所有用户操作，并将其保存为测试用例。通过使用相同的软件重放测试用例来再现测试，该软件尝试模拟相同的测试用例；这是通过重复相同的UI操作集和顺序来完成的。
- en: Testability is also related to the complexity of code in a way very similar
    to modifiability. A system becomes more testable when parts of it can be isolated
    and made to work independent of the rest of the system. In other words, a system
    with low coupling is more testable than a system with high coupling.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试性也与代码的复杂性有关，与可修改性非常相似。当系统的部分可以被隔离并独立于系统的其余部分工作时，系统变得更具可测试性。换句话说，耦合度低的系统比耦合度高的系统更具可测试性。
- en: Another aspect of testability, which is related to the predictability mentioned
    earlier, is to reduce non-determinism. When writing test suites, we need to isolate
    the elements that are to be tested from other parts of the system which have a
    tendency to behave unpredictably so that the tested element's behavior becomes
    predictable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的另一个方面与前面提到的可预测性有关，即减少非确定性。在编写测试套件时，我们需要将要测试的元素与系统的其他部分隔离开来，这些部分往往表现出不可预测的行为，以便测试元素的行为变得可预测。
- en: An example is a multi-threaded system, which responds to events raised in other
    parts of the system. The entire system is probably quite unpredictable, and not
    amenable to repeated testing. Instead one needs to separate the events subsystem,
    and possibly, mock its behavior so that those inputs can be controlled, and the
    subsystem which receives the events become predictable and hence, testable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是多线程系统，它响应系统其他部分引发的事件。整个系统可能相当不可预测，不适合重复测试。相反，需要将事件子系统分离出来，并可能模拟其行为，以便可以控制这些输入，并且接收事件的子系统变得可预测，因此可测试。
- en: 'The following schematic diagram explains the relationship between the testability
    and predictability of a system to the **Coupling** and **Cohesion** between its
    components:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示意图解释了系统的可测试性和可预测性与其组件之间的**耦合**和**内聚**之间的关系：
- en: '![Testability](../Images/image00373.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![可伸缩性](../Images/image00374.jpeg)'
- en: Relation of Testability & Predictability of a system to Coupling and Cohesion
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可测试性和可预测性与耦合和内聚的关系
- en: Scalability
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Modern-day web applications are all about *scaling up*. If you are part of any
    modern-day software organization, it is very likely that you have heard about
    or worked on an application that is written for the cloud, which is able to scale
    up elastically on demand.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序都是关于*扩展*的。如果您是现代软件组织的一部分，很可能您已经听说过或者正在开发一款为云端编写的应用程序，它能够根据需求弹性扩展。
- en: Scalability of a system is its capacity to accommodate increasing workload on
    demand while keeping its performance within acceptable limits.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可伸缩性是指其在保持性能在可接受范围内的情况下，能够容纳不断增加的工作负载的能力。
- en: 'Scalability in the context of a software system, typically, falls into two
    categories, which are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件系统的背景下，可伸缩性通常分为两类，如下所示：
- en: '**Horizontal scalability**: Horizontal scalability implies scaling out/in a
    software system by adding more computing nodes to it. Advances in cluster computing
    in the last decade have given rise to the advent of commercial horizontally scalable
    **elastic** systems as services on the Web. A well-known example is Amazon Web
    Services. In horizontally scalable systems, typically, data and/or computation
    is done on units or nodes, which are, usually, virtual machines running on commodity
    systems known as virtual private servers (VPS). The scalability is achieved "n"
    times by adding n or more nodes to the system, typically fronted by a load balancer.
    Scaling out means expanding the scalability by adding more nodes, and scaling
    in means reducing the scalability by removing existing nodes:![Scalability](../Images/image00374.jpeg)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平可伸缩性**：水平可伸缩性意味着通过向软件系统添加更多计算节点来扩展/缩减系统。过去十年中集群计算的进步催生了商业水平可伸缩的**弹性**系统作为Web服务的出现。一个著名的例子是亚马逊网络服务。在水平可伸缩系统中，通常数据和/或计算是在单元或节点上进行的，通常是在称为虚拟专用服务器（VPS）的商品系统上运行的虚拟机。通过向系统添加n个或更多节点，通常由负载均衡器进行前端处理，可实现“n”倍的可伸缩性。扩展意味着通过添加更多节点来扩展可伸缩性，而缩减意味着通过移除现有节点来减少可伸缩性。'
- en: Example deployment architecture showing horizontally scaling a web application
    server
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 显示水平扩展Web应用程序服务器的示例部署架构
- en: '**Vertical scalability**: Vertical scalability involves adding or removing
    resources from a single node in a system. This is usually done by adding or removing
    CPUs or RAM (memory) from a single virtual server in a cluster. The former is
    called scaling up, and the latter, scaling down. Another kind of scaling up is
    increasing the capacity of an existing software process in the system—typically,
    by augmenting its processing power. This is usually done by increasing the number
    of processes or threads available to an application. Some examples are as follows:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直可伸缩性**：垂直可伸缩性涉及向系统中的单个节点添加或移除资源。通常是通过向集群中的单个虚拟服务器添加或移除CPU或RAM（内存）来实现的。前者称为扩展，后者称为缩减。另一种扩展是增加系统中现有软件进程的容量，通常是通过增加可用于应用程序的进程或线程数量来实现的。一些例子如下：'
- en: Increasing the capacity of an Nginx server process by increasing its number
    of worker processes
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加其工作进程的数量来增加Nginx服务器进程的容量
- en: Increasing the capacity of a PostgreSQL server by increasing its number of maximum
    connections
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加其最大连接数来增加PostgreSQL服务器的容量
- en: Performance
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'Performance of a system is related to its scalability. Performance of a system
    can be defined as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的性能与其可伸缩性相关。系统的性能可以定义如下：
- en: '*"Performance of a computer system is the amount of work accomplished by a
    system using a given unit of computing resource. Higher the work/unit ratio, higher
    the performance."*'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“计算机系统的性能是系统使用给定的计算资源单位所完成的工作量。工作/单位比率越高，性能越高。”*'
- en: 'The unit of computing resource to measure performance can be one of the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 用于衡量性能的计算资源单位可以是以下之一：
- en: '**Response time**: How much time a function or any unit of execution takes
    to execute in terms of real time (user time) and clock time (CPU time).'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：函数或任何执行单元在实时（用户时间）和时钟时间（CPU时间）方面执行所需的时间。'
- en: '**Latency**: How much time it takes for a system to get its stimulation, and
    then provide a response. An example is the time it takes for the request-response
    loop of a web application to complete, measured from the end-user perspective.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：系统获取刺激并提供响应所需的时间。一个例子是Web应用程序的请求-响应循环完成所需的时间，从最终用户的角度来衡量。'
- en: '**Throughput**: The rate at which a system processes its information. A system
    which has higher performance would usually have a higher throughput, and correspondingly
    higher scalability. An example is the throughput of an e-commerce website measured
    as the number of transactions completed per minute.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：系统处理信息的速率。性能更高的系统通常具有更高的吞吐量，相应地具有更高的可伸缩性。一个例子是电子商务网站的吞吐量，以每分钟完成的交易数量来衡量。'
- en: Performance is closely tied to scalability, especially, vertical scalability.
    A system that has excellent performance with respect to its memory management
    would easily scale up vertically by adding more RAM.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 性能与可伸缩性密切相关，特别是纵向可伸缩性。一个在内存管理方面表现出色的系统将通过添加更多RAM轻松实现纵向扩展。
- en: Similarly, a system that has multi-threaded workload characteristics and is
    written optimally for a multicore CPU, would scale up by adding more CPU cores.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有多线程工作负载特性并且针对多核CPU进行了最佳编写的系统，将通过添加更多CPU核来扩展。
- en: Horizontal scalability is thought of as having no direct connection to the performance
    of a system within its own compute node. However, if a system is written in a
    way that it doesn't utilize the network effectively, thereby producing network
    latency issues, it may have a problem scaling horizontally effectively, as the
    time spent on network latency would offset any gain in scalability obtained by
    distributing the work.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 水平可伸缩性被认为与系统在其自己的计算节点内的性能没有直接联系。然而，如果系统以一种不利用网络的方式编写，从而产生网络延迟问题，它可能会在水平方面有效地扩展，因为在网络延迟上花费的时间会抵消通过分发工作获得的可伸缩性增益。
- en: Some dynamic programming languages such as Python have built-in scalability
    issues when it comes to scaling up vertically. For example, the **Global Interpreter
    Lock** (**GIL**) of Python (CPython) prevents it from making full use of the available
    CPU cores for computing by multiple threads.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动态编程语言，如Python，在纵向扩展时存在内置的可伸缩性问题。例如，Python（CPython）的全局解释器锁（GIL）阻止它通过多个线程充分利用可用的CPU核进行计算。
- en: Availability
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Availability refers to the property of readiness of a software system to carry
    out its operations when the need arises.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性是指软件系统在需要时执行其操作的准备性质。
- en: Availability of a system is closely related to its reliability. The more reliable
    a system is, the more available it is.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可用性与其可靠性密切相关。系统越可靠，可用性就越高。
- en: Another factor which modifies availability is the ability of a system to recover
    from faults. A system may be very reliable, but if the system is unable to recover
    either from complete or partial failures of its subsystems, then it may not be
    able to guarantee availability. This aspect is called **recovery**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修改可用性的因素是系统从故障中恢复的能力。一个系统可能非常可靠，但如果系统无法从其子系统的完全或部分故障中恢复，那么它可能无法保证可用性。这一方面被称为**恢复**。
- en: 'The availability of a system can be defined as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可用性可以定义如下：
- en: '*"Availability of a system is the degree to which the system is in a fully
    operable state to carry out its functionality when it is called or invoked at
    random."*'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“系统的可用性是系统在随机调用或调用时完全可操作状态的程度。”*'
- en: 'Mathematically, this can be expressed as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学上，这可以表示如下：
- en: '*Availability* = *MTBF*/(*MTBF* + *MTTR*)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*可用性* = *MTBF* / (*MTBF* + *MTTR*)'
- en: 'Take a look at the following terms used in the preceding formula:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面公式中使用的以下术语：
- en: '**MTBF**: Mean time between failures'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MTBF**：平均故障间隔时间'
- en: '**MTTR**: Mean time to repair'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MTTR**：平均修复时间'
- en: This is often called the **mission capable rate** of a system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为系统的**任务可执行率**。
- en: 'Techniques for **Availability** are closely tied to recovery techniques. This
    is due to the fact that a system can never be 100% available. Instead, one needs
    to plan for faults and strategies to recover from faults, which directly determines
    the availability. These techniques can be classified as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性的技术与恢复技术密切相关。这是因为系统永远无法100%可用。相反，需要计划故障和从故障中恢复的策略，这直接决定了可用性。这些技术可以分类如下：
- en: '**Fault detection**: The ability to detect faults and take action helps to
    avert situations where a system or parts of a system become unavailable completely.
    Fault detection typically involves steps such as monitoring, heartbeat, and ping/echo
    messages, which are sent to the nodes in a system, and the response measured to
    calculate if the nodes are alive, dead, or are in the process of failing.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障检测**：检测故障并采取行动的能力有助于避免系统或系统部分完全不可用的情况。故障检测通常涉及监视、心跳和ping/echo消息等步骤，这些消息被发送到系统中的节点，并测量响应以计算节点是活着的、死了的还是正在失败的。'
- en: '**Fault recovery**: Once a fault is detected, the next step is to prepare the
    system to recover from the fault and bring it to a state where the system can
    be considered available. Typical tactics used here include Hot/Warm Spares (Active/Passive
    redundancy), Rollback, Graceful Degradation, and Retry.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障恢复**：一旦检测到故障，下一步是准备系统从故障中恢复，并使其达到可以被认为是可用的状态。这里通常使用的策略包括热备份/冷备份（主/备份冗余）、回滚、优雅降级和重试。'
- en: '**Fault prevention**: This approach uses active methods to anticipate and prevent
    faults from occurring so that the system does not have a chance to go to recovery.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障预防**：这种方法使用主动方法来预见和防止故障发生，以便系统没有机会进行恢复。'
- en: Availability of a system is closely tied to the consistency of its data via
    the CAP theorem which places a theoretical limit on the trade-offs a system can
    make with respect to consistency versus availability in the event of a network
    partition. The CAP theorem states that a system can choose between being consistent
    or being available—typically leading to two broad types of systems, namely, CP
    (consistent and tolerant to network failures) and AP (available and tolerant to
    network failures).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可用性与其数据的一致性密切相关，根据CAP定理，系统在网络分区的情况下在一致性和可用性之间存在理论上的限制。CAP定理指出系统可以选择在一致性和可用性之间进行权衡，通常导致两种类型的系统，即CP（一致性和网络故障容忍）和AP（可用性和网络故障容忍）。
- en: Availability is also tied to the system's scalability tactics, performance metrics,
    and its security. For example, a system that is highly horizontally scalable would
    have a very high availability, since it allows the load balancer to determine
    inactive nodes and take them out of the configuration pretty quickly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性还与系统的可扩展策略、性能指标和安全性相关。例如，高度横向扩展的系统将具有非常高的可用性，因为它允许负载均衡器快速确定非活动节点并将其从配置中移除。
- en: A system which instead tries to scale up may have to monitor its performance
    metrics carefully. The system may have availability issues even when the node
    on which the system is fully available if the software processes are squeezed
    for system resources such as CPU time or memory. This is where performance measurements
    become critical, and the system's load factor needs to be monitored and optimized.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一个试图扩展的系统可能需要仔细监控其性能指标。即使系统所在的节点完全可用，如果软件进程受到系统资源（如CPU时间或内存）的挤压，系统可能会出现可用性问题。这就是性能测量变得至关重要的地方，系统的负载因子需要被监控和优化。
- en: With the increasing popularity of web applications and distributed computing,
    security is also an aspect that affects availability. It is possible for a malicious
    hacker to launch remote denial of service attacks on your servers, and if the
    system is not made foolproof against such attacks, it can lead to a condition
    where the system becomes unavailable or only partially available.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用程序和分布式计算的日益流行，安全也是影响可用性的一个方面。恶意黑客可能对您的服务器发动远程拒绝服务攻击，如果系统没有针对这种攻击做出防范，可能导致系统变得不可用或只部分可用。
- en: Security
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: Security, in the software domain, can be defined as the degree of ability of
    a system to avoid damage to its data and logic from unauthenticated access, while
    continuing to provide services to other systems and roles that are properly authenticated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，安全可以定义为系统避免未经授权访问对其数据和逻辑造成损害的能力，同时继续向其他经过适当认证的系统和角色提供服务。
- en: A security crisis or attack occurs when a system is intentionally compromised
    with a view to gaining illegal access to it in order to compromise its services,
    copy, or modify its data, or deny access to its legitimate users.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 安全危机或攻击发生在系统被有意破坏，以获取非法访问、损害其服务、复制或修改其数据，或拒绝合法用户访问的情况下。
- en: 'In modern software systems, the users are tied to specific roles which have
    exclusive rights to different parts of the system. For example, a typical web
    application with a database may define the following roles:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件系统中，用户与具有对系统不同部分独占权限的特定角色相关联。例如，具有数据库的典型Web应用程序可能定义以下角色：
- en: '**user**: End user of the system with login and access to his/her private data'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：系统的最终用户，具有登录和访问自己私人数据的权限'
- en: '**dbadmin**: Database administrator, who can view, modify, or delete all database
    data'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dbadmin**：数据库管理员，可以查看、修改或删除所有数据库数据'
- en: '**reports**: Report admin, who has admin rights only to those parts of database
    and code that deal with report generation'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告**：报告管理员，只对处理报告生成的数据库和代码部分具有管理员权限'
- en: '**admin**: Superuser, who has edit rights to the complete system'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**：超级用户，对整个系统具有编辑权限'
- en: This way of allocating system control via user roles is called **access control**.
    Access control works by associating a user role with certain system privileges,
    thereby decoupling the actual user login from the rights granted by these privileges.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用户角色分配系统控制的方式称为**访问控制**。访问控制通过将用户角色与某些系统特权关联起来，从而将实际用户登录与这些特权授予的权限分离开来。
- en: This principle is the **Authorization** technique of security.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则是安全的**授权**技术。
- en: Another aspect of security is with respect to transactions where each person
    must validate the actual identity of the other. Public key cryptography, message
    signing, and so on are common techniques used here. For example, when you sign
    an e-mail with your GPG or PGP key, you are validating yourself—*The sender of
    this message is really me, Mr. A*—to your friend Mr. B on the other side of the
    e-mail. This principle is the **Authentication** technique of security.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的另一个方面是与交易相关的，每个人都必须验证对方的真实身份。公钥加密、消息签名等是常用的技术。例如，当您用您的GPG或PGP密钥签署电子邮件时，您正在验证自己——*发送此消息的人确实是我，A先生*——给您在电子邮件另一端的朋友B。这个原则是安全的**认证**技术。
- en: 'The other aspects of security are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的其他方面如下：
- en: '**Integrity**: These techniques are used to ensure that a data or information
    is not tampered with in anyway on its way to the end user. Examples are message
    hashing, CRC Checksum, and others.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：这些技术用于确保数据或信息在传输到最终用户的过程中没有被篡改。例如消息哈希、CRC校验和等。'
- en: '**Origin**: These techniques are used to assure the end receiver that the origin
    of the data is exactly the same as where it is purporting to be from. Examples
    of this are SPF, Sender-ID (for e-mail), Public Key Certificates and Chains (for
    websites using SSL), and others.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源**：这些技术用于向最终接收者保证数据的来源与其所宣称的完全相同。这些技术包括SPF、Sender-ID（用于电子邮件）、使用SSL的网站的公钥证书和链等。'
- en: '**Authenticity**: These are the techniques which combine both the Integrity
    and Origin of a message into one. This ensures that the author of a message cannot
    deny the contents of the message as well as its origin (himself/herself). This
    typically uses **Digital Certificate Mechanisms**.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实性**：这些是将消息的完整性和来源结合在一起的技术。这确保了消息的作者不能否认消息的内容以及其来源（他/她自己）。这通常使用**数字证书机制**。'
- en: Deployability
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署性
- en: Deployability is one of those quality attributes which is not fundamental to
    the software. However, in this book, we are interested in this aspect, because
    it plays a critical role in many aspects of the ecosystem in the Python programming
    language and its usefulness to the programmer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 部署性是软件质量属性之一，但并非对软件至关重要。然而，在本书中，我们对这一方面感兴趣，因为它在Python编程语言的生态系统的许多方面以及对程序员的实用性中起着关键作用。
- en: Deployability is the degree of ease with which software can be taken from the
    development to the production environment. It is more of a function of the technical
    environment, module structures, and programming runtime/languages used in building
    a system, and has nothing to do with the actual logic or code of the system.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 部署性是指软件从开发环境到生产环境的易用程度。这更多地取决于技术环境、模块结构和构建系统所使用的编程运行时/语言的功能，与系统的实际逻辑或代码无关。
- en: 'The following are some factors that determine deployability:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些影响部署性的因素：
- en: '**Module structures**: If your system has its code organized into well-defined
    modules/projects which compartmentalize the system into easily deployable subunits,
    the deployment is much easier. On the other hand, if the code is organized into
    a monolithic project with a single setup step, it would be hard to deploy the
    code into a multiple node cluster.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块结构**：如果您的系统将代码组织成明确定义的模块/项目，将系统分隔成易于部署的子单元，那么部署将更加容易。另一方面，如果代码组织成单体项目，只需进行一次设置步骤，那么将很难将代码部署到多节点集群中。'
- en: '**Production versus development environment**: Having a production environment
    which is very similar to the structure of the development environment makes deployment
    an easy task. When the environments are similar, the same set of scripts and toolchains
    that are used by the developers/Devops team can be used to deploy the system to
    a development server as well as a production server with minor changes—mostly
    in the configuration.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境与开发环境的对比**：拥有与开发环境结构非常相似的生产环境可以使部署变得简单。当环境相似时，开发人员/Devops团队使用的相同一组脚本和工具链可以用于将系统部署到开发服务器以及生产服务器，只需进行少量更改—主要是在配置方面。'
- en: '**Development ecosystem support**: Having a mature tool-chain support for your
    system runtime, which allows configurations such as dependencies to be automatically
    established and satisfied, increases deployability. Programming languages such
    as Python are rich in this kind of support in its development ecosystem, with
    a rich array of tools available for the Devops professional to take advantage
    of.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发生态系统支持**：拥有成熟的工具链支持系统运行时，可以自动建立和满足依赖关系的配置，可以增加部署性。像Python这样的编程语言在其开发生态系统中拥有丰富的支持，为Devops专业人员提供了丰富的工具。'
- en: '**Standardized configuration**: It is a good idea to keep your configuration
    structures (files, database tables, and others) the same for both developer and
    production environments. The actual objects or filenames can be different, but
    if the configuration structures vary widely across both the environments, deployability
    decreases, as extra work is required to map the configuration of the environment
    to its structures.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化配置**：保持开发和生产环境的配置结构（文件、数据库表等）相同是一个好主意。实际对象或文件名可以不同，但如果配置结构在两个环境中差异很大，部署性会降低，因为需要额外的工作来将环境的配置映射到其结构。'
- en: '**Standardized infrastructure:** It is a well-known fact that keeping your
    deployments to a homogeneous or standardized set of infrastructure greatly aids
    deployability. For example, if you standardize your frontend application to run
    on 4 GB RAM, Debian-based 64-bit Linux VPS, then it is easy to automate deployment
    of such nodes—either using a script, or by using elastic compute approaches of
    providers such as Amazon—and to keep a standard set of scripts across both development
    and production environments. On the other hand, if your production deployment
    consists of heterogeneous infrastructure, say, a mix of Windows and Linux servers
    with varying capacities and resource specifications, the work typically doubles
    for each type of infrastructure decreasing deployability.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化基础设施**：众所周知，将部署保持在同质化或标准化的基础设施集上极大地有助于部署性。例如，如果您将前端应用程序标准化为在4GB RAM、基于Debian的64位Linux
    VPS上运行，那么很容易自动化这些节点的部署—可以使用脚本，也可以使用提供商如亚马逊的弹性计算方法—并在开发和生产环境中保持一组标准脚本。另一方面，如果您的生产部署包括异构基础设施，比如混合使用Windows和Linux服务器，容量和资源规格各不相同，那么对于每种类型的基础设施，工作量通常会增加，从而降低部署性。'
- en: '**Use of containers**: The user of container software, popularized by the advent
    of technology such as Docker and Vagrant built on top of Linux containers, has
    become a recent trend in deploying software on servers. The use of containers
    allows you to standardize your software, and makes deployability easier by reducing
    the amount of overhead required to start/stop the nodes, as containers don''t
    come with the overhead of a full virtual machine. This is an interesting trend
    to watch for.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器的使用**：容器软件的使用，由Docker和Vagrant等技术的出现所推广，已成为在服务器上部署软件的最新趋势。使用容器可以使您标准化软件，并通过减少启动/停止节点所需的开销，使部署变得更加容易，因为容器不会带来完整虚拟机的开销。这是一个值得关注的有趣趋势。'
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about software architecture. We saw the different
    aspects of software architecture, and learned that every architecture comprises
    a system, which has a structure working in an environment for its stakeholders.
    We briefly looked at how software architecture differs from software design.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了软件架构。我们看到了软件架构的不同方面，并了解到每个架构都包括一个系统，该系统在其利益相关者的环境中运作。我们简要地看了软件架构与软件设计的区别。
- en: We went on to look at various characteristics of software architecture such
    as how a software architecture defines a structure, picks a core set of elements,
    and connects stakeholders.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续研究了软件架构的各种特征，比如软件架构如何定义结构、选择核心元素并连接利益相关者。
- en: We then addressed the important question of the importance of software architecture
    to an organization, and why it is a good idea to have a formal software architecture
    defined for your software systems.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们讨论了软件架构对组织的重要性，以及为软件系统定义正式软件架构的好处。
- en: The distinction of different roles of architects in an organization was discussed
    next. We saw the various roles system architects play in an organization, and
    how an Enterprise architect's focus is different from that of the System architect's.
    The focus of strategy and technology breadth versus technology depth was clarified
    with illustrations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论了组织中架构师的不同角色。我们看到了系统架构师在组织中扮演的各种角色，以及企业架构师的关注重点与系统架构师的不同。战略和技术广度与技术深度的关注重点通过图示得到了澄清。
- en: We then discussed the elements of the main theme of this book—Architectural
    Quality Attributes. We defined what a quality attribute is, and then looked, in
    quite some detail, at the quality attributes of Modifiability, Testability, Scalability/Performance,
    Security, and Deployability. While going into the details of these attributes,
    we discussed their definitions, techniques, and how they relate to each other.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了本书主题的要素——架构质量属性。我们定义了质量属性是什么，然后详细讨论了可修改性、可测试性、可扩展性/性能、安全性和可部署性等质量属性。在讨论这些属性的细节时，我们讨论了它们的定义、技术以及它们之间的关系。
- en: With this chapter serving as the base, we are now ready to take on these quality
    attributes, and then discuss in detail the various tactics and techniques to achieve
    them using the Python programming language. That forms the rest of this book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有了本章作为基础，我们现在准备好去探讨这些质量属性，然后详细讨论使用Python编程语言实现它们的各种策略和技术。这构成了本书的其余部分。
- en: In the next chapter, we'll start with one of the very first quality attributes
    we discussed in this chapter, namely, Modifiability and its associated attribute,
    Readability.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从本章讨论的第一个质量属性开始，即可修改性及其相关属性可读性。
