- en: Chapter 1. Getting Started with wxPython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 开始使用 wxPython
- en: 'In this chapter, we will cover the components that are at the foundation of
    nearly all wxPython applications, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几乎所有 wxPython 应用程序的基础组件，例如：
- en: The application object
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用对象
- en: The main frame
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主框架
- en: Understanding the window hierarchy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解窗口层次结构
- en: Referencing controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用控件
- en: Using Bitmaps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位图
- en: Adding icons to Windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向窗口添加图标
- en: Utilizing Stock IDs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用库存编号
- en: Accessing the clipboard
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问剪贴板
- en: Supporting drag and drop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持拖放
- en: Two-stage widget creation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两阶段小部件创建
- en: Understanding inheritance limitations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承限制
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In today's world of desktop applications there is a great amount of incentive
    to be able to develop applications that can run on multiple operating systems
    and desktop platforms. Currently there are a handful of cross-platform Python
    frameworks that can be used to develop desktop applications. The wxPython Library
    is a set of Python bindings to the wxWidgets Library, which is a powerful cross-platform
    C++ application framework that can be used to create user interfaces. What sets
    wxPython apart is that, unlike other UI toolkits that draw their own controls,
    wxPython uses the platform's own native UI toolkit for creating and displaying
    UI components. This means that a wxPython application will have the same look
    and feel as other applications on the system since it is using the same controls
    and themes as the rest of the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的桌面应用程序世界中，能够开发能在多个操作系统和桌面平台上运行的应用程序具有极大的吸引力。目前，有少数几个跨平台的Python框架可以用来开发桌面应用程序。wxPython库是一组针对wxWidgets库的Python绑定，wxWidgets是一个功能强大的跨平台C++应用程序框架，可用于创建用户界面。wxPython与众不同的地方在于，与其他绘制自己控制器的UI工具包不同，wxPython使用平台自身的原生UI工具包来创建和显示UI组件。这意味着wxPython应用程序将具有与系统上其他应用程序相同的视觉和感觉，因为它使用的是与系统其他部分相同的控件和主题。
- en: Developing an application in wxPython provides great flexibility for writing
    applications that will run on Windows, Macintosh OS X, Linux, and other UNIX like
    environments. Applications can rapidly be developed on one platform and often
    deployed to another with little or no changes necessary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中开发应用程序为编写可在Windows、Macintosh OS X、Linux和其他类似UNIX环境中运行的应用程序提供了极大的灵活性。应用程序可以在一个平台上快速开发，并且通常只需进行很少或不需要任何修改就可以部署到另一个平台。
- en: The application object
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用对象
- en: The `App` object bootstraps the library and initializes the underlying toolkit.
    All wxPython applications must create an `App` object. This should be instantiated
    before trying to create any other GUI objects to ensure that all the dependant
    parts of the library have been properly initialized. The `App` object also maintains
    the `MainLoop`, which is used to drive a wxPython application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 对象启动库并初始化底层工具包。所有 wxPython 应用程序都必须创建一个 `App` 对象。这应该在尝试创建任何其他 GUI 对象之前完成，以确保库的所有依赖部分都已正确初始化。`App`
    对象还维护 `MainLoop`，它用于驱动 wxPython 应用程序。'
- en: This recipe will demonstrate the basic pattern that all wxPython applications
    can be built from.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将演示所有 wxPython 应用程序都可以构建的基本模式。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will create a "Hello World" like application to show the basic structure
    of a wxPython application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个类似于 "Hello World" 的应用程序，以展示 wxPython 应用程序的基本结构：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running the previous script will result in the following pop-up dialog shown
    on the screen. Click on **OK** to close it and exit the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个脚本将在屏幕上显示以下弹出对话框。点击**确定**以关闭它并退出应用程序。
- en: '![How to do it...](img/1780_01_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_01_01.jpg)'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application object calls its `OnInit` method when it is created. This method
    is overridden and used as the main entry point for initializing this application.
    By returning `True`, the method informs the framework that it is good to go. `OnInit`
    is where most applications will do their initialization and create their main
    window(s).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用对象在创建时会调用其`OnInit`方法。此方法被重写并用作初始化此应用程序的主要入口点。通过返回`True`，该方法通知框架可以继续进行。`OnInit`是大多数应用程序进行初始化和创建主窗口（s）的地方。
- en: In this example, we created the `App` object by passing `False` as the first
    argument. This argument is used to tell wxPython whether to redirect output or
    not. When developing an application, it is advised to always set this to `False`,
    and to run scripts from the command line so that you can see any error output
    that might be missed when running the script by double clicking on it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将`False`作为第一个参数传递来创建`App`对象。这个参数用于告诉wxPython是否要重定向输出。在开发应用程序时，建议始终将此设置为`False`，并从命令行运行脚本，这样你就可以看到在通过双击脚本运行时可能被遗漏的任何错误输出。
- en: After creating the application object and once all initializations are complete,
    the last thing that you need to do is to call the `App` objects `MainLoop` method
    in order to start the event loop. This method will not return until the last top-level
    window is destroyed or until the `App` object is told to exit. wxPython is an
    event-driven system and the `MainLoop` is the heart of the whole system. During
    each iteration of the loop, events are dispatched to perform all of the tasks
    in the GUI, such as handling mouse clicks, moving the window, and redrawing the
    screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序对象并且所有初始化完成之后，你需要做的最后一件事就是调用`App`对象的`MainLoop`方法来启动事件循环。此方法将不会返回，直到最后一个顶级窗口被销毁或者直到`App`对象被告知退出。wxPython是一个事件驱动系统，而`MainLoop`是这个系统的核心。在循环的每次迭代中，事件被分发以执行GUI中的所有任务，例如处理鼠标点击、移动窗口和重绘屏幕。
- en: There's more...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `wx.App` class constructor has four optional keyword arguments:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx.App` 类构造函数有四个可选的关键字参数：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The four optional keyword arguments are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 四个可选的关键字参数如下：
- en: '`redirect:` Redirect `stdout`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect:` 重定向 `stdout`。'
- en: '`filename:` If redirect is `True` this can be used to specify an output file
    to redirect to.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:` 如果重定向为 `True`，则可以用来指定要重定向到的输出文件。'
- en: '`useBestVisual:` Specifies whether the application should try to use the best
    visuals provided by the underlying toolkit. (It does not have an affect on most
    systems.)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useBestVisual:` 指定应用程序是否应尝试使用底层工具包提供的最佳视觉效果。（它对大多数系统没有影响。）'
- en: '`clearSigInt:` Should `SIGINT` be cleared? Setting this to `True` will allow
    the application to be terminated by pressing *Ctrl* + *C*, like most other applications.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearSigInt:` 是否应该清除`SIGINT`？将此设置为`True`将允许通过按下*Ctrl* + *C*来终止应用程序，就像大多数其他应用程序一样。'
- en: The main frame
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主框架
- en: For most applications, you will want to display a window for its users to interact
    with. In wxPython, the most typical window object is known as a `Frame`. This
    recipe will show you how to sublass a `Frame` and display it in an application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用，您可能希望显示一个窗口供用户与之交互。在wxPython中，最典型的窗口对象被称为`Frame`。本食谱将向您展示如何派生一个`Frame`并在应用程序中显示它。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This example extends upon the previous recipe to add a minimal empty application
    window:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在先前的配方基础上扩展，添加了一个最小的空应用程序窗口：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the previous code will result in a window like the following being
    shown:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将会显示如下窗口：
- en: '![How to do it...](img/1780_01_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_01_02.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Frame` is the main top-level window and container for most applications.
    Let's start by examining our `MyFrame` class. In this class there is one important
    thing to note. We created a `Panel` object as a child window of the `Frame`. You
    can think of a `Panel` as a box for containing other controls. Also, in order
    for a `Frame` to operate and look correct on all platforms, it is important that
    it has a `Panel` as its main child.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` 是大多数应用程序的主要顶级窗口和容器。让我们首先检查我们的 `MyFrame` 类。在这个类中，有一件重要的事情需要注意。我们创建了一个
    `Panel` 对象，作为 `Frame` 的子窗口。你可以把 `Panel` 看作是包含其他控件的一个盒子。此外，为了使 `Frame` 在所有平台上都能正确运行和显示，它必须有一个
    `Panel` 作为其主要子窗口。'
- en: Firstly, in the `OnInit` method of our `App`, we create an instance of `MyFrame`,
    passing `None` as its first parameter. This parameter is used to specify the parent
    window of the `Frame`. Because this is our main window, we pass in `None` to indicate
    that it has no parent. Secondly, we call the `SetTopWindow` method of our `App`
    in order to set our newly-created `MyFrame` instance as the application's top
    window. Thirdly and finally, we call `Show` on our `Frame`; this simply does what
    its name suggests, and shows the `Frame` so that a user can see it, though the
    `Frame` will not actually be visible on the screen until the `MainLoop` is started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的 `App` 的 `OnInit` 方法中，我们创建了一个 `MyFrame` 实例，并将 `None` 作为其第一个参数传递。这个参数用于指定
    `Frame` 的父窗口。因为这是我们主窗口，所以我们传递 `None` 来表示它没有父窗口。其次，我们调用我们的 `App` 的 `SetTopWindow`
    方法，以便将新创建的 `MyFrame` 实例设置为应用程序的顶级窗口。最后，我们调用 `Frame` 的 `Show` 方法；这仅仅做了它名字所暗示的事情，即显示
    `Frame`，以便用户可以看到它，尽管 `Frame` 不会在屏幕上实际可见，直到 `MainLoop` 开始运行。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Frame` class has a number of style flags that can be set in its constructor
    to modify the behavior and appearance of the window. These style flags can be
    combined as a bitmask and are supplied as the value to the constructors' style
    parameter. The following table outlines some of the common ones. A full list of
    all available styles can be found in the wxPython online documentation, at [http://wxpython.org/onlinedocs.php](http://wxpython.org/onlinedocs.php).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` 类在其构造函数中具有多个样式标志，可以设置这些标志以修改窗口的行为和外观。这些样式标志可以组合成一个位掩码，并作为构造函数的样式参数的值提供。下表概述了一些常见的样式标志。所有可用样式的完整列表可以在
    wxPython 在线文档中找到，网址为 [http://wxpython.org/onlinedocs.php](http://wxpython.org/onlinedocs.php)。'
- en: '| Style flags | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.DEFAULT_FRAME_STYLE` | This is a bitwise OR of the following flags:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| `wx.DEFAULT_FRAME_STYLE` | 这是以下标志的按位或运算：'
- en: '`wx.MINIMIZE_BOX`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.MINIMIZE_BOX`'
- en: '`wx.MAXIMIZE_BOX`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.MAXIMIZE_BOX`'
- en: '`wx.RESIZE_BORDER`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.RESIZE_BORDER`'
- en: '`wx.SYSTEM_MENU`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.SYSTEM_MENU`'
- en: '`wx.CAPTION`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CAPTION`'
- en: '`wx.CLOSE_BOX`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CLOSE_BOX`'
- en: '`wx.CLIP_CHILDREN`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.CLIP_CHILDREN`'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `wx.MINIMIZE_BOX` | Display a title bar button that minimizes the Frame |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `wx.MINIMIZE_BOX` | 显示一个最小化窗口的标题栏按钮 |'
- en: '| `wx.MAXIMIZE_BOX` | Display a title bar button that maximizes the Frame |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `wx.MAXIMIZE_BOX` | 显示一个最大化窗口的标题栏按钮 |'
- en: '| `wx.CLOSE_BOX` | Display a title bar button that allows the Frame to be closed.
    (the "X" button) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `wx.CLOSE_BOX` | 显示一个标题栏按钮，允许关闭框架。（即“X”按钮） |'
- en: '| `wx.RESIZE_BORDER` | Allow the Frame to be resized by the user when they
    drag the border |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `wx.RESIZE_BORDER` | 允许用户通过拖动边框来调整框架的大小 |'
- en: '| `wx.CAPTION` | Displays a caption on the Frame |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `wx.CAPTION` | 显示在框架上的标题 |'
- en: '| `wx.SYSTEM_MENU` | Display a system menu (that is, the menu that is shown
    when clicking in the frames icon on Windows) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `wx.SYSTEM_MENU` | 显示系统菜单（即在 Windows 上单击框架图标时显示的菜单） |'
- en: '| `wx.CLIP_CHILDREN` | Eliminates flicker caused by the background being repainted
    (Windows only) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `wx.CLIP_CHILDREN` | 消除因背景重绘引起的闪烁（仅限Windows） |'
- en: Understanding the window hierarchy
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解窗口层次结构
- en: All of the different windows and controls in wxPython have a hierarchy of containment.
    Some controls can be containers for other controls and some cannot. This recipe
    is geared towards giving an understanding of this hierarchy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython中的所有不同窗口和控制都有包含的层次结构。一些控制可以作为其他控制的容器，而另一些则不能。本食谱旨在帮助理解这一层次结构。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will be making just a minor change to the `Frame` from the previous recipe,
    so let's open the code from that recipe to get ready for the new changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对之前食谱中的`Frame`进行微小的修改，所以让我们打开那个食谱的代码，为新的更改做好准备。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here is the new code that will replace our existing Frame class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是即将替换我们现有Frame类的新的代码。
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Basically, there are three general categories of window objects that are tiered,
    in the following containment order:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，存在三种按以下包含顺序分层的窗口对象类别：
- en: Top-Level Windows (Frames and Dialogs)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级窗口（框架和对话框）
- en: General Containers (Panels and Notebooks, ...)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用容器（面板和笔记本，...）
- en: Controls (Buttons, CheckBoxes, ComboBoxes, ...)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件（按钮、复选框、组合框等）
- en: The Top-Level Window is at the top of the hierarchy and it can contain any kind
    of window except another Top-Level Window. General Containers come next, and they
    can arbitrarily hold any other General Container or Control. Finally, at the bottom
    of the Hierarchy are the Controls. These are the functional part of a UI that
    the user will interact with. They can, in some cases, be used to hold other controls,
    but typically will not. The containment hierarchy is connected to the parental
    hierarchy of controls. A parent will be the container for its children.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级窗口位于层次结构的顶部，它可以包含任何类型的窗口，除了另一个顶级窗口。接下来是通用容器，它们可以任意地包含任何其他通用容器或控件。最后，在层次结构的底部是控件。这些是用户将与之交互的UI的功能部分。在某些情况下，它们可以用来包含其他控件，但通常不会这样做。包含层次结构与控件的父母层次结构相连接。父控件将是其子控件的容器。
- en: When running the previous sample, this hierarchy becomes apparent. The `Frame`,
    as we have previously seen, is the outer-most container object; next you can see
    the `Panel`, which we turned black to make it more visible; finally you can see
    the `Button`, which was added as a child of the `Panel`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的示例时，这个层次结构变得明显。正如我们之前看到的，`Frame` 是最外层的容器对象；接下来你可以看到 `Panel`，我们将它变成了黑色以便更明显；最后你可以看到
    `Button`，它是作为 `Panel` 的子对象被添加的。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Referencing controls* recipe in this chapter offers further explanation
    as to how the window hierarchy is connected together.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*引用控制*的配方提供了进一步解释，说明了窗口层次结构是如何相互连接的。
- en: Referencing controls
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用控制
- en: All `Window` objects in an application are connected in various ways. Quite
    often it is useful to get a reference to an instance of a control so that you
    can perform some operation on the control or retrieve some data from it. This
    recipe will show some of the facilities that are available for finding and getting
    references to controls.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的所有 `Window` 对象以各种方式相互连接。通常情况下，获取一个控件实例的引用非常有用，这样你就可以对控件执行某些操作或从中检索一些数据。本食谱将展示一些用于查找和获取控件引用的可用功能。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we extend the `MyFrame` class from the previous recipe to have an event
    handler for when its Button is clicked. In the event handler we can see some ways
    to access different controls in our UI during runtime:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将之前菜谱中的`MyFrame`类扩展，使其在按钮被点击时具有事件处理器。在事件处理器中，我们可以看到一些在运行时访问我们UI中不同控件的方法：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each window in the framework keeps a reference to its parent and to its children.
    Running our program now will print out the results of using the accessor functions
    that all windows have for finding and retrieving references to their children
    and other related controls.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 框架中的每个窗口都保存对其父窗口和子窗口的引用。现在运行我们的程序将打印出使用所有窗口都有的访问器函数来查找和检索对其子窗口和其他相关控件引用的结果。
- en: '`GetChildren:` This method will return a list of all of the children that the
    given control has'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetChildren:` 此方法将返回给定控件的所有子控件的列表'
- en: '`FindWindowById:` This can be used to find a specific child window by using
    its ID'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindWindowById:` 这可以通过使用其ID来查找特定的子窗口'
- en: '`GetParent:` This method will retrieve the window''s parent window'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetParent:` 此方法将检索窗口的父窗口'
- en: '`wx.GetApp:` This is a global function for getting access to the one and only
    application object'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.GetApp:` 这是一个全局函数，用于获取唯一的应用对象访问权限'
- en: '`App.GetTopWindow:` This gets the main Top-Level Window in the application'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.GetTopWindow:` 这将获取应用程序中的主顶层窗口'
- en: Clicking on the `Button` will cause the `OnButton` method to be called. In `OnButton`,
    there are examples that show how to use each of the above methods. Each of them
    will return a reference to a GUI object. In our example, calling `GetChildren`
    on the `Panel` will return a list of its children controls. Iterating over this
    list, we print out each of the children, which will just be the Button in this
    case. `FindWindowById` can be used to find a specific child control; again, we
    called this on our `Panel` to find the `Button` control. Just to show that we
    found the `Button`, we used its `SetLabel` method to change its label. Next, calling
    `GetParent` on the `Button` will return the `Button's` parent, which is the `Panel`.
    Finally, by using the global `GetApp` function, we can get a reference to the
    application object. The `App` object's `GetTopWindow` will return a reference
    to our Frame.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`按钮`将会调用`OnButton`方法。在`OnButton`中，有一些示例展示了如何使用上述每种方法。每个方法都会返回一个GUI对象的引用。在我们的例子中，对`Panel`调用`GetChildren`将返回其子控件列表。遍历这个列表，我们将打印出每个子控件，在这个情况下，就是按钮。`FindWindowById`可以用来查找特定的子控件；同样，我们也在我们的`Panel`上调用这个方法来查找`按钮`控件。为了展示我们已经找到了`按钮`，我们使用了它的`SetLabel`方法来更改其标签。接下来，对`按钮`调用`GetParent`将返回`按钮`的父对象，即`Panel`。最后，通过使用全局的`GetApp`函数，我们可以获取到应用程序对象的引用。`App`对象的`GetTopWindow`将返回对我们Frame的引用。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are a few more useful methods available for getting references to controls.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多有用的方法来获取控件引用。
- en: '| Function Name | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.FindWindowByLabel(label)` | Finds a child window by looking for it by
    Label |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FindWindowByLabel(label)` | 通过标签查找子窗口 |'
- en: '| `wx.FindWindowByName(name)` | Finds a child window by looking for it by Name
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FindWindowByName(name)` | 通过名称查找子窗口 |'
- en: '| `wx.GetTopLevelParent()` | Gets the Top-Level Window, which is at the top
    of the given control''s parental hierarchy |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`wx.GetTopLevelParent()` 获取顶层窗口，该窗口位于给定控件父级层次结构的顶部'
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding the window hierarchy* recipe in this chapter outlines the
    structure of how windows are contained within and are related to each other.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*理解窗口层次结构*的配方概述了窗口如何在其中包含以及它们之间如何相互关联的结构。
- en: Using Bitmaps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位图
- en: It's likely that, at some point, you will want to be able to display an image
    in your application. A `Bitmap` is the basic data type that is used to display
    images in an application. This recipe will show how to load an image file into
    a `Bitmap` and then display it in a `Frame`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，在某个时刻，你将希望能够在你的应用程序中显示一张图片。`Bitmap` 是用于在应用程序中显示图片的基本数据类型。本食谱将展示如何将图片文件加载到
    `Bitmap` 中，并在 `Frame` 中显示它。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see how to use Bitmaps, we will create a little application that loads an
    image from the hard disk and displays it in a Frame:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用位图，我们将创建一个小应用程序，从硬盘加载一张图片并在一个框架中显示它：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `StaticBitmap` control is the simplest method of displaying a Bitmap in
    an application. In the example code that accompanies this recipe, we have an image
    in the same directory as our script, called `face-grin.png`, that we want to display.
    In order to display the image we first use the `Bitmap` constructor to load the
    image into memory, and then pass it to the `StaticBitmap` control in order to
    display the image on the screen. The constructor takes a path to the file, and
    a type argument that specifies the image format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticBitmap` 控件是在应用程序中显示位图的简单方法。在随本食谱附带的示例代码中，我们有一个与我们的脚本在同一目录下的图像，名为 `face-grin.png`，我们希望显示该图像。为了显示图像，我们首先使用
    `Bitmap` 构造函数将图像加载到内存中，然后将其传递给 `StaticBitmap` 控件以在屏幕上显示图像。构造函数接受文件路径和一个指定图像格式的类型参数。'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is built-in support for the most common image formats. The following
    list shows the supported image file formats:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内置了对最常见图像格式的支持。以下列表显示了支持的图像文件格式：
- en: '`wx.BITMAP_TYPE_ANY`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_ANY`'
- en: '`wx.BITMAP_TYPE_BMP`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_BMP`'
- en: '`wx.BITMAP_TYPE_ICO`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_ICO`'
- en: '`wx.BITMAP_TYPE_CUR`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_CUR`'
- en: '`wx.BITMAP_TYPE_XBM`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_XBM`'
- en: '`wx.BITMAP_TYPE_XPM`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_XPM`'
- en: '`wx.BITMAP_TYPE_TIF`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_TIF`'
- en: '`wx.BITMAP_TYPE_GIF`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_GIF`'
- en: '`wx.BITMAP_TYPE_PNG`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_PNG`'
- en: '`wx.BITMAP_TYPE_JPEG`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_JPEG`'
- en: '`wx.BITMAP_TYPE_PNM`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_PNM`'
- en: '`wx.BITMAP_TYPE_PCX`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_PCX`'
- en: '`wx.BITMAP_TYPE_PICT`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_PICT`'
- en: '`wx.BITMAP_TYPE_ICON`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_ICON`'
- en: '`wx.BITMAP_TYPE_ANI`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_ANI`'
- en: '`wx.BITMAP_TYPE_IFF`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx.BITMAP_TYPE_IFF`'
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Working with ToolBars* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    contains some more Bitmap usage examples.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的*使用工具栏*配方，*用户界面基本构建块*包含了一些更多的位图使用示例。'
- en: The *Customizing the ArtProvider* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    provides more on information how to create Bitmaps.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。创建组件和扩展功能")的*自定义ArtProvider配方*中，*创建组件和扩展功能*提供了更多关于如何创建位图的详细信息。
- en: Adding icons to Windows
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图标到Windows
- en: Adding an icon to your application's title bar as a way of branding the application
    that will help to set it apart and distinguish it from the other applications
    running on the desktop. This recipe will show how easy it is to add an icon to
    a Frame.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将图标添加到应用程序的标题栏中，作为品牌化应用程序的一种方式，这有助于将其与其他在桌面上运行的应用程序区分开来。本食谱将展示如何轻松地将图标添加到框架中。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Support for adding an Icon to the title bar on OS X is currently not supported
    by wxPython 2.8.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 系统上，wxPython 2.8 目前不支持在标题栏添加图标。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will create a `Frame` subclass that loads an image file from the hard
    disk and displays it on its title bar:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个`Frame`子类，该子类从硬盘加载一个图像文件并在其标题栏上显示它：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Displaying this Frame subclass will result in a window like the following.
    Comparing this to the one in the Main Frame recipe, you can see the new icon to
    the left of the title:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显示这个Frame子类将导致出现如下窗口。与主Frame配方中的窗口相比，您可以看到标题左侧的新图标：
- en: '![How to do it...](img/1780_01_03.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_01_03.jpg)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we have a small (16x16) image of a monkey that we want to show
    in the title bar of the `Frame`. For simplicity, this image is located in the
    same directory as our script and we load it using a relative path. The `Frame`
    requires an icon instead of a `Bitmap`, so we have to use an `Icon` to load our
    image into memory. After loading the image, all that is left is to call the Frame's
    `SetIcon` method in order to set the Icon for the `Frame`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个小（16x16）的猴子图像，我们希望将其显示在`Frame`的标题栏中。为了简单起见，此图像位于我们的脚本相同的目录中，我们使用相对路径来加载它。`Frame`需要一个图标而不是`Bitmap`，因此我们必须使用`Icon`将我们的图像加载到内存中。在加载图像后，剩下的只是调用`Frame`的`SetIcon`方法来设置`Frame`的图标。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using Bitmaps* recipe in this chapter discusses the more commonly-used
    Bitmap image type.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用位图*配方讨论了更常用的位图图像类型。
- en: Utilizing Stock IDs
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用库存编号
- en: All controls, and many other user-interface elements, such as menus, take an
    ID as an argument in their constructor that can be used to identify the control
    or object inside event handlers. Typically, the value of `wx.ID_ANY` is used to
    let the system automatically generate an ID for the item, or the `wx.NewId` function
    is used to create a new ID. However, there are also a number of predefined IDs
    available in the `wx` module that have special meaning for certain common items
    that many applications tend to have, such as Copy/Paste menu items or Ok/Cancel
    buttons. The expected behavior and appearance of some of these items can vary
    from platform to platform. By using the stock ID, wxPython will take care of the
    differences for you. This recipe will show a few of the places in which these
    IDs can come in handy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控件以及许多其他用户界面元素，例如菜单，在其构造函数中接受一个ID作为参数，该参数可用于在事件处理程序中识别控件或对象。通常，使用`wx.ID_ANY`的值让系统自动为项目生成一个ID，或者使用`wx.NewId`函数创建一个新的ID。然而，`wx`模块中也有许多预定义的ID，这些ID对于许多应用程序中常见的某些项目具有特殊含义，例如复制/粘贴菜单项或确定/取消按钮。这些项目的一些预期行为和外观可能会因平台而异。通过使用标准ID，wxPython将为您处理这些差异。本食谱将展示这些ID可以在哪些地方派上用场。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This code snippet shows how to make use of some of the predefined IDs to simplify
    the creation of some common UI elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了如何利用一些预定义的ID来简化创建一些常见UI元素的过程：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous class will create the following window:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节课将创建以下窗口：
- en: '![How to do it...](img/1780_01_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_01_04.jpg)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing to notice in this recipe is that no labels were specified for
    the two buttons that we created. By using the Stock IDs for OK and Cancel as their
    IDs, the framework will automatically put the proper label on the control.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中首先要注意的是，我们创建的两个按钮没有指定标签。通过使用“确定”和“取消”的库存ID作为它们的ID，框架将自动为控件添加正确的标签。
- en: This also applies to menu items, as can be seen in our Edit menu for the Preferences
    item. Another important thing to note is that if this sample is run on Macintosh
    OS X, the framework will also automatically move the Preferences menu item to
    its expected location in the Application menu.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于菜单项，如在我们编辑菜单中查看的“偏好设置”项所示。另一个需要注意的重要事项是，如果在这个示例中运行在Macintosh OS X上，框架也会自动将“偏好设置”菜单项移动到应用程序菜单中预期的位置。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using buttons with Stock IDs in a Modal Dialog will also allow the dialog to
    be dismissed, and return the appropriate value, such as `wx.OK` or `wx.CANCEL`,
    without the need to connect event handlers to the buttons for performing this
    standard action. Automatically getting the correct button layout for a dialog
    can also be achieved by using Stock IDs with `StdDialogButtonSizer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在模态对话框中使用具有库存ID的按钮也将允许对话框被关闭，并返回适当的值，例如`wx.OK`或`wx.CANCEL`，无需将事件处理程序连接到按钮以执行此标准操作。通过使用`StdDialogButtonSizer`与库存ID，也可以自动获取对话框的正确按钮布局。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating Stock Buttons* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    shows how Stock IDs can be used to construct standard buttons.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *创建股票按钮* 菜单，*用户界面基本构建块* 展示了如何使用股票ID来构建标准按钮。'
- en: The *Standard dialog button layout* recipe in [Chapter 7](ch07.html "Chapter 7. Window
    Layout and Design"), *Window Layout and Design* shows how to easily add common
    buttons to dialogs by using Stock IDs.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。窗口布局和设计")中的*标准对话框按钮布局*配方，*窗口布局和设计*展示了如何通过使用库存ID轻松地将常用按钮添加到对话框中。'
- en: The *Optimizing for OS X* recipe in [Chapter 12](ch12.html "Chapter 12. Building
    and Managing Applications for Distribution"), *Building and Managing Applications
    for Distribution* shows more uses for Stock IDs.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。构建和管理应用程序以分发")中的*针对OS X优化*配方展示了Stock IDs的更多用途。'
- en: Accessing the clipboard
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问剪贴板
- en: The Clipboard is a system-wide, accessible way of getting data to and from one
    application to another. This recipe will show how to get text from the clipboard,
    as well as how to put text in the clipboard for other applications to access.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板是一种跨应用、可访问的方式，用于在不同应用程序之间传输数据。本食谱将展示如何从剪贴板获取文本，以及如何将文本放入剪贴板以便其他应用程序访问。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following two functions can be used to get text from and put text on the
    clipboard:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数可以用来从剪贴板获取文本和将文本放置到剪贴板：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'wxPython provides a singleton clipboard object that can be used to interact
    with the systems clipboard. This class works with data objects that are used to
    represent the underlying system data types. The use of the clipboard is a three-step
    process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython提供了一个单例剪贴板对象，可以用来与系统剪贴板进行交互。这个类与用于表示底层系统数据类型的对象一起工作。使用剪贴板是一个三步过程：
- en: Open the Clipboard
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开剪贴板
- en: Set/Get the DataObject
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置/获取数据对象
- en: Close the Clipboard
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭剪贴板
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The clipboard supports many other data types besides just text. wxPython provides
    built-in support for some additional types, as well as classes for defining your
    own custom types. The usage of these different data types follows the same general
    pattern as the `TextDataObject.`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板支持许多其他数据类型，而不仅仅是文本。wxPython 提供了对一些附加类型的内置支持，以及用于定义您自己的自定义类型的类。这些不同数据类型的用法遵循与
    `TextDataObject` 相同的一般模式。
- en: '| Data types | Description |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.BitmapDataObject` | Used to get Bitmaps from and put Bitmaps on the Clipboard
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `wx.BitmapDataObject` | 用于从剪贴板获取位图并将其放置在剪贴板上 |'
- en: '| `wx.CustomDataObject` | Can hold any Python picklable data type |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `wx.CustomDataObject` | 可以存储任何可Python可序列化的数据类型 |'
- en: '| `wx.DataObjectComposite` | Can contain any arbitrary number of simple data
    types and make them all available at once |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `wx.DataObjectComposite` | 可以包含任意数量的简单数据类型，并使它们一次性全部可用 |'
- en: '| `wx.FileDataObject` | Used for holding filenames |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FileDataObject` | 用于存储文件名 |'
- en: '| `wx.URLDataObject` | Used for holding URLs |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `wx.URLDataObject` | 用于存储URL |'
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Supporting drag and drop* recipe in this chapter is related to the clipboard
    in that it allows for the transfer of data between applications.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*支持拖放*的配方与剪贴板相关，因为它允许在应用程序之间传输数据。
- en: Supporting drag and drop
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持拖放
- en: In order to improve usability, it is good to support drag and drop in an application
    so that the user can simply drop files or other objects into your application.
    This recipe will show how to support accepting a `CompositeDataObject` that supports
    both files and text.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可用性，在应用程序中支持拖放操作是很好的，这样用户就可以简单地拖放文件或其他对象到您的应用程序中。本食谱将展示如何支持接受一个同时支持文件和文本的`CompositeDataObject`。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First we will define a custom drop target class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个自定义的拖放目标类：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then to make use of the `FileAndTextDropTarget`, we assign it to a window using
    the window object's `SetDropTarget` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了使用`FileAndTextDropTarget`，我们使用窗口对象的`SetDropTarget`方法将其分配给一个窗口。
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The framework will call the `OnData` method of our `DropTarget` when the window
    has received the drop data. When `OnData` is called, we simply get the data from
    our `DataObject` and pass it to the appropriate callback function to let our window
    decide how to handle the data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口接收到拖放数据时，框架将调用我们的`DropTarget`的`OnData`方法。当`OnData`被调用时，我们只需从我们的`DataObject`中获取数据，并将其传递给适当的回调函数，以便我们的窗口决定如何处理这些数据。
- en: All window objects have a `SetDropTarget` method that can be used to assign
    a `DropTarget`, so this class can be reused for almost any type of control. In
    the previous example, we assigned it to a `ListBox` and then appended the dropped
    data to the list in each of our callbacks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有窗口对象都有一个`SetDropTarget`方法，可以用来分配一个`DropTarget`，因此这个类可以用于几乎任何类型的控件。在先前的示例中，我们将它分配给了一个`ListBox`，然后在我们每个回调函数中将拖放的数据添加到列表中。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `PyDropTarget` class provides a few more methods that can be called at different
    times during the drag operation. These methods can also be overridden in order
    to do things such as change the mouse cursor, show a custom drag image, or reject
    the drag object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyDropTarget` 类提供了一些可以在拖动操作的不同时间点调用的方法。这些方法也可以被重写，以便执行诸如更改鼠标光标、显示自定义拖动图像或拒绝拖动对象等操作。'
- en: '| Methods | When the methods are called |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 当方法被调用时 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `OnEnter(x, y, drag_result)` | Called when a drag object enters the window.
    Returns a drag result value (that is, `wx.DragNone, wx.DragCopy`, ...) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `OnEnter(x, y, drag_result)` | 当拖动对象进入窗口时被调用。返回一个拖动结果值（即，`wx.DragNone, wx.DragCopy`,
    ...） |'
- en: '| `OnDragOver(x, y, drag_result)` | Called while the mouse is dragging the
    object over the target |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `OnDragOver(x, y, drag_result)` | 在鼠标拖动对象到目标上时调用 |'
- en: '| `OnLeave()` | Called when the mouse leaves the drop target |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `OnLeave()` | 当鼠标离开拖放目标时调用 |'
- en: '| `OnDrop(x, y)` | Called when the user drops the object. Return `True` to
    accept the object or `False` to reject it |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `OnDrop(x, y)` | 当用户放下对象时被调用。返回 `True` 以接受对象或返回 `False` 以拒绝它 |'
- en: '| `OnData(x, y, drag_result)` | Called after `OnDrop`, when the data object
    was accepted |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `OnData(x, y, drag_result)` | 在 `OnDrop` 被调用后，当数据对象被接受时调用 |'
- en: See also
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*The Accessing the clipboard* recipe in this chapter shows another way to perform
    data transfer between applications.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*访问剪贴板*配方展示了另一种在应用程序之间进行数据传输的方法。
- en: Two-stage widget creation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两阶段小部件创建
- en: Two-stage widget creation is a way of initialzing a widget and then its UI part,
    in two steps. This method of object creation is used by class factories such as
    XRC (XML Resource) and to set extra style flags that cannot be set by using the
    constructor's regular style parameter. This recipe will show how to use two-stage
    creations to create a frame that has a special button that can be used to put
    it into a context-sensitive help mode.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 两阶段小部件创建是一种通过两步初始化小部件及其UI部分的方法。这种对象创建方法被类工厂如XRC（XML资源）所使用，以及用于设置不能通过构造函数的常规样式参数设置的其他样式标志。本食谱将展示如何使用两阶段创建来创建一个具有特殊按钮的框架，该按钮可用于将其置于上下文相关帮助模式。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: This is a Windows-specific example; other platforms do not support having a
    `ContextButton` in their title bar.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特定于Windows的示例；其他平台不支持在它们的标题栏中拥有`ContextButton`。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will create a `Frame` subclass that uses two stage creation in order
    to set an extra style flag:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个`Frame`子类，它使用两阶段创建来设置一个额外的样式标志：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In wxPython, two-stage widget creation is actually a three-step process. First,
    each class that supports it has its own `PreClass` that is used as a factory constructor
    that pre-creates the object. At this point, the pre object can be used to set
    the extra style flag. The next step is to call `Create. Create` acts like the
    regular constructor and creates the UI portion of the control. The final step
    is to call `PostCreate, PostCreate` does the work of translating the `pre` object
    into `self` so that the object will appear just as if the class's `__init__` method
    had been called normally.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，两阶段小部件创建实际上是一个三步过程。首先，每个支持它的类都有自己的`PreClass`，它用作一个工厂构造函数，预先创建对象。在这个阶段，预对象可以用来设置额外的样式标志。下一步是调用`Create`，`Create`的行为类似于常规构造函数，创建控制器的UI部分。最后一步是调用`PostCreate`，`PostCreate`将`pre`对象转换为`self`，使得对象看起来就像类的`__init__`方法已经被正常调用一样。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using XRC* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout and
    Design"), *Window Layout and Design* discusses XRC.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。窗口布局与设计")中的*使用XRC*配方，*窗口布局与设计*讨论了XRC。'
- en: Understanding inheritance limitations
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承限制
- en: wxPython is a wrapper around the wxWidgets C++ framework. This relationship
    means that inside most wxPython objects there is a C++ object. Because of this,
    methods that belong to wxPython classes cannot always be overridden in the same
    way as they can with a normal Python object.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython 是围绕 wxWidgets C++ 框架的包装器。这种关系意味着在大多数 wxPython 对象内部存在一个 C++ 对象。因此，属于
    wxPython 类的方法并不能总是像在普通 Python 对象中那样被覆盖。
- en: To demonstrate this behavior, this recipe will show how to create a class that
    will automatically add its children windows to its `Sizer` layout. This will be
    contrasted to a class that does not expose its virtual methods to the Python layer
    of the class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种行为，这个菜谱将展示如何创建一个类，该类会自动将其子窗口添加到其`Sizer`布局中。这将与一个不向Python层公开其虚方法的类进行对比。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To demonstrate the difference in overriding methods, we will create two similar
    classes first starting with one that derives from the standard `Panel` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示重写方法之间的差异，我们首先将创建两个相似的类，从一个继承自标准`Panel`类的类开始：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will create a class that is exactly the same except that it derives
    from the `Py` version of the class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个与`Py`版本完全相同的类，只是它派生自该类：
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now below we have a little sample application that uses the above two classes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下面我们有一个使用上述两个类的小型示例应用：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this code will result in a window like the following one being displayed:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示如下窗口：
- en: '![How to do it...](img/1780_01_05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_01_05.jpg)'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In each version of our `Panel` class we override the `AddChild` method, which
    is called every time that a window has a new child window created. `AddChild`
    is called inside the C++ part of the class when this happens, so in order to be
    able to override the method in our Python version of the class, we need to use
    the special version that provides access to overriding the virtualized method
    from the C++ class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`Panel`类的每个版本中，我们都重写了`AddChild`方法，该方法在每次创建新的子窗口时被调用。当这种情况发生时，`AddChild`方法在类的C++部分中被调用，因此为了能够在我们的Python类版本中重写该方法，我们需要使用提供访问从C++类中虚拟化方法重写的特殊版本。
- en: The classes in wxPython that have a version of the class prefixed with `Py`
    have the virtualized versions of many of the methods exposed, so that when they
    are overridden in a Python subclass they get bound to the method in the C++ layer
    of the object and will be called by the framework instead of the base class's
    implementation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，那些带有以`Py`为前缀的类版本，暴露了许多方法的虚拟化版本，因此当它们在Python子类中被覆盖时，它们会被绑定到对象C++层的相应方法，并且将由框架调用而不是基类的实现。
- en: This can be seen in the screenshot of our recipe application that was shown
    above. The top version of the class that does not derive from `PyPanel` has all
    three of its `Buttons` stacked on top of each other in the top left-hand corner
    of the window, because its overridden `AddChild` method is never called. On the
    other hand, the version of the class that does derive from `PyPanel` has its `AddChild`
    method called and is able to lay out the `Buttons` in its `Sizer`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在上面展示的我们的食谱应用截图中看到。那个不继承自`PyPanel`的类的顶部版本，其三个`按钮`都堆叠在窗口的左上角，因为它的重写`AddChild`方法从未被调用。另一方面，那个继承自`PyPanel`的类的版本调用了其`AddChild`方法，并且能够在其`Sizer`中布局`按钮`。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is not well documented as to which methods are exposed as virtual methods
    and which ones are not. Here is a little trick that can help you to identify which
    virtual methods are available in a given class. Just run the following code inside
    the Python interpreter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些方法是作为虚方法暴露的，哪些不是，并没有很好地记录。这里有一个小技巧可以帮助你识别给定类中可用的虚方法。只需在Python解释器中运行以下代码：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The argument in the `dir()` call can be changed to whatever class you want to
    inspect. Running this will print out a list of all of the methods in the class
    that are virtualized. The `base_` methods are generated by SWIG as a part of the
    wxPython bindings to wxWidgets, and should not be used directly in your code.
    Instead, the methods without the `base_` prefix should be used.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir()` 调用中的参数可以更改为您想要检查的任何类。运行此命令将打印出该类中所有虚拟化的方法列表。`base_` 方法是由 SWIG 在 wxPython
    绑定到 wxWidgets 的过程中生成的，不应直接在您的代码中使用。相反，应使用没有 `base_` 前缀的方法。'
- en: See also
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom control* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*,
    shows more usage examples of overriding virtual methods.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第10章 [创建自定义控件](ch10.html "第10章。创建组件和扩展功能") 的“创建组件和扩展功能”中，*创建自定义控件*的配方展示了更多重写虚拟方法的用法示例。
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Design and Layout*, explains how the BoxSizer class can
    be used to perform the layout of controls in a window.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。窗口布局和设计")中的*使用BoxSizer*配方，*窗口设计和布局*，解释了如何使用BoxSizer类在窗口中执行控件布局。'
