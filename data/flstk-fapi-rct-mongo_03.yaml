- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Python Type Hints and Pydantic
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类型提示和Pydantic
- en: Before exploring FastAPI, it is useful to explore some Python concepts that
    will be heavily used throughout your journey with FastAPI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索FastAPI之前，了解一些将在FastAPI旅程中大量使用的Python概念是有用的。
- en: Python type hinting is a very important and relatively new feature of the language
    that facilitates the work of developers, bringing greater robustness and maintainability
    to the development workflow. Types make your code more readable and understandable,
    and most importantly, they promote good practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型提示是语言中非常重要且相对较新的特性，它有助于开发者提高工作效率，为开发流程带来更大的健壮性和可维护性。类型使你的代码更易于阅读和理解，最重要的是，它们促进了良好的编程实践。
- en: FastAPI is heavily based on Python type hints. So, before diving into the framework,
    it is useful to review the basic concepts of type hinting, what they are, how
    they are implemented, and what their purpose is. This foundational knowledge will
    help you create robust, maintainable, and scalable APIs with FastAPI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI高度基于Python类型提示。因此，在深入研究框架之前，回顾类型提示的基本概念、它们是什么、如何实现以及它们的目的是有用的。这些基础知识将帮助你使用FastAPI创建健壮、可维护和可扩展的API。
- en: By the end of this chapter, you will have a deep understanding of the role of
    type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python
    library that enforces type hints at runtime, provides customizable and user-friendly
    errors when data is invalid, and allows definition of data structures using Python
    type annotations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对Python中类型注解在FastAPI和Pydantic中的作用有深入的理解。Pydantic是一个现代Python库，它在运行时强制执行类型提示，当数据无效时提供可定制且用户友好的错误，并允许使用Python类型注解定义数据结构。
- en: You will be able to model your data with precision, leveraging the advanced
    features of Pydantic to make you a better and more productive FastAPI developer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够精确地建模你的数据，利用Pydantic的高级功能，使你成为一个更好的、更高效的FastAPI开发者。
- en: 'This chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Python type hints and their usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python类型提示及其用法
- en: A general overview of Pydantic and its main functions, including parsing and
    validating data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pydantic的概述及其主要功能，包括解析和验证数据
- en: Data deserialization and serialization, including advanced and special cases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据反序列化和序列化，包括高级和特殊情况
- en: Validation and data transformation, aliases, and field and model-level validation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和数据转换、别名以及字段和模型级别的验证
- en: Advanced Pydantic usage such as nested models, fields, and model settings
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Pydantic使用，例如嵌套模型、字段和模型设置
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the sample application in this chapter, you should have Python version
    3.11.7(https://www.python.org/downloads/) or higher installed on your local computer,
    a virtual environment, and a couple of packages. As the examples in this chapter
    will not make use of FastAPI, if you wish, you can create a pristine virtual environment
    and install Pydantic with the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例应用程序，你应在本地计算机上安装Python版本3.11.7（https://www.python.org/downloads/）或更高版本，一个虚拟环境，以及一些包。由于本章的示例不会使用FastAPI，如果你愿意，你可以创建一个干净的虚拟环境，并使用以下命令安装Pydantic：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, you will be working with Pydantic and some Pydantic-related
    packages, such as `pydantic_settings`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用Pydantic以及一些与Pydantic相关的包，例如`pydantic_settings`。
- en: Python types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类型
- en: The different types present in a programming language define the language itself—they
    define its boundaries and set some ground rules for what is possible and, more
    importantly, what the recommended way of achieving something is. Different types
    of variables have completely different sets of methods and properties available.
    For example, while capitalizing a string makes perfect sense, capitalizing a floating
    number or a list of integers doesn’t.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中存在的不同类型定义了语言本身——它们定义了其边界，并为可能实现的方式设定了一些基本规则，更重要的是，它们推荐了实现某种功能的方法。不同类型的变量有完全不同的方法和属性集合。例如，将字符串大写是有意义的，但将浮点数或整数列表大写则没有意义。
- en: 'If you have used Python for a while, even for the most mundane tasks, you already
    know that, like every programming language, it supports different types of data—strings
    and different numerical types such as integers and floats. It also features a
    rather rich data structure library: from dictionaries to lists, from sets to tuples,
    and so on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Python一段时间了，即使是完成最平凡的任务，你也已经知道，就像每一种编程语言一样，它支持不同类型的数据——字符串和不同的数值类型，如整数和浮点数。它还拥有一个相当丰富的数据结构库：从字典到列表，从集合到元组，等等。
- en: Python is a **dynamically typed language**. This means that the type of a variable
    is not determined at compile time, but at runtime. This feature gives the language
    itself a lot of flexibility and enables you to declare a variable as a string,
    use it, and then later on reassign it to a list. However, the ease of changing
    the variable type can make larger and more complex codebases more prone to errors.
    Dynamic typing implies that the type of a variable is embedded with the variable
    itself and is easily modifiable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种**动态类型语言**。这意味着变量的类型不是在编译时确定的，而是在运行时确定的。这个特性使得语言本身具有很大的灵活性，并允许你将一个变量声明为字符串，使用它，然后稍后将其重新赋值为列表。然而，改变变量类型的便捷性可能会使得更大、更复杂的代码库更容易出错。动态类型意味着变量的类型与其本身嵌入，并且易于修改。
- en: 'On the other end of the spectrum lie the so-called statically typed languages:
    C, C++, Java, Rust, Go, and so on. In these languages, the type of the variable
    is known at compile time, and it cannot change over time. The type-checking is
    performed at compile time (so before runtime) and errors are caught before runtime,
    as the compiler will prevent the program from being compiled.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端的是所谓的静态类型语言：C、C++、Java、Rust、Go等等。在这些语言中，变量的类型是在编译时已知的，并且不能随时间改变。类型检查是在编译时（即在运行时之前）进行的，错误是在运行时之前捕获的，因为编译器会阻止程序编译。
- en: 'Programming languages are divided into different categories along another,
    different axis: strongly typed languages and weakly typed languages. This characteristic
    tells us how much a language restricts its types to operations inherent to those
    specific types and how easy it is to coerce, or change, a variable from one to
    another type. Unlike JavaScript, for instance, Python is considered to be on the
    stronger side of the spectrum, and the interpreter sends strong messages when
    you try to perform an illegal operation, such as typing the following in a Python
    interpreter to add a `dict` type to a number:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言根据另一个不同的轴划分为不同的类别：强类型语言和弱类型语言。这个特性告诉我们语言对其类型限制到多大程度，以及从一个类型强制转换为另一个类型有多容易。例如，与JavaScript不同，Python被认为是在这个光谱的较强一侧，当你在Python解释器中尝试执行非法操作时，解释器会发送强烈的消息，例如在Python解释器中输入以下内容以将`dict`类型添加到数字中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, while Python does complain when you attempt to perform unsupported operations,
    it only does so at runtime, not before executing the code. In fact, there is no
    indication to you—the developer—that you are writing code that violates the Python
    type system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然Python会在你尝试执行不支持的操作时抱怨，但它只会在运行时这样做，而不是在执行代码之前。实际上，对于开发者来说，没有任何提示表明你正在编写的代码违反了Python的类型系统。
- en: Type hinting
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示
- en: As you have seen in the previous section, Python is a dynamically typed language,
    and types aren’t known until runtime. Since variable types are embedded in the
    value of the variable itself, as a developer, you cannot know the type of a variable
    that you encounter in a codebase just by looking at it or inspecting it with your
    IDE of choice. Fortunately, Python introduced a very sought-out feature starting
    from version 3.5—type annotations (https://peps.python.org/pep-0484/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中看到的，Python是一种动态类型语言，类型是在运行时才知道的。由于变量类型嵌入在变量的值中，作为一个开发者，仅通过查看它或使用你选择的IDE检查它，你无法知道代码库中遇到的变量的类型。幸运的是，Python从3.5版本开始引入了一个非常受欢迎的特性——类型注解（https://peps.python.org/pep-0484/）。
- en: Type annotations or hints in Python are an additional syntax that notifies you,
    the developer, of the expected type of a variable. They are not used by the Python
    language at runtime, and they do not modify or affect the behavior of your program
    in any way. You might be wondering what the use of these hints is if the Python
    interpreter cannot even see them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解或提示在Python中是额外的语法，它通知你，开发者，变量的预期类型。它们在运行时不被Python语言使用，并且以任何方式修改或影响你的程序的行为。你可能想知道，如果Python解释器甚至看不到它们，这些提示有什么用。
- en: 'As it turns out, several important benefits will make almost any codebase much
    more robust, more maintainable, and future-proof:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，几个重要的好处将使几乎任何代码库都更加健壮、更易于维护和面向未来：
- en: '**Faster code development**: Any developer reading your code will know exactly
    the type of any annotated variable—whether it is an integer or a floating point,
    a list or a set, allowing for faster development.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的代码开发**：任何阅读你代码的开发者都会确切知道任何注释变量的类型——无论是整数还是浮点数，列表还是集合，这有助于加快开发速度。'
- en: '**Knowledge of methods and properties**: You will know exactly which methods
    or properties are available for any given variable. Inadvertently changing the
    type of a variable in a larger codebase will be picked up immediately.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法和属性知识**：你将确切知道任何给定变量可用的哪些方法和属性。在大型代码库中意外更改变量的类型将被立即检测到。'
- en: '**Simplified code development**: Code editors and IDE (such as Visual Studio
    Code) will provide excellent support and auto-completion (IntelliSense), further
    simplifying development and reducing the cognitive load on the developer.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化代码开发**：代码编辑器和 IDE（如 Visual Studio Code）将提供出色的支持和自动完成（IntelliSense），进一步简化开发并减少开发者的认知负荷。'
- en: '**Automatic code generation**: FastAPI provides automatic and interactive (as
    in a fully functional REST API) documentation that is entirely based on Python
    type hints.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动代码生成**：FastAPI 提供基于 Python 类型提示的自动和交互式（如完全功能的 REST API）文档，完全基于 Python 类型提示。'
- en: '**Type checkers**: This is the most important benefit. These are programs that
    run in the background and perform static analysis of your code, spotting potential
    problems and informing you immediately.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型检查器**：这是最重要的好处。这些是在后台运行的程序，对你的代码进行静态分析，发现潜在问题并立即通知你。'
- en: '**Easier to read and smaller cognitive load**: Annotated code is much easier
    to read and puts much less cognitive load on you as a developer when you have
    to work on a piece of code and are trying to figure out what it is supposed to
    do.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易于阅读和更小的认知负荷**：注释的代码更容易阅读，并且当你作为开发者需要处理代码并试图弄清楚它应该做什么时，它对你的认知负荷要小得多。'
- en: '**Strongly typed and flexible**: Preserves the language’s strongly typed nature
    and dynamic typing flexibility, while allowing for imposing the necessary safety
    requirements and constraints. While recommended for larger codebases, Python type
    hints are ingrained into FastAPI and Pydantic, so even the smallest projects will
    require you to at least know your way around types and how to work with them.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强类型且灵活**：保留了语言强类型和动态类型灵活性的特点，同时允许施加必要的安全要求和约束。虽然推荐用于大型代码库，但 Python 类型提示已深入
    FastAPI 和 Pydantic，因此即使是小型项目，也至少需要了解类型以及如何使用它们。'
- en: Type hinting is at the very base of FastAPI. Coupled with MongoDB’s flexible
    document schema, it is the backbone of FARM stack development. Type hinting ensures
    that your application data flow maintains the right data types going in and out
    of the system at every moment. While this might seem trivial for simpler endpoints—quantities
    should be integers, names should be strings, and so on—when your data structure
    becomes more complex, debugging type errors can become very cumbersome.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是 FastAPI 的基础。结合 MongoDB 的灵活文档模式，它是 FARM 栈开发的支柱。类型提示确保你的应用程序数据流在系统中的每个时刻都保持正确的数据类型。虽然对于简单的端点来说这可能看起来微不足道——数量应该是整数，名称应该是字符串等——但是当你的数据结构变得更加复杂时，调试类型错误可能会变得非常繁琐。
- en: Type hints can also be defined as a formalism—a formal solution to statically
    (before runtime) indicate the type of a value to a type checker (**Mypy**, in
    your case), which will ensure that when the Python runtime encounters your program
    the types will not be problematic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示也可以被定义为一种形式化——一种在运行时之前（静态）向类型检查器（在你的情况下是 **Mypy**）指示值类型的正式解决方案，这将确保当 Python
    运行时遇到你的程序时，类型不会成为问题。
- en: The next section will detail the syntax of type hints, how to annotate functions,
    and how to check your code with Mypy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将详细说明类型提示的语法、如何注释函数以及如何使用 Mypy 检查代码。
- en: Implementing type hints
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现类型提示
- en: 'Let’s see how you can implement type hinting. Create a directory named `Chapter3`
    and create a virtual environment inside it, as shown earlier. Inside, add a `requirements.txt`
    file with the following contents if you want to be able to recreate the examples
    in the chapter exactly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现类型提示。创建一个名为 `Chapter3` 的目录，并在其中创建一个虚拟环境，如前所述。在此目录内，如果你想要能够精确地重现章节中的示例，请添加一个包含以下内容的
    `requirements.txt` 文件：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install the packages with `requirements.txt`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `requirements.txt` 安装包：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you are ready to explore the world of Python type hints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好探索 Python 类型提示的世界了。
- en: While there are many Python type checkers—basically tools that perform static
    analysis of the source code without running it—we will use `mypy` as it is easily
    installable. Later, you will have tools such as Black or Ruff at your disposal.
    These perform different actions on your source code, including type checking.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多 Python 类型检查器——基本上是执行源代码静态分析而不运行它的工具——但我们将使用 `mypy`，因为它易于安装。稍后，你将拥有 Black
    或 Ruff 等工具，这些工具会对你的源代码执行不同的操作，包括类型检查。
- en: 'In order to showcase the Python type annotation syntax, a simple function,
    such as the following will suffice:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Python 类型注解语法，一个简单的函数，如下所示，就足够了：
- en: 'Create a file called `chapter3_01.py` and define a simple function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `chapter3_01.py` 的文件并定义一个简单的函数：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous function accepts two parameters, `name` (a string) and `times`
    (an integer), and returns `None`, while the function prints the given name for
    a given number of times in the console. If you try to call the function in your
    code and start typing the arguments, Visual Studio Code (or any IDE with Python
    type-checking support) will immediately suggest a string as the first positional
    argument and an integer as the second.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的函数接受两个参数，`name`（一个字符串）和 `times`（一个整数），并返回 `None`，同时该函数会在控制台打印给定名称指定次数。如果你尝试在代码中调用该函数并开始输入参数，Visual
    Studio Code（或任何具有 Python 类型检查支持的 IDE）会立即建议第一个位置参数为字符串，第二个位置参数为整数。
- en: 'You can try to input the wrong argument types, for instance, an integer first
    and then a string afterward, save the file, and run `mypy` on the command line:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以尝试输入错误的参数类型，例如，先输入一个整数，然后输入一个字符串，保存文件，并在命令行上运行 `mypy`：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Mypy will inform you that there are two errors:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mypy 将会通知你存在两个错误：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example was simple enough, but take a look again at what **Python Enhancement
    Proposal 8** (**PEP 8**)recommends when it comes to the type-hinting syntax with
    another example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子足够简单，但再次看看 **Python 增强提案 8**（**PEP 8**）在另一个例子中对类型提示语法的建议：
- en: 'Insert a simple variable that has a value:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个具有值的简单变量：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The colon is attached to the variable (no spaces), there is one space after
    the colon, and, in cases where you do provide a value, there are spaces around
    the equal sign.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 冒号紧接在变量后面（没有空格），冒号后有一个空格，并且在提供值的情况下，等号周围有空格。
- en: 'When annotating the output of a function, the "arrow," which is made up of
    a dash and greater than sign (`->`), should be surrounded by one space, like this:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当注释函数的输出时，由破折号和大于号组成的“箭头”（`->`）应该被一个空格包围，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far, you have seen simple annotations that constrain a variable to some
    Python primitive types including integers and strings. Typing annotations can
    be more flexible: you might want to allow a variable to accept several variable
    types, such as an integer and a string.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了简单的注解，这些注解将变量限制为一些 Python 原始类型，包括整数和字符串。类型注解可以更加灵活：你可能希望允许变量接受几种不同的变量类型，例如整数和字符串。
- en: 'You can achieve this with the use of the `Union` package from the `typing`
    module:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `typing` 模块的 `Union` 包来实现这一点：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previously defined `x` variable can take a string or an integer value.
    The more modern and concise way of achieving the same functionality is the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前定义的 `x` 变量可以接受字符串或整数值。实现相同功能的一种更现代和简洁的方式如下：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These annotations mean that the variable `x` can be an integer or it can take
    a value of `string`, which is a different type from an integer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注解意味着变量 `x` 可以是整数，也可以接受 `string` 类型的值，这与整数的类型不同。
- en: 'The `typing` module contains several types of so-called generics, including
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing` 模块包含几种所谓的泛型，包括以下几种：'
- en: '`List`: For variables that should be of the list type'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`：用于应该为列表类型的变量'
- en: '`Dict`: For dictionaries'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dict`：用于字典'
- en: '`Sequence`: For any type of sequence of values'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sequence`：用于任何类型的值序列'
- en: '`Callable`: For callables, such as functions'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`：用于可调用对象，例如函数'
- en: '`Iterator`: Indicates that a function or variable accepts an iterator object
    (an object that implements the iterator protocol and can be used in a `for` loop)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator`：表示一个函数或变量接受一个迭代器对象（一个实现迭代器协议并可用于 `for` 循环的对象）'
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You are encouraged to explore the `typing` module but bear in mind that the
    types from the module are gradually being imported into Python’s code functionality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你探索 `typing` 模块，但请记住，该模块中的类型正在逐渐被导入到 Python 的代码功能中。
- en: For instance, the `List` type is very useful in working with FastAPI as it allows
    you to serialize a list of items or resources quickly and efficiently into a JSON
    output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`List` 类型在处理 FastAPI 时非常有用，因为它允许你快速高效地将项目或资源的列表序列化为 JSON 输出。
- en: 'An example of a `List` type is the following, in a new file called `chapter3_02.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类型的例子如下，在一个名为 `chapter3_02.py` 的新文件中：'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another useful type is `Literal` , which restricts the possible values of a
    variable to a few admissible states:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的类型是 `Literal`，它将变量的可能值限制为几个可接受的状态：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding lines showcase the power of type hints. There is nothing inherently
    wrong with assigning the `account_type` variable to a string, but that string
    is not part of the admissible state set and thus Mypy complains and returns an
    `Incompatible types in` `assignment` error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的几行展示了类型提示的力量。将 `account_type` 变量分配给字符串本身并没有什么错误，但这个字符串不是可接受状态集的一部分，因此 Mypy
    会抱怨并返回一个 `Incompatible types in` `assignment` 错误。
- en: 'Now, look at an example that includes a `datetime` argument. Create a new file
    called `chapter3_03.py`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看一个包含 `datetime` 参数的例子。创建一个名为 `chapter3_03.py` 的新文件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previously defined function accepts one parameter—a datetime object—and
    outputs a string: a nicely formatted date and time, useful for displaying on websites.
    If you try to type *dt* and then a dot in your Visual Studio Code editor, you
    will be prompted by the autocompletion system, offering all the methods and properties
    related to the datetime object.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的函数接受一个参数——一个 datetime 对象，并输出一个字符串：一个格式良好的日期和时间，适用于在网站上显示。如果你在 Visual Studio
    Code 编辑器中尝试输入 *dt* 然后一个点，你将收到自动完成系统的提示，提供与 datetime 对象相关的所有方法和属性。
- en: 'To declare a structure as a list of dictionaries (something very familiar to
    anyone working with a JSON-based API), you could use something like this, in a
    file named `chapter3_04.py`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个结构为字典列表（对任何使用基于 JSON 的 API 的人来说都非常熟悉），你可以使用如下方式，在一个名为 `chapter3_04.py`
    的文件中：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After having covered the basic annotation types in Python, the next few sections
    will look at some more advanced types that are very useful when working with FastAPI
    and Pydantic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 Python 中的基本注解类型之后，接下来的几节将探讨一些更高级的类型，这些类型在处理 FastAPI 和 Pydantic 时非常有用。
- en: Advanced annotations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级注解
- en: The annotations you have seen so far are very simple and convey basic information
    related only to the specific desired type of a variable, function, class argument,
    or output. Python’s typing system is capable of much more and it can be used to
    restrict the allowable variables' state further and prevent you, the developer,
    from creating impossible or illegal states in your code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的注解非常简单，仅传达与变量、函数、类参数或输出相关的特定所需类型的基本信息。Python 的类型系统功能更强大，它可以用来进一步限制允许的变量状态，并防止你，作为开发者，在代码中创建不可能或非法的状态。
- en: 'The most frequently used types are the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的类型如下：
- en: The `Optional` type is used for handling optional values and `None` values in
    an explicit and developer-friendly way.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional` 类型用于以明确和开发者友好的方式处理可选值和 `None` 值。'
- en: The `Union` type allows you to define a union of possible types, such as integers
    and strings. Modern Python uses the pipe operator (`|`), as shown in the previous
    example.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Union` 类型允许你定义可能类型的联合，例如整数和字符串。现代 Python 使用管道运算符（`|`），如前例所示。'
- en: The `self` type is used to indicate that the value will be an instance of a
    certain class, useful in Pydantic model validators as we will see later.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self` 类型用于表示值将是某个类的实例，这在 Pydantic 模型验证器中非常有用，正如我们稍后将要看到的。'
- en: The `New` type allows developers to define completely new types based on existing
    types.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New` 类型允许开发者基于现有类型定义全新的类型。'
- en: This section detailed Python type hints, their purpose, and how they are implemented.
    The next section will take a deeper look at Pydantic, the workhorse of FastAPI
    data validation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了 Python 类型提示、它们的目的以及它们的实现方式。下一节将更深入地探讨 Pydantic，FastAPI 数据验证的得力助手。
- en: Pydantic
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pydantic
- en: 'Pydantic is a data validation library labeled on its website as the most widely
    used data validation library for Python. It allows you to model your data in a
    granular way and perform various types of validation while being firmly rooted
    in the Python type hinting system. The actual version, V2, has critical parts
    of the code rewritten in **Rust** for speed and allows for an excellent developer
    experience. The following list describes some of the benefits of using Pydantic:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic是一个数据验证库，在其网站上被标记为Python最广泛使用的验证库。它允许您以细粒度的方式对数据进行建模，并在Python类型提示系统中牢固地扎根，同时执行各种类型的验证。实际版本V2将代码的关键部分重写为**Rust**以提高速度，并提供了出色的开发者体验。以下列表描述了使用Pydantic的一些好处：
- en: '**Based on type hints that are part of the standard library**: Instead of needing
    to learn contrived new systems or terminologies, you just need to learn pure Python
    types.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于标准库中的类型提示**：您无需学习虚构的新系统或术语，只需学习纯Python类型即可。'
- en: '**Excellent speed**: Everything about FastAPI and MongoDB revolves around speed—fast
    and responsive applications delivered in record time—so having a fast validation
    and parsing library is mandatory. The core of Pydantic is written in Rust, which
    ensures high-speed operations on data.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卓越的速度**：FastAPI和MongoDB的各个方面都围绕着速度——以创纪录的时间交付快速且响应迅速的应用程序——因此拥有一个快速的验证和解析库是强制性的。Pydantic的核心是用Rust编写的，这确保了数据操作的高速运行。'
- en: '**Huge community support and wide adoption**: Learning your way around Pydantic
    will prove useful when working with popular packages such as Django Ninja, SQLModel,
    LangChain, and more.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**庞大的社区支持和广泛采用**：当与Django Ninja、SQLModel、LangChain等流行包一起工作时，学习Pydantic将非常有用。'
- en: '**The possibility of emitting JSON schema**: It facilitates integration with
    other systems.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON schema的发射可能性**：它有助于与其他系统集成。'
- en: '**More flexibility**: Pydantic supports different modes (strict and lax when
    it comes to coercion) and nearly unlimited customization options and flexibility.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多灵活性**：Pydantic支持不同的模式（在强制转换方面严格和宽松）以及几乎无限定制的选项和灵活性。'
- en: '**Popular among developers**: It has been downloaded more than 70 million times
    and over 8,000 packages on PyPI depend on Pydantic (as of July 2024).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深受开发者喜爱**：它已被下载超过7000万次，PyPI上有超过8000个包依赖于Pydantic（截至2024年7月）。'
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can take a look at Pydantic in detail in its documentation: [https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其文档中详细了解Pydantic：[https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/)。
- en: Broadly speaking, Pydantic tackles many important problems in a modern web development
    workflow. It ensures that the data that is ingested into your application is properly
    formed and formatted, falls within the desired range, is of the appropriate type
    and dimensions, and reaches your document store safely and without errors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，Pydantic在现代Web开发工作流程中解决了许多重要问题。它确保输入到您的应用程序中的数据是正确形成和格式化的，位于期望的范围内，具有适当类型和尺寸，并且安全且无错误地到达文档存储库。
- en: Pydantic also ensures that your application outputs the data exactly as intended
    and according to the specification, omitting fields that should not be exposed
    (such as user passwords) and even more complex tasks, including interfacing with
    other incompatible systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic还确保您的应用程序输出的数据与预期和规范完全一致，省略了不应公开的字段（如用户密码），甚至包括与不兼容系统交互等更复杂的任务。
- en: FastAPI is standing on the shoulders of two powerful Python libraries—Starlette
    and Pydantic. While Starlette takes care of the web-related aspects of the framework,
    often through thin wrappers and utility functions and classes provided by FastAPI,
    Pydantic is responsible for FastAPI’s phenomenal developer experience. Pydantic
    is fundamental to FastAPI, and leveraging its powerful capabilities opens up the
    playing field for all FARM stack developers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI站在两个强大的Python库——Starlette和Pydantic的肩膀上。虽然Starlette负责框架的Web相关方面，通常通过FastAPI提供的薄包装、实用函数和类来实现，但Pydantic负责FastAPI的非凡开发者体验。Pydantic是FastAPI的基础，利用其强大的功能为所有FARM堆栈开发者打开了竞技场。
- en: While type checking is performed statically (without running the code), the
    role of Pydantic is apparent during runtime and performs the role of a guardian
    of inbound data. Your FastAPI application will receive data from users, from a
    flexible MongoDB database schema, and from other systems via APIs—and Pydantic
    will facilitate the parsing and data validation. Instead of crafting complex validation
    logic for every possible invalid case, you will simply create Pydantic models
    of desired complexity, matching your application’s needs as closely as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型检查是在静态（不运行代码）的情况下执行的，但Pydantic在运行时的作用很明显，并扮演着输入数据的守护者角色。你的FastAPI应用将从用户那里接收数据，从灵活的MongoDB数据库模式中接收数据，以及通过API从其他系统接收数据——Pydantic将简化解析和数据验证。你不需要为每个可能的无效情况编写复杂的验证逻辑，只需创建与你的应用程序需求尽可能匹配的Pydantic模型即可。
- en: In the following sections, you will explore most of functionality of Pydantic
    through examples with increasing complexity and demands as we feel that it is
    the best and most effective way of familiarizing yourself with the library.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将通过具有递增复杂性和要求的示例来探索Pydantic的大部分功能，因为我们认为这是熟悉库的最佳和最有效的方式。
- en: Pydantic basics
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pydantic基础知识
- en: 'Unlike some other libraries that provide similar functionality (such as `dataclasses`),
    Pydantic provides a base model (aptly named `BaseModel`) that enables the parsing
    and validation functionality through inheritance. Since you will be building a
    user model in the coming sections, you can start by jotting down the most basic
    data that needs to be associated with your user. At the minimum, you will need
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些提供类似功能的其他库（如`dataclasses`）不同，Pydantic提供了一个基类（恰当地命名为`BaseModel`），通过继承实现了解析和验证功能。由于你将在接下来的部分中构建用户模型，你可以先列出需要与你的用户关联的最基本数据。至少，你需要以下内容：
- en: A username
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: An email address
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: An ID (keep it as an integer for now)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个ID（目前保持为整数）
- en: A date of birth
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生日期
- en: 'In Pydantic, a user model that would be associated with this specification
    could look like the following, in a file called `chapter3_05.py`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pydantic中，一个与该规范相关联的用户模型可能如下所示，在一个名为`chapter3_05.py`的文件中：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `User` class already handled a lot of work for you—there is no need to perform
    validation checks as the instantiation of the class performs the validation and
    parsing immediately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类已经为你处理了很多工作——在类实例化时立即执行验证和解析，因此不需要执行验证检查。'
- en: 'The process of constructing the class is pretty straightforward: each field
    has a type declaration, and Pydantic is ready to inform you of any erroneous types
    it might encounter.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类的过程相当直接：每个字段都有一个类型声明，Pydantic准备好通知你任何可能遇到的错误类型。
- en: 'If you try and create a user, you shouldn’t see any errors:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试创建一个用户，你不应该看到任何错误：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Say however, you create a user with the wrong data, and conveniently import
    the Pydantic `ValidationError`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你创建了一个包含错误数据的用户，并且方便地导入了Pydantic的`ValidationError`：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Pydantic will inform you that the data cannot be validated when you run the
    program:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，Pydantic会通知你数据无法验证：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The error messages of Pydantic, derived from `ValidationError`, are deliberately
    informative and precise. The field with an error is called `id` and the type of
    error is described. The first useful aspect that comes to mind is that if there
    were several errors—for instance, you might provide an invalid `datetime`—Pydantic
    will not stop at the first error. It will continue parsing the entire instance
    and outputting the list of errors that can easily be output in JSON format. That
    is actually the desired behavior when working with APIs; you want to be able to
    list all the errors, for instance, to a user that has sent the wrong data to the
    backend. The exception contains a list of all the encountered errors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic的错误信息，源自`ValidationError`，是故意设计得信息丰富且精确的。出现错误的字段被称作`id`，错误类型也会被描述。首先想到的有用之处是，如果有多个错误——例如，你可能提供了一个无效的`datetime`——Pydantic不会在第一个错误处停止。它会继续解析整个实例，并输出一个错误列表，这个列表可以很容易地以JSON格式输出。这实际上是在处理API时的期望行为；你希望能够列出所有错误，例如，向发送了错误数据的后端用户。异常包含了一个遇到的所有错误的列表。
- en: The model guarantees that the instance, once validation is passed, will have
    the required fields and that they are of the correct type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模型保证实例在验证通过后，将包含所需的字段，并且它们的类型是正确的。
- en: 'You can also provide defaults and nullable types, according to the type hinting
    conventions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据类型提示约定提供默认值和可空类型：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous model has a default `id` value (which is not something that you
    would want to do in practice) and a list of favorite colors as strings, which
    can also be `None`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的模型有一个默认的 `id` 值（这在实践中可能不是你想要做的）以及一个作为字符串的喜欢的颜色列表，这些也可以是 `None`。
- en: 'When you create and print a model (or more precisely, when you invoke its representation
    via the `print` function), you get a nice output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建并打印一个模型（或者更准确地说，当你通过 `print` 函数调用它的表示时），你会得到一个漂亮的输出：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pydantic by default operates in a lax mode, which means that it will try to
    coerce the provided types to the ones that are declared in the model. For instance,
    if you pass the user ID as a string `"2"` to the model, there will not be any
    errors, as Pydantic automatically converts the ID to an integer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 默认以宽松模式运行，这意味着它会尝试将提供的类型强制转换为模型中声明的类型。例如，如果你将用户 ID 作为字符串 `"2"` 传递给模型，将不会出现任何错误，因为
    Pydantic 会自动将 ID 转换为整数。
- en: Although fields are available through the dot notation (`user.id`) and they
    can be easily modified, this is not recommended as the validation rules will not
    be applied. You could instantiate a user with an `id` value of `5`, access `user.id`,
    and set it to a string `"five"`, but that is probably not something you would
    want.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字段可以通过点符号（`user.id`）访问并且可以轻松修改，但这不建议这样做，因为验证规则将不会应用。你可以创建一个具有 `id` 值为 `5`
    的用户实例，访问 `user.id`，并将其设置为字符串 `"five"`，但这可能不是你想要的。
- en: 'Besides pure data validation, Pydantic provides other important functionalities
    to your application. Some of the most widely used operations with Pydantic models
    are the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯粹的数据验证之外，Pydantic 还为你的应用程序提供了其他重要的功能。Pydantic 模型中最广泛使用的操作包括以下内容：
- en: '**Data deserialization**: Ingesting data into the model'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据反序列化**：将数据摄入模型'
- en: '**Data serialization**: Outputting validated data from the model into Python
    data structures or JSON'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据序列化**：将验证后的数据从模型输出到 Python 数据结构或 JSON'
- en: '**Data modification**: Sanitizing or modifying data on the fly'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据修改**：实时清理或修改数据'
- en: The next few sections will look at each of these operations in more detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将更详细地查看这些操作的每一个。
- en: Deserialization
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反序列化
- en: Deserialization refers to the process of providing data to the model, which
    is the input phase, as opposed to the process of serialization, which means outputting
    model data in a desired form. Deserialization is tightly coupled with validation
    as the processes of validation and parsing are performed when instantiating the
    model, although this can be overridden.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化是指向模型提供数据的过程，这是输入阶段，与序列化过程相对，序列化意味着以期望的形式输出模型数据。反序列化与验证紧密相关，因为验证和解析过程是在实例化模型时执行的，尽管这可以被覆盖。
- en: In Pydantic, the term `ValidationError` type of Pydantic that is raised when
    data cannot be successfully parsed into a model instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pydantic 中，`ValidationError` 是 Pydantic 类型，当数据无法成功解析为模型实例时会被抛出。
- en: 'While you have already performed a couple of validations through instantiating
    the Pydantic-based user models, the data to be validated is often passed in the
    form of a dictionary. The following is an example of passing data as a dictionary,
    in a file named `chapter3_06.py`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经通过实例化基于 Pydantic 的用户模型执行了一些验证，但待验证的数据通常以字典的形式传递。以下是一个将数据作为字典传递的示例，文件名为
    `chapter3_06.py`：
- en: 'Create another version of your user model and pass it a dictionary of data:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的用户模型的另一个版本，并传递一个包含数据的字典：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `.model_validate()` method is a helper that accepts a Python dictionary
    and performs the class instantiation and thus validation. This method creates
    your `user` instance and validates the data types in one step.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`.model_validate()` 方法是一个辅助方法，它接受一个 Python 字典并执行类实例化和验证。这个方法在一步中创建你的 `user`
    实例并验证数据类型。'
- en: Similarly, `model_validate_json()` accepts a JSON string (useful when working
    with APIs).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`model_validate_json()` 接受一个 JSON 字符串（当与 API 一起工作时很有用）。
- en: There is also a method for constructing a model instance without validation
    with `model_construct()` but this has very specific user cases and is not recommended
    in most cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `model_construct()` 方法不进行验证来构建模型实例，但这有非常特定的用户场景，并且在大多数情况下不推荐使用。
- en: You have learned how to pass data to your simple Pydantic model. The next section
    will take a closer look at the model fields and their properties.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将数据传递给你的简单 Pydantic 模型。下一个部分将更详细地查看模型字段及其属性。
- en: Model fields
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型字段
- en: Pydantic fields are based on Python types and setting them to be required or
    nullable and providing default values is intuitive. For instance, to create a
    default value for a field, it is enough to provide it in the model as a value,
    while the nullable field follows the same conventions that you saw in the *Python
    types* sections—by using the older union syntax from the `typing` module, or the
    newer syntax with the pipe operator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 字段基于 Python 类型，设置它们为必需或可空并提供默认值是直观的。例如，要为字段创建默认值，只需在模型中提供它作为值即可，而可空字段遵循你在
    *Python 类型* 部分中看到的相同约定——通过使用 `typing` 模块的旧联合语法，或使用带有管道操作符的新语法。
- en: 'The following is an example of another user model in a file named `chapter3_07.py`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为 `chapter3_07.py` 的文件中另一个用户模型的示例：
- en: 'Insert some default values:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一些默认值：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The previously defined `UserModel` class defines a couple of standard string-type
    fields: an account that can have exactly two values or be equal to `None` and
    a nickname that can be a string or `None`.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前定义的 `UserModel` 类定义了一些标准的字符串类型字段：一个账户可以有两个确切值或等于 `None`，以及一个昵称可以是字符串或 `None`。
- en: 'You may use the `model_fields` property to inspect the model as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `model_fields` 属性如下检查模型：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will get a handy list of all the fields belonging to the model with information
    about them including their types and whether they are required:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得一个方便的列表，其中包含属于该模型的所有字段及其信息，包括它们的类型和是否为必需项：
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The next section will detail Pydantic-specific types that make working with
    the library easier and faster.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将详细介绍 Pydantic 特定的类型，这些类型使得使用库更加容易和快速。
- en: Pydantic types
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pydantic 类型
- en: While Pydantic is based on standard Python types such as strings, integers,
    dictionaries, and sets, which makes it very intuitive and straightforward for
    starting, the library also provides a plethora of customizations and solutions
    for common cases. In this section, you will get to know the most useful ones.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Pydantic 基于标准 Python 类型，如字符串、整数、字典和集合，这使得它对于初学者来说非常直观和简单，但该库还提供了一系列针对常见情况的定制和解决方案。在本节中，你将了解其中最有用的。
- en: 'Strict types such as `StrictBool`, `StrictInt`, `StrictStr`, and other Pydantic-specific
    types are types that will pass validation only if the validated value belongs
    to these types, without any coercion: a `StrictInt` must be of type `Integer`
    and not `"1"` or `1.0`, for example.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的类型，如 `StrictBool`、`StrictInt`、`StrictStr` 和其他 Pydantic 特定类型，是只有当验证的值属于这些类型时才会通过验证的类型，没有任何强制转换：例如，`StrictInt`
    必须是 `Integer` 类型，而不是 `"1"` 或 `1.0`。
- en: Constrained types provide additional constraints for existing types. For instance,
    `condate()` is a date type with greater than, greater than or equal, less than,
    and less than or equal constraints. `conlist()` wraps the list type and adds length
    validation or can impose a rule that the items contained must be unique.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 限制类型为现有类型提供额外的约束。例如，`condate()` 是一个具有大于、大于等于、小于和小于等于约束的日期类型。`conlist()` 包装列表类型并添加长度验证，或可以强制规则，即包含的项必须是唯一的。
- en: 'Pydantic is not limited to the validation of primitive types such as strings
    and integers. Many additional validators cover the vast majority of uses that
    you might run into while modeling your business logic. For instance, the `email`
    validator validates email addresses and, since it is not part of the core Pydantic
    package, it needs to be installed separately by using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 不仅限于验证原始类型，如字符串和整数。许多额外的验证器涵盖了你在建模业务逻辑时可能遇到的大多数使用情况。例如，`email` 验证器验证电子邮件地址，由于它不是
    Pydantic 核心包的一部分，因此需要使用以下命令单独安装：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Pydantic website (https://docs.pydantic.dev/latest/api/types/) provides
    a comprehensive list of additional validation types that extend the functionalities—lists
    can have a minimum and maximum length, uniqueness can be required, integers can
    be positive or negative, and many more, including CSS color codes, for instance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 网站（https://docs.pydantic.dev/latest/api/types/）提供了一个全面的附加验证类型列表，这些类型扩展了功能——列表可以有最小和最大长度，唯一性可以是必需的，整数可以是正数或负数，等等，例如
    CSS 颜色代码。
- en: Pydantic fields
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pydantic 字段
- en: While the simple Python type annotations might suffice in many cases, the real
    power of Pydantic starts to show when you begin to use the `Field` class for the
    fields. The `Field` class is used to customize models and add metadata to the
    model fields.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的 Python 类型注解在许多情况下可能足够，但 Pydantic 的真正力量开始在你开始使用 `Field` 类为字段定制模型并添加元数据到模型字段时显现出来。
- en: Let’s see how you can use the `Field` class for the `UserModel` explored in
    the previous section. Create a file and name it `chapter3_08.py`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用上一节中探讨的 `UserModel` 的 `Field` 类。创建一个文件，并将其命名为 `chapter3_08.py`。
- en: 'First, rewrite your previous `UserModel` with the help of the `Field` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `Field` 类重写你之前的 `UserModel`：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This model is equivalent to the one previously defined without fields. The first
    syntactic difference can be seen in the way default values are provided—the `Field`
    class accepts a default value that is defined explicitly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型与之前定义的没有字段的模型等效。第一个语法差异可以在提供默认值的方式中看到——`Field` 类接受一个显式定义的默认值。
- en: Fields also provide additional model flexibility, through the use of aliases,
    as you will see in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 字段还通过使用别名提供了额外的模型灵活性，正如你将在下一节中看到的。
- en: Field aliases
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段别名
- en: 'Fields allow you to create and use aliases, which is very useful when dealing
    with different systems that need to be compatible with your Pydantic-based data
    definition. Create a file named `chapter3_09.py`. Assume that your application
    uses the `UserModelFields` model for users, but also needs to be able to ingest
    data from another system, maybe through a JSON-based API, and this other system
    sends the data in the following JSON format:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 字段允许你创建和使用别名，这在处理需要与你的基于 Pydantic 的数据定义兼容的不同系统时非常有用。创建一个名为 `chapter3_09.py`
    的文件。假设你的应用程序使用 `UserModelFields` 模型来处理用户，但也需要能够从另一个系统接收数据，可能通过基于 JSON 的 API，而这个其他系统发送的数据格式如下：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This format clearly doesn’t conform to your `UserModelFields` model and aliases
    provide an elegant way of dealing with this incompatibility:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式明显不符合你的 `UserModelFields` 模型，而别名提供了一种优雅地处理这种不兼容性的方法：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This updated model provides aliases for all the fields that have different
    names, so it is possible to validate your external data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新后的模型为所有具有不同名称的字段提供了别名，因此可以验证你的外部数据：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, you have used the simple `alias` parameter, but there are other
    options for aliases for serialization or for validation only.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你已经使用了简单的 `alias` 参数，但还有其他选项用于别名，用于序列化或仅用于验证。
- en: Additionally, the `Field` class enables numeric values to be constrained in
    different ways, which is a feature heavily used in FastAPI. Create a file called
    `chapter3_10.py` and start populating it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Field` 类允许以不同的方式约束数值，这是 FastAPI 中广泛使用的一个特性。创建一个名为 `chapter3_10.py` 的文件并开始填充它。
- en: 'Suppose you need to model a chess event that has the following fields:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要模拟一个具有以下字段的棋类活动：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this relatively simple class, Pydantic fields introduce some complex validation
    rules that would otherwise be very verbose and cumbersome to write:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相对简单的课程中，Pydantic 字段引入了一些复杂的验证规则，否则这些规则将非常冗长且难以编写：
- en: '`dt`: The `datetime` object of the tournament uses a `default_factory` parameter,
    a function invoked at instantiation time that provides the default value. In this
    case, the value is equal to `datetime.now`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dt`：锦标赛的 `datetime` 对象使用 `default_factory` 参数，这是一个在实例化时调用的函数，它提供了默认值。在这种情况下，值等于
    `datetime.now`。'
- en: '`name`: This field has some length constraints, such as the minimum and maximum
    length.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此字段有一些长度约束，例如最小和最大长度。'
- en: '**The number of enlisted players is constrained**: It must be greater than
    or equal to 4, less than or equal to 16, and additionally, it must be an even
    number—a multiple of 2—to allow for all players to play in each round.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册球员的数量受到限制**：它必须大于或等于 4，小于或等于 16，并且还必须是偶数——2 的倍数，以便所有球员都能在每一轮比赛中进行比赛。'
- en: '`uuid` library.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid` 库。'
- en: '`id`: This field is an integer, but this time you apply the `strict` flag,
    which means you override the default behavior of Pydantic and do not allow strings
    like `"3"` to pass validation, even though they could be cast to integers.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：此字段是一个整数，但这次你应用了 `strict` 标志，这意味着你覆盖了 Pydantic 的默认行为，不允许像 `"3"` 这样的字符串通过验证，即使它们可以被转换为整数。'
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A useful page in the Pydantic documentation is dedicated to Fields: https://docs.pydantic.dev/latest/concepts/fields/.
    There are numerous validation options available through the `Field` class, and
    you are encouraged to skim through them before you start your modeling process.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 文档中的一个有用页面专门介绍了字段：https://docs.pydantic.dev/latest/concepts/fields/。`Field`
    类提供了许多验证选项，建议在开始建模过程之前浏览一下。
- en: The next section will detail how to get the data out of the model through the
    process of deserialization.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将详细介绍如何通过反序列化过程从模型中获取数据。
- en: Serialization
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: The most important task of any parsing and validation library is data serialization
    (or data dumping). It is the process of converting and outputting a model instance
    to a Python dictionary or a JSON-encoded string. The method for generating a Python
    dictionary is `model_dump()`, as demonstrated by the following user model example,
    in a new file called `chapter3_11.py`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 任何解析和验证库最重要的任务是数据序列化（或数据导出）。这是将模型实例转换为 Python 字典或 JSON 编码字符串的过程。生成 Python 字典的方法是
    `model_dump()`，如下面的用户模型示例所示，在一个名为 `chapter3_11.py` 的新文件中。
- en: 'To be able to use email validation in Pydantic, add the following line to the
    `requirements.txt` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Pydantic 中使用电子邮件验证，请将以下行添加到 `requirements.txt` 文件中：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then, re-run the user model:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新运行用户模型：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The user model that you are using is a fairly standard one, and, with your
    knowledge of Pydantic fields, you can already understand it. There are a couple
    of new validations, but they are intuitive: the `EmailStr` object imported from
    Pydantic is a string that validates email addresses, while the `password` field
    contains an additional regular expression to ensure that the field contains only
    alphanumeric characters and no spaces. Here’s another example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用的用户模型是一个相当标准的模型，并且，凭借您对 Pydantic 字段的了解，您已经可以理解它。有几个新的验证，但它们是直观的：从 Pydantic
    导入的 `EmailStr` 对象是一个验证电子邮件地址的字符串，而 `password` 字段包含一个额外的正则表达式，以确保该字段只包含字母数字字符，没有空格。以下是一个例子：
- en: 'Create an instance of the model and serialize it to a Python dictionary:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模型的一个实例并将其序列化为 Python 字典：
- en: '[PRE33]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is a simple Python dictionary:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是一个简单的 Python 字典：
- en: '[PRE34]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Try to dump the model to a JSON representation and omit the password for security
    reasons:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将模型导出为 JSON 表示形式并出于安全原因省略密码：
- en: '[PRE35]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is a JSON string with the password omitted:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是一个省略密码的 JSON 字符串：
- en: '[PRE36]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Serialization uses the field names and not the aliases by default, but that
    is another setting that can be easily overridden by setting the `by_alias` flag
    to `True`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化默认使用字段名而不是别名，但这是可以通过将 `by_alias` 标志设置为 `True` 来轻松覆盖的另一个设置。
- en: An example of an alias used when working with FastAPI and MongoDB is MongoDB’s
    `ObjectId` field, which is mostly serialized as a string. Another useful method
    is `model_json_schema()`, which generates the JSON schema for a model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 FastAPI 和 MongoDB 时，一个使用的别名示例是 MongoDB 的 `ObjectId` 字段，它通常序列化为字符串。另一个有用的方法是
    `model_json_schema()`，它为模型生成 JSON 模式。
- en: 'Models can be additionally configured through the `ConfigDict` object, and
    the special field called `model_config`—the name is reserved and mandatory. In
    the following file, called `chapter3_12.py`, you are using the `model_config`
    field to allow populating the model by name and prevent passing additional data
    to the model:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以通过 `ConfigDict` 对象进行额外配置，以及一个名为 `model_config` 的特殊字段——该名称是保留的且必须的。在以下名为
    `chapter3_12.py` 的文件中，您使用 `model_config` 字段允许通过名称填充模型并防止向模型传递额外的数据：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `model_config` field allows for additional configuration of the model.
    For instance, the `extra` keyword refers to additional data fields that are passed
    to the deserialization process: the default behavior is just to ignore this data.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`model_config` 字段允许对模型进行额外配置。例如，`extra` 关键字指的是传递给反序列化过程的数据字段：默认行为是简单地忽略这些数据。'
- en: In this example, we set `extra` to `forbid`, so any additional data passed and
    not declared in the model will throw a validation error. `populate_by_name` is
    another useful setting as it allows us to populate a model by using field names
    and not only aliases, practically mixing and matching. You will see that this
    feature is handy when crafting APIs that have to talk to different systems.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将 `extra` 设置为 `forbid`，因此任何传递的额外数据（未在模型中声明）将引发验证错误。"populate_by_name"
    是另一个有用的设置，因为它允许我们使用字段名而不是仅使用别名来填充模型，实际上是将两者混合使用。您将看到，当构建需要与不同系统通信的 API 时，此功能非常方便。
- en: Custom serializers
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义序列化器
- en: Pydantic can provide you with virtually unlimited capabilities when it comes
    to serialization and also provides different serialization methods for Python
    and JSON outputs with the use of the `@``field_serializer` decorator.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到序列化时，Pydantic几乎可以提供无限的能力，并且还提供了不同的序列化方法，用于Python和JSON输出，这通过使用`@field_serializer`装饰器来实现。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Python decorators are a powerful and elegant feature that allow you to modify
    or extend the behavior of functions or methods without changing their actual code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python装饰器是一种强大而优雅的特性，允许您在不更改实际代码的情况下修改或扩展函数或方法的行为。
- en: Decorators are higher-order functions that take a function as input, add some
    functionality, and return a new, decorated function. This approach promotes the
    reusability, modularity, and separation of concerns in your Python programs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是高阶函数，它接受一个函数作为输入，添加一些功能，并返回一个新的、装饰过的函数。这种方法促进了Python程序的可重用性、模块化和关注点的分离。
- en: 'In the following example, you are going to create a very simple bank account
    model and use different serializers depending on the type of serialization. Your
    requirement is to round the balance to exactly two decimals and, only when serializing
    to JSON, to format the `updated` field according to the ISO format:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您将创建一个非常简单的银行账户模型，并使用不同类型的序列化器。您的需求是将余额精确四舍五入到两位小数，并且在序列化为JSON时，将`updated`字段格式化为ISO格式：
- en: 'Create a new file named `chapter3_13.py` and add a simple model for a bank
    account that contains only two fields, the balance and the time of the last account
    update:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter3_13.py`的新文件，并添加一个简单的银行账户模型，该模型只包含两个字段：余额和最后账户更新时间：
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You have added two custom serializers. The first is the balance serializer (as
    denoted by the string `"balance"`), which will always be used. This serializer
    simply rounds the balance to two decimals. The second serializer is used only
    for JSON serialization and returns the date as an ISO-formatted datetime string.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您已添加了两个自定义序列化器。第一个是余额序列化器（如字符串`"balance"`所示），它将始终被使用。这个序列化器简单地将余额四舍五入到两位小数。第二个序列化器仅用于JSON序列化，并将日期返回为ISO格式的日期时间字符串。
- en: 'If you try to populate the model and inspect the serializations, you will see
    how the serializers modified the initial default output:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试填充模型并检查序列化，您将看到序列化器如何修改了初始默认输出：
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get a similar output:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将得到类似的输出：
- en: '[PRE40]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Earlier in this chapter, you saw basic validation provided by Pydantic through
    the mere instantiation of the model class. The next section will discuss the various
    custom validation methods of Pydantic with the help of Pydantic decorators and
    how they can be leveraged to move beyond serialization and provide powerful custom
    validation functionality.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，您已经看到了通过仅实例化模型类所提供的Pydantic基本验证。下一节将讨论Pydantic的各种自定义验证方法，以及如何借助Pydantic装饰器来利用这些方法，从而超越序列化并提供强大的自定义验证功能。
- en: Custom data validation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义数据验证
- en: Similar to custom field serializers, custom field validators are implemented
    as decorators, with the `@``field_validator` decorator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义字段序列化器类似，自定义字段验证器作为装饰器实现，使用`@field_validator`装饰器。
- en: Field validators are class methods, so they must receive the entire class as
    the first argument, not the instance, while the second value is the name of the
    field to be validated (or a list of fields, or the `*` symbol for all fields).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 字段验证器是类方法，因此它们必须接收整个类作为第一个参数，而不是实例，第二个值是要验证的字段名称（或字段列表，或`*`符号表示所有字段）。
- en: 'Field validators should return either the parsed value or a `ValueError` response
    (or `AssertionError`) in case the data passed to the validator doesn’t conform
    to the validation rules. As with other Pydantic features, it is much easier to
    start with an example. Create a new file called `chapter3_14.py` and insert the
    following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 字段验证器应返回解析后的值或一个`ValueError`响应（或`AssertionError`），如果传递给验证器的数据不符合验证规则。与其他Pydantic功能一样，从示例开始要容易得多。创建一个名为`chapter3_14.py`的新文件，并插入以下代码：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The validator is run before the class instantiation and accepts the class and
    the name of the validated field as arguments. The `check_title` validator checks
    that the title contains the string `"FARM stack"` and if it doesn’t, it throws
    `ValueError`. Additionally, the validator returns the string in title case, so
    we can perform data transformation as well, at the field level.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器在类实例化之前运行，并接受类和验证的字段名称作为参数。`check_title`验证器检查标题是否包含字符串`"FARM stack"`，如果不包含，则抛出`ValueError`。此外，验证器返回标题大写的字符串，因此我们可以在字段级别执行数据转换。
- en: While field validators provide great flexibility, they do not consider field
    interactions and the combinations of field values. That is where model validators
    come into play, as the next section will outline.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字段验证器提供了很大的灵活性，但它们并没有考虑字段之间的交互和字段值的组合。这就是模型验证器发挥作用的地方，下一节将详细说明。
- en: Model validators
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型验证器
- en: Another useful feature when performing validation of web-related data is model
    validation—the possibility to write validation functions at the model level, allowing
    for complex interactions between various fields.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行与网络相关数据的验证时，另一个有用的功能是模型验证——在模型级别编写验证函数的可能性，允许各种字段之间进行复杂的交互。
- en: 'The model validators can run before or after instantiating the model class.
    Again, we will take a look at a rather simple example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 模型验证器可以在实例化模型类之前或之后运行。我们再次将关注一个相当简单的例子：
- en: First, create a new file and name it `chapter3_15.py`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新文件，并将其命名为`chapter3_15.py`。
- en: 'Suppose you have a user model with the following structure:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个具有以下结构的用户模型：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The model is simple like the previous ones, and it contains two password fields
    that are required to match to enable the registration of a new user. Additionally,
    you want to impose another validation—the data that comes into the model via deserialization
    must not contain private data (such as a social security number or card number).
    Model validators allow you to perform flexible validations such as this.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该模型与之前的模型一样简单，它包含两个密码字段，这两个字段必须匹配才能注册新用户。此外，你还想施加另一个验证——通过反序列化进入模型的 数据不得包含私有数据（如社会保险号码或卡号）。模型验证器允许你执行此类灵活的验证。
- en: 'Continuing the previous model, you can write the following model validators
    under the class definition:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续上一个模型，你可以在类定义下编写以下模型验证器：
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, try to validate of the following data:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试验证以下数据：
- en: '[PRE44]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You will be informed of just one error—the one related to the `before` mode,
    stating that private data should not be included.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你只会被告知一个错误——与`before`模式相关的错误，指出不应包含私有数据。
- en: 'If you comment out or delete the line that sets the `private_data` field and
    re-run the example, the error becomes the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你取消注释或删除设置`private_data`字段的行并重新运行示例，错误将变为以下内容：
- en: '[PRE45]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a couple of new concepts involved in the previous example; you are
    using the `Self` Python type, introduced for denoting instances of the wrapping
    class, so you practically expect the output to be an instance of the `UserModelV`
    class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中涉及了一些新概念；你正在使用Python的`Self`类型，它是为了表示包装类的实例而引入的，因此你实际上期望输出是`UserModelV`类的实例。
- en: Another new concept is present in the `check_private_data` function as it checks
    whether the data passed to the class is an instance of a dictionary, and then
    proceeds to verify whether the undesired `private_data` field is present in the
    dictionary—this is just Pydantic’s way of checking for the data passed as it is
    stored inside a dictionary.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`check_private_data`函数中，还有一个新概念，它检查传递给类的数据是否是字典的实例，然后继续验证字典中是否包含不希望的`private_data`字段——这只是Pydantic检查传递数据的途径，因为它存储在字典内部。
- en: The next section will detail how to compose nested models with Pydantic to validate
    models of increasing complexity.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将详细介绍如何使用Pydantic组合嵌套模型以验证越来越复杂的模型。
- en: Nested models
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套模型
- en: 'The treatment of nested models in Pydantic through composition is very straightforward
    and intuitive if you are coming from a basic MongoDB background. To understand
    how to implement nested models, the easiest way is to start from an existing data
    structure that needs to be validated and run through Pydantic:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自基本的MongoDB背景，那么通过组合在Pydantic中对嵌套模型的处理非常简单直观。要了解如何实现嵌套模型，最简单的方法是从需要验证的现有数据结构开始，并通过Pydantic进行操作：
- en: 'Begin with the structure of a JSON document that returns car brands and makes
    (or models). Create a new file named `chapter3_16.py` and add the following lines
    of code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从返回汽车品牌和型号（或模型）的 JSON 文档结构开始。创建一个名为 `chapter3_16.py` 的新文件，并添加以下代码行：
- en: '[PRE46]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can start from the inside of the data structure and begin identifying the
    smallest units or the most deeply nested structures—in this case, the smallest
    unit is the car model (a Ford Mustang from 1964).
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从数据结构内部开始，识别最小的单元或最深层嵌套的结构——在这个例子中，最小的单元是1964年的福特野马车型。
- en: 'This can be the first Pydantic model:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以是第一个 Pydantic 模型：
- en: '[PRE47]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once this first abstraction is made, it is easy to create a model for the brand:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这个初步的抽象，创建品牌模型就变得容易了：
- en: '[PRE48]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The car brand model has distinct names and countries of origin and contains
    a list of models.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车品牌型号有独特的名称和产地，并包含一系列车型。
- en: Model fields can be other models (or lists or sets or other sequences thereof)
    and this feature makes mapping Pydantic data structures to data, and especially
    MongoDB documents, a very pleasant and intuitive process.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模型字段可以是其他模型（或列表、集合或其他序列）并且这个特性使得将 Pydantic 数据结构映射到数据，尤其是 MongoDB 文档，变得非常愉快和直观。
- en: While MongoDB can support up to 100 levels of nesting, you will probably not
    hit that limit in your data modeling process. However, it’s worth noting that
    Pydantic will support you as you delve deeper and deeper into your data structures.
    Embedding data also becomes much more manageable from the Python side, as you
    can rest assured that data coming into your collections is stored as intended.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MongoDB 可以支持多达 100 层的嵌套，但在您的数据建模过程中，您可能不会达到这个限制。然而，值得注意的是，Pydantic 将在您深入数据结构时支持您。从
    Python 端嵌入数据也变得更加容易管理，因为您可以确信进入您集合的数据是按照预期存储的。
- en: The next and final section will detail another useful tool that Pydantic offers—a
    little help with managing environment variables and settings, a problem that you
    face in every web-related project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节和最后一节将详细介绍 Pydantic 提供的另一个有用工具——在处理环境变量和设置时提供一些帮助，这是每个与网络相关的项目都会遇到的问题。
- en: Pydantic Settings
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pydantic Settings
- en: Pydantic Settings is an external package that needs to be installed separately.
    It provides Pydantic features for loading a settings or config class from environment
    variables or secret files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic Settings 是一个外部包，需要单独安装。它提供了从环境变量或秘密文件中加载设置或配置类的 Pydantic 功能。
- en: That is basically the definition from the Pydantic website ([https://docs.pydantic.dev/latest/concepts/pydantic_settings/](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)),
    and the whole concept revolves around the `BaseSettings` class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是 Pydantic 网站上的定义（[https://docs.pydantic.dev/latest/concepts/pydantic_settings/](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)），整个概念围绕着
    `BaseSettings` 类展开。
- en: A model that inherits from this class attempts to read the values of any fields
    passed as keyword arguments by scanning the environment.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从此类继承的模型会尝试通过扫描环境来读取任何作为关键字参数传递的字段值。
- en: This simple functionality allows you to define clear and straightforward configuration
    classes from environment variables. Pydantic settings can also automatically pick
    up environment modifications and, when needed, manually override settings for
    testing, development, or production.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的功能允许您从环境变量中定义清晰和直接的配置类。Pydantic 设置也可以自动获取环境修改，并在需要时手动覆盖测试、开发或生产中的设置。
- en: 'In the following exercise, you will create a simple `pydantic_settings` setup
    that will allow you to read environment variables and easily override them in
    case the necessity arises:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将创建一个简单的 `pydantic_settings` 设置，这将允许您读取环境变量，并在必要时轻松覆盖它们：
- en: 'Install Pydantic settings with `pip`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pip` 安装 Pydantic settings：
- en: '[PRE49]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a `.env` file at the same level as your project files:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与项目文件同一级别的位置创建一个 `.env` 文件：
- en: '[PRE50]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now you can set up a simple `Settings` configuration (the `chapter3_17.py`
    file):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以设置一个简单的 `Settings` 配置（`chapter3_17.py` 文件）：
- en: '[PRE51]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you run this code, both the Python and the `.env` file are on the same path,
    so you will see that Pydantic was able to read the environment variables from
    the `.``env` file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行此代码，Python 和 `.env` 文件位于同一路径，您将看到 Pydantic 能够从 `.env` 文件中读取环境变量：
- en: '[PRE52]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: However, if you set an environment variable, it will take precedence over the
    `.``env` file.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果您设置了环境变量，它将优先于 `.env` 文件。
- en: 'You can test it by adding this line before the `Settings()` call and observing
    the output of the program:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在 `Settings()` 调用之前添加此行来测试它，并观察程序的输出：
- en: '[PRE53]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Pydantic Settings makes managing configurations such as your Atlas and MongoDB
    URLs, secrets for hashing passwords, and other configurations much more structured
    and organized.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 设置使得管理配置，如 Atlas 和 MongoDB 的 URL、密码散列的秘密以及其他配置，变得更加结构化和有序。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter detailed aspects of Python that are either new and still evolving,
    or often simply overlooked, such as type hinting, and the implications that their
    use can have on your projects.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了 Python 的一些方面，这些方面要么是新的且仍在发展中，要么通常被简单地忽视，例如类型提示，以及它们的使用可能对你的项目产生的影响。
- en: FastAPI is based on Pydantic and type hinting. Working with these solid principles
    and conventions will make your code more robust, maintainable, and future-proof
    even when working with other frameworks. You have a solid Python types foundation
    and have learned the basic functionalities provided by Pydantic—validation, serialization,
    and deserialization.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 基于 Pydantic 和类型提示。与这些稳固的原则和约定一起工作，将使你的代码更加健壮、可维护和面向未来，即使在与其他框架一起工作时也是如此。你已经拥有坚实的
    Python 类型基础，并学习了 Pydantic 提供的基本功能——验证、序列化和反序列化。
- en: You have learned how to deserialize, serialize, and validate data through Pydantic,
    and even add some transformations during the process, creating structures of increased
    complexity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何通过 Pydantic 反序列化、序列化和验证数据，甚至在过程中添加一些转换，创建更复杂的结构。
- en: This chapter has equipped you to learn more web-specific aspects of FastAPI
    and to blend data seamlessly between MongoDB, Python data structures, and JSON.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已为你提供了学习更多 FastAPI 的网络特定方面的能力，以及如何在 MongoDB、Python 数据结构和 JSON 之间无缝混合数据。
- en: The next chapter will explore FastAPI and its Pythonic foundations.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨 FastAPI 及其 Pythonic 基础。
