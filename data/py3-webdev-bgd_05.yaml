- en: Chapter 5. Entities and Relations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 实体和关系
- en: Most real life applications sport more than one entity and often many of these
    entities are related. Modeling these relations is one of the strong points of
    a relational database. In this chapter, we will develop an application to maintain
    lists of books for multiple users.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数现实生活中的应用程序都包含多个实体，并且通常这些实体之间有很多关系。在数据库建模中，这些关系是强项之一。在本章中，我们将开发一个应用程序来维护多个用户的图书列表。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Design and implement a data model consisting of several entities and relations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现一个由多个实体和关系组成的数据模型
- en: Implement reusable entity and relation modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可重用的实体和关系模块
- en: Look in depth at the necessity of clearly separating layers of functionality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨清晰分离功能层的重要性
- en: And encounter jQuery UI's autocomplete widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且遇到 jQuery UI 的自动完成小部件
- en: So let's get started with it...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧...
- en: Designing a book database
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个图书数据库
- en: Before we start to design our application, let's have a good look at the different
    entities that need to be handled by it. The entities we recognize are a book,
    an author, and a user. A book may have many attributes, but here we limit ourselves
    to a title, an ISBN (International Standard Book Number), and a publisher. An
    author has just a name, but of course, if we would like to extend that with extra
    attributes, like the date of birth or nationality, we can always add that later.
    Finally, a user is an entity with a single attribute as well, the user ID.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计我们的应用程序之前，让我们先好好看看它需要处理的不同的实体。我们识别出的实体有书、作者和用户。一本书可能有多个属性，但在这里我们限制自己只包括标题、ISBN（国际标准书号）和出版社。作者只有一个名字，但当然，如果我们想用额外的属性来扩展它，比如出生日期或国籍，我们总是可以稍后添加。最后，用户是一个具有单个属性的实体，即用户ID。
- en: 'The next important part is to have a clear understanding of the relations between
    these entities. A book may be written by one or more authors, so we need to define
    a relation between a book entity and an author entity. Also, any number of users
    may own a copy of a book. This is another relation we have to define, this time,
    between a book entity and a user entity. The following diagram may help to see
    those entities and their relations more clearly:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的部分是要对这些实体之间的关系有一个清晰的理解。一本书可能由一位或多位作者撰写，因此我们需要在图书实体和作者实体之间定义一个关系。此外，任何数量的用户都可能拥有一本书的副本。这是我们不得不定义的另一个关系，这次是在图书实体和用户实体之间。以下图表可能有助于更清楚地看到这些实体及其关系：
- en: '![Designing a book database](img/3746OS_05_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![设计一个图书数据库](img/3746OS_05_01.jpg)'
- en: 'These three entities and the relations between them need to be represented
    in two realms: as database tables and as Python classes. Now we could model each
    entity and relation separately, like we did in the previous chapter for the `tasklist`
    application, but all entities share a lot of common functionality so there are
    ample opportunities for reuse. Reuse means less code and less code equals less
    maintenance and often better readability. So let''s see what we need to define
    a reusable `Entity` class.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个实体及其之间的关系需要在两个领域中进行表示：作为数据库表和作为 Python 类。现在我们可以像我们在上一章为 `tasklist` 应用程序所做的那样，分别对每个实体和关系进行建模，但所有实体都共享很多共同的功能，因此有大量的重用机会。重用意味着更少的代码，更少的代码等于更少的维护，并且通常有更好的可读性。那么，让我们看看我们需要定义一个可重用的
    `Entity` 类需要什么。
- en: The Entity class
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体类
- en: 'From what we learned in the previous chapters, we already know there is a shared
    body of functionality that each class that represents an entity needs to implement:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前章节中学到的知识，我们已经知道每个代表实体的类都需要实现一个共享的功能集：
- en: It needs to be able to verify that a corresponding table exists in the database
    and create one if it doesn't.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要能够验证数据库中是否存在相应的表，如果不存在则创建一个。
- en: It needs to implement a way to manage database connections in a thread-safe
    manner.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现一种以线程安全的方式管理数据库连接的方法。
- en: 'Also, each entity should present us with a **CRUD** interface:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个实体都应该提供一个 **CRUD** 接口：
- en: '*Create* new object instances'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建* 新的对象实例'
- en: '*Retrieve* individual object instances and find instances that match some criteria'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检索* 单个对象实例以及找到符合某些标准的实例'
- en: '*Update* the attributes of an object instance and synchronize this data to
    the database'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新* 对象实例的属性并将这些数据同步到数据库中'
- en: '*Delete* an object instance'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除* 对象实例'
- en: 'That is a lot of shared functionality, but of course a book and an author are
    not identical: They differ in the number and type of their attributes. Before
    we look at the implementation, let''s illustrate how we would like to use an `Entity`
    class to define a specific entity, for example, a car.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多共享功能，但当然一本书和作者并不相同：它们在属性的数量和类型上有所不同。在我们查看实现之前，让我们说明我们如何希望使用 `Entity` 类来定义一个特定的实体，例如一辆车。
- en: Time for action using the Entity class
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Entity` 类进行操作的时间
- en: Let us first define for ourselves how we want to use an `Entity` class, because
    the interface we create must match as closely as possible the things we would
    like to express in our code. The following example shows what we have in mind
    (available as `carexample.py):`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们希望如何使用 `Entity` 类，因为我们要创建的接口必须尽可能接近我们希望在代码中表达的东西。以下示例显示了我们的想法（作为 `carexample.py`
    提供）：`
- en: '**Chapter5/carexample.py**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/carexample.py**'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The idea is to create a `Car` class that is a subclass of `Entity`. We therefore
    have to take the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是创建一个 `Car` 类，它是 `Entity` 的子类。因此，我们必须采取以下步骤：
- en: Import the `Entity` class from the `entity` module.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `entity` 模块导入 `Entity` 类。
- en: Define the `Car` class. The body of this class is completely empty as we simply
    inherit all functionality from the `Entity` class. We could, of course, augment
    this with specific functionality, but in general, this shouldn't be necessary.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `Car` 类。这个类的主体完全为空，因为我们只是从 `Entity` 类继承所有功能。当然，我们可以添加特定的功能，但通常这不应该必要。
- en: Initialize a connection to the database. Before we can work with the `Car` instances,
    an application has to initialize a connection to the database for each thread.
    In this example, we do not create extra threads, so there is just the single main
    thread of the application that needs a connection to the database. We create one
    here with the `threadinit()` method (highlighted).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据库连接。在我们能够处理 `Car` 实例之前，应用程序必须为每个线程初始化数据库连接。在这个例子中，我们没有创建额外的线程，所以只有一个需要连接到数据库的应用程序的主线程。我们在这里使用
    `threadinit()` 方法（已突出显示）创建了一个连接。
- en: 'Make sure an appropriate table with the necessary columns exists in the database.
    Therefore, we call the `inittable()` method with arguments that specify the attributes
    of our entity with possibly extra information on how to define them as columns
    in a database table. Here we define three columns: `make, model`, and `licenseplate`.
    Remember that SQLite doesn''t need explicit typing, so `make` and `model` are
    passed as arguments with just an empty string as the value. The `licenseplate`
    attribute, however, is adorned with a `unique` constraint in this example.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保数据库中存在适当的表，并且具有必要的列。因此，我们使用 `inittable()` 方法，并使用指定我们的实体属性（可能包括如何将它们定义为数据库表中的列的额外信息）的参数调用它。我们在这里定义了三个列：`make,
    model` 和 `licenseplate`。记住，SQLite 不需要显式类型，所以 `make` 和 `model` 只传递了一个空字符串作为值的参数。然而，在这个例子中，`licenseplate`
    属性被添加了一个 `unique` 约束。
- en: Now we can work with `Car` instances, as illustrated in the lines that create
    two different objects or in the last few lines that retrieve the IDs of all `Car`
    records in the database and instantiate `Car` instances with those IDs to print
    the various attributes of a `Car`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理 `Car` 实例了，正如创建两个不同对象或检索数据库中所有 `Car` 记录的 ID 并使用这些 ID 实例化 `Car` 对象以打印
    `Car` 的各种属性的最后几行所示。
- en: That is the way we would like it to work. The next step is to implement this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望它工作的方式。下一步是实现这一点。
- en: What just happened?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The previous example showed how we could derive the `Car` class from `Entity`
    and use it. But what does that `Entity` class look like?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了我们如何从 `Entity` 派生出 `Car` 类并使用它。但 `Entity` 类是什么样子呢？
- en: The definition for the `Entity` class starts off with defining a class variable
    `threadlocal` and a class method `threadinit()` to initialize this variable with
    an object that holds data that is local to each thread (the full code is available
    as `entity.py)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity` 类的定义从定义一个类变量 `threadlocal` 和一个类方法 `threadinit()` 开始，用于使用一个包含每个线程本地数据（即
    `entity.py` 中的完整代码）的对象初始化这个变量。'
- en: If this `threadlocal` object does not yet have a `connection` attribute, a new
    connection to the database is created (highlighted) and we configure this connection
    by setting its `row_factory` attribute to `sqlite.Row`, as this will enable us
    to access columns in the results by name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`threadlocal`对象还没有`connection`属性，则会创建一个新的数据库连接（高亮显示），并且我们通过设置其`row_factory`属性为`sqlite.Row`来配置这个连接，因为这将使我们能够通过名称访问结果中的列。
- en: We also execute a single `pragma foreign_keys=1` statement to enable the enforcing
    of foreign keys. As we will see, when we discuss the implementation of relations,
    this is vital in maintaining a database without dangling references. This `pragma`
    must be set for each connection separately; therefore, we put it in the thread
    initialization method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还执行一个单独的`pragma foreign_keys=1`语句来启用外键的强制执行。正如我们将看到的，在讨论关系的实现时，这对于维护没有悬空引用的数据库至关重要。这个`pragma`必须为每个连接单独设置；因此，我们将其放在线程初始化方法中。
- en: '**Chapter5/entity.py**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/entity.py**'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next is the `inittable()` method. This should be called once to verify that
    the table necessary for this entity already exists or to define a table with suitable
    columns if it doesn't. It takes any number of keyword arguments. The names of
    the keywords correspond to the names of the columns and the value of such a keyword
    may be an empty string or a string with additional attributes for the column,
    for example, `unique` or an explicit type like `float`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`inittable()`方法。这个方法应该只调用一次，以验证为这个实体所需的表已经存在，或者如果不存在，则定义一个具有合适列的表。它接受任意数量的键值参数。键的名称对应于列的名称，这样的键的值可能是一个空字符串或带有额外属性（例如，`unique`或显式的类型如`float`）的字符串。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although SQLite allows you to store a value of any type in a column, you may
    still define a type. This type (or more accurately, **affinity)** is what SQLite
    tries to convert a value to when it is stored in a column. If it doesn't succeed,
    the value is stored as is. Defining a column as float, for example, may save a
    lot of space. More on these affinities can be found on [http://www.sqlite.org/datatype3.html](http://www.sqlite.org/datatype3.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite允许你在列中存储任何类型的值，但你仍然可以定义一个类型。这个类型（或者更准确地说，**亲和性**）是SQLite在存储到列中时尝试将值转换成的类型。如果它不成功，则值将按原样存储。例如，将列定义为`float`可能节省很多空间。更多关于这些亲和性的信息可以在[http://www.sqlite.org/datatype3.html](http://www.sqlite.org/datatype3.html)找到。
- en: '**Chapter5/entity.py**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/entity.py**'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The column definitions are stored in the `columns` class variable for later
    use by the `__init__()` method and joined together to a single string. This string,
    together with the name of the class (available in the `__name__` attribute of
    a (possibly derived) class) is then used to compose a SQL statement to create
    a table (highlighted).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列定义存储在`columns`类变量中，供`__init__()`方法稍后使用，并将它们连接成一个字符串。然后，这个字符串与类的名称（在（可能派生的）类的`__name__`属性中可用）一起用于组成创建表的SQL语句（高亮显示）。
- en: Besides the columns that we defined based on the keyword arguments, we can also
    create a primary key column that will be filled with a unique integer automatically.
    This way, we ensure that we can refer to each individual row in the table later
    on, for example, from a bridging table that defines a relation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于键值参数定义的列之外，我们还可以创建一个自动填充唯一整数的主键列。这样，我们确保以后可以引用表中的每一行，例如，从一个定义关系的桥接表中。
- en: 'When we take our previous car example, we see that a Python statement like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑之前的汽车示例时，我们看到一个Python语句如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Is converted to the following SQL statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下SQL语句：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the order in which we pass the keyword arguments to the `inittable()`
    method is not necessarily preserved as these arguments are stored in a `dict`
    object, and regular `dict` objects do not preserve the order of their keys.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递给`inittable()`方法的键值参数的顺序不一定被保留，因为这些参数被存储在一个`dict`对象中，而常规的`dict`对象不保留其键的顺序。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes preserving the order of the keys in a dictionary is very desirable.
    In this case, column order doesn't matter much, but Python does have an `OrderedDict`
    class available in its `collections` module (see [http://docs.python.org/library/collections.html#collections.OrderedDict)](http://docs.python.org/library/collections.html#collections.OrderedDict))
    that we could have used. However, this would prevent us from using keywords to
    define each column.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时保留字典中键的顺序是非常希望的。在这种情况下，列顺序并不重要，但Python在其 `collections` 模块中确实提供了一个 `OrderedDict`
    类（见 [http://docs.python.org/library/collections.html#collections.OrderedDict](http://docs.python.org/library/collections.html#collections.OrderedDict)），我们可以使用它。然而，这将阻止我们使用关键字来定义每个列。
- en: 'Also note that there isn''t any form of sanity checking implemented: anything
    may be passed as a value for one of the column definitions. Judging whether that
    is anything sensible is left to SQLite when we pass the SQL statement to the database
    engine with the `execute()` method.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，没有实现任何形式的合理性检查：任何东西都可以作为列定义中的一个值的参数传递。是否合理留给SQLite在通过 `execute()` 方法将SQL语句传递给数据库引擎时判断。
- en: This method will raise an `sqlite3.OperationalError` if there is a syntax error
    in the SQL statement. However, many issues are simply ignored. If we pass an argument
    like `licenseplate="foo`", it would happily proceed, assuming `foo` to be a type
    it doesn't recognize, so it is simply ignored! If the execution didn't raise an
    exception, we finish by committing our changes to the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法如果SQL语句中存在语法错误，将引发 `sqlite3.OperationalError`。然而，许多问题只是被忽略。如果我们传递一个像 `licenseplate="foo"`
    这样的参数，它将愉快地继续，假设 `foo` 是它不认识的一种类型，所以它被简单地忽略了！如果执行没有引发异常，我们最后将提交我们的更改到数据库。
- en: Have a go hero checking your input
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试检查你的输入
- en: Silently ignoring things passed as arguments is not considered a good habit.
    Without explicit checking, a developer might not even know he/she has done something
    wrong, something that might backfire later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对传递的参数静默忽略不是一个好习惯。没有明确的检查，开发者可能甚至不知道他/她做错了什么，这可能会在以后产生反效果。
- en: How would you implement code to restrict the value to a limited set of directives?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何实现代码来限制值到一个有限的指令集？
- en: 'Hint: Types and constraints in a SQL column definition mostly consist of single
    words. You could check each word against a list of allowable types, for example.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：SQL列定义中的类型和约束大多由单个单词组成。例如，你可以将每个单词与允许的类型列表进行核对。
- en: Time for action creating instances
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实例的时间
- en: 'The next method we look at is the constructor the `__init__()` method. It will
    be used to create individual instances of an entity. The constructor can be called
    in two ways:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的方法是构造函数 `__init__()` 方法。它将用于创建实体的单个实例。构造函数可以通过两种方式调用：
- en: With a single `id` argument, in which case, an existing record will be retrieved
    from the database and the instance initialized with the column values of this
    record, or
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个 `id` 参数，在这种情况下，将从数据库中检索现有记录，并用该记录的列值初始化实例，或者
- en: With a number of keyword arguments to create a new instance and save this as
    a new database record
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个关键字参数来创建一个新实例并将其保存为新的数据库记录
- en: 'The code to implement this behavior looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此行为的代码如下所示：
- en: '**Chapter5/entity.py**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/entity.py**'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code reflects this dual use. After checking that all keywords indeed refer
    to the previously defined columns (highlighted), it checks whether it was passed
    an `id` argument. If it was, there shouldn't be any other keyword arguments. If
    there are additional keywords, an exception is raised. If the `id` argument is
    present, an SQL statement is constructed next that will retrieve the records from
    the associated table. Each record's primary key should match the ID.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码反映了这种双重用途。在检查所有关键字确实指向先前定义的列（突出显示）之后，它检查是否传递了 `id` 参数。如果是，则不应有其他任何关键字参数。如果有额外的关键字，将引发异常。如果存在
    `id` 参数，接下来将构建一个SQL语句，该语句将从相关表中检索记录。每条记录的主键应与ID匹配。
- en: What just happened?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Because the primary key is unique, this will match at most a single record,
    something that is verified after we retrieve the matching records. If we didn't
    fetch exactly one (1) record, an exception is raised (highlighted).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为主键是唯一的，所以这最多匹配一条记录，这是在我们检索匹配的记录后验证的。如果我们没有获取到正好一条（1）记录，将引发异常（突出显示）。
- en: If everything went well, we initialize the attributes of the instance we are
    creating with the built-in `setattr()` function. The columns of the record we
    retrieved can be accessed by name because we initialized the `row_factory` attribute
    of the connection object to a `sqlite3.Row`. We also stored the names of the columns
    in the `columns` class variable and this lets us initialize the instance's attributes
    with the values of the corresponding column names (highlighted).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将使用内置的 `setattr()` 函数初始化我们正在创建的实例的属性。我们检索到的记录的列可以通过名称访问，因为我们已将连接对象的
    `row_factory` 属性初始化为 `sqlite3.Row`。我们还存储了列的名称在 `columns` 类变量中，这使得我们可以使用相应的列名称的值来初始化实例的属性（高亮显示）。
- en: 'Creating a `Car` instance with:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式创建一个 `Car` 实例：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Will result in a SQL statement like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致如下 SQL 语句：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Where the question mark is a placeholder for the actual value that is passed
    to the `execute()` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中问号是传递给 `execute()` 方法的实际值的占位符。
- en: 'The second branch of the code (starting at the `else` clause) is executed if
    no `id` argument was present. In this case, we separate the keyword names and
    values and set the attributes of the instance we are creating. The keyword names
    and values are then used to construct an SQL statement to insert a new row in
    the table associated with this `Entity` (highlighted). For example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供 `id` 参数，则执行代码的第二分支（从 `else` 子句开始）。在这种情况下，我们将分离关键字名称和值，并设置我们正在创建的实例的属性。然后，关键字名称和值用于构建一个
    SQL 语句，以在与此 `Entity` 相关的表中插入一行（高亮显示）。例如：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Will give us:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将给出：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The question marks are again placeholders for the values we pass to the `execute()`
    method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 问号再次是用于传递给 `execute()` 方法的值的占位符。
- en: If calling the `execute()` method (highlighted) went well, we initialize the
    `id` attribute of the instance we are creating with the value of the `lastrowid`
    attribute. Because we defined the primary key as a `primary key integer autoincrement`
    column and did not specify it in the insert statement, the primary key will hold
    a new unique integer and this integer is available as the `lastrowid` attribute.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 `execute()` 方法（高亮显示）顺利，我们将使用 `lastrowid` 属性的值初始化我们正在创建的实例的 `id` 属性。因为我们定义了主键为一个
    `primary key integer autoincrement` 列，并且在插入语句中没有指定它，所以主键将保留一个新唯一的整数，这个整数作为 `lastrowid`
    属性可用。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is very SQLite-specific and the primary key should be defined in exactly
    this way for this to hold true. More on this can be found at [http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常特定于 SQLite，并且主键应该以完全相同的方式定义，才能使这一点成立。更多关于此的信息可以在 [http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid)
    找到。
- en: Any `sqlite3.IntegrityError` that might be raised due to the violation of a
    uniqueness constraint is caught and re-raised as a `ValueError` with slightly
    more meaningful text.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能由于违反唯一性约束而引发的 `sqlite3.IntegrityError` 都会被捕获并重新引发为带有稍微更有意义文本的 `ValueError`。
- en: 'The `update()` method is used to synchronize an instance with the database.
    It can be used in two ways: we can alter any attributes of an instance first and
    then call `update()`, or we may pass keyword arguments to `update()` to let `update()`
    alter the corresponding attributes and synchronize the instance to the database.
    These two ways may even be combined. Either way, the database will hold the most
    current values of all attributes corresponding to a column once the `update()`
    returns. The following two pieces of code are therefore equivalent:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()` 方法用于同步实例与数据库。它可以有两种用法：我们首先可以更改实例的任何属性，然后调用 `update()`，或者我们可以传递关键字参数给
    `update()`，让 `update()` 更改相应的属性并将实例同步到数据库。这两种方式甚至可以结合使用。无论如何，一旦 `update()` 返回，数据库将保留所有对应于列的所有属性的当前值。因此，以下两段代码是等效的：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并且：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Any keyword arguments we pass to `update()` should match a column name, otherwise
    an exception is raised (highlighted).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `update()` 的任何关键字参数都应该匹配列名称，否则将引发异常（高亮显示）。
- en: '**Chapter5/entity.py**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/entity.py**'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The column names and the values of the corresponding attributes are then used
    to construct an SQL statement to update records with these values, but only for
    the single record whose primary key matches the ID of the instance we are updating.
    The SQL statement might look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列名称和相应的属性值随后用于构建一个 SQL 语句来更新具有这些值的记录，但仅限于与我们要更新的实例的 ID 匹配的单个记录。SQL 语句可能看起来像这样：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The question marks again are placeholders for the values we pass to the `execute()`
    method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用问号作为我们传递给 `execute()` 方法的值的占位符。
- en: After we execute this statement, we do a sanity check by validating that the
    number of affected records is indeed one. Just as for an insert statement, this
    number is available as the `rowcount` attribute of the cursor object after an
    update statement (highlighted).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此语句后，我们通过验证受影响的记录数确实是 1 来进行合理性检查。就像插入语句一样，这个数字在更新语句之后作为游标对象的 `rowcount` 属性可用（高亮显示）。
- en: 'Deleting an instance is implemented by the `delete()` method of the `Entity`
    class and consists primarily of composing an SQL statement that will delete the
    record with a primary key equal to the `id` attribute of the instance. The resulting
    SQL looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的删除是通过 `Entity` 类的 `delete()` 方法实现的，主要是由一个 SQL 语句组成，该语句将删除具有与实例的 `id` 属性相等的键的记录。生成的
    SQL 看起来像这样：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just like in the `update()` method, we end with a sanity check to verify that
    just a single record was affected (highlighted). Note that `delete()` will only
    remove the record in the database, not the Python instance it is called on. If
    nothing references this object instance, it will be automatically removed by the
    Python''s garbage collector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `update()` 方法中一样，我们以一个合理性检查结束，以验证仅影响了一条记录（高亮显示）。请注意，`delete()` 只会删除数据库中的记录，而不会删除调用它的
    Python 实例。如果没有其他东西引用此对象实例，它将被 Python 的垃圾回收器自动删除：
- en: '**Chapter5/entity.py**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/entity.py**'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final method we encounter is the class method `list()`. This method may
    be used to retrieve the IDs of all instances of an entity when called without
    arguments or to retrieve the IDs of instances that match certain criteria passed
    as arguments. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的最后一个方法是类方法 `list()`。当不带参数调用时，此方法可以用来检索实体的所有实例的 ID，或者检索与作为参数传递的某些标准匹配的实例的
    ID。例如：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Will return a list of IDs of all cars in the database, whereas:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回数据库中所有汽车的 ID 列表，而：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Will return the IDs of all the Volvos in the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回数据库中所有沃尔沃的 ID。
- en: '**Chapter5/entity.py**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/entity.py**'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementation is straightforward and starts off with creating an SQL statement
    to select all IDs from the table (highlighted). An example would be:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单，从创建一个选择表中选择所有 ID 的 SQL 语句开始（高亮显示）。一个例子将是：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If there were any keyword arguments passed to the `list()` method, these are
    then used to construct a `where` clause that will restrict the IDs returned to
    those of the records that match. This `where` clause is appended to our general
    select statement (highlighted). For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向 `list()` 方法传递了任何关键字参数，这些参数将用于构建一个 `where` 子句，该子句将限制返回的 ID 仅限于与记录匹配的 ID。这个
    `where` 子句被附加到我们的通用选择语句（高亮显示）。例如：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After invocation of the `execute()` method, we yield all the IDs. By using the
    `yield` statement, we have identified the `list()` method as a **generator** that
    will return the IDs found one-by-one rather than in one go. We still can manipulate
    this generator just like a list if we wish, but for very large result sets, a
    generator might be a better option as it does consume less memory, for example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `execute()` 方法之后，我们通过使用 `yield` 语句产生所有 ID。通过使用 `yield` 语句，我们已经将 `list()`
    方法标识为一个 **生成器**，它将逐个返回找到的 ID，而不是一次性返回。如果我们愿意，我们仍然可以像处理列表一样操作这个生成器，但对于非常大的结果集，生成器可能是一个更好的选择，因为它确实消耗更少的内存，例如。
- en: The Relation class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系类
- en: The `Relation` class is used to manage relations between individual instances
    of entities. If we have `Car` entities as well as `Owner` entities, we might like
    to define a `CarOwner` class that provides us with the functionality to identify
    the ownership of a certain car by a specific owner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Relation` 类用于管理实体各个实例之间的关系。如果我们有 `Car` 实体以及 `Owner` 实体，我们可能希望定义一个 `CarOwner`
    类，它为我们提供识别特定车主拥有的特定汽车的功能。'
- en: 'Like entities, generic relations share a lot of common functionality: we must
    be able to create a new relation between two entities, delete a relation, and
    list related entities given a primary entity, for example, list all owners of
    a given car or all cars of a certain owner.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与实体一样，通用关系共享许多共同的功能：我们必须能够创建两个实体之间的新关系，删除关系，以及根据主实体列出相关实体，例如列出特定汽车的或特定车主的所有汽车。
- en: Relations are stored in the database in a table, often called a **bridging table**,
    consisting of records with columns that store the IDs of both related entities.
    When an application starts using a (subclass of) the `Relation` class, we must
    verify that the corresponding table exists, and if not, create it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关系存储在数据库中的一个表中，通常称为**桥接表**，其中包含存储相关实体ID的列的记录。当应用程序开始使用（`Relation`类的子类）时，我们必须验证相应的表是否存在，如果不存在，则创建它。
- en: Time for action using the Relation class
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Relation`类进行操作的时间
- en: 'Let''s have a look at how we would like to use our `Relation` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用我们的`Relation`类：
- en: '**Chapter5/carexample2.py**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/carexample2.py**'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Like before, we first define a `Car` class and then an `Owner` class because
    the `CarOwner` class we define and initialize in the first highlighted lines are
    only meaningful if the entities in the relation exist. The highlighted lines show
    that defining and initializing a relation follows the same general pattern as
    initializing the entities.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，我们首先定义一个`Car`类，然后定义一个`Owner`类，因为我们定义并初始化的`CarOwner`类只有在关系中的实体存在时才有意义。高亮行显示，定义和初始化关系遵循与初始化实体相同的一般模式。
- en: We then create two `Car` entities and an `Owner` and establish a relation between
    these (second set of highlighted lines).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个`Car`实体和一个`Owner`实体，并在这两个实体之间建立了关系（第二组高亮行）。
- en: The final lines show how we can find and print the owners of a car or the cars
    belonging to an owner.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后几行显示了如何查找并打印一辆车的车主或车主拥有的车辆。
- en: Many of these requirements for the `Relation` class are similar to those of
    the `Entity` class, so when we take a look at the code, some pieces will look
    familiar.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多`Relation`类的要求与`Entity`类的要求相似，所以当我们查看代码时，一些部分看起来会很熟悉。
- en: What just happened?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first method we encounter is the `threadinit()` class method (the full code
    is available as `relation.py)`. It is identical to the one we encountered in the
    `Entity` class and should be called once for every thread.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一种方法是`threadinit()`类方法（完整代码可在`relation.py`中找到）。它与我们在`Entity`类中遇到的方法相同，并且应该为每个线程调用一次。
- en: '**Chapter5/relation.py**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `inittable()` class method is the method that should be called once when
    we start an application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`inittable()`类方法是我们在启动应用程序时应该调用一次的方法：'
- en: '**Chapter5/relation.py**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It takes the two classes involved in the relations as arguments to construct
    a proper SQL statement to create a bridging table if it does not exist yet (highlighted).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受参与关系的两个类作为参数，以构建一个适当的SQL语句来创建一个桥接表（如果尚不存在）（高亮显示）。
- en: 'For example, `CarOwner.inittable(Car,Owner)` will result in a statement like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`CarOwner.inittable(Car,Owner)`将产生如下语句：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are a couple of interesting things to note here. There are two columns
    each referring to a table by way of the `references` clause. Because we do not
    explicitly state *which* column we reference inside the table, the reference is
    made to the primary key. This is a convenient way to write this down and works
    because we always define a proper primary key for any table that represents an
    entity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个有趣的事情需要注意。这里有两列，每列都通过`references`子句引用一个表。因为我们没有在表中明确指出*哪一列*是我们引用的，所以引用是针对主键的。这是一种方便的记录方式，并且它之所以有效，是因为我们总是为任何表示实体的表定义一个合适的主键。
- en: Another thing to note is the `on delete cascade` clause. This helps us to maintain
    something called **referential integrity**. It ensures that when the record that
    is referenced is deleted, the records in the bridging table that refer to it are
    deleted as well. This way, there will never be entries in a table that represent
    a relation that points to non-existing entities. To ensure that this referential
    integrity checking is actually performed, it is necessary to execute a `pragma
    foreign_keys = 1` instruction for each connection to the database. This is taken
    care of in the `threadinit()` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是`on delete cascade`子句。这有助于我们维护所谓的**引用完整性**。它确保当被引用的记录被删除时，引用它的桥接表中的记录也会被删除。这样，就不会有指向不存在实体的关系的表中的条目。为了确保实际上执行了引用完整性检查，必须为每个数据库连接执行`pragma
    foreign_keys = 1`指令。这在`threadinit()`方法中得到了处理。
- en: Finally, there is a `unique` constraint over both the columns. This effectively
    ensures that we only maintain, at most, a single entry in this table for each
    relation between two entities. That is, if I own a car, I can enter this specific
    relation only once.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对这两个列有 `unique` 约束。这实际上确保了我们只为两个实体之间的每个关系在这个表中维护最多一个条目。也就是说，如果我拥有一辆车，我只能进入这个特定的关系一次。
- en: If the execution of this statement went well, `inittable()` finishes with storing
    the names of the entity classes that this relation refers to in the `columns`
    class variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此语句的执行顺利，`inittable()` 方法将存储在 `columns` 类变量中，该变量引用此关系所涉及的实体类名称。
- en: Pop quiz how to check a class
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答：如何检查一个类
- en: How can we make sure that the classes we are passing as arguments to the `initdb()`
    method are subclasses of `Entity?`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保传递给 `initdb()` 方法的类是 `Entity` 的子类？
- en: Relation instances
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系实例
- en: The `__init__()` method constructs an instance of a `Relation`, that is, we
    use it to record the relation between two specific entities.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法构建一个 `Relation` 实例，即我们使用它来记录两个特定实体之间的关系。'
- en: '**Chapter5/relation.py**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes the IDs of both `Entity` instances that are involved in this specific
    relation and a `stub` parameter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受涉及此特定关系的两个 `Entity` 实例的 ID 和一个 `stub` 参数。
- en: The `__init__()` method is not meant to be called directly as it doesn't know
    nor check whether the IDs passed to it make any sense. It simply stores those
    IDs if the `stub` parameter is true or inserts a record in the table if it isn't.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法不应该直接调用，因为它不知道也不检查传递给它的 ID 是否有意义。如果 `stub` 参数为真，它简单地存储这些 ID；如果不是，它就在表中插入一条记录。'
- en: Normally, we would use the `add()` method to create a new relationship with
    all necessary type checking. Separating this makes sense as all this checking
    is expensive and is unnecessary if we know that the IDs we pass are correct. The
    `list()` method of the `Relation` class for example retrieves only pairs of valid
    IDs so that we can use the `__init__()` method without the need for costly additional
    checks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用 `add()` 方法来创建一个新的关系，并进行所有必要的类型检查。将此分离是有意义的，因为所有这些检查都很昂贵，如果我们知道我们传递的
    ID 是正确的，则这些检查是不必要的。例如，`Relation` 类的 `list()` 方法仅检索有效的 ID 对，这样我们就可以使用 `__init__()`
    方法而无需进行昂贵的额外检查。
- en: 'The SQL statement that is constructed may look like this for a new `CarOwner`
    relation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 构造的 SQL 语句可能看起来像这样，对于一个新的 `CarOwner` 关系：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we would try to insert a second relation between the same entities, the `unique`
    constraint on both columns together would be violated. If so, the `insert or replace`
    clause would make sure that the insert statement wouldn't fail, but there still
    would be just one record with these two IDs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在这两个实体之间插入第二个关系，这两个列上的 `unique` 约束将违反。如果是这样，`insert or replace` 子句将确保插入语句不会失败，但仍然只有一个包含这两个
    ID 的记录。
- en: 'Note that the insert statement could fail for another reason. If either of
    the IDs we try to insert does not refer to an existing record in the table it
    refers to, it would fail with an exception `sqlite3.IntegrityError: foreign key
    constraint failed`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，插入语句可能会因为其他原因失败。如果我们尝试插入的任何一个 ID 都不指向它所引用的表中的现有记录，它将抛出异常 `sqlite3.IntegrityError:
    foreign key constraint failed`。'
- en: The final sanity check in the last line is to use the `rowcount` attribute to
    verify that just one record was inserted.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一行进行最终的健康检查，使用 `rowcount` 属性来验证只插入了一个记录。
- en: The `add()` method *does* make sure that the instances passed to it are in the
    correct order by checking the names of the classes against the names of the columns
    stored by the `inittable()` method. It raises a `ValueError()` if this is not
    correct, otherwise it instantiates a new relation by calling the class constructor
    with both IDs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()` 方法确实通过检查通过给它的实例的类名与由 `inittable()` 方法存储的列名是否匹配来确保这些实例的顺序正确。如果这不正确，它会抛出一个
    `ValueError()` 异常，否则它会通过调用类构造函数并传递两个 ID 来实例化一个新的关系。'
- en: '**Chapter5/relation.py**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `list()` method is meant to return a list of zero or more `Relation` objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()` 方法旨在返回零个或多个 `Relation` 对象的列表。'
- en: '**Chapter5/relation.py**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It needs to work for both sides of the relation: if we pass a `Car` instance,
    for example, to the `list()` method of the `CarOwner` class, we should find all
    records where the `Car_id` column matches the `id` attribute of the `Car` instance.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要适用于关系的两边：如果我们向 `CarOwner` 类的 `list()` 方法传递一个 `Car` 实例，例如，我们应该找到所有 `Car_id`
    列与 `Car` 实例的 `id` 属性匹配的记录。
- en: 'Likewise, if we pass an `Owner` instance, we should find all records where
    the `Owner_id` column matches the `id` attribute of the `Owner` instance. But
    precisely because we gave the columns in the table that represents the relation
    meaningful names derived from the names of the classes and hence the tables, this
    is rather straightforward. For example, the SQL constructed for `CarOwner.list(car)`
    might look like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们传递一个`Owner`实例，我们应该找到所有`Owner_id`列与`Owner`实例的`id`属性匹配的记录。但正因为我们在表示关系的表中给出了有意义的列名，这些列名是从类名派生出来的，所以这相当直接。例如，为`CarOwner.list(car)`构建的SQL可能如下所示：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Whereas the SQL for `CarOwner.list(owner)` would look like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 而SQL查询`CarOwner.list(owner)`可能看起来如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is accomplished by referring to the class name of the instance passed as
    argument (highlighted).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过引用作为参数传递的实例的类名（突出显示）来实现的。
- en: After executing this SQL statement, the results are fetched with the `fetchall()`
    method and returned as a list of relation instances. Note that this list may be
    of zero length if there weren't any matching relations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此SQL语句后，使用`fetchall()`方法检索结果，并将其作为关系实例的列表返回。请注意，如果没有任何匹配的关系，此列表可能为零长度。
- en: The last method of note defined for the `Relation` class is the `delete()` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Relation`类定义的最后一个值得注意的是`delete()`方法。
- en: '**Chapter5/relation.py**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/relation.py**'
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It constructs an SQL delete statement which, in our `CarOwner` example, may
    look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它构建了一个SQL删除语句，在我们的`CarOwner`示例中可能如下所示：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The sanity check we perform in the last line means that an exception is raised
    if the number of deleted records is not exactly one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句中我们执行的健全性检查意味着如果删除的记录数不是恰好一条，则会引发异常。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If there was not exactly one record deleted, what would that signify?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有恰好一条记录被删除，那会意味着什么？
- en: If it would be more than one, that would indicate a serious problem because
    all the constraints are there to prevent that there is never more than one record
    describing the same relationship, but if it would be zero, this would probably
    mean we try to delete the same relationship more than once.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多于一个，那将表明一个严重的问题，因为所有约束都是为了防止有超过一条记录描述相同的关系，但如果为零，这通常意味着我们试图删除相同的关系多次。
- en: 'You might wonder why there isn''t any method to update a `Relation` object
    in any way. The reason is that this hardly makes any sense: either there is a
    relation between two entity instances or there isn''t. If we would like to transfer
    ownership of a car, for example, it is just as simple to delete the relation between
    the car and the current owner and then add a new relation between the car and
    the new owner.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么没有方法可以以任何方式更新`Relation`对象。原因是这几乎没有任何意义：两个实体实例之间要么存在关系，要么不存在。例如，如果我们想转移一辆车的所有权，简单地删除车辆和当前车主之间的关系，然后添加车辆和新车主之间的关系就足够简单了。
- en: Now that we have a simple Entity and Relation framework, let's look at how we
    can use this to implement the foundation of our books application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个简单的实体和关系框架，让我们看看我们如何使用这个框架来实现我们图书应用程序的基础。
- en: Time for action defining the Books database
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义图书数据库的时间到了
- en: The next step is to create a module `booksdb.py` that uses the `entity` and
    `relation` modules to construct a data model that can be used conveniently by
    the delivery layer (the parts of the web application that deal with providing
    content to the client). We therefore have to define `Book, Author`, and `User`
    entities as well as a `BookAuthor` relation and a `UserBook` relation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为`booksdb.py`的模块，该模块使用`entity`和`relation`模块来构建一个数据模型，该模型可以方便地被交付层（处理向客户端提供内容的Web应用程序部分）使用。因此，我们必须定义`Book,
    Author`和`User`实体以及`BookAuthor`关系和`UserBook`关系。
- en: We will also provide some functions that are bit more high-level, for example,
    a `newbook()` function that checks whether a book with a given title already exists
    and that only creates a new `Book` instance if the authors are different (presumably
    because they wrote a book with the same title).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供一些更高级别的函数，例如，一个`newbook()`函数，该函数检查给定标题的书籍是否已经存在，并且只有当作者不同时（可能是因为他们写了同一标题的书籍）才创建新的`Book`实例。
- en: Having a separate layer that models data in terms that are meaningful in the
    context makes it easier to understand what is going on. It also keeps the delivery
    layer less cluttered and therefore easier to maintain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中以有意义的术语对数据进行建模的独立层使得理解正在发生的事情变得更容易。它还使交付层更加简洁，因此更容易维护。
- en: What just happened?
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'After importing the `Entity` and `Relation` class, the first thing we do is
    define the appropriate entities and relations (the full code is available as `booksdb.py)`.
    The first function we encounter is `threadinit()` (highlighted). It is a convenience
    function that calls all the individual `threadinit()` methods of the different
    entities and relations we have defined:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`Entity`和`Relation`类之后，我们首先定义适当的实体和关系（完整的代码作为`booksdb.py`提供）。我们遇到的第一个函数是`threadinit()`（高亮显示）。这是一个便利函数，它调用我们定义的不同实体和关系的所有单个`threadinit()`方法：
- en: '**Chapter5/booksdb.py**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksdb.py**'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Likewise, the `inittable()` function is a convenience function that calls all
    the necessary `inittable()` methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`inittable()`函数是一个便利函数，它调用所有必要的`inittable()`方法：
- en: '**Chapter5/booksdb.py**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksdb.py**'
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It defines a `Book` as a subclass of `Entity` having a `title`, a `unique isbn`,
    and a `publisher` attribute. An `Author` is defined as a subclass of `Entity`
    with just a `name` attribute and a `User` as an `Entity` with just a `userid`
    that must be unique and cannot be null. Also, the relations that exist between
    `Book` and `Author`, and `User` and `Book` are initialized here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`Book`定义为`Entity`的子类，具有`title`、唯一的`isbn`和`publisher`属性。`Author`被定义为具有仅`name`属性的`Entity`子类，而`User`作为具有唯一且不能为空的`userid`的`Entity`。此外，`Book`和`Author`以及`User`和`Book`之间存在的关联在这里被初始化。
- en: 'The `newbook()` function should be used to add a new book to the database:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用`newbook()`函数将新书添加到数据库中：
- en: '**Chapter5/booksdb.py**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksdb.py**'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It takes a `title` argument and a list of `Author` objects and any number of
    optional keywords to select a unique book if the title is not sufficient to identify
    a book. If a book with the given title and additional keywords cannot be found,
    a new `Book` object is created (highlighted). If more than one book is found that
    matches the criteria, an exception is raised.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个`title`参数和一个`Author`对象的列表以及任意数量的可选关键词来选择一本独特的书籍，如果标题不足以识别书籍的话。如果找不到具有给定标题和附加关键词的书籍，将创建一个新的`Book`对象（高亮显示）。如果找到多个符合标准的书籍，将引发异常。
- en: The next step is to retrieve a list of authors associated with this book. This
    list is used to check if any author in the list of authors passed to the `newbook()`
    function is not already associated with this book. If not, this new author is
    added. This ensures we do not attempt to associate an author more than once with
    the same book, but it also makes it possible to add authors to the list of authors
    associated with an existing book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检索与这本书相关的作者列表。此列表用于检查传递给`newbook()`函数的作者列表中是否有任何作者尚未与这本书关联。如果没有，则添加这个新作者。这确保我们不会尝试将作者与同一本书关联多次，同时也使得向现有书籍的作者列表中添加作者成为可能。
- en: 'The `newauthor()` function verifies that the name passed as an argument is
    not empty and is indeed a string (highlighted):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`newauthor()`函数验证传递给参数的名字不为空，并且确实是一个字符串（高亮显示）：'
- en: '**Chapter5/booksdb.py**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksdb.py**'
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then it checks whether an author with such a name already exists. If it doesn't,
    a new `Author` object is created and returned. If only one `Author` was found,
    that one is returned without creating a new one. If the same name matched more
    than one `Author`, an exception is raised because our current data model does
    not provide the notion of more than one author with the same name.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它检查是否已存在具有该名称的作者。如果没有，则创建一个新的`Author`对象并返回。如果只找到一个`Author`，则返回该`Author`而不创建新的。如果相同的名称匹配多个`Author`，则引发异常，因为我们的当前数据模型不提供具有相同名称的多个作者的概念。
- en: An application to register books is most often used to see if we already own
    a book. A function to list books matching a set of criteria should therefore be
    quite flexible to provide the end user with enough functionality to make finding
    books as simple as possible, even if the books number is in the thousands.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注册书籍的应用程序通常用于查看我们是否已经拥有这本书。因此，列出符合一组标准书籍的功能应该相当灵活，以便为最终用户提供足够的功能，使查找书籍尽可能简单，即使书籍数量达到数千本。
- en: The `listbooks()` function tries to encapsulate the necessary functionality.
    It takes a number of keyword arguments used to match any number of books. If the
    `user` argument is present, the results returned are limited to those books that
    are owned by that user. Likewise, the `author` argument limits the results to
    books by that author. The `pattern` argument may be a string that limits the books
    returned to those whose title contains the text in the `pattern` argument.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`listbooks()`函数试图封装必要的功能。它接受多个关键字参数，用于匹配任意数量的书籍。如果存在`user`参数，返回的结果将限制为该用户拥有的书籍。同样，`author`参数将结果限制为该作者所写的书籍。`pattern`参数可能是一个字符串，它将返回的书籍限制为标题包含`pattern`参数中文本的书籍。'
- en: 'Because the number of books matching the criteria could be very large, `listbooks()`
    takes two additional parameters to return a smaller subset. This way, the delivery
    layer can offer the list of results in a page-by-page manner. The `offset` argument
    determines the start of the subset and `limit` of the number of results returned.
    If `limit` is `-1`, all results starting at the given `offset` are returned. For
    example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于匹配的书籍数量可能非常大，`listbooks()`函数接受两个额外的参数以返回较小的子集。这样，交付层可以分页提供结果列表。`offset`参数确定子集的起始位置和返回结果的数量。如果`limit`为`-1`，则返回从给定`offset`开始的全部结果。例如：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Would return the first three books I own that have the text blind in their title.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回我拥有的标题中包含“盲”文字的前三本书。
- en: 'Given these requirements, the implementation of `listbooks()` is rather straightforward:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些要求，`listbooks()`的实现相当直接：
- en: '**Chapter5/booksdb.py**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksdb.py**'
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It starts by checking that any `user` argument is indeed an instance of a `User`
    entity and then finds all books owned by this user (highlighted) and converts
    this list to a **set**. It checks any `author` argument in a similar way. If neither
    an author nor a user was specified, we simply retrieve a list of all books (highlighted)
    and convert it to a set as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查任何`user`参数确实是一个`User`实体的实例，然后找到该用户拥有的所有书籍（突出显示）并将此列表转换为**集合**。以类似的方式检查任何`author`参数。如果没有指定作者或用户，我们只需检索所有书籍的列表（突出显示）并将其转换为集合即可。
- en: Working with sets is convenient, as sets will never contain duplicates and can
    easily be manipulated. For example, if we have a non-empty set of books associated
    with an author and a non-empty set of books owned by a user, we can obtain the
    **intersection** (that is, books both owned by the given owner and written by
    the given author) with the`&` operator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合非常方便，因为集合永远不会包含重复项，并且可以轻松地进行操作。例如，如果我们有一个与作者关联的非空书籍集合以及一个用户拥有的非空书籍集合，我们可以使用`&`运算符获取它们的**交集**（即既被给定所有者拥有又被给定作者所写）。
- en: Either way, we end up with a list of book IDs in `lb`. This list of IDs is then
    converted to `Book` objects and sorted on the title to ensure consistent results
    when dealing with offsets (highlighted). The next step is to reduce the number
    of results to those books whose title contains the text in the `pattern` argument.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们最终都会得到一个包含书籍ID的`lb`列表。然后，将这个ID列表转换为`Book`对象，并按标题排序，以确保在处理偏移量时结果的一致性（突出显示）。下一步是减少结果数量，只保留标题中包含`pattern`参数中文本的书籍。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All this matching, sorting, and filtering could have been done with SQL as well
    and probably in a more efficient manner too. However, this would mean the SQL
    would be rather complicated and we would ruin the clear distinction between the
    low-level database operations defined in the `entity` and `relation` modules and
    the more high-level operations defined here in `booksdb`. If efficiency was more
    important, that would be a valid argument, but here we choose for a clear separation
    to aid understanding, as Python is a lot easier to read than SQL.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些匹配、排序和过滤也可以使用SQL完成，并且可能更加高效。然而，这意味着SQL将相当复杂，我们将会破坏`entity`和`relation`模块中定义的低级数据库操作与在这里`booksdb`中定义的更高级操作的清晰区分。如果效率更重要，那将是一个合理的论点，但在这里我们选择清晰的分离以帮助理解，因为Python比SQL更容易阅读。
- en: All that is left now is to return the proper slice from the list of books based
    on the `offset` and `limit` arguments, as shown in the last line of the `listbooks()`
    function. Note that we actually return a tuple, the first item being the total
    number of matching books, the second item the actual list of matching books. This
    makes it simple to present information to the end user like 'showing items 20-29
    of 311'.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是根据`offset`和`limit`参数从书籍列表中返回适当的切片，如`listbooks()`函数的最后一行所示。请注意，我们实际上返回一个元组，第一个元素是匹配书籍的总数，第二个元素是实际的匹配书籍列表。这使得向最终用户展示信息变得简单，例如“显示第20-29项，共311项”。
- en: 'The `listauthors()` function either returns a list of authors associated with
    a book if a `book` argument is given or a list of all authors:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`listauthors()`函数要么在给定`book`参数的情况下返回与书籍关联的作者列表，要么返回所有作者列表：'
- en: '**Chapter5/booksdb.py**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksdb.py**'
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It does make sure that any `book` argument is indeed an instance of a `Book`
    entity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实确保任何`book`参数确实是一个`Book`实体的实例。
- en: '`checkuser()` may be called to see if there already exists a user with the
    given username and if not creates one:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用`checkuser()`来查看是否已经存在具有给定用户名的用户，如果不存在，则创建一个：
- en: '**Chapter5/booksdb.py**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksdb.py**'
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Any user that uses this application should have a corresponding `User` entity,
    if he/she wants to be able to register his/her ownership of a book. This function
    makes sure this is possible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用此应用程序的用户都应该有一个相应的`User`实体，如果他/她想要能够注册他/她的书籍所有权。此函数确保这是可能的。
- en: Note that our application does not *authenticate* a user at this level, that
    is left to the delivery layer as we will see. Any authentication database the
    delivery layer uses is completely separate from the `User` entity in our books
    database. The delivery layer may, for example, use the system password database
    to authenticate a user and pass the username to this layer if the authentication
    was successful. If, at that point, the user does not yet exist in our books database,
    we can make sure he does by calling the `checkuser()` function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的应用程序在此级别不*认证*用户，这留给传输层，正如我们将看到的。传输层使用的任何认证数据库都与我们的书籍数据库中的`User`实体完全分开。例如，传输层可以使用系统密码数据库来认证用户，并在认证成功后将用户名传递给此层。如果在此点，用户尚未存在于我们的书籍数据库中，我们可以通过调用`checkuser()`函数来确保他/她存在。
- en: The `addowner()` and `delowner()` functions are used to establish or remove
    a specific ownership relation between a book and a user. Both are thin wrappers
    around the underlying methods in the `Relation` class, but add some additional
    type checking.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`addowner()`和`delowner()`函数用于建立或删除书籍与用户之间的特定所有权关系。这两个函数都是`Relation`类中底层方法的薄包装，但添加了一些额外的类型检查。'
- en: '**Chapter5/booksdb.py**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksdb.py**'
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This foundation will be put to good use in the next section where we will implement
    the delivery layer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用这个基础来实现传输层。
- en: Pop quiz how to select a limited number of books
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验：如何选择有限数量的书籍
- en: How would you select the third page of 10 books from a list of all books in
    the database?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何从数据库中所有书籍的列表中选择第三页的10本书？
- en: Have a go hero cleaning up the books database
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄般地清理书籍数据库
- en: '`booksdb.py` lacks a `delbooks()` function because we won''t be providing this
    functionality in our final application. It is not a disadvantage to just remove
    ownership and leave the book as is, even if it doesn''t have any owners because
    other users may register ownership by referring to this existing book without
    the need to enter it again. However, occasionally we might want to clean up the
    database. How would you implement a function that removes all books without an
    owner?'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`booksdb.py`缺少`delbooks()`函数，因为我们不会在我们的最终应用程序中提供此功能。仅仅删除所有权并保留书籍原样，即使它没有任何所有者，也不是一个缺点，因为其他用户可以通过引用此现有书籍来注册所有权，而无需再次输入。然而，偶尔我们可能想要清理数据库。你将如何实现一个删除所有无所有者书籍的函数？'
- en: The delivery layer
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层
- en: 'Because we laid a substantial foundation with the `entity, relation`, and `booksdb`
    modules, we can now cleanly separate the delivery layer from the rest of the application.
    The delivery layer consists of just a couple of CherryPy applications. To authenticate
    a user, we will reuse the logon application we encountered in previous chapters
    and the rest of the application consists of a single `Books` class with the necessary
    methods to provide two main screens: a navigable and filterable list of books
    and a screen to add new books to the database.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`entity, relation`和`booksdb`模块上建立了坚实的基础，我们现在可以干净地将交付层与应用程序的其余部分分离。交付层仅由几个CherryPy应用程序组成。为了验证用户身份，我们将重用我们在前几章中遇到的登录应用程序，而应用程序的其余部分则由一个包含提供两个主要屏幕所需方法的`Books`类组成：一个可导航和可过滤的书籍列表和一个用于向数据库添加新书籍的屏幕。
- en: Time for action designing the delivery layer
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计交付层的时间
- en: To design these screens it is often convenient to make some drawings to have
    a visual representation of the screen. This makes it a lot easier to discuss functionality
    with your client.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计这些屏幕，通常方便的做法是绘制一些草图，以便有一个屏幕的视觉表示。这使得与客户讨论功能变得容易得多。
- en: 'There exist a number of good applications to assist you with drawing up some
    mock ups (for example, Microsoft''s Expression Blend or Kaxaml [http://kaxaml.com/)](http://kaxaml.com/))
    but often, especially in the early stages of designing an application, a simple
    drawing will do, even if it''s hand drawn. The illustrations show the sketches
    I used in making a rough draft, both done with the GIMP (http://www.gimp.org/):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的应用程序可以帮助你绘制一些原型（例如，微软的Expression Blend或Kaxaml [http://kaxaml.com/](http://kaxaml.com)），但通常，尤其是在设计应用程序的早期阶段，简单的草图就足够了，即使它是手绘的。插图显示了我在制作草图时使用的草图，两者都是用GIMP（http://www.gimp.org/）完成的：
- en: '![Time for action designing the delivery layer](img/3746_05_002.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![设计交付层的时间](img/3746_05_002.jpg)'
- en: The first image is a sketch of the screen that lets the user interact with a
    list of books, the second image shows what a screen to add a new book could look
    like.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图是用户可以与之交互的书籍列表屏幕草图，第二张图显示了添加新书籍的屏幕可能的样子。
- en: '![Time for action designing the delivery layer](img/3746_05_003.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![设计交付层的时间](img/3746_05_003.jpg)'
- en: Such images are easy to print and annotate during a discussion without the need
    for a computer application, all you need is a pen or pencil. Another useful designing
    technique is to draw some outline on a whiteboard and add details while you discuss
    functionality. At the end of the session, you can take a picture of the whiteboard
    with your cell phone and use that as a starting point. The design will likely
    change anyway during the development and starting with this simple approach saves
    a lot of effort that might have to be undone later on.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的图像很容易在讨论期间打印和标注，而不需要计算机应用程序，你只需要一支笔或铅笔。另一种有用的设计技术是在白板上绘制一些轮廓，并在讨论功能时添加细节。在会议结束时，你可以用你的手机拍下白板的照片，并将其作为起点。设计很可能会在开发过程中发生变化，而从这个简单的起点开始可以节省大量的努力，这些努力可能需要在以后撤销。
- en: 'When we take a look at the design for the screen that lists the books we see
    immediately that the key functionality is all in the **button bar**. Notably,
    we will have to implement functionality to:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看列出书籍的屏幕设计时，我们立即看到关键功能都在**按钮栏**中。值得注意的是，我们将不得不实现以下功能：
- en: Show a list of books
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示书籍列表
- en: Page forward and backward through this list
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此列表中向前和向后翻页
- en: Limit the list of books to those owned by the current user
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将书籍列表限制为当前用户拥有的书籍
- en: Filter the list of books on words occurring in the title
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据标题中出现的单词过滤书籍列表
- en: 'The screen to add a new book is deceptively simple. The user must be able to
    enter a title and an author to indicate he owns a book, but this means that in
    the background, we have at least the following scenarios to check:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新书籍的屏幕设计看似简单。用户必须能够输入标题和作者以表明他拥有这本书，但这意味着在后台，我们至少有以下场景需要检查：
- en: There is no book in the database with the given title
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库中没有具有给定标题的书籍
- en: There is a book with the given title but without the given author
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在具有给定标题但没有给定作者的书籍
- en: The combination of book and author is known
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知书籍和作者的组合
- en: In the first situation, we have to create a new `Book` entity, and possibly
    a new `Author` entity if the author is unknown.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们必须创建一个新的`Book`实体，如果作者未知，还可能创建一个新的`Author`实体。
- en: In the second situation, we will create a new `Book` entity as well, because
    it is very well possible that different authors write books with the same title.
    In a more elaborate application, we might be able to make a distinction based
    on the ISBN.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们还将创建一个新的`Book`实体，因为不同的作者可能以相同的标题写书。在一个更复杂的应用中，我们可能能够根据ISBN进行区分。
- en: In the last situation, we do not have to create a new `Book` or an `Author`
    entity, but we still have to make sure that we register ownership of that specific
    book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，我们不需要创建新的`Book`或`Author`实体，但我们仍然需要确保我们注册了那本特定书籍的所有权。
- en: The final requirement is one of convenience to the user. If there are many users
    entering books in the database, chances will grow that if someone registers a
    new book he/she owns, that book is already present in the database. To save the
    user some typing, it would be nice if we could present the user with a list of
    possible titles and authors while he/she types along. This is called auto completion
    and is fairly straightforward to implement with a combination of jQuery UI and
    Python.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最终要求是使用户感到方便。如果有很多用户在数据库中录入书籍，那么有人注册他/她拥有的新书时，这本书可能已经在数据库中。为了节省用户输入，如果我们能在用户输入时显示可能的标题和作者列表，那就很好了。这被称为自动完成，结合jQuery
    UI和Python实现起来相当直接。
- en: '![Time for action designing the delivery layer](img/3746_05_004.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![设计交付层的时间](img/3746_05_004.jpg)'
- en: When `booksweb.py` is started, the list of books will look like the preceding
    image and the page to add a new book is shown next. We will enhance these looks
    in the last section of this chapter, but we focus on the implementation of the
    delivery layer in `booksweb.py` first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当`booksweb.py`启动时，书籍列表将看起来像前面的图像，接下来显示添加新书的页面。我们将在本章的最后部分增强这些外观，但首先我们关注`booksweb.py`中交付层的实现。
- en: '![Time for action designing the delivery layer](img/3746_05_005.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![设计交付层的时间](img/3746_05_005.jpg)'
- en: 'Auto completion is a close companion of client-side input validation. By presenting
    the user with a list of possibilities to choose from, we lower the risk of a user
    entering a similar title with a slightly different spelling. Of course there are
    some additional checks to make: a title may not be empty, for example. If the
    user does make an erroneous entry, there should also be some sort of feedback
    so he/she can correct his mistake.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成是客户端输入验证的紧密伴侣。通过向用户提供一个选择列表，我们降低了用户输入类似标题但拼写略有不同的情况的风险。当然，还有一些额外的检查要做：例如，标题可能不能为空。如果用户确实输入了错误，也应该有一些反馈，以便他/她可以纠正错误。
- en: Of course, client-side validation is a useful tool to enhance the user experience,
    but it doesn't protect us from malicious attempts to corrupt our data. Therefore,
    we have implemented some server-side checks as well.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，客户端验证是一个有用的工具，可以增强用户体验，但它不能保护我们免受恶意尝试破坏我们数据的风险。因此，我们还实施了一些服务器端检查。
- en: What just happened?
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We start off by creating a global variable that holds the basic HTML that we
    will use both in the booklist screen as well as in the add book screen (the full
    code is available as `booksweb.py):`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个全局变量，它包含我们将同时在书单屏幕和添加书籍屏幕中使用的HTML（完整的代码作为`booksweb.py`提供）：
- en: '**Chapter5/booksweb.py**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.py**'
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We read it in from a separate file instead of storing it inside the module as
    a string. Storing the HTML in a separate file makes it a lot easier to edit because
    the editor can use syntax highlighting for HTML instead of just marking it as
    a string literal in Python. The file is available as `basepage.html:`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是从一个单独的文件中读取它，而不是将其作为字符串存储在模块内部。将HTML存储在单独的文件中使得编辑变得容易得多，因为编辑器可以使用语法高亮显示HTML，而不是仅仅将其标记为Python中的字符串字面量。该文件作为`basepage.html`提供：
- en: '**Chapter5/basepage.html**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/basepage.html**'
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This time, we choose to incorporate all external libraries from Google's content
    delivery network (highlighted).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们选择将所有外部库从Google的内容交付网络（突出显示）中整合进来。
- en: You might not want to depend on an external agency for your production application,
    but for development, this is an advantage as you don't have to lug around those
    files. But even in a production environment, this choice may make sense as this
    option will reduce the number of requests made to your server and minimize the
    bandwidth. Likewise, we refer to the cascading style sheets and accompanying files
    for our chosen theme (Smoothness) on Google's content delivery network.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想在生产应用程序中依赖外部机构，但在开发过程中，这确实是一个优势，因为你不必携带这些文件。即使在生产环境中，这个选择也可能是有意义的，因为这个选项将减少对服务器的请求次数并最小化带宽。同样，我们引用了
    Google 的内容交付网络（CDN）上我们选择的主题（Smoothness）的相关样式表和文件。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Besides Google, a number of other large players offer a Content Delivery Network
    (CDN) that you may use. Even Microsoft (http://www.asp.net/ajaxlibrary/cdn.ashx)
    offers free access to the jQuery and jQuery UI libraries on its CDN.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Google 之外，许多其他大型玩家也提供内容交付网络（CDN），你可以使用。即使是 Microsoft（http://www.asp.net/ajaxlibrary/cdn.ashx）也在其
    CDN 上提供对 jQuery 和 jQuery UI 库的免费访问。
- en: The head section also contains a link to an additional style sheet `books.css`
    that will be used to tweak the layout and style of the elements that are not jQuery
    UI widgets.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 头部部分还包含一个指向附加样式表 `books.css` 的链接，该样式表将用于调整不是 jQuery UI 小部件的元素布局和样式。
- en: The body is a single`<div>` element with a `%s` placeholder to be filled with
    different relevant markup for the booklist and new book pages, followed by a`<script>`
    tag that will provide other script elements within the specific pages with common
    functionality.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是一个单独的 `<div>` 元素，其中包含一个 `%s` 占位符，用于填充不同相关标记以用于书单和新书页面，之后是一个 `<script>` 标签，它将为特定页面内的其他脚本元素提供常用功能。
- en: '`booksweb.py` continues with the definition of the `Books` class that will
    act as the central application in the CherryPy framework for this application.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`booksweb.py` 继续定义 `Books` 类，该类将作为 CherryPy 框架中此应用程序的中心应用。'
- en: '**Chapter5/booksweb.py**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.py**'
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `index()` function serves `basepage.html` with a single`<div>` element that
    will hold the content.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()` 函数使用单个 `<div>` 元素提供 `basepage.html`，该元素将包含内容。'
- en: The `list()` method will be called from JavaScript functions defined in `booksweb.js`
    once it loads and will be used to fill the content`<div>` initially, as well as
    refresh the contents of this div when the buttons in the navigation button bar
    are pressed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()` 方法将在 `booksweb.js` 中定义的 JavaScript 函数加载后调用，并用于最初填充内容 `<div>`，以及当导航按钮栏中的按钮被按下时刷新此
    div 的内容。'
- en: Before we examine the `list()` and `addbook()` methods, let's have a look at
    the JavaScript in `booksweb.js` to see how these methods are invoked from the
    AJAX calls in the client (the full JavaScript code is available as `booksweb.js)`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查 `list()` 和 `addbook()` 方法之前，让我们看看 `booksweb.js` 中的 JavaScript，以了解这些方法是如何从客户端的
    AJAX 调用中调用的（完整的 JavaScript 代码作为 `booksweb.js` 提供）。
- en: '**Chapter5/booksweb.js**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.js**'
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first activity we encounter in `booksweb.js` is setting global defaults
    for all AJAX calls. We disable caching to make sure the browser executes an AJAX
    call every time we ask it to, without checking if it made a call to the same URL
    earlier, because otherwise we would not actually refresh the content of our list
    of books.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `booksweb.js` 中遇到的第一项活动是为所有 AJAX 调用设置全局默认值。我们禁用缓存以确保浏览器每次我们请求它时都执行 AJAX 调用，而不会检查它是否之前已经对同一
    URL 执行了调用，否则我们实际上不会刷新我们书单的内容。
- en: For debugging purposes, we also make sure every AJAX call uses the HTTP `GET`
    method because arguments to a `POST` call are not logged normally while arguments
    to a `GET` are part of the URL of the request.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，我们还确保每个 AJAX 调用都使用 HTTP `GET` 方法，因为在 `POST` 调用中，参数通常不会被记录，而在 `GET` 调用中，参数是请求
    URL 的一部分。
- en: 'The `prepnavbar()` function we encounter next is our workhorse: every time
    we make the URL `/books/list` get a list of books, `prepnavbar()` is called once
    the request is completed.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来遇到的 `prepnavbar()` 函数是我们的工作马：每次我们通过 URL `/books/list` 获取书籍列表时，一旦请求完成，就会调用
    `prepnavbar()` 一次。
- en: '**Chapter5/booksweb.js**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.js**'
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The HTML returned by `/books/list` not only contains the matching books, but
    also the navigation buttons themselves together with additional information on
    the number of matching books returned. These navigation buttons are not yet styled
    and configuring this is the task of the `prepnavbar()` function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`/books/list` 返回的 HTML 不仅包含匹配的书籍，还包括导航按钮本身以及返回的匹配书籍数量的附加信息。这些导航按钮尚未进行样式设置，配置此任务由
    `prepnavbar()` 函数完成。'
- en: It styles each button (except for the input button that is used to filter on
    text) as a jQuery UI button widget without text but with an appropriate icon.
    It also adds the `oddline` class to each odd row of the `bookrow` class, so we
    can refer to this class in our style sheet to give it distinctive zebra stripes,
    for example.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它将每个按钮（除了用于按文本过滤的输入按钮）样式化为一个没有文本但有适当图标的 jQuery UI 按钮小部件。它还向 `bookrow` 类的每个奇数行添加
    `oddline` 类，这样我们就可以在我们的样式表中引用这个类，例如，给它添加独特的斑马条纹。
- en: When `booksweb.js` is executed, the content of the page consists of an empty`<div>`.
    This`<div>` element is filled with HTML returned by calling the `/books/list`
    URL with parameters (last line). The `prepnavbar()` function is passed as the
    second argument to the `load()` method and will be called once loading the data
    is completed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `booksweb.js` 执行时，页面的内容由一个空的 `<div>` 组成。这个 `<div>` 元素被调用 `/books/list` URL
    并带有参数（最后一行）返回的 HTML 填充。`prepnavbar()` 函数作为 `load()` 方法的第二个参数传递，并在数据加载完成后被调用。
- en: The remaining part of `booksweb.js` is filled with adding live click handlers
    to all navigation buttons.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`booksweb.js` 的剩余部分充满了为所有导航按钮添加实时点击处理器的代码。'
- en: '**Chapter5/booksweb.js**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.js**'
- en: '[PRE47]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A live handler will be attached to any element that matches its selector, even
    elements that are not present yet in the documents. This will ensure that when
    we reload the list of books complete with new navigation buttons, the click handlers
    we define here will be bound to these new buttons as well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配其选择器的元素都将附加一个实时处理程序，即使这些元素在文档中尚未存在。这将确保当我们重新加载包含新导航按钮的书籍列表时，我们在这里定义的点击处理程序也将绑定到这些新按钮上。
- en: Each of these handlers call the `getparams()` function to retrieve the information
    contained in the`<p>` element with the `id="info`". This data is returned as a
    JavaScript object that may be passed to the `load()` method. The `load()` method
    will append the attributes in this object as parameters to the URL it calls. The
    information in the object reflects the currently listed books and each handler
    modifies this data according to its function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些处理程序中的每一个都会调用 `getparams()` 函数来检索包含 `id="info"` 的 `<p>` 元素中的信息。这些数据作为 JavaScript
    对象返回，可以传递给 `load()` 方法。`load()` 方法将在此对象中附加的属性作为参数附加到它调用的 URL 上。对象中的信息反映了当前列出的书籍，每个处理程序都会根据其功能修改这些数据。
- en: For example, the handler for the `#firstpage` button (highlighted) modifies
    the `offset` attribute. It simply sets it to zero before calling `/books/load`
    to retrieve the first set of books.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`#firstpage` 按钮的处理程序（高亮显示）修改了 `offset` 属性。它在调用 `/books/load` 以检索第一组书籍之前，将其简单地设置为零。
- en: The handler for the `#previouspage` button subtracts the value of the `limit`
    attribute from offset to get the previous page full of books, but makes sure that
    the offset is not smaller than zero. The handlers for the other clickable buttons
    perform similar actions before calling `/books/load`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`#previouspage` 按钮的处理程序从偏移量中减去 `limit` 属性的值以获取包含书籍的前一页，但确保偏移量不小于零。其他可点击按钮的处理程序在调用
    `/books/load` 之前执行类似操作。'
- en: The exception is the handler for the `#mine` button, that does not manipulate
    offsets but toggles the `checked` attribute.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例外的是 `#mine` 按钮的处理程序，它不操作偏移量，而是切换 `checked` 属性。
- en: The `#pattern` input element is different as well. It doesn't act on a click,
    but reacts on pressing the *return* key. If that key is pressed, it also calls
    `getparams()` just like the other handlers. The object retrieved this way will
    also contain a `pattern` attribute, which holds the value of the `#pattern` input
    element that was just entered by the user. The `offset` attribute is set to zero
    to ensure that when we pass on a new pattern value, we start viewing the resulting
    list at the start.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pattern` 输入元素也有所不同。它不对点击做出反应，而是在按下 *回车* 键时做出反应。如果按下该键，它也会像其他处理程序一样调用 `getparams()`。以这种方式检索到的对象也将包含一个
    `pattern` 属性，该属性包含用户刚刚输入的 `#pattern` 输入元素的值。将 `offset` 属性设置为零以确保当我们传递新的模式值时，我们从列表的开始处查看结果列表。'
- en: Let's return to the server-side in `booksweb.py` and see how the `list()` method
    is implemented.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `booksweb.py` 的服务器端，看看 `list()` 方法是如何实现的。
- en: '**Chapter5/booksweb.py**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5章/booksweb.py**'
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `list()` method takes a number of keyword arguments to determine which
    books to return. It doesn''t return a complete HTML page but just a list of`<div>`
    elements representing the selection of books together with some additional information
    on the number of books selected and the button elements used to browse through
    the list:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`方法接受多个关键字参数以确定要返回哪些书籍。它不会返回一个完整的HTML页面，而只是返回一个代表书籍选择的`<div>`元素列表，以及一些关于所选书籍数量和用于浏览列表的按钮元素的一些附加信息：'
- en: The `offset` argument determines where the list of matching books will start.
    Counting starts at 0.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`参数确定匹配书籍列表的起始位置。计数从0开始。'
- en: The `limit` argument determines the number of matching books to return. This
    is a maximum, less books will be returned if they are not available. When we have
    14 matching books, an offset of 10, with a limit of 10, will return 10 books through
    13.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`参数确定要返回的匹配书籍数量。这是一个最大值，如果没有足够的书籍，将返回更少的书籍。当我们有14本匹配的书籍时，偏移量为10，限制为10，将返回从13到10的10本书。'
- en: If the `mine` argument is non-zero, the list of matching books is limited to
    the ones owned by the user issuing the request.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`mine`参数非零，匹配的书籍列表将限制为请求用户拥有的书籍。
- en: if the `pattern` argument is not an empty string, the list of matching books
    is limited to the ones that contain the pattern string in their title.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`pattern`参数不是一个空字符串，匹配的书籍列表将限制为包含该模式字符串的标题的书籍。
- en: The `_` (underscore) argument is ignored. We configured our AJAX calls not to
    be cached (in `booksweb.js)` and jQuery prevents caching by appending each time
    an `_` argument with a random value to the URL it requests. The URL will look
    different each time to the browser this way, and this will prevent caching.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`（下划线）参数被忽略。我们在`booksweb.js`中配置了我们的AJAX调用不要缓存，jQuery通过在请求的URL中每次附加一个具有随机值的`_`参数来防止缓存。这样，浏览器每次看到的URL都会不同，这将防止缓存。'
- en: The implementation of the `list()` method starts off by validating that the
    user is logged in and then retrieving the corresponding `User` object. The next
    steps systematically validate the arguments passed to the method and raise a `ValueError`
    or `TypeError` if something fails to validate. The `offset` argument, for example,
    should be larger or equal to zero (highlighted).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`方法的实现首先验证用户是否已登录，然后检索相应的`User`对象。接下来的步骤系统地验证传递给方法的方法参数，并在验证失败时引发`ValueError`或`TypeError`。例如，`offset`参数应该大于或等于零（突出显示）。'
- en: Once the arguments are validated, these are handed off to the `booksdb.listbooks()`
    function, that will take care of the actual selection and will return a tuple
    consisting of the number of matching books and the actual list of books sorted
    on their title.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦参数得到验证，这些参数就会被传递给`booksdb.listbooks()`函数，该函数将负责实际的筛选并将返回一个元组，包含匹配的书籍数量和按标题排序的实际书籍列表。
- en: This list of books is used to step through and generate the appropriate HTML
    markup. For each book, we fetch the authors of the book (highlighted) and then
    yield a string with HTML markup. This HTML contains the title of the book and
    the name of the first author. If there is more information we would like to present,
    for example, the ISBN of the book, we could easily add it here. By using `yield`
    to return the results one-by one, we save ourselves the trouble of constructing
    a complete string first before returning it in one go.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个书籍列表用于遍历并生成适当的HTML标记。对于每一本书，我们获取书籍的作者（突出显示），然后生成一个包含HTML标记的字符串。这个HTML包含书籍的标题和第一作者的名字。如果我们还想展示更多信息，例如书籍的ISBN，我们很容易在这里添加。通过使用`yield`逐个返回结果，我们避免了在返回之前先构建一个完整的字符串的麻烦。
- en: The final `yield` statement contains a`<div>` element with the `id="navigation`".
    We choose to return the complete navigation markup, including buttons, to enable
    us to easily set the values of these buttons. The pattern`<input>` element, for
    example, should display the current text we filter on. We could pass this as separate
    information and use client-side JavaScript to set these values but this would
    complicate the JavaScript quite a bit.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`yield`语句包含一个具有`id="navigation"`的`<div>`元素。我们选择返回完整的导航标记，包括按钮，以便我们能够轻松设置这些按钮的值。例如，`<input>`模式元素应该显示我们当前过滤的文本。我们可以将其作为单独的信息传递，并使用客户端JavaScript来设置这些值，但这会使JavaScript变得相当复杂。
- en: 'Still, the `offset` and `limit` values together with the total number of matching
    books is returned inside a`<p>` element. This serves two goals: we can display
    this as an informational message to the user, but it is also necessary information
    for the navigation buttons to function.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`offset`和`limit`值以及匹配的书籍总数都返回在`<p>`元素内。这服务于两个目的：我们可以将其显示为用户的信息消息，但它也是导航按钮正常工作的必要信息。
- en: Time for action adding a new book
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新书的时间到了
- en: 'The screen to add a new book to the database is a simple form. What we need
    to implement is:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将新书添加到数据库的屏幕是一个简单的表单。我们需要实现的是：
- en: Some HTML to make it possible to display the form
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些HTML，使其能够显示表单
- en: A method in our CherryPy application that will produce this HTML
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们CherryPy应用程序中的一个方法，将生成此HTML
- en: A method to process the input once this form is submitted
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此表单提交后处理输入的方法
- en: There is no need to implement two different methods here because based on the
    arguments passed to the method we can decide whether to return a form or to process
    the submitted contents of the same form. Although it may be considered bad form
    to design a method to do two things, it does keep related functionality together.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不需要实现两种不同的方法，因为基于传递给方法的参数，我们可以决定是返回表单还是处理同一表单的提交内容。虽然设计一个执行两项任务的方法可能被认为是不好的做法，但它确实将相关的功能放在一起。
- en: What just happened?
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The `addbookform` class variable contains the template that refers to a number
    of string variables to interpolate. There is also a`<script>` element to add some
    extra functionality that we examine later:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`addbookform`类变量包含一个模板，该模板引用了多个字符串变量以进行插值。还有一个`<script>`元素，用于添加一些额外的功能，我们稍后将其检查：'
- en: '**Chapter5/booksweb.py**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/booksweb.py**'
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `addbook()` method itself is used both to display the initial screen and
    to process the results, that is, it acts as the target of the`<form>` element's
    action attribute and processes the values from the various`<input>` and`<button>`
    elements.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`addbook()` 方法本身既用于显示初始屏幕，也用于处理结果，即它作为`<form>`元素的动作属性的靶标，并处理来自各种`<input>`和`<button>`元素的值。'
- en: 'All arguments are therefore keyword arguments with default values. If they
    are all missing, `addbook()` will construct an empty form, otherwise it will check
    and process the information. In the latter case, there will be two possible scenarios:
    the values are ok, in which case a new book will be added and the user will be
    returned to the page with the book listing, or one or more of the values are not
    ok, in which case, the form is presented again, with suitable error markings,
    but with the entered values still in place for the user to edit.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有参数都是具有默认值的键值参数。如果它们全部缺失，`addbook()` 将构建一个空表单，否则它将检查并处理信息。在后一种情况下，将有两种可能的场景：值是正确的，在这种情况下，将添加新书，并将用户返回到包含书籍列表的页面，或者一个或多个值不正确，在这种情况下，将再次呈现表单，带有适当的错误标记，但用户输入的值仍然保留以供编辑。
- en: '**Chapter5/booksweb.py**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/booksweb.py**'
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `addbook()` method first verifies if the user is logged in, and if so, fetches
    the corresponding `User` object. The next step is to check if the cancel button
    contained in the form was clicked, in which case the `cancel` argument will contain
    a value and the user will be redirected to the list of books (highlighted).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`addbook()` 方法首先验证用户是否已登录，如果是，则获取相应的`User`对象。下一步是检查表单中包含的取消按钮是否被点击，如果是，则`cancel`参数将包含一个值，并将用户重定向到书籍列表（突出显示）。'
- en: Next, we create a default dictionary that will return an empty string for every
    missing key that is accessed. This default dictionary will be used as interpolation
    data for strings in `addbookform`. This way we can set a number of interpolation
    variables if we want to (for example, `%(title)s` in the `value` attribute of
    the`<input>` element for a title), but if we leave anything out, it will be automatically
    replaced by an empty string.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个默认字典，它将为每个访问的缺失键返回一个空字符串。这个默认字典将被用作`addbookform`中字符串的插值数据。这样，如果我们想设置多个插值变量（例如，`<input>`元素的`value`属性中的`%(title)s`），但如果我们省略了任何内容，它将被自动替换为空字符串。
- en: If the `submit` argument is equal to None, this means it wasn't present, so
    `addbook()` was called to display just the empty form and that is just what is
    done (highlighted). Because `data` contains no keys at all at this moment, *all*
    interpolation variables will yield an empty string resulting in an empty form.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`submit`参数等于None，这意味着它不存在，因此调用`addbook()`来显示空表单，这正是所做之事（高亮显示）。因为此时`data`中没有任何键，所以所有插入变量都将产生空字符串，从而得到一个空表单。
- en: If the `submit` argument was not None, we are processing the values in the form.
    First we perform a sanity check. If either the `title` or the `author` argument
    is missing, we raise an exception (highlighted). Even if the user failed to enter
    either of them, the corresponding values would be present in the arguments but
    as empty strings. So, if either of these arguments is missing completely, this
    cannot be the result of a user action and therefore it is sensible to raise an
    exception.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`submit`参数不为None，我们正在处理表单中的值。首先我们进行合理性检查。如果`title`或`author`参数中任何一个缺失，我们抛出一个异常（高亮显示）。即使用户未能输入其中任何一个，相应的值也会出现在参数中，但作为空字符串。所以，如果这些参数中任何一个完全缺失，这不能是用户操作的结果，因此抛出异常是有意义的。
- en: If both arguments are present, we save them in the default dictionary so that
    we can redisplay them as default values in the form, if we need to present the
    form again.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个参数都存在，我们将它们保存在默认字典中，这样我们就可以在需要再次显示表单时，将其作为默认值显示。
- en: The next step is to try the `newauthor()` function from the `booksdb` module.
    It either returns a valid `Author` object (because we already know the author
    or a new one was created) or it raises an exception. Such an exception is caught
    and the error text is added to the `authorerror` key in the dictionary together
    with some HTML class attributes that will enable us to display the corresponding`<input>`
    element in a suitable manner to indicate the error condition.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是尝试从`booksdb`模块中的`newauthor()`函数。它要么返回一个有效的`Author`对象（因为我们已经知道作者或者创建了一个新的作者）或者抛出一个异常。这样的异常会被捕获，并将错误文本添加到字典中的`authorerror`键，以及一些HTML类属性，这将使我们能够以适当的方式显示相应的`<input>`元素，以指示错误状态。
- en: Once we have a valid `Author` object, the same approach is used to retrieve
    a valid `Book` object. This may fail (mainly if the `title` argument is an empty
    string) in which case we set the `titleerror` key in the dictionary.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个有效的`Author`对象，我们将使用相同的方法来检索一个有效的`Book`对象。这可能会失败（主要如果`title`参数是空字符串），在这种情况下，我们将`titleerror`键设置在字典中。
- en: We end with establishing an ownership relation between the user and the book
    with a call to the `addowner()` function and then redirect the user to the page
    that lists the books.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`addowner()`函数在用户和书籍之间建立所有权关系，然后将用户重定向到列出书籍的页面。
- en: If anything goes wrong, we catch some exception and we end up at the return
    statement which will return the form again, only this time the dictionary will
    hold some keys that will be interpolated, resulting in suitable default values
    (for example, if a `title` argument was empty, but the `author` argument wasn't,
    the user doesn't have to enter the name of the author again) and information on
    the errors encountered.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，我们会捕获一些异常，最终回到返回语句，这将再次返回表单，但这次字典将包含一些将被插入的键，从而产生合适的默认值（例如，如果`title`参数为空，但`author`参数不为空，用户不必再次输入作者的姓名）以及遇到的错误信息。
- en: 'All this string interpolation business might be a bit daunting, so let''s have
    a brief look at an example. The definition for the title`<input>` element in the
    `addbookform` variable looks like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些字符串插入可能有点令人畏惧，所以让我们简要地看一下一个例子。`addbookform`变量中标题`<input>`元素的定义如下：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we want to present the user with an empty form, the string is interpolated
    with a default dictionary that holds no keys. The references `%(title)s` and `%(titlerror)s`
    will therefore come up with empty strings resulting in:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向用户显示一个空表单，字符串将与一个不包含任何键的默认字典进行插入。因此，引用`%(title)s`和`%(titlerror)s`将产生空字符串，结果如下：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A plain`<input>` element without a default value.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不带默认值的普通`<input>`元素。
- en: 'Now if something went wrong with locating or creating an author, the dictionary
    would hold a `title` key but no `titleerror` key (but it would have an `authorrerror`
    key). Assuming that the title entered by the user was "A book title", the resulting
    interpolation would therefore look like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果定位或创建作者出现问题，字典将包含`title`键但没有`titleerror`键（但会有`authorerror`键）。假设用户输入的书名是“一本书名”，那么最终的插值将看起来像这样：
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, if there was an error with the title, for example, because no book
    title was entered by the user, both the `title` key would be present (albeit,
    in this case, as an empty string) and the `titleerror` key. The value of the `titleerror`
    key holds both the error message as an HTML `title` attribute together with an
    HTML `class` attribute that looks like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果标题出现了错误，例如，因为用户没有输入书名，`title`键将存在（尽管在这种情况下，是一个空字符串）以及`titleerror`键。`titleerror`键的值包含错误消息作为HTML的`title`属性，以及一个看起来像这样的HTML`class`属性：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So the final interpolation would result in:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的插值结果将是：
- en: '[PRE55]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Auto completion
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动完成
- en: When we presented the HTML markup for the page that shows a form to add a new
    book, we skipped over the`<script>` element at the end. That script element is
    used to augment the title and author`<input>` elements with **auto completion**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示了显示添加新书表单的页面的HTML标记时，我们跳过了末尾的`<script>`元素。这个脚本元素用于通过**自动完成**增强标题和作者`<input>`元素。
- en: Time for action using input fields with auto completion
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有自动完成的输入字段执行操作的时间
- en: 'With the`<script>` element in place, the input elements can now retrieve possible
    completions with an AJAX call. Now, when we enter a few characters in an input
    field, we are presented with a list of choices, as shown in the image:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了`<script>`元素之后，输入元素现在可以通过AJAX调用检索可能的完成项。现在，当我们在一个输入字段中输入一些字符时，我们会看到一个选择列表，如图像所示：
- en: '![Time for action using input fields with auto completion](img/3746_05_006.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![使用具有自动完成的输入字段执行操作的时间](img/3746_05_006.jpg)'
- en: Let's look in some detail at how this is implemented in, remarkably, a few lines
    of JavaScript.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这是如何在JavaScript中实现的，令人惊讶的是，只有几行代码。
- en: What just happened?
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'If we look at the code again, we see that we call the `autocomplete()` method
    on both the `#title` and `#author <input>` elements, but each with a different
    source argument. The **autocomplete widget** in jQuery UI is very versatile and
    simple to apply (The code shown is part of `booksweb.py`, but we skipped this
    earlier):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看代码，我们会看到我们在`#title`和`#author <input>`元素上都调用了`autocomplete()`方法，但每个都有不同的源参数。jQuery
    UI中的**自动完成小部件**非常灵活且易于应用（显示的代码是`booksweb.py`的一部分，但我们之前跳过了这部分）：
- en: '**Chapter5/booksweb.py**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksweb.py**'
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `source` attribute of the options object we pass to the `autocomplete()`
    method holds a URL that will be used to retrieve a list of possible completions
    for the characters entered so far.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`autocomplete()`方法的选项对象的`source`属性包含一个URL，该URL将用于检索已输入字符的可能完成项列表。
- en: The `minLength` attribute ensures that we only start looking for possible completions
    once the user has entered at least two characters, otherwise the list would probably
    be enormous and not much of a help. Note that it is still possible to enter a
    completely new value into an input field. The user is not obliged to pick an item
    from the list presented and can keep on typing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`minLength`属性确保只有在用户输入至少两个字符后，我们才开始寻找可能的完成项，否则列表可能会非常大，而且帮助不大。请注意，仍然可以在输入字段中输入一个全新的值。用户没有义务从显示的列表中选择一个项目，并且可以继续输入。'
- en: The autocomplete widget adds the text entered so far as the `term` argument
    to the `source` URL. When the user has typed 'foo' in the `#author <input>` element,
    this will result in a call to a URL like `/books/getauthors?term=foo&_=12345678`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件将已输入的文本作为`term`参数添加到`source` URL中。当用户在`#author <input>`元素中输入`foo`时，这将导致对类似`/books/getauthors?term=foo&_=12345678`的URL的调用。
- en: 'This means that the `gettitles()` and `getauthors()` methods will both take
    a `term` argument (and an `_` (underscore) argument to ensure nothing is cached):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`gettitles()`和`getauthors()`方法都将接受一个`term`参数（以及一个`_`（下划线）参数以确保没有缓存）：
- en: '**Chapter5/booksweb.py**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**第五章/booksweb.py**'
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Both methods simply pass on the request to the corresponding `booksdb` functions,
    but because autocomplete widgets expect the result as a JSON encoded string, we
    convert the list with the `json.dumps()` function before returning it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法只是将请求传递给相应的 `booksdb` 函数，但由于自动完成小部件期望结果为 JSON 编码的字符串，我们在返回之前使用 `json.dumps()`
    函数将列表转换为字符串：
- en: '**Chapter5/booksdb.py**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/booksdb.py**'
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The functions `getauthors()` and `gettitles()` in `booksdb.py` could have simply
    retrieved a list of `Author` or `Book` objects respectively and extracted the
    `name` or `title` attributes. This would have been fairly slow, however, as creating
    potentially a lot of objects is costly in terms of processing power. Moreover,
    since we are really interested in just a list of strings and not in whole objects,
    it is worthwhile to implement a `getcolumnvalues()` method in the `Entity` class:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`booksdb.py` 中的 `getauthors()` 和 `gettitles()` 函数可以简单地检索 `Author` 或 `Book`
    对象的列表，并提取 `name` 或 `title` 属性。然而，这样做相当慢，因为创建大量对象在处理能力方面成本很高。此外，因为我们真正感兴趣的是字符串列表而不是整个对象，所以在
    `Entity` 类中实现一个 `getcolumnvalues()` 方法是值得的：'
- en: '**Chapter5/entity.py**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/entity.py**'
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`getcolumnvalues()` first checks if the requested column exists in this `Entity`
    (sub)class and raises an exception if it doesn''t. Then it constructs a SQL statement
    to return the values in the requested column, sorted without regard for case (highlighted).
    The result is a list of tuples consisting of a single item and this is converted
    to a simple list of items before returning it.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`getcolumnvalues()` 首先检查请求的列是否存在于这个 `Entity`（子）类中，如果不存在则抛出异常。然后它构建一个 SQL 语句来返回请求列中的值，排序时不考虑大小写（高亮显示）。结果是包含单个元素的元组列表，在返回之前将其转换为简单的项目列表。'
- en: The presentation layer
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示层
- en: Now that we have implemented the delivery layer, the application is almost usable,
    but looks a bit rough on the edges. Although some components already look quite
    good due to the styling inherent in the jQuery UI widgets used, other parts need
    some serious tweaking.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了传输层，应用程序几乎可以使用，但边缘看起来有点粗糙。尽管由于使用了 jQuery UI 小部件内置的样式，一些组件看起来相当不错，但其他部分需要一些重大的调整。
- en: Time for action using an enhanced presentation layer
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用增强的展示层进行操作的时间
- en: 'The additional JavaScript code and CSS information is part of `booksweb.js`
    and `booksweb.css` respectively. The following illustrations show the end results
    for the page with the list of books and the page to add a new book:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 JavaScript 代码和 CSS 信息分别包含在 `booksweb.js` 和 `booksweb.css` 中。以下插图显示了书籍列表页面和添加新书籍页面的最终结果：
- en: '![Time for action using an enhanced presentation layer](img/3746_05_007.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![使用增强的展示层进行操作的时间](img/3746_05_007.jpg)'
- en: We added some zebra stripes to aid readability and changed the look of the column
    headings.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些斑马条纹以帮助可读性，并更改了列标题的外观。
- en: '![Time for action using an enhanced presentation layer](img/3746_05_008.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![使用增强的展示层进行操作的时间](img/3746_05_008.jpg)'
- en: The page to add a book had its buttons styled in the same style as the buttons
    on the page with the list of books. Also, the layout was cleaned up and functionality
    was added to present any errors returned in a clearly visible way (in the last
    example, the title is empty so the background is red).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 添加书籍的页面使用了与书籍列表页面上的按钮相同的样式。同时，布局得到了清理，并添加了功能以清晰可见的方式呈现任何返回的错误（在最后一个示例中，标题为空，因此背景为红色）。
- en: '![Time for action using an enhanced presentation layer](img/3746_05_009.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![使用增强的展示层进行操作的时间](img/3746_05_009.jpg)'
- en: What just happened?
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: To effect the changes seen in the previous images, we added the following lines
    of JavaScript to `booksweb.js:`
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前图中看到的变化，我们在 `booksweb.js` 中添加了以下几行 JavaScript：
- en: '**Chapter5/booksweb.js**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter5/booksweb.js**'
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The effect is just to alter the appearance of the buttons, not to add to their
    functionality with some sort of event handler because there is no need for this.
    The page contains a regular`<form>` element with a valid `action` attribute, so
    our submit and cancel buttons will behave as expected.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果仅仅是改变按钮的外观，而不是通过某种事件处理器添加功能，因为不需要这样做。页面包含一个带有有效 `action` 属性的常规 `<form>`
    元素，因此我们的提交和取消按钮将按预期工作。
- en: The rest of the changes, including borders, fonts, and colors are implemented
    in `booksweb.css`, which we do not examine here as the CSS contained in it is
    very straightforward.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的更改，包括边框、字体和颜色，都在 `booksweb.css` 中实现，这里我们不对其进行检查，因为其中包含的 CSS 非常简单。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned a lot in this chapter about designing and implementing a web
    application around a data model consisting of several entities and relations.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于围绕由多个实体和关系组成的数据模型设计和实现Web应用学到了很多。
- en: 'Specifically, we covered:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to design the data model
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计数据模型
- en: How to create a reusable entity and relation framework
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建可重用的实体和关系框架
- en: How to maintain a clear separation between database, object layer, and delivery
    layer
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在数据库、对象层和交付层之间保持清晰的分离
- en: How to implement auto completion using jQuery UI's autocomplete widget
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用jQuery UI的自动完成小部件实现自动完成
- en: We also discussed the importance of input validation, both client-side and server-side.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了输入验证的重要性，包括客户端和服务器端。
- en: We did not yet wield the full power of our entity and relation framework and
    input validation might be much more involved. To exercise our new skills and expand
    them, the next chapter will be about designing and building a wiki application.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未充分发挥我们的实体和关系框架以及输入验证的潜力，输入验证可能涉及更多。为了锻炼我们的新技能并扩展它们，下一章将介绍设计和构建一个维基应用。
