- en: '*Chapter 10*: Concurrent Image Processing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：并发图像处理'
- en: This chapter discusses the task of processing and manipulating images via concurrent
    programming, specifically multiprocessing. Since images are processed independently
    of one another, concurrent programming is an attractive option for achieving a
    significant speedup. This chapter lays out the basics behind image processing
    techniques, illustrates the improvements that concurrent programming provides,
    and goes over some of the best practices that are used in image processing applications.
    This discussion will consolidate our knowledge of how to leverage concurrent and
    parallel processing tools in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了通过并发编程处理和操作图像的任务，特别是多进程。由于图像是独立处理的，因此并发编程是实现显著加速的有吸引力的选择。本章概述了图像处理技术背后的基础知识，说明了并发编程提供的改进，并概述了一些在图像处理应用中使用的一些最佳实践。这次讨论将巩固我们如何利用Python中的并发和并行处理工具的知识。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Image processing fundamentals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理基础
- en: Applying concurrency to image processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将并发应用于图像处理
- en: Good concurrent image processing practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的并发图像处理实践
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的先决条件列表：
- en: You must have Python 3 installed on your computer.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须在您的计算机上安装Python 3。
- en: You must have OpenCV and NumPy installed for your Python 3 distribution.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须为您的Python 3发行版安装OpenCV和NumPy。
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter10).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter10)。
- en: Image processing fundamentals
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理基础
- en: '**Digital/computational image processing** (which we will refer to as **image
    processing** from this point forward) has become so popular in the modern era
    that it exists in numerous aspects of our everyday life. Image processing and
    manipulation are involved when you take a picture with your camera or phone using
    different filters, such as when advanced image editing software such as Adobe
    Photoshop is used, or even when you simply edit images using Microsoft Paint.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字/计算图像处理**（从现在起我们将称之为**图像处理**）在现代社会变得如此流行，以至于它存在于我们日常生活的许多方面。当您使用相机或手机拍摄照片并使用不同的滤镜时，就会涉及到图像处理和操作，例如使用高级图像编辑软件如Adobe
    Photoshop，或者简单地使用Microsoft Paint编辑图像。'
- en: Many of the techniques and algorithms that are used in image processing were
    developed in the early 1960s for various purposes such as medical imaging, satellite
    image analysis, character recognition, and so on. However, these image processing
    techniques required significant computing power, and the fact that the available
    computer equipment at the time was unable to accommodate the need for fast number-crunching
    slowed down the use of image processing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在图像处理中使用的技术和算法是在20世纪60年代初为各种目的开发的，如医学成像、卫星图像分析、字符识别等。然而，这些图像处理技术需要大量的计算能力，而当时可用的计算机设备无法满足快速数值计算的需求，这减缓了图像处理的使用。
- en: Fast-forwarding to the future, when powerful computers with fast, multicore
    processors were developed, image processing techniques became much more accessible,
    and research on image processing increased significantly. Nowadays, numerous image
    processing applications are being actively developed and studied, including pattern
    recognition, classification, feature extraction, and more. Some of the specific
    image processing techniques that take advantage of concurrent and parallel programming,
    and would otherwise be extremely computationally time-consuming, include **Hidden
    Markov models**, **independent component analysis**, and even **neural network
    models**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到未来，当强大的计算机和快速的多核处理器被开发出来时，图像处理技术变得更加容易获取，并且对图像处理的研究显著增加。如今，许多图像处理应用正在积极开发和研究中，包括模式识别、分类、特征提取等。一些利用并发和并行编程的特定图像处理技术，否则将极其耗时，包括**隐马尔可夫模型**、**独立成分分析**，甚至**神经网络模型**。
- en: 'The following is one of the simplest forms of image processing, where we convert
    a fully colored image into a grayscale one. This process is called **grayscaling**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最简单的图像处理形式之一，我们将全彩图像转换为灰度图像。这个过程被称为 **灰度化**：
- en: '![Figure 10.1 – An example use of image processing – grayscaling ](img/B17499_Figure_10.1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 图像处理的一个示例应用 – 灰度化](img/B17499_Figure_10.1.jpg)'
- en: Figure 10.1 – An example use of image processing – grayscaling
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 图像处理的一个示例应用 – 灰度化
- en: Later in this chapter, we will see how grayscaling, along with other processing
    techniques, can be done using Python. To do this, we must install the necessary
    libraries and packages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何使用 Python 来实现灰度化以及其他处理技术。为此，我们必须安装必要的库和包。
- en: Python as an image processing tool
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 作为图像处理工具
- en: As we have stated multiple times throughout this book, the Python programming
    language is on its way to becoming the most popular programming language. This
    is especially true in the field of computational image processing, which, most
    of the time, requires fast prototyping and designing, as well as significant automation
    capabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的多个地方所提到的，Python 编程语言正在成为最受欢迎的编程语言。这在计算图像处理领域尤其如此，因为大多数时候，它需要快速原型设计和设计，以及显著的自动化能力。
- en: As we will find out in the following section, digital images are represented
    in two-dimensional and three-dimensional matrices so that computers can process
    them easily. Consequently, most of the time, digital image processing involves
    matrix calculation. Multiple Python libraries and modules not only provide efficient
    matrix calculation options but also interact seamlessly with other libraries that
    handle image reading/writing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解到数字图像是以二维和三维矩阵的形式表示的，这样计算机可以轻松处理它们。因此，大多数情况下，数字图像处理涉及矩阵计算。多个 Python
    库和模块不仅提供了高效的矩阵计算选项，而且与其他处理图像读取/写入的库无缝交互。
- en: 'As we already know, automating tasks and making them concurrent is Python''s
    strong suit. This makes Python the prime candidate to implement your image processing
    applications. For this chapter, we will be working with two main Python libraries:
    **OpenCV** (which stands for **Open Source Computer Vision**), which is a library
    that provides image processing and computer vision options in C++, Java, and Python,
    and NumPy, which, as we know, is one of the most popular Python modules and performs
    efficient and parallelizable number-crunching calculations. Let''s see how we
    can install these libraries.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知道的，自动化任务和使它们并发是 Python 的强项。这使得 Python 成为实施图像处理应用的理想选择。对于本章，我们将使用两个主要的
    Python 库：**OpenCV**（代表 **开源计算机视觉**），这是一个提供 C++、Java 和 Python 中图像处理和计算机视觉选项的库，以及
    NumPy，正如我们所知，它是最受欢迎的 Python 模块之一，执行高效且可并行化的数值计算。让我们看看我们如何安装这些库。
- en: Installing OpenCV and NumPy
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 OpenCV 和 NumPy
- en: 'To install NumPy for your Python distribution using the `pip` package manager,
    run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `pip` 软件包管理器为你的 Python 发行版安装 NumPy，请运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using Anaconda/Miniconda to manage your packages, you must run the
    following command instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Anaconda/Miniconda 来管理你的包，你必须运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Installing OpenCV might be more complicated, depending on your operating system.
    The easiest option is to have Anaconda handle the installation process by following
    the guide at [https://anaconda.org/conda-forge/opencv](https://anaconda.org/conda-forge/opencv)
    after installing Anaconda ([https://www.anaconda.com/download/](https://www.anaconda.com/download/))
    as your main Python package manager. If, however, you are not using Anaconda,
    the main option for installing OpenCV is to follow its official documentation
    guide, which can be found at [https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html](https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html).
    After successfully installing OpenCV, open a Python interpreter and try importing
    the library, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenCV 可能会更复杂，这取决于你的操作系统。最简单的方法是让 Anaconda 通过遵循安装 Anaconda ([https://www.anaconda.com/download/](https://www.anaconda.com/download/))
    后的指南在 [https://anaconda.org/conda-forge/opencv](https://anaconda.org/conda-forge/opencv)
    处理安装过程来处理安装过程。然而，如果你没有使用 Anaconda，安装 OpenCV 的主要选项是遵循其官方文档指南，该指南可在 [https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html](https://docs.opencv.org/master/df/d65/tutorial_table_of_content_introduction.html)
    找到。在成功安装 OpenCV 后，打开 Python 解释器并尝试导入库，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will import OpenCV using the name `cv2`, which is the library alias of OpenCV
    in Python. The success message indicates the version of the OpenCV library that
    has been downloaded (4.5.2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名称`cv2`导入OpenCV，这是Python中OpenCV的库别名。成功消息表示已下载的OpenCV库版本（4.5.2）。
- en: Computer image basics
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机图像基础
- en: Before we jump into processing and manipulating digital image files, we need
    to discuss the fundamentals of those files and how computers interpret data from
    them. Specifically, we need to understand how data regarding the colors and coordinates
    of individual pixels in an image file is represented, as well as how to extract
    it using Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入处理和操作数字图像文件之前，我们需要讨论这些文件的基本知识以及计算机如何解释它们的数据。具体来说，我们需要了解图像文件中关于单个像素的颜色和坐标的数据是如何表示的，以及如何使用Python提取它。
- en: RGB values
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RGB值
- en: RGB values are the basics of how colors are represented digitally. Standing
    for **red**, **green**, and **blue** (**RGB**), these values are constructed from
    the fact that all colors can be generated from a specific combination of red,
    green, and blue. So, an RGB value is a tuple of three integer numbers, each of
    which ranges from 0 (which indicates no color at all) to 255 (which indicates
    the deepest shade of that specific color).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: RGB值是数字表示颜色的基础。代表**红色**、**绿色**和**蓝色**（**RGB**），这些值是基于所有颜色都可以由红色、绿色和蓝色的特定组合生成的这一事实构建的。因此，RGB值是一个包含三个整数数字的元组，每个数字的范围从0（表示完全没有颜色）到255（表示该特定颜色的最深色调）。
- en: For example, red corresponds to the tuple (255, 0, 0); in this tuple, there
    is only the highest value for red and no values for the other colors, so the whole
    tuple represents the pure color red. Similarly, blue is represented by (0, 0,
    255), while green is represented by (0, 255, 0). Yellow is the result of mixing
    equal amounts of red and green and is therefore represented by (255, 255, 0) (the
    maximum amount of red and green, with no blue). White, which is the combination
    of all three colors, is (255, 255, 255), while black, which is the opposite of
    white and therefore lacks all colors, is represented by (0, 0, 0).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，红色对应于元组（255，0，0）；在这个元组中，只有红色的最大值，其他颜色的值都没有，所以整个元组代表纯红色。同样，蓝色由（0，0，255）表示，而绿色由（0，255，0）表示。黄色是红色和绿色的等量混合的结果，因此由（255，255，0）表示（最大量的红色和绿色，没有蓝色）。白色是三种颜色的组合，因此是（255，255，255），而黑色是白色的对立面，因此没有颜色，由（0，0，0）表示。
- en: 'This is illustrated by the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这由以下图表说明：
- en: '![Figure 10.2 – Illustration of RGB values ](img/B17499_Figure_10.2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – RGB值的说明](img/B17499_Figure_10.2.jpg)'
- en: Figure 10.2 – Illustration of RGB values
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – RGB值的说明
- en: Pixels and image files
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素和图像文件
- en: 'So, an RGB value indicates a specific color, but how do we connect this to
    a computer image? If we were to view an image on our computer and try to zoom
    in as much as we could, we would observe that as we zoom in deeper and deeper,
    the image will start breaking apart into increasingly discernible colored squares.
    These squares are called pixels, which are the smallest units of color on a computer
    display or in a digital image:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RGB值表示特定的颜色，但我们如何将其与计算机图像联系起来呢？如果我们要在电脑上查看一张图片并尽可能放大，我们会观察到，当我们越来越深入地放大，图像将开始分解成越来越容易辨认的彩色方块。这些方块被称为像素，它们是计算机显示或数字图像中最小的颜色单位：
- en: '![Figure 10.3 – Examples of pixels in digital images ](img/B17499_Figure_10.3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 数字图像中像素的示例](img/B17499_Figure_10.3.jpg)'
- en: Figure 10.3 – Examples of pixels in digital images
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 数字图像中像素的示例
- en: A set of different pixels arranged in a tabular format (rows and columns of
    pixels) makes up a computer image. Each pixel, in turn, is an RGB value; in other
    words, a pixel is a tuple of three integers. This means that a computer image
    is simply a two-dimensional array of tuples, whose sides correspond to the size
    of the image. For example, a 128 x 128 image has 128 rows and 128 columns of RGB
    tuples for its data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一组以表格格式（像素的行和列）排列的不同像素组成计算机图像。每个像素，反过来，是一个RGB值；换句话说，一个像素是一个包含三个整数的元组。这意味着计算机图像只是一个二维数组，其边长对应于图像的大小。例如，一个128
    x 128的图像有128行和128列的RGB元组来表示其数据。
- en: Coordinates inside an image
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像内部的坐标
- en: Like indexing two-dimensional arrays, the coordinate for a digital image pixel
    is a pair of two integers, representing the *x*- and *y*-coordinates of that pixel;
    the *x*-coordinate indicates the pixel's location along the horizontal axis starting
    from the left, while the *y*-coordinate indicates the pixel's location along the
    vertical axis starting from the top.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像索引二维数组一样，数字图像像素的坐标是一对两个整数，表示该像素的 *x* 和 *y* 坐标；*x* 坐标表示从左侧开始的像素在水平轴上的位置，而 *y*
    坐标表示从顶部开始的像素在垂直轴上的位置。
- en: Here, we can see how heavy computational number-crunching processes are typically
    involved when it comes to image processing since each image is a matrix of integer
    tuples. This also suggests that, with the help of the NumPy library and concurrent
    programming, we can achieve significant improvements in execution time for Python
    image processing applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到当涉及到图像处理时，通常涉及大量的计算密集型处理过程，因为每个图像都是一个整数元组的矩阵。这也表明，借助 NumPy 库和并发编程，我们可以显著提高
    Python 图像处理应用程序的执行时间。
- en: Following the convention of indexing two-dimensional arrays in NumPy, the location
    of a pixel is still a pair of integers, but the first number indicates the index
    of the row containing the pixel, which corresponds to the *y*-coordinate, and
    similarly, the second number indicates the *x*-coordinate of the pixel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 NumPy 中二维数组的索引惯例，像素的位置仍然是一对整数，但第一个数字表示包含像素的行的索引，这对应于 *y* 坐标，同样，第二个数字表示像素的
    *x* 坐标。
- en: OpenCV API
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenCV API
- en: There are a surprising number of methods for reading in, performing image processing,
    and displaying a digital image file in Python. However, OpenCV provides some of
    the easiest and most intuitive options to do this. One important thing to note
    regarding OpenCV is that it inverts RGB values as BGR values when interpreting
    its images. So, instead of red, green, and blue in order, the tuples in an image
    matrix will represent blue, green, and red, in that order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有大量用于读取、执行图像处理和显示数字图像文件的方法。然而，OpenCV 提供了一些最简单、最直观的选项来完成这些任务。关于 OpenCV，有一点需要注意，即它在解释图像时将
    RGB 值反转成 BGR 值。因此，图像矩阵中的元组将按照蓝色、绿色和红色的顺序表示，而不是按照红色、绿色和蓝色的顺序。
- en: 'Let''s look at an example of interacting with OpenCV in Python:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个在 Python 中与 OpenCV 交互的例子：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few methods from OpenCV that have been used in this script that
    we need to discuss:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中使用了几个 OpenCV 的方法，我们需要讨论一下：
- en: '`cv2.imread()`: This method takes in a path to an image file (compatible file
    extensions include `.jpeg`, `.jpg`, `.png`, and so on) and returns an image object,
    which, as we will see later, is represented by a NumPy array.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.imread()`: 此方法接受一个图像文件的路径（兼容的文件扩展名包括 `.jpeg`, `.jpg`, `.png` 等）并返回一个图像对象，正如我们稍后将会看到的，这个图像对象由一个
    NumPy 数组表示。'
- en: '`cv2.imshow()`: This method takes in a string and an image object and displays
    it in a separate window. The title of the window is specified by the passed-in
    string. The method should always be followed by the `cv2.waitKey()` method.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.imshow()`: 此方法接受一个字符串和一个图像对象，并在一个单独的窗口中显示它。窗口的标题由传入的字符串指定。此方法应始终跟在 `cv2.waitKey()`
    方法之后。'
- en: '`cv2.waitKey()`: This method takes in a number and blocks the program for a
    corresponding number of milliseconds unless the number `0` is passed in, in which
    case it will block indefinitely until the user presses a key on their keyboard.
    This method should always follow the `cv2.imshow()` method.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.waitKey()`: 此方法接受一个数字并阻塞程序，直到经过相应数量的毫秒数，除非传入的数字是 `0`，在这种情况下，它将无限期地阻塞，直到用户按下键盘上的任意键。此方法应始终跟在
    `cv2.imshow()` 方法之后。'
- en: 'After calling `cv2.imshow()` on the `ship.jpg` file inside the input subfolder
    so that it''s displayed from the Python interpreter, the program will stop until
    a key is pressed, at which point it will execute the rest of the program. If run
    successfully, the script will display the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入子文件夹中的 `ship.jpg` 文件上调用 `cv2.imshow()` 之后，以便从 Python 解释器中显示它，程序将停止，直到按下任意键，此时将执行程序的其余部分。如果成功运行，脚本将显示以下输出：
- en: '![Figure 10.4 – Displaying an image using OpenCV ](img/B17499_Figure_10.4.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 使用 OpenCV 显示图像](img/B17499_Figure_10.4.jpg)'
- en: Figure 10.4 – Displaying an image using OpenCV
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 使用 OpenCV 显示图像
- en: 'You should also obtain the following output for the rest of the main program
    after pressing any key to close the displayed picture:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下任意键关闭显示的图片后，主程序的其余部分也应输出以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output confirms a few of the things that we discussed earlier:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了我们之前讨论的一些内容：
- en: First, when printing out the image object that was returned by the `cv2.imread()`
    function, we obtained a matrix of numbers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当我们打印出`cv2.imread()`函数返回的图像对象时，我们得到了一个数字矩阵。
- en: 'Using the `type()` method from Python, we found that the class of this matrix
    is indeed a NumPy array: `numpy.ndarray`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的`type()`方法，我们发现这个矩阵的确是NumPy数组类型：`numpy.ndarray`。
- en: Calling the `shape` attribute of the array, we can see that the image is a three-dimensional
    matrix of the shape (`1118`, `1577`, `3`), which corresponds to a table with `1118`
    rows and `1577` columns, each element of which is a pixel (three-number tuple).
    The numbers for the rows and columns also correspond to the size of the image.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用数组的`shape`属性，我们可以看到图像是一个形状为(`1118`, `1577`, `3`)的三维矩阵，这对应于一个有`1118`行和`1577`列的表格，每个元素都是一个像素（一个包含三个数字的元组）。行和列的数字也对应于图像的大小。
- en: Focusing on the top-left pixel in the matrix (the first pixel in the first row;
    that is, `im[0, 0]`), we obtained the BGR value of (`199`, `136`, `86`) – `199`
    blue, `136` green, and `86` red. By looking up this BGR value through any online
    converter, we can see that this is a light blue that corresponds to the sky, which
    is the upper part of the image.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们关注矩阵的左上角像素（第一行第一个像素；即`im[0, 0]`），我们得到了BGR值为(`199`, `136`, `86`) – `199`代表蓝色，`136`代表绿色，`86`代表红色。通过任何在线转换器查找这个BGR值，我们可以看到这是一种浅蓝色，对应于天空，这是图像的上方部分。
- en: Image processing techniques
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像处理技术
- en: We have already seen some Python APIs that are provided by OpenCV to read data
    from image files. Before we can use OpenCV to perform various image processing
    tasks, let's discuss the theoretical foundation for several techniques that are
    commonly used in image processing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些OpenCV提供的Python API，用于从图像文件中读取数据。在我们能够使用OpenCV执行各种图像处理任务之前，让我们讨论一下图像处理中常用的一些技术的理论基础。
- en: Grayscaling
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灰度化
- en: We saw an example of grayscaling earlier in this chapter. Arguably one of the
    most widely used image processing techniques, grayscaling is the process of reducing
    the dimensionality of the image pixel matrix by only considering the intensity
    information of each pixel, which is represented by the amount of light available.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面看到了一个灰度化的例子。可以说，灰度化是应用最广泛的一种图像处理技术。灰度化是通过仅考虑每个像素的强度信息来降低图像像素矩阵的维度，这种强度信息由可用的光量表示。
- en: As a result, the pixels of grayscale images no longer hold three-dimensional
    information (red, green, and blue), and only one-dimensional black-and-white data.
    These images are exclusively composed of shades of gray, with black indicating
    the weakest light intensity and white indicating the strongest.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，灰度图像的像素不再包含三维信息（红色、绿色和蓝色），而只有一维的黑白数据。这些图像仅由灰度色调组成，黑色表示最弱的光强度，白色表示最强的光强度。
- en: Grayscaling serves many important purposes in image processing. Firstly, as
    we mentioned previously, it reduces the dimensionality of the image pixel matrix
    by mapping traditional three-dimensional color data to one-dimensional gray data.
    So, instead of having to analyze and process three layers of color data, image
    processing programs only have to do one-third of the job with grayscale images.
    Additionally, by only representing colors using one spectrum, important patterns
    in the image are more likely to be recognized with just black and white data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度化在图像处理中发挥着许多重要作用。首先，正如我们之前提到的，它通过将传统的三维颜色数据映射到一维灰度数据来降低图像像素矩阵的维度。因此，我们不需要分析和处理三层颜色数据，图像处理程序只需要用灰度图像完成三分之一的任务。此外，仅使用一个光谱来表示颜色，图像中的重要模式更有可能仅通过黑白数据被识别。
- en: 'There are multiple algorithms for converting color into grayscale: colorimetric
    conversion, luma coding, single-channel, and more. Luckily, we do not have to
    implement one ourselves, as the OpenCV library provides a one-line method to convert
    normal images into grayscale ones. Still using the image of a ship from the previous
    example, let''s look at another example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将颜色转换为灰度的算法有多种：色度转换、亮度编码、单通道等。幸运的是，我们不需要自己实现，因为OpenCV库提供了一个将普通图像转换为灰度图像的一行方法。仍然使用之前例子中的船的图像，让我们看看另一个例子：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we are using the `cvtColor()` method from OpenCV to convert
    our original image into a grayscale one. After running this script, the following
    output should be displayed on your computer:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了OpenCV的`cvtColor()`方法将我们的原始图像转换为灰度图像。运行此脚本后，以下输出应显示在您的计算机上：
- en: '![Figure 10.5 – Output from grayscaling ](img/B17499_Figure_10.5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 灰度化输出](img/B17499_Figure_10.5.jpg)'
- en: Figure 10.5 – Output from grayscaling
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 灰度化输出
- en: 'By pressing any key to unblock your program, you should obtain the following
    output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按任意键解除程序阻塞，您应该获得以下输出：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we can see that the structure of our grayscale image object is different
    from what we saw with our original image object. Even though it is still represented
    by a NumPy array, it is now a two-dimensional array of integers, each of which
    ranges from 0 (for black) to 255 (for white). The table of pixels, however, still
    consists of `1118` rows and `1577` columns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的灰度图像对象的结构与我们看到的原始图像对象不同。尽管它仍然由NumPy数组表示，但现在它是一个从0（黑色）到255（白色）的整数二维数组。然而，像素表仍然由`1118`行和`1577`列组成。
- en: In this example, we also used the `cv2.imwrite()` method, which saves the image
    object to your local computer. This means that the grayscale image can be found
    in the output subfolder of this chapter's folder, as specified in our code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还使用了`cv2.imwrite()`方法，它将图像对象保存到您的本地计算机上。这意味着灰度图像可以在本章节文件夹的输出子文件夹中找到，如我们的代码中指定。
- en: Thresholding
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阈值化
- en: Another important technique in image processing is **thresholding**. Intending
    to categorize each pixel in a digital image into different groups (also known
    as **image segmentation**), thresholding provides a quick and intuitive way to
    create binary images (with just black and white pixels).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理中的另一个重要技术是**阈值化**。目的是将数字图像中的每个像素分类到不同的组（也称为**图像分割**），阈值化提供了一种快速直观的方法来创建二值图像（仅包含黑色和白色像素）。
- en: The idea behind thresholding is to replace each pixel in an image with a white
    pixel if the pixel's intensity is greater than a previously specified threshold,
    and with a black pixel if the pixel's intensity is less than that threshold. Similar
    to the goal of grayscaling, thresholding amplifies the differences between high-
    and low-intensity pixels, and from that, important features and patterns in an
    image can be recognized and extracted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值化的基本思想是将图像中的每个像素替换为白色像素，如果像素的强度大于先前指定的阈值，或者替换为黑色像素，如果像素的强度小于该阈值。与灰度化的目标相似，阈值化放大了高强度和低强度像素之间的差异，从而可以识别和提取图像中的重要特征和模式。
- en: Recall that grayscaling converts a fully colored image into a version that only
    has different shades of gray; in this case, each pixel has a value of an integer
    ranging from 0 to 255\. From a grayscale image, thresholding can convert it into
    a fully black-and-white one, each pixel of which is now only either 0 (black)
    or 255 (white). So, after performing thresholding on an image, each pixel of that
    image can only hold two possible values, further reducing the complexity of our
    image data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，灰度化将全彩图像转换为只有不同灰度版本的图像；在这种情况下，每个像素的值是一个介于0到255之间的整数。从灰度图像中，阈值化可以将其转换为全黑白色图像，每个像素现在只能是0（黑色）或255（白色）。因此，在执行图像的阈值化之后，该图像的每个像素只能持有两种可能值，从而进一步降低了我们图像数据的复杂性。
- en: 'So, the key to an effective thresholding process is finding an appropriate
    threshold so that the pixels in an image are segmented in a way that allows separate
    regions in the image to become more obvious. The simplest form of thresholding
    is to use a constant threshold to process all the pixels throughout a whole image.
    Let''s consider an example of this method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有效阈值化过程的关键是找到一个合适的阈值，以便图像中的像素以某种方式分割，使得图像中的不同区域变得更加明显。最简单的阈值化形式是使用一个常数阈值来处理整个图像中的所有像素。让我们考虑一个这种方法的例子：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, after converting the image of a ship that we have been using
    to grayscale, we called the `threshold(src, thresh, maxval, type)` function from
    OpenCV, which takes in the following arguments:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在将我们一直在使用的船只图像转换为灰度图之后，调用了OpenCV中的`threshold(src, thresh, maxval, type)`函数，该函数接受以下参数：
- en: '`src`: This argument takes in the input/source image.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：此参数接受输入/源图像。'
- en: '`thresh`: This is the constant threshold to be used throughout the image. Here,
    we are using `127`, as it is simply the middle point between 0 and 255.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thresh`：这是在整个图像中使用的常数阈值。在这里，我们使用`127`，因为它简单地位于0和255之间的中间点。'
- en: '`maxval`: Pixels whose original values are greater than the constant threshold
    will take this value after the thresholding process. We pass in 255 to specify
    that those pixels should be completely white.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxval`：原始值大于常数阈值的像素在阈值化过程后将取此值。我们传递255来指定这些像素应该是完全白色的。'
- en: '`type`: This value indicates the thresholding type that''s used by OpenCV.
    We are performing simple binary thresholding, so we pass in `cv2.THRESH_BINARY`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这个值表示OpenCV使用的阈值化类型。我们正在进行简单的二值阈值化，因此我们传递`cv2.THRESH_BINARY`。'
- en: 'After running the script, you should be able to find the following image in
    the output with the name `custom_thresh_ship.jpg`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该能够在输出中找到名为`custom_thresh_ship.jpg`的以下图像：
- en: '![](img/B17499_Figure_10.6.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17499_Figure_10.6.jpg)'
- en: Figure 10.6 – Output from simple thresholding
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 简单阈值化输出
- en: 'Here, we can see that with a simple threshold (`127`), we have obtained an
    image that highlights separate regions of the image: the sky, the ship, and the
    sea. However, there are several problems that this simple thresholding method
    poses, the most common of which is finding the appropriate constant threshold.
    Since different images have different color tones, lighting conditions, and so
    on, it is undesirable to use a static value across different images as their thresholds.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，使用简单的阈值（`127`），我们已经获得了一个突出显示图像中不同区域的图像：天空、船只和海洋。然而，这种简单的阈值化方法存在几个问题，其中最常见的是找到合适的常数阈值。由于不同的图像有不同的色调、光照条件等，因此在不同图像中使用静态值作为它们的阈值是不理想的。
- en: 'This issue is addressed by adaptive thresholding methods, which use different
    thresholds whose values are dynamically determined for small regions of an image.
    This process allows the threshold to adjust according to the input image, and
    not depend solely on a static value. Let''s consider two examples of these adaptive
    thresholding methods, namely **Adaptive Mean Thresholding** and **Adaptive Gaussian
    Thresholding**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应阈值化方法解决了这个问题，这些方法使用不同阈值，其值根据图像的小区域动态确定。这个过程允许阈值根据输入图像进行调整，而不是完全依赖于静态值。让我们考虑两种自适应阈值化方法的例子，即**自适应均值阈值化**和**自适应高斯阈值化**：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to what we did with the `cv2.threshold()` method earlier, here, we are
    converting the original image into its grayscale version, and then we are passing
    it to the `adaptiveThreshold()` method from OpenCV. This method takes in similar
    arguments to the `cv2.threshold()` method, except that instead of taking in a
    constant to be the threshold, it takes in an argument for the adaptive method.
    We used `cv2.ADAPTIVE_THRESH_MEAN_C` and `cv2.ADAPTIVE_THRESH_GAUSSIAN_C`, respectively.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前使用的`cv2.threshold()`方法类似，这里，我们将原始图像转换为灰度版本，然后将其传递给OpenCV的`adaptiveThreshold()`方法。此方法接受与`cv2.threshold()`方法类似的参数，除了它接受一个用于自适应方法的参数。我们分别使用了`cv2.ADAPTIVE_THRESH_MEAN_C`和`cv2.ADAPTIVE_THRESH_GAUSSIAN_C`。
- en: The second to last argument specifies the size of the window to perform thresholding
    on; this number has to be an odd positive integer. Specifically, we used 11 in
    our example, so for each pixel in the image, the algorithm will consider the neighboring
    pixels (in an 11 x 11 square surrounding the original pixel). The last argument
    specifies the adjustment to make for each pixel in the final output. These two
    arguments, again, help localize the threshold for different regions of the image,
    thus making the thresholding process more dynamic and, as its name suggests, adaptive.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个到最后一个参数指定了进行阈值化操作的窗口大小；这个数字必须是一个奇数正整数。具体来说，我们在示例中使用了11，因此对于图像中的每个像素，算法将考虑周围的像素（在一个以原始像素为中心的11x11正方形内）。最后一个参数指定了在最终输出中对每个像素进行调整。这两个参数再次帮助定位图像的不同区域的阈值，从而使阈值化过程更加动态，正如其名称所暗示的，具有适应性。
- en: 'After running the script, you should be able to find the following images as
    output with the names `mean_thresh_ship.jpg` and `gauss_thresh_ship.jpg`. The
    output for `mean_thresh_ship.jpg` is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该能够在输出中找到以下图像，名称分别为`mean_thresh_ship.jpg`和`gauss_thresh_ship.jpg`。`mean_thresh_ship.jpg`的输出如下：
- en: '![Figure 10.7 – Output from mean thresholding ](img/B17499_Figure_10.7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 均值阈值化输出](img/B17499_Figure_10.7.jpg)'
- en: Figure 10.7 – Output from mean thresholding
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 均值阈值处理的输出
- en: 'The output for `gauss_thresh_ship.jpg` is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`gauss_thresh_ship.jpg` 的输出如下：'
- en: '![Figure 10.8 – Output from Gaussian thresholding ](img/B17499_Figure_10.8.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 高斯阈值处理的输出](img/B17499_Figure_10.8.jpg)'
- en: Figure 10.8 – Output from Gaussian thresholding
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 高斯阈值处理的输出
- en: Here, we can see that with adaptive thresholding, details in specific regions
    will be thresholded and highlighted in the final output image. These techniques
    are useful when we need to recognize small details in an image, while simple thresholding
    is useful when we only want to extract big regions of an image.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，通过自适应阈值处理，特定区域的细节将在最终输出图像中被阈值化并突出显示。当我们需要在图像中识别小细节时，这些技术非常有用，而简单的阈值处理则适用于我们只想提取图像的大区域时。
- en: We have talked a lot about the basics of image processing and some common image
    processing techniques. We also know why image processing is a heavy number-crunching
    task, and that concurrent and parallel programming can be applied to speed up
    independent processing tasks. In the next section, we will look at a specific
    example of how to implement a concurrent image processing application that can
    handle a large number of input images.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于图像处理的基础知识和一些常见的图像处理技术。我们还知道为什么图像处理是一个繁重的数值计算任务，以及并发和并行编程可以应用于加速独立处理任务。在下一节中，我们将探讨一个具体的示例，展示如何实现一个可以处理大量输入图像的并发图像处理应用程序。
- en: Applying concurrency to image processing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将并发应用于图像处理
- en: First, head to the current folder for this chapter's code. Inside the `input`
    folder, there is a subfolder called `large_input`, which contains 400 images that
    we will be using for this example. These pictures are of different regions in
    our original ship image, and they have been cropped from it using the *array-indexing*
    and *-slicing* options that NumPy provides for slicing OpenCV image objects. If
    you are curious as to how these images were generated, check out the `generate_input.py`
    file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往本章代码所在的当前文件夹。在 `input` 文件夹中，有一个名为 `large_input` 的子文件夹，其中包含我们将用于此示例的400张图像。这些图片是我们原始船图像的不同区域的图片，并且它们是通过使用NumPy为切片OpenCV图像对象提供的
    *array-indexing* 和 *-slicing* 选项从其中裁剪出来的。如果你对这些图像是如何生成的感到好奇，可以查看 `generate_input.py`
    文件。
- en: 'Our goal in this section is to implement a program that can concurrently process
    these images using thresholding. To do this, let''s look at the `example5.py`
    file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是实现一个程序，该程序可以使用阈值处理并发处理这些图像。为此，让我们看看 `example5.py` 文件：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are using the `Pool` class from the `multiprocessing` module
    to manage our processes. As a refresher, a `Pool` object supplies convenient options
    to map a sequence of inputs to separate processes using the `Pool.map()` method.
    We are using the `Pool.starmap()` method in our example, however, to pass multiple
    arguments to the target function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `multiprocessing` 模块中的 `Pool` 类来管理我们的进程。作为一个复习，`Pool` 对象提供了方便的选项，使用
    `Pool.map()` 方法将输入序列映射到不同的进程。然而，在我们的例子中，我们使用 `Pool.starmap()` 方法来将多个参数传递给目标函数。
- en: 'At the beginning of our program, we make several housekeeping assignments:
    the thresholding method to perform adaptive thresholding when processing the images,
    the paths for the input and output folders, and the names of the images to process.
    The `process_threshold()` function is what we use to process the images; it takes
    in an image object, the name for the processed version of the image, and which
    thresholding method to use. Again, this is why we need to use the `Pool.starmap()`
    method instead of the traditional `Pool.map()` method.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们程序的开始阶段，我们进行了几个维护性赋值：执行图像自适应阈值处理的阈值方法、输入和输出文件夹的路径，以及要处理的图像名称。`process_threshold()`
    函数是我们用来处理图像的；它接受一个图像对象、图像处理版本的名称以及要使用的阈值方法。再次强调，这就是为什么我们需要使用 `Pool.starmap()`
    方法而不是传统的 `Pool.map()` 方法。
- en: In the main program, to demonstrate the difference in performance between sequential
    and multiprocessing image processing, we want to run our program with different
    numbers of processes, specifically from one single process to six different processes.
    In each iteration of the `for` loop, we initialize a `Pool` object and map the
    necessary arguments of each image to the `process_threshold()` function, while
    keeping track of how much time it takes to process and save all of the images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，为了展示顺序处理和并行图像处理之间的性能差异，我们希望用不同的进程数运行我们的程序，具体是从一个单独的进程到六个不同的进程。在`for`循环的每次迭代中，我们初始化一个`Pool`对象，并将每个图像的必要参数映射到`process_threshold()`函数，同时记录处理和保存所有图像所需的时间。
- en: 'After running the script, the processed images can be found in the `output/large_output/`
    subfolder in our current chapter''s folder. You should obtain an output similar
    to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，处理过的图像可以在我们当前章节文件夹下的`output/large_output/`子文件夹中找到。你应该得到以下类似的结果：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see a big difference in execution time when we go from one single process
    to two separate processes. However, there is negligible or even negative speedup
    after going from two to higher numbers of processes. Generally, this is because
    of the heavy overhead, which is the product of implementing many separate processes,
    in comparison to a relatively low number of inputs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从单个进程变为两个独立进程时，我们可以看到执行时间的显著差异。然而，从两个进程增加到更多进程后，速度提升可以忽略不计，甚至可能是负提升。一般来说，这是因为相对于相对较低的数量输入，实现许多独立进程的重叠开销很大。
- en: 'So far, we have seen that concurrent programming could provide a significant
    speedup for image processing applications. However, if we take a look at our preceding
    program, we can see that there are additional adjustments that we can make to
    improve the execution time even further. Specifically, in the preceding program,
    we are sequentially reading in images by using list comprehension in the following
    line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到并发编程可以为图像处理应用提供显著的加速。然而，如果我们看一下先前的程序，我们可以看到我们可以进行一些额外的调整来进一步改善执行时间。具体来说，在先前的程序中，我们使用以下行中的列表解析按顺序读取图像：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Theoretically, if we were to make the process of reading in different image
    files concurrent, we could also gain additional speedup with our program. This
    is especially true in an image processing application that deals with large input
    files, where significant time is spent waiting for input to be read. With that
    in mind, let''s consider the following example, in which we will implement concurrent
    input/output processing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果我们使读取不同图像文件的过程并发，我们也可以通过我们的程序获得额外的加速。这在处理大型输入文件的图像处理应用中尤其如此，在这些应用中，大量时间用于等待读取输入。考虑到这一点，让我们考虑以下示例，我们将实现并发输入/输出处理：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The structure of this program is similar to that of the previous one. However,
    instead of preparing the necessary images to be processed and other relevant input
    information, we implement them inside the `process_threshold()` function, which
    now only takes the name of the input image and handles reading the image itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的结构与上一个类似。然而，我们不是在`process_threshold()`函数外部准备要处理的必要图像和其他相关输入信息，而是在该函数内部实现它们，现在该函数只接受输入图像的名称，并处理读取图像本身。
- en: As a side note, we are using Python's built-in `functools.partial()` method
    in our main program to pass in a partial argument (hence the name), specifically
    `thresh_method`, to the `process_threshold()` function, as this argument is fixed
    across all images and processes. More information about this tool can be found
    at [https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们在主程序中使用Python的内置`functools.partial()`方法传递部分参数（因此得名），即`thresh_method`，到`process_threshold()`函数，因为这个参数在所有图像和进程中都是固定的。更多关于这个工具的信息可以在[https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html)找到。
- en: 'After running the script, you should obtain an output similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你应该得到以下类似的结果：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compared to our previous output, this implementation of the application gives
    us a significantly better execution time!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的输出相比，这个应用程序的实现给我们带来了显著更好的执行时间！
- en: Good concurrent image processing practices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的并发图像处理实践
- en: So far, you have most likely realized that image processing is quite an involved
    process and that implementing concurrent and parallel programming in an image
    processing application can add more complexity to our work. There are, however,
    good practices that will guide us in the right direction while developing our
    image processing applications. The following sections discuss some of the most
    common practices that we should keep in mind.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经意识到图像处理是一个相当复杂的过程，而在图像处理应用程序中实现并发和并行编程可能会给我们的工作增加更多复杂性。然而，在开发我们的图像处理应用程序时，有一些良好的实践可以引导我们走向正确的方向。以下几节将讨论我们应该牢记的一些最常见实践。
- en: Choosing the correct way (out of many)
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的方法（众多方法中的一种）
- en: We have hinted at this practice briefly when we learned about thresholding.
    How an image processing application handles and processes its image data heavily
    depends on the problems it is supposed to solve, and what kind of data will be
    fed to it. Therefore, there is significant variability when it comes to choosing
    specific parameters when processing your image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在学习阈值处理时简要提到了这种实践。图像处理应用程序如何处理和加工其图像数据在很大程度上取决于它应该解决的问题，以及将要输入的数据类型。因此，在处理图像时选择特定参数时存在很大的可变性。
- en: 'For example, as we saw earlier, there are various ways to threshold an image,
    and each will result in a very different output: if you want to focus on only
    the large, distinct regions of an image, **simple constant thresholding** will
    prove to be more beneficial than **adaptive thresholding**; if, however, you want
    to highlight small changes in the details of an image, adaptive thresholding will
    be significantly better.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，正如我们之前所看到的，有各种方法可以对图像进行阈值处理，每种方法都会产生非常不同的输出：如果您只想关注图像中的大而明显的区域，**简单的常量阈值处理**将比**自适应阈值处理**更有益；然而，如果您想突出图像细节中的微小变化，自适应阈值处理将显著更好。
- en: Let's consider another example, in which we will see how tuning a specific parameter
    for an image processing function results in better output. In this example, we
    are using a simple **Haar Cascade model** to detect faces in images. We will not
    go too deeply into how the model handles and processes its data since it is already
    built into OpenCV; again, we are only using this model at a high level, changing
    its parameters to obtain different results.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，我们将看到调整图像处理函数的特定参数如何导致更好的输出。在这个例子中，我们使用一个简单的 **Haar Cascade 模型**来检测图像中的面部。我们不会深入探讨模型如何处理和加工其数据，因为它已经内置在
    OpenCV 中；再次强调，我们只是在高级别上使用这个模型，通过改变其参数来获得不同的结果。
- en: 'Navigate to the `example7.py` file in this chapter''s folder. The script is
    designed to detect the faces in the `obama1.jpeg` and `obama2.jpg` images in our
    input folder:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到本章文件夹中的 `example7.py` 文件。该脚本旨在检测我们输入文件夹中的 `obama1.jpeg` 和 `obama2.jpg` 图像中的面部：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, the program loads the pre-trained Haar Cascade model from the `input`
    folder using the `cv2.CascadeClassifier` class. For each input image, the script
    converts it into grayscale and feeds it to the pre-trained model. The script then
    draws a green rectangle around each face it found in the image and displays it
    in a separate window.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序使用 `cv2.CascadeClassifier` 类从 `input` 文件夹中加载预训练的 Haar Cascade 模型。对于每个输入图像，脚本将其转换为灰度图像，并将其输入到预训练模型中。然后脚本在图像中找到的每个面部周围绘制一个绿色矩形，并在单独的窗口中显示它。
- en: 'Run the program; you will see the following image with the title `5 face(s)
    found`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序；您将看到以下标题为 `5 face(s) found` 的图像：
- en: '![Figure 10.9 – Correct face detection ](img/B17499_Figure_10.9.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 正确的面部检测](img/B17499_Figure_10.9.jpg)'
- en: Figure 10.9 – Correct face detection
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 正确的面部检测
- en: 'It looks like our program is working well so far. Press any key to continue.
    You should see the following image with the title `7 face(s) found`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的程序到目前为止运行得很好。按任意键继续。您应该会看到以下标题为 `7 face(s) found` 的图像：
- en: '![Figure 10.10 – Incorrect face detection ](img/B17499_Figure_10.10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 错误的面部检测](img/B17499_Figure_10.10.jpg)'
- en: Figure 10.10 – Incorrect face detection
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 错误的面部检测
- en: Now, our program is mistaking some other objects as actual faces, resulting
    in two false positives. The reason behind this involves how the pre-trained model
    was created. Specifically, the Haar Cascade model used a training dataset with
    images of specific (pixel) sizes, and when an input image contains faces of different
    sizes – which is common when it is a group picture with some people being close
    to the camera, while others being far away – is fed into this model, it will cause
    false positives in the output.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的程序错误地将一些其他对象误认为是实际的人脸，导致出现两个误报。背后的原因涉及到预训练模型是如何创建的。具体来说，Haar Cascade模型使用了一个包含特定（像素）大小图像的训练数据集，当包含不同大小的人脸的输入图像（这在是群体照片时很常见，其中一些人靠近相机，而其他人远离相机）被输入到这个模型中时，它会导致输出中出现误报。
- en: 'The `scaleFactor` parameter in the `detectMultiScale` method of the `cv2.CascadeClassifier`
    class addresses this issue. This parameter will scale down different areas of
    the input image before trying to predict whether those areas contain a face or
    not – doing this negates the potential difference in face sizes. To implement
    this, change the line where we pass the input images to the model to the following
    to specify the `scaleFactor` parameter as `1.2`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.CascadeClassifier`类中的`detectMultiScale`方法的`scaleFactor`参数解决了这个问题。这个参数会在尝试预测输入图像的不同区域是否包含人脸之前将其缩小——这样做消除了人脸大小可能存在的差异。为了实现这一点，将传递给模型的输入图像的行更改为以下内容，以指定`scaleFactor`参数为`1.2`：'
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program; you will see that this time, our application can correctly
    detect all of the faces in our input images without making any false positives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序；这次，您将看到，我们的应用程序可以正确地检测出输入图像中的所有人脸，而不会产生任何误报。
- en: From this example, we can see that it is important to know about the potential
    challenges that the input images will pose to your image processing application
    in execution, as well as to try different methods or parameters within one method
    of processing to achieve the best results.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看出，了解输入图像在执行过程中可能对您的图像处理应用程序造成的潜在挑战非常重要，同时尝试在处理方法中尝试不同的方法或参数，以实现最佳结果。
- en: Spawning an appropriate number of processes
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动适当数量的进程
- en: One point we noticed in our example of concurrent image processing is that the
    task of spawning processes takes a considerable amount of time. Due to this, if
    the number of processes available to analyze the data is too high in comparison
    to the amount of input, the improvement in execution time that's obtained from
    increasing the number of working processes will diminish and sometimes even become
    negative.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的并发图像处理示例中，我们注意到启动进程的任务需要相当长的时间。因此，如果可用于分析数据的进程数量与输入量相比过高，那么增加工作进程数量所获得的执行时间改进将减少，有时甚至变为负数。
- en: However, there is no concrete way to tell whether a specific number of separate
    processes is appropriate for a program unless we also take into account its input
    images. For example, if the input images are relatively large files, and it takes
    a significant amount of time for the program to load them from storage, having
    a larger number of processes might be beneficial; when some processes are waiting
    for their images to load, others can proceed to perform processing on theirs.
    In other words, having a larger number of processes will allow for some overlapping
    between loading and processing time, which will result in better speedup.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非我们同时考虑其输入图像，否则没有具体的方法来判断一个特定数量的独立进程是否适合一个程序。例如，如果输入图像是相对较大的文件，并且程序从存储中加载它们需要相当长的时间，那么拥有更多的进程可能会有所帮助；当一些进程正在等待它们的图像加载时，其他进程可以继续对它们的图像进行处理。换句话说，拥有更多的进程将允许加载和处理时间之间有一定的重叠，这将导致更好的加速效果。
- en: In short, it is important to test out different processes that are available
    for your image processing application to see what the optimal number for scalability
    is.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试您图像处理应用程序可用的不同进程对于确定可扩展性的最佳数量非常重要。
- en: Processing input/output concurrently
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发处理输入/输出
- en: We saw that loading input images in a sequential way might harm the execution
    time of an image processing application, as opposed to allowing separate processes
    to load their inputs. This is specifically true if the image files are significantly
    large, as the loading time in separate processes might overlap with the loading/processing
    time in other processes. The same is applicable for writing output images to files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，以顺序方式加载输入图像可能会损害图像处理应用程序的执行时间，这与允许单独的进程加载它们的输入相反。这特别适用于图像文件非常大时，因为单独进程的加载时间可能会与其他进程的加载/处理时间重叠。将输出图像写入文件也是如此。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Image processing is the task of analyzing and manipulating digital image files
    to create new versions of the images or to extract important data from them. These
    digital images are represented by tables of pixels, which are RGB values or, in
    essence, tuples of numbers. Therefore, digital images are simply multi-dimensional
    matrices of numbers, which results in the fact that image processing tasks typically
    come down to heavy number-crunching.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是分析并操作数字图像文件以创建图像的新版本或从中提取重要数据的任务。这些数字图像由像素表表示，像素是RGB值，本质上是一组数字。因此，数字图像仅仅是多维数字矩阵，这导致图像处理任务通常归结为大量的数值计算。
- en: Since images can be analyzed and processed independently from each other in
    an image processing application, concurrent and parallel programming – specifically,
    multiprocessing – provides a way for us to make significant improvements to the
    execution time of the application. Additionally, there are several good practices
    to follow while implementing a concurrent image processing program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在图像处理应用程序中，图像可以独立于彼此进行分析和处理，因此并发和并行编程——特别是多进程——为我们提供了一种方法，可以显著提高应用程序的执行时间。此外，在实现并发图像处理程序时，还有一些好的实践需要遵循。
- en: We have seen how we can apply parallel programming to accelerate the task of
    image processing. The exercises in this chapter allowed us to examine various
    aspects of the workflow and how each of them could be parallelized, thus allowing
    us to build up more confidence in implementing concurrent applications in Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何应用并行编程来加速图像处理任务。本章的练习使我们能够检查工作流程的各个方面以及它们如何被并行化，从而增强我们在Python中实现并发应用程序的信心。
- en: In the next chapter, we will go through a similar exercise, where we aim to
    use asynchronous programming to build communication channels.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进行类似的练习，目标是使用异步编程来建立通信通道。
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an image processing task?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是图像处理任务？
- en: What is the smallest unit of digital imaging? How is it represented in computers?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字成像的最小单位是什么？它在计算机中是如何表示的？
- en: What is grayscaling? What purpose does this technique serve?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是灰度化？这项技术有什么作用？
- en: What is thresholding? What purpose does this technique serve?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阈值化是什么？这项技术有什么作用？
- en: Why should image processing be made concurrent?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么图像处理应该实现并发？
- en: What are some good practices for concurrent image processing?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发图像处理有哪些好的实践？
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*,
    Al Sweigart, No Starch Press, 2015.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用Python自动化无聊的事情：面向完全初学者的实用编程*，Al Sweigart，No Starch Press，2015。'
- en: '*Learning Image Processing with OpenCV*, Garcia, Gloria Bueno, et al, Packt
    Publishing Ltd, 2015.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用OpenCV学习图像处理*，Garcia, Gloria Bueno，等，Packt Publishing Ltd，2015。'
- en: '*A Computational Introduction to Digital Image Processing*, Alasdair McAndrew,
    Chapman and Hall/CRC, 2015.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字图像处理计算导论*，Alasdair McAndrew，Chapman and Hall/CRC，2015。'
- en: 'Howse, J., P. Joshi, and M. Beyeler. OpenCV: *Computer Vision Projects with
    Python.* Packt Publishing Ltd, 2016.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Howse, J., P. Joshi, and M. Beyeler. OpenCV: *计算机视觉项目与Python*。Packt Publishing
    Ltd, 2016。'
