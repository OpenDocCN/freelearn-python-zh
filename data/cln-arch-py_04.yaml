- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Type-Enhanced Python: Strengthening Clean Architecture'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型增强的 Python：加强清洁架构
- en: 'In [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040) we explored the SOLID principles
    and their application in Python, establishing a foundation for maintainable and
    flexible code. Building on this, we now turn to a powerful feature in Python:
    **type hinting**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](Chapter_02.xhtml#_idTextAnchor040)中，我们探讨了 SOLID 原则及其在 Python 中的应用，为可维护和灵活的代码奠定了基础。在此基础上，我们现在转向
    Python 中的一个强大功能：**类型提示**。
- en: While Python’s dynamic typing offers flexibility, it can sometimes lead to unexpected
    errors in complex projects. Type hinting provides a solution, combining the benefits
    of dynamic typing with the robustness of static type checking.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 的动态类型提供了灵活性，但它有时会导致复杂项目中的意外错误。类型提示提供了一个解决方案，结合了动态类型的好处和静态类型检查的健壮性。
- en: This chapter explores how type hinting enhances Clean Architecture implementations,
    making code more self-documenting and less error-prone. We’ll see how type hints
    support SOLID principles, particularly in creating clear interfaces and reinforcing
    the Dependency Inversion Principle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了类型提示如何增强清洁架构的实现，使代码更具自文档性和更少错误。我们将看到类型提示如何支持 SOLID 原则，特别是在创建清晰的接口和加强依赖倒置原则方面。
- en: We’ll begin with the role of type awareness in Python’s dynamic environment,
    then delve into practical aspects of Python’s typing system. Finally, we’ll explore
    automated static type-checking tools for early issue detection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从类型意识在 Python 动态环境中的作用开始，然后深入探讨 Python 类型系统的实际方面。最后，我们将探索用于早期问题检测的自动静态类型检查工具。
- en: By the chapter’s end, you’ll understand how to effectively use type hints in
    Python projects, writing code that’s more robust, maintainable, and aligned with
    Clean Architecture principles. This knowledge will be crucial as we progress to
    building complex, scalable systems in later chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何在 Python 项目中有效地使用类型提示，编写更健壮、可维护且与清洁架构原则一致的代码。随着我们进入后续章节构建复杂、可扩展的系统，这种知识将至关重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding type awareness in Python’s dynamic environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Python 动态环境中的类型意识
- en: Leveraging Python’s typing system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Python 的类型系统
- en: Leveraging automated static type-checking tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用自动静态类型检查工具
- en: Let’s begin our exploration of Python type hinting and its role in strengthening
    Clean Architecture implementations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索 Python 类型提示及其在加强清洁架构实现中的作用。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. All examples can be found in the book’s accompanying
    GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
    This chapter does refer to **Visual Studio Code** (**VS Code**). VS Code can be
    downloaded from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分提供的代码示例均使用 Python 3.13 进行测试。所有示例均可在本书配套的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)。本章还提到了
    **Visual Studio Code** （**VS Code**）。VS Code 可从 [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    下载。
- en: Understanding type awareness in Python’s dynamic environment
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Python 动态环境中的类型意识
- en: To fully appreciate Python’s type system, it’s important to distinguish between
    dynamically typed languages like Python and statically typed languages like Java
    or C++. In statically typed languages, variables have a fixed type that’s determined
    at compile time. Python, as a dynamically typed language, allows variables to
    change types during runtime, offering great flexibility but also introducing potential
    challenges. This dynamic typing is both a blessing and a challenge when implementing
    Clean Architecture. While it offers flexibility and rapid development, it can
    also lead to unclear interfaces and hidden dependencies, issues that Clean Architecture
    aims to address. In this section, we’ll explore how type awareness can enhance
    our Clean Architecture implementations without sacrificing Python’s dynamic nature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分欣赏Python的类型系统，区分动态类型语言（如Python）和静态类型语言（如Java或C++）非常重要。在静态类型语言中，变量在编译时有一个固定的类型。Python作为一种动态类型语言，允许变量在运行时改变类型，提供了极大的灵活性，但也引入了潜在的挑战。这种动态类型在实现Clean
    Architecture时既是祝福也是挑战。虽然它提供了灵活性和快速开发，但也可能导致接口不明确和隐藏的依赖，这些问题正是Clean Architecture旨在解决的。在本节中，我们将探讨如何通过类型意识来增强我们的Clean
    Architecture实现，而不会牺牲Python的动态特性。
- en: Evolution of typing in Python
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中打字的发展
- en: Python’s approach to typing has evolved significantly over time. While originally
    a purely dynamically typed language, Python introduced optional static typing
    with the addition of type hinting syntax in Python 3.5 (2015) via PEP 484\. This
    introduction was motivated by the growing complexity of Python applications, particularly
    in large-scale projects where Clean Architecture principles are most beneficial.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python对类型的方法随着时间的推移发生了显著变化。虽然最初是一种纯动态类型语言，但Python通过在Python 3.5（2015年）中添加类型提示语法（PEP
    484）引入了可选的静态类型。这种引入是由Python应用程序日益增长的复杂性所推动的，特别是在大规模项目中，Clean Architecture原则最有益。
- en: This standardization of type hints through PEP 484 marked a significant milestone
    in Python’s evolution, providing a unified approach to adding type information
    to Python code. It paved the way for the broader adoption of static type checking
    in the Python ecosystem and the development of various tools and IDEs that leverage
    this type hinting information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过PEP 484对类型提示的标准化标志着Python发展的一个重要里程碑，为向Python代码添加类型信息提供了一种统一的方法。它为Python生态系统中静态类型检查的更广泛采用以及各种工具和IDE的开发铺平了道路，这些工具和IDE利用了这种类型提示信息。
- en: 'Python’s approach to type hinting is part of a broader trend in dynamic languages.
    JavaScript, for instance, has seen the rise of TypeScript, a typed superset of
    JavaScript that compiles to plain JavaScript. While both Python and TypeScript
    aim to bring the benefits of static typing to dynamic languages, their approaches
    differ:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python对类型提示的方法是动态语言中更广泛趋势的一部分。例如，JavaScript看到了TypeScript的兴起，它是JavaScript的一个类型超集，编译成纯JavaScript。虽然Python和TypeScript都旨在将静态类型的好处带给动态语言，但它们的方法不同：
- en: '**Integration**: Python’s type hints are built into the language itself, whereas
    TypeScript is a separate language that compiles to JavaScript'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：Python的类型提示是内置于语言本身的，而TypeScript是一种独立语言，它编译成JavaScript'
- en: '**Optionality**: Python’s type hints are entirely optional and can be gradually
    adopted, while TypeScript enforces type-checking more strictly'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选性**：Python的类型提示完全是可选的，可以逐步采用，而TypeScript则更严格地执行类型检查'
- en: The success of TypeScript in the JavaScript ecosystem further validates the
    value of adding type information to dynamic languages. Both Python’s type hints
    and TypeScript demonstrate how combining the flexibility of dynamic typing with
    the robustness of static typing can lead to more maintainable and scalable codebases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript在JavaScript生态系统中的成功进一步验证了在动态语言中添加类型信息的价值。Python的类型提示和TypeScript都展示了如何将动态类型灵活性结合到静态类型健壮性中，从而实现更易于维护和可扩展的代码库。
- en: The evolution of type hinting in Python was driven by several important factors.
    It significantly improves code readability and serves as a form of self-documentation,
    making it easier for developers to understand the intended use of variables and
    functions. This enhanced clarity is particularly valuable in maintaining Clean
    Architecture’s separation of concerns. Type hints also enable better **integrated
    development environment** (**IDE**) and tool support, facilitating more accurate
    code completion and error detection. This improved tooling support is crucial
    when working with complex architectures, helping developers navigate between different
    layers and components more efficiently.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中类型提示的演变是由几个重要因素驱动的。它显著提高了代码的可读性，并作为一种自我文档化的形式，使开发者更容易理解变量和函数的预期用途。这种增强的清晰度在维护
    Clean Architecture 的关注点分离方面特别有价值。类型提示还使集成开发环境（**IDE**）和工具支持更好，促进了更准确的代码补全和错误检测。当处理复杂架构时，这种改进的工具支持至关重要，它帮助开发者更有效地在不同层和组件之间导航。
- en: Furthermore, type hinting makes refactoring and maintaining large codebases
    considerably easier. In the context of Clean Architecture, where we strive to
    create systems that are adaptable to change, this benefit is particularly significant.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类型提示使重构和维护大型代码库变得容易得多。在 Clean Architecture 的背景下，我们努力创建能够适应变化的系统，这种好处尤其显著。
- en: Type hints act as a safety net during large-scale refactoring efforts, helping
    to ensure that changes in one part of the system don’t inadvertently break interfaces
    or expectations in another part.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示在大型重构努力中充当安全网，有助于确保系统某一部分的更改不会无意中破坏另一部分的接口或期望。
- en: Perhaps most importantly for our Clean Architecture implementations, type hints
    allow us to catch certain types of errors earlier in the development process.
    By making our intentions explicit through type annotations, we can identify potential
    issues at design time or during static analysis, rather than encountering them
    at runtime. This early error detection aligns perfectly with Clean Architecture’s
    goal of creating robust, maintainable systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们实现 Clean Architecture 来说，最重要的是，类型提示允许我们在开发过程的早期阶段捕捉到某些类型的错误。通过通过类型注解明确我们的意图，我们可以在设计时间或静态分析期间识别潜在问题，而不是在运行时遇到它们。这种早期错误检测与
    Clean Architecture 创建健壮、可维护系统的目标完美契合。
- en: As we delve deeper into the specifics of type hinting in the following sections,
    keep in mind that these features are tools to enhance our Python implementations
    of Clean Architecture. They offer a way to make our architectural boundaries more
    explicit and our code more self-documenting, all while retaining the flexibility
    and expressiveness that make Python such a powerful language for software development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节深入探讨类型提示的具体细节时，请记住，这些功能是增强我们 Python 实现 Clean Architecture 的工具。它们提供了一种使我们的架构边界更明确、代码更自我文档化的方法，同时保留了使
    Python 成为软件开发如此强大语言的灵活性和表达性。
- en: Dynamic typing versus type hinting
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型与类型提示的比较
- en: To understand the significance of type hints in Python, it’s crucial to distinguish
    between Python’s fundamental dynamic typing and the role of type hints. These
    two concepts serve different purposes and operate at different stages of the development
    process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解类型提示在 Python 中的重要性，区分 Python 的基本动态类型和类型提示的作用至关重要。这两个概念服务于不同的目的，并在开发过程的不同阶段运行。
- en: Dynamic typing
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态类型
- en: 'In a dynamically typed language such as Python, variables can hold values of
    any type, and these types can change during runtime. This flexibility is a core
    feature of Python. Let’s look at an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Python 这样的动态类型语言中，变量可以持有任何类型的值，并且这些类型可以在运行时改变。这种灵活性是 Python 的核心特性。让我们来看一个例子：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This flexibility allows for rapid development and expressive code but can lead
    to runtime errors if not managed carefully. Consider the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性允许快速开发和表达性代码，但如果不小心管理，可能会导致运行时错误。考虑以下示例：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the `add_numbers` function works as expected when given two integers,
    but raises a `TypeError` when given an integer and a string. This error only occurs
    at runtime, which can be problematic if it’s in a critical part of your application
    or if it’s not caught by your testing process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`add_numbers` 函数在给定两个整数时按预期工作，但在给定一个整数和一个字符串时引发 `TypeError`。这种错误仅在运行时发生，如果在应用程序的关键部分发生或未通过测试过程捕获，可能会成为问题。
- en: Type hinting
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型提示
- en: 'Type hints allow developers to annotate variables and function parameters in
    addition to returning values with their expected types. Regarding type hints,
    let’s revisit our simple function to add numbers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示允许开发者除了返回值外，还可以用它们期望的类型来注释变量和函数参数。关于类型提示，让我们重新审视我们简单的加法函数：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the type hinting syntax used in this function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个函数中使用的类型提示语法：
- en: '`a: int` and `b: int`: These annotations indicate that both `a` and `b` are
    expected to be integers. The colon (`:`) is used to separate the parameter name
    from its type.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a: int` 和 `b: int`：这些注解表明`a`和`b`都预期为整数。冒号（`:`）用于将参数名与其类型分开。'
- en: '`-> int:` This arrow notation after the function’s parameter list specifies
    the return type. In this case, it indicates that `add_numbers` is expected to
    return an integer.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-> int:` 函数参数列表之后的这个箭头符号指定了返回类型。在这种情况下，它表示`add_numbers`函数预期返回一个整数。'
- en: These type annotations provide clear information about the function’s expected
    inputs and output, making the code more self-documenting and easier to understand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型注解提供了关于函数预期输入和输出的清晰信息，使代码更具自文档性和易于理解。
- en: 'Key points about type hints include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型提示的关键点包括以下内容：
- en: They don’t affect Python’s runtime behavior. Python remains dynamically typed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会影响Python的运行时行为。Python仍然是动态类型的。
- en: They serve as documentation, making code intentions clearer.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们作为文档，使代码意图更加清晰。
- en: They enable static analysis tools to catch potential type-related errors before
    runtime.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使静态分析工具能够在运行时之前捕获潜在的与类型相关的错误。
- en: They improve IDE support for code completion and refactoring.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了IDE对代码补全和重构的支持。
- en: Type hints unlock the power of static analysis tools to catch potential errors
    before runtime. While Python itself provides the syntax for type hints, it doesn’t
    enforce them at runtime. The Python interpreter treats type hints as decorative
    metadata. It’s third-party tools such as *mypy* or *pyright* that perform the
    actual static type checking. These tools analyze your code without executing it,
    using the type hints to infer and check types across your entire codebase. They
    can be run as standalone commands, integrated into IDEs for real-time feedback,
    or incorporated into continuous integration pipelines, allowing for type-checking
    at various stages of development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示解锁了静态分析工具在运行时之前捕获潜在错误的能力。虽然Python本身提供了类型提示的语法，但它不会在运行时强制执行。Python解释器将类型提示视为装饰性元数据。是像*mypy*或*pyright*这样的第三方工具执行实际的静态类型检查。这些工具在不执行代码的情况下分析你的代码，使用类型提示推断和检查整个代码库中的类型。它们可以作为独立命令运行，集成到IDE中以提供实时反馈，或纳入持续集成管道，允许在开发的不同阶段进行类型检查。
- en: In the *Leveraging automated static type checking tools* section of this chapter,
    we’ll dive deeper into how to use these tools, to perform static type checking
    across your entire codebase at key points in the developer workflow.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*利用自动化静态类型检查工具*部分，我们将更深入地探讨如何使用这些工具，在开发工作流程的关键点上对整个代码库进行静态类型检查。
- en: Type awareness in Clean Architecture
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构中的类型意识
- en: The introduction of type hints is particularly relevant to Clean Architecture.
    In the previous chapter, we discussed the importance of clear interfaces and dependency
    inversion. Type hints can play a crucial role in achieving these goals, making
    our architectural boundaries more explicit and easier to maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的引入对于Clean Architecture尤其相关。在前一章中，我们讨论了清晰接口和依赖倒置的重要性。类型提示可以在实现这些目标中发挥关键作用，使我们的架构边界更加明确且易于维护。
- en: 'Consider how type hints can enhance the `Shape` example we introduced in [*Chapter
    2*](Chapter_02.xhtml#_idTextAnchor040), here with a more complete utilization
    of type hints:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下类型提示如何增强我们在[*第二章*](Chapter_02.xhtml#_idTextAnchor040)中引入的`Shape`示例，这里使用类型提示的更完整利用：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s take a closer look at this example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个例子：
- en: The `area` method in the `Shape` class is annotated to return a `float`, clearly
    communicating the expected return type for all shape implementations.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape`类中的`area`方法被注解为返回一个`float`，清楚地传达了所有形状实现预期的返回类型。'
- en: The `Rectangle` and `Circle` classes specify that their constructors expect
    `float` parameters and return `None`. This `-> None` annotation explicitly indicates
    that constructors don’t return a value, which is implicit in Python but made clear
    through type hinting.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle`和`Circle`类指定它们的构造函数期望`float`参数并返回`None`。这个`-> None`注解明确指出构造函数不返回任何值，这在Python中是隐含的，但通过类型提示变得明确。'
- en: The concrete `area` methods in `Rectangle` and `Circle` are annotated to return
    `float`, adhering to the contract defined in the `Shape` abstract base class.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle`和`Circle`中的具体`area`方法被注解为返回`float`，遵循在`Shape`抽象基类中定义的合同。'
- en: The `AreaCalculator` class explicitly states that its `calculate_area` method
    expects a `Shape` object as an argument and returns a `float`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AreaCalculator`类明确指出其`calculate_area`方法期望一个`Shape`对象作为参数并返回一个`float`。'
- en: These type hints make the interfaces more explicit, helping to maintain Clean
    Architecture’s boundaries between components. It’s important to note that these
    type hints don’t enforce anything at runtime. Rather, they serve as documentation
    and enable static analysis tools to catch potential type errors before execution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型提示使接口更明确，有助于维护清洁架构组件之间的边界。需要注意的是，这些类型提示在运行时并不强制执行任何事情。相反，它们作为文档，并使静态分析工具能够在执行前捕获潜在的类型错误。
- en: 'They provide several benefits in a Clean Architecture context:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在清洁架构的上下文中，它们提供了几个好处：
- en: '**Clear interfaces**: Type hints make the contracts between different layers
    of your architecture explicit. In our example, it’s clear that any `Shape` must
    have an `area` method that returns a `float`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的接口**：类型提示使架构不同层之间的合同明确。在我们的例子中，很明显任何`Shape`都必须有一个返回`float`的`area`方法。'
- en: '**Dependency inversion**: They help enforce the Dependency Rule by clearly
    defining the abstract interfaces that higher-level modules depend on. The `AreaCalculator`
    depends on the abstract `Shape`, not on concrete implementations.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转**：它们通过明确定义高层模块所依赖的抽象接口来帮助执行依赖规则。《AreaCalculator》依赖于抽象的`Shape`，而不是具体的实现。'
- en: '**Testability**: Type hints make it easier to create and use mock objects that
    conform to expected interfaces. For testing, we could easily create a mock `Shape`
    that adheres to the documented interface requirements.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：类型提示使创建和使用符合预期接口的模拟对象变得更容易。对于测试，我们可以轻松创建一个符合记录接口要求的模拟`Shape`。'
- en: '**Maintainability**: As your project grows, type hints serve as living documentation,
    making it easier for developers to understand and modify the code. They provide
    immediate insight into the expected types of method parameters and return values.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：随着项目的增长，类型提示作为活文档，使开发者更容易理解和修改代码。它们提供了对方法参数和返回值预期类型的即时洞察。'
- en: By leveraging type hints in this way, we create a more robust implementation
    of Clean Architecture. The explicitly documented interfaces and clear dependencies
    make our code more self-documenting and help catch type-related issues early through
    static analysis. As we build more complex systems, these benefits compound, resulting
    in a codebase that’s easier to understand, modify, and extend. In the next section,
    we’ll explore some challenges and considerations to keep in mind when integrating
    type hints into your Clean Architecture designs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式利用类型提示，我们创建了一个更健壮的清洁架构实现。明确记录的接口和清晰的依赖关系使我们的代码更具自文档性，并通过静态分析在早期捕获类型相关的问题。随着我们构建更复杂的系统，这些好处会累积，导致代码库更容易理解、修改和扩展。在下一节中，我们将探讨在将类型提示集成到您的清洁架构设计中时需要考虑的一些挑战和注意事项。
- en: Challenges and considerations
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战和考虑因素
- en: 'When leveraging type hints in your Python projects, it’s important to be aware
    of several key considerations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Python项目中利用类型提示时，重要的是要意识到几个关键考虑因素：
- en: They don’t replace the need for proper testing and error handling
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们并不取代对适当测试和错误处理的必要性
- en: There’s a learning curve for developers new to static typing concepts
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新接触静态类型概念的开发者来说，存在一个学习曲线。
- en: Planned incorporation into your team’s development workflow and **continuous
    integration, continuous deployment** (**CI/CD**) pipeline is essential for successful
    adoption
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划将其纳入团队的开发工作流程和**持续集成，持续部署**（**CI/CD**）管道对于成功采用至关重要。
- en: As we delve deeper into Python’s typing system in the following sections and
    the remainder of the book, we’ll explore how to leverage these features to create
    more robust, maintainable, and self-documenting Clean Architecture implementations.
    We’ll see how type awareness can help us create clearer boundaries between architectural
    layers, make our dependencies more explicit, and catch potential issues earlier
    in the development process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节和本书的剩余部分，我们将深入探讨如何利用这些特性来创建更健壮、可维护和自文档化的 Clean Architecture 实现。我们将看到类型意识如何帮助我们创建更清晰的架构层边界，使我们的依赖关系更明确，并在开发过程中早期捕捉潜在问题。
- en: Remember, the goal is not to turn Python into a statically typed language but
    to use type awareness as a tool to enhance our Clean Architecture designs. By
    the end of this chapter, you’ll have a solid understanding of how to balance Python’s
    dynamic nature with the benefits of type awareness in your Clean Architecture
    implementations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标不是将 Python 转变为静态类型语言，而是将类型意识作为一个工具来增强我们的 Clean Architecture 设计。到本章结束时，你将牢固地理解如何平衡
    Python 的动态特性与 Clean Architecture 实现中类型意识的好处。
- en: Leveraging Python’s typing system
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Python 的类型系统
- en: In the realm of Clean Architecture, the role of a robust type system extends
    far beyond simple error prevention. It serves as a powerful tool for expressing
    and enforcing architectural boundaries, supporting key principles such as abstraction,
    polymorphism, and dependency inversion. Python’s typing system, when leveraged
    effectively, becomes an invaluable asset in implementing these crucial concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clean Architecture 的领域内，强大类型系统的角色远远超出了简单的错误预防。它作为表达和强制架构边界的强大工具，支持诸如抽象、多态和依赖倒置等关键原则。当有效地利用时，Python
    的类型系统成为实现这些关键概念的无价资产。
- en: As we start to consider more advanced features of Python’s typing system, we’ll
    see how they can significantly enhance our Clean Architecture implementations.
    These features allow us to create more expressive and precise interfaces between
    different layers of our application, leading to code that is not only more robust
    but also more self-documenting and maintainable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始考虑 Python 类型系统的更高级特性时，我们将看到它们如何显著增强我们的 Clean Architecture 实现。这些特性允许我们在应用程序的不同层之间创建更表达性和精确的接口，从而产生不仅更健壮，而且更自文档化和可维护的代码。
- en: In this section, we’ll explore a range of typing features, from type aliases
    and union types to literal and `TypedDict` types. We’ll then see how these can
    be applied to support SOLID principles in our Clean Architecture designs. By the
    end of this section, you’ll have a comprehensive understanding of how to use Python’s
    type system to create cleaner, more maintainable architectural boundaries.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一系列类型特性，从类型别名和联合类型到字面量和 `TypedDict` 类型。然后我们将看到这些如何应用于支持 Clean Architecture
    设计中的 SOLID 原则。到本节结束时，你将全面理解如何使用 Python 的类型系统来创建更干净、更可维护的架构边界。
- en: We’ll start with a review of basic type hinting, then delve into more advanced
    features, and finally see how these features support SOLID principles in the context
    of Clean Architecture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本类型提示的回顾开始，然后深入探讨更高级的特性，最后我们将看到这些特性如何在 Clean Architecture 的背景下支持 SOLID
    原则。
- en: 'Basic type hinting: from simple types to containers'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型提示：从简单类型到容器
- en: 'We’ve already seen how to use basic type hints for simple types. Let’s quickly
    recap the syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何为简单类型使用基本类型提示。让我们快速回顾一下语法：
- en: 'For integers: `count: int`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于整数：`count: int`'
- en: 'For floating-point numbers: `price: float`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于浮点数：`price: float`'
- en: 'For strings: `name: str`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于字符串：`name: str`'
- en: 'For booleans: `is_active: bool`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于布尔值：`is_active: bool`'
- en: 'For function annotations: follow the `def function_name(parameter: type) ->
    return_type:` pattern'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于函数注解：遵循 `def function_name(parameter: type) -> return_type:` 模式'
- en: 'Now, let’s look at how we can use type hints with container types such as lists
    and dictionaries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用类型提示与容器类型，如列表和字典一起使用：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s take a closer look at this example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个例子：
- en: '`list[str]` indicates that items should be a list of strings'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list[str]` 表示项目应该是一个字符串列表'
- en: '`list[int]` specifies that quantities should be a list of integers'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list[int]` 表示数量应该是一个整数列表'
- en: '`-> dict[str, int]` tells us that the function returns a dictionary with string
    keys and integer values'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-> dict[str, int]` 告诉我们该函数返回一个具有字符串键和整数值的字典'
- en: These type hints provide clear information about the expected structure of the
    input and output data, which is particularly valuable in Clean Architecture, where
    we often deal with complex data structures passing between different layers of
    the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型提示提供了关于输入和输出数据预期结构的清晰信息，这在Clean Architecture中尤其有价值，因为在Clean Architecture中，我们经常处理在不同应用层之间传递的复杂数据结构。
- en: '**Why do I sometimes see** `list` **and other times** `List` **in Python code?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我有时会看到** `list` **而有时会看到** `List` **在Python代码中？**'
- en: You might notice that some Python code uses `list` (lowercase) while other code
    uses `List` (capitalized) for type annotations. This is because support for built-in
    generic types was introduced in Python 3.9\. Before that, you needed to import
    the `List` stand-in type from the typing package. For code in Python 3.9+, you
    can simply use built-in collection names such as `list` and `dict`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，一些Python代码使用`list`（小写）而其他代码使用`List`（大写）进行类型注解。这是因为Python 3.9引入了对内置泛型类型的支持。在此之前，你需要从`typing`包中导入`List`占位符类型。对于Python
    3.9+的代码，你可以简单地使用内置的集合名称，如`list`和`dict`。
- en: In Clean Architecture, such type hints are especially useful when defining interfaces
    between different layers of the application. They provide a clear contract for
    data passing between the Domain layer, use cases, and external interfaces, helping
    to maintain clean boundaries and reduce the risk of data inconsistencies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clean Architecture中，这种类型提示在定义应用不同层之间的接口时特别有用。它们为领域层、用例和外部接口之间的数据传递提供了清晰的合同，有助于保持清晰的边界并降低数据不一致的风险。
- en: As we move forward, we’ll see how more advanced typing features can further
    enhance our ability to express complex relationships and constraints, supporting
    robust Clean Architecture implementations in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将看到更高级的类型功能如何进一步增强我们表达复杂关系和约束的能力，支持健壮的Python Clean Architecture实现。
- en: 'Sequence: flexibility in collection types'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sequence：集合类型的灵活性
- en: The **Sequence** type hint from the typing module is a powerful tool for expressing
    collections in a way that aligns well with the SOLID principles, particularly
    the Liskov Substitution Principle and the Open–Closed Principle.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块中的`Sequence`类型提示是一个强大的工具，可以以与SOLID原则（特别是Liskov替换原则和开放-封闭原则）良好对齐的方式表达集合。'
- en: 'Here’s an example demonstrating its use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示其使用的例子：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `Sequence` instead of a specific type such as `List` or `Tuple` offers
    several advantages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Sequence`而不是特定的类型，如`List`或`Tuple`，具有几个优点：
- en: '**Liskov Substitution Principle**: `Sequence` allows the function to work with
    any sequence type (lists, tuples, and custom sequence classes) without breaking
    the contract'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**：`Sequence`允许函数与任何序列类型（列表、元组和自定义序列类）一起工作，而不会破坏合同'
- en: '**Open–Closed Principle**: The `calculate_total` function is open for extension
    (it can work with new sequence types) but closed for modification (we don’t need
    to change the function to support new types)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放-封闭原则**：`calculate_total`函数对扩展是开放的（它可以与新的序列类型一起工作），但对修改是封闭的（我们不需要更改函数以支持新类型）'
- en: '**Interface Segregation Principle**: By using `Sequence`, we’re only requiring
    the minimal interface needed (iteration over elements), rather than committing
    to a specific collection type with potentially unnecessary methods'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：通过使用`Sequence`，我们只要求所需的最小接口（元素迭代），而不是承诺使用可能不必要的特定集合类型'
- en: In Clean Architecture, the `Sequence` type hint proves valuable across various
    layers. In the Use Case layer, it facilitates processing collections of entities
    or value objects. In the Interface Adapters layer, it enables flexible APIs that
    work with various collection types. In the Domain layer, `Sequence` expresses
    the need for a collection without specifying its implementation, maintaining separation
    of concerns. This versatility makes `Sequence` a powerful tool for creating adaptable
    and maintainable Clean Architecture implementations in Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clean Architecture中，`Sequence`类型提示在各个层之间都非常有价值。在用例层，它简化了实体或值对象的集合处理。在接口适配器层，它实现了与各种集合类型协同工作的灵活API。在领域层，`Sequence`表达了需要集合的需求，但没有指定其实施，保持了关注点的分离。这种多功能性使`Sequence`成为在Python中创建适应性强且可维护的Clean
    Architecture实现的强大工具。
- en: Union and Optional types
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合和可选类型
- en: 'In Clean Architecture, we often need to handle multiple possible types or optional
    values, especially at the boundaries between layers. **Union types** and **Optional
    types** are perfect for these scenarios:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clean Architecture 中，我们经常需要处理多个可能类型或可选值，尤其是在层之间的边界。**联合类型**和**可选类型**非常适合这些场景：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Union` types allow a value to be one of several types, while `Optional` is
    a shorthand for `Union[Some_Type, None]`. These constructs are particularly useful
    in Clean Architecture for creating flexible interfaces between layers while maintaining
    type safety.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union` 类型允许一个值是几种类型之一，而 `Optional` 是 `Union[Some_Type, None]` 的简写。这些结构在 Clean
    Architecture 中创建灵活的层之间接口的同时保持类型安全性特别有用。'
- en: 'It should be noted that in Python 3.10+, the union syntax was simplified to
    a concise literal use of the pipe character (`|`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，在 Python 3.10+ 中，联合语法被简化为简洁的管道字符（`|`）的文本使用：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding line would be simplified to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行可以简化为以下形式：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Literal types
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字类型
- en: '**Literal types** allow us to specify exact values that a variable can take.
    This is especially useful in Clean Architecture for enforcing specific values
    at interface boundaries:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**文字类型**允许我们指定变量可以取的确切值。这在 Clean Architecture 中强制在接口边界上执行特定值时特别有用：'
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Literal` types help in creating more precise interfaces, reducing the chance
    of invalid data propagating through the system. This aligns well with Clean Architecture’s
    emphasis on clear boundaries and contracts between layers.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Literal` 类型有助于创建更精确的接口，减少无效数据通过系统的可能性。这与 Clean Architecture 强调的层之间清晰的边界和契约相吻合。'
- en: Type aliases
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: '**Type aliases** help in simplifying complex type annotations, making our code
    more readable and maintainable. This is particularly useful in Clean Architecture
    when dealing with complex domain models or data transfer objects.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名** 有助于简化复杂的类型注解，使我们的代码更易于阅读和维护。这在 Clean Architecture 中处理复杂的领域模型或数据传输对象时特别有用。'
- en: 'Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s take a closer look at this code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码：
- en: '`UserDict` is a type alias for `dict[str, str]`, representing a user object
    with string keys and values'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDict` 是 `dict[str, str]` 的类型别名，表示具有字符串键和值的用户对象'
- en: '`UserList` is a type alias for `list[UserDict]`, representing a list of user
    dictionaries'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserList` 是 `list[UserDict]` 的类型别名，表示用户字典的列表'
- en: Type aliases provide more readable names for complex types, improving code clarity
    without creating new types. They enable us to write code that is both expressive
    and aligned with the principles of Clean Architecture, promoting separation of
    concerns, maintainability, and clarity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名提供了更易于阅读的复杂类型名称，提高了代码的清晰度，而没有创建新类型。它们使我们能够编写既具有表达性又与 Clean Architecture
    原则一致、促进关注点分离、可维护性和清晰性的代码。
- en: NewType
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NewType
- en: '**NewType** creates distinct types, providing additional type safety. This
    is valuable in Clean Architecture for defining clear domain concepts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**NewType** 创建独特的类型，提供额外的类型安全性。这在 Clean Architecture 中定义清晰的领域概念时非常有价值：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`NewType` creates distinct types that are recognized by static type checkers,
    preventing accidental mixing of similar but conceptually different values. This
    helps catch potential errors early in the development process and enhances the
    overall type safety of your Clean Architecture implementation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewType` 创建独特的类型，这些类型被静态类型检查器识别，防止类似但概念上不同的值的意外混合。这有助于在开发早期阶段捕获潜在的错误，并增强 Clean
    Architecture 实现的整体类型安全性。'
- en: Both type aliases and `NewType` align well with Clean Architecture principles
    by improving code readability, ensuring type safety across layer boundaries, and
    clearly defining domain concepts. This leads to more expressive, type-safe, and
    maintainable Clean Architecture implementations in Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名和 `NewType` 都很好地与 Clean Architecture 原则相吻合，通过提高代码可读性，确保层之间的类型安全性，并清晰地定义领域概念。这导致在
    Python 中实现更具表达性、类型安全和可维护的 Clean Architecture。
- en: The Any type
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意类型
- en: 'The **Any type** is a special type hint that essentially tells the type checker
    to allow any type. It’s used when you want to indicate that a variable can be
    of any type, or when you’re dealing with code where the type is genuinely not
    known or could vary widely.  We can see its use in this general logging example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**任意类型**是一个特殊的类型提示，它本质上告诉类型检查器允许任何类型。当您想表示一个变量可以是任何类型，或者当您处理类型真正未知或可能广泛变化的代码时，会用到它。我们可以在以下通用日志示例中看到它的用法：'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Clean Architecture, we generally aim to be as specific as possible about
    types, especially at layer boundaries. The `Any` type should be seen as a last
    resort, often indicating a need for refactoring or a more specific type definition.
    It’s most appropriate when interfacing with external systems where the type is
    truly unknown or highly variable. Within your own code, see the use of `Any` as
    a signal to refactor the code to the use of specific types versus the use of the
    catch-all `Any` type.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clean Architecture中，我们通常力求尽可能具体地指定类型，尤其是在层边界处。`Any`类型应被视为最后的手段，通常表明需要重构或更具体的类型定义。它最适用于与外部系统接口，那里的类型真正未知或高度可变。在你的代码内部，将`Any`的使用视为重构代码到使用特定类型而不是使用通用的`Any`类型的信号。
- en: These advanced typing features provide powerful tools for implementing Clean
    Architecture in Python. They allow us to create more expressive, precise, and
    self-documenting interfaces between different layers of our application. As we
    move forward, we’ll explore how these features can be applied to support SOLID
    principles in our Clean Architecture designs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级类型功能为在Python中实现Clean Architecture提供了强大的工具。它们允许我们在应用程序的不同层之间创建更具有表达性、精确性和自文档化的接口。随着我们继续前进，我们将探讨这些功能如何应用于支持Clean
    Architecture设计中的SOLID原则。
- en: Leveraging automated static type-checking tools
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用自动化静态类型检查工具
- en: 'As we’ve explored Python’s typing system and its benefits for Clean Architecture,
    it’s crucial to understand how to effectively apply these type hints in practice.
    Python, being a dynamically typed language, doesn’t enforce type-checking at runtime.
    This is where automated static type-checking tools come into play, bridging the
    gap between Python’s dynamic nature and the benefits of static typing. This approach
    offers several key benefits:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所探讨的，Python的类型系统和它在Clean Architecture中的好处，了解如何在实践中有效地应用这些类型提示至关重要。Python作为一个动态类型语言，在运行时不强制执行类型检查。这就是自动化静态类型检查工具发挥作用的地方，它弥合了Python的动态特性和静态类型的好处之间的差距。这种方法提供了几个关键的好处：
- en: '**Early error detection**: Catch type-related issues before runtime, reducing
    the likelihood of bugs in production'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期错误检测**：在运行时之前捕获类型相关的问题，降低生产中出现bug的可能性'
- en: '**Improved code quality**: Enforce consistent use of types across your project,
    leading to more robust and self-documenting code'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：在整个项目中强制使用类型的一致性，从而产生更健壮和自文档化的代码'
- en: '**Enhanced refactoring**: Make large-scale code changes with more confidence,
    as the type checker can identify many of the places that need to be updated'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强重构**：在更大规模的代码更改中更有信心，因为类型检查器可以识别许多需要更新的地方'
- en: '**Better IDE support**: Enable more accurate code completion, navigation, and
    refactoring tools in your development environment'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的IDE支持**：在你的开发环境中启用更精确的代码补全、导航和重构工具'
- en: These benefits are particularly valuable in Clean Architecture implementations,
    where maintaining clear boundaries between layers and ensuring the correctness
    of data flow is paramount.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些好处在Clean Architecture的实现中尤其有价值，在保持层之间的清晰边界和确保数据流的正确性方面至关重要。
- en: In this section, we’ll focus on how to leverage these automated tools to enforce
    type consistency, catch errors early, and improve the overall development experience.
    We’ll use `mypy`’s command line interface (CLI) but then use another tool as an
    extension to the VS Code IDE.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍如何利用这些自动化工具来强制类型一致性、早期捕获错误并提高整体开发体验。我们将使用`mypy`的命令行界面（CLI），但随后将使用另一个工具作为VS
    Code IDE的扩展。
- en: The mypy CLI
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mypy命令行界面
- en: Mypy is a powerful static type checker that can be run directly from the command
    line. This makes it easy to integrate into your development workflow and deployment
    pipelines. Let’s walk through how to use `mypy` and interpret its output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy是一个强大的静态类型检查器，可以直接从命令行运行。这使得它很容易集成到你的开发工作流程和部署管道中。让我们一步步了解如何使用`mypy`并解释其输出。
- en: 'First, you’ll need to install `mypy`. Since it’s a Python module, you can easily
    install it using `pip`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装`mypy`。由于它是一个Python模块，你可以使用`pip`轻松安装它：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once installed, you can use `mypy` to check your Python files for type errors.
    Let’s look at a simple example. Assume you have a Python file named `user_service.py`
    with the following content:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用`mypy`检查你的Python文件中的类型错误。让我们看看一个简单的例子。假设你有一个名为`user_service.py`的Python文件，其内容如下：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To check this file with `mypy`, run the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`mypy`检查此文件，请运行以下命令：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s break down what `mypy` is telling us:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下`mypy`告诉我们什么：
- en: It identifies the file (`user_service.py`) and the line number (`9`) where the
    error occurs
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它识别出发生错误的文件（`user_service.py`）和行号（`9`）
- en: 'It describes the error: we’re passing a string (`"123"`) to `get_user`, but
    the function expects an integer'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它描述了错误：我们向 `get_user` 函数传递了一个字符串（`"123"`），但该函数期望一个整数
- en: It categorizes the error as an `[arg-type]` issue, indicating a problem with
    argument types
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将错误分类为 `[arg-type]` 问题，表明存在参数类型问题
- en: This output is incredibly valuable. It catches a type mismatch that could lead
    to runtime errors, allowing us to fix it before the code is even executed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出非常有价值。它捕捉到可能导致运行时错误的类型不匹配，使我们能够在代码执行之前修复它。
- en: 'We can correct the error by changing `user = get_user("123")` to `user = get_user(123)`
    and then rerun mypy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `user = get_user("123")` 更改为 `user = get_user(123)` 然后重新运行 mypy 来纠正错误：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, `mypy` reports no issues, confirming that our type annotations are consistent
    with how we’re using the functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`mypy` 没有报告任何问题，确认我们的类型注解与我们使用函数的方式一致。
- en: Configuring mypy
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 mypy
- en: While `mypy` works well out of the box, you can customize its behavior using
    a configuration file. This is particularly useful for large projects or when you
    want to gradually adopt type checking.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `mypy` 默认工作良好，但您可以使用配置文件自定义其行为。这对于大型项目或您想逐步采用类型检查时特别有用。
- en: 'Create a file named `mypy.ini` in your project root:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目根目录中创建一个名为 `mypy.ini` 的文件：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This configuration does the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置执行以下操作：
- en: Ignores missing imports, which is useful when working with third-party libraries
    without type stubs
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略缺失的导入，这在处理没有类型存根的第三方库时非常有用
- en: Enables strict checking of `Optional` types
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用对 `Optional` 类型的严格检查
- en: 'Warns about redundant type casts and unused `type: ignore` comments'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '警告关于冗余的类型转换和未使用的 `type: ignore` 注释'
- en: Warns when a function returns `Any` implicitly
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数隐式返回 `Any` 时发出警告
- en: Alerts you to unreachable code
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告不可达的代码
- en: With this configuration, `mypy` will provide more comprehensive checking, helping
    you catch a wider range of potential issues in your Clean Architecture implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，`mypy` 将提供更全面的检查，帮助您在 Clean Architecture 实现中捕捉到更广泛的潜在问题。
- en: By regularly running `mypy` as part of your development process, you can catch
    type-related issues early, ensuring that your Clean Architecture layers interact
    correctly and maintain their intended boundaries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定期将 `mypy` 作为开发过程的一部分运行，您可以早期捕捉到与类型相关的问题，确保您的 Clean Architecture 层能够正确交互并保持其预期的边界。
- en: The configuration options for `mypy` are vast and can be tailored to fit the
    needs of your specific project. For a complete list of available options and their
    descriptions, refer to the official `mypy` documentation at [https://mypy.readthedocs.io/en/stable/config_file.html](https://mypy.readthedocs.io/en/stable/config_file.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypy` 的配置选项非常广泛，可以根据您特定项目的需求进行定制。有关可用选项及其描述的完整列表，请参阅官方 `mypy` 文档[https://mypy.readthedocs.io/en/stable/config_file.html](https://mypy.readthedocs.io/en/stable/config_file.html)。'
- en: Mypy in deployment pipelines
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署管道中的 Mypy
- en: Integrating `mypy` into your deployment pipeline is a crucial step in ensuring
    type consistency across your project, especially in a Clean Architecture context
    where maintaining clear boundaries between layers is paramount.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `mypy` 集成到您的部署管道中是确保项目类型一致性至关重要的步骤，尤其是在 Clean Architecture 的背景下，保持层之间的清晰边界至关重要。
- en: 'While the specific implementation details may vary depending on your chosen
    CI/CD tool, the fundamental concept remains the same: run `mypy` as part of your
    automated checks before deploying your code. Given that `mypy` operates via a
    straightforward CLI, incorporating it into most deployment pipelines is relatively
    straightforward.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具体实现细节可能因您选择的 CI/CD 工具而异，但基本概念保持不变：在部署代码之前，将 `mypy` 作为自动化检查的一部分运行。鉴于 `mypy`
    通过简单的 CLI 运行，将其纳入大多数部署管道相对简单。
- en: 'For instance, you might run `mypy` checks in the following instances:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能在这些情况下运行 `mypy` 检查：
- en: After each commit push
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次提交推送之后
- en: As part of pull request validation
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为拉取请求验证的一部分
- en: Before merging into the main branch
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在合并到主分支之前
- en: Prior to deploying to staging or production environments
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署到预发布或生产环境之前
- en: This approach helps catch type-related issues early in the development process,
    reducing the likelihood of type errors making their way into production.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有助于在开发过程中早期捕捉到与类型相关的问题，降低类型错误进入生产的风险。
- en: 'As an example, here’s a simple GitHub Actions workflow that runs `mypy` followed
    by unit tests:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个简单的GitHub Actions工作流程，它运行`mypy`然后是单元测试：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This workflow does the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流程执行以下操作：
- en: Triggers on push or pull request events
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推送或拉取请求事件时触发
- en: Sets up a Python environment
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Python环境
- en: Installs necessary dependencies (including `mypy` and `pytest`)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装必要的依赖项（包括`mypy`和`pytest`）
- en: Runs `mypy` on the entire project
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个项目中运行`mypy`
- en: Runs the project’s unit tests
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行项目的单元测试
- en: By including `mypy` in your deployment pipeline, you ensure that all code changes
    are type-checked before they’re integrated, helping maintain the integrity of
    your Clean Architecture implementation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在部署管道中包含`mypy`，您确保所有代码更改在集成之前都经过类型检查，有助于维护Clean Architecture实现的完整性。
- en: Remember, while this example uses GitHub Actions, the principle applies to any
    CI/CD tool. The key is to run mypy as part of your automated checks, leveraging
    its CLI to integrate smoothly into your existing deployment processes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然此示例使用GitHub Actions，但原则适用于任何CI/CD工具。关键是运行mypy作为您自动化检查的一部分，利用其CLI来无缝集成到现有的部署流程中。
- en: Leveraging type hints in IDEs for improved development experience
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在IDE中使用类型提示以改善开发体验
- en: While having a deployment pipeline with type checking is essential for maintaining
    code quality, the most effective approach involves catching type issues in real
    time as the code is being written. This immediate feedback allows developers to
    address type inconsistencies instantly, reducing the time and effort spent on
    fixing issues later in the development process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有带有类型检查的部署管道对于维护代码质量至关重要，但最有效的方法是在编写代码时实时捕捉类型问题。这种即时反馈允许开发者立即解决类型不一致，减少在开发后期修复问题的时间和精力。
- en: Modern IDEs have embraced this approach, leveraging type hints to provide an
    enhanced coding experience with immediate type-checking feedback. While this functionality
    is available in most popular Python IDEs, we’ll focus on VS Code as our primary
    example due to its widespread use and robust Python support.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现代集成开发环境（IDEs）已经采纳了这种方法，利用类型提示来提供带有即时类型检查反馈的增强编码体验。虽然这种功能在大多数流行的Python IDEs中都有提供，但我们将重点关注VS
    Code，因为它被广泛使用，并且对Python的支持非常强大。
- en: In VS Code, the **Pylance** extension has become the preferred tool for Python
    type checking. Pylance, which uses `pyright` as its type-checking engine, integrates
    seamlessly into VS Code, offering real-time type-checking along with other advanced
    features that significantly improve the Python development experience.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中，**Pylance**扩展已成为Python类型检查的首选工具。Pylance使用`pyright`作为其类型检查引擎，无缝集成到VS
    Code中，提供实时类型检查以及其他显著改善Python开发体验的高级功能。
- en: 'With Pylance installed in VS Code, developers receive instant visual cues regarding
    any type issues:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中安装了Pylance后，开发者会立即收到有关任何类型问题的视觉提示：
- en: '![Figure 3.1: VS Code with the Pylance extension installed](img/B31577_03_1.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：安装了Pylance扩展的VS Code](img/B31577_03_1.png)'
- en: 'Figure 3.1: VS Code with the Pylance extension installed'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：安装了Pylance扩展的VS Code
- en: In *Figure 3.1*, we see that the use of a string where an integer is expected
    is decorated in the IDE editor with a precise explanation of what the issue is.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.1*中，我们看到在IDE编辑器中，期望整数的地方使用了字符串，并且对问题进行了精确的解释。
- en: This real-time feedback creates a powerful synergy with the type hints we’ve
    incorporated into our Clean Architecture implementation. It allows developers
    to maintain strict type consistency across architectural boundaries as they code,
    rather than relying solely on post-development checks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实时反馈与我们在Clean Architecture实现中集成的类型提示产生了强大的协同作用。它允许开发者在编码时维护严格的类型一致性，而不是仅仅依赖开发后的检查。
- en: You can install the Pylance extension from the VS Code marketplace ([https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)),
    in addition to reading more about its features and configuration.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从VS Code市场（[https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)）安装Pylance扩展，同时阅读更多关于其功能和配置的信息。
- en: Additional type-checking features
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的类型检查功能
- en: While real-time feedback and deployment pipeline checks are crucial, there are
    additional features that can enhance your type-checking workflow.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实时反馈和部署管道检查至关重要，但还有一些额外的功能可以增强您的类型检查工作流程。
- en: The Problems tab in VS Code
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VS Code中的“问题”标签页
- en: VS Code offers a **Problems** tab that aggregates all issues in your code, including
    type errors detected by Pylance. This tab provides a comprehensive overview of
    type inconsistencies across your project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code提供了一个**问题**标签页，它汇总了你的代码中的所有问题，包括由Pylance检测到的类型错误。此标签页提供了项目类型不一致的全面概述。
- en: '![Figure 3.2: VS Code Problems tab](img/B31577_03_2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：VS Code问题标签页](img/B31577_03_2.png)'
- en: 'Figure 3.2: VS Code Problems tab'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：VS Code问题标签页
- en: In *Figure 3.2*, we see the aggregation of the types checks we saw inline earlier.
    Developers can use this tab as a final check before committing code, ensuring
    no type issues are overlooked.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.2*中，我们看到的是我们之前内联看到的类型检查的汇总。开发者可以使用此标签页作为提交代码前的最终检查，确保没有遗漏任何类型问题。
- en: Git pre-commit hooks
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git预提交钩子
- en: Git supports pre-commit hooks, allowing you to run checks automatically before
    each commit. You can configure these hooks to run `mypy` and unit tests, preventing
    commits that introduce type errors or break existing functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Git支持预提交钩子，允许你在每次提交前自动运行检查。你可以配置这些钩子来运行`mypy`和单元测试，防止引入类型错误或破坏现有功能的提交。
- en: 'For more information on setting up Git hooks, refer to the official Git documentation:
    [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设置Git钩子的更多信息，请参阅官方Git文档：[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)
- en: By incorporating these additional features into your workflow, you create multiple
    layers of type-checking in your development process. This comprehensive approach
    helps maintain the integrity of your Clean Architecture implementation, catching
    type inconsistencies at every stage from writing code to committing changes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些附加功能纳入你的工作流程，你在开发过程中创建了多个类型检查层。这种全面的方法有助于维护Clean Architecture实现的完整性，从编写代码到提交更改的每个阶段都能捕捉到类型不一致。
- en: Gradual adoption strategy
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐进式采用策略
- en: Introducing static type checking in Python projects can sometimes face resistance,
    particularly from developers accustomed to Python’s dynamic nature. To ensure
    a smooth transition, it’s crucial to work collaboratively with your team, clearly
    communicating the rationale and benefits of type hinting.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python项目中引入静态类型检查有时会遇到阻力，尤其是来自习惯于Python动态特性的开发者。为了确保平稳过渡，与团队协作并清楚地传达类型提示的理由和好处至关重要。
- en: 'Here’s a strategy for gradual adoption:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个逐步采用策略：
- en: Conduct a team meeting to discuss and formulate a plan for incorporating type
    checking.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举行团队会议，讨论并制定一个纳入类型检查的计划。
- en: Implement a policy requiring type hints for all new code.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施一项政策，要求所有新代码都必须有类型提示。
- en: 'Minimize initial disruption by configuring `mypy` to ignore specific modules
    or packages. This can be done in the `mypy` configuration file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过配置`mypy`以忽略特定模块或包来最小化初始干扰。这可以在`mypy`配置文件中完成：
- en: '[PRE19]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create scheduled maintenance tasks to progressively add type hints to existing
    code, prioritizing critical paths.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建计划维护任务，逐步向现有代码添加类型提示，优先考虑关键路径。
- en: 'By employing these tools and strategies, you can substantially improve the
    robustness and maintainability of your Clean Architecture implementations. The
    most effective approach combines checks at various stages: real-time feedback
    in the IDE, pre-commit hooks, and validation in the deployment pipeline. This
    multi-layered strategy ensures early error detection, enhances code navigation,
    and maintains consistent type checking throughout the development life cycle.
    Ultimately, this comprehensive approach leads to more reliable, maintainable,
    and scalable Python applications, fully leveraging the power of Python’s type
    system in your Clean Architecture projects.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这些工具和策略，你可以显著提高你的Clean Architecture实现的健壮性和可维护性。最有效的方法是在各个阶段进行检查：IDE中的实时反馈、预提交钩子和部署管道中的验证。这种多层次策略确保了早期错误检测，增强了代码导航，并在整个开发周期中保持类型检查的一致性。最终，这种全面的方法导致更可靠、可维护和可扩展的Python应用程序，充分利用Python类型系统在Clean
    Architecture项目中的力量。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored type awareness in Python’s dynamic environment
    and its role in strengthening Clean Architecture implementations. We learned how
    to leverage Python’s typing system and type hints to create more robust, self-documenting
    code and discovered the value of automated static type-checking tools in catching
    errors early.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Python 动态环境中的类型意识及其在加强 Clean Architecture 实现中的作用。我们学习了如何利用 Python
    的类型系统和类型提示来创建更健壮、自文档化的代码，并发现了自动化静态类型检查工具在早期捕获错误的价值。
- en: You gained skills in implementing type hints in functions, classes, and variables,
    improving code clarity and reliability. You also learned how to set up and use
    static type-checking tools such as `mypy` to verify type consistency in your projects.
    These skills are fundamental to creating maintainable and scalable Clean Architecture
    implementations in Python, enhancing code quality and alignment with Clean Architecture
    principles.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您掌握了在函数、类和变量中实现类型提示的技能，提高了代码的清晰度和可靠性。您还学习了如何设置和使用静态类型检查工具，如 `mypy`，以验证项目中的类型一致性。这些技能对于在
    Python 中创建可维护和可扩展的 Clean Architecture 实现至关重要，可以提升代码质量并与 Clean Architecture 原则保持一致。
- en: 'In the next chapter, *Domain-Driven Design: Crafting the Core Business Logic*,
    we’ll build upon type-enhanced Python and the SOLID principles from [*Chapter
    2*](Chapter_02.xhtml#_idTextAnchor040). We’ll explore the Domain layer of Clean
    Architecture, learning how to model and implement core business logic that’s independent
    of external concerns. Using a personal task management application as an example,
    we’ll apply type awareness techniques and SOLID principles to create a robust,
    well-structured domain model, setting the stage for a truly clean and maintainable
    architecture.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，*领域驱动设计：构建核心业务逻辑*，我们将基于增强类型的 Python 和来自 [*第二章*](Chapter_02.xhtml#_idTextAnchor040)
    的 SOLID 原则进行探讨。我们将探索 Clean Architecture 的领域层，学习如何建模和实现独立于外部关注的核心业务逻辑。以个人任务管理应用为例，我们将应用类型意识技术和
    SOLID 原则来创建一个健壮、结构良好的领域模型，为真正清洁和可维护的架构奠定基础。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Python Type Checking (Guide)* ([https://realpython.com/python-type-checking/](https://realpython.com/python-type-checking/))'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 类型检查（指南）* ([https://realpython.com/python-type-checking/](https://realpython.com/python-type-checking/))'
- en: '*Type Hints Cheat Sheet* ([https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html))'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型提示速查表* ([https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html))'
- en: '*Continuous Integration with Python: An Introduction* ([https://realpython.com/python-continuous-integration/](https://realpython.com/python-continuous-integration/))'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python 进行持续集成：入门指南* ([https://realpython.com/python-continuous-integration/](https://realpython.com/python-continuous-integration/))'
