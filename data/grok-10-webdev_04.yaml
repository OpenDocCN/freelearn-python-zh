- en: Chapter 4. Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 模型
- en: 'In Chapter 3, we learned how to display information on a web page by using
    views. In fact, as we saw, the view machinery is powerful enough to create complete
    applications, like our to-do list manager. We''ll now turn our attention to where
    the data for these views comes from: the content objects, or models that define
    Grok applications. Here''s a list of what we''ll cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们学习了如何通过使用视图在网页上显示信息。实际上，正如我们所看到的，视图机制足够强大，可以创建完整的应用程序，就像我们的待办事项列表管理器。现在，我们将注意力转向这些视图的数据来源：内容对象，或定义Grok应用程序的模型。以下是本章我们将涵盖的内容列表：
- en: What a model is and what relationship it has with views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型是什么以及它与视图有什么关系
- en: How to persist model data on the ZODB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在ZODB上持久化模型数据
- en: How to structure our code to maintain the separation of display logic from application
    logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何结构化我们的代码以保持显示逻辑与应用逻辑的分离
- en: What a container is and how to use one
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是什么以及如何使用它
- en: How to use multiple models and associate specific views to each
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用多个模型并将特定视图关联到每个模型
- en: How to use the Grok introspector to navigate models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Grok内省器导航模型
- en: Models and applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和应用程序
- en: 'Although the views do the actual work of showing our data and handling user
    interaction, they are just one possible way of displaying the data. In the previous
    chapter, we started with a very simple view with no styles or client-side scripting,
    and by the end of the chapter, we had a completely different looking application.
    What remained constant throughout was the thing we were working with: to-do lists.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管视图执行显示数据和处理用户交互的实际工作，但它们只是显示数据的一种可能方式。在前一章中，我们从一个非常简单的视图开始，没有任何样式或客户端脚本，到本章结束时，我们有了完全不同的应用程序。始终不变的是我们正在处理的东西：待办事项列表。
- en: 'Whenever we added lists or list items and checked off items, we were interacting
    with the model for our application, which in this case was defined with just two
    lines of code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们添加列表或列表项并勾选项目时，我们都在与应用程序的模型进行交互，在这个例子中，它只由两行代码定义：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A Grok application is composed of one or more models. The models can be simple
    Python objects, but generally use `grok.Model` as a base class. The main model
    of an application should inherit from `grok.Application` as well, which is what
    happens in the preceding code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Grok应用程序由一个或多个模型组成。这些模型可以是简单的Python对象，但通常使用`grok.Model`作为基类。应用程序的主要模型也应该继承自`grok.Application`，这正是前面代码所发生的情况。
- en: The model contains the application data and all of the logic that's not directly
    related to how this data is shown. In the case of our to-do list manager, the
    model consists of only a `todolists` class attribute that holds all the lists
    and their items.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模型包含应用程序数据和所有与如何显示这些数据直接无关的逻辑。在我们的待办事项列表管理器中，模型仅由一个`todolists`类属性组成，它包含所有列表及其项目。
- en: Even though this model is so simple, the views work for the model and not the
    other way around. If we look at the code in both the `index` and `check` views,
    we'll see that every time something important happens the value of `self.context.todolists`
    is modified. As we mentioned before, all views have a `context` attribute that
    refers to their associated model. Through it, views can access all of the attributes
    of this model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个模型如此简单，视图是为模型工作而不是相反。如果我们查看`index`和`check`视图中的代码，我们会看到每次发生重要事件时，`self.context.todolists`的值都会被修改。正如我们之前提到的，所有视图都有一个`context`属性，它指向它们关联的模型。通过它，视图可以访问这个模型的所有属性。
- en: Storing model data
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储模型数据
- en: So far, we can create and manage lists successfully, but once we restart the
    application we lose all the data. We need a way to persist the information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以成功创建和管理列表，但一旦我们重新启动应用程序，我们就会丢失所有数据。我们需要一种方法来持久化信息。
- en: For web applications, this usually means creating some tables in a relational
    database and storing the information by using direct SQL queries or an **Object
    Relational Mapper** (**ORM**). An ORM is a good solution as it takes our objects
    and transparently stores their attributes in the corresponding tables. Each time
    we need to work with our objects, the ORM reassembles them from the database once
    again, without the need for us to worry about SQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，这通常意味着在关系型数据库中创建一些表，并通过直接SQL查询或**对象关系映射器**（**ORM**）来存储信息。ORM是一个很好的解决方案，因为它将我们的对象透明地存储在相应的表中。每次我们需要处理我们的对象时，ORM都会再次从数据库中重新组装它们，而无需我们担心SQL。
- en: 'Grok can store data in relational databases using plain SQL as well as a diverse
    range of ORMs for Python, such as SQLAlchemy ([http://www.sqlalchemy.org](http://www.sqlalchemy.org))
    or Storm ([https://storm.canonical.com](https://storm.canonical.com)). However,
    Grok gives us another interesting option that is a more natural fit for our Python
    objects, and can work even more transparently than ORMs: the **Zope Object Database**
    (**ZODB**).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Grok可以使用纯SQL以及多种Python ORM（如SQLAlchemy [http://www.sqlalchemy.org](http://www.sqlalchemy.org)
    或 Storm [https://storm.canonical.com](https://storm.canonical.com)）在关系数据库中存储数据。然而，Grok为我们提供了另一个更有趣的选项，它更适合我们的Python对象，并且可以比ORM更透明地工作：**Zope对象数据库**（**ZODB**）。
- en: The ZODB
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZODB
- en: We discussed the ZODB in the first chapter, where we mentioned that it is very
    well integrated with Grok. We'll show a simple example of storing data now, and
    come back to the details, later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第1章中讨论了ZODB，其中我们提到它与Grok集成得非常好。现在我们将展示一个存储数据的简单示例，稍后我们将回到细节。
- en: 'Right now, the to-do list manager application has its title defined inside
    the`<h1>` tag on the `index` template. Let''s give each application instance a
    `title` attribute, so that the user can set the title himself. First, we''ll replace
    the simplistic model definition that we have been using so far with more realistic
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，待办事项列表管理应用程序的标题定义在`index`模板中的`<h1>`标签内。让我们给每个应用程序实例一个`title`属性，这样用户就可以自己设置标题。首先，我们将用更现实的代码替换到目前为止我们所使用的简单模型定义：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have added an `__init__` method that is called when the application is created.
    Inside this method, we make sure that we call the superclass' `__init__` method
    as well, so that our method extends, rather than replaces the original code. We
    then define two instance attributes, `title` and `todolists`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个在应用程序创建时被调用的`__init__`方法。在这个方法内部，我们确保调用超类`__init__`方法，这样我们的方法扩展而不是替换原始代码。然后我们定义了两个实例属性，`title`和`todolists`。
- en: 'In Python, there are two kinds of objects: **mutable objects**, which can have
    their values changed, and **immutable objects**, that cannot. For immutable objects,
    such as strings or numbers, we gain automatic persistence in the ZODB merely by
    inheriting from `grok.Model`. In the case of the title, now we can transparently
    store it in the ZODB. The `todolists`, as they are stored inside a list (a mutable
    object), need a little more work, but we''ll get to them later.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有两种类型的对象：**可变对象**，其值可以更改，和**不可变对象**，其值不能更改。对于不可变对象，如字符串或数字，我们只需通过从`grok.Model`继承即可在ZODB中获得自动持久性。在标题的情况下，现在我们可以透明地将其存储在ZODB中。`todolists`（因为它们存储在一个列表中，一个可变对象）需要做更多的工作，但稍后我们会讨论。
- en: Changing the title dynamically
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态更改标题
- en: 'Now that we have a `title` attribute, we can modify the `index.pt` template
    to show that, instead of the old text. Both the`<title>` and`<h1>` tags need a
    `tal:content` statement, like in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`title`属性，我们可以修改`index.pt`模板，以显示新文本而不是旧文本。`<title>`和`<h1>`标签都需要一个`tal:content`语句，如下例所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, the template will use whatever title is stored in the application instance.
    Now we need a way for the user to set the title. Let''s create a simple Ajax view
    that can do this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模板将使用存储在应用程序实例中的任何标题。现在我们需要一种让用户设置标题的方法。让我们创建一个简单的Ajax视图来完成这个任务：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All this does is checks for the key `new_title` in the request, and sets the
    `title` attribute to its value. As we did with the `Check` view back in Chapter
    3, the response does not use a template, but a simple Python code that returns
    plain text. We just return the `title` attribute that was changed in the `update`
    method, so that the JavaScript callback function can change it immediately after
    it's set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是检查请求中的键`new_title`，并将`title`属性设置为它的值。正如我们在第3章中与`Check`视图所做的那样，响应不使用模板，而是一个简单的Python代码，返回纯文本。我们只是返回在`update`方法中更改的`title`属性，以便JavaScript回调函数可以在设置后立即更改它。
- en: 'On the client side, we use a couple of JavaScript functions to produce an *edit-in-place*
    effect, so that the user can click on the title and change it right there. We
    won''t go into the code here, but you can find it in the Chapter 4 directory in
    the book''s code package. You can look at the result in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们使用几个JavaScript函数来产生一个*原地编辑*效果，这样用户就可以点击标题并立即更改它。我们不会在这里深入代码，但你可以找到它在该书的代码包的第四章目录中。你可以在以下屏幕截图中查看结果：
- en: '![Changing the title dynamically](img/7481_04_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![动态更改标题](img/7481_04_01.jpg)'
- en: 'If we run the application now, it will be possible to edit the title, restart
    the application, and see that its value is saved across server restarts. One word
    of warning though: because we added an attribute to the application instance inside
    the `__init__` method, it''s necessary to delete any existing application instances
    before trying this code. That''s because the `title` attribute is added at the
    time of application creation, when the `__init__` method is run, which didn''t
    happen when we created applications in the previous chapter. If we try to use
    an older application instance, we''ll get an attribute error when we try to access
    the `title` attribute.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，将能够编辑标题、重新启动应用程序，并看到其值在服务器重启后仍然被保存。不过有一个警告：因为我们已经在 `__init__` 方法中向应用程序实例添加了一个属性，所以在尝试这段代码之前，必须删除任何现有的应用程序实例。这是因为
    `title` 属性是在应用程序创建时添加的，当时 `__init__` 方法被调用，而在上一章创建应用程序时并没有发生这种情况。如果我们尝试使用较旧的应用程序实例，当我们尝试访问
    `title` 属性时，将会得到一个属性错误。
- en: The rules of persistence
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性规则
- en: As we mentioned earlier, the `todolists` attribute will not get persisted to
    the ZODB that easily. The reason is that whenever changes are made to mutable
    attributes, the application needs to inform the ZODB that there has been a change.
    This is done by setting the special `_p_changed` attribute of the instance to
    `True.`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`todolists` 属性不会那么容易持久化到 ZODB。原因是每当对可变属性进行更改时，应用程序需要通知 ZODB 已发生更改。这是通过将实例的特殊
    `_p_changed` 属性设置为 `True` 来实现的。
- en: 'In the case of the `todolists` attribute, all we have to do is set `_p_changed`
    to `True` after any modification to the attribute. We''ll just need to add this
    code at the end of the `update` methods in the index and check views:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `todolists` 属性的情况下，我们只需在修改属性后将其 `_p_changed` 设置为 `True`。我们只需在索引和检查视图的 `update`
    方法末尾添加此代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Thankfully, this is the only rule that we have to keep in mind when working
    with the ZODB in Grok. Well, there are a few more rules, but Grok already follows
    them, so this is the only one that will require us to modify the code. Let''s
    look at the rules of persistence for the ZODB:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是我们与 Grok 一起使用 ZODB 时必须记住的唯一规则。好吧，还有一些其他规则，但 Grok 已经遵循了它们，所以这是唯一一个需要我们修改代码的规则。让我们看看
    ZODB 的持久性规则：
- en: Inherit from `persistent.Persistent` (a class defined in the ZODB code) or one
    of its subclasses. The Grok classes, `grok.Model` and `grok.Container` already
    do this for us, so by extending them we will automatically persist our classes.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `persistent.Persistent`（ZODB 代码中定义的一个类）或其子类继承。Grok 类 `grok.Model` 和 `grok.Container`
    已经为我们做了这件事，所以通过扩展它们，我们将自动持久化我们的类。
- en: Class instances have to be related to each other in a hierarchical structure.
    The ZODB has a root object and this object contains other objects, which can in
    turn contain some other objects, forming a tree.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例必须以层次结构相互关联。ZODB 有一个根对象，该对象包含其他对象，这些对象反过来又可以包含一些其他对象，形成一个树状结构。
- en: When modifying mutable attributes of persistent objects that are not persistent
    themselves, the persistence machinery has to be notified, by setting the special
    `_p_changed` attribute of the instance to `True`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当修改不是持久化的持久化对象的可变属性时，持久化机制必须通过将实例的特殊 `_p_changed` 属性设置为 `True` 来通知。
- en: Like we said, Grok follows these rules, so that by using Grok's models and containers
    we automatically have persistent data storage for our applications. In this way,
    we can think only in terms of classes and attributes instead of translating them
    back and forth in our minds (and code) into tables and columns.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，Grok 遵循这些规则，所以通过使用 Grok 的模型和容器，我们自动为我们的应用程序提供了持久数据存储。这样，我们只需考虑类和属性，而无需在心中（和代码中）将它们来回转换成表和列。
- en: That's all we have to do to store the to-do lists inside the ZODB. We almost
    have a complete application, so now let's focus on how to better structure our
    code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需这样做就可以在 ZODB 中存储待办事项列表。我们几乎已经完成了一个完整的应用程序，所以现在让我们关注如何更好地组织我们的代码。
- en: Display logic and application logic
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示逻辑和应用逻辑
- en: We keep talking about the separation of display and application logic, but our
    code so far is clearly not enforcing this rule. The model only holds the lists
    and everything else happens inside the views.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论显示逻辑和应用逻辑的分离，但我们的代码到目前为止显然没有强制执行这一规则。模型只持有列表，而所有其他操作都在视图中进行。
- en: The problem with this approach is that our views need to know too much about
    how the model is implemented, and it becomes very hard to change it without needing
    to modify some or all of the views.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于我们的视图需要了解太多关于模型实现的方式，因此在不修改某些或所有视图的情况下，改变它变得非常困难。
- en: For example, when we add a list item in the `update` method of our index view,
    we have to know that list items are stored as dictionaries with `description`
    and `check` keys . We also have to know that the list of items is stored under
    the key items in a dictionary representing the list itself. These are too many
    internal details, and writing view code, which relies on this knowledge may require
    heavy modifications to it, if the model implementation changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们在我们索引视图的`update`方法中添加一个列表项时，我们必须知道列表项是以`description`和`check`键存储为字典的。我们还得知道，项目列表存储在代表列表本身的字典中的`items`键下。这些都是太多的内部细节，如果模型实现发生变化，依赖于这些知识的视图代码可能需要进行重大修改。
- en: 'Worse, relying on this knowledge makes our code more repetitive than it should
    be, and forces us to make the same change in multiple places when there are modifications.
    Look at this line of code from the to-do list manager:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，依赖于这些知识使得我们的代码比应有的重复性更高，并且在有修改时，我们不得不在多个地方进行相同的更改。看看这个来自待办事项管理器的代码行：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We only have two views, and this line shows up in both of them. If we add more
    views and need to look at the items from some list in them, we'll have to repeat
    this code again. Now suppose we add projects to our application and wish to store
    the lists inside a project. In this case, we would have to change every occurrence
    of this line in every view, to reflect the new structure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有两个视图，并且这一行出现在它们两个中。如果我们添加更多视图并且需要查看它们中的某些列表项，我们就必须再次重复这段代码。现在假设我们向应用程序添加项目，并希望将列表存储在项目中。在这种情况下，我们必须在每个视图中更改这一行的每个出现，以反映新的结构。
- en: This is why separation of display and application logic is so important. It
    helps to structure our applications and allows us to change the way the data is
    displayed without modifying its internal representation, or the other way around.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么分离显示和应用逻辑如此重要的原因。它有助于结构化我们的应用程序，并允许我们更改数据的显示方式，而无需修改其内部表示，反之亦然。
- en: Separating display and application logic
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离显示和应用逻辑
- en: Let's think about how we could restructure the application so that this principle
    is taken into account. Remember, the model shouldn't know anything about how it
    is displayed and the views should not depend on any implementation details from
    the model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何重构应用程序，以便考虑到这个原则。记住，模型不应该了解任何关于它如何显示的信息，而视图不应该依赖于模型中的任何实现细节。
- en: 'We could start by adding some method to the model to add lists and get all
    the items from a list, so that we can call these new methods from the view and
    stop depending on how list data are stored in the main list of the to-do lists.
    We might be tempted to write something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从向模型添加一些方法开始，用于添加列表和从列表中获取所有项，这样我们就可以从视图中调用这些新方法，并停止依赖于列表数据在待办事项列表主列表中的存储方式。我们可能会想写点像这样东西：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, we must resist the temptation. If we go down this path, our code will
    be filled with `self._p_changed` lines, and we'll be passing list indexes around
    like crazy. Having the to-do lists represented as a simple list is really not
    the way to go. We should instead use a more carefully designed model, and take
    full advantage of Grok's model classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须抵制这种诱惑。如果我们走这条路，我们的代码将充满`self._p_changed`行，并且我们会像疯狂一样传递列表索引。将待办事项列表表示为简单的列表真的不是一条好路。我们应该使用更精心设计的模型，并充分利用Grok的模型类。
- en: Using containers and multiple models
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器和多个模型
- en: Up to this point, we are using `grok.Model` as a base class for our application,
    which mostly buys us nearly transparent ZODB storage, as we have seen. Most non-trivial
    applications, however, will require more than one type of object to be useful.
    Also, it's fairly common to organize application data using parent and child relationships,
    so that one main object is the parent and contains a number of child objects.
    In our to-do list manager application, the main application is a container of
    to-do lists and each list in turn can contain a number of items.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们正在使用`grok.Model`作为我们应用程序的基类，这基本上为我们提供了我们看到的几乎透明的ZODB存储。然而，大多数非平凡的应用程序都需要多种类型的对象才能有用。此外，使用父级和子级关系组织应用程序数据相当常见，这样主要对象就是父级，并包含多个子对象。在我们的待办事项列表管理应用程序中，主要应用程序是待办事项列表的容器，而每个列表又可以包含多个项目。
- en: Because this is a very common pattern, Grok offers a `grok.Container` class
    which allows us to store other models and also handles ZODB persistence. Using
    it, we can structure our code better, simplify it, and also eliminate the need
    to signal to the framework every time a change is made to a list or one of its
    items (no more `self._p_changed` lines). Instead of dealing with an ad hoc list
    structure and keeping track of indexes, we can think about list objects and item
    objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个非常常见的模式，Grok提供了一个`grok.Container`类，它允许我们存储其他模型，并处理ZODB持久化。使用它，我们可以更好地组织我们的代码，简化它，并且还可以消除每次对列表或其项目进行更改时向框架发出信号的需求（不再需要`self._p_changed`行）。我们不再需要处理一个临时的列表结构并跟踪索引，我们可以考虑列表对象和项目对象。
- en: Adding containers to our application
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器添加到我们的应用程序中
- en: 'Conceptually, then, our application will consist of a container of lists. A
    list object will also be a container, where the items will be stored. Let''s start
    by defining the main model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们的应用程序将包含一个列表的容器。列表对象也将是一个容器，其中将存储项目。让我们首先定义主要模型：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is not very different from what we had before. The important change is
    that we now inherit from `grok.Container` instead of `grok.Model`. This will allow
    the application to store list objects. We also define a `next_id` attribute to
    create identifiers for the lists. OK, let''s define the list model now:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前所拥有的并没有太大区别。重要的变化是我们现在从`grok.Container`继承，而不是从`grok.Model`继承。这将允许应用程序存储列表对象。我们还定义了一个`next_id`属性来为列表创建标识符。好的，现在让我们定义列表模型：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A list has `title` and `description` attributes, both mandatory parameters at
    instance creation. As with the list model, we also define a `next_id` attribute
    to keep track of individual items. Notice that `grok.Application` is not a base
    class here, because this is a model that will be used by the application defined
    earlier. In some cases, we could have a need for more than one application in
    a project, and technically we could define both in the same file, but generally
    it's suggested that we use a separate file for different applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有`title`和`description`属性，两者都是实例创建时的必填参数。与列表模型一样，我们也定义了一个`next_id`属性来跟踪单个项目。请注意，`grok.Application`在这里不是一个基类，因为这个是一个将用于之前定义的应用程序中的模型。在某些情况下，我们可能需要在项目中使用多个应用程序，技术上我们可以在同一个文件中定义这两个应用程序，但通常建议我们为不同的应用程序使用单独的文件。
- en: 'The `TodoList` class is also a `grok.Container` because it will contain to-do
    items. These items will not contain other types of models, so the list item class
    definition will simply be a model:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList`类也是一个`grok.Container`，因为它将包含待办事项。这些项目不会包含其他类型的模型，因此列表项目类定义将简单地是一个模型：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `TodoItem` class just inherits from `grok.Model`. It only has a `description`
    attribute, which is a mandatory parameter at instance creation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItem`类仅从`grok.Model`继承。它只有一个`description`属性，这是实例创建时的一个必填参数。'
- en: Adding behavior to the models
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模型添加行为
- en: Now that we have our application model structured, we should think about which
    model will perform which actions. We are talking about the different actions,
    such as list and item creation, that our application performs. However, in the
    previous version they were crowded inside the `update` method of the `index` view.
    With a clean model structure we can now separate these actions and put each one
    where it better belongs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将应用程序模型结构化，我们应该考虑哪个模型将执行哪些操作。我们正在讨论应用程序执行的不同操作，例如列表和项目的创建。然而，在之前的版本中，它们都拥挤在`index`视图的`update`方法中。有了干净的模式结构，我们现在可以分离这些操作，并将每个操作放在它更适合的位置。
- en: 'The main application is the list manager, so the methods for list creation
    and deletion should be added to the `Todo` class. Let''s get going with the code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序是列表管理器，因此应该将列表创建和删除的方法添加到 `Todo` 类中。让我们开始编写代码：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `addList` method takes a `title` and `description` and simply creates an
    instance of `TodoList`. The new list is stored in the container using a key, just
    like a Python dictionary works (in fact, it supports the same methods, such as
    keys, values, and items). The key is generated using the `next_id` attribute that
    we discussed earlier, which is then incremented for the next list creation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`addList` 方法接受 `title` 和 `description`，并简单地创建一个 `TodoList` 实例。新的列表使用键存储在容器中，就像
    Python 字典一样工作（实际上，它支持相同的方法，如 keys、values 和 items）。键是使用我们之前讨论的 `next_id` 属性生成的，然后为下一个列表创建递增。'
- en: The `deleteList` method is even simpler, as we just need to delete the desired
    key from the dictionary using the `del` statement. As promised, notice the absence
    of any code dealing directly with persistence. The lists will be correctly stored
    in the ZODB without the need for explicit notification.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteList` 方法甚至更简单，因为我们只需要使用 `del` 语句从字典中删除所需的键。正如我们承诺的那样，请注意，没有直接处理持久性的代码。列表将在
    ZODB 中正确存储，无需显式通知。'
- en: The TodoList model
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TodoList` 模型'
- en: 'Now let''s turn our attention to the `TodoList` model. We need a way to add
    and delete items, similar to what we did with the main application. Also, if we
    want to keep our non-JavaScript-enabled version of the application working, we
    need a way to change the `checked` status of multiple items at the same time.
    Here''s the code that we have to add to the `TodoList` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向 `TodoList` 模型。我们需要一种方法来添加和删除项目，类似于我们在主应用程序中所做的。此外，如果我们想保持非 JavaScript
    启用的应用程序版本正常工作，我们需要一种方法来同时更改多个项目的 `checked` 状态。以下是我们要添加到 `TodoList` 类中的代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `addItem` method is almost a verbatim copy of the `addList` method that
    we saw earlier. We use the `next_id` pattern to create the ID, and create a new
    instance of `TodoItem`. The `deleteItem` method is identical to the `deleteList`
    method discussed earlier. The `updateItems` method is different because it expects
    a list of item IDs to mark as checked. We iterate through all of the items in
    the list and set their `checked` attribute to `True` if they are on the received
    list, or set it to `False` otherwise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem` 方法几乎是我们之前看到的 `addList` 方法的逐字逐句的复制。我们使用 `next_id` 模式来创建 ID，并创建一个新的
    `TodoItem` 实例。`deleteItem` 方法与之前讨论的 `deleteList` 方法相同。`updateItems` 方法不同，因为它期望一个包含要标记为已检查的项目
    ID 的列表。我们遍历列表中的所有项目，如果它们在接收到的列表中，则将它们的 `checked` 属性设置为 `True`，否则设置为 `False`。'
- en: 'The `TodoItem` model is the simplest of the three. We can directly set the
    `checked` attribute to `True` or `False`, so we probably don''t need separate
    methods to do that. We will only add a convenience method to toggle the `checked`
    state of an item, without requiring us to know the current state. This will be
    useful for the Ajax-enabled check view that we created earlier:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItem` 模型是三个中最简单的。我们可以直接将 `checked` 属性设置为 `True` 或 `False`，所以我们可能不需要单独的方法来做这件事。我们将只添加一个方便的方法来切换项目的
    `checked` 状态，而无需我们知道当前状态。这将对我们之前创建的 Ajax 启用的检查视图很有用：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `toggleCheck` method simply sets the value of the `checked` attribute of
    the `TodoItem` to the opposite of the current value, thus acting as a toggle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleCheck` 方法简单地将 `TodoItem` 的 `checked` 属性的值设置为当前值的相反，从而起到切换的作用。'
- en: We now have a complete model that uses Grok's features and includes all of the
    application logic. The views will now be able to perform the display work without
    messing with the application's internals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的模型，它使用了 Grok 的特性，并包含了所有应用程序逻辑。视图现在将能够执行显示工作，而不会干扰应用程序的内部结构。
- en: Reorganizing the views
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新组织视图
- en: Speaking of views, we need to refactor those, too. So far, we have been doing
    everything with only one view, but this needs to change. We'd like to keep the
    application as having one single main view and showing all modifications to the
    different models on the same page, but method calls to each model's actions should
    come from the views associated with that model. This is because in this way Grok
    will take care of setting the context for the view correctly, and we will not
    have to worry about making sure that we act on the correct model in our code.
    Remember that earlier we used a hidden`<input>` tag with a list index to tell
    our `update` method on which list we wanted to operate. We don't need to do this
    anymore if we associate our views with the right models.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 说到视图，我们也需要重构它们。到目前为止，我们一直只用一个视图做所有事情，但这一点需要改变。我们希望保持应用程序只有一个单一的主视图，并在同一页面上显示对不同模型的全部修改，但每个模型的操作调用应来自与该模型关联的视图。这是因为这样Grok将正确地设置视图的上下文，我们就不必担心在代码中确保我们作用于正确的模型。记住，我们之前使用了一个隐藏的`<input>`标签和列表索引来告诉我们的`update`方法我们想要在哪个列表上操作。如果我们把视图与正确的模型关联起来，我们就不需要这样做。
- en: For the main application, then, we will keep the `index` view and the `setTitle`
    views. We'll also add views for calling the `addList` and `deleteList` methods.
    The new `TodoList` model will have a view for each of its three actions, which
    are `addItem, deleteItem`, and `updateItem`. For the `TodoItem` model, we'll reuse
    the existing `check` view, but the one associated with this model instead of the
    main application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主应用程序，我们将保留`index`视图和`setTitle`视图。我们还将添加调用`addList`和`deleteList`方法的视图。新的`TodoList`模型将为它的三个操作（`addItem`、`deleteItem`和`updateItem`）各自提供一个视图。对于`TodoItem`模型，我们将重用现有的`check`视图，但与这个模型相关联，而不是主应用程序。
- en: That's it. So, previously we had a single model with three views, but now we
    have three models, and each will require a couple of views. How will Grok know
    which views are associated with which model?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。所以，之前我们有一个单一模型和三个视图，但现在我们有三个模型，每个模型都需要几个视图。Grok将如何知道哪些视图与哪个模型相关联？
- en: Introducing class annotations
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍类注解
- en: One of Grok's conventions is that all views defined in a module where there's
    only one model definition will be associated with this model. Grok knows that
    this is the only possibility, and so automatically sets the `context` attribute
    on all views to be this model. Now that we have three models, each view that we
    create has to explicitly tell Grok to which model it belongs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Grok的一个约定是，在一个模块中定义了单个模型的情况下，所有定义的视图都将与这个模型相关联。Grok知道这是唯一可能性，因此自动将所有视图的`context`属性设置为这个模型。现在我们有三个模型，我们创建的每个视图都必须明确告诉Grok它属于哪个模型。
- en: The mechanism Grok uses to do this is called a **class annotation**. Grok has
    many conventions that help it decide what to do when no information is available,
    but we can certainly tell Grok what to do when we need to. A class annotation
    is just a declarative way of telling Grok something about a class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Grok用来做这件事的机制被称为**类注解**。Grok有许多约定，有助于它在没有信息的情况下做出决定，但当我们需要时，我们当然可以告诉Grok该怎么做。类注解只是告诉Grok关于类的一些信息的声明性方式。
- en: 'To explicitly associate a view with a model, we use the `grok.context` class
    annotation. This class takes as a parameter the model to which we want to associate
    a view. Let''s redefine our `index` view:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确地将一个视图与一个模型关联，我们使用`grok.context`类注解。这个类将我们想要关联视图的模型作为参数。让我们重新定义我们的`index`视图：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `grok.context` class annotation to tell Grok that this view will
    work with the `Todo` model as context. This is in fact all of the code that we
    need for this view, as we have separated the model responsibilities into three
    different views. No more gigantic `update` methods full of `if` statements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`grok.context`类注解来告诉Grok这个视图将使用`Todo`模型作为上下文。实际上，这就是我们为这个视图需要的所有代码，因为我们已经将模型责任分成了三个不同的视图。不再有满是`if`语句的巨大`update`方法。
- en: Before going on with the other views, let's think a bit about how `index` views
    work. As we saw in the previous chapter, if a view has the name `index` it will
    be treated as the default view for a model. We also learned that the name of a
    view is automatically given by the lowercase version of its own class name. Now,
    for the case where we have more than one model and for each of them we want to
    have a default view, how do we name the view classes? There can't be two `Index`
    classes defined in the same module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续其他视图之前，让我们稍微思考一下`index`视图是如何工作的。正如我们在上一章所看到的，如果一个视图的名称是`index`，它将被视为该模型的默认视图。我们还了解到，视图的名称是自动由其类名的小写版本给出的。现在，对于我们有多个模型并且我们希望每个模型都有一个默认视图的情况，我们该如何命名视图类？在同一个模块中不能定义两个`Index`类。
- en: Setting view names explicitly
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确设置视图名称
- en: 'If you guessed that class annotations would come into play again, you were
    absolutely right. For cases like these, we have the `grok.name` class annotation,
    which can be used to explicitly set the name of a view. Right now, we need only
    one `index` view in our code, but we may need to add default views for the other
    models later, so we might as well change the code at this point:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜到类注解会再次发挥作用，你完全正确。对于这类情况，我们有`grok.name`类注解，它可以用来显式设置视图的名称。目前，我们只需要在我们的代码中有一个`index`视图，但以后我们可能需要为其他模型添加默认视图，所以我们可以在这个时候修改代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We change the view class name to `TodoIndex`, which would result in URLs with
    the name `todoindex`. We then use the `grok.name` annotation to set the view name
    to `index`, thus allowing us to call the default view without using its name.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将视图类名更改为`TodoIndex`，这将导致名为`todoindex`的URL。然后我们使用`grok.name`注解将视图名称设置为`index`，这样我们就可以调用默认视图而不使用其名称。
- en: 'Now let''s take a look at the action views for this model. First, the `addlist`
    view, which will be used to add new lists to the application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个模型的动作视图。首先，是`addlist`视图，它将被用来向应用程序添加新的列表：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `TodoAddList` view is also associated with the `Todo` model, but uses a
    different name. This view will be called when the user fills the create list form
    and clicks on the submit button.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoAddList`视图也与`Todo`模型相关联，但使用不同的名称。当用户填写创建列表表单并点击提交按钮时，将调用此视图。'
- en: Notice in this code how the `update` method is just one line long. We just call
    the `addList` method of the `context` and pass the two required parameters to
    it. No need to grapple with form parameters or make `if` checks to see what action
    is desired.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这段代码中，`update`方法只有一行长。我们只是调用`context`的`addList`方法，并将两个必需的参数传递给它。不需要处理表单参数或进行`if`检查以查看所需的操作。
- en: Redirecting views
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图重定向
- en: In this application we want the index page to show all changes immediately.
    Therefore, in the `render` method, instead of using a template to produce HTML,
    or sending a plain text string as we have done before, we perform a redirection
    to the index view, using the `redirect` method available to the view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们希望索引页面能够立即显示所有更改。因此，在`render`方法中，我们不是使用模板生成HTML，或者像我们之前所做的那样发送一个纯文本字符串，而是使用视图可用的`redirect`方法将视图重定向到索引视图。
- en: 'The `deletelist` view is very similar to the `addlist` view. We hadn''t implemented
    this functionality in the initial version of our application, but you''ll see
    it''s really cheap to do that now that we have the proper structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`deletelist`视图与`addlist`视图非常相似。我们最初的应用程序版本中没有实现这个功能，但现在你会看到，有了适当的结构，实现这个功能真的很简单：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We just use a different name and call the `deleteList` method of the model,
    but otherwise the code is the same.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是使用不同的名称并调用模型的`deleteList`方法，但除此之外代码是相同的。
- en: 'The last view for the `Todo` model is the `setTitle` view that we added at
    the beginning of this chapter. Here''s how it looks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Todo`模型的最后一个视图是我们在本章开头添加的`setTitle`视图。以下是它的样子：'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we keep the old behavior of returning the new title when rendering.
    The only change here is that the association with the model is explicit, and we
    give it a different name than its class name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们保留了在渲染时返回新标题的旧行为。这里唯一的改变是，与模型的关联是明确的，并且我们给它一个不同于其类名的名称。
- en: 'The three views associated to the `TodoList` model are almost carbon copies
    of the `addlist` and `deletelist` views of the `Todo` model. Let''s take a look
    and talk about what''s different:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与`TodoList`模型关联的三个视图几乎与`Todo`模型的`addlist`和`deletelist`视图完全相同。让我们看看并讨论一下有什么不同：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the three of them use the `grok.context` annotation to associate
    themselves with the `TodoList` model. The `update` methods of all three are very
    similar to the other ones, and just call the correct `update` method from the
    `context`, which in this case we know is a `TodoList` instance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这三者如何使用`grok.context`注解将自己与`TodoList`模型关联。这三个的`update`方法与其他方法非常相似，只是调用`context`的正确`update`方法，在这种情况下我们知道是一个`TodoList`实例。
- en: The `redirect` call on the `render` method is a little different, though. As
    the context is a `TodoList` and we want to show the index view for the `Todo`
    model, we need to get at the container of this list to pass it to the `url` function
    of the view, so that it can generate the correct URL. To do this, we use another
    characteristic of a Grok model object, a `__parent__` attribute, which points
    to its container. As we know that the list is contained by the `Todo` model, we
    can get at it in this way. Model objects also have a `__name__` attribute, which
    stores the key that is used to access the object inside its container. We'll use
    that in a minute when we see how the index template has to change to accommodate
    the new model structure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法上的`redirect`调用略有不同。因为上下文是`TodoList`，而我们想显示`Todo`模型的索引视图，所以我们需要获取这个列表的容器，以便将其传递给视图的`url`函数，这样它就可以生成正确的URL。为此，我们使用Grok模型对象的另一个特性，即`__parent__`属性，它指向其容器。正如我们所知，列表被`Todo`模型包含，我们可以这样访问它。模型对象还有一个`__name__`属性，它存储用于访问容器内对象的键。我们将在稍后看到索引模板如何改变以适应新的模型结构时使用它。
- en: 'As for the `TodoItem` model, we just need the `check` view that was already
    used in the previous version of our application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`TodoItem`模型，我们只需要之前版本中已经使用的`check`视图：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a few differences. The view is now explicitly associated with the
    `TodoItem` model using `grok.context`, obviously. Also, we now call the new `toggleCheck`
    method of the `TodoItem` instead of making the change in the view. Finally, we
    construct the ID for the`<div>` tag that the view will be returning, by using
    the `__parent__` and `__name__` attributes of the model. In this way, we avoid
    the need to have list and item indexes passed as view parameters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些差异。现在视图明确地使用`grok.context`与`TodoItem`模型关联，这是显而易见的。现在我们调用`TodoItem`的新`toggleCheck`方法，而不是在视图中进行更改。最后，我们通过使用模型的`__parent__`和`__name__`属性来构造视图将返回的`<div>`标签的ID。这样，我们就避免了需要将列表和项目索引作为视图参数传递的需要。
- en: 'We now have a much better separation of application and display logic in our
    to-do list manager application. Let''s see how this impacts the code for the `index`
    view, which now has to display data from three models instead of one. Look at
    the code for the loop that shows the lists and their items. First, note that we
    now iterate over the lists using `context/values` instead of the list elements
    that we had in the old model:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的待办事项列表管理应用程序中，应用程序和显示逻辑的分离要好得多。让我们看看这对`index`视图代码的影响，现在它必须显示来自三个模型而不是一个模型的数据。看看显示列表及其项目的循环代码。首先，注意我们现在使用`context/values`而不是旧模型中的列表元素来遍历列表：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After that, we define the `todo` list form. Notice how we use `view.url()` to
    generate the correct URL for posting the form. Remember that this function works
    by passing the object for which we want to generate a URL and an optional view
    name to append to it. In the following code, the action for the first form is
    defined by calling the `view url` method, passing the current `todolist` object
    and the `updateitems` view name to it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义了`todo`列表表单。注意我们如何使用`view.url()`生成表单的正确URL。记住，这个函数通过传递我们想要生成URL的对象以及可选的附加到它上面的视图名称来工作。在下面的代码中，第一个表单的动作是通过调用`view
    url`方法定义的，将当前的`todolist`对象和`updateitems`视图名称传递给它。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we have the code to delete a list. Take a look at how we use the `__name__`
    attribute to create URLs that include the name of the object that we are interested
    in. In this way, methods that expect a key to work will receive it directly from
    this view. We don''t need to do any list and item index calculations, or add hidden
    fields with list data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有删除列表的代码。看看我们如何使用`__name__`属性来创建包含我们感兴趣的对象的名称的URL。这样，期望接收键的方法将直接从这个视图中接收它。我们不需要进行任何列表和项目索引的计算，也不需要添加包含列表数据的隐藏字段：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The rest of the form has very similar changes, which are mostly the use of `__name__`
    and `view.url:`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的其余部分有非常相似的变化，主要是使用`__name__`和`view.url:`。
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the form for adding list items now also uses `view.url` to generate
    the form action:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加列表项的表单现在也使用`view.url`来生成表单操作：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One would think that having to use three models could complicate things in the
    view, but we actually have to use less code this time around. It's also a lot
    cleaner. Instead of a big form with multiple submit buttons that all go to the
    same `update` method in the same view, we now use several forms, and direct the
    form submissions to the respective view by using `view.url()` to generate the
    correct URL in each case.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会认为需要使用三个模型可能会使视图中的事情变得复杂，但实际上这次我们使用的代码更少。它也更为简洁。我们不再使用一个包含多个提交按钮的大表单，这些按钮都指向同一视图中的相同`update`方法，我们现在使用几个表单，并通过使用`view.url()`生成每个情况下的正确URL，将表单提交直接导向相应的视图。
- en: Other than these changes, the code for the template is mostly the same as we
    already had, so no big changes are required to make it work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些更改之外，模板的代码基本上与我们已有的相同，因此不需要进行大的更改来使其工作。
- en: The Grok introspector
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grok内省器
- en: So we now have a fully working application. Play with it a little and create
    some lists and tasks. Everything will be safely stored inside the ZODB.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个完全工作的应用程序。玩一玩它，创建一些列表和任务。所有内容都将安全地存储在ZODB中。
- en: We'll now take a quick look at one tool that Grok offers that can be very helpful
    to understand object relationships and responsibilities when we are dealing with
    applications developed by someone else (or revisiting applications we wrote years
    ago).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速浏览一下Grok提供的一个工具，这个工具在处理他人开发的应用程序（或回顾我们多年前编写的应用程序）时，可以帮助我们理解对象关系和职责。
- en: 'The Grok introspector is a tool that is accessible from the application list
    at `http://localhost:8080/applications`. Go there and, under **Installed Applications**,
    you''ll see your instance of the `Todo` application. The application name is a
    link to run it, but to the right of that name there is a link that says **object
    browser**. Click on this link and you''ll see something similar to the next screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Grok内省器是一个可以从`http://localhost:8080/applications`的应用程序列表访问的工具。前往那里，在**已安装的应用程序**下，你会看到`Todo`应用程序的实例。应用程序名称是一个链接，可以运行它，但在名称的右侧有一个链接，上面写着**对象浏览器**。点击这个链接，你会看到类似于下一张截图的内容：
- en: '![The Grok introspector](img/7481_04_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![The Grok introspector](img/7481_04_02.jpg)'
- en: In this case, we can see the data from the current instance of the `Todo` model.
    Notice how the parent information used for the `__parent__` attribute is there
    at the top. Below we can see the base classes of the object, which we know are
    `grok.Application` and `grok.Container`. Under the **Base classes** section there
    is an **Interfaces provided** section. We'll have more to say about interfaces
    later, so for now let's skip that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到`Todo`模型当前实例的数据。注意用于`__parent__`属性的父信息就在顶部。下面我们可以看到该对象的基本类，我们知道它们是`grok.Application`和`grok.Container`。在**基类**部分下面有一个**提供的接口**部分。我们稍后会更多地讨论接口，所以现在让我们跳过那个部分。
- en: Below that you can see a section called **Attributes and Properties**. Under
    **Attributes**, you'll find the `title` and `next_id` attributes of the `Todo`
    model, with their current values. Then comes the **Mappings** section, where the
    values for all of the objects stored in this container are shown. If you click
    on any of these values, you'll get a page with the data for the corresponding
    model instance, so you can easily navigate the whole data structure produced by
    the application and look at the information within.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面你可以看到一个名为**属性和属性**的部分。在**属性**下，你可以找到`Todo`模型的`title`和`next_id`属性及其当前值。然后是**映射**部分，其中显示了存储在此容器中的所有对象的值。如果你点击这些值中的任何一个，你将得到一个页面，显示相应模型实例的数据，这样你可以轻松地导航应用程序产生的整个数据结构并查看其中的信息。
- en: Finally, the names and documentation strings for all of the methods of the object
    are shown. Try adding a documentation string to a method of our application, and
    you will see it reflected in that section (after a server restart, of course).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，显示了该对象所有方法的名称和文档字符串。尝试在我们的应用程序中添加一个方法的文档字符串，你将看到它在那个部分中反映出来（当然，在服务器重启后）。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we extended our demonstration application using models. The
    amount of code did not increase greatly from the previous chapter, but we have
    a much more elegant and better-structured application. The code is also more maintainable
    and pretty extensible, as we'll learn next when we deal with forms in Grok.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用模型扩展了我们的演示应用。代码量与上一章相比并没有大幅增加，但我们得到了一个更加优雅且结构更优的应用。代码的维护性也更强，并且具有很好的扩展性，这一点我们将在处理Grok中的表单时学到。
