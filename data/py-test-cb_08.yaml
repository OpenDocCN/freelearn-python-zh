- en: Smoke/Load Testing – Testing Major Parts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒烟/负载测试-测试主要部分
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining a subset of test cases using import statements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导入语句定义测试用例的子集
- en: Leaving out integration tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 省略集成测试
- en: Targeting end to end scenarios
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对端到端场景
- en: Targeting the test server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对测试服务器
- en: Coding a data simulator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写数据模拟器
- en: Recording and playing back live data in real time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时记录和播放实时数据
- en: Recording and playing back live data as fast as possible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快记录和播放实时数据
- en: Automating your management demo
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化管理演示
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Smoke testing is not very widely embraced by teams that write automated tests.
    Writing tests to verify things are working or to expose bugs is a commonly adopted
    practice, and many teams pick up the idea of using acceptance testing to verify
    whether their applications are meeting customer demands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试并不是被编写自动化测试的团队广泛接受的。编写测试来验证事物是否正常工作或暴露错误是一种常见的做法，许多团队也采用了使用验收测试来验证他们的应用程序是否满足客户需求的想法。
- en: But smoke testing is a little different. One of the key ideas with smoke testing
    is to see whether the system has a pulse. What does this mean? It's similar to
    when a doctor first sees a patient. The first thing they do is check the patient's
    pulse, along with other vital signs. No pulse; critical pulse! So, what exactly
    in software constitutes a pulse? That is what we'll explore in the recipes in
    this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但冒烟测试有所不同。冒烟测试的一个关键想法是看系统是否有脉搏。这是什么意思？这类似于医生第一次看到患者时的情况。他们做的第一件事就是检查患者的脉搏，以及其他重要的生命体征。没有脉搏；重要的脉搏！那么，软件中的脉搏究竟是什么？这就是我们将在本章的示例中探讨的内容。
- en: Instead of thinking about comprehensive test suites that make sure every corner
    of the system has been checked, smoke testing takes a much broader perspective.
    A set of smoke tests is meant to make sure the system is up and alive. It's almost
    like a ping check. Compare it to sanity tests. Sanity tests are used to prove
    a small set of situations actually work. Smoke testing, which is similar in the
    sense that it is quick and shallow, is meant to see whether the system is in an
    adequate state to proceed with more extensive testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与考虑确保系统的每个角落都经过检查的全面测试套件不同，冒烟测试采用了更广泛的视角。一组冒烟测试旨在确保系统正常运行。这几乎就像是一个ping检查。将其与理智测试进行比较。理智测试用于证明一小部分情况实际上是有效的。冒烟测试，从快速和浅显的意义上来说是类似的，旨在查看系统是否处于足够的状态以进行更广泛的测试。
- en: 'If you imagine an application built to ingest invoices, a set of smoke tests
    could include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想象一个用于摄取发票的应用程序，一组冒烟测试可能包括以下内容：
- en: Verify the test file has been consumed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证测试文件已被消耗
- en: Verify the number of lines parsed
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证解析的行数
- en: Verify the grand total of the bill
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证账单的总额
- en: Does this sound like a small set of tests? Is it incomplete? Yes it is. And
    that's the idea. Instead of verifying our software parsed everything correctly,
    we are verifying just a few key areas that *must* be working. If it fails to read
    one file, then there is a major issue that needs to be addressed. If the grand
    total of the bill is incorrect, again, something big must be taken care of.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一小部分测试吗？它是不完整的吗？是的。这就是意图。我们不是在验证我们的软件是否正确解析了所有内容，而是在验证一些*必须*正常工作的关键领域。如果它无法读取一个文件，那么就需要解决一个重大问题。如果账单的总额不正确，那么再次，必须解决一个重大问题。
- en: A key side effect of smoke testing is that these tests should be quick to run.
    What if we altered the function that handles files? If our test suite involves
    parsing lots of different file types, it could take a long time to verify we didn't
    break anything. Instead of spending 30 minutes to run a comprehensive test suite,
    wouldn't it be better to run a one minute quick test and then spend the other
    29 minutes working on the software?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试的一个关键副作用是这些测试应该运行得很快。如果我们改变了处理文件的功能会怎么样？如果我们的测试套件涉及解析许多不同类型的文件，那么验证我们没有破坏任何东西可能需要很长时间。与其花费30分钟来运行全面的测试套件，不如运行一分钟的快速测试，然后花费其他29分钟来处理软件会更好吗？
- en: Smoke tests are also good to use when preparing for a customer demo. With the
    tension turned up, it's good to run tests more often to make sure we haven't broken
    anything. Before launching a demo, one last pulse check to know the system is
    alive may be needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试在准备客户演示时也很有用。在紧张的情况下，经常运行测试以确保我们没有破坏任何东西是很好的。在启动演示之前，可能需要进行最后一次脉冲检查以确保系统是活跃的。
- en: This chapter also dives into load testing. Load testing is crucial to verify
    whether our applications can handle the strain of real-world situations. This
    often involves collecting real-world data and playing it back through our software
    for a reproducible environment. While we need to know our system can handle today's
    load, how likely is it that tomorrow's load will be the same? Not very likely.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还深入探讨了负载测试。负载测试对于验证我们的应用程序是否能够承受真实世界情况的压力至关重要。这通常涉及收集真实世界数据，并通过我们的软件进行可重现的环境回放。虽然我们需要知道我们的系统能够处理今天的负载，但明天的负载可能会有多大的可能性呢？不太可能。
- en: It is very useful to seek out the next bottleneck in our application. That way,
    we can work towards eliminating it before we hit that load in production. One
    way to stress the system is to play back real-world data as quickly as possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找应用程序中的下一个瓶颈非常有用。这样，我们就可以在生产中遇到负载之前消除它。压力系统的一种方法是尽快播放实时数据。
- en: In this chapter, we will look at some recipes in which we both smoke test and
    load test the network management application. The types of load we will be placing
    on the application could also be described as **soak testing** and **stress testing**.
    **Soak testing** is described as putting a significant load on the system over
    a significant period of time. **Stress testing** is described as loading down
    a system until it breaks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些配方，其中我们既对网络管理应用程序进行了烟雾测试，又对其进行了负载测试。我们将对应用程序施加的负载类型也可以描述为**浸泡测试**和**压力测试**。**浸泡测试**被描述为在相当长的时间内对系统施加重大负载。**压力测试**被描述为将系统负载到崩溃。
- en: In my opinion, soak testing and stress testing are different sides of the same
    coin of load testing. That is why this chapter simply uses the term load testing
    when the various recipes can easily extend to these types of testing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，浸泡测试和压力测试是负载测试的不同方面。这就是为什么本章在各种配方可以轻松扩展到这些类型的测试时，简单地使用负载测试这个术语的原因。
- en: The code in this chapter also uses several utilities provided by Spring Python
    ([http://springpython.webfactional.com](http://springpython.webfactional.com)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码还使用了Spring Python提供的几个实用工具（[http://springpython.webfactional.com](http://springpython.webfactional.com)）。
- en: Many of the recipes in this chapter interact with a MySQL database. Install
    the Python MySQLdb library by typing `pip install mysql-python`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多配方与MySQL数据库交互。通过输入`pip install mysql-python`来安装Python MySQLdb库。
- en: Several of the recipes in this chapter use **Python Remote Objects** (**Pyro**)
    ([http://www.xs4all.nl/~irmen/pyro3/](http://www.xs4all.nl/~irmen/pyro3/)). It
    is a **Remote****Procedure****Call** (**RPC**) library that supports communicating
    between threads and processes. Install Pyro by typing `pip install pyro`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的几个配方使用了**Python Remote Objects**（**Pyro**）（[http://www.xs4all.nl/~irmen/pyro3/](http://www.xs4all.nl/~irmen/pyro3/)）。这是一个支持在线程和进程之间通信的**远程过程调用**（**RPC**）库。通过输入`pip
    install pyro`来安装Pyro。
- en: Defining a subset of test cases using import statements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导入语句定义一组测试用例的子集
- en: Create a Python module that selectively imports which test cases to run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Python模块，有选择地导入要运行的测试用例。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will explore selectively picking a smaller set of tests
    to facilitate a faster test run:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探讨有选择地选择一小组测试，以便进行更快的测试运行：
- en: 'Create a test module called `recipe59_test.py`, which will be used to write
    some tests against our network application, as shown here:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe59_test.py`的测试模块，用于针对我们的网络应用编写一些测试，如下所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a test case that removes the database connection and stubs out the data
    access functions, as shown here:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，删除数据库连接并将数据访问函数存根化，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a test method that creates a set of canned data values, invokes the
    application''s process method, and then verifies the values, as shown here:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试方法，创建一组预定义数据值，调用应用程序的处理方法，然后验证这些值，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create another test case that preloads the database using a SQL script, as
    shown:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个测试用例，使用SQL脚本预加载数据库，如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Write a test method that calls the network application''s process method and
    then prints out the results, as shown here:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个调用网络应用程序的处理方法然后打印结果的测试方法，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new file called `recipe59.py` that only imports the SQL-based test
    case, as shown here:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe59.py`的新文件，只导入基于SQL的测试用例，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the test module. Take a look at the following screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试模块。查看以下屏幕截图：
- en: '![](../images/00136.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00136.jpeg)'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We need to write various test cases to cover the different levels of testing
    we need. By separating the test runner from the test case, we are able to decide
    to only run the test that integrated with the database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写各种测试用例，以覆盖我们需要的不同测试级别。通过将测试运行程序与测试用例分开，我们可以决定仅运行与数据库集成的测试。
- en: Why would we do this? In our situation, we have only one unit test, and it runs
    pretty quickly. Do you think that a real-world application with months or years
    of development and a corresponding test suite will run as quickly? Of course not!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做？在我们的情况下，我们只有一个单元测试，而且运行速度相当快。你认为一个具有数月或数年开发时间和相应测试套件的真实应用程序会像这样快速运行吗？当然不会！
- en: Some of the tests may be complex. They may involve talking to real systems,
    parsing huge sample data files, and other time-consuming tasks. This could realistically
    take minutes or hours to run.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有些测试可能会很复杂。它们可能涉及与真实系统交流，解析大型样本数据文件和其他耗时任务。这可能需要几分钟甚至几小时才能运行。
- en: When we are about to make a presentation to a customer, we don't need a long-running
    test suite. Instead, we need to be able to run a quick subset of these tests that
    gives us the confidence that things are working. Using Python's import statements
    makes this easy to define.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们即将向客户做演示时，我们不需要一个运行时间很长的测试套件。相反，我们需要能够运行这些测试的一个快速子集，以确保一切正常。使用Python的导入语句可以很容易地定义这一点。
- en: 'Some suites we may want to think about include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要考虑的一些测试套件包括以下内容：
- en: '`pulse.py`: Import a set of test cases that provide broad, yet shallow testing
    of the application, to verify the system has a pulse'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pulse.py`：导入一组测试用例，对应用程序进行广泛而浅显的测试，以验证系统是否正常运行'
- en: '`checkin.py`: Import a set of test cases that are currently functioning, and
    provide enough confidence that code is ready to be committed'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkin.py`：导入一组当前正常运行的测试用例，并提供足够的信心，表明代码已准备好提交'
- en: '`integration.py`: Import a set of test cases that start up, interact, and then
    shut down external systems such as LDAP, databases, or other subsystems'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integration.py`：导入一组测试用例，启动、交互，然后关闭LDAP、数据库或其他子系统等外部系统'
- en: '`security.py`: Import a set of test cases that are focused on various security
    scenarios, confirming both good and bad credential handling'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security.py`：导入一组专注于各种安全场景的测试用例，确认良好和不良凭据处理'
- en: '`all.py`: Import all test cases to make sure everything is working'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all.py`：导入所有测试用例以确保一切正常'
- en: This is just a sample of the types of test module we could define. It's possible
    to define a module for each subsystem we handle. But since we are talking about
    smoke testing, we may want to think more broadly, and instead pick some key tests
    from each subsystem and tie them together to give us a sense that the application
    is working.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们可以定义的测试模块类型的一个示例。我们可以为我们处理的每个子系统定义一个模块。但是，由于我们正在讨论冒烟测试，我们可能希望思考得更广泛，而是从每个子系统中挑选一些关键测试，并将它们联系在一起，以便让我们感觉应用程序正在运行。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's have a look at these too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看这些。
- en: Security, checking, and integration aren't smoke tests!
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性、检查和集成不是冒烟测试！
- en: That is absolutely right. The previous list shows that using Python import statements
    isn't confined to defining smoke test suites. It can be used to bundle together
    test cases that serve a variety of needs. So why bring this up, since we are talking
    about smoke tests? Well, because I wanted to convey how useful this mechanism
    is for organizing tests, and that it extends beyond smoke testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绝对正确的。前面的列表显示，使用Python导入语句不仅限于定义冒烟测试套件。它可以用于捆绑满足各种需求的测试用例。那么，为什么要提到这一点，因为我们正在谈论冒烟测试？嗯，因为我想传达这种机制在组织测试方面有多么有用，它不仅限于冒烟测试。
- en: What provides good flexibility?
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么提供了很好的灵活性？
- en: To have good flexibility in being able to pick test classes, we should avoid
    making the test classes too big. But putting each test method inside a different
    class is probably too much.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够灵活地选择测试类，我们应该避免使测试类太大。但是，将每个测试方法放在不同的类中可能太多了。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Leaving out integration tests* recipe in this chapter
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的*省略集成测试*配方
- en: Leaving out integration tests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 省略集成测试
- en: A fast test suite avoids connecting to remote systems, such as databases and
    LDAP. Just verifying the core units and avoiding external systems can result in
    a faster-running test suite with more coverage. This can lead to a useful smoke
    test that gives developers confidence in the system without running all the tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试套件避免连接到远程系统，如数据库和LDAP。只验证核心单元并避免外部系统可能导致运行更快的测试套件并覆盖更多内容。这可以导致一个有用的冒烟测试，让开发人员对系统有信心，而不运行所有测试。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will see how to cut out test cases that interact with
    external systems:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将看到如何剔除与外部系统交互的测试用例：
- en: 'Create a test module called `recipe60_test.py`, which will be used for writing
    some tests for our network application, as shown here:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe60_test.py`的测试模块，用于编写我们的网络应用程序的一些测试，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a test case that removes the database connection and stubs out the data
    access functions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，删除数据库连接并将数据访问函数存根出来：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a test method that creates a set of canned data values, invokes the
    applications process method, and then verifies the values, as shown here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试方法，它创建一组预定义的数据值，调用应用程序的处理方法，然后验证这些值，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create another test case that preloads the database using a SQL script:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个测试用例，使用SQL脚本预加载数据库：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Write a test method that calls the network application''s process method and
    then prints out the results:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试方法，调用网络应用程序的处理方法，然后打印结果：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a module called `recipe60.py` that only imports the unit test that avoids
    making SQL calls. Take a look at this code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe60.py`的模块，它只导入避免进行SQL调用的单元测试。看看这段代码：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the test module. Take a look at the following screenshot:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试模块。查看以下截图：
- en: '![](../images/00137.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00137.jpeg)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This test suite runs the unit tests and avoids running test cases that integrate
    with a live database. It uses Python `import` statements to decide which test
    cases to include.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件运行单元测试，并避免运行与实时数据库集成的测试用例。它使用Python的`import`语句来决定包括哪些测试用例。
- en: In our contrived scenario, there is little gained performance. But with a real
    project, there are probably a lot more computer cycles spent on integration testing,
    due to the extra costs of talking to external systems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们虚构的场景中，性能几乎没有提高。但是对于一个真实的项目，可能会花费更多的计算机周期来进行集成测试，因为与外部系统交互会产生额外的成本。
- en: The idea is to create a subset of tests that verify to some degree that our
    application works by covering a big chunk of it in a small amount of time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一组测试的子集，以某种程度上验证我们的应用程序通过在很短的时间内覆盖大部分内容来工作。
- en: The trick with smoke testing is deciding what constitutes a good enough test.
    Automated testing cannot completely confirm that our application has no bugs.
    We are foiled by the fact that either a particular bug doesn't exist, or we haven't
    written a test case that exposes such a bug. To engage in smoke testing, we are
    deciding to use a subset of these tests for a quick pulse read. Again, deciding
    which subset gives us a good enough pulse may be more art than science.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试的诀窍在于决定什么构成了足够好的测试。自动化测试无法完全确认我们的应用程序没有错误。我们受到这样一个事实的干扰，即特定的错误不存在，或者我们还没有编写一个暴露这样一个错误的测试用例。要进行冒烟测试，我们决定使用这些测试的一个子集进行快速脉冲读取。再次决定哪个子集给我们足够好的脉冲可能更多地是一种艺术而不是科学。
- en: This recipe focuses on the idea that unit tests will probably run more quickly,
    and that cutting out the integration tests will remove the slower test cases.
    If all the unit tests pass, then we have some confidence that our application
    is in good shape.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方侧重于单元测试可能会更快地运行，并且剔除集成测试将删除较慢的测试用例。如果所有单元测试都通过了，那么我们就有了一些信心，我们的应用程序状态良好。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I must point out that test cases don't just easily fall into the category of
    **unit test** or **integration test**. It is more of a continuum. In this recipe's
    sample code, we wrote one unit test and one integration test, and then we picked
    the unit test for our smoke test suite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须指出，测试用例不仅仅容易归类为**单元测试**或**集成测试**。它更多的是一个连续体。在这个配方的示例代码中，我们编写了一个单元测试和一个集成测试，然后我们选择了单元测试作为我们的冒烟测试套件。
- en: Does this appear arbitrary and perhaps contrived? Sure it does. That is why
    smoke testing isn't cut and dried but instead requires some analysis and judgment
    about what to pick. And as development proceeds, there is room for fine-tuning.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是任意的，也许是刻意的吗？当然是。这就是为什么烟雾测试不是一成不变的，而是需要一些分析和判断来选择。随着开发的进行，还有改进的空间。
- en: I once developed a system that ingested invoices from different suppliers. I
    wrote unit tests that set up empty database tables, ingested files of many formats,
    and then examined the contents of the database to verify processing. The test
    suite took over 45 minutes to run. This pressured me to not run the test suite
    as often as desired. I crafted a smoke test suite that involved running only the
    unit tests that did *not* talk to the database (since they were quick), combined
    with ingesting one supplier invoice. It ran in fewer than five minutes, and provided
    a quicker means to assure myself that fundamental changes to the code did not
    break the entire system. I could run this many times during the day, and only
    run the comprehensive suite about once a day.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经开发过一个系统，可以从不同供应商那里获取发票。我编写了设置空数据库表、摄取多种格式文件，然后检查数据库内容以验证处理的单元测试。测试套件运行超过45分钟。这迫使我不能像期望的那样频繁地运行测试套件。我设计了一个烟雾测试套件，只运行不涉及数据库的单元测试（因为它们很快），并摄取一个供应商发票。它运行时间少于五分钟，并提供了一个更快的方法来确保代码的基本更改没有破坏整个系统。我可以在一天中运行多次这个测试，并且每天只运行一次全面的测试套件。
- en: Should a smoke test include integration or unit tests?
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烟雾测试是否应包括集成或单元测试？
- en: Does this code appear to be similar to that shown in the *Defining a subset
    of test cases using import statements *recipe? Yes, it does. So, why include it
    in this recipe? Because what is picked for the smoke test suite is just as critical
    as the tactics used to make it happen. The other recipe decided to pick up an
    integration test while cutting out the unit tests to create a smaller, faster-running
    test suite.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是否与*使用导入语句定义测试用例的子集*食谱中显示的代码相似？是的，它是。那么，为什么要包含在这个食谱中呢？因为选择烟雾测试套件和用于实现它的策略一样关键。另一个食谱决定选择一个集成测试，同时剔除单元测试，以创建一个更小、更快的测试套件。
- en: This recipe shows that another possibility is to cut out the lengthier integration
    tests and instead run as many unit tests as possible, considering they are probably
    faster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例表明，另一个可能性是剔除更长的集成测试，而是尽可能多地运行单元测试，考虑它们可能更快。
- en: As stated earlier, smoke testing isn't cut and dried. It involves picking the
    best representation of tests without taking up too much time running them. It
    is quite possible that none the tests written up to this point precisely target
    the idea of capturing a pulse of the system. A good smoke test suite may involve
    mixing together a subset of unit and integration tests.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，烟雾测试并不是一成不变的。它涉及选择最佳的测试代表，而不会花费太多时间来运行它们。很可能到目前为止写的测试中没有一个确切地针对捕捉系统脉搏的想法。一个好的烟雾测试套件可能涉及混合一部分单元测试和集成测试。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Defining a subset of test cases using import statements* recipe
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用导入语句定义测试用例的子集*食谱'
- en: Targeting end-to-end scenarios
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对端到端场景
- en: Pick a complement of tests that runs enough parts to define a thread of execution.
    This is sometimes referred to as thread testing. Not because we are using software
    threading, but instead because we are focusing on a story thread. Many times,
    our threads either come from customer scenarios, or they are at least inspired
    by them. Other threads can involve other groups, such as operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一组测试，运行足够的部分来定义一个执行线程。这有时被称为线程测试。不是因为我们使用软件线程，而是因为我们专注于一个故事线。很多时候，我们的线程要么来自客户场景，要么至少受到它们的启发。其他线程可能涉及其他团队，比如运营团队。
- en: For example, a network management system may push out customer-affecting alarms,
    but the internal operations team that has to solve the network problems may have
    a totally different perspective. Both of these situations demonstrate valid end-to-end
    threads that are good places to invest in automated testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个网络管理系统可能会推送影响客户的警报，但必须解决网络问题的内部运营团队可能有完全不同的视角。这两种情况都展示了有效的端到端线程，是值得投资自动化测试的好地方。
- en: If the different teams are viewed as different types of customers, then the
    concepts of acceptance testing certainly apply. And it's also possible to overlap
    this with the concepts of BDD.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将不同团队视为不同类型的客户，那么验收测试的概念肯定适用。还可以将其与BDD的概念重叠。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Copy the SQL script into a new file called `recipe61_network.sql` and replace
    the insert statements at the bottom with the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SQL脚本复制到一个名为`recipe61_network.sql`的新文件中，并在底部替换插入语句为以下内容：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this set of test data, `pyhost1` and `pyhost2` map into `service-abc`. `pyhost3`
    doesn't map into any service.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这组测试数据中，`pyhost1`和`pyhost2`映射到`service-abc`。`pyhost3`没有映射到任何服务。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: With these steps, we will build up an end-to-end test scenario.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将建立一个端到端的测试场景。
- en: Create a test module called `recipe61_test.py`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe61_test.py`的测试模块。
- en: 'Create a test case where each test method captures a different thread of execution,
    as shown here:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试用例，其中每个测试方法捕获不同的执行线程，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a test method that captures the thread of failing and recovering a piece
    of equipment, as shown here:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个捕获设备故障和恢复的线程的测试方法，如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Have the test method inject a single, faulting alarm and then confirm that
    a related piece of equipment has failed, as shown here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试方法应注入单个故障警报，然后确认相关设备已经失败，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the same test method, add code that injects a single, clearing alarm and
    confirms that the equipment has recovered, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个测试方法中，添加代码，注入单个清除警报，并确认设备已经恢复，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create another test method that captures the thread of failing and clearing
    a service, as shown here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个捕获服务失败和清除线程的测试方法，如下所示：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a test method that injects a single, faulting alarm and confirms that
    both a piece of equipment and a related service fails, as shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试方法，注入一个单一的故障警报，并确认设备和相关服务都失败了，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same test method, add code that injects a single, clearing alarm and
    confirms that both the equipment and the service have recovered, as shown here:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个测试方法中，添加代码，注入一个单一的清除警报，并确认设备和服务都已恢复，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a test runner called `recipe61.py` that imports both of these thread
    tests, as shown here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe61.py`的测试运行器，导入这两个线程测试，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the test suite. Look at the following screenshot:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试套件。查看以下截图：
- en: '![](../images/00138.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00138.jpeg)'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe we coded two end to end test scenarios. Now consider the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们编写了两个端到端测试场景。现在考虑以下：
- en: The first scenario tested how our application processes a fault, followed by
    a clear that only impacts a piece of the equipment.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个场景测试了我们的应用程序如何处理故障，然后是只影响设备的清除。
- en: The second scenario tested how our application processes a fault, followed by
    a clear that impacts a service.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个场景测试了我们的应用程序如何处理故障，然后是影响服务的清除。
- en: We injected a fault and then checked the results to confirm that the proper
    piece of inventory failed. Then we injected a clear, and again we confirmed that
    the proper piece of inventory recovered.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入了一个故障，然后检查结果，确认适当的库存部分失败了。然后我们注入了一个清除，再次确认适当的库存部分恢复了。
- en: Both of these scenarios show how our application processes different types of
    events from the beginning to the end.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都展示了我们的应用程序如何处理从开始到结束的不同类型的事件。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a more complex, realistic version of this application, what other systems
    do you think would be involved in an end to end thread? What about security? Transactions?
    Publishing results to an external interface?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序的更复杂、更真实的版本中，你认为还有哪些其他系统会涉及到端到端的线程？安全性呢？交易？将结果发布到外部接口？
- en: This is where we need to define where the ends are. Imagine that our application
    was grown to the point where incoming events are received by a web request and
    equipment and service updates are pushed out as JSON data to be received by a
    web page.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要定义端点的地方。想象一下，我们的应用程序已经发展到接收到来自网络请求的事件，并且设备和服务更新被推送为JSON数据，以便由网页接收。
- en: A good end-to-end test would include these parts as well. For the JSON output,
    we can use Python's JSON library to decode the output and then confirm the results.
    For the incoming web request, we can use many different techniques, including 
    acceptance testing tools such as the Robot Framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的端到端测试还应包括这些部分。对于JSON输出，我们可以使用Python的JSON库来解码输出，然后确认结果。对于传入的网络请求，我们可以使用许多不同的技术，包括接受测试工具，如机器人框架。
- en: How does this define smoke tests?
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何定义冒烟测试？
- en: If it takes too long run all the end-to-end tests, we should pick a subset of
    them that covers some key parts. For example, we could skip the equipment-based
    thread but keep the service-based one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行所有端到端测试需要太长时间，我们应该选择其中一部分覆盖一些关键部分。例如，我们可以跳过基于设备的线程，但保留基于服务的线程。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Testing Web Basics with the Robot Framework* recipe in [Chapter 10](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf), *Web
    UI Testing Using Selenium*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用机器人框架测试Web基础知识* 配方在[第10章](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf)中，*使用Selenium进行Web
    UI测试*'
- en: '*Using Robot to Verify Web Application Security *recipe in [Chapter 10](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf), *Web
    UI Testing Using Selenium*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用机器人验证Web应用程序安全* 配方在[第10章](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf)中，*使用Selenium进行Web
    UI测试*'
- en: Targeting the test server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对测试服务器
- en: Does your test server have all the parts? If not, then define an alternative
    set of tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试服务器是否有所有的部分？如果没有，那么定义一组替代测试。
- en: This recipe assumes that the production server has an enterprise grade MySQL
    database system, while the developer's workstation does not. We will explore writing
    some tests that use the MySQL database. But when we need to run them in the development
    lab, we will make adjustments so they run on SQLite, which comes bundled with
    Python.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设生产服务器有一个企业级的MySQL数据库系统，而开发人员的工作站没有。我们将探讨编写一些使用MySQL数据库的测试。但是当我们需要在开发实验室中运行它们时，我们将进行调整，使它们在Python捆绑的SQLite上运行。
- en: Are you wondering why MySQL isn't on the developer's workstation? It is true
    that MySQL is easy to install and not a huge performance load. But this scenario
    applies just the same if the production server is Oracle and management deems
    it too costly for our developers to be granted an individual license. Due to the
    cost of setting up a commercial database, this recipe is uses MySQL and SQLite
    rather than Oracle and SQLite.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道为什么MySQL不在开发人员的工作站上？MySQL确实很容易安装，而且性能负载不大。但是，如果生产服务器是Oracle，并且管理层认为为我们的开发人员授予单独的许可证成本太高，那么这种情况同样适用。由于设置商业数据库的成本，这个配方使用的是MySQL和SQLite，而不是Oracle和SQLite。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s look at the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Make sure the MySQL production database server is up and running:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MySQL生产数据库服务器正在运行：
- en: '![](../images/00139.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00139.jpeg)'
- en: Open a command-line MySQL client shell as the root user.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root用户身份打开命令行MySQL客户端shell。
- en: Create a database for this recipe called `recipe62` and a user with permission
    to access it.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方创建一个名为`recipe62`的数据库，并创建一个具有访问权限的用户。
- en: 'Exit the shell. Contrary to what is shown in the following screenshot, never,
    ever, ever create a live production database with passwords stored in the clear.
    This database is for demonstration purposes only:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出shell。与以下截图所示的情况相反，绝对不要创建一个存储在明文中的生产数据库密码。这个数据库仅用于演示目的：
- en: '![](../images/00140.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00140.jpeg)'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In these steps, we will see how to build tests that are aimed at different
    servers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，我们将看到如何构建针对不同服务器的测试：
- en: 'Create an alternate version of the SQL script called `recipe62_network.mysql`
    used in earlier recipes that uses MySQL conventions, as shown here:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe62_network.mysql`的SQL脚本的备用版本，该脚本在早期的配方中使用了MySQL约定，如下所示：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You might not have noticed, but this schema definition has no foreign key constraints.
    In a real-world SQL script, they should definitely be included. They were left
    out in this case to reduce complexity.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但这个模式定义没有外键约束。在真实的SQL脚本中，它们肯定应该被包含进去。在这种情况下，它们被省略是为了减少复杂性。
- en: Create a new module called `recipe62_test.py` to put our test code.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新模块`recipe62_test.py`来放置我们的测试代码。
- en: 'Create an abstract test case that has one test method verifying event-to-service
    correlation, as shown here:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有一个测试方法来验证事件到服务相关性的抽象测试用例，如下所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a concrete subclass that connects to the MySQL database and uses the
    MySQL script, as shown here:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连接到MySQL数据库并使用MySQL脚本的具体子类，如下所示：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a corresponding production test runner called `recipe62_production.py`,
    as shown here:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe62_production.py`的相应的生产测试运行程序，如下所示：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run it and verify that it connects with the production database:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它并验证它是否连接到生产数据库：
- en: '![](../images/00141.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00141.jpeg)'
- en: 'Now create a SQLite version of the SQL script called `recipe62_network.sql`,
    as shown here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个SQLite版本的SQL脚本，名为`recipe62_network.sql`，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create another concrete subclass of the abstract test case, have it connect
    as SQLite using the SQLite script, and add it to `recipe62_test.py`, as shown
    here:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建抽象测试用例的另一个具体子类，让它使用SQLite连接SQLite脚本，并将其添加到`recipe62_test.py`中，如下所示：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a corresponding development workstation test runner called `recipe62_dev.py`,
    as shown here:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe62_dev.py`的相应的开发工作站测试运行程序，如下所示：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run it and verify that it connects with the development database:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并验证它是否连接到开发数据库：
- en: '![](../images/00142.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00142.jpeg)'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It is not uncommon to have a production environment with full-fledged servers
    and software installed while at the same time having a smaller development environment.
    Some shops even have a test bed that is somewhere in between these configurations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中拥有完整的服务器和安装的软件，同时在较小的开发环境中也有是很常见的。一些商店甚至有一个介于这些配置之间的测试床。
- en: Our network application handles this situation by allowing database connection
    information to get injected into it. In each test case, we used the exact same
    application, but with different database systems.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络应用通过允许将数据库连接信息注入其中来处理这种情况。在每个测试用例中，我们使用完全相同的应用程序，但使用不同的数据库系统。
- en: We wrote a test case that used the production MySQL database, and we wrote a
    test case that used the development SQLite database. Of course, MySQL, even though
    it is used in many production environments, doesn't sound like something that's
    not available to developers. But it provides an easy-to-see example of having
    to switch database systems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个使用生产MySQL数据库的测试用例，还编写了一个使用开发SQLite数据库的测试用例。当然，MySQL，即使在许多生产环境中使用，也不像是开发人员无法使用的东西。但它提供了一个很容易看到的例子，即必须切换数据库系统。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we showed the need to switch database systems. This isn't the
    only type of external system that may require alternate configurations for test
    purposes. Other things, such as LDAP servers, third-party web services, and separate
    subsystems, may have totally different configurations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们展示了需要切换数据库系统。这不是唯一可能需要为测试目的提供备用配置的外部系统。其他东西，比如LDAP服务器、第三方Web服务和独立子系统，可能有完全不同的配置。
- en: I have worked on several contracts and have often seen members of management
    cut development lab resources to save costs. They seem to conclude that the cost
    of maintaining multiple configurations and handling non-reproducible bugs is less
    than the cost of having the exact same complement of equipment and software. I
    feel that this conclusion is faulty, because, at some time in the future, they
    end up buying more hardware and upgrade things due to increasing issues involving
    platform variance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在几个合同上工作过，经常看到管理人员削减开发实验室资源以节省成本。他们似乎得出结论，即维护多个配置和处理不可重现的错误的成本要低于拥有完全相同的设备和软件的成本。我觉得这个结论是错误的，因为在将来的某个时候，他们最终会因涉及平台差异的问题增加硬件并升级设备。
- en: This means we can't always write tests that target the production environment.
    Writing our software so that it has maximum flexibility, such as injecting database
    configuration, as we did earlier, is a minimum requirement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们并不总是能够编写针对生产环境的测试。编写我们的软件，使其具有最大的灵活性，比如注入数据库配置，正如我们之前所做的那样，是一个最低要求。
- en: 'It''s important that we write as many tests as possible that work on the developer''s
    platform. When developers have to start sharing server-side resources, then we
    run into resource collisions. For example, two developers sharing a single database
    server will have to do one of these things:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们尽可能多地编写在开发人员平台上运行的测试。当开发人员不得不开始共享服务器端资源时，我们就会遇到资源冲突。例如，两个开发人员共享一个单一的数据库服务器将不得不做以下事情之一：
- en: Have separate schemas so they can empty and load test data
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有单独的模式，这样它们就可以清空和加载测试数据
- en: Coordinate times when they each have access to the same schema
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调时间，使它们都可以访问相同的模式
- en: Have different servers set up for each developer
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个开发人员设置不同的服务器
- en: The third option is highly unlikely, given that we are talking about a development
    lab with a smaller footprint than the production one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是极不可能的，因为我们谈论的是一个比生产环境占地面积小得多的开发实验室。
- en: A positive note is that developers are getting faster and more powerful machines.
    Compared to 10 years ago, a commonly seen workstation far exceeds old server machines.
    But, even though we may each be able to run the entire software stack on our machine,
    it doesn't mean management will pay for all the necessary licensing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个积极的消息是，开发人员的机器变得更快更强大。与10年前相比，常见的工作站远远超过了旧的服务器机器。但是，即使我们每个人都能在自己的机器上运行整个软件堆栈，也并不意味着管理层会支付所有必要的许可费用。
- en: Unfortunately, this limitation may never change. Hence, we have to be ready
    to write tests for alternate configurations and manage the discrepancies with
    the production environment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种限制可能永远不会改变。因此，我们必须准备为备用配置编写测试，并管理与生产环境的差异。
- en: How likely is it that a development and production environment would use two
    different database systems?
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和生产环境使用两种不同的数据库系统的可能性有多大？
- en: Admittedly, it is unlikely to have something as big as switching between SQLite
    and MySQL. That alone requires slightly different dialects of SQL to define the
    schema. Some would immediately consider this too difficult to manage. But there
    are smaller differences in environment that can still yield the same need for
    reduced testing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，很少有人会在SQLite和MySQL之间进行如此大的切换。这本身就需要使用略有不同的SQL方言来定义模式。有些人可能会立刻认为这太难以管理了。但是环境中的较小差异仍然可能导致对减少测试的同样需求。
- en: I worked on a system for many years where the production system used Oracle
    9i RAC, while the development lab just had Oracle 9i. RAC required extra hardware,
    and we were never allocated the resources for it. To top it off, Oracle 9i was
    too big to install on the relatively lightweight PCs we developed with. While
    everything spoke Oracle's dialect of SQL, the uptime differences between RAC and
    non-RAC generated a fair number of bugs that we couldn't reproduce in the development
    lab. It really did qualify as two different database systems. Given that we couldn't
    work in the production environment, we tested as much as we could in the development
    lab and then scheduled time in the test lab where an RAC instance existed. Since
    many people needed access to that lab, we confined our usage to RAC-specific issues
    to avoid schedule delays.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经在一个系统上工作了很多年，该系统的生产系统使用的是Oracle 9i RAC，而开发实验室只有Oracle 9i。RAC需要额外的硬件，而我们从未为此分配资源。更糟糕的是，Oracle
    9i太大了，无法安装在我们开发的相对轻量级的个人电脑上。虽然所有内容都使用Oracle的SQL方言，但是RAC和非RAC之间的运行时间差异产生了大量我们无法在开发实验室中复现的错误。这确实可以算作两个不同的数据库系统。鉴于我们无法在生产环境中工作，我们尽可能在开发实验室进行测试，然后安排时间在测试实验室进行测试，那里有一个RAC实例。由于许多人需要访问该实验室，我们限制了我们对RAC特定问题的使用，以避免时间延迟。
- en: This isn't just confined to database systems
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这不仅仅局限于数据库系统
- en: As stated earlier, this isn't just about database systems. We have discussed
    MySQL, SQLite, and Oracle, but this also involves any sort of system we work with
    or depend on that varies between production and development environments.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，这不仅仅是关于数据库系统。我们已经讨论了MySQL、SQLite和Oracle，但这也涉及到我们工作或依赖的任何在生产和开发环境之间有差异的系统。
- en: Being able to code subsets of tests to achieve confidence can help cut down
    on the actual issues we will inevitably have to deal with.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写子集测试以获得信心可以帮助减少我们不可避免地必须处理的实际问题。
- en: Coding a data simulator
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写数据模拟器
- en: Coding a simulator that spits out data at a defined rate can help simulate real
    load.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个模拟器，以定义的速率产生数据，可以帮助模拟真实负载。
- en: This recipe assumes that the reader's machine is installed with MySQL.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱假设读者的机器已经安装了MySQL。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the MySQL production database server is up and running.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MySQL生产数据库服务器正在运行。
- en: Open a command-line MySQL client shell as the root user.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root用户身份打开命令行MySQL客户端shell。
- en: Create a database for this recipe called `recipe63` as well as a user with permission
    to access it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个食谱创建一个名为`recipe63`的数据库，以及一个具有访问权限的用户。
- en: 'Exit the shell as shown here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出shell，如下所示：
- en: '![](../images/00143.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00143.jpeg)'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'With these steps, we will explore coding a test simulator:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将探讨编写一个测试模拟器：
- en: 'Create a test generator script called `recipe63.py` that uses various Python
    libraries, as shown here:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe63.py`的测试生成器脚本，使用各种Python库，如下所示：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a usage method that prints out command-line options, as shown here:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个打印命令行选项的使用方法，如下所示：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use Python''s getopt library to parse command-line arguments, as shown here:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的getopt库来解析命令行参数，如下所示：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add a switch so when it's not in demo mode, it uses Spring Python's `PyroProxyFactory`
    to connect to a server instance of the network management application*:*
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个开关，这样当它不在演示模式下，它将使用Spring Python的`PyroProxyFactory`连接到网络管理应用程序的服务器实例：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Code an infinite loop that creates a random event, as shown here:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个创建随机事件的无限循环，如下所示：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If in demo mode, print out the event, as shown here:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在演示模式下，打印出事件，如下所示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If not in demo mode, make a remote call through the proxy to the network app''s
    process method, as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是在演示模式下，通过代理进行远程调用到网络应用程序的处理方法，如下所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sleep for a certain amount of time before repeating the loop, by using this
    code line:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重复循环之前休眠一段时间，使用这行代码：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the generator script. In the following screenshot, notice there is an error
    because we haven''t started the server process yet. This can also happen if the
    client and server have mismatched URLs:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行生成器脚本。在下面的屏幕截图中，请注意出现了错误，因为我们还没有启动服务器进程。如果客户端和服务器的URL不匹配，也会出现这种情况：
- en: '![](../images/00144.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00144.jpeg)'
- en: 'Create a server script called `recipe63_server.py` that will run our network
    management app connected to MySQL using the `recipe62_network.sql` SQL script from
    the *Targeting the test server* recipe, as shown here:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe63_server.py`的服务器脚本，该脚本将运行我们的网络管理应用程序，使用*定位测试服务器*食谱中显示的`recipe62_network.sql`
    SQL脚本连接到MySQL。
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add code to expose the app using Pyro, as shown here:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码以使用Pyro公开应用程序，如下所示：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the server script in a different shell:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的shell中运行服务器脚本：
- en: '![](../images/00145.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00145.jpeg)'
- en: 'The default rate is 10 events/second. Run the generator script with a rate
    of one event/second. In the following screenshot, notice how the script generated
    a clear, fault, and then another fault. The service started at Operational, moved
    to Outage, and stayed there:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认速率为每秒10个事件。以每秒一个事件的速率运行生成器脚本。在下面的截图中，注意脚本生成了一个清晰的故障，然后又一个故障。服务从运行状态转移到故障状态，并保持在那里：
- en: '![](../images/00146.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00146.jpeg)'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python's `random.choice` method makes it easy to create a range of random events.
    By using the `time.sleep` method, we can control the rate at which the events
    are created.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`random.choice`方法使得创建一系列随机事件变得容易。通过使用`time.sleep`方法，我们可以控制事件创建的速率。
- en: We used Pyro to connect the test generator to the network management application.
    This isn't the only way to connect things together. We could have exposed the
    application through other means, such as REST, JSON, or perhaps by communicating
    through a database table. That's not important. What is important is that we built
    an independent tool that fed data into our application as if it came from a live
    network.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Pyro将测试生成器连接到网络管理应用程序。这不是连接事物的唯一方式。我们可以通过其他方式暴露应用程序，比如REST、JSON，或者通过数据库表进行通信。这并不重要。重要的是我们建立了一个独立的工具，将数据输入到我们的应用程序中，就好像它来自于一个真实的网络。
- en: There's more...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We built a test generator. It's easy to run multiple copies of it in different
    shells, at different rates. We have an easy way to simulate different subnets
    producing different volumes of traffic.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了一个测试生成器。在不同的shell中以不同的速率运行多个副本很容易。我们有一种简单的方法来模拟不同子网产生不同量的流量。
- en: We could also add more command-line options to fine-tune the events. For example,
    we could make the event condition a parameter, and emulate different rates for
    different types of events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加更多的命令行选项来微调事件。例如，我们可以将事件条件作为参数，并模拟不同类型事件的不同速率。
- en: Why does the server script initialize the database?
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么服务器脚本要初始化数据库？
- en: A production version of the server wouldn't do this. For the demonstration purposes
    of this recipe, it is convenient to put it there. Every time we stop and start
    the server script, it relaunches the database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 生产版本的服务器不会这样做。对于这个配方的演示目的，把它放在那里很方便。每次我们停止和启动服务器脚本时，它都会重新启动数据库。
- en: Why MySQL instead of SQLite?
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用MySQL而不是SQLite？
- en: SQLite has some limitations when it comes to multithreading. Pyro uses multithreading,
    and SQLite can't pass objects across threads. SQLite is also relatively lightweight
    and probably not well-suited for a real network management application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite在多线程方面有一些限制。Pyro使用多线程，而SQLite无法在线程之间传递对象。SQLite也相对轻量，并且可能不适合真正的网络管理应用程序。
- en: See also
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Targeting the test server* recipe
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对测试服务器*配方'
- en: Recording and playing back live data in real time
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时录制和播放数据
- en: Nothing beats live production data. With this recipe, we will write some code
    to record live data. Then we will play it back with delays added to simulate playing
    back the live data stream.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比真实的生产数据更好。通过这个配方，我们将编写一些代码来记录实时数据。然后我们将播放它，并添加延迟以模拟播放实时数据流。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s look at the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: Make sure the MySQL production database server is up and running.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MySQL生产数据库服务器正在运行。
- en: Open a command line MySQL client shell as the root user.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root用户身份打开命令行MySQL客户端shell。
- en: Create a database for this recipe called `recipe64` as well as a user with permission
    to access it.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方创建一个名为`recipe64`的数据库，以及一个具有访问权限的用户。
- en: 'Exit the shell, as shown here:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里退出shell：
- en: '![](../images/00147.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00147.jpeg)'
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will see how to record and play back data in real-time
    pace:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将看到如何以实时速度记录和播放数据：
- en: 'Write a script called `recipe64_livedata.py` that simulates live data being
    sent every one to ten seconds, as shown here:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`recipe64_livedata.py`的脚本，模拟每一到十秒发送一次实时数据，如下所示：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Write a server script called `recipe64_server.py` that initializes the database
    using the SQL script `recipe62_network.mysql` from *Targeting the test server*,
    as shown here:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`recipe64_server.py`的服务器脚本，使用SQL脚本`recipe62_network.mysql`来初始化数据库，如下所示：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add some code that creates an instance of the network management application
    and advertises it using Pyro and Spring Python, as shown here:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，创建网络管理应用程序的实例，并使用Pyro和Spring Python进行广告发布，如下所示：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add some more code that defines an interceptor that captures incoming event
    data along with a time stamp to disk, as shown here:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，定义一个拦截器，将传入的事件数据和时间戳捕获到磁盘上，如下所示：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add some code that wraps the network management application with the interceptor
    and advertises it using Pyro, as shown here:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，使用拦截器包装网络管理应用程序，并使用Pyro进行广告发布，如下所示：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Start up the server app by typing `python recipe64_server.py`. Notice in the
    following screenshot that there is both a `network` service and a `network_advised`
    service registered with Pyro:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe64_server.py`启动服务器应用程序。请注意以下截图中Pyro注册了`network`服务和`network_advised`服务：
- en: '![](../images/00148.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00148.jpeg)'
- en: 'Run the live data simulator by typing `python recipe64_livedata.py` until it
    generates a few events, and then hit Ctrl+C to break out of it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`python recipe64_livedata.py`运行实时数据模拟器，直到生成一些事件，然后按Ctrl+C退出：
- en: '![](../images/00149.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00149.jpeg)'
- en: 'Look at the server-side of things, and notice how it recorded several events:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看服务器端的情况，并注意它记录了几个事件：
- en: '![](../images/00150.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00150.jpeg)'
- en: Inspect the `recipe64_data.txt` data file, noting how each line represents a
    separate event and time stamp. While it's hard to decipher the data stored in
    a pickled format, it's possible to spot bits and pieces.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`recipe64_data.txt`数据文件，注意每行代表一个单独的事件和时间戳。虽然很难解读封存格式中存储的数据，但仍然有可能发现一些片段。
- en: 'Create a script called `recipe64_playback.py` that de-pickles each line of
    the data file, as shown here:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe64_playback.py`的脚本，反封存数据文件的每一行，如下所示：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a function that finds the time interval between the current event and the
    previous one, as shown here:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，找到当前事件和上一个事件之间的时间间隔，如下所示：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define a client proxy to connect to the unadvised interface to our network
    management application, as shown here:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个客户端代理，连接到我们网络管理应用程序的未建议接口，如下所示：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add code that iterates over each event, calculating the difference, and then
    delaying the next event by that many seconds, as shown here:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码，迭代每个事件，计算差异，然后延迟下一个事件那么多秒，如下所示：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the playback script by typing `python recipe64_playback.py` and observe
    how it has the same delays as the original live data simulator did:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe64_playback.py`来运行播放脚本，并观察它与原始实时数据模拟器具有相同的延迟：
- en: '![](../images/00151.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00151.jpeg)'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Normally, we would be recording data coming in from the live network. In this
    situation, we need a simulator that generates random data. The simulator we coded
    in this recipe is very similar to the one shown in the *Coding a data simulator*
    recipe.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会记录来自实时网络的数据。在这种情况下，我们需要一个生成随机数据的模拟器。我们在这个配方中编写的模拟器与*编写数据模拟器*配方中显示的模拟器非常相似。
- en: 'To capture the data, we coded an interceptor that is embedded between Pyro
    and the network management application. Every event published to the `network_advised`
    Pyro service name seamlessly passes through this interceptor. Consider the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获数据，我们编写了一个拦截器，嵌入在Pyro和网络管理应用程序之间。发布到`network_advised` Pyro服务名称的每个事件都无缝地通过这个拦截器。考虑以下内容：
- en: Each event that comes in is appended to the data file that was initialized when
    the interceptor was first created.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个进来的事件都被追加到拦截器首次创建时初始化的数据文件中。
- en: The event is also stored with a copy of `datetime.now()` to capture a time stamp.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件还与`datetime.now()`的副本一起存储，以捕获时间戳。
- en: The event and time stamp are combined into a tuple and pickled, making it easy
    to write and later read back from disk.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件和时间戳被合并成一个元组并被封存，这样可以轻松地写入并稍后从磁盘读取。
- en: The data is pickled to make it easy to transfer to and from disk.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据被封存以便于在磁盘上进行传输。
- en: After writing it on to the disk, the interceptor calls the target service and
    passes the results back to the original caller.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其写入磁盘后，拦截器调用目标服务，并将结果传递回原始调用者。
- en: Finally, we have a playback script that reads in the data file, one event per
    line. It de-pickles each line into the tuple format it was originally stored in
    and builds a list of events.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个播放脚本，它读取数据文件，每行一个事件。它将每行反封存成最初存储的元组格式，并构建事件列表。
- en: The list of events is then scanned, one at a time. By comparing the current
    event's time stamp with the previous one, a difference in seconds is calculated
    to use Python's `time.sleep()` method to play the events back at the same rate
    they were recorded.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后逐个扫描事件列表。通过将当前事件的时间戳与上一个事件进行比较，计算出秒数差，使用Python的`time.sleep()`方法以相同的速率播放事件。
- en: The playback script uses Pyro to send the events into the network management
    application. But it talks to a different exposure point. This is to avoid re-recording
    the same event.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 播放脚本使用Pyro将事件发送到网络管理应用程序。但它与不同的暴露点进行通信。这是为了避免重新记录相同的事件。
- en: There's more...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The code in this recipe uses Pyro as the mechanism connecting clients and servers
    communicate in a publish/subscribe paradigm. This isn't the only way to build
    such a service. Python has XML-RPC built in as well. It just isn't as flexible
    as Pyro. A more thorough analysis of real traffic is needed to determine whether
    this interface is good enough. Alternatives include pushing events through a database
    EVENT table where the client inserts rows and the server polls the table for new
    rows, and then removes them as they are consumed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的代码使用Pyro作为连接客户端和服务器在发布/订阅范式中通信的机制。这不是构建这样一个服务的唯一方法。Python也内置了XML-RPC。只是它不像Pyro那样灵活。需要更彻底的实际流量分析来确定这个接口是否足够好。替代方案包括通过数据库EVENT表推送事件，客户端插入行，服务器轮询表格以获取新行，然后在消耗时删除它们。
- en: This recipe also makes heavy use of Spring Python for its **aspect-oriented
    programming** features to insert the data recording code ([http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html)).
    This provides a clean way to add the extra layer of functionality we need to sniff
    and record network traffic without having to touch the already-built network management
    code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方还大量使用Spring Python的**面向方面的编程**功能来插入数据记录代码([http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html))。这提供了一种干净的方式来添加我们需要的额外功能层，以便在不必触及已构建的网络管理代码的情况下，嗅探和记录网络流量。
- en: I thought this recipe was about live data!
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我以为这个配方是关于实时数据的！
- en: Well, the recipe is more about **recording** the live data and controlling the
    speed of playback. To capture this concept in a reusable recipe requires that
    we simulate the live system. But the fundamental concept of inserting a tap point
    in front of the network management processor, as we have done, is just as valid.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个配方更多地是关于**记录**实时数据和控制回放速度。为了在一个可重复使用的配方中捕捉这个概念，需要模拟实时系统。但在网络管理处理器前插入一个监听点的基本概念，就像我们所做的那样，同样有效。
- en: Is opening and closing a file for every event a good idea?
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个事件打开和关闭文件是一个好主意吗？
- en: The recipe was coded to ensure that stopping the recording would incur a minimal
    risk of losing captured data not yet written to disk. Analysis of production data
    is required to determine the most efficient way of storing data. For example,
    it may take less I/O intense to write data in batches of 10, or perhaps 100 events.
    But the risk is that data can be lost in similar bundles.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 编写该配方是为了确保停止记录不会造成损失尚未写入磁盘的捕获数据的最小风险。需要分析生产数据以确定存储数据的最有效方式。例如，批量写入数据可能需要较少的I/O强度，也许是10个或者100个事件的批量。但风险在于数据可能会在类似的捆绑中丢失。
- en: If the volume of traffic is low enough, writing each event one by one, as shown
    in this recipe, may not be a problem at all.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流量量足够低，按照本配方中所示，逐个写入每个事件可能根本不是问题。
- en: What about offloading the storage of data?
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于数据存储的卸载呢？
- en: It is not uncommon to have the actual logic of opening the file, appending the
    data, and then closing the file contained in a separate class. This utility could
    then be injected into the interceptor we built. This may become important if some
    more elaborate means to storing or piping the data is needed. For example, another
    Pyro service may exist in another location that wants a copy of the live data
    feed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，打开文件、追加数据，然后关闭文件的实际逻辑包含在一个单独的类中。然后可以将此实用程序注入到我们构建的拦截器中。如果需要一些更复杂的方式来存储或传输数据，这可能变得很重要。例如，另一个Pyro服务可能存在于另一个位置，希望获得实时数据源的副本。
- en: Injecting the data consumer into the aspect we coded would give us more flexibility.
    In this recipe, we don't have such requirements, but it's not hard to imagine
    making such adjustments as new requirements arrive.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据消费者注入我们编写的方面将使我们更加灵活。在这个配方中，我们没有这样的要求，但很容易想象在新要求到来时进行这样的调整。
- en: See also
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Writing* *a data simulator* recipe
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写一个数据模拟器的配方
- en: The *Recording and playing back live data as fast as possible* recipe
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能快地记录和回放实时数据的配方
- en: Recording and playing back live data as fast as possible
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和尽可能快地回放实时数据
- en: Replaying production data as fast as possible (instead of in real time) can
    give you insight into where your bottlenecks are.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能快地重放生产数据（而不是实时），可以让您了解瓶颈在哪里。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the MySQL production database server is up and running.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MySQL生产数据库服务器正常运行。
- en: Open a command-line MySQL client shell as the root user.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root用户身份打开命令行MySQL客户端shell。
- en: Create a database for this recipe called `recipe65` as well as a user with permission
    to access it.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个配方创建一个名为`recipe65`的数据库，以及一个具有访问权限的用户。
- en: 'Exit the shell, as shown here:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出shell，如下所示：
- en: '![](../images/00152.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00152.jpeg)'
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In these steps, we will write some code that lets us put a big load on our
    system:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，我们将编写一些代码，让我们的系统承受重大负载：
- en: 'Write a script called `recipe65_livedata.py` that simulates live data being
    sent every one to ten seconds, as shown here:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`recipe65_livedata.py`的脚本，模拟每一到十秒发送一次实时数据，如下所示：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Write a server script called `recipe65_server.py` that initializes the database
    using the SQL script `recipe62_network.mysql` from the *Targeting the test server *recipe,
    as shown here:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`recipe65_server.py`的服务器脚本，使用SQL脚本`recipe62_network.mysql`来初始化数据库，如下所示：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add some code that creates an instance of the network management application
    and advertises it using Pyro and Spring Python, as shown here:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，创建网络管理应用程序的实例，并使用Pyro和Spring Python进行广告发布，如下所示：
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add some more code that defines an interceptor that captures incoming event
    data along with a time stamp on disk, as shown here:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些更多的代码，定义一个拦截器，捕获磁盘上的传入事件数据以及时间戳，如下所示：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add some code that wraps the network management application with the interceptor
    and advertises it using Pyro, as shown here:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，用拦截器包装网络管理应用程序，并使用Pyro进行广告发布，如下所示：
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Start up the server app by typing `python recipe65_server.py`. In the following
    screenshot, notice that there is both a `network` service and a `network_advised`
    service registered with Pyro:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe65_server.py`来启动服务器应用程序。在下面的屏幕截图中，请注意Pyro注册了`network`服务和`network_advised`服务：
- en: '![](../images/00153.jpeg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00153.jpeg)'
- en: 'Run the live data simulator by typing `python recipe65_livedata.py` and watch
    it run until it generates a few events, and then hit *Ctrl*+*C* to break out of
    it:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe65_livedata.py`来运行实时数据模拟器，并观察它运行直到生成一些事件，然后按下*Ctrl*+*C*来中断它：
- en: '![](../images/00154.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00154.jpeg)'
- en: 'Look at the server side of things, and notice how it recorded several events:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看服务器端的情况，并注意它记录了几个事件：
- en: '![](../images/00155.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00155.jpeg)'
- en: Inspect the `recipe65_data.txt` data file, noting how each line represents a
    separate event and time stamp. While it's hard to decipher the data stored in
    a pickled format, it's possible to spot bits and pieces.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`recipe65_data.txt`数据文件，注意每行代表一个单独的事件和时间戳。虽然很难解密以pickled格式存储的数据，但可能会发现一些片段。
- en: 'Create a playback script called `recipe65_playback.py` that de-pickles each
    line of the data file, as shown here:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe65_playback.py`的回放脚本，解pickle化数据文件的每一行，如下所示：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define a client proxy to connect to the unadvised interface to our network
    management application, as shown here:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个客户端代理，连接到我们网络管理应用程序的未建议接口，如下所示：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add code that iterates over each event, playing back the events as quickly
    as possible, as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码，迭代每个事件，尽可能快地回放事件，如下所示：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the playback script by typing `python recipe65_playback.py`, observing
    how it doesn''t delay events but instead plays them back as quickly as possible:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe65_playback.py`来运行播放脚本，观察它不会延迟事件，而是尽可能快地回放事件：
- en: '![](../images/00156.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00156.jpeg)'
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Normally, we would be recording data coming in from the live network. In this
    situation, we need a simulator that generates random data. The simulator we coded
    in this recipe is very similar to the one shown in the *Coding a data simulator*
    recipe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会记录来自实时网络的数据。在这种情况下，我们需要一个生成随机数据的模拟器。我们在这个方法中编写的模拟器与*编写数据模拟器*方法中显示的模拟器非常相似。
- en: 'To capture the data, we coded an interceptor that is embedded between Pyro
    and the network management application. Every event published to the `network_advised`
    Pyro service name seamlessly passes through this interceptor. Consider the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获数据，我们编写了一个拦截器，它嵌入在Pyro和网络管理应用程序之间。每个发布到`network_advised` Pyro服务名称的事件都无缝地通过这个拦截器。考虑以下情况：
- en: Each event that comes in is appended to the data file that was initialized when
    the interceptor was first created.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进来的事件都被追加到拦截器首次创建时初始化的数据文件中。
- en: The event is also stored with a copy of `datetime.now()` to capture a time stamp.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件还存储了`datetime.now()`的副本以捕获时间戳。
- en: The event and time stamp are combined into a tuple, and pickled, making it easy
    to write and later read back from disk.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件和时间戳被合并成一个元组，并被序列化，这样可以轻松地写入和稍后从磁盘中读取。
- en: The data is pickled to make it easy to transfer to and from disk.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被序列化以便于在磁盘上传输。
- en: After writing it to disk, the interceptor calls the target service and passes
    the results back to the original caller.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其写入磁盘后，拦截器调用目标服务，并将结果传递回原始调用者。
- en: Finally, we have a playback script that reads in the data file, one event per
    line. It de-pickles each line into the tuple format it was originally stored in,
    and builds a list of events.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个回放脚本，它读取数据文件，每行一个事件。它将每一行反序列化成最初存储的元组格式，并构建一个事件列表。
- en: The list of events is then scanned, one at a time. Instead of evaluating the
    time stamps to figure out how long to delay playing back the events, they are
    injected immediately into the network management application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后逐个扫描事件列表。不是通过评估时间戳来确定延迟播放事件的时间，而是立即将其注入到网络管理应用程序中。
- en: The playback script uses Pyro to send the events in to the network management
    application, but it talks to a different exposure point. This is to avoid re-recording
    the same event.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 回放脚本使用Pyro将事件发送到网络管理应用程序，但它与不同的暴露点进行通信。这是为了避免重新记录相同的事件。
- en: There's more...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The code in this recipe uses Pyro as the mechanism connecting clients and servers
    communicates in a publish/subscribe paradigm. This isn't the only way to build
    such a service. Python has XML-RPC built in as well. It just isn't as flexible
    as Pyro. A more thorough analysis of real traffic is needed to determine whether
    this interface is good enough. Alternatives include pushing events through a database
    EVENT table where the client inserts rows and the server polls the table for new
    rows, and then removes them as they are consumed.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中的代码使用Pyro作为连接客户端和服务器的机制，以发布/订阅范式进行通信。这并不是构建这样一个服务的唯一方式。Python也内置了XML-RPC。只是它没有Pyro灵活。需要更彻底的实时流量分析来确定这个接口是否足够好。替代方案包括通过数据库EVENT表推送事件，其中客户端插入行，服务器轮询表以获取新行，然后在消耗后删除它们。
- en: This recipe also makes heavy use of Spring Python for its **aspect-oriented
    programming** features to insert the data recording code ([http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html)).
    This provides a clean way to add the extra layer of functionality we need to sniff
    and record network traffic without having to touch the existing network management
    code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法还大量使用了Spring Python的**面向方面的编程**功能来插入数据记录代码（[http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html)）。这提供了一种清晰的方式来添加我们需要的额外功能层，以便在不触及现有网络管理代码的情况下嗅探和记录网络流量。
- en: What is the difference between this and playing back in real time?
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与实时回放有什么不同？
- en: Real-time playback is useful to see how the system handles production load.
    But this doesn't answer the question of where the system is expected to break.
    Traffic flow is never steady. Instead, it often has bursts that are not expected.
    That is when playing back live data at an accelerated rate will help expose the
    system's next breakpoints.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 实时回放对于查看系统如何处理生产负载很有用。但这并不能回答系统预计会在哪里出现问题的问题。流量永远不是稳定的。相反，它经常有意外的突发情况。这时以加速的速率回放实时数据将有助于暴露系统的下一个瓶颈。
- en: Preemptively addressing some of these concerns will make our system more resilient.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 预先解决一些这些问题将使我们的系统更具弹性。
- en: Where are the breaking points of this application?
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个应用程序的瓶颈在哪里？
- en: Admittedly, this recipe didn't break when we played back four events as fast
    as possible. Would this be the same result in production? Things break in different
    ways. We may not get a real exception or error message but instead discover that
    certain parts of the system become backlogged.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，当我们以最快的速度回放四个事件时，这个方法并没有崩溃。在生产中会得到相同的结果吗？事情以不同的方式崩溃。我们可能不会得到真正的异常或错误消息，而是发现系统的某些部分变得积压。
- en: That is where this recipe reaches its limit. While we have demonstrated how
    to overload the system with a large volume of traffic, we are not showing how
    to monitor where the bottlenecks are.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个方法的极限所在。虽然我们已经演示了如何通过大量的流量来过载系统，但我们没有展示如何监视瓶颈所在。
- en: 'If the application under load uses database tables to queue up work, then we
    would need to write the code that monitors them all and report the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负载下的应用程序使用数据库表来排队工作，那么我们需要编写监视它们并报告以下情况的代码：
- en: Which one is the longest
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪一个是最长的
- en: Which one is getting longer, and showing no sign of catching up
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪一个正在变得更长，并且没有显示追赶的迹象
- en: Which one is the earliest in the pipeline of activity
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪一个是活动管道中最早的
- en: In systems with stages of processing, there is often one bottleneck that makes
    itself known. When that bottleneck is fixed, it is rarely the only bottleneck.
    It was simply either the most critical one or the first one in a chain.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有处理阶段的系统中，通常会出现一个明显的瓶颈。当解决了该瓶颈时，很少是唯一的瓶颈。它只是最关键的瓶颈或者是链中的第一个瓶颈。
- en: Also, this recipe cannot solve your bottleneck. The purpose of this recipe is
    to find it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个配方不能解决你的瓶颈问题。这个配方的目的是找到它。
- en: I once built a network load tester very much like this one. The code could handle
    processing lots of traffic in parallel, but events from the same device had to
    be processed in order. Replaying a days worth of events all at once exposed the
    fact that too many events from the same device caused the entire queue system
    to become overloaded and starve out handling other devices. After improving the
    service update algorithm, we were able to replay the same load test and verify
    it could keep up. This helped avoid non-reproducible outages that happened after
    hours or on weekends.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经构建过一个非常类似的网络负载测试工具。代码可以并行处理大量的流量，但来自同一设备的事件必须按顺序处理。一次性重放一天的事件暴露了这样一个事实，即来自同一设备的太多事件会导致整个队列系统过载并使其他设备的处理受阻。改进服务更新算法后，我们能够重放相同的负载测试并验证它能够跟上。这有助于避免在非工作时间或周末发生的不可重现的故障。
- en: What amount of live data should be collected?
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该收集多少实时数据？
- en: It is useful for capturing things such as a 24-hour block of traffic to allow an
    entire day of events to be played back. Another possibility is an entire week.
    Live systems may be apt to have different loads on weekends rather than weekdays,
    and a week of data will allow better investigation.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获诸如一天的交通量块之类的东西是很有用的，这样可以让整天的事件都被回放。另一个可能性是整整一周。实时系统可能在周末和工作日有不同的负载，一周的数据将有助于更好地调查。
- en: The problem with this much data is that it is hard to pick out a window to investigate.
    This is why 24 hours of data from the weekend and 24 hours of data during the
    week may be more practical.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这么多数据的问题在于很难挑选一个窗口进行调查。这就是为什么周末的24小时数据和工作日的24小时数据可能更实际。
- en: If there is some sort of network instability where huge outages are occurring
    and causing a huge flow of traffic, it may be useful to turn on the collector
    and wait for another similar outage to occur. After such an outage occurs, it
    may be useful to shift through the data file and trim it down to where the uptick
    in traffic occurred.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在某种网络不稳定性，导致大规模的故障并引起大量的流量，打开收集器并等待另一个类似的故障发生可能是有用的。在发生这样的故障之后，可能有必要浏览数据文件并将其修剪到流量增加的位置。
- en: These types of captured scenarios are invaluable in load testing new releases,
    because they confirm that new patches either improve performance as expected,
    or at least don't reduce performance when fixing non-performance issues.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的捕获场景在加载测试新版本时非常有价值，因为它们确认新补丁是否像预期的那样提高了性能，或者至少在修复非性能问题时没有降低性能。
- en: See also
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Writing a data simulator* recipe
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写数据模拟器*配方'
- en: The *Recording and playing back live data in real-time* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时录制和播放数据*配方'
- en: Automating your management demo
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化您的管理演示
- en: Got a demo coming? Write automated tests that simulate the steps you'll be taking.
    Then print out your test suite, and use it like a script.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有演示吗？编写模拟执行你将要执行的步骤的自动化测试。然后打印出你的测试套件，并像脚本一样使用它。
- en: How to do it...
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With these steps, we will see how to write our management demo script in a
    runnable fashion:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将看到如何以可运行的方式编写我们的管理演示脚本：
- en: Create a new file called `recipe66.py` for the test code for our management
    demo.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`recipe66.py`的新文件，用于我们管理演示的测试代码。
- en: Create a `unittest` test scenario to capture your demo.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`unittest`测试场景来捕捉你的演示。
- en: Write a series of operations as if you were driving the application from this
    automated test.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一系列操作，就好像你正在从这个自动化测试中驱动应用程序。
- en: 'Include asserts at every point where you will vocally point out something during
    the demo. Take a look at this code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在演示期间的每个点都包含断言。看一下这段代码：
- en: '[PRE55]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the test suite by typing `python recipe66.py`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`python recipe66.py`来运行测试套件：
- en: '![](../images/00157.jpeg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00157.jpeg)'
- en: How it works...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is more philosophical and less code-based. While the concept of
    this recipe is valuable, it is hard to capture in a single nugget of reusable
    code.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方更多的是哲学性的，而不是基于代码的。虽然这个配方的概念很有价值，但很难用一个可重复使用的代码片段来捕捉。
- en: In this test case, I inject an event, process it, and then confirm what it impacts.
    This test case is headless, but our demo probably won't be. So far in this chapter,
    we haven't built any user screens. As we develop user screens, we need to ensure
    they call the same APIs this automated test calls.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，我注入一个事件，处理它，然后确认它的影响。这个测试用例是无头的，但我们的演示可能不会是。到目前为止，在本章中，我们还没有构建任何用户屏幕。随着我们开发用户屏幕，我们需要确保它们调用与这个自动化测试相同的API。
- en: Given this, we are set up to use the screens to define the same event shown
    in the test. After the event is digested, another screen will probably exist that
    shows current service status. We would expect it to reflect the update to Outage.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我们设置使用屏幕来定义测试中显示的相同事件。事件被消化后，可能会存在另一个屏幕显示当前的服务状态。我们期望它能反映对故障的更新。
- en: During our management demo, we will then point out/zoom in to this part of the
    screen and show how `service-abc` switched from *Operational* to *Outage.*
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管理演示中，我们将指出/放大屏幕的这一部分，并展示`service-abc`从*运行*切换到*故障*。
- en: If the screens are built to delegate to this underlying logic, then the screen
    logic is little more than components put together to display information. The
    core logic being tested maintains its headless and easy-to-test nature.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕被构建为委托给底层逻辑，那么屏幕逻辑只不过是组件组合在一起显示信息。被测试的核心逻辑保持其无头和易于测试的特性。
- en: Our code sample isn't complete, and wouldn't amount to more than a one minute
    demo. But the concept is sound. By capturing the steps we plan to execute in our
    demo in a runnable form, our management demo should go off without a hitch.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例并不完整，也不会超过一分钟的演示。但这个概念是正确的。通过以可运行的形式捕捉我们计划在演示中执行的步骤，我们的管理演示应该会顺利进行。
- en: Did I say without a hitch? Well, demos rarely work that well. Doesn't something
    about management appearances cause things to break? At one time, I began prepping
    for a senior management demo a month in advance using this recipe. I uncovered
    and subsequently fixed several bugs, such that my demo worked flawlessly. Management
    was impressed. I'm not making any promises here, but sincerely making your demo
    100% runnable will greatly increase your odds.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我说了没有问题吗？嗯，演示很少能够那么顺利。管理层的出现难道不会导致问题出现吗？有一次，我提前一个月准备了一次高级管理演示，使用了这个秘诀。我发现并随后修复了几个错误，以至于我的演示完美无缺。管理层印象深刻。我在这里并不做任何承诺，但真诚地让你的演示100%可运行将极大地增加你的成功几率。
- en: There's more...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What is the secret to this recipe? It seems to be a bit short on code. While
    it's important to make the demo 100 percent runnable, the key is then printing
    out the test and using it like a script. That way, the only steps you are taking
    have already been proven to work.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个秘诀是什么？它似乎有点缺少代码。虽然让演示100%可运行很重要，但关键是打印出测试并像脚本一样使用它。这样，你所采取的步骤都已经被证明有效。
- en: What if my manager likes to take detours?
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我的经理喜欢绕道走？
- en: If your manager likes to ask lots of what-if questions that pull you off-script,
    then you are sailing into uncharted territory. Your odds for a successful demo
    may drop quickly.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的经理喜欢问很多假设性问题，让你偏离原计划，那么你就是在未知的领域航行。你成功进行演示的几率可能会迅速下降。
- en: You can politely dodge this by capturing their what-ifs for a future demo and
    try to keep the current one on track. If you take the plunge to try other things
    out, realize the risk you are taking.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以客气地推迟他们的假设问题，留到未来的演示中再试，努力保持当前的演示在正轨上。如果你冒险尝试其他事情，要意识到你所承担的风险。
- en: 'Don''t be afraid to promise a future demo where you will travel down the path
    requested instead of risking it in this demo. Managers are actually pretty open
    to accepting a response such as: *I haven''t tested that yet. How about another
    demo next month where we cover that?* Failed demos leave a bad taste in the mouth
    of management and put your reputation in jeopardy. Successful ones have an equally
    positive effect on your reputation as a developer. Management tends to have a
    more optimistic view of seeing 70% of the system succeed 100% rather than 100%
    of the system succeed 70%.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕承诺未来的演示，届时你将按照要求的路径前行，而不是在这次演示中冒险。经理们实际上相当愿意接受这样的回答：*我还没有测试过那个。下个月我们再做一个演示，包括那个内容，怎么样？*失败的演示会给管理层留下不好的印象，并危及你的声誉。成功的演示对你作为开发者的声誉也会产生同样积极的影响。管理层倾向于更乐观地看待系统70%成功100%，而不是系统100%成功70%。
- en: This is where the line between engineer and manager needs to be observed. While
    managers want to see what's available, it is our job to show them what is currently
    working and give an accurate status on what is and isn't available. Asking to
    see something we haven't tested yet definitely warrants pushing back and telling
    them such a demo isn't ready yet.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是工程师和经理之间需要遵守的界限。虽然经理们想要看到现有的东西，但我们的工作是向他们展示目前正在运行的东西，并准确地报告目前可用和不可用的情况。要求看到我们尚未测试过的东西绝对值得反驳，并告诉他们这样的演示还没有准备好。
