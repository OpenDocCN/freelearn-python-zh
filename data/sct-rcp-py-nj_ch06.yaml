- en: Improving Python Performance with PyPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyPy 提高 Python 性能
- en: 'In this chapter, we will cover PyPy, a compiled version of Python that aims
    to increase the performance of Python programs. We will talk about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 PyPy，这是 Python 的编译版本，旨在提高 Python 程序的性能。我们将讨论以下内容：
- en: What is PyPy?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 PyPy？
- en: What is RPython?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 RPython？
- en: Some real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些真实世界的例子
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Python is an interpreted language. Interpreted languages use middleware to read
    the source code and generate system-specific machine language. Compiled languages
    use a compiler to convert the source code directly into machine language; there
    is no middle step in the process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种解释型语言。解释型语言使用中间件来读取源代码并生成特定系统的机器语言。编译型语言使用编译器将源代码直接转换为机器语言；在这个过程中没有中间步骤。
- en: The benefit of compiled languages is that, without the interpretation step,
    the code is executed directly by the system and yields the fastest processing
    time available. In addition, compilers have the ability to look at the source
    code as it is being converted and apply optimizations to make the machine code
    that much faster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言的好处是，没有解释步骤，代码可以直接由系统执行，并产生最快的处理时间。此外，编译器能够在将源代码转换为机器代码的过程中查看源代码，并应用优化以使机器代码更快。
- en: For example, if the compiler is analyzing the source code and sees that code
    spends a large amount of time in a particular loop, it can apply one of several
    optimization algorithms to the code to improve performance, such as breaking a
    single loop into multiple loops that each process a smaller part of the original
    loop's body.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果编译器正在分析源代码，并看到代码在某个特定的循环中花费了大量时间，它可以将代码应用几种优化算法之一来提高性能，例如将单个循环拆分成多个循环，每个循环处理原始循环体的一部分。
- en: 'Conversely, interpreted languages make the life of a programmer easier, as
    the languages tend to be easier to code in and they generally have an interactive
    prompt, allowing a developer to test code before putting it into the final program.
    This leads to another point about interpreted languages: they don''t have a compilation
    step so seeing the results of a program is more or less immediate. If there is
    a bug in the code, the developer knows immediately rather than after the (potentially
    long) compilation. (While most bugs are identified by the compiler during compilation,
    there are some bugs that won''t be caught, such as those identified at [http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/](http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/).)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，解释型语言使程序员的编程生活更加轻松，因为这些语言通常更容易编写，并且它们通常有一个交互式提示，允许开发者在将其放入最终程序之前测试代码。这导致了解释型语言的另一个观点：它们没有编译步骤，因此看到程序的结果几乎是即时的。如果代码中存在错误，开发者会立即知道，而不是在（可能很长的）编译之后。（虽然大多数错误都是在编译过程中由编译器识别的，但也有一些错误不会被捕获，例如在
    [http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/](http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/)
    中识别的错误。)
- en: 'Just as a quick example of the possible speed differences that can occur between
    interpreted and compiled languages, here are some times for C++ versus Python
    from [https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&amp;lang2=gpp](https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&lang2=gpp):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速示例，说明解释型语言和编译型语言之间可能出现的速度差异，以下是一些来自 [https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&lang2=gpp](https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&lang2=gpp)
    的 C++ 与 Python 的时间比较：
- en: '| **Task** | **Python (secs)** | **C++ (secs)** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **Python (secs)** | **C++ (secs)** |'
- en: '| Pi digits | 3.43 | 1.88 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| π 数字 | 3.43 | 1.88 |'
- en: '| Reverse complement | 18.79 | 3.08 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 反向互补 | 18.79 | 3.08 |'
- en: '| Regex redux | 15.22 | 1.61 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式更新 | 15.22 | 1.61 |'
- en: '| Mandelbrot | 225.24 | 1.51 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 曼德布罗特 | 225.24 | 1.51 |'
- en: What is PyPy?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 PyPy？
- en: 'PyPy is an alternative implementation of Python. While normal Python is built
    using the C language (hence the alternative term: CPython), PyPy is built on the
    **RPython** (**Restricted Python**) language . RPython constrains the Python language;
    these constraints mean that PyPy can look at the RPython code, translate it into
    C code, and then compile it to machine code.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy 是 Python 的另一种实现。虽然正常的 Python 是使用 C 语言构建的（因此有替代术语：CPython），但 PyPy 是基于 **RPython**（**受限
    Python**）语言的。RPython 限制了 Python 语言；这些限制意味着 PyPy 可以查看 RPython 代码，将其转换为 C 代码，然后编译成机器代码。
- en: The main aspects of PyPy is the **just-in-time**** (JIT)** compiler. Specifically,
    it uses a tracing JIT, which monitors frequently executed loops and compiles them
    into native machine code. Since programs frequently spend much of their time in
    loops, compiling those loops to native code maximizes the speed at which they
    process data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy的主要方面是**即时编译器**（JIT）。具体来说，它使用跟踪JIT，该JIT监视频繁执行的循环并将它们编译成本地机器代码。由于程序经常花费大量时间在循环中，将这些循环编译成本地代码最大化它们处理数据的速度。
- en: Using RPython, the JIT compiler receives known code, that is, the compiler doesn't
    have to spend time parsing the metadata of the code to determine what type an
    object is, how much memory space is taken up, and so on. Thus, it is able to effectively
    convert the CPython code into C code and then to native assembly language for
    the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RPython时，JIT编译器接收已知的代码，即编译器不需要花费时间解析代码的元数据来确定对象的类型、占用的内存空间等。因此，它能够有效地将CPython代码转换为C代码，然后转换为系统的本地汇编语言。
- en: 'While object types are still inferred, like normal Python, and are not declared
    like statically typed languages, each variable can only have one type associated
    with it and cannot change later in the code. For example, a favorite thing to
    show about Python is that the following are both legitimate variable assignments
    in Python; `x` has no inherited knowledge about itself so it can be changed at
    any time:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对象类型仍然像正常Python一样推断，不像静态类型语言那样声明，但每个变量只能与一个类型相关联，并且在代码中不能更改。例如，关于Python的一个常见展示是以下都是Python中的合法变量赋值；`x`没有关于自己的继承知识，因此可以随时更改：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But with RPython, this would not be allowed because, once a variable is declared,
    even if as something like an empty list, it can never change types, for example,
    converting from a list to a tuple.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但在RPython中，这不被允许，因为一旦变量被声明，即使像空列表一样，它永远不能更改类型，例如，从列表转换为元组。
- en: Because it is different from CPython, there may be compatibility issues when
    using PyPy. While their designers strive to provide maximum compatibility between
    the two implementations, there are some known problems ([http://pypy.org/compat.html](http://pypy.org/compat.html)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与CPython不同，使用PyPy时可能存在兼容性问题。尽管它们的设计师努力提供两个实现之间的最大兼容性，但有一些已知问题([http://pypy.org/compat.html](http://pypy.org/compat.html))。
- en: 'The main features of PyPy are the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy的主要功能如下：
- en: 'Speed: Currently, PyPy is an average of 7.6x faster than CPython ([http://speed.pypy.org](http://speed.pypy.org)).
    Depending on the module, speed improvements can be up to 98%. Note that there
    are two main cases where PyPy will not provide a speed increase:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度：目前，PyPy的平均速度比CPython快7.6倍([http://speed.pypy.org](http://speed.pypy.org))。根据模块的不同，速度提升可以达到98%。请注意，有两种主要情况PyPy不会提供速度提升：
- en: Programs that are too short for the JIT compiler to warm up. A program has to
    run for a few seconds, so a large number of simple scripts will not benefit from
    PyPy.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于JIT编译器来说太短，无法预热的应用程序。一个程序必须运行几秒钟，因此大量简单的脚本将无法从PyPy中受益。
- en: Obviously, if the program isn't running Python code but is working with runtime
    libraries such as C functions (for example, Python is just a glue language between
    blocks of compiled code) you won't notice a performance difference with PyPy.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，如果程序不是运行Python代码，而是使用运行时库，例如C函数（例如，Python只是编译代码块之间的粘合语言），那么你不会注意到PyPy的性能差异。
- en: 'Memory usage: PyPy programs tend to have better memory management than CPython,
    that is, hundreds of MBs in size. While it isn''t always the case, there may be
    some resource improvement through PyPy, though it depends on the details of the
    program.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用：PyPy程序通常比CPython有更好的内存管理，即几百MB的大小。虽然这并不总是如此，但可能通过PyPy有一些资源改进，尽管这取决于程序的细节。
- en: Stackless support is integrated into PyPy, allowing improved concurrent processing
    support.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPy集成了Stackless支持，允许改进的并发处理支持。
- en: 'Other languages implement RPython: Prolog, Smalltalk, JavaScript, Io, Scheme,
    Gameboy, Ruby (called Topaz), and PHP (called HippyVM).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他语言实现了RPython：Prolog、Smalltalk、JavaScript、Io、Scheme、Gameboy、Ruby（称为Topaz）和PHP（称为HippyVM）。
- en: A prototype sandbox environment is available for testing. It is designed to
    replace calls to external libraries with a code stub that handles communications
    with an external process that handles the policy.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用原型沙箱环境进行测试。它旨在用处理与外部进程通信的代码占位符替换对外部库的调用，该外部进程处理策略。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Installing PyPy can be easy or hard, depending on your system. Binaries are
    available ([http://pypy.org/download.html#default-with-a-jit-compiler](http://pypy.org/download.html#default-with-a-jit-compiler))
    for x86, ARM, PowerPC, and s390x CPUs for Windows, macOS, and Linux OSes. In addition,
    Python 2.7 and 3.5 versions are available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 PyPy 可能很简单或很困难，这取决于你的系统。二进制文件适用于 Windows、macOS 和 Linux 操作系统的 x86、ARM、PowerPC
    和 s390x CPU，并且提供了 Python 2.7 和 3.5 版本。
- en: If installing on Linux, binaries are only usable for the distributions they
    are compiled for. Unfortunately, this means that many more recent distribution
    versions are out of luck. For example, the latest Ubuntu version supported is
    16.04, while Windows doesn't have a 64-bit version available. If you don't use
    a binary that is expressly written for your version, you will most likely get
    error messages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Linux 上安装，二进制文件仅适用于它们编译的发行版。不幸的是，这意味着许多更新的发行版版本将无法使用。例如，支持的最新 Ubuntu 版本是
    16.04，而 Windows 没有可用的 64 位版本。如果你不使用为你的版本专门编写的二进制文件，你很可能会收到错误消息。
- en: If you are running Linux and it isn't one of the distributions listed in the
    downloads site, you have the choice of hacking your distribution to make things
    work, or trying out the portable PyPy binary. Portable PyPy is an attempt to write
    a 64-bit x86-compatible binary for a variety of Linux distributions without requiring
    additional libraries or OS configuration changes. These portable binaries are
    created using Docker, so while they should work without issue, like any technology,
    your mileage may vary.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 Linux，并且它不是下载网站上列出的发行版之一，你可以选择修改你的发行版以使其工作，或者尝试便携式 PyPy 二进制文件。便携式 PyPy
    是尝试为各种 Linux 发行版编写 64 位 x86 兼容的二进制文件，而无需额外的库或操作系统配置更改。这些便携式二进制文件是使用 Docker 创建的，因此虽然它们应该没有问题地工作，但像任何技术一样，你的体验可能会有所不同。
- en: In addition to PyPy, these portable binaries include `virtenv` to keep everything
    separate, as well as providing OpenSSL, SQLite3, libffi, expat, and Tcl/Tk.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 PyPy，这些便携式二进制文件还包括 `virtenv` 以保持一切分离，并提供 OpenSSL、SQLite3、libffi、expat 和 Tcl/Tk。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To run PyPy, simply go to the location where you placed the binary and call
    PyPy:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 PyPy，只需前往放置二进制文件的目录并调用 PyPy：
- en: '![](img/57cd3fbb-f88f-412a-829e-6c4a19243655.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57cd3fbb-f88f-412a-829e-6c4a19243655.png)'
- en: As can be seen, it looks like a standard Python interactive interpreter, so
    you can experiment with your code as normal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，它看起来像标准的 Python 交互式解释器，因此你可以像平常一样实验你的代码。
- en: 'For a simple test to demonstrate how quick PyPy compares with normal Python,
    we will make a couple of files, as well as a C file, to see how well PyPy''s JIT
    compiler compares:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示 PyPy 与常规 Python 的速度比较，我们将创建几个文件，以及一个 C 文件，以查看 PyPy 的 JIT 编译器的性能如何：
- en: 'We save the following as `add_funct.py`:'
  id: totrans-42
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将以下内容保存为 `add_funct.py`：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following is `loop_funct.py`**:**
  id: totrans-44
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是 `loop_funct.py`**：**
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`loop_funct.c` is the C code for comparison:'
  id: totrans-46
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop_funct.c` 是用于比较的 C 代码：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshots show the timings for each program type:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了每种程序类型的计时：
- en: 'Python:'
  id: totrans-49
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Python:'
- en: '![](img/0e650d5f-ee08-4a28-863c-257b9ca22547.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e650d5f-ee08-4a28-863c-257b9ca22547.png)'
- en: 'PyPy:'
  id: totrans-51
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PyPy:'
- en: '![](img/651cae91-dd2f-471e-8186-de33f0bc251b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/651cae91-dd2f-471e-8186-de33f0bc251b.png)'
- en: 'C:'
  id: totrans-53
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C:'
- en: '![](img/48b2e619-bc97-4f20-9372-9aeca4e4f20c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48b2e619-bc97-4f20-9372-9aeca4e4f20c.png)'
- en: The speed increase using PyPy over Python was 99.5%. The speed difference between
    PyPy and C was 97.3%, but comparing C to Python resulted in a 99.9% increase.
    In programs that use human interaction, the difference between C and PyPy times
    is effectively nil, but in long-running, non-interactive programs, that time difference
    adds up. Is it enough to warrant rewriting Python code into C code? Probably not,
    but it might be worth rewriting just the the bottleneck code in C and then passing
    that data into Python.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PyPy 相对于 Python 的速度提升为 99.5%。PyPy 和 C 之间的速度差异为 97.3%，但将 C 与 Python 进行比较则导致
    99.9% 的提升。在涉及人类交互的程序中，C 和 PyPy 的时间差异实际上可以忽略不计，但在长时间运行的非交互式程序中，这种时间差异会累积起来。这足以证明将
    Python 代码重写为 C 代码是合理的吗？可能不是，但可能值得将瓶颈代码重写为 C 代码，然后将这些数据传递给 Python。
- en: '`beer_loop.py` shows that PyPy is most effective if it can work on loops that
    execute functions. The following program, while having a long iteration, is essentially
    just a counter. The loop doesn''t call any functions or do much besides print
    strings:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beer_loop.py` 显示，如果 PyPy 可以在执行函数的循环上工作，它将最为有效。以下程序虽然迭代时间较长，但本质上只是一个计数器。循环没有调用任何函数或做很多除了打印字符串的事情：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we time both a normal Python call and PyPy, we''ll see that the times are
    roughly the same:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们同时测量正常Python调用和PyPy，我们会看到时间大致相同：
- en: '![](img/39caa66b-8e55-487d-af3a-c2f0f6482892.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39caa66b-8e55-487d-af3a-c2f0f6482892.png)'
- en: The preceding screenshot is the time for normal Python 3 to run through 1 million
    iterations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了正常Python 3运行一百万次迭代的耗时。
- en: '![](img/04762c1d-84ed-4c38-8a72-52e886ed5988.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04762c1d-84ed-4c38-8a72-52e886ed5988.png)'
- en: The preceding screenshot is for PyPy. While there is about a 25% difference
    between the two, the speed improvement with PyPy is nowhere near what is was in
    the results shown in step 4 above (more than 99% speed increase). Even after running
    it a few additional times to see whether having a compiled file already available
    made a difference, this author was not able to improve the results. Hence, while
    PyPy can improve performance on a number of different Python programs, the improvement
    really occurs on functions that are hottest, that is, the functions that are executed
    most often. Thus, one way to maximize performance is to simply make your code
    utilize functions whenever possible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图是针对PyPy的。虽然两者之间大约有25%的差距，但PyPy的速度提升远不及上面第4步显示的结果（超过99%的速度提升）。即使额外运行了几次以查看是否有编译文件已经存在会带来差异，作者也没有能够改善结果。因此，虽然PyPy可以在许多不同的Python程序上提高性能，但真正的改进发生在最热的函数上，即执行最频繁的函数。因此，最大化性能的一种方法是在可能的情况下简单地让代码利用函数。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Of course, there are ways to improve code, such as actually using a loop rather
    than an iterator, but this demonstrates a couple of points:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有方法可以改进代码，比如实际使用循环而不是迭代器，但这展示了几个要点：
- en: Just because PyPy is being used doesn't mean that it will improve program performance.
    Not only do you have to ensure that the PyPy subset of Python commands is utilized,
    it also means that the code has to be written in a manner that utilizes the improvement
    capabilities of PyPy.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只是因为使用了PyPy，并不意味着它会提高程序性能。不仅必须确保使用PyPy子集的Python命令，还意味着代码必须以利用PyPy改进能力的方式编写。
- en: While maximum performance can be achieved using a compiled language, using PyPy
    means that you don't have to bother rewriting your code very often. Of course,
    if your code is taking a long time to process, but can't be optimized for PyPy,
    then compiling may be your best bet.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然使用编译语言可以达到最大性能，但使用PyPy意味着你不必经常重写你的代码。当然，如果你的代码处理时间较长，但又不能为PyPy优化，那么编译可能就是你的最佳选择。
- en: For example, writing a C version of the Million Bottles code resulted in a compilation
    time of < 1 second. This is 99 percent faster than PyPy's time.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，编写百万瓶代码的C版本，编译时间少于1秒。这比PyPy的时间快了99%。
- en: This also points out that it is better to write your code first, then conduct
    performance modeling and identify bottlenecks. Those areas will be the key places
    to focus on, whether it's rewriting in a compiled language or looking into PyPy.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也指出，先编写代码，然后进行性能建模和识别瓶颈会更好。这些区域将是关键的关注点，无论是用编译语言重写还是研究PyPy。
- en: 'The PyPy documentation ([http://pypy.org/performance.html](http://pypy.org/performance.html))
    provides some hints on how to optimize your code prior to refactoring or rewriting
    it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy文档([http://pypy.org/performance.html](http://pypy.org/performance.html))提供了一些关于在重构或重写代码之前如何优化代码的提示：
- en: Use regression testing. Like any testing code, it requires significant time
    upfront to determine what tests are needed, as well as the actual code writing.
    But the payout comes when refactoring as it allows you to try different optimizations
    without worrying about adding a lot of hidden bugs.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回归测试。就像任何测试代码一样，它需要前期投入大量时间来确定所需的测试以及实际代码编写。但是，在重构时，它允许你尝试不同的优化而不用担心添加大量隐藏的错误。
- en: Use profilers to actually measure the time of your code overall, as well as
    individual portions. This way, you know exactly where the time sinks are so you
    can focus on those areas, rather than guessing where the bottlenecks are.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析器来实际测量你代码的整体运行时间以及各个部分的时间。这样，你就能确切知道时间消耗在哪里，从而可以专注于这些区域，而不是猜测瓶颈在哪里。
- en: Harking back to parallel processing, be aware of code that is I/O-bound versus
    CPU-bound. I/O-bound code is reliant upon data transfers and benefits most from
    multithreading, rather than significant code optimization; there is only so much
    you can do with your code before the data processing becomes reliant on the speed
    of the I/O connections.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到并行处理，请注意I/O密集型代码与CPU密集型代码的区别。I/O密集型代码依赖于数据传输，并且从多线程中受益最大，而不是显著的代码优化；在数据处理依赖于I/O连接速度之前，你可以在代码上做这么多。
- en: CPU-bound code is where you get the most value in terms of refactoring and optimization.
    That's because the CPU has to process a lot of data, so any sort of optimization
    in the code, such as compiling it or parallelizing it, will have an impact on
    the performance speed.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CPU密集型代码是你在重构和优化方面获得最大价值的地方。这是因为CPU需要处理大量数据，所以代码中的任何优化，如编译它或并行化它，都会对性能速度产生影响。
- en: While you can always rewrite your code in a compiled language, it defeats the
    purpose of using Python. A better technique is to tune your algorithms to maximize
    performance in terms how the data is processed. You will probably go through several
    iterations of tuning and algorithm optimizing as you discover new bottlenecks.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然你可以始终用编译语言重写你的代码，但这违背了使用Python的目的。更好的技术是调整你的算法，以最大化数据处理方面的性能。当你发现新的瓶颈时，你可能会经历多次调整和算法优化的迭代。
- en: Smaller programs are intrinsically faster than larger ones. This is because
    the different levels of cache on CPUs are progressively smaller the closer to
    the core they are, but they are also faster as well. If you can create a program,
    or at least subroutines, that can fit inside a cache space, it will be as fast
    as the cache itself is.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的程序本质上比较大的程序运行得更快。这是因为CPU上的不同缓存级别越接近核心就越小，但它们也越快。如果你能创建一个程序，或者至少是子程序，使其能够适应缓存空间，那么它的速度将和缓存本身一样快。
- en: Smaller programs imply simpler code, as simple code creates shorter machine
    language opcodes. The problem comes from algorithm tuneup; improving algorithm
    performance generally implies using time-saving but space-filling techniques such
    as pre-computations or reverse maps.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序越小，代码越简单，因为简单的代码会生成更短的机器语言操作码。问题来自于算法调整；提高算法性能通常意味着使用节省时间但占用空间的技巧，如预计算或反向映射。
- en: What is RPython?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RPython？
- en: RPython is the language used to create PyPy. Technically, it is considered a
    translation and support framework for implementing dynamic programming languages,
    separating the language specs from the implementation aspects. This means that
    RPython can be used for other languages besides Python, though it is most commonly
    associated with Python. This also means that any dynamic language will benefit
    from the JIT compiler and allows for a mix-and-match style when making implementation
    choices.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: RPython是创建PyPy所使用的语言。技术上，它被认为是一个实现动态编程语言的翻译和支持框架，将语言规范与实现方面分离。这意味着RPython可以用于Python以外的其他语言，尽管它最常与Python相关联。这也意味着任何动态语言都将从JIT编译器中受益，并允许在实现选择时采用混合匹配的风格。
- en: While certain environments have been created in the past to provide abstraction
    between source code and the target system, such as .NET and Java Virtual Machines,
    RPython uses a subset of CPython to create languages that act as simple interpreters,
    with little direct connectivity to low-level, system details. The subsequent toolchain
    creates a solid virtual machine for a designated platform by using the appropriate
    lower-level aspects as needed. This allows further customization of features and
    platform configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然过去已经创建了某些环境来在源代码和目标系统之间提供抽象，例如.NET和Java虚拟机，但RPython使用CPython的一个子集来创建作为简单解释器的语言，与底层系统细节的直接连接很少。随后的工具链通过使用所需的适当低级方面，为指定的平台创建了一个坚实的虚拟机。这允许进一步定制功能和平台配置。
- en: When implementing languages, developers have to contend with the languages themselves,
    the platforms that will run the languages, and the design decisions made during
    development. The overriding goal of PyPy and RPython development is to make it
    so that these development variables can be modified independently. Thus, the language
    used can be modified or replaced, the platform-specific code can be optimized
    to meet different model needs and desired trade-offs, and the translator backends
    can be written to target different physical and virtual platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现语言时，开发者必须应对语言本身、将运行这些语言的平台以及开发过程中做出的设计决策。PyPy和RPython开发的总体目标是使这些开发变量可以独立修改。因此，可以修改或替换使用的语言，针对特定平台的代码可以优化以满足不同的模型需求和期望的权衡，并且可以编写针对不同物理和虚拟平台的翻译后端。
- en: Thus, while a framework such as .NET tries to create a common environment for
    developers to target, PyPy strives to allow developers to essentially do whatever
    they want, however they want. JIT compilers are one way to do this, as they are
    made in a language-independent manner.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管像.NET这样的框架试图为开发者创建一个通用的环境以进行目标定位，PyPy则努力允许开发者基本上做他们想做的任何事情，以任何他们想要的方式。即时编译器是实现这一目标的一种方式，因为它们是以语言无关的方式制作的。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: RPython is not designed for writing programs, as such, but is designed for writing
    software interpreters. If you want to speed up your Python code, then just use
    PyPy. RPython's sole purpose is to allow development of dynamic language interpreters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: RPython不是为编写程序而设计的，而是为编写软件解释器而设计的。如果您想加速您的Python代码，那么只需使用PyPy。RPython的唯一目的是允许开发动态语言解释器。
- en: In the light of the preceding tip, this section won't walk through the normal
    code examples. We will cover the differences between RPython and Python, just
    so you understand what is meant by RPython being a subset of Python, and possibly
    some of the considerations necessary if you are looking to write an interpreter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的提示，本节不会遍历正常的代码示例。我们将介绍RPython与Python之间的差异，以便您了解RPython作为Python子集的含义，以及如果您打算编写解释器可能需要考虑的一些因素。
- en: Flow restrictions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流限制
- en: Variables should only contain values that are only one type at each control
    point. In other words, when combining paths of control, for example, `if...else`
    statements, using the same variable name for two different types of values, for
    example, a string and an integer, must be avoided.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应只包含在每个控制点只包含一种类型的值。换句话说，当组合控制路径时，例如`if...else`语句，应避免使用相同的变量名来表示两种不同类型的值，例如字符串和整数。
- en: All global values within a module are considered constants and can't change
    while the program is running.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块内的所有全局值都被视为常量，并且在程序运行期间不能改变。
- en: All control structures are allowed but `for` loops are restricted to built-in
    types and generators are heavily restricted.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有控制结构都是允许的，但`for`循环仅限于内置类型，生成器受到严格的限制。
- en: The `range` and `xrange` functions are treated equally, though `xrange` fields
    are not accessible to Python.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`和`xrange`函数被同等对待，尽管`xrange`字段在Python中不可访问。'
- en: Defining classes or functions at runtime is prohibited.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时定义类或函数是被禁止的。
- en: While generators are supported, their scope is limited and you cannot merge
    different generators at a single control point.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然支持生成器，但它们的范围有限，并且您不能在单个控制点合并不同的生成器。
- en: Exceptions are fully supported. However, the generation of exceptions is slightly
    different compared to regular Python.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常得到了完全支持。然而，与常规Python相比，异常的生成略有不同。
- en: Object restrictions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象限制
- en: Integers, floats, and booleans all work as expected.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数、浮点数和布尔值都按预期工作。
- en: Most string methods are implemented but, of the ones that are implemented, not
    all arguments are accepted. String formatting is limited, as is Unicode support.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数字符串方法都已实现，但实现的方法中并非所有参数都被接受。字符串格式化有限，Unicode支持也是如此。
- en: Tuples must be a fixed length and list-to-tuple conversion is not handled in
    a general way, as there is no way for RPython to determine, non-statically, what
    the length of the result would be.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组必须是固定长度，并且列表到元组的转换不是以通用方式处理的，因为RPython无法非静态地确定结果长度。
- en: Lists are implemented as allocated arrays. Negative and out-of-bounds indexing
    is only allowed in limited cases. Obviously, fixed-length lists will optimize
    better, but appending to lists is relatively quick.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表作为分配的数组实现。负数和越界索引仅在有限情况下允许。显然，固定长度的列表将优化得更好，但向列表中添加元素相对较快。
- en: Dictionaries must have unique keys but custom hash functions or custom equality
    will be ignored.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典必须具有唯一的键，但自定义哈希函数或自定义等价性将被忽略。
- en: Sets are not directly supported but can be simulated by creating a dictionary
    and providing the values for each key as `None`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合不支持，但可以通过创建字典并为每个键提供 `None` 作为值来模拟。
- en: List comprehensions can be used to create allocated, initialized arrays.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导可以用来创建已分配、初始化的数组。
- en: Functions may be declared with default arguments and `*args`, but `**keywords`
    arguments aren't allowed. Generally speaking, functions operate normally but care
    must be taken when calling a function with a dynamic number of arguments.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以声明默认参数和 `*args`，但不允许 `**keywords` 参数。一般来说，函数可以正常工作，但在调用具有动态参数数量的函数时必须小心。
- en: Most built-in functions are available, but their support may be different from
    expected.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数内置函数都是可用的，但它们的支持可能与预期不同。
- en: Classes are supported, as long as methods and attributes don't change after
    startup. Single inheritance is fully supported, but not multiple inheritance.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持类，只要启动后方法和属性没有改变。完全支持单继承，但不支持多继承。
- en: General object support is provided for, so creating custom objects shouldn't
    run into significant problems. However, only a limited set of special methods,
    for example, `__init__`, are available to custom objects.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一般对象支持，因此创建自定义对象不应遇到重大问题。然而，只有有限的一组特殊方法可用于自定义对象，例如 `__init__`。
- en: Integer types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'Because integers are implemented differently between Python 2 and Python 3,
    normal integers are used for signed arithmetic. This means that, prior to translation,
    *longs* are used in the case of overflow but, after translation, silent wraparound
    occurs. However, in cases where more control is necessary, the following functions
    and class are provided:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 2 和 Python 3 之间整数实现的不同，通常使用带符号算术的普通整数。这意味着在翻译之前，*longs* 用于溢出情况，但在翻译之后，会发生静默回绕。然而，在需要更多控制的情况下，提供了以下函数和类：
- en: '`ovfcheck()`: Should only be used when a single arithmetic operation is used
    as the argument. This function will perform its operation in overflow-checking
    mode.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ovfcheck()`：仅当单个算术操作用作参数时才应使用。此函数将以溢出检查模式执行其操作。'
- en: '`intmask()`: Used for wraparound arithmetic and returns the lower bits of its
    argument, masking anything that isn''t part of a C signed-long-int. This allows
    Python to convert from a `long` from a previous operation to an `int`. Code generators
    ignore this function, as they conduct wraparound, signed arithmetic by default.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intmask()`：用于回绕算术，并返回其参数的低位，屏蔽任何不属于 C 带符号长整型的部分。这允许 Python 将之前的操作中的 `long`
    转换为 `int`。代码生成器忽略此函数，因为它们默认执行回绕和带符号算术。'
- en: '`r_uint`: This class is a pure Python implementation of native machine-sized,
    unsigned integers that silently wrap around. This is provided to allow consistent
    typing by utilizing `r_uint` instances throughout the program; all operations
    with these instances will be assumed to be unsigned. Mixing signed integers and
    `r_uint` instances results in unsigned integers. To convert back to signed integers,
    the `intmask()` function should be used.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r_uint`：这是一个纯 Python 实现的本地机器大小的无符号整数，它会静默地回绕。这是为了在整个程序中利用 `r_uint` 实例实现一致的类型；所有与这些实例的操作都将假定是无符号的。将带符号整数与
    `r_uint` 实例混合会导致无符号整数。要转换回带符号整数，应使用 `intmask()` 函数。'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Just for clarification, RPython is not a compiler. It is a development framework,
    as well as a programming language, specifically a subset of regular Python. PyPy
    uses RPython as its programming language to implement a JIT compiler.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，RPython 不是一个编译器。它是一个开发框架，也是一个编程语言，具体来说是常规 Python 的一个子集。PyPy 使用 RPython
    作为其编程语言来实现 JIT 编译器。
- en: Some real-world examples
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些实际示例
- en: Here are more examples of how PyPy can improve performance, as well as some
    practical uses of the environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 PyPy 如何提高性能的更多示例，以及一些环境的实际用途。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following code (`time.py`*)* uses the Pythagorean Theorem to calculate
    the hypotenuse for a number of triangles with increasing side lengths:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码（`time.py`*）使用勾股定理计算具有递增边长的多个三角形的斜边：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code (`time2.py`) does the same thing as `pythag_theorem.py`
    but puts the calculations within a function, rather than performing the calculation
    in line:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码（`time2.py`）与 `pythag_theorem.py` 做相同的事情，但将计算放在函数中，而不是在行内执行计算：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the time-to-complete differences between regular
    Python and PyPy, for both `time.py` and `time2.py`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了常规Python和PyPy在`time.py`和`time2.py`两个文件中的完成时间差异：
- en: '![](img/aea3ff84-b35c-4fda-b1a4-1842a14c9fe1.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aea3ff84-b35c-4fda-b1a4-1842a14c9fe1.png)'
- en: The times for Python for both inline and function calls are within a second
    of each other. The difference for PyPy between the two calculations is the same,
    but there is a 96% speed improvement between PyPy and Python.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，内联调用和函数调用的耗时几乎相同。PyPy在这两次计算之间的差异相同，但PyPy与Python之间的速度提升了96%。
- en: 'This demonstrates two main things:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了两个主要问题：
- en: Python takes a performance hit when calling functions, due to the overhead costs
    involved in looking up the function and calling the function
  id: totrans-123
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用函数时，Python会受到性能的影响，这是由于查找函数和调用函数所涉及的开销成本
- en: PyPy can have a significant effect when allowed to optimize code that is repeatedly
    called
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当允许PyPy优化重复调用的代码时，PyPy可以产生显著的影响
- en: 'If we modify the code so both `time.py` and `time2.py` are only run once, that
    is, `TIMES=1`, the following results occur:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们修改代码，使`time.py`和`time2.py`都只运行一次，即`TIMES=1`，以下结果会出现：
- en: '![](img/9d3d3ec3-65c2-45c5-957b-f1b064583c62.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d3d3ec3-65c2-45c5-957b-f1b064583c62.png)'
- en: With one pass through the code, the time for Python is functionally equivalent
    for both inline and function calls. Also, the overhead required by PyPy to compile
    the code, then process it, leads to a longer time-to-process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一次代码遍历，Python的内联调用和函数调用的耗时在功能上是等效的。此外，PyPy编译代码并处理代码所需的开销导致处理时间更长。
- en: 'Going to the other extreme, we change the count to 1 billion and run the programs
    again:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计数改为10亿并再次运行程序，走向另一个极端：
- en: 'The following is regular Python, running `time.py`:'
  id: totrans-129
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为常规Python运行`time.py`的结果：
- en: '![](img/a13b72fc-acc8-472a-965f-1ff579d9764f.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a13b72fc-acc8-472a-965f-1ff579d9764f.png)'
- en: 'The following is regular Python, running `time2.py`:'
  id: totrans-131
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为常规Python运行`time2.py`的结果：
- en: '![](img/ed5c52d0-8072-4121-8885-19151b46075e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed5c52d0-8072-4121-8885-19151b46075e.png)'
- en: 'The following is PyPy, running `time.py`:'
  id: totrans-133
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为PyPy运行`time.py`的结果：
- en: '![](img/30b32837-fa8d-413f-8a77-8882db5a6854.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30b32837-fa8d-413f-8a77-8882db5a6854.png)'
- en: 'The following is PyPy, running `time2.py`:'
  id: totrans-135
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下为PyPy运行`time2.py`的结果：
- en: '![](img/a683124a-6d82-44cc-bcfc-b7da52965944.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a683124a-6d82-44cc-bcfc-b7da52965944.png)'
- en: 'The first screenshot is the time for Python to complete `time.py`: nearly 14.5
    minutes. By having to deal with function calls, the second screenshot shows that
    Python''s time increases to nearly 17 minutes.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张截图是Python完成`time.py`的时间：近14.5分钟。由于必须处理函数调用，第二张截图显示Python的时间增加到近17分钟。
- en: By comparison, PyPy didn't really seem to care too much. The third and fourth
    screenshots both show nearly the same time, less than 1 minute. Considering that
    we calculated 1 billion Pythagorean equations, that is an outstanding time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，PyPy似乎并不太在意。第三张和第四张截图都显示了几乎相同的时间，不到1分钟。考虑到我们计算了10亿个勾股定理方程，这是一个出色的成绩。
- en: 'A real-world example is calculating the Great Circle distance, a common calculation
    for navigation to determine the shortest distance between two points on a sphere.
    `great_circle.py` was created using the formula from Wikipedia ([https://en.wikipedia.org/w/index.php?title=Great-circle_distance&amp;oldid=819870157](https://en.wikipedia.org/w/index.php?title=Great-circle_distance&oldid=819870157)):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个现实世界的例子是计算大圆距离，这是导航中确定球面上两点之间最短距离的常见计算。`great_circle.py`是使用维基百科上的公式创建的（[https://en.wikipedia.org/w/index.php?title=Great-circle_distance&oldid=819870157](https://en.wikipedia.org/w/index.php?title=Great-circle_distance&oldid=819870157)）：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's worth pointing out that we are using some of the `math` module functions.
    In the interests of full disclosure, this author forgot to account for the use
    of radians initially, and the result was off by 1,300.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们使用了一些`math`模块的函数。出于完全披露的目的，作者最初忘记考虑弧度的使用，结果偏差了1,300。
- en: 'We can set up a loop to calculate the distance between the same two points,
    much like the previous example. In this case, we used 1 billion again:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以设置一个循环来计算相同两点之间的距离，就像之前的例子一样。在这种情况下，我们再次使用了10亿：
- en: '![](img/8da03b73-15f3-4592-8a07-6ac8a8fe4a1e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8da03b73-15f3-4592-8a07-6ac8a8fe4a1e.png)'
- en: The time differences here work out to a 97% improvement with PyPy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的时间差异表明，使用PyPy可以提高97%的性能。
- en: As an interesting comparison, we will rewrite the Great Circle code to use multiprocessing.
    This was done because there are no I/O operations occurring, so multithreading
    wouldn't do much good in a CPU-intensive operation.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为有趣的比较，我们将重写大圆代码以使用多进程。这样做是因为没有I/O操作发生，所以在CPU密集型操作中多线程不会带来太多好处。
- en: As this is just a simple test, the code is not optimized in any fashion. It
    just creates a pool of eight workers and calls the `great_circle()` function in
    an asynchronous fashion.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个简单的测试，代码没有进行任何优化。它只是创建了一个包含八个工作进程的池，并以异步方式调用`great_circle()`函数。
- en: 'So as to not drag out the time, only 1 million function calls were made for
    this example:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不拖慢时间，这个例子中只进行了100万个函数调用：
- en: '![](img/87445af2-c8e2-4095-945f-d58cdde971f8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87445af2-c8e2-4095-945f-d58cdde971f8.png)'
- en: In this example, the multiprocessing call was performed first, with a time of
    nearly 45 seconds. The code was modified to remove the multiprocessing calls and
    ran with normal Python and PyPy, resulting in times of nearly 1.5 seconds and
    0.5 seconds, respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先执行了多进程调用，耗时近45秒。代码被修改以移除多进程调用，并使用正常的Python和PyPy运行，分别耗时近1.5秒和0.5秒。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The multiprocessing example demonstrates that, while multiprocessing is useful
    in some situations, considerable effort must be made to optimize the program to
    best utilize multiprocessing. In addition, multiprocessing can be slower than
    single thread operations because each process must be started anew, much like
    the function call overhead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程示例表明，虽然多进程在某些情况下很有用，但必须付出相当大的努力来优化程序以充分利用多进程。此外，多进程可能比单线程操作慢，因为每个进程都必须重新启动，就像函数调用开销一样。
- en: There is also the problem of each process taking over a CPU core. While this
    helps with the parallelization of code processing, it means that the core is essentially
    locked until the processing is done.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程占用一个CPU核心也存在问题。虽然这有助于代码处理的并行化，但这也意味着核心在处理完成之前实际上是被锁定的。
- en: For counts under than 1 million, multiprocessing performed well. At 100,000
    calls, the total time was just under 4 seconds. At 10,000 calls, the time was
    less than 0.5 seconds, which is comparable to PyPy's time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低于100万的计数，多进程表现良好。在10万个调用时，总时间略低于4秒。在1万个调用时，时间不到0.5秒，这与PyPy的时间相当。
- en: However, when attempting to run this code with the original 1  billion calls,
    this author's computer (with eight cores) locked up hard. After attempting to
    kill the process, the computer finally released the lock after 1.5 hours.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当尝试使用原始的10亿个调用运行此代码时，这位作者的电脑（具有八个核心）严重卡住。在尝试终止进程后，电脑在1.5小时后最终释放了锁。
- en: There are multiple reasons why the multiprocessing code caused this. The main
    part is that it isn't well optimized and simply tries to call the function as
    resources are available. Each process takes up both CPU cycles and memory space,
    so there eventually comes a point when new processes have to wait for resources
    to become available.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程代码导致这种情况的原因有很多。主要部分是它没有很好地优化，只是简单地尝试在资源可用时调用函数。每个进程都占用CPU周期和内存空间，所以最终会有一个点，新的进程必须等待资源变得可用。
- en: On the other hand, serial processing, such as Python or PyPy, don't have this
    overhead problem and can simply plug and chug to process the code. Even on multiple
    calls, they are still able to process quickly. Of course, this is a more or less
    artificial test and real-world projects will vary considerably as to which method
    is best.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，串行处理，如Python或PyPy，没有这种开销问题，可以直接插入并运行以处理代码。即使在多次调用中，它们也能快速处理。当然，这更多是一个人为的测试，实际项目在哪种方法最好方面会有很大差异。
- en: Ultimately, this gives a good demonstration of the capabilities of PyPy and
    how it compares to multiprocessing. Combining PyPy with multiprocessing may work
    but, based on readings, it looks like the PyPy community isn't interested in improving
    performance for parallel processing, so your results will vary.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这很好地展示了PyPy的能力以及它与多进程的比较。将PyPy与多进程结合可能可行，但根据阅读材料，PyPy社区似乎对提高并行处理性能不感兴趣，所以你的结果可能会有所不同。
