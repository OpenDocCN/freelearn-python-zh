- en: Deploying with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署
- en: In this chapter, we'll look at how to deploy MyMDB into a production environment
    using Docker containers hosted on a Linux server in Amazon's **Electric Computing
    Cloud** (**EC2**). We will also use **Simple Storage Service** (**S3**) of **Amazon
    Web Services** (**AWS**) to store files that users upload.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何使用托管在亚马逊的**电子计算云**（**EC2**）上的Docker容器将MyMDB部署到生产环境。我们还将使用**亚马逊网络服务**（**AWS**）的**简单存储服务**（**S3**）来存储用户上传的文件。
- en: 'We will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做以下事情：
- en: Split up our requirements and settings files to separate development and production
    settings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的要求和设置文件拆分为单独的开发和生产设置
- en: Build a Docker container for MyMDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为MyMDB构建一个Docker容器
- en: Build a database container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建数据库容器
- en: Use Docker Compose to launch both containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose启动两个容器
- en: Launch MyMDB into a production environment on a Linux server in the cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中的Linux服务器上将MyMDB启动到生产环境
- en: First, let's split up our requirements and settings so that our development
    and production values are kept separate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们拆分我们的要求和设置，以便保持开发和生产值分开。
- en: Organizing configuration for production and development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产和开发组织配置
- en: Till now, we've kept a single requirements file and a single `settings.py` file.
    This has made development convenient. However, we can't use our development settings
    in production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们保留了一个要求文件和一个`settings.py`文件。这使得开发变得方便。但是，我们不能在生产中使用我们的开发设置。
- en: The current best practice is to have a separate file for each environment. Each
    environment's file then imports a common file with shared values. We'll use this
    pattern for requirements and settings files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的最佳实践是为每个环境使用单独的文件。然后，每个环境的文件都导入具有共享值的公共文件。我们将使用此模式进行要求和设置文件。
- en: Let's start by splitting up our requirements files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先拆分我们的要求文件。
- en: Splitting requirements files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分要求文件
- en: 'Let''s create `requirements.common.txt` at the root of our project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根目录下创建`requirements.common.txt`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of the environment that we're in, we always need Django, Postgres
    drivers, and Pillow (for the `ImageField` class). However, this requirements file
    is never used directly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们处于哪种环境，我们始终需要Django、Postgres驱动程序和Pillow（用于`ImageField`类）。但是，此要求文件永远不会直接使用。
- en: 'Next, let''s list our development requirements in `requirements.dev.txt`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`requirements.dev.txt`中列出我们的开发要求：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding file will install everything from `requirements.common.txt` (thanks
    to `-r`) and the Django Debug Toolbar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件将安装来自`requirements.common.txt`（感谢`-r`）和Django调试工具栏的所有内容。
- en: 'For our production packages, we''ll use `requirements.production.txt`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的生产软件包，我们将使用`requirements.production.txt`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will also install the packages from `requirements.common.txt`. It will
    also install the `boto3` and `django-storages` packages to help us upload files
    to S3 easily. The `uwsgi` package will provide the server we'll use to serve Django.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将安装来自`requirements.common.txt`的软件包。它还将安装`boto3`和`django-storages`软件包，以帮助我们轻松地将文件上传到S3。`uwsgi`软件包将提供我们用于提供Django的服务器。
- en: 'To install packages for production, we can now execute the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要为生产环境安装软件包，我们现在可以执行以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, let's split up the settings file along similar lines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按类似的方式拆分设置文件。
- en: Splitting settings file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分设置文件
- en: 'Again, we will follow the current Django best practice of splitting our settings
    file into the following three files: `common_settings.py`, `production_settings.py`,
    and `dev_settings.py`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将遵循当前的Django最佳实践，将我们的设置文件分成以下三个文件：`common_settings.py`，`production_settings.py`和`dev_settings.py`。
- en: Creating common_settings.py
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建common_settings.py
- en: We'll create `common_settings.py` by renaming our current `settings.py` file
    and then making the changes mentioned in this section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将当前的`settings.py`文件重命名为`common_settings.py`，然后进行本节中提到的更改来创建`common_settings.py`。
- en: 'Let''s change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let''s change the `SECRET_KEY` setting to get its value
    from an environment variable, by changing its line to be:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`DEBUG = False`更改为不会*意外*处于调试模式的新设置文件。然后，让我们更改`SECRET_KEY`设置，以便通过更改其行来从环境变量获取其值：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s also add a new setting, `STATIC_ROOT`. `STATIC_ROOT` is the directory
    where Django will collect all the static files from across our installed apps
    to make it easier to serve them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还添加一个新的设置`STATIC_ROOT`。`STATIC_ROOT`是Django将从已安装的应用程序中收集所有静态文件的目录，以便更容易地提供它们：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the database config, we can remove all the credentials but keep the `ENGINE` value
    (to make it clear, we intend to use Postgres everywhere):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库配置中，我们可以删除所有凭据，但保留`ENGINE`值（为了明确起见，我们打算在任何地方都使用Postgres）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, let's delete the `CACHES` setting. This will have to be configured
    differently in each environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们删除`CACHES`设置。这将在每个环境中以不同的方式配置。
- en: Next, let's create a development settings file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个开发设置文件。
- en: Creating dev_settings.py
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建dev_settings.py
- en: Our development settings will be in `django/config/dev_settings.py`. We'll build
    it incrementally.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发设置将在`django/config/dev_settings.py`中。我们将逐步构建它。
- en: 'First, we will import everything from `common_settings`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`common_settings`中导入所有内容：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we''ll override the `DEBUG` and `SECRET_KEY` settings:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将覆盖`DEBUG`和`SECRET_KEY`设置：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In development, we want to run in debug mode. We will also feel safe hardcoding
    a secret key, as we know that it won't be used in production.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们希望以调试模式运行。我们还会感到安全，硬编码一个秘密密钥，因为我们知道它不会在生产中使用。
- en: 'Next, let’s update the `INSTALLED_APPS` list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`INSTALLED_APPS`列表：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In development, we can run extra apps (such as the Django Debug Toolbar) by
    appending a list of development-only apps to the `INSTALLED_APPS` list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们可以通过将一系列仅用于开发的应用程序附加到`INSTALLED_APPS`列表中来运行额外的应用程序（例如Django调试工具栏）。
- en: 'Then, let’s update the database configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们更新数据库配置：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since our development database is local, we can hardcode the values in our settings
    to make the file simpler. If your database is not local, avoid checking passwords
    into version control and use `os.getenv()`, as in production.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的开发数据库是本地的，我们可以在设置中硬编码值，使文件更简单。如果您的数据库不是本地的，请避免将密码检入版本控制，并在生产中使用`os.getenv()`。
- en: 'Next, let’s update the cache configuration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新缓存配置：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll use a very short timeout in our development cache.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发缓存中，我们将使用非常短的超时时间。
- en: 'Finally, we need to set file upload directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置文件上传目录：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In development, we'll store uploaded files on our local filesystem in development.
    We will specify the directory to upload to using `MEDIA_ROOT`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，我们将在本地文件系统中存储上传的文件。我们将使用`MEDIA_ROOT`指定要上传到的目录。
- en: 'The Django Debug Toolbar needs a bit of configuration as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar也需要一些配置：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Django Debug Toolbar will only render at predefined IPs, so we will give
    it our localhost IP so that we can use it locally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar只会在预定义的IP上呈现，所以我们会给它我们的本地IP，这样我们就可以在本地使用它。
- en: We can also add more settings that our development-only apps may require.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加我们的开发专用应用程序可能需要的更多设置。
- en: Next, let's add production settings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加生产设置。
- en: Creating production_settings.py
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建production_settings.py
- en: Let's create our production settings in `django/config/production_settings.py`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/config/production_settings.py`中创建我们的生产设置。
- en: '`production_settings.py` is similar to `dev_settings.py` but often uses `os.getenv()`
    to get values from environment variables. This helps us keep secrets (for example,
    Passwords, API tokens, and so on) out of version control and decouples settings
    from particular servers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`production_settings.py`类似于`dev_settings.py`，但通常使用`os.getenv()`从环境变量中获取值。这有助于我们将秘密信息（例如密码、API令牌等）排除在版本控制之外，并将设置与特定服务器解耦：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we import the common settings. Out of an abundance of caution, we ensure
    that the debug mode is off.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入通用设置。出于谨慎起见，我们确保调试模式已关闭。
- en: Having a `SECRET_KEY` set is vital to our system staying secure. We `assert`
    to prevent Django from starting up without `SECRET_KEY`. The `common_settings` module should
    have already set it from an environment variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`SECRET_KEY`对于我们的系统保持安全至关重要。我们使用`assert`来防止Django在没有`SECRET_KEY`的情况下启动。`common_settings`模块应该已经从环境变量中设置了它。
- en: A production website will be accessed from a domain other than `localhost`.
    We then tell Django what other domains we're serving by appending the `DJANGO_ALLOWED_HOSTS` environment
    variable to the `ALLOWED_HOSTS` list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生产网站将从除`localhost`之外的域访问。然后我们通过将`DJANGO_ALLOWED_HOSTS`环境变量附加到`ALLOWED_HOSTS`列表来告诉Django我们正在服务的其他域。
- en: 'Next, we’ll update the database configuration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新数据库配置：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We update the database configuration using values from environment variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自环境变量的值更新数据库配置。
- en: Then, the cache configuration needs to be set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要设置缓存配置。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In production, we will accept the trade-offs of a local memory cache. We configure
    the timeout at runtime using another environment variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，我们将接受本地内存缓存的权衡。我们使用另一个环境变量在运行时配置超时时间。
- en: Next, the file upload configuration settings need to bedded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要设置文件上传配置设置。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In production, we won't store uploaded images on our container's local filesystem.
    One core concept of Docker is that containers are ephemeral. It should be acceptable
    to stop and delete a container and replace it with another. If we stored uploaded
    images locally, we’d go against that philosophy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，我们不会将上传的图像存储在容器的本地文件系统上。Docker的一个核心概念是容器是短暂的。停止和删除容器并用另一个替换应该是可以接受的。如果我们将上传的图像存储在本地，我们将违背这一理念。
- en: Another reason for not storing uploaded files locally is that they should also
    be served from a different domain (we discussed this in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml), *Posters,
    Headshots, and Security*). We will use S3 storage since it's cheap and easy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不将上传的文件存储在本地的另一个原因是，它们也应该从不同的域提供服务（我们在[第3章](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml)中讨论过这个问题，*海报、头像和安全性*）。我们将使用S3存储，因为它便宜且易于使用。
- en: The `django-storages` app provides file storage backends for many CDNs, including
    S3\. We tell Django to use that S3 by changing the `DEFAULT_FILE_STORAGE` setting.
    The `S3Boto3Storage` backend requires a few more settings to be able to work with
    AWS, including an AWS Access Key, an AWS Secret Access Key, and the name of the
    destination bucket. We'll discuss the two Access Keys later, in the AWS section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-storages`应用程序为许多CDN提供文件存储后端，包括S3。我们告诉Django使用S3，方法是更改`DEFAULT_FILE_STORAGE`设置。`S3Boto3Storage`后端需要一些额外的设置才能与AWS一起工作，包括AWS访问密钥、AWS秘密访问密钥和目标存储桶的名称。我们将在AWS部分稍后讨论这两个访问密钥。'
- en: Now that our settings are organized, we can create our MyMDB `Dockerfile`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的设置已经组织好了，我们可以创建我们的MyMDB `Dockerfile`。
- en: Creating the MyMDB Dockerfile
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MyMDB Dockerfile
- en: In this section, we will create a Dockerfile for MyMDB. Docker runs containers
    based on an image. An image is defined by a Dockerfile. A Dockerfile must extend
    another Dockerfile (the reserved `scratch` image being the end of this cycle).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为MyMDB创建一个Dockerfile。Docker基于镜像运行容器。镜像由Dockerfile定义。Dockerfile必须扩展另一个Dockerfile（保留的`scratch`镜像是这个周期的结束）。
- en: Docker's philosophy is that each container should have a single concern (purpose).
    This may mean that it runs a single process, or it may run multiple processes
    working together. In our case, it will run both uWSGI and Nginx processes to provide
    MyMDB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的理念是每个容器应该只有一个关注点（目的）。这可能意味着它运行一个单一进程，或者它可能运行多个一起工作的进程。在我们的情况下，它将运行uWSGI和Nginx进程来提供MyMDB。
- en: Confusingly, Dockerfile refers to both the expected *filename* and the *file
    type*. So `Dockerfile` is a Dockerfile.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，Dockerfile既指预期的*文件名*，也指*文件类型*。所以`Dockerfile`是一个Dockerfile。
- en: Let's create a Dockerfile at the root of our project in a file called `Dockerfile`.
    Dockerfile uses its own language to define the files/directories in the image,
    as well as any commands required to run while making the image. A complete guide
    on writing a Dockerfile is out of the scope of this chapter. Instead, we'll build
    our `Dockerfile` incrementally, discussing only the most relevant elements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根目录中创建一个名为`Dockerfile`的文件。 Dockerfile使用自己的语言来定义图像中的文件/目录，以及在制作图像时需要运行的任何命令。编写Dockerfile的完整指南超出了本章的范围。相反，我们将逐步构建我们的`Dockerfile`，仅讨论最相关的元素。
- en: 'We''ll build our `Dockerfile` by following six steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下六个步骤构建我们的`Dockerfile`：
- en: Initializing the base image and adding the source code to the image
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化基础镜像并将源代码添加到镜像中
- en: Installing packages
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装软件包
- en: Collecting static files
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集静态文件
- en: Configuring Nginx
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Nginx
- en: Configuring uWSGI
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置uWSGI
- en: Cleaning up unnecessary resources
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理不必要的资源
- en: Starting our Dockerfile
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的Dockerfile
- en: 'The first part of our `Dockerfile` tells Docker which image to use as the base,
    adds our code, and creates some common directories:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Dockerfile`的第一部分告诉Docker要使用哪个镜像作为基础，添加我们的代码，并创建一些常见的目录：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look at these instructions in more detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些说明：
- en: '`FROM`: This is required in a Dockerfile. `FROM` tells Docker what image to
    use as the base image for our image. We will use `phusion/baseimage` because it
    provides a lot of convenient facilities and uses very little memory. It''s a tailored-for-Docker
    Ubuntu image with a smaller easy-to-use init service manager called runit (instead
    of the Ubuntu''s upstart).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：Dockerfile中需要这个。`FROM`告诉Docker我们的镜像要使用哪个基础镜像。我们将使用`phusion/baseimage`，因为它提供了许多方便的设施并且占用的内存很少。它是一个专为Docker定制的Ubuntu镜像，具有一个更小、易于使用的init服务管理器，称为runit（而不是Ubuntu的upstart）。'
- en: '`RUN`: This executes a command as part of building the image. `RUN mkdir /mymdb`
    creates the directory in which we''ll store our files.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：这在构建图像的过程中执行命令。`RUN mkdir /mymdb`创建我们将存储文件的目录。'
- en: '`WORKDIR`: This sets the working directory for all our future `RUN` commands.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：这为我们所有未来的`RUN`命令设置了工作目录。'
- en: '`COPY`: This adds a file (or directory) from our filesystem to the image. Source
    paths are relative to the directory containing our `Dockerfile`. It''s best to
    make the destination path an absolute path.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：这将文件（或目录）从我们的文件系统添加到图像中。源路径是相对于包含我们的`Dockerfile`的目录的。最好将目标路径设置为绝对路径。'
- en: 'We will also reference a new directory called `scripts`. Let''s create it at
    the root of our project directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引用一个名为`scripts`的新目录。让我们在项目目录的根目录中创建它：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As part of configuring and building the new image, we'll create a few small
    bash scripts that we'll keep in the `scripts` directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为配置和构建新镜像的一部分，我们将创建一些小的bash脚本，我们将保存在`scripts`目录中。
- en: Installing packages in Dockerfile
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Dockerfile中安装软件包
- en: 'Next, we''ll tell our `Dockerfile` to install all the packages we will need:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将告诉我们的`Dockerfile`安装我们将需要的所有软件包：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We used `RUN` statements to install the Ubuntu packages and create a virtual
    environment. To install our Python packages into our virtual environment, we''ll
    create a small script in `scripts/pip_install.sh`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`RUN`语句来安装Ubuntu软件包并创建虚拟环境。要将我们的Python软件包安装到虚拟环境中，我们将在`scripts/pip_install.sh`中创建一个小脚本：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding script simply activates the virtual environment and runs `pip3
    install` on our production requirements file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本只是激活虚拟环境并在我们的生产需求文件上运行`pip3 install`。
- en: It's often hard to debug long commands in the middle of a Docker file. Wrapping
    commands in scripts can make them easier to debug. If something isn't working,
    you can connect to a container using the `docker exec -it bash -l` command and
    debug the script as normal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile的中间调试长命令通常很困难。将命令包装在脚本中可以使它们更容易调试。如果某些内容不起作用，您可以使用`docker exec -it
    bash -l`命令连接到容器并像平常一样调试脚本。
- en: Collecting static files in Dockerfile
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Dockerfile中收集静态文件
- en: 'Static files are the CSS, JavaScript, and images that support our website.
    Static files may not always be created by us. Some static files come from installed
    Django apps (for example, Django admin). Let’s update our `Dockerfile` to collect
    the static files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件是支持我们网站的CSS、JavaScript和图像。静态文件可能并非总是由我们创建。一些静态文件来自安装的Django应用程序（例如Django管理）。让我们更新我们的`Dockerfile`以收集静态文件：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, we''ve wrapped the command in a script. Let''s add the following script
    to `scripts/collect_static.sh`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将命令包装在脚本中。让我们将以下脚本添加到`scripts/collect_static.sh`中：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding script activates the virtual environment we created in the preceding
    code and sets the required environment variables. Most of these values don't matter
    in this context as long as the variables are present. However, the `DJANGO_SETTINGS_MODULE` environment
    variable is very important. The `DJANGO_SETTINGS_MODULE` environment variable is
    used by Django to find the settings module. If we don't set it and don't have `config/settings.py`,
    then Django won't start (even `manage.py` commands will fail).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本激活了我们在前面的代码中创建的虚拟环境，并设置了所需的环境变量。在这种情况下，大多数这些值都不重要，只要变量存在即可。但是，`DJANGO_SETTINGS_MODULE`环境变量非常重要。`DJANGO_SETTINGS_MODULE`环境变量用于Django查找设置模块。如果我们不设置它并且没有`config/settings.py`，那么Django将无法启动（甚至`manage.py`命令也会失败）。
- en: Adding Nginx to Dockerfile
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Nginx添加到Dockerfile
- en: 'To configure Nginx, we will add a config file and a runit service script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Nginx，我们将添加一个配置文件和一个runit服务脚本：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring Nginx
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Nginx
- en: 'Let''s add an Nginx configuration file to `nginx/mymdb.conf`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个Nginx配置文件添加到`nginx/mymdb.conf`中：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nginx will be responsible for the following two things:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx将负责以下两件事：
- en: Serving static files (URLs starting with `/static`)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件（以“/static”开头的URL）
- en: Passing all other requests to uWSGI
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有其他请求传递给uWSGI
- en: The `upstream` block describes the location of our Django (uWSGI) server. In
    the `location /` block, nginx is instructed to pass requests on to the upstream
    server using the uWSGI protocol. The `include /etc/nginx/uwsgi_params` file describes
    how to map headers so that uWSGI understands them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`upstream`块描述了我们Django（uWSGI）服务器的位置。在`location /`块中，nginx被指示使用uWSGI协议将请求传递给上游服务器。`include
    /etc/nginx/uwsgi_params`文件描述了如何映射标头，以便uWSGI理解它们。'
- en: '`client_max_body_size` is an important setting. It describes the maximum size
    for file uploads. Leaving this value too big can expose a vulnerability, as attackers
    can overwhelm the server with huge requests.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`client_max_body_size`是一个重要的设置。它描述了文件上传的最大大小。将这个值设置得太大可能会暴露漏洞，因为攻击者可以用巨大的请求压倒服务器。'
- en: Creating Nginx runit service
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Nginx runit服务
- en: 'In order for `runit` to know how to start Nginx, we will need to provide a
    `run` script. Our `Dockerfile` expects it to be in `runit/nginx/run`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`runit`知道如何启动Nginx，我们需要提供一个`run`脚本。我们的`Dockerfile`希望它在`runit/nginx/run`中：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`runit` doesn''t want its services to fork off a separate process, so we run
    Nginx with `daemon off`. Further, `runit` wants us to use `exec` to replace our
    script''s process, the new Nginx process.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`runit`不希望其服务分叉出一个单独的进程，因此我们使用`daemon off`来运行Nginx。此外，`runit`希望我们使用`exec`来替换我们脚本的进程，新的Nginx进程。'
- en: Adding uWSGI to the Dockerfile
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将uWSGI添加到Dockerfile
- en: 'We''re using uWSGI because it often ranks as the fastest WSGI app server. Let''s
    set it up in our `Dockerfile` by adding the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用uWSGI，因为它通常被评为最快的WSGI应用服务器。让我们通过添加以下代码到我们的`Dockerfile`中来设置它：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This instructs Docker to use a `mymdb.ini` file to configure uWSGI, creates
    log directories, and adds a uWSGI runit service. In order for runit to start the
    uWSGI service, we give the runit script permission to execute using the `chmod` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示Docker使用`mymdb.ini`文件配置uWSGI，创建日志目录，并添加uWSGI runit服务。为了让runit启动uWSGI服务，我们使用`chmod`命令给予runit脚本执行权限。
- en: Configuring uWSGI to run MyMDB
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置uWSGI运行MyMDB
- en: 'Let''s create the uWSGI configuration in `uwsgi/mymdb.ini`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`uwsgi/mymdb.ini`中创建uWSGI配置：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take a closer look at some of these settings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下其中一些设置：
- en: '`socket` tells uWSGI to open a socket on `127.0.0.1:3031` using its custom
    `uwsgi` protocol (confusingly, the protocol and the server have the same name).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`告诉uWSGI在`127.0.0.1:3031`上使用其自定义的`uwsgi`协议打开一个套接字（令人困惑的是，协议和服务器的名称相同）。'
- en: '`chdir` changes the processes''s working directory. All paths need to be relative
    to this location.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chdir`改变了进程的工作目录。所有路径都需要相对于这个位置。'
- en: '`virtualenv` tells uWSGI the path to the project''s virtual environment.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualenv`告诉uWSGI项目虚拟环境的路径。'
- en: Each `env` instruction sets an environment variable for our process. We can
    access these with `os.getenv()` in our code (for example, `production_settings.py`).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`env`指令为我们的进程设置一个环境变量。我们可以在我们的代码中使用`os.getenv()`访问这些变量（例如，`production_settings.py`）。
- en: '`$(...)` are references environment variables from the uWSGI process''s own
    environment (for example, `$(DJANGO_SECRET_KEY )`).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(...)`是从uWSGI进程自己的环境中引用的环境变量（例如，`$(DJANGO_SECRET_KEY )`）。'
- en: '`proccesses` sets how many processes we should run.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proccesses`设置我们应该运行多少个进程。'
- en: '`threads` sets how many threads each process should have.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threads`设置每个进程应该有多少线程。'
- en: The `processes` and `threads` settings will need to be fine-tuned based on production
    performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`processes`和`threads`设置将根据生产性能进行微调。'
- en: Creating the uWSGI runit service
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建uWSGI runit服务
- en: 'In order for runit to know how to start uWSGI, we will need to provide a `run`
    script. Our `Dockerfile` expects it to be in `runit/uwsgi/run`. This script is
    more complex than what we used for Nginx:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让runit知道如何启动uWSGI，我们需要提供一个`run`脚本。我们的`Dockerfile`希望它在`runit/uwsgi/run`中。这个脚本比我们用于Nginx的要复杂：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This script does the following three things:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本做了以下三件事：
- en: Checks whether it can connect to the DB, exiting otherwise
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否可以连接到数据库，否则退出
- en: Runs all the migrations or exits on failure
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行所有迁移或失败时退出
- en: Starts uWSGI
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动uWSGI
- en: runit requires that we use `exec` to start our process so that uWSGI will replace
    the `run` script's process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: runit要求我们使用`exec`来启动我们的进程，以便uWSGI将替换`run`脚本的进程。
- en: Finishing our Dockerfile
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的Dockerfile
- en: 'As the final step, we will clean up and document the port we''re using:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将清理并记录我们正在使用的端口：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `EXPOSE` statement documents which port we're using. Importantly, it does
    not actually open any ports. We'll have to do that when we run the container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`语句记录了我们正在使用的端口。重要的是，它实际上并不打开任何端口。当我们运行容器时，我们将不得不这样做。'
- en: Next, let's create a container for our database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的数据库创建一个容器。
- en: Creating a database container
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库容器
- en: We will need a database to run Django in production. The PostgreSQL Docker community
    provides us with a very robust Postgres image that we can extend.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据库来在生产中运行Django。PostgreSQL Docker社区为我们提供了一个非常强大的Postgres镜像，我们可以扩展使用。
- en: 'Let''s create another container for our database in `docker/psql/Dockerfile`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`docker/psql/Dockerfile`中为我们的数据库创建另一个容器：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The base image for this `Dockerfile` will use Postgres 10.1\. It also has a
    convenient facility that it will execute any shell or SQL scripts in `/docker-entrypoint-initdb.d` as
    part of the DB initialization. We'll take advantage of this to create our MyMDB
    database and user.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`的基本镜像将使用Postgres 10.1。它还有一个方便的设施，它将执行`/docker-entrypoint-initdb.d`中的任何shell或SQL脚本作为DB初始化的一部分。我们将利用这一点来创建我们的MyMDB数据库和用户。
- en: 'Let''s create our database initialization script in `docker/psql/make_database.sh`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`docker/psql/make_database.sh`中创建我们的数据库初始化脚本：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We used a shell script in the preceding code so that we can use environment
    variables to populate our SQL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用了一个shell脚本，以便我们可以使用环境变量来填充我们的SQL。
- en: Now that we have both our containers ready, let's make sure that we can actually
    launch them by signing up for and configuring AWS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的两个容器都准备好了，让我们确保我们实际上可以通过注册并配置AWS来启动它们。
- en: Storing uploaded files on AWS S3
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS S3上存储上传的文件
- en: We expect our MyMDB to save files to S3\. To accomplish that, we will need to
    sign up for AWS and then configure our shell to be able to use AWS.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望我们的MyMDB将文件保存到S3。为了实现这一点，我们需要注册AWS，然后配置我们的shell以便能够使用AWS。
- en: Signing up for AWS
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册AWS
- en: To sign up, navigate to [https://aws.amazon.com](https://aws.amazon.com) and
    follow their instructions. Note that signing up is free.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册，请转到[https://aws.amazon.com](https://aws.amazon.com)并按照其说明操作。请注意，注册是免费的。
- en: The resources we will use are all in the AWS free tier at the time of writing
    this book. Some elements of the free tier are only available to new accounts for
    the first year. Review your account's eligibility before executing any AWS command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的资源在撰写本书时都在AWS免费层中。免费层的一些元素仅在第一年对新帐户可用。在执行任何AWS命令之前，请检查您的帐户的资格。
- en: Setting up the AWS environment
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置AWS环境
- en: To interact with the AWS API, we will need the following two tokens—an Access
    Key and a Secret Access Key. This key pair defines access to an account.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与AWS API交互，我们将需要以下两个令牌——访问密钥和秘密访问密钥。这对密钥定义了对帐户的访问。
- en: To generate a pair of tokens, go to [https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential_](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential),
    click on Access Keys, and then click on the create new access keys button. There
    is no way to retrieve a Secret Access Key if you lose it, so ensure that you save
    it in a safe place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一对令牌，转到[https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential_](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential)，单击访问密钥，然后单击创建新的访问密钥按钮。如果您丢失了秘密访问密钥，将无法检索它，因此请确保将其保存在安全的地方。
- en: The preceding AWS Console link will generate tokens for your root account. This
    is fine while we're testing things out. In future, you should make users with
    limited permissions using the AWS IAM permissions system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的AWS控制台链接将为您的根帐户生成令牌。在我们测试时这没问题。将来，您应该使用AWS IAM权限系统创建具有有限权限的用户。
- en: 'Next, let''s install the AWS **command-line interface** (**CLI**):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装AWS命令行界面（CLI）：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then,we need to configure the AWS command line tool with our key and region.
    The `aws` command offers an interactive `configure` subcommand to do this. Let’s
    run it on the command line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用我们的密钥和区域配置AWS命令行工具。`aws`命令提供一个交互式`configure`子命令来执行此操作。让我们在命令行上运行它：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `aws configure` command stores the values you entered in a `.aws` directory
    in your home directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws configure`命令将存储您在家目录中的`.aws`目录中输入的值。'
- en: 'To confirm that your new account is set up correctly, request a list of EC2
    instances (there should be none):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认您的新帐户是否设置正确，请请求EC2实例的列表（不应该有）：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the file upload bucket
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件上传存储桶
- en: S3 is organized into buckets. Each bucket must have a unique name (unique across
    all of AWS). Each bucket will also have a policy, which controls access.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: S3被组织成存储桶。每个存储桶必须有一个唯一的名称（在整个AWS中唯一）。每个存储桶还将有一个控制访问的策略。
- en: 'Let''s create a bucket for our file uploads by executing the following commands
    (change `BUCKET_NAME` to your own unique name):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令来创建我们的文件上传存储桶（将`BUCKET_NAME`更改为您自己的唯一名称）：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To let unauthenticated users access the files in our bucket, we must set a
    policy. Let''s create the policy in `AWS/mymdb-bucket-policy.json`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让未经身份验证的用户访问我们存储桶中的文件，我们必须设置一个策略。让我们在`AWS/mymdb-bucket-policy.json`中创建策略：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ensure that you update `BUCKET_NAME` to the name of your bucket.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`BUCKET_NAME`更新为您的存储桶的名称。
- en: 'Now, we can apply the policy on your bucket using the AWS CLI:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用AWS CLI在您的存储桶上应用策略：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Ensure that you remember your bucket name, AWS access key, and AWS secret access
    key as we'll use them in the next section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您记住您的存储桶名称，AWS访问密钥和AWS秘密访问密钥，因为我们将在下一节中使用它们。
- en: Using Docker Compose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose
- en: We now have all the pieces of production deployment ready. Docker Compose is
    how Docker lets multiple containers work together. Docker Compose is made of a
    command-line tool, `docker-compose`; a configuration file, `docker-compose.yml`;
    and an environment variable file, `.env`. We will create both these files at the
    root of our project directory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好生产部署的所有部分。 Docker Compose是Docker让多个容器一起工作的方式。 Docker Compose由一个命令行工具`docker-compose`，一个配置文件`docker-compose.yml`和一个环境变量文件`.env`组成。我们将在项目目录的根目录中创建这两个文件。
- en: Never check your `.env` file into version control. That's where your secrets
    live. Don't let them leak.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将您的`.env`文件检入版本控制。那里是您的秘密所在。不要让它们泄漏。
- en: 'First, let''s list our environment variables in `.env`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`.env`中列出我们的环境变量：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Many of these values are okay to hardcode, but there are a few values that
    you need to set for your project:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中的许多值都可以硬编码，但有一些值需要为您的项目设置：
- en: '`DJANGO_SECRET_KEY`: The Django secret key is used as part of the seed for
    Django''s cryptography'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DJANGO_SECRET_KEY`：Django秘密密钥用作Django加密种子的一部分'
- en: '`DJANGO_DB_PASSWORD`: This is the password for the Django''s MyMDB database
    user'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DJANGO_DB_PASSWORD`：这是Django的MyMDB数据库用户的密码'
- en: '`AWS_ACCESS_KEY_ID`: Your AWS access key'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_ACCESS_KEY_ID`：您的AWS访问密钥'
- en: '`AWS_SECRET_ACCESS_KEY_ID`: Your AWS secret access key'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_SECRET_ACCESS_KEY_ID`：您的AWS秘密访问密钥'
- en: '`DJANGO_UPLOAD_S3_BUCKET`: Your bucket name'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DJANGO_UPLOAD_S3_BUCKET`：您的存储桶名称'
- en: '`POSTGRES_PASSWORD`: The password for the Postgres database super user (different
    from the MyMDB database user)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_PASSWORD`：Postgres数据库超级用户的密码（与MyMDB数据库用户不同）'
- en: '`DJANGO_ALLOWED_HOSTS`: The domain we''ll be serving from (we''ll fill this
    in once we start an EC2 instance)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DJANGO_ALLOWED_HOSTS`：我们将提供服务的域（一旦我们启动EC2实例，我们将填写这个）'
- en: 'Next, we define how our containers work together in `docker-compose.yml`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`docker-compose.yml`中定义我们的容器如何一起工作：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This Compose file describes the two services that make up MyMDB (`db` and `web`).
    Let''s review the configuration options we used:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此Compose文件描述了构成MyMDB的两个服务（`db`和`web`）。让我们回顾一下我们使用的配置选项：
- en: '`build`: Path to a build context. A build context is, generally speaking, a
    directory with a `Dockerfile`. So, `db` uses the `psql` directory and `web` uses
    the `.` directory (the project root directory, which has a `Dockerfile`).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：构建上下文的路径。一般来说，构建上下文是一个带有`Dockerfile`的目录。因此，`db`使用`psql`目录，`web`使用`.`目录（项目根目录，其中有一个`Dockerfile`）。'
- en: '`ports`: A list of port mappings, describing how to route connections from
    ports on the host to ports on the container. In our case, we''re not changing
    any ports.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：端口映射列表，描述如何将主机端口上的连接路由到容器上的端口。在我们的情况下，我们不会更改任何端口。'
- en: '`environment`: Environment variables for each service. The format we''re using
    implies we''re getting the values from our `.env` file. However, you could hardcode
    values using the `MYVAR=123`  syntax.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：每个服务的环境变量。我们使用的格式意味着我们从我们的`.env`文件中获取值。但是，您也可以使用`MYVAR=123`语法硬编码值。'
- en: '`restart`: This is the restart policy for the container. `always` indicates
    that Docker should always try to restart the container if it stops for any reason.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：这是容器的重启策略。`always`表示如果容器因任何原因停止，Docker应该始终尝试重新启动容器。'
- en: '`depends_on`: This tells Docker to start the `db` container before the `web`
    container. However, we still can''t be sure that Postgres will manage to start
    before uWSGI, so we need to check the database is up in our runit script.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`：这告诉Docker在启动`web`容器之前启动`db`容器。然而，我们仍然不能确定Postgres是否能在uWSGI之前成功启动，因此我们需要在我们的runit脚本中检查数据库是否已经启动。'
- en: Tracing environment variables
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪环境变量
- en: 'Our production configuration relies heavily on environment variables. Let''s
    review the steps we must follow before it can be accessed in Django by `os.getenv()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生产配置严重依赖于环境变量。让我们回顾一下在Django中使用`os.getenv()`之前必须遵循的步骤：
- en: List the variable in `.env`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.env`中列出变量
- en: Include the variable under the environment option `environment` in `docker-compose.yml`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`中的`environment`选项下包括变量
- en: Include the uWSGI ini file variable with `env`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`env`中包括uWSGI ini文件变量
- en: Access the variable with `os.getenv`
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`os.getenv`访问变量
- en: Running Docker Compose locally
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行Docker Compose
- en: Now that we have configured our Docker containers and Docker Compose, we can
    run the containers. One of the advantages of Docker Compose is that it can provide
    the same environment everywhere. This means that we can run Docker Compose locally
    and get the exact same environment that we'll get in production. There's no need
    to worry that there's an extra process or a different distribution across environments.
    Let's run Docker Compose locally.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的Docker容器和Docker Compose，我们可以运行这些容器。Docker Compose的一个优点是它可以在任何地方提供相同的环境。这意味着我们可以在本地运行Docker
    Compose，并获得与我们在生产环境中获得的完全相同的环境。不必担心在不同环境中有额外的进程或不同的分发。让我们在本地运行Docker Compose。
- en: Installing Docker
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: To follow along with the rest of this chapter, you must install Docker on your
    machine. Docker, Inc. provides Docker Community Edition for free from its website: [https://docker.com](https://docker.com).
    The Docker Community Edition installer is an easy-to-use wizard on Windows and
    Mac. Docker, Inc. also offers official packages for most major Linux distributions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续阅读本章的其余部分，您必须在您的机器上安装Docker。Docker, Inc.提供免费的Docker社区版，可以从其网站上获得：[https://docker.com](https://docker.com)。Docker社区版安装程序在Windows和Mac上是一个易于使用的向导。Docker,
    Inc.还为大多数主要的Linux发行版提供官方软件包。
- en: Once you have it installed, you'll be able to follow all of the next steps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您将能够按照接下来的所有步骤进行操作。
- en: Using Docker Compose
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose
- en: 'To start our containers locally, run the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地启动我们的容器，请运行以下命令：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`docker-compose up` builds and then starts our containers. The `-d` option
    detaches Compose from our shell.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose up`构建然后启动我们的容器。`-d`选项将Compose与我们的shell分离。'
- en: 'To check whether our containers are running, we can use `docker ps`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们的容器是否正在运行，我们可以使用`docker ps`：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To check the Docker logs, you can use the `docker logs` command to note the
    output of startup scripts:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Docker日志，您可以使用`docker logs`命令来记录启动脚本的输出：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To access a shell inside the container (so that you can examine files or view
    application logs), use this `docker exec` command to start bash:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问容器内部的shell（以便您可以检查文件或查看应用程序日志），请使用此`docker exec`命令启动bash：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To stop the containers, use the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止容器，请使用以下命令：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To stop the containers and *delete* them, use the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止容器并*删除*它们，请使用以下命令：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you delete a container, you delete all the data in it. That's not a problem
    for the Django container as it holds no data. However, if you delete the db container,
    you *lose the database's data*. Be careful in production.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当您删除一个容器时，您会删除其中的所有数据。对于Django容器来说这不是问题，因为它不保存数据。然而，如果您删除db容器，您将*丢失数据库的数据*。在生产环境中要小心。
- en: Sharing your container via a container registry
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过容器注册表共享您的容器
- en: Now that we have a working container, we may want to make it more widely accessible.
    Docker has the concept of a container registry. You can push your container to
    a container registry to make it available either publicly or to just your team.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作的容器，我们可能希望使其更广泛地可访问。Docker有一个容器注册表的概念。您可以将您的容器推送到容器注册表，以便将其公开或仅提供给您的团队。
- en: The most popular Docker container registry is the Docker Hub ([https://hub.docker.com](https://hub.docker.com)).
    You can create an account for free and, at the time of writing this book, each
    account comes with one free private repository and unlimited public repositories.
    Most cloud providers also have a docker repository hosting facilities as well
    (though prices may vary).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的Docker容器注册表是Docker Hub（[https://hub.docker.com](https://hub.docker.com)）。您可以免费创建一个帐户，并且在撰写本书时，每个帐户都附带一个免费的私有存储库和无限的公共存储库。大多数云提供商也提供docker存储库托管设施（尽管价格可能有所不同）。
- en: The rest of this section assumes that you have a host configured. We'll use
    Docker Hub as our example, but all the steps are the same regardless of who hosts
    your container repository.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分假设您已配置了主机。我们将以Docker Hub为例，但无论谁托管您的容器存储库，所有步骤都是相同的。
- en: 'To share your container, you''ll need to do the following things:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要共享您的容器，您需要做以下事情：
- en: Log in to a Docker registry
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Docker注册表
- en: Tag our container
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记我们的容器
- en: Push to a Docker registry
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送到Docker注册表
- en: 'Let''s start by logging in to a Docker registry:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先登录到Docker注册表：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `USERNAME` and `PASSWORD` values need to be the same as you used for your
    account on Docker Hub. `docker.io` is the domain of Docker Hub's container registry.
    If you're using a different container registry host, then you need to change the
    domain.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERNAME` 和 `PASSWORD` 的值需要与您在Docker Hub帐户上使用的相同。 `docker.io` 是Docker Hub容器注册表的域。如果您使用不同的容器注册表主机，则需要更改域。'
- en: 'Now that we''re logged in, let''s rebuild and tag our container:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录，让我们重新构建并标记我们的容器：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Where your `USERNAME` and `REPOSITORY` values are replaced with your values.
    The `:latest` suffix is the tag for the build. We could have many different tags
    in the same repository (for example, `development`, `stable`, and `1.x`). Tags
    in Docker are much like tags in version control; they help us find a particular
    item quickly and easily. `:latest` is the common tag given to the latest build
    (though it may not be stable).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `USERNAME` 和 `REPOSITORY` 的值将被替换为您的值。 `:latest` 后缀是构建的标签。我们可以在同一个存储库中有许多不同的标签（例如
    `development`，`stable` 和 `1.x`）。Docker中的标签很像版本控制中的标签；它们帮助我们快速轻松地找到特定的项目。 `:latest`
    是给最新构建的常见标签（尽管它可能不稳定）。
- en: 'Finally, let''s push our tagged build to our repository:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将标记的构建推送到我们的存储库：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Docker will show us its progress uploading and then show a SHA256 digest upon
    success.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将显示其上传的进度，然后在成功时显示SHA256摘要。
- en: When we push a Docker image to a remote repository we need to be mindful of
    any private data stored on the image. All the files we created or added in `Dockerfile` are
    contained in the pushed image. Just like we don’t want to hard code passwords
    in code that is stored in a remote repository, we also don’t want to store sensitive
    data (like passwords) in Docker images that might be stored on remote servers.
    This is another reason we emphasize storing passwords in environment variables
    rather than hard coding them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Docker镜像推送到远程存储库时，我们需要注意镜像中存储的任何私人数据。我们在 `Dockerfile` 中创建或添加的所有文件都包含在推送的镜像中。就像我们不希望在存储在远程存储库中的代码中硬编码密码一样，我们也不希望在可能存储在远程服务器上的Docker镜像中存储敏感数据（如密码）。这是我们强调将密码存储在环境变量而不是硬编码它们的另一个原因。
- en: Great! Now you can share the repo with other team members to run your Docker
    container.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在你可以与其他团队成员分享存储库，以运行你的Docker容器。
- en: Next, let's launch our container.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们启动我们的容器。
- en: Launching containers on a Linux server in the cloud
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中的Linux服务器上启动容器
- en: Now that we have everything working, we can deploy it to the internet. We can
    use Docker to deploy our containers to any Linux server. Most people who use Docker
    are using a cloud provider to provide a Linux server host. In our case, we will
    use AWS.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让一切运转起来，我们可以将其部署到互联网上。我们可以使用Docker将我们的容器部署到任何Linux服务器上。大多数使用Docker的人都在使用云提供商来提供Linux服务器主机。在我们的情况下，我们将使用AWS。
- en: In the preceding section, when we used `docker-compose`, we were actually using
    it to send commands to a Docker service running on our machine. Docker Machine
    provides a way to manage remote servers running Docker. We will use `docker-machine`
    to start an EC2 instance, which will host our Docker containers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，当我们使用 `docker-compose` 时，实际上是在向运行在我们的机器上的Docker服务发送命令。Docker Machine提供了一种管理运行Docker的远程服务器的方法。我们将使用
    `docker-machine` 来启动一个EC2实例，该实例将托管我们的Docker容器。
- en: Starting an EC2 instance can cost money. We'll use an instance that is eligible
    for the AWS free tier `t2.micro` at the time of writing this book. However, you
    are responsible for checking the terms of the AWS free tier.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 启动EC2实例可能会产生费用。在撰写本书时，我们将使用符合AWS免费套餐资格的实例 `t2.micro`。但是，您有责任检查AWS免费套餐的条款。
- en: Starting the Docker EC2 VM
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Docker EC2 VM
- en: 'We will launch our EC2 VM (called an EC2 instance) into our account''s **Virtual
    Private Cloud** (**VPC**). However, each account has a unique VPC ID. To get your
    VPC ID, run the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的帐户的**虚拟私有云**（**VPC**）中启动我们的EC2 VM（称为EC2实例）。但是，每个帐户都有一个唯一的VPC ID。要获取您的VPC
    ID，请运行以下命令：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The value used in the preceding code is not a real value.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中使用的值不是真实值。
- en: 'Now that we know our VPC ID, we can use `docker-machine` to launch an EC2 instance:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的VPC ID，我们可以使用 `docker-machine` 来启动一个EC2实例：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This tells Docker Machine to launch an EC2 `t2.micro` instance in the `us-west-2`
    region and the provided VPC. Docker Machine takes care of ensuring that a Docker
    daemon is installed and started on the server. When referencing this EC2 instance
    in Docker Machine, we refer to it by the name `mymdb-host`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Docker Machine在`us-west-2`地区和提供的VPC中启动一个EC2 `t2.micro`实例。Docker Machine负责确保服务器上安装并启动了Docker守护程序。在Docker
    Machine中引用此EC2实例时，我们使用名称 `mymdb-host`。
- en: 'When the instance is started, we can ask AWS for the public DNS name for our
    instance:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例启动时，我们可以向AWS请求我们实例的公共DNS名称：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding command may return multiple copies of the same value even if only
    one instance is up. Put the result in the `.env` file as `DJANGO_ALLOWED_HOSTS`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一个实例运行，上述命令可能会返回相同值的多个副本。将结果放入 `.env` 文件中作为 `DJANGO_ALLOWED_HOSTS`。
- en: 'All EC2 instances are protected by a firewall determined by their security
    group. Docker Machine automatically created a security group for our server when
    it started our instance. In order for our HTTP requests to make it to our machine,
    we will need to open port `80` in the `docker-machine` security group, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有EC2实例都受其安全组确定的防火墙保护。Docker Machine在启动我们的实例时自动为我们的服务器创建了一个安全组。为了使我们的HTTP请求到达我们的机器，我们需要在
    `docker-machine` 安全组中打开端口 `80`，如下所示：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that everything is set up, we can configure `docker-compose` to talk to
    our remote server and bring up our containers:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了，我们可以配置`docker-compose`与我们的远程服务器通信，并启动我们的容器：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Congratulations! MyMDB is up in a production environment. Check it out by navigating
    to the address used in `DJANGO_ALLOWED_HOSTS`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！MyMDB已经在生产环境中运行起来了。通过导航到`DJANGO_ALLOWED_HOSTS`中使用的地址来查看它。
- en: The instructions here are focused on starting an AWS Linux server. However,
    all the Docker commands have equivalent options for Google Cloud, Azure, and other
    major cloud providers. There's even a *generic* option that is made to work with
    any Linux server, though your mileage may vary depending on the Linux distribution
    and Docker version.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的说明重点是启动AWS Linux服务器。然而，所有的Docker命令都有等效的选项适用于Google Cloud、Azure和其他主要的云服务提供商。甚至还有一个*通用*选项，可以与任何Linux服务器配合使用，尽管根据Linux发行版和Docker版本的不同，效果可能有所不同。
- en: Shutting down the Docker EC2 VM
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭Docker EC2虚拟机
- en: 'Docker machine can also be used to stop VM running Docker as shown in the following
    snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine也可以用于停止运行Docker的虚拟机，如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will stop the EC2 instance and destroy all the containers in it. If you
    wish to preserve your DB, ensure that you back up your database by running the
    preceding `eval` command and then opening a shell using `docker exec -it mymdb_db_1
    bash -l`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止EC2实例并销毁其中的所有容器。如果您希望保留您的数据库，请确保通过运行前面的`eval`命令来备份您的数据库，然后使用`docker exec
    -it mymdb_db_1 bash -l`打开一个shell。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've launched MyMDB into a production Docker environment on
    the internet. We've created a Docker container for MyMDB using a Dockerfile. We
    used Docker Compose to make MyMDB work with a PostgreSQL database (also in a Docker
    container). Finally, we launched the containers on the AWS cloud using Docker
    Machine.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经将MyMDB部署到了互联网上的生产Docker环境中。我们使用Dockerfile为MyMDB创建了一个Docker容器。我们使用Docker
    Compose使MyMDB与PostgreSQL数据库（也在Docker容器中）配合工作。最后，我们使用Docker Machine在AWS云上启动了这些容器。
- en: Congratulations! You now have MyMDB running.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经让MyMDB运行起来了。
- en: In the next chapter, we'll make our implementation of Stack Overflow.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现Stack Overflow。
