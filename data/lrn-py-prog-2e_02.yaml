- en: Built-in Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: '"Data! Data! Data!" he cried impatiently. "I can''t make bricks without clay."– Sherlock
    Holmes – The Adventure of the Copper Beeches'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “数据！数据！数据！”他不耐烦地喊道。“没有黏土，我就无法制造砖块。”– 福尔摩斯 – 铜山毛榉的冒险
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It's the music you listen to, the movies you stream, the PDFs
    you open. Even the source of the chapter you're reading at this very moment is
    just a file, which is data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在计算机上所做的一切都是在管理数据。数据有许多不同的形状和风味。这是你听的音乐，你流媒体的电影，你打开的PDF。甚至你正在阅读的本章的来源只是一个文件，也就是数据。
- en: Data can be simple, an integer number to represent an age, or complex, like
    an order placed on a website. It can be about a single object or about a collection
    of them. Data can even be about data, that is, metadata. Data that describes the
    design of other data structures or data that describes application data or its
    context. In Python, *objects are abstraction for data*, and Python has an amazing
    variety of data structures that you can use to represent data, or combine them
    to create your own custom data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是简单的，比如用整数表示年龄，也可以是复杂的，比如在网站上下的订单。它可以是关于单个对象或关于它们的集合。数据甚至可以是关于数据的，也就是元数据。描述其他数据结构的设计或描述应用程序数据或其上下文的数据。在Python中，*对象是数据的抽象*，Python有各种各样的数据结构，你可以用它们来表示数据，或者组合它们来创建自己的自定义数据。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Python objects' structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python对象的结构
- en: Mutability and immutability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性和不可变性
- en: 'Built-in data types: numbers, strings, sequences, collections, and mapping
    types'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型：数字、字符串、序列、集合和映射类型
- en: The collections module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合模块
- en: Enumerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Everything is an object
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是对象
- en: Before we delve into the specifics, I want you to be very clear about objects
    in Python, so let's talk a little bit more about them. As we already said, everything
    in Python is an object. But what really happens when you type an instruction like
    `age = 42` in a Python module?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体内容之前，我希望你对Python中的对象非常清楚，所以让我们再多谈一点关于它们。正如我们已经说过的，Python中的一切都是对象。但是当你在Python模块中输入`age
    = 42`这样的指令时，真正发生了什么呢？
- en: If you go to [http://pythontutor.com/](http://pythontutor.com/), you can type
    that instruction into a text box and get its visual representation. Keep this
    website in mind; it's very useful to consolidate your understanding of what goes
    on behind the scenes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去[http://pythontutor.com/](http://pythontutor.com/)，你可以在文本框中输入该指令并获得其可视化表示。记住这个网站；它对于巩固你对幕后发生的事情的理解非常有用。
- en: 'So, what happens is that an object is created. It gets an `id`, the `type`
    is set to `int` (integer number), and the `value` to `42`. A name `age` is placed
    in the global namespace, pointing to that object. Therefore, whenever we are in
    the global namespace, after the execution of that line, we can retrieve that object
    by simply accessing it through its name: `age`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建了一个对象。它得到了一个`id`，`type`设置为`int`（整数），`value`设置为`42`。一个名为`age`的名称被放置在全局命名空间中，指向该对象。因此，每当我们在全局命名空间中，在执行该行之后，我们可以通过简单地通过其名称访问它来检索该对象：`age`。
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it *cutlery*. Can you see it''s exactly the same concept? Here''s
    a screenshot of what it may look like (you may have to tweak the settings to get
    to the same view):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要搬家，你会把所有的刀、叉和勺子放在一个盒子里，贴上“餐具”的标签。你能看到这正是相同的概念吗？这是一个可能看起来像这样的屏幕截图（你可能需要调整设置以获得相同的视图）：
- en: '![](../images/00005.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value`, think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an `id`, a `type`, and a `value`. There is a little bit more to say about
    this mechanism, but it's much easier to talk about it over an example, so we'll
    get back to this later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的其余部分，每当你读到诸如`name = some_value`这样的内容时，想象一下一个放置在命名空间中的名称，它与写入该指令的范围相关联，并且有一个漂亮的箭头指向具有`id`、`type`和`value`的对象。关于这个机制还有一些要说的，但是通过一个例子来谈论它要容易得多，所以我们稍后再回到这个问题。
- en: Mutable or immutable? That is the question
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变还是不可变？这是个问题
- en: A first fundamental distinction that Python makes on data is about whether or
    not the value of an object changes. If the value can change, the object is called
    **mutable**, while if the value cannot change, the object is called **immutable**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python对数据所做的第一个基本区分是关于对象的值是否会改变。如果值可以改变，对象称为**可变**，而如果值不能改变，对象称为**不可变**。
- en: 'It is very important that you understand the distinction between mutable and
    immutable because it affects the code you write, so here''s a question:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，你要理解可变和不可变之间的区别，因为它会影响你编写的代码，所以这里有一个问题：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, on the line `#A`, have I changed the value of age? Well,
    no. But now it''s `43` (I hear you say...). Yes, it''s `43`, but `42` was an integer
    number, of the type `int`, which is immutable. So, what happened is really that
    on the first line, `age` is a name that is set to point to an `int` object, whose
    value is `42`. When we type `age = 43`, what happens is that another object is
    created, of the type `int` and value `43` (also, the `id` will be different),
    and the name `age` is set to point to it. So, we didn''t change that `42` to `43`.
    We actually just pointed `age` to a different location: the new `int` object whose
    value is `43`. Let''s see the same code also printing the IDs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`#A`行，我改变了age的值吗？嗯，没有。但现在是`43`（我听到你说...）。是的，是`43`，但`42`是一个整数，类型是`int`，是不可变的。因此，真正发生的是在第一行，`age`是一个名称，它被设置为指向一个`int`对象，其值为`42`。当我们输入`age
    = 43`时，真正发生的是创建了另一个对象，类型为`int`，值为`43`（此外，`id`将不同），并且名称`age`被设置为指向它。因此，我们并没有将`42`改为`43`。实际上，我们只是将`age`指向了一个不同的位置：值为`43`的新`int`对象。让我们看看相同的代码也打印出ID：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we print the IDs by calling the built-in `id` function. As you
    can see, they are different, as expected. Bear in mind that `age` points to one
    object at a time: `42` first, then `43`. Never together.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过调用内置的`id`函数打印了这些ID。如你所见，它们是不同的，这是预期的。请记住，`age`一次只指向一个对象：首先是`42`，然后是`43`。从来不会同时存在。
- en: 'Now, let''s see the same example using a mutable object. For this example,
    let''s just use a `Person` object, that has a property `age` (don''t worry about
    the class declaration for now; it''s there only for completeness):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用可变对象的相同例子。对于这个例子，让我们只使用一个`Person`对象，它有一个`age`属性（现在不用担心类的声明；它只是为了完整起见）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, I set up an object `fab` whose `type` is `Person` (a custom class).
    On creation, the object is given the `age` of `42`. I'm printing it, along with
    the object `id`, and the ID of `age` as well. Notice that, even after I change
    `age` to be `25`, the ID of `fab` stays the same (while the ID of `age` has changed,
    of course). Custom objects in Python are mutable (unless you code them not to
    be). Keep this concept in mind; it's very important. I'll remind you about it
    throughout the rest of the chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我设置了一个`fab`对象，它的`type`是`Person`（一个自定义类）。在创建时，对象被赋予`42`的`age`。我打印它，以及对象的`id`，以及`age`的ID。请注意，即使我将`age`更改为`25`，`fab`的ID仍然保持不变（当然，`age`的ID已经改变了）。Python中的自定义对象是可变的（除非你编写代码使它们不可变）。记住这个概念；这是非常重要的。我会在本章的其余部分提醒你。
- en: Numbers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Let's start by exploring Python's built-in data types for numbers. Python was
    designed by a man with a master's degree in mathematics and computer science,
    so it's only logical that it has amazing support for numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索Python内置的数字数据类型开始。Python是由一位数学和计算机科学硕士设计的，因此它对数字有很好的支持是合乎逻辑的。
- en: Numbers are immutable objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是不可变对象。
- en: Integers
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'Python integers have an unlimited range, subject only to the available virtual
    memory. This means that it doesn''t really matter how big a number you want to
    store is: as long as it can fit in your computer''s memory, Python will take care
    of it. Integer numbers can be positive, negative, and 0 (zero). They support all
    the basic mathematical operations, as shown in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python整数具有无限范围，只受可用虚拟内存的限制。这意味着你想要存储的数字有多大并不重要：只要它能适应计算机的内存，Python就会处理它。整数可以是正数、负数和0（零）。它们支持所有基本的数学运算，如下例所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    (`/`), which returns the quotient of the operands, and the other one, the so-called
    **integer division** (`//`), which returns the *floored* quotient of the operands.
    It might be worth noting that in Python 2 the division operator `/` behaves differently
    than in Python 3\. See how that is different for positive and negative numbers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该很容易理解。只要注意一件重要的事情：Python有两个除法运算符，一个执行所谓的**真除法**(`//`)，返回操作数的商，另一个是所谓的**整数除法**(`//`)，返回操作数的*向下取整*商。值得注意的是，在Python
    2中，除法运算符`/`的行为与Python 3中不同。看看对于正数和负数的不同之处：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an interesting example. If you were expecting a `-1` on the last line,
    don''t feel bad, it''s just the way Python works. The result of an integer division
    in Python is always rounded towards minus infinity. If, instead of flooring, you
    want to truncate a number to an integer, you can use the built-in `int` function,
    as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子。如果你在最后一行期望得到`-1`，不要感到难过，这只是Python的工作方式。在Python中，整数除法的结果总是向负无穷大舍入。如果你想要将一个数字截断为整数，而不是向下取整，你可以使用内置的`int`函数，如下例所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the truncation is done toward `0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意截断是朝着`0`进行的。
- en: 'There is also an operator to calculate the remainder of a division. It''s called
    a modulo operator, and it''s represented by a percentage (`%`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个运算符可以计算除法的余数。它被称为模运算符，用百分号(`%`)表示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One nice feature introduced in Python 3.6 is the ability to add underscores
    within number literals (between digits or base specifiers, but not leading or
    trailing). The purpose is to help make some numbers more readable, like for example `1_000_000_000`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6中引入的一个很好的特性是在数字文字中添加下划线的能力（在数字或基数指示符之间，但不是在前导或尾随）。目的是帮助使一些数字更易读，比如`1_000_000_000`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Booleans
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Boolean algebra is that subset of algebra in which the values of the variables
    are the truth values: true and false. In Python, `True` and `False` are two keywords
    that are used to represent truth values. Booleans are a subclass of integers,
    and behave respectively like `1` and `0`. The equivalent of the `int` class for
    Booleans is the `bool` class, which returns either `True` or `False`. Every built-in
    Python object has a value in the Boolean context, which means they basically evaluate
    to either `True` or `False` when fed to the `bool` function. We''ll see all about
    this in [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe), *Iterating
    and Making Decisions*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数是代数的一个子集，在其中变量的值是真值：真和假。在Python中，`True`和`False`是两个关键字，用于表示真值。布尔值是整数的一个子类，分别像`1`和`0`一样行为。布尔值的等价于`int`类的是`bool`类，它返回`True`或`False`。每个内置的Python对象在布尔上下文中都有一个值，这意味着当它们被传递给`bool`函数时，它们基本上会被评估为`True`或`False`。我们将在[第3章](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe)中详细了解这一切，*迭代和做决定*。
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and`, `or`, and `not`. Again, we''ll see them in full in the next chapter, so
    for now let''s just see a simple example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值可以使用逻辑运算符`and`、`or`和`not`组合成布尔表达式。我们将在下一章中详细介绍它们，所以现在让我们看一个简单的例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs the addition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当你尝试将`True`和`False`相加时，它们是整数的子类。Python将它们提升为整数并执行加法：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In the example presented here, `True` and `False`, which belong to a class
    derived from the integer class, are converted back to integers when needed. This
    topic is about inheritance and will be explained in detail in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**向上转型**是一种从子类到其父类的类型转换操作。在这里介绍的例子中，`True`和`False`属于从整数类派生的类，当需要时会转换回整数。这个主题涉及继承，将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)
    *OOP, Decorators, and Iterators*中详细解释。'
- en: Real numbers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实数
- en: 'Real numbers, or floating point numbers, are represented in Python according
    to the IEEE 754 double-precision binary floating-point format, which is stored
    in 64 bits of information divided into three sections: sign, exponent, and mantissa.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实数，或浮点数，根据IEEE 754双精度二进制浮点格式在Python中表示，该格式存储在64位信息中，分为三个部分：符号、指数和尾数。
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科上了解有关这种格式的知识：[http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format)。
- en: 'Usually, programming languages give coders two different formats: single and
    double precision. The former takes up 32 bits of memory, and the latter 64\. Python
    supports only the double format. Let''s see a simple example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言给程序员提供两种不同的格式：单精度和双精度。前者占用32位内存，后者占用64位。Python仅支持双精度格式。让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the calculation of the area, I wrapped the `radius ** 2` within braces. Even
    though that wasn't necessary because the power operator has higher precedence
    than the multiplication one, I think the formula reads more easily like that.
    Moreover, should you get a slightly different result for the area, don't worry.
    It might depend on your OS, how Python was compiled, and so on. As long as the
    first few decimal digits are correct, you know it's a correct result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算面积时，我在`radius ** 2`外面加了括号。尽管这并不是必要的，因为幂运算符的优先级高于乘法运算符，但我认为这样公式读起来更容易。此外，如果你对面积得到了稍微不同的结果，不要担心。这可能取决于你的操作系统，Python是如何编译的等等。只要前几位小数正确，你就知道这是正确的结果。
- en: 'The `sys.float_info` struct sequence holds information about how floating point
    numbers will behave on your system. This is what I see on my box:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.float_info`结构序列包含有关浮点数在您的系统上的行为的信息。这是我在我的电脑上看到的：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s make a few considerations here: we have 64 bits to represent float numbers.
    This means we can represent at most `2 ** 64 == 18,446,744,073,709,551,616` numbers
    with that amount of bits. Take a look at the `max` and `epsilon` values for the
    float numbers, and you''ll realize it''s impossible to represent them all. There
    is just not enough space, so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. Well, think again and try the following in your console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做一些考虑：我们有64位来表示浮点数。这意味着我们最多可以用`2 ** 64 == 18,446,744,073,709,551,616`个数字来表示这些位数。查看浮点数的`max`和`epsilon`值，你会意识到不可能表示它们所有。空间不够，因此它们被近似到最接近的可表示数字。你可能认为只有极大或极小的数字才会受到这个问题的影响。好吧，再想一想，尝试在你的控制台上输入以下内容：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like `0.1` or `0.3`.
    Why is this important? It can be a big problem if you're handling prices, or financial
    calculations, or any kind of data that needs not to be approximated. Don't worry,
    Python gives you the **decimal** type, which doesn't suffer from these issues;
    we'll see them in a moment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你什么？它告诉你，双精度数甚至在处理简单的数字如`0.1`或`0.3`时也会受到近似问题的影响。为什么这很重要？如果你处理价格、金融计算或任何不需要近似的数据，这可能是一个大问题。不用担心，Python给了你**decimal**类型，它不会受到这些问题的影响；我们马上就会看到它们。
- en: Complex numbers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: Python gives you complex numbers support out of the box. If you don't know what
    complex numbers are, they are numbers that can be expressed in the form *a + ib*
    where *a* and *b* are real numbers, and *i* (or *j* if you're an engineer) is
    the imaginary unit, that is, the square root of *-1*. *a* and *b* are called,
    respectively, the *real* and *imaginary* part of the number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python为您提供了复数支持。如果你不知道什么是复数，它们是可以用*a + ib*的形式表示的数字，其中*a*和*b*是实数，*i*（或者如果你是工程师，是*j*）是虚数单位，即*-1*的平方根。*a*和*b*分别被称为数字的*实部*和*虚部*。
- en: 'It''s actually unlikely you''ll be using them, unless you''re coding something
    scientific. Let''s see a small example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能不会经常使用它们，除非你在编写科学代码。让我们看一个小例子：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Fractions and decimals
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数和小数
- en: 'Let''s finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let''s see a quick example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结束数字部分的介绍，看一看分数和小数。分数以最简形式保存有理数的分子和分母。让我们看一个快速的例子：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although they can be very useful at times, it's not that common to spot them
    in commercial software. Much easier instead, is to see decimal numbers being used
    in all those contexts where precision is everything; for example, in scientific
    and financial calculations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有时可能非常有用，但在商业软件中很少见。相反，更容易看到小数被用在所有那些需要精度的情境中；例如，在科学和金融计算中。
- en: It's important to remember that arbitrary precision decimal numbers come at
    a price in performance, of course. The amount of data to be stored for each number
    is far greater than it is for fractions or floats as well as the way they are
    handled, which causes the Python interpreter much more work behind the scenes.
    Another interesting thing to note is that you can get and set the precision by
    accessing `decimal.getcontext().prec`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，任意精度的十进制数当然会影响性能。每个数字要存储的数据量远远大于分数或浮点数，以及它们的处理方式，这会导致Python解释器在幕后做更多的工作。另一个有趣的事情是，您可以通过访问`decimal.getcontext().prec`来获取和设置精度。
- en: 'Let''s see a quick example with decimal numbers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用十进制数看一个快速的例子：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that when we construct a `Decimal` number from a `float`, it takes on
    all the approximation issues `float` may come from. On the other hand, when the
    `Decimal` has no approximation issues (for example, when we feed an `int` or a
    `string` representation to the constructor), then the calculation has no quirky
    behavior. When it comes to money, use decimals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们从`float`构造一个`Decimal`数字时，它会带有所有可能出现的近似问题。另一方面，当`Decimal`没有近似问题时（例如，当我们将`int`或`string`表示传递给构造函数时），则计算没有古怪的行为。在涉及货币时，请使用小数。
- en: This concludes our introduction to built-in numeric types. Let's now look at
    sequences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对内置数字类型的介绍。现在让我们来看看序列。
- en: Immutable sequences
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变序列
- en: 'Let''s start with immutable sequences: strings, tuples, and bytes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不可变序列开始：字符串、元组和字节。
- en: Strings and bytes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字节
- en: Textual data in Python is handled with `str` objects, more commonly known as
    **strings**. They are immutable sequences of **Unicode code points**. Unicode
    code points can represent a character, but can also have other meanings, such
    as formatting data, for example. Python, unlike other languages, doesn't have
    a `char` type, so a single character is rendered simply by a string of length
    `1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的文本数据是使用`str`对象处理的，更常见的是**字符串**。它们是**Unicode代码点**的不可变序列。Unicode代码点可以表示一个字符，但也可以有其他含义，例如格式化数据。与其他语言不同，Python没有`char`类型，因此单个字符只是一个长度为`1`的字符串。
- en: 'Unicode is an excellent way to handle data, and should be used for the internals
    of any application. When it comes to storing textual data though, or sending it
    on the network, you may want to encode it, using an appropriate encoding for the
    medium you''re using. The result of an encoding produces a `bytes` object, whose
    syntax and behavior is similar to that of strings. String literals are written
    in Python using single, double, or triple quotes (both single or double). If built
    with triple quotes, a string can span on multiple lines. An example will clarify
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是处理数据的一种出色方式，应该用于任何应用程序的内部。但是，当涉及存储文本数据或在网络上传输文本数据时，您可能希望对其进行编码，使用适合您使用的介质的适当编码。编码的结果会产生一个`bytes`对象，其语法和行为类似于字符串。Python中的字符串文字使用单引号、双引号或三引号（单引号或双引号）编写。如果使用三引号构建，字符串可以跨多行。一个例子将澄清这一点：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `#A` and `#B`, we print `str4`, first implicitly, and then explicitly, using
    the `print` function. A nice exercise would be to find out why they are different.
    Are you up to the challenge? (hint: look up the `str` function.)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#A`和`#B`中，我们打印`str4`，首先是隐式地，然后是显式地，使用`print`函数。一个很好的练习是找出它们为什么不同。您敢挑战吗？（提示：查找`str`函数。）
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，像任何序列一样，都有一个长度。您可以通过调用`len`函数来获得这个长度：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Encoding and decoding strings
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和解码字符串
- en: 'Using the `encode`/`decode` methods, we can encode Unicode strings and decode
    bytes objects. **UTF-8** is a variable length character encoding, capable of encoding
    all possible Unicode code points. It is the dominant encoding for the web. Notice
    also that by adding a literal `b` in front of a string declaration, we''re creating
    a *bytes* object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`encode`/`decode`方法，我们可以对Unicode字符串进行编码和解码字节对象。**UTF-8**是一种可变长度的字符编码，能够编码所有可能的Unicode代码点。它是网络的主要编码。还要注意，通过在字符串声明前面添加文字`b`，我们正在创建一个*字节*对象：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indexing and slicing strings
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片字符串
- en: When manipulating sequences, it's very common to have to access them at one
    precise position (indexing), or to get a subsequence out of them (slicing). When
    dealing with immutable sequences, both operations are read-only.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作序列时，非常常见的是必须在一个精确的位置访问它们（索引），或者从它们中获取一个子序列（切片）。在处理不可变序列时，这两种操作都是只读的。
- en: 'While indexing comes in one form, a zero-based access to any position within
    the sequence, slicing comes in different forms. When you get a slice of a sequence,
    you can specify the `start` and `stop` positions, and the `step`. They are separated
    with a colon (`:`) like this: `my_sequence[start:stop:step]`. All the arguments
    are optional, `start` is inclusive, and `stop` is exclusive. It''s much easier
    to show an example, rather than explain them further in words:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然索引以一种形式出现，即零为基础的访问序列中的任何位置，但切片以不同的形式出现。当您获取序列的一部分时，可以指定`start`和`stop`位置以及`step`。它们用冒号（`:`）分隔，就像这样：`my_sequence[start:stop:step]`。所有参数都是可选的，`start`是包含的，`stop`是排他的。最好通过示例来展示，而不是用更多的文字来解释它们：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of all the lines, the last one is probably the most interesting. If you don't
    specify a parameter, Python will fill in the default for you. In this case, `start`
    will be the start of the string, `stop` will be the end of the string, and `step`
    will be the default `1`. This is an easy and quick way of obtaining a copy of
    the string `s` (same value, but different object). Can you find a way to get the
    reversed copy of a string using slicing (don't look it up; find it for yourself)?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有行中，最后一行可能是最有趣的。如果您不指定参数，Python将为您填充默认值。在这种情况下，`start`将是字符串的开头，`stop`将是字符串的结尾，`step`将是默认值`1`。这是一种轻松快速地获取字符串`s`的副本的方法（相同的值，但不同的对象）。您能找到一种使用切片获取字符串的反向副本的方法吗（不要查找，自己找找）？
- en: String formatting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'One of the features strings have is the ability to be used as a template. There
    are several different ways of formatting a string, and for the full list of possibilities,
    I encourage you to look up the documentation. Here are some common examples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串具有的一个特性是可以用作模板。有几种不同的格式化字符串的方法，对于所有可能性的完整列表，我鼓励您查阅文档。以下是一些常见的例子：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous example, you can see four different ways of formatting stings.
    The first one, which relies on the `%` operator, is deprecated and shouldn't be
    used any more. The current, modern way to format a string is by using the `format` string
    method. You can see, from the different examples, that a pair of curly braces
    acts as a placeholder within the string. When we call `format`, we feed it data
    that replaces the placeholders. We can specify indexes (and much more) within
    the curly braces, and even names, which implies we'll have to call `format` using
    keyword arguments instead of positional ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，您可以看到四种不同的格式化字符串的方法。第一种依赖于`%`运算符，已经被弃用，不应再使用。格式化字符串的当前、现代方式是使用`format`字符串方法。从不同的例子中可以看出，一对大括号在字符串中充当占位符。当我们调用`format`时，我们提供替换占位符的数据。我们可以在大括号中指定索引（以及更多），甚至名称，这意味着我们将不得不使用关键字参数而不是位置参数来调用`format`。
- en: Notice how `greet_positional_idx` is rendered differently by feeding different
    data to the call to `format`. Apparently, I'm into Python and coffee... big surprise!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`greet_positional_idx`通过向`format`调用提供不同的数据而呈现出不同的方式。显然，我喜欢Python和咖啡...大惊喜！
- en: 'One last feature I want to show you is a relatively new addition to Python
    (Version 3.6) and it''s called **formatted string literals**. This feature is
    quite cool: strings are prefixed with `f`, and contain replacement fields surrounded
    by curly braces. Replacement fields are expressions evaluated at runtime, and
    then formatted using the `format` protocol:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向您展示的最后一个特性是Python的一个相对较新的添加（版本3.6），它被称为**格式化字符串文字**。这个特性非常酷：字符串以`f`为前缀，并包含用大括号括起来的替换字段。替换字段是在运行时评估的表达式，然后使用`format`协议进行格式化：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Check out the official documentation to learn everything about string formatting
    and how powerful it can be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档，了解有关字符串格式化以及它的强大功能的一切。
- en: Tuples
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'The last immutable sequence type we''re going to see is the tuple. A **tuple**
    is a sequence of arbitrary Python objects. In a tuple, items are separated by
    commas. They are used everywhere in Python, because they allow for patterns that
    are hard to reproduce in other languages. Sometimes tuples are used implicitly;
    for example, to set up multiple variables on one line, or to allow a function
    to return multiple different objects (usually a function returns one object only,
    in many other languages), and even in the Python console, you can use tuples implicitly
    to print multiple elements with one single instruction. We''ll see examples for
    all these cases:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的最后一个不可变序列类型是元组。**元组**是任意Python对象的序列。在元组中，项目用逗号分隔。它们在Python中随处可见，因为它们允许在其他语言中难以复制的模式。有时元组被隐式使用；例如，一次设置多个变量，或者允许函数返回多个不同的对象（通常函数只返回一个对象，在许多其他语言中），甚至在Python控制台中，您可以隐式使用元组以一条指令打印多个元素。我们将看到所有这些情况的例子：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the membership operator `in` can also be used with lists, strings,
    dictionaries, and, in general, with collection and sequence objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，成员运算符`in`也可以与列表、字符串、字典以及一般的集合和序列对象一起使用。
- en: Notice that to create a tuple with one item, we need to put that comma after
    the item. The reason is that without the comma that item is just itself wrapped
    in braces, kind of in a redundant mathematical expression. Notice also that on
    assignment, braces are optional so `my_tuple = 1, 2, 3` is the same as `my_tuple
    = (1, 2, 3)`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要创建一个只有一个项目的元组，我们需要在项目后面加上逗号。原因是，没有逗号，该项目只是自己包裹在大括号中，有点像冗余的数学表达式。还要注意，赋值时，大括号是可选的，所以`my_tuple
    = 1, 2, 3`和`my_tuple = (1, 2, 3)`是一样的。
- en: 'One thing that tuple assignment allows us to do, is *one-line swaps*, with
    no need for a third temporary variable. Let''s see first a more traditional way
    of doing it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 元组赋值允许我们*一行交换*，不需要第三个临时变量。让我们首先看一种更传统的方法：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now let''s see how we would do it in Python:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何在Python中做到这一点：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take a look at the line that shows you the Pythonic way of swapping two values.
    Do you remember what I wrote in [Chapter 1](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *A Gentle Introduction to Python*? A Python program is typically one-fifth to
    one-third the size of equivalent Java or C++ code, and features like one-line
    swaps contribute to this. Python is elegant, where elegance in this context also
    means economy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下显示Python交换两个值的Pythonic方式。你还记得我在[第1章](part0021.html#K0RQ0-2ddb708647cc4530a187c2c6c0e9acfe)中写的吗？Python程序通常只有等价的Java或C++代码的五分之一到三分之一大小，像一行交换这样的特性有助于实现这一点。Python是优雅的，这里的优雅也意味着经济。
- en: Because they are immutable, tuples can be used as keys for dictionaries (we'll
    see this shortly). To me, tuples are Python's built-in data that most closely
    represent a mathematical vector. This doesn't mean that this was the reason for
    which they were created though. Tuples usually contain an heterogeneous sequence
    of elements, while on the other hand, lists are most of the times homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是不可变的，元组可以用作字典的键（我们很快就会看到这一点）。对我来说，元组是Python内置数据，最接近数学向量的。这并不意味着这就是它们被创建的原因。元组通常包含异构序列的元素，而另一方面，列表大多数情况下是同构的。此外，元组通常通过解包或索引访问，而列表通常是迭代的。
- en: Mutable sequences
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变序列
- en: 'Mutable sequences differ from their immutable sisters in that they can be changed
    after creation. There are two mutable sequence types in Python: lists and byte
    arrays. I said before that the dictionary is the king of data structures in Python.
    I guess this makes the list its rightful queen.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列与它们的不可变姐妹们的不同之处在于它们可以在创建后进行更改。Python中有两种可变序列类型：列表和字节数组。我之前说过字典是Python中数据结构的王者。我猜这使得列表成为它合法的女王。
- en: Lists
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Python lists are mutable sequences. They are very similar to tuples, but they
    don''t have the restrictions of immutability. Lists are commonly used to storing
    collections of homogeneous objects, but there is nothing preventing you from store
    heterogeneous collections as well. Lists can be created in many different ways.
    Let''s see an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表是可变序列。它们与元组非常相似，但没有不可变性的限制。列表通常用于存储同类对象的集合，但没有什么阻止你存储异类集合。列表可以用许多不同的方式创建。让我们看一个例子：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, I showed you how to create a list using different techniques.
    I would like you to take a good look at the line that says `Python is magic`,
    which I am not expecting you to fully understand at this point (unless you cheated
    and you're not a novice!). That is called a **list ****comprehension**, a very
    powerful functional feature of Python, which we'll see in detail in [Chapter 5](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Saving Time and Memory*. I just wanted to make your mouth water at this point.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我向你展示了如何使用不同的技术创建列表。我希望你仔细看一下那一行，上面写着“Python is magic”，我不指望你现在完全理解它（除非你作弊了，你不是新手！）。这被称为**列表推导**，是Python非常强大的函数特性，我们将在[第5章](part0142.html#47DFS0-2ddb708647cc4530a187c2c6c0e9acfe)中详细讨论，*节省时间和内存*。我只是想在这一点上让你垂涎三尺。
- en: 'Creating lists is good, but the real fun comes when we use them, so let''s
    see the main methods they gift us with:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表是好的，但真正有趣的是当我们使用它们时，所以让我们看看它们赋予我们的主要方法：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code gives you a roundup of a list''s main methods. I want to
    show you how powerful they are, using `extend` as an example. You can extend lists
    using any sequence type:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为你提供了列表主要方法的概述。我想向你展示它们有多强大，以`extend`为例。你可以使用任何序列类型来扩展列表：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s see what are the most common operations you can do with lists:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你可以用列表做哪些最常见的操作：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The last two lines in the preceding code are quite interesting because they
    introduce us to a concept called **operator ****overloading**. In short, it means
    that operators such as `+`, `-`. `*`, `%`, and so on, may represent different
    operations according to the context they are used in. It doesn't make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself according to the
    right operand.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的最后两行非常有趣，因为它们向我们介绍了一个叫做**运算符重载**的概念。简而言之，这意味着`+`、`-`、`*`、`%`等运算符根据它们所用的上下文可能代表不同的操作。对两个列表求和没有任何意义，对吧？因此，`+`号用于连接它们。因此，`*`号用于根据右操作数将列表连接到自身。
- en: 'Now, let''s take a step further and see something a little more interesting.
    I want to show you how powerful the `sorted` method can be and how easy it is
    in Python to achieve results that require a great deal of effort in other languages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再进一步，看一些更有趣的东西。我想向你展示`sorted`方法有多强大，以及在Python中实现需要在其他语言中付出很大努力才能实现的结果有多容易：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code deserves a little explanation. First of all, `a` is a list
    of tuples. This means each element in `a` is a tuple (a 2-tuple, to be precise).
    When we call `sorted(some_list)`, we get a sorted version of `some_list`. In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)`, which yields `[(1, 2), (1, 3), ...]`. Python also
    gives us the ability to control which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function to work on
    the first element of each tuple (by `key=itemgetter(0)`), the result is different:
    `[(1, 3), (1, 2), ...]`. The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)`, which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1\. Compare the results and you''ll see they match.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码值得解释一下。首先，`a`是一个元组的列表。这意味着`a`中的每个元素都是一个元组（准确地说是一个2元组）。当我们调用`sorted(some_list)`时，我们得到了`some_list`的排序版本。在这种情况下，对2元组的排序是通过对元组中的第一个项目进行排序，当第一个项目相同时，再对第二个项目进行排序。你可以在`sorted(a)`的结果中看到这种行为，它产生了`[(1,
    2), (1, 3), ...]`。Python还让我们有能力控制排序必须针对元组的哪个元素。请注意，当我们指示`sorted`函数在每个元组的第一个元素上工作时（通过`key=itemgetter(0)`），结果是不同的：`[(1,
    3), (1, 2), ...]`。排序仅在每个元组的第一个元素上进行（即在位置0的元素上）。如果我们想复制简单的`sorted(a)`调用的默认行为，我们需要使用`key=itemgetter(0,
    1)`，这告诉Python首先对元组中位置0的元素进行排序，然后对位置1的元素进行排序。比较结果，你会发现它们是匹配的。
- en: For completeness, I included an example of sorting only on the elements at position
    1, and the same but in reverse order. If you have ever seen sorting in Java, I
    expect you to be quite impressed at this moment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我包括了一个仅对位置1的元素进行排序的示例，以及相同但顺序相反的示例。如果你曾经见过Java中的排序，我相信你此刻会感到非常震惊。
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (we've already seen this name, can you recall when?). It is aptly named **Timsort**,
    and it is a blend between **merge** and **insertion ****sort** and has better
    time performances than most other algorithms used for mainstream programming languages.
    Timsort is a stable sorting algorithm, which means that when multiple records
    have the same key, their original order is preserved. We've seen this in the result
    of `sorted(a, key=itemgetter(0))`, which has yielded `[(1, 3), (1, 2), ...]`,
    in which the order of those two tuples has been preserved because they have the
    same value at position 0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python排序算法非常强大，由Tim Peters编写（我们已经见过这个名字，你还记得吗？）。 它被称为**Timsort**，它是**merge**和**insertion
    sort**之间的混合，并且比大多数其他用于主流编程语言的算法具有更好的时间性能。 Timsort是一种稳定的排序算法，这意味着当多个记录具有相同的键时，它们的原始顺序被保留。
    我们在`sorted(a，key=itemgetter(0))`的结果中看到了这一点，它产生了`[(1, 3)，(1, 2)，...]`，其中这两个元组的顺序已被保留，因为它们在位置0处具有相同的值。
- en: Byte arrays
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节数组
- en: To conclude our overview of mutable sequence types, let's spend a couple of
    minutes on the `bytearray` type. Basically, they represent the mutable version
    of `bytes` objects. They expose most of the usual methods of mutable sequences
    as well as most of the methods of the `bytes` type. Items are integers in the
    range [0, 256).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对可变序列类型的概述，让我们花几分钟时间来了解`bytearray`类型。 基本上，它们代表了`bytes`对象的可变版本。 它们公开了大多数可变序列的常用方法以及`bytes`类型的大多数方法。
    项目是范围内的整数[0, 256)。
- en: 'When it comes to intervals, I''m going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round brace means it''s excluded. The granularity is usually inferred by the type
    of the edge elements so, for example, the interval [3, 7] means all integers between
    3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and
    7 exclusive (hence 4, 5, and 6). Items in a `bytearray` type are integers between
    0 and 256; 0 is included, 256 is not. One reason intervals are often expressed
    like this is to ease coding. If we break a range *[a, b)* into *N* consecutive
    ranges, we can easily represent the original one as a concatenation like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到间隔时，我将使用开/闭范围的标准表示法。 一端的方括号表示包括该值，而圆括号表示不包括该值。 粒度通常由边缘元素的类型推断，因此，例如，间隔[3,
    7]表示3和7之间的所有整数，包括。 另一方面，（3, 7）表示3和7之间的所有整数不包括（因此4、5和6）。 `bytearray`类型中的项目是介于0和256之间的整数；
    0包括在内，256不包括在内。 表达间隔的一个原因通常是为了便于编码。 如果我们将范围*[a，b)*分成*N*个连续范围，我们可以轻松地将原始范围表示为这样的连接：
- en: '*[a,k[1])+[k[1],k[2])+[k[2],k[3])+...+[k[N-1],b)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*[a，k[1])+[k[1]，k[2])+[k[2]，k[3])+...+[k[N-1]，b)*'
- en: The middle points (*k[i]*) being excluded on one end, and included on the other
    end, allow for easy concatenation and splitting when intervals are handled in
    the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 中间点（*k[i]*）在一端被排除，在另一端被包括，这样在代码处理间隔时就可以轻松进行连接和拆分。
- en: 'Let''s see a quick example with the `bytearray `type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`bytearray`类型的快速示例：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the preceding code, there are a few ways to create a `bytearray`
    object. They can be useful in many situations; for example, when receiving data
    through a socket, they eliminate the need to concatenate data while polling, hence
    they can prove to be very handy. On the line `#A`, I created a `bytearray` named
    as `name` from the bytes literal `b'Lina'` to show you how the `bytearray` object
    exposes methods from both sequences and strings, which is extremely handy. If
    you think about it, they can be considered as mutable strings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，有几种方法可以创建`bytearray`对象。 它们在许多情况下都很有用； 例如，当通过套接字接收数据时，它们消除了在轮询时连接数据的需要，因此它们可能非常方便。
    在`＃A`行，我创建了一个名为`name`的`bytearray`，从字节文字`b'Lina'`中显示了`bytearray`对象如何公开来自序列和字符串的方法，这非常方便。
    如果您仔细考虑，它们可以被视为可变字符串。
- en: Set types
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: Python also provides two set types, `set` and `frozenset`. The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects. **Hashability** is a characteristic that allows an object to be used
    as a set member as well as a key for a dictionary, as we'll see very soon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了两种集合类型，`set`和`frozenset`。 `set`类型是可变的，而`frozenset`是不可变的。 它们是不可变对象的无序集合。
    **可哈希性**是一个特性，允许对象被用作集合成员以及字典的键，我们很快就会看到。
- en: 'From the official documentation: <q class="calibre25">An object is hashable
    if it has a hash value which never changes during its lifetime, and can be compared
    to other objects. Hashability makes an object usable as a dictionary key and a
    set member, because these data structures use the hash value internally. All of
    Python’s immutable built-in objects are hashable while mutable containers are
    not.</q>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方文档：<q class="calibre25">如果对象具有在其生命周期内永远不会更改的哈希值，并且可以与其他对象进行比较，则对象是可哈希的。
    可哈希性使对象可用作字典键和集合成员，因为这些数据结构在内部使用哈希值。 所有Python的不可变内置对象都是可哈希的，而可变容器则不是。</q>
- en: 'Objects that compare equally must have the same hash value. Sets are very commonly
    used to test for membership, so let''s introduce the `in` operator in the following
    example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对象比较相等必须具有相同的哈希值。 集合非常常用于测试成员资格，因此让我们在以下示例中引入`in`运算符：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, you can see two different ways to create a set. One creates
    an empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as an argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到创建集合的两种不同方法。 一个是创建一个空集合，然后逐个添加元素。 另一个是使用数字列表作为构造函数的参数创建集合，这样我们就可以完成所有工作。
    当然，您可以从列表或元组（或任何可迭代对象）创建集合，然后可以随意添加和删除集合中的成员。
- en: We'll look at iterable objects and iteration in the next chapter. For now, just
    know that iterable objects are objects you can iterate on in a direction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中查看可迭代对象和迭代。现在，只需知道可迭代对象是可以按照某个方向进行迭代的对象。
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建集合的方法是简单地使用大括号表示法，就像这样：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice I added some duplication to emphasize that the resulting set won''t
    have any. Let''s see an example about the immutable counterpart of the set type,
    `frozenset`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我添加了一些重复，以强调结果集不会有任何重复。让我们看一个关于集合类型的不可变对应物`frozenset`的例子：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `frozenset` objects are quite limited in respect of their mutable
    counterpart. They still prove very effective for membership test, union, intersection,
    and difference operations, and for performance reasons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`frozenset`对象在其可变对应物方面相当有限。它们仍然非常有效地用于成员测试、并集、交集和差集操作，出于性能原因。
- en: Mapping types – dictionaries
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型 - 字典
- en: Of all the built-in Python data types, the dictionary is easily the most interesting
    one. It's the only standard mapping type, and it is the backbone of every Python
    object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内置的Python数据类型中，字典很容易是最有趣的一个。它是唯一的标准映射类型，也是每个Python对象的支柱。
- en: 'A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are mutable objects. There are quite
    a few different ways to create a dictionary, so let me give you a simple example
    of how to create a dictionary equal to `{''A'': 1, ''Z'': -1}` in five different
    ways:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '字典将键映射到值。键需要是可哈希的对象，而值可以是任意类型。字典是可变对象。有很多不同的方法来创建字典，所以让我给你一个简单的例子，演示如何以五种不同的方式创建一个等于`{''A'':
    1, ''Z'': -1}`的字典：'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have you noticed those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or five in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the `is` operator, and checks whether the two objects are the same (if
    they have the same ID, not just the value), but unless you have a good reason
    to use it, you should use the double equals instead. In the preceding code, I
    also used one nice function: `zip`. It is named after the real-life zip, which
    glues together two things taking one element from each at a time. Let me show
    you an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到那些双等号？赋值是用一个等号来完成的，而要检查一个对象是否与另一个对象相同（或者在这种情况下一次检查五个对象），我们使用双等号。还有另一种比较对象的方法，涉及`is`运算符，并检查两个对象是否相同（如果它们具有相同的ID，而不仅仅是值），但除非你有充分的理由使用它，否则应该使用双等号。在前面的代码中，我还使用了一个很好的函数：`zip`。它的名字来源于现实生活中的拉链，它将两个东西粘合在一起，每次取一个元素。让我给你举个例子：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, I have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that I had to wrap the `list` constructor around the `zip` call (the reason is
    because `zip` returns an iterator, not a `list`, so if I want to see the result
    I need to exhaust that iterator into something—a list in this case), and concentrate
    on the result. See how `zip` has coupled the first elements of its two arguments
    together, then the second ones, then the third ones, and so on and so forth? Take
    a look at your pants (or at your purse, if you're a lady) and you'll see the same
    behavior in your actual zip. But let's go back to dictionaries and see how many
    wonderful methods they expose for allowing us to manipulate them as we want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我以两种不同的方式创建了相同的列表，一种更加明确，另一种稍微更加Pythonic。暂时忘记我不得不在`zip`调用周围包装`list`构造函数的事实（原因是因为`zip`返回一个迭代器，而不是`list`，所以如果我想看到结果，我需要将该迭代器耗尽到某个东西中
    - 在这种情况下是一个列表），并专注于结果。看看`zip`是如何将其两个参数的第一个元素配对在一起的，然后是第二个元素，然后是第三个元素，依此类推？看看你的裤子（或者如果你是女士，看看你的钱包），你会看到你的拉链也有相同的行为。但让我们回到字典，看看它们为我们提供了多少精彩的方法来允许我们按照自己的意愿对它们进行操作。
- en: 'Let''s start with the basic operations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本操作开始：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we're performing, is done through square brackets. Do you remember strings, lists,
    and tuples? We were accessing elements at some position through square brackets
    as well, which is yet another example of Python's consistency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论我们执行何种类型的操作，访问字典的键都是通过方括号进行的。你还记得字符串、列表和元组吗？我们之前也是通过方括号访问某个位置的元素，这是Python一致性的又一个例子。
- en: 'Let''s see now three special objects called dictionary views: `keys`, `values`,
    and `items`. These objects provide a dynamic view of the dictionary entries and
    they change when the dictionary changes. `keys()` returns all the keys in the
    dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看三个特殊的对象，称为字典视图：`keys`、`values`和`items`。这些对象提供了字典条目的动态视图，并且随着字典的更改而更改。`keys()`返回字典中的所有键，`values()`返回字典中的所有值，`items()`返回字典中的所有*(键，值)*对。
- en: 'According to the Python documentation: "*Keys and values are iterated over
    in an arbitrary order which is non-random, varies across Python implementations,
    and depends on the dictionary’s history of insertions and deletions. If keys,
    values and items views are iterated over with no intervening modifications to
    the dictionary, the order of items will directly correspond.*"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：“*键和值以任意顺序进行迭代，这个顺序是非随机的，在Python的不同实现中会有所变化，并且取决于字典插入和删除的历史。如果在对键、值和项视图进行迭代时没有对字典进行干预修改，那么项的顺序将直接对应*”。
- en: 'Enough with this chatter; let''s put all this down into code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 够啰嗦了，让我们把这一切都写成代码：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are a few things to notice in the preceding code. First, notice how we're
    creating a dictionary by iterating over the zipped version of the string `'hello'`
    and the list `[0, 1, 2, 3, 4]`. The string `'hello'` has two `'l'` characters
    inside, and they are paired up with the values `2` and `3` by the `zip` function.
    Notice how in the dictionary, the second occurrence of the `'l'` key (the one
    with value `3`), overwrites the first one (the one with value `2`). Another thing
    to notice is that when asking for any view, the original order is now preserved,
    while before Version 3.6 there was no guarantee of that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有几件事情需要注意。首先，注意我们是如何通过迭代字符串`'hello'`和列表`[0, 1, 2, 3, 4]`的压缩版本来创建字典的。字符串`'hello'`里有两个`'l'`字符，它们分别与`zip`函数的值`2`和`3`配对。请注意，在字典中，`'l'`键的第二次出现（值为`3`）覆盖了第一次出现（值为`2`）。另一个需要注意的是，当请求任何视图时，原始顺序现在被保留，而在3.6版本之前，没有这样的保证。
- en: As of Python 3.6, the `dict` type has been reimplemented to use a more compact
    representation. This resulted in dictionaries using 20% to 25% less memory when
    compared to Python 3.5\. Moreover, in Python 3.6, as a side effect, dictionaries
    are natively ordered. This feature has received such a welcome from the community
    that in 3.7 it has become a legit feature of the language rather than an implementation
    side effect. A `dict` is ordered if it remembers the order in which keys were
    first inserted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.6开始，`dict`类型已经重新实现以使用更紧凑的表示。与Python 3.5相比，这导致字典使用的内存减少了20%到25%。此外，在Python
    3.6中，作为一个副作用，字典是本地有序的。这个特性受到了社区的欢迎，在3.7中它已经成为语言的合法特性，而不是实现的副作用。如果`dict`记住了首次插入键的顺序，那么它就是有序的。
- en: 'We''ll see how these views are fundamental tools when we talk about iterating
    over collections. Let''s take a look now at some other methods exposed by Python''s
    dictionaries; there''s plenty of them and they are very useful:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论对集合进行迭代时，我们将看到这些视图是基本工具。现在让我们来看一下Python字典暴露的一些其他方法；它们有很多，而且非常有用：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All these methods are quite simple to understand, but it''s worth talking about
    that `None`, for a moment. Every function in Python returns `None`, unless the
    `return` statement is explicitly used to return something else, but we''ll see
    this when we explore functions. `None` is frequently used to represent the absence
    of a value, and it is quite commonly used as a default value for arguments in
    function declaration. Some inexperienced coders sometimes write code that returns
    either `False` or `None`. Both `False` and `None` evaluate to `False` in a Boolean
    context so it may seem there is not much difference between them. But actually,
    I would argue there is quite an important difference: `False` means that we have
    information, and the information we have is `False`. `None` means *no information*.
    And no information is very different from information that is `False`. In layman''s
    terms, if you ask your mechanic,  *Is my car ready?*, there is a big difference
    between the answer, *No, it''s not* (`False`) and, *I have no idea* (`None`).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都很容易理解，但值得一提的是`None`。Python中的每个函数都返回`None`，除非`return`语句被明确用于返回其他内容，但我们将在探讨函数时再看到这一点。`None`经常用于表示值的缺失，并且在函数声明的参数中经常用作默认值。一些经验不足的编程人员有时会编写返回`False`或`None`的代码。`False`和`None`在布尔上下文中都会评估为`False`，因此它们之间似乎没有太大的区别。但实际上，我认为它们之间有一个非常重要的区别：`False`表示我们有信息，而我们拥有的信息是`False`。`None`表示*没有信息*。没有信息与信息为`False`是非常不同的。通俗地说，如果你问你的机械师，*我的车准备好了吗？*，答案之间有很大的区别，*不，还没有*（`False`）和，*我不知道*（`None`）。
- en: 'One last method I really like about dictionaries is `setdefault`. It behaves
    like `get`, but also sets the key with the given value if it is not there. Let''s
    see an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢字典的最后一个方法`setdefault`。它的行为类似于`get`，但如果键不存在，它还会将给定值设置为键。让我们看一个例子：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, we''re now at the end of this tour. Test your knowledge about dictionaries
    by trying to foresee what `d` looks like after this line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在已经到了这次旅行的尽头。通过尝试预测这行之后`d`的样子，来测试你对字典的了解：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't worry if you don't get it immediately. I just wanted to encourage you
    to experiment with dictionaries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能立刻理解，不要担心。我只是想鼓励你尝试使用字典。
- en: This concludes our tour of built-in data types. Before I discuss some considerations
    about what we've seen in this chapter, I want to take a peek briefly at the `collections`
    module.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对内置数据类型的介绍。在我讨论本章中所见内容的一些注意事项之前，我想简要地看一下`collections`模块。
- en: The collections module
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: collections模块
- en: 'When Python general purpose built-in containers (`tuple`, `list`, `set`, and
    `dict`) aren''t enough, we can find specialized container datatypes in the `collections`
    module. They are:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python通用内置容器（`tuple`，`list`，`set`和`dict`）不够用时，我们可以在`collections`模块中找到专门的容器数据类型。它们是：
- en: '| **Data type** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '**数据类型** | **描述**'
- en: '| `namedtuple()` | Factory function for creating tuple subclasses with named
    fields |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '`namedtuple()` | 用于创建具有命名字段的元组子类的工厂函数'
- en: '| `deque` | List-like container with fast appends and pops on either end |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '`deque` | 具有快速附加和弹出的类似列表的容器'
- en: '| `ChainMap` | Dictionary-like class for creating a single view of multiple
    mappings |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '`ChainMap` | 用于创建多个映射的单个视图的类似字典的类'
- en: '| `Counter` | Dictionary subclass for counting hashable objects |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '`Counter` | 用于计算可散列对象的字典子类'
- en: '| `OrderedDict` | Dictionary subclass that remembers the order entries were
    added |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '`OrderedDict` | 记住条目添加顺序的字典子类'
- en: '| `defaultdict` | Dictionary subclass that calls a factory function to supply
    missing values |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '`defaultdict` | 调用工厂函数以提供缺失值的字典子类'
- en: '| `UserDict` | Wrapper around dictionary objects for easier dictionary subclassing
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '`UserDict` | 用于更轻松地对字典子类进行封装的字典对象'
- en: '| `UserList` | Wrapper around list objects for easier list subclassing |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '`UserList` | 用于更轻松地对列表子类进行封装的列表对象'
- en: '| `UserString` | Wrapper around string objects for easier string subclassing
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '`UserString` | 用于更轻松地对字符串子类进行封装的字符串对象'
- en: We don't have the room to cover all of them, but you can find plenty of examples
    in the official documentation, so here I'll just give a small example to show
    you `namedtuple`, `defaultdict`, and `ChainMap`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有空间来涵盖所有这些，但您可以在官方文档中找到大量的例子，所以在这里我只给出一个小例子，向您展示`namedtuple`、`defaultdict`和`ChainMap`。
- en: namedtuple
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: namedtuple
- en: 'A `namedtuple` is a tuple-like object that has fields accessible by attribute
    lookup as well as being indexable and iterable (it''s actually a subclass of `tuple`).
    This is sort of a compromise between a full-fledged object and a tuple, and it
    can be useful in those cases where you don''t need the full power of a custom
    object, but you want your code to be more readable by avoiding weird indexing.
    Another use case is when there is a chance that items in the tuple need to change
    their position after refactoring, forcing the coder to refactor also all the logic
    involved, which can be very tricky. As usual, an example is better than a thousand
    words (or was it a picture?). Say we are handling data about the left and right
    eyes of a patient. We save one value for the left eye (position 0) and one for
    the right eye (position 1) in a regular tuple. Here''s how that might be:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`是一个类似于元组的对象，可以通过属性查找访问字段，也可以通过索引和迭代访问（实际上它是`tuple`的子类）。这在完整对象和元组之间是一种折衷，可以在那些不需要自定义对象的全部功能，但又希望代码更易读的情况下很有用，避免奇怪的索引。另一个用例是在重构后元组中的项目可能需要改变位置的情况下，迫使编码人员也要重构所有涉及的逻辑，这可能非常棘手。通常情况下，例子胜过千言万语（还是图片？）。假设我们正在处理关于患者左眼和右眼的数据。我们在常规元组中为左眼（位置0）保存一个值，右眼（位置1）保存一个值。如下所示：'
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s pretend we handle `vision` objects all the time, and at some point
    the designer decides to enhance them by adding information for the combined vision,
    so that a `vision` object stores data in this format: *(left eye, combined, right
    eye)*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假装我们一直处理`vision`对象，并且在某个时候设计师决定通过添加组合视觉的信息来增强它们，以便`vision`对象以这种格式存储数据：*(左眼，组合，右眼)*。
- en: 'Do you see the trouble we''re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which it still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`,
    and it can be painful. We could have probably approached this a bit better from
    the beginning, by using a `namedtuple`. Let me show you what I mean:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到我们遇到的问题了吗？我们可能有很多依赖于`vision[0]`是左眼信息（它仍然是）和`vision[1]`是右眼信息（这不再是情况）的代码。我们必须在处理这些对象的任何地方重构我们的代码，将`vision[1]`更改为`vision[2]`，这可能很痛苦。也许我们最初可以更好地处理这个问题，使用`namedtuple`。让我告诉你我的意思：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If within our code, we refer to the left and right eyes using `vision.left`
    and `vision.right`, all we need to do to fix the new design issue is to change
    our factory and the way we create instances. The rest of the code won''t need
    to change:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的代码中，我们使用`vision.left`和`vision.right`来引用左眼和右眼，我们只需要改变我们的工厂和创建实例的方式来解决新的设计问题。代码的其余部分不需要更改：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, a wise man once wrote, *Explicit is better than implicit* (can
    you recall where? Think *Zen* if you can't...). This example may be a little extreme;
    of course, it's not likely that our code designer will go for a change like this,
    but you'd be amazed to see how frequently issues similar to this one happen in
    a professional environment, and how painful it is to refactor them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，按名称而不是按位置引用这些值是多么方便。毕竟，有智慧的人曾经写道，*明确胜于隐晦*（你能回忆起在哪里吗？如果你不能，想想*禅*）。这个例子可能有点极端；当然，我们的代码设计师不太可能做出这样的改变，但您会惊讶地看到在专业环境中经常发生类似这种问题，以及重构它们是多么痛苦。
- en: defaultdict
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'The `defaultdict` data type is one of my favorites. It allows you to avoid
    checking if a key is in a dictionary by simply inserting it for you on your first
    access attempt, with a default value whose type you pass on creation. In some
    cases, this tool can be very handy and shorten your code a little. Let''s see
    a quick example. Say we are updating the value of `age`, by adding one year. If
    `age` is not there, we assume it was `0` and we update it to `1`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`数据类型是我最喜欢的之一。它允许您避免检查字典中是否存在键，只需在第一次访问时为您插入它，使用您在创建时传递的默认值类型。在某些情况下，这个工具可能非常方便，可以稍微缩短您的代码。让我们看一个快速的例子。假设我们正在更新`age`的值，增加一岁。如果`age`不存在，我们假设它是`0`，然后将其更新为`1`：'
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let''s see how it would work with a `defaultdict` data type. The second
    line is actually the short version of a four-lines-long `if` clause that we would
    have to write if dictionaries didn''t have the `get` method (we''ll see all about
    `if` clauses in [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Iterating and Making Decisions)*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`defaultdict`数据类型如何工作。第二行实际上是一个四行长的`if`子句的简短版本，如果字典没有`get`方法，我们将不得不编写它（我们将在[第3章](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe)中看到所有关于`if`子句的内容，*迭代和做决定*）：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used in case the key is missing (we'll get `0`, which is the
    default for the `int` type). Also, notice that even though in this example there
    is no gain on the number of lines, there is definitely a gain in readability,
    which is very important. You can also use a different technique to instantiate
    a `defaultdict` data type, which involves creating a factory object. To dig deeper,
    please refer to the official documentation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需要指示`defaultdict`工厂，我们希望在键丢失时使用`int`数字（我们将得到`0`，这是`int`类型的默认值）。还要注意，即使在这个例子中行数没有减少，但可读性肯定有所提高，这是非常重要的。您还可以使用不同的技术来实例化`defaultdict`数据类型，这涉及创建一个工厂对象。要深入了解，请参考官方文档。
- en: ChainMap
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChainMap
- en: '`ChainMap` is an extremely nice data type which was introduced in Python 3.3\.
    It behaves like a normal dictionary but according to the Python documentation:
    "*is provided for quickly linking a number of mappings so they can be treated
    as a single unit<q class="calibre30">"</q>.* This is usually much faster than
    creating one dictionary and running multiple update calls on it. `ChainMap` can
    be used to simulate nested scopes and is useful in templating. The underlying
    mappings are stored in a list. That list is public and can be accessed or updated
    using the maps attribute. Lookups search the underlying mappings successively
    until a key is found. By contrast, writes, updates, and deletions only operate
    on the first mapping.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`是Python 3.3中引入的一种非常好的数据类型。它的行为类似于普通字典，但根据Python文档的说法：“*用于快速链接多个映射，以便它们可以被视为单个单元<q
    class="calibre30">*”</q>。这通常比创建一个字典并对其运行多个更新调用要快得多。`ChainMap`可用于模拟嵌套作用域，在模板中非常有用。底层映射存储在列表中。该列表是公共的，可以使用maps属性进行访问或更新。查找依次搜索底层映射，直到找到一个键。相比之下，写入、更新和删除只对第一个映射进行操作。'
- en: 'A very common use case is providing defaults, so let''s see an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的用例是提供默认值，所以让我们看一个例子：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I just love how Python makes your life easy. You work on a `ChainMap` object,
    configure the first mapping as you want, and when you need a complete dictionary
    with all the defaults as well as the customized items, you just feed the `ChainMap`
    object to a `dict` constructor. If you have never coded in other languages, such
    as Java or C++, you probably won't be able to appreciate fully how precious this
    is, and how Python makes your life so much easier. I do, I feel claustrophobic
    every time I have to code in some other language.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是喜欢Python如何让你的生活变得轻松。你可以在`ChainMap`对象上工作，配置第一个映射，然后当你需要一个包含所有默认项以及自定义项的完整字典时，你只需将`ChainMap`对象提供给`dict`构造函数。如果你从未在其他语言（如Java或C++）中编写过代码，你可能无法完全欣赏到这有多么宝贵，以及Python如何让你的生活变得更加轻松。我可以，每次我不得不在其他语言中编写代码时，我都感到有一种幽闭恐惧症。
- en: Enums
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Technically not a built-in data type, as you have to import them from the `enum`
    module, but definitely worth mentioning, are enumerations. They were introduced
    in Python 3.4, and though it is not that common to see them in professional code
    (yet), I thought I'd give you an example anyway.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，枚举不是内置数据类型，因为你必须从`enum`模块中导入它们，但绝对值得一提的是枚举。它们是在Python 3.4中引入的，虽然在专业代码中看到它们并不那么常见（但），但我还是想给你举个例子。
- en: 'The official definition goes like this: "*An enumeration is a set of* *sy**mbolic*
    *names (members) bound to unique, constant values. Within an enumeration, the
    members can be compared by identity, and the enumeration itself can be iterated
    over*."'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 官方定义如下：“*枚举是一组* *符号* *名称（成员）绑定到唯一的、常量值。在枚举中，成员可以通过标识进行比较，枚举本身可以被迭代*。”
- en: 'Say you need to represent traffic lights. In your code, you might resort to
    doing this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要表示交通信号灯。在你的代码中，你可能会这样做：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There''s nothing special about the preceding code. It''s something, in fact,
    that is very common to find. But, consider doing this instead:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有什么特别之处。事实上，这是非常常见的。但是，考虑改为这样做：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Ignoring for a moment the (relative) complexity of a class definition, you can
    appreciate how this might be more advantageous. The data structure is much cleaner,
    and the API it provides is much more powerful. I encourage you to check out the
    official documentation to explore all the great features you can find in the `enum`
    module. I think it's worth exploring, at least once.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忽略类定义的（相对）复杂性，你可以欣赏到这可能更有优势。数据结构更清晰，提供的API更强大。我鼓励你查看官方文档，探索在`enum`模块中可以找到的所有出色功能。我认为值得探索，至少一次。
- en: Final considerations
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终考虑
- en: That's it. Now you have seen a very good proportion of the data structures that
    you will use in Python. I encourage you to take a dive into the Python documentation
    and experiment further with each and every data type we've seen in this chapter.
    It's worth it, believe me. Everything you'll write will be about handling data,
    so make sure your knowledge about it is rock solid.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在你已经看到了你将在Python中使用的数据结构的很大一部分。我鼓励你深入阅读Python文档，并进一步尝试本章中我们所见过的每一种数据类型。值得的，相信我。你将写的一切都与处理数据有关，所以确保你对它的知识是非常扎实的。
- en: Before we leap into [Chapter 3](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe), *Iterating
    and Making Decisions*, I'd like to share some final considerations about different
    aspects that to my mind are important and not to be neglected.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入[第3章](part0087.html#2IV0U0-2ddb708647cc4530a187c2c6c0e9acfe) *迭代和决策*之前，我想分享一些关于不同方面的最终考虑，我认为这些方面很重要，不容忽视。
- en: Small values caching
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小值缓存
- en: 'When we discussed objects at the beginning of this chapter, we saw that when
    we assigned a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value and
    we expect different objects to be created, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章开头讨论对象时，我们看到当我们将一个名称分配给一个对象时，Python会创建对象，设置其值，然后将名称指向它。我们可以将不同的名称分配给相同的值，并且我们期望创建不同的对象，就像这样：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value but they are not the same object, as you can see, their `id`
    is not the same. So let''s do it again:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`a`和`b`被分配给了两个`int`对象，它们具有相同的值，但它们不是同一个对象，你可以看到，它们的`id`不同。所以让我们再做一次：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Oh, oh! Is Python broken? Why are the two objects the same now? We didn't do
    `a = b = 5`, we set them up separately. Well, the answer is performances. Python
    caches short strings and small numbers, to avoid having many copies of them clogging
    up the system memory. Everything is handled properly under the hood so you don't
    need to worry a bit, but make sure that you remember this behavior should your
    code ever need to fiddle with IDs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，哦！Python出问题了吗？为什么现在两个对象是相同的？我们没有执行`a = b = 5`，我们分别设置它们。嗯，答案是性能。Python缓存短字符串和小数字，以避免它们的副本堵塞系统内存。一切都在幕后妥善处理，因此你不需要担心，但请确保在您的代码需要处理ID时记住这种行为。
- en: How to choose data structures
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择数据结构
- en: 'As we''ve seen, Python provides you with several built-in data types and sometimes,
    if you''re not that experienced, choosing the one that serves you best can be
    tricky, especially when it comes to collections. For example, say you have many
    dictionaries to store, each of which represents a customer. Within each customer
    dictionary, there''s an `''id'': ''code''` unique identification code. In what
    kind of collection would you place them? Well, unless I know more about these
    customers, it''s very hard to answer. What kind of access will I need? What sort
    of operations will I have to perform on each of them, and how many times? Will
    the collection change over time? Will I need to modify the customer dictionaries
    in any way? What is going to be the most frequent operation I will have to perform
    on the collection?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所见，Python为您提供了几种内置数据类型，有时，如果您没有那么多经验，选择最适合您的数据类型可能会很棘手，特别是当涉及到集合时。例如，假设您有许多字典要存储，每个字典代表一个客户。在每个客户字典中，都有一个`''id'':
    ''code''`唯一标识代码。您会将它们放在什么样的集合中？嗯，除非我更多地了解这些客户，否则很难回答。我将需要什么样的访问？我将需要对它们执行什么样的操作，以及多少次？集合会随时间改变吗？我需要以任何方式修改客户字典吗？我将在集合上执行的最频繁的操作是什么？'
- en: 'If you can answer the preceding questions, then you will know what to choose.
    If the collection never shrinks or grows (in other words, it won''t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise, lists are a good candidate. Every customer dictionary has a unique
    identifier though, so even a dictionary could work. Let me draft these options
    for you:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能回答前面的问题，那么您就会知道该选择什么。如果集合永远不会缩小或增长（换句话说，在创建后不需要添加/删除任何客户对象）或洗牌，那么元组是一个可能的选择。否则，列表是一个不错的选择。不过，每个客户字典都有一个唯一标识符，因此甚至字典也可以工作。让我为您草拟这些选项：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Some customers we have there, right? I probably wouldn't go with the tuple option,
    unless I wanted to highlight that the collection is not going to change. I'd say
    usually a list is better, as it allows for more flexibility.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些客户在那里，对吧？我可能不会选择元组选项，除非我想强调集合不会改变。我会说通常列表更好，因为它更灵活。
- en: Another factor to keep in mind is that tuples and lists are ordered collections.
    If you use a dictionary (prior to Python 3.6) or a set, you lose the ordering,
    so you need to know if ordering is important in your application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要记住的因素是元组和列表是有序集合。如果使用字典（Python 3.6之前）或集合，你会失去排序，因此你需要知道排序在你的应用程序中是否重要。
- en: What about performances? For example, in a list, operations such as insertion
    and membership can take *O(n)*, while they are *O(1)* for a dictionary. It's not
    always possible to use dictionaries though, if we don't have the guarantee that
    we can uniquely identify each item of the collection by means of one of its properties,
    and that the property in question is hashable (so it can be a key in `dict`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 性能如何？例如，在列表中，插入和成员资格等操作可能需要*O(n)*的时间，而对于字典来说则是*O(1)*。不过，并不总是可以使用字典，如果我们不能保证可以通过其属性之一唯一标识集合中的每个项目，并且该属性是可散列的（因此可以成为`dict`中的键）。
- en: If you're wondering what *O(n)* and *O(1)* mean, please Google `big O notation`.
    In this context, let's just say that if performing an operation *Op* on a data
    structure takes *O(f(n))*, it would mean that *Op* takes at most a time *t ≤ c
    * f(n)*  to complete, where *c* is some positive constant, *n* is the size of
    the input, and *f* is some function. So, think of *O(...)* as an upper bound for
    the running time of an operation (it can be used also to size other measurable
    quantities, of course).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道*O(n)*和*O(1)*的含义，请谷歌`大O符号`。在这种情况下，让我们只说，如果对数据结构执行操作*Op*需要*O(f(n))*的时间，这意味着*Op*最多需要时间*t
    ≤ c * f(n)*来完成，其中*c*是某个正常数，*n*是输入的大小，*f*是某个函数。因此，将*O(...)*视为操作运行时间的上限（当然也可以用于其他可测量的数量）。
- en: Another way of understanding if you have chosen the right data structure is
    by looking at the code you have to write in order to manipulate it. If everything
    comes easily and flows naturally, then you probably have chosen correctly, but
    if you find yourself thinking your code is getting unnecessarily complicated,
    then you probably should try and decide whether you need to reconsider your choices.
    It's quite hard to give advice without a practical case though, so when you choose
    a data structure for your data, try to keep ease of use and performance in mind
    and give precedence to what matters most in the context you are in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种了解是否选择了正确的数据结构的方法是查看您必须编写的代码以便对其进行操作。如果一切都很顺利，自然流畅，那么你可能选择正确了，但如果你发现自己认为代码变得不必要复杂，那么你可能应该尝试并决定是否需要重新考虑你的选择。不过，没有实际案例很难给出建议，因此当你为数据选择数据结构时，请记住考虑易用性和性能，并优先考虑在你所处的环境中最重要的事情。
- en: About indexing and slicing
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于索引和切片
- en: 'At the beginning of this chapter, we saw slicing applied on strings. Slicing,
    in general, applies to a sequence: tuples, lists, strings, and so on. With lists,
    slicing can also be used for assignment. I''ve almost never seen this used in
    professional code, but still, you know you can. Could you slice dictionaries or
    sets? I hear you scream, *Of course not!*. Excellent; I see we''re on the same
    page here, so let''s talk about indexing.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了字符串上的切片应用。切片通常适用于序列：元组、列表、字符串等。对于列表，切片也可以用于赋值。我几乎从未在专业代码中看到过这种用法，但是您知道您可以这样做。您可以对字典或集合进行切片吗？我听到您在尖叫，*当然不行！*。太好了；我看到我们在同一个页面上，所以让我们谈谈索引。
- en: 'There is one characteristic about Python indexing I haven''t mentioned before.
    I''ll show you by way of an example. How do you address the last element of a
    collection? Let''s see:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于Python索引的特点我之前没有提到。我将通过一个示例向您展示。如何寻址集合的最后一个元素？让我们看一下：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the list `a` has 10 elements, because of the 0-index positioning system
    of Python, the first one is at position 0 and the last one is at position 9\.
    In the preceding example, the elements are conveniently placed in a position equal
    to their value: `0` is at position 0, `1` at position 1, and so on.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表`a`有10个元素，由于Python的0索引定位系统，第一个元素位于位置0，最后一个元素位于位置9。在前面的例子中，元素方便地放置在与它们的值相等的位置：`0`位于位置0，`1`位于位置1，依此类推。
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, or string, and so on) and then subtract `1`. Hence: `len(a) -
    1`. This is so common an operation that Python provides you with a way to retrieve
    elements using **negative ****indexing**. This proves very useful when you do
    data manipulation. Here''s a nice diagram about how indexing works on the string
    `"HelloThere"` (which is Obi-Wan Kenobi sarcastically greeting General Grievous):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获取最后一个元素，我们需要知道整个列表（或元组、字符串等）的长度，然后减去`1`。因此：`len(a) - 1`。这是一个非常常见的操作，Python提供了一种使用**负索引**检索元素的方法。这在进行数据操作时非常有用。下面是一个关于字符串`"HelloThere"`（这是Obi-Wan
    Kenobi讽刺地向Grievous将军问候）的索引工作的漂亮图表：
- en: '![](../images/00006.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: Trying to address indexes greater than **9** or smaller than **-10** will raise
    an `IndexError`, as expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试处理大于**9**或小于**-10**的索引将引发`IndexError`，这是预期的。
- en: About the names
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于名称
- en: You may have noticed that, in order to keep the examples as short as possible,
    I have called many objects using simple letters, like `a`, `b`, `c`, `d`, and
    so on. This is perfectly OK when you debug on the console or when you show that
    `a + b == 7`, but it's bad practice when it comes to professional coding (or any
    type of coding, for that matter). I hope you will indulge me if I sometimes do
    it; the reason is to present the code in a more compact way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，为了使示例尽可能简短，我使用了简单的字母来调用许多对象，如`a`、`b`、`c`、`d`等。当您在控制台上调试或显示`a + b ==
    7`时，这是完全可以的，但是在专业编码（或任何类型的编码）中是不好的做法。如果我有时这样做，希望您能谅解；原因是为了以更紧凑的方式呈现代码。
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully and they should reflect what the data is about. So, if you
    have a collection of `Customer` objects, `customers` is a perfectly good name
    for it. Would `customers_list`, `customers_tuple`, or `customers_collection` work
    as well? Think about it for a second. Is it good to tie the name of the collection
    to the datatype? I don't think so, at least in most cases. So I'd say if you have
    an excellent reason to do so, go ahead; otherwise, don't. The reason is, once
    that `customers_tuple` starts being used in different places of your code, and
    you realize you actually want to use a list instead of a tuple, you're up for
    some fun refactoring (also known as **wasted time**). Names for data should be
    nouns, and names for functions should be verbs. Names should be as expressive
    as possible. Python is actually a very good example when it comes to names. Most
    of the time you can just guess what a function is called if you know what it does.
    Crazy, huh?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实环境中，当您为数据选择名称时，您应该仔细选择名称，并且名称应该反映数据的内容。因此，如果您有一组`Customer`对象，`customers`是一个非常好的名称。`customers_list`、`customers_tuple`或`customers_collection`也可以吗？想一想。将集合的名称与数据类型绑定在一起好吗？我认为大多数情况下不好。因此，我会说如果您有充分的理由这样做，请继续；否则，不要这样做。原因是，一旦`customers_tuple`开始在代码的不同位置使用，并且您意识到实际上想要使用列表而不是元组，您将需要进行一些有趣的重构（也称为**浪费时间**）。数据的名称应该是名词，函数的名称应该是动词。名称应该尽可能具有表现力。实际上，Python在命名方面是一个非常好的例子。大多数情况下，如果您知道函数的作用，您可以猜出函数的名称。疯狂，对吧？
- en: '*Chapter 2* of *Meaningful Names* of *Clean Code*, *Robert C. Martin*, *Prentice
    Hall* is entirely dedicated to names. It''s an amazing book that helped me improve
    my coding style in many different ways, and is a must-read if you want to take
    your coding to the next level.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*《代码整洁之道》*的*《有意义的命名》*第2章，*Robert C. Martin*，*Prentice Hall*完全致力于名称。这是一本了不起的书，它帮助我以许多不同的方式改进了我的编码风格，如果您想将编码提升到下一个水平，这是一本必读的书。'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've explored the built-in data types of Python. We've seen
    how many there are and how much can be achieved by just using them in different
    combinations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Python的内置数据类型。我们已经看到了有多少种类型，以及仅仅通过不同的组合就可以实现多少。
- en: We've seen number types, sequences, sets, mappings, collections (and a special
    guest appearance by `Enum`), we've seen that everything is an object, we've learned
    the difference between mutable and immutable, and we've also learned about slicing
    and indexing (and, proudly, negative indexing as well).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了数字类型、序列、集合、映射、集合（以及`Enum`的特别客串），我们已经知道了一切都是对象，我们已经学会了可变和不可变的区别，我们还学会了切片和索引（以及自豪地学会了负索引）。
- en: We've presented simple examples, but there's much more that you can learn about
    this subject, so stick your nose into the official documentation and explore.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了简单的示例，但是您可以学到更多关于这个主题的知识，所以请深入研究官方文档并探索。
- en: Most of all, I encourage you to try out all the exercises by yourself, get your
    fingers using that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types into a single expression, when you manage strings. Play with all
    data types. Exercise them, break them, discover all their methods, enjoy them,
    and learn them very, very well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我鼓励你自己尝试所有的练习，让你的手指使用那些代码，建立一些肌肉记忆，并且不断尝试，实验，实验。学习当你除以零时会发生什么，当你将不同的数字类型组合成一个表达式时会发生什么，当你处理字符串时会发生什么。玩转所有的数据类型。锻炼它们，打破它们，发现它们所有的方法，享受它们，并且非常非常好地学习它们。
- en: If your foundation is not rock solid, how good can your code be? And data is
    the foundation for everything. Data shapes what dances around it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的基础不是非常牢固的，你的代码能有多好呢？而数据是一切的基础。数据塑造了其周围的一切。
- en: The more you progress with the book, the more it's likely that you will find
    some discrepancies or maybe a small typo here and there in my code (or yours).
    You will get an error message, something will break. That's wonderful! When you
    code, things break all the time, you debug and fix all the time, so consider errors
    as useful exercises to learn something new about the language you're using, and
    not as failures or problems. Errors will keep coming up until your very last line
    of code, that's for sure, so you may as well start making your peace with them
    now.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在书中的进展，很可能会发现我的代码（或你的代码）中偶尔会出现一些不一致或小错误。你会收到错误消息，有些东西会出错。这很棒！编码时，事情经常会出错，你会一直进行调试和修复，所以把错误视为学习有关你正在使用的语言的新知识的有用练习，而不是失败或问题。错误会一直出现，直到你的最后一行代码，这是肯定的，所以最好现在就开始接受它们。
- en: The next chapter is about iterating and making decisions. We'll see how actually
    to put those collections to use, and take decisions based on the data we're presented
    with. We'll start to go a little faster now that your knowledge is building up,
    so make sure you're comfortable with the contents of this chapter before you move
    to the next one. Once more, have fun, explore, break things. It's a very good
    way to learn.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于迭代和做决策的。我们将看到如何实际运用这些集合，并根据我们所提供的数据做出决策。现在你的知识正在积累，我们将开始加快速度，所以在你进入下一章之前，请确保你对本章的内容感到舒适。再次强调，玩得开心，探索，打破一切。这是学习的好方法。
