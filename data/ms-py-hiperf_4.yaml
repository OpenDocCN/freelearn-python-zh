- en: Chapter 4. Optimize Everything
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。优化一切
- en: The path to mastering performance in Python has just started. Profiling only
    takes us half way there. Measuring how our program is using the resources at its
    disposal only tells us where the problem is, not how to fix it. In the previous
    chapters, we saw some practical examples when going over the profilers. We did
    some optimization, but we never really explained a lot about it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握Python性能提升之路才刚刚开始。性能分析只能带我们走一半的路。测量我们的程序如何使用其可用的资源只能告诉我们问题所在，但不能告诉我们如何修复它。在前几章中，我们看到了一些在介绍分析器时的实际例子。我们进行了一些优化，但从未真正详细解释过。
- en: 'In this chapter, we will cover the process of optimization, and to do that,
    we need to start with the basics. We''ll keep it inside the language for now:
    no external tools, just Python and the right way to use it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍优化的过程，为此，我们需要从基础知识开始。现在我们将将其保持在语言内部：没有外部工具，只有Python和正确使用它的方法。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下主题：
- en: Memoization / lookup tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存/查找表
- en: Usage of default arguments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数的使用
- en: List comprehension
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列推导
- en: Generators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: ctypes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ctypes
- en: String concatenation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Other tips and tricks of Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的其他技巧和窍门
- en: Memoization / lookup tables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存/查找表
- en: This is one of the most common techniques used to improve the performance of
    a piece of code (namely a function). We can save the results of expensive function
    calls associated with a specific set of input values and return the saved result
    (instead of redoing the whole computation) when the function is called with the
    remembered input. It might be confused with caching, since this is one type of
    memoization, although this term also refers to other types of optimization (such
    as HTTP caching, buffering, and so on).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提高代码（即函数）性能最常用的技术之一。我们可以保存与特定输入值集相关的高成本函数调用的结果，并在函数使用记住的输入值时返回保存的结果（而不是重新进行整个计算）。这可能会与缓存混淆，因为这是缓存的一种类型，尽管这个术语也指代其他类型的优化（如HTTP缓存、缓冲等）。
- en: This methodology is very powerful because in practice, it'll turn what should
    have been a potentially very expensive call into a *O(1)* function call (for more
    information about this, refer to [Chapter 1](ch01.html "Chapter 1. Profiling 101"),
    *Profiling 101*) if the implementation is right. Normally, the parameters are
    used to create a unique key, which is then used on a dictionary to either save
    the result or obtain it if it's been already saved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常强大，因为在实践中，它将本应是一个非常昂贵的调用转换为一个*O(1)*函数调用（有关更多信息，请参阅[第1章](ch01.html "第1章。性能分析101")，*性能分析101*），如果实现正确的话。通常，参数用于创建一个唯一的键，然后在该字典上使用该键来保存结果或获取它如果已经保存。
- en: There is, of course, a trade-off to this technique. If we're going to remember
    the returned values of a memoized function, then we'll be exchanging memory space
    for speed. This is a very acceptable trade-off, unless the saved data becomes
    more than what the system can handle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术也有权衡。如果我们打算记住缓存函数的返回值，那么我们将用内存空间来换取速度。这是一个非常可接受的权衡，除非保存的数据超过了系统可以处理的数据。
- en: 'Classic use cases for this optimization are function calls that repeat the
    input parameters often. This will assure that most of the time, the memoized results
    are returned. If there are many function calls, but with different parameters,
    we''ll only store results and spend our memory without any real benefit, as shown
    in the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化的经典用例是经常重复输入参数的函数调用。这将确保大多数时间，都会返回已缓存的值。如果有许多函数调用，但参数不同，我们只会存储结果，消耗内存而没有实际的好处，如下面的图像所示：
- en: '![Memoization / lookup tables](img/B02088_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![缓存/查找表](img/B02088_04_01.jpg)'
- en: You can clearly see how the blue bar (**Fixed params, memoized**) is clearly
    the fastest use case, while the others are all similar due to their nature.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，蓝色条（**固定参数，已缓存**）显然是最快的使用案例，而其他由于它们的性质都是相似的。
- en: 'Here is the code that generates values for the preceding chart. To generate
    some sort of time-consuming function, the code will call either the `twoParams`
    function or the `twoParamsMemoized` function several hundred times under different
    conditions, and it will log the execution time:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生成前面图表值的代码。为了生成某种耗时函数，代码将在不同条件下多次调用`twoParams`函数或`twoParamsMemoized`函数数百次，并记录执行时间：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main insight to take from the preceding chart is that, just like with every
    aspect of programming, there is no silver bullet algorithm that will work for
    all cases. Memoization is clearly a very basic way of optimizing code, but clearly,
    it won't optimize anything given the right circumstances.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以得出的主要见解是，就像编程的每个方面一样，没有一种银弹算法适用于所有情况。显然，记忆化是一种非常基本的代码优化方法，但在适当的条件下，它显然不会优化任何内容。
- en: As for the code, there is not much to it. It is a very simple, non real-world
    example of the point I was trying to send across. The `performTest` function will
    take care of running a series of 10 tests for every use case and measure the total
    time each use case takes. Notice that we're not really using profilers at this
    point. We're just measuring time in a very basic and ad-hoc way, which works for
    us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 至于代码，并没有太多。这是一个非常简单、非现实世界的例子，用以说明我试图传达的观点。`performTest` 函数将负责为每个用例运行一系列 10 个测试，并测量每个用例所花费的总时间。请注意，我们目前并没有真正使用性能分析器。我们只是在非常基础和临时的方式下测量时间，这对我们来说已经足够了。
- en: The input for both functions is simply a set of numbers on which they will run
    some math functions, just for the sake of doing something.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数的输入只是一个数字集合，它们将在这些数字上运行一些数学函数，只是为了做点事情。
- en: 'The other interesting bit about the arguments is that, since the first argument
    is a list of numbers, we can''t just use the `args` parameter as a key inside
    the `Memoized` class'' methods. This is why we have the following line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于参数的另一个有趣之处在于，由于第一个参数是一个数字列表，我们无法在 `Memoized` 类的方法中使用 `args` 参数作为键。这就是为什么我们有以下这一行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line will concatenate all the numbers from the first parameter into a single
    value, which will act as the key. The second parameter is not used here because
    it's always random, which would imply that the key will never be the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将第一个参数的所有数字连接成一个单一值，这个值将作为键。第二个参数在这里没有使用，因为它总是随机的，这意味着键永远不会相同。
- en: 'Another variation of the preceding method is to precalculate all values from
    the function during initialization (assuming we have a limited number of inputs,
    of course) initialization and then refer to the lookup table during execution.
    This approach has several preconditions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的另一种变体是在初始化期间预先计算函数的所有值（当然，假设我们有一个有限的输入数量），然后在执行期间引用查找表。这种方法有几个前提条件：
- en: The number of input values must be finite; otherwise it's impossible to precalculate
    everything
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入值数量必须是有限的；否则，无法预先计算所有内容
- en: The lookup table with all of its values, must fit into memory
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有值的查找表必须能够适应内存
- en: Just like before, the input must be repeated, at least once, so the optimization
    both makes sense and is worth the extra effort
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像之前一样，输入必须至少重复一次，这样优化才有意义，并且值得额外的努力。
- en: There are different approaches when it comes to architecting the lookup table,
    all offering different types of optimizations. It all depends on the type of application
    and solution that you're trying to optimize. Here is a set of examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建查找表时，有不同方法，所有这些方法都提供了不同类型的优化。这完全取决于你试图优化的应用程序和解决方案的类型。这里有一组示例。
- en: Performing a lookup on a list or linked list
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在列表或链表上执行查找
- en: This solution works by iterating over an unsorted list and checking the key
    against each element, with the associated value as the result we're looking for.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案通过遍历一个未排序的列表，并将键与每个元素进行比较，以关联的值作为我们寻找的结果。
- en: This is obviously a very slow method of implementation, with a Big O notation
    of *O(n)* for both the average and worst case scenarios. Still, given the right
    circumstances, it could prove to be faster than calling the actual function every
    time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一种非常慢的实现方法，对于平均和最坏情况都有 *O(n)* 的大 O 表示法。尽管如此，在适当的条件下，它可能比每次都调用实际函数要快。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: In this case, using a linked list would improve the performance of the algorithm
    over using a simple list. However, it would still depend heavily on the type of
    linked list it is (doubly linked list, simple linked list with direct access to
    the first and last elements, and so on).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用链表可以提高算法的性能，而不是使用简单的列表。然而，它仍然会严重依赖于链表的类型（双向链表、简单链表，可以直接访问第一个和最后一个元素，等等）。
- en: Simple lookup on a dictionary
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字典上进行简单查找
- en: This method works using a one-dimensional dictionary lookup, indexed by a key
    consisting of the input parameters (enough of them create a unique key). In particular
    cases (like we covered earlier), this is probably one of the fastest lookups,
    even faster than binary search in some cases with a constant execution time (Big
    O notation of *O(1)*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用一维字典查找，通过由输入参数（足够多以创建一个唯一键）组成的键进行索引。在特定情况下（如我们之前所讨论的），这可能是最快的查找之一，在某些情况下甚至比二分查找更快，具有恒定的执行时间（Big
    O 表示法为 *O(1)*）。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this approach is efficient as long as the key-generation algorithm
    is capable of generating unique keys every time. Otherwise, the performance could
    degrade over time due to the many collisions on the dictionaries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只要密钥生成算法每次都能生成唯一的密钥，这种方法就是高效的。否则，由于字典中存在许多冲突，性能可能会随着时间的推移而下降。
- en: Binary search
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找
- en: This particular method is only possible if the list is sorted. This could potentially
    be an option depending on the values to sort. Yet sorting them would require extra
    effort that would hurt the performance of the entire effort. However, it presents
    very good results, even in long lists (average Big O notation of *O(log n)*).
    It works by determining in which half of the list the value is and repeating until
    either the value is found or the algorithm is able to determine that the value
    is not in the list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定方法仅在列表已排序的情况下才可行。这可能会根据要排序的值成为一个潜在的选择。然而，排序它们会需要额外的努力，这可能会损害整个工作的性能。然而，即使在长列表中，它也能提供非常好的结果（平均
    Big O 表示法为 *O(log n)*）。它是通过确定值在列表的哪一半，并重复进行，直到找到值或算法能够确定值不在列表中。
- en: To put all of this into perspective, looking at the `Memoized` class mentioned
    earlier, it implements a simple lookup on a dictionary. However, this would be
    the place to implement either of the other algorithms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更全面地了解这一点，看看前面提到的 `Memoized` 类，它在一个字典上实现了一个简单的查找。然而，这将是实现其他算法的地方。
- en: Use cases for lookup tables
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找表的应用场景
- en: There are some classic example use cases for this type of optimization, but
    the most common one is probably the optimization of trigonometric functions. Based
    on the computing time, these functions are really slow. When used repeatedly,
    they can cause some serious damage to your program's performance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的优化有一些经典的用例，但最常见的一个可能是三角函数的优化。根据计算时间，这些函数实际上非常慢。当重复使用时，它们可能会对程序的性能造成严重损害。
- en: This is why it is normally recommended to precalculate the values of these functions.
    For functions that deal with an infinite domain universe of possible input values,
    this task becomes impossible. So, the developer is forced to sacrifice accuracy
    for performance by precalculating a discrete subdomain of the possible input values
    (that is, going from floating points down to integer numbers).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么通常建议预先计算这些函数的值。对于处理可能输入值无限域宇宙的函数，这项任务变得不可能。因此，开发者被迫牺牲精度以换取性能，通过预先计算可能输入值的离散子域（即从浮点数降到整数）。
- en: This approach might not be ideal in some cases, since some systems require both
    performance and accuracy. So, the solution is to meet in the middle and use some
    form of interpolation to calculate the required value, based on the ones that
    have been precalculated. It will provide better accuracy. Even though it won't
    be as performant as using the lookup table directly, it should prove to be faster
    than doing the trigonometric calculation every time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种方法可能并不理想，因为一些系统既需要性能也需要精度。因此，解决方案是折中一下，使用某种形式的插值来计算所需值，基于已经预先计算的那些值。这将提供更好的精度。尽管它可能不会像直接使用查找表那样高效，但它应该比每次都进行三角计算要快。
- en: 'Let''s look at some examples of this; for instance, for the following trigonometric
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些这个方法的例子；例如，对于以下三角函数：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll take a look at how simple precalculation won't be accurate enough and
    how some form of interpolation will result in a better level of accuracy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨简单的预先计算为什么不够准确，以及某种形式的插值如何导致更高的精度水平。
- en: 'The following code will precalculate the values for the function in a range
    from `-1000` to `1000` (only integer values). Then it''ll try to do the same calculation
    (only for a smaller range) for floating point numbers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将预先计算从 `-1000` 到 `1000` 范围内（仅整数值）的函数值。然后它将尝试对浮点数进行相同的计算（仅针对更小的范围）：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The results from the preceding code will help demonstrate how the simple lookup
    table approach is not accurate enough (see the following chart). However, it compensates
    for this with speed, as the original function takes 0.001526 seconds to run while
    the lookup table only takes 0.000717 seconds.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果将有助于展示简单的查找表方法并不足够准确（请参见以下图表）。然而，它通过速度来补偿这一点，因为原始函数运行需要0.001526秒，而查找表只需0.000717秒。
- en: '![Use cases for lookup tables](img/B02088_04_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![查找表的用例](img/B02088_04_02.jpg)'
- en: 'The preceding chart shows how the lack of interpolation hurts the accuracy.
    You can see how, even though both plots are quite similar, the results from the
    lookup table execution aren''t as accurate as the `trig` function used directly.
    So, now, let''s take another look at the same problem. However, this time, we''ll
    add some basic interpolation (we''ll limit the rage of values from `-PI` to `PI`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表显示了缺乏插值如何影响准确性。你可以看到，尽管两个图表非常相似，但查找表执行的结果并不像直接使用的`trig`函数那样准确。所以，现在，让我们再次审视相同的问题。然而，这次，我们将添加一些基本的插值（我们将值域限制在`-PI`到`PI`之间）：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you might've noticed in the previous chart, the resulting plot is periodic
    (especially because we've limited the range from `-PI` to `PI`). So, we'll focus
    on a particular range of values that will generate one single segment of the plot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在之前的图表中注意到的，生成的图表是周期性的（特别是因为我们已经将范围限制在`-PI`到`PI`之间）。因此，我们将关注一个特定的值域，这将生成图表的单个部分。
- en: 'The output of the preceding script also shows that the interpolation solution
    is still faster than the original trigonometric function, although not as fast
    as it was earlier:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前脚本的输出还显示，插值解决方案仍然比原始的三角函数快，尽管不如之前快：
- en: '| Interpolation solution | Original function |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 插值解决方案 | 原始函数 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0.000118 seconds | 0.000343 seconds |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0.000118秒 | 0.000343秒 |'
- en: 'The following chart is a bit different from the previous one, especially because
    it shows (in green) the error percentage between the interpolated value and the
    original one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表与之前的图表略有不同，特别是因为它显示了（以绿色表示）插值值与原始值之间的误差百分比：
- en: '![Use cases for lookup tables](img/B02088_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![查找表的用例](img/B02088_04_03.jpg)'
- en: The biggest error we have is around 12 percent (which represents the peaks we
    see on the chart). However, it's for the smallest values, such as -0.000852248551417
    versus -0.000798905501416\. This is a case where the error percentage needs to
    be contextualized to see if it really matters. In our case, since the values related
    to that error are so small, we can ignore that error in practice.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最大的误差大约是12%（这代表了图表上看到的峰值）。然而，这是对于最小的值，例如-0.000852248551417与-0.000798905501416之间的差异。这是一个需要根据上下文来理解误差百分比是否真正重要的案例。在我们的情况下，由于与该误差相关的值非常小，我们实际上可以忽略这个误差。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other use cases for lookup tables, such as in image processing. However,
    for the sake of this book, the preceding example should be enough to demonstrate
    their benefits and the trade-off implied in their usage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 查找表还有其他用例，例如在图像处理中。然而，为了这本书的目的，之前的例子应该足以展示它们的优点以及使用它们的权衡。
- en: Usage of default arguments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数的使用
- en: Another optimization technique, one that is contrary to memoization, is not
    particularly generic. Instead, it is directly tied to how the Python interpreter
    works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种优化技术，与记忆化相反，并不特别通用。相反，它直接与Python解释器的工作方式相关联。
- en: Default arguments can be used to determine values once at function creation
    time, instead of at run time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数可以在函数创建时确定值，而不是在运行时。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This can only be done for functions or objects that will not be changed during
    program execution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这只能用于在程序执行期间不会改变的函数或对象。
- en: 'Let''s look at an example of how this optimization can be applied. The following
    code shows two versions of the same function, which does some random trigonometric
    calculation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何应用这种优化的一个例子。以下代码显示了同一函数的两个版本，该函数执行一些随机的三角计算：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This optimization can be problematic if not correctly documented. Since it uses
    attributes to precompute terms that should not change during the program's execution,
    it could lead to the creation of a confusing API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有正确记录，这种优化可能会出现问题。因为它使用属性来预计算在程序执行期间不应改变的项，这可能导致创建一个令人困惑的API。
- en: 'With a quick and simple test, we can double-check the performance gain from
    this optimization:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速简单的测试，我们可以再次检查这种优化的性能提升：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code measures the time it takes for the script to finish each
    of the versions of the function to run its code for a range of `1000`. It saves
    those measurements, and finally, it creates an average for each case. The result
    is displayed in the following chart:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码测量了脚本完成每个函数版本运行范围`1000`所需的时间。它保存了这些测量结果，并最终为每种情况创建一个平均值。结果如下表所示：
- en: '![Usage of default arguments](img/B02088_04_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![默认参数的使用](img/B02088_04_04.jpg)'
- en: It clearly isn't an amazing optimization. However, it does shave off some microseconds
    from our execution time, so we'll keep it in mind. Just remember that this optimization
    could cause problems if you're working as part of an OS developer team.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是一种惊人的优化。然而，它确实从我们的执行时间中节省了一些微秒，所以我们会记住它。只是记住，如果你是作为操作系统开发团队的一员工作，这种优化可能会引起问题。
- en: List comprehension and generators
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导和生成器
- en: List comprehension is a special construct provided by Python to generate lists
    by writing in the way a mathematician would, by describing its content instead
    of writing about the way the content should be generated (with a classic `for`
    loop).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导是Python提供的一种特殊结构，通过以数学家的方式编写来生成列表，通过描述其内容而不是描述内容应如何生成（使用经典的`for`循环）。
- en: 'Let''s see an example of this to better understand how it works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解它是如何工作的：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, list comprehension is not meant to replace `for` loops altogether. They
    are a great help when dealing with loops that, like the earlier one, are creating
    a list. However, they aren't particularly recommended for those `for` loops that
    you write because of their side effects. This means you're not creating a list.
    You're most likely calling a function inside it or doing some other calculation
    that does not translate into a list. For these cases, a list comprehension expression
    would actually hurt readability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表推导并不是要完全取代`for`循环。当处理像之前那样的创建列表的循环时，它们非常有帮助。然而，对于由于副作用而编写的`for`循环，它们并不特别推荐。这意味着你并没有创建一个列表。你很可能是调用它内部的一个函数或进行一些其他不转化为列表的计算。在这些情况下，列表推导表达式实际上会损害可读性。
- en: To understand why these expressions are more performant than regular `for` loops,
    we need to do some disassembling and read a bit of bytecode. We can do this because,
    even though Python is an interpreted language, it is still being translated into
    bytecode by the compiler. This bytecode is the one that is interpreted. So, using
    the `dis` module, we can turn that bytecode into something that humans can read,
    and analyze its execution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这些表达式比常规`for`循环更高效，我们需要进行一些反汇编和阅读字节码。我们可以这样做，因为尽管Python是一种解释型语言，但它仍然被编译器翻译成字节码。这个字节码是解释器所解释的。因此，使用`dis`模块，我们可以将字节码转换成人类可读的形式，并分析其执行。
- en: 'Let''s look at the code then:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That code will output two things:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码将输出两件事：
- en: The time each piece of code takes to run
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每段代码运行所需的时间
- en: The set of instructions generated by the interpreter, thanks to the `dis` module
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由解释器生成的指令集，得益于`dis`模块
- en: 'Here is a screenshot of how that output would look (in your system, the time
    might change, but the rest should be pretty similar):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果的截图（在你的系统中，时间可能会变化，但其余部分应该相当相似）：
- en: '![List comprehension and generators](img/B02088_04_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![列表推导和生成器](img/B02088_04_05.jpg)'
- en: 'First things first; the output proves that the list comprehension version of
    the code is, indeed, faster. Now, let''s take a closer look at both lists of instructions,
    side by side, to try to understand them better:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输出证明代码的列表推导版本确实更快。现在，让我们将两个指令列表并排仔细查看，以更好地理解它们：
- en: '| The for loop instructions | Comments | The list comprehension instructions
    | Comments |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `for`循环指令 | 注释 | 列表推导指令 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `BUILD_LIST` |   | `BUILD_LIST` |   |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `BUILD_LIST` |   | `BUILD_LIST` |   |'
- en: '| `STORE_NAME` | The definition of our "multiples_of_two" list |   |   |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `STORE_NAME` | 我们“倍数”列表的定义 |   |   |'
- en: '| `SETUP_LOOP` |   |   |   |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `SETUP_LOOP` |   |   |   |'
- en: '| `LOAD_NAME` | Range function | `LOAD_NAME` | Range function |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_NAME` | 范围函数 | `LOAD_NAME` | 范围函数 |'
- en: '| `LOAD_CONST` | 100 (the attribute for the range) | `LOAD_CONST` | 100 (the
    attribute for the range) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_CONST` | 100（范围属性） | `LOAD_CONST` | 100（范围属性） |'
- en: '| `CALL_FUNCTION` | Calls range | `CALL_FUNCTION` | Calls range |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `CALL_FUNCTION` | 调用 range | `CALL_FUNCTION` | 调用 range |'
- en: '| `GET_ITER` |   | `GET_ITER` |   |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `GET_ITER` |   | `GET_ITER` |   |'
- en: '| `FOR_ITER` |   | `FOR_ITER` |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `FOR_ITER` |   | `FOR_ITER` |   |'
- en: '| `STORE_NAME` | Our temp variable x | `STORE_NAME` | Our temp variable `x`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `STORE_NAME` | 我们临时变量 x | `STORE_NAME` | 我们临时变量 `x` |'
- en: '| `LOAD_NAME` |   | `LOAD_NAME` |   |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_NAME` |   | `LOAD_NAME` |   |'
- en: '| `LOAD_CONST` | *X % 2 == 0* | `LOAD_CONST` | *X % 2 == 0* |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_CONST` | *X % 2 == 0* | `LOAD_CONST` | *X % 2 == 0* |'
- en: '| `BINARY_MODULO` | `BINARY_MODULO` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `BINARY_MODULO` | `BINARY_MODULO` |'
- en: '| `LOAD_CONST` | `LOAD_CONST` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_CONST` | `LOAD_CONST` |'
- en: '| `COMPARE_OP` | `COMPARE_OP` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `COMPARE_OP` | `COMPARE_OP` |'
- en: '| `POP_JUMP_IF_FALSE` |   | `POP_JUMP_IF_FALSE` |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `POP_JUMP_IF_FALSE` |   | `POP_JUMP_IF_FALSE` |   |'
- en: '| `LOAD_NAME` |   | `LOAD_NAME` |   |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_NAME` |   | `LOAD_NAME` |   |'
- en: '| `LOAD_ATTR` | Lookup for the append method | `LIST_APPEND` | Appends the
    value to the list |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_ATTR` | 查找追加方法 | `LIST_APPEND` | 将值追加到列表 |'
- en: '| `LOAD_NAME` | Loads the value of *X* |   |   |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_NAME` | 加载 *X* 的值 |   |   |'
- en: '| `CALL_FUNCTION` | Appends the actual value to the list |   |   |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `CALL_FUNCTION` | 将实际值追加到列表 |   |   |'
- en: '| `POP_TOP` |   |   |   |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `POP_TOP` |   |   |   |'
- en: '| `JUMP_ABSOLUTE` |   | `JUMP_ABSOLUTE` |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `JUMP_ABSOLUTE` |   | `JUMP_ABSOLUTE` |   |'
- en: '| `JUMP_ABSOLUTE` |   | `STORE_NAME` |   |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `JUMP_ABSOLUTE` |   | `STORE_NAME` |   |'
- en: '| `POP_BLOCK` |   | `LOAD_CONST` |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `POP_BLOCK` |   | `LOAD_CONST` |   |'
- en: '| `LOAD_CONST` |   | `RETURN_VALUE` |   |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `LOAD_CONST` |   | `RETURN_VALUE` |   |'
- en: '| `RETURN_VALUE` |   |   |   |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `RETURN_VALUE` |   |   |   |'
- en: From the preceding table, you can see how the `for` loop generates a longer
    list of instructions. The instructions generated by the comprehension code almost
    looks like a subset of the ones generated by the `for` loop, with the major difference
    of how the values are added. For the `for` loop, they are added one by one, using
    three instructions (`LOAD_ATTR`, `LOAD_NAME`, and `CALL_FUNCTION`). On the other
    hand, for the list comprehension column, this is done with one single, optimized
    instruction (`LIST_APPEND`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中，你可以看到`for`循环如何生成更长的指令列表。推导式代码生成的指令几乎像是`for`循环生成的指令的一个子集，主要区别在于值的添加方式。对于`for`循环，它们是逐个添加的，使用三个指令（`LOAD_ATTR`、`LOAD_NAME`和`CALL_FUNCTION`）。另一方面，对于列表推导式列，这是通过一个单一的、优化的指令（`LIST_APPEND`）完成的。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is the reason why when generating a list, the `for` loop should not be
    your weapon of choice. This is because the list comprehension you're writing is
    more efficient and sometimes, even writes more readable code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在生成列表时，`for`循环不应该成为你的首选武器。这是因为你正在编写的列表推导式更高效，有时甚至能写出更易读的代码。
- en: That being said, remember to not abuse these expressions by replacing every
    `for` loop, even the ones that do other things (side effects). In these cases,
    list comprehension expressions are not optimized and will take longer than a regular
    `for` loop.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，请记住不要过度使用这些表达式，以替换每个`for`循环，即使是执行其他操作（副作用）的循环。在这些情况下，列表推导式没有优化，并且会比常规的`for`循环花费更长的时间。
- en: 'Finally, there is one more related consideration to take into account: when
    generating big lists, comprehension expressions might not be the best solution.
    This is because they still need to generate every single value. So, if you''re
    generating a list of 100k items, there is a better way. You can use generator
    expressions. Instead of returning a list, they return a generator object, which
    has a similar API to what lists have. However, every time you request a new item,
    that item will be dynamically generated.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个相关的考虑因素需要考虑：当生成大列表时，推导式可能不是最佳解决方案。这是因为它们仍然需要生成每个单独的值。所以，如果你正在生成包含10万个项目的列表，有一个更好的方法。你可以使用生成器表达式。它们不会返回列表，而是返回一个生成器对象，其API与列表类似。然而，每次你请求一个新的项目时，该项目将会动态生成。
- en: 'The main difference between a generator object and a list object is that the
    first one doesn''t support random access. So, you can''t really use the brackets
    notation for anything. However, you can use the generator object to iterate over
    your list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象和列表对象之间的主要区别是，第一个对象不支持随机访问。所以，你实际上不能使用方括号表示法来执行任何操作。然而，你可以使用生成器对象来遍历你的列表：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another key difference between lists and generator objects is that you can only
    iterate once over the latter, while you can do the same as many times as you like
    over a list. This is a key difference because it will limit the usage of your
    efficiently generated list. So, take it into account when deciding to go with
    a list comprehension expression or a generator expression.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和生成器对象之间的另一个关键区别是，你只能对后者迭代一次，而你可以对列表进行多次相同的操作。这是一个关键的区别，因为它将限制你高效生成的列表的使用。因此，在决定使用列表推导式表达式还是生成器表达式时，请考虑这一点。
- en: 'This approach might add a little overhead when accessing the values, but it''ll
    be faster when creating the list. Here is a comparison of both list comprehension
    and generator expressions when creating lists of different lengths:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在访问值时可能会增加一点开销，但在创建列表时将会更快。以下是创建不同长度列表时列表推导式和生成器表达式的比较：
- en: '![List comprehension and generators](img/B02088_04_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![列表推导式和生成器](img/B02088_04_06.jpg)'
- en: The chart clearly shows that the performance of the generator expressions is
    better than the list comprehension expressions for lengthier lists. For smaller
    lists, the list comprehension ones are better.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图表清楚地显示，对于较长的列表，生成器表达式的性能优于列表推导式表达式。对于较短的列表，列表推导式表达式更好。
- en: ctypes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ctypes
- en: The ctypes library allows the developer to reach under the hood of Python and
    tap into the power of the C language. This is only possible with the official
    interpreter (CPython) because it is written in C. Other versions of it, such as
    PyPy or Jython, do not provide access to this library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ctypes 库允许开发者深入 Python 的底层，并利用 C 语言的强大功能。这仅适用于官方解释器（CPython），因为它是用 C 编写的。其他版本，如
    PyPy 或 Jython，不提供对这个库的访问。
- en: This interface to C can be used to do many things, since you literally have
    the ability to load pre-compiled code and use it from C. This means you have access
    to libraries such as `kernel32.dll` and `msvcrt.dll` for Windows systems, and
    `libc.so.6` for Linux systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C 接口可以用来做很多事情，因为你实际上有加载预编译代码并从 C 中使用它的能力。这意味着你可以访问 Windows 系统上的 `kernel32.dll`
    和 `msvcrt.dll` 库，以及 Linux 系统上的 `libc.so.6` 库。
- en: For our particular case, we'll focus on ways to optimize our code, showing how
    to load a custom C library and how to load a system library to take advantage
    of its optimized code. For full details on how to use this library, refer to the
    official documentation at [https://docs.python.org/2/library/ctypes.html](https://docs.python.org/2/library/ctypes.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的特定情况，我们将关注优化代码的方法，展示如何加载自定义 C 库以及如何加载系统库以利用其优化的代码。有关如何使用此库的完整详细信息，请参阅官方文档[https://docs.python.org/2/library/ctypes.html](https://docs.python.org/2/library/ctypes.html)。
- en: Loading your own custom C library
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载自己的自定义 C 库
- en: Sometimes, no matter how many optimization techniques we use on our code, they
    won't be enough to help us achieve the best possible time. In these cases, we
    can always write the sensitive code outside our program, in C, compile it into
    a library, and import it into our Python code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，无论我们在代码上使用多少优化技术，它们可能都不足以帮助我们达到最佳可能的时间。在这些情况下，我们总是可以将敏感的代码编写在我们的程序之外，用 C
    语言编写，编译成库，然后将其导入到我们的 Python 代码中。
- en: Let's look at an example of how we can do this and what type of performance
    boost we are expecting.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点以及我们期望的性能提升。
- en: The problem to solve is a very simple one, something really basic. We'll write
    the code to generate a list of prime numbers, from a list of 1 million integers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决的问题非常简单，非常基础。我们将编写代码来生成一个包含一百万个整数的素数列表。
- en: 'The Python code for that could be as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 针对那个问题的 Python 代码可能如下所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code is simple enough. Yes, we could easily improve it by changing
    the list comprehension expression for a generator. However, for the sake of showing
    the improvement from the C code, let's not do that. Now, the C code is taking
    4.5 seconds on average to run.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已经足够简单。是的，我们可以通过将列表推导式表达式更改为生成器来轻松改进它。然而，为了展示从 C 代码中获得的改进，我们就不这样做。现在，C 代码的平均运行时间为
    4.5 秒。
- en: 'Let''s now write the `check_prime` function in C, and let''s export it into
    a shared library (`.so` file):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用 C 语言编写 `check_prime` 函数，并将其导出为一个共享库（`.so` 文件）：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To generate the library file, use the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成库文件，请使用以下命令：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can edit our Python script to run both versions of the function and
    compare the times, like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编辑我们的 Python 脚本来运行函数的两个版本并比较时间，如下所示：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code gives the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下输出：
- en: '| Full Python version | C version |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 完整Python版本 | C版本 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4.49 seconds | 1.04 seconds |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 4.49秒 | 1.04秒 |'
- en: The performance boost is pretty good. It has gone from 4.5 seconds down to just
    1 second!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升相当显著。它已经从4.5秒降低到仅仅1秒！
- en: Loading a system library
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载系统库
- en: At times, there is no need to code your C function. The system's libraries probably
    have it for you already. All you have to do is import that library and use the
    function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不需要编写C函数。系统的库可能已经为你准备好了。你只需要导入那个库并使用该函数。
- en: Let's see another simple example to demonstrate the concept.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看另一个简单的例子来演示这个概念。
- en: 'The following line generates a list of 1 million random numbers, taking 0.9
    seconds:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行生成了一百万个随机数字的列表，耗时0.9秒：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the full code that runs both lines and prints out the times:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行这两行代码并打印出时间的完整代码：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: String concatenation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Python strings deserve a separate portion of this chapter because they're not
    like strings in other languages. In Python, strings are immutable, which means
    that once you create one you can't really change its value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串值得在这一章中单独讨论，因为它们与其他语言的字符串不同。在Python中，字符串是不可变的，这意味着一旦创建，就无法真正改变其值。
- en: This is a relatively confusing affirmation, since we're used to doing things
    such as concatenation or replacement on string variables. However, what the average
    Python developer doesn't realize is that there is a lot more going on behind the
    curtains than they think.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对令人困惑的断言，因为我们习惯于对字符串变量进行诸如连接或替换之类的操作。然而，普通的Python开发者并没有意识到，幕后的操作远比他们想象的要多。
- en: Since string objects are immutable, every time we do anything to change its
    content, we're actually creating a whole new string with new content and pointing
    our variable to that new string. So, we must be careful when working with strings
    to make sure we actually want to do that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串对象是不可变的，每次我们对其进行任何更改内容的行为时，实际上是在创建一个全新的字符串，并让我们的变量指向那个新字符串。因此，我们在处理字符串时必须小心，确保我们确实想要这样做。
- en: 'There is a very simple way to check the preceding scenario. The following code
    will create a set of variables with the same string (we''ll write the string every
    time). Then, using the `id` function (which, in CPython, returns the memory address
    where the value the variable points to is stored), we''ll compare them to each
    other. If strings were mutable, then all objects would be different, and thus,
    the returned values should be different. Let''s look at the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常简单的方法来检查前面的情况。下面的代码将创建一组具有相同字符串的变量（我们将每次都写这个字符串）。然后，使用`id`函数（在CPython中，它返回变量指向的值的内存地址），我们将它们相互比较。如果字符串是可变的，那么所有对象都将是不同的，因此返回的值应该是不同的。让我们看看代码：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As the comments on the code state, the output will be `True`, `True`, and `False`,
    thus showing how the system is actually reusing the `This is a string` string
    every time we write it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码注释所述，输出将是`True`，`True`和`False`，从而显示系统实际上每次我们写入`This is a string`字符串时都会重用该字符串。
- en: 'The following image tries to represent the same idea in a more graphical way:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像试图以更图形化的方式表示相同的概念：
- en: '![String concatenation](img/B02088_04_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![字符串连接](img/B02088_04_07.jpg)'
- en: Although we wrote the string twice, internally, both variables are referencing
    the same block of memory (containing the actual string). If we assign another
    value to one of them, we would not be changing the string content. We would just
    be pointing our variable to another memory address.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们写了两次字符串，但内部，这两个变量都引用了相同的内存块（包含实际的字符串）。如果我们给其中一个赋值，我们不会改变字符串的内容。我们只是让我们的变量指向另一个内存地址。
- en: '![String concatenation](img/B02088_04_08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![字符串连接](img/B02088_04_08.jpg)'
- en: The same thing happens in the preceding case, where we have a variable `b` pointing
    directly to variable `a`. Still, if we try to modify `b`, we would just be creating
    a new string once again.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个变量`b`直接指向变量`a`。尽管如此，如果我们尝试修改`b`，我们只是再次创建一个新的字符串。
- en: '![String concatenation](img/B02088_04_09.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![字符串连接](img/B02088_04_09.jpg)'
- en: Finally, what happens if we change the value of both our variables from our
    example? What happens to the `hello world` string stored in memory? Well, if there
    are no other references to it, the **Garbage Collector** will eventually take
    care of it, releasing that memory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们改变示例中两个变量的值会发生什么？内存中存储的 `hello world` 字符串会发生什么？嗯，如果没有其他引用，垃圾收集器最终会处理它，释放那块内存。
- en: That being said, immutable objects are not all that bad. They are actually good
    for performance if used right, since they can be used as dictionary keys, for
    instance, or even shared between different variable bindings (since the same block
    of memory is used every time you reference the same string). This means that the
    string `hey there` will be the same exact object every time you use that string,
    no matter what variable it is stored in (like we saw earlier).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，不可变对象并不全是坏事。如果使用得当，它们对性能实际上是有好处的，因为它们可以用作字典键，例如，甚至可以在不同的变量绑定之间共享（因为每次引用相同的字符串时都使用相同的内存块）。这意味着，无论你将这个字符串存储在什么变量中（就像我们之前看到的），字符串
    `hey there` 都将是完全相同的对象。
- en: 'With this in mind, think about what would happen for some common cases, such
    as the following one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，考虑一下一些常见情况会发生什么，例如以下这种情况：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code will generate a new string for `full_doc` for every item
    in the `word_list` list. This is not really efficient memory usage, is it? This
    is a very common case when we''re trying to recreate a string from different parts.
    There is a better, more memory efficient way of doing it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将为 `word_list` 列表中的每个项目为 `full_doc` 生成一个新的字符串。这并不是真正的有效内存使用，对吧？当我们试图从不同部分重新创建一个字符串时，这是一个非常常见的情况。有一种更好、更节省内存的方法来做这件事：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The alternative is easier to read, faster to write, and more efficient, both
    memory and time wise. The following code shows the time each option takes. With
    the right command, we can also see that the `for` loop alternative uses a bit
    more memory:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方案更容易阅读，更快地编写，并且在内存和时间方面都更高效。以下代码显示了每个选项所需的时间。使用正确的命令，我们还可以看到 `for` 循环替代方案使用了更多的内存：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the following commands we can execute the script and measure the memory
    used, using the Linux utility `time`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令我们可以执行脚本并测量内存使用，使用 Linux 工具 `time`：
- en: '#for the for-loop version:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '# 对于 for-loop 版本：'
- en: '[PRE20]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#for the join version:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '# 对于连接版本：'
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output from the for-loop version command is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: for-loop 版本的命令输出如下：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output from the join version command is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 连接版本的命令输出如下：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The join version clearly takes considerably less time, and the peak memory consumption
    (measured by the time command) is also less.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 连接版本明显花费的时间更少，并且峰值内存消耗（由 `time` 命令测量）也更少。
- en: 'The other use case we want to consider when working with strings in Python
    is a different type of concatenation; it is used when you''re only dealing with
    a few variables, such as the following one:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Python 中处理字符串时，我们还想考虑的其他用例是不同类型的连接；它在你只处理几个变量时使用，例如以下这种情况：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You''ll end up creating a set of substrings every time the system computes
    a new concatenation. So a better and more efficient way of doing this is using
    variable interpolation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每当系统计算新的连接时，你都会创建一组子字符串。所以，一个更好、更高效的方法是使用变量插值：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, it is even better to create substrings using the `locals` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 `locals` 函数创建子字符串甚至更好：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Other tips and tricks
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技巧和窍门
- en: The tips mentioned earlier are some of the most common techniques to optimize
    a program. Some of them are Python specific (such as string concatenation or using
    ctypes) and others are more generic (such as memoization and lookup tables).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的技巧是一些最常用的优化程序的技术。其中一些是 Python 特有的（例如字符串连接或使用 ctypes），而其他则是更通用的（例如记忆化和查找表）。
- en: 'There are still a few more minor tips and tricks specific to Python, which
    we will cover here. They might not yield a significant boost of speed, but they
    will shed some more light into the inner workings of the language:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些针对 Python 的特定的小技巧和窍门，我们将在下面介绍。它们可能不会带来显著的速度提升，但会更多地揭示语言的内部工作原理：
- en: '**Membership testing**: When trying to figure out if a value is inside a list
    (we use the word "list" generically here, not specifically referencing the type
    `list`), something such as "a in b", we would have better results using sets and
    dictionaries (with a lookup time of *O(1)*) than lists or tuples.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员测试**：当试图确定一个值是否在列表中（我们在这里泛指“列表”，并不是特指类型 `list`）时，例如 "a in b"，使用集合和字典（查找时间为
    *O(1)*）会比列表或元组得到更好的结果。'
- en: '**Don''t reinvent the wheel**: Python comes with built-in core blocks that
    are written in optimized C. There is no need to use hand-built alternatives, since
    the latter will most likely be slower. Datatypes such as `lists`, `tuples`, `sets`,
    and `dictionaries`, and modules such as `array`, `itertools`, and `collections.deque`
    are recommended. Built-in functions also apply here. They''ll always be faster
    to do something such as `map(operator.add, list1, list2)` will always be faster
    than `map(lambda x, y: x+y, list1, list2)`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重新发明轮子**：Python 内置了用优化过的 C 编写的核心块。没有必要使用手工构建的替代品，因为后者很可能会更慢。建议使用如 `lists`、`tuples`、`sets`
    和 `dictionaries` 这样的数据类型，以及如 `array`、`itertools` 和 `collections.deque` 这样的模块。内置函数也适用于此处。它们总是比
    `map(operator.add, list1, list2)` 这样的操作更快，而 `map(lambda x, y: x+y, list1, list2)`
    则不是。'
- en: '**Don''t forget about deque**: When needing a fixed length array or a variable
    length stack, lists perform well. However, when dealing with the `pop(0)` or `insert(0,
    your_list)` operation, try to use `collections.deque`, since it offers fast (*O(1)*)
    appends and pops up on either end of the list.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别忘了deque**：当需要固定长度的数组或可变长度的栈时，列表表现良好。然而，当处理 `pop(0)` 或 `insert(0, your_list)`
    操作时，尽量使用 `collections.deque`，因为它在列表两端提供快速的（*O(1)*）追加和弹出。'
- en: '**Sometimes is better not to def**: Calling a function adds a lot of overhead
    (as we already saw earlier). So, sometimes, in time-critical loops especially,
    inlining the code of a function, instead of calling that function, will be more
    performant. There is a big trade-off with this tip, since it could also considerably
    hurt things such as readability and maintainability. So this should only be done
    if, in fact, the boost on performance is absolutely required. The following simple
    example shows how a simple lookup operation ends up adding a considerable amount
    of time:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有时最好是不要定义**：调用函数会添加很多开销（如我们之前看到的）。因此，有时，尤其是在时间敏感的循环中，内联函数的代码，而不是调用该函数，将更高效。这个技巧有很大的权衡，因为它也可能大大损害可读性和可维护性。所以，只有在确实需要性能提升的情况下才应该这样做。以下简单的示例展示了简单的查找操作最终会增加相当多的时间：'
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**When possible, sort by the key**: When doing a custom sort on a list, try
    not to sort using a comparison function. Instead, when possible, sort by the key.
    This is because the key function will be called only once per item, whereas the
    comparison function will be called several times per item during the process.
    Let''s see a quick example comparing both methods:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当可能时，按键排序**：在对列表进行自定义排序时，尽量不使用比较函数进行排序。相反，当可能时，按键排序。这是因为键函数每个项目只会被调用一次，而比较函数在排序过程中每个项目会被调用多次。让我们通过一个快速示例来比较这两种方法：'
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**1 is better than True**: Python 2.3 `while 1` gets optimized into a single
    jump, while `while True` does not, thus taking several jumps to complete. This
    implies that writing `while 1` is more efficient than `while True`, although just
    like inlining the code, this tip comes with a big trade-off.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1比True好**：Python 2.3 的 `while 1` 被优化为单次跳转，而 `while True` 则不是，因此需要多次跳转才能完成。这意味着编写
    `while 1` 比编写 `while True` 更高效，尽管就像内联代码一样，这个技巧也有很大的权衡。'
- en: '**Multiple assignments are slow but...**: Multiple assignments (`a,b = "hello
    there", 123`) are generally slower than single assignments. However, again, when
    doing variable swaps, it becomes faster than doing it the regular way (because
    we skip the usage and assignment of the temporal variable):'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重赋值慢但...**：多重赋值（`a,b = "hello there", 123`）通常比单次赋值慢。然而，再次强调，当进行变量交换时，它比常规方式更快（因为我们跳过了临时变量的使用和赋值）：'
- en: '[PRE29]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Chained comparisons are good**: When comparing three variables with each
    other, instead of doing *x < y* and *y < z*, you can use *x < y < z*. This should
    prove easier to read (more natural) and faster to run.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链式比较是好的**：当比较三个变量时，与其做 *x < y* 和 *y < z*，你可以使用 *x < y < z*。这应该更容易阅读（更自然）并且运行更快。'
- en: '**Using namedtuples instead of regular objects**: When creating simple objects
    to store data, using the regular class notation, the instances contain a dictionary
    for attribute storage. This storage can become wasteful for objects with few attributes.
    If you need to create a large number of those objects, then that waste of memory
    adds up. For such cases, you can use `namedtuples`. This is a new `tuple` subclass,
    which can be easily constructed and is optimized for the task. For details on
    `namedtuples`, check the official documentation at [https://docs.python.org/2/library/collections.html#collections.namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple).
    The following code creates 1 million objects, both using regular classes and `namedtuples`,
    and displays the time for each action:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用命名元组代替常规对象**：当创建简单的对象来存储数据时，使用常规类表示法，实例包含一个用于属性存储的字典。对于属性较少的对象，这种存储可能会变得低效。如果你需要创建大量这样的对象，那么这种内存浪费就会累积。在这种情况下，你可以使用`namedtuples`。这是一个新的`tuple`子类，可以轻松构建，并且针对此任务进行了优化。有关`namedtuples`的详细信息，请查看官方文档[https://docs.python.org/2/library/collections.html#collections.namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple)。以下代码创建了100万个对象，既使用常规类也使用`namedtuples`，并显示了每个动作的时间：'
- en: '[PRE30]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered several optimization techniques. Some of them are
    meant to provide big boosts on speed, and/or save memory. Some of them are just
    meant to provide minor speed improvements. Most of this chapter covered Python-specific
    techniques, but some of them can be translated into other languages as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几种优化技术。其中一些旨在提供速度的大幅提升，以及/或节省内存。其中一些只是旨在提供轻微的速度提升。本章的大部分内容涵盖了Python特定的技术，但其中一些也可以翻译成其他语言。
- en: In the next chapter, we will go over optimization techniques. In particular,
    we'll cover multi-threading and multiprocessing, and you'll learn when to apply
    each one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍优化技术。特别是，我们将涵盖多线程和多进程，你将学习何时应用每一种。
