- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Enhancing Your Blog and Adding Social Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升您的博客并添加社交功能
- en: In the preceding chapter, we learned the main components of Django by developing
    a simple blog application using views, templates, and URLs. In this chapter, we
    will extend the functionalities of the blog application with features that can
    be found in many blogging platforms nowadays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用视图、模板和URL开发一个简单的博客应用程序，学习了Django的主要组件。在本章中，我们将通过添加现在许多博客平台都有的功能来扩展博客应用程序的功能。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Using canonical URLs for models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型使用规范URL
- en: Creating SEO-friendly URLs for posts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子创建SEO友好的URL
- en: Adding pagination to the post list view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为帖子列表视图添加分页
- en: Building class-based views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于类的视图
- en: Sending emails with Django
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django发送电子邮件
- en: Using Django forms to share posts via email
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django表单通过电子邮件分享帖子
- en: Adding comments to posts using forms from models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型表单添加帖子评论
- en: Functional overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 2.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*展示了本章将要构建的视图、模板和功能表示：'
- en: '![](img/B21088_02_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_01.png)'
- en: 'Figure 2.1: Diagram of functionalities built in Chapter 2'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：第二章构建的功能图
- en: In this chapter, we will add pagination to the post list page to navigate through
    all posts. We will also learn how to build class-based views with Django and convert
    the `post_list` view to a class-based view named `PostListView`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为帖子列表页面添加分页功能以浏览所有帖子。我们还将学习如何使用Django构建基于类的视图，并将`post_list`视图转换为名为`PostListView`的基于类的视图。
- en: We will create the `post_share` view to share posts via email. We will use Django
    forms to share posts and send email recommendations via **Simple Mail Transfer
    Protocol** (**SMTP**). To add comments to posts, we will create a `Comment` model
    to store comments, and we will build the `post_comment` view using forms for models.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`post_share`视图，通过电子邮件分享帖子。我们将使用Django表单来分享帖子并通过**简单邮件传输协议**（**SMTP**）发送电子邮件推荐。为了给帖子添加评论，我们将创建一个`Comment`模型来存储评论，并使用模型表单构建`post_comment`视图。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)找到。
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the `python -m pip install -r requirements.txt` command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python包都包含在章节源代码的`requirements.txt`文件中。您可以在以下部分按照说明安装每个Python包，或者可以使用`python
    -m pip install -r requirements.txt`命令一次性安装所有依赖。
- en: Using canonical URLs for models
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模型使用规范URL
- en: A website might have different pages that display the same content. In our application,
    the initial part of the content for each post is displayed both on the post list
    page and the post detail page. A canonical URL is the preferred URL for a resource.
    You can think of it as the URL of the most representative page for specific content.
    There might be different pages on your site that display posts, but there is a
    single URL that you use as the main URL for a post.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站可能有不同的页面显示相同的内容。在我们的应用程序中，每个帖子的内容初始部分既在帖子列表页面上显示，也在帖子详情页面上显示。规范URL是资源的首选URL。您可以将其视为特定内容的代表性页面的URL。您的网站上可能有不同的页面显示帖子，但只有一个URL用作帖子的主要URL。
- en: Canonical URLs allow you to specify the URL for the master copy of a page. Django
    allows you to implement the `get_absolute_url()` method in your models to return
    the canonical URL for the object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 规范URL允许您指定页面的主副本的URL。Django允许您在模型中实现`get_absolute_url()`方法以返回对象的规范URL。
- en: We will use the `post_detail` URL defined in the URL patterns of the application
    to build the canonical URL for `Post` objects. Django provides different URL resolver
    functions that allow you to build URLs dynamically using their name and any required
    parameters. We will use the `reverse()` utility function of the `django.urls`
    module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在应用程序的URL模式中定义的`post_detail` URL来构建`Post`对象的规范URL。Django提供了不同的URL解析器函数，允许您使用它们的名称和任何所需的参数动态构建URL。我们将使用`django.urls`模块的`reverse()`实用函数。
- en: 'Edit the `models.py` file of the `blog` application to import the `reverse()`
    function and add the `get_absolute_url()` method to the `Post` model as follows.
    The new code is highlighted in bold:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`models.py`文件以导入`reverse()`函数并将`get_absolute_url()`方法添加到`Post`模型中，如下所示。新的代码以粗体显示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `reverse()` function will build the URL dynamically using the URL name defined
    in the URL patterns. We have used the `blog` namespace followed by a colon and
    the `post_detail` URL name. Remember that the `blog` namespace is defined in the
    main `urls.py` file of the project when including the URL patterns from `blog.urls`.
    The `post_detail` URL is defined in the `urls.py` file of the `blog` application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()`函数将使用在URL模式中定义的URL名称动态构建URL。我们使用了`blog`命名空间，后面跟着一个冒号和`post_detail`
    URL名称。记住，当从`blog.urls`包含URL模式时，`blog`命名空间在项目的`urls.py`主文件中定义。`post_detail` URL在`blog`应用的`urls.py`文件中定义。'
- en: The resulting string, `blog:post_detail`, can be used globally in your project
    to refer to the post detail URL. This URL has a required parameter, which is the
    `id` of the blog post to retrieve. We have included the `id` of the `Post` object
    as a positional argument by using `args=[self.id]`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串`blog:post_detail`可以在你的项目中全局使用来引用文章详细URL。此URL有一个必需的参数，即要检索的博客文章的`id`。我们通过使用`args=[self.id]`将`Post`对象的`id`作为位置参数包含在内。
- en: You can learn more about the URL’s utility functions at [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)了解更多关于URL实用函数的信息。
- en: Let’s replace the post detail URLs in the templates with the new `get_absolute_url()`
    method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将模板中的文章详细URL替换为新的`get_absolute_url()`方法。
- en: 'Edit the `blog/post/list.html` file and replace the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/post/list.html`文件并替换以下行：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下行：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `blog/post/list.html` file should now look as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`blog/post/list.html`文件应该看起来如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 打开shell提示符并执行以下命令以启动开发服务器：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser. Links to individual blog
    posts should still work. Django now builds the post URLs using the `get_absolute_url()`
    method of the `Post` model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/blog/`。指向单个博客文章的链接仍然应该有效。Django现在使用`Post`模型的`get_absolute_url()`方法构建文章URL。
- en: Creating SEO-friendly URLs for posts
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对SEO友好的文章URL
- en: The canonical URL for a blog post detail view currently looks like `/blog/1/`.
    We will change the URL pattern to create SEO-friendly URLs for posts. We will
    be using both the `publish` date and `slug` values to build the URLs for single
    posts. By combining dates, we will make a post detail URL to look like `/blog/2024/1/1/who-was-django-reinhardt/`.
    We will provide search engines with friendly URLs to index, containing both the
    title and date of the post.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前博客文章详细视图的规范URL看起来像`/blog/1/`。我们将更改URL模式以创建对SEO友好的文章URL。我们将使用发布日期和`slug`值来构建单个文章的URL。通过组合日期，我们将文章详细URL设置为`/blog/2024/1/1/who-was-django-reinhardt/`。我们将为搜索引擎提供友好的URL以进行索引，包含文章的标题和日期。
- en: To retrieve single posts with the combination of publication date and slug,
    we need to ensure that no post can be stored in the database with the same `slug`
    and `publish` date as an existing post. We will prevent the `Post` model from
    storing duplicated posts by defining slugs to be unique for the publication date
    of the post.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过发布日期和`slug`的组合检索单个文章，我们需要确保没有文章可以存储在数据库中，其`slug`和`publish`日期与现有文章相同。我们将通过定义`slug`为文章发布日期的唯一值来防止`Post`模型存储重复的文章。
- en: 'Edit the `models.py` file and add the following `unique_for_date` parameter
    to the `slug` field of the `Post` model:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`models.py`文件并在`Post`模型的`slug`字段中添加以下`unique_for_date`参数：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using `unique_for_date`, the `slug` field is now required to be unique for
    the date stored in the `publish` field. Note that the `publish` field is an instance
    of `DateTimeField`, but the check for unique values will be done only against
    the date (not the time). Django will prevent you from saving a new post with the
    same slug as an existing post for a given publication date. We have now ensured
    that slugs are unique for the publication date, so we can now retrieve single
    posts by the `publish` and `slug` fields.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `unique_for_date`，`slug` 字段现在必须对于存储在 `publish` 字段中的日期是唯一的。请注意，`publish`
    字段是 `DateTimeField` 的一个实例，但唯一值的检查将仅针对日期（而不是时间）进行。Django 将防止你保存一个与给定发布日期的现有文章具有相同slug的新文章。我们现在确保slug对于发布日期是唯一的，因此我们现在可以通过
    `publish` 和 `slug` 字段检索单个文章。
- en: We have changed our models, so, let’s create migrations. Note that `unique_for_date`
    is not enforced at the database level, so no database migration is required. However,
    Django uses migrations to keep track of all model changes. We will create a migration
    just to keep migrations aligned with the current state of the model.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了模型，所以，让我们创建迁移。请注意，`unique_for_date` 并不在数据库级别强制执行，因此不需要数据库迁移。然而，Django
    使用迁移来跟踪所有模型更改。我们将创建一个迁移，只是为了保持迁移与当前模型状态的一致。
- en: 'Run the following command in the shell prompt:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中运行以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Django just created the `0002_alter_post_slug.py` file inside the `migrations`
    directory of the `blog` application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Django 已经在 `blog` 应用程序的 `migrations` 目录中创建了 `0002_alter_post_slug.py` 文件。
- en: 'Execute the following command in the shell prompt to apply existing migrations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中执行以下命令以应用现有迁移：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will get an output that ends with the following line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个以以下行结束的输出：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Django will consider that all migrations have been applied and the models are
    in sync. No action will be done in the database because `unique_for_date` is not
    enforced at the database level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将认为所有迁移都已应用，并且模型是一致的。由于 `unique_for_date` 并不在数据库级别强制执行，因此数据库中不会执行任何操作。
- en: Modifying the URL patterns
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改URL模式
- en: Let’s modify the URL patterns to use the publication date and slug for the post
    detail URL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改URL模式以使用发布日期和slug为文章详情URL。
- en: 'Edit the `urls.py` file of the `blog` application and replace the following
    line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用的 `urls.py` 文件并替换以下行：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replace the preceding line with the following lines:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下行：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `urls.py` file should now look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls.py` 文件现在应该看起来像这样：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The URL pattern for the `post_detail` view takes the following arguments:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_detail` 视图的URL模式接受以下参数：'
- en: '`year`: This requires an integer'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`：这需要一个整数'
- en: '`month`: This requires an integer'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`month`：这需要一个整数'
- en: '`day`: This requires an integer'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day`：这需要一个整数'
- en: '`post`: This requires a slug (a string that contains only letters, numbers,
    underscores, or hyphens)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：这需要一个slug（一个只包含字母、数字、下划线或连字符的字符串）'
- en: The `int` path converter is used for the `year`, `month`, and `day` parameters,
    whereas the `slug` path converter is used for the `post` parameter. You learned
    about path converters in the previous chapter. You can see all path converters
    provided by Django at [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 路径转换器用于 `year`、`month` 和 `day` 参数，而 `slug` 路径转换器用于 `post` 参数。你可以在上一章中了解到路径转换器。你可以在
    Django 提供的所有路径转换器中看到 [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)。'
- en: Our posts have now an SEO-friendly URL that is built with the date and slug
    of each post. Let’s modify the `post_detail` view accordingly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文章现在有一个SEO友好的URL，它是用每篇文章的日期和slug构建的。让我们相应地修改 `post_detail` 视图。
- en: Modifying the views
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改视图
- en: We will change the parameters of the `post_detail` view to match the new URL
    parameters and use them to retrieve the corresponding `Post` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改 `post_detail` 视图的参数以匹配新的URL参数并使用它们来检索相应的 `Post` 对象。
- en: 'Edit the `views.py` file and edit the `post_detail` view like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `views.py` 文件并修改 `post_detail` 视图如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have modified the `post_detail` view to take the `year`, `month`, `day`,
    and `post` arguments and retrieve a published post with the given slug and publication
    date. By adding `unique_for_date='publish'` to the `slug` field of the `Post`
    model, we ensured that there would be only one post with a slug for a given date.
    Thus, you can retrieve single posts using the date and slug.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已修改`post_detail`视图，以接受`year`、`month`、`day`和`post`参数，并检索具有给定slug和发布日期的已发布文章。通过在`Post`模型的`slug`字段中添加`unique_for_date='publish'`，我们确保了对于给定日期只有一个具有slug的文章。因此，您可以使用日期和slug检索单个文章。
- en: Modifying the canonical URL for posts
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改文章的规范URL
- en: We also have to modify the parameters of the canonical URL for blog posts to
    match the new URL parameters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改博客文章的规范URL参数，以匹配新的URL参数。
- en: 'Edit the `models.py` file of the `blog` application and edit the `get_absolute_url()`
    method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`models.py`文件，并按照以下方式编辑`get_absolute_url()`方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start the development server by typing the following command in the shell prompt:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中键入以下命令以启动开发服务器：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, you can return to your browser and click on one of the post titles to
    take a look at the detail view of the post. You should see something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在浏览器中点击其中一个文章标题，查看文章的详细视图。您应该看到如下内容：
- en: '![](img/B21088_02_02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_02.png)'
- en: 'Figure 2.2: The page for the post’s detail view'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：文章详细视图页面
- en: You have designed SEO-friendly URLs for the blog posts. The URL for a post now
    looks like `/blog/2024/1/1/who-was-django-reinhardt/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经为博客文章设计了SEO友好的URL。现在文章的URL看起来像这样：`/blog/2024/1/1/who-was-django-reinhardt/`。
- en: Now that you have implemented SEO-friendly URLs, let’s focus on implementing
    navigation through posts using pagination.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经实现了SEO友好的URL，让我们专注于使用分页实现文章导航。
- en: Adding pagination
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分页
- en: When you start adding content to your blog, you can easily store tens or hundreds
    of posts in your database. Instead of displaying all the posts on a single page,
    you may want to split the list of posts across several pages and include navigation
    links to the different pages. This functionality is called pagination, and you
    can find it in almost every web application that displays long lists of items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始向博客添加内容时，您可以在数据库中轻松存储数十或数百篇文章。而不是在单页上显示所有文章，您可能希望将文章列表分页显示在几个页面上，并包含导航链接到不同的页面。这种功能称为分页，您几乎可以在显示长列表项的每个Web应用程序中找到它。
- en: 'For example, Google uses pagination to divide search results across multiple
    pages. *Figure 2.3* shows Google’s pagination links for search result pages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Google使用分页将搜索结果分散在多个页面上。*图2.3*展示了Google搜索结果页面的分页链接：
- en: '![Icon  Description automatically generated](img/B21088_02_03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图标描述自动生成](img/B21088_02_03.png)'
- en: 'Figure 2.3: Google pagination links for search result pages'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Google搜索结果页面的分页链接
- en: Django has a built-in pagination class that allows you to manage paginated data
    easily. You can define the number of objects you want to be returned per page
    and you can retrieve the posts that correspond to the page requested by the user.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个内置的分页类，允许您轻松管理分页数据。您可以定义每页要返回的对象数量，并且可以检索用户请求的页面对应的文章。
- en: Adding pagination to the post list view
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文章列表视图中添加分页
- en: We will add pagination to the list of posts so that users can easily navigate
    through all posts published on the blog.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向文章列表添加分页，以便用户可以轻松浏览博客上发布的所有文章。
- en: 'Edit the `views.py` file of the `blog` application to import the Django `Paginator`
    class and modify the `post_list` view as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，导入Django的`Paginator`类，并按照以下方式修改`post_list`视图：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s review the new code we have added to the view:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们添加到视图中的新代码：
- en: We instantiate the `Paginator` class with the number of objects to return per
    page. We will display three posts per page.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用每页要返回的对象数量实例化`Paginator`类。我们将每页显示三篇文章。
- en: We retrieve the `page` `GET` HTTP parameter and store it in the `page_number`
    variable. This parameter contains the requested page number. If the `page` parameter
    is not in the `GET` parameters of the request, we use the default value `1` to
    load the first page of results.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检索`page` `GET` HTTP参数并将其存储在`page_number`变量中。此参数包含请求的页码。如果`page`参数不在请求的`GET`参数中，我们使用默认值`1`来加载结果的第一页。
- en: We obtain the objects for the desired page by calling the `page()` method of
    `Paginator`. This method returns a `Page` object that we store in the `posts`
    variable.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用 `Paginator` 的 `page()` 方法来获取所需页面的对象。此方法返回一个 `Page` 对象，我们将其存储在 `posts`
    变量中。
- en: We pass the `posts` object to the template.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `posts` 对象传递给模板。
- en: Creating a pagination template
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分页模板
- en: We need to create a page navigation for users to browse through the different
    pages. In this section, we will create a template to display the pagination links,
    and we’ll make it generic so that we can reuse the template for any object pagination
    on our website.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为用户创建页面导航，以便浏览不同的页面。在本节中，我们将创建一个模板来显示分页链接，并将其设计为通用，以便我们可以在网站上为任何对象分页重用该模板。
- en: 'In the `templates/` directory, create a new file and name it `pagination.html`.
    Add the following HTML code to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates/` 目录下创建一个新文件，并将其命名为 `pagination.html`。将以下HTML代码添加到文件中：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the generic pagination template. The template expects to have a `Page`
    object in the context to render the previous and next links and to display the
    current page and total pages of results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的分页模板。该模板期望在上下文中有一个 `Page` 对象来渲染上一页和下一页的链接，并显示当前页和总页数。
- en: 'Let’s return to the `blog/post/list.html` template and include the `pagination.html`
    template at the bottom of the `{% content %}` block, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `blog/post/list.html` 模板，并在 `{% content %}` 块的底部包含 `pagination.html` 模板，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `{% include %}` template tag loads the given template and renders it using
    the current template context. We use `with` to pass additional context variables
    to the template. The pagination template uses the `page` variable to render, while
    the `Page` object that we pass from our view to the template is called `posts`.
    We use `with page=posts` to pass the variable expected by the pagination template.
    You can follow this method to use the pagination template for any type of object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% include %}` 模板标签加载给定的模板，并使用当前的模板上下文来渲染它。我们使用 `with` 来向模板传递额外的上下文变量。分页模板使用
    `page` 变量进行渲染，而我们从视图传递给模板的 `Page` 对象被称为 `posts`。我们使用 `with page=posts` 来传递分页模板期望的变量。您可以使用这种方法为任何类型的对象使用分页模板。'
- en: 'Start the development server by typing the following command in the shell prompt:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在shell提示符中输入以下命令来启动开发服务器：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open `http://127.0.0.1:8000/admin/blog/post/` in your browser and use the administration
    site to create a total of four different posts. Make sure to set the status to
    **Published**for all of them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:8000/admin/blog/post/` 并使用管理站点创建总共四篇不同的帖子。确保将所有帖子的状态设置为**已发布**。
- en: 'Now, open `http://127.0.0.1:8000/blog/` in your browser. You should see the
    first three posts in reverse chronological order, and then the navigation links
    at the bottom of the post list like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开 `http://127.0.0.1:8000/blog/`。您应该看到按倒序排列的前三篇帖子，然后在帖子列表底部的导航链接如下所示：
- en: '![](img/B21088_02_04.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_04.png)'
- en: 'Figure 2.4: The post list page including pagination'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：包含分页的帖子列表页面
- en: If you click on **Next**, you will see the last post. The URL for the second
    page contains the `?page=2` `GET` parameter. This parameter is used by the view
    to load the requested page of results using the paginator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**下一页**，您将看到最后一篇帖子。第二页的URL包含 `?page=2` 的 `GET` 参数。此参数由视图用于通过分页器加载请求的页面。
- en: '![](img/B21088_02_05.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_05.png)'
- en: 'Figure 2.5: The second page of results'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：结果页的第二页
- en: Great! The pagination links are working as expected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，分页链接按预期工作。
- en: Handling pagination errors
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理分页错误
- en: Now that the pagination is working, we can add exception handling for pagination
    errors in the view. The `page` parameter used by the view to retrieve the given
    page could potentially be used with wrong values, such as non-existing page numbers
    or a string value that cannot be used as a page number. We will implement appropriate
    error handling for those cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在分页功能已经正常工作，我们可以在视图中添加对分页错误的异常处理。视图使用的 `page` 参数可能被用于错误值，例如不存在的页码或无法用作页码的字符串值。我们将为这些情况实现适当的错误处理。
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser. You should see the
    following error page:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://127.0.0.1:8000/blog/?page=3`。您应该看到以下错误页面：
- en: '![](img/B21088_02_06.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_06.png)'
- en: 'Figure 2.6: The EmptyPage error page'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：空页错误页面
- en: The `Paginator` object throws an `EmptyPage` exception when retrieving page
    `3` because it’s out of range. There are no results to display. Let’s handle this
    error in our view.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当检索第`3`页时，`Paginator`对象抛出`EmptyPage`异常，因为它超出了范围。没有结果可以显示。让我们在我们的视图中处理这个错误。
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，添加必要的导入并修改`post_list`视图如下：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have added a try and except block to manage the `EmptyPage` exception when
    retrieving a page. If the page requested is out of range, we return the last page
    of results. We get the total number of pages with `paginator.num_pages`. The total
    number of pages is the same as the last page number.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个try和except块来管理检索页面时出现的`EmptyPage`异常。如果请求的页面超出范围，我们返回最后一页的结果。我们通过`paginator.num_pages`获取总页数。总页数与最后一页的页码相同。
- en: 'Open `http://127.0.0.1:8000/blog/?page=3` in your browser again. Now, the exception
    is managed by the view, and the last page of results is returned as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开`http://127.0.0.1:8000/blog/?page=3`。现在，异常由视图管理，并返回如下最后页的结果：
- en: '![](img/B21088_02_07.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_07.png)'
- en: 'Figure 2.7: The last page of results'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：结果的最后一页
- en: Our view should also handle the case when something different than an integer
    is passed in the `page` parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图也应该处理当`page`参数传递的不是整数时的情况。
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser. You should see
    the following error page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://127.0.0.1:8000/blog/?page=asdf`。你应该看到以下错误页面：
- en: '![](img/B21088_02_08.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_08.png)'
- en: 'Figure 2.8: The PageNotAnInteger error page'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：`PageNotAnInteger`错误页面
- en: In this case, the `Paginator` object throws a `PageNotAnInteger` exception when
    retrieving the page `asdf` because page numbers can only be integers. Let’s handle
    this error in our view.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当检索页面`asdf`时，`Paginator`对象抛出`PageNotAnInteger`异常，因为页码只能是整数。让我们在我们的视图中处理这个错误。
- en: 'Edit the `views.py` file of the `blog` application to add the necessary imports
    and modify the `post_list` view as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，添加必要的导入并修改`post_list`视图如下：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have added a new `except` block to manage the `PageNotAnInteger` exception
    when retrieving a page. If the page requested is not an integer, we return the
    first page of results.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的`except`块来管理检索页面时出现的`PageNotAnInteger`异常。如果请求的页面不是整数，我们返回结果的第一页。
- en: 'Open `http://127.0.0.1:8000/blog/?page=asdf` in your browser again. Now, the
    exception is managed by the view and the first page of results is returned as
    follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开`http://127.0.0.1:8000/blog/?page=asdf`。现在，异常由视图管理，并返回如下第一页的结果：
- en: '![](img/B21088_02_09.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_09.png)'
- en: 'Figure 2.9: The first page of results'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：结果的第一页
- en: The pagination for blog posts is now fully implemented.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章的分页现在已经完全实现。
- en: You can learn more about the `Paginator` class at [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)了解更多关于`Paginator`类的信息。
- en: Having learned how to paginate your blog, we will now turn to transforming the
    `post_list` view into an equivalent view that is built using Django generic views
    and built-in pagination.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了如何分页你的博客后，我们现在将转向将`post_list`视图转换为使用Django通用视图和内置分页构建的等效视图。
- en: Building class-based views
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于类的视图
- en: We have built the blog application using function-based views. Function-based
    views are simple and powerful, but Django also allows you to build views using
    classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基于函数的视图构建了博客应用。基于函数的视图简单而强大，但Django还允许你使用类来构建视图。
- en: Class-based views are an alternative way to implement views as Python objects
    instead of functions. Since a view is a function that takes a web request and
    returns a web response, you can also define your views as class methods. Django
    provides base view classes that you can use to implement your own views. All of
    them inherit from the `View` class, which handles HTTP method dispatching and
    other common functionalities.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图是实现视图作为Python对象而不是函数的另一种方式。由于视图是一个接收网络请求并返回网络响应的函数，你还可以将你的视图定义为类方法。Django提供了你可以用来实现你自己的视图的基础视图类。所有这些类都继承自`View`类，该类处理HTTP方法调度和其他常见功能。
- en: Why use class-based views
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用基于类的视图
- en: 'Class-based views offer some advantages over function-based views that are
    useful for specific use cases. Class-based views allow you to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图相对于基于函数的视图在特定用例中提供了一些优势。基于类的视图允许您：
- en: Organize code related to HTTP methods, such as `GET`, `POST`, or `PUT`, in separate
    methods, instead of using conditional branching
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将与HTTP方法相关的代码，如`GET`、`POST`或`PUT`，组织在单独的方法中，而不是使用条件分支
- en: Use multiple inheritance to create reusable view classes (also known as *mixins*)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多重继承来创建可重用的视图类（也称为*mixins*）
- en: Using a class-based view to list posts
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于类的视图来列出帖子
- en: To understand how to write class-based views, we will create a new class-based
    view that is equivalent to the `post_list` view. We will create a class that will
    inherit from the generic `ListView` view offered by Django. `ListView` allows
    you to list any type of object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何编写基于类的视图，我们将创建一个新的与`post_list`视图等效的基于类的视图。我们将创建一个继承自Django提供的通用`ListView`视图的类。`ListView`允许您列出任何类型的对象。
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，并向其中添加以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `PostListView` view is analogous to the `post_list` view we built previously.
    We have implemented a class-based view that inherits from the `ListView` class.
    We have defined a view with the following attributes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostListView`视图与之前构建的`post_list`视图类似。我们已经实现了一个继承自`ListView`类的基于类的视图。我们定义了一个具有以下属性的视图：'
- en: We use `queryset` to use a custom QuerySet instead of retrieving all objects.
    Instead of defining a `queryset` attribute, we could have specified `model = Post`
    and Django would have built the generic `Post.objects.all()` QuerySet for us.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`queryset`来使用自定义QuerySet，而不是检索所有对象。我们可以在不定义`queryset`属性的情况下指定`model = Post`，Django将为我们构建通用的`Post.objects.all()`
    QuerySet。
- en: We use the context variable `posts` for the query results. The default variable
    is `object_list` if you don’t specify any `context_object_name`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用上下文变量`posts`来表示查询结果。如果没有指定任何`context_object_name`，默认变量是`object_list`。
- en: We define the pagination of results with `paginate_by`, returning three objects
    per page.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`paginate_by`定义结果分页，每页返回三个对象。
- en: We use a custom template to render the page with `template_name`. If you don’t
    set a default template, `ListView` will use `blog/post_list.html` by default.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用自定义模板来渲染带有`template_name`的页面。如果您没有设置默认模板，`ListView`将默认使用`blog/post_list.html`。
- en: 'Now, edit the `urls.py` file of the `blog` application, comment the preceding
    `post_list` URL pattern, and add a new URL pattern using the `PostListView` class,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`blog`应用的`urls.py`文件，注释掉之前的`post_list` URL模式，并使用`PostListView`类添加一个新的URL模式，如下所示：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to keep pagination working, we have to use the right page object that
    is passed to the template. Django’s `ListView` generic view passes the page requested
    in a variable called `page_obj`. We have to edit the `post/list.html` template
    accordingly to include the paginator using the right variable, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分页功能正常工作，我们必须使用传递给模板的正确页面对象。Django的`ListView`通用视图通过一个名为`page_obj`的变量传递请求的页面。我们必须相应地编辑`post/list.html`模板，以包含使用正确变量的分页器，如下所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser and verify that the pagination
    links work as expected. The behavior of the pagination links should be the same
    as with the previous `post_list` view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/blog/`并验证分页链接是否按预期工作。分页链接的行为应该与之前的`post_list`视图相同。
- en: 'The exception handling in this case is a bit different. If you try to load
    a page out of range or pass a non-integer value in the `page` parameter, the view
    will return an HTTP response with the status code `404` (page not found) like
    this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，异常处理略有不同。如果您尝试加载超出范围的页面或传递`page`参数中的非整数值，视图将返回一个带有状态码`404`（页面未找到）的HTTP响应，如下所示：
- en: '![](img/B21088_02_10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_10.png)'
- en: 'Figure 2.10: HTTP 404 Page not found response'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：HTTP 404 页面未找到响应
- en: The exception handling that returns the HTTP `404` status code is provided by
    the `ListView` view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回HTTP `404`状态码的异常处理由`ListView`视图提供。
- en: This is a simple example of how to write class-based views. You will learn more
    about class-based views in *Chapter 13*, *Creating a Content Management System*,
    and successive chapters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何编写基于类的视图的简单示例。您将在第13章“创建内容管理系统”和随后的章节中了解更多关于基于类的视图的内容。
- en: You can read an introduction to class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)阅读关于基于类的视图的介绍。
- en: After learning how to use class-based views and using built-in object pagination,
    we will implement the functionality for sharing posts by email to engage your
    blog readers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用基于类的视图和使用内置的对象分页后，我们将实现通过电子邮件分享帖子以吸引博客读者的功能。
- en: Recommending posts by email
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过电子邮件推荐帖子
- en: We will allow users to share blog posts with others by sending post recommendations
    via email. You will learn how to create forms in Django, handle data submission,
    and send emails with Django, enhancing your blog with a personal touch.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许用户通过发送帖子推荐通过电子邮件与他人分享博客帖子。您将学习如何在Django中创建表单、处理数据提交以及发送电子邮件，为您的博客增添个性化特色。
- en: Take a minute to think about how you could use *views*, *URLs*, and *templates*
    to create this functionality using what you learned in the preceding chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间思考一下，您如何可以使用*视图*、*URL*和*模板*来创建此功能，使用您在前一章中学到的知识。
- en: 'To allow users to share posts via email, we will need to:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户通过电子邮件分享帖子，我们需要做以下事情：
- en: Create a form for users to fill in their name, their email address, the recipient’s
    email address, and optional comments
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表单，让用户填写他们的姓名、他们的电子邮件地址、收件人的电子邮件地址以及可选的评论
- en: Create a view in the `views.py` file that handles the posted data and sends
    the email
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`views.py`文件中创建一个视图来处理提交的数据并发送电子邮件
- en: Add a URL pattern for the new view in the `urls.py` file of the blog application
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在博客应用的`urls.py`文件中为新的视图添加一个URL模式
- en: Create a template to display the form
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模板来显示表单
- en: Creating forms with Django
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django创建表单
- en: Let’s start by building the form to share posts. Django has a built-in forms
    framework that allows you to create forms easily. The forms framework makes it
    simple to define the fields of the form, specify how they have to be displayed,
    and indicate how they have to validate input data. The Django forms framework
    offers a flexible way to render forms in HTML and handle data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建分享帖子的表单开始。Django内置了一个表单框架，允许您轻松创建表单。表单框架使得定义表单字段、指定它们的显示方式以及指示如何验证输入数据变得简单。Django表单框架提供了一个灵活的方式来在HTML中渲染表单并处理数据。
- en: 'Django comes with two base classes to build forms:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了两个基础类来构建表单：
- en: '`Form`: This allows you to build standard forms by defining fields and validations.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Form`: 这允许您通过定义字段和验证来构建标准表单。'
- en: '`ModelForm`: This allows you to build forms tied to model instances. It provides
    all the functionalities of the base `Form` class, but form fields can be explicitly
    declared, or automatically generated, from model fields. The form can be used
    to create or edit model instances.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelForm`: 这允许您构建与模型实例相关的表单。它提供了基础`Form`类的所有功能，但表单字段可以显式声明，或从模型字段自动生成。该表单可用于创建或编辑模型实例。'
- en: 'First, create a `forms.py` file inside the directory of your `blog` application
    and add the following code to it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的`blog`应用目录中创建一个`forms.py`文件，并将其中的以下代码添加到该文件中：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have defined our first Django form. The `EmailPostForm` form inherits from
    the base `Form` class. We use different field types to validate data accordingly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的第一个Django表单。`EmailPostForm`表单从基础`Form`类继承。我们使用不同的字段类型来相应地验证数据。
- en: Forms can reside anywhere in your Django project. The convention is to place
    them inside a `forms.py` file for each application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表单可以位于您的Django项目的任何位置。惯例是将它们放置在每个应用的`forms.py`文件中。
- en: 'The form contains the following fields:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表单包含以下字段：
- en: '`name`: An instance of `CharField` with a maximum length of `25` characters.
    We will use it for the name of the person sending the post.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 一个最大长度为`25`字符的`CharField`实例。我们将用它来表示发送帖子的个人姓名。'
- en: '`email`: An instance of `EmailField`. We will use the email of the person sending
    the post recommendation.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: `EmailField`的一个实例。我们将使用发送帖子推荐的个人电子邮件。'
- en: '`to`: An instance of `EmailField`. We will use the email address of the recipient,
    who will receive an email recommending the post.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: `EmailField`的一个实例。我们将使用收件人的电子邮件地址，该收件人将收到一封推荐帖子的电子邮件。'
- en: '`comments`: An instance of `CharField`. We will use it for comments to include
    in the post recommendation email. We have made this field optional by setting
    `required` to `False`, and we have specified a custom widget to render the field.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comments`：`CharField` 的一个实例。我们将使用它来包含在帖子推荐电子邮件中的评论。我们通过将 `required` 设置为 `False`
    使此字段可选，并指定了一个自定义小部件来渲染该字段。'
- en: Each field type has a default widget that determines how the field is rendered
    in HTML. The `name` field is an instance of `CharField`. This type of field is
    rendered as an `<input type="text">` HTML element. The default widget can be overridden
    with the `widget` attribute. In the `comments` field, we use the `Textarea` widget
    to display it as a `<textarea>` HTML element instead of the default `<input>`
    element.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每种字段类型都有一个默认的小部件，它决定了字段在 HTML 中的渲染方式。`name` 字段是 `CharField` 的一个实例。此类字段以 `<input
    type="text">` HTML 元素的形式渲染。默认小部件可以通过 `widget` 属性来覆盖。在 `comments` 字段中，我们使用 `Textarea`
    小部件将其显示为 `<textarea>` HTML 元素，而不是默认的 `<input>` 元素。
- en: Field validation also depends on the field type. For example, the `email` and
    `to` fields are `EmailField` fields. Both fields require a valid email address;
    the field validation will otherwise raise a `forms.ValidationError` exception
    and the form will not validate. Other parameters are also taken into account for
    the form field validation, such as the `name` field having a maximum length of
    `25` or the `comments` field being optional.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 字段验证也取决于字段类型。例如，`email` 和 `to` 字段是 `EmailField` 字段。这两个字段都需要一个有效的电子邮件地址；否则，字段验证将引发
    `forms.ValidationError` 异常，表单将无法验证。表单字段验证还会考虑其他参数，例如 `name` 字段的最大长度为 `25` 或 `comments`
    字段为可选。
- en: These are only some of the field types that Django provides for forms. You can
    find a list of all field types available at [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Django 为表单提供的字段类型中的一部分。您可以在 [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/)
    找到所有可用字段类型的列表。
- en: Handling forms in views
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中处理表单
- en: We have defined the form to recommend posts via email. Now, we need a view to
    create an instance of the form and handle the form submission.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个通过电子邮件推荐帖子的表单。现在，我们需要一个视图来创建表单的实例并处理表单提交。
- en: 'Edit the `views.py` file of the `blog` application and add the following code
    to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用程序的 `views.py` 文件，并向其中添加以下代码：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have defined the `post_share` view that takes the `request` object and the
    `post_id` variable as parameters. We use the `get_object_or_404()` shortcut to
    retrieve a published post by its `id`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `post_share` 视图，它接受 `request` 对象和 `post_id` 变量作为参数。我们使用 `get_object_or_404()`
    快捷方式通过其 `id` 检索一个已发布的帖子。
- en: We use the same view both for displaying the initial form and processing the
    submitted data. The HTTP `request` method allows us to differentiate whether the
    form is being submitted. A `GET` request will indicate that an empty form has
    to be displayed to the user and a `POST` request will indicate the form is being
    submitted. We use `request.method == 'POST'` to differentiate between the two
    scenarios.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的视图来显示初始表单和处理提交的数据。HTTP `request` 方法允许我们区分表单是否正在提交。一个 `GET` 请求表示需要向用户显示一个空表单，而一个
    `POST` 请求表示表单正在提交。我们使用 `request.method == 'POST'` 来区分这两种情况。
- en: 'This is the process to display the form and handle the form submission:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示表单和处理表单提交的过程：
- en: 'When the page is loaded for the first time, the view receives a `GET` request.
    In this case, a new `EmailPostForm` instance is created and stored in the `form`
    variable. This form instance will be used to display the empty form in the template:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面首次加载时，视图接收一个 `GET` 请求。在这种情况下，创建一个新的 `EmailPostForm` 实例并将其存储在 `form` 变量中。此表单实例将用于在模板中显示空表单：
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When the user fills in the form and submits it via `POST`, a form instance
    is created using the submitted data contained in `request.POST`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户填写表单并通过 `POST` 提交时，会使用 `request.POST` 中包含的提交数据创建一个表单实例：
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After this, the data submitted is validated using the form’s `is_valid()` method.
    This method validates the data introduced in the form and returns `True` if all
    fields contain valid data. If any field contains invalid data, then `is_valid()`
    returns `False`. The list of validation errors can be obtained with `form.errors`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用表单的 `is_valid()` 方法验证提交的数据。此方法验证表单中引入的数据，如果所有字段都包含有效数据，则返回 `True`。如果有任何字段包含无效数据，则
    `is_valid()` 返回 `False`。可以通过 `form.errors` 获取验证错误列表。
- en: If the form is not valid, the form is rendered in the template again, including
    the data submitted. Validation errors will be displayed in the template.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单无效，表单将在模板中再次渲染，包括提交的数据。验证错误将在模板中显示。
- en: If the form is valid, the validated data is retrieved with `form.cleaned_data`.
    This attribute is a dictionary of form fields and their values. Forms not only
    validate the data but also *clean* the data by normalizing it to a consistent
    format.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单有效，将通过`form.cleaned_data`检索验证后的数据。这个属性是表单字段及其值的字典。表单不仅验证数据，而且通过将其规范化为一致格式来*清理*数据。
- en: If your form data does not validate, `cleaned_data` will contain only the valid
    fields.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的表单数据无效，`cleaned_data`将只包含有效的字段。
- en: We have implemented the view to display the form and handle the form submission.
    We will now learn how to send emails using Django and then we will add that functionality
    to the `post_share` view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了显示表单和处理表单提交的视图。现在我们将学习如何使用Django发送邮件，然后我们将将该功能添加到`post_share`视图中。
- en: Sending emails with Django
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django发送邮件
- en: Sending emails with Django is very straightforward. You need to have a local
    SMTP server, or you need to access an external SMTP server, like your email service
    provider.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django发送邮件非常直接。你需要有一个本地的SMTP服务器，或者你需要访问一个外部SMTP服务器，比如你的电子邮件服务提供商。
- en: 'The following settings allow you to define the SMTP configuration to send emails
    with Django:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置允许你定义SMTP配置以使用Django发送邮件：
- en: '`EMAIL_HOST`: The SMTP server host; the default is `localhost`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST`：SMTP服务器主机；默认为`localhost`'
- en: '`EMAIL_PORT`: The SMTP port; the default is `25`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_PORT`：SMTP端口；默认为`25`'
- en: '`EMAIL_HOST_USER`: The username for the SMTP server'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_USER`：SMTP服务器的用户名'
- en: '`EMAIL_HOST_PASSWORD`: The password for the SMTP server'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_PASSWORD`：SMTP服务器的密码'
- en: '`EMAIL_USE_TLS`: Whether to use a **Transport Layer Security** (**TLS**) secure
    connection'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_USE_TLS`：是否使用**传输层安全**（**TLS**）安全连接'
- en: '`EMAIL_USE_SSL`: Whether to use an implicit TLS secure connection'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMAIL_USE_SSL`：是否使用隐式TLS安全连接'
- en: Additionally, you can use the `DEFAULT_FROM_EMAIL` setting to specify the default
    sender when sending emails with Django. For this example, we will use Google’s
    SMTP server with a standard Gmail account.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用`DEFAULT_FROM_EMAIL`设置来指定发送Django邮件时的默认发送者。在这个例子中，我们将使用Google的SMTP服务器和一个标准的Gmail账户。
- en: Working with environment variables
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与环境变量一起工作
- en: 'We will add SMTP configuration settings to the project, and we will load the
    SMTP credentials from environment variables. By using environment variables, we
    will avoid embedding credentials in the source code. There are multiple reasons
    to keep configuration separate from the code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向项目中添加SMTP配置设置，并从环境变量中加载SMTP凭据。通过使用环境变量，我们将避免在源代码中嵌入凭据。将配置与代码分离有多个原因：
- en: '**Security**: Credentials or secret keys in the code can lead to unintentional
    exposure, especially if you push the code to public repositories.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：代码中的凭据或密钥可能导致意外泄露，尤其是如果你将代码推送到公共仓库时。'
- en: '**Flexibility**: Keeping the configuration separate will allow you to use the
    same code base across different environments without any changes. You will learn
    how to build multiple environments in *Chapter 17*, *Going Live*.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：保持配置与代码分离将允许你在不同的环境中使用相同的代码库而无需任何更改。你将在第17章“上线”中学习如何构建多个环境。'
- en: '**Maintainability**: Changing a configuration won’t require a code change,
    ensuring that your project remains consistent across versions.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：更改配置不需要修改代码，确保你的项目在各个版本之间保持一致性。'
- en: To facilitate the separation of configuration from code, we are going to use
    `python-decouple`. This library simplifies the use of environment variables in
    your projects. You can find information about `python-decouple` at [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于将配置与代码分离，我们将使用`python-decouple`。这个库简化了在项目中使用环境变量的操作。你可以在[https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)找到关于`python-decouple`的信息。
- en: 'First, install `python-decouple` via `pip` by running the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令使用`pip`安装`python-decouple`：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, create a new file inside your project’s root directory and name it `.env`.
    The `.env` file will contain key-value pairs of environment variables. Add the
    following lines to the new file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的项目根目录内创建一个新文件，并将其命名为`.env`。`.env`文件将包含环境变量的键值对。将以下行添加到新文件中：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you have a Gmail account, replace `your_account@gmail.com` with your Gmail
    account. The `EMAIL_HOST_PASSWORD` variable has no value yet, we will add it later.
    The `DEFAULT_FROM_EMAIL` variable will be used to specify the default sender for
    our emails. If you don’t have a Gmail account, you can use the SMTP credentials
    for your email service provider.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有Gmail账户，请将`your_account@gmail.com`替换为您的Gmail账户。`EMAIL_HOST_PASSWORD`变量目前还没有值，我们稍后会添加它。`DEFAULT_FROM_EMAIL`变量将用于指定我们电子邮件的默认发送者。如果您没有Gmail账户，您可以使用电子邮件服务提供商的SMTP凭证。
- en: If you are using a `git` repository for your code, make sure to include `.env`
    in the `.gitignore` file of your repository. By doing so, you ensure that credentials
    are excluded from the repository.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`git`仓库存储代码，请确保将`.env`文件包含在您的仓库的`.gitignore`文件中。这样做可以确保凭证不被包含在仓库中。
- en: 'Edit the `settings.py` file of your project and add the following code to it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您项目的`settings.py`文件，并向其中添加以下代码：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `EMAIL_HOST_USER`, `EMAIL_HOST_PASSWORD` and `DEFAULT_FROM_EMAIL` settings
    are now loaded from environment variables defined in the `.env` file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`EMAIL_HOST_USER`、`EMAIL_HOST_PASSWORD`和`DEFAULT_FROM_EMAIL`设置现在是从`.env`文件中定义的环境变量加载的。'
- en: The provided `EMAIL_HOST`, `EMAIL_PORT` and `EMAIL_USE_TLS` settings are for
    Gmail’s SMTP server. If you don’t have a Gmail account, you can use the SMTP server
    configuration of your email service provider.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`EMAIL_HOST`、`EMAIL_PORT`和`EMAIL_USE_TLS`设置是针对Gmail的SMTP服务器的。如果您没有Gmail账户，您可以使用电子邮件服务提供商的SMTP服务器配置。
- en: Instead of Gmail, you can also use a professional, scalable email service that
    allows you to send emails via SMTP using your own domain, such as SendGrid ([https://sendgrid.com/](https://sendgrid.com/))
    or Amazon **Simple Email Service** (**SES**) ([https://aws.amazon.com/ses/](https://aws.amazon.com/ses/)).
    Both services will require you to verify your domain and sender email accounts
    and will provide you with SMTP credentials to send emails. The `django-anymail`
    application simplifies the task of adding email service providers to your project
    like SendGrid or Amazon SES. You can find installation instructions for `django-anymail`
    at [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/),
    and the list of supported email service providers at [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Gmail，您还可以使用一个专业、可扩展的电子邮件服务，允许您通过SMTP使用自己的域名发送电子邮件，例如SendGrid ([https://sendgrid.com/](https://sendgrid.com/))
    或Amazon **简单电子邮件服务** (**SES**) ([https://aws.amazon.com/ses/](https://aws.amazon.com/ses/))。这两个服务都将要求您验证您的域名和发送者电子邮件账户，并提供SMTP凭证以发送电子邮件。`django-anymail`应用程序简化了将电子邮件服务提供商（如SendGrid或Amazon
    SES）添加到您项目的任务。您可以在[https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/)找到`django-anymail`的安装说明，以及在[https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/)找到支持的电子邮件服务提供商列表。
- en: 'If you can’t use an SMTP server, you can tell Django to write emails to the
    console by adding the following setting to the `settings.py` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不能使用SMTP服务器，您可以在`settings.py`文件中添加以下设置，让Django将电子邮件写入控制台：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By using this setting, Django will output all emails to the shell instead of
    sending them. This is very useful for testing your application without an SMTP
    server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，Django将输出所有电子邮件到shell而不是发送它们。这对于在没有SMTP服务器的情况下测试您的应用程序非常有用。
- en: In order to send emails with Gmail’s SMTP server, make sure that two-step verification
    is active in your Gmail account.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Gmail的SMTP服务器发送电子邮件，请确保您的Gmail账户中启用了两步验证。
- en: 'Open [https://myaccount.google.com/security](https://myaccount.google.com/security)
    in your browser and enable **2-Step Verification** for your account, as shown
    in *Figure 2.11*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开[https://myaccount.google.com/security](https://myaccount.google.com/security)，并为您账户启用**两步验证**，如图*图2.11*所示：
- en: '![](img/B21088_02_11.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_11.png)'
- en: 'Figure 2.11: The sign in to Google page for Google accounts'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：Google账户的登录页面
- en: Then, you need to create an app password and use it for your SMTP credentials.
    An app password is a 16-digit passcode that gives a *less secure* app or device
    permission to access your Google account.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要创建一个应用密码，并使用它作为您的SMTP凭证。应用密码是一个16位数的密码，它允许一个不太安全的程序或设备访问您的Google账户。
- en: 'To create an app password, open [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords)
    in your browser. You will see the following screen:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建应用密码，请在浏览器中打开[https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords)。您将看到以下屏幕：
- en: '![](img/B21088_02_12.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_12.png)'
- en: 'Figure 2.12: Form to generate a new Google app password'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：生成新的Google应用密码的表单
- en: If you cannot access **App passwords**, it might be that 2-Step Verification
    is not set for your account, your account is an organization account instead of
    a standard Gmail account, or you turned on Google’s advanced protection. Make
    sure to use a standard Gmail account and activate 2-Step Verification for your
    Google account. You can find more information at [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法访问 **应用密码**，可能是因为你的账户没有设置两步验证，你的账户是一个组织账户而不是标准 Gmail 账户，或者你开启了 Google 的高级保护。请确保使用标准
    Gmail 账户，并为你的 Google 账户激活两步验证。你可以在[https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833)找到更多信息。
- en: 'Enter the name `Blog` and click the **Create** button, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输入名称 `Blog` 并点击 **创建** 按钮，如下所示：
- en: '![](img/B21088_02_13.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_13.png)'
- en: 'Figure 2.13: Form to generate a new Google app password'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：生成新的 Google 应用密码的表单
- en: 'A new password will be generated and displayed like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个新的密码并显示如下：
- en: '![](img/B21088_02_14.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_14.png)'
- en: 'Figure 2.14: Generated Google app password'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14：生成的 Google 应用密码
- en: Copy the generated app password.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 复制生成的应用密码。
- en: 'Next, edit the `.env` file of your project and add the app password to the
    `EMAIL_HOST_PASSWORD` variable, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑你的项目中的 `.env` 文件，并将应用密码添加到 `EMAIL_HOST_PASSWORD` 变量中，如下所示：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Open the Python shell by running the following command in the system shell
    prompt:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在系统 shell 提示符中运行以下命令来打开 Python shell：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Execute the following code in the Python shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python shell 中执行以下代码：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `send_mail()` function takes the subject, message, sender, and list of recipients
    as required arguments. By setting the optional argument `fail_silently=False`,
    we are telling it to raise an exception if the email cannot be sent. If the output
    you see is `1`, then your email was successfully sent.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_mail()` 函数需要主题、消息、发件人和收件人列表作为必需参数。通过设置可选参数 `fail_silently=False`，我们告诉它如果无法发送电子邮件则抛出异常。如果你看到的输出是
    `1`，则表示你的电子邮件已成功发送。'
- en: 'If you get a `CERTIFICATE_VERIFY_FAILED` error, install the `certify` module
    with the command `pip install --upgrade certifi`. If you are using macOS, run
    the following command on the shell to install `certify` and let Python access
    macOS root certificates:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到 `CERTIFICATE_VERIFY_FAILED` 错误，请使用以下命令安装 `certify` 模块：`pip install --upgrade
    certifi`。如果你使用的是 macOS，请在 shell 中运行以下命令来安装 `certify` 并允许 Python 访问 macOS 根证书：
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check your inbox. You should have received the email as displayed in *Figure
    2.15*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的收件箱。你应该已经收到了如图 *图 2.15* 所示的电子邮件：
- en: '![](img/B21088_02_15.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_15.png)'
- en: 'Figure 2.15: Test email sent displayed in Gmail'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15：在 Gmail 中显示发送的测试电子邮件
- en: You just sent your first email with Django! You can find more information about
    sending emails with Django at [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚用 Django 发出了第一封电子邮件！你可以在[https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/)找到更多关于使用
    Django 发送电子邮件的信息。
- en: Let’s add this functionality to the `post_share` view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此功能添加到 `post_share` 视图中。
- en: Sending emails in views
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中发送电子邮件
- en: 'Edit the `post_share` view in the `views.py` file of the `blog` application,
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用程序中的 `views.py` 文件中的 `post_share` 视图，如下所示：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we have declared a `sent` variable with the initial `False`
    value. We set this variable to `True` after the email is sent. We will use the
    `sent` variable later in the template to display a success message when the form
    is successfully submitted.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个初始值为 `False` 的 `sent` 变量。在邮件发送后，我们将此变量设置为 `True`。我们将在模板中稍后使用
    `sent` 变量来显示当表单成功提交时的成功消息。
- en: Since we have to include a link to the post in the email, we retrieve the absolute
    path of the post using its `get_absolute_url()` method. We use this path as an
    input for `request.build_absolute_uri()` to build a complete URL, including the
    HTTP schema and hostname.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须在电子邮件中包含一个指向帖子的链接，我们使用帖子的 `get_absolute_url()` 方法检索帖子的绝对路径。我们使用此路径作为 `request.build_absolute_uri()`
    的输入来构建一个完整的 URL，包括 HTTP 协议和主机名。
- en: We create the subject and the message body of the email using the cleaned data
    of the validated form. Finally, we send the email to the email address contained
    in the `to` field of the form. In the `from_email` parameter, we pass the `None`
    value, so the value of the `DEFAULT_FROM_EMAIL` setting will be used for the sender.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用经过验证的表单的清理数据创建电子邮件的主题和消息正文。最后，我们将电子邮件发送到表单中 `to` 字段包含的电子邮件地址。在 `from_email`
    参数中，我们传递 `None` 值，因此将使用 `DEFAULT_FROM_EMAIL` 设置的值作为发件人。
- en: Now that the view is complete, we have to add a new URL pattern for it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在视图已经完成，我们必须为它添加一个新的URL模式。
- en: 'Open the `urls.py` file of your `blog` application and add the `post_share`
    URL pattern, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`blog`应用的`urls.py`文件，并添加`post_share` URL模式，如下所示：
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Rendering forms in templates
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中渲染表单
- en: After creating the form, programming the view, and adding the URL pattern, the
    only thing missing is the template for the view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建表单、编写视图和添加URL模式后，唯一缺少的是视图的模板。
- en: Create a new file in the `blog/templates/blog/post/` directory and name it `share.html`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog/templates/blog/post/`目录下创建一个新文件，并将其命名为`share.html`。
- en: 'Add the following code to the new `share.html` template:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到新的`share.html`模板中：
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the template that is used to both display the form to share a post via
    email and to display a success message when the email has been sent. We differentiate
    between both cases with `{% if sent %}`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于显示通过电子邮件分享帖子的表单以及显示发送电子邮件后的成功消息的模板。我们通过`{% if sent %}`区分这两种情况。
- en: 'To display the form, we have defined an HTML form element, indicating that
    it has to be submitted by the `POST` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示表单，我们定义了一个HTML表单元素，表明它必须通过`POST`方法提交：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have included the form instance with `{{ form.as_p }}`. We tell Django to
    render the form fields using HTML paragraph `<p>` elements by using the `as_p`
    method. We could also render the form as an unordered list with `as_ul` or as
    an HTML table with `as_table`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了表单实例`{{ form.as_p }}`。我们告诉Django使用`as_p`方法通过HTML段落`<p>`元素渲染表单字段。我们也可以使用`as_ul`将其渲染为无序列表，或者使用`as_table`将其渲染为HTML表格。
- en: We have added a `{% csrf_token %}` template tag. This tag introduces a hidden
    field with an autogenerated token to avoid **cross-site request forgery** (**CSRF**)
    attacks. These attacks consist of a malicious website or program performing an
    unwanted action for a user on the site. You can find more information about CSRF
    at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`{% csrf_token %}`模板标签。此标签引入了一个带有自动生成的令牌的隐藏字段，以避免**跨站请求伪造**（**CSRF**）攻击。这些攻击包括恶意网站或程序在网站上对用户执行不受欢迎的操作。你可以在[https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)找到有关CSRF的更多信息。
- en: 'The `{% csrf_token %}` template tag generates a hidden field that is rendered
    like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% csrf_token %}`模板标签生成一个隐藏字段，其渲染方式如下：'
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By default, Django checks for the CSRF token in all `POST` requests. Remember
    to include the `csrf_token` tag in all forms that are submitted via `POST`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django会在所有`POST`请求中检查CSRF令牌。请记住，在所有通过`POST`提交的表单中包含`csrf_token`标签。
- en: 'Edit the `blog/post/detail.html` template and make it look like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/post/detail.html`模板，使其看起来像这样：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have added a link to the `post_share` URL. The URL is built dynamically with
    the `{% url %}` template tag provided by Django. We use the namespace called `blog`
    and the URL named `post_share`. We pass the `id` post as a parameter to build
    the URL.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个指向`post_share` URL的链接。该URL通过Django提供的`{% url %}`模板标签动态构建。我们使用名为`blog`的命名空间和名为`post_share`的URL。我们将帖子`id`作为参数传递以构建URL。
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 打开shell提示符并执行以下命令以启动开发服务器：
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Open `http://127.0.0.1:8000/blog/` in your browser and click on any post title
    to view the post detail page.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/blog/`，然后点击任何帖子标题以查看帖子详情页面。
- en: 'Under the post body, you should see the link that you just added, as shown
    in *Figure 2.16*:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在帖子正文中，你应该看到你刚刚添加的链接，如图*图2.16*所示：
- en: '![](img/B21088_02_16.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21088_02_16.png]'
- en: 'Figure 2.16: The post detail page, including a link to share the post'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：帖子详情页面，包括分享帖子的链接
- en: 'Click on **Share this post**, and you should see the page, including the form
    to share this post by email, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**分享此帖子**，你应该看到包括通过电子邮件分享此帖子的表单的页面，如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_02_17.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B21088_02_17.png)'
- en: 'Figure 2.17: The page to share a post via email'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：通过电子邮件分享帖子的页面
- en: 'CSS styles for the form are included in the example code in the `static/css/blog.css`
    file. When you click on the **SEND E-MAIL** button, the form is submitted and
    validated. If all fields contain valid data, you get a success message, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的CSS样式包含在`static/css/blog.css`文件中的示例代码中。当你点击**发送电子邮件**按钮时，表单将被提交并验证。如果所有字段都包含有效数据，你将得到以下成功消息：
- en: '![Text  Description automatically generated with medium confidence](img/B21088_02_18.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成，置信度中等](img/B21088_02_18.png)'
- en: 'Figure 2.18: A success message for a post shared via email'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：通过电子邮件分享帖子的成功消息
- en: 'Send a post to your own email address and check your inbox. The email you receive
    should look like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将帖子发送到您的电子邮件地址并检查您的收件箱。您收到的电子邮件应该看起来像这样：
- en: '![](img/B21088_02_19.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_19.png)'
- en: 'Figure 2.19: Test email sent displayed in Gmail'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：在Gmail中显示的测试电子邮件发送
- en: 'If you submit the form with invalid data, the form will be rendered again,
    including all validation errors:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提交包含无效数据的表单，表单将被重新渲染，包括所有验证错误：
- en: '![Graphical user interface, text, application, Teams  Description automatically
    generated](img/B21088_02_20.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，团队描述自动生成](img/B21088_02_20.png)'
- en: 'Figure 2.20: The share post form displaying invalid data errors'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：显示无效数据错误的分享帖子表单
- en: Most modern browsers will prevent you from submitting a form with empty or erroneous
    fields. This is because the browser validates the fields based on their attributes
    before submitting the form. In this case, the form won’t be submitted, and the
    browser will display an error message for the fields that are wrong. To test the
    Django form validation using a modern browser, you can skip the browser form validation
    by adding the `novalidate` attribute to the HTML `<form>` element, like `<form
    method="post" novalidate>`. You can add this attribute to prevent the browser
    from validating fields and test your own form validation. After you are done testing,
    remove the `novalidate` attribute to keep the browser form validation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器都会阻止您提交包含空或错误字段的表单。这是因为浏览器在提交表单之前会根据它们的属性验证字段。在这种情况下，表单将不会提交，浏览器将为错误字段显示错误消息。要使用现代浏览器测试Django表单验证，您可以通过在HTML
    `<form>` 元素中添加`novalidate`属性来跳过浏览器表单验证，例如`<form method="post" novalidate>`。您可以将此属性添加到防止浏览器验证字段并测试您自己的表单验证。测试完成后，请删除`novalidate`属性以保持浏览器表单验证。
- en: The functionality for sharing posts by email is now complete. You can find more
    information about working with forms at [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过电子邮件分享帖子的功能现已完成。您可以在[https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/)找到更多关于处理表单的信息。
- en: Creating a comment system
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个评论系统
- en: 'We will continue extending our blog application with a comment system that
    will allow users to comment on posts. To build the comment system, we will need
    the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续扩展我们的博客应用，添加一个允许用户对帖子进行评论的评论系统。为了构建评论系统，我们需要以下内容：
- en: A comment model to store user comments on posts
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储用户对帖子评论的评论模型
- en: A Django form that allows users to submit comments and manages the data validation
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Django表单，允许用户提交评论并管理数据验证
- en: A view that processes the form and saves a new comment to the database
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视图来处理表单并将新评论保存到数据库中
- en: A list of comments and the HTML form to add a new comment that can be included
    in the post detail template
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份评论列表和用于添加新评论的HTML表单，该表单可以包含在帖子详情模板中
- en: Creating a model for comments
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建评论模型
- en: Let’s start by building a model to store user comments on posts.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先构建一个用于存储用户对帖子评论的模型。
- en: 'Open the `models.py` file of your `blog` application and add the following
    code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`models.py`文件并添加以下代码：
- en: '[PRE44]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is the `Comment` model. We have added a `ForeignKey` field to associate
    each comment with a single post. This many-to-one relationship is defined in the
    `Comment` model because each comment will be made on one post, and each post may
    have multiple comments.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Comment`模型。我们添加了一个`ForeignKey`字段来将每个评论与单个帖子关联。这种多对一关系在`Comment`模型中定义，因为每个评论都将针对一个帖子，每个帖子可能有多个评论。
- en: The `related_name` attribute allows you to name the attribute that you use for
    the relationship from the related object back to this one. We can retrieve the
    post of a comment object using `comment.post` and retrieve all comments associated
    with a post object using `post.comments.all()`. If you don’t define the `related_name`
    attribute, Django will use the name of the model in lowercase, followed by `_set`
    (that is, `comment_set`) to name the relationship of the related object to the
    object of the model, where this relationship has been defined.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`related_name` 属性允许您命名从相关对象返回此对象的关联属性。我们可以使用 `comment.post` 来检索评论对象的帖子，使用 `post.comments.all()`
    来检索与帖子对象关联的所有评论。如果您不定义 `related_name` 属性，Django 将使用模型名称的小写形式，后跟 `_set`（即 `comment_set`）来命名相关对象与模型对象的关联关系，其中此关系已被定义。'
- en: You can learn more about many-to-one relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/)
    了解更多关于多对一关系的信息。
- en: We have defined the `active` Boolean field to control the status of the comments.
    This field will allow us to manually deactivate inappropriate comments using the
    administration site. We use `default=True` to indicate that all comments are active
    by default.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已定义 `active` 布尔字段来控制评论的状态。此字段将允许我们通过管理站点手动停用不适当的评论。我们使用 `default=True` 来表示所有评论默认为活动状态。
- en: We have defined the `created` field to store the date and time when the comment
    was created. By using `auto_now_add`, the date will be saved automatically when
    creating an object. In the `Meta` class of the model, we have added `ordering
    = ['created']` to sort comments in chronological order by default, and we have
    added an index for the `created` field in ascending order. This will improve the
    performance of database lookups or ordering results using the `created` field.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已定义 `created` 字段来存储评论创建的日期和时间。通过使用 `auto_now_add`，创建对象时日期将自动保存。在模型的 `Meta`
    类中，我们添加了 `ordering = ['created']` 以默认按时间顺序排序评论，并添加了 `created` 字段的升序索引。这将提高使用 `created`
    字段进行数据库查找或排序结果的性能。
- en: The `Comment` model that we have built is not synchronized with the database.
    We need to generate a new database migration to create the corresponding database
    table.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的 `Comment` 模型与数据库未同步。我们需要生成一个新的数据库迁移来创建相应的数据库表。
- en: 'Run the following command from the shell prompt:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从shell提示符运行以下命令：
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should see the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Django has generated a `0003_comment.py` file inside the `migrations/` directory
    of the `blog` application. We need to create the related database schema and apply
    the changes to the database.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在 `blog` 应用程序的 `migrations/` 目录中生成了一个 `0003_comment.py` 文件。我们需要创建相关的数据库模式并将更改应用到数据库中。
- en: 'Run the following command to apply existing migrations:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用现有迁移：
- en: '[PRE47]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will get an output that includes the following line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到包含以下行的输出：
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The migration has been applied and the `blog_comment` table has been created
    in the database.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移已应用，并在数据库中创建了 `blog_comment` 表。
- en: Adding comments to the administration site
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在管理站点添加评论
- en: Next, we will add the new model to the administration site to manage comments
    through a simple interface.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加新的模型到管理站点，以便通过简单的界面管理评论。
- en: 'Open the `admin.py` file of the `blog` application, import the `Comment` model,
    and add the following `ModelAdmin` class:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `blog` 应用的 `admin.py` 文件，导入 `Comment` 模型，并添加以下 `ModelAdmin` 类：
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open the shell prompt and execute the following command to start the development
    server:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 打开shell提示符并执行以下命令以启动开发服务器：
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open `http://127.0.0.1:8000/admin/` in your browser. You should see the new
    model included in the **BLOG** section, as shown in *Figure 2.21*:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:8000/admin/`。您应该能看到包含在 **BLOG** 部分的新的模型，如图 *图2.21*
    所示：
- en: '![](img/B21088_02_21.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_21.png)'
- en: 'Figure 2.21: Blog application models on the Django administration index page'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：Django管理索引页上的博客应用程序模型
- en: The model is now registered on the administration site.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 模型现在已在管理站点上注册。
- en: 'In the **Comments** row, click on **Add**. You will see the form to add a new
    comment:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Comments** 行中，点击 **Add**。您将看到添加新评论的表单：
- en: '![](img/B21088_02_22.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_22.png)'
- en: 'Figure 2.22: Form to add a new comment in the Django administration site'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：在Django管理站点添加新评论的表单
- en: Now we can manage `Comment` instances using the administration site.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用管理站点来管理 `Comment` 实例。
- en: Creating forms from models
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模型创建表单
- en: 'We need to build a form to let users comment on blog posts. Remember that Django
    has two base classes that can be used to create forms: `Form` and `ModelForm`.
    We used the `Form` class to allow users to share posts by email. Now, we will
    use `ModelForm` to take advantage of the existing `Comment` model and build a
    form dynamically for it.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一个表单，让用户可以对博客帖子进行评论。记住，Django 有两个基类可以用来创建表单：`Form` 和 `ModelForm`。我们使用
    `Form` 类允许用户通过电子邮件分享帖子。现在，我们将使用 `ModelForm` 来利用现有的 `Comment` 模型并为其动态构建一个表单。
- en: 'Edit the `forms.py` file of your `blog` application and add the following lines:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用的 `forms.py` 文件并添加以下行：
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To create a form from a model, we just indicate which model to build the form
    for in the `Meta` class of the form. Django will introspect the model and build
    the corresponding form dynamically.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个模型创建表单，我们只需在表单的 `Meta` 类中指定要为哪个模型构建表单。Django 将会反射模型并动态地构建相应的表单。
- en: Each model field type has a corresponding default form field type. The attributes
    of model fields are taken into account for form validation. By default, Django
    creates a form field for each field contained in the model. However, we can explicitly
    tell Django which fields to include in the form using the `fields` attribute or
    define which fields to exclude using the `exclude` attribute. In the `CommentForm`
    form, we have explicitly included the `name`, `email`, and `body` fields. These
    are the only fields that will be included in the form.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型字段类型都有一个对应的默认表单字段类型。模型字段的属性会被考虑进表单验证中。默认情况下，Django 为模型中的每个字段创建一个表单字段。然而，我们可以通过使用
    `fields` 属性显式地告诉 Django 哪些字段要包含在表单中，或者使用 `exclude` 属性定义哪些字段要排除。在 `CommentForm`
    表单中，我们明确包含了 `name`、`email` 和 `body` 字段。这些是唯一会被包含在表单中的字段。
- en: You can find more information about creating forms from models at [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/)
    找到更多关于从模型创建表单的信息。
- en: Handling ModelForms in views
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中处理 ModelForms
- en: 'For sharing posts by email, we used the same view to display the form and manage
    its submission. We used the HTTP method to differentiate between both cases: `GET`
    to display the form and `POST` to submit it. In this case, we will add the comment
    form to the post detail page, and we will build a separate view to handle the
    form submission. The new view that processes the form will allow the user to return
    to the post detail view once the comment has been stored in the database.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过电子邮件分享帖子，我们使用了相同的视图来显示表单并管理其提交。我们使用 HTTP 方法来区分这两种情况：`GET` 用于显示表单，`POST`
    用于提交。在这种情况下，我们将评论表单添加到帖子详情页，并且我们将构建一个单独的视图来处理表单提交。处理表单的新视图将允许用户在评论存储到数据库后返回到帖子详情视图。
- en: 'Edit the `views.py` file of the `blog` application and add the following code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用的 `views.py` 文件并添加以下代码：
- en: '[PRE52]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have defined the `post_comment` view that takes the `request` object and
    the `post_id` variable as parameters. We will be using this view to manage the
    post submission. We expect the form to be submitted using the HTTP `POST` method.
    We use the `require_POST` decorator provided by Django to only allow `POST` requests
    for this view. Django allows you to restrict the HTTP methods allowed for views.
    Django will throw an HTTP `405` (method not allowed) error if you try to access
    the view with any other HTTP method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `post_comment` 视图，它接受 `request` 对象和 `post_id` 变量作为参数。我们将使用这个视图来管理帖子提交。我们期望表单将通过
    HTTP `POST` 方法提交。我们使用 Django 提供的 `require_POST` 装饰器来仅允许对这个视图的 `POST` 请求。Django
    允许你限制视图允许的 HTTP 方法。如果你尝试用任何其他 HTTP 方法访问视图，Django 将会抛出一个 HTTP `405`（方法不被允许）错误。
- en: 'In this view, we have implemented the following actions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们实现了以下操作：
- en: We retrieve a published post by its `id` using the `get_object_or_404()` shortcut.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `get_object_or_404()` 快捷方式通过 `id` 获取一个已发布的帖子。
- en: We define a `comment` variable with the initial value `None`. This variable
    will be used to store the comment object when it is created.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个初始值为 `None` 的 `comment` 变量。当创建评论对象时，这个变量将用来存储评论对象。
- en: We instantiate the form using the submitted `POST` data and validate it using
    the `is_valid()` method. If the form is invalid, the template is rendered with
    the validation errors.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用提交的 `POST` 数据实例化表单，并使用 `is_valid()` 方法进行验证。如果表单无效，模板将带有验证错误被渲染。
- en: 'If the form is valid, we create a new `Comment` object by calling the form’s
    `save()` method and assign it to the `comment` variable, as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单有效，我们将通过调用表单的 `save()` 方法创建一个新的 `Comment` 对象，并将其分配给 `comment` 变量，如下所示：
- en: '[PRE53]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `save()` method creates an instance of the model that the form is linked
    to and saves it to the database. If you call it using `commit=False`, the model
    instance is created but not saved to the database. This allows us to modify the
    object before finally saving it.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`save()` 方法创建与表单关联的模型实例并将其保存到数据库。如果您使用 `commit=False` 调用它，则模型实例将被创建但不会保存到数据库。这允许我们在最终保存之前修改对象。'
- en: The `save()` method is available for `ModelForm` but not for `Form` instances
    since they are not linked to any model.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`save()` 方法对 `ModelForm` 实例可用，但对 `Form` 实例不可用，因为它们没有链接到任何模型。'
- en: 'We assign the post to the comment we created:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将帖子分配给创建的评论：
- en: '[PRE54]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We save the new comment to the database by calling its `save()` method:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用其 `save()` 方法将新的评论保存到数据库：
- en: '[PRE55]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We render the `blog/post/comment.html` template, passing the `post`, `form`,
    and `comment` objects in the template context. This template doesn’t exist yet;
    we will create it later.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们渲染 `blog/post/comment.html` 模板，将 `post`、`form` 和 `comment` 对象传递到模板上下文中。此模板尚不存在；我们将在稍后创建它。
- en: Let’s create a URL pattern for this view.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个视图创建一个 URL 模式。
- en: 'Edit the `urls.py` file of the `blog` application and add the following URL
    pattern to it:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用的 `urls.py` 文件，并向其中添加以下 URL 模式：
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We have implemented the view to manage the submission of comments and their
    corresponding URL. Let’s create the necessary templates.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了管理评论提交及其对应 URL 的视图。让我们创建必要的模板。
- en: Creating templates for the comment form
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建评论表单的模板
- en: 'We will create a template for the comment form that we will use in two places:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个用于评论表单的模板，我们将在两个地方使用它：
- en: In the post detail template associated with the `post_detail` view to let users
    publish comments.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与 `post_detail` 视图关联的帖子详情模板中，让用户发布评论。
- en: In the post comment template associated with the `post_comment` view to display
    the form again if there are any form errors.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与 `post_comment` 视图关联的发表评论模板中，如果有任何表单错误，将再次显示表单。
- en: We will create the form template and use the `{% include %}` template tag to
    include it in the two other templates.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建表单模板，并使用 `{% include %}` 模板标签将其包含在另外两个模板中。
- en: In the `templates/blog/post/` directory, create a new `includes/` directory.
    Add a new file inside this directory and name it `comment_form.html`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates/blog/post/` 目录中，创建一个新的 `includes/` 目录。在此目录内添加一个新文件，并将其命名为 `comment_form.html`。
- en: 'The file structure should look as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构应如下所示：
- en: '[PRE57]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Edit the new `blog/post/includes/comment_form.html` template and add the following
    code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新的 `blog/post/includes/comment_form.html` 模板，并添加以下代码：
- en: '[PRE58]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this template, we build the `action` URL of the HTML `<form>` element dynamically
    using the `{% url %}` template tag. We build the URL of the `post_comment` view
    that will process the form. We display the form rendered in paragraphs and we
    include `{% csrf_token %}` for CSRF protection because this form will be submitted
    with the `POST` method.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们使用 `{% url %}` 模板标签动态构建 HTML `<form>` 元素的 `action` URL。我们构建将处理表单的 `post_comment`
    视图的 URL。我们显示以段落形式渲染的表单，并包含 `{% csrf_token %}` 以实现 CSRF 保护，因为此表单将以 `POST` 方法提交。
- en: Create a new file in the `templates/blog/post/` directory of the `blog` application
    and name it `comment.html`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `blog` 应用的 `templates/blog/post/` 目录中创建一个新文件，并将其命名为 `comment.html`。
- en: 'The file structure should now look as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构现在应如下所示：
- en: '[PRE59]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Edit the new `blog/post/comment.html` template and add the following code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新的 `blog/post/comment.html` 模板，并添加以下代码：
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is the template for the post comment view. In this view, we expect the
    form to be submitted via the `POST` method. The template covers two different
    scenarios:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是帖子评论视图的模板。在这个视图中，我们期望表单通过 `POST` 方法提交。模板涵盖了两种不同的场景：
- en: If the form data submitted is valid, the `comment` variable will contain the
    `comment` object that was created and a success message will be displayed.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提交的表单数据有效，`comment` 变量将包含创建的 `comment` 对象，并将显示成功消息。
- en: If the form data submitted is not valid, the `comment` variable will be `None`.
    In this case, we will display the comment form. We use the `{% include %}` template
    tag to include the `comment_form.html` template that we have previously created.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提交的表单数据无效，`comment` 变量将为 `None`。在这种情况下，我们将显示评论表单。我们使用 `{% include %}` 模板标签来包含我们之前创建的
    `comment_form.html` 模板。
- en: Adding comments to the post detail view
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在帖子详情视图中添加评论
- en: To complete the comment functionality, we will add the list of comments and
    the comment form to the `post_detail` view.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成评论功能，我们将添加评论列表和评论表单到 `post_detail` 视图中。
- en: 'Edit the `views.py` file of the `blog` application and edit the `post_detail`
    view as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog` 应用程序的 `views.py` 文件并按照以下方式编辑 `post_detail` 视图：
- en: '[PRE61]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s review the code we have added to the `post_detail` view:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们添加到 `post_detail` 视图中的代码：
- en: 'We have added a QuerySet to retrieve all active comments for the post, as follows:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个查询集来检索帖子的所有活跃评论，如下所示：
- en: '[PRE62]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This QuerySet is built using the `post` object. Instead of building a QuerySet
    for the `Comment` model directly, we leverage the `post` object to retrieve the
    related `Comment` objects. We use the `comments` manager for the related `Comment`
    objects that we previously defined in the `Comment` model, using the `related_name`
    attribute of the `ForeignKey` field to the `Post` model.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此查询集是通过使用 `post` 对象构建的。我们不是直接为 `Comment` 模型构建查询集，而是利用 `post` 对象来检索相关的 `Comment`
    对象。我们使用在 `Comment` 模型中先前定义的 `comments` 管理器来处理相关的 `Comment` 对象，使用 `ForeignKey`
    字段的 `related_name` 属性来关联 `Post` 模型。
- en: We have also created an instance of the comment form with `form = CommentForm()`.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还创建了一个评论表单的实例，`form = CommentForm()`。
- en: Adding comments to the post detail template
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在帖子详情模板中添加评论
- en: 'We need to edit the `blog/post/detail.html` template to implement the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑 `blog/post/detail.html` 模板以实施以下更改：
- en: Display the total number of comments for a post
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示帖子的评论总数
- en: Display the list of comments
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示评论列表
- en: Display the form for users to add a new comment
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户添加新评论的表单
- en: We will start by adding the total number of comments for a post.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加帖子的评论总数。
- en: 'Edit the `blog/post/detail.html` template and change it as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog/post/detail.html` 模板并按照以下方式更改：
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We use the Django **object relational mapper** (**ORM**) in the template, executing
    the `comments.count()` QuerySet. Note that the Django template language doesn’t
    use parentheses for calling methods. The `{% with %}` tag allows you to assign
    a value to a new variable that will be available in the template until the `{%
    endwith %}` tag.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中使用 Django **对象关系映射器**（**ORM**），执行 `comments.count()` 查询集。请注意，Django 模板语言在调用方法时不使用括号。`{%
    with %}` 标签允许您将值分配给一个新变量，该变量将在模板中可用，直到遇到 `{% endwith %}` 标签。
- en: The `{% with %}` template tag is useful for avoiding hitting the database or
    accessing expensive methods multiple times.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% with %}` 模板标签对于避免多次访问数据库或调用昂贵的方法非常有用。'
- en: We use the `pluralize` template filter to display a plural suffix for the word
    “comment,” depending on the `total_comments` value. Template filters take the
    value of the variable they are applied to as their input and return a computed
    value. We will learn more about template filters in *Chapter 3*, *Extending Your
    Blog Application*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `pluralize` 模板过滤器来根据 `total_comments` 值显示单词 “comment” 的复数后缀。模板过滤器将它们应用到的变量的值作为输入，并返回一个计算后的值。我们将在
    *第3章*，*扩展您的博客应用程序* 中了解更多关于模板过滤器的内容。
- en: The `pluralize` template filter returns a string with the letter “s” if the
    value is different from `1`. The preceding text will be rendered as *0 comments*,
    *1 comment*, or *N comments*, depending on the number of active comments for the
    post.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`pluralize` 模板过滤器如果值不同于 `1`，则返回带有字母 “s” 的字符串。根据帖子的活跃评论数量，前面的文本将渲染为 *0 条评论*，*1
    条评论* 或 *N 条评论*。'
- en: Now, let’s add the list of active comments to the post detail template.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将活跃评论的列表添加到帖子详情模板中。
- en: 'Edit the `blog/post/detail.html` template and implement the following changes:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog/post/detail.html` 模板并实施以下更改：
- en: '[PRE64]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have added a `{% for %}` template tag to loop through the post comments.
    If the `comments` list is empty, we display a message that informs users that
    there are no comments for this post. We enumerate comments with the `{{ forloop.counter
    }}` variable, which contains the loop counter in each iteration. For each post,
    we display the name of the user who posted it, the date, and the body of the comment.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `{% for %}` 模板标签来遍历帖子评论。如果 `comments` 列表为空，我们显示一条消息，告知用户此帖子没有评论。我们使用
    `{{ forloop.counter }}` 变量来列举评论，该变量包含每次迭代的循环计数。对于每个帖子，我们显示发布者的名字、日期和评论内容。
- en: Finally, let’s add the comment form to the template.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将评论表单添加到模板中。
- en: 'Edit the `blog/post/detail.html` template and include the comment form template
    as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog/post/detail.html` 模板，并按照以下方式包含评论表单模板：
- en: '[PRE65]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and click on a post title
    to take a look at the post detail page. You will see something like *Figure 2.23*:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:8000/blog/` 并点击帖子标题以查看帖子详情页面。你会看到类似 *图2.23* 的内容：
- en: '![](img/B21088_02_23.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_23.png)'
- en: 'Figure 2.23: The post detail page, including the form to add a comment'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：帖子详情页面，包括添加评论的表单
- en: 'Fill in the comment form with valid data and click on **Add comment**. You
    should see the following page:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效数据填写评论表单并点击 **添加评论**。你应该看到以下页面：
- en: '![](img/B21088_02_24.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_24.png)'
- en: 'Figure 2.24: The comment added success page'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：添加评论成功页面
- en: 'Click on the **Back to the post** link. You should be redirected back to the
    post detail page, and you should be able to see the comment that you just added,
    as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **返回帖子** 链接。你应该被重定向回帖子详情页面，你应该能够看到你刚刚添加的评论，如下所示：
- en: '![](img/B21088_02_25.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_25.png)'
- en: 'Figure 2.25: The post detail page, including a comment'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：帖子详情页面，包括评论
- en: 'Add one more comment to the post. The comments should appear below the post
    contents in chronological order, as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 向帖子添加一条评论。评论应按时间顺序显示在帖子内容下方，如下所示：
- en: '![](img/B21088_02_26.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_26.png)'
- en: 'Figure 2.26: The comment list on the post detail page'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：帖子详情页面上的评论列表
- en: 'Open `http://127.0.0.1:8000/admin/blog/comment/` in your browser. You will
    see the administration page with the list of comments you created, like this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:8000/admin/blog/comment/`。你会看到包含你创建的评论列表的管理页面，如下所示：
- en: '![](img/B21088_02_27.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_27.png)'
- en: 'Figure 2.27: List of comments on the administration site'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：管理站点上的评论列表
- en: 'Click on the name of one of the posts to edit it. Uncheck the **Active** checkbox
    as follows and click on the **Save** button:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 点击其中一个帖子的名称来编辑它。按照以下方式取消选择 **活动** 复选框，然后点击 **保存** 按钮：
- en: '![](img/B21088_02_28.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_28.png)'
- en: 'Figure 2.28: Editing a comment on the administration site'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：在管理站点上编辑评论
- en: 'You will be redirected to the list of comments. The **Active** column will
    display an inactive icon for the comment, as shown in *Figure 2.29*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被重定向到评论列表。**活动**列将显示非活动图标，如图 *图2.29* 所示：
- en: '![](img/B21088_02_29.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_29.png)'
- en: 'Figure 2.29: Active/inactive comments on the administration site'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29：管理站点上的活动/非活动评论
- en: 'If you return to the post detail view, you will note that the inactive comment
    is no longer displayed, neither is it counted for the total number of active comments
    for the post:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回到帖子详情视图，你会注意到不再显示非活动评论，它也不会计入帖子的总活动评论数：
- en: '![](img/B21088_02_30.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_02_30.png)'
- en: 'Figure 2.30: A single active comment displayed on the post detail page'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30：在帖子详情页面上显示的单个活动评论
- en: Thanks to the `active` field, you can deactivate inappropriate comments and
    avoid showing them on your posts.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `active` 字段，你可以停用不适当的评论，并避免在帖子中显示它们。
- en: Using simplified templates for form rendering
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简化的模板进行表单渲染
- en: You have used `{{ form.as_p }}` to render the forms using HTML paragraphs. This
    is a very straightforward method for rendering forms, but there may be occasions
    when you need to employ custom HTML markup for rendering forms.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了 `{{ form.as_p }}` 来使用HTML段落渲染表单。这是一个渲染表单的非常直接的方法，但可能有时你需要使用自定义HTML标记来渲染表单。
- en: 'To use custom HTML for rendering form fields, you can access each form field
    directly, or iterate through the form fields, as in the following example:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义HTML渲染表单字段，你可以直接访问每个表单字段，或者遍历表单字段，如下例所示：
- en: '[PRE66]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this code, we use `{{ field.errors }}` to render any field errors of the
    form, `{{ field.label_tag }}` to render the form HTML label, `{{ field }}` to
    render the actual field, and `{{ field.help_text|safe }}` to render the field’s
    help text HTML.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`{{ field.errors }}`来渲染表单的任何字段错误，`{{ field.label_tag }}`来渲染表单HTML标签，`{{
    field }}`来渲染实际字段，以及`{{ field.help_text|safe }}`来渲染字段的帮助文本HTML。
- en: This method is helpful to customize how forms are rendered, but you might need
    to add certain HTML elements for specific fields or include some fields in containers.
    Django 5.0 introduces field groups and field group templates. Field groups simplify
    the rendering of labels, widgets, help texts, and field errors. Let’s use this
    new feature to customize the comment form.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有助于自定义表单的渲染方式，但你可能需要为特定字段添加某些HTML元素或将某些字段包含在容器中。Django 5.0引入了字段组和字段组模板。字段组简化了标签、小部件、帮助文本和字段错误的渲染。让我们使用这个新功能来自定义评论表单。
- en: We are going to use custom HTML markup to reposition the `name` and `email`
    form fields using additional HTML elements.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自定义HTML标记来重新定位`name`和`email`表单字段，使用额外的HTML元素。
- en: 'Edit the `blog/post/includes/comment_form.html` template and modify it as follows.
    The new code is highlighted in bold:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/post/includes/comment_form.html`模板，并按以下方式修改。新的代码以粗体显示：
- en: '[PRE67]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We have added `<div>` containers for the `name` and `email` fields with a custom
    CSS class to float both fields to the left.The `as_field_group` method renders
    each field including help text and errors. This method uses the `django/forms/field.html`
    template by default. You can see the contents of this template at [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html).
    You can also create custom field templates and reuse them by adding the `template_name`
    attribute to any form field. You can read more about reusable form templates at
    [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`name`和`email`字段添加了带有自定义CSS类的`<div>`容器，使两个字段都浮动到左边。`as_field_group`方法渲染每个字段，包括帮助文本和错误。此方法默认使用`django/forms/field.html`模板。你可以在[https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html)中查看此模板的内容。你还可以创建自定义字段模板，并通过将`template_name`属性添加到任何表单字段来重复使用它们。你可以在[https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates)上了解更多关于可重复使用的表单模板的信息。
- en: 'Open a blog post and take a look at the comment form. The form should now look
    like *Figure 2.31*:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一篇博客文章，查看评论表单。现在表单应该看起来像*图2.31*：
- en: '![](img/B21088_02_31.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_02_31.png)'
- en: 'Figure 2.31: The comment form with the new HTML markup'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31：带有新HTML标记的评论表单
- en: The `name` and `email` fields are now displayed next to each other. Field groups
    allow you to easily customize form rendering.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`和`email`字段现在并排显示。字段组允许你轻松自定义表单渲染。'
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to define canonical URLs for models. You created
    SEO-friendly URLs for blog posts, and you implemented object pagination for your
    post list. You also learned how to work with Django forms and model forms. You
    created a system to recommend posts by email and created a comment system for
    your blog.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为模型定义规范URL。你为博客文章创建了SEO友好的URL，并为你的文章列表实现了对象分页。你还学习了如何使用Django表单和模型表单。你创建了一个通过电子邮件推荐文章的系统，并为你的博客创建了一个评论系统。
- en: In the next chapter, you will create a tagging system for the blog. You will
    learn how to build complex QuerySets to retrieve objects by similarity. You will
    learn how to create custom template tags and filters. You will also build a custom
    sitemap and feed for your blog posts and implement full-text search functionality
    for your posts.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将为博客创建一个标签系统。你将学习如何构建复杂的查询集以通过相似性检索对象。你将学习如何创建自定义模板标签和过滤器。你还将为你的博客文章构建自定义的网站地图和源，并为你的文章实现全文搜索功能。
- en: Additional resources
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了与本章所涵盖主题相关的额外信息：
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章源代码：[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter02)
- en: 'URL utility functions: [https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL实用函数：[https://docs.djangoproject.com/en/5.0/ref/urlresolvers/](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/)
- en: 'URL path converters: [https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL路径转换器：[https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters](https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters)
- en: 'Django paginator class: [https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django分页器类：[https://docs.djangoproject.com/en/5.0/ref/paginator/](https://docs.djangoproject.com/en/5.0/ref/paginator/)
- en: Introduction to class-based views – [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类的视图介绍 – [https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/](https://docs.djangoproject.com/en/5.0/topics/class-based-views/intro/)
- en: 'Sending emails with Django: [https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django发送电子邮件：[https://docs.djangoproject.com/en/5.0/topics/email/](https://docs.djangoproject.com/en/5.0/topics/email/)
- en: 'The `python-decouple` library: [https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-decouple`库：[https://github.com/HBNetwork/python-decouple](https://github.com/HBNetwork/python-decouple)'
- en: 'The `django-anymail` library: [https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-anymail`库：[https://anymail.dev/en/stable/installation/](https://anymail.dev/en/stable/installation/)'
- en: 'The `django-anymail` supported email service providers: [https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-anymail`支持的电子邮件服务提供商：[https://anymail.dev/en/stable/esps/](https://anymail.dev/en/stable/esps/)'
- en: 'Django form field types: [https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django表单字段类型：[https://docs.djangoproject.com/en/5.0/ref/forms/fields/](https://docs.djangoproject.com/en/5.0/ref/forms/fields/)
- en: 'Working with forms: [https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/)'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与表单一起工作：[https://docs.djangoproject.com/en/5.0/topics/forms/](https://docs.djangoproject.com/en/5.0/topics/forms/)
- en: 'Creating forms from models: [https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模型创建表单：[https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/](https://docs.djangoproject.com/en/5.0/topics/forms/modelforms/)
- en: 'Many-to-one model relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一模型关系：[https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_one/)
- en: 'Default form field template: [https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认表单字段模板：[https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html](https://github.com/django/django/blob/stable/5.0.x/django/forms/templates/django/forms/field.html)
- en: 'Reusable field group templates: [https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用字段组模板：[https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates](https://docs.djangoproject.com/en/5.0/topics/forms/#reusable-field-group-templates)
