- en: Chapter 2. Starting with Python Strings, Files, and Menus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 从 Python 字符串、文件和菜单开始
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with text and strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本和字符串
- en: Using files and handling errors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件和处理错误
- en: Creating a boot-up menu
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建启动菜单
- en: Creating a self-defining menu
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自我定义的菜单
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we discuss how to use Python to perform some basic encryption
    by scrambling letters. This will introduce some basic string manipulation, user
    input, progressing on to creating reusable modules, and graphical user interfaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用 Python 通过打乱字母来执行一些基本的加密。这将介绍一些基本的字符串操作、用户输入，并逐步创建可重用的模块和图形用户界面。
- en: To follow, we will create some useful Python scripts that can be added to run
    as the Raspberry Pi boots or an easy-to-run command that will provide quick shortcuts
    to common or frequently-used commands. Taking this further, we will make use of
    threading to run multiple tasks and introduce classes to define multiple objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些有用的 Python 脚本，可以将它们添加到启动时运行或在需要时快速运行的命令，提供对常用或频繁使用的命令的快捷方式。进一步来说，我们将利用线程来运行多个任务，并引入类来定义多个对象。
- en: As it is customary to start any programming exercise with a *Hello World* example,
    we will kick off with that now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何编程练习的传统做法都是以 *Hello World* 示例开始，我们现在就从这个例子开始。
- en: 'Create the `hellopi.py` file using `nano`, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nano` 创建 `hellopi.py` 文件，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within our `hellopi.py` file, add the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `hellopi.py` 文件中，添加以下代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When done, save and exit (*Ctrl* + *X*, *Y*, and *Enter*). To run the file,
    use the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，保存并退出（*Ctrl* + *X*，*Y*，和 *Enter*）。要运行文件，请使用以下命令：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Congratulations, you have created your first program!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经创建了您的第一个程序！
- en: 'Your result should be similar to the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果应类似于以下截图：
- en: '![Introduction](img/6623OT_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/6623OT_02_01.jpg)'
- en: The Hello Raspberry Pi output
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Hello Raspberry Pi 输出
- en: Working with text and strings
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本和字符串
- en: A good starting point for Python is to gain an understanding of basic text handling
    and strings. A string is a block of characters stored together as a value. As
    you will learn, they can be viewed as a simple list of characters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个良好起点是了解基本的文本处理和字符串。字符串是一组字符作为一个值存储在一起。正如您将学到的，它们可以被视为字符的简单列表。
- en: We will create a script to obtain the user's input, use string manipulation
    to switch around the letters, and print out a coded version of the message. We
    will then extend this example by demonstrating how encoded messages can be passed
    between parties without revealing the encoding methods, while also showing how
    to reuse sections of the code within other Python modules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本来获取用户的输入，使用字符串操作来交换字母，并打印出编码后的消息。然后我们将通过演示如何在不透露编码方法的情况下在各方之间传递编码消息，同时展示如何在其他
    Python 模块中重用代码段来扩展这个示例。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You can use most text editors to write Python code. They can be used directly
    on the Raspberry Pi or remotely through VNC or SSH.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用大多数文本编辑器来编写 Python 代码。它们可以直接在 Raspberry Pi 上使用，或者通过 VNC 或 SSH 远程使用。
- en: 'The following are a few text editors that are available with the Raspberry
    Pi:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与 Raspberry Pi 一起提供的文本编辑器：
- en: '**nano**: This text editor is available at the terminal and includes syntax
    highlighting and line numbers (with the `-c` option). Refer to the following screenshot:![Getting
    ready](img/6623OT_02_02.jpg)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nano**：这个文本编辑器在终端可用，包括语法高亮和行号（使用 `-c` 选项）。请参考以下截图：![准备就绪](img/6623OT_02_02.jpg)'
- en: The nano command-line editor
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nano 命令行编辑器
- en: '**IDLE3**: This Python editor includes the syntax highlighting feature, context
    help, and will run scripts directly from the editor (on pressing *F5*). This program
    requires X-Windows (the Debian desktop) or X11-forwarding to run remotely. We
    will be using Python 3 throughout the book, so ensure that you run IDLE3 (rather
    than IDLE), which will use Python 3 to run the scripts, as shown in the following
    screenshot:![Getting ready](img/6623OT_02_03.jpg)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDLE3**：这个 Python 编辑器包括语法高亮功能、上下文帮助，并且可以直接从编辑器中运行脚本（按 *F5*）。此程序需要 X-Windows（Debian
    桌面）或 X11 转发以远程运行。本书将使用 Python 3，所以请确保您运行 IDLE3（而不是 IDLE），它将使用 Python 3 来运行脚本，如下面的截图所示：![准备就绪](img/6623OT_02_03.jpg)'
- en: The IDLE3 Python editor
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IDLE3 Python 编辑器
- en: '**Geany**: This text editor provides an **Integrated Development Environment**
    (**IDE**) that supports a range of programming languages, syntax highlighting,
    auto completion, and easy code navigation. This is a feature-rich editor, but
    can be difficult to use for beginners and may sometimes be slow when running on
    the Raspberry Pi. Again, you will need to run this editor with the Debian desktop
    or X11-forwarding. Refer to the following screenshot:![Getting ready](img/6623OT_02_04.jpg)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Geany**：这个文本编辑器提供了一个**集成开发环境**（**IDE**），支持多种编程语言，语法高亮，自动完成和易于代码导航。这是一个功能丰富的编辑器，但对于初学者来说可能难以使用，并且在Raspberry
    Pi上运行时有时可能会变慢。再次提醒，您需要使用Debian桌面或X11转发来运行此编辑器。请参考以下截图：![准备中](img/6623OT_02_04.jpg)'
- en: The Geany IDE
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Geany IDE
- en: 'To install Geany, use the following command and then run **Geany** from the
    **Programming** menu item:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要安装Geany，请使用以下命令，然后从**编程**菜单项运行**Geany**：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To ensure Geany uses Python 3 when you click on the **Execute** button (to
    run your scripts), you will need to change the *build* commands. Load `hellopi.py`
    and then click on the **Build** menu and select **Set Build Commands**. In the
    window that appears, as shown in the following screenshot, change `python` to
    `python3` in the **Compile** and **Execute** sections. Python is always compiled
    automatically when it is run (producing the temporary `.pyc` files), so you don''t
    need to use the **Compile** button, except maybe to check the syntax of the code:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保当你点击**执行**按钮（运行你的脚本）时Geany使用Python 3，你需要更改**构建**命令。加载`hellopi.py`，然后点击**构建**菜单并选择**设置构建命令**。在出现的窗口中，如图所示，将**编译**和**执行**部分中的`python`更改为`python3`。Python在运行时总是自动编译（生成临时的`.pyc`文件），所以你不需要使用**编译**按钮，除非你可能需要检查代码的语法：
- en: '![Getting ready](img/6623OT_02_05.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_02_05.jpg)'
- en: The Geany Build command settings for Python 3
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Geany为Python 3的构建命令设置
- en: If you have the `home` directory of the Raspberry Pi shared across the network
    (refer to *Sharing the home folder of the Raspberry Pi with SMB* recipe in [Chapter
    1](ch01.html "Chapter 1. Getting Started with a Raspberry Pi Computer"), *Getting
    Started with a Raspberry Pi Computer*), you can edit files on another computer.
    However, note that if you use Windows, you must use an editor that supports Linux
    line endings, such as Notepad++ (you should not use the standard Notepad program).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Raspberry Pi的`home`目录通过网络共享（请参阅[第1章](ch01.html "第1章。使用Raspberry Pi计算机入门")中的*使用SMB共享Raspberry
    Pi的home文件夹*菜谱），你可以在另一台计算机上编辑文件。但是请注意，如果你使用Windows，你必须使用支持Linux行结束符的编辑器，例如Notepad++（你不应该使用标准的记事本程序）。
- en: 'To create a space for your Python scripts, we will add a `python_scripts` folder
    to your `home` directory with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的Python脚本创建空间，我们将使用以下命令在你的`home`目录中添加一个`python_scripts`文件夹：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you can open this folder and list the files whenever you need to, using
    the following commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开这个文件夹，并在需要时使用以下命令列出文件：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the *Tab* key to help complete commands in the terminal, for example,
    typing `cd ~/pyt` and then pressing the *Tab* key will finish the command for
    you. If there are multiple options that start with `pyt`, pressing the *Tab* key
    again will list them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Tab**键帮助在终端中完成命令，例如，键入`cd ~/pyt`然后按**Tab**键将为你完成命令。如果有多个以`pyt`开头的选项，再次按**Tab**键将列出它们。
- en: To repeat or edit older commands, use the up and down arrow keys to switch between
    older and newer commands as required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复或编辑较旧的命令，请使用上箭头键和下箭头键在较旧和较新的命令之间切换，根据需要操作。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the `encryptdecrypt.py` script as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式创建`encryptdecrypt.py`脚本：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Within the *There''s more…* section of this recipe, we will change `main()`
    to the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱的*还有更多…*部分，我们将把`main()`更改为以下代码：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want to skip the section, ensure that you include this change in the
    `encryptdecrypt.py` file, as we will use it later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跳过这一部分，请确保你在`encryptdecrypt.py`文件中包含这个更改，因为我们稍后会用到它。
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding script implements a very basic method to scramble the text using
    a simple form of character substitution called the **Caesar cipher**. Named after
    the Roman emperor Julius Caesar, who originally used this method to send secret
    orders to his armies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本实现了一种非常基本的通过称为**凯撒密码**的简单字符替换形式来打乱文本的方法。这种方法是以罗马皇帝凯撒命名的，他最初使用这种方法向他的军队发送秘密命令。
- en: The file defines two functions, `encryptText()` and `main()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件定义了两个函数，`encryptText()`和`main()`。
- en: 'When the script is running, the `main()` function obtains the user''s input
    using the `input()` command. The result is stored as a string in the `user_input`
    variable (the command will wait until the user has pressed the *Enter* key before
    continuing), as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，`main()`函数使用`input()`命令获取用户的输入。结果存储在`user_input`变量中（该命令将在用户按下*Enter*键之前等待），如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `input()` function will not handle non-ASCII characters, so we use `try…except`
    to handle this case, which will cause `UnicodeDecodeError` to be raised. For more
    information about using `try…except`, refer to the *Using files and handling errors*
    recipe of this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数不会处理非ASCII字符，因此我们使用`try…except`来处理这种情况，这会导致抛出`UnicodeDecodeError`。有关使用`try…except`的更多信息，请参阅本章的*使用文件和处理错误*配方。'
- en: 'We will call the `encryptText()` function with two arguments, the text to be
    encrypted, and the key. After the text has been encrypted, the result is printed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个参数调用`encryptText()`函数，即要加密的文本和密钥。文本加密后，结果将被打印出来：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we will use `input()` to wait for the user input again (in this case,
    a prompt to press *Enter*; any other input is ignored). Now, we will unscramble
    the text by reversing the encryption by calling `encryptText()` again, but with
    a negative version of the key, and displaying the result, which should be the
    original message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`input()`再次等待用户输入（在这种情况下，提示按*Enter*；任何其他输入都将被忽略）。现在，我们将通过再次调用`encryptText()`并使用密钥的负值来反转加密，并显示结果，结果应该是原始消息。
- en: The `encryptText()` function performs a simple form of encryption by taking
    the letters in the message and substituting each letter with another in the alphabet
    (determined by counting from the number of letters specified by the encryption
    `key`). In this way, the letter `A` will become `C` when the encryption `key`
    is `2`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`encryptText()`函数通过将消息中的字母替换为字母表中另一个字母（由加密`key`指定的字母数量决定）来执行一种简单的加密形式。这样，当加密`key`为“2”时，字母“A”将变为“C”。'
- en: 'To simplify the process, the function converts all characters to uppercase.
    This allows us to use the ASCII character set to translate each character into
    numbers easily; the letter `A` is represented by `65` and `Z` by `90`. This is
    achieved with `input_text=input_text.upper()` and then by using `ord(letter)`
    to convert to an ASCII value, which gives us a number representation of the character.
    ASCII is a standard that maps the numbers 0 to 254 (an 8-bit value) and commonly
    used characters and symbols:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化过程，该函数将所有字符转换为大写。这使得我们可以使用ASCII字符集轻松地将每个字符转换为数字；字母“A”表示为“65”，而“Z”表示为“90”。这是通过`input_text=input_text.upper()`实现的，然后使用`ord(letter)`将其转换为ASCII值，这给我们提供了字符的数字表示。ASCII是一个将数字0到254（一个8位值）映射到常用字符和符号的标准：
- en: '| A | B | C | D | E | F | G | H | I | J | K | L | M |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| A | B | C | D | E | F | G | H | I | J | K | L | M |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
- en: '| 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 |'
- en: '| **N** | **O** | **P** | **Q** | **R** | **S** | **T** | **U** | **V** | **W**
    | **X** | **Y** | **Z** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **N** | **O** | **P** | **Q** | **R** | **S** | **T** | **U** | **V** | **W**
    | **X** | **Y** | **Z** |'
- en: '| 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 |'
- en: ASCII table for upper case letters
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大写字母的ASCII表
- en: Next, we will ensure that we have an empty string where we can build our result
    (`result = ""`) and we will also set our encryption `key` to our key value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保我们有一个空字符串，我们可以在这个字符串中构建我们的结果（`result = ""`），同时我们也将我们的加密`key`设置为密钥值。
- en: The `input_text` variable contains our string, which is stored as a list (this
    is similar to an array) of letters. We can access each item in the list using
    `input_text[0]` for the first item and so on; however, Python also allows us to
    loop through a list using `for…in`, accessing each item in turn.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`input_text`变量包含我们的字符串，它被存储为一个字母列表（这与数组类似）。我们可以使用`input_text[0]`访问列表中的第一个项目，依此类推；然而，Python还允许我们使用`for…in`循环遍历列表，依次访问每个项目。'
- en: The `for letter in input_text:` line allows us to break up `input_text` by looping
    through it for each item inside (in this case, the letters in the string) and
    also setting the letter equal to that item. So if `input_text` equaled `HELLO`,
    it would run all the code that is indented under the command five times; each
    time, the `letter` variable would be set to `H`, `E`, `L`, `L`, and finally `O`.
    This allows us to read each letter separately, process it, and add the new encrypted
    letter to the `result` string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`for letter in input_text:` 这一行代码允许我们通过遍历 `input_text` 中的每个项目（在这种情况下，字符串中的字母）来将其拆分，并且将字母设置为该项目。所以如果
    `input_text` 等于 `HELLO`，它将运行命令下缩进的所有代码五次；每次，`letter` 变量将被设置为 `H`、`E`、`L`、`L`，最后是
    `O`。这使得我们可以单独读取每个字母，处理它，并将新的加密字母添加到 `result` 字符串中。'
- en: The next part, `if (ord("A") > ascii_value) or (ascii_value > ord("Z")):`, checks
    to see if the character we are looking at is not between `A` and `Z`, which means
    it is probably a number or punctuation mark. In this case, we will exclude the
    character from the encryption (passing the character directly to the `result`
    string unchanged).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分，`if (ord("A") > ascii_value) or (ascii_value > ord("Z")):` 检查我们正在查看的字符是否不在
    `A` 和 `Z` 之间，这意味着它可能是一个数字或标点符号。在这种情况下，我们将从加密中排除该字符（直接将字符不变地传递到 `result` 字符串中）。
- en: 'If the letter is between `A` and `Z`, we can add the value of our encryption
    `key` to the value of our letter to obtain our new encoded letter. That is, for
    an encryption `key` of `10`, we end up with the following set of letters in the
    output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字母在 `A` 和 `Z` 之间，我们可以将我们的加密 `key` 的值添加到我们的字母的值，以获得我们新的编码字母。也就是说，对于加密 `key`
    为 `10` 的情况，我们在输出中最终得到以下字母集：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we want the encrypted message to be easy to write out, we have limited the
    output to be between `A` and `Z`. So, if the letter starts as `X`, we want to
    it to wrap around and continue counting from `A`. We can achieve this by using
    the `%` (modulus) function, which gives us the remainder value if we divide a
    number by another. So, if `X` is `24` and we add `10`, we get `34`. The value
    of `34%26` (where `26` is the total number of letters) is `8`. Counting `8` from
    `A`, we reach `H`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望加密的消息易于书写，我们已将输出限制在 `A` 和 `Z` 之间。所以，如果字母以 `X` 开头，我们希望它绕回并从 `A` 继续计数。我们可以通过使用
    `%`（模数）函数来实现这一点，它给出了当我们用一个数除以另一个数时的余数值。所以，如果 `X` 是 `24`，我们加上 `10` 得到 `34`。`34%26`（其中
    `26` 是字母的总数）的值是 `8`。从 `A` 开始计数 `8`，我们到达 `H`。
- en: 'However, in ASCII, the letter `A` is the number `65`, so we will remove this
    offset from `key_value` and then add it back once we have the modulus value. The
    following code ensures that we limit the ASCII values to be between `A` and `Z`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ASCII 中，字母 `A` 是数字 `65`，因此我们将从 `key_value` 中减去这个偏移量，然后在得到模数值后将其加回。以下代码确保我们将
    ASCII 值限制在 `A` 和 `Z` 之间：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Essentially, if the value is not between the values for `A` or `Z`, then we
    will allow the value to wrap around (by calculating the modulus using the total
    number of letters between `A` and `Z`, which is `26`). This also works if the
    key is larger than `26` and if we are counting the opposite way too, for instance,
    if the encryption key was negative, and therefore, the decryption key positive.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果值不在 `A` 或 `Z` 的值之间，我们将允许值通过（通过使用 `A` 和 `Z` 之间字母的总数计算模数，即 `26`）。这也适用于密钥大于
    `26` 的情况，或者我们在相反方向计数时，例如，如果加密密钥是负数，那么解密密钥就是正数。
- en: Finally, we can convert `key_value` back into a letter by using the `chr()`
    and `str()` functions and adding it to the result string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过使用 `chr()` 和 `str()` 函数将 `key_value` 转换回字母，并将其添加到结果字符串中。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use `\` to split the code into another line, it doesn't affect
    the calculation. Python can be very fussy about splitting lines, in some cases
    you can find a natural break in the code and separate the line with a carriage
    return, however other times we have to force a line break using the `\` symbol.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `\` 来将代码拆分到另一行，这不会影响计算。Python 对换行非常挑剔，在某些情况下，你可以在代码中找到一个自然的断点，并用回车换行符分隔行，然而在其他时候，我们必须使用
    `\` 符号强制换行。
- en: Of course, given very little time, such a simple encryption method could easily
    be broken. Remember that there are only 25 possible combinations to choose from
    before the result of the encryption is repeated (multiples of 26 will result in
    no encryption at all).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在很短的时间内，这种简单的加密方法很容易被破解。记住，在加密结果重复之前，只有 25 种可能的组合可以选择（26 的倍数将导致没有任何加密）。
- en: There's more…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can try this simple experiment. Currently, with this basic form of encryption,
    you will supply the method and key to anyone you wish to read your message. However,
    what happens if you want to send a secure transmission without sending the method
    and key?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试这个简单的实验。目前，使用这种基本的加密形式，你将向任何你想阅读你信息的人提供方法和密钥。然而，如果你想在不发送方法和密钥的情况下发送安全的传输会发生什么呢？
- en: 'The answer is to send the same message back and forth three times as demonstrated
    in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是发送相同的信息往返三次，如下面的图示所示：
- en: '![There''s more…](img/6623OT_02_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/6623OT_02_06.jpg)'
- en: We do not need to exchange encryption keys with the other person
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要与其他人交换加密密钥
- en: The first time, we will encrypt it and send it over to the other party. They
    will then encrypt it again with their own encryption and send it back. The message
    at this stage has two layers of encryption applied to it. We can now remove our
    encryption and return it. Finally, they will receive the message with just their
    encryption, which they can remove and read the message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们将对其进行加密并发送给另一方。然后他们将以自己的加密方式再次加密并发送回来。此时，信息已经应用了两层加密。我们现在可以移除我们的加密并返回。最后，他们将只收到他们的加密信息，他们可以移除并阅读信息。
- en: Just remember that there are only 25 useful encryption combinations with the
    Caesar cipher, so it is possible that they could decrypt the message by accident.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，凯撒密码只有25种有用的加密组合，因此他们可能意外地解密了信息。
- en: 'We can make use of our previous file as a module using the `import` command
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前的文件作为模块，通过以下`import`命令使用：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will allow access to any function inside the `encryptdecrypt` file using
    `ENC` as the reference. When such a file is imported, it will run any code that
    would normally be run; in this case, the `main()` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许使用`ENC`作为参考，访问`encryptdecrypt`文件中的任何函数。当导入此类文件时，它将运行通常会被运行的任何代码；在这种情况下，`main()`函数。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid this, we can change the call to `main()` only to occur when the file
    is run directly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以只将`main()`函数的调用改为在文件直接运行时发生。
- en: 'If the file is run directly, Python will set `__name__` to the `"__main__"`
    global attribute. By using the following code, we can reuse the functions in this
    Python script in other scripts without running any other code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件直接运行，Python将`__name__`设置为`"__main__"`全局属性。通过使用以下代码，我们可以在其他脚本中重用此Python脚本中的函数，而无需运行任何其他代码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the `keypassing.py` script using the following code in the same directory
    as `encryptdecrypt.py`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`encryptdecrypt.py`相同的目录下创建`keypassing.py`脚本，使用以下代码：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On running the preceding script, we can see that the other person doesn''t
    need to know the encryption key that we are using, and anyone who intercepts the
    message will not be able to see its contents. The script produces the following
    output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的脚本时，我们可以看到，其他人不需要知道我们使用的加密密钥，任何拦截信息的人都将无法看到其内容。该脚本产生以下输出：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is known as the **three-pass protocol**, developed by Adi Shamir
    in 1980 ([http://en.wikipedia.org/wiki/Three-pass_protocol](http://en.wikipedia.org/wiki/Three-pass_protocol)).
    One particular disadvantage of this method is that it is possible for a third
    party to intercept the messages (the so-called man-in-the-middle attack) and characterize
    the encryption method by inserting known values and analyzing the responses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为**三次传递协议**，由Adi Shamir于1980年开发（[http://en.wikipedia.org/wiki/Three-pass_protocol](http://en.wikipedia.org/wiki/Three-pass_protocol)）。这种方法的一个特定缺点是，第三方可能拦截信息（所谓的中间人攻击）并通过插入已知值和分析响应来识别加密方法。
- en: Using files and handling errors
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件和处理错误
- en: In addition to easy string handling, Python allows you to read, edit, and create
    files easily. So, by building upon the previous scripts, we can make use of our
    `encryptText()` function to encode complete files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了易于字符串处理外，Python还允许你轻松地读取、编辑和创建文件。因此，通过在先前的脚本上构建，我们可以利用我们的`encryptText()`函数来编码完整的文件。
- en: Reading and writing to files can be quite dependent on factors that are outside
    of the direct control of the script, such as whether the file that we are trying
    to open exists or the filesystem has space to store a new file. Therefore, we
    will also take a look at how to handle exceptions and protect operations that
    may result in errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件可能非常依赖于脚本直接控制之外的因素，例如我们试图打开的文件是否存在或文件系统是否有空间存储新文件。因此，我们还将探讨如何处理异常并保护可能产生错误的操作。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following script will allow you to specify a file through the command line,
    which will be read and encoded to produce an output file. Create a small text
    file named `infile.txt` and save it so that we can test the script. It should
    include a short message similar to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将允许你通过命令行指定一个文件，该文件将被读取并编码以生成输出文件。创建一个名为`infile.txt`的小文本文件并保存它，以便我们可以测试脚本。它应包含类似于以下的消息：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the `fileencrypt.py` script using the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建`fileencrypt.py`脚本：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run the script, use the following command (here, `infile` can be any text
    file we want to encrypt, `outfile` is our encrypted version, and `key` is the
    key value we wish to use):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，请使用以下命令（在这里，`infile`可以是任何我们想要加密的文本文件，`outfile`是我们的加密版本，`key`是我们希望使用的密钥值）：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, to encrypt `infile.txt` and output it as `encrypted.txt` using
    `30` as the key, use the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用`30`作为密钥加密`infile.txt`并输出为`encrypted.txt`，请使用以下命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To view the result, use `less encrypted.txt`. Press *Q* to exit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，使用`less encrypted.txt`。按*Q*键退出。
- en: 'To decrypt `encrypted.txt` and output it as `decrypted.txt` using `-30` as
    the key, use the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`-30`作为密钥解密`encrypted.txt`并输出为`decrypted.txt`，请使用以下命令：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To view the result, use `less decrypted.txt`. Press *Q* to exit.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，使用`less decrypted.txt`。按*Q*键退出。
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The script requires us to use arguments that are provided on the command line.
    We will access them by importing the Python module called `sys`. Just like we
    did earlier, we will also import our `encryptdecrypt` module using the `import`
    command. We will use the `as` part to allow us to reference it using `ENC`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本要求我们使用命令行提供的参数。我们将通过导入名为`sys`的Python模块来访问它们。就像我们之前做的那样，我们也将使用`import`命令导入我们的`encryptdecrypt`模块。我们将使用`as`部分来允许我们使用`ENC`来引用它。
- en: 'Next, we will set values to define what each command-line argument will represent.
    When you run it, you will see that `sys.argv[]` is a list of values shown in the
    following array:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置值来定义每个命令行参数将代表什么。当你运行它时，你会看到`sys.argv[]`是一个值列表，如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, the input file is at the index `1` in the list (indexing always starts at
    0), then the output file, and finally, the key, with the total number of arguments
    being `ARG_LENGTH=4`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输入文件在列表中的索引是`1`（索引始终从0开始），然后是输出文件，最后是密钥，参数总数为`ARG_LENGTH=4`。
- en: Next, we will define the `convertFile()` function, which we will call in a minute
    from the next block of code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`convertFile()`函数，我们将在下一块代码中调用它。
- en: To avoid errors, we will check whether the length of the `sys.argv` value matches
    the expected number of arguments from the command line. This will ensure that
    the user has supplied us with enough, and we don't try to reference items in the
    `sys.argv[]` list that don't exist. Otherwise, we will return a short message
    explaining what we are expecting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，我们将检查`sys.argv`值的长度是否与命令行期望的参数数量相匹配。这将确保用户已经提供了足够的参数，我们不会尝试引用`sys.argv[]`列表中不存在的项。否则，我们将返回一条简短的消息，解释我们期望的内容。
- en: We will now call the `convertFile()` function using the command-line values
    and making use of Python's built-in exception handling features to ensure that
    errors are responded to accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用命令行值调用`convertFile()`函数，并利用Python内置的异常处理功能来确保错误得到相应的响应。
- en: The `try…except` code allows you to try running some code and handle any exceptions
    (errors) within the program itself, rather than everything coming to a sudden
    stop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`try…except`代码允许你尝试运行一些代码，并在程序内部处理任何异常（错误），而不是让一切突然停止。'
- en: 'The `try` code is accompanied by the following four optional sections:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`代码伴随着以下四个可选部分：'
- en: '`except ValueError:` – When an error occurs, a specific type of exception can
    be specified and handled with the action, depending on the error we wish to handle
    (that is, for `ValueError`, we could check whether the value is a float value
    and convert it to an integer or prompt for a new one). Multiple exceptions can
    be caught using `except (ValueError,IOError)` as required.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except ValueError:` – 当发生错误时，可以指定并处理特定类型的异常，具体取决于我们希望处理的错误（即，对于`ValueError`，我们可以检查值是否为浮点值并将其转换为整数，或者提示输入新的值）。根据需要，可以使用`except
    (ValueError, IOError)`捕获多个异常。'
- en: '`except:` – This is a catch-all case where any other exceptions that we haven''t
    handled can be dealt with. For situations where the code may be called from other
    places, we may also want to raise the exception again using the `raise` command
    so that it can be dealt with by other parts of the program (for instance, as part
    of the GUI, we can warn the user that the input was not correct without needing
    to do so at this stage). Typically, you should either deal with a specific exception
    or ensure that you raise it again so that the particular error is visible on a
    failure; if not handled at all, Python will report it on the terminal along with
    the trace to the function where it occurred.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except:` – 这是一个通用的捕获情况，其中我们可以处理我们尚未处理的任何其他异常。对于可能从其他地方调用的代码，我们可能还希望使用`raise`命令再次引发异常，以便其他程序部分可以处理它（例如，作为GUI的一部分，我们可以警告用户输入不正确，而无需在此阶段这样做）。通常，你应该处理特定的异常或确保再次引发它，以便特定的错误在失败时可见；如果根本未处理，Python将在终端上报告它，并附带发生错误的函数的跟踪信息。'
- en: '`else:` – This section of code is always executed if the `try` code was successful
    and there was no exception raised; however, any errors in this code will not be
    handled by the `try…except` section it is part of.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else:` – 如果`try`代码成功且没有引发异常，则始终执行此代码段；然而，此代码中的任何错误都不会由它所属的`try…except`部分处理。'
- en: '`finally:` – This code is always executed, regardless of whether an exception
    was raised or the `try` code ran without problems.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally:` – 无论是否引发异常或`try`代码运行无问题，此代码总是执行。'
- en: If you are familiar with other languages, you will find `try…except` similar
    to `try…catch`, and `raise` and `throw` as equivalents. Dealing with exceptions
    can be quite an art form; however, making your code able to handle problems gracefully
    and effectively is all part of good design. In many cases, catching the situations
    where things go wrong is just as important as performing the intended function
    successfully.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他语言，你会发现`try…except`类似于`try…catch`，`raise`和`throw`是等效的。处理异常可以是一种相当的艺术形式；然而，使你的代码能够优雅有效地处理问题是良好设计的一部分。在许多情况下，捕捉出错的情况与成功执行预期功能一样重要。
- en: If there is no problem with converting the `key` argument into an integer, we
    will continue to open the input file specified and read the contents into the
    `infile_content` list. This will contain the contents of the file split into separate
    lines as a list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`key`参数转换为整数没有问题，我们将继续打开指定的输入文件，并将内容读取到`infile_content`列表中。这将包含文件内容，按单独的行分割成列表。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we will use a slightly different method to display values within
    the `print` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用一种稍微不同的方法在`print`语句中显示值。
- en: 'Consider the following code as an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码作为示例：
- en: 'print ("Error: The key %s should be an integer value!" %(key))'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: print ("错误：键%s应该是整数值！"%key)
- en: This allows us to use the `%s` symbol to determine where the key value is printed
    and also to specify the format (`%s` is a string). For numerical values, such
    as floats and integers, we can use `%d` to display integers, `%f` for floats,
    or even `%.4f` to limit the value to four decimal places.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用`%s`符号来确定键值打印的位置，也可以指定格式（`%s`是一个字符串）。对于数值，如浮点数和整数，我们可以使用`%d`显示整数，`%f`用于浮点数，甚至`%.4f`将值限制为四位小数。
- en: 'You may have noticed that we opened the file using the `with…as…:` section.
    This is a special way to open a file, which will ensure that it is closed once
    it has finished (even if there is an error). Refer to the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用`with…as…:`部分打开了文件。这是一种特殊的打开文件方式，它将确保文件完成操作后关闭（即使有错误）。请参考以下代码：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is equivalent to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If there is an exception in opening the file (if it doesn't exist, for example,
    it will raise `IOError`), we can flag to the user that there was a problem with
    the filename/path provided. We will also use `except:` on its own to deal with
    any other problems that we may have with the file, such as the encoding type or
    non-text based files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在打开文件时出现异常（例如，如果文件不存在，它将引发`IOError`），我们可以向用户标记提供的文件名/路径存在问题。我们还将使用`except:`单独处理可能遇到的任何其他问题，例如编码类型或非文本文件。
- en: Next, we will open a file for our output using `'w'` to open it as a writable
    file. If it doesn't exist, it will create a new file; otherwise, it will overwrite
    the file. We will also have the option to append to the file instead, using `'a'`.
    We will step through each item in `infile_content`, converting each line by passing
    it through our `ENC.encryptText()` function and writing the line to the `f_out`
    file. Once again, when we finish the `with…as…:` section, the file is closed and
    the conversion is complete.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`'w'`模式打开一个文件作为可写文件进行输出。如果文件不存在，它将创建一个新文件；否则，它将覆盖文件。我们还将有使用`'a'`模式追加到文件的选择。我们将逐项遍历`infile_content`中的每个项目，通过传递它通过我们的`ENC.encryptText()`函数并将行写入`f_out`文件来转换每一行。再次强调，当我们完成`with…as…:`部分时，文件将被关闭，转换完成。
- en: Creating a boot-up menu
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建启动菜单
- en: We will now apply the methods introduced in the previous scripts and reapply
    them to create a menu that we can customize to present a range of quick-to-run
    commands and programs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将应用之前脚本中介绍的方法，并将它们重新应用于创建一个我们可以自定义以展示一系列快速运行的命令和程序的菜单。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create the `menu.py` script using the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建`menu.py`脚本：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a `menu.ini` file that will contain the following menu items and commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下菜单项和命令的`menu.ini`文件：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can add your own commands to the list, creating your own custom start-up
    menu. The script will assume the `menu.ini` file is formatted correctly, so if
    you experience an error (for example `ErrorIndex`) it may be because the file
    is not as expected (such as missing commas or blank lines). We could use `except
    ErrorIndex:` to handle any errors, however we are better off highlighting there
    is a problem within the input file so that it can be fixed instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向列表中添加自己的命令，创建自己的自定义启动菜单。脚本将假设`menu.ini`文件格式正确，因此如果您遇到错误（例如`ErrorIndex`），那可能是因为文件不符合预期（例如缺少逗号或空白行）。我们可以使用`except
    ErrorIndex:`来处理任何错误，但我们最好突出显示输入文件中存在问题，以便可以修复。
- en: How it works…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to execute other programs from within a Python script, we need to use
    the `call` command. This time, we only wish to use the `call` part of the `subprocess`
    module, so we can simply use `from subprocess import call`. This just imports
    the part we need.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python脚本中执行其他程序，我们需要使用`call`命令。这次，我们只想使用`subprocess`模块的`call`部分，因此我们可以简单地使用`from
    subprocess import call`。这仅仅导入了我们需要的部分。
- en: 'We will open the file and read all the lines into a `menufile` list. We can
    then process each item (or line of the file) using `item.split('','')`, which
    will create a new list consisting of each section of the line divided by the `'',''`
    symbol, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开文件并将所有行读入一个`menufile`列表。然后我们可以使用`item.split(',')`处理每个项目（或文件的每一行），这将创建一个新的列表，该列表由`','`符号分隔的行的各个部分组成，如下所示：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown by the `print` statement, we can now access each section independently,
    so we can print the key we need to press for a specific command and the description
    of the command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如`print`语句所示，我们现在可以独立访问每个部分，因此我们可以打印出执行特定命令所需按下的键以及命令的描述。
- en: 'Once we have printed the entire menu of commands, we will wait for the user''s
    input. This is done inside a `while` loop; it will continue to run until we set
    the condition inside `running` to `False`. This means that if an invalid key is
    pressed, we can enter another key until a command is selected or the exit item
    is used. We will then check the input key to see if it matches the allocated key
    for the menu item, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打印出整个命令菜单，我们将等待用户输入。这是在`while`循环中完成的；它将继续运行，直到我们将`running`内部的条件设置为`False`。这意味着如果按下了无效的键，我们可以输入另一个键，直到选择了一个命令或使用了退出项。然后我们将检查输入键是否与菜单项分配的键匹配，如下所示：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If there is a match, we will extract the command we wish to call. The `call`
    command requires a command and its arguments to be a list, so we will use `.split()`
    to break up the command part into a list (where each space in the command is a
    new item in the list). Also note that there is `/n` after `startx`, this is the
    end of the line character from the `menu.ini` file. We will remove this first
    using `.rstrip()`, which removes any whitespace (spaces, tabs, or line endings)
    from the end of a string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有匹配项，我们将提取我们希望调用的命令。`call`命令要求命令及其参数是一个列表，因此我们将使用`.split()`将命令部分拆分成一个列表（其中命令中的每个空格都是列表中的新项）。此外，请注意`startx`之后有`/n`，这是来自`menu.ini`文件的行结束符。我们将首先使用`.rstrip()`移除它，该函数会从字符串的末尾移除任何空白（空格、制表符或换行符）。
- en: 'Once the command is formatted into a list of arguments, we will set `running`
    to `False` (so the `while` loop will not enter another loop), execute our command,
    and finish the script. If the user selects `x`, there will be no `commands` set,
    allowing us to exit the menu without calling anything. The script produces a small
    menu of options, as shown in the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令被格式化为参数列表，我们将设置 `running` 为 `False`（这样 `while` 循环就不会进入另一个循环），执行我们的命令，并完成脚本。如果用户选择
    `x`，则不会有 `commands` 设置，这样我们就可以在未调用任何内容的情况下退出菜单。脚本会生成一个包含选项的小菜单，如下所示：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: To make the script run each time, we will start the Raspberry Pi; we can call
    it from `.bash_profile`, which is a bash script that runs when the user's profile
    is loaded.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让脚本每次都能运行，我们将启动树莓派；我们可以从 `.bash_profile` 中调用它，这是一个在用户配置文件加载时运行的 bash 脚本。
- en: 'Create or edit the file as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式创建或编辑文件：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following commands (assuming `menu.py` is located in the `/home/pi/python_scripts`
    directory):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下命令（假设 `menu.py` 位于 `/home/pi/python_scripts` 目录中）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When done, save and exit (*Ctrl* + *X*, *Y*, and *Enter*).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，保存并退出（*Ctrl* + *X*，*Y*，和 *Enter*）。
- en: The next time you power up your Raspberry Pi, you will have a menu to run your
    favorite commands from, without needing to remember them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下次您启动树莓派时，您将有一个菜单可以从中运行您喜欢的命令，而无需记住它们。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also run Python scripts directly, without the `python3` command, making
    them executable, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接运行 Python 脚本，而不需要 `python3` 命令，使它们可执行，如下所示：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now type `./menu.py` and the script will run using the program defined within
    the file by the first line, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入 `./menu.py`，脚本将使用文件第一行定义的程序运行，如下所示：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating a self-defining menu
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义菜单
- en: While the previous menu is very useful for defining the most common commands
    and functions we may use when running the Raspberry Pi, we will often change what
    we are doing or develop scripts to automate complex tasks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的菜单对于定义我们在运行树莓派时可能使用的最常见命令和功能非常有用，但我们会经常改变我们正在做的事情或开发脚本来自动化复杂任务。
- en: 'To avoid the need to continuously update and edit the `menu.ini` file, we can
    create a menu that can list the installed scripts and dynamically build a menu
    from it, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要不断更新和编辑 `menu.ini` 文件，我们可以创建一个可以列出已安装脚本并从其中动态构建菜单的菜单，如下面的截图所示：
- en: '![Creating a self-defining menu](img/6623OT_02_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个自定义菜单](img/6623OT_02_07.jpg)'
- en: A menu of all the Python scripts in the current directory
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录中所有 Python 脚本的菜单
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create the `menuadv.py` script using the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建 `menuadv.py` 脚本：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This script allows us to take a different approach. Rather than predefining
    a list of commands or applications, we can simply keep a folder of useful scripts
    and scan it to create a list to pick from. In this case, the menu will just list
    Python scripts and call them without any command-line options.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本允许我们采取不同的方法。而不是预先定义命令或应用程序的列表，我们只需保留一个有用的脚本文件夹，并扫描它以创建一个可供选择的列表。在这种情况下，菜单将只列出
    Python 脚本，并调用它们而不带任何命令行选项。
- en: To be able to access the list of files in a directory, we can use the `os` module's
    `os.listdir()` function. This function allows us to specify a directory and it
    will return a list of the files and directories within it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问目录中的文件列表，我们可以使用 `os` 模块的 `os.listdir()` 函数。此函数允许我们指定一个目录，它将返回该目录中文件和目录的列表。
- en: Using `SCRIPT_DIR="."` will allow us to search the current directory (the one
    the script is being run from). We can specify an absolute path (that is, `"//home/pi/python_scripts"`),
    a relative path (that is, `"./python_scripts_subdirectory"`), or navigate from
    the current directory to others in the structure (that is, `"../more_scripts"`,
    where the `..` symbol will move up a level from the current directory and then
    into the `more_scripts` directory if it existed).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SCRIPT_DIR="."` 将允许我们在当前目录（即脚本运行的目录）中搜索。我们可以指定一个绝对路径（即 `"//home/pi/python_scripts"`），一个相对路径（即
    `"./python_scripts_subdirectory"`），或者从当前目录导航到结构中的其他目录（即 `"../more_scripts"`，其中
    `..` 符号将从当前目录向上移动一个级别，然后进入 `more_scripts` 目录，如果它存在的话）。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the directory does not exist, an exception (`OSError`) will be raised. Since
    this menu is intended to simply run and display the list, we are better off letting
    the exception cause an error and stop the script. This will encourage the user
    to fix the directory rather than try to handle the error (perhaps by prompting
    for another path each time). It will also be easier for the user to locate and
    correct the path when the script isn't running.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录不存在，将会抛出一个异常（`OSError`）。由于这个菜单的目的是简单地运行并显示列表，我们最好让异常引发错误并停止脚本。这将鼓励用户修复目录而不是尝试处理错误（例如，每次都提示输入另一个路径）。当脚本不运行时，用户也更容易找到并纠正路径。
- en: We will also get the name of the script using `os.path.basename(__file__)`,
    this allows us to later exclude the `menuadv.py` script from the list options.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`os.path.basename(__file__)`获取脚本的名称，这允许我们稍后从列表选项中排除`menuadv.py`脚本。
- en: We will create an empty `scripts` list and ensure that we initialize `item_num`
    to `1`. Now, we will call `os.listdir(SCRIPT_DIR)` directly within a `for…in`
    loop so that we can process each directory or filename returned by it. Next, we
    can check the end of each item using the `endswith()` function (another useful
    string function), which allows us to look for a specific ending to the string
    (in this case, the ending for Python scripts). At this point, we can also exclude
    the `menuadv.py` script from the list, if found.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个空的`scripts`列表，并确保将`item_num`初始化为`1`。现在，我们将在`for…in`循环中直接调用`os.listdir(SCRIPT_DIR)`，这样我们就可以处理它返回的每个目录或文件名。接下来，我们可以使用`endswith()`函数（另一个有用的字符串函数）检查每个项目的末尾，这允许我们查找字符串的特定结尾（在这种情况下，Python脚本的结尾）。在这个阶段，如果找到，我们还可以从列表中排除`menuadv.py`脚本。
- en: We print the name of the script along with `item_num` and add it to the script
    list, finally incrementing `item_num` so that it is correct for the next item.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将脚本的名称与`item_num`一起打印出来，并将其添加到脚本列表中，最后递增`item_num`以确保它对下一个项目是正确的。
- en: We will now prompt the user to enter the relevant script number (between `1`
    and the total number of scripts) and wait for the user input from `input()`. The
    script will check for a valid input. If it is a number, it will stay in the `try`
    section, and we can then check whether the number is in the correct range (one
    of the listed script numbers). If correct, the script is called using `['python3',
    'scriptname.py']` and the `call()` function as before. If the input is not a number
    (for example, `x`), it will raise the `ValueError` exception. Within the `ValueError`
    exception, we can check whether `x` was pressed and exit the `while` loop by setting
    `running` to `False` (otherwise, the loop will reprint the prompt and wait for
    new input).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将提示用户输入相关的脚本编号（介于`1`和脚本总数之间），并等待用户通过`input()`输入。脚本将检查输入是否有效。如果是数字，它将停留在`try`部分，然后我们可以检查该数字是否在正确的范围内（列表中的脚本编号之一）。如果正确，脚本将使用`['python3',
    'scriptname.py']`和之前的`call()`函数调用。如果输入不是数字（例如，`x`），它将引发`ValueError`异常。在`ValueError`异常中，我们可以检查是否按下了`x`并通过将`running`设置为`False`退出`while`循环（否则，循环将重新打印提示并等待新输入）。
- en: The script is now complete.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已完成。
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can adjust the preceding script to support other types of scripts, if required.
    Simply add other file extensions, such as `.sh`, to the scripts list and call
    using `sh` or `bash` instead of `python3`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以调整前面的脚本以支持其他类型的脚本。只需将其他文件扩展名，如`.sh`，添加到脚本列表中，并使用`sh`或`bash`而不是`python3`来调用。
- en: There's more…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: We can extend this example further by placing all our useful scripts in a single
    place and adding the `menu` script to the path.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将所有有用的脚本放在一个地方并将`menu`脚本添加到路径中来进一步扩展这个例子。
- en: Alternative script locations
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代脚本位置
- en: 'While not entirely necessary (by default, the script will look in the current
    directory), it will be useful to create a suitable location to keep your scripts
    that you would like to use with the menu. This can be a location within your `home`
    folder (`~` is short for the `home` folder path, which is `/home/pi` by default).
    An example is shown in the following command line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并非完全必要（默认情况下，脚本将在当前目录中查找），但创建一个合适的位置来保存您希望与菜单一起使用的脚本将很有用。这可以是在您的`home`文件夹中的一个位置（`~`是`home`文件夹路径的缩写，默认情况下是`/home/pi`）。以下是一个示例命令行：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To copy files, you can use `cp sourcefile targetfile`. If you use the `-r` option,
    it will also create the directory if it doesn't exist. To move or rename the files,
    use `mv sourcefile targetfile`. To delete the files, use `rm targetfile`. You
    must use the `-r` option to delete a directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件，你可以使用 `cp sourcefile targetfile` 命令。如果你使用 `-r` 选项，如果目录不存在，它也会创建该目录。要移动或重命名文件，请使用
    `mv sourcefile targetfile` 命令。要删除文件，请使用 `rm targetfile` 命令。你必须使用 `-r` 选项来删除目录。
- en: Just ensure that if the script is not within the same location, the path is
    updated for `SCRIPT_DIR` to refer to the required location.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保如果脚本不在同一位置，更新 `SCRIPT_DIR` 的路径以指向所需的位置。
- en: Adding scripts to PATH
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将脚本添加到 PATH
- en: As before, we could add this script to a start-up file, such as `.bash_profile`,
    and have the menu appear when the user logs in to the Raspberry Pi. Alternatively,
    we can place such scripts into a folder such as `/home/pi/bin`, in which we can
    include the global value call `PATH`. The `PATH` settings are a list of directories
    that scripts and programs will check when trying to locate a file that isn't in
    the current directory (typically, installed programs and software, but also common
    configuration files and scripts).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将此脚本添加到启动文件，例如 `.bash_profile`，以便用户登录到 Raspberry Pi 时出现菜单。或者，我们可以将这些脚本放入如
    `/home/pi/bin` 这样的文件夹中，我们可以在其中包含全局值调用 `PATH`。`PATH` 设置是一系列目录，当脚本和程序尝试定位不在当前目录中的文件时（通常是已安装的程序和软件，但也包括常见的配置文件和脚本）会检查这些目录。
- en: This will allow us to run the script regardless of what directory we are currently
    in.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们无论当前在哪个目录下都能运行脚本。
- en: 'We can see the current `PATH` settings using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看当前的 `PATH` 设置：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The actual contents of the `PATH` setting will depend on the initial settings
    of the distribution you are using and also on the applications you have installed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 设置的实际内容将取决于你使用的发行版的初始设置，以及你安装的应用程序。'
- en: 'If `/home/pi/bin` isn''t included, we can temporarily add to this until the
    next boot with the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `/home/pi/bin` 没有包含在内，我们可以使用以下命令临时添加，直到下一次启动：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also add this to `.bash_profile` to set it every time for the current
    user, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其添加到 `.bash_profile` 中，为当前用户每次设置，如下所示：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next time we reboot, the `PATH` settings will be (for a user with the name
    `pi`) as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们重启时，`PATH` 设置将如下所示（对于名为 `pi` 的用户）：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When items are automatically located through `PATH`, it can be difficult to
    find a specific version of a file or program. To overcome this, use `whereis`
    before the filename/command, and it will list all the locations where it can be
    found.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目通过 `PATH` 自动定位时，可能很难找到特定版本的一个文件或程序。为了克服这个问题，在文件名/命令前使用 `whereis`，它将列出所有可以找到的位置。
- en: Finally, if you do move the script to the `bin` directory, ensure that you update
    the path in `os.listdir("//home/pi/bin")` to locate and list the scripts you wish
    to display in the menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你确实将脚本移动到 `bin` 目录，请确保更新 `os.listdir("//home/pi/bin")` 中的路径，以便定位和列出你希望在菜单中显示的脚本。
